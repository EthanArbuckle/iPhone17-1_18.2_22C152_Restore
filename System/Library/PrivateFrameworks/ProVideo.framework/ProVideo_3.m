uint64_t TXSequenceParams::getNumObjects(TXSequenceParams *this, const CMTime *a2)
{
  unsigned int *v3;
  uint64_t (*v4)(unsigned int *);
  uint64_t result;
  char *StringPtr;
  uint64_t vars8;

  v3 = *(unsigned int **)(*(void *)this + 27704);
  switch(OZChannel::getValueAsInt((OZChannel *)((char *)this + 1256), MEMORY[0x1E4F1FA48], 0.0))
  {
    case 0u:
    case 4u:
      goto LABEL_7;
    case 1u:
      v4 = *(uint64_t (**)(unsigned int *))(*(void *)v3 + 224);
      return v4(v3);
    case 2u:
      return v3[4831];
    case 3u:
      if (!OZChannel::getValueAsInt((OZChannel *)((char *)this + 1968), MEMORY[0x1E4F1FA48], 0.0)) {
        goto LABEL_10;
      }
LABEL_7:
      StringPtr = TXChannelString::getStringPtr((TXChannelString *)(v3 + 4762));
      result = (uint64_t)PCString::size((PCString *)StringPtr);
      break;
    default:
LABEL_10:
      result = 1;
      break;
  }
  return result;
}

double TXSequenceParams::getStart(TXSequenceParams *this, CMTime *a2)
{
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 1256), a2, 0.0) != 4) {
    return 0.0;
  }

  OZChannel::getValueAsDouble((OZChannel *)((char *)this + 1512), a2, 0.0);
  return result;
}

void TXSequenceParams::getEnd(TXSequenceParams *this, CMTime *a2)
{
  unsigned int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 1256), a2, 0.0);
  if (ValueAsInt >= 3)
  {
    if (ValueAsInt == 4)
    {
      OZChannel::getValueAsDouble((OZChannel *)((char *)this + 1664), a2, 0.0);
    }
  }
  else
  {
    CMTime v5 = *a2;
    TXSequenceParams::getSpan(this, &v5);
  }
}

double TXSequenceParams::getSpan(TXSequenceParams *this, CMTime *a2)
{
  v2 = *(_DWORD **)(*(void *)this + 27704);
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 1256), a2, 0.0);
  double v4 = 1.0;
  switch(ValueAsInt)
  {
    case 0:
    case 3:
    case 4:
      StringPtr = TXChannelString::getStringPtr((TXChannelString *)(v2 + 4762));
      unsigned int v6 = PCString::size((PCString *)StringPtr);
      goto LABEL_4;
    case 1:
      unsigned int v6 = (*(uint64_t (**)(_DWORD *, double))(*(void *)v2 + 224))(v2, 1.0);
LABEL_4:
      double v4 = (double)v6;
      break;
    case 2:
      LODWORD(v4) = v2[4831];
      double v4 = (double)*(unint64_t *)&v4;
      break;
    default:
      return 1.0 / v4;
  }
  return 1.0 / v4;
}

uint64_t TXSequenceParams::shuffle(TXSequenceParams *this, const CMTime *a2, Float64 a3)
{
  uint64_t result = TXSequenceParams::getNumObjects(this, a2);
  if (result)
  {
    int v7 = result;
    int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 848), MEMORY[0x1E4F1FA48], 0.0);
    if (*((_DWORD *)this + 558) != v7 || ValueAsInt != *((_DWORD *)this + 559))
    {
      uint64_t v9 = *((void *)this + 278);
      if (v9)
      {
        MEMORY[0x1BA9BFB70](v9, 0x1000C8052888210);
        *((void *)this + 278) = 0;
      }
      operator new[]();
    }
    uint64_t v10 = *((void *)this + 278);
    return *(unsigned int *)(v10 + 4
                                 * TXSequenceParams::charIndexToSelectionIndex(this, (uint64_t)a2, a3));
  }
  return result;
}

uint64_t TXSequenceParams::charIndexToSelectionIndex(TXSequenceParams *this, uint64_t a2, Float64 a3)
{
  memset(&v11, 0, sizeof(v11));
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)this + 336))(*(void *)this);
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v6 + 336), (__n128 *)&v10);
  operator*(&v10, &v11, a3);
  int v7 = *(TXTextLayout **)(*(void *)this + 27704);
  switch(OZChannel::getValueAsInt((OZChannel *)((char *)this + 1256), &v11, 0.0))
  {
    case 0u:
    case 4u:
      return a2;
    case 1u:
      uint64_t LineIndex = (*(uint64_t (**)(TXTextLayout *, uint64_t))(*(void *)v7 + 720))(v7, a2);
      goto LABEL_5;
    case 2u:
      uint64_t LineIndex = TXTextLayout::getLineIndex(v7, a2);
LABEL_5:
      a2 = LineIndex;
      break;
    case 3u:
      if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 1968), MEMORY[0x1E4F1FA48], 0.0)) {
        a2 = a2;
      }
      else {
        a2 = 0;
      }
      break;
    default:
      a2 = 0;
      break;
  }
  return a2;
}

double TXSequenceParams::normalizeIndex(TXSequenceParams *this, unsigned int a2, Float64 a3)
{
  memset(&v15, 0, sizeof(v15));
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)this + 336))(*(void *)this);
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v6 + 336), (__n128 *)&v14);
  operator*(&v14, &v15, a3);
  int v7 = *(_DWORD **)(*(void *)this + 27704);
  double v8 = 0.0;
  switch(OZChannel::getValueAsInt((OZChannel *)((char *)this + 1256), &v15, 0.0))
  {
    case 0u:
    case 3u:
    case 4u:
      double v9 = (double)a2 + 0.5;
      StringPtr = TXChannelString::getStringPtr((TXChannelString *)(v7 + 4762));
      unsigned int v11 = PCString::size((PCString *)StringPtr);
      goto LABEL_6;
    case 1u:
      double v9 = (double)a2 + 0.5;
      unsigned int v11 = (*(uint64_t (**)(_DWORD *))(*(void *)v7 + 224))(v7);
LABEL_6:
      double v8 = v9 / (double)v11;
      break;
    case 2u:
      int v12 = v7[4831];
      double v8 = (double)a2;
      if (v12 != 1) {
        double v8 = (v8 + 0.5) / (double)v12;
      }
      break;
    default:
      return v8;
  }
  return v8;
}

void TXTextSequenceBehavior::getKeyframeExtent(TXTextSequenceBehavior *this, double *a2, double *a3)
{
  uint64_t v3 = *((void *)this + 69);
  uint64_t v4 = *((void *)this + 68);
  if (v3 == v4)
  {
    *a2 = 0.0;
    *a3 = 0.0;
  }
  else
  {
    char v5 = 0;
    double v6 = 0.0;
    double v7 = 0.0;
    do
    {
      double v8 = *(const void **)v4;
      if ((*(void *)(*(void *)v4 + 56) & 0x1000) != 0)
      {
        v29 = 0;
        v30 = 0;
        uint64_t v31 = 0;
        OZChannelFolder::getAllDescendantsFlattened((uint64_t)v14, (void **)&v29, 0, 0);
        v16 = v29;
        CMTime v15 = v30;
        if (v29 != v30)
        {
          do
          {
            if (*v16) {
            else
            }
              v17 = 0;
            OZChannel::getKeyframeMinTime(v17, (uint64_t)&v28);
            CMTime v33 = v28;
            OZChannel::getKeyframeMaxTime(v17, (uint64_t)&v28);
            CMTime v32 = v28;
            CMTime v27 = v33;
            double Seconds = CMTimeGetSeconds(&v27);
            CMTime v26 = v32;
            double v19 = CMTimeGetSeconds(&v26);
            if (v7 <= Seconds) {
              double v20 = v7;
            }
            else {
              double v20 = Seconds;
            }
            if (v6 >= v19) {
              double v21 = v6;
            }
            else {
              double v21 = v19;
            }
            if (v5) {
              double v7 = v20;
            }
            else {
              double v7 = Seconds;
            }
            if (v5) {
              double v6 = v21;
            }
            else {
              double v6 = v19;
            }
            ++v16;
            char v5 = 1;
          }
          while (v16 != v15);
          v16 = v29;
        }
        if (v16)
        {
          v30 = v16;
          operator delete(v16);
        }
      }
      else
      {
        OZChannel::getKeyframeMinTime(v9, (uint64_t)&v33);
        OZChannel::getKeyframeMaxTime(v9, (uint64_t)&v32);
        CMTime time = v33;
        double v10 = CMTimeGetSeconds(&time);
        CMTime v24 = v32;
        double v11 = CMTimeGetSeconds(&v24);
        if (v7 <= v10) {
          double v12 = v7;
        }
        else {
          double v12 = v10;
        }
        if (v6 >= v11) {
          double v13 = v6;
        }
        else {
          double v13 = v11;
        }
        if (v5) {
          double v7 = v12;
        }
        else {
          double v7 = v10;
        }
        if (v5) {
          double v6 = v13;
        }
        else {
          double v6 = v11;
        }
        char v5 = 1;
      }
      v4 += 8;
    }
    while (v4 != v3);
    *a2 = v7;
    *a3 = v6;
  }
}

void sub_1B76779B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void TXTextSequenceBehavior::TXTextSequenceBehavior(TXTextSequenceBehavior *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  TXTextBehavior::TXTextBehavior(this, a2, a3, a4);
  *(void *)uint64_t v5 = &unk_1F10C0ED8;
  *(void *)(v5 + 16) = &unk_1F10C1190;
  *(void *)(v5 + 48) = &unk_1F10C13E8;
  *(void *)(v5 + 336) = &unk_1F10C1440;
  double v6 = (OZChannelFolder *)(v5 + 56);
  TXSequenceChannels::TXSequenceChannels((TXSequenceChannels *)(v5 + 536), (OZChannelFolder *)(v5 + 56), 0xCAu);
  *(_OWORD *)((char *)this + 27704) = 0u;
  TXSequenceParams::TXSequenceParams((TXTextSequenceBehavior *)((char *)this + 27720), v6, 0xC9u, this);
}

void sub_1B7677AC8(_Unwind_Exception *a1)
{
  TXSequenceChannels::~TXSequenceChannels(v2);
  TXTextBehavior::~TXTextBehavior(v1);
  _Unwind_Resume(a1);
}

void TXTextSequenceBehavior::TXTextSequenceBehavior(TXTextSequenceBehavior *this, const TXTextSequenceBehavior *a2, char a3)
{
  TXTextBehavior::TXTextBehavior(this, a2, a3);
  *(void *)uint64_t v5 = &unk_1F10C0ED8;
  *(void *)(v5 + 16) = &unk_1F10C1190;
  *(void *)(v5 + 48) = &unk_1F10C13E8;
  *(void *)(v5 + 336) = &unk_1F10C1440;
  double v6 = (OZChannelFolder *)(v5 + 56);
  TXSequenceChannels::TXSequenceChannels((TXSequenceChannels *)(v5 + 536), (const TXTextSequenceBehavior *)((char *)a2 + 536), (OZChannelFolder *)(v5 + 56));
  *((void *)this + 3463) = *((void *)a2 + 3463);
  *((void *)this + 3464) = 0;
  TXSequenceParams::TXSequenceParams((TXTextSequenceBehavior *)((char *)this + 27720), (const TXTextSequenceBehavior *)((char *)a2 + 27720), v6, this);
}

void sub_1B7677BDC(_Unwind_Exception *a1)
{
  TXSequenceChannels::~TXSequenceChannels(v2);
  TXTextBehavior::~TXTextBehavior(v1);
  _Unwind_Resume(a1);
}

void TXTextSequenceBehavior::~TXTextSequenceBehavior(TXTextSequenceBehavior *this)
{
  *(void *)this = &unk_1F10C0ED8;
  *((void *)this + 2) = &unk_1F10C1190;
  *((void *)this + 6) = &unk_1F10C13E8;
  *((void *)this + 42) = &unk_1F10C1440;
  TXSequenceParams::~TXSequenceParams((TXTextSequenceBehavior *)((char *)this + 27720));
  TXSequenceChannels::~TXSequenceChannels((TXTextSequenceBehavior *)((char *)this + 536));

  TXTextBehavior::~TXTextBehavior(this);
}

{
  uint64_t vars8;

  TXTextSequenceBehavior::~TXTextSequenceBehavior(this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'TXTextSequenceBehavior::~TXTextSequenceBehavior(TXTextSequenceBehavior *this)
{
}

{
  TXTextSequenceBehavior::~TXTextSequenceBehavior((TXTextSequenceBehavior *)((char *)this - 48));
}

{
  TXTextSequenceBehavior::~TXTextSequenceBehavior((TXTextSequenceBehavior *)((char *)this - 336));
}

{
  uint64_t vars8;

  TXTextSequenceBehavior::~TXTextSequenceBehavior((TXTextSequenceBehavior *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  TXTextSequenceBehavior::~TXTextSequenceBehavior((TXTextSequenceBehavior *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  TXTextSequenceBehavior::~TXTextSequenceBehavior((TXTextSequenceBehavior *)((char *)this - 336));

  JUMPOUT(0x1BA9BFBA0);
}

__n128 TXTextSequenceBehavior::operator=(uint64_t a1, const void *a2)
{
  TXTextBehavior::operator=();
  if (!v4) {
    __cxa_bad_cast();
  }
  uint64_t v5 = v4;
  TXSequenceChannels::operator=(a1 + 536, (uint64_t)(v4 + 536));
  *(void *)(a1 + 27720) = *((void *)v5 + 3465);
  OZChannelFolder::operator=(a1 + 27728);
  OZChannelBase::operator=(a1 + 27856, (uint64_t)(v5 + 27856));
  OZChannelBase::operator=(a1 + 28112, (uint64_t)(v5 + 28112));
  OZChannelBase::operator=(a1 + 28264, (uint64_t)(v5 + 28264));
  OZChannelBase::operator=(a1 + 28416, (uint64_t)(v5 + 28416));
  OZChannelBase::operator=(a1 + 28568, (uint64_t)(v5 + 28568));
  OZChannelBase::operator=(a1 + 28720, (uint64_t)(v5 + 28720));
  OZChannelBase::operator=(a1 + 28976, (uint64_t)(v5 + 28976));
  OZChannelBase::operator=(a1 + 29232, (uint64_t)(v5 + 29232));
  OZChannelBase::operator=(a1 + 29384, (uint64_t)(v5 + 29384));
  OZChannelBase::operator=(a1 + 29536, (uint64_t)(v5 + 29536));
  OZChannelBase::operator=(a1 + 29688, (uint64_t)(v5 + 29688));
  __n128 result = *(__n128 *)(v5 + 29944);
  *(__n128 *)(a1 + 29944) = result;
  *(void *)(a1 + 27720) = a1;
  return result;
}

OZChannelBehavior *TXTextSequenceBehavior::didAddToNode(OZChannelBehavior *this, OZSceneNode *lpsrc)
{
  if (lpsrc)
  {
    uint64_t v3 = this;
    if (this)
    {
      *((void *)v3 + 3463) = this;
      OZChannelBehavior::didAddToNode(v3, lpsrc);
      return (OZChannelBehavior *)TXTextSequenceBehavior::sequenceBehaviorDidLoad(v3);
    }
  }
  return this;
}

uint64_t TXTextSequenceBehavior::sequenceBehaviorDidLoad(TXTextSequenceBehavior *this)
{
  if (!*((void *)this + 3464)) {
    operator new();
  }
  uint64_t result = TXSequenceChannels::removeTrackingChannel((TXTextSequenceBehavior *)((char *)this + 536), 1045);
  uint64_t v3 = (OZChannelBase **)*((void *)this + 68);
  for (i = (OZChannelBase **)*((void *)this + 69); v3 != i; ++v3)
  {
    uint64_t v5 = *v3;
    if (((*v3)->var7 & 0x1000) != 0)
    {
      double v6 = *(OZChannelBase ****)(result + 112);
      double v7 = *v6;
      double v8 = v6[1];
      while (v7 != v8)
      {
        double v9 = *v7;
        uint64_t result = OZChannelBase::testFlag(*v7, 2);
        if ((result & 1) == 0) {
          uint64_t result = (uint64_t)TXTextSequenceBehavior::addChannel(this, v9);
        }
        ++v7;
      }
    }
    else
    {
      uint64_t result = OZChannelBase::testFlag(*v3, 2);
      if ((result & 1) == 0) {
        uint64_t result = (uint64_t)TXTextSequenceBehavior::addChannel(this, v5);
      }
    }
  }
  return result;
}

void sub_1B7678164(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C409AC7BE1CLL);
  _Unwind_Resume(a1);
}

OZChannelFolder *TXTextSequenceBehavior::addChannel(TXTextSequenceBehavior *this, OZChannelBase *a2)
{
  OZChannelBase::resetFlag(a2, 2, 0);
  var6 = a2->var6;
  if (var6) {
    OZChannelBase::resetFlag((OZChannelBase *)var6, 2, 0);
  }
  Channel = (OZChannelBase *)TXSequenceChannels::findChannel((TXSequenceChannels *)(*((void *)this + 3463) + 25032), a2->var3, 0, 0);

  return TXTextSequenceBehavior::addSequenceNodes(this, a2, Channel);
}

void TXTextSequenceBehavior::willRemove(TXTextSequenceBehavior *this)
{
  OZChannel::deleteCurveProcessingNode((OZChannel *)(*((void *)this + 3463) + 24880), *((void **)this + 3464));
  uint64_t v10 = *((void *)this + 3464);
  std::list<OZBehaviorCurveNode *>::remove((uint64_t)this + 344, &v10);
  uint64_t v2 = *((void *)this + 3463);
  uint64_t v3 = *(OZChannelBase ***)(v2 + 25040);
  for (i = *(OZChannelBase ***)(v2 + 25048); v3 != i; ++v3)
  {
    uint64_t v5 = *v3;
    if (((*v3)->var7 & 0x1000) != 0)
    {
      double v7 = *v6;
      double v8 = v6[1];
      while (v7 != v8)
      {
        double v9 = *v7++;
        TXTextSequenceBehavior::removeChannel(this, v9);
      }
    }
    else
    {
      TXTextSequenceBehavior::removeChannel(this, v5);
    }
  }
  OZChannelBehavior::clearChannels(this);
  OZChannelBehavior::willRemove(this);
}

char *TXTextSequenceBehavior::removeChannel(TXTextSequenceBehavior *this, OZChannelBase *a2)
{
  OZChannelBase::setFlag(a2, 2, 0);
  var6 = a2->var6;
  if (var6)
  {
    uint64_t v5 = (OZChannelBase ***)*((void *)var6 + 14);
    double v6 = *v5;
    double v7 = v5[1];
    while (v6 != v7)
    {
      if (!OZChannelBase::testFlag(*v6, 2)) {
        goto LABEL_7;
      }
      ++v6;
    }
    OZChannelBase::setFlag((OZChannelBase *)var6, 2, 0);
  }
LABEL_7:
  if ((a2->var7 & 0x1000) != 0)
  {
    double v9 = (OZChannelBase ***)*((void *)result + 14);
    if (v9)
    {
      uint64_t v10 = *v9;
      double v11 = v9[1];
      while (v10 != v11)
      {
        double v12 = *v10++;
        uint64_t result = TXTextSequenceBehavior::removeCurveNodes((char *)this, v12);
      }
    }
  }
  else
  {
    return TXTextSequenceBehavior::removeCurveNodes((char *)this, a2);
  }
  return result;
}

OZChannelFolder *TXTextSequenceBehavior::addSequenceNodes(TXTextSequenceBehavior *this, OZChannelBase *a2, OZChannelBase *a3)
{
  if ((a2->var7 & 0x1000) != 0)
  {
    double v9 = (OZChannelBase ***)v7[14];
    uint64_t v10 = (OZChannelBase ***)v8[14];
    if (v9) {
      BOOL v11 = v10 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11)
    {
      double v12 = *v9;
      if (*v9 != v9[1])
      {
        double v13 = *v10;
        do
        {
          if (v13 == v10[1]) {
            break;
          }
          CMTime v15 = *v12++;
          CMTime v14 = v15;
          v16 = *v13++;
          TXTextSequenceBehavior::addSequenceNodes(this, v14, v16);
        }
        while (v12 != v9[1]);
      }
    }
  }
  else
  {
    if (!a3
    {
      operator new();
    }
  }
  (*((void (**)(OZChannelBase *, uint64_t, void))a2->var0 + 13))(a2, 1, 0);
  var6 = a2->var6;
  if (var6) {
    (*(void (**)(OZChannelFolder *, uint64_t, void))(*(void *)var6 + 104))(var6, 1, 0);
  }
  (*((void (**)(OZChannelBase *, uint64_t, void))a3->var0 + 13))(a3, 1, 0);
  uint64_t result = a3->var6;
  if (result)
  {
    double v19 = *(uint64_t (**)(void))(*(void *)result + 104);
    return (OZChannelFolder *)v19();
  }
  return result;
}

void sub_1B7678778(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40F7988963);
  _Unwind_Resume(a1);
}

char *TXTextSequenceBehavior::removeCurveNodes(char *this, OZChannelBase *a2)
{
  uint64_t v2 = (uint64_t)(this + 344);
  uint64_t v3 = (char *)*((void *)this + 44);
  if (v3 != this + 344)
  {
    var6 = a2->var6;
    do
    {
      uint64_t v5 = v3 + 8;
      uint64_t v3 = (char *)*((void *)v3 + 1);
      this = (char *)v5[1];
      if (this)
      {
        if (this)
        {
          double v6 = this;
          double v7 = (OZChannel *)*((void *)this + 2);
          if (a2->var3 == v7->var3 && (!var6 || (double v8 = v7->var6) == 0 || *((_DWORD *)var6 + 6) == *((_DWORD *)v8 + 6)))
          {
            OZChannel::deleteCurveProcessingNode(*((OZChannel **)this + 2), this);
            v16 = v6;
            std::list<OZBehaviorCurveNode *>::remove(v2, &v16);
            int NumberOfCurveProcessingNodes = OZChannel::getNumberOfCurveProcessingNodes(v7);
            if (!NumberOfCurveProcessingNodes) {
              (*((void (**)(OZChannel *, void, void))v7->var0 + 13))(v7, 0, 0);
            }
            uint64_t v10 = v7->var6;
            this = (char *)(*(uint64_t (**)(OZChannelFolder *))(*(void *)v10 + 120))(v10);
            if (!this) {
              goto LABEL_15;
            }
            if (!NumberOfCurveProcessingNodes) {
              this = (char *)(*(uint64_t (**)(OZChannelFolder *, void, void))(*(void *)v10 + 104))(v10, 0, 0);
            }
            uint64_t v10 = (OZChannelFolder *)*((void *)v10 + 6);
            if (v10)
            {
LABEL_15:
              BOOL v11 = (const void ***)*((void *)v10 + 14);
              double v12 = *v11;
              double v13 = v11[1];
              while (v12 != v13)
              {
                if (*v12)
                {
                  if (v14)
                  {
                    this = (char *)OZChannel::getNumberOfCurveProcessingNodes(v14);
                    if (this) {
                      goto LABEL_22;
                    }
                  }
                }
                ++v12;
              }
              this = (char *)(*(uint64_t (**)(OZChannelFolder *, void, void))(*(void *)v10 + 104))(v10, 0, 0);
            }
          }
        }
      }
LABEL_22:
      ;
    }
    while (v3 != (char *)v2);
  }
  return this;
}

double TXTextSequenceBehavior::calcHashForState(uint64_t a1, void *a2, CMTime *a3, uint64_t **a4)
{
  OZBehavior::calcHashForState(a1, a2, a3, a4);
  if (!v5) {
    __cxa_bad_cast();
  }
  double v6 = v5;
  __n128 v9 = *(__n128 *)PCHashWriteStream::getHash(v5)->i8;
  (*(void (**)(void *))(*(void *)a2 + 40))(a2);
  Hash = PCHashWriteStream::getHash(v6);
  PCHash128::operator+=((int *)&v9, (int *)Hash);
  *(void *)&double result = PCHashWriteStream::setHash((__n128 *)v6, &v9).n128_u64[0];
  return result;
}

double non-virtual thunk to'TXTextSequenceBehavior::calcHashForState(uint64_t a1, void *a2, CMTime *a3, uint64_t **a4)
{
  return TXTextSequenceBehavior::calcHashForState(a1 - 16, a2, a3, a4);
}

uint64_t TXTextSequenceBehavior::getPreviewSceneNode(TXTextSequenceBehavior *this)
{
  PCSharedCount::PCSharedCount(&v7);
  NextUniqueID = (const PCString *)OZChannelBase::getNextUniqueID(v1);
  uint64_t v3 = (TXTextLayout *)TXTextInput::create((TXTextInput *)&v7, NextUniqueID);
  PCString::~PCString((PCString *)&v7);
  uint64_t v4 = (CMTime *)MEMORY[0x1E4F1FA48];
  long long v9 = *MEMORY[0x1E4F1FA48];
  uint64_t v10 = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  PCURL::PCURL((PCURL *)&v7, @"Text Behavior Preview Text");
  (*(void (**)(TXTextLayout *, long long *, PCSharedCount *))(*(void *)v3 + 144))(v3, &v9, &v7);
  PCString::~PCString((PCString *)&v7);
  TXTextLayout::didFinishInitializing(v3, 1);
  TXTextLayout::getCurrentStyleForInsertion((uint64_t)v3, &v7);
  if (v7.var0)
  {
    CMTime v6 = *v4;
    OZChannel::setValue((OZChannel *)v7.var0 + 13, &v6, 16.0, 0);
  }
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  return (uint64_t)v3 + 200;
}

void sub_1B7678BE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, PCString a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TXTextSequenceBehavior::parseEnd(TXTextSequenceBehavior *this, PCSerializerReadStream *a2)
{
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 27856), MEMORY[0x1E4F1FA48], 0.0);
  if (*((_DWORD *)a2 + 26) == 1 && ValueAsInt == 1)
  {
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 28264), MEMORY[0x1E4F1FA48], 0.0);
    OZChannel::setDefaultValue((OZChannel *)((char *)this + 28264), v6 * 0.5);
    (*(void (**)(char *, void))(*((void *)this + 3533) + 288))((char *)this + 28264, 0);
  }
  if (((*(uint64_t (**)(char *, uint64_t))(*((void *)this + 308) + 496))((char *)this + 2464, 1) & 1) == 0
    && ((*(uint64_t (**)(char *, uint64_t))(*((void *)this + 327) + 496))((char *)this + 2616, 1) & 1) == 0
    && ((*(uint64_t (**)(char *, uint64_t))(*((void *)this + 346) + 496))((char *)this + 2768, 1) & 1) == 0)
  {
    OZChannelBase::operator=((uint64_t)this + 2768, (uint64_t)this + 3184);
    OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2768), 2, 1);
    if (OZChannelBase::testFlag((OZChannelBase *)((char *)this + 3184), 2)) {
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 2328), 2, 1);
    }
    else {
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2328), 2, 1);
    }
  }
  unsigned int v7 = *((_DWORD *)a2 + 26);
  if (v7 <= 2)
  {
    OZChannel::scaleChannel((OZChannel *)((char *)this + 5824), 2.0);
    OZChannel::scaleChannel((OZChannel *)((char *)this + 10656), 2.0);
    OZChannel::scaleChannel((OZChannel *)((char *)this + 15896), 2.0);
    OZChannel::scaleChannel((OZChannel *)((char *)this + 22280), 2.0);
    unsigned int v7 = *((_DWORD *)a2 + 26);
  }
  if (v7 <= 3)
  {
    copy1DBlurChannelTo2DBlurChannel((OZChannelBase *)this + 52, (TXTextSequenceBehavior *)((char *)this + 5384));
    copy1DBlurChannelTo2DBlurChannel((OZChannelBase *)((char *)this + 10656), (TXTextSequenceBehavior *)((char *)this + 10216));
    copy1DBlurChannelTo2DBlurChannel((OZChannelBase *)((char *)this + 15896), (TXTextSequenceBehavior *)((char *)this + 15456));
    copy1DBlurChannelTo2DBlurChannel((OZChannelBase *)((char *)this + 22280), (TXTextSequenceBehavior *)((char *)this + 21840));
  }

  return OZBehavior::parseEnd(this, a2);
}

OZChannelBase *copy1DBlurChannelTo2DBlurChannel(OZChannelBase *a1, OZChannel2D *a2)
{
  uint64_t v4 = (OZChannelBase *)((char *)a2 + 136);
  OZChannelBase::operator=((uint64_t)a2 + 136, (uint64_t)a1);
  OZChannelBase::operator=((uint64_t)a2 + 288, (uint64_t)a1);
  OZChannelBase::resetFlag(v4, 8, 1);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)a2 + 288), 8, 1);
  OZChannelBase::resetFlag((OZChannelBase *)a2, 2, 1);
  OZChannelBase::resetFlag((OZChannelBase *)a2, 8, 1);
  if (OZChannelBase::testFlag(a1, 2)) {
    OZChannelBase::setFlag((OZChannelBase *)a2, 2, 1);
  }
  else {
    OZChannelBase::resetFlag((OZChannelBase *)a2, 2, 1);
  }

  return OZChannelBase::setFlag(a1, 0x400000, 1);
}

uint64_t non-virtual thunk to'TXTextSequenceBehavior::parseEnd(TXTextSequenceBehavior *this, PCSerializerReadStream *a2)
{
  return TXTextSequenceBehavior::parseEnd((TXTextSequenceBehavior *)((char *)this - 48), a2);
}

BOOL TXTextSequenceBehavior::isChannelEnabled(TXTextSequenceBehavior *this, int a2)
{
  Channel = (OZChannelBase *)TXSequenceChannels::findChannel((TXTextSequenceBehavior *)((char *)this + 536), a2, 0, 0);
  return !OZChannelBase::testFlag(Channel, 2);
}

void TXChannelFont::TXChannelFont(TXChannelFont *this, OZFactory *a2, const PCString *a3, OZChannelFolder *a4, unsigned int a5, int a6)
{
  OZChannelFontBase::OZChannelFontBase(this, a2, a3, a4, a5, a6);
  *(void *)unsigned int v7 = &unk_1F10C14B0;
  *((void *)v7 + 2) = &unk_1F10C1820;
  Instance = (OZFontManagerBase *)TXFontManager::getInstance(v7);
  OZFontManagerBase::getDefaultSystemFont(&v9);
  OZChannelFontBase::init((PCString *)this, Instance, &v9);
  OZChannelBase::setParameterCtlrClassName((OZChannelBase *)this, @"TXFontController");
  PCString::~PCString(&v9);
}

void sub_1B767905C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelFontBase::~OZChannelFontBase(v10);
  _Unwind_Resume(a1);
}

void TXChannelFont::TXChannelFont(TXChannelFont *this, const PCString *a2, OZChannelFolder *a3, unsigned int a4, int a5)
{
  Instance = (OZFactory *)TXChannelFont_Factory::getInstance(this);

  TXChannelFont::TXChannelFont(this, Instance, a2, a3, a4, a5);
}

void TXChannelFont::TXChannelFont(TXChannelFont *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
}

void TXChannelFont::TXChannelFont(TXChannelFont *this, const TXChannelFont *a2, OZChannelFolder *a3)
{
  OZChannelFontBase::OZChannelFontBase(this, a2, a3);
  v3->var0 = (void **)&unk_1F10C14B0;
  v3->var2 = (void **)&unk_1F10C1820;
  OZChannelBase::setParameterCtlrClassName(v3, @"TXFontController");
}

void sub_1B7679170(_Unwind_Exception *a1)
{
  OZChannelFontBase::~OZChannelFontBase(v1);
  _Unwind_Resume(a1);
}

__CFString *TXChannelFont::getObjCWrapperName(TXChannelFont *this)
{
  return @"CHChannelTextFont";
}

void TXChannelFont::clone(TXChannelFont *this)
{
}

void sub_1B76791E0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C404D384FFFLL);
  _Unwind_Resume(a1);
}

void TXChannelFont::reset(TXChannelFont *this, uint64_t a2)
{
  OZChannelBase::reset((OZChannelBase *)this, a2);
  ObjectManipulator = (OZObjectManipulator *)OZChannelBase::getObjectManipulator((OZChannelBase *)this);
  TXTextStylePtrFromObjectManipulator(ObjectManipulator, &v5);
  if (v5)
  {
    if (PCString::empty((PCString *)this + 82)) {
      (*(void (**)(PCString *__return_ptr, TXChannelFont *))(*(void *)this + 824))(&v4, this);
    }
    else {
      PCString::PCString(&v4, (const PCString *)this + 82);
    }
    (*(void (**)(uint64_t, PCString *, uint64_t))(*(void *)v5 + 168))(v5, &v4, 1);
    PCString::~PCString(&v4);
  }
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void sub_1B76792E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(a1);
}

void TXChannelFont::undoDidReplace(OZChannelFolder *this)
{
  OZChannelFolder::undoDidReplace(this);
  ObjectManipulator = (OZObjectManipulator *)OZChannelBase::getObjectManipulator((OZChannelBase *)this);
  TXTextStylePtrFromObjectManipulator(ObjectManipulator, &v3);
  if (v3) {
    TXTextStyle::clearCachedFontFace(v3);
  }
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void sub_1B767935C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void *TXChannelFont::didLoadFontName(OZChannelBase *this)
{
  double result = (void *)OZChannelBase::getObjectManipulator(this);
  if (result)
  {
    if (result)
    {
      uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 168);
      return (void *)v2();
    }
  }
  return result;
}

uint64_t TXChannelFont::getSystemFonts(TXChannelFont *this)
{
  return 0;
}

void TXChannelFont::getFontFace(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void TXChannelFont::getDefaultSystemFontFace(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void TXChannelFont::~TXChannelFont(PCString *this)
{
  OZChannelFontBase::~OZChannelFontBase(this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'TXChannelFont::~TXChannelFont(PCString *this)
{
}

{
  uint64_t vars8;

  OZChannelFontBase::~OZChannelFontBase(this - 2);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t HTextureBlend::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  Input = HGRenderer::GetInput(a2, this, 0);
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  uint64_t v13 = v12;
  CMTime v14 = HGRenderer::GetInput(a2, this, 1u);
  uint64_t v15 = HGRenderer::GetDOD(a2, v14);
  if (a3)
  {
    uint64_t v17 = DOD;
    uint64_t v18 = v13;
    uint64_t v19 = v6;
    uint64_t v20 = v5;
  }
  else
  {
    uint64_t v19 = v15;
    uint64_t v20 = v16;
    uint64_t v17 = v6;
    uint64_t v18 = v5;
  }
  return HGRectIntersection(v17, v18, v19, v20);
}

void HTextureBlend::~HTextureBlend(HGNode *this)
{
  HgcTXModulate::~HgcTXModulate(this);

  HGObject::operator delete(v1);
}

BOOL HGBitmap::cpu(HGBitmap *this)
{
  return (*((unsigned char *)this + 12) & 0x30) == 0;
}

BOOL HGBitmap::gpu(HGBitmap *this)
{
  return (*((unsigned char *)this + 12) & 0x30) != 0;
}

uint64_t HGBitmap::buffer(HGBitmap *this)
{
  return *((unsigned char *)this + 13) & 1;
}

uint64_t HGBitmap::texture(HGBitmap *this)
{
  return (*((unsigned __int8 *)this + 13) >> 1) & 1;
}

uint64_t std::__tree<PCHash128>::__count_unique<PCHash128>(uint64_t a1, const PCHash128 *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v4 = 1;
    do
    {
      if (!operator<(a2, (const PCHash128 *)((char *)v2 + 28)))
      {
        if (!operator<((const PCHash128 *)((char *)v2 + 28), a2)) {
          return v4;
        }
        ++v2;
      }
      uint64_t v2 = (void *)*v2;
    }
    while (v2);
  }
  return 0;
}

char *std::__tree<PCHash128>::__emplace_unique_key_args<PCHash128,PCHash128 const&>(uint64_t **a1, const PCHash128 *a2, _OWORD *a3)
{
  uint64_t v5 = (void **)std::__tree<PCHash128>::__find_equal<PCHash128>((uint64_t)a1, &v9, a2);
  uint64_t v6 = (char *)*v5;
  if (!*v5)
  {
    unsigned int v7 = (uint64_t **)v5;
    uint64_t v6 = (char *)operator new(0x30uLL);
    *(_OWORD *)(v6 + 28) = *a3;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v9, v7, (uint64_t *)v6);
  }
  return v6;
}

void *std::__tree<PCHash128>::__find_equal<PCHash128>(uint64_t a1, void *a2, const PCHash128 *a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        unsigned int v7 = v4;
        double v8 = (const PCHash128 *)((char *)v4 + 28);
        if (!operator<(a3, (const PCHash128 *)((char *)v4 + 28))) {
          break;
        }
        uint64_t v4 = (void *)*v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!operator<(v8, a3)) {
        break;
      }
      uint64_t v5 = v7 + 1;
      uint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    unsigned int v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

const char *HgcTXAlpha::GetProgram(HgcTXAlpha *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000236\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=5499c239:9891868e:bd9ea6d3:bd30d467\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000228\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=6eae314a:ee581af3:fdfce447:74b07bd6\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001f6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=78149511:5c47b7fc:9d3dfb0a:c601ba4b\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcTXAlpha::InitProgramDescriptor(HgcTXAlpha *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcTXAlpha_hgc_visible", "//Metal1.0     \n//LEN=00000000fc\n[[ visible ]] FragmentOut HgcTXAlpha_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcTXAlpha");
}

void sub_1B7679880(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 3OZChannelFontBase::~OZChannelFontBase(this - 2) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75770;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  CMTime v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7679980(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B76799C0()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B76799B8);
}

void *HgcTXAlpha::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcTXAlpha [hgc1]");
}

uint64_t HgcTXAlpha::BindTexture(HgcTXAlpha *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcTXAlpha::Bind(void *a1, uint64_t a2)
{
  return 0;
}

uint64_t HgcTXAlpha::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    uint64_t v5 = *(void *)(a2 + 16);
    uint64_t v6 = *(void *)(a2 + 80);
    uint64_t v7 = 16 * *(int *)(a2 + 88);
    uint64_t v8 = 16 * *(int *)(a2 + 24);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v16) = 0;
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = 32;
        do
        {
          float32x4_t v11 = *(float32x4_t *)*(void *)(a1 + 496);
          float32x4_t v12 = vmulq_f32(*(float32x4_t *)(v6 + v10 - 16), v11);
          float32x4_t v13 = vmulq_f32(*(float32x4_t *)(v6 + v10), v11);
          float32x4_t v14 = vmulq_f32(*(float32x4_t *)(v6 + v10 + 16), v11);
          uint64_t v15 = (float32x4_t *)(v5 + v10);
          v15[-2] = vmulq_f32(*(float32x4_t *)(v6 + v10 - 32), v11);
          v15[-1] = v12;
          *uint64_t v15 = v13;
          v15[1] = v14;
          v9 -= 4;
          v10 += 64;
        }
        while (v4 + v9 > 3);
        LODWORD(v16) = -v9;
      }
      if ((int)v16 < v4)
      {
        uint64_t v16 = v16;
        do
        {
          *(float32x4_t *)(v5 + 16 * v16) = vmulq_f32(*(float32x4_t *)(v6 + 16 * v16), *(float32x4_t *)*(void *)(a1 + 496));
          ++v16;
        }
        while (v16 < v4);
      }
      ++v3;
      v6 += v7;
      v5 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcTXAlpha::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

uint64_t HgcTXAlpha::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void HgcTXAlpha::HgcTXAlpha(HgcTXAlpha *this)
{
}

void sub_1B7679D44(_Unwind_Exception *a1)
{
  HGColorMatrix::~HGColorMatrix(v1);
  _Unwind_Resume(a1);
}

void HgcTXAlpha::~HgcTXAlpha(HgcTXAlpha *this)
{
  *(void *)this = &unk_1F10C1AF8;
  uint64_t v2 = *((void *)this + 62);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B8406A4ELL);
  }

  HGColorMatrix::~HGColorMatrix(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcTXAlpha::~HgcTXAlpha(this);

  HGObject::operator delete(v1);
}

uint64_t HgcTXAlpha::SetParameter(HgcTXAlpha *this, uint64_t a2, __n128 a3, float a4, float a5, double a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (__n128 *)*((void *)this + 62);
  if (v8->n128_f32[0] == *(float *)&a6
    && v8->n128_f32[1] == *(float *)&a6
    && v8->n128_f32[2] == *(float *)&a6
    && v8->n128_f32[3] == *(float *)&a6)
  {
    return 0;
  }
  a3.n128_f32[1] = a4;
  a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
  *(int32x4_t *)uint64_t v8 = vdupq_lane_s32(*(int32x2_t *)&a6, 0);
  v8[9] = a3;
  uint64_t v7 = 1;
  *((_DWORD *)this + 126) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return v7;
}

float HgcTXAlpha::GetParameter(HgcTXAlpha *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 62);
    *a3 = v3[36];
    a3[1] = v3[37];
    a3[2] = v3[38];
    float result = v3[39];
    a3[3] = result;
  }
  return result;
}

HGNode *HgcTXAlpha::GetOutput(__n128 *this, HGRenderer *a2, __n128 a3, __n128 a4, __n128 a5)
{
  if (this[31].n128_u32[2])
  {
    uint64_t v5 = (float32x4_t *)this[31].n128_u64[0];
    a4 = (__n128)vmulq_f32(v5[6], *v5);
    a5 = (__n128)vmulq_f32(v5[7], *v5);
    float32x4_t v6 = vmulq_f32(v5[8], *v5);
    v5[1] = vmulq_f32(v5[5], *v5);
    *(__n128 *)(this[31].n128_u64[0] + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = a4;
    *(__n128 *)(this[31].n128_u64[0] + 48) = a5;
    *(float32x4_t *)(this[31].n128_u64[0] + 64) = v6;
    uint64_t v7 = (__n128 *)this[31].n128_u64[0];
    this[27] = v7[1];
    this[28] = v7[2];
    this[29] = v7[3];
    a3 = v7[4];
    this[30] = a3;
    this[31].n128_u32[2] = 0;
  }
  return HGColorMatrix::GetOutput((HGColorMatrix *)this, a2, a3.n128_f64[0], a4.n128_f64[0], (int32x2_t)a5.n128_u64[0]);
}

const char *HgcTXPremulColor::GetProgram(HgcTXPremulColor *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000001b6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]])\n"
             "{\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0.w = hg_Params[0].w;\n"
             "    output.color0.xyz = hg_Params[0].xyz*hg_Params[0].www;\n"
             "    return output;\n"
             "}\n"
             "//MD5=a5c19c7c:730d39de:48b920fb:a280a93c\n"
             "//SIG=00400000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000001b6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]])\n"
             "{\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0.w = hg_Params[0].w;\n"
             "    output.color0.xyz = hg_Params[0].xyz*hg_Params[0].www;\n"
             "    return output;\n"
             "}\n"
             "//MD5=a5c19c7c:730d39de:48b920fb:a280a93c\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001a8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "void main()\n"
           "{\n"
           "\n"
           "    gl_FragColor.w = hg_ProgramLocal0.w;\n"
           "    gl_FragColor.xyz = hg_ProgramLocal0.xyz*hg_ProgramLocal0.www;\n"
           "}\n"
           "//MD5=6e3bf428:c715c4f4:d1d5c186:d5aa37ca\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
  }
}

void HgcTXPremulColor::InitProgramDescriptor(HgcTXPremulColor *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcTXPremulColor_hgc_visible", "//Metal1.0     \n//LEN=000000010b\n[[ visible ]] FragmentOut HgcTXPremulColor_hgc_visible(const constant float4* hg_Params)\n{\n    FragmentOut output;\n"
    "\n"
    "    output.color0.w = hg_Params[0].w;\n"
    "    output.color0.xyz = hg_Params[0].xyz*hg_Params[0].www;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcTXPremulColor");
}

void sub_1B767A03C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, long long a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  *(_DWORD *)(v31 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v31 - 56), "FragmentOut");
  *(_OWORD *)(v31 - 3OZChannelFontBase::~OZChannelFontBase(this - 2) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v30, v31 - 64);
  if (*(char *)(v31 - 33) < 0) {
    operator delete(*(void **)(v31 - 56));
  }
  memset(v36, 0, 24);
  LODWORD(v3OZChannelFontBase::~OZChannelFontBase(this - 2) = 2;
  std::string::basic_string[abi:ne180100]<0>(&v33, "float4");
  long long v35 = xmmword_1B7E75770;
  std::vector<HGBinding>::push_back[abi:ne180100](v36, (uint64_t)&v32);
  if (v34 < 0) {
    operator delete(v33);
  }
  HGProgramDescriptor::SetArgumentBindings(v30, v36);
  uint64_t v32 = (void **)v36;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v32);
}

void sub_1B767A0F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19)
{
  a10 = &a19;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  _Unwind_Resume(a1);
}

void sub_1B767A130()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B767A128);
}

void *HgcTXPremulColor::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcTXPremulColor [hgc1]");
}

uint64_t HgcTXPremulColor::BindTexture()
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcTXPremulColor::Bind(void *a1, uint64_t a2)
{
  return 0;
}

uint64_t HgcTXPremulColor::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    uint64_t v5 = *(int8x16_t **)(a2 + 16);
    float32x4_t v6 = v5 + 2;
    uint64_t v7 = 16 * *(int *)(a2 + 24);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v11) = 0;
      }
      else
      {
        int v8 = 0;
        int v9 = v6;
        do
        {
          int8x16_t v10 = vbslq_s8(*(int8x16_t *)(*(void *)(a1 + 408) + 16), *(int8x16_t *)*(void *)(a1 + 408), (int8x16_t)vmulq_laneq_f32(*(float32x4_t *)*(void *)(a1 + 408), *(float32x4_t *)*(void *)(a1 + 408), 3));
          v9[-2] = v10;
          v9[-1] = v10;
          *int v9 = v10;
          v9[1] = v10;
          v9 += 4;
          v8 -= 4;
        }
        while (v4 + v8 > 3);
        LODWORD(v11) = -v8;
      }
      if ((int)v11 < v4)
      {
        uint64_t v11 = v11;
        do
          v5[v11++] = vbslq_s8(*(int8x16_t *)(*(void *)(a1 + 408) + 16), *(int8x16_t *)*(void *)(a1 + 408), (int8x16_t)vmulq_laneq_f32(*(float32x4_t *)*(void *)(a1 + 408), *(float32x4_t *)*(void *)(a1 + 408), 3));
        while (v11 < v4);
      }
      ++v3;
      float32x4_t v6 = (int8x16_t *)((char *)v6 + v7);
      uint64_t v5 = (int8x16_t *)((char *)v5 + v7);
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcTXPremulColor::GetDOD(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = &HGRectInfinite;
  if (a3) {
    int v3 = &HGRectNull;
  }
  return *(void *)v3;
}

uint64_t HgcTXPremulColor::GetROI()
{
  return 0;
}

void HgcTXPremulColor::HgcTXPremulColor(HgcTXPremulColor *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10C1D70;
  operator new();
}

void sub_1B767A368(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcTXPremulColor::~HgcTXPremulColor(HGNode *this)
{
  *(void *)this = &unk_1F10C1D70;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcTXPremulColor::~HgcTXPremulColor(this);

  HGObject::operator delete(v1);
}

uint64_t HgcTXPremulColor::SetParameter(HgcTXPremulColor *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  int v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *int v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcTXPremulColor::GetParameter(HgcTXPremulColor *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcTXGlowMix::GetProgram(HgcTXGlowMix *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000029e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).w;\n"
             "    r0 = clamp(r0.wwww*half4(hg_Params[0]), 0.00000h, 1.00000h);\n"
             "    r0 = half4(hg_Params[1])*r0;\n"
             "    output.color0 = float4(r0)*float4(r0.wwww);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d13ab9e4:f9602b4c:6bdbf93d:fd6c672a\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0002:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000027b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).w;\n"
             "    r0 = clamp(r0.wwww*hg_Params[0], 0.00000f, 1.00000f);\n"
             "    r0 = hg_Params[1]*r0;\n"
             "    output.color0 = r0*r0.wwww;\n"
             "    return output;\n"
             "}\n"
             "//MD5=972021ef:6831d6bb:0c2f8c81:0f83b167\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0002:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000027f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.w = texture2D(hg_Texture0, hg_TexCoord0.xy).w;\n"
           "    r0 = clamp(r0.wwww*hg_ProgramLocal0, vec4(0.00000), vec4(1.00000));\n"
           "    r0 = hg_ProgramLocal1*r0;\n"
           "    gl_FragColor = r0*r0.wwww;\n"
           "}\n"
           "//MD5=1578383b:5660ee4d:6e591614:1a4b03c4\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0002:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcTXGlowMix::InitProgramDescriptor(HgcTXGlowMix *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcTXGlowMix_hgc_visible", "//Metal1.0     \n//LEN=0000000151\n[[ visible ]] FragmentOut HgcTXGlowMix_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.w = color0.w;\n"
    "    r0 = clamp(r0.wwww*hg_Params[0], 0.00000f, 1.00000f);\n"
    "    r0 = hg_Params[1]*r0;\n"
    "    output.color0 = r0*r0.wwww;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcTXGlowMix");
}

void sub_1B767A5D4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 3OZChannelFontBase::~OZChannelFontBase(this - 2) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75630;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  CMTime v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B767A6D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B767A714()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B767A70CLL);
}

void *HgcTXGlowMix::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcTXGlowMix [hgc1]");
}

uint64_t HgcTXGlowMix::BindTexture(HgcTXGlowMix *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcTXGlowMix::Bind(void *a1, uint64_t a2)
{
  return 0;
}

uint64_t HgcTXGlowMix::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    uint64_t v5 = *(void *)(a2 + 16);
    uint64_t v6 = *(void *)(a2 + 80);
    uint64_t v7 = 16 * *(int *)(a2 + 88);
    uint64_t v8 = 16 * *(int *)(a2 + 24);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v20) = 0;
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = 32;
        do
        {
          uint64_t v11 = *(float32x4_t **)(a1 + 408);
          float32x4_t v12 = v11[1];
          float32x4_t v13 = v11[2];
          float32x4_t v14 = v11[3];
          float32x4_t v15 = vmulq_f32(vminq_f32(vmaxq_f32(vmulq_laneq_f32(*v11, *(float32x4_t *)(v6 + v10 - 32), 3), v13), v14), v12);
          float32x4_t v16 = vmulq_f32(vminq_f32(vmaxq_f32(vmulq_laneq_f32(*v11, *(float32x4_t *)(v6 + v10 - 16), 3), v13), v14), v12);
          float32x4_t v17 = vmulq_f32(vminq_f32(vmaxq_f32(vmulq_laneq_f32(*v11, *(float32x4_t *)(v6 + v10), 3), v13), v14), v12);
          float32x4_t v18 = vmulq_f32(vminq_f32(vmaxq_f32(vmulq_laneq_f32(*v11, *(float32x4_t *)(v6 + v10 + 16), 3), v13), v14), v12);
          uint64_t v19 = (float32x4_t *)(v5 + v10);
          v19[-2] = vmulq_laneq_f32(v15, v15, 3);
          v19[-1] = vmulq_laneq_f32(v16, v16, 3);
          *uint64_t v19 = vmulq_laneq_f32(v17, v17, 3);
          v19[1] = vmulq_laneq_f32(v18, v18, 3);
          v9 -= 4;
          v10 += 64;
        }
        while (v4 + v9 > 3);
        LODWORD(v20) = -v9;
      }
      if ((int)v20 < v4)
      {
        uint64_t v20 = v20;
        do
        {
          float32x4_t v21 = vmulq_f32(vminq_f32(vmaxq_f32(vmulq_laneq_f32(*(float32x4_t *)*(void *)(a1 + 408), *(float32x4_t *)(v6 + 16 * v20), 3), *(float32x4_t *)(*(void *)(a1 + 408) + 32)), *(float32x4_t *)(*(void *)(a1 + 408) + 48)), *(float32x4_t *)(*(void *)(a1 + 408) + 16));
          *(float32x4_t *)(v5 + 16 * v20++) = vmulq_laneq_f32(v21, v21, 3);
        }
        while (v20 < v4);
      }
      ++v3;
      v6 += v7;
      v5 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcTXGlowMix::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

uint64_t HgcTXGlowMix::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void HgcTXGlowMix::HgcTXGlowMix(HgcTXGlowMix *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10C1FD8;
  operator new();
}

void sub_1B767AAFC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcTXGlowMix::~HgcTXGlowMix(HGNode *this)
{
  *(void *)this = &unk_1F10C1FD8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcTXGlowMix::~HgcTXGlowMix(this);

  HGObject::operator delete(v1);
}

uint64_t HgcTXGlowMix::SetParameter(HgcTXGlowMix *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  if (a2 == 1)
  {
    uint64_t v9 = *((void *)this + 51);
    if (*(float *)(v9 + 16) != a3.n128_f32[0]
      || *(float *)(v9 + 20) != a4
      || *(float *)(v9 + 24) != a5
      || *(float *)(v9 + 28) != a6)
    {
      *(_DWORD *)(v9 + 16) = a3.n128_u32[0];
      *(float *)(v9 + 20) = a4;
      *(float *)(v9 + 24) = a5;
      *(float *)(v9 + 28) = a6;
      goto LABEL_13;
    }
    return 0;
  }
  if (!a2)
  {
    uint64_t v7 = *((void *)this + 51);
    if (*(float *)v7 != a3.n128_f32[0]
      || *(float *)(v7 + 4) != a3.n128_f32[0]
      || *(float *)(v7 + 8) != a3.n128_f32[0]
      || *(float *)(v7 + 12) != a3.n128_f32[0])
    {
      int32x4_t v8 = vdupq_lane_s32((int32x2_t)a3.n128_u64[0], 0);
      a3.n128_f32[1] = a4;
      *(int32x4_t *)uint64_t v7 = v8;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      *(__n128 *)(v7 + 64) = a3;
LABEL_13:
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    }
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HgcTXGlowMix::GetParameter(HgcTXGlowMix *this, int a2, float *a3)
{
  if (a2 == 1)
  {
    uint64_t v5 = (float *)*((void *)this + 51);
    *a3 = v5[4];
    a3[1] = v5[5];
    a3[2] = v5[6];
    int v4 = v5 + 7;
    goto LABEL_5;
  }
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = v3[16];
    a3[1] = v3[17];
    a3[2] = v3[18];
    int v4 = v3 + 19;
LABEL_5:
    uint64_t result = 0;
    a3[3] = *v4;
    return result;
  }
  return 0xFFFFFFFFLL;
}

const char *HgcTXModulate::GetProgram(HgcTXModulate *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000307\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).w;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0.wwww*half4(hg_Params[0]);\n"
             "    output.color0 = float4(r1)*float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1d09d869:7cd955f7:353fc8a1:a9ec9d54\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002e4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).w;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = r0.wwww*hg_Params[0];\n"
             "    output.color0 = r1*r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=15c9e9d3:f22bf7b9:996454d7:a5632a63\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000028e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.w = texture2D(hg_Texture0, hg_TexCoord0.xy).w;\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = r0.wwww*hg_ProgramLocal0;\n"
           "    gl_FragColor = r1*r0;\n"
           "}\n"
           "//MD5=5eb97ec9:baab9bfc:5b1e2b66:f6a473a6\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcTXModulate::InitProgramDescriptor(HgcTXModulate *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcTXModulate_hgc_visible", "//Metal1.0     \n//LEN=0000000140\n[[ visible ]] FragmentOut HgcTXModulate_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.w = color0.w;\n"
    "    r1 = color1;\n"
    "    r0 = r0.wwww*hg_Params[0];\n"
    "    output.color0 = r1*r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcTXModulate");
}

void sub_1B767ADEC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 3OZChannelFontBase::~OZChannelFontBase(this - 2) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75770;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  CMTime v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B767AF2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B767AF74()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B767AF6CLL);
}

void *HgcTXModulate::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcTXModulate [hgc1]");
}

uint64_t HgcTXModulate::BindTexture(HgcTXModulate *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 1;
  }
  else
  {
    if (a3) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcTXModulate::Bind(void *a1, uint64_t a2)
{
  return 0;
}

uint64_t HgcTXModulate::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    uint64_t v5 = *(void *)(a2 + 16);
    uint64_t v6 = *(void *)(a2 + 96);
    uint64_t v7 = 16 * *(int *)(a2 + 88);
    uint64_t v8 = *(void *)(a2 + 80);
    uint64_t v9 = 16 * *(int *)(a2 + 104);
    uint64_t v10 = 16 * *(int *)(a2 + 24);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v18) = 0;
      }
      else
      {
        int v11 = 0;
        uint64_t v12 = 32;
        do
        {
          float32x4_t v13 = *(float32x4_t *)*(void *)(a1 + 408);
          float32x4_t v14 = vmulq_f32(*(float32x4_t *)(v6 + v12 - 16), vmulq_laneq_f32(v13, *(float32x4_t *)(v8 + v12 - 16), 3));
          float32x4_t v15 = vmulq_f32(*(float32x4_t *)(v6 + v12), vmulq_laneq_f32(v13, *(float32x4_t *)(v8 + v12), 3));
          float32x4_t v16 = vmulq_f32(*(float32x4_t *)(v6 + v12 + 16), vmulq_laneq_f32(v13, *(float32x4_t *)(v8 + v12 + 16), 3));
          float32x4_t v17 = (float32x4_t *)(v5 + v12);
          v17[-2] = vmulq_f32(*(float32x4_t *)(v6 + v12 - 32), vmulq_laneq_f32(v13, *(float32x4_t *)(v8 + v12 - 32), 3));
          v17[-1] = v14;
          float32x4_t *v17 = v15;
          v17[1] = v16;
          v11 -= 4;
          v12 += 64;
        }
        while (v4 + v11 > 3);
        LODWORD(v18) = -v11;
      }
      if ((int)v18 < v4)
      {
        uint64_t v18 = v18;
        do
        {
          *(float32x4_t *)(v5 + 16 * v18) = vmulq_f32(*(float32x4_t *)(v6 + 16 * v18), vmulq_laneq_f32(*(float32x4_t *)*(void *)(a1 + 408), *(float32x4_t *)(v8 + 16 * v18), 3));
          ++v18;
        }
        while (v18 < v4);
      }
      ++v3;
      v8 += v7;
      v6 += v9;
      v5 += v10;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcTXModulate::GetDOD(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return a4;
  }
}

uint64_t HgcTXModulate::GetROI(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return a4;
  }
}

void HgcTXModulate::HgcTXModulate(HgcTXModulate *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10C2240;
  operator new();
}

void sub_1B767B360(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcTXModulate::~HgcTXModulate(HGNode *this)
{
  *(void *)this = &unk_1F10C2240;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcTXModulate::~HgcTXModulate(this);

  HGObject::operator delete(v1);
}

uint64_t HgcTXModulate::SetParameter(HgcTXModulate *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcTXModulate::GetParameter(HgcTXModulate *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

NSString *PCReplaceUnsupportedXMLChars(NSString *a1, NSString *a2)
{
  uint64_t v2 = a1;
  if (a1 && [(NSString *)a1 length])
  {
    uint64_t v2 = (NSString *)[MEMORY[0x1E4F28E78] stringWithString:v2];
    uint64_t v5 = 0;
    objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28FD8], "regularExpressionWithPattern:options:error:", @"[\x00-\b]|\v|\f|[\x0E-\x1F]", 0, &v5), "replaceMatchesInString:options:range:withTemplate:", v2, 0, 0, -[NSString length](v2, "length"), a2);
  }
  return v2;
}

BOOL compareVertex(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)(a1 + 16);
  double v3 = *(double *)(a2 + 16);
  if (v2 > v3) {
    return 0;
  }
  if (v2 < v3) {
    return 1;
  }
  double v5 = *(double *)(a1 + 24);
  double v6 = *(double *)(a2 + 24);
  return v5 <= v6 && v5 < v6;
}

BOOL PCEdgeSegment::operator<(double *a1, double *a2)
{
  double v2 = a1[1];
  double v3 = a2[1];
  if (v2 > v3)
  {
    double v4 = a2[2];
    double v5 = a2[3] - v3;
    double v6 = v5 * (a1[2] - v4);
    double v7 = v2 - v3;
    double v8 = a2[4] - v4;
    double v9 = v7 * v8;
    if (vabdd_f64(v6, v9) < 0.0000001) {
      return v5 * (a1[4] - v4) - v8 * (a1[3] - v3) <= 0.0;
    }
    return v6 - v9 < 0.0;
  }
  double v11 = a1[2];
  double v12 = a1[3];
  double v13 = a2[2];
  double v14 = (v12 - v2) * (v13 - v11);
  double v15 = v3 - v2;
  double v16 = a1[4] - v11;
  double v17 = v15 * v16;
  if (vabdd_f64(v14, v17) >= 0.0000001)
  {
    double v19 = v14 - v17;
    return v19 > 0.0;
  }
  if (vabdd_f64(v2, v12) >= 0.0000001)
  {
    double v19 = (v12 - v2) * (a2[4] - v11) - v16 * (a2[3] - v2);
    return v19 > 0.0;
  }
  return v11 < v13;
}

uint64_t *PCVertexList::PCVertexList(uint64_t *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v3 = a2[1] - *a2;
  if (v3)
  {
    uint64_t v5 = 0;
    double v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = v3 >> 4;
    if ((unint64_t)(v3 >> 4) <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v3 >> 4;
    }
    do
    {
      long long v23 = 0u;
      long long v24 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      *(void *)&long long v22 = v7;
      uint64_t v10 = *a2;
      long long v23 = *(_OWORD *)(*a2 + v5);
      if (v7 + 1 == v8) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = v7 + 1;
      }
      long long v24 = *(_OWORD *)(v10 + 16 * v11);
      *(void *)&long long v19 = v7;
      long long v20 = *(_OWORD *)(v10 + 16 * v11);
      long long v21 = *(_OWORD *)(v10 + v5);
      if (*(double *)&v23 > *(double *)&v20
        || *(double *)&v23 >= *(double *)&v20 && *((double *)&v23 + 1) >= *((double *)&v20 + 1))
      {
        uint64_t v12 = 0;
        uint64_t v13 = 1;
      }
      else
      {
        uint64_t v13 = 0;
        uint64_t v12 = 1;
      }
      *((void *)&v22 + 1) = v13;
      *((void *)&v19 + 1) = v12;
      if ((unint64_t)v6 >= a1[2])
      {
        double v14 = (_OWORD *)std::vector<PCEdgeVertex>::__push_back_slow_path<PCEdgeVertex const&>(a1, &v22);
      }
      else
      {
        *double v6 = v22;
        v6[1] = v23;
        v6[2] = v24;
        double v14 = v6 + 3;
      }
      a1[1] = (uint64_t)v14;
      if ((unint64_t)v14 >= a1[2])
      {
        double v6 = (long long *)std::vector<PCEdgeVertex>::__push_back_slow_path<PCEdgeVertex const&>(a1, &v19);
      }
      else
      {
        *double v14 = v19;
        v14[1] = v20;
        v14[2] = v21;
        double v6 = v14 + 3;
      }
      a1[1] = (uint64_t)v6;
      v5 += 16;
      ++v7;
    }
    while (v7 != v9);
    double v15 = (long long *)*a1;
  }
  else
  {
    double v6 = 0;
    double v15 = 0;
  }
  unint64_t v16 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (v6 - v15));
  *(void *)&long long v22 = compareVertex;
  if (v6 == v15) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = v16;
  }
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*,false>(v15, v6, (unsigned int (**)(_OWORD *, long long *))&v22, v17, 1);
  return a1;
}

void sub_1B767B88C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t PCSweepline::PCSweepline(uint64_t a1, long long **a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if ((long long **)a1 != a2) {
    std::vector<PCVector2<double>>::__assign_with_size[abi:ne180100]<PCVector2<double>*,PCVector2<double>*>((void *)a1, *a2, a2[1], a2[1] - *a2);
  }
  return a1;
}

void sub_1B767B904(_Unwind_Exception *a1)
{
  PCBinaryTree<PCEdgeSegment>::~PCBinaryTree(v2);
  double v4 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

void PCSweepline::~PCSweepline(PCSweepline *this)
{
  PCBinaryTree<PCEdgeSegment>::~PCBinaryTree((uint64_t *)this + 3);
  double v2 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

uint64_t PCSweepline::addSegment(uint64_t a1, unint64_t *a2)
{
  long long v10 = 0u;
  float64x2_t v11 = 0u;
  unint64_t v9 = *a2;
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  float64x2_t v4 = *(float64x2_t *)(*(void *)a1 + 16 * (v9 % v3));
  float64x2_t v5 = *(float64x2_t *)(*(void *)a1 + 16 * ((v9 + 1) % v3));
  if ((vmovn_s64(vcgtq_f64(v4, v5)).u8[0] & 1) != 0
    || (int32x2_t v6 = vmovn_s64(vcgtq_f64(v5, v4)), ((v6.i32[0] | v6.i32[1]) & 1) == 0))
  {
    long long v7 = *(_OWORD *)(*(void *)a1 + 16 * ((v9 + 1) % v3));
  }
  else
  {
    long long v7 = *(_OWORD *)(*(void *)a1 + 16 * (v9 % v3));
    float64x2_t v4 = *(float64x2_t *)(*(void *)a1 + 16 * ((v9 + 1) % v3));
  }
  long long v10 = v7;
  float64x2_t v11 = v4;
  PCBinaryTree<PCEdgeSegment>::insertNode((uint64_t **)(a1 + 24), (double *)&v9);
  return PCBinaryTree<PCEdgeSegment>::findNode(a1 + 24, *(void *)(a1 + 24), (double *)&v9);
}

uint64_t *PCBinaryTree<PCEdgeSegment>::insertNode(uint64_t **a1, double *a2)
{
  unint64_t v3 = *a1;
  if (!*a1) {
    operator new();
  }

  return PCBinaryTree<PCEdgeSegment>::insertNode(a1, (uint64_t)v3, a2);
}

uint64_t PCBinaryTree<PCEdgeSegment>::findNode(uint64_t a1, uint64_t a2, double *a3)
{
  uint64_t v3 = a2;
  if (a2)
  {
    double v5 = *a3;
    while (*(void *)v3 != *(void *)&v5)
    {
      if (PCEdgeSegment::operator<(a3, (double *)v3))
      {
        uint64_t v3 = *(void *)(v3 + 40);
        if (!v3) {
          return v3;
        }
      }
      else
      {
        uint64_t v3 = *(void *)(v3 + 48);
        if (!v3) {
          return v3;
        }
      }
    }
  }
  return v3;
}

BOOL PCSweepline::intersect(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL result = 0;
  if (a2 && a3)
  {
    unint64_t v5 = (uint64_t)(a1[1] - *a1) >> 4;
    if ((*(void *)a2 + 1) % v5 == *(void *)a3) {
      return 0;
    }
    if ((*(void *)a3 + 1) % v5 == *(void *)a2) {
      return 0;
    }
    double v6 = *(double *)(a2 + 8);
    double v7 = *(double *)(a2 + 16);
    double v8 = *(double *)(a2 + 24);
    double v9 = *(double *)(a2 + 32);
    double v10 = *(double *)(a3 + 8);
    double v11 = *(double *)(a3 + 16);
    double v13 = *(double *)(a3 + 24);
    double v12 = *(double *)(a3 + 32);
    return ((v8 - v6) * (v11 - v7) - (v10 - v6) * (v9 - v7)) * ((v8 - v6) * (v12 - v7) - (v9 - v7) * (v13 - v6)) <= 0.0
        && ((v7 - v11) * (v13 - v10) - (v6 - v10) * (v12 - v11)) * ((v9 - v11) * (v13 - v10) - (v8 - v10) * (v12 - v11)) <= 0.0;
  }
  return result;
}

uint64_t *PCBinaryTree<PCEdgeSegment>::removeNode(uint64_t **a1, uint64_t a2, double *a3)
{
  if (!a2) {
    return 0;
  }
  unint64_t v5 = a1;
  if (*(void *)a2 == *(void *)a3)
  {
    double v6 = *(uint64_t **)(a2 + 40);
    double v7 = *(uint64_t **)(a2 + 48);
    uint64_t v8 = *(void *)(a2 + 56);
    double v9 = *a1;
    if (*(_OWORD *)(a2 + 40) != 0)
    {
      if (v6 && !v7)
      {
        if (v8)
        {
          double v10 = (uint64_t **)(v8 + 40);
          if (*(void *)(v8 + 40) == a2 || (double v10 = (uint64_t **)(v8 + 48), *(void *)(v8 + 48) == a2))
          {
            *double v10 = v6;
            v6[7] = v8;
          }
        }
        if (v9 == (uint64_t *)a2)
        {
          *a1 = 0;
          MEMORY[0x1BA9BFBA0](a2, 0x1020C40CB6E4C77);
          *unint64_t v5 = v6;
          v6[7] = 0;
        }
        else
        {
          MEMORY[0x1BA9BFBA0](a2, 0x1020C40CB6E4C77);
        }
        goto LABEL_26;
      }
      if (!v6 && v7)
      {
        if (v8)
        {
          long long v19 = (uint64_t **)(v8 + 40);
          if (*(void *)(v8 + 40) == a2 || (long long v19 = (uint64_t **)(v8 + 48), *(void *)(v8 + 48) == a2))
          {
            *long long v19 = v7;
            v7[7] = v8;
          }
        }
        if (v9 == (uint64_t *)a2)
        {
          *a1 = 0;
          MEMORY[0x1BA9BFBA0](a2, 0x1020C40CB6E4C77);
          *unint64_t v5 = v7;
          v7[7] = 0;
        }
        else
        {
          MEMORY[0x1BA9BFBA0](a2, 0x1020C40CB6E4C77);
        }
        double v6 = v7;
        goto LABEL_26;
      }
      uint64_t v20 = *(void *)(a2 + 48);
      do
      {
        double v13 = (double *)v20;
        uint64_t v20 = *(void *)(v20 + 40);
      }
      while (v20);
      long long v21 = *(_OWORD *)v13;
      long long v22 = *((_OWORD *)v13 + 1);
      *(double *)(a2 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v13[4];
      *(_OWORD *)a2 = v21;
      *(_OWORD *)(a2 + 16) = v22;
      double v12 = v7;
      goto LABEL_15;
    }
    if (v8)
    {
      double v15 = (void *)(v8 + 40);
      if (*(void *)(v8 + 40) == a2)
      {
LABEL_22:
        *double v15 = 0;
        goto LABEL_23;
      }
      uint64_t v17 = *(void *)(v8 + 48);
      unint64_t v16 = (void *)(v8 + 48);
      if (v17 == a2)
      {
        double v15 = v16;
        goto LABEL_22;
      }
    }
LABEL_23:
    if (v9 == (uint64_t *)a2) {
      *a1 = 0;
    }
    MEMORY[0x1BA9BFBA0](a2, 0x1020C40CB6E4C77);
    double v6 = 0;
    goto LABEL_26;
  }
  if (!PCEdgeSegment::operator<((double *)a2, a3))
  {
    uint64_t v14 = PCBinaryTree<PCEdgeSegment>::removeNode(v5, *(void *)(a2 + 40), a3);
    *(void *)(a2 + 40) = v14;
    if (!v14) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  double v12 = *(uint64_t **)(a2 + 48);
  a1 = v5;
  double v13 = a3;
LABEL_15:
  uint64_t v14 = PCBinaryTree<PCEdgeSegment>::removeNode(a1, v12, v13);
  *(void *)(a2 + 48) = v14;
  if (v14) {
LABEL_16:
  }
    *(void *)(v14 + 56) = a2;
LABEL_17:
  double v6 = (uint64_t *)a2;
LABEL_26:
  uint64_t v18 = *v5;
  BOOL result = PCBinaryTree<PCEdgeSegment>::balance((uint64_t)v5, v6);
  if (v6 == v18) {
    *unint64_t v5 = result;
  }
  return result;
}

uint64_t PCSweepline::getSegmentAboveSegment(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = *(void *)(a2 + 48);
  if (v2)
  {
    do
    {
      uint64_t result = v2;
      uint64_t v2 = *(void *)(v2 + 40);
    }
    while (v2);
    return result;
  }
  uint64_t v4 = *(void *)(a2 + 56);
  if (!v4) {
    return 0;
  }
  if (*(void *)(v4 + 40) == a2) {
    return *(void *)(a2 + 56);
  }
  do
  {
    uint64_t result = *(void *)(v4 + 56);
    if (!result) {
      break;
    }
    BOOL v5 = *(void *)(result + 40) == v4;
    uint64_t v4 = *(void *)(v4 + 56);
  }
  while (!v5);
  return result;
}

uint64_t PCSweepline::getSegmentBelowSegment(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = *(void *)(a2 + 40);
  if (v2)
  {
    do
    {
      uint64_t result = v2;
      uint64_t v2 = *(void *)(v2 + 48);
    }
    while (v2);
    return result;
  }
  uint64_t v4 = *(void *)(a2 + 56);
  if (!v4) {
    return 0;
  }
  if (*(void *)(v4 + 48) == a2) {
    return *(void *)(a2 + 56);
  }
  do
  {
    uint64_t result = *(void *)(v4 + 56);
    if (!result) {
      break;
    }
    BOOL v5 = *(void *)(result + 48) == v4;
    uint64_t v4 = *(void *)(v4 + 56);
  }
  while (!v5);
  return result;
}

uint64_t isSimplePolygon(uint64_t *a1)
{
  PCVertexList::PCVertexList((uint64_t *)&__p, a1);
  PCSweepline::PCSweepline((uint64_t)v16, (long long **)a1);
  uint64_t v2 = (char *)__p;
  if (v19 == __p)
  {
LABEL_10:
    uint64_t v14 = 1;
    goto LABEL_12;
  }
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  while (1)
  {
    BOOL v5 = &v2[v3];
    if (!*(void *)&v2[v3 + 8]) {
      break;
    }
    unint64_t v20 = *(void *)v5;
    long long v22 = *((_OWORD *)v5 + 1);
    long long v21 = *((_OWORD *)v5 + 2);
    uint64_t Node = PCBinaryTree<PCEdgeSegment>::findNode((uint64_t)&v17, (uint64_t)v17, (double *)&v20);
    double v7 = (double *)Node;
    if (Node)
    {
      uint64_t SegmentAboveSegment = PCSweepline::getSegmentAboveSegment(Node, Node);
      uint64_t SegmentBelowSegment = PCSweepline::getSegmentBelowSegment(SegmentAboveSegment, (uint64_t)v7);
      if (PCSweepline::intersect(v16, SegmentAboveSegment, SegmentBelowSegment)) {
        goto LABEL_11;
      }
      PCBinaryTree<PCEdgeSegment>::removeNode(&v17, (uint64_t)v17, v7);
    }
LABEL_9:
    ++v4;
    uint64_t v2 = (char *)__p;
    v3 += 48;
    if (v4 >= 0xAAAAAAAAAAAAAAABLL * ((v19 - (unsigned char *)__p) >> 4)) {
      goto LABEL_10;
    }
  }
  uint64_t v10 = PCSweepline::addSegment((uint64_t)v16, (unint64_t *)v5);
  uint64_t v11 = PCSweepline::getSegmentAboveSegment(v10, v10);
  BOOL v12 = PCSweepline::intersect(v16, v10, v11);
  if (!v12)
  {
    uint64_t v13 = PCSweepline::getSegmentBelowSegment(v12, v10);
    if (!PCSweepline::intersect(v16, v10, v13)) {
      goto LABEL_9;
    }
  }
LABEL_11:
  uint64_t v14 = 0;
LABEL_12:
  PCSweepline::~PCSweepline((PCSweepline *)v16);
  if (__p)
  {
    long long v19 = __p;
    operator delete(__p);
  }
  return v14;
}

void sub_1B767C07C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<PCEdgeVertex>::__push_back_slow_path<PCEdgeVertex const&>(uint64_t *a1, _OWORD *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v9 = 0x555555555555555;
  }
  else {
    unint64_t v9 = v5;
  }
  long long v19 = a1 + 2;
  uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HGBinding>>(v7, v9);
  uint64_t v11 = &v10[48 * v4];
  __p = v10;
  unint64_t v16 = v11;
  uint64_t v18 = &v10[48 * v12];
  *(_OWORD *)uint64_t v11 = *a2;
  *((_OWORD *)v11 + 1) = a2[1];
  *((_OWORD *)v11 + OZChannelFontBase::~OZChannelFontBase(this - 2) = a2[2];
  uint64_t v17 = v11 + 48;
  std::vector<PCEdgeVertex>::__swap_out_circular_buffer(a1, &__p);
  uint64_t v13 = a1[1];
  if (v17 != v16) {
    uint64_t v17 = &v16[(v17 - v16 - 48) % 0x30uLL];
  }
  if (__p) {
    operator delete(__p);
  }
  return v13;
}

void sub_1B767C1D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::vector<PCEdgeVertex>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 48;
      *(_OWORD *)(v4 - 48) = *(_OWORD *)(v3 - 48);
      *(_OWORD *)(v4 - 3OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_OWORD *)(v3 - 32);
      *(_OWORD *)(v4 - 16) = *(_OWORD *)(v3 - 16);
      v3 -= 48;
      v4 -= 48;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v6 = *result;
  *uint64_t result = v5;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*,false>(long long *a1, long long *a2, unsigned int (**a3)(_OWORD *, long long *), uint64_t a4, char a5)
{
LABEL_1:
  uint64_t v11 = a2 - 3;
  uint64_t v12 = a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = v12;
    uint64_t v14 = v13;
    uint64_t v15 = (char *)a2 - (char *)v12;
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (a2 - v12);
    if (!(!v6 & v5))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          uint64_t v32 = *a3;
          v41[0] = *(a2 - 3);
          v41[1] = *(a2 - 2);
          v41[2] = *(a2 - 1);
          long long v33 = v12[1];
          v40[0] = *v12;
          v40[1] = v33;
          v40[2] = v12[2];
          if (v32(v41, v40))
          {
            long long v34 = v12[1];
            long long v42 = *v12;
            long long v35 = v12[2];
            long long v37 = *(a2 - 2);
            long long v36 = *(a2 - 1);
            *uint64_t v12 = *v11;
            v12[1] = v37;
            v12[2] = v36;
            *uint64_t v11 = v42;
            *(a2 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v34;
            *(a2 - 1) = v35;
          }
          break;
        case 3uLL:
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(v12, v12 + 3, a2 - 3, a3);
          break;
        case 4uLL:
          std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(v12, v12 + 3, v12 + 6, a2 - 3, a3);
          break;
        case 5uLL:
          std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(v12, v12 + 3, v12 + 6, v12 + 9, a2 - 3, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v15 <= 1151)
    {
      if (a5) {
        std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>((uint64_t)v12, a2, (uint64_t (**)(long long *, _OWORD *))a3);
      }
      else {
        std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>((uint64_t)v12, a2, (uint64_t (**)(long long *, _OWORD *))a3);
      }
      return;
    }
    if (v14 == 1) {
      break;
    }
    unint64_t v17 = v16 >> 1;
    uint64_t v18 = &v12[3 * (v16 >> 1)];
    if ((unint64_t)v15 >= 0x1801)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(v12, &v12[3 * (v16 >> 1)], a2 - 3, a3);
      uint64_t v19 = 3 * v17;
      unint64_t v20 = &v12[3 * v17 - 3];
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(v12 + 3, v20, a2 - 6, a3);
      long long v21 = v12 + 6;
      long long v22 = &v12[v19 + 3];
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(v21, v22, a2 - 9, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(v20, v18, v22, a3);
      long long v23 = a1[1];
      long long v42 = *a1;
      long long v24 = a1[2];
      long long v25 = v18[2];
      long long v26 = *v18;
      a1[1] = v18[1];
      a1[2] = v25;
      *a1 = v26;
      *uint64_t v18 = v42;
      v18[1] = v23;
      v18[2] = v24;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(&v12[3 * (v16 >> 1)], v12, a2 - 3, a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    CMTime v27 = *a3;
    v39[0] = *(a1 - 3);
    v39[1] = *(a1 - 2);
    v39[2] = *(a1 - 1);
    long long v28 = a1[1];
    v38[0] = *a1;
    v38[1] = v28;
    v38[2] = a1[2];
    if ((((uint64_t (*)(_OWORD *, _OWORD *))v27)(v39, v38) & 1) == 0)
    {
      uint64_t v12 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,PCEdgeVertex *,BOOL (*&)(PCEdgeVertex,PCEdgeVertex)>(a1, a2, (uint64_t (**)(long long *, _OWORD *))a3);
      goto LABEL_18;
    }
LABEL_13:
    v29 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,PCEdgeVertex *,BOOL (*&)(PCEdgeVertex,PCEdgeVertex)>(a1, a2, (uint64_t (**)(_OWORD *, long long *))a3);
    if ((v30 & 1) == 0) {
      goto LABEL_16;
    }
    BOOL v31 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(a1, v29, a3);
    uint64_t v12 = v29 + 3;
    if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(v29 + 3, a2, a3))
    {
      a4 = -v14;
      a2 = v29;
      if (v31) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v14 + 1;
    if (!v31)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*,false>(a1, v29, a3, -v14, a5 & 1);
      uint64_t v12 = v29 + 3;
LABEL_18:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (v12 != a2) {
    std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*,PCEdgeVertex*>((uint64_t)v12, a2, a2, (uint64_t (**)(_OWORD *, long long *))a3);
  }
}

  uint64_t v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (uint64_t)a2 - v11;
    uint64_t v15 = (uint64_t)((uint64_t)a2 - v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (a2[-1].n128_u32[2] > *(_DWORD *)(v11 + 8))
          {
            long long v22 = *(_OWORD *)v11;
            *(__n128 *)uint64_t v11 = a2[-1];
            a2[-1] = (__n128)v22;
          }
          break;
        case 3uLL:
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((long long *)v11, (long long *)(v11 + 16), (long long *)&a2[-1]);
          break;
        case 4uLL:
          std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(v11, v11 + 16, v11 + 32, (uint64_t)&a2[-1]);
          break;
        case 5uLL:
          std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((__n128 *)v11, (__n128 *)(v11 + 16), (__n128 *)(v11 + 32), (__n128 *)(v11 + 48), a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if ((__n128 *)v11 != a2)
      {
        std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *,PCSingleton::Info *>(v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = (long long *)(v11 + 16 * (v15 >> 1));
    if ((unint64_t)v14 >= 0x801)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((long long *)v11, (long long *)(v11 + 16 * (v15 >> 1)), (long long *)&a2[-1]);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((long long *)(v11 + 16), v17 - 1, (long long *)&a2[-2]);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((long long *)(v11 + 32), (long long *)(v11 + 16 + 16 * v16), (long long *)&a2[-3]);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(v17 - 1, v17, (long long *)(v11 + 16 + 16 * v16));
      long long v21 = *(_OWORD *)v11;
      *(_OWORD *)uint64_t v11 = *v17;
      char *v17 = v21;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((long long *)(v11 + 16 * (v15 >> 1)), (long long *)v11, (long long *)&a2[-1]);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (*(_DWORD *)(v11 - 8) <= *(_DWORD *)(v11 + 8))
    {
      uint64_t v11 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Info *,PCSingleton::Compare &>((void *)v11, a2);
      goto LABEL_18;
    }
LABEL_13:
    uint64_t v18 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Info *,PCSingleton::Compare &>((uint64_t *)v11, (uint64_t *)a2);
    if ((v19 & 1) == 0) {
      goto LABEL_16;
    }
    unint64_t v20 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(v11, v18);
    uint64_t v11 = v18 + 16;
    if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(v18 + 16, (uint64_t)a2))
    {
      a4 = -v13;
      a2 = (__n128 *)v18;
      if (v20) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v20)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *,false>(a1, v18, a3, -v13, a5 & 1);
      uint64_t v11 = v18 + 16;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((_DWORD *)v11, a2);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((_DWORD *)v11, a2);
  }
}

  uint64_t v11 = a2 - 1;
  uint64_t v12 = a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = v12;
    uint64_t v14 = (char *)a2 - (char *)v12;
    uint64_t v15 = v14 >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          v99 = *(a2 - 2);
          v100 = *a1;
          if (*(void *)(v99 + 112) > *(void *)(*a1 + 112))
          {
            *a1 = v99;
            *(a2 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v100;
            v101 = a1[1];
            a1[1] = *(a2 - 1);
            *(a2 - 1) = v101;
          }
          return;
        case 3uLL:
          v102 = a1[2];
          v103 = *(void *)(v102 + 112);
          v104 = *a1;
          v105 = *(void *)(*a1 + 112);
          v106 = *(a2 - 2);
          v107 = *(void *)(v106 + 112);
          if (v103 <= v105)
          {
            if (v107 <= v103) {
              return;
            }
            a1[2] = v106;
            *(a2 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v102;
            uint64_t v11 = a1 + 3;
            v126 = a1[3];
            a1[3] = *(a2 - 1);
            *(a2 - 1) = v126;
            v127 = a1[2];
            v128 = *a1;
            if (*(void *)(v127 + 112) <= *(void *)(*a1 + 112)) {
              return;
            }
            *a1 = v127;
            a1[2] = v128;
            v108 = a1 + 1;
          }
          else
          {
            if (v107 <= v103)
            {
              v108 = a1 + 3;
              v129 = a1[3];
              v130 = a1[1];
              *a1 = v102;
              a1[1] = v129;
              a1[2] = v104;
              a1[3] = v130;
              v131 = *(a2 - 2);
              if (*(void *)(v131 + 112) <= v105) {
                return;
              }
              a1[2] = v131;
            }
            else
            {
              v108 = a1 + 1;
              *a1 = v106;
            }
            *(a2 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v104;
          }
          v132 = *v108;
          *v108 = *v11;
          *uint64_t v11 = v132;
          return;
        case 4uLL:
          std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(a1, a1 + 2, a1 + 4, a2 - 2);
          return;
        case 5uLL:
          std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(a1, a1 + 2, a1 + 4, a1 + 6);
          v109 = *(a2 - 2);
          v110 = a1[6];
          if (*(void *)(v109 + 112) > *(void *)(v110 + 112))
          {
            a1[6] = v109;
            *(a2 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v110;
            v111 = a1[7];
            a1[7] = *(a2 - 1);
            *(a2 - 1) = v111;
            v112 = a1[6];
            v113 = *(void *)(v112 + 112);
            v114 = a1[4];
            if (v113 > *(void *)(v114 + 112))
            {
              v115 = a1[5];
              v116 = a1[7];
              a1[4] = v112;
              a1[5] = v116;
              a1[6] = v114;
              a1[7] = v115;
              v117 = a1[2];
              if (v113 > *(void *)(v117 + 112))
              {
                v118 = a1[3];
                a1[2] = v112;
                a1[3] = v116;
                a1[4] = v117;
                a1[5] = v118;
                v119 = *a1;
                if (v113 > *(void *)(*a1 + 112))
                {
                  v120 = a1[1];
                  *a1 = v112;
                  a1[1] = v116;
                  a1[2] = v119;
                  a1[3] = v120;
                }
              }
            }
          }
          return;
        default:
          JUMPOUT(0);
      }
    }
    if (v14 <= 383) {
      break;
    }
    unint64_t v16 = v13;
    if (v13 == 1)
    {
      if (a1 != a2)
      {
        v121 = (v15 - 2) >> 1;
        v122 = v121 + 1;
        v123 = &a1[2 * v121];
        do
        {
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>((uint64_t)a1, a3, v14 >> 4, v123);
          v123 -= 2;
          --v122;
        }
        while (v122);
        v124 = (unint64_t)v14 >> 4;
        do
        {
          std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices,std::shared_ptr<HGGPUComputeDevice const> *>((uint64_t)a1, (uint64_t)a2, a3, v124);
          a2 -= 2;
        }
        while (v124-- > 2);
      }
      return;
    }
    unint64_t v17 = v15 >> 1;
    uint64_t v18 = &a1[2 * (v15 >> 1)];
    uint64_t v19 = *(a2 - 2);
    unint64_t v20 = *(void *)(v19 + 112);
    if ((unint64_t)v14 >= 0x801)
    {
      long long v21 = *v18;
      long long v22 = *(void *)(*v18 + 112);
      long long v23 = *a1;
      long long v24 = *(void *)(*a1 + 112);
      if (v22 <= v24)
      {
        if (v20 > v22)
        {
          *uint64_t v18 = v19;
          *(a2 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v21;
          BOOL v31 = &a1[2 * v17];
          long long v33 = v31[1];
          uint64_t v32 = v31 + 1;
          *uint64_t v32 = *(a2 - 1);
          *(a2 - 1) = v33;
          long long v34 = *a1;
          if (*(void *)(*v18 + 112) > *(void *)(*a1 + 112))
          {
            *a1 = *v18;
            long long v25 = a1 + 1;
            *uint64_t v18 = v34;
            goto LABEL_23;
          }
        }
      }
      else
      {
        if (v20 > v22)
        {
          long long v25 = a1 + 1;
          *a1 = v19;
          goto LABEL_22;
        }
        *a1 = v21;
        *uint64_t v18 = v23;
        v38 = a1[1];
        long long v25 = &a1[2 * v17 + 1];
        a1[1] = *v25;
        *long long v25 = v38;
        v39 = *(a2 - 2);
        if (*(void *)(v39 + 112) > v24)
        {
          *uint64_t v18 = v39;
LABEL_22:
          *(a2 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v23;
          uint64_t v32 = a2 - 1;
LABEL_23:
          v40 = *v25;
          *long long v25 = *v32;
          *uint64_t v32 = v40;
        }
      }
      v41 = v17 - 1;
      long long v42 = &a1[2 * v17 - 2];
      v43 = *v42;
      v44 = *(void *)(*v42 + 112);
      v45 = a1[2];
      v46 = *(void *)(v45 + 112);
      v47 = *(a2 - 4);
      v48 = *(void *)(v47 + 112);
      if (v44 <= v46)
      {
        if (v48 > v44)
        {
          *long long v42 = v47;
          *(a2 - 4) = v43;
          v50 = &a1[2 * v41];
          v52 = v50[1];
          v51 = v50 + 1;
          *v51 = *(a2 - 3);
          *(a2 - 3) = v52;
          v53 = a1[2];
          if (*(void *)(*v42 + 112) > *(void *)(v53 + 112))
          {
            a1[2] = *v42;
            *long long v42 = v53;
            v49 = a1 + 3;
            goto LABEL_36;
          }
        }
      }
      else
      {
        if (v48 > v44)
        {
          v49 = a1 + 3;
          a1[2] = v47;
          goto LABEL_35;
        }
        v56 = &a1[2 * v41];
        v57 = v56[1];
        v49 = v56 + 1;
        v58 = a1[3];
        a1[2] = v43;
        a1[3] = v57;
        *long long v42 = v45;
        *v49 = v58;
        v59 = *(a2 - 4);
        if (*(void *)(v59 + 112) > v46)
        {
          *long long v42 = v59;
LABEL_35:
          *(a2 - 4) = v45;
          v51 = a2 - 3;
LABEL_36:
          v60 = *v49;
          *v49 = *v51;
          *v51 = v60;
        }
      }
      v61 = v17 + 1;
      v62 = &a1[2 * v17 + 2];
      v63 = *v62;
      v64 = *(void *)(*v62 + 112);
      v65 = a1[4];
      v66 = *(void *)(v65 + 112);
      v67 = *(a2 - 6);
      v68 = *(void *)(v67 + 112);
      if (v64 <= v66)
      {
        if (v68 > v64)
        {
          *v62 = v67;
          *(a2 - 6) = v63;
          v70 = &a1[2 * v61];
          v72 = v70[1];
          v71 = v70 + 1;
          *v71 = *(a2 - 5);
          *(a2 - 5) = v72;
          v63 = *v62;
          v73 = a1[4];
          if (*(void *)(*v62 + 112) > *(void *)(v73 + 112))
          {
            a1[4] = v63;
            *v62 = v73;
            v69 = a1 + 5;
            goto LABEL_47;
          }
        }
      }
      else
      {
        if (v68 > v64)
        {
          v69 = a1 + 5;
          a1[4] = v67;
          goto LABEL_46;
        }
        v74 = &a1[2 * v61];
        v75 = v74[1];
        v69 = v74 + 1;
        v76 = a1[5];
        a1[4] = v63;
        a1[5] = v75;
        *v62 = v65;
        *v69 = v76;
        v77 = *(a2 - 6);
        if (*(void *)(v77 + 112) <= v66)
        {
          v63 = v65;
          goto LABEL_48;
        }
        *v62 = v77;
LABEL_46:
        *(a2 - 6) = v65;
        v71 = a2 - 5;
LABEL_47:
        v78 = *v69;
        *v69 = *v71;
        *v71 = v78;
        v63 = *v62;
      }
LABEL_48:
      v79 = *v18;
      v80 = *(void *)(*v18 + 112);
      v81 = *v42;
      v82 = *(void *)(*v42 + 112);
      v83 = *(void *)(v63 + 112);
      if (v80 <= v82)
      {
        if (v83 <= v80) {
          goto LABEL_59;
        }
        *uint64_t v18 = v63;
        v86 = &a1[2 * v17];
        v87 = v86[1];
        v85 = v86 + 1;
        *v62 = v79;
        v88 = &a1[2 * v61];
        *v85 = v88[1];
        v88[1] = v87;
        if (v83 <= v82)
        {
          v79 = v63;
          goto LABEL_59;
        }
        *long long v42 = v63;
        *uint64_t v18 = v81;
        v84 = &a1[2 * v41 + 1];
      }
      else
      {
        v84 = &a1[2 * v41 + 1];
        if (v83 > v80)
        {
          *long long v42 = v63;
          *v62 = v81;
          v85 = &a1[2 * v61 + 1];
          goto LABEL_58;
        }
        *long long v42 = v79;
        *uint64_t v18 = v81;
        v89 = &a1[2 * v17];
        v91 = v89[1];
        v90 = v89 + 1;
        v92 = *v84;
        *v84 = v91;
        *v90 = v92;
        if (v83 <= v82)
        {
          v79 = v81;
          goto LABEL_59;
        }
        *uint64_t v18 = v63;
        *v62 = v81;
        v85 = &a1[2 * v61 + 1];
        v84 = v90;
      }
LABEL_58:
      v93 = *v84;
      *v84 = *v85;
      *v85 = v93;
      v79 = *v18;
LABEL_59:
      v94 = *a1;
      *a1 = v79;
      char v30 = a1 + 1;
      *uint64_t v18 = v94;
      long long v35 = &a1[2 * v17 + 1];
LABEL_60:
      v95 = *v30;
      *char v30 = *v35;
      *long long v35 = v95;
      goto LABEL_61;
    }
    long long v26 = *a1;
    CMTime v27 = *(void *)(*a1 + 112);
    long long v28 = *v18;
    v29 = *(void *)(*v18 + 112);
    if (v27 <= v29)
    {
      if (v20 > v27)
      {
        *a1 = v19;
        *(a2 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v26;
        long long v35 = a1 + 1;
        long long v36 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v36;
        long long v37 = *v18;
        if (*(void *)(*a1 + 112) > *(void *)(*v18 + 112))
        {
          *uint64_t v18 = *a1;
          *a1 = v37;
          char v30 = &a1[2 * v17 + 1];
          goto LABEL_60;
        }
      }
    }
    else
    {
      char v30 = &a1[2 * v17 + 1];
      if (v20 > v27)
      {
        *uint64_t v18 = v19;
        *(a2 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v28;
LABEL_32:
        long long v35 = a2 - 1;
        goto LABEL_60;
      }
      *uint64_t v18 = v26;
      *a1 = v28;
      v54 = *v30;
      *char v30 = a1[1];
      a1[1] = v54;
      v55 = *(a2 - 2);
      if (*(void *)(v55 + 112) > v29)
      {
        *a1 = v55;
        *(a2 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v28;
        char v30 = a1 + 1;
        goto LABEL_32;
      }
    }
LABEL_61:
    if ((a5 & 1) == 0 && *(void *)(*(a1 - 2) + 112) <= *(void *)(*a1 + 112))
    {
      uint64_t v12 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::shared_ptr<HGGPUComputeDevice const> *,SortGPUDevices &>((long long *)a1, a2);
LABEL_68:
      a5 = 0;
      a4 = -v16;
      goto LABEL_2;
    }
    v96 = (uint64_t *)std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::shared_ptr<HGGPUComputeDevice const> *,SortGPUDevices &>((long long *)a1, (long long *)a2);
    if ((v97 & 1) == 0) {
      goto LABEL_67;
    }
    v98 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(a1, v96);
    uint64_t v12 = v96 + 2;
    if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(v96 + 2, a2))
    {
      a4 = -v16;
      a2 = v96;
      if (v98) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v16 + 1;
    if (!v98)
    {
LABEL_67:
      std::__introsort<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *,false>(a1, v96, a3, -v16, a5 & 1);
      uint64_t v12 = v96 + 2;
      goto LABEL_68;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(a1, a2);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(a1, a2);
  }
}

  uint64_t v10 = a2 - 9;
  uint64_t v11 = a2 - 18;
  uint64_t v12 = a2 - 27;
  n128_u64 = a1;
  v711 = a2;
  while (1)
  {
    a1 = n128_u64;
    uint64_t v14 = (uint64_t)a2 - n128_u64;
    uint64_t v15 = 0x8E38E38E38E38E39 * ((uint64_t)((uint64_t)a2 - n128_u64) >> 4);
    if (v6 || !v5) {
      break;
    }
    if (v14 <= 3455)
    {
      v608 = (__n128 *)(n128_u64 + 144);
      v610 = (__n128 *)n128_u64 == a2 || v608 == a2;
      if (a5)
      {
        if (!v610)
        {
          v611 = 0;
          v612 = (__n128 *)n128_u64;
          do
          {
            v620 = (long long *)v612;
            v612 = v608;
            if ((*a3)((char *)v608, v620))
            {
              v723 = *v612;
              v621 = v612[1];
              v622 = v612[2];
              v623 = v612[4];
              v726 = (__int128)v612[3];
              v727 = v623;
              v724 = (__int128)v621;
              v725 = v622;
              v624 = v612[5];
              v625 = v612[6];
              v626 = v612[8];
              v730 = (__int128)v612[7];
              v731 = v626;
              v728 = (__int128)v624;
              v729 = v625;
              v627 = v611;
              do
              {
                v628 = (_OWORD *)(n128_u64 + v627);
                v629 = *(_OWORD *)(n128_u64 + v627 + 112);
                v628[15] = *(_OWORD *)(n128_u64 + v627 + 96);
                v628[16] = v629;
                v628[17] = *(_OWORD *)(n128_u64 + v627 + 128);
                v630 = *(_OWORD *)(n128_u64 + v627 + 48);
                v628[11] = *(_OWORD *)(n128_u64 + v627 + 32);
                v628[12] = v630;
                v631 = *(_OWORD *)(n128_u64 + v627 + 80);
                v628[13] = *(_OWORD *)(n128_u64 + v627 + 64);
                v628[14] = v631;
                v632 = *(_OWORD *)(n128_u64 + v627 + 16);
                v628[9] = *(_OWORD *)(n128_u64 + v627);
                v628[10] = v632;
                if (!v627)
                {
                  v613 = (__n128 *)n128_u64;
                  goto LABEL_122;
                }
                v627 -= 144;
              }
              while ((((uint64_t (*)(__n128 *, unint64_t))*a3)(&v723, v627 + n128_u64) & 1) != 0);
              v613 = (__n128 *)(n128_u64 + v627 + 144);
LABEL_122:
              *v613 = v723;
              v614 = (__n128)v724;
              v615 = v725;
              v616 = v727;
              v613[3] = (__n128)v726;
              v613[4] = v616;
              v613[1] = v614;
              v613[2] = v615;
              v617 = (__n128)v728;
              v618 = v729;
              v619 = v731;
              v613[7] = (__n128)v730;
              v613[8] = v619;
              v613[5] = v617;
              v613[6] = v618;
            }
            v608 = v612 + 9;
            v611 += 144;
          }
          while (&v612[9] != a2);
        }
      }
      else if (!v610)
      {
        v665 = (long long *)(n128_u64 - 144);
        do
        {
          v666 = (long long *)a1;
          a1 = (unint64_t)v608;
          if ((*a3)((char *)v608, v666))
          {
            v723 = *(__n128 *)a1;
            v667 = *(_OWORD *)(a1 + 16);
            v668 = *(__n128 *)(a1 + 32);
            v669 = *(__n128 *)(a1 + 64);
            v726 = *(_OWORD *)(a1 + 48);
            v727 = v669;
            v724 = v667;
            v725 = v668;
            v670 = *(_OWORD *)(a1 + 80);
            v671 = *(__n128 *)(a1 + 96);
            v672 = *(__n128 *)(a1 + 128);
            v730 = *(_OWORD *)(a1 + 112);
            v731 = v672;
            v728 = v670;
            v729 = v671;
            v673 = v665;
            do
            {
              v674 = v673[16];
              v673[24] = v673[15];
              v673[25] = v674;
              v673[26] = v673[17];
              v675 = v673[12];
              v673[20] = v673[11];
              v673[21] = v675;
              v676 = v673[14];
              v673[22] = v673[13];
              v673[23] = v676;
              v677 = v673[10];
              v673[18] = v673[9];
              v673[19] = v677;
              v678 = (*a3)((char *)&v723, v673);
              v673 -= 9;
            }
            while ((v678 & 1) != 0);
            v673[18] = (__int128)v723;
            v679 = v724;
            v680 = (__int128)v725;
            v681 = (__int128)v727;
            v673[21] = v726;
            v673[22] = v681;
            v673[19] = v679;
            v673[20] = v680;
            v682 = v728;
            v683 = (__int128)v729;
            v684 = (__int128)v731;
            v673[25] = v730;
            v673[26] = v684;
            v673[23] = v682;
            v673[24] = v683;
          }
          v608 = (__n128 *)(a1 + 144);
          v665 += 9;
        }
        while ((__n128 *)(a1 + 144) != a2);
      }
      return;
    }
    if (!a4)
    {
      if ((__n128 *)n128_u64 != a2) {
        std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*,HGROIsInfo*>((char *)n128_u64, (char *)a2, (char *)a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = (long long *)(n128_u64 + 144 * (v15 >> 1));
    uint64_t v18 = *a3;
    if ((unint64_t)v14 >= 0x4801)
    {
      uint64_t v19 = v18((char *)(n128_u64 + 144 * (v15 >> 1)), (long long *)n128_u64);
      unint64_t v20 = (*a3)((char *)v10, v17);
      if (v19)
      {
        if (v20)
        {
          v723 = *(__n128 *)n128_u64;
          long long v21 = *(_OWORD *)(n128_u64 + 16);
          long long v22 = *(__n128 *)(n128_u64 + 32);
          long long v23 = *(__n128 *)(n128_u64 + 64);
          v726 = *(_OWORD *)(n128_u64 + 48);
          v727 = v23;
          v724 = v21;
          v725 = v22;
          long long v24 = *(_OWORD *)(n128_u64 + 80);
          long long v25 = *(__n128 *)(n128_u64 + 96);
          long long v26 = *(__n128 *)(n128_u64 + 128);
          v730 = *(_OWORD *)(n128_u64 + 112);
          v731 = v26;
          v728 = v24;
          v729 = v25;
          *(__n128 *)n128_u64 = *v10;
          CMTime v27 = v10[1];
          long long v28 = v10[2];
          v29 = v10[4];
          *(__n128 *)(n128_u64 + 48) = v10[3];
          *(__n128 *)(n128_u64 + 64) = v29;
          *(__n128 *)(n128_u64 + 16) = v27;
          *(__n128 *)(n128_u64 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v28;
          char v30 = v10[5];
          BOOL v31 = v10[6];
          uint64_t v32 = v10[8];
          *(__n128 *)(n128_u64 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v10[7];
          *(__n128 *)(n128_u64 + 128) = v32;
          *(__n128 *)(n128_u64 + 80) = v30;
          *(__n128 *)(n128_u64 + 96) = v31;
        }
        else
        {
          v723 = *(__n128 *)n128_u64;
          v119 = *(_OWORD *)(n128_u64 + 16);
          v120 = *(__n128 *)(n128_u64 + 32);
          v121 = *(__n128 *)(n128_u64 + 64);
          v726 = *(_OWORD *)(n128_u64 + 48);
          v727 = v121;
          v724 = v119;
          v725 = v120;
          v122 = *(_OWORD *)(n128_u64 + 80);
          v123 = *(__n128 *)(n128_u64 + 96);
          v124 = *(__n128 *)(n128_u64 + 128);
          v730 = *(_OWORD *)(n128_u64 + 112);
          v731 = v124;
          v728 = v122;
          v729 = v123;
          *(_OWORD *)n128_u64 = *v17;
          v125 = v17[1];
          v126 = v17[2];
          v127 = v17[4];
          *(_OWORD *)(n128_u64 + 48) = v17[3];
          *(_OWORD *)(n128_u64 + 64) = v127;
          *(_OWORD *)(n128_u64 + 16) = v125;
          *(_OWORD *)(n128_u64 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v126;
          v128 = v17[5];
          v129 = v17[6];
          v130 = v17[8];
          *(_OWORD *)(n128_u64 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v17[7];
          *(_OWORD *)(n128_u64 + 128) = v130;
          *(_OWORD *)(n128_u64 + 80) = v128;
          *(_OWORD *)(n128_u64 + 96) = v129;
          char *v17 = (__int128)v723;
          v131 = v724;
          v132 = (__int128)v725;
          v133 = (__int128)v727;
          v17[3] = v726;
          v17[4] = v133;
          v17[1] = v131;
          v17[2] = v132;
          v134 = v728;
          v135 = (__int128)v729;
          v136 = (__int128)v731;
          v17[7] = v730;
          v17[8] = v136;
          v17[5] = v134;
          v17[6] = v135;
          if (!(*a3)((char *)v10, v17)) {
            goto LABEL_24;
          }
          v723 = (__n128)*v17;
          v137 = v17[1];
          v138 = v17[2];
          v139 = v17[4];
          v726 = v17[3];
          v727 = (__n128)v139;
          v724 = v137;
          v725 = (__n128)v138;
          v140 = v17[5];
          v141 = v17[6];
          v142 = v17[8];
          v730 = v17[7];
          v731 = (__n128)v142;
          v728 = v140;
          v729 = (__n128)v141;
          char *v17 = (__int128)*v10;
          v143 = (__int128)v10[1];
          v144 = (__int128)v10[2];
          v145 = (__int128)v10[4];
          v17[3] = (__int128)v10[3];
          v17[4] = v145;
          v17[1] = v143;
          v17[2] = v144;
          v146 = (__int128)v10[5];
          v147 = (__int128)v10[6];
          v148 = (__int128)v10[8];
          v17[7] = (__int128)v10[7];
          v17[8] = v148;
          v17[5] = v146;
          v17[6] = v147;
        }
        *uint64_t v10 = v723;
        v149 = (__n128)v724;
        v150 = v725;
        v151 = v727;
        v10[3] = (__n128)v726;
        v10[4] = v151;
        v10[1] = v149;
        v10[2] = v150;
        v152 = (__n128)v728;
        v153 = v729;
        v154 = v731;
        v10[7] = (__n128)v730;
        v10[8] = v154;
        v10[5] = v152;
        v10[6] = v153;
      }
      else if (v20)
      {
        v723 = (__n128)*v17;
        v47 = v17[1];
        v48 = v17[2];
        v49 = v17[4];
        v726 = v17[3];
        v727 = (__n128)v49;
        v724 = v47;
        v725 = (__n128)v48;
        v50 = v17[5];
        v51 = v17[6];
        v52 = v17[8];
        v730 = v17[7];
        v731 = (__n128)v52;
        v728 = v50;
        v729 = (__n128)v51;
        char *v17 = (__int128)*v10;
        v53 = (__int128)v10[1];
        v54 = (__int128)v10[2];
        v55 = (__int128)v10[4];
        v17[3] = (__int128)v10[3];
        v17[4] = v55;
        v17[1] = v53;
        v17[2] = v54;
        v56 = (__int128)v10[5];
        v57 = (__int128)v10[6];
        v58 = (__int128)v10[8];
        v17[7] = (__int128)v10[7];
        v17[8] = v58;
        v17[5] = v56;
        v17[6] = v57;
        *uint64_t v10 = v723;
        v59 = (__n128)v724;
        v60 = v725;
        v61 = v727;
        v10[3] = (__n128)v726;
        v10[4] = v61;
        v10[1] = v59;
        v10[2] = v60;
        v62 = (__n128)v728;
        v63 = v729;
        v64 = v731;
        v10[7] = (__n128)v730;
        v10[8] = v64;
        v10[5] = v62;
        v10[6] = v63;
        if ((*a3)((char *)v17, (long long *)n128_u64))
        {
          v723 = *(__n128 *)n128_u64;
          v65 = *(_OWORD *)(n128_u64 + 16);
          v66 = *(__n128 *)(n128_u64 + 32);
          v67 = *(__n128 *)(n128_u64 + 64);
          v726 = *(_OWORD *)(n128_u64 + 48);
          v727 = v67;
          v724 = v65;
          v725 = v66;
          v68 = *(_OWORD *)(n128_u64 + 80);
          v69 = *(__n128 *)(n128_u64 + 96);
          v70 = *(__n128 *)(n128_u64 + 128);
          v730 = *(_OWORD *)(n128_u64 + 112);
          v731 = v70;
          v728 = v68;
          v729 = v69;
          *(_OWORD *)n128_u64 = *v17;
          v71 = v17[1];
          v72 = v17[2];
          v73 = v17[4];
          *(_OWORD *)(n128_u64 + 48) = v17[3];
          *(_OWORD *)(n128_u64 + 64) = v73;
          *(_OWORD *)(n128_u64 + 16) = v71;
          *(_OWORD *)(n128_u64 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v72;
          v74 = v17[5];
          v75 = v17[6];
          v76 = v17[8];
          *(_OWORD *)(n128_u64 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v17[7];
          *(_OWORD *)(n128_u64 + 128) = v76;
          *(_OWORD *)(n128_u64 + 80) = v74;
          *(_OWORD *)(n128_u64 + 96) = v75;
          char *v17 = (__int128)v723;
          v77 = v724;
          v78 = (__int128)v725;
          v79 = (__int128)v727;
          v17[3] = v726;
          v17[4] = v79;
          v17[1] = v77;
          v17[2] = v78;
          v80 = v728;
          v81 = (__int128)v729;
          v82 = (__int128)v731;
          v17[7] = v730;
          v17[8] = v82;
          v17[5] = v80;
          v17[6] = v81;
        }
      }
LABEL_24:
      v155 = (__n128 *)(n128_u64 + 144);
      v156 = (__n128 *)(a1 + 144 * v16 - 144);
      v157 = (*a3)((char *)v156, (long long *)(a1 + 144));
      v158 = (*a3)((char *)v11, (long long *)v156);
      if (v157)
      {
        if (v158)
        {
          v159 = *(_OWORD *)(a1 + 192);
          v725 = *(__n128 *)(a1 + 176);
          v726 = v159;
          v160 = *(__n128 *)(a1 + 272);
          v161 = *(__n128 *)(a1 + 240);
          v730 = *(_OWORD *)(a1 + 256);
          v731 = v160;
          v162 = *(_OWORD *)(a1 + 224);
          v727 = *(__n128 *)(a1 + 208);
          v728 = v162;
          v729 = v161;
          v163 = *(_OWORD *)(a1 + 160);
          v723 = *v155;
          v724 = v163;
          *v155 = *v11;
          v164 = v11[1];
          v165 = v11[2];
          v166 = v11[4];
          *(__n128 *)(a1 + 19OZChannelFontBase::~OZChannelFontBase(this - 2) = v11[3];
          *(__n128 *)(a1 + 208) = v166;
          *(__n128 *)(a1 + 160) = v164;
          *(__n128 *)(a1 + 176) = v165;
          v167 = v11[5];
          v168 = v11[6];
          v169 = v11[8];
          *(__n128 *)(a1 + 256) = v11[7];
          *(__n128 *)(a1 + 27OZChannelFontBase::~OZChannelFontBase(this - 2) = v169;
          *(__n128 *)(a1 + 224) = v167;
          *(__n128 *)(a1 + 240) = v168;
        }
        else
        {
          v241 = *(_OWORD *)(a1 + 192);
          v725 = *(__n128 *)(a1 + 176);
          v726 = v241;
          v242 = *(__n128 *)(a1 + 272);
          v243 = *(__n128 *)(a1 + 240);
          v730 = *(_OWORD *)(a1 + 256);
          v731 = v242;
          v244 = *(_OWORD *)(a1 + 224);
          v727 = *(__n128 *)(a1 + 208);
          v728 = v244;
          v729 = v243;
          v245 = *(_OWORD *)(a1 + 160);
          v723 = *v155;
          v724 = v245;
          *v155 = *v156;
          v246 = *(_OWORD *)(a1 + 144 * v16 - 128);
          v247 = *(_OWORD *)(a1 + 144 * v16 - 112);
          v248 = *(_OWORD *)(a1 + 144 * v16 - 80);
          *(_OWORD *)(a1 + 19OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_OWORD *)(a1 + 144 * v16 - 96);
          *(_OWORD *)(a1 + 208) = v248;
          *(_OWORD *)(a1 + 160) = v246;
          *(_OWORD *)(a1 + 176) = v247;
          v249 = *(_OWORD *)(a1 + 144 * v16 - 64);
          v250 = *(_OWORD *)(a1 + 144 * v16 - 48);
          v251 = *(_OWORD *)(a1 + 144 * v16 - 16);
          *(_OWORD *)(a1 + 256) = *(_OWORD *)(a1 + 144 * v16 - 32);
          *(_OWORD *)(a1 + 27OZChannelFontBase::~OZChannelFontBase(this - 2) = v251;
          *(_OWORD *)(a1 + 224) = v249;
          *(_OWORD *)(a1 + 240) = v250;
          *v156 = v723;
          v252 = v724;
          v253 = v725;
          v254 = v727;
          *(_OWORD *)(a1 + 144 * v16 - 96) = v726;
          *(__n128 *)(a1 + 144 * v16 - 80) = v254;
          *(_OWORD *)(a1 + 144 * v16 - 128) = v252;
          *(__n128 *)(a1 + 144 * v16 - 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v253;
          v255 = v728;
          v256 = v729;
          v257 = v731;
          *(_OWORD *)(a1 + 144 * v16 - 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v730;
          *(__n128 *)(a1 + 144 * v16 - 16) = v257;
          *(_OWORD *)(a1 + 144 * v16 - 64) = v255;
          *(__n128 *)(a1 + 144 * v16 - 48) = v256;
          if (!(*a3)((char *)v11, (long long *)(a1 + 144 * v16 - 144))) {
            goto LABEL_38;
          }
          v723 = *v156;
          v258 = *(_OWORD *)(a1 + 144 * v16 - 128);
          v259 = *(__n128 *)(a1 + 144 * v16 - 112);
          v260 = *(__n128 *)(a1 + 144 * v16 - 80);
          v726 = *(_OWORD *)(a1 + 144 * v16 - 96);
          v727 = v260;
          v724 = v258;
          v725 = v259;
          v261 = *(_OWORD *)(a1 + 144 * v16 - 64);
          v262 = *(__n128 *)(a1 + 144 * v16 - 48);
          v263 = *(__n128 *)(a1 + 144 * v16 - 16);
          v730 = *(_OWORD *)(a1 + 144 * v16 - 32);
          v731 = v263;
          v728 = v261;
          v729 = v262;
          *v156 = *v11;
          v264 = v11[1];
          v265 = v11[2];
          v266 = v11[4];
          *(__n128 *)(a1 + 144 * v16 - 96) = v11[3];
          *(__n128 *)(a1 + 144 * v16 - 80) = v266;
          *(__n128 *)(a1 + 144 * v16 - 128) = v264;
          *(__n128 *)(a1 + 144 * v16 - 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v265;
          v267 = v11[5];
          v268 = v11[6];
          v269 = v11[8];
          *(__n128 *)(a1 + 144 * v16 - 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v11[7];
          *(__n128 *)(a1 + 144 * v16 - 16) = v269;
          *(__n128 *)(a1 + 144 * v16 - 64) = v267;
          *(__n128 *)(a1 + 144 * v16 - 48) = v268;
        }
        *uint64_t v11 = v723;
        v270 = (__n128)v724;
        v271 = v725;
        v272 = v727;
        v11[3] = (__n128)v726;
        v11[4] = v272;
        v11[1] = v270;
        v11[2] = v271;
        v273 = (__n128)v728;
        v274 = v729;
        v275 = v731;
        v11[7] = (__n128)v730;
        v11[8] = v275;
        v11[5] = v273;
        v11[6] = v274;
      }
      else if (v158)
      {
        v723 = *v156;
        v170 = *(_OWORD *)(a1 + 144 * v16 - 128);
        v171 = *(__n128 *)(a1 + 144 * v16 - 112);
        v172 = *(__n128 *)(a1 + 144 * v16 - 80);
        v726 = *(_OWORD *)(a1 + 144 * v16 - 96);
        v727 = v172;
        v724 = v170;
        v725 = v171;
        v173 = *(_OWORD *)(a1 + 144 * v16 - 64);
        v174 = *(__n128 *)(a1 + 144 * v16 - 48);
        v175 = *(__n128 *)(a1 + 144 * v16 - 16);
        v730 = *(_OWORD *)(a1 + 144 * v16 - 32);
        v731 = v175;
        v728 = v173;
        v729 = v174;
        *v156 = *v11;
        v176 = v11[1];
        v177 = v11[2];
        v178 = v11[4];
        *(__n128 *)(a1 + 144 * v16 - 96) = v11[3];
        *(__n128 *)(a1 + 144 * v16 - 80) = v178;
        *(__n128 *)(a1 + 144 * v16 - 128) = v176;
        *(__n128 *)(a1 + 144 * v16 - 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v177;
        v179 = v11[5];
        v180 = v11[6];
        v181 = v11[8];
        *(__n128 *)(a1 + 144 * v16 - 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v11[7];
        *(__n128 *)(a1 + 144 * v16 - 16) = v181;
        *(__n128 *)(a1 + 144 * v16 - 64) = v179;
        *(__n128 *)(a1 + 144 * v16 - 48) = v180;
        *uint64_t v11 = v723;
        v182 = (__n128)v724;
        v183 = v725;
        v184 = v727;
        v11[3] = (__n128)v726;
        v11[4] = v184;
        v11[1] = v182;
        v11[2] = v183;
        v185 = (__n128)v728;
        v186 = v729;
        v187 = v731;
        v11[7] = (__n128)v730;
        v11[8] = v187;
        v11[5] = v185;
        v11[6] = v186;
        if ((*a3)((char *)(a1 + 144 * v16 - 144), (long long *)(a1 + 144)))
        {
          v188 = *(_OWORD *)(a1 + 192);
          v725 = *(__n128 *)(a1 + 176);
          v726 = v188;
          v189 = *(__n128 *)(a1 + 272);
          v190 = *(__n128 *)(a1 + 240);
          v730 = *(_OWORD *)(a1 + 256);
          v731 = v189;
          v191 = *(_OWORD *)(a1 + 224);
          v727 = *(__n128 *)(a1 + 208);
          v728 = v191;
          v729 = v190;
          v192 = *(_OWORD *)(a1 + 160);
          v723 = *v155;
          v724 = v192;
          *v155 = *v156;
          v193 = *(_OWORD *)(a1 + 144 * v16 - 128);
          v194 = *(_OWORD *)(a1 + 144 * v16 - 112);
          v195 = *(_OWORD *)(a1 + 144 * v16 - 80);
          *(_OWORD *)(a1 + 19OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_OWORD *)(a1 + 144 * v16 - 96);
          *(_OWORD *)(a1 + 208) = v195;
          *(_OWORD *)(a1 + 160) = v193;
          *(_OWORD *)(a1 + 176) = v194;
          v196 = *(_OWORD *)(a1 + 144 * v16 - 64);
          v197 = *(_OWORD *)(a1 + 144 * v16 - 48);
          v198 = *(_OWORD *)(a1 + 144 * v16 - 16);
          *(_OWORD *)(a1 + 256) = *(_OWORD *)(a1 + 144 * v16 - 32);
          *(_OWORD *)(a1 + 27OZChannelFontBase::~OZChannelFontBase(this - 2) = v198;
          *(_OWORD *)(a1 + 224) = v196;
          *(_OWORD *)(a1 + 240) = v197;
          *v156 = v723;
          v199 = v724;
          v200 = v725;
          v201 = v727;
          *(_OWORD *)(a1 + 144 * v16 - 96) = v726;
          *(__n128 *)(a1 + 144 * v16 - 80) = v201;
          *(_OWORD *)(a1 + 144 * v16 - 128) = v199;
          *(__n128 *)(a1 + 144 * v16 - 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v200;
          v202 = v728;
          v203 = v729;
          v204 = v731;
          *(_OWORD *)(a1 + 144 * v16 - 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v730;
          *(__n128 *)(a1 + 144 * v16 - 16) = v204;
          *(_OWORD *)(a1 + 144 * v16 - 64) = v202;
          *(__n128 *)(a1 + 144 * v16 - 48) = v203;
        }
      }
LABEL_38:
      v276 = (__n128 *)(a1 + 288);
      v277 = (__n128 *)(a1 + 144 * v16 + 144);
      v278 = (*a3)((char *)v277, (long long *)(a1 + 288));
      v279 = (*a3)((char *)v12, (long long *)v277);
      if (v278)
      {
        if (v279)
        {
          v280 = *(_OWORD *)(a1 + 336);
          v725 = *(__n128 *)(a1 + 320);
          v726 = v280;
          v281 = *(__n128 *)(a1 + 416);
          v282 = *(__n128 *)(a1 + 384);
          v730 = *(_OWORD *)(a1 + 400);
          v731 = v281;
          v283 = *(_OWORD *)(a1 + 368);
          v727 = *(__n128 *)(a1 + 352);
          v728 = v283;
          v729 = v282;
          v284 = *(_OWORD *)(a1 + 304);
          v723 = *v276;
          v724 = v284;
          *v276 = *v12;
          v285 = v12[1];
          v286 = v12[2];
          v287 = v12[4];
          *(__n128 *)(a1 + 336) = v12[3];
          *(__n128 *)(a1 + 35OZChannelFontBase::~OZChannelFontBase(this - 2) = v287;
          *(__n128 *)(a1 + 304) = v285;
          *(__n128 *)(a1 + 320) = v286;
          v288 = v12[5];
          v289 = v12[6];
          v290 = v12[8];
          *(__n128 *)(a1 + 400) = v12[7];
          *(__n128 *)(a1 + 416) = v290;
          *(__n128 *)(a1 + 368) = v288;
          *(__n128 *)(a1 + 384) = v289;
        }
        else
        {
          v326 = *(_OWORD *)(a1 + 336);
          v725 = *(__n128 *)(a1 + 320);
          v726 = v326;
          v327 = *(__n128 *)(a1 + 416);
          v328 = *(__n128 *)(a1 + 384);
          v730 = *(_OWORD *)(a1 + 400);
          v731 = v327;
          v329 = *(_OWORD *)(a1 + 368);
          v727 = *(__n128 *)(a1 + 352);
          v728 = v329;
          v729 = v328;
          v330 = *(_OWORD *)(a1 + 304);
          v723 = *v276;
          v724 = v330;
          *v276 = *v277;
          v331 = v277[1];
          v332 = v277[2];
          v333 = v277[4];
          *(__n128 *)(a1 + 336) = v277[3];
          *(__n128 *)(a1 + 35OZChannelFontBase::~OZChannelFontBase(this - 2) = v333;
          *(__n128 *)(a1 + 304) = v331;
          *(__n128 *)(a1 + 320) = v332;
          v334 = v277[5];
          v335 = v277[6];
          v336 = v277[8];
          *(__n128 *)(a1 + 400) = v277[7];
          *(__n128 *)(a1 + 416) = v336;
          *(__n128 *)(a1 + 368) = v334;
          *(__n128 *)(a1 + 384) = v335;
          *v277 = v723;
          v337 = (__n128)v724;
          v338 = v725;
          v339 = v727;
          v277[3] = (__n128)v726;
          v277[4] = v339;
          v277[1] = v337;
          v277[2] = v338;
          v340 = (__n128)v728;
          v341 = v729;
          v342 = v731;
          v277[7] = (__n128)v730;
          v277[8] = v342;
          v277[5] = v340;
          v277[6] = v341;
          if (!(*a3)((char *)v12, (long long *)v277)) {
            goto LABEL_47;
          }
          v723 = *v277;
          v343 = v277[1];
          v344 = v277[2];
          v345 = v277[4];
          v726 = (__int128)v277[3];
          v727 = v345;
          v724 = (__int128)v343;
          v725 = v344;
          v346 = v277[5];
          v347 = v277[6];
          v348 = v277[8];
          v730 = (__int128)v277[7];
          v731 = v348;
          v728 = (__int128)v346;
          v729 = v347;
          *v277 = *v12;
          v349 = v12[1];
          v350 = v12[2];
          v351 = v12[4];
          v277[3] = v12[3];
          v277[4] = v351;
          v277[1] = v349;
          v277[2] = v350;
          v352 = v12[5];
          v353 = v12[6];
          v354 = v12[8];
          v277[7] = v12[7];
          v277[8] = v354;
          v277[5] = v352;
          v277[6] = v353;
        }
        *uint64_t v12 = v723;
        v355 = (__n128)v724;
        v356 = v725;
        v357 = v727;
        v12[3] = (__n128)v726;
        v12[4] = v357;
        v12[1] = v355;
        v12[2] = v356;
        v358 = (__n128)v728;
        v359 = v729;
        v360 = v731;
        v12[7] = (__n128)v730;
        v12[8] = v360;
        v12[5] = v358;
        v12[6] = v359;
      }
      else if (v279)
      {
        v723 = *v277;
        v291 = v277[1];
        v292 = v277[2];
        v293 = v277[4];
        v726 = (__int128)v277[3];
        v727 = v293;
        v724 = (__int128)v291;
        v725 = v292;
        v294 = v277[5];
        v295 = v277[6];
        v296 = v277[8];
        v730 = (__int128)v277[7];
        v731 = v296;
        v728 = (__int128)v294;
        v729 = v295;
        *v277 = *v12;
        v297 = v12[1];
        v298 = v12[2];
        v299 = v12[4];
        v277[3] = v12[3];
        v277[4] = v299;
        v277[1] = v297;
        v277[2] = v298;
        v300 = v12[5];
        v301 = v12[6];
        v302 = v12[8];
        v277[7] = v12[7];
        v277[8] = v302;
        v277[5] = v300;
        v277[6] = v301;
        *uint64_t v12 = v723;
        v303 = (__n128)v724;
        v304 = v725;
        v305 = v727;
        v12[3] = (__n128)v726;
        v12[4] = v305;
        v12[1] = v303;
        v12[2] = v304;
        v306 = (__n128)v728;
        v307 = v729;
        v308 = v731;
        v12[7] = (__n128)v730;
        v12[8] = v308;
        v12[5] = v306;
        v12[6] = v307;
        if ((*a3)((char *)v277, (long long *)(a1 + 288)))
        {
          v309 = *(_OWORD *)(a1 + 336);
          v725 = *(__n128 *)(a1 + 320);
          v726 = v309;
          v310 = *(__n128 *)(a1 + 416);
          v311 = *(__n128 *)(a1 + 384);
          v730 = *(_OWORD *)(a1 + 400);
          v731 = v310;
          v312 = *(_OWORD *)(a1 + 368);
          v727 = *(__n128 *)(a1 + 352);
          v728 = v312;
          v729 = v311;
          v313 = *(_OWORD *)(a1 + 304);
          v723 = *v276;
          v724 = v313;
          *v276 = *v277;
          v314 = v277[1];
          v315 = v277[2];
          v316 = v277[4];
          *(__n128 *)(a1 + 336) = v277[3];
          *(__n128 *)(a1 + 35OZChannelFontBase::~OZChannelFontBase(this - 2) = v316;
          *(__n128 *)(a1 + 304) = v314;
          *(__n128 *)(a1 + 320) = v315;
          v317 = v277[5];
          v318 = v277[6];
          v319 = v277[8];
          *(__n128 *)(a1 + 400) = v277[7];
          *(__n128 *)(a1 + 416) = v319;
          *(__n128 *)(a1 + 368) = v317;
          *(__n128 *)(a1 + 384) = v318;
          *v277 = v723;
          v320 = (__n128)v724;
          v321 = v725;
          v322 = v727;
          v277[3] = (__n128)v726;
          v277[4] = v322;
          v277[1] = v320;
          v277[2] = v321;
          v323 = (__n128)v728;
          v324 = v729;
          v325 = v731;
          v277[7] = (__n128)v730;
          v277[8] = v325;
          v277[5] = v323;
          v277[6] = v324;
        }
      }
LABEL_47:
      v361 = (*a3)((char *)v17, (long long *)v156);
      v362 = (*a3)((char *)v277, v17);
      if (v361)
      {
        if (v362)
        {
          v723 = *v156;
          v363 = v156[1];
          v364 = v156[2];
          v365 = v156[4];
          v726 = (__int128)v156[3];
          v727 = v365;
          v724 = (__int128)v363;
          v725 = v364;
          v366 = v156[5];
          v367 = v156[6];
          v368 = v156[8];
          v730 = (__int128)v156[7];
          v731 = v368;
          v728 = (__int128)v366;
          v729 = v367;
          v369 = v277[3];
          v156[2] = v277[2];
          v156[3] = v369;
          v370 = v277[8];
          v371 = v277[6];
          v156[7] = v277[7];
          v156[8] = v370;
          v372 = v277[5];
          v156[4] = v277[4];
          v156[5] = v372;
          v156[6] = v371;
          v373 = v277[1];
          *v156 = *v277;
          v156[1] = v373;
        }
        else
        {
          v723 = *v156;
          v408 = v156[1];
          v409 = v156[2];
          v410 = v156[4];
          v726 = (__int128)v156[3];
          v727 = v410;
          v724 = (__int128)v408;
          v725 = v409;
          v411 = v156[5];
          v412 = v156[6];
          v413 = v156[8];
          v730 = (__int128)v156[7];
          v731 = v413;
          v728 = (__int128)v411;
          v729 = v412;
          v414 = v17[3];
          v156[2] = (__n128)v17[2];
          v156[3] = (__n128)v414;
          v415 = v17[8];
          v416 = v17[6];
          v156[7] = (__n128)v17[7];
          v156[8] = (__n128)v415;
          v417 = v17[5];
          v156[4] = (__n128)v17[4];
          v156[5] = (__n128)v417;
          v156[6] = (__n128)v416;
          v418 = v17[1];
          *v156 = (__n128)*v17;
          v156[1] = (__n128)v418;
          char *v17 = (__int128)v723;
          v419 = v724;
          v420 = (__int128)v725;
          v421 = (__int128)v727;
          v17[3] = v726;
          v17[4] = v421;
          v17[1] = v419;
          v17[2] = v420;
          v422 = v728;
          v423 = (__int128)v729;
          v424 = (__int128)v731;
          v17[7] = v730;
          v17[8] = v424;
          v17[5] = v422;
          v17[6] = v423;
          if (!(*a3)((char *)v277, v17)) {
            goto LABEL_56;
          }
          v723 = (__n128)*v17;
          v425 = v17[1];
          v426 = v17[2];
          v427 = v17[4];
          v726 = v17[3];
          v727 = (__n128)v427;
          v724 = v425;
          v725 = (__n128)v426;
          v428 = v17[5];
          v429 = v17[6];
          v430 = v17[8];
          v730 = v17[7];
          v731 = (__n128)v430;
          v728 = v428;
          v729 = (__n128)v429;
          v431 = (__int128)v277[3];
          v17[2] = (__int128)v277[2];
          v17[3] = v431;
          v432 = (__int128)v277[8];
          v433 = (__int128)v277[6];
          v17[7] = (__int128)v277[7];
          v17[8] = v432;
          v434 = (__int128)v277[5];
          v17[4] = (__int128)v277[4];
          v17[5] = v434;
          v17[6] = v433;
          v435 = (__int128)v277[1];
          char *v17 = (__int128)*v277;
          v17[1] = v435;
        }
        *v277 = v723;
        v436 = (__n128)v724;
        v437 = v725;
        v438 = v727;
        v277[3] = (__n128)v726;
        v277[4] = v438;
        v277[1] = v436;
        v277[2] = v437;
        v439 = (__n128)v728;
        v440 = v729;
        v441 = v731;
        v277[7] = (__n128)v730;
        v277[8] = v441;
        v277[5] = v439;
        v277[6] = v440;
      }
      else if (v362)
      {
        v723 = (__n128)*v17;
        v374 = v17[1];
        v375 = v17[2];
        v376 = v17[4];
        v726 = v17[3];
        v727 = (__n128)v376;
        v724 = v374;
        v725 = (__n128)v375;
        v377 = v17[5];
        v378 = v17[6];
        v379 = v17[8];
        v730 = v17[7];
        v731 = (__n128)v379;
        v728 = v377;
        v729 = (__n128)v378;
        v380 = (__int128)v277[3];
        v17[2] = (__int128)v277[2];
        v17[3] = v380;
        v381 = (__int128)v277[8];
        v382 = (__int128)v277[6];
        v17[7] = (__int128)v277[7];
        v17[8] = v381;
        v383 = (__int128)v277[5];
        v17[4] = (__int128)v277[4];
        v17[5] = v383;
        v17[6] = v382;
        v384 = (__int128)v277[1];
        char *v17 = (__int128)*v277;
        v17[1] = v384;
        *v277 = v723;
        v385 = (__n128)v724;
        v386 = v725;
        v387 = v727;
        v277[3] = (__n128)v726;
        v277[4] = v387;
        v277[1] = v385;
        v277[2] = v386;
        v388 = (__n128)v728;
        v389 = v729;
        v390 = v731;
        v277[7] = (__n128)v730;
        v277[8] = v390;
        v277[5] = v388;
        v277[6] = v389;
        if ((*a3)((char *)v17, (long long *)v156))
        {
          v723 = *v156;
          v391 = v156[1];
          v392 = v156[2];
          v393 = v156[4];
          v726 = (__int128)v156[3];
          v727 = v393;
          v724 = (__int128)v391;
          v725 = v392;
          v394 = v156[5];
          v395 = v156[6];
          v396 = v156[8];
          v730 = (__int128)v156[7];
          v731 = v396;
          v728 = (__int128)v394;
          v729 = v395;
          v397 = v17[3];
          v156[2] = (__n128)v17[2];
          v156[3] = (__n128)v397;
          v398 = v17[8];
          v399 = v17[6];
          v156[7] = (__n128)v17[7];
          v156[8] = (__n128)v398;
          v400 = v17[5];
          v156[4] = (__n128)v17[4];
          v156[5] = (__n128)v400;
          v156[6] = (__n128)v399;
          v401 = v17[1];
          *v156 = (__n128)*v17;
          v156[1] = (__n128)v401;
          char *v17 = (__int128)v723;
          v402 = v724;
          v403 = (__int128)v725;
          v404 = (__int128)v727;
          v17[3] = v726;
          v17[4] = v404;
          v17[1] = v402;
          v17[2] = v403;
          v405 = v728;
          v406 = (__int128)v729;
          v407 = (__int128)v731;
          v17[7] = v730;
          v17[8] = v407;
          v17[5] = v405;
          v17[6] = v406;
        }
      }
LABEL_56:
      v723 = *(__n128 *)a1;
      v442 = *(_OWORD *)(a1 + 16);
      v443 = *(__n128 *)(a1 + 32);
      v444 = *(__n128 *)(a1 + 64);
      v726 = *(_OWORD *)(a1 + 48);
      v727 = v444;
      v724 = v442;
      v725 = v443;
      v445 = *(_OWORD *)(a1 + 80);
      v446 = *(__n128 *)(a1 + 96);
      v447 = *(__n128 *)(a1 + 128);
      v730 = *(_OWORD *)(a1 + 112);
      v731 = v447;
      v728 = v445;
      v729 = v446;
      *(_OWORD *)a1 = *v17;
      v448 = v17[1];
      v449 = v17[2];
      v450 = v17[4];
      *(_OWORD *)(a1 + 48) = v17[3];
      *(_OWORD *)(a1 + 64) = v450;
      *(_OWORD *)(a1 + 16) = v448;
      *(_OWORD *)(a1 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v449;
      v451 = v17[5];
      v452 = v17[6];
      v453 = v17[8];
      *(_OWORD *)(a1 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v17[7];
      *(_OWORD *)(a1 + 128) = v453;
      *(_OWORD *)(a1 + 80) = v451;
      *(_OWORD *)(a1 + 96) = v452;
      char *v17 = (__int128)v723;
      v454 = v724;
      v455 = (__int128)v725;
      v456 = (__int128)v727;
      v17[3] = v726;
      v17[4] = v456;
      v17[1] = v454;
      v17[2] = v455;
      v457 = v728;
      v458 = (__int128)v729;
      v459 = (__int128)v731;
      v17[7] = v730;
      v17[8] = v459;
      v17[5] = v457;
      v17[6] = v458;
      a2 = v711;
      --a4;
      if ((a5 & 1) == 0) {
        goto LABEL_57;
      }
LABEL_58:
      v460 = 0;
      v714 = *(__n128 *)a1;
      v461 = *(__n128 *)(a1 + 16);
      v462 = *(__n128 *)(a1 + 32);
      v463 = *(__n128 *)(a1 + 64);
      v717 = *(__n128 *)(a1 + 48);
      v718 = v463;
      v715 = v461;
      v716 = v462;
      v464 = *(__n128 *)(a1 + 80);
      v465 = *(__n128 *)(a1 + 96);
      v466 = *(__n128 *)(a1 + 128);
      v721 = *(__n128 *)(a1 + 112);
      v722 = v466;
      v719 = v464;
      v720 = v465;
      do
        v460 += 144;
      while ((((uint64_t (*)(unint64_t, __n128 *))*a3)(v460 + a1, &v714) & 1) != 0);
      v467 = a1 + v460;
      v468 = a2;
      if (v460 == 144)
      {
        v468 = a2;
        do
        {
          if (v467 >= (unint64_t)v468) {
            break;
          }
          v468 -= 9;
        }
        while ((((uint64_t (*)(__n128 *, __n128 *))*a3)(v468, &v714) & 1) == 0);
      }
      else
      {
        do
          v468 -= 9;
        while (!(*a3)((char *)v468, (long long *)&v714));
      }
      if (v467 >= (unint64_t)v468)
      {
        v489 = (__n128 *)(v467 - 144);
        if (v467 - 144 == a1) {
          goto LABEL_76;
        }
LABEL_75:
        *(__n128 *)a1 = *v489;
        v490 = v489[1];
        v491 = v489[2];
        v492 = v489[4];
        *(__n128 *)(a1 + 48) = v489[3];
        *(__n128 *)(a1 + 64) = v492;
        *(__n128 *)(a1 + 16) = v490;
        *(__n128 *)(a1 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v491;
        v493 = v489[5];
        v494 = v489[6];
        v495 = v489[8];
        *(__n128 *)(a1 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v489[7];
        *(__n128 *)(a1 + 128) = v495;
        *(__n128 *)(a1 + 80) = v493;
        *(__n128 *)(a1 + 96) = v494;
        goto LABEL_76;
      }
      v469 = (__n128 *)(a1 + v460);
      v470 = v468;
      do
      {
        v723 = *v469;
        v471 = v469[1];
        v472 = v469[2];
        v473 = v469[4];
        v726 = (__int128)v469[3];
        v727 = v473;
        v724 = (__int128)v471;
        v725 = v472;
        v474 = v469[5];
        v475 = v469[6];
        v476 = v469[8];
        v730 = (__int128)v469[7];
        v731 = v476;
        v728 = (__int128)v474;
        v729 = v475;
        *v469 = *v470;
        v477 = v470[1];
        v478 = v470[2];
        v479 = v470[4];
        v469[3] = v470[3];
        v469[4] = v479;
        v469[1] = v477;
        v469[2] = v478;
        v480 = v470[5];
        v481 = v470[6];
        v482 = v470[8];
        v469[7] = v470[7];
        v469[8] = v482;
        v469[5] = v480;
        v469[6] = v481;
        *v470 = v723;
        v483 = (__n128)v724;
        v484 = v725;
        v485 = v727;
        v470[3] = (__n128)v726;
        v470[4] = v485;
        v470[1] = v483;
        v470[2] = v484;
        v486 = (__n128)v728;
        v487 = v729;
        v488 = v731;
        v470[7] = (__n128)v730;
        v470[8] = v488;
        v470[5] = v486;
        v470[6] = v487;
        do
          v469 += 9;
        while ((((uint64_t (*)(__n128 *, __n128 *))*a3)(v469, &v714) & 1) != 0);
        do
          v470 -= 9;
        while (!(*a3)((char *)v470, (long long *)&v714));
      }
      while (v469 < v470);
      v489 = v469 - 9;
      if (&v469[-9] != (__n128 *)a1) {
        goto LABEL_75;
      }
LABEL_76:
      *v489 = v714;
      v496 = v715;
      v497 = v716;
      v498 = v718;
      v489[3] = v717;
      v489[4] = v498;
      v489[1] = v496;
      v489[2] = v497;
      v499 = v719;
      v500 = v720;
      v501 = v722;
      v489[7] = v721;
      v489[8] = v501;
      v489[5] = v499;
      v489[6] = v500;
      if (v467 < (unint64_t)v468) {
        goto LABEL_79;
      }
      v502 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*>((__n128 *)a1, v489, (uint64_t (**)(__n128 *, __n128 *))a3);
      n128_u64 = (unint64_t)v489[9].n128_u64;
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*>(v489 + 9, a2, (uint64_t (**)(__n128 *, __n128 *))a3))
      {
        a2 = v489;
        if (v502) {
          return;
        }
        goto LABEL_1;
      }
      if (!v502)
      {
LABEL_79:
        std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*,false>(a1, v489, a3, a4, a5 & 1);
        a5 = 0;
        n128_u64 = (unint64_t)v489[9].n128_u64;
      }
    }
    else
    {
      long long v33 = v18((char *)n128_u64, (long long *)(n128_u64 + 144 * (v15 >> 1)));
      long long v34 = (*a3)((char *)v10, (long long *)n128_u64);
      if (v33)
      {
        if (v34)
        {
          v723 = (__n128)*v17;
          long long v35 = v17[1];
          long long v36 = v17[2];
          long long v37 = v17[4];
          v726 = v17[3];
          v727 = (__n128)v37;
          v724 = v35;
          v725 = (__n128)v36;
          v38 = v17[5];
          v39 = v17[6];
          v40 = v17[8];
          v730 = v17[7];
          v731 = (__n128)v40;
          v728 = v38;
          v729 = (__n128)v39;
          char *v17 = (__int128)*v10;
          v41 = (__int128)v10[1];
          long long v42 = (__int128)v10[2];
          v43 = (__int128)v10[4];
          v17[3] = (__int128)v10[3];
          v17[4] = v43;
          v17[1] = v41;
          v17[2] = v42;
          v44 = (__int128)v10[5];
          v45 = (__int128)v10[6];
          v46 = (__int128)v10[8];
          v17[7] = (__int128)v10[7];
          v17[8] = v46;
          v17[5] = v44;
          v17[6] = v45;
          goto LABEL_32;
        }
        v723 = (__n128)*v17;
        v205 = v17[1];
        v206 = v17[2];
        v207 = v17[4];
        v726 = v17[3];
        v727 = (__n128)v207;
        v724 = v205;
        v725 = (__n128)v206;
        v208 = v17[5];
        v209 = v17[6];
        v210 = v17[8];
        v730 = v17[7];
        v731 = (__n128)v210;
        v728 = v208;
        v729 = (__n128)v209;
        char *v17 = *(_OWORD *)n128_u64;
        v211 = *(_OWORD *)(n128_u64 + 16);
        v212 = *(_OWORD *)(n128_u64 + 32);
        v213 = *(_OWORD *)(n128_u64 + 64);
        v17[3] = *(_OWORD *)(n128_u64 + 48);
        v17[4] = v213;
        v17[1] = v211;
        v17[2] = v212;
        v214 = *(_OWORD *)(n128_u64 + 80);
        v215 = *(_OWORD *)(n128_u64 + 96);
        v216 = *(_OWORD *)(n128_u64 + 128);
        v17[7] = *(_OWORD *)(n128_u64 + 112);
        v17[8] = v216;
        v17[5] = v214;
        v17[6] = v215;
        *(__n128 *)n128_u64 = v723;
        v217 = v724;
        v218 = v725;
        v219 = v727;
        *(_OWORD *)(n128_u64 + 48) = v726;
        *(__n128 *)(n128_u64 + 64) = v219;
        *(_OWORD *)(n128_u64 + 16) = v217;
        *(__n128 *)(n128_u64 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v218;
        v220 = v728;
        v221 = v729;
        v222 = v731;
        *(_OWORD *)(n128_u64 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v730;
        *(__n128 *)(n128_u64 + 128) = v222;
        *(_OWORD *)(n128_u64 + 80) = v220;
        *(__n128 *)(n128_u64 + 96) = v221;
        if ((*a3)((char *)v10, (long long *)n128_u64))
        {
          v723 = *(__n128 *)n128_u64;
          v223 = *(_OWORD *)(n128_u64 + 16);
          v224 = *(__n128 *)(n128_u64 + 32);
          v225 = *(__n128 *)(n128_u64 + 64);
          v726 = *(_OWORD *)(n128_u64 + 48);
          v727 = v225;
          v724 = v223;
          v725 = v224;
          v226 = *(_OWORD *)(n128_u64 + 80);
          v227 = *(__n128 *)(n128_u64 + 96);
          v228 = *(__n128 *)(n128_u64 + 128);
          v730 = *(_OWORD *)(n128_u64 + 112);
          v731 = v228;
          v728 = v226;
          v729 = v227;
          *(__n128 *)n128_u64 = *v10;
          v229 = v10[1];
          v230 = v10[2];
          v231 = v10[4];
          *(__n128 *)(n128_u64 + 48) = v10[3];
          *(__n128 *)(n128_u64 + 64) = v231;
          *(__n128 *)(n128_u64 + 16) = v229;
          *(__n128 *)(n128_u64 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v230;
          v232 = v10[5];
          v233 = v10[6];
          v234 = v10[8];
          *(__n128 *)(n128_u64 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v10[7];
          *(__n128 *)(n128_u64 + 128) = v234;
          *(__n128 *)(n128_u64 + 80) = v232;
          *(__n128 *)(n128_u64 + 96) = v233;
LABEL_32:
          *uint64_t v10 = v723;
          v235 = (__n128)v724;
          v236 = v725;
          v237 = v727;
          v10[3] = (__n128)v726;
          v10[4] = v237;
          v10[1] = v235;
          v10[2] = v236;
          v238 = (__n128)v728;
          v239 = v729;
          v240 = v731;
          v10[7] = (__n128)v730;
          v10[8] = v240;
          v10[5] = v238;
          v10[6] = v239;
        }
LABEL_33:
        --a4;
        if (a5) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }
      if (!v34) {
        goto LABEL_33;
      }
      v723 = *(__n128 *)n128_u64;
      v83 = *(_OWORD *)(n128_u64 + 16);
      v84 = *(__n128 *)(n128_u64 + 32);
      v85 = *(__n128 *)(n128_u64 + 64);
      v726 = *(_OWORD *)(n128_u64 + 48);
      v727 = v85;
      v724 = v83;
      v725 = v84;
      v86 = *(_OWORD *)(n128_u64 + 80);
      v87 = *(__n128 *)(n128_u64 + 96);
      v88 = *(__n128 *)(n128_u64 + 128);
      v730 = *(_OWORD *)(n128_u64 + 112);
      v731 = v88;
      v728 = v86;
      v729 = v87;
      *(__n128 *)n128_u64 = *v10;
      v89 = v10[1];
      v90 = v10[2];
      v91 = v10[4];
      *(__n128 *)(n128_u64 + 48) = v10[3];
      *(__n128 *)(n128_u64 + 64) = v91;
      *(__n128 *)(n128_u64 + 16) = v89;
      *(__n128 *)(n128_u64 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v90;
      v92 = v10[5];
      v93 = v10[6];
      v94 = v10[8];
      *(__n128 *)(n128_u64 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v10[7];
      *(__n128 *)(n128_u64 + 128) = v94;
      *(__n128 *)(n128_u64 + 80) = v92;
      *(__n128 *)(n128_u64 + 96) = v93;
      *uint64_t v10 = v723;
      v95 = (__n128)v724;
      v96 = v725;
      v97 = v727;
      v10[3] = (__n128)v726;
      v10[4] = v97;
      v10[1] = v95;
      v10[2] = v96;
      v98 = (__n128)v728;
      v99 = v729;
      v100 = v731;
      v10[7] = (__n128)v730;
      v10[8] = v100;
      v10[5] = v98;
      v10[6] = v99;
      if (!(*a3)((char *)n128_u64, v17)) {
        goto LABEL_33;
      }
      v723 = (__n128)*v17;
      v101 = v17[1];
      v102 = v17[2];
      v103 = v17[4];
      v726 = v17[3];
      v727 = (__n128)v103;
      v724 = v101;
      v725 = (__n128)v102;
      v104 = v17[5];
      v105 = v17[6];
      v106 = v17[8];
      v730 = v17[7];
      v731 = (__n128)v106;
      v728 = v104;
      v729 = (__n128)v105;
      char *v17 = *(_OWORD *)n128_u64;
      v107 = *(_OWORD *)(n128_u64 + 16);
      v108 = *(_OWORD *)(n128_u64 + 32);
      v109 = *(_OWORD *)(n128_u64 + 64);
      v17[3] = *(_OWORD *)(n128_u64 + 48);
      v17[4] = v109;
      v17[1] = v107;
      v17[2] = v108;
      v110 = *(_OWORD *)(n128_u64 + 80);
      v111 = *(_OWORD *)(n128_u64 + 96);
      v112 = *(_OWORD *)(n128_u64 + 128);
      v17[7] = *(_OWORD *)(n128_u64 + 112);
      v17[8] = v112;
      v17[5] = v110;
      v17[6] = v111;
      *(__n128 *)n128_u64 = v723;
      v113 = v724;
      v114 = v725;
      v115 = v727;
      *(_OWORD *)(n128_u64 + 48) = v726;
      *(__n128 *)(n128_u64 + 64) = v115;
      *(_OWORD *)(n128_u64 + 16) = v113;
      *(__n128 *)(n128_u64 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v114;
      v116 = v728;
      v117 = v729;
      v118 = v731;
      *(_OWORD *)(n128_u64 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v730;
      *(__n128 *)(n128_u64 + 128) = v118;
      *(_OWORD *)(n128_u64 + 80) = v116;
      *(__n128 *)(n128_u64 + 96) = v117;
      --a4;
      if (a5) {
        goto LABEL_58;
      }
LABEL_57:
      if (((uint64_t (*)(unint64_t, unint64_t))*a3)(a1 - 144, a1)) {
        goto LABEL_58;
      }
      v714 = *(__n128 *)a1;
      v503 = *(__n128 *)(a1 + 16);
      v504 = *(__n128 *)(a1 + 32);
      v505 = *(__n128 *)(a1 + 64);
      v717 = *(__n128 *)(a1 + 48);
      v718 = v505;
      v715 = v503;
      v716 = v504;
      v506 = *(__n128 *)(a1 + 80);
      v507 = *(__n128 *)(a1 + 96);
      v508 = *(__n128 *)(a1 + 128);
      v721 = *(__n128 *)(a1 + 112);
      v722 = v508;
      v719 = v506;
      v720 = v507;
      if (((uint64_t (*)(__n128 *, __n128 *))*a3)(&v714, v10))
      {
        n128_u64 = a1;
        do
          n128_u64 += 144;
        while ((((uint64_t (*)(__n128 *, unint64_t))*a3)(&v714, n128_u64) & 1) == 0);
      }
      else
      {
        v509 = (long long *)(a1 + 144);
        do
        {
          n128_u64 = (unint64_t)v509;
          if (v509 >= (long long *)a2) {
            break;
          }
          v510 = (*a3)((char *)&v714, v509);
          v509 = (long long *)(n128_u64 + 144);
        }
        while (!v510);
      }
      v511 = a2;
      if (n128_u64 < (unint64_t)a2)
      {
        v511 = a2;
        do
          v511 -= 9;
        while ((((uint64_t (*)(__n128 *, __n128 *))*a3)(&v714, v511) & 1) != 0);
      }
      while (n128_u64 < (unint64_t)v511)
      {
        v723 = *(__n128 *)n128_u64;
        v512 = *(_OWORD *)(n128_u64 + 16);
        v513 = *(__n128 *)(n128_u64 + 32);
        v514 = *(__n128 *)(n128_u64 + 64);
        v726 = *(_OWORD *)(n128_u64 + 48);
        v727 = v514;
        v724 = v512;
        v725 = v513;
        v515 = *(_OWORD *)(n128_u64 + 80);
        v516 = *(__n128 *)(n128_u64 + 96);
        v517 = *(__n128 *)(n128_u64 + 128);
        v730 = *(_OWORD *)(n128_u64 + 112);
        v731 = v517;
        v728 = v515;
        v729 = v516;
        *(__n128 *)n128_u64 = *v511;
        v518 = v511[1];
        v519 = v511[2];
        v520 = v511[4];
        *(__n128 *)(n128_u64 + 48) = v511[3];
        *(__n128 *)(n128_u64 + 64) = v520;
        *(__n128 *)(n128_u64 + 16) = v518;
        *(__n128 *)(n128_u64 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v519;
        v521 = v511[5];
        v522 = v511[6];
        v523 = v511[8];
        *(__n128 *)(n128_u64 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v511[7];
        *(__n128 *)(n128_u64 + 128) = v523;
        *(__n128 *)(n128_u64 + 80) = v521;
        *(__n128 *)(n128_u64 + 96) = v522;
        *v511 = v723;
        v524 = (__n128)v724;
        v525 = v725;
        v526 = v727;
        v511[3] = (__n128)v726;
        v511[4] = v526;
        v511[1] = v524;
        v511[2] = v525;
        v527 = (__n128)v728;
        v528 = v729;
        v529 = v731;
        v511[7] = (__n128)v730;
        v511[8] = v529;
        v511[5] = v527;
        v511[6] = v528;
        do
          n128_u64 += 144;
        while (!(*a3)((char *)&v714, (long long *)n128_u64));
        do
          v511 -= 9;
        while ((((uint64_t (*)(__n128 *, __n128 *))*a3)(&v714, v511) & 1) != 0);
      }
      v530 = (__n128 *)(n128_u64 - 144);
      char v5 = n128_u64 - 144 >= a1;
      char v6 = n128_u64 - 144 == a1;
      if (n128_u64 - 144 != a1)
      {
        *(__n128 *)a1 = *v530;
        v531 = *(_OWORD *)(n128_u64 - 128);
        v532 = *(_OWORD *)(n128_u64 - 112);
        v533 = *(_OWORD *)(n128_u64 - 80);
        *(_OWORD *)(a1 + 48) = *(_OWORD *)(n128_u64 - 96);
        *(_OWORD *)(a1 + 64) = v533;
        *(_OWORD *)(a1 + 16) = v531;
        *(_OWORD *)(a1 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v532;
        v534 = *(_OWORD *)(n128_u64 - 64);
        v535 = *(_OWORD *)(n128_u64 - 48);
        v536 = *(_OWORD *)(n128_u64 - 16);
        *(_OWORD *)(a1 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_OWORD *)(n128_u64 - 32);
        *(_OWORD *)(a1 + 128) = v536;
        *(_OWORD *)(a1 + 80) = v534;
        *(_OWORD *)(a1 + 96) = v535;
      }
      a5 = 0;
      *v530 = v714;
      v537 = v715;
      v538 = v716;
      v539 = v718;
      *(__n128 *)(n128_u64 - 96) = v717;
      *(__n128 *)(n128_u64 - 80) = v539;
      *(__n128 *)(n128_u64 - 128) = v537;
      *(__n128 *)(n128_u64 - 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v538;
      v540 = v719;
      v541 = v720;
      v542 = v722;
      *(__n128 *)(n128_u64 - 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v721;
      *(__n128 *)(n128_u64 - 16) = v542;
      *(__n128 *)(n128_u64 - 64) = v540;
      *(__n128 *)(n128_u64 - 48) = v541;
    }
  }
  switch(v15)
  {
    case 0uLL:
    case 1uLL:
      return;
    case 2uLL:
      if (!(*a3)((char *)v10, (long long *)n128_u64)) {
        return;
      }
      goto LABEL_105;
    case 3uLL:
      v543 = (__n128 *)(n128_u64 + 144);
      v544 = (*a3)((char *)(n128_u64 + 144), (long long *)n128_u64);
      v545 = (*a3)((char *)v10, (long long *)(n128_u64 + 144));
      if (v544)
      {
        if (v545)
        {
LABEL_105:
          v723 = *(__n128 *)n128_u64;
          v546 = *(_OWORD *)(n128_u64 + 16);
          v547 = *(__n128 *)(n128_u64 + 32);
          v548 = *(__n128 *)(n128_u64 + 64);
          v726 = *(_OWORD *)(n128_u64 + 48);
          v727 = v548;
          v724 = v546;
          v725 = v547;
          v549 = *(_OWORD *)(n128_u64 + 80);
          v550 = *(__n128 *)(n128_u64 + 96);
          v551 = *(__n128 *)(n128_u64 + 128);
          v730 = *(_OWORD *)(n128_u64 + 112);
          v731 = v551;
          v728 = v549;
          v729 = v550;
          *(__n128 *)n128_u64 = *v10;
          v552 = v10[1];
          v553 = v10[2];
          v554 = v10[4];
          *(__n128 *)(n128_u64 + 48) = v10[3];
          *(__n128 *)(n128_u64 + 64) = v554;
          *(__n128 *)(n128_u64 + 16) = v552;
          *(__n128 *)(n128_u64 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v553;
          v555 = v10[5];
          v556 = v10[6];
          v557 = v10[8];
          *(__n128 *)(n128_u64 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v10[7];
          *(__n128 *)(n128_u64 + 128) = v557;
          *(__n128 *)(n128_u64 + 80) = v555;
          *(__n128 *)(n128_u64 + 96) = v556;
        }
        else
        {
          v723 = *(__n128 *)n128_u64;
          v685 = *(_OWORD *)(n128_u64 + 16);
          v686 = *(__n128 *)(n128_u64 + 32);
          v687 = *(__n128 *)(n128_u64 + 64);
          v726 = *(_OWORD *)(n128_u64 + 48);
          v727 = v687;
          v724 = v685;
          v725 = v686;
          v688 = *(_OWORD *)(n128_u64 + 80);
          v689 = *(__n128 *)(n128_u64 + 96);
          v690 = *(__n128 *)(n128_u64 + 128);
          v730 = *(_OWORD *)(n128_u64 + 112);
          v731 = v690;
          v728 = v688;
          v729 = v689;
          v691 = *(_OWORD *)(n128_u64 + 192);
          *(_OWORD *)(n128_u64 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_OWORD *)(n128_u64 + 176);
          *(_OWORD *)(n128_u64 + 48) = v691;
          v692 = *(_OWORD *)(n128_u64 + 272);
          v693 = *(_OWORD *)(n128_u64 + 240);
          *(_OWORD *)(n128_u64 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_OWORD *)(n128_u64 + 256);
          *(_OWORD *)(n128_u64 + 128) = v692;
          v694 = *(_OWORD *)(n128_u64 + 224);
          *(_OWORD *)(n128_u64 + 64) = *(_OWORD *)(n128_u64 + 208);
          *(_OWORD *)(n128_u64 + 80) = v694;
          *(_OWORD *)(n128_u64 + 96) = v693;
          v695 = *(_OWORD *)(n128_u64 + 160);
          *(__n128 *)n128_u64 = *v543;
          *(_OWORD *)(n128_u64 + 16) = v695;
          v696 = v730;
          *(__n128 *)(n128_u64 + 240) = v729;
          *(_OWORD *)(n128_u64 + 256) = v696;
          *(__n128 *)(n128_u64 + 27OZChannelFontBase::~OZChannelFontBase(this - 2) = v731;
          v697 = v726;
          *(__n128 *)(n128_u64 + 176) = v725;
          *(_OWORD *)(n128_u64 + 19OZChannelFontBase::~OZChannelFontBase(this - 2) = v697;
          v698 = v728;
          *(__n128 *)(n128_u64 + 208) = v727;
          *(_OWORD *)(n128_u64 + 224) = v698;
          v699 = v724;
          *v543 = v723;
          *(_OWORD *)(n128_u64 + 160) = v699;
          if (!(*a3)((char *)v10, (long long *)(n128_u64 + 144))) {
            return;
          }
          v700 = *(_OWORD *)(n128_u64 + 192);
          v725 = *(__n128 *)(n128_u64 + 176);
          v726 = v700;
          v701 = *(__n128 *)(n128_u64 + 272);
          v702 = *(__n128 *)(n128_u64 + 240);
          v730 = *(_OWORD *)(n128_u64 + 256);
          v731 = v701;
          v703 = *(_OWORD *)(n128_u64 + 224);
          v727 = *(__n128 *)(n128_u64 + 208);
          v728 = v703;
          v729 = v702;
          v704 = *(_OWORD *)(n128_u64 + 160);
          v723 = *v543;
          v724 = v704;
          *v543 = *v10;
          v705 = v10[1];
          v706 = v10[2];
          v707 = v10[4];
          *(__n128 *)(n128_u64 + 19OZChannelFontBase::~OZChannelFontBase(this - 2) = v10[3];
          *(__n128 *)(n128_u64 + 208) = v707;
          *(__n128 *)(n128_u64 + 160) = v705;
          *(__n128 *)(n128_u64 + 176) = v706;
          v708 = v10[5];
          v709 = v10[6];
          v710 = v10[8];
          *(__n128 *)(n128_u64 + 256) = v10[7];
          *(__n128 *)(n128_u64 + 27OZChannelFontBase::~OZChannelFontBase(this - 2) = v710;
          *(__n128 *)(n128_u64 + 224) = v708;
          *(__n128 *)(n128_u64 + 240) = v709;
        }
        *uint64_t v10 = v723;
        v558 = (__n128)v724;
        v559 = v725;
        v560 = v727;
        v10[3] = (__n128)v726;
        v10[4] = v560;
        v10[1] = v558;
        v10[2] = v559;
        v561 = (__n128)v728;
        v562 = v729;
        v563 = v731;
        v10[7] = (__n128)v730;
        v10[8] = v563;
        v10[5] = v561;
        v10[6] = v562;
        return;
      }
      if (v545)
      {
        v633 = *(_OWORD *)(n128_u64 + 192);
        v725 = *(__n128 *)(n128_u64 + 176);
        v726 = v633;
        v634 = *(__n128 *)(n128_u64 + 272);
        v635 = *(__n128 *)(n128_u64 + 240);
        v730 = *(_OWORD *)(n128_u64 + 256);
        v731 = v634;
        v636 = *(_OWORD *)(n128_u64 + 224);
        v727 = *(__n128 *)(n128_u64 + 208);
        v728 = v636;
        v729 = v635;
        v637 = *(_OWORD *)(n128_u64 + 160);
        v723 = *v543;
        v724 = v637;
        *v543 = *v10;
        v638 = v10[1];
        v639 = v10[2];
        v640 = v10[4];
        *(__n128 *)(n128_u64 + 19OZChannelFontBase::~OZChannelFontBase(this - 2) = v10[3];
        *(__n128 *)(n128_u64 + 208) = v640;
        *(__n128 *)(n128_u64 + 160) = v638;
        *(__n128 *)(n128_u64 + 176) = v639;
        v641 = v10[5];
        v642 = v10[6];
        v643 = v10[8];
        *(__n128 *)(n128_u64 + 256) = v10[7];
        *(__n128 *)(n128_u64 + 27OZChannelFontBase::~OZChannelFontBase(this - 2) = v643;
        *(__n128 *)(n128_u64 + 224) = v641;
        *(__n128 *)(n128_u64 + 240) = v642;
        *uint64_t v10 = v723;
        v644 = (__n128)v724;
        v645 = v725;
        v646 = v727;
        v10[3] = (__n128)v726;
        v10[4] = v646;
        v10[1] = v644;
        v10[2] = v645;
        v647 = (__n128)v728;
        v648 = v729;
        v649 = v731;
        v10[7] = (__n128)v730;
        v10[8] = v649;
        v10[5] = v647;
        v10[6] = v648;
LABEL_133:
        if ((*a3)((char *)v543, (long long *)n128_u64))
        {
          v723 = *(__n128 *)n128_u64;
          v650 = *(_OWORD *)(n128_u64 + 16);
          v651 = *(__n128 *)(n128_u64 + 32);
          v652 = *(__n128 *)(n128_u64 + 64);
          v726 = *(_OWORD *)(n128_u64 + 48);
          v727 = v652;
          v724 = v650;
          v725 = v651;
          v653 = *(_OWORD *)(n128_u64 + 80);
          v654 = *(__n128 *)(n128_u64 + 96);
          v655 = *(__n128 *)(n128_u64 + 128);
          v730 = *(_OWORD *)(n128_u64 + 112);
          v731 = v655;
          v728 = v653;
          v729 = v654;
          v656 = v543[3];
          *(__n128 *)(n128_u64 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v543[2];
          *(__n128 *)(n128_u64 + 48) = v656;
          v657 = v543[8];
          v658 = v543[6];
          *(__n128 *)(n128_u64 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v543[7];
          *(__n128 *)(n128_u64 + 128) = v657;
          v659 = v543[5];
          *(__n128 *)(n128_u64 + 64) = v543[4];
          *(__n128 *)(n128_u64 + 80) = v659;
          *(__n128 *)(n128_u64 + 96) = v658;
          v660 = v543[1];
          *(__n128 *)n128_u64 = *v543;
          *(__n128 *)(n128_u64 + 16) = v660;
          v661 = (__n128)v730;
          v543[6] = v729;
          v543[7] = v661;
          v543[8] = v731;
          v662 = (__n128)v726;
          v543[2] = v725;
          v543[3] = v662;
          v663 = (__n128)v728;
          v543[4] = v727;
          v543[5] = v663;
          v664 = (__n128)v724;
          *v543 = v723;
          v543[1] = v664;
        }
      }
      break;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*>((__n128 *)n128_u64, (__n128 *)(n128_u64 + 144), (__n128 *)(n128_u64 + 288), v10, (uint64_t (**)(__n128 *, __n128 *))a3);
      return;
    case 5uLL:
      v543 = (__n128 *)(n128_u64 + 144);
      v564 = (__n128 *)(n128_u64 + 288);
      v565 = (__n128 *)(n128_u64 + 432);
      v566 = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*>((__n128 *)n128_u64, (__n128 *)(n128_u64 + 144), (__n128 *)(n128_u64 + 288), (__n128 *)(n128_u64 + 432), (uint64_t (**)(__n128 *, __n128 *))a3);
      if (!((unsigned int (*)(__n128 *, unint64_t, __n128))*a3)(v10, n128_u64 + 432, v566)) {
        return;
      }
      v567 = *(_OWORD *)(n128_u64 + 480);
      v725 = *(__n128 *)(n128_u64 + 464);
      v726 = v567;
      v568 = *(__n128 *)(n128_u64 + 560);
      v569 = *(__n128 *)(n128_u64 + 528);
      v730 = *(_OWORD *)(n128_u64 + 544);
      v731 = v568;
      v570 = *(_OWORD *)(n128_u64 + 512);
      v727 = *(__n128 *)(n128_u64 + 496);
      v728 = v570;
      v729 = v569;
      v571 = *(_OWORD *)(n128_u64 + 448);
      v723 = *v565;
      v724 = v571;
      *v565 = *v10;
      v572 = v10[1];
      v573 = v10[2];
      v574 = v10[4];
      *(__n128 *)(n128_u64 + 480) = v10[3];
      *(__n128 *)(n128_u64 + 496) = v574;
      *(__n128 *)(n128_u64 + 448) = v572;
      *(__n128 *)(n128_u64 + 464) = v573;
      v575 = v10[5];
      v576 = v10[6];
      v577 = v10[8];
      *(__n128 *)(n128_u64 + 544) = v10[7];
      *(__n128 *)(n128_u64 + 560) = v577;
      *(__n128 *)(n128_u64 + 51OZChannelFontBase::~OZChannelFontBase(this - 2) = v575;
      *(__n128 *)(n128_u64 + 528) = v576;
      *uint64_t v10 = v723;
      v578 = (__n128)v724;
      v579 = v725;
      v580 = v727;
      v10[3] = (__n128)v726;
      v10[4] = v580;
      v10[1] = v578;
      v10[2] = v579;
      v581 = (__n128)v728;
      v582 = v729;
      v583 = v731;
      v10[7] = (__n128)v730;
      v10[8] = v583;
      v10[5] = v581;
      v10[6] = v582;
      if (!(*a3)((char *)(n128_u64 + 432), (long long *)(n128_u64 + 288))) {
        return;
      }
      v584 = *(_OWORD *)(n128_u64 + 400);
      v729 = *(__n128 *)(n128_u64 + 384);
      v730 = v584;
      v731 = *(__n128 *)(n128_u64 + 416);
      v585 = *(_OWORD *)(n128_u64 + 336);
      v725 = *(__n128 *)(n128_u64 + 320);
      v726 = v585;
      v586 = *(_OWORD *)(n128_u64 + 368);
      v727 = *(__n128 *)(n128_u64 + 352);
      v728 = v586;
      v587 = *(_OWORD *)(n128_u64 + 304);
      v723 = *v564;
      v724 = v587;
      v588 = *(_OWORD *)(n128_u64 + 512);
      *(_OWORD *)(n128_u64 + 35OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_OWORD *)(n128_u64 + 496);
      *(_OWORD *)(n128_u64 + 368) = v588;
      v589 = *(_OWORD *)(n128_u64 + 544);
      *(_OWORD *)(n128_u64 + 384) = *(_OWORD *)(n128_u64 + 528);
      *(_OWORD *)(n128_u64 + 400) = v589;
      *(_OWORD *)(n128_u64 + 416) = *(_OWORD *)(n128_u64 + 560);
      v590 = *(_OWORD *)(n128_u64 + 480);
      *(_OWORD *)(n128_u64 + 320) = *(_OWORD *)(n128_u64 + 464);
      *(_OWORD *)(n128_u64 + 336) = v590;
      v591 = *(_OWORD *)(n128_u64 + 448);
      *v564 = *v565;
      *(_OWORD *)(n128_u64 + 304) = v591;
      v592 = v728;
      *(__n128 *)(n128_u64 + 496) = v727;
      *(_OWORD *)(n128_u64 + 51OZChannelFontBase::~OZChannelFontBase(this - 2) = v592;
      v593 = v730;
      *(__n128 *)(n128_u64 + 528) = v729;
      *(_OWORD *)(n128_u64 + 544) = v593;
      *(__n128 *)(n128_u64 + 560) = v731;
      v594 = v726;
      *(__n128 *)(n128_u64 + 464) = v725;
      *(_OWORD *)(n128_u64 + 480) = v594;
      v595 = v724;
      *v565 = v723;
      *(_OWORD *)(n128_u64 + 448) = v595;
      if (!(*a3)((char *)(n128_u64 + 288), (long long *)(n128_u64 + 144))) {
        return;
      }
      v596 = *(_OWORD *)(n128_u64 + 256);
      v729 = *(__n128 *)(n128_u64 + 240);
      v730 = v596;
      v731 = *(__n128 *)(n128_u64 + 272);
      v597 = *(_OWORD *)(n128_u64 + 192);
      v725 = *(__n128 *)(n128_u64 + 176);
      v726 = v597;
      v598 = *(_OWORD *)(n128_u64 + 224);
      v727 = *(__n128 *)(n128_u64 + 208);
      v728 = v598;
      v599 = *(_OWORD *)(n128_u64 + 160);
      v723 = *v543;
      v724 = v599;
      v600 = *(_OWORD *)(n128_u64 + 368);
      *(_OWORD *)(n128_u64 + 208) = *(_OWORD *)(n128_u64 + 352);
      *(_OWORD *)(n128_u64 + 224) = v600;
      v601 = *(_OWORD *)(n128_u64 + 400);
      *(_OWORD *)(n128_u64 + 240) = *(_OWORD *)(n128_u64 + 384);
      *(_OWORD *)(n128_u64 + 256) = v601;
      *(_OWORD *)(n128_u64 + 27OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_OWORD *)(n128_u64 + 416);
      v602 = *(_OWORD *)(n128_u64 + 336);
      *(_OWORD *)(n128_u64 + 176) = *(_OWORD *)(n128_u64 + 320);
      *(_OWORD *)(n128_u64 + 19OZChannelFontBase::~OZChannelFontBase(this - 2) = v602;
      v603 = *(_OWORD *)(n128_u64 + 304);
      *v543 = *v564;
      *(_OWORD *)(n128_u64 + 160) = v603;
      v604 = v728;
      *(__n128 *)(n128_u64 + 35OZChannelFontBase::~OZChannelFontBase(this - 2) = v727;
      *(_OWORD *)(n128_u64 + 368) = v604;
      v605 = v730;
      *(__n128 *)(n128_u64 + 384) = v729;
      *(_OWORD *)(n128_u64 + 400) = v605;
      *(__n128 *)(n128_u64 + 416) = v731;
      v606 = v726;
      *(__n128 *)(n128_u64 + 320) = v725;
      *(_OWORD *)(n128_u64 + 336) = v606;
      v607 = v724;
      *v564 = v723;
      *(_OWORD *)(n128_u64 + 304) = v607;
      goto LABEL_133;
    default:
      JUMPOUT(0);
  }
}

  uint64_t v10 = (const void ***)(a2 - 16);
  v97 = a2 - 32;
  v98 = (const void ***)a2;
  uint64_t v11 = a2 - 48;
  uint64_t v12 = a1;
  while (1)
  {
    a1 = v12;
    uint64_t v13 = a2 - v12;
    uint64_t v14 = (uint64_t)(a2 - v12) >> 4;
    if (v5 || !v4)
    {
      switch(v14)
      {
        case 0:
        case 1:
          return;
        case 2:
          {
            v40 = *(const void ***)a1;
            *(void *)a1 = *(void *)(a2 - 16);
            *(void *)(a2 - 16) = v40;
            v41 = *(void *)(a1 + 8);
            *(void *)(a1 + 8) = *(void *)(a2 - 8);
            *(void *)(a2 - 8) = v41;
          }
          break;
        case 3:
          break;
        case 4:
          break;
        case 5:
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v13 <= 383) {
      break;
    }
    if (!a3)
    {
      if (a1 == a2) {
        return;
      }
      v53 = (unint64_t)(v14 - 2) >> 1;
      v54 = v53;
      do
      {
        v55 = v54;
        if (v53 >= v54)
        {
          v56 = (2 * v54) | 1;
          v57 = a1 + 16 * v56;
          if (2 * v54 + 2 < v14
          {
            v57 += 16;
            v56 = 2 * v55 + 2;
          }
          v58 = a1 + 16 * v55;
          {
            v100 = *(_OWORD *)v58;
            *(void *)v58 = 0;
            *(void *)(v58 + 8) = 0;
            do
            {
              v59 = v57;
              v60 = *(_OWORD *)v57;
              *(void *)v57 = 0;
              *(void *)(v57 + 8) = 0;
              v61 = *(std::__shared_weak_count **)(v58 + 8);
              *(_OWORD *)v58 = v60;
              if (v61) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v61);
              }
              if (v53 < v56) {
                break;
              }
              v62 = (2 * v56) | 1;
              v57 = a1 + 16 * v62;
              v63 = 2 * v56 + 2;
              if (v63 < v14
              {
                v57 += 16;
                v62 = v63;
              }
              v58 = v59;
              v56 = v62;
            }
            v64 = v100;
            v100 = 0uLL;
            v65 = *(std::__shared_weak_count **)(v59 + 8);
            *(_OWORD *)v59 = v64;
            if (v65) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v65);
            }
            if (*((void *)&v100 + 1)) {
              std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v100 + 1));
            }
          }
        }
        v54 = v55 - 1;
      }
      while (v55);
      v66 = (unint64_t)v13 >> 4;
      v67 = v98;
      while (2)
      {
        v68 = 0;
        v69 = v67;
        v70 = *(const void ***)a1;
        v99 = *(const void ***)(a1 + 8);
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = 0;
        v71 = a1;
        do
        {
          v72 = v71 + 16 * v68 + 16;
          v73 = 2 * v68;
          v68 = (2 * v68) | 1;
          v74 = v73 + 2;
          if (v73 + 2 < v66
          {
            v72 += 16;
            v68 = v74;
          }
          v75 = *(_OWORD *)v72;
          *(void *)v72 = 0;
          *(void *)(v72 + 8) = 0;
          v76 = *(std::__shared_weak_count **)(v71 + 8);
          *(_OWORD *)v71 = v75;
          if (v76) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v76);
          }
          v71 = v72;
        }
        while (v68 <= (uint64_t)((unint64_t)(v66 - 2) >> 1));
        v67 -= 2;
        if ((const void ***)v72 == v69 - 2)
        {
          v86 = *(std::__shared_weak_count **)(v72 + 8);
          *(void *)v72 = v70;
          *(void *)(v72 + 8) = v99;
          if (!v86) {
            goto LABEL_137;
          }
        }
        else
        {
          v77 = *((_OWORD *)v69 - 1);
          *v67 = 0;
          *(v69 - 1) = 0;
          v78 = *(std::__shared_weak_count **)(v72 + 8);
          *(_OWORD *)v72 = v77;
          if (v78) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v78);
          }
          v79 = (std::__shared_weak_count *)*(v69 - 1);
          *(v69 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v70;
          *(v69 - 1) = v99;
          if (v79) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v79);
          }
          v80 = v72 + 16 - a1;
          if (v80 < 17) {
            goto LABEL_137;
          }
          v81 = (((unint64_t)v80 >> 4) - 2) >> 1;
          v82 = a1 + 16 * v81;
            goto LABEL_137;
          v100 = *(_OWORD *)v72;
          *(void *)v72 = 0;
          *(void *)(v72 + 8) = 0;
          do
          {
            v83 = v82;
            v84 = *(_OWORD *)v82;
            *(void *)v82 = 0;
            *(void *)(v82 + 8) = 0;
            v85 = *(std::__shared_weak_count **)(v72 + 8);
            *(_OWORD *)v72 = v84;
            if (v85) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v85);
            }
            if (!v81) {
              break;
            }
            v81 = (v81 - 1) >> 1;
            v82 = a1 + 16 * v81;
            v72 = v83;
          }
          v86 = *(std::__shared_weak_count **)(v83 + 8);
          *(_OWORD *)v83 = v100;
          if (!v86)
          {
LABEL_137:
            if (v66-- <= 2) {
              return;
            }
            continue;
          }
        }
        break;
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v86);
      goto LABEL_137;
    }
    uint64_t v15 = (unint64_t)v14 >> 1;
    unint64_t v16 = (_OWORD *)(a1 + 16 * ((unint64_t)v14 >> 1));
    if ((unint64_t)v13 < 0x801)
    {
    }
    else
    {
      unint64_t v17 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *v16;
      char *v16 = v17;
    }
    --a3;
    {
      uint64_t v18 = 0;
      v100 = *(_OWORD *)a1;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      do
        v18 += 16;
      uint64_t v19 = a1 + v18;
      unint64_t v20 = v98;
      if (v18 == 16)
      {
        unint64_t v20 = v98;
        do
        {
          if (v19 >= (unint64_t)v20) {
            break;
          }
          v20 -= 2;
        }
      }
      else
      {
        do
          v20 -= 2;
      }
      uint64_t v12 = a1 + v18;
      if (v19 >= (unint64_t)v20)
      {
        a2 = (unint64_t)v98;
      }
      else
      {
        long long v21 = v20;
        a2 = (unint64_t)v98;
        do
        {
          long long v22 = *(const void ***)v12;
          *(void *)uint64_t v12 = *v21;
          *long long v21 = v22;
          long long v23 = *(const void ***)(v12 + 8);
          *(void *)(v12 + 8) = v21[1];
          v21[1] = v23;
          do
            v12 += 16;
          do
            v21 -= 2;
        }
        while (v12 < (unint64_t)v21);
      }
      long long v24 = (long long *)(v12 - 16);
      if (v12 - 16 != a1)
      {
        long long v25 = *v24;
        *(void *)long long v24 = 0;
        *(void *)(v12 - 8) = 0;
        long long v26 = *(std::__shared_weak_count **)(a1 + 8);
        *(_OWORD *)a1 = v25;
        if (v26) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v26);
        }
      }
      CMTime v27 = v100;
      v100 = 0uLL;
      long long v28 = *(std::__shared_weak_count **)(v12 - 8);
      *(_OWORD *)(v12 - 16) = v27;
      if (v28) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v28);
      }
      if (*((void *)&v100 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v100 + 1));
      }
      if (v19 < (unint64_t)v20) {
        goto LABEL_37;
      }
      {
        a2 = v12 - 16;
        if (v29) {
          return;
        }
        goto LABEL_1;
      }
      if (!v29)
      {
LABEL_37:
        goto LABEL_38;
      }
    }
    else
    {
      v100 = *(_OWORD *)a1;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      {
        uint64_t v12 = a1;
        a2 = (unint64_t)v98;
        do
          v12 += 16;
      }
      else
      {
        char v30 = (const void ***)(a1 + 16);
        a2 = (unint64_t)v98;
        do
        {
          uint64_t v12 = (unint64_t)v30;
          if (v30 >= v98) {
            break;
          }
          char v30 = (const void ***)(v12 + 16);
        }
        while (!v31);
      }
      uint64_t v32 = a2;
      if (v12 < a2)
      {
        uint64_t v32 = a2;
        do
          v32 -= 16;
      }
      while (v12 < v32)
      {
        long long v33 = *(const void ***)v12;
        *(void *)uint64_t v12 = *(void *)v32;
        *(void *)uint64_t v32 = v33;
        long long v34 = *(void *)(v12 + 8);
        *(void *)(v12 + 8) = *(void *)(v32 + 8);
        *(void *)(v32 + 8) = v34;
        do
          v12 += 16;
        do
          v32 -= 16;
      }
      long long v35 = (long long *)(v12 - 16);
      uint64_t v4 = v12 - 16 >= a1;
      char v5 = v12 - 16 == a1;
      if (v12 - 16 != a1)
      {
        long long v36 = *v35;
        *(void *)long long v35 = 0;
        *(void *)(v12 - 8) = 0;
        long long v37 = *(std::__shared_weak_count **)(a1 + 8);
        *(_OWORD *)a1 = v36;
        if (v37) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v37);
        }
      }
      v38 = v100;
      v100 = 0uLL;
      v39 = *(std::__shared_weak_count **)(v12 - 8);
      *(_OWORD *)(v12 - 16) = v38;
      if (v39) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v39);
      }
      if (*((void *)&v100 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v100 + 1));
      }
LABEL_38:
      a4 = 0;
    }
  }
  if (a4)
  {
    if (a1 != a2)
    {
      long long v42 = (const void ***)(a1 + 16);
      if (a1 + 16 != a2)
      {
        v43 = 0;
        v44 = a1;
        do
        {
          v45 = (const void ***)v44;
          v44 = (unint64_t)v42;
          {
            v100 = *(_OWORD *)v44;
            *(void *)v44 = 0;
            *(void *)(v44 + 8) = 0;
            v46 = v43;
            while (1)
            {
              v47 = a1 + v46;
              v48 = *(_OWORD *)(a1 + v46);
              *(void *)v47 = 0;
              *(void *)(v47 + 8) = 0;
              v49 = *(std::__shared_weak_count **)(a1 + v46 + 24);
              *(_OWORD *)(v47 + 16) = v48;
              if (v49) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v49);
              }
              if (!v46) {
                break;
              }
              v46 -= 16;
              {
                v50 = a1 + v46 + 16;
                goto LABEL_87;
              }
            }
            v50 = a1;
LABEL_87:
            v51 = v100;
            v100 = 0uLL;
            v52 = *(std::__shared_weak_count **)(v50 + 8);
            *(_OWORD *)v50 = v51;
            a2 = (unint64_t)v98;
            if (v52) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v52);
            }
            if (*((void *)&v100 + 1)) {
              std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v100 + 1));
            }
          }
          long long v42 = (const void ***)(v44 + 16);
          v43 += 16;
        }
        while (v44 + 16 != a2);
      }
    }
  }
  else if (a1 != a2)
  {
    v88 = (const void ***)(a1 + 16);
    if (a1 + 16 != a2)
    {
      v89 = a1 - 16;
      do
      {
        v90 = (const void ***)a1;
        a1 = (unint64_t)v88;
        {
          v100 = *(_OWORD *)a1;
          *(void *)a1 = 0;
          *(void *)(a1 + 8) = 0;
          v91 = v89;
          do
          {
            v92 = *(_OWORD *)(v91 + 16);
            *(void *)(v91 + 16) = 0;
            *(void *)(v91 + 24) = 0;
            v93 = *(std::__shared_weak_count **)(v91 + 40);
            *(_OWORD *)(v91 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v92;
            if (v93) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v93);
            }
            v91 -= 16;
          }
          while (v94);
          v95 = v100;
          v100 = 0uLL;
          v96 = *(std::__shared_weak_count **)(v91 + 40);
          *(_OWORD *)(v91 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v95;
          if (v96) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v96);
          }
          if (*((void *)&v100 + 1)) {
            std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v100 + 1));
          }
        }
        v88 = (const void ***)(a1 + 16);
        v89 += 16;
      }
      while (a1 + 16 != a2);
    }
  }
}

  unint64_t v9 = a2 - 3;
  i = (float *)a1;
  while (1)
  {
    a1 = (unint64_t)i;
    uint64_t v11 = (char *)a2 - (char *)i;
    uint64_t v12 = 0xAAAAAAAAAAAAAAABLL * (a2 - i);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0:
        case 1:
          return;
        case 2:
          {
            v78 = *(_DWORD *)(a1 + 8);
            v79 = *(void *)a1;
            *(float *)a1 = *(a2 - 3);
            *(float *)(a1 + 4) = *(a2 - 2);
            *(float *)(a1 + 8) = *(a2 - 1);
            *(void *)(a2 - 3) = v79;
            *((_DWORD *)a2 - 1) = v78;
          }
          break;
        case 3:
          break;
        case 4:
          break;
        case 5:
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 287) {
      break;
    }
    if (!a3)
    {
      if ((float *)a1 != a2)
      {
        v97 = (unint64_t)(v12 - 2) >> 1;
        v98 = v97;
        do
        {
          v99 = v98;
          if (v97 >= v98)
          {
            v100 = (2 * v98) | 1;
            v101 = (float *)(a1 + 12 * v100);
            if (2 * v98 + 2 < v12
            {
              v101 += 3;
              v100 = 2 * v99 + 2;
            }
            v102 = (float *)(a1 + 12 * v99);
            {
              v103 = *v102;
              v104 = v102[1];
              v105 = v102[2];
              *v102 = *v101;
              v102[1] = v101[1];
              v102[2] = v101[2];
              while (v97 >= v100)
              {
                v106 = v101;
                v107 = 2 * v100;
                v100 = (2 * v100) | 1;
                v101 = (float *)(a1 + 12 * v100);
                v108 = v107 + 2;
                if (v107 + 2 < v12
                {
                  v101 += 3;
                  v100 = v108;
                }
                v109 = *v101;
                if (vabds_f32(*v101, v103) >= 0.00001)
                {
                  if (v109 < v103) {
                    goto LABEL_230;
                  }
                }
                else
                {
                  v110 = v101[1];
                  if (vabds_f32(v110, v104) >= 0.00001)
                  {
                    if (v110 < v104) {
                      goto LABEL_230;
                    }
                  }
                  else
                  {
                    v111 = v101[2];
                    if (vabds_f32(v111, v105) >= 0.00001 && v111 < v105)
                    {
LABEL_230:
                      v101 = v106;
                      break;
                    }
                  }
                }
                *v106 = v109;
                v106[1] = v101[1];
                v106[2] = v101[2];
              }
              *v101 = v103;
              v101[1] = v104;
              v101[2] = v105;
            }
          }
          v98 = v99 - 1;
        }
        while (v99);
        v113 = v11 / 0xCuLL;
        do
        {
          v114 = 0;
          v116 = *(float *)a1;
          v115 = *(_DWORD *)(a1 + 4);
          v117 = *(_DWORD *)(a1 + 8);
          v118 = (_DWORD *)a1;
          do
          {
            v119 = (uint64_t)&v118[3 * v114 + 3];
            v120 = (2 * v114) | 1;
            v121 = 2 * v114 + 2;
            if (v121 < v113
            {
              v119 += 12;
              v120 = v121;
            }
            *v118 = *(_DWORD *)v119;
            v118[1] = *(_DWORD *)(v119 + 4);
            v118[2] = *(_DWORD *)(v119 + 8);
            v118 = (_DWORD *)v119;
            v114 = v120;
          }
          while (v120 <= (uint64_t)((unint64_t)(v113 - 2) >> 1));
          if ((float *)v119 == a2 - 3)
          {
            *(float *)v119 = v116;
            *(_DWORD *)(v119 + 4) = v115;
            *(_DWORD *)(v119 + 8) = v117;
            goto LABEL_258;
          }
          *(float *)v119 = *(a2 - 3);
          *(float *)(v119 + 4) = *(a2 - 2);
          *(float *)(v119 + 8) = *(a2 - 1);
          *(a2 - 3) = v116;
          *((_DWORD *)a2 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v115;
          *((_DWORD *)a2 - 1) = v117;
          v122 = v119 - a1 + 12;
          if (v122 >= 13)
          {
            v123 = v122 / 0xCuLL - 2;
            v124 = v123 >> 1;
            v125 = (float *)(a1 + 12 * (v123 >> 1));
            {
              v126 = *(float *)v119;
              v127 = *(float *)(v119 + 4);
              v128 = *(float *)(v119 + 8);
              *(float *)v119 = *v125;
              *(float *)(v119 + 4) = v125[1];
              *(float *)(v119 + 8) = v125[2];
              if (v123 < 2) {
                goto LABEL_257;
              }
              while (1)
              {
                v129 = v125;
                v130 = v124 - 1;
                v124 = (v124 - 1) >> 1;
                v125 = (float *)(a1 + 12 * v124);
                v131 = *v125;
                if (vabds_f32(*v125, v126) >= 0.00001)
                {
                  if (v131 >= v126) {
                    goto LABEL_256;
                  }
                  v132 = v125[1];
                }
                else
                {
                  v132 = v125[1];
                  if (vabds_f32(v132, v127) >= 0.00001)
                  {
                    if (v132 >= v127) {
                      goto LABEL_256;
                    }
                  }
                  else
                  {
                    v133 = v125[2];
                    if (vabds_f32(v133, v128) < 0.00001 || v133 >= v128)
                    {
LABEL_256:
                      v125 = v129;
LABEL_257:
                      *v125 = v126;
                      v125[1] = v127;
                      v125[2] = v128;
                      break;
                    }
                  }
                }
                *v129 = v131;
                v129[1] = v132;
                v129[2] = v125[2];
                if (v130 <= 1) {
                  goto LABEL_257;
                }
              }
            }
          }
LABEL_258:
          a2 -= 3;
        }
        while (v113-- > 2);
      }
      return;
    }
    uint64_t v13 = (unint64_t)v12 >> 1;
    uint64_t v14 = a1 + 12 * ((unint64_t)v12 >> 1);
    if ((unint64_t)v11 < 0x601)
    {
    }
    else
    {
      uint64_t v15 = 3 * v13;
      unint64_t v16 = (float *)(a1 + 12 * v13 - 12);
      unint64_t v17 = (float *)(a1 + 12 + 4 * v15);
      uint64_t v18 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(v14 + 8);
      uint64_t v19 = *(void *)a1;
      *(void *)a1 = *(void *)v14;
      *(void *)uint64_t v14 = v19;
      *(_DWORD *)(v14 + 8) = v18;
    }
    --a3;
    {
      v49 = *(float *)a1;
      v50 = *(float *)(a1 + 4);
      v51 = *(float *)(a1 + 8);
      v52 = *v9;
      if (vabds_f32(*(float *)a1, *v9) >= 0.00001)
      {
        if (v49 < v52) {
          goto LABEL_95;
        }
      }
      else
      {
        v53 = *(a2 - 2);
        if (vabds_f32(v50, v53) >= 0.00001)
        {
          if (v50 < v53) {
            goto LABEL_95;
          }
        }
        else
        {
          v54 = *(a2 - 1);
          if (vabds_f32(v51, v54) >= 0.00001 && v51 < v54)
          {
LABEL_95:
            for (i = (float *)(a1 + 12); ; i += 3)
            {
              if (vabds_f32(v49, *i) >= 0.00001)
              {
                if (v49 < *i) {
                  goto LABEL_123;
                }
              }
              else
              {
                v56 = i[1];
                if (vabds_f32(v50, v56) >= 0.00001)
                {
                  if (v50 < v56) {
                    goto LABEL_123;
                  }
                }
                else
                {
                  v57 = i[2];
                  if (vabds_f32(v51, v57) >= 0.00001 && v51 < v57) {
                    goto LABEL_123;
                  }
                }
              }
            }
          }
        }
      }
      for (i = (float *)(a1 + 12); i < a2; i += 3)
      {
        if (vabds_f32(v49, *i) >= 0.00001)
        {
          if (v49 < *i) {
            break;
          }
        }
        else
        {
          v59 = i[1];
          if (vabds_f32(v50, v59) >= 0.00001)
          {
            if (v50 < v59) {
              break;
            }
          }
          else
          {
            v60 = i[2];
            if (vabds_f32(v51, v60) >= 0.00001 && v51 < v60) {
              break;
            }
          }
        }
      }
LABEL_123:
      j = a2;
      if (i < a2)
      {
        for (j = a2 - 3; ; j -= 3)
        {
          if (vabds_f32(v49, v52) >= 0.00001)
          {
            if (v49 >= v52) {
              break;
            }
          }
          else
          {
            v63 = j[1];
            if (vabds_f32(v50, v63) >= 0.00001)
            {
              if (v50 >= v63) {
                break;
              }
            }
            else
            {
              v64 = j[2];
              if (vabds_f32(v51, v64) < 0.00001 || v51 >= v64) {
                break;
              }
            }
          }
          v66 = *(j - 3);
          v52 = v66;
        }
      }
      if (i < j)
      {
        v67 = *i;
        v68 = *j;
        do
        {
          *i = v68;
          v69 = *(void *)(i + 1);
          i[1] = j[1];
          i[2] = j[2];
          *j = v67;
          *(void *)(j + 1) = v69;
          do
          {
            while (1)
            {
              while (1)
              {
                v70 = i[3];
                i += 3;
                v67 = v70;
                if (vabds_f32(v49, v70) < 0.00001) {
                  break;
                }
                if (v49 < v67) {
                  goto LABEL_154;
                }
              }
              v71 = i[1];
              if (vabds_f32(v50, v71) < 0.00001) {
                break;
              }
              if (v50 < v71) {
                goto LABEL_154;
              }
            }
            v72 = i[2];
          }
          while (vabds_f32(v51, v72) < 0.00001 || v51 >= v72);
          do
          {
            while (1)
            {
LABEL_154:
              while (1)
              {
                v74 = *(j - 3);
                j -= 3;
                v68 = v74;
                if (vabds_f32(v49, v74) < 0.00001) {
                  break;
                }
                if (v49 >= v68) {
                  goto LABEL_160;
                }
              }
              v75 = j[1];
              if (vabds_f32(v50, v75) < 0.00001) {
                break;
              }
              if (v50 >= v75) {
                goto LABEL_160;
              }
            }
            v76 = j[2];
          }
          while (vabds_f32(v51, v76) >= 0.00001 && v51 < v76);
LABEL_160:
          ;
        }
        while (i < j);
      }
      uint64_t v4 = (unint64_t)(i - 3) >= a1;
      char v5 = i - 3 == (float *)a1;
      if (i - 3 != (float *)a1)
      {
        *(float *)a1 = *(i - 3);
        *(float *)(a1 + 4) = *(i - 2);
        *(float *)(a1 + 8) = *(i - 1);
      }
      a4 = 0;
      *(i - 3) = v49;
      *(i - OZChannelFontBase::~OZChannelFontBase(this - 2) = v50;
      *(i - 1) = v51;
      continue;
    }
    unint64_t v20 = 0;
    long long v21 = *(float *)a1;
    long long v22 = *(float *)(a1 + 4);
    long long v23 = *(float *)(a1 + 8);
    while (1)
    {
      long long v24 = *(float *)(a1 + v20 + 12);
      if (vabds_f32(v24, v21) >= 0.00001)
      {
        if (v24 >= v21) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }
      long long v25 = *(float *)(a1 + v20 + 16);
      if (vabds_f32(v25, v22) < 0.00001) {
        break;
      }
      if (v25 >= v22) {
        goto LABEL_23;
      }
LABEL_22:
      v20 += 12;
    }
    long long v26 = *(float *)(a1 + v20 + 20);
    if (vabds_f32(v26, v23) >= 0.00001 && v26 < v23) {
      goto LABEL_22;
    }
LABEL_23:
    long long v28 = a1 + v20 + 12;
    k = a2 - 3;
    if (v20)
    {
      while (1)
      {
        if (vabds_f32(*k, v21) >= 0.00001)
        {
          if (*k < v21) {
            goto LABEL_54;
          }
        }
        else
        {
          char v30 = k[1];
          if (vabds_f32(v30, v22) >= 0.00001)
          {
            if (v30 < v22) {
              goto LABEL_54;
            }
          }
          else
          {
            BOOL v31 = k[2];
            if (vabds_f32(v31, v23) >= 0.00001 && v31 < v23) {
              goto LABEL_54;
            }
          }
        }
        k -= 3;
      }
    }
    k = a2;
    if (v28 < (unint64_t)a2)
    {
      for (k = a2 - 3; ; k -= 3)
      {
        if (vabds_f32(*k, v21) >= 0.00001)
        {
          if (*k < v21 || v28 >= (unint64_t)k) {
            break;
          }
        }
        else
        {
          long long v33 = k[1];
          if (vabds_f32(v33, v22) >= 0.00001)
          {
            if (v28 >= (unint64_t)k || v33 < v22) {
              break;
            }
          }
          else
          {
            long long v34 = k[2];
            long long v35 = vabds_f32(v34, v23) < 0.00001;
            if (v34 >= v23) {
              long long v35 = 1;
            }
            if (v28 >= (unint64_t)k || !v35) {
              break;
            }
          }
        }
      }
    }
LABEL_54:
    if (v28 >= (unint64_t)k)
    {
      i = (float *)v28;
    }
    else
    {
      long long v37 = *k;
      i = (float *)v28;
      v38 = k;
      do
      {
        *i = v37;
        v39 = *(void *)(i + 1);
        i[1] = v38[1];
        i[2] = v38[2];
        *v38 = v24;
        *(void *)(v38 + 1) = v39;
        do
        {
          while (1)
          {
            while (1)
            {
              v40 = i[3];
              i += 3;
              long long v24 = v40;
              if (vabds_f32(v40, v21) < 0.00001) {
                break;
              }
              if (v24 >= v21) {
                goto LABEL_71;
              }
            }
            v41 = i[1];
            if (vabds_f32(v41, v22) < 0.00001) {
              break;
            }
            if (v41 >= v22) {
              goto LABEL_71;
            }
          }
          long long v42 = i[2];
        }
        while (vabds_f32(v42, v23) >= 0.00001 && v42 < v23);
        do
        {
          while (1)
          {
LABEL_71:
            while (1)
            {
              v44 = *(v38 - 3);
              v38 -= 3;
              long long v37 = v44;
              if (vabds_f32(v44, v21) < 0.00001) {
                break;
              }
              if (v37 < v21) {
                goto LABEL_78;
              }
            }
            v45 = v38[1];
            if (vabds_f32(v45, v22) < 0.00001) {
              break;
            }
            if (v45 < v22) {
              goto LABEL_78;
            }
          }
          v46 = v38[2];
        }
        while (vabds_f32(v46, v23) < 0.00001 || v46 >= v23);
LABEL_78:
        ;
      }
      while (i < v38);
    }
    if (i - 3 != (float *)a1)
    {
      *(float *)a1 = *(i - 3);
      *(float *)(a1 + 4) = *(i - 2);
      *(float *)(a1 + 8) = *(i - 1);
    }
    *(i - 3) = v21;
    *(i - OZChannelFontBase::~OZChannelFontBase(this - 2) = v22;
    *(i - 1) = v23;
    if (v28 < (unint64_t)k)
    {
LABEL_86:
      a4 = 0;
    }
    else
    {
      {
        a2 = i - 3;
        if (v48) {
          return;
        }
        goto LABEL_1;
      }
      if (!v48) {
        goto LABEL_86;
      }
    }
  }
  v80 = (float *)(a1 + 12);
  v82 = (float *)a1 == a2 || v80 == a2;
  if ((a4 & 1) == 0)
  {
    if (v82) {
      return;
    }
    for (m = a1 + 4; ; m += 12)
    {
      v137 = v80;
        break;
LABEL_277:
      v80 = v137 + 3;
      a1 = (unint64_t)v137;
      if (v137 + 3 == a2) {
        return;
      }
    }
    v138 = *v137;
    v139 = *(float *)(a1 + 16);
    v140 = *(float *)(a1 + 20);
    v141 = m;
    v142 = *(float *)a1;
    while (1)
    {
      v143 = *(float *)v141;
      v144 = *(_DWORD *)(v141 + 4);
      *(float *)(v141 + 8) = v142;
      *(float *)(v141 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = v143;
      *(_DWORD *)(v141 + 16) = v144;
      v142 = *(float *)(v141 - 16);
      if (vabds_f32(v138, v142) >= 0.00001)
      {
        if (v138 >= v142) {
          goto LABEL_276;
        }
      }
      else
      {
        v145 = *(float *)(v141 - 12);
        if (vabds_f32(v139, v145) >= 0.00001)
        {
          if (v139 >= v145) {
            goto LABEL_276;
          }
        }
        else
        {
          v146 = *(float *)(v141 - 8);
          if (vabds_f32(v140, v146) < 0.00001 || v140 >= v146)
          {
LABEL_276:
            *(float *)(v141 - 4) = v138;
            *(float *)v141 = v139;
            *(float *)(v141 + 4) = v140;
            goto LABEL_277;
          }
        }
      }
      v141 -= 12;
    }
  }
  if (v82) {
    return;
  }
  v83 = 0;
  v84 = a1;
  while (2)
  {
    v85 = v80;
      goto LABEL_204;
    v86 = *(float *)(v84 + 12);
    v87 = *(float *)(v84 + 16);
    v88 = *(float *)(v84 + 20);
    v89 = *(_DWORD *)(v84 + 4);
    *(_DWORD *)(v84 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_DWORD *)v84;
    *((_DWORD *)v85 + 1) = v89;
    v85[2] = *(float *)(v84 + 8);
    v90 = (float *)a1;
    if (v84 == a1) {
      goto LABEL_203;
    }
    v91 = v83;
    while (2)
    {
      v92 = *(float *)(a1 + v91 - 12);
      if (vabds_f32(v86, v92) >= 0.00001)
      {
        if (v86 >= v92) {
          goto LABEL_202;
        }
        v93 = *(float *)(a1 + v91 - 8);
        goto LABEL_200;
      }
      v93 = *(float *)(a1 + v91 - 8);
      if (vabds_f32(v87, v93) < 0.00001)
      {
        v90 = (float *)(a1 + v91);
        v94 = *(float *)(a1 + v91 - 4);
        if (vabds_f32(v88, v94) < 0.00001 || v88 >= v94) {
          goto LABEL_203;
        }
LABEL_200:
        v84 -= 12;
        v96 = a1 + v91;
        *(float *)v96 = v92;
        *(float *)(v96 + 4) = v93;
        *(_DWORD *)(v96 + 8) = *(_DWORD *)(a1 + v91 - 4);
        v91 -= 12;
        if (!v91)
        {
          v90 = (float *)a1;
          goto LABEL_203;
        }
        continue;
      }
      break;
    }
    if (v87 < v93) {
      goto LABEL_200;
    }
LABEL_202:
    v90 = (float *)v84;
LABEL_203:
    *v90 = v86;
    v90[1] = v87;
    v90[2] = v88;
LABEL_204:
    v80 = v85 + 3;
    v83 += 12;
    v84 = (unint64_t)v85;
    if (v85 + 3 != a2) {
      continue;
    }
    break;
  }
}

  uint64_t v12 = a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = v12;
    uint64_t v14 = v13;
    uint64_t v15 = (uint64_t)&a2[-v12];
    unint64_t v16 = (uint64_t)&a2[-v12] >> 3;
    if (!(!v7 & v6))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if ((*a3)((uint64_t *)a2 - 1, (uint64_t *)v12))
          {
            long long v24 = *(void *)v12;
            *(_DWORD *)uint64_t v12 = *((_DWORD *)a2 - 2);
            *(_DWORD *)(v12 + 4) = *((_DWORD *)a2 - 1);
            *((void *)a2 - 1) = v24;
          }
          break;
        case 3uLL:
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>((uint64_t *)v12, (uint64_t *)(v12 + 8), (uint64_t *)a2 - 1, a3);
          break;
        case 4uLL:
          std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(v12, v12 + 8, v12 + 16, (uint64_t *)a2 - 1, a3);
          break;
        case 5uLL:
          std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(v12, v12 + 8, v12 + 16, v12 + 24, (_DWORD *)a2 - 2, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v15 <= 191) {
      break;
    }
    if (v14 == 1)
    {
      if ((char *)v12 != a2)
      {
        std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*,Vec2f*>((char *)v12, a2, a2, (unsigned int (**)(uint64_t, uint64_t))a3, a6);
      }
      return;
    }
    unint64_t v17 = v16 >> 1;
    uint64_t v18 = (uint64_t *)(v12 + 8 * (v16 >> 1));
    if ((unint64_t)v15 >= 0x401)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>((uint64_t *)v12, (uint64_t *)(v12 + 8 * (v16 >> 1)), (uint64_t *)a2 - 1, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>((uint64_t *)(v12 + 8), v18 - 1, (uint64_t *)a2 - 2, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>((uint64_t *)(v12 + 16), (uint64_t *)(v12 + 8 + 8 * v17), (uint64_t *)a2 - 3, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(v18 - 1, v18, (uint64_t *)(v12 + 8 + 8 * v17), a3);
      uint64_t v19 = *(void *)v12;
      *(void *)uint64_t v12 = *v18;
      *uint64_t v18 = v19;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>((uint64_t *)(v12 + 8 * (v16 >> 1)), (uint64_t *)v12, (uint64_t *)a2 - 1, a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (((*a3)((uint64_t *)(v12 - 8), (uint64_t *)v12) & 1) == 0)
    {
      uint64_t v12 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,Vec2f *,BOOL (*&)(Vec2f const&,Vec2f const&)>(v12, a2, (uint64_t (**)(uint64_t *, unint64_t))a3);
      goto LABEL_18;
    }
LABEL_13:
    a6.n128_f32[0] = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,Vec2f *,BOOL (*&)(Vec2f const&,Vec2f const&)>((uint64_t *)v12, (uint64_t *)a2, a3);
    long long v21 = v20;
    if ((v22 & 1) == 0) {
      goto LABEL_16;
    }
    long long v23 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(v12, v20, a3);
    uint64_t v12 = (unint64_t)(v21 + 1);
    if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>((uint64_t)(v21 + 1), (uint64_t *)a2, a3))
    {
      a4 = -v14;
      a2 = (char *)v21;
      if (v23) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v14 + 1;
    if (!v23)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*,false>(a1, v21, a3, -v14, a5 & 1, a6);
      uint64_t v12 = (unint64_t)(v21 + 1);
LABEL_18:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(v12, a2, (uint64_t (**)(void *, void))a3);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(v12, a2, (uint64_t (**)(void *, _DWORD *))a3);
  }
}

  uint64_t v12 = (long long *)&a2[-4];
  uint64_t v13 = a1;
LABEL_2:
  uint64_t v14 = 1 - a4;
  while (1)
  {
    a1 = v13;
    uint64_t v15 = v14;
    unint64_t v16 = (char *)a2 - (char *)v13;
    unint64_t v17 = ((char *)a2 - (char *)v13) >> 6;
    if (!(!v7 & v6))
    {
      switch(v17)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if ((*a3)((long long *)&a2[-4], v13))
          {
            long long v34 = v13[2];
            long long v36 = v13[3];
            char v30 = *v13;
            uint64_t v32 = v13[1];
            long long v26 = *v12;
            CMTime v27 = (__int128)a2[-3];
            long long v28 = (__int128)a2[-1];
            v13[2] = (__int128)a2[-2];
            v13[3] = v28;
            *uint64_t v13 = v26;
            v13[1] = v27;
            *uint64_t v12 = v30;
            a2[-3] = (__n128)v32;
            a2[-2] = (__n128)v34;
            a2[-1] = (__n128)v36;
          }
          break;
        case 3uLL:
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(v13, v13 + 4, (long long *)&a2[-4], a3);
          break;
        case 4uLL:
          std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>((uint64_t)v13, v13 + 4, v13 + 8, (long long *)&a2[-4], a3);
          break;
        case 5uLL:
          std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>((uint64_t)v13, v13 + 4, v13 + 8, v13 + 12, (long long *)&a2[-4], a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v16 <= 1535) {
      break;
    }
    if (v15 == 1)
    {
      if (v13 != (long long *)a2)
      {
        std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*,PSEmitter::RenderEntry*>((uint64_t)v13, a2, a2, (unsigned int (**)(__n128 *, __n128 *))a3, a6);
      }
      return;
    }
    uint64_t v18 = v17 >> 1;
    uint64_t v19 = &v13[4 * (v17 >> 1)];
    if ((unint64_t)v16 > 0x2000)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(v13, &v13[4 * (v17 >> 1)], (long long *)&a2[-4], a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(v13 + 4, v19 - 4, (long long *)&a2[-8], a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(v13 + 8, &v13[4 * v18 + 4], (long long *)&a2[-12], a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(v19 - 4, v19, &v13[4 * v18 + 4], a3);
      long long v33 = v13[2];
      long long v35 = v13[3];
      v29 = *v13;
      BOOL v31 = v13[1];
      unint64_t v20 = *v19;
      long long v21 = v19[1];
      long long v22 = v19[3];
      v13[2] = v19[2];
      v13[3] = v22;
      *uint64_t v13 = v20;
      v13[1] = v21;
      v19[2] = v33;
      v19[3] = v35;
      *uint64_t v19 = v29;
      v19[1] = v31;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(&v13[4 * (v17 >> 1)], v13, (long long *)&a2[-4], a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (((*a3)(v13 - 4, v13) & 1) == 0)
    {
      uint64_t v13 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,PSEmitter::RenderEntry *,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&)>(v13, (long long *)a2, a3);
      goto LABEL_18;
    }
LABEL_13:
    long long v23 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,PSEmitter::RenderEntry *,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&)>(v13, (long long *)a2, a3);
    if ((v24 & 1) == 0) {
      goto LABEL_16;
    }
    long long v25 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(v13, v23, a3);
    uint64_t v13 = v23 + 4;
    if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(v23 + 4, (long long *)a2, a3))
    {
      a4 = -v15;
      a2 = (__n128 *)v23;
      if (v25) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v14 = v15 + 1;
    if (!v25)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*,false>(a1, v23, a3, -v15, a5 & 1);
      uint64_t v13 = v23 + 4;
LABEL_18:
      a5 = 0;
      a4 = -v15;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>((uint64_t)v13, a2, (uint64_t (**)(_OWORD *, void))a3);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>((uint64_t)v13, a2, a3);
  }
}

uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(uint64_t result, _OWORD *a2, uint64_t (**a3)(long long *, _OWORD *))
{
  if ((_OWORD *)result != a2)
  {
    uint64_t v39 = v8;
    uint64_t v40 = v7;
    uint64_t v41 = v6;
    uint64_t v42 = v5;
    uint64_t v43 = v3;
    uint64_t v44 = v4;
    uint64_t v10 = result;
    uint64_t v11 = (_OWORD *)(result + 48);
    if ((_OWORD *)(result + 48) != a2)
    {
      uint64_t v13 = 0;
      uint64_t v14 = (_OWORD *)result;
      do
      {
        uint64_t v15 = v11;
        unint64_t v16 = *a3;
        long long v17 = v14[4];
        long long v18 = v14[5];
        v38[0] = *v15;
        v38[1] = v17;
        v38[2] = v18;
        long long v19 = v14[1];
        v37[0] = *v14;
        v37[1] = v19;
        v37[2] = v14[2];
        uint64_t result = v16(v38, v37);
        if (result)
        {
          long long v36 = *v15;
          uint64_t v20 = *((void *)v14 + 8);
          uint64_t v21 = *((void *)v14 + 9);
          uint64_t v22 = *((void *)v14 + 10);
          uint64_t v23 = *((void *)v14 + 11);
          uint64_t v24 = v13;
          while (1)
          {
            long long v25 = (_OWORD *)(v10 + v24);
            long long v26 = *(_OWORD *)(v10 + v24 + 16);
            v25[3] = *(_OWORD *)(v10 + v24);
            v25[4] = v26;
            v25[5] = *(_OWORD *)(v10 + v24 + 32);
            if (!v24) {
              break;
            }
            CMTime v27 = *a3;
            uint64_t v32 = v20;
            uint64_t v33 = v21;
            uint64_t v34 = v22;
            uint64_t v35 = v23;
            long long v28 = *(v25 - 2);
            v30[0] = *(v25 - 3);
            v30[1] = v28;
            v30[2] = *(v25 - 1);
            long long v31 = v36;
            uint64_t result = v27(&v31, v30);
            v24 -= 48;
            if ((result & 1) == 0)
            {
              uint64_t v29 = v10 + v24 + 48;
              goto LABEL_10;
            }
          }
          uint64_t v29 = v10;
LABEL_10:
          *(_OWORD *)uint64_t v29 = v36;
          *(void *)(v29 + 16) = v20;
          *(void *)(v29 + 24) = v21;
          *(void *)(v29 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v22;
          *(void *)(v29 + 40) = v23;
        }
        uint64_t v11 = v15 + 3;
        v13 += 48;
        uint64_t v14 = v15;
      }
      while (v15 + 3 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(uint64_t result, _OWORD *a2, uint64_t (**a3)(long long *, _OWORD *))
{
  if ((_OWORD *)result != a2)
  {
    uint64_t v38 = v8;
    uint64_t v39 = v7;
    uint64_t v40 = v6;
    uint64_t v41 = v5;
    uint64_t v42 = v3;
    uint64_t v43 = v4;
    uint64_t v10 = (_OWORD *)result;
    uint64_t v11 = (_OWORD *)(result + 48);
    if ((_OWORD *)(result + 48) != a2)
    {
      do
      {
        uint64_t v13 = v11;
        uint64_t v14 = *a3;
        long long v15 = v10[4];
        long long v16 = v10[5];
        v37[0] = *v13;
        v37[1] = v15;
        v37[2] = v16;
        long long v17 = v10[1];
        v36[0] = *v10;
        v36[1] = v17;
        v36[2] = v10[2];
        uint64_t result = v14(v37, v36);
        if (result)
        {
          long long v35 = *v13;
          uint64_t v18 = *((void *)v10 + 8);
          uint64_t v19 = *((void *)v10 + 9);
          uint64_t v20 = *((void *)v10 + 10);
          uint64_t v21 = *((void *)v10 + 11);
          uint64_t v22 = v13;
          do
          {
            long long v23 = *(v22 - 2);
            long long v24 = *(v22 - 1);
            long long v25 = *(v22 - 4);
            *uint64_t v22 = *(v22 - 3);
            v22[1] = v23;
            v22[2] = v24;
            v29[2] = v25;
            long long v30 = v35;
            long long v26 = *(v22 - 5);
            v29[0] = *(v22 - 6);
            v29[1] = v26;
            CMTime v27 = v22 - 3;
            long long v28 = *a3;
            uint64_t v31 = v18;
            uint64_t v32 = v19;
            uint64_t v33 = v20;
            uint64_t v34 = v21;
            uint64_t result = v28(&v30, v29);
            uint64_t v22 = v27;
          }
          while ((result & 1) != 0);
          *CMTime v27 = v35;
          *((void *)v27 + OZChannelFontBase::~OZChannelFontBase(this - 2) = v18;
          *((void *)v27 + 3) = v19;
          *((void *)v27 + 4) = v20;
          *((void *)v27 + 5) = v21;
        }
        uint64_t v11 = v13 + 3;
        uint64_t v10 = v13;
      }
      while (v13 + 3 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(long long *a1, long long *a2, _OWORD *a3, unsigned int (**a4)(_OWORD *, long long *))
{
  uint64_t v8 = *a4;
  long long v9 = a2[1];
  v62[0] = *a2;
  v62[1] = v9;
  v62[2] = a2[2];
  long long v10 = a1[1];
  v61[0] = *a1;
  v61[1] = v10;
  v61[2] = a1[2];
  char v11 = v8(v62, v61);
  uint64_t v12 = *a4;
  if (v11)
  {
    long long v13 = a3[1];
    v56[0] = *a3;
    v56[1] = v13;
    v56[2] = a3[2];
    long long v14 = a2[1];
    v55[0] = *a2;
    v55[1] = v14;
    v55[2] = a2[2];
    if (v12(v56, v55))
    {
      long long v15 = *a1;
      long long v16 = a1[1];
      long long v17 = a1[2];
      long long v18 = a3[2];
      long long v19 = *a3;
      a1[1] = a3[1];
      a1[2] = v18;
      *a1 = v19;
      *a3 = v15;
      a3[1] = v16;
      uint64_t result = 1;
LABEL_9:
      a3[2] = v17;
      return result;
    }
    long long v36 = *a1;
    uint64_t v37 = *((void *)a1 + 2);
    uint64_t v38 = *((void *)a1 + 3);
    uint64_t v39 = *((void *)a1 + 4);
    uint64_t v40 = *((void *)a1 + 5);
    long long v41 = a2[2];
    long long v42 = *a2;
    a1[1] = a2[1];
    a1[2] = v41;
    *a1 = v42;
    *a2 = v36;
    *((void *)a2 + OZChannelFontBase::~OZChannelFontBase(this - 2) = v37;
    *((void *)a2 + 3) = v38;
    *((void *)a2 + 4) = v39;
    *((void *)a2 + 5) = v40;
    uint64_t v43 = *a4;
    long long v44 = a3[1];
    v54[0] = *a3;
    v54[1] = v44;
    v54[2] = a3[2];
    long long v49 = *a2;
    uint64_t v50 = v37;
    uint64_t v51 = v38;
    uint64_t v52 = v39;
    uint64_t v53 = v40;
    if (v43(v54, &v49))
    {
      long long v45 = *a2;
      long long v46 = a2[1];
      long long v17 = a2[2];
      long long v47 = a3[2];
      long long v48 = *a3;
      a2[1] = a3[1];
      a2[2] = v47;
      *a2 = v48;
      *a3 = v45;
      a3[1] = v46;
      uint64_t result = 2;
      goto LABEL_9;
    }
  }
  else
  {
    long long v21 = a3[1];
    v60[0] = *a3;
    v60[1] = v21;
    v60[2] = a3[2];
    long long v22 = a2[1];
    v59[0] = *a2;
    v59[1] = v22;
    v59[2] = a2[2];
    uint64_t result = ((uint64_t (*)(_OWORD *, _OWORD *))v12)(v60, v59);
    if (!result) {
      return result;
    }
    long long v23 = *a2;
    long long v24 = a2[1];
    long long v25 = a2[2];
    long long v26 = a3[2];
    long long v27 = *a3;
    a2[1] = a3[1];
    a2[2] = v26;
    *a2 = v27;
    *a3 = v23;
    a3[1] = v24;
    a3[2] = v25;
    long long v28 = *a4;
    long long v29 = a2[1];
    v58[0] = *a2;
    v58[1] = v29;
    v58[2] = a2[2];
    long long v30 = a1[1];
    v57[0] = *a1;
    v57[1] = v30;
    v57[2] = a1[2];
    if (v28(v58, v57))
    {
      long long v31 = *a1;
      long long v32 = a1[1];
      long long v33 = a1[2];
      long long v34 = a2[2];
      long long v35 = *a2;
      a1[1] = a2[1];
      a1[2] = v34;
      *a1 = v35;
      *a2 = v31;
      a2[1] = v32;
      uint64_t result = 2;
      a2[2] = v33;
      return result;
    }
  }
  return 1;
}

long long *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,PCEdgeVertex *,BOOL (*&)(PCEdgeVertex,PCEdgeVertex)>(long long *a1, long long *a2, uint64_t (**a3)(long long *, _OWORD *))
{
  uint64_t v4 = a2;
  long long v72 = *a1;
  uint64_t v6 = *((void *)a1 + 2);
  uint64_t v7 = *((void *)a1 + 3);
  uint64_t v8 = *((void *)a1 + 4);
  uint64_t v9 = *((void *)a1 + 5);
  long long v10 = *a3;
  uint64_t v68 = v6;
  uint64_t v69 = v7;
  uint64_t v70 = v8;
  uint64_t v71 = v9;
  long long v11 = *(a2 - 2);
  v66[0] = *(a2 - 3);
  v66[1] = v11;
  v66[2] = *(a2 - 1);
  long long v67 = v72;
  if (v10(&v67, v66))
  {
    uint64_t v12 = a1;
    do
    {
      long long v13 = v12 + 3;
      long long v14 = *a3;
      long long v61 = v72;
      uint64_t v62 = v6;
      uint64_t v63 = v7;
      uint64_t v64 = v8;
      uint64_t v65 = v9;
      long long v15 = v12[4];
      v60[0] = v12[3];
      v60[1] = v15;
      v60[2] = v12[5];
      char v16 = v14(&v61, v60);
      uint64_t v12 = v13;
    }
    while ((v16 & 1) == 0);
  }
  else
  {
    long long v17 = a1 + 3;
    do
    {
      long long v13 = v17;
      if (v17 >= v4) {
        break;
      }
      long long v18 = *a3;
      uint64_t v56 = v6;
      uint64_t v57 = v7;
      uint64_t v58 = v8;
      uint64_t v59 = v9;
      long long v19 = v13[1];
      v54[0] = *v13;
      v54[1] = v19;
      v54[2] = v13[2];
      long long v55 = v72;
      int v20 = v18(&v55, v54);
      long long v17 = v13 + 3;
    }
    while (!v20);
  }
  if (v13 >= v4)
  {
    long long v21 = v4;
  }
  else
  {
    do
    {
      long long v21 = v4 - 3;
      long long v22 = *a3;
      uint64_t v50 = v6;
      uint64_t v51 = v7;
      uint64_t v52 = v8;
      uint64_t v53 = v9;
      long long v23 = *(v4 - 2);
      v48[0] = *(v4 - 3);
      v48[1] = v23;
      v48[2] = *(v4 - 1);
      long long v49 = v72;
      v4 -= 3;
    }
    while ((v22(&v49, v48) & 1) != 0);
  }
  while (v13 < v21)
  {
    long long v24 = v13[1];
    long long v73 = *v13;
    long long v25 = v13[2];
    long long v26 = v21[2];
    long long v27 = *v21;
    v13[1] = v21[1];
    v13[2] = v26;
    *long long v13 = v27;
    *long long v21 = v73;
    v21[1] = v24;
    v21[2] = v25;
    do
    {
      long long v43 = v72;
      uint64_t v44 = v6;
      uint64_t v45 = v7;
      uint64_t v46 = v8;
      uint64_t v47 = v9;
      v42[0] = v13[3];
      v42[1] = v13[4];
      long long v28 = v13[5];
      v13 += 3;
      long long v29 = *a3;
      v42[2] = v28;
    }
    while (!v29(&v43, v42));
    do
    {
      long long v37 = v72;
      uint64_t v38 = v6;
      uint64_t v39 = v7;
      uint64_t v40 = v8;
      uint64_t v41 = v9;
      v36[0] = *(v21 - 3);
      v36[1] = *(v21 - 2);
      long long v30 = *(v21 - 1);
      v21 -= 3;
      long long v31 = *a3;
      v36[2] = v30;
    }
    while ((v31(&v37, v36) & 1) != 0);
  }
  long long v32 = v13 - 3;
  if (v13 - 3 != a1)
  {
    long long v33 = *v32;
    long long v34 = *(v13 - 1);
    a1[1] = *(v13 - 2);
    a1[2] = v34;
    *a1 = v33;
  }
  *long long v32 = v72;
  *((void *)v13 - 4) = v6;
  *((void *)v13 - 3) = v7;
  *((void *)v13 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v8;
  *((void *)v13 - 1) = v9;
  return v13;
}

long long *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,PCEdgeVertex *,BOOL (*&)(PCEdgeVertex,PCEdgeVertex)>(long long *a1, long long *a2, uint64_t (**a3)(_OWORD *, long long *))
{
  uint64_t v6 = 0;
  long long v63 = *a1;
  uint64_t v7 = *((void *)a1 + 2);
  uint64_t v8 = *((void *)a1 + 3);
  uint64_t v9 = *((void *)a1 + 4);
  uint64_t v10 = *((void *)a1 + 5);
  do
  {
    long long v11 = *a3;
    long long v12 = a1[v6 + 4];
    v62[0] = a1[v6 + 3];
    v62[1] = v12;
    v62[2] = a1[v6 + 5];
    long long v57 = v63;
    uint64_t v58 = v7;
    uint64_t v59 = v8;
    uint64_t v60 = v9;
    uint64_t v61 = v10;
    v6 += 3;
  }
  while ((v11(v62, &v57) & 1) != 0);
  long long v13 = &a1[v6];
  if (v6 == 3)
  {
    while (v13 < a2)
    {
      long long v17 = *a3;
      long long v14 = a2 - 3;
      long long v18 = *(a2 - 2);
      v56[0] = *(a2 - 3);
      v56[1] = v18;
      v56[2] = *(a2 - 1);
      long long v51 = v63;
      uint64_t v52 = v7;
      uint64_t v53 = v8;
      uint64_t v54 = v9;
      uint64_t v55 = v10;
      a2 -= 3;
      if (v17(v56, &v51)) {
        goto LABEL_9;
      }
    }
    long long v14 = a2;
  }
  else
  {
    do
    {
      long long v14 = a2 - 3;
      long long v15 = *a3;
      long long v16 = *(a2 - 2);
      v50[0] = *(a2 - 3);
      v50[1] = v16;
      v50[2] = *(a2 - 1);
      long long v45 = v63;
      uint64_t v46 = v7;
      uint64_t v47 = v8;
      uint64_t v48 = v9;
      uint64_t v49 = v10;
      a2 -= 3;
    }
    while (!v15(v50, &v45));
  }
LABEL_9:
  long long v19 = v13;
  if (v13 < v14)
  {
    int v20 = v14;
    do
    {
      long long v22 = v19[1];
      long long v64 = *v19;
      long long v21 = v64;
      long long v23 = v19[2];
      long long v24 = *v20;
      long long v25 = v20[2];
      v19[1] = v20[1];
      v19[2] = v25;
      *long long v19 = v24;
      *int v20 = v21;
      v20[1] = v22;
      v20[2] = v23;
      do
      {
        v44[0] = v19[3];
        v44[1] = v19[4];
        long long v26 = v19[5];
        v19 += 3;
        long long v27 = *a3;
        v44[2] = v26;
        long long v39 = v63;
        uint64_t v40 = v7;
        uint64_t v41 = v8;
        uint64_t v42 = v9;
        uint64_t v43 = v10;
      }
      while ((v27(v44, &v39) & 1) != 0);
      do
      {
        v38[0] = *(v20 - 3);
        v38[1] = *(v20 - 2);
        long long v28 = *(v20 - 1);
        v20 -= 3;
        long long v29 = *a3;
        v38[2] = v28;
        long long v33 = v63;
        uint64_t v34 = v7;
        uint64_t v35 = v8;
        uint64_t v36 = v9;
        uint64_t v37 = v10;
      }
      while (!v29(v38, &v33));
    }
    while (v19 < v20);
  }
  uint64_t result = v19 - 3;
  if (v19 - 3 != a1)
  {
    long long v31 = *result;
    long long v32 = *(v19 - 1);
    a1[1] = *(v19 - 2);
    a1[2] = v32;
    *a1 = v31;
  }
  *uint64_t result = v63;
  *((void *)v19 - 4) = v7;
  *((void *)v19 - 3) = v8;
  *((void *)v19 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v9;
  *((void *)v19 - 1) = v10;
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(long long *a1, long long *a2, unsigned int (**a3)(_OWORD *, long long *))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v8 = *a3;
      long long v9 = *(a2 - 2);
      v43[0] = *(a2 - 3);
      v43[1] = v9;
      v43[2] = *(a2 - 1);
      long long v10 = a1[1];
      v42[0] = *a1;
      v42[1] = v10;
      v42[2] = a1[2];
      if (v8(v43, v42))
      {
        long long v11 = *a1;
        long long v12 = a1[1];
        long long v13 = a1[2];
        long long v14 = *(a2 - 1);
        long long v15 = *(a2 - 3);
        a1[1] = *(a2 - 2);
        a1[2] = v14;
        *a1 = v15;
        *(a2 - 3) = v11;
        *(a2 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v12;
        *(a2 - 1) = v13;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(a1, a1 + 3, a2 - 3, a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(a1, a1 + 3, a1 + 6, a2 - 3, a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(a1, a1 + 3, a1 + 6, a1 + 9, a2 - 3, a3);
      return 1;
    default:
      long long v16 = a1 + 6;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(a1, a1 + 3, a1 + 6, a3);
      long long v17 = a1 + 9;
      if (a1 + 9 == a2) {
        return 1;
      }
      uint64_t v18 = 0;
      int v19 = 0;
      break;
  }
  while (1)
  {
    int v20 = *a3;
    long long v21 = v17[1];
    v41[0] = *v17;
    v41[1] = v21;
    v41[2] = v17[2];
    long long v22 = v16[1];
    v40[0] = *v16;
    v40[1] = v22;
    v40[2] = v16[2];
    if (v20(v41, v40))
    {
      long long v39 = *v17;
      uint64_t v23 = *((void *)v17 + 2);
      uint64_t v24 = *((void *)v17 + 3);
      uint64_t v25 = *((void *)v17 + 4);
      uint64_t v26 = *((void *)v17 + 5);
      uint64_t v27 = v18;
      while (1)
      {
        long long v28 = (long long *)((char *)a1 + v27);
        long long v29 = *(long long *)((char *)a1 + v27 + 112);
        v28[9] = *(long long *)((char *)a1 + v27 + 96);
        v28[10] = v29;
        v28[11] = *(long long *)((char *)a1 + v27 + 128);
        if (v27 == -96) {
          break;
        }
        long long v30 = *a3;
        uint64_t v35 = v23;
        uint64_t v36 = v24;
        uint64_t v37 = v25;
        uint64_t v38 = v26;
        long long v31 = v28[4];
        v33[0] = v28[3];
        v33[1] = v31;
        v33[2] = v28[5];
        long long v34 = v39;
        v27 -= 48;
        if ((((uint64_t (*)(long long *, _OWORD *))v30)(&v34, v33) & 1) == 0)
        {
          uint64_t v32 = (uint64_t)a1 + v27 + 144;
          goto LABEL_12;
        }
      }
      uint64_t v32 = (uint64_t)a1;
LABEL_12:
      *(_OWORD *)uint64_t v32 = v39;
      *(void *)(v32 + 16) = v23;
      *(void *)(v32 + 24) = v24;
      *(void *)(v32 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v25;
      *(void *)(v32 + 40) = v26;
      if (++v19 == 8) {
        return v17 + 3 == a2;
      }
    }
    long long v16 = v17;
    v18 += 48;
    v17 += 3;
    if (v17 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(long long *a1, long long *a2, long long *a3, long long *a4, unsigned int (**a5)(_OWORD *, long long *))
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(a1, a2, a3, a5);
  long long v10 = *a5;
  long long v11 = a4[1];
  v39[0] = *a4;
  v39[1] = v11;
  v39[2] = a4[2];
  long long v12 = a3[1];
  v38[0] = *a3;
  v38[1] = v12;
  v38[2] = a3[2];
  if (v10(v39, v38))
  {
    long long v14 = *a3;
    long long v15 = a3[1];
    long long v16 = a3[2];
    long long v17 = a4[2];
    long long v18 = *a4;
    a3[1] = a4[1];
    a3[2] = v17;
    *a3 = v18;
    *a4 = v14;
    a4[1] = v15;
    a4[2] = v16;
    int v19 = *a5;
    long long v20 = a3[1];
    v37[0] = *a3;
    v37[1] = v20;
    v37[2] = a3[2];
    long long v21 = a2[1];
    v36[0] = *a2;
    v36[1] = v21;
    v36[2] = a2[2];
    if (v19(v37, v36))
    {
      long long v22 = *a2;
      long long v23 = a2[1];
      long long v24 = a2[2];
      long long v25 = a3[2];
      long long v26 = *a3;
      a2[1] = a3[1];
      a2[2] = v25;
      *a2 = v26;
      *a3 = v22;
      a3[1] = v23;
      a3[2] = v24;
      uint64_t v27 = *a5;
      long long v28 = a2[1];
      v35[0] = *a2;
      v35[1] = v28;
      v35[2] = a2[2];
      long long v29 = a1[1];
      v34[0] = *a1;
      v34[1] = v29;
      v34[2] = a1[2];
      if (v27(v35, v34))
      {
        __n128 result = (__n128)*a1;
        long long v30 = a1[1];
        long long v31 = a1[2];
        long long v32 = a2[2];
        long long v33 = *a2;
        a1[1] = a2[1];
        a1[2] = v32;
        *a1 = v33;
        *a2 = (__int128)result;
        a2[1] = v30;
        a2[2] = v31;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(long long *a1, long long *a2, long long *a3, long long *a4, long long *a5, unsigned int (**a6)(_OWORD *, long long *))
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(a1, a2, a3, a4, a6);
  long long v12 = *a6;
  long long v13 = a5[1];
  v51[0] = *a5;
  v51[1] = v13;
  v51[2] = a5[2];
  long long v14 = a4[1];
  v50[0] = *a4;
  v50[1] = v14;
  v50[2] = a4[2];
  if (v12(v51, v50))
  {
    long long v16 = *a4;
    long long v17 = a4[1];
    long long v18 = a4[2];
    long long v19 = a5[2];
    long long v20 = *a5;
    a4[1] = a5[1];
    a4[2] = v19;
    *a4 = v20;
    *a5 = v16;
    a5[1] = v17;
    a5[2] = v18;
    long long v21 = *a6;
    long long v22 = a4[1];
    v49[0] = *a4;
    v49[1] = v22;
    v49[2] = a4[2];
    long long v23 = a3[1];
    v48[0] = *a3;
    v48[1] = v23;
    v48[2] = a3[2];
    if (v21(v49, v48))
    {
      long long v24 = *a3;
      long long v25 = a3[1];
      long long v26 = a3[2];
      long long v27 = a4[2];
      long long v28 = *a4;
      a3[1] = a4[1];
      a3[2] = v27;
      *a3 = v28;
      *a4 = v24;
      a4[1] = v25;
      a4[2] = v26;
      long long v29 = *a6;
      long long v30 = a3[1];
      v47[0] = *a3;
      v47[1] = v30;
      v47[2] = a3[2];
      long long v31 = a2[1];
      v46[0] = *a2;
      v46[1] = v31;
      v46[2] = a2[2];
      if (v29(v47, v46))
      {
        long long v32 = *a2;
        long long v33 = a2[1];
        long long v34 = a2[2];
        long long v35 = a3[2];
        long long v36 = *a3;
        a2[1] = a3[1];
        a2[2] = v35;
        *a2 = v36;
        *a3 = v32;
        a3[1] = v33;
        a3[2] = v34;
        uint64_t v37 = *a6;
        long long v38 = a2[1];
        v45[0] = *a2;
        v45[1] = v38;
        v45[2] = a2[2];
        long long v39 = a1[1];
        v44[0] = *a1;
        v44[1] = v39;
        v44[2] = a1[2];
        if (v37(v45, v44))
        {
          __n128 result = (__n128)*a1;
          long long v40 = a1[1];
          long long v41 = a1[2];
          long long v42 = a2[2];
          long long v43 = *a2;
          a1[1] = a2[1];
          a1[2] = v42;
          *a1 = v43;
          *a2 = (__int128)result;
          a2[1] = v40;
          a2[2] = v41;
        }
      }
    }
  }
  return result;
}

_OWORD *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*,PCEdgeVertex*>(uint64_t a1, _OWORD *a2, _OWORD *a3, uint64_t (**a4)(_OWORD *, long long *))
{
  if ((_OWORD *)a1 != a2)
  {
    uint64_t v8 = (uint64_t)a2 - a1;
    uint64_t v9 = ((uint64_t)a2 - a1) / 48;
    if ((uint64_t)a2 - a1 >= 49)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      long long v12 = (_OWORD *)(a1 + 48 * v10);
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(a1, a4, v9, v12);
        v12 -= 3;
        --v11;
      }
      while (v11);
    }
    long long v13 = a2;
    if (a2 != a3)
    {
      long long v14 = a2;
      do
      {
        long long v15 = *a4;
        long long v16 = v14[1];
        v35[0] = *v14;
        v35[1] = v16;
        v35[2] = v14[2];
        long long v17 = *(_OWORD *)(a1 + 16);
        v34[0] = *(_OWORD *)a1;
        v34[1] = v17;
        v34[2] = *(_OWORD *)(a1 + 32);
        if (v15(v35, v34))
        {
          long long v18 = *v14;
          long long v19 = v14[1];
          long long v20 = v14[2];
          long long v21 = *(_OWORD *)(a1 + 32);
          long long v22 = *(_OWORD *)a1;
          v14[1] = *(_OWORD *)(a1 + 16);
          v14[2] = v21;
          *long long v14 = v22;
          *(_OWORD *)a1 = v18;
          *(_OWORD *)(a1 + 16) = v19;
          *(_OWORD *)(a1 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v20;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(a1, a4, v9, (_OWORD *)a1);
        }
        v14 += 3;
      }
      while (v14 != a3);
      long long v13 = a3;
    }
    if (v8 >= 49)
    {
      int64_t v23 = v8 / 0x30uLL;
      long long v24 = a2 - 3;
      do
      {
        long long v36 = *(_OWORD *)a1;
        uint64_t v26 = *(void *)(a1 + 16);
        uint64_t v25 = *(void *)(a1 + 24);
        uint64_t v28 = *(void *)(a1 + 32);
        uint64_t v27 = *(void *)(a1 + 40);
        long long v29 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>((_OWORD *)a1, (unsigned int (**)(_OWORD *, _OWORD *))a4, v23);
        if (v24 == v29)
        {
          _OWORD *v29 = v36;
          *((void *)v29 + OZChannelFontBase::~OZChannelFontBase(this - 2) = v26;
          *((void *)v29 + 3) = v25;
          *((void *)v29 + 4) = v28;
          *((void *)v29 + 5) = v27;
        }
        else
        {
          long long v30 = *v24;
          long long v31 = v24[2];
          v29[1] = v24[1];
          v29[2] = v31;
          _OWORD *v29 = v30;
          *long long v24 = v36;
          *((void *)v24 + OZChannelFontBase::~OZChannelFontBase(this - 2) = v26;
          *((void *)v24 + 3) = v25;
          *((void *)v24 + 4) = v28;
          *((void *)v24 + 5) = v27;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(a1, (uint64_t)(v29 + 3), a4, 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v29 - a1 + 48) >> 4));
        }
        v24 -= 3;
      }
      while (v23-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(uint64_t result, uint64_t (**a2)(_OWORD *, long long *), uint64_t a3, _OWORD *a4)
{
  unint64_t v10 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v56 = v9;
    uint64_t v57 = v8;
    uint64_t v58 = v7;
    uint64_t v59 = v6;
    uint64_t v60 = v4;
    uint64_t v61 = v5;
    unint64_t v11 = a4;
    uint64_t v12 = result;
    uint64_t v13 = v10 >> 1;
    if ((uint64_t)(v10 >> 1) >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * (((uint64_t)a4 - result) >> 4)))
    {
      uint64_t v16 = (0x5555555555555556 * (((uint64_t)a4 - result) >> 4)) | 1;
      long long v17 = (_OWORD *)(result + 48 * v16);
      uint64_t v18 = 0x5555555555555556 * (((uint64_t)a4 - result) >> 4) + 2;
      if (v18 < a3)
      {
        long long v19 = *a2;
        uint64_t v20 = result + 48 * v16;
        long long v21 = *(_OWORD *)(v20 + 16);
        long long v22 = *(_OWORD *)(v20 + 32);
        v55[0] = *v17;
        v55[1] = v21;
        v55[2] = v22;
        long long v23 = v17[4];
        v54[0] = v17[3];
        v54[1] = v23;
        v54[2] = v17[5];
        if (v19(v55, v54))
        {
          v17 += 3;
          uint64_t v16 = v18;
        }
      }
      long long v24 = *a2;
      long long v25 = v17[1];
      v53[0] = *v17;
      v53[1] = v25;
      v53[2] = v17[2];
      long long v26 = v11[1];
      v52[0] = *v11;
      v52[1] = v26;
      v52[2] = v11[2];
      __n128 result = v24(v53, v52);
      if ((result & 1) == 0)
      {
        long long v51 = *v11;
        uint64_t v27 = *((void *)v11 + 2);
        uint64_t v28 = *((void *)v11 + 3);
        uint64_t v29 = *((void *)v11 + 4);
        uint64_t v30 = *((void *)v11 + 5);
        do
        {
          long long v31 = v11;
          unint64_t v11 = v17;
          long long v32 = *v17;
          long long v33 = v17[2];
          v31[1] = v17[1];
          v31[2] = v33;
          *long long v31 = v32;
          if (v13 < v16) {
            break;
          }
          uint64_t v34 = (2 * v16) | 1;
          long long v17 = (_OWORD *)(v12 + 48 * v34);
          uint64_t v35 = 2 * v16 + 2;
          if (v35 < a3)
          {
            long long v36 = *a2;
            uint64_t v37 = v12 + 48 * v34;
            long long v38 = *(_OWORD *)(v37 + 16);
            long long v39 = *(_OWORD *)(v37 + 32);
            v50[0] = *v17;
            v50[1] = v38;
            v50[2] = v39;
            long long v40 = v17[4];
            v49[0] = v17[3];
            v49[1] = v40;
            v49[2] = v17[5];
            if (v36(v50, v49))
            {
              v17 += 3;
              uint64_t v34 = v35;
            }
          }
          long long v41 = *a2;
          long long v42 = v17[1];
          v48[0] = *v17;
          v48[1] = v42;
          v48[2] = v17[2];
          long long v43 = v51;
          uint64_t v44 = v27;
          uint64_t v45 = v28;
          uint64_t v46 = v29;
          uint64_t v47 = v30;
          __n128 result = v41(v48, &v43);
          uint64_t v16 = v34;
        }
        while (!result);
        *unint64_t v11 = v51;
        *((void *)v11 + OZChannelFontBase::~OZChannelFontBase(this - 2) = v27;
        *((void *)v11 + 3) = v28;
        *((void *)v11 + 4) = v29;
        *((void *)v11 + 5) = v30;
      }
    }
  }
  return result;
}

_OWORD *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(_OWORD *a1, unsigned int (**a2)(_OWORD *, _OWORD *), uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = v6 + 1;
    unint64_t v10 = &a1[3 * v6 + 3];
    uint64_t v11 = (2 * v6) | 1;
    uint64_t v12 = 2 * v6 + 2;
    if (v12 < a3)
    {
      uint64_t v13 = *a2;
      v19[0] = *v10;
      long long v14 = &a1[3 * v9];
      v19[1] = v14[1];
      v19[2] = v14[2];
      v18[0] = v10[3];
      v18[1] = v10[4];
      v18[2] = v10[5];
      if (v13(v19, v18))
      {
        v10 += 3;
        uint64_t v11 = v12;
      }
    }
    long long v15 = *v10;
    long long v16 = v10[2];
    a1[1] = v10[1];
    a1[2] = v16;
    *a1 = v15;
    a1 = v10;
    uint64_t v6 = v11;
  }
  while (v11 <= v8);
  return v10;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PCEdgeVertex,PCEdgeVertex),PCEdgeVertex*>(uint64_t result, uint64_t a2, uint64_t (**a3)(_OWORD *, long long *), uint64_t a4)
{
  if (a4 >= 2)
  {
    uint64_t v37 = v9;
    uint64_t v38 = v8;
    uint64_t v39 = v7;
    uint64_t v40 = v6;
    uint64_t v41 = v4;
    uint64_t v42 = v5;
    uint64_t v12 = result;
    unint64_t v13 = (unint64_t)(a4 - 2) >> 1;
    long long v14 = *a3;
    long long v15 = (_OWORD *)(result + 48 * v13);
    long long v16 = v15[1];
    v36[0] = *v15;
    v36[1] = v16;
    v36[2] = v15[2];
    long long v17 = *(_OWORD *)(a2 - 32);
    v35[0] = *(_OWORD *)(a2 - 48);
    v35[1] = v17;
    v35[2] = *(_OWORD *)(a2 - 16);
    __n128 result = v14(v36, v35);
    if (result)
    {
      uint64_t v18 = (_OWORD *)(a2 - 48);
      long long v34 = *(_OWORD *)(a2 - 48);
      uint64_t v19 = *(void *)(a2 - 32);
      uint64_t v20 = *(void *)(a2 - 24);
      uint64_t v21 = *(void *)(a2 - 16);
      uint64_t v22 = *(void *)(a2 - 8);
      do
      {
        long long v23 = v18;
        uint64_t v18 = v15;
        long long v24 = *v15;
        long long v25 = v15[2];
        v23[1] = v15[1];
        v23[2] = v25;
        *long long v23 = v24;
        if (!v13) {
          break;
        }
        unint64_t v13 = (v13 - 1) >> 1;
        long long v26 = *a3;
        long long v15 = (_OWORD *)(v12 + 48 * v13);
        long long v27 = v15[1];
        v33[0] = *v15;
        v33[1] = v27;
        v33[2] = v15[2];
        long long v28 = v34;
        uint64_t v29 = v19;
        uint64_t v30 = v20;
        uint64_t v31 = v21;
        uint64_t v32 = v22;
        __n128 result = v26(v33, &v28);
      }
      while ((result & 1) != 0);
      *uint64_t v18 = v34;
      *((void *)v18 + OZChannelFontBase::~OZChannelFontBase(this - 2) = v19;
      *((void *)v18 + 3) = v20;
      *((void *)v18 + 4) = v21;
      *((void *)v18 + 5) = v22;
    }
  }
  return result;
}

uint64_t *PCBinaryTree<PCEdgeSegment>::~PCBinaryTree(uint64_t *a1)
{
  *a1 = 0;
  return a1;
}

uint64_t PCBinaryTree<PCEdgeSegment>::removeBranch(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    PCBinaryTree<PCEdgeSegment>::removeBranch(result, *(void *)(a2 + 40));
    PCBinaryTree<PCEdgeSegment>::removeBranch(v3, *(void *)(a2 + 48));
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

uint64_t *PCBinaryTree<PCEdgeSegment>::insertNode(uint64_t **a1, uint64_t a2, double *a3)
{
  if (!a2) {
    operator new();
  }
  if (!PCEdgeSegment::operator<(a3, (double *)a2))
  {
    uint64_t inserted = PCBinaryTree<PCEdgeSegment>::insertNode(a1, *(void *)(a2 + 48), a3);
    *(void *)(a2 + 48) = inserted;
    if (!inserted) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  uint64_t inserted = PCBinaryTree<PCEdgeSegment>::insertNode(a1, *(void *)(a2 + 40), a3);
  *(void *)(a2 + 40) = inserted;
  if (inserted) {
LABEL_7:
  }
    *(void *)(inserted + 56) = a2;
LABEL_8:
  uint64_t v7 = *a1;
  __n128 result = PCBinaryTree<PCEdgeSegment>::balance((uint64_t)a1, (uint64_t *)a2);
  if (v7 == (uint64_t *)a2) {
    *a1 = result;
  }
  return result;
}

uint64_t *PCBinaryTree<PCEdgeSegment>::balance(uint64_t a1, uint64_t *a2)
{
  if (!a2) {
    return 0;
  }
  int NodeHeight = PCBinaryTree<PCEdgeSegment>::getNodeHeight(a1, a2[5]);
  int v5 = NodeHeight - PCBinaryTree<PCEdgeSegment>::getNodeHeight(a1, a2[6]);
  if (v5 < 2)
  {
    if (v5 > -2) {
      return a2;
    }
    if ((int)PCBinaryTree<PCEdgeSegment>::getNodeHeightDelta(a1, a2[6]) < 1)
    {
      __n128 result = (uint64_t *)a2[6];
      uint64_t v6 = a2[7];
      uint64_t v12 = result[5];
      a2[6] = v12;
      if (v12) {
        *(void *)(v12 + 56) = a2;
      }
      result[5] = (uint64_t)a2;
      a2[7] = (uint64_t)result;
      goto LABEL_19;
    }
    uint64_t v9 = a1;
    unint64_t v10 = a2;
    int v11 = 3;
  }
  else
  {
    if ((int)PCBinaryTree<PCEdgeSegment>::getNodeHeightDelta(a1, a2[5]) >= 1)
    {
      uint64_t v6 = a2[7];
      __n128 result = (uint64_t *)a2[5];
      uint64_t v8 = result[6];
      a2[5] = v8;
      if (v8) {
        *(void *)(v8 + 56) = a2;
      }
      a2[7] = (uint64_t)result;
      result[6] = (uint64_t)a2;
LABEL_19:
      result[7] = v6;
      return result;
    }
    uint64_t v9 = a1;
    unint64_t v10 = a2;
    int v11 = 2;
  }

  return PCBinaryTree<PCEdgeSegment>::rotate(v9, v10, v11);
}

uint64_t PCBinaryTree<PCEdgeSegment>::getNodeHeightDelta(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  int NodeHeight = PCBinaryTree<PCEdgeSegment>::getNodeHeight(a1, *(void *)(a2 + 40));
  return NodeHeight - PCBinaryTree<PCEdgeSegment>::getNodeHeight(a1, *(void *)(a2 + 48));
}

void *PCBinaryTree<PCEdgeSegment>::rotate(uint64_t a1, void *a2, int a3)
{
  uint64_t v3 = a2[7];
  switch(a3)
  {
    case 1:
      __n128 result = (void *)a2[5];
      uint64_t v8 = result[6];
      a2[5] = v8;
      if (v8) {
        *(void *)(v8 + 56) = a2;
      }
      result[6] = a2;
      goto LABEL_8;
    case 2:
      uint64_t v9 = PCBinaryTree<PCEdgeSegment>::rotate(a1, a2[5], 0);
      a2[5] = v9;
      if (v9) {
        *(void *)(v9 + 56) = a2;
      }
      uint64_t v10 = a1;
      int v11 = a2;
      uint64_t v12 = 1;
      goto LABEL_15;
    case 3:
      uint64_t v13 = PCBinaryTree<PCEdgeSegment>::rotate(a1, a2[6], 1);
      a2[6] = v13;
      if (v13) {
        *(void *)(v13 + 56) = a2;
      }
      uint64_t v10 = a1;
      int v11 = a2;
      uint64_t v12 = 0;
LABEL_15:
      __n128 result = (void *)PCBinaryTree<PCEdgeSegment>::rotate(v10, v11, v12);
      break;
    default:
      __n128 result = (void *)a2[6];
      uint64_t v7 = result[5];
      a2[6] = v7;
      if (v7) {
        *(void *)(v7 + 56) = a2;
      }
      result[5] = a2;
LABEL_8:
      a2[7] = result;
      break;
  }
  result[7] = v3;
  return result;
}

uint64_t PCBinaryTree<PCEdgeSegment>::getNodeHeight(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  int NodeHeight = PCBinaryTree<PCEdgeSegment>::getNodeHeight(a1, *(void *)(a2 + 40));
  int v5 = PCBinaryTree<PCEdgeSegment>::getNodeHeight(a1, *(void *)(a2 + 48));
  if (NodeHeight <= v5) {
    int v6 = v5;
  }
  else {
    int v6 = NodeHeight;
  }
  return (v6 + 1);
}

uint64_t ProCore_Private::PCBitmapRepDefault::PCBitmapRepDefault(uint64_t a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  *(void *)a1 = &unk_1F10C24A8;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = a3;
  *(_DWORD *)(a1 + 16) = a4;
  unsigned int v7 = (a5 + PCPixelFormat::getBytesPerPixel(a4) * a2 - 1) / a5 * a5;
  *(_DWORD *)(a1 + 20) = v7;
  unsigned int v8 = getpagesize();
  unint64_t v9 = v8 + v7 * (unint64_t)a3 - 1;
  size_t v10 = v9 / v8 * v8;
  *(void *)(a1 + 24) = v10;
  if (v9 == v9 - v10) {
    int v11 = 0;
  }
  else {
    int v11 = malloc_type_valloc(v10, 0x5BE40E5DuLL);
  }
  *(void *)(a1 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v11;
  return a1;
}

void ProCore_Private::PCBitmapRepDefault::~PCBitmapRepDefault(ProCore_Private::PCBitmapRepDefault *this)
{
  *(void *)this = &unk_1F10C24A8;
  uint64_t v1 = (void *)*((void *)this + 4);
  if (v1) {
    free(v1);
  }
}

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_1F10C24A8;
  uint64_t v1 = (void *)*((void *)this + 4);
  if (v1) {
    free(v1);
  }

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProCore_Private::PCBitmapRepDefault::getData(ProCore_Private::PCBitmapRepDefault *this)
{
  return *((void *)this + 4);
}

uint64_t ProCore_Private::PCBitmapRepDefault::getAllocationSize(ProCore_Private::PCBitmapRepDefault *this)
{
  return *((void *)this + 3);
}

uint64_t ProCore_Private::PCBitmapRepDefault::getWidth(ProCore_Private::PCBitmapRepDefault *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t ProCore_Private::PCBitmapRepDefault::getHeight(ProCore_Private::PCBitmapRepDefault *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t ProCore_Private::PCBitmapRepDefault::getPixelFormat(ProCore_Private::PCBitmapRepDefault *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t ProCore_Private::PCBitmapRepDefault::setPixelFormat(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t ProCore_Private::PCBitmapRepDefault::getBytesPerRow(ProCore_Private::PCBitmapRepDefault *this)
{
  return *((unsigned int *)this + 5);
}

void _PCMod_error(const char *a1, const char *a2, int a3)
{
  exception = (PCException *)__cxa_allocate_exception(0x40uLL);
  PCString::PCString(&v8, a1);
  PCString::PCString(&v7, a2);
  PCException::PCException(exception, &v8, &v7, a3);
  *(void *)exception = &unk_1F1199218;
}

void sub_1B767E3D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

void PCException::PCException(PCException *this, const PCString *a2, const PCString *a3, int a4)
{
  *(void *)this = &unk_1F10C25D0;
  *((void *)this + 1) = 0;
  PCString::PCString((PCString *)this + 2, a2);
  PCString::PCString((PCString *)this + 3, a3);
  *((_DWORD *)this + 8) = a4;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
}

void sub_1B767E4A0(_Unwind_Exception *a1)
{
  PCString::~PCString(v3);
  PCCFRef<__CFArray const*>::~PCCFRef(v2);
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void PCIllegalArgumentException::~PCIllegalArgumentException(PCString *this)
{
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

void **PCException::what(const PCString *this)
{
  int var0_high = SHIBYTE(this[7].var0);
  if (var0_high < 0) {
    var0 = this[6].var0;
  }
  else {
    var0 = (__CFString *)HIBYTE(this[7].var0);
  }
  p_var0 = (void **)&this[5].var0;
  if (var0)
  {
    if ((var0_high & 0x80) == 0) {
      return p_var0;
    }
    return (void **)*p_var0;
  }
  PCException::getInfo(this, &v7);
  int v6 = PCString::createCStr(&v7);
  std::string::basic_string[abi:ne180100]<0>(&v8, v6);
  free(v6);
  if (SHIBYTE(this[7].var0) < 0) {
    operator delete(*p_var0);
  }
  *(_OWORD *)p_var0 = v8;
  this[7].var0 = v9;
  HIBYTE(v9) = 0;
  LOBYTE(v8) = 0;
  PCString::~PCString(&v7);
  if ((HIBYTE(this[7].var0) & 0x80) != 0) {
    return (void **)*p_var0;
  }
  return p_var0;
}

void sub_1B767E5C4(void *a1)
{
}

void PCIllegalArgumentException::className(PCURL *a1@<X8>)
{
}

uint64_t PCException::callStackSymbols(PCException *this)
{
  return *((void *)this + 1);
}

PCString *PCException::getInfo@<X0>(const PCString *this@<X0>, PCString *a2@<X8>)
{
  uint64_t v4 = (PCString *)&this[2];
  ((void (*)(const PCString *))this->var0->length)(this);
  __n128 result = (PCString *)PCString::size(v4);
  if (result)
  {
    PCString::PCString(&v6, ": ");
    PCString::append(a2, &v6);
    PCString::~PCString(&v6);
    __n128 result = PCString::append(a2, v4);
  }
  if (LODWORD(this[4].var0))
  {
    PCString::append(a2, " (");
    PCString::append(a2, this + 3);
    PCString::append(a2, ":");
    PCString::ssprintf((PCString *)"%d", &v6, LODWORD(this[4].var0));
    PCString::append(a2, &v6);
    PCString::~PCString(&v6);
    return PCString::append(a2, ")");
  }
  return result;
}

void sub_1B767E700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  PCString::~PCString(v10);
  _Unwind_Resume(a1);
}

void PCException::~PCException(PCString *this)
{
  this->var0 = (__CFString *)&unk_1F10C25D0;
  if (SHIBYTE(this[7].var0) < 0) {
    operator delete(this[5].var0);
  }
  PCString::~PCString(this + 3);
  PCString::~PCString(this + 2);
  PCCFRef<__CFArray const*>::~PCCFRef((const void **)&this[1].var0);

  std::exception::~exception((std::exception *)this);
}

{
  uint64_t vars8;

  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

UInt8 *PCCreatePrivateColorSpaceFromColorSpace(const char *a1, CGColorSpaceRef space)
{
  CFDataRef v4 = CGColorSpaceCopyICCData(space);
  int v5 = ColorSyncProfileCreate(v4, 0);
  ColorSyncMutableProfileRef MutableCopy = ColorSyncProfileCreateMutableCopy(v5);
  if (MutableCopy)
  {
    PCString v7 = MutableCopy;
    int v8 = strlen(a1);
    size_t v9 = (v8 + 91);
    Mutable = CFDataCreateMutable(0, v9);
    if (Mutable)
    {
      int v11 = Mutable;
      size_t v12 = (v8 + 1);
      CFDataSetLength(Mutable, v9);
      MutableBytePtr = CFDataGetMutableBytePtr(v11);
      bzero(MutableBytePtr, v9);
      *(_DWORD *)MutableBytePtr = 1668506980;
      *((_DWORD *)MutableBytePtr + OZChannelFontBase::~OZChannelFontBase(this - 2) = bswap32(v12);
      memcpy(MutableBytePtr + 12, a1, v12);
      ColorSyncProfileSetTag(v7, @"desc", v11);
      CFRelease(v11);
      ColorSyncMD5 MD5 = ColorSyncProfileGetMD5(v7);
      CFDataRef theData = ColorSyncProfileCopyHeader(v7);
      CFIndex Length = CFDataGetLength(theData);
      std::vector<unsigned char>::vector(&buffer, Length);
      v26.location = 0;
      v26.length = Length;
      CFDataGetBytes(theData, v26, buffer);
      long long v16 = buffer;
      long long v17 = v24;
      *(ColorSyncMD5 *)(buffer + 84) = MD5;
      CFDataRef v18 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v16, v17 - v16);
      CFDataRef v22 = v18;
      if (theData && theData != v18)
      {
        CFRelease(theData);
        CFDataRef v18 = v22;
      }
      CFDataRef theData = v18;
      CFDataRef v22 = 0;
      PCCFRef<__CTLine const*>::~PCCFRef((const void **)&v22);
      ColorSyncProfileSetHeader(v7, theData);
      if (buffer)
      {
        long long v24 = buffer;
        operator delete(buffer);
      }
      PCCFRef<__CTLine const*>::~PCCFRef((const void **)&theData);
      buffer = (UInt8 *)MEMORY[0x1BA9BE610](v7, 0);
      if (CGColorSpaceUsesExtendedRange(space))
      {
        PCCreateExtendedColorSpace((CGColorSpace **)&buffer, &theData);
        uint64_t v19 = (UInt8 *)theData;
        if (buffer && buffer != (UInt8 *)theData)
        {
          PCCFRefTraits<CGColorSpace *>::release((CGColorSpaceRef)buffer);
          uint64_t v19 = (UInt8 *)theData;
        }
        buffer = v19;
        CFDataRef theData = 0;
        PCCFRef<CGColorSpace *>::~PCCFRef(&theData);
      }
      CGColorSpaceRetain((CGColorSpaceRef)buffer);
      uint64_t v20 = buffer;
      PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&buffer);
    }
    else
    {
      uint64_t v20 = 0;
    }
    CFRelease(v7);
    if (v5) {
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v20 = 0;
    if (v5) {
LABEL_18:
    }
      CFRelease(v5);
  }
  if (v4) {
    CFRelease(v4);
  }
  return v20;
}

void sub_1B767E9F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, uint64_t a13, CGColorSpace *a14)
{
}

CGColorSpace *PCCreateColorSpaceFromAttachments(const __CFDictionary *a1)
{
  ColorSpaceFromAttachments = CVImageBufferCreateColorSpaceFromAttachments(a1);
  Value = CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E4F24BC8]);
  if (!Value) {
    return ColorSpaceFromAttachments;
  }
  CFDataRef v4 = Value;
  int v5 = (const void *)*MEMORY[0x1E4F24BF8];
  if (!CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F24BF8]) && !CFEqual(v4, (CFTypeRef)*MEMORY[0x1E4F24BD8])) {
    return ColorSpaceFromAttachments;
  }
  PCString v6 = CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E4F24A90]);
  PCString v7 = CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E4F24C18]);
  if (!v6 || v7 == 0) {
    return ColorSpaceFromAttachments;
  }
  if (v5 == v4)
  {
    size_t v9 = (__CFString *)CFStringCreateWithFormat(0, 0, @"%@ / PQ / %@", v6, v7);
  }
  else
  {
    if ((const void *)*MEMORY[0x1E4F24BD8] != v4) {
      return ColorSpaceFromAttachments;
    }
    size_t v9 = (__CFString *)CFStringCreateWithFormat(0, 0, @"%@ / HLG / %@", v6, v7);
  }
  if (v9)
  {
    size_t v10 = v9;
    int v11 = PCCreatePrivateColorSpaceFromColorSpace((const char *)[(__CFString *)v9 UTF8String], ColorSpaceFromAttachments);
    CGColorSpaceRelease(ColorSpaceFromAttachments);
    CFRelease(v10);
    return (CGColorSpace *)v11;
  }
  return ColorSpaceFromAttachments;
}

BOOL PCIsLinearColorSpace(CGColorSpace *a1)
{
  return PCGetNCLCCodeForColorSpace(a1) >> 32 == 8 || PCEstimateGamma(a1) == 1.0;
}

BOOL PCIsHDRColorSpace(CGColorSpace *a1)
{
  if (CGColorSpaceGetModel(a1) != kCGColorSpaceModelRGB) {
    return 0;
  }
  if (CGColorSpaceUsesITUR_2100TF(a1)) {
    return 1;
  }

  return PCIsLinearColorSpace(a1);
}

void *std::vector<unsigned char>::vector(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    CFDataRef v4 = (char *)a1[1];
    int v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B767EC9C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned char>::__vallocate[abi:ne180100](void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

std::vector<char> *__cdecl std::vector<char>::vector(std::vector<char> *this, std::vector<char>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](this, __n);
    std::vector<char>::pointer end = this->__end_;
    int v5 = &end[__n];
    bzero(end, __n);
    this->__end_ = v5;
  }
  return this;
}

void sub_1B767ED54(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B767EF90(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B767F0D0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B767F238(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

double operator*@<D0>(long long *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  long long v4 = *a1;
  uint64_t v5 = *((void *)a1 + 2);
  return PC_CMTimeMultiply64Divide64((uint64_t)&v4, *(void *)a2, *(int *)(a2 + 8), a3);
}

CMTime *operator*@<X0>(CMTime *a1@<X0>, CMTime *a2@<X8>, Float64 a3@<D0>)
{
  CMTime v4 = *a1;
  return CMTimeMultiplyByFloat64(a2, &v4, a3);
}

CMTime *operator*@<X0>(CMTime *a1@<X0>, int32_t a2@<W1>, CMTime *a3@<X8>)
{
  CMTime v4 = *a1;
  return CMTimeMultiply(a3, &v4, a2);
}

CMTime *operator*@<X0>(int32_t multiplier@<W0>, CMTime *a2@<X1>, CMTime *a3@<X8>)
{
  CMTime v4 = *a2;
  return CMTimeMultiply(a3, &v4, multiplier);
}

double operator/@<D0>(long long *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  long long v4 = *a1;
  uint64_t v5 = *((void *)a1 + 2);
  return PC_CMTimeMultiply64Divide64((uint64_t)&v4, *(int *)(a2 + 8), *(void *)a2, a3);
}

double operator/@<D0>(long long *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  long long v4 = *a1;
  uint64_t v5 = *((void *)a1 + 2);
  return PC_CMTimeMultiply64Divide64((uint64_t)&v4, 1, a2, a3);
}

double operator/@<D0>(long long *a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  long long v4 = *a1;
  uint64_t v5 = *((void *)a1 + 2);
  return PC_CMTimeMultiply64Divide64((uint64_t)&v4, 1, a2, a3);
}

double operator/@<D0>(long long *a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  int v3 = *((_DWORD *)a1 + 2);
  if (v3 && v3 < 0x20000)
  {
    while (vabdd_f64(floor((double)v3 * a3) / (double)v3, a3) >= 0.00001)
    {
      int v4 = 2 * v3;
      BOOL v5 = v3 < 0x10000;
      v3 *= 2;
      if (!v5) {
        goto LABEL_7;
      }
    }
  }
  int v4 = v3;
LABEL_7:
  long long v7 = *a1;
  uint64_t v8 = *((void *)a1 + 2);
  return PC_CMTimeMultiply64Divide64((uint64_t)&v7, v4, (uint64_t)((double)v4 * a3), a2);
}

CFDictionaryRef CMTimeRangeCopyAsDictionary(CMTimeRange *range, CFAllocatorRef allocator)
{
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  int v4 = (void *)*MEMORY[0x1E4F1FA18];
  keys[0] = *(void **)MEMORY[0x1E4F1FA28];
  keys[1] = v4;
  CMTime time = range->start;
  values[0] = CMTimeCopyAsDictionary(&time, allocator);
  CMTime duration = range->duration;
  values[1] = CMTimeCopyAsDictionary(&duration, allocator);
  CFDictionaryRef v5 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v6 = 0;
  char v7 = 1;
  do
  {
    char v8 = v7;
    size_t v9 = values[v6];
    if (v9) {
      CFRelease(v9);
    }
    char v7 = 0;
    uint64_t v6 = 1;
  }
  while ((v8 & 1) != 0);
  return v5;
}

CMTimeRange *__cdecl CMTimeRangeMakeFromDictionary(CMTimeRange *__return_ptr retstr, CFDictionaryRef dictionaryRepresentation)
{
  memset(&v8, 0, sizeof(v8));
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(dictionaryRepresentation, (const void *)*MEMORY[0x1E4F1FA28]);
  CMTimeMakeFromDictionary(&v8, Value);
  memset(&v7, 0, sizeof(v7));
  CFDictionaryRef v5 = (const __CFDictionary *)CFDictionaryGetValue(dictionaryRepresentation, (const void *)*MEMORY[0x1E4F1FA18]);
  CMTimeMakeFromDictionary(&v7, v5);
  CMTime v10 = v8;
  CMTime v9 = v7;
  return (CMTimeRange *)CMTimeRangeSaferMake(&v10, &v9, (uint64_t)retstr);
}

BOOL _svdCall(uint64_t a1, uint64_t a2)
{
  PCGenMatrix<double>::copy(a2, 0, (uint64_t)&v56);
  PCGenMatrix<double>::resize((_DWORD *)(a1 + 24), v57, v58, 0);
  uint64_t v4 = *(unsigned int *)(a1 + 32);
  if ((int)v4 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *(void **)(a1 + 48);
    uint64_t v7 = *(unsigned int *)(a1 + 36);
    uint64_t v8 = 8 * *(int *)(a1 + 40);
    uint64_t v9 = 8 * *(int *)(a1 + 44);
    do
    {
      CMTime v10 = v6;
      uint64_t v11 = v7;
      if ((int)v7 >= 1)
      {
        do
        {
          *CMTime v10 = 0;
          CMTime v10 = (void *)((char *)v10 + v9);
          --v11;
        }
        while (v11);
      }
      ++v5;
      uint64_t v6 = (void *)((char *)v6 + v8);
    }
    while (v5 != v4);
  }
  PCGenMatrix<double>::resize((_DWORD *)(a1 + 56), v58, v58, 1);
  uint64_t v12 = *(unsigned int *)(a1 + 64);
  if ((int)v12 >= 1)
  {
    uint64_t v13 = 0;
    long long v14 = *(void **)(a1 + 80);
    uint64_t v15 = *(unsigned int *)(a1 + 68);
    uint64_t v16 = 8 * *(int *)(a1 + 72);
    uint64_t v17 = 8 * *(int *)(a1 + 76);
    do
    {
      CFDataRef v18 = v14;
      uint64_t v19 = v15;
      if ((int)v15 >= 1)
      {
        do
        {
          *CFDataRef v18 = 0;
          CFDataRef v18 = (void *)((char *)v18 + v17);
          --v19;
        }
        while (v19);
      }
      ++v13;
      long long v14 = (void *)((char *)v14 + v16);
    }
    while (v13 != v12);
  }
  PCGenVector<double>::resize(a1 + 88, *(_DWORD *)(a2 + 12));
  uint64_t v20 = *(unsigned int *)(a1 + 96);
  if ((int)v20 >= 1)
  {
    uint64_t v21 = *(void **)(a1 + 104);
    uint64_t v22 = 8 * *(int *)(a1 + 100);
    do
    {
      *uint64_t v21 = 0;
      uint64_t v21 = (void *)((char *)v21 + v22);
      --v20;
    }
    while (v20);
  }
  PCGenVector<double>::resize(a1 + 112, *(_DWORD *)(a2 + 12));
  uint64_t v23 = *(unsigned int *)(a1 + 120);
  if ((int)v23 >= 1)
  {
    long long v24 = *(void **)(a1 + 128);
    uint64_t v25 = 8 * *(int *)(a1 + 124);
    do
    {
      *long long v24 = 0;
      long long v24 = (void *)((char *)v24 + v25);
      --v23;
    }
    while (v23);
  }
  PCGenVector<double>::resize(a1 + 136, 0);
  __CLPK_integer v27 = v57;
  __CLPK_integer v26 = v58;
  if (v57 >= 1)
  {
    uint64_t v28 = 0;
    do
    {
      if (v26 >= 1)
      {
        uint64_t v29 = 0;
        do
        {
          PCGenMatrix<double>::checkColIndex((uint64_t)&v56, v29);
          PCGenMatrix<double>::checkRowIndex((uint64_t)&v56, v28);
          if ((*(void *)&v61[v60 * (int)v29 + v59 * (int)v28] & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
          {
            PCGenMatrix<double>::operator()((uint64_t)&v56, v28, v29);
            exception = (PCException *)__cxa_allocate_exception(0x40uLL);
            PCString::PCString(&v46, "NaN");
            PCException::PCException(exception, &v46);
            *(void *)exception = &unk_1F1199218;
          }
          uint64_t v29 = (v29 + 1);
          __CLPK_integer v26 = v58;
        }
        while ((int)v29 < v58);
        __CLPK_integer v27 = v57;
      }
      uint64_t v28 = (v28 + 1);
    }
    while ((int)v28 < v27);
  }
  char __jobu = 83;
  char __jobvt = 65;
  __CLPK_integer __n = v26;
  __CLPK_integer __m = v27;
  __CLPK_integer __ldu = v27;
  __CLPK_integer __lda = v27;
  __CLPK_integer __ldvt = v26;
  if (v27 <= v26) {
    __CLPK_integer v30 = v26;
  }
  else {
    __CLPK_integer v30 = v27;
  }
  int v31 = 10 * v30;
  int v32 = 2 * v27 * v26;
  if (v31 <= v32) {
    uint64_t v33 = v32;
  }
  else {
    uint64_t v33 = v31;
  }
  __CLPK_integer __lwork = v33;
  PCGenVector<double>::PCGenVector((double **)&v46, v33, 0.0);
  __CLPK_integer v45 = 0;
  int v34 = dgesvd_(&__jobu, &__jobvt, &__m, &__n, v61, &__lda, *(__CLPK_doublereal **)(a1 + 104), *(__CLPK_doublereal **)(a1 + 48), &__ldu, *(__CLPK_doublereal **)(a1 + 80), &__ldvt, v47, &__lwork, &v45);
  __CLPK_integer v35 = v45;
  int v36 = v34 | v45;
  *(unsigned char *)(a1 + 224) = (v34 | v45) == 0;
  if (v35 < 0)
  {
    long long v43 = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"dgesvd: bad parameter %d", &v44, -v45);
    PCException::PCException(v43, &v44);
  }
  var0 = v46.var0;
  if (v46.var0)
  {
    int v38 = HIDWORD(v46.var0[-1].length) - 1;
    HIDWORD(v46.var0[-1].length) = v38;
    if (!v38) {
      MEMORY[0x1BA9BFB70](&var0[-1].length, 0x1000C8077774924);
    }
  }
  uint64_t v39 = v56;
  if (v56)
  {
    int v40 = *(_DWORD *)(v56 - 4) - 1;
    *(_DWORD *)(v56 - 4) = v40;
    if (!v40) {
      MEMORY[0x1BA9BFB70](v39 - 8, 0x1000C8077774924);
    }
  }
  return v36 == 0;
}

void sub_1B7680230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, PCString a16, uint64_t a17, PCString a18)
{
  PCString::~PCString(&a16);
  var0 = a18.var0;
  if (a18.var0)
  {
    int v21 = HIDWORD(a18.var0[-1].length) - 1;
    HIDWORD(a18.var0[-1].length) = v21;
    if (!v21) {
      MEMORY[0x1BA9BFB70](&var0[-1].length, 0x1000C8077774924);
    }
  }
  uint64_t v22 = *(void *)(v18 - 80);
  if (v22)
  {
    int v23 = *(_DWORD *)(v22 - 4) - 1;
    *(_DWORD *)(v22 - 4) = v23;
    if (!v23) {
      MEMORY[0x1BA9BFB70](v22 - 8, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(a1);
}

_DWORD *PCGenMatrix<double>::copy@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v6 = *(_DWORD *)(a1 + 8);
  int v7 = *(_DWORD *)(a1 + 12);
  PCGenBlockRef<double>::PCGenBlockRef((void *)a3, v7 * v6);
  *(_DWORD *)(a3 + 8) = v6;
  *(_DWORD *)(a3 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = v7;
  if (a2) {
    int v8 = v7;
  }
  else {
    int v8 = 1;
  }
  if (a2) {
    int v9 = 1;
  }
  else {
    int v9 = v6;
  }
  *(_DWORD *)(a3 + 16) = v8;
  *(_DWORD *)(a3 + 20) = v9;
  *(void *)(a3 + 24) = *(void *)a3;
  return PCGenMatrix<double>::set<double>((_DWORD *)a3, a1);
}

void sub_1B768038C(_Unwind_Exception *a1)
{
  PCGenBlockRef<double>::deref(v1);
  _Unwind_Resume(a1);
}

_DWORD *PCGenMatrix<double>::resize(_DWORD *result, int a2, int a3, int a4)
{
  uint64_t v6 = (uint64_t)result;
  int v8 = result[2];
  int v7 = result[3];
  BOOL v10 = v8 != a2 || v7 != a3;
  if (a4)
  {
    if (a4 == 1)
    {
      if (result[5] == 1)
      {
        if (result[4] != v7) {
          LOBYTE(v10) = 1;
        }
        if (!v10) {
          return result;
        }
      }
    }
    else if (!v10)
    {
      return result;
    }
    int v11 = 0;
LABEL_21:
    __n128 result = PCGenBlockRef<double>::PCGenBlockRef(&v32, a3 * a2);
    *(void *)&long long v33 = __PAIR64__(a3, a2);
    if (v11) {
      int v12 = 1;
    }
    else {
      int v12 = a3;
    }
    if (v11) {
      int v13 = a2;
    }
    else {
      int v13 = 1;
    }
    *((void *)&v33 + 1) = __PAIR64__(v13, v12);
    int v14 = *(_DWORD *)(v6 + 12);
    if (a2 >= *(_DWORD *)(v6 + 8)) {
      int v15 = *(_DWORD *)(v6 + 8);
    }
    else {
      int v15 = a2;
    }
    uint64_t v16 = v32;
    uint64_t v34 = v32;
    if (a3 >= v14) {
      int v17 = v14;
    }
    else {
      int v17 = a3;
    }
    unsigned int v18 = v15 - 1;
    if (v15 >= 1 && v17 >= 1)
    {
      v30[0] = 0;
      v30[1] = v15 - 1;
      unsigned int v20 = v17 - 1;
      v29[0] = 0;
      v29[1] = v17 - 1;
      PCGenMatrix<double>::operator()((uint64_t)result, v30, v29, (uint64_t)v31);
      v27[0] = 0;
      v27[1] = v18;
      v26[0] = 0;
      v26[1] = v20;
      PCGenMatrix<double>::operator()(v6, v27, v26, (uint64_t)v28);
      __n128 result = (_DWORD *)PCGenMatrix<double>::set<double>(v31, v28);
      uint64_t v21 = v28[0];
      if (v28[0])
      {
        int v22 = *(_DWORD *)(v28[0] - 4) - 1;
        *(_DWORD *)(v28[0] - 4) = v22;
        if (!v22) {
          __n128 result = (_DWORD *)MEMORY[0x1BA9BFB70](v21 - 8, 0x1000C8077774924);
        }
      }
      uint64_t v23 = v31[0];
      if (v31[0])
      {
        int v24 = *(_DWORD *)(v31[0] - 4) - 1;
        *(_DWORD *)(v31[0] - 4) = v24;
        if (!v24) {
          __n128 result = (_DWORD *)MEMORY[0x1BA9BFB70](v23 - 8, 0x1000C8077774924);
        }
      }
      uint64_t v16 = v32;
    }
    if (&v32 != (uint64_t *)v6)
    {
      *(_OWORD *)(v6 + 8) = v33;
      if (*(void *)v6 != v16)
      {
        __n128 result = PCGenBlockRef<double>::deref((void *)v6);
        *(void *)uint64_t v6 = v16;
        if (v16) {
          ++*(_DWORD *)(v16 - 4);
        }
      }
      uint64_t v16 = v32;
      *(void *)(v6 + 24) = v34;
    }
    if (v16)
    {
      int v25 = *(_DWORD *)(v16 - 4) - 1;
      *(_DWORD *)(v16 - 4) = v25;
      if (!v25) {
        return (_DWORD *)MEMORY[0x1BA9BFB70](v16 - 8, 0x1000C8077774924);
      }
    }
    return result;
  }
  if (result[4] != 1) {
    goto LABEL_18;
  }
  if (result[5] != v8) {
    LOBYTE(v10) = 1;
  }
  if (v10)
  {
LABEL_18:
    int v11 = 1;
    goto LABEL_21;
  }
  return result;
}

void sub_1B76805AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a11)
  {
    int v19 = *(_DWORD *)(a11 - 4) - 1;
    *(_DWORD *)(a11 - 4) = v19;
    if (!v19) {
      MEMORY[0x1BA9BFB70](a11 - 8, 0x1000C8077774924);
    }
  }
  if (a17)
  {
    int v20 = *(_DWORD *)(a17 - 4) - 1;
    *(_DWORD *)(a17 - 4) = v20;
    if (!v20) {
      MEMORY[0x1BA9BFB70](a17 - 8, 0x1000C8077774924);
    }
  }
  uint64_t v21 = *(void *)(v17 - 80);
  if (v21)
  {
    int v22 = *(_DWORD *)(v21 - 4) - 1;
    *(_DWORD *)(v21 - 4) = v22;
    if (!v22) {
      MEMORY[0x1BA9BFB70](v21 - 8, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(exception_object);
}

void PCGenVector<double>::resize(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 8) != a2)
  {
    PCGenBlockRef<double>::PCGenBlockRef(&v13, a2);
    int v4 = *(_DWORD *)(a1 + 8);
    if (a2 >= v4) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = a2;
    }
    uint64_t v6 = v13;
    bzero(v13, 8 * a2);
    uint64_t v7 = *(int *)(a1 + 12);
    int v8 = *(void **)(a1 + 16);
    if (v7 == 1)
    {
      if (v8) {
        memcpy(v6, v8, 8 * (int)v5);
      }
    }
    else if (v8 && (int)v5 >= 1)
    {
      uint64_t v9 = 8 * v7;
      BOOL v10 = v6;
      do
      {
        *v10++ = *v8;
        int v8 = (void *)((char *)v8 + v9);
        --v5;
      }
      while (v5);
    }
    int v11 = v13;
    if (*(void **)a1 != v13)
    {
      PCGenBlockRef<double>::deref((void *)a1);
      *(void *)a1 = v11;
      if (v11) {
        ++*(v11 - 1);
      }
      int v11 = v13;
    }
    *(void *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 8) = a2;
    *(_DWORD *)(a1 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = 1;
    if (v11)
    {
      int v12 = *(v11 - 1) - 1;
      *(v11 - 1) = v12;
      if (!v12) {
        MEMORY[0x1BA9BFB70](v11 - 2, 0x1000C8077774924);
      }
    }
  }
}

uint64_t PCGenMatrix<double>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a3;
  PCGenMatrix<double>::checkColIndex(a1, a3);
  PCGenMatrix<double>::checkRowIndex(a1, a2);
  return *(void *)(a1 + 24) + 8 * (*(_DWORD *)(a1 + 20) * v3 + *(_DWORD *)(a1 + 16) * (int)a2);
}

uint64_t PCGenVector<double>::operator()(uint64_t a1, uint64_t a2)
{
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(a1 + 8) <= (int)a2)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenVector index %d out of range %d", &v6, a2, (*(_DWORD *)(a1 + 8) - 1));
    PCException::PCException(exception, &v6);
    *(void *)exception = &unk_1F10C2560;
  }
  return *(void *)(a1 + 16) + 8 * *(_DWORD *)(a1 + 12) * (int)a2;
}

void sub_1B7680890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12)
{
}

void PCException::PCException(PCException *this, const PCString *a2)
{
  *(void *)this = &unk_1F10C25D0;
  *((void *)this + 1) = 0;
  PCString::PCString((PCString *)this + 2, a2);
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 3);
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
}

void sub_1B7680934(_Unwind_Exception *a1)
{
  PCString::~PCString(v3);
  PCCFRef<__CFArray const*>::~PCCFRef(v2);
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void *PCGenBlockRef<double>::PCGenBlockRef(void *result, int a2)
{
  if (a2) {
    operator new[]();
  }
  *__n128 result = 0;
  return result;
}

void *PCGenBlockRef<double>::deref(void *result)
{
  uint64_t v1 = *result;
  if (*result)
  {
    int v2 = *(_DWORD *)(v1 - 4) - 1;
    *(_DWORD *)(v1 - 4) = v2;
    if (!v2)
    {
      int v3 = result;
      __n128 result = (void *)MEMORY[0x1BA9BFB70](v1 - 8, 0x1000C8077774924);
      *int v3 = 0;
    }
  }
  return result;
}

void PCMatrixErrorException::~PCMatrixErrorException(PCString *this)
{
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

void PCMatrixErrorException::className(PCURL *a1@<X8>)
{
}

_DWORD *PCGenMatrix<double>::set<double>(_DWORD *result, uint64_t a2)
{
  if ((_DWORD *)a2 != result)
  {
    int v3 = result;
    int v4 = result[2];
    if (v4 != *(_DWORD *)(a2 + 8))
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"PCGenMatrix row mismatch %d != %d", &v31, v3[2], *(unsigned int *)(a2 + 8));
      PCException::PCException(exception, &v31);
      *(void *)exception = &unk_1F10C2560;
    }
    int v5 = result[3];
    if (v5 != *(_DWORD *)(a2 + 12))
    {
      __CLPK_integer v30 = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"PCGenMatrix col mismatch %d != %d", &v31, v3[3], *(unsigned int *)(a2 + 12));
      PCException::PCException(v30, &v31);
      *(void *)__CLPK_integer v30 = &unk_1F10C2560;
    }
    uint64_t v6 = *(void *)result;
    if (!*(void *)result)
    {
      __n128 result = PCGenMatrix<double>::resize(result, v4, v5, result[5] == 1);
      uint64_t v6 = *(void *)v3;
    }
    if (*(void *)a2 == v6)
    {
      v31.var0 = 0;
      uint64_t v32 = 0;
      uint64_t v33 = 0x100000001;
      uint64_t v34 = 0;
      __n128 result = (_DWORD *)PCGenMatrix<double>::set<double>(&v31, a2);
      uint64_t v17 = v3[2];
      if ((int)v17 >= 1)
      {
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        uint64_t v20 = v3[3];
        uint64_t v21 = v34;
        uint64_t v22 = 8 * (int)v33;
        uint64_t v23 = 8 * SHIDWORD(v33);
        do
        {
          if ((int)v20 >= 1)
          {
            int v24 = (void *)(*((void *)v3 + 3) + v18 * (int)v3[4]);
            uint64_t v25 = 8 * (int)v3[5];
            uint64_t v26 = v20;
            __n128 result = v21;
            do
            {
              *int v24 = *(void *)result;
              int v24 = (void *)((char *)v24 + v25);
              __n128 result = (_DWORD *)((char *)result + v23);
              --v26;
            }
            while (v26);
          }
          ++v19;
          v18 += 8;
          uint64_t v21 = (_DWORD *)((char *)v21 + v22);
        }
        while (v19 != v17);
      }
      var0 = v31.var0;
      if (v31.var0)
      {
        int v28 = HIDWORD(v31.var0[-1].length) - 1;
        HIDWORD(v31.var0[-1].length) = v28;
        if (!v28) {
          return (_DWORD *)MEMORY[0x1BA9BFB70](&var0[-1].length, 0x1000C8077774924);
        }
      }
    }
    else
    {
      uint64_t v7 = v3[2];
      if ((int)v7 >= 1)
      {
        uint64_t v8 = 0;
        uint64_t v9 = 0;
        uint64_t v10 = v3[3];
        int v11 = *(_DWORD **)(a2 + 24);
        uint64_t v12 = 8 * *(int *)(a2 + 16);
        uint64_t v13 = 8 * *(int *)(a2 + 20);
        do
        {
          if ((int)v10 >= 1)
          {
            int v14 = (void *)(*((void *)v3 + 3) + v8 * (int)v3[4]);
            uint64_t v15 = 8 * (int)v3[5];
            uint64_t v16 = v10;
            __n128 result = v11;
            do
            {
              *int v14 = *(void *)result;
              int v14 = (void *)((char *)v14 + v15);
              __n128 result = (_DWORD *)((char *)result + v13);
              --v16;
            }
            while (v16);
          }
          ++v9;
          v8 += 8;
          int v11 = (_DWORD *)((char *)v11 + v12);
        }
        while (v9 != v7);
      }
    }
  }
  return result;
}

void sub_1B7680D1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCString a11)
{
}

uint64_t PCGenMatrix<double>::operator()@<X0>(uint64_t a1@<X0>, unsigned int *a2@<X1>, unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  PCGenMatrix<double>::checkRowIndex(a1, *a2);
  PCGenMatrix<double>::checkRowIndex(a1, a2[1]);
  PCGenMatrix<double>::checkColIndex(a1, *a3);
  uint64_t result = PCGenMatrix<double>::checkColIndex(a1, a3[1]);
  int v10 = *a2;
  unsigned int v9 = a2[1];
  int v12 = *a3;
  unsigned int v11 = a3[1];
  int v14 = *(_DWORD *)(a1 + 16);
  int v13 = *(_DWORD *)(a1 + 20);
  uint64_t v15 = *(void *)(a1 + 24);
  uint64_t v16 = *(void *)a1;
  *(void *)a4 = *(void *)a1;
  if (v16) {
    ++*(_DWORD *)(v16 - 4);
  }
  *(_DWORD *)(a4 + 8) = v9 - v10 + 1;
  *(_DWORD *)(a4 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = v11 - v12 + 1;
  *(_DWORD *)(a4 + 16) = v14;
  *(_DWORD *)(a4 + 20) = v13;
  *(void *)(a4 + 24) = v15 + 8 * v14 * v10 + 8 * v13 * v12;
  return result;
}

uint64_t PCGenMatrix<double>::checkRowIndex(uint64_t result, uint64_t a2)
{
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(result + 8) <= (int)a2)
  {
    uint64_t v3 = result;
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenMatrix row %d out of range 0..%d", &v5, a2, (*(_DWORD *)(v3 + 8) - 1));
    PCException::PCException(exception, &v5);
    *(void *)exception = &unk_1F10C2560;
  }
  return result;
}

void sub_1B7680EDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12)
{
}

uint64_t PCGenMatrix<double>::checkColIndex(uint64_t result, uint64_t a2)
{
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(result + 12) <= (int)a2)
  {
    uint64_t v3 = result;
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenMatrix col %d out of range 0..%d", &v5, a2, (*(_DWORD *)(v3 + 12) - 1));
    PCException::PCException(exception, &v5);
    *(void *)exception = &unk_1F10C2560;
  }
  return result;
}

void sub_1B7680FC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12)
{
}

double **PCGenVector<double>::PCGenVector(double **a1, uint64_t a2, double a3)
{
  uint64_t v6 = PCGenBlockRef<double>::PCGenBlockRef(a1, a2);
  *((_DWORD *)v6 + OZChannelFontBase::~OZChannelFontBase(this - 2) = a2;
  *((_DWORD *)v6 + 3) = 1;
  if ((a2 & 0x80000000) != 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenVector length %d must be nonnegative", &v11, a2);
    PCException::PCException(exception, &v11);
    *(void *)exception = &unk_1F10C2560;
  }
  uint64_t v7 = *a1;
  a1[2] = *a1;
  if (a2)
  {
    unsigned int v8 = a2 + 1;
    do
    {
      *v7++ = a3;
      --v8;
    }
    while (v8 > 1);
  }
  return a1;
}

void sub_1B76810DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  PCGenBlockRef<double>::deref(v10);
  _Unwind_Resume(a1);
}

uint64_t PCGenVector<double>::set<double>(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 8);
    if (v4 != *(_DWORD *)(a2 + 8))
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"PCGenVector length mismatch %d != %d", &v19, *(unsigned int *)(a1 + 8), *(unsigned int *)(a2 + 8));
      PCException::PCException(exception, &v19);
      *(void *)exception = &unk_1F10C2560;
    }
    if (*(void *)a1) {
      BOOL v5 = *(void *)a2 == *(void *)a1;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {
      PCGenBlockRef<double>::PCGenBlockRef(&v19, *(_DWORD *)(a1 + 8));
      int v20 = v4;
      int v21 = 1;
      var0 = v19.var0;
      PCGenVector<double>::set<double>(&v19, a2);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      if ((int)v10 >= 1)
      {
        PCString v11 = var0;
        int v12 = *(void ***)(a1 + 16);
        uint64_t v13 = 8 * *(int *)(a1 + 12);
        uint64_t v14 = 8 * v21;
        do
        {
          *int v12 = v11->isa;
          int v12 = (void **)((char *)v12 + v13);
          PCString v11 = (__CFString *)((char *)v11 + v14);
          --v10;
        }
        while (v10);
      }
      uint64_t v15 = v19.var0;
      if (v19.var0)
      {
        int v16 = HIDWORD(v19.var0[-1].length) - 1;
        HIDWORD(v19.var0[-1].length) = v16;
        if (!v16) {
          MEMORY[0x1BA9BFB70](&v15[-1].length, 0x1000C8077774924);
        }
      }
    }
    else if ((int)v4 >= 1)
    {
      uint64_t v6 = *(void **)(a2 + 16);
      uint64_t v7 = *(void **)(a1 + 16);
      uint64_t v8 = 8 * *(int *)(a1 + 12);
      uint64_t v9 = 8 * *(int *)(a2 + 12);
      do
      {
        *uint64_t v7 = *v6;
        uint64_t v7 = (void *)((char *)v7 + v8);
        uint64_t v6 = (void *)((char *)v6 + v9);
        --v4;
      }
      while (v4);
    }
  }
  return a1;
}

void sub_1B76812C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12)
{
}

void OUTLINED_FUNCTION_0()
{
  JUMPOUT(0x1BA9BFB70);
}

void PCGenMatrix<double>::set<double>(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 - 4) - 1;
  *(_DWORD *)(a1 - 4) = v1;
  if (!v1) {
    OUTLINED_FUNCTION_0();
  }
}

void PCException::report(const PCString *this)
{
  PCException::getInfo(this, &v5);
  int v1 = PCString::createCStr(&v5);
  int v2 = v1;
  if (v1)
  {
    size_t v3 = strlen(v1);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)v2, v3);
    free(v2);
  }
  std::ios_base::getloc((const std::ios_base *)(MEMORY[0x1E4FBA240] + *(void *)(*MEMORY[0x1E4FBA240] - 24)));
  uint64_t v4 = std::locale::use_facet(&v6, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 10);
  std::locale::~locale(&v6);
  std::ostream::put();
  std::ostream::flush();
  PCString::~PCString(&v5);
}

void sub_1B7681468(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void throw_PCNullPointerException(BOOL a1)
{
  exception = (PCNullPointerException *)__cxa_allocate_exception(0x40uLL);
  PCNullPointerException::PCNullPointerException(exception, a1);
}

void sub_1B76814D4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void PCException::className(PCURL *a1@<X8>)
{
}

void PCNullPointerException::PCNullPointerException(PCNullPointerException *this, int a2)
{
  PCException::PCException(this);
  *uint64_t v4 = &unk_1F10C2610;
  if (a2) {
    PCException::addCallStackSymbols(this);
  }
}

void sub_1B768158C(_Unwind_Exception *a1)
{
  PCException::~PCException(v1);
  _Unwind_Resume(a1);
}

void PCException::PCException(PCException *this)
{
  *(void *)this = &unk_1F10C25D0;
  *((void *)this + 1) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 2);
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 3);
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
}

void sub_1B7681610(_Unwind_Exception *a1)
{
  PCString::~PCString(v3);
  PCCFRef<__CFArray const*>::~PCCFRef(v2);
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void PCNullPointerException::~PCNullPointerException(PCString *this)
{
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

void PCNullPointerException::className(PCURL *a1@<X8>)
{
}

void sub_1B7681848(void *a1)
{
}

void sub_1B7681878(_Unwind_Exception *a1)
{
}

CGColorSpaceRef PCCreateExtendedColorSpace@<X0>(CGColorSpace **a1@<X0>, CGColorSpaceRef *a2@<X8>)
{
  CGColorSpaceRef result = createExtendedColorSpace(*a1);
  *a2 = result;
  return result;
}

CGColorSpaceRef createExtendedColorSpace(CGColorSpace *a1)
{
  if (CGColorSpaceUsesExtendedRange(a1))
  {
LABEL_2:
    return CGColorSpaceRetain(a1);
  }
  {
    createExtendedColorSpace(CGColorSpace *)::deviceRGB = (uint64_t)CGColorSpaceCreateDeviceRGB();
  }
  CFHashCode v3 = CFHash((CFTypeRef)createExtendedColorSpace(CGColorSpace *)::deviceRGB);
  if (v3 != CFHash(a1))
  {
    CGColorSpaceRef result = CGColorSpaceCreateExtended(a1);
    if (result) {
      return result;
    }
    goto LABEL_2;
  }
  CFStringRef v4 = (const __CFString *)*MEMORY[0x1E4F1DBE8];

  return CGColorSpaceCreateWithName(v4);
}

void sub_1B7681B74(_Unwind_Exception *a1)
{
}

void PCInit(void)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  {
    uint64_t v0 = (ProCore::Private *)getrlimit(8, &v7);
    if (!v0)
    {
      *(void *)uint64_t v8 = 0x1D00000001;
      int v6 = 0;
      size_t v5 = 4;
      uint64_t v0 = (ProCore::Private *)sysctl(v8, 2u, &v6, &v5, 0, 0);
      if (!v0)
      {
        int v3 = v6;
        if (v6 >= 10240) {
          int v3 = 10240;
        }
        v7.rlim_cur = v3;
        uint64_t v0 = (ProCore::Private *)setrlimit(8, &v7);
      }
    }
    ProCore::Private::initChromaticityMath(v0, v1, v2);
    ProCore::Private::initColorSpaceHandle(v4);
  }
}

uint64_t PCBitDepth::getBitsPerChannel(int a1)
{
  return PCBitDepth::_bitsPerChannel[a1];
}

uint64_t PCBitDepth::getFromBitsPerChannel(PCBitDepth *this, int a2)
{
  if (a2) {
    unsigned int v2 = 1;
  }
  else {
    unsigned int v2 = 2;
  }
  if (this != 16) {
    unsigned int v2 = 0;
  }
  if (this == 32) {
    return 3;
  }
  else {
    return v2;
  }
}

uint64_t PCBitmap::sanitizeColorSpace(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = a1;
  if (!a1)
  {
    hasRGB = (PCInfo *)PCPixelFormat::hasRGB(a2);
    if (hasRGB)
    {
      uint64_t DefaultRGBCGColorSpace = PCInfo::getDefaultRGBCGColorSpace(hasRGB);
    }
    else
    {
      hasGray = (PCInfo *)PCPixelFormat::hasGray(a2);
      if (!hasGray)
      {
        uint64_t v3 = 0;
        goto LABEL_8;
      }
      uint64_t DefaultRGBCGColorSpace = PCInfo::getDefaultGrayscaleCGColorSpace(hasGray);
    }
    uint64_t v3 = DefaultRGBCGColorSpace;
  }
LABEL_8:
  if ((PCPixelFormat::hasRGB(a2) & 1) == 0 && !PCPixelFormat::hasGray(a2)) {
    return 0;
  }
  return v3;
}

void PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
  int v7 = (*(uint64_t (**)(void))(*(void *)*a2 + 40))();
  unsigned int v8 = (*(uint64_t (**)(void))(*(void *)*a2 + 48))();
  int BitsPerChannel = PCPixelFormat::getBitsPerChannel(v8);
  unsigned int v10 = (*(uint64_t (**)(void))(*(void *)*a2 + 48))();
  int NumChannels = PCPixelFormat::getNumChannels(v10);
  unsigned int v12 = (*(uint64_t (**)(void))(*(void *)*a2 + 48))();
  uint64_t v13 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(a3, v12);
  PCImage::PCImage((PCImage *)a1, v6, v7, BitsPerChannel, NumChannels, v13);
  *(void *)a1 = &unk_1F10C2650;
  uint64_t v14 = *a2;
  *a2 = 0;
  *(void *)(a1 + 64) = v14;
  *(_DWORD *)(a1 + 24) = 1;
}

void PCBitmap::PCBitmap()
{
}

{
  operator new();
}

{
  operator new();
}

{
  operator new();
}

void sub_1B7681F54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void sub_1B768205C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void sub_1B768216C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C4028F97B41);
  _Unwind_Resume(a1);
}

void sub_1B768227C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C4028F97B41);
  _Unwind_Resume(a1);
}

void PCBitmap::copy(PCBitmap *this, PCBitmap *a2)
{
  PCImage::getColorSpace((PCImage *)a2, &v8);
  (*(void (**)(PCBitmap *, CGColorSpace **))(*(void *)this + 56))(this, &v8);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v8);
  char v4 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 48))(a2);
  PCImage::setIsPremultiplied((uint64_t)this, v4);
  int v5 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
  int v7 = (PCBitmap *)1;
  if (v5 == (*(unsigned int (**)(PCBitmap *))(*(void *)a2 + 16))(a2))
  {
    int v6 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
    if (v6 == (*(unsigned int (**)(PCBitmap *))(*(void *)a2 + 24))(a2)) {
      int v7 = 0;
    }
  }
}

void sub_1B7682430(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PCBitmap::~PCBitmap(PCBitmap *this)
{
  *(void *)this = &unk_1F10C2650;
  uint64_t v2 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  PCImage::~PCImage((CGColorSpace **)this);
}

{
  uint64_t vars8;

  PCBitmap::~PCBitmap(this);

  JUMPOUT(0x1BA9BFBA0);
}

void PCBitmap::PCBitmap(PCBitmap *this, const PCBitmap *a2)
{
}

void sub_1B7682610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  PCBitmap::~PCBitmap(v10);
  _Unwind_Resume(a1);
}

uint64_t PCBitmap::getRepresentation(PCBitmap *this)
{
  return *((void *)this + 8);
}

unint64_t PCBitmap::getSize(PCBitmap *this)
{
  unsigned int v2 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
  return (*(unsigned int (**)(PCBitmap *))(*(void *)this + 24))(this) * (unint64_t)v2;
}

uint64_t PCBitmap::getBytesPerRow(PCBitmap *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 8) + 64))();
}

uint64_t PCBitmap::getAllocationSize(PCBitmap *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 8) + 24))();
}

uint64_t PCBitmap::getWidth(PCBitmap *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 8) + 32))();
}

uint64_t PCBitmap::getHeight(PCBitmap *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 8) + 40))();
}

void PCBitmap::copyWithColorSpaceConversion(PCBitmap *this, PCBitmap *a2)
{
}

void anonymous namespace'::copyBitmapImageUsingCG(_anonymous_namespace_ *this, PCBitmap *a2, PCBitmap *a3)
{
  int v3 = (int)a3;
  if (!(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this)
    || !(*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this)
    || !(*(unsigned int (**)(PCBitmap *))(*(void *)a2 + 16))(a2)
    || !(*(unsigned int (**)(PCBitmap *))(*(void *)a2 + 24))(a2))
  {
    return;
  }
  int v6 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
  unsigned int v7 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
  int v8 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
  int v9 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
  if (v6 == v8 && v7 == v9)
  {
    PCImage::getColorSpace(this, image);
    PCImage::getColorSpace((PCImage *)a2, c);
    BOOL isSameColorSpace = PCColorSpaceHandle::isSameColorSpace(image, c, v11);
    PCCFRef<CGColorSpace *>::~PCCFRef(c);
    PCCFRef<CGColorSpace *>::~PCCFRef(image);
    if (isSameColorSpace)
    {
      int v13 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
      if (v13 == (*(unsigned int (**)(PCBitmap *))(*(void *)a2 + 48))(a2))
      {
        unsigned int v14 = (*(uint64_t (**)(void))(**((void **)this + 8) + 48))(*((void *)this + 8));
        unsigned int v15 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8));
        if (v14 == v15)
        {
          unsigned int v16 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          unsigned int v17 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
          int v18 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          if (v18 == (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8)))
          {
            PCString v19 = (void *)(*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
            int v20 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
            size_t v21 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 40))(this);
            memcpy(v19, v20, v21);
          }
          else
          {
            int v24 = (char *)(*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
            uint64_t v25 = (char *)(*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
            unsigned int v26 = (*(uint64_t (**)(void))(**((void **)this + 8) + 48))(*((void *)this + 8));
            int BytesPerPixel = PCPixelFormat::getBytesPerPixel(v26);
            if (v7)
            {
              uint64_t v28 = v7;
              size_t v29 = (BytesPerPixel * v6);
              do
              {
                memcpy(v25, v24, v29);
                v24 += v16;
                v25 += v17;
                --v28;
              }
              while (v28);
            }
          }
          return;
        }
        unsigned int v22 = v15;
        if (PCPixelFormat::hasRGB(v14) && PCPixelFormat::hasRGB(v22))
        {
          if (PCPixelFormat::is32Bit(v14) && PCPixelFormat::is32Bit(v22))
          {
            return;
          }
          if (PCPixelFormat::is8Bit(v14) && PCPixelFormat::is8Bit(v22))
          {
            return;
          }
        }
      }
    }
  }
  unsigned int v31 = (*(uint64_t (**)(void))(**((void **)this + 8) + 48))(*((void *)this + 8));
  int hasAlpha = PCPixelFormat::hasAlpha(v31);
  unsigned int v33 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8));
  if (PCPixelFormat::hasGray(v33)) {
    int v34 = PCPixelFormat::hasAlpha(v33);
  }
  else {
    int v34 = 0;
  }
  unsigned int v35 = (*(uint64_t (**)(void))(**((void **)this + 8) + 48))(*((void *)this + 8));
  if (v35 > 0x11 || ((1 << v35) & 0x3C1AE) == 0)
  {
    int v38 = image[0];
    v82 = (std::__shared_weak_count *)image[1];
  }
  else
  {
    v82 = 0;
    int v38 = this;
  }
  if ((hasAlpha & v34) == 1)
  {
    switch((*(unsigned int (**)(void))(**((void **)this + 8) + 48))(*((void *)this + 8)))
    {
      case 2u:
        int v39 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v40 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v41 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, 1u);
        PCCreateBitmap(v39, v40, 1, v41);
      case 3u:
        int v42 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v43 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        PCString v44 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, 1u);
        PCCreateBitmap(v42, v43, 1, v44);
      case 4u:
        int v45 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v46 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v47 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, 1u);
        PCCreateBitmap(v45, v46, 1, v47);
      case 5u:
        int v48 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v49 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v50 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, 1u);
        PCCreateBitmap(v48, v49, 1, v50);
      case 6u:
        int v51 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v52 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v53 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, 1u);
        PCCreateBitmap(v51, v52, 1, v53);
      case 8u:
        int v54 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v55 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v56 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, 7u);
        PCCreateBitmap(v54, v55, 7, v56);
      case 0xAu:
        int v57 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v58 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        int v59 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, 7u);
        PCCreateBitmap(v57, v58, 7, v59);
      case 0xCu:
        int v60 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v61 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v62 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, 0xEu);
        PCCreateBitmap(v60, v61, 14, v62);
      case 0xDu:
        int v63 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v64 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v65 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, 0xEu);
        PCCreateBitmap(v63, v64, 14, v65);
      case 0xFu:
        int v66 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v67 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v68 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, 0xEu);
        PCCreateBitmap(v66, v67, 14, v68);
      case 0x10u:
        int v69 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v70 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v71 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, 0xEu);
        PCCreateBitmap(v69, v70, 14, v71);
      case 0x11u:
        int v72 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v73 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        v74 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, 0xEu);
        PCCreateBitmap(v72, v73, 14, v74);
      default:
        break;
    }
  }
  unsigned int v75 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8));
  if (v75 > 0x10) {
    goto LABEL_54;
  }
  if (((1 << v75) & 0x10428) != 0)
  {
    if (((*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 48))(a2) & 1) == 0) {
      goto LABEL_54;
    }
  }
  else if (((1 << v75) & 0x4082) == 0)
  {
LABEL_54:
    switch((*(unsigned int (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8)))
    {
      case 2u:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      case 3u:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        (*(void (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8));
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      case 4u:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      case 5u:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        (*(void (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8));
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      case 6u:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      case 8u:
        int v77 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        int v78 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        CGColorSpace = (CGColorSpace *)PCImage::getCGColorSpace((PCImage *)a2);
        PCCreateBitmap(v77, v78, 7, CGColorSpace);
      case 9u:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      case 0xAu:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      case 0xBu:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      case 0xCu:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      case 0xDu:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      case 0xFu:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      case 0x10u:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        (*(void (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8));
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      case 0x11u:
        (*(void (**)(PCBitmap *))(*(void *)a2 + 16))(a2);
        (*(void (**)(PCBitmap *))(*(void *)a2 + 24))(a2);
        PCImage::getColorSpace((PCImage *)a2, &v83);
        PCCreateBitmap();
      default:
        c[0] = 0;
        c[1] = 0;
        v76 = 0;
        break;
    }
    goto LABEL_72;
  }
  v76 = (_anonymous_namespace_ *)a2;
LABEL_72:
  if (v3) {
    CGContextSetInterpolationQuality(c[0], kCGInterpolationHigh);
  }
  unsigned int v80 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)v76 + 16))(v76);
  unsigned int v81 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)v76 + 24))(v76);
  CGContextSetBlendMode(c[0], kCGBlendModeCopy);
  v86.size.width = (double)v80;
  v86.size.height = (double)v81;
  v86.origin.x = 0.0;
  v86.origin.y = 0.0;
  CGContextDrawImage(c[0], v86, image[0]);
  if (c[1]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)c[1]);
  }
  if (image[1]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)image[1]);
  }
  if (v82) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v82);
  }
}

void sub_1B768537C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, CGColorSpace *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(&a15);
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(a1);
}

void PCBitmap::flip(PCBitmap *this)
{
  unsigned int v2 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
  uint64_t v3 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
  uint64_t v4 = (*(unsigned int (**)(PCBitmap *))(*(void *)this + 24))(this) - 1;
  int v5 = (char *)(*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
  int v6 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
  unsigned int v7 = (*(uint64_t (**)(void))(**((void **)this + 8) + 48))(*((void *)this + 8));
  size_t v8 = PCPixelFormat::getBytesPerPixel(v7) * v6;
  std::vector<unsigned char>::vector(__dst, v8);
  int v9 = __dst[0];
  if ((unint64_t)v5 < v3 + v4 * (unint64_t)v2)
  {
    unint64_t v10 = v4 * (unint64_t)v2;
    uint64_t v11 = (v4 - 1) * v2;
    do
    {
      memcpy(v9, (const void *)(v3 + v10), v8);
      memcpy((void *)(v3 + v10), v5, v8);
      int v9 = __dst[0];
      memcpy(v5, __dst[0], v8);
      v5 += v2;
      unint64_t v12 = v3 + v11;
      v3 -= v2;
    }
    while ((unint64_t)v5 < v12);
  }
  if (v9)
  {
    __dst[1] = v9;
    operator delete(v9);
  }
}

void *PCBitmap::copyDataToBitmap(PCBitmap *this, char *a2)
{
  int v4 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
  unsigned int v5 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
  int v6 = (char *)(*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
  unsigned int v7 = (*(uint64_t (**)(void))(**((void **)this + 8) + 48))(*((void *)this + 8));
  size_t v8 = PCPixelFormat::getBytesPerPixel(v7) * v4;
  CGColorSpaceRef result = (void *)(*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
  if (v8 == result)
  {
    return memcpy(v6, a2, v8 * (unint64_t)v5);
  }
  else if (v5)
  {
    uint64_t v10 = result;
    do
    {
      CGColorSpaceRef result = memcpy(v6, a2, v8);
      a2 += v8;
      v6 += v10;
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t PCBitmap::swizzleTo(_anonymous_namespace_ *a1, int a2)
{
  unsigned int v4 = (*(uint64_t (**)(void *))(**((void **)a1 + 8) + 48))(*((void **)a1 + 8));
  if (PCPixelFormat::isFloat(v4))
  {
    if (a2 == 1) {
      uint64_t v8 = 16;
    }
    else {
      uint64_t v8 = 17;
    }
  }
  else
  {
    if ((a2 - 1) > 2) {
      uint64_t v8 = 3;
    }
    else {
      uint64_t v8 = dword_1B7E7C440[a2 - 1];
    }
  }
  return (*(uint64_t (**)(void *, uint64_t))(**((void **)a1 + 8) + 56))(*((void **)a1 + 8), v8);
}

uint64_t PCBitmap::dumpImage(PCBitmap *this, int a2, int a3)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v19);
  if (a3 == -1)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"/tmp/PCBitmap", 13);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"/tmp/PCBitmap_", 14);
    unsigned int v5 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"_", 1);
  }
  time(0);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)".png", 4);
  std::stringbuf::str();
  if (v18 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  PCString::PCString(&v16, p_p);
  PCPrint("%s: %s, %s\n", v8, v9, v10, v11, v12, v13, v14, (char)"PCBitmap::dumpImage");
  PCString::~PCString(&v16);
  if (v18 < 0) {
    operator delete(__p);
  }
  v19[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v19 + *(void *)(v19[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v19[1] = MEMORY[0x1E4FBA470] + 16;
  if (v20 < 0) {
    operator delete((void *)v19[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v21);
}

void sub_1B7685BF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  unsigned int v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x1E4FBA498] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1B7685DA4(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x1BA9BFAB0](v1);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::writePCBitmap(const PCString *this, const PCString *a2, const PCBitmap *a3, const __CFDictionary *a4)
{
  CGFloat v4 = *(double *)&a2;
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (((unsigned int (*)(const PCString *))a2->var0->data)(a2)
    && (*(unsigned int (**)(CGFloat))(**(void **)&v4 + 24))(COERCE_CGFLOAT(*(void *)&v4)))
  {
    unsigned int v6 = (*(uint64_t (**)(void))(**(void **)(*(void *)&v4 + 64) + 48))(*(void *)(*(void *)&v4 + 64));
    if (v6 > 0x11 || ((1 << v6) & 0x3C1AE) == 0)
    {
      CGFloat v4 = components[0];
      CGFloat v9 = components[1];
    }
    else
    {
      CGFloat v9 = 0.0;
    }
    unsigned int v10 = (*(uint64_t (**)(CGFloat))(**(void **)&v4 + 16))(COERCE_CGFLOAT(*(void *)&v4));
    unsigned int v11 = (*(uint64_t (**)(CGFloat))(**(void **)&v4 + 24))(COERCE_CGFLOAT(*(void *)&v4));
    uint64_t v12 = (const void *)(*(uint64_t (**)(void))(**(void **)(*(void *)&v4 + 64) + 16))(*(void *)(*(void *)&v4 + 64));
    unsigned int v13 = (*(uint64_t (**)(void))(**(void **)(*(void *)&v4 + 64) + 48))(*(void *)(*(void *)&v4 + 64));
    unsigned int BitsPerChannel = PCPixelFormat::getBitsPerChannel(v13);
    unsigned int v15 = (*(uint64_t (**)(void))(**(void **)(*(void *)&v4 + 64) + 48))(*(void *)(*(void *)&v4 + 64));
    int NumChannels = PCPixelFormat::getNumChannels(v15);
    PCImage::getColorSpace(*(PCImage **)&v4, &v21);
    PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v21);
    PCURL::PCURL((PCURL *)&v24, this, 0);
    PCURL::getExtension(&v24, (PCURL *)&v23);
    PCString::PCString((PCString *)components, "");
    int v18 = PCString::compare(&v23, (const PCString *)components);
    PCString::~PCString((PCString *)components);
    if (!v18) {
      PCString::set(&v23, "png");
    }
    if (v19) {
      std::shared_ptr<CGDataProvider>::shared_ptr[abi:ne180100]<CGDataProvider,void (*)(CGDataProvider*),void>(provider, (uint64_t)v19);
    }
    provider[0] = 0;
    provider[1] = 0;
    PCString::~PCString(&v23);
    PCURL::~PCURL((PCURL *)&v24);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v21);
    if (v9 != 0.0) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v9);
    }
  }
  return 0;
}

void sub_1B768637C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CGColorSpace *a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20,PCString a21,char a22,PCString a23,uint64_t a24)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  if (v25) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v25);
  }
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a18);
  }
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  PCString::~PCString(&a21);
  PCURL::~PCURL((PCURL *)&a22);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a12);
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  }
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)a1 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BA9BFAB0](a1 + 112);
  return a1;
}

uint64_t PCBitmap::premultiply(PCBitmap *this)
{
  uint64_t result = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 48))(this);
  if ((result & 1) == 0)
  {
    unsigned int v3 = (*(uint64_t (**)(void))(**((void **)this + 8) + 48))(*((void *)this + 8));
    uint64_t result = PCPixelFormat::hasAlpha(v3);
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 8) + 48))(*((void *)this + 8));
      switch((int)result)
      {
        case 2:
          int v4 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
          int v5 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
          unsigned int v6 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v7 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          if (v5)
          {
            for (int i = 0; i != v5; ++i)
            {
              int v9 = v4;
              for (j = (unsigned __int8 *)v7; v9; --v9)
              {
                unsigned __int8 *j = (32897 * *j * j[1]) >> 23;
                j += 2;
              }
              v7 += v6;
            }
          }
          goto LABEL_73;
        case 3:
          int v11 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
          int v12 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
          unsigned int v13 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v14 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          if (v12)
          {
            for (int k = 0; k != v12; ++k)
            {
              int v16 = v11;
              for (m = (unsigned __int8 *)v14; v16; --v16)
              {
                int v18 = *m;
                m[1] = (32897 * m[1] * v18) >> 23;
                m[2] = (32897 * m[2] * v18) >> 23;
                m[3] = (32897 * m[3] * v18) >> 23;
                m += 4;
              }
              v14 += v13;
            }
          }
          goto LABEL_73;
        case 4:
          int v19 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
          int v20 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
          unsigned int v21 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v22 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          if (v20)
          {
            for (int n = 0; n != v20; ++n)
            {
              int v24 = v19;
              for (iint i = (unsigned __int8 *)v22; v24; --v24)
              {
                int v26 = *ii;
                ii[3] = (32897 * ii[3] * v26) >> 23;
                ii[2] = (32897 * ii[2] * v26) >> 23;
                ii[1] = (32897 * ii[1] * v26) >> 23;
                ii += 4;
              }
              v22 += v21;
            }
          }
          goto LABEL_73;
        case 5:
          int v27 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
          int v28 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
          unsigned int v29 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v30 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          if (v28)
          {
            int v31 = 0;
            uint64_t v32 = (unsigned __int8 *)(v30 + 1);
            do
            {
              unsigned int v33 = v32;
              for (int jj = v27; jj; --jj)
              {
                int v35 = v33[2];
                *(v33 - 1) = (32897 * *(v33 - 1) * v35) >> 23;
                *unsigned int v33 = (32897 * *v33 * v35) >> 23;
                v33[1] = (32897 * v33[1] * v35) >> 23;
                v33 += 4;
              }
              ++v31;
              v32 += v29;
            }
            while (v31 != v28);
          }
          goto LABEL_73;
        case 6:
          int v36 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
          int v37 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
          unsigned int v38 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v39 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          if (v37)
          {
            int v40 = 0;
            uint64_t v41 = (unsigned __int8 *)(v39 + 1);
            do
            {
              int v42 = v41;
              for (kint k = v36; kk; --kk)
              {
                int v44 = v42[2];
                v42[1] = (32897 * v42[1] * v44) >> 23;
                *int v42 = (32897 * *v42 * v44) >> 23;
                *(v42 - 1) = (32897 * *(v42 - 1) * v44) >> 23;
                v42 += 4;
              }
              ++v40;
              v41 += v38;
            }
            while (v40 != v37);
          }
          goto LABEL_73;
        case 8:
          int v45 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
          int v46 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
          unsigned int v47 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v48 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          if (v46)
          {
            for (int mm = 0; mm != v46; ++mm)
            {
              int v50 = v45;
              for (nint n = (unsigned __int16 *)v48; v50; --v50)
              {
                *nint n = *nn * nn[1] / 0xFFFF;
                nn += 2;
              }
              v48 += v47;
            }
          }
          goto LABEL_73;
        case 10:
          int v52 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
          int v53 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
          unsigned int v54 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v55 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          if (v53)
          {
            int v56 = 0;
            int v57 = (unsigned __int16 *)(v55 + 4);
            do
            {
              int v58 = v57;
              for (int i1 = v52; i1; --i1)
              {
                int v60 = v58[1];
                *(v58 - OZChannelFontBase::~OZChannelFontBase(this - 2) = *(v58 - 2) * v60 / 0xFFFF;
                *(v58 - 1) = *(v58 - 1) * v60 / 0xFFFF;
                *int v58 = *v58 * v60 / 0xFFFF;
                v58 += 4;
              }
              ++v56;
              int v57 = (unsigned __int16 *)((char *)v57 + v54);
            }
            while (v56 != v53);
          }
          goto LABEL_73;
        case 12:
          int v61 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
          int v62 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
          unsigned int v63 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v64 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          if (v62)
          {
            uint64_t v65 = (unsigned __int16 *)v64;
            int v66 = 0;
            uint64_t v67 = v63;
            do
            {
              int v68 = v61;
              for (i2 = v65; v68; --v68)
              {
                PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>::premultiply(i2);
                i2 += 2;
              }
              uint64_t v65 = (unsigned __int16 *)((char *)v65 + v67);
              ++v66;
            }
            while (v66 != v62);
          }
          goto LABEL_73;
        case 13:
        case 15:
          int v70 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
          int v71 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
          unsigned int v72 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v73 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          if (v71)
          {
            for (int i3 = 0; i3 != v71; ++i3)
            {
              int v75 = v70;
              for (i4 = (float *)v73; v75; --v75)
              {
                float *i4 = i4[1] * *i4;
                i4 += 2;
              }
              v73 += v72;
            }
          }
          goto LABEL_73;
        case 16:
          int v77 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
          int v78 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
          unsigned int v79 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v80 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          if (v78)
          {
            int v81 = 0;
            v82 = (float *)(v80 + 8);
            do
            {
              v83 = v82;
              for (int i5 = v77; i5; --i5)
              {
                float v86 = *v83;
                float v85 = v83[1];
                float v87 = v85 * *(v83 - 1);
                *(v83 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v85 * *(v83 - 2);
                *(v83 - 1) = v87;
                float *v83 = v85 * v86;
                v83 += 4;
              }
              ++v81;
              v82 = (float *)((char *)v82 + v79);
            }
            while (v81 != v78);
          }
          goto LABEL_73;
        case 17:
          int v88 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 16))(this);
          int v89 = (*(uint64_t (**)(PCBitmap *))(*(void *)this + 24))(this);
          unsigned int v90 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v91 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          if (v89)
          {
            for (int i6 = 0; i6 != v89; ++i6)
            {
              int v93 = v88;
              for (i7 = (float *)v91; v93; --v93)
              {
                float v95 = *i7;
                float v96 = i7[3];
                float v97 = *i7 * i7[2];
                i7[1] = *i7 * i7[1];
                i7[2] = v97;
                i7[3] = v95 * v96;
                i7 += 4;
              }
              v91 += v90;
            }
          }
LABEL_73:
          uint64_t result = PCImage::setIsPremultiplied((uint64_t)this, 1);
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

uint64_t anonymous namespace'::preMultBitmap<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>(void **a1)
{
  int v2 = ((uint64_t (*)(void **))(*a1)[2])(a1);
  int v3 = ((uint64_t (*)(void **))(*a1)[3])(a1);
  unsigned int v4 = (*(uint64_t (**)(void *))(*a1[8] + 64))(a1[8]);
  uint64_t v5 = (*(uint64_t (**)(void *))(*a1[8] + 16))(a1[8]);
  if (v3)
  {
    unsigned int v6 = (unsigned __int16 *)v5;
    int v7 = 0;
    uint64_t v8 = v4;
    do
    {
      int v9 = v2;
      for (int i = v6; v9; --v9)
      {
        PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>::premultiply(i);
        i += 4;
      }
      unsigned int v6 = (unsigned __int16 *)((char *)v6 + v8);
      ++v7;
    }
    while (v7 != v3);
  }

  return PCImage::setIsPremultiplied((uint64_t)a1, 1);
}

void PCCreateBitmap(int a1, int a2, unsigned int a3)
{
  unsigned int v6 = (CGColorSpace *)PCBitmap::sanitizeColorSpace(0, a3);

  PCCreateBitmap(a1, a2, a3, v6);
}

void PCCreateBitmap(int a1, int a2, int a3, CGColorSpaceRef space)
{
  PCColorSpaceHandle::PCColorSpaceHandle((PCColorSpaceHandle *)v4, space);
  PCCreateBitmap();
}

void sub_1B76874B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PCCreateBitmap()
{
}

void sub_1B768759C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C4028F97B41);
  _Unwind_Resume(a1);
}

double PCCreateBitmap<ProCore_Private::PCBitmapRepDefault>@<D0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = a2;
  switch((*(unsigned int (**)(uint64_t))(*(void *)*a1 + 48))(*a1))
  {
    case 1u:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 2u:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 3u:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 4u:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 5u:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 6u:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 7u:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 8u:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 9u:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>,std::allocator<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 0xAu:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 0xBu:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 0xCu:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 0xDu:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 0xEu:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 0xFu:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 0x10u:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
      goto LABEL_20;
    case 0x11u:
      std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(a1, &v7, &v6);
LABEL_20:
      double result = *(double *)&v6;
      *(_OWORD *)a3 = v6;
      break;
    default:
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      break;
  }
  return result;
}

void PCBitmap::toBitmap(PCBitmap *this@<X0>, void *a2@<X8>)
{
  std::shared_ptr<OZStyle>::shared_ptr[abi:ne180100]<OZStyle,void>(&lpsrc, (void *)this + 1);
  if (lpsrc
  {
    unsigned int v4 = v6;
    *a2 = v3;
    a2[1] = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void sub_1B76878FC(void *a1)
{
}

void sub_1B7687938(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C405CA75B9BLL);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

unint64_t PCBitmap::isPremultiplied(PCBitmap *this)
{
  unint64_t result = PCImage::isPremultiplied((PCImage *)this);
  if (result)
  {
    unsigned int v3 = (*(uint64_t (**)(void))(**((void **)this + 8) + 48))(*((void *)this + 8));
    return PCPixelFormat::hasAlpha(v3);
  }
  return result;
}

void CreateCGImageFromPCBitmap(PCImage **a1, int a2)
{
  int v4 = (*(uint64_t (**)(PCImage *))(*(void *)*a1 + 16))(*a1);
  int v5 = (*(uint64_t (**)(void))(*(void *)*a1 + 24))();
  CGColorSpace = (CGColorSpace *)PCImage::getCGColorSpace(*a1);
  PCCreateBitmap(v4, v5, a2, CGColorSpace);
}

void sub_1B7687CB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t freeImage(uint64_t result, const void *a2)
{
  if (result)
  {
    int v2 = *(std::__shared_weak_count **)(result + 8);
    if (v2) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v2);
    }
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

uint64_t anonymous namespace'::copyForCGImage@<X0>(_anonymous_namespace_ *this@<X0>, const PCBitmap *a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  uint64_t result = (*(uint64_t (**)(void, const PCBitmap *))(**((void **)this + 8) + 48))(*((void *)this + 8), a2);
  switch((int)result)
  {
    case 4:
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      PCImage::getColorSpace(this, &v5);
      PCCreateBitmap();
    case 6:
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      PCImage::getColorSpace(this, &v5);
      PCCreateBitmap();
    case 9:
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      PCImage::getColorSpace(this, &v5);
      PCCreateBitmap();
    case 10:
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      PCImage::getColorSpace(this, &v5);
      PCCreateBitmap();
    case 11:
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      PCImage::getColorSpace(this, &v5);
      PCCreateBitmap();
    case 12:
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      PCImage::getColorSpace(this, &v5);
      PCCreateBitmap();
    case 13:
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      (*(void (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      PCImage::getColorSpace(this, &v5);
      PCCreateBitmap();
    default:
      return result;
  }
}

void sub_1B7689AEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

CGColorSpace **anonymous namespace'::makeCGImageFromPCBitmap@<X0>(_anonymous_namespace_ *this@<X0>, void *a2@<X8>)
{
  CGColorSpace = (CGColorSpace *)PCImage::getCGColorSpace(this);
  long long v6 = CGColorSpace;
  if (CGColorSpace) {
    PCCFRefTraits<CGColorSpace *>::retain(CGColorSpace);
  }
  unsigned int v21 = v6;
  uint64_t v7 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
  size_t v8 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 40))(this);
  if (v9) {
    std::shared_ptr<CGDataProvider>::shared_ptr[abi:ne180100]<CGDataProvider,void (*)(CGDataProvider*),void>(&provider, (uint64_t)v9);
  }
  CGDataProviderRef provider = 0;
  int v20 = 0;
  unsigned int v10 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
  unsigned int v11 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
  size_t v12 = *((unsigned int *)this + 9);
  int v13 = *((_DWORD *)this + 10);
  unsigned int v14 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
  CGImageRef v17 = CGImageCreate(v10, v11, v12, (v13 * v12), v14, v21, v16, 0, 0, 0, kCGRenderingIntentDefault);
  if (v17) {
    std::shared_ptr<CGImage>::shared_ptr[abi:ne180100]<CGImage,void (*)(CGImage*),void>(a2, (uint64_t)v17);
  }
  *a2 = 0;
  a2[1] = 0;
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v21);
}

void sub_1B7689D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

CGColorSpace **anonymous namespace'::makeCGBitmapContextForPCBitmap@<X0>(_anonymous_namespace_ *this@<X0>, void *a2@<X8>)
{
  CGColorSpace = (CGColorSpace *)PCImage::getCGColorSpace(this);
  long long v6 = CGColorSpace;
  if (CGColorSpace) {
    PCCFRefTraits<CGColorSpace *>::retain(CGColorSpace);
  }
  CGBitmapInfo v16 = v6;
  uint64_t v7 = (void *)(*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
  unsigned int v8 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
  unsigned int v9 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
  size_t v10 = *((unsigned int *)this + 9);
  unsigned int v11 = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
  if (v14) {
    std::shared_ptr<CGContext>::shared_ptr[abi:ne180100]<CGContext,void (*)(CGContext*),void>(a2, (uint64_t)v14);
  }
  *a2 = 0;
  a2[1] = 0;
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v16);
}

void sub_1B7689F40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::copyGrayAlpha(_anonymous_namespace_ *this, const PCBitmap *a2, const PCBitmap *a3, PCBitmap *a4)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 48))(*((void *)a3 + 8));
  if (a2)
  {
    if ((int)result > 11)
    {
      if (result == 12)
      {
        uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8));
        if ((int)result > 10)
        {
          if (result == 11 || result == 14)
          {
            uint64_t v166 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
            uint64_t v167 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
            uint64_t v168 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
            int v169 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
            int v170 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
            uint64_t v457 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
            uint64_t v446 = (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
            uint64_t v171 = (*(unsigned int (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
            uint64_t result = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
            if (result)
            {
              if (v170)
              {
                int v172 = v170;
                for (int i = 0; i != v172; ++i)
                {
                  if (v169)
                  {
                    uint64_t v174 = 0;
                    int v175 = v169;
                    do
                    {
                      v176 = (_WORD *)(v168 + v174);
                      _WORD *v176 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v166 + v174));
                      uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v167 + v174));
                      v176[1] = result;
                      v174 += 4;
                      --v175;
                    }
                    while (v175);
                  }
                  v166 += v457;
                  v167 += v446;
                  v168 += v171;
                }
              }
            }
            else
            {
              int v442 = v170;
              if (v170)
              {
                int v277 = 0;
                do
                {
                  if (v169)
                  {
                    uint64_t v278 = 0;
                    int v279 = v169;
                    do
                    {
                      v280 = (_WORD *)(v168 + v278);
                      _WORD *v280 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v166 + v278));
                      v280[1] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v167 + v278));
                      uint64_t result = PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>::unpremultiply((unsigned __int16 *)(v168 + v278));
                      v278 += 4;
                      --v279;
                    }
                    while (v279);
                  }
                  v166 += v457;
                  v167 += v446;
                  v168 += v171;
                  ++v277;
                }
                while (v277 != v442);
              }
            }
          }
        }
        else if (result == 1)
        {
          uint64_t v238 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          uint64_t v239 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
          uint64_t v240 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
          int v460 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
          int v241 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
          uint64_t v449 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v242 = (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
          uint64_t v243 = (*(unsigned int (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
          uint64_t result = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
          if (result)
          {
            if (v241)
            {
              for (int j = 0; j != v241; ++j)
              {
                if (v460)
                {
                  uint64_t v245 = 0;
                  v246 = (_WORD *)v240;
                  do
                  {
                    _WORD *v246 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v238 + 4 * v245));
                    LOBYTE(v247) = *(unsigned char *)(v239 + v245);
                    *(float *)&unint64_t v247 = (double)v247 * 0.00392156863;
                    uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)&v247);
                    v246[1] = result;
                    ++v245;
                    v246 += 2;
                  }
                  while (v460 != v245);
                }
                v238 += v449;
                v239 += v242;
                v240 += v243;
              }
            }
          }
          else if (v241)
          {
            for (int k = 0; k != v241; ++k)
            {
              if (v460)
              {
                uint64_t v375 = 0;
                v376 = (unsigned __int16 *)v240;
                do
                {
                  unsigned __int16 *v376 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v238 + 4 * v375));
                  LOBYTE(v377) = *(unsigned char *)(v239 + v375);
                  *(float *)&unint64_t v377 = (double)v377 * 0.00392156863;
                  v376[1] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)&v377);
                  uint64_t result = PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>::unpremultiply(v376);
                  ++v375;
                  v376 += 2;
                }
                while (v460 != v375);
              }
              v238 += v449;
              v239 += v242;
              v240 += v243;
            }
          }
        }
        else if (result == 7)
        {
          uint64_t v82 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          uint64_t v83 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
          uint64_t v84 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
          int v454 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
          int v85 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
          uint64_t v444 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v86 = (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
          uint64_t v87 = (*(unsigned int (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
          uint64_t result = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
          if (result)
          {
            if (v85)
            {
              for (int m = 0; m != v85; ++m)
              {
                if (v454)
                {
                  uint64_t v89 = 0;
                  unsigned int v90 = (_WORD *)v84;
                  do
                  {
                    *unsigned int v90 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v82 + 4 * v89));
                    LOWORD(v91) = *(_WORD *)(v83 + 2 * v89);
                    *(float *)&unint64_t v91 = (double)v91 * 0.0000152590219;
                    uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)&v91);
                    v90[1] = result;
                    ++v89;
                    v90 += 2;
                  }
                  while (v454 != v89);
                }
                v82 += v444;
                v83 += v86;
                v84 += v87;
              }
            }
          }
          else if (v85)
          {
            for (int n = 0; n != v85; ++n)
            {
              if (v454)
              {
                uint64_t v343 = 0;
                v344 = (unsigned __int16 *)v84;
                do
                {
                  unsigned __int16 *v344 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v82 + 4 * v343));
                  LOWORD(v345) = *(_WORD *)(v83 + 2 * v343);
                  *(float *)&unint64_t v345 = (double)v345 * 0.0000152590219;
                  v344[1] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)&v345);
                  uint64_t result = PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>::unpremultiply(v344);
                  ++v343;
                  v344 += 2;
                }
                while (v454 != v343);
              }
              v82 += v444;
              v83 += v86;
              v84 += v87;
            }
          }
        }
      }
      else if (result == 15)
      {
        uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8));
        if ((int)result > 10)
        {
          if (result == 11 || result == 14)
          {
            uint64_t v140 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
            uint64_t v141 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
            uint64_t v142 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
            int v143 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
            int v144 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
            uint64_t v145 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
            uint64_t v146 = (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
            uint64_t v147 = (*(unsigned int (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
            uint64_t result = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
            if (result)
            {
              if (v144)
              {
                for (iint i = 0; ii != v144; ++ii)
                {
                  if (v143)
                  {
                    uint64_t v149 = 0;
                    v150 = (_DWORD *)v142;
                    do
                    {
                      _DWORD *v150 = *(_DWORD *)(v140 + 4 * v149);
                      v150[1] = *(_DWORD *)(v141 + 4 * v149++);
                      v150 += 2;
                    }
                    while (v143 != v149);
                  }
                  v140 += v145;
                  v141 += v146;
                  v142 += v147;
                }
              }
            }
            else if (v144)
            {
              for (int jj = 0; jj != v144; ++jj)
              {
                if (v143)
                {
                  uint64_t v263 = 0;
                  v264 = (float *)v142;
                  do
                  {
                    float v265 = *(float *)(v140 + 4 * v263);
                    float *v264 = v265;
                    float v266 = *(float *)(v141 + 4 * v263);
                    v264[1] = v266;
                    if (v266 != 1.0)
                    {
                      float v267 = v265 / v266;
                      if (v266 == 0.0) {
                        float v267 = 0.0;
                      }
                      float *v264 = v267;
                    }
                    v264 += 2;
                    ++v263;
                  }
                  while (v143 != v263);
                }
                v140 += v145;
                v141 += v146;
                v142 += v147;
              }
            }
          }
        }
        else if (result == 1)
        {
          uint64_t v210 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          uint64_t v211 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
          uint64_t v212 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
          int v213 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
          int v214 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
          uint64_t v215 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v216 = (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
          uint64_t v217 = (*(unsigned int (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
          uint64_t result = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
          if (result)
          {
            if (v214)
            {
              for (kint k = 0; kk != v214; ++kk)
              {
                if (v213)
                {
                  uint64_t v221 = 0;
                  v222 = (_DWORD *)v212;
                  do
                  {
                    LODWORD(v218) = *(_DWORD *)(v210 + 4 * v221);
                    _DWORD *v222 = LODWORD(v218);
                    LOBYTE(v218) = *(unsigned char *)(v211 + v221);
                    double v218 = (double)*(unint64_t *)&v218 * 0.00392156863;
                    *(float *)&double v218 = v218;
                    v222[1] = LODWORD(v218);
                    ++v221;
                    v222 += 2;
                  }
                  while (v213 != v221);
                }
                v210 += v215;
                v211 += v216;
                v212 += v217;
              }
            }
          }
          else if (v214)
          {
            for (int mm = 0; mm != v214; ++mm)
            {
              if (v213)
              {
                uint64_t v359 = 0;
                uint64_t v360 = v212;
                do
                {
                  float v361 = *(float *)(v210 + 4 * v359);
                  *(float *)uint64_t v360 = v361;
                  LOBYTE(v219) = *(unsigned char *)(v211 + v359);
                  double v219 = (double)*(unint64_t *)&v219 * 0.00392156863;
                  *(float *)&double v219 = v219;
                  *(_DWORD *)(v360 + 4) = LODWORD(v219);
                  if (*(float *)&v219 != 1.0)
                  {
                    float v362 = v361 / *(float *)&v219;
                    if (*(float *)&v219 == 0.0) {
                      float v362 = 0.0;
                    }
                    *(float *)uint64_t v360 = v362;
                  }
                  v360 += 8;
                  ++v359;
                }
                while (v213 != v359);
              }
              v210 += v215;
              v211 += v216;
              v212 += v217;
            }
          }
        }
        else if (result == 7)
        {
          uint64_t v42 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          uint64_t v43 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
          uint64_t v44 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
          int v45 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
          int v46 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
          uint64_t v47 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v48 = (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
          uint64_t v49 = (*(unsigned int (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
          uint64_t result = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
          if (result)
          {
            if (v46)
            {
              for (nint n = 0; nn != v46; ++nn)
              {
                if (v45)
                {
                  uint64_t v53 = 0;
                  unsigned int v54 = (_DWORD *)v44;
                  do
                  {
                    LOWORD(v50) = *(_WORD *)(v43 + 2 * v53);
                    double v50 = (double)*(unint64_t *)&v50 * 0.0000152590219;
                    *(float *)&double v50 = v50;
                    *unsigned int v54 = *(_DWORD *)(v42 + 4 * v53);
                    v54[1] = LODWORD(v50);
                    v54 += 2;
                    ++v53;
                  }
                  while (v45 != v53);
                }
                v42 += v47;
                v43 += v48;
                v44 += v49;
              }
            }
          }
          else if (v46)
          {
            for (int i1 = 0; i1 != v46; ++i1)
            {
              if (v45)
              {
                uint64_t v327 = 0;
                uint64_t v328 = v44;
                do
                {
                  float v329 = *(float *)(v42 + 4 * v327);
                  LOWORD(v51) = *(_WORD *)(v43 + 2 * v327);
                  double v51 = (double)*(unint64_t *)&v51 * 0.0000152590219;
                  *(float *)&double v51 = v51;
                  *(float *)uint64_t v328 = v329;
                  *(_DWORD *)(v328 + 4) = LODWORD(v51);
                  if (*(float *)&v51 != 1.0)
                  {
                    float v330 = v329 / *(float *)&v51;
                    if (*(float *)&v51 == 0.0) {
                      float v330 = 0.0;
                    }
                    *(float *)uint64_t v328 = v330;
                  }
                  v328 += 8;
                  ++v327;
                }
                while (v45 != v327);
              }
              v42 += v47;
              v43 += v48;
              v44 += v49;
            }
          }
        }
      }
    }
    else if (result == 2)
    {
      uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8));
      if ((int)result > 10)
      {
        if (result == 11 || result == 14)
        {
          uint64_t v152 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          uint64_t v153 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
          uint64_t v154 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
          int v155 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
          int v156 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
          uint64_t v456 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v445 = (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
          uint64_t v439 = (*(unsigned int (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
          uint64_t result = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
          if (result)
          {
            if (v156)
            {
              for (int i2 = 0; i2 != v156; ++i2)
              {
                if (v155)
                {
                  uint64_t v160 = 0;
                  v161 = (unsigned char *)v154;
                  do
                  {
                    LOBYTE(v158) = *(unsigned char *)(v152 + v160);
                    float v162 = (double)*(unint64_t *)&v158 * 0.00392156863;
                    int v163 = vcvtmd_s64_f64((float)(v162 * 255.0) + 0.5 + 0.0000001);
                    if (v163 >= 255) {
                      int v163 = 255;
                    }
                    unsigned char *v161 = v163 & ~(v163 >> 31);
                    double v158 = (float)(*(float *)(v153 + 4 * v160) * 255.0) + 0.5 + 0.0000001;
                    int v164 = vcvtmd_s64_f64(v158);
                    if (v164 >= 255) {
                      int v164 = 255;
                    }
                    v161[1] = v164 & ~(v164 >> 31);
                    ++v160;
                    v161 += 2;
                  }
                  while (v155 != v160);
                }
                v152 += v456;
                v153 += v445;
                v154 += v439;
              }
            }
          }
          else if (v156)
          {
            int v268 = v156;
            int v269 = 0;
            int v270 = v155;
            int v434 = v155;
            do
            {
              if (v155)
              {
                uint64_t v271 = 0;
                v272 = (unsigned char *)v154;
                do
                {
                  LOBYTE(v157) = *(unsigned char *)(v152 + v271);
                  float v273 = (double)v157 * 0.00392156863;
                  int v274 = vcvtmd_s64_f64((float)(v273 * 255.0) + 0.5 + 0.0000001);
                  if (v274 >= 255) {
                    int v274 = 255;
                  }
                  unsigned char *v272 = v274 & ~(v274 >> 31);
                  double v275 = (float)(*(float *)(v153 + 4 * v271) * 255.0) + 0.5 + 0.0000001;
                  int v276 = vcvtmd_s64_f64(v275);
                  if (v276 >= 255) {
                    int v276 = 255;
                  }
                  v272[1] = v276 & ~(v276 >> 31);
                  uint64_t result = (uint64_t)PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>::unpremultiply(v272, v275);
                  ++v271;
                  v272 += 2;
                }
                while (v270 != v271);
              }
              v152 += v456;
              v153 += v445;
              v154 += v439;
              ++v269;
              int v155 = v434;
            }
            while (v269 != v268);
          }
        }
      }
      else if (result == 1)
      {
        uint64_t v223 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
        uint64_t v224 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
        uint64_t v225 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
        int v226 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v227 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v459 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
        uint64_t v448 = (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
        uint64_t v441 = (*(unsigned int (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
        uint64_t result = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
        if (result)
        {
          if (v227)
          {
            for (int i3 = 0; i3 != v227; ++i3)
            {
              if (v226)
              {
                uint64_t v231 = 0;
                v232 = (unsigned char *)v225;
                do
                {
                  LOBYTE(v229) = *(unsigned char *)(v223 + v231);
                  float v233 = (double)*(unint64_t *)&v229 * 0.00392156863;
                  double v234 = (float)(v233 * 255.0) + 0.5 + 0.0000001;
                  int v235 = vcvtmd_s64_f64(v234);
                  if (v235 >= 255) {
                    int v235 = 255;
                  }
                  unsigned char *v232 = v235 & ~(v235 >> 31);
                  LOBYTE(v234) = *(unsigned char *)(v224 + v231);
                  float v236 = (double)*(unint64_t *)&v234 * 0.00392156863;
                  double v229 = (float)(v236 * 255.0) + 0.5 + 0.0000001;
                  int v237 = vcvtmd_s64_f64(v229);
                  if (v237 >= 255) {
                    int v237 = 255;
                  }
                  v232[1] = v237 & ~(v237 >> 31);
                  ++v231;
                  v232 += 2;
                }
                while (v226 != v231);
              }
              v223 += v459;
              v224 += v448;
              v225 += v441;
            }
          }
        }
        else if (v227)
        {
          int v363 = v227;
          int v364 = 0;
          int v365 = v226;
          int v436 = v226;
          do
          {
            if (v226)
            {
              uint64_t v366 = 0;
              v367 = (unsigned char *)v225;
              do
              {
                LOBYTE(v228) = *(unsigned char *)(v223 + v366);
                float v368 = (double)v228 * 0.00392156863;
                double v369 = (float)(v368 * 255.0) + 0.5 + 0.0000001;
                int v370 = vcvtmd_s64_f64(v369);
                if (v370 >= 255) {
                  int v370 = 255;
                }
                unsigned char *v367 = v370 & ~(v370 >> 31);
                LOBYTE(v369) = *(unsigned char *)(v224 + v366);
                float v371 = (double)*(unint64_t *)&v369 * 0.00392156863;
                double v372 = (float)(v371 * 255.0) + 0.5 + 0.0000001;
                int v373 = vcvtmd_s64_f64(v372);
                if (v373 >= 255) {
                  int v373 = 255;
                }
                v367[1] = v373 & ~(v373 >> 31);
                uint64_t result = (uint64_t)PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>::unpremultiply(v367, v372);
                ++v366;
                v367 += 2;
              }
              while (v365 != v366);
            }
            v223 += v459;
            v224 += v448;
            v225 += v441;
            ++v364;
            int v226 = v436;
          }
          while (v364 != v363);
        }
      }
      else if (result == 7)
      {
        uint64_t v67 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
        uint64_t v68 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
        uint64_t v69 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
        int v70 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v71 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v453 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
        uint64_t v443 = (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
        uint64_t v437 = (*(unsigned int (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
        uint64_t result = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
        if (result)
        {
          if (v71)
          {
            for (int i4 = 0; i4 != v71; ++i4)
            {
              if (v70)
              {
                uint64_t v75 = 0;
                v76 = (unsigned char *)v69;
                do
                {
                  LOBYTE(v73) = *(unsigned char *)(v67 + v75);
                  float v77 = (double)*(unint64_t *)&v73 * 0.00392156863;
                  double v78 = (float)(v77 * 255.0) + 0.5 + 0.0000001;
                  int v79 = vcvtmd_s64_f64(v78);
                  if (v79 >= 255) {
                    int v79 = 255;
                  }
                  unsigned char *v76 = v79 & ~(v79 >> 31);
                  LOWORD(v78) = *(_WORD *)(v68 + 2 * v75);
                  float v80 = (double)*(unint64_t *)&v78 * 0.0000152590219;
                  double v73 = (float)(v80 * 255.0) + 0.5 + 0.0000001;
                  int v81 = vcvtmd_s64_f64(v73);
                  if (v81 >= 255) {
                    int v81 = 255;
                  }
                  v76[1] = v81 & ~(v81 >> 31);
                  ++v75;
                  v76 += 2;
                }
                while (v70 != v75);
              }
              v67 += v453;
              v68 += v443;
              v69 += v437;
            }
          }
        }
        else if (v71)
        {
          int v331 = v71;
          int v332 = 0;
          int v333 = v70;
          int v435 = v70;
          do
          {
            if (v70)
            {
              uint64_t v334 = 0;
              v335 = (unsigned char *)v69;
              do
              {
                LOBYTE(v7OZChannelFontBase::~OZChannelFontBase(this - 2) = *(unsigned char *)(v67 + v334);
                float v336 = (double)v72 * 0.00392156863;
                double v337 = (float)(v336 * 255.0) + 0.5 + 0.0000001;
                int v338 = vcvtmd_s64_f64(v337);
                if (v338 >= 255) {
                  int v338 = 255;
                }
                unsigned char *v335 = v338 & ~(v338 >> 31);
                LOWORD(v337) = *(_WORD *)(v68 + 2 * v334);
                float v339 = (double)*(unint64_t *)&v337 * 0.0000152590219;
                double v340 = (float)(v339 * 255.0) + 0.5 + 0.0000001;
                int v341 = vcvtmd_s64_f64(v340);
                if (v341 >= 255) {
                  int v341 = 255;
                }
                v335[1] = v341 & ~(v341 >> 31);
                uint64_t result = (uint64_t)PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>::unpremultiply(v335, v340);
                ++v334;
                v335 += 2;
              }
              while (v333 != v334);
            }
            v67 += v453;
            v68 += v443;
            v69 += v437;
            ++v332;
            int v70 = v435;
          }
          while (v332 != v331);
        }
      }
    }
    else if (result == 8)
    {
      uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8));
      if ((int)result > 10)
      {
        if (result == 11 || result == 14)
        {
          uint64_t v121 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
          uint64_t v122 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
          uint64_t v123 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
          int v438 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
          int v124 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
          uint64_t v125 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
          uint64_t v126 = (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
          uint64_t v127 = (*(unsigned int (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
          uint64_t result = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
          if (result)
          {
            if (v124)
            {
              int v129 = 0;
              float32x2_t v130 = (float32x2_t)vdup_n_s32(0x477FFF00u);
              __asm { FMOV            V2.2D, #0.5 }
              float64x2_t v135 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
              do
              {
                if (v438)
                {
                  uint64_t v136 = 0;
                  do
                  {
                    LOWORD(v128) = *(_WORD *)(v121 + 2 * v136);
                    v137.f32[0] = (double)v128 * 0.0000152590219;
                    v137.i32[1] = *(_DWORD *)(v122 + 4 * v136);
                    unint64_t v128 = (unint64_t)vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(v137, v130)), _Q2), v135)))), (int32x2_t)0xFFFF0000FFFFLL), 0);
                    v138 = (_WORD *)(v123 + 4 * v136);
                    v138[1] = WORD2(v128);
                    _WORD *v138 = v128;
                    ++v136;
                  }
                  while (v438 != v136);
                }
                v121 += v125;
                v122 += v126;
                v123 += v127;
                ++v129;
              }
              while (v129 != v124);
            }
          }
          else if (v124)
          {
            int v248 = 0;
            float32x2_t v249 = (float32x2_t)vdup_n_s32(0x477FFF00u);
            __asm { FMOV            V1.2D, #0.5 }
            int64x2_t v251 = vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
            float64x2_t v450 = (float64x2_t)v251;
            float64x2_t v461 = _Q1;
            int v433 = v124;
            do
            {
              uint64_t v252 = v127;
              uint64_t v253 = v126;
              uint64_t v254 = v125;
              float64x2_t v256 = v450;
              float64x2_t v255 = v461;
              if (v438)
              {
                uint64_t v257 = 0;
                int v258 = v438;
                v259 = (_WORD *)v123;
                do
                {
                  v251.i16[0] = *(_WORD *)(v121 + 2 * v257);
                  v260.f32[0] = (double)v251.u64[0] * 0.0000152590219;
                  v260.i32[1] = *(_DWORD *)(v122 + 4 * v257);
                  double v261 = COERCE_DOUBLE(vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(v260, v249)), v255), v256)))), (int32x2_t)0xFFFF0000FFFFLL), 0));
                  v259[1] = WORD2(v261);
                  _WORD *v259 = LOWORD(v261);
                  uint64_t result = (uint64_t)PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>::unpremultiply(v259, v261);
                  float64x2_t v256 = v450;
                  float64x2_t v255 = v461;
                  v259 += 2;
                  ++v257;
                  --v258;
                }
                while (v258);
              }
              uint64_t v125 = v254;
              v121 += v254;
              uint64_t v126 = v253;
              v122 += v253;
              uint64_t v127 = v252;
              v123 += v252;
              ++v248;
            }
            while (v248 != v433);
          }
        }
      }
      else if (result == 1)
      {
        uint64_t v195 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
        uint64_t v196 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
        uint64_t v197 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
        uint64_t v198 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v199 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v458 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
        uint64_t v447 = (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
        uint64_t v440 = (*(unsigned int (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
        uint64_t result = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
        if (result)
        {
          if (v199)
          {
            for (int i5 = 0; i5 != v199; ++i5)
            {
              if (v198)
              {
                uint64_t v203 = 0;
                v204 = (_WORD *)v197;
                do
                {
                  LOWORD(v201) = *(_WORD *)(v195 + 2 * v203);
                  float v205 = (double)*(unint64_t *)&v201 * 0.0000152590219;
                  double v206 = (float)(v205 * 65535.0) + 0.5 + 0.0000001;
                  int v207 = vcvtmd_s64_f64(v206);
                  if (v207 >= 0xFFFF) {
                    int v207 = 0xFFFF;
                  }
                  _WORD *v204 = v207 & ~(unsigned __int16)(v207 >> 31);
                  LOBYTE(v206) = *(unsigned char *)(v196 + v203);
                  float v208 = (double)*(unint64_t *)&v206 * 0.00392156863;
                  double v201 = (float)(v208 * 65535.0) + 0.5 + 0.0000001;
                  int v209 = vcvtmd_s64_f64(v201);
                  if (v209 >= 0xFFFF) {
                    int v209 = 0xFFFF;
                  }
                  v204[1] = v209 & ~(unsigned __int16)(v209 >> 31);
                  ++v203;
                  v204 += 2;
                }
                while (v198 != v203);
              }
              v195 += v458;
              v196 += v447;
              v197 += v440;
            }
          }
        }
        else if (v199)
        {
          int v346 = v199;
          int v347 = 0;
          int v348 = v198;
          do
          {
            uint64_t v349 = v198;
            if (v198)
            {
              uint64_t v350 = 0;
              v351 = (_WORD *)v197;
              do
              {
                LOWORD(v200) = *(_WORD *)(v195 + 2 * v350);
                float v352 = (double)v200 * 0.0000152590219;
                double v353 = (float)(v352 * 65535.0) + 0.5 + 0.0000001;
                int v354 = vcvtmd_s64_f64(v353);
                if (v354 >= 0xFFFF) {
                  int v354 = 0xFFFF;
                }
                _WORD *v351 = v354 & ~(unsigned __int16)(v354 >> 31);
                LOBYTE(v353) = *(unsigned char *)(v196 + v350);
                float v355 = (double)*(unint64_t *)&v353 * 0.00392156863;
                double v356 = (float)(v355 * 65535.0) + 0.5 + 0.0000001;
                int v357 = vcvtmd_s64_f64(v356);
                if (v357 >= 0xFFFF) {
                  int v357 = 0xFFFF;
                }
                v351[1] = v357 & ~(unsigned __int16)(v357 >> 31);
                uint64_t result = (uint64_t)PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>::unpremultiply(v351, v356);
                ++v350;
                v351 += 2;
              }
              while (v348 != v350);
            }
            v195 += v458;
            v196 += v447;
            v197 += v440;
            ++v347;
            uint64_t v198 = v349;
          }
          while (v347 != v346);
        }
      }
      else if (result == 7)
      {
        uint64_t v8 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
        uint64_t v9 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
        uint64_t v10 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
        int v452 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v11 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v12 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
        uint64_t v13 = (*(unsigned int (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
        uint64_t v14 = (*(unsigned int (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
        uint64_t result = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
        if (result)
        {
          if (v11)
          {
            for (int i6 = 0; i6 != v11; ++i6)
            {
              if (v452)
              {
                uint64_t v18 = 0;
                int v19 = v452;
                do
                {
                  int v20 = (_WORD *)(v10 + 2 * v18);
                  LOWORD(v16) = *(_WORD *)(v8 + v18);
                  float v21 = (double)*(unint64_t *)&v16 * 0.0000152590219;
                  double v22 = (float)(v21 * 65535.0) + 0.5 + 0.0000001;
                  int v23 = vcvtmd_s64_f64(v22);
                  if (v23 >= 0xFFFF) {
                    int v23 = 0xFFFF;
                  }
                  *int v20 = v23 & ~(unsigned __int16)(v23 >> 31);
                  LOWORD(v2OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_WORD *)(v9 + v18);
                  float v24 = (double)*(unint64_t *)&v22 * 0.0000152590219;
                  double v16 = (float)(v24 * 65535.0) + 0.5 + 0.0000001;
                  int v25 = vcvtmd_s64_f64(v16);
                  if (v25 >= 0xFFFF) {
                    int v25 = 0xFFFF;
                  }
                  v20[1] = v25 & ~(unsigned __int16)(v25 >> 31);
                  v18 += 2;
                  --v19;
                }
                while (v19);
              }
              v8 += v12;
              v9 += v13;
              v10 += v14;
            }
          }
        }
        else if (v11)
        {
          int v313 = 0;
          int v451 = v11;
          do
          {
            uint64_t v314 = v14;
            uint64_t v315 = v13;
            uint64_t v316 = v12;
            if (v452)
            {
              uint64_t v317 = 0;
              int v318 = v452;
              do
              {
                v319 = (_WORD *)(v10 + 2 * v317);
                LOWORD(v15) = *(_WORD *)(v8 + v317);
                float v320 = (double)v15 * 0.0000152590219;
                double v321 = (float)(v320 * 65535.0) + 0.5 + 0.0000001;
                int v322 = vcvtmd_s64_f64(v321);
                if (v322 >= 0xFFFF) {
                  int v322 = 0xFFFF;
                }
                _WORD *v319 = v322 & ~(unsigned __int16)(v322 >> 31);
                LOWORD(v321) = *(_WORD *)(v9 + v317);
                float v323 = (double)*(unint64_t *)&v321 * 0.0000152590219;
                double v324 = (float)(v323 * 65535.0) + 0.5 + 0.0000001;
                int v325 = vcvtmd_s64_f64(v324);
                if (v325 >= 0xFFFF) {
                  int v325 = 0xFFFF;
                }
                v319[1] = v325 & ~(unsigned __int16)(v325 >> 31);
                uint64_t result = (uint64_t)PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>::unpremultiply(v319, v324);
                v317 += 2;
                --v318;
              }
              while (v318);
            }
            uint64_t v12 = v316;
            v8 += v316;
            uint64_t v13 = v315;
            v9 += v315;
            uint64_t v14 = v314;
            v10 += v314;
            ++v313;
          }
          while (v313 != v451);
        }
      }
    }
  }
  else if ((int)result > 11)
  {
    if (result == 12)
    {
      uint64_t v107 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
      uint64_t v108 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
      int v109 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
      int v110 = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
      int hasAlpha = PCPixelFormat::hasAlpha(0xEu);
      int v112 = PCPixelFormat::hasAlpha(0xCu);
      int v113 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      int v114 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      uint64_t v455 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
      uint64_t result = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
      uint64_t v115 = result;
      if (hasAlpha)
      {
        if (v112)
        {
          if (v109 == v110)
          {
            if (v114)
            {
              for (int i7 = 0; i7 != v114; ++i7)
              {
                if (v113)
                {
                  uint64_t v393 = 0;
                  int v394 = v113;
                  do
                  {
                    v395 = (_WORD *)(v108 + v393);
                    _WORD *v395 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v107 + v393));
                    uint64_t result = 15360;
                    v395[1] = 15360;
                    v393 += 4;
                    --v394;
                  }
                  while (v394);
                }
                v107 += v455;
                v108 += v115;
              }
            }
          }
          else if (v109)
          {
            if (v114)
            {
              for (int i8 = 0; i8 != v114; ++i8)
              {
                if (v113)
                {
                  uint64_t v117 = 0;
                  int v118 = v113;
                  do
                  {
                    v119 = (_WORD *)(v108 + v117);
                    _WORD *v119 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v107 + v117));
                    uint64_t result = 15360;
                    v119[1] = 15360;
                    v117 += 4;
                    --v118;
                  }
                  while (v118);
                }
                v107 += v455;
                v108 += v115;
              }
            }
          }
          else if (v114)
          {
            for (int i9 = 0; i9 != v114; ++i9)
            {
              if (v113)
              {
                uint64_t v430 = 0;
                int v431 = v113;
                do
                {
                  v432 = (_WORD *)(v108 + v430);
                  _WORD *v432 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v107 + v430));
                  v432[1] = 15360;
                  uint64_t result = PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>::premultiply((unsigned __int16 *)(v108 + v430));
                  v430 += 4;
                  --v431;
                }
                while (v431);
              }
              v107 += v455;
              v108 += v115;
            }
          }
        }
        else if (v109)
        {
          if (v114)
          {
            for (int i10 = 0; i10 != v114; ++i10)
            {
              if (v113)
              {
                uint64_t v295 = 0;
                int v296 = v113;
                do
                {
                  uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v107 + v295));
                  *(_WORD *)(v108 + v295) = result;
                  v295 += 4;
                  --v296;
                }
                while (v296);
              }
              v107 += v455;
              v108 += v115;
            }
          }
        }
        else if (v114)
        {
          for (int i11 = 0; i11 != v114; ++i11)
          {
            if (v113)
            {
              uint64_t v410 = 0;
              int v411 = v113;
              do
              {
                uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v107 + v410));
                *(_WORD *)(v108 + v410) = result;
                v410 += 4;
                --v411;
              }
              while (v411);
            }
            v107 += v455;
            v108 += v115;
          }
        }
      }
      else if (v112)
      {
        if (v114)
        {
          for (int i12 = 0; i12 != v114; ++i12)
          {
            if (v113)
            {
              uint64_t v192 = 0;
              int v193 = v113;
              do
              {
                v194 = (_WORD *)(v108 + v192);
                _WORD *v194 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v107 + v192));
                uint64_t result = 15360;
                v194[1] = 15360;
                v192 += 4;
                --v193;
              }
              while (v193);
            }
            v107 += v455;
            v108 += v115;
          }
        }
      }
      else if (v114)
      {
        for (int i13 = 0; i13 != v114; ++i13)
        {
          if (v113)
          {
            uint64_t v311 = 0;
            int v312 = v113;
            do
            {
              uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v107 + v311));
              *(_WORD *)(v108 + v311) = result;
              v311 += 4;
              --v312;
            }
            while (v312);
          }
          v107 += v455;
          v108 += v115;
        }
      }
    }
    else if (result == 15)
    {
      uint64_t v55 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
      uint64_t v56 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
      int v57 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
      int v58 = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
      int v59 = PCPixelFormat::hasAlpha(0xEu);
      int v60 = PCPixelFormat::hasAlpha(0xFu);
      int v61 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      int v62 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      uint64_t v63 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
      uint64_t result = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
      if (v59)
      {
        if (v60)
        {
          if (v57 == v58)
          {
            if (v62)
            {
              for (int i14 = 0; i14 != v62; ++i14)
              {
                if (v61)
                {
                  uint64_t v385 = 0;
                  v386 = (_DWORD *)v56;
                  do
                  {
                    _DWORD *v386 = *(_DWORD *)(v55 + 4 * v385);
                    v386[1] = 1065353216;
                    ++v385;
                    v386 += 2;
                  }
                  while (v61 != v385);
                }
                v55 += v63;
                v56 += result;
              }
            }
          }
          else if (v57)
          {
            if (v62)
            {
              for (int i15 = 0; i15 != v62; ++i15)
              {
                if (v61)
                {
                  uint64_t v65 = 0;
                  int v66 = (_DWORD *)v56;
                  do
                  {
                    *int v66 = *(_DWORD *)(v55 + 4 * v65);
                    v66[1] = 1065353216;
                    ++v65;
                    v66 += 2;
                  }
                  while (v61 != v65);
                }
                v55 += v63;
                v56 += result;
              }
            }
          }
          else if (v62)
          {
            int v418 = 0;
            v419 = (_DWORD *)(v56 + 4);
            do
            {
              if (v61)
              {
                uint64_t v420 = 0;
                v421 = v419;
                do
                {
                  int v422 = *(_DWORD *)(v55 + 4 * v420);
                  _DWORD *v421 = 1065353216;
                  *(v421 - 1) = v422;
                  ++v420;
                  v421 += 2;
                }
                while (v61 != v420);
              }
              v55 += v63;
              ++v418;
              v419 = (_DWORD *)((char *)v419 + result);
            }
            while (v418 != v62);
          }
        }
        else if (v57)
        {
          if (v62)
          {
            for (int i16 = 0; i16 != v62; ++i16)
            {
              if (v61)
              {
                uint64_t v287 = 0;
                v288 = (_DWORD *)v56;
                do
                {
                  _DWORD *v288 = *(_DWORD *)(v55 + 4 * v287);
                  v288 += 2;
                  ++v287;
                }
                while (v61 != v287);
              }
              v55 += v63;
              v56 += result;
            }
          }
        }
        else if (v62)
        {
          for (int i17 = 0; i17 != v62; ++i17)
          {
            if (v61)
            {
              uint64_t v402 = 0;
              v403 = (_DWORD *)v56;
              do
              {
                _DWORD *v403 = *(_DWORD *)(v55 + 4 * v402);
                v403 += 2;
                ++v402;
              }
              while (v61 != v402);
            }
            v55 += v63;
            v56 += result;
          }
        }
      }
      else if (v60)
      {
        if (v62)
        {
          for (int i18 = 0; i18 != v62; ++i18)
          {
            if (v61)
            {
              uint64_t v184 = 0;
              v185 = (_DWORD *)v56;
              do
              {
                _DWORD *v185 = *(_DWORD *)(v55 + 4 * v184);
                v185[1] = 1065353216;
                ++v184;
                v185 += 2;
              }
              while (v61 != v184);
            }
            v55 += v63;
            v56 += result;
          }
        }
      }
      else if (v62)
      {
        for (int i19 = 0; i19 != v62; ++i19)
        {
          if (v61)
          {
            uint64_t v303 = 0;
            v304 = (_DWORD *)v56;
            do
            {
              _DWORD *v304 = *(_DWORD *)(v55 + 4 * v303);
              v304 += 2;
              ++v303;
            }
            while (v61 != v303);
          }
          v55 += v63;
          v56 += result;
        }
      }
    }
  }
  else if (result == 2)
  {
    uint64_t v92 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
    uint64_t v93 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
    int v94 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
    int v95 = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
    int v96 = PCPixelFormat::hasAlpha(1u);
    int v97 = PCPixelFormat::hasAlpha(2u);
    int v98 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
    int v99 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
    uint64_t v100 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
    uint64_t result = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
    if (v96)
    {
      if (v97)
      {
        if (v94 == v95)
        {
          if (v99)
          {
            for (int i20 = 0; i20 != v99; ++i20)
            {
              if (v98)
              {
                uint64_t v388 = 0;
                v389 = (unsigned char *)v93;
                do
                {
                  LOBYTE(v101) = *(unsigned char *)(v92 + v388);
                  float v390 = (double)*(unint64_t *)&v101 * 0.00392156863;
                  double v101 = (float)(v390 * 255.0) + 0.5 + 0.0000001;
                  int v391 = vcvtmd_s64_f64(v101);
                  if (v391 >= 255) {
                    int v391 = 255;
                  }
                  unsigned char *v389 = v391 & ~(v391 >> 31);
                  v389[1] = -1;
                  ++v388;
                  v389 += 2;
                }
                while (v98 != v388);
              }
              v92 += v100;
              v93 += result;
            }
          }
        }
        else if (v94)
        {
          if (v99)
          {
            for (int i21 = 0; i21 != v99; ++i21)
            {
              if (v98)
              {
                uint64_t v103 = 0;
                v104 = (unsigned char *)v93;
                do
                {
                  LOBYTE(v101) = *(unsigned char *)(v92 + v103);
                  float v105 = (double)*(unint64_t *)&v101 * 0.00392156863;
                  double v101 = (float)(v105 * 255.0) + 0.5 + 0.0000001;
                  int v106 = vcvtmd_s64_f64(v101);
                  if (v106 >= 255) {
                    int v106 = 255;
                  }
                  unsigned char *v104 = v106 & ~(v106 >> 31);
                  v104[1] = -1;
                  ++v103;
                  v104 += 2;
                }
                while (v98 != v103);
              }
              v92 += v100;
              v93 += result;
            }
          }
        }
        else if (v99)
        {
          int v423 = 0;
          v424 = (unsigned char *)(v93 + 1);
          do
          {
            if (v98)
            {
              uint64_t v425 = 0;
              v426 = v424;
              do
              {
                LOBYTE(v101) = *(unsigned char *)(v92 + v425);
                float v427 = (double)*(unint64_t *)&v101 * 0.00392156863;
                double v101 = (float)(v427 * 255.0) + 0.5 + 0.0000001;
                int v428 = vcvtmd_s64_f64(v101);
                if (v428 >= 255) {
                  int v428 = 255;
                }
                unsigned char *v426 = -1;
                *(v426 - 1) = v428 & ~(v428 >> 31);
                ++v425;
                v426 += 2;
              }
              while (v98 != v425);
            }
            v92 += v100;
            ++v423;
            v424 += result;
          }
          while (v423 != v99);
        }
      }
      else if (v94)
      {
        if (v99)
        {
          for (int i22 = 0; i22 != v99; ++i22)
          {
            if (v98)
            {
              uint64_t v290 = 0;
              v291 = (unsigned char *)v93;
              do
              {
                LOBYTE(v101) = *(unsigned char *)(v92 + v290);
                float v292 = (double)*(unint64_t *)&v101 * 0.00392156863;
                double v101 = (float)(v292 * 255.0) + 0.5 + 0.0000001;
                int v293 = vcvtmd_s64_f64(v101);
                if (v293 >= 255) {
                  int v293 = 255;
                }
                unsigned char *v291 = v293 & ~(v293 >> 31);
                v291 += 2;
                ++v290;
              }
              while (v98 != v290);
            }
            v92 += v100;
            v93 += result;
          }
        }
      }
      else if (v99)
      {
        for (int i23 = 0; i23 != v99; ++i23)
        {
          if (v98)
          {
            uint64_t v405 = 0;
            v406 = (unsigned char *)v93;
            do
            {
              LOBYTE(v101) = *(unsigned char *)(v92 + v405);
              float v407 = (double)*(unint64_t *)&v101 * 0.00392156863;
              double v101 = (float)(v407 * 255.0) + 0.5 + 0.0000001;
              int v408 = vcvtmd_s64_f64(v101);
              if (v408 >= 255) {
                int v408 = 255;
              }
              unsigned char *v406 = v408 & ~(v408 >> 31);
              v406 += 2;
              ++v405;
            }
            while (v98 != v405);
          }
          v92 += v100;
          v93 += result;
        }
      }
    }
    else if (v97)
    {
      if (v99)
      {
        for (int i24 = 0; i24 != v99; ++i24)
        {
          if (v98)
          {
            uint64_t v187 = 0;
            v188 = (unsigned char *)v93;
            do
            {
              LOBYTE(v101) = *(unsigned char *)(v92 + v187);
              float v189 = (double)*(unint64_t *)&v101 * 0.00392156863;
              double v101 = (float)(v189 * 255.0) + 0.5 + 0.0000001;
              int v190 = vcvtmd_s64_f64(v101);
              if (v190 >= 255) {
                int v190 = 255;
              }
              unsigned char *v188 = v190 & ~(v190 >> 31);
              v188[1] = -1;
              ++v187;
              v188 += 2;
            }
            while (v98 != v187);
          }
          v92 += v100;
          v93 += result;
        }
      }
    }
    else if (v99)
    {
      for (int i25 = 0; i25 != v99; ++i25)
      {
        if (v98)
        {
          uint64_t v306 = 0;
          v307 = (unsigned char *)v93;
          do
          {
            LOBYTE(v101) = *(unsigned char *)(v92 + v306);
            float v308 = (double)*(unint64_t *)&v101 * 0.00392156863;
            double v101 = (float)(v308 * 255.0) + 0.5 + 0.0000001;
            int v309 = vcvtmd_s64_f64(v101);
            if (v309 >= 255) {
              int v309 = 255;
            }
            unsigned char *v307 = v309 & ~(v309 >> 31);
            v307 += 2;
            ++v306;
          }
          while (v98 != v306);
        }
        v92 += v100;
        v93 += result;
      }
    }
  }
  else if (result == 8)
  {
    uint64_t v26 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
    uint64_t v27 = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 16))(*((void *)a3 + 8));
    int v28 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
    int v29 = (*(uint64_t (**)(const PCBitmap *))(*(void *)a3 + 48))(a3);
    int v30 = PCPixelFormat::hasAlpha(7u);
    int v31 = PCPixelFormat::hasAlpha(8u);
    int v32 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
    int v33 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
    uint64_t v34 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
    uint64_t result = (*(uint64_t (**)(void))(**((void **)a3 + 8) + 64))(*((void *)a3 + 8));
    if (v30)
    {
      if (v31)
      {
        if (v28 == v29)
        {
          if (v33)
          {
            for (int i26 = 0; i26 != v33; ++i26)
            {
              if (v32)
              {
                uint64_t v379 = 0;
                int v380 = v32;
                do
                {
                  LOWORD(v35) = *(_WORD *)(v26 + v379);
                  float v381 = (double)*(unint64_t *)&v35 * 0.0000152590219;
                  double v35 = (float)(v381 * 65535.0) + 0.5 + 0.0000001;
                  int v382 = vcvtmd_s64_f64(v35);
                  v383 = (_WORD *)(v27 + 2 * v379);
                  if (v382 >= 0xFFFF) {
                    int v382 = 0xFFFF;
                  }
                  _WORD *v383 = v382 & ~(unsigned __int16)(v382 >> 31);
                  v383[1] = -1;
                  v379 += 2;
                  --v380;
                }
                while (v380);
              }
              v26 += v34;
              v27 += result;
            }
          }
        }
        else if (v28)
        {
          if (v33)
          {
            for (int i27 = 0; i27 != v33; ++i27)
            {
              if (v32)
              {
                uint64_t v37 = 0;
                int v38 = v32;
                do
                {
                  LOWORD(v35) = *(_WORD *)(v26 + v37);
                  float v39 = (double)*(unint64_t *)&v35 * 0.0000152590219;
                  double v35 = (float)(v39 * 65535.0) + 0.5 + 0.0000001;
                  int v40 = vcvtmd_s64_f64(v35);
                  uint64_t v41 = (_WORD *)(v27 + 2 * v37);
                  if (v40 >= 0xFFFF) {
                    int v40 = 0xFFFF;
                  }
                  *uint64_t v41 = v40 & ~(unsigned __int16)(v40 >> 31);
                  v41[1] = -1;
                  v37 += 2;
                  --v38;
                }
                while (v38);
              }
              v26 += v34;
              v27 += result;
            }
          }
        }
        else if (v33)
        {
          for (int i28 = 0; i28 != v33; ++i28)
          {
            if (v32)
            {
              uint64_t v413 = 0;
              int v414 = v32;
              do
              {
                LOWORD(v35) = *(_WORD *)(v26 + v413);
                float v415 = (double)*(unint64_t *)&v35 * 0.0000152590219;
                double v35 = (float)(v415 * 65535.0) + 0.5 + 0.0000001;
                int v416 = vcvtmd_s64_f64(v35);
                v417 = (_WORD *)(v27 + 2 * v413);
                if (v416 >= 0xFFFF) {
                  int v416 = 0xFFFF;
                }
                v417[1] = -1;
                _WORD *v417 = v416 & ~(unsigned __int16)(v416 >> 31);
                v413 += 2;
                --v414;
              }
              while (v414);
            }
            v26 += v34;
            v27 += result;
          }
        }
      }
      else if (v28)
      {
        if (v33)
        {
          for (int i29 = 0; i29 != v33; ++i29)
          {
            if (v32)
            {
              uint64_t v282 = 0;
              int v283 = v32;
              do
              {
                LOWORD(v35) = *(_WORD *)(v26 + v282);
                float v284 = (double)*(unint64_t *)&v35 * 0.0000152590219;
                double v35 = (float)(v284 * 65535.0) + 0.5 + 0.0000001;
                int v285 = vcvtmd_s64_f64(v35);
                if (v285 >= 0xFFFF) {
                  int v285 = 0xFFFF;
                }
                *(_WORD *)(v27 + 2 * v28OZChannelFontBase::~OZChannelFontBase(this - 2) = v285 & ~(unsigned __int16)(v285 >> 31);
                v282 += 2;
                --v283;
              }
              while (v283);
            }
            v26 += v34;
            v27 += result;
          }
        }
      }
      else if (v33)
      {
        for (int i30 = 0; i30 != v33; ++i30)
        {
          if (v32)
          {
            uint64_t v397 = 0;
            int v398 = v32;
            do
            {
              LOWORD(v35) = *(_WORD *)(v26 + v397);
              float v399 = (double)*(unint64_t *)&v35 * 0.0000152590219;
              double v35 = (float)(v399 * 65535.0) + 0.5 + 0.0000001;
              int v400 = vcvtmd_s64_f64(v35);
              if (v400 >= 0xFFFF) {
                int v400 = 0xFFFF;
              }
              *(_WORD *)(v27 + 2 * v397) = v400 & ~(unsigned __int16)(v400 >> 31);
              v397 += 2;
              --v398;
            }
            while (v398);
          }
          v26 += v34;
          v27 += result;
        }
      }
    }
    else if (v31)
    {
      if (v33)
      {
        for (int i31 = 0; i31 != v33; ++i31)
        {
          if (v32)
          {
            uint64_t v178 = 0;
            int v179 = v32;
            do
            {
              LOWORD(v35) = *(_WORD *)(v26 + v178);
              float v180 = (double)*(unint64_t *)&v35 * 0.0000152590219;
              double v35 = (float)(v180 * 65535.0) + 0.5 + 0.0000001;
              int v181 = vcvtmd_s64_f64(v35);
              v182 = (_WORD *)(v27 + 2 * v178);
              if (v181 >= 0xFFFF) {
                int v181 = 0xFFFF;
              }
              _WORD *v182 = v181 & ~(unsigned __int16)(v181 >> 31);
              v182[1] = -1;
              v178 += 2;
              --v179;
            }
            while (v179);
          }
          v26 += v34;
          v27 += result;
        }
      }
    }
    else if (v33)
    {
      for (int i32 = 0; i32 != v33; ++i32)
      {
        if (v32)
        {
          uint64_t v298 = 0;
          int v299 = v32;
          do
          {
            LOWORD(v35) = *(_WORD *)(v26 + v298);
            float v300 = (double)*(unint64_t *)&v35 * 0.0000152590219;
            double v35 = (float)(v300 * 65535.0) + 0.5 + 0.0000001;
            int v301 = vcvtmd_s64_f64(v35);
            if (v301 >= 0xFFFF) {
              int v301 = 0xFFFF;
            }
            *(_WORD *)(v27 + 2 * v298) = v301 & ~(unsigned __int16)(v301 >> 31);
            v298 += 2;
            --v299;
          }
          while (v299);
        }
        v26 += v34;
        v27 += result;
      }
    }
  }
  return result;
}

uint64_t anonymous namespace'::copyFromCGBitmap(_anonymous_namespace_ *this, PCBitmap *a2, PCBitmap *a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8));
  switch((int)result)
  {
    case 3:
      uint64_t v6 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
      uint64_t v7 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
      int v8 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
      int v9 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 48))(a2);
      int hasAlpha = PCPixelFormat::hasAlpha(3u);
      int v11 = PCPixelFormat::hasAlpha(3u);
      int v12 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      int v13 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      uint64_t v14 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
      uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
      uint64_t v16 = result;
      if (hasAlpha)
      {
        if (v11)
        {
          if (v8 == v9)
          {
            if (v13)
            {
              for (int i = 0; i != v13; ++i)
              {
                if (v12)
                {
                  uint64_t v428 = 0;
                  int v429 = v12;
                  do
                  {
                    uint64_t v430 = (unsigned char *)(v6 + v428);
                    LOBYTE(v15) = *(unsigned char *)(v6 + v428 + 1);
                    float v431 = (double)*(unint64_t *)&v15 * 0.00392156863;
                    double v432 = (float)(v431 * 255.0) + 0.5 + 0.0000001;
                    int v433 = vcvtmd_s64_f64(v432);
                    int v434 = (unsigned char *)(v7 + v428);
                    if (v433 >= 255) {
                      int v433 = 255;
                    }
                    v434[1] = v433 & ~(v433 >> 31);
                    LOBYTE(v43OZChannelFontBase::~OZChannelFontBase(this - 2) = v430[2];
                    float v435 = (double)*(unint64_t *)&v432 * 0.00392156863;
                    double v436 = (float)(v435 * 255.0) + 0.5 + 0.0000001;
                    int v437 = vcvtmd_s64_f64(v436);
                    if (v437 >= 255) {
                      int v437 = 255;
                    }
                    v434[2] = v437 & ~(v437 >> 31);
                    LOBYTE(v436) = v430[3];
                    float v438 = (double)*(unint64_t *)&v436 * 0.00392156863;
                    double v439 = (float)(v438 * 255.0) + 0.5 + 0.0000001;
                    int v440 = vcvtmd_s64_f64(v439);
                    if (v440 >= 255) {
                      int v440 = 255;
                    }
                    v434[3] = v440 & ~(v440 >> 31);
                    LOBYTE(v439) = *v430;
                    float v441 = (double)*(unint64_t *)&v439 * 0.00392156863;
                    double v15 = (float)(v441 * 255.0) + 0.5 + 0.0000001;
                    int v442 = vcvtmd_s64_f64(v15);
                    if (v442 >= 255) {
                      int v442 = 255;
                    }
                    *int v434 = v442 & ~(v442 >> 31);
                    v428 += 4;
                    --v429;
                  }
                  while (v429);
                }
                v6 += v14;
                v7 += result;
              }
            }
          }
          else if (v8)
          {
            if (v13)
            {
              int v17 = 0;
              int v831 = v13;
              uint64_t v826 = v14;
              do
              {
                if (v12)
                {
                  uint64_t v18 = 0;
                  int v19 = v12;
                  do
                  {
                    int v20 = (unsigned char *)(v7 + v18);
                    LODWORD(v838) = *(_DWORD *)(v6 + v18);
                    uint64_t result = (uint64_t)PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>::unpremultiply((unsigned __int8 *)&v838);
                    LOBYTE(v21) = BYTE1(v838);
                    *(float *)&unint64_t v21 = (double)v21 * 0.00392156863;
                    double v22 = (float)(*(float *)&v21 * 255.0) + 0.5 + 0.0000001;
                    int v23 = vcvtmd_s64_f64(v22);
                    if (v23 >= 255) {
                      int v23 = 255;
                    }
                    v20[1] = v23 & ~(v23 >> 31);
                    LOBYTE(v2OZChannelFontBase::~OZChannelFontBase(this - 2) = BYTE2(v838);
                    float v24 = (double)*(unint64_t *)&v22 * 0.00392156863;
                    double v25 = (float)(v24 * 255.0) + 0.5 + 0.0000001;
                    int v26 = vcvtmd_s64_f64(v25);
                    if (v26 >= 255) {
                      int v26 = 255;
                    }
                    v20[2] = v26 & ~(v26 >> 31);
                    LOBYTE(v25) = BYTE3(v838);
                    float v27 = (double)*(unint64_t *)&v25 * 0.00392156863;
                    double v28 = (float)(v27 * 255.0) + 0.5 + 0.0000001;
                    int v29 = vcvtmd_s64_f64(v28);
                    if (v29 >= 255) {
                      int v29 = 255;
                    }
                    v20[3] = v29 & ~(v29 >> 31);
                    LOBYTE(v28) = v838;
                    float v30 = (double)*(unint64_t *)&v28 * 0.00392156863;
                    int v31 = vcvtmd_s64_f64((float)(v30 * 255.0) + 0.5 + 0.0000001);
                    if (v31 >= 255) {
                      int v31 = 255;
                    }
                    *int v20 = v31 & ~(v31 >> 31);
                    v18 += 4;
                    --v19;
                  }
                  while (v19);
                }
                v6 += v826;
                v7 += v16;
                ++v17;
              }
              while (v17 != v831);
            }
          }
          else if (v13)
          {
            for (int j = 0; j != v13; ++j)
            {
              if (v12)
              {
                uint64_t v624 = 0;
                int v625 = v12;
                do
                {
                  v626 = (unsigned char *)(v6 + v624);
                  LOBYTE(v15) = *(unsigned char *)(v6 + v624 + 1);
                  float v627 = (double)*(unint64_t *)&v15 * 0.00392156863;
                  double v628 = (float)(v627 * 255.0) + 0.5 + 0.0000001;
                  int v629 = vcvtmd_s64_f64(v628);
                  v630 = (unsigned char *)(v7 + v624);
                  if (v629 >= 255) {
                    int v629 = 255;
                  }
                  int v631 = v629 & ~(v629 >> 31);
                  v630[1] = v631;
                  LOBYTE(v628) = v626[2];
                  float v632 = (double)*(unint64_t *)&v628 * 0.00392156863;
                  double v633 = (float)(v632 * 255.0) + 0.5 + 0.0000001;
                  int v634 = vcvtmd_s64_f64(v633);
                  if (v634 >= 255) {
                    int v634 = 255;
                  }
                  int v635 = v634 & ~(v634 >> 31);
                  v630[2] = v635;
                  LOBYTE(v633) = v626[3];
                  float v636 = (double)*(unint64_t *)&v633 * 0.00392156863;
                  double v637 = (float)(v636 * 255.0) + 0.5 + 0.0000001;
                  int v638 = vcvtmd_s64_f64(v637);
                  if (v638 >= 255) {
                    int v638 = 255;
                  }
                  uint64_t result = v638 & ~(v638 >> 31);
                  v630[3] = result;
                  LOBYTE(v637) = *v626;
                  float v639 = (double)*(unint64_t *)&v637 * 0.00392156863;
                  double v15 = (float)(v639 * 255.0) + 0.5 + 0.0000001;
                  int v640 = vcvtmd_s64_f64(v15);
                  if (v640 >= 255) {
                    int v640 = 255;
                  }
                  int v641 = v640 & ~(v640 >> 31);
                  unsigned char *v630 = v641;
                  v630[1] = (32897 * v641 * v631) >> 23;
                  v630[2] = (32897 * v641 * v635) >> 23;
                  v630[3] = (32897 * v641 * result) >> 23;
                  v624 += 4;
                  --v625;
                }
                while (v625);
              }
              v6 += v14;
              v7 += v16;
            }
          }
        }
        else if (v8)
        {
          if (v13)
          {
            for (int k = 0; k != v13; ++k)
            {
              if (v12)
              {
                uint64_t v280 = 0;
                int v281 = v12;
                do
                {
                  uint64_t v282 = v6 + v280;
                  LOBYTE(v15) = *(unsigned char *)(v6 + v280 + 1);
                  float v283 = (double)*(unint64_t *)&v15 * 0.00392156863;
                  double v284 = (float)(v283 * 255.0) + 0.5 + 0.0000001;
                  int v285 = vcvtmd_s64_f64(v284);
                  if (v285 >= 255) {
                    int v285 = 255;
                  }
                  uint64_t v286 = v7 + v280;
                  *(unsigned char *)(v7 + v280 + 1) = v285 & ~(v285 >> 31);
                  LOBYTE(v284) = *(unsigned char *)(v282 + 2);
                  float v287 = (double)*(unint64_t *)&v284 * 0.00392156863;
                  double v288 = (float)(v287 * 255.0) + 0.5 + 0.0000001;
                  int v289 = vcvtmd_s64_f64(v288);
                  if (v289 >= 255) {
                    int v289 = 255;
                  }
                  *(unsigned char *)(v286 + OZChannelFontBase::~OZChannelFontBase(this - 2) = v289 & ~(v289 >> 31);
                  LOBYTE(v288) = *(unsigned char *)(v282 + 3);
                  float v290 = (double)*(unint64_t *)&v288 * 0.00392156863;
                  double v15 = (float)(v290 * 255.0) + 0.5 + 0.0000001;
                  int v291 = vcvtmd_s64_f64(v15);
                  if (v291 >= 255) {
                    int v291 = 255;
                  }
                  *(unsigned char *)(v286 + 3) = v291 & ~(v291 >> 31);
                  v280 += 4;
                  --v281;
                }
                while (v281);
              }
              v6 += v14;
              v7 += result;
            }
          }
        }
        else if (v13)
        {
          int v525 = 0;
          float64x2_t v526 = (float64x2_t)vdupq_n_s64(0x3F70101010101010uLL);
          float32x2_t v527 = (float32x2_t)vdup_n_s32(0x437F0000u);
          __asm { FMOV            V2.2D, #0.5 }
          float64x2_t v529 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
          do
          {
            if (v12)
            {
              uint64_t v530 = 0;
              int v531 = v12;
              do
              {
                int v532 = *(unsigned __int8 *)(v6 + v530);
                unsigned int v533 = ((32897 * *(unsigned __int8 *)(v6 + v530 + 2) * v532) >> 23);
                v534.f64[0] = (double)((32897 * *(unsigned __int8 *)(v6 + v530 + 1)
                                                               * v532) >> 23);
                unsigned int v535 = ((32897 * *(unsigned __int8 *)(v6 + v530 + 3) * v532) >> 23);
                v536 = (unsigned char *)(v7 + v530);
                v534.f64[1] = (double)v533;
                *(int32x2_t *)&v534.f64[0] = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(vmulq_f64(v534, v526)), v527)), _Q2), v529)))), (int32x2_t)0xFF000000FFLL), 0);
                char v537 = LOBYTE(v534.f64[0]);
                *(float *)v534.f64 = (double)v535 * 0.00392156863;
                v536[1] = v537;
                int v538 = vcvtmd_s64_f64((float)(*(float *)v534.f64 * 255.0) + 0.5 + 0.0000001);
                v536[2] = BYTE4(v534.f64[0]);
                if (v538 >= 255) {
                  int v539 = 255;
                }
                else {
                  int v539 = v538;
                }
                v536[3] = v539 & ~(v539 >> 31);
                v530 += 4;
                --v531;
              }
              while (v531);
            }
            v6 += v14;
            v7 += result;
            ++v525;
          }
          while (v525 != v13);
        }
      }
      else if (v11)
      {
        if (v13)
        {
          for (int m = 0; m != v13; ++m)
          {
            if (v12)
            {
              uint64_t v179 = 0;
              int v180 = v12;
              do
              {
                uint64_t v181 = v6 + v179;
                LOBYTE(v15) = *(unsigned char *)(v6 + v179 + 1);
                float v182 = (double)*(unint64_t *)&v15 * 0.00392156863;
                double v183 = (float)(v182 * 255.0) + 0.5 + 0.0000001;
                int v184 = vcvtmd_s64_f64(v183);
                v185 = (unsigned char *)(v7 + v179);
                if (v184 >= 255) {
                  int v184 = 255;
                }
                v185[1] = v184 & ~(v184 >> 31);
                LOBYTE(v183) = *(unsigned char *)(v181 + 2);
                float v186 = (double)*(unint64_t *)&v183 * 0.00392156863;
                double v187 = (float)(v186 * 255.0) + 0.5 + 0.0000001;
                int v188 = vcvtmd_s64_f64(v187);
                if (v188 >= 255) {
                  int v188 = 255;
                }
                v185[2] = v188 & ~(v188 >> 31);
                LOBYTE(v187) = *(unsigned char *)(v181 + 3);
                float v189 = (double)*(unint64_t *)&v187 * 0.00392156863;
                double v15 = (float)(v189 * 255.0) + 0.5 + 0.0000001;
                int v190 = vcvtmd_s64_f64(v15);
                if (v190 >= 255) {
                  int v190 = 255;
                }
                v185[3] = v190 & ~(v190 >> 31);
                unsigned char *v185 = -1;
                v179 += 4;
                --v180;
              }
              while (v180);
            }
            v6 += v14;
            v7 += result;
          }
        }
      }
      else if (v13)
      {
        for (int n = 0; n != v13; ++n)
        {
          if (v12)
          {
            uint64_t v352 = 0;
            int v353 = v12;
            do
            {
              uint64_t v354 = v6 + v352;
              LOBYTE(v15) = *(unsigned char *)(v6 + v352 + 1);
              float v355 = (double)*(unint64_t *)&v15 * 0.00392156863;
              double v356 = (float)(v355 * 255.0) + 0.5 + 0.0000001;
              int v357 = vcvtmd_s64_f64(v356);
              if (v357 >= 255) {
                int v357 = 255;
              }
              uint64_t v358 = v7 + v352;
              *(unsigned char *)(v7 + v352 + 1) = v357 & ~(v357 >> 31);
              LOBYTE(v356) = *(unsigned char *)(v354 + 2);
              float v359 = (double)*(unint64_t *)&v356 * 0.00392156863;
              double v360 = (float)(v359 * 255.0) + 0.5 + 0.0000001;
              int v361 = vcvtmd_s64_f64(v360);
              if (v361 >= 255) {
                int v361 = 255;
              }
              *(unsigned char *)(v358 + OZChannelFontBase::~OZChannelFontBase(this - 2) = v361 & ~(v361 >> 31);
              LOBYTE(v360) = *(unsigned char *)(v354 + 3);
              float v362 = (double)*(unint64_t *)&v360 * 0.00392156863;
              double v15 = (float)(v362 * 255.0) + 0.5 + 0.0000001;
              int v363 = vcvtmd_s64_f64(v15);
              if (v363 >= 255) {
                int v363 = 255;
              }
              *(unsigned char *)(v358 + 3) = v363 & ~(v363 >> 31);
              v352 += 4;
              --v353;
            }
            while (v353);
          }
          v6 += v14;
          v7 += result;
        }
      }
      break;
    case 4:
      if ((*(unsigned int (**)(PCBitmap *))(*(void *)a2 + 48))(a2)) {
        goto LABEL_53;
      }
      uint64_t v33 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
      uint64_t v34 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
      int v35 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
      int v36 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 48))(a2);
      int v37 = PCPixelFormat::hasAlpha(3u);
      int v38 = PCPixelFormat::hasAlpha(4u);
      int v39 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      int v40 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      uint64_t v41 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
      uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
      uint64_t v43 = result;
      if (v37)
      {
        if (v38)
        {
          if (v35 == v36)
          {
            if (v40)
            {
              for (iint i = 0; ii != v40; ++ii)
              {
                if (v39)
                {
                  uint64_t v643 = 0;
                  int v644 = v39;
                  do
                  {
                    v645 = (unsigned char *)(v33 + v643);
                    LOBYTE(v4OZChannelFontBase::~OZChannelFontBase(this - 2) = *(unsigned char *)(v33 + v643 + 1);
                    float v646 = (double)*(unint64_t *)&v42 * 0.00392156863;
                    double v647 = (float)(v646 * 255.0) + 0.5 + 0.0000001;
                    int v648 = vcvtmd_s64_f64(v647);
                    v649 = (unsigned char *)(v34 + v643);
                    if (v648 >= 255) {
                      int v648 = 255;
                    }
                    v649[3] = v648 & ~(v648 >> 31);
                    LOBYTE(v647) = v645[2];
                    float v650 = (double)*(unint64_t *)&v647 * 0.00392156863;
                    double v651 = (float)(v650 * 255.0) + 0.5 + 0.0000001;
                    int v652 = vcvtmd_s64_f64(v651);
                    if (v652 >= 255) {
                      int v652 = 255;
                    }
                    v649[2] = v652 & ~(v652 >> 31);
                    LOBYTE(v651) = v645[3];
                    float v653 = (double)*(unint64_t *)&v651 * 0.00392156863;
                    double v654 = (float)(v653 * 255.0) + 0.5 + 0.0000001;
                    int v655 = vcvtmd_s64_f64(v654);
                    if (v655 >= 255) {
                      int v655 = 255;
                    }
                    v649[1] = v655 & ~(v655 >> 31);
                    LOBYTE(v654) = *v645;
                    float v656 = (double)*(unint64_t *)&v654 * 0.00392156863;
                    double v42 = (float)(v656 * 255.0) + 0.5 + 0.0000001;
                    int v657 = vcvtmd_s64_f64(v42);
                    if (v657 >= 255) {
                      int v657 = 255;
                    }
                    unsigned char *v649 = v657 & ~(v657 >> 31);
                    v643 += 4;
                    --v644;
                  }
                  while (v644);
                }
                v33 += v41;
                v34 += result;
              }
            }
          }
          else if (v35)
          {
            if (v40)
            {
              int v44 = 0;
              float32x2_t v45 = (float32x2_t)vdup_n_s32(0x437F0000u);
              __asm { FMOV            V0.2D, #0.5 }
              float64x2_t v827 = _Q0;
              float64x2_t v832 = (float64x2_t)vdupq_n_s64(0x3F70101010101010uLL);
              float64x2_t v824 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
              do
              {
                if (v39)
                {
                  uint64_t v51 = 0;
                  int v52 = v39;
                  do
                  {
                    uint64_t v53 = (unsigned char *)(v34 + v51);
                    LODWORD(v838) = *(_DWORD *)(v33 + v51);
                    uint64_t result = (uint64_t)PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>::unpremultiply((unsigned __int8 *)&v838);
                    LOBYTE(v55) = BYTE2(v838);
                    LOBYTE(v54) = BYTE1(v838);
                    v56.f64[0] = (double)v55;
                    v56.f64[1] = (double)v54;
                    unint64_t v57 = (unint64_t)vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(vmulq_f64(v56, v832)), v45)), v827), v824)))), (int32x2_t)0xFF000000FFLL), 0);
                    _OWORD v53[3] = BYTE4(v57);
                    v53[2] = v57;
                    LOBYTE(v57) = BYTE3(v838);
                    LOBYTE(v56.f64[0]) = v838;
                    v56.f64[0] = (double)*(unint64_t *)&v56.f64[0];
                    v56.f64[1] = (double)v57;
                    int32x2_t v58 = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(vmulq_f64(v56, v832)), v45)), v827), v824)))), (int32x2_t)0xFF000000FFLL), 0);
                    v53[1] = v58.i8[4];
                    *uint64_t v53 = v58.i8[0];
                    v51 += 4;
                    --v52;
                  }
                  while (v52);
                }
                v33 += v41;
                v34 += v43;
                ++v44;
              }
              while (v44 != v40);
            }
          }
          else if (v40)
          {
            for (int jj = 0; jj != v40; ++jj)
            {
              if (v39)
              {
                uint64_t v778 = 0;
                int v779 = v39;
                do
                {
                  v780 = (unsigned char *)(v33 + v778);
                  LOBYTE(v4OZChannelFontBase::~OZChannelFontBase(this - 2) = *(unsigned char *)(v33 + v778 + 1);
                  float v781 = (double)*(unint64_t *)&v42 * 0.00392156863;
                  double v782 = (float)(v781 * 255.0) + 0.5 + 0.0000001;
                  int v783 = vcvtmd_s64_f64(v782);
                  v784 = (unsigned char *)(v34 + v778);
                  if (v783 >= 255) {
                    int v783 = 255;
                  }
                  int v785 = v783 & ~(v783 >> 31);
                  v784[3] = v785;
                  LOBYTE(v78OZChannelFontBase::~OZChannelFontBase(this - 2) = v780[2];
                  float v786 = (double)*(unint64_t *)&v782 * 0.00392156863;
                  double v787 = (float)(v786 * 255.0) + 0.5 + 0.0000001;
                  int v788 = vcvtmd_s64_f64(v787);
                  if (v788 >= 255) {
                    int v788 = 255;
                  }
                  int v789 = v788 & ~(v788 >> 31);
                  v784[2] = v789;
                  LOBYTE(v787) = v780[3];
                  float v790 = (double)*(unint64_t *)&v787 * 0.00392156863;
                  double v791 = (float)(v790 * 255.0) + 0.5 + 0.0000001;
                  int v792 = vcvtmd_s64_f64(v791);
                  if (v792 >= 255) {
                    int v792 = 255;
                  }
                  uint64_t result = v792 & ~(v792 >> 31);
                  v784[1] = result;
                  LOBYTE(v791) = *v780;
                  float v793 = (double)*(unint64_t *)&v791 * 0.00392156863;
                  double v42 = (float)(v793 * 255.0) + 0.5 + 0.0000001;
                  int v794 = vcvtmd_s64_f64(v42);
                  if (v794 >= 255) {
                    int v794 = 255;
                  }
                  int v795 = v794 & ~(v794 >> 31);
                  unsigned char *v784 = v795;
                  v784[3] = (32897 * v795 * v785) >> 23;
                  v784[2] = (32897 * v795 * v789) >> 23;
                  v784[1] = (32897 * v795 * result) >> 23;
                  v778 += 4;
                  --v779;
                }
                while (v779);
              }
              v33 += v41;
              v34 += v43;
            }
          }
        }
        else if (v35)
        {
          if (v40)
          {
            for (kint k = 0; kk != v40; ++kk)
            {
              if (v39)
              {
                uint64_t v444 = 3;
                int v445 = v39;
                do
                {
                  uint64_t v446 = (unsigned char *)(v33 + v444);
                  LOBYTE(v4OZChannelFontBase::~OZChannelFontBase(this - 2) = *(unsigned char *)(v33 + v444 - 2);
                  float v447 = (double)*(unint64_t *)&v42 * 0.00392156863;
                  double v448 = (float)(v447 * 255.0) + 0.5 + 0.0000001;
                  int v449 = vcvtmd_s64_f64(v448);
                  if (v449 >= 255) {
                    int v449 = 255;
                  }
                  uint64_t v450 = v34 + v444;
                  *(unsigned char *)(v34 + v444) = v449 & ~(v449 >> 31);
                  LOBYTE(v448) = *(v446 - 1);
                  float v451 = (double)*(unint64_t *)&v448 * 0.00392156863;
                  double v452 = (float)(v451 * 255.0) + 0.5 + 0.0000001;
                  int v453 = vcvtmd_s64_f64(v452);
                  if (v453 >= 255) {
                    int v453 = 255;
                  }
                  *(unsigned char *)(v450 - 1) = v453 & ~(v453 >> 31);
                  LOBYTE(v45OZChannelFontBase::~OZChannelFontBase(this - 2) = *v446;
                  float v454 = (double)*(unint64_t *)&v452 * 0.00392156863;
                  double v42 = (float)(v454 * 255.0) + 0.5 + 0.0000001;
                  int v455 = vcvtmd_s64_f64(v42);
                  if (v455 >= 255) {
                    int v455 = 255;
                  }
                  *(unsigned char *)(v450 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v455 & ~(v455 >> 31);
                  v444 += 4;
                  --v445;
                }
                while (v445);
              }
              v33 += v41;
              v34 += result;
            }
          }
        }
        else if (v40)
        {
          int v741 = 0;
          float64x2_t v742 = (float64x2_t)vdupq_n_s64(0x3F70101010101010uLL);
          float64x2_t v743 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
          float32x2_t v744 = (float32x2_t)vdup_n_s32(0x437F0000u);
          __asm { FMOV            V6.2D, #0.5 }
          do
          {
            if (v39)
            {
              uint64_t v746 = 0;
              int v747 = v39;
              do
              {
                int v748 = *(unsigned __int8 *)(v33 + v746);
                float v749 = (double)((32897 * *(unsigned __int8 *)(v33 + v746 + 1) * v748) >> 23)
                     * 0.00392156863;
                int v750 = vcvtmd_s64_f64((float)(v749 * 255.0) + 0.5 + 0.0000001);
                v751.f64[0] = (double)((32897
                                                       * *(unsigned __int8 *)(v33 + v746 + 3)
                                                       * v748) >> 23);
                v751.f64[1] = (double)((32897
                                                       * *(unsigned __int8 *)(v33 + v746 + 2)
                                                       * v748) >> 23);
                float32x2_t v752 = vmul_f32(vcvt_f32_f64(vmulq_f64(v751, v742)), v744);
                if (v750 >= 255) {
                  int v753 = 255;
                }
                else {
                  int v753 = v750;
                }
                int32x2_t v754 = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(v752), _Q6), v743)))), (int32x2_t)0xFF000000FFLL), 0);
                v755 = (unsigned char *)(v34 + v746);
                v755[3] = v753 & ~(v753 >> 31);
                v755[2] = v754.i8[4];
                v755[1] = v754.i8[0];
                v746 += 4;
                --v747;
              }
              while (v747);
            }
            v33 += v41;
            v34 += result;
            ++v741;
          }
          while (v741 != v40);
        }
      }
      else if (v38)
      {
        if (v40)
        {
          for (int mm = 0; mm != v40; ++mm)
          {
            if (v39)
            {
              uint64_t v293 = 3;
              int v294 = v39;
              do
              {
                uint64_t v295 = (unsigned char *)(v33 + v293);
                LOBYTE(v4OZChannelFontBase::~OZChannelFontBase(this - 2) = *(unsigned char *)(v33 + v293 - 2);
                float v296 = (double)*(unint64_t *)&v42 * 0.00392156863;
                double v297 = (float)(v296 * 255.0) + 0.5 + 0.0000001;
                int v298 = vcvtmd_s64_f64(v297);
                int v299 = (unsigned char *)(v34 + v293);
                if (v298 >= 255) {
                  int v298 = 255;
                }
                *int v299 = v298 & ~(v298 >> 31);
                LOBYTE(v297) = *(v295 - 1);
                float v300 = (double)*(unint64_t *)&v297 * 0.00392156863;
                double v301 = (float)(v300 * 255.0) + 0.5 + 0.0000001;
                int v302 = vcvtmd_s64_f64(v301);
                if (v302 >= 255) {
                  int v302 = 255;
                }
                *(v299 - 1) = v302 & ~(v302 >> 31);
                LOBYTE(v301) = *v295;
                float v303 = (double)*(unint64_t *)&v301 * 0.00392156863;
                double v42 = (float)(v303 * 255.0) + 0.5 + 0.0000001;
                int v304 = vcvtmd_s64_f64(v42);
                if (v304 >= 255) {
                  int v304 = 255;
                }
                *(v299 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v304 & ~(v304 >> 31);
                *(v299 - 3) = -1;
                v293 += 4;
                --v294;
              }
              while (v294);
            }
            v33 += v41;
            v34 += result;
          }
        }
      }
      else if (v40)
      {
        for (nint n = 0; nn != v40; ++nn)
        {
          if (v39)
          {
            uint64_t v541 = 3;
            int v542 = v39;
            do
            {
              v543 = (unsigned char *)(v33 + v541);
              LOBYTE(v4OZChannelFontBase::~OZChannelFontBase(this - 2) = *(unsigned char *)(v33 + v541 - 2);
              float v544 = (double)*(unint64_t *)&v42 * 0.00392156863;
              double v545 = (float)(v544 * 255.0) + 0.5 + 0.0000001;
              int v546 = vcvtmd_s64_f64(v545);
              if (v546 >= 255) {
                int v546 = 255;
              }
              uint64_t v547 = v34 + v541;
              *(unsigned char *)(v34 + v541) = v546 & ~(v546 >> 31);
              LOBYTE(v545) = *(v543 - 1);
              float v548 = (double)*(unint64_t *)&v545 * 0.00392156863;
              double v549 = (float)(v548 * 255.0) + 0.5 + 0.0000001;
              int v550 = vcvtmd_s64_f64(v549);
              if (v550 >= 255) {
                int v550 = 255;
              }
              *(unsigned char *)(v547 - 1) = v550 & ~(v550 >> 31);
              LOBYTE(v549) = *v543;
              float v551 = (double)*(unint64_t *)&v549 * 0.00392156863;
              double v42 = (float)(v551 * 255.0) + 0.5 + 0.0000001;
              int v552 = vcvtmd_s64_f64(v42);
              if (v552 >= 255) {
                int v552 = 255;
              }
              *(unsigned char *)(v547 - OZChannelFontBase::~OZChannelFontBase(this - 2) = v552 & ~(v552 >> 31);
              v541 += 4;
              --v542;
            }
            while (v542);
          }
          v33 += v41;
          v34 += result;
        }
      }
      break;
    case 5:
      uint64_t v59 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
      uint64_t v60 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
      int v61 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
      int v62 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 48))(a2);
      int v63 = PCPixelFormat::hasAlpha(5u);
      int v64 = PCPixelFormat::hasAlpha(5u);
      int v65 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      int v66 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      uint64_t v67 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
      uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
      uint64_t v69 = result;
      if (v63)
      {
        if (v64)
        {
          if (v61 == v62)
          {
            if (v66)
            {
              for (int i1 = 0; i1 != v66; ++i1)
              {
                if (v65)
                {
                  uint64_t v457 = 0;
                  int v458 = v65;
                  do
                  {
                    uint64_t v459 = (unsigned char *)(v59 + v457);
                    LOBYTE(v68) = *(unsigned char *)(v59 + v457);
                    float v460 = (double)*(unint64_t *)&v68 * 0.00392156863;
                    double v461 = (float)(v460 * 255.0) + 0.5 + 0.0000001;
                    int v462 = vcvtmd_s64_f64(v461);
                    v463 = (unsigned char *)(v60 + v457);
                    if (v462 >= 255) {
                      int v462 = 255;
                    }
                    unsigned char *v463 = v462 & ~(v462 >> 31);
                    LOBYTE(v461) = v459[1];
                    float v464 = (double)*(unint64_t *)&v461 * 0.00392156863;
                    double v465 = (float)(v464 * 255.0) + 0.5 + 0.0000001;
                    int v466 = vcvtmd_s64_f64(v465);
                    if (v466 >= 255) {
                      int v466 = 255;
                    }
                    v463[1] = v466 & ~(v466 >> 31);
                    LOBYTE(v465) = v459[2];
                    float v467 = (double)*(unint64_t *)&v465 * 0.00392156863;
                    double v468 = (float)(v467 * 255.0) + 0.5 + 0.0000001;
                    int v469 = vcvtmd_s64_f64(v468);
                    if (v469 >= 255) {
                      int v469 = 255;
                    }
                    v463[2] = v469 & ~(v469 >> 31);
                    LOBYTE(v468) = v459[3];
                    float v470 = (double)*(unint64_t *)&v468 * 0.00392156863;
                    double v68 = (float)(v470 * 255.0) + 0.5 + 0.0000001;
                    int v471 = vcvtmd_s64_f64(v68);
                    if (v471 >= 255) {
                      int v471 = 255;
                    }
                    v463[3] = v471 & ~(v471 >> 31);
                    v457 += 4;
                    --v458;
                  }
                  while (v458);
                }
                v59 += v67;
                v60 += result;
              }
            }
          }
          else if (v61)
          {
            if (v66)
            {
              int v70 = 0;
              int v833 = v66;
              uint64_t v828 = v67;
              do
              {
                if (v65)
                {
                  uint64_t v71 = 0;
                  int v72 = v65;
                  do
                  {
                    double v73 = (unsigned char *)(v60 + v71);
                    LODWORD(v838) = *(_DWORD *)(v59 + v71);
                    uint64_t result = (uint64_t)PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>::unpremultiply((unsigned __int8 *)&v838);
                    LOBYTE(v74) = v838;
                    *(float *)&unint64_t v74 = (double)v74 * 0.00392156863;
                    double v75 = (float)(*(float *)&v74 * 255.0) + 0.5 + 0.0000001;
                    int v76 = vcvtmd_s64_f64(v75);
                    if (v76 >= 255) {
                      int v76 = 255;
                    }
                    *double v73 = v76 & ~(v76 >> 31);
                    LOBYTE(v75) = BYTE1(v838);
                    float v77 = (double)*(unint64_t *)&v75 * 0.00392156863;
                    double v78 = (float)(v77 * 255.0) + 0.5 + 0.0000001;
                    int v79 = vcvtmd_s64_f64(v78);
                    if (v79 >= 255) {
                      int v79 = 255;
                    }
                    v73[1] = v79 & ~(v79 >> 31);
                    LOBYTE(v78) = BYTE2(v838);
                    float v80 = (double)*(unint64_t *)&v78 * 0.00392156863;
                    double v81 = (float)(v80 * 255.0) + 0.5 + 0.0000001;
                    int v82 = vcvtmd_s64_f64(v81);
                    if (v82 >= 255) {
                      int v82 = 255;
                    }
                    v73[2] = v82 & ~(v82 >> 31);
                    LOBYTE(v81) = BYTE3(v838);
                    float v83 = (double)*(unint64_t *)&v81 * 0.00392156863;
                    int v84 = vcvtmd_s64_f64((float)(v83 * 255.0) + 0.5 + 0.0000001);
                    if (v84 >= 255) {
                      int v84 = 255;
                    }
                    v73[3] = v84 & ~(v84 >> 31);
                    v71 += 4;
                    --v72;
                  }
                  while (v72);
                }
                v59 += v828;
                v60 += v69;
                ++v70;
              }
              while (v70 != v833);
            }
          }
          else if (v66)
          {
            for (int i2 = 0; i2 != v66; ++i2)
            {
              if (v65)
              {
                uint64_t v659 = 0;
                int v660 = v65;
                do
                {
                  v661 = (unsigned char *)(v59 + v659);
                  LOBYTE(v68) = *(unsigned char *)(v59 + v659);
                  float v662 = (double)*(unint64_t *)&v68 * 0.00392156863;
                  double v663 = (float)(v662 * 255.0) + 0.5 + 0.0000001;
                  int v664 = vcvtmd_s64_f64(v663);
                  v665 = (unsigned char *)(v60 + v659);
                  if (v664 >= 255) {
                    int v664 = 255;
                  }
                  int v666 = v664 & ~(v664 >> 31);
                  unsigned char *v665 = v666;
                  LOBYTE(v663) = v661[1];
                  float v667 = (double)*(unint64_t *)&v663 * 0.00392156863;
                  double v668 = (float)(v667 * 255.0) + 0.5 + 0.0000001;
                  int v669 = vcvtmd_s64_f64(v668);
                  if (v669 >= 255) {
                    int v669 = 255;
                  }
                  int v670 = v669 & ~(v669 >> 31);
                  v665[1] = v670;
                  LOBYTE(v668) = v661[2];
                  float v671 = (double)*(unint64_t *)&v668 * 0.00392156863;
                  double v672 = (float)(v671 * 255.0) + 0.5 + 0.0000001;
                  int v673 = vcvtmd_s64_f64(v672);
                  if (v673 >= 255) {
                    int v673 = 255;
                  }
                  uint64_t result = v673 & ~(v673 >> 31);
                  v665[2] = result;
                  LOBYTE(v67OZChannelFontBase::~OZChannelFontBase(this - 2) = v661[3];
                  float v674 = (double)*(unint64_t *)&v672 * 0.00392156863;
                  double v68 = (float)(v674 * 255.0) + 0.5 + 0.0000001;
                  int v675 = vcvtmd_s64_f64(v68);
                  if (v675 >= 255) {
                    int v675 = 255;
                  }
                  int v676 = v675 & ~(v675 >> 31);
                  v665[3] = v676;
                  unsigned char *v665 = (32897 * v676 * v666) >> 23;
                  v665[1] = (32897 * v676 * v670) >> 23;
                  v665[2] = (32897 * v676 * result) >> 23;
                  v659 += 4;
                  --v660;
                }
                while (v660);
              }
              v59 += v67;
              v60 += v69;
            }
          }
        }
        else if (v61)
        {
          if (v66)
          {
            for (int i3 = 0; i3 != v66; ++i3)
            {
              if (v65)
              {
                uint64_t v306 = 0;
                int v307 = v65;
                do
                {
                  uint64_t v308 = v59 + v306;
                  LOBYTE(v68) = *(unsigned char *)(v59 + v306);
                  float v309 = (double)*(unint64_t *)&v68 * 0.00392156863;
                  double v310 = (float)(v309 * 255.0) + 0.5 + 0.0000001;
                  uint64_t v311 = (unsigned char *)(v60 + v306);
                  int v312 = vcvtmd_s64_f64(v310);
                  if (v312 >= 255) {
                    int v312 = 255;
                  }
                  *uint64_t v311 = v312 & ~(v312 >> 31);
                  LOBYTE(v310) = *(unsigned char *)(v308 + 1);
                  float v313 = (double)*(unint64_t *)&v310 * 0.00392156863;
                  double v314 = (float)(v313 * 255.0) + 0.5 + 0.0000001;
                  int v315 = vcvtmd_s64_f64(v314);
                  if (v315 >= 255) {
                    int v315 = 255;
                  }
                  v311[1] = v315 & ~(v315 >> 31);
                  LOBYTE(v314) = *(unsigned char *)(v308 + 2);
                  float v316 = (double)*(unint64_t *)&v314 * 0.00392156863;
                  double v68 = (float)(v316 * 255.0) + 0.5 + 0.0000001;
                  int v317 = vcvtmd_s64_f64(v68);
                  if (v317 >= 255) {
                    int v317 = 255;
                  }
                  v311[2] = v317 & ~(v317 >> 31);
                  v306 += 4;
                  --v307;
                }
                while (v307);
              }
              v59 += v67;
              v60 += result;
            }
          }
        }
        else if (v66)
        {
          int v553 = 0;
          float64x2_t v554 = (float64x2_t)vdupq_n_s64(0x3F70101010101010uLL);
          float32x2_t v555 = (float32x2_t)vdup_n_s32(0x437F0000u);
          __asm { FMOV            V2.2D, #0.5 }
          float64x2_t v557 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
          do
          {
            if (v65)
            {
              uint64_t v558 = 0;
              int v559 = v65;
              do
              {
                int v560 = *(unsigned __int8 *)(v59 + v558 + 3);
                v561.f64[0] = (double)((32897 * v560 * *(unsigned __int8 *)(v59 + v558)) >> 23);
                v562 = (unsigned char *)(v60 + v558);
                v561.f64[1] = (double)((32897
                                                       * v560
                                                       * *(unsigned __int8 *)(v59 + v558 + 1)) >> 23);
                *(int32x2_t *)&v561.f64[0] = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(vmulq_f64(v561, v554)), v555)), _Q2), v557)))), (int32x2_t)0xFF000000FFLL), 0);
                char v563 = LOBYTE(v561.f64[0]);
                *(float *)v561.f64 = (double)((32897
                                                              * v560
                                                              * *(unsigned __int8 *)(v59 + v558 + 2)) >> 23)
                                   * 0.00392156863;
                unsigned char *v562 = v563;
                int v564 = vcvtmd_s64_f64((float)(*(float *)v561.f64 * 255.0) + 0.5 + 0.0000001);
                v562[1] = BYTE4(v561.f64[0]);
                if (v564 >= 255) {
                  int v565 = 255;
                }
                else {
                  int v565 = v564;
                }
                v562[2] = v565 & ~(v565 >> 31);
                v558 += 4;
                --v559;
              }
              while (v559);
            }
            v59 += v67;
            v60 += result;
            ++v553;
          }
          while (v553 != v66);
        }
      }
      else if (v64)
      {
        if (v66)
        {
          for (int i4 = 0; i4 != v66; ++i4)
          {
            if (v65)
            {
              uint64_t v192 = 0;
              int v193 = v65;
              do
              {
                uint64_t v194 = v59 + v192;
                LOBYTE(v68) = *(unsigned char *)(v59 + v192);
                float v195 = (double)*(unint64_t *)&v68 * 0.00392156863;
                double v196 = (float)(v195 * 255.0) + 0.5 + 0.0000001;
                int v197 = vcvtmd_s64_f64(v196);
                uint64_t v198 = (unsigned char *)(v60 + v192);
                if (v197 >= 255) {
                  int v197 = 255;
                }
                *uint64_t v198 = v197 & ~(v197 >> 31);
                LOBYTE(v196) = *(unsigned char *)(v194 + 1);
                float v199 = (double)*(unint64_t *)&v196 * 0.00392156863;
                double v200 = (float)(v199 * 255.0) + 0.5 + 0.0000001;
                int v201 = vcvtmd_s64_f64(v200);
                if (v201 >= 255) {
                  int v201 = 255;
                }
                v198[1] = v201 & ~(v201 >> 31);
                LOBYTE(v200) = *(unsigned char *)(v194 + 2);
                float v202 = (double)*(unint64_t *)&v200 * 0.00392156863;
                double v68 = (float)(v202 * 255.0) + 0.5 + 0.0000001;
                int v203 = vcvtmd_s64_f64(v68);
                if (v203 >= 255) {
                  int v203 = 255;
                }
                v198[2] = v203 & ~(v203 >> 31);
                v198[3] = -1;
                v192 += 4;
                --v193;
              }
              while (v193);
            }
            v59 += v67;
            v60 += result;
          }
        }
      }
      else if (v66)
      {
        for (int i5 = 0; i5 != v66; ++i5)
        {
          if (v65)
          {
            uint64_t v365 = 0;
            int v366 = v65;
            do
            {
              uint64_t v367 = v59 + v365;
              LOBYTE(v68) = *(unsigned char *)(v59 + v365);
              float v368 = (double)*(unint64_t *)&v68 * 0.00392156863;
              double v369 = (float)(v368 * 255.0) + 0.5 + 0.0000001;
              int v370 = (unsigned char *)(v60 + v365);
              int v371 = vcvtmd_s64_f64(v369);
              if (v371 >= 255) {
                int v371 = 255;
              }
              *int v370 = v371 & ~(v371 >> 31);
              LOBYTE(v369) = *(unsigned char *)(v367 + 1);
              float v372 = (double)*(unint64_t *)&v369 * 0.00392156863;
              double v373 = (float)(v372 * 255.0) + 0.5 + 0.0000001;
              int v374 = vcvtmd_s64_f64(v373);
              if (v374 >= 255) {
                int v374 = 255;
              }
              v370[1] = v374 & ~(v374 >> 31);
              LOBYTE(v373) = *(unsigned char *)(v367 + 2);
              float v375 = (double)*(unint64_t *)&v373 * 0.00392156863;
              double v68 = (float)(v375 * 255.0) + 0.5 + 0.0000001;
              int v376 = vcvtmd_s64_f64(v68);
              if (v376 >= 255) {
                int v376 = 255;
              }
              v370[2] = v376 & ~(v376 >> 31);
              v365 += 4;
              --v366;
            }
            while (v366);
          }
          v59 += v67;
          v60 += result;
        }
      }
      break;
    case 6:
      if ((*(unsigned int (**)(PCBitmap *))(*(void *)a2 + 48))(a2))
      {
LABEL_53:
      }
      else
      {
        uint64_t v204 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
        uint64_t v205 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
        int v206 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
        int v207 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 48))(a2);
        int v208 = PCPixelFormat::hasAlpha(3u);
        int v209 = PCPixelFormat::hasAlpha(6u);
        int v210 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v211 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v212 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
        uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
        uint64_t v214 = result;
        if (v208)
        {
          if (v209)
          {
            if (v206 == v207)
            {
              if (v211)
              {
                for (int i6 = 0; i6 != v211; ++i6)
                {
                  if (v210)
                  {
                    uint64_t v722 = 0;
                    int v723 = v210;
                    do
                    {
                      v724 = (unsigned char *)(v204 + v722);
                      LOBYTE(v213) = *(unsigned char *)(v204 + v722 + 1);
                      float v725 = (double)*(unint64_t *)&v213 * 0.00392156863;
                      double v726 = (float)(v725 * 255.0) + 0.5 + 0.0000001;
                      int v727 = vcvtmd_s64_f64(v726);
                      v728 = (unsigned char *)(v205 + v722);
                      if (v727 >= 255) {
                        int v727 = 255;
                      }
                      v728[2] = v727 & ~(v727 >> 31);
                      LOBYTE(v726) = v724[2];
                      float v729 = (double)*(unint64_t *)&v726 * 0.00392156863;
                      double v730 = (float)(v729 * 255.0) + 0.5 + 0.0000001;
                      int v731 = vcvtmd_s64_f64(v730);
                      if (v731 >= 255) {
                        int v731 = 255;
                      }
                      v728[1] = v731 & ~(v731 >> 31);
                      LOBYTE(v730) = v724[3];
                      float v732 = (double)*(unint64_t *)&v730 * 0.00392156863;
                      double v733 = (float)(v732 * 255.0) + 0.5 + 0.0000001;
                      int v734 = vcvtmd_s64_f64(v733);
                      if (v734 >= 255) {
                        int v734 = 255;
                      }
                      unsigned char *v728 = v734 & ~(v734 >> 31);
                      LOBYTE(v733) = *v724;
                      float v735 = (double)*(unint64_t *)&v733 * 0.00392156863;
                      double v213 = (float)(v735 * 255.0) + 0.5 + 0.0000001;
                      int v736 = vcvtmd_s64_f64(v213);
                      if (v736 >= 255) {
                        int v736 = 255;
                      }
                      v728[3] = v736 & ~(v736 >> 31);
                      v722 += 4;
                      --v723;
                    }
                    while (v723);
                  }
                  v204 += v212;
                  v205 += result;
                }
              }
            }
            else if (v206)
            {
              if (v211)
              {
                int v215 = 0;
                int v837 = v211;
                uint64_t v830 = v212;
                do
                {
                  if (v210)
                  {
                    uint64_t v216 = 0;
                    int v217 = v210;
                    do
                    {
                      double v218 = (unsigned char *)(v205 + v216);
                      LODWORD(v838) = *(_DWORD *)(v204 + v216);
                      uint64_t result = (uint64_t)PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>::unpremultiply((unsigned __int8 *)&v838);
                      LOBYTE(v219) = BYTE1(v838);
                      *(float *)&unint64_t v219 = (double)v219 * 0.00392156863;
                      double v220 = (float)(*(float *)&v219 * 255.0) + 0.5 + 0.0000001;
                      int v221 = vcvtmd_s64_f64(v220);
                      if (v221 >= 255) {
                        int v221 = 255;
                      }
                      v218[2] = v221 & ~(v221 >> 31);
                      LOBYTE(v220) = BYTE2(v838);
                      float v222 = (double)*(unint64_t *)&v220 * 0.00392156863;
                      double v223 = (float)(v222 * 255.0) + 0.5 + 0.0000001;
                      int v224 = vcvtmd_s64_f64(v223);
                      if (v224 >= 255) {
                        int v224 = 255;
                      }
                      v218[1] = v224 & ~(v224 >> 31);
                      LOBYTE(v223) = BYTE3(v838);
                      float v225 = (double)*(unint64_t *)&v223 * 0.00392156863;
                      double v226 = (float)(v225 * 255.0) + 0.5 + 0.0000001;
                      int v227 = vcvtmd_s64_f64(v226);
                      if (v227 >= 255) {
                        int v227 = 255;
                      }
                      *double v218 = v227 & ~(v227 >> 31);
                      LOBYTE(v226) = v838;
                      float v228 = (double)*(unint64_t *)&v226 * 0.00392156863;
                      int v229 = vcvtmd_s64_f64((float)(v228 * 255.0) + 0.5 + 0.0000001);
                      if (v229 >= 255) {
                        int v229 = 255;
                      }
                      v218[3] = v229 & ~(v229 >> 31);
                      v216 += 4;
                      --v217;
                    }
                    while (v217);
                  }
                  v204 += v830;
                  v205 += v214;
                  ++v215;
                }
                while (v215 != v837);
              }
            }
            else if (v211)
            {
              for (int i7 = 0; i7 != v211; ++i7)
              {
                if (v210)
                {
                  uint64_t v797 = 0;
                  int v798 = v210;
                  do
                  {
                    v799 = (unsigned char *)(v204 + v797);
                    LOBYTE(v213) = *(unsigned char *)(v204 + v797 + 1);
                    float v800 = (double)*(unint64_t *)&v213 * 0.00392156863;
                    double v801 = (float)(v800 * 255.0) + 0.5 + 0.0000001;
                    int v802 = vcvtmd_s64_f64(v801);
                    v803 = (unsigned char *)(v205 + v797);
                    if (v802 >= 255) {
                      int v802 = 255;
                    }
                    int v804 = v802 & ~(v802 >> 31);
                    v803[2] = v804;
                    LOBYTE(v801) = v799[2];
                    float v805 = (double)*(unint64_t *)&v801 * 0.00392156863;
                    double v806 = (float)(v805 * 255.0) + 0.5 + 0.0000001;
                    int v807 = vcvtmd_s64_f64(v806);
                    if (v807 >= 255) {
                      int v807 = 255;
                    }
                    int v808 = v807 & ~(v807 >> 31);
                    v803[1] = v808;
                    LOBYTE(v806) = v799[3];
                    float v809 = (double)*(unint64_t *)&v806 * 0.00392156863;
                    double v810 = (float)(v809 * 255.0) + 0.5 + 0.0000001;
                    int v811 = vcvtmd_s64_f64(v810);
                    if (v811 >= 255) {
                      int v811 = 255;
                    }
                    uint64_t result = v811 & ~(v811 >> 31);
                    unsigned char *v803 = result;
                    LOBYTE(v810) = *v799;
                    float v812 = (double)*(unint64_t *)&v810 * 0.00392156863;
                    double v213 = (float)(v812 * 255.0) + 0.5 + 0.0000001;
                    int v813 = vcvtmd_s64_f64(v213);
                    if (v813 >= 255) {
                      int v813 = 255;
                    }
                    int v814 = v813 & ~(v813 >> 31);
                    v803[3] = v814;
                    v803[2] = (32897 * v814 * v804) >> 23;
                    v803[1] = (32897 * v814 * v808) >> 23;
                    unsigned char *v803 = (32897 * v814 * result) >> 23;
                    v797 += 4;
                    --v798;
                  }
                  while (v798);
                }
                v204 += v212;
                v205 += v214;
              }
            }
          }
          else if (v206)
          {
            if (v211)
            {
              for (int i8 = 0; i8 != v211; ++i8)
              {
                if (v210)
                {
                  uint64_t v509 = 0;
                  int v510 = v210;
                  do
                  {
                    uint64_t v511 = v204 + v509;
                    LOBYTE(v213) = *(unsigned char *)(v204 + v509 + 1);
                    float v512 = (double)*(unint64_t *)&v213 * 0.00392156863;
                    double v513 = (float)(v512 * 255.0) + 0.5 + 0.0000001;
                    v514 = (unsigned char *)(v205 + v509);
                    int v515 = vcvtmd_s64_f64(v513);
                    if (v515 >= 255) {
                      int v515 = 255;
                    }
                    v514[2] = v515 & ~(v515 >> 31);
                    LOBYTE(v513) = *(unsigned char *)(v511 + 2);
                    float v516 = (double)*(unint64_t *)&v513 * 0.00392156863;
                    double v517 = (float)(v516 * 255.0) + 0.5 + 0.0000001;
                    int v518 = vcvtmd_s64_f64(v517);
                    if (v518 >= 255) {
                      int v518 = 255;
                    }
                    v514[1] = v518 & ~(v518 >> 31);
                    LOBYTE(v517) = *(unsigned char *)(v511 + 3);
                    float v519 = (double)*(unint64_t *)&v517 * 0.00392156863;
                    double v213 = (float)(v519 * 255.0) + 0.5 + 0.0000001;
                    int v520 = vcvtmd_s64_f64(v213);
                    if (v520 >= 255) {
                      int v520 = 255;
                    }
                    unsigned char *v514 = v520 & ~(v520 >> 31);
                    v509 += 4;
                    --v510;
                  }
                  while (v510);
                }
                v204 += v212;
                v205 += result;
              }
            }
          }
          else if (v211)
          {
            int v756 = 0;
            float64x2_t v757 = (float64x2_t)vdupq_n_s64(0x3F70101010101010uLL);
            float64x2_t v758 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
            float32x2_t v759 = (float32x2_t)vdup_n_s32(0x437F0000u);
            __asm { FMOV            V6.2D, #0.5 }
            do
            {
              if (v210)
              {
                uint64_t v761 = 0;
                int v762 = v210;
                do
                {
                  int v763 = *(unsigned __int8 *)(v204 + v761);
                  float v764 = (double)((32897 * *(unsigned __int8 *)(v204 + v761 + 1) * v763) >> 23)
                       * 0.00392156863;
                  int v765 = vcvtmd_s64_f64((float)(v764 * 255.0) + 0.5 + 0.0000001);
                  v766.f64[0] = (double)((32897
                                                         * *(unsigned __int8 *)(v204 + v761 + 3)
                                                         * v763) >> 23);
                  v766.f64[1] = (double)((32897
                                                         * *(unsigned __int8 *)(v204 + v761 + 2)
                                                         * v763) >> 23);
                  float32x2_t v767 = vmul_f32(vcvt_f32_f64(vmulq_f64(v766, v757)), v759);
                  if (v765 >= 255) {
                    int v768 = 255;
                  }
                  else {
                    int v768 = v765;
                  }
                  int32x2_t v769 = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(v767), _Q6), v758)))), (int32x2_t)0xFF000000FFLL), 0);
                  v770 = (unsigned char *)(v205 + v761);
                  v770[2] = v768 & ~(v768 >> 31);
                  v770[1] = v769.i8[4];
                  unsigned char *v770 = v769.i8[0];
                  v761 += 4;
                  --v762;
                }
                while (v762);
              }
              v204 += v212;
              v205 += result;
              ++v756;
            }
            while (v756 != v211);
          }
        }
        else if (v209)
        {
          if (v211)
          {
            for (int i9 = 0; i9 != v211; ++i9)
            {
              if (v210)
              {
                uint64_t v378 = 0;
                int v379 = v210;
                do
                {
                  uint64_t v380 = v204 + v378;
                  LOBYTE(v213) = *(unsigned char *)(v204 + v378 + 1);
                  float v381 = (double)*(unint64_t *)&v213 * 0.00392156863;
                  double v382 = (float)(v381 * 255.0) + 0.5 + 0.0000001;
                  int v383 = vcvtmd_s64_f64(v382);
                  v384 = (unsigned char *)(v205 + v378);
                  if (v383 >= 255) {
                    int v383 = 255;
                  }
                  v384[2] = v383 & ~(v383 >> 31);
                  LOBYTE(v38OZChannelFontBase::~OZChannelFontBase(this - 2) = *(unsigned char *)(v380 + 2);
                  float v385 = (double)*(unint64_t *)&v382 * 0.00392156863;
                  double v386 = (float)(v385 * 255.0) + 0.5 + 0.0000001;
                  int v387 = vcvtmd_s64_f64(v386);
                  if (v387 >= 255) {
                    int v387 = 255;
                  }
                  v384[1] = v387 & ~(v387 >> 31);
                  LOBYTE(v386) = *(unsigned char *)(v380 + 3);
                  float v388 = (double)*(unint64_t *)&v386 * 0.00392156863;
                  double v213 = (float)(v388 * 255.0) + 0.5 + 0.0000001;
                  int v389 = vcvtmd_s64_f64(v213);
                  if (v389 >= 255) {
                    int v389 = 255;
                  }
                  unsigned char *v384 = v389 & ~(v389 >> 31);
                  v384[3] = -1;
                  v378 += 4;
                  --v379;
                }
                while (v379);
              }
              v204 += v212;
              v205 += result;
            }
          }
        }
        else if (v211)
        {
          for (int i10 = 0; i10 != v211; ++i10)
          {
            if (v210)
            {
              uint64_t v607 = 0;
              int v608 = v210;
              do
              {
                uint64_t v609 = v204 + v607;
                LOBYTE(v213) = *(unsigned char *)(v204 + v607 + 1);
                float v610 = (double)*(unint64_t *)&v213 * 0.00392156863;
                double v611 = (float)(v610 * 255.0) + 0.5 + 0.0000001;
                v612 = (unsigned char *)(v205 + v607);
                int v613 = vcvtmd_s64_f64(v611);
                if (v613 >= 255) {
                  int v613 = 255;
                }
                v612[2] = v613 & ~(v613 >> 31);
                LOBYTE(v611) = *(unsigned char *)(v609 + 2);
                float v614 = (double)*(unint64_t *)&v611 * 0.00392156863;
                double v615 = (float)(v614 * 255.0) + 0.5 + 0.0000001;
                int v616 = vcvtmd_s64_f64(v615);
                if (v616 >= 255) {
                  int v616 = 255;
                }
                v612[1] = v616 & ~(v616 >> 31);
                LOBYTE(v615) = *(unsigned char *)(v609 + 3);
                float v617 = (double)*(unint64_t *)&v615 * 0.00392156863;
                double v213 = (float)(v617 * 255.0) + 0.5 + 0.0000001;
                int v618 = vcvtmd_s64_f64(v213);
                if (v618 >= 255) {
                  int v618 = 255;
                }
                unsigned char *v612 = v618 & ~(v618 >> 31);
                v607 += 4;
                --v608;
              }
              while (v608);
            }
            v204 += v212;
            v205 += result;
          }
        }
      }
      break;
    case 9:
      uint64_t v85 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
      uint64_t v86 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
      int v87 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
      int v88 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 48))(a2);
      int v89 = PCPixelFormat::hasAlpha(0xAu);
      int v90 = PCPixelFormat::hasAlpha(9u);
      int v91 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      int v92 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      uint64_t v93 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
      uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
      uint64_t v96 = result;
      if (v89)
      {
        if (v90)
        {
          if (v87 == v88)
          {
            if (v92)
            {
              int v472 = 0;
              float64x2_t v473 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
              float32x2_t v474 = (float32x2_t)vdup_n_s32(0x477FFF00u);
              __asm { FMOV            V2.2D, #0.5 }
              float64x2_t v476 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
              do
              {
                int v477 = v91;
                v478 = (_WORD *)v86;
                for (int i11 = (_WORD *)v85; v477; --v477)
                {
                  LOWORD(v94) = *i11;
                  v480.f64[0] = (double)*(unint64_t *)&v94;
                  LOWORD(v95) = i11[1];
                  double v95 = (double)*(unint64_t *)&v95;
                  v480.f64[1] = v95;
                  *(int32x2_t *)&v480.f64[0] = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(vmulq_f64(v480, v473)), v474)), _Q2), v476)))), (int32x2_t)0xFFFF0000FFFFLL), 0);
                  v478[1] = WORD2(v480.f64[0]);
                  _WORD *v478 = LOWORD(v480.f64[0]);
                  LOWORD(v480.f64[0]) = i11[2];
                  *(float *)v480.f64 = (double)*(unint64_t *)&v480.f64[0] * 0.0000152590219;
                  double v94 = (float)(*(float *)v480.f64 * 65535.0) + 0.5 + 0.0000001;
                  int v481 = vcvtmd_s64_f64(v94);
                  if (v481 >= 0xFFFF) {
                    int v481 = 0xFFFF;
                  }
                  v478[2] = v481 & ~(unsigned __int16)(v481 >> 31);
                  i11 += 4;
                  v478 += 3;
                }
                v85 += v93;
                v86 += result;
                ++v472;
              }
              while (v472 != v92);
            }
          }
          else if (v87)
          {
            if (v92)
            {
              int v97 = 0;
              float32x2_t v98 = (float32x2_t)vdup_n_s32(0x477FFF00u);
              __asm { FMOV            V0.2D, #0.5 }
              float64x2_t v829 = _Q0;
              float64x2_t v834 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
              float64x2_t v825 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
              int v823 = v92;
              do
              {
                if (v91)
                {
                  uint64_t v100 = 0;
                  double v101 = (_WORD *)v86;
                  do
                  {
                    uint64_t v838 = *(void *)(v85 + 8 * v100);
                    uint64_t result = (uint64_t)PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>::unpremultiply((unsigned __int16 *)&v838);
                    LOWORD(v10OZChannelFontBase::~OZChannelFontBase(this - 2) = v838;
                    v103.f64[0] = (double)v102;
                    LOWORD(v104) = WORD1(v838);
                    v103.f64[1] = (double)v104;
                    *(int32x2_t *)&v103.f64[0] = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(vmulq_f64(v103, v834)), v98)), v829), v825)))), (int32x2_t)0xFFFF0000FFFFLL), 0);
                    v101[1] = WORD2(v103.f64[0]);
                    *double v101 = LOWORD(v103.f64[0]);
                    LOWORD(v103.f64[0]) = WORD2(v838);
                    *(float *)v103.f64 = (double)*(unint64_t *)&v103.f64[0] * 0.0000152590219;
                    int v105 = vcvtmd_s64_f64((float)(*(float *)v103.f64 * 65535.0) + 0.5 + 0.0000001);
                    if (v105 >= 0xFFFF) {
                      int v105 = 0xFFFF;
                    }
                    v101[2] = v105 & ~(unsigned __int16)(v105 >> 31);
                    ++v100;
                    v101 += 3;
                  }
                  while (v91 != v100);
                }
                v85 += v93;
                v86 += v96;
                ++v97;
              }
              while (v97 != v823);
            }
          }
          else if (v92)
          {
            int v677 = 0;
            float64x2_t v678 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
            float32x2_t v679 = (float32x2_t)vdup_n_s32(0x477FFF00u);
            __asm { FMOV            V2.2D, #0.5 }
            float64x2_t v681 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
            do
            {
              int v682 = v91;
              v683 = (_WORD *)v86;
              for (int i12 = (_WORD *)v85; v682; --v682)
              {
                LOWORD(v94) = *i12;
                v685.f64[0] = (double)*(unint64_t *)&v94;
                LOWORD(v95) = i12[1];
                double v95 = (double)*(unint64_t *)&v95;
                v685.f64[1] = v95;
                *(int32x2_t *)&v685.f64[0] = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(vmulq_f64(v685, v678)), v679)), _Q2), v681)))), (int32x2_t)0xFFFF0000FFFFLL), 0);
                v683[1] = WORD2(v685.f64[0]);
                _WORD *v683 = LOWORD(v685.f64[0]);
                LOWORD(v685.f64[0]) = i12[2];
                *(float *)v685.f64 = (double)*(unint64_t *)&v685.f64[0] * 0.0000152590219;
                double v94 = (float)(*(float *)v685.f64 * 65535.0) + 0.5 + 0.0000001;
                int v686 = vcvtmd_s64_f64(v94);
                if (v686 >= 0xFFFF) {
                  int v686 = 0xFFFF;
                }
                v683[2] = v686 & ~(unsigned __int16)(v686 >> 31);
                i12 += 4;
                v683 += 3;
              }
              v85 += v93;
              v86 += result;
              ++v677;
            }
            while (v677 != v92);
          }
        }
        else if (v87)
        {
          if (v92)
          {
            int v318 = 0;
            float64x2_t v319 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
            float32x2_t v320 = (float32x2_t)vdup_n_s32(0x477FFF00u);
            __asm { FMOV            V2.2D, #0.5 }
            float64x2_t v322 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
            do
            {
              int v323 = v91;
              double v324 = (_WORD *)v86;
              for (int i13 = (_WORD *)v85; v323; --v323)
              {
                LOWORD(v94) = *i13;
                v326.f64[0] = (double)*(unint64_t *)&v94;
                LOWORD(v95) = i13[1];
                double v95 = (double)*(unint64_t *)&v95;
                v326.f64[1] = v95;
                *(int32x2_t *)&v326.f64[0] = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(vmulq_f64(v326, v319)), v320)), _Q2), v322)))), (int32x2_t)0xFFFF0000FFFFLL), 0);
                v324[1] = WORD2(v326.f64[0]);
                *double v324 = LOWORD(v326.f64[0]);
                LOWORD(v326.f64[0]) = i13[2];
                *(float *)v326.f64 = (double)*(unint64_t *)&v326.f64[0] * 0.0000152590219;
                double v94 = (float)(*(float *)v326.f64 * 65535.0) + 0.5 + 0.0000001;
                int v327 = vcvtmd_s64_f64(v94);
                if (v327 >= 0xFFFF) {
                  int v327 = 0xFFFF;
                }
                v324[2] = v327 & ~(unsigned __int16)(v327 >> 31);
                i13 += 4;
                v324 += 3;
              }
              v85 += v93;
              v86 += result;
              ++v318;
            }
            while (v318 != v92);
          }
        }
        else if (v92)
        {
          int v566 = 0;
          float64x2_t v567 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
          float32x2_t v568 = (float32x2_t)vdup_n_s32(0x477FFF00u);
          __asm { FMOV            V2.2D, #0.5 }
          float64x2_t v570 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
          do
          {
            int v571 = v91;
            v572 = (_WORD *)v86;
            for (int i14 = (unsigned __int16 *)v85; v571; --v571)
            {
              int v574 = i14[3];
              v575.f64[0] = (double)(unsigned __int16)(v574 * *i14 / 0xFFFF);
              v575.f64[1] = (double)(unsigned __int16)(v574 * i14[1] / 0xFFFF);
              *(int32x2_t *)&v575.f64[0] = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(vmulq_f64(v575, v567)), v568)), _Q2), v570)))), (int32x2_t)0xFFFF0000FFFFLL), 0);
              __int16 v576 = LOWORD(v575.f64[0]);
              *(float *)v575.f64 = (double)(unsigned __int16)(v574 * i14[2] / 0xFFFF) * 0.0000152590219;
              _WORD *v572 = v576;
              int v577 = vcvtmd_s64_f64((float)(*(float *)v575.f64 * 65535.0) + 0.5 + 0.0000001);
              v572[1] = WORD2(v575.f64[0]);
              if (v577 >= 0xFFFF) {
                int v578 = 0xFFFF;
              }
              else {
                int v578 = v577;
              }
              v572[2] = v578 & ~(unsigned __int16)(v578 >> 31);
              i14 += 4;
              v572 += 3;
            }
            v85 += v93;
            v86 += result;
            ++v566;
          }
          while (v566 != v92);
        }
      }
      else if (v90)
      {
        if (v92)
        {
          int v230 = 0;
          float64x2_t v231 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
          float32x2_t v232 = (float32x2_t)vdup_n_s32(0x477FFF00u);
          __asm { FMOV            V2.2D, #0.5 }
          float64x2_t v234 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
          do
          {
            int v235 = v91;
            float v236 = (_WORD *)v86;
            for (int i15 = (_WORD *)v85; v235; --v235)
            {
              LOWORD(v94) = *i15;
              v238.f64[0] = (double)*(unint64_t *)&v94;
              LOWORD(v95) = i15[1];
              double v95 = (double)*(unint64_t *)&v95;
              v238.f64[1] = v95;
              *(int32x2_t *)&v238.f64[0] = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(vmulq_f64(v238, v231)), v232)), _Q2), v234)))), (int32x2_t)0xFFFF0000FFFFLL), 0);
              v236[1] = WORD2(v238.f64[0]);
              *float v236 = LOWORD(v238.f64[0]);
              LOWORD(v238.f64[0]) = i15[2];
              *(float *)v238.f64 = (double)*(unint64_t *)&v238.f64[0] * 0.0000152590219;
              double v94 = (float)(*(float *)v238.f64 * 65535.0) + 0.5 + 0.0000001;
              int v239 = vcvtmd_s64_f64(v94);
              if (v239 >= 0xFFFF) {
                int v239 = 0xFFFF;
              }
              v236[2] = v239 & ~(unsigned __int16)(v239 >> 31);
              i15 += 4;
              v236 += 3;
            }
            v85 += v93;
            v86 += result;
            ++v230;
          }
          while (v230 != v92);
        }
      }
      else if (v92)
      {
        int v390 = 0;
        float64x2_t v391 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
        float32x2_t v392 = (float32x2_t)vdup_n_s32(0x477FFF00u);
        __asm { FMOV            V2.2D, #0.5 }
        float64x2_t v394 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
        do
        {
          int v395 = v91;
          v396 = (_WORD *)v86;
          for (int i16 = (_WORD *)v85; v395; --v395)
          {
            LOWORD(v94) = *i16;
            v398.f64[0] = (double)*(unint64_t *)&v94;
            LOWORD(v95) = i16[1];
            double v95 = (double)*(unint64_t *)&v95;
            v398.f64[1] = v95;
            *(int32x2_t *)&v398.f64[0] = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(vmulq_f64(v398, v391)), v392)), _Q2), v394)))), (int32x2_t)0xFFFF0000FFFFLL), 0);
            v396[1] = WORD2(v398.f64[0]);
            _WORD *v396 = LOWORD(v398.f64[0]);
            LOWORD(v398.f64[0]) = i16[2];
            *(float *)v398.f64 = (double)*(unint64_t *)&v398.f64[0] * 0.0000152590219;
            double v94 = (float)(*(float *)v398.f64 * 65535.0) + 0.5 + 0.0000001;
            int v399 = vcvtmd_s64_f64(v94);
            if (v399 >= 0xFFFF) {
              int v399 = 0xFFFF;
            }
            v396[2] = v399 & ~(unsigned __int16)(v399 >> 31);
            i16 += 4;
            v396 += 3;
          }
          v85 += v93;
          v86 += result;
          ++v390;
        }
        while (v390 != v92);
      }
      break;
    case 10:
      uint64_t v106 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
      uint64_t v107 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
      int v108 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
      int v109 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 48))(a2);
      int v110 = PCPixelFormat::hasAlpha(0xAu);
      int v111 = PCPixelFormat::hasAlpha(0xAu);
      int v112 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      int v113 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      uint64_t v114 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
      uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
      uint64_t v116 = result;
      if (v110)
      {
        if (v111)
        {
          if (v108 == v109)
          {
            if (v113)
            {
              for (int i17 = 0; i17 != v113; ++i17)
              {
                if (v112)
                {
                  uint64_t v483 = 0;
                  int v484 = v112;
                  do
                  {
                    v485 = (_WORD *)(v106 + v483);
                    LOWORD(v115) = *(_WORD *)(v106 + v483);
                    float v486 = (double)*(unint64_t *)&v115 * 0.0000152590219;
                    double v487 = (float)(v486 * 65535.0) + 0.5 + 0.0000001;
                    int v488 = vcvtmd_s64_f64(v487);
                    v489 = (_WORD *)(v107 + v483);
                    if (v488 >= 0xFFFF) {
                      int v488 = 0xFFFF;
                    }
                    _WORD *v489 = v488 & ~(unsigned __int16)(v488 >> 31);
                    LOWORD(v487) = v485[1];
                    float v490 = (double)*(unint64_t *)&v487 * 0.0000152590219;
                    double v491 = (float)(v490 * 65535.0) + 0.5 + 0.0000001;
                    int v492 = vcvtmd_s64_f64(v491);
                    if (v492 >= 0xFFFF) {
                      int v492 = 0xFFFF;
                    }
                    v489[1] = v492 & ~(unsigned __int16)(v492 >> 31);
                    LOWORD(v491) = v485[2];
                    float v493 = (double)*(unint64_t *)&v491 * 0.0000152590219;
                    double v494 = (float)(v493 * 65535.0) + 0.5 + 0.0000001;
                    int v495 = vcvtmd_s64_f64(v494);
                    if (v495 >= 0xFFFF) {
                      int v495 = 0xFFFF;
                    }
                    v489[2] = v495 & ~(unsigned __int16)(v495 >> 31);
                    LOWORD(v494) = v485[3];
                    float v496 = (double)*(unint64_t *)&v494 * 0.0000152590219;
                    double v115 = (float)(v496 * 65535.0) + 0.5 + 0.0000001;
                    int v497 = vcvtmd_s64_f64(v115);
                    if (v497 >= 0xFFFF) {
                      int v497 = 0xFFFF;
                    }
                    v489[3] = v497 & ~(unsigned __int16)(v497 >> 31);
                    v483 += 8;
                    --v484;
                  }
                  while (v484);
                }
                v106 += v114;
                v107 += result;
              }
            }
          }
          else if (v108)
          {
            if (v113)
            {
              int v117 = 0;
              uint64_t v835 = v114;
              do
              {
                if (v112)
                {
                  uint64_t v118 = 0;
                  int v119 = v112;
                  do
                  {
                    v120 = (_WORD *)(v107 + v118);
                    uint64_t v838 = *(void *)(v106 + v118);
                    uint64_t result = (uint64_t)PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>::unpremultiply((unsigned __int16 *)&v838);
                    LOWORD(v121) = v838;
                    *(float *)&unint64_t v121 = (double)v121 * 0.0000152590219;
                    double v122 = (float)(*(float *)&v121 * 65535.0) + 0.5 + 0.0000001;
                    int v123 = vcvtmd_s64_f64(v122);
                    if (v123 >= 0xFFFF) {
                      int v123 = 0xFFFF;
                    }
                    _WORD *v120 = v123 & ~(unsigned __int16)(v123 >> 31);
                    LOWORD(v12OZChannelFontBase::~OZChannelFontBase(this - 2) = WORD1(v838);
                    float v124 = (double)*(unint64_t *)&v122 * 0.0000152590219;
                    double v125 = (float)(v124 * 65535.0) + 0.5 + 0.0000001;
                    int v126 = vcvtmd_s64_f64(v125);
                    if (v126 >= 0xFFFF) {
                      int v126 = 0xFFFF;
                    }
                    v120[1] = v126 & ~(unsigned __int16)(v126 >> 31);
                    LOWORD(v125) = WORD2(v838);
                    float v127 = (double)*(unint64_t *)&v125 * 0.0000152590219;
                    double v128 = (float)(v127 * 65535.0) + 0.5 + 0.0000001;
                    int v129 = vcvtmd_s64_f64(v128);
                    if (v129 >= 0xFFFF) {
                      int v129 = 0xFFFF;
                    }
                    v120[2] = v129 & ~(unsigned __int16)(v129 >> 31);
                    LOWORD(v128) = HIWORD(v838);
                    float v130 = (double)*(unint64_t *)&v128 * 0.0000152590219;
                    int v131 = vcvtmd_s64_f64((float)(v130 * 65535.0) + 0.5 + 0.0000001);
                    if (v131 >= 0xFFFF) {
                      int v131 = 0xFFFF;
                    }
                    v120[3] = v131 & ~(unsigned __int16)(v131 >> 31);
                    v118 += 8;
                    --v119;
                  }
                  while (v119);
                }
                v106 += v835;
                v107 += v116;
                ++v117;
              }
              while (v117 != v113);
            }
          }
          else if (v113)
          {
            for (int i18 = 0; i18 != v113; ++i18)
            {
              if (v112)
              {
                uint64_t v688 = 0;
                int v689 = v112;
                do
                {
                  v690 = (_WORD *)(v106 + v688);
                  LOWORD(v115) = *(_WORD *)(v106 + v688);
                  float v691 = (double)*(unint64_t *)&v115 * 0.0000152590219;
                  double v692 = (float)(v691 * 65535.0) + 0.5 + 0.0000001;
                  int v693 = vcvtmd_s64_f64(v692);
                  v694 = (_WORD *)(v107 + v688);
                  if (v693 >= 0xFFFF) {
                    int v693 = 0xFFFF;
                  }
                  int v695 = v693 & ~(v693 >> 31);
                  _WORD *v694 = v695;
                  LOWORD(v69OZChannelFontBase::~OZChannelFontBase(this - 2) = v690[1];
                  float v696 = (double)*(unint64_t *)&v692 * 0.0000152590219;
                  double v697 = (float)(v696 * 65535.0) + 0.5 + 0.0000001;
                  int v698 = vcvtmd_s64_f64(v697);
                  if (v698 >= 0xFFFF) {
                    int v698 = 0xFFFF;
                  }
                  int v699 = v698 & ~(v698 >> 31);
                  v694[1] = v699;
                  LOWORD(v697) = v690[2];
                  float v700 = (double)*(unint64_t *)&v697 * 0.0000152590219;
                  double v701 = (float)(v700 * 65535.0) + 0.5 + 0.0000001;
                  int v702 = vcvtmd_s64_f64(v701);
                  if (v702 >= 0xFFFF) {
                    int v702 = 0xFFFF;
                  }
                  int v703 = v702 & ~(v702 >> 31);
                  v694[2] = v703;
                  LOWORD(v701) = v690[3];
                  float v704 = (double)*(unint64_t *)&v701 * 0.0000152590219;
                  double v115 = (float)(v704 * 65535.0) + 0.5 + 0.0000001;
                  int v705 = vcvtmd_s64_f64(v115);
                  if (v705 >= 0xFFFF) {
                    int v705 = 0xFFFF;
                  }
                  int v706 = v705 & ~(v705 >> 31);
                  v694[3] = v706;
                  _WORD *v694 = v706 * v695 / 0xFFFFu;
                  v694[1] = v706 * v699 / 0xFFFFu;
                  v694[2] = v706 * v703 / 0xFFFFu;
                  v688 += 8;
                  --v689;
                }
                while (v689);
              }
              v106 += v114;
              v107 += result;
            }
          }
        }
        else if (v108)
        {
          if (v113)
          {
            for (int i19 = 0; i19 != v113; ++i19)
            {
              if (v112)
              {
                uint64_t v329 = 0;
                int v330 = v112;
                do
                {
                  uint64_t v331 = v106 + v329;
                  LOWORD(v115) = *(_WORD *)(v106 + v329);
                  float v332 = (double)*(unint64_t *)&v115 * 0.0000152590219;
                  double v333 = (float)(v332 * 65535.0) + 0.5 + 0.0000001;
                  uint64_t v334 = (_WORD *)(v107 + v329);
                  int v335 = vcvtmd_s64_f64(v333);
                  if (v335 >= 0xFFFF) {
                    int v335 = 0xFFFF;
                  }
                  *uint64_t v334 = v335 & ~(unsigned __int16)(v335 >> 31);
                  LOWORD(v333) = *(_WORD *)(v331 + 2);
                  float v336 = (double)*(unint64_t *)&v333 * 0.0000152590219;
                  double v337 = (float)(v336 * 65535.0) + 0.5 + 0.0000001;
                  int v338 = vcvtmd_s64_f64(v337);
                  if (v338 >= 0xFFFF) {
                    int v338 = 0xFFFF;
                  }
                  v334[1] = v338 & ~(unsigned __int16)(v338 >> 31);
                  LOWORD(v337) = *(_WORD *)(v331 + 4);
                  float v339 = (double)*(unint64_t *)&v337 * 0.0000152590219;
                  double v115 = (float)(v339 * 65535.0) + 0.5 + 0.0000001;
                  int v340 = vcvtmd_s64_f64(v115);
                  if (v340 >= 0xFFFF) {
                    int v340 = 0xFFFF;
                  }
                  v334[2] = v340 & ~(unsigned __int16)(v340 >> 31);
                  v329 += 8;
                  --v330;
                }
                while (v330);
              }
              v106 += v114;
              v107 += result;
            }
          }
        }
        else if (v113)
        {
          int v579 = 0;
          float64x2_t v580 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
          float32x2_t v581 = (float32x2_t)vdup_n_s32(0x477FFF00u);
          __asm { FMOV            V2.2D, #0.5 }
          float64x2_t v583 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
          do
          {
            if (v112)
            {
              uint64_t v584 = 0;
              int v585 = v112;
              do
              {
                v586 = (_WORD *)(v107 + v584);
                int v587 = *(unsigned __int16 *)(v106 + v584 + 6);
                v588.f64[0] = (double)(unsigned __int16)(v587 * *(unsigned __int16 *)(v106 + v584) / 0xFFFF);
                v588.f64[1] = (double)(unsigned __int16)(v587
                                                       * *(unsigned __int16 *)(v106 + v584 + 2)
                                                       / 0xFFFF);
                *(int32x2_t *)&v588.f64[0] = vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_f64(vmulq_f64(v588, v580)), v581)), _Q2), v583)))), (int32x2_t)0xFFFF0000FFFFLL), 0);
                __int16 v589 = LOWORD(v588.f64[0]);
                *(float *)v588.f64 = (double)(unsigned __int16)(v587
                                                              * *(unsigned __int16 *)(v106 + v584 + 4)
                                                              / 0xFFFF)
                                   * 0.0000152590219;
                _WORD *v586 = v589;
                int v590 = vcvtmd_s64_f64((float)(*(float *)v588.f64 * 65535.0) + 0.5 + 0.0000001);
                v586[1] = WORD2(v588.f64[0]);
                if (v590 >= 0xFFFF) {
                  int v590 = 0xFFFF;
                }
                v586[2] = v590 & ~(unsigned __int16)(v590 >> 31);
                v584 += 8;
                --v585;
              }
              while (v585);
            }
            v106 += v114;
            v107 += result;
            ++v579;
          }
          while (v579 != v113);
        }
      }
      else if (v111)
      {
        if (v113)
        {
          for (int i20 = 0; i20 != v113; ++i20)
          {
            if (v112)
            {
              uint64_t v241 = 0;
              int v242 = v112;
              do
              {
                uint64_t v243 = v106 + v241;
                LOWORD(v115) = *(_WORD *)(v106 + v241);
                float v244 = (double)*(unint64_t *)&v115 * 0.0000152590219;
                double v245 = (float)(v244 * 65535.0) + 0.5 + 0.0000001;
                int v246 = vcvtmd_s64_f64(v245);
                unint64_t v247 = (_WORD *)(v107 + v241);
                if (v246 >= 0xFFFF) {
                  int v246 = 0xFFFF;
                }
                *unint64_t v247 = v246 & ~(unsigned __int16)(v246 >> 31);
                LOWORD(v245) = *(_WORD *)(v243 + 2);
                float v248 = (double)*(unint64_t *)&v245 * 0.0000152590219;
                double v249 = (float)(v248 * 65535.0) + 0.5 + 0.0000001;
                int v250 = vcvtmd_s64_f64(v249);
                if (v250 >= 0xFFFF) {
                  int v250 = 0xFFFF;
                }
                v247[1] = v250 & ~(unsigned __int16)(v250 >> 31);
                LOWORD(v249) = *(_WORD *)(v243 + 4);
                float v251 = (double)*(unint64_t *)&v249 * 0.0000152590219;
                double v115 = (float)(v251 * 65535.0) + 0.5 + 0.0000001;
                int v252 = vcvtmd_s64_f64(v115);
                if (v252 >= 0xFFFF) {
                  int v252 = 0xFFFF;
                }
                v247[2] = v252 & ~(unsigned __int16)(v252 >> 31);
                v247[3] = -1;
                v241 += 8;
                --v242;
              }
              while (v242);
            }
            v106 += v114;
            v107 += result;
          }
        }
      }
      else if (v113)
      {
        for (int i21 = 0; i21 != v113; ++i21)
        {
          if (v112)
          {
            uint64_t v401 = 0;
            int v402 = v112;
            do
            {
              uint64_t v403 = v106 + v401;
              LOWORD(v115) = *(_WORD *)(v106 + v401);
              float v404 = (double)*(unint64_t *)&v115 * 0.0000152590219;
              double v405 = (float)(v404 * 65535.0) + 0.5 + 0.0000001;
              v406 = (_WORD *)(v107 + v401);
              int v407 = vcvtmd_s64_f64(v405);
              if (v407 >= 0xFFFF) {
                int v407 = 0xFFFF;
              }
              _WORD *v406 = v407 & ~(unsigned __int16)(v407 >> 31);
              LOWORD(v405) = *(_WORD *)(v403 + 2);
              float v408 = (double)*(unint64_t *)&v405 * 0.0000152590219;
              double v409 = (float)(v408 * 65535.0) + 0.5 + 0.0000001;
              int v410 = vcvtmd_s64_f64(v409);
              if (v410 >= 0xFFFF) {
                int v410 = 0xFFFF;
              }
              v406[1] = v410 & ~(unsigned __int16)(v410 >> 31);
              LOWORD(v409) = *(_WORD *)(v403 + 4);
              float v411 = (double)*(unint64_t *)&v409 * 0.0000152590219;
              double v115 = (float)(v411 * 65535.0) + 0.5 + 0.0000001;
              int v412 = vcvtmd_s64_f64(v115);
              if (v412 >= 0xFFFF) {
                int v412 = 0xFFFF;
              }
              v406[2] = v412 & ~(unsigned __int16)(v412 >> 31);
              v401 += 8;
              --v402;
            }
            while (v402);
          }
          v106 += v114;
          v107 += result;
        }
      }
      break;
    case 11:
      uint64_t v132 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
      uint64_t v133 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
      int v134 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
      int v135 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 48))(a2);
      int v136 = PCPixelFormat::hasAlpha(0xEu);
      int v137 = PCPixelFormat::hasAlpha(0xBu);
      int v138 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      int v139 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      uint64_t v140 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
      uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
      uint64_t v141 = result;
      if (v136)
      {
        if (v137)
        {
          if (v134 == v135)
          {
            if (v139)
            {
              for (int i22 = 0; i22 != v139; ++i22)
              {
                if (v138)
                {
                  uint64_t v499 = 0;
                  do
                  {
                    uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v132 + 4 * v499));
                    *(_WORD *)(v133 + 2 * v499++) = result;
                  }
                  while (v138 != v499);
                }
                v132 += v140;
                v133 += v141;
              }
            }
          }
          else if (v134)
          {
            if (v139)
            {
              for (int i23 = 0; i23 != v139; ++i23)
              {
                if (v138)
                {
                  uint64_t v143 = 0;
                  do
                  {
                    uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v132 + 4 * v143));
                    *(_WORD *)(v133 + 2 * v143++) = result;
                  }
                  while (v138 != v143);
                }
                v132 += v140;
                v133 += v141;
              }
            }
          }
          else if (v139)
          {
            for (int i24 = 0; i24 != v139; ++i24)
            {
              if (v138)
              {
                uint64_t v708 = 0;
                do
                {
                  uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v132 + 4 * v708));
                  *(_WORD *)(v133 + 2 * v708++) = result;
                }
                while (v138 != v708);
              }
              v132 += v140;
              v133 += v141;
            }
          }
        }
        else if (v134)
        {
          if (v139)
          {
            for (int i25 = 0; i25 != v139; ++i25)
            {
              if (v138)
              {
                uint64_t v342 = 0;
                do
                {
                  uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v132 + 4 * v342));
                  *(_WORD *)(v133 + 2 * v342++) = result;
                }
                while (v138 != v342);
              }
              v132 += v140;
              v133 += v141;
            }
          }
        }
        else if (v139)
        {
          for (int i26 = 0; i26 != v139; ++i26)
          {
            if (v138)
            {
              uint64_t v592 = 0;
              do
              {
                uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v132 + 4 * v592));
                *(_WORD *)(v133 + 2 * v592++) = result;
              }
              while (v138 != v592);
            }
            v132 += v140;
            v133 += v141;
          }
        }
      }
      else if (v137)
      {
        if (v139)
        {
          for (int i27 = 0; i27 != v139; ++i27)
          {
            if (v138)
            {
              uint64_t v254 = 0;
              do
              {
                uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v132 + 4 * v254));
                *(_WORD *)(v133 + 2 * v254++) = result;
              }
              while (v138 != v254);
            }
            v132 += v140;
            v133 += v141;
          }
        }
      }
      else if (v139)
      {
        for (int i28 = 0; i28 != v139; ++i28)
        {
          if (v138)
          {
            uint64_t v414 = 0;
            do
            {
              uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*(float *)(v132 + 4 * v414));
              *(_WORD *)(v133 + 2 * v414++) = result;
            }
            while (v138 != v414);
          }
          v132 += v140;
          v133 += v141;
        }
      }
      break;
    case 13:
      uint64_t v144 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
      uint64_t v145 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
      int v146 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
      int v147 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 48))(a2);
      int v148 = PCPixelFormat::hasAlpha(0x10u);
      int v149 = PCPixelFormat::hasAlpha(0xDu);
      int v150 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      int v151 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      uint64_t v836 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
      uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
      uint64_t v152 = result;
      if (v148)
      {
        if (v149)
        {
          if (v146 == v147)
          {
            if (v151)
            {
              for (int i29 = 0; i29 != v151; ++i29)
              {
                int v501 = v150;
                v502 = (_WORD *)v145;
                for (int i30 = (float *)v144; v501; --v501)
                {
                  _WORD *v502 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*i30);
                  v502[1] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(i30[1]);
                  v502[2] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(i30[2]);
                  uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(i30[3]);
                  v502[3] = result;
                  i30 += 4;
                  v502 += 4;
                }
                v144 += v836;
                v145 += v152;
              }
            }
          }
          else if (v146)
          {
            if (v151)
            {
              for (int i31 = 0; i31 != v151; ++i31)
              {
                int v154 = v150;
                int v155 = (_WORD *)v145;
                for (int i32 = (float *)v144; v154; --v154)
                {
                  float v157 = i32[3];
                  if (v157 == 1.0)
                  {
                    float v158 = *i32;
                    float v159 = i32[1];
                    float v160 = i32[2];
                  }
                  else
                  {
                    float v158 = 0.0;
                    float v159 = 0.0;
                    float v160 = 0.0;
                    if (v157 != 0.0)
                    {
                      float v158 = *i32 * (float)(1.0 / v157);
                      float v159 = i32[1] * (float)(1.0 / v157);
                      float v160 = i32[2] * (float)(1.0 / v157);
                    }
                  }
                  *int v155 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(v158);
                  v155[1] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(v159);
                  v155[2] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(v160);
                  uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(v157);
                  v155[3] = result;
                  i32 += 4;
                  v155 += 4;
                }
                v144 += v836;
                v145 += v152;
              }
            }
          }
          else if (v151)
          {
            for (int i33 = 0; i33 != v151; ++i33)
            {
              int v710 = v150;
              v711 = (unsigned __int16 *)v145;
              for (i34 = (float *)v144; v710; --v710)
              {
                unsigned __int16 *v711 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*i34);
                v711[1] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(i34[1]);
                v711[2] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(i34[2]);
                v711[3] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(i34[3]);
                uint64_t result = PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>::premultiply(v711);
                i34 += 4;
                v711 += 4;
              }
              v144 += v836;
              v145 += v152;
            }
          }
        }
        else if (v146)
        {
          if (v151)
          {
            for (int i35 = 0; i35 != v151; ++i35)
            {
              int v344 = v150;
              unint64_t v345 = (_WORD *)v145;
              for (i36 = (float *)v144; v344; --v344)
              {
                *unint64_t v345 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*i36);
                v345[1] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(i36[1]);
                uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(i36[2]);
                v345[2] = result;
                i36 += 4;
                v345 += 4;
              }
              v144 += v836;
              v145 += v152;
            }
          }
        }
        else if (v151)
        {
          for (int i37 = 0; i37 != v151; ++i37)
          {
            int v594 = v150;
            v595 = (_WORD *)v145;
            for (i38 = (float *)v144; v594; --v594)
            {
              float v597 = i38[3];
              float v598 = i38[1] * v597;
              float v599 = i38[2] * v597;
              _WORD *v595 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*i38 * v597);
              v595[1] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(v598);
              uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(v599);
              v595[2] = result;
              i38 += 4;
              v595 += 4;
            }
            v144 += v836;
            v145 += v152;
          }
        }
      }
      else if (v149)
      {
        if (v151)
        {
          for (int i39 = 0; i39 != v151; ++i39)
          {
            int v256 = v150;
            uint64_t v257 = (_WORD *)v145;
            for (i40 = (float *)v144; v256; --v256)
            {
              *uint64_t v257 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*i40);
              v257[1] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(i40[1]);
              v257[2] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(i40[2]);
              uint64_t result = 15360;
              v257[3] = 15360;
              i40 += 4;
              v257 += 4;
            }
            v144 += v836;
            v145 += v152;
          }
        }
      }
      else if (v151)
      {
        for (int i41 = 0; i41 != v151; ++i41)
        {
          int v416 = v150;
          v417 = (_WORD *)v145;
          for (i42 = (float *)v144; v416; --v416)
          {
            _WORD *v417 = ProCore::Private::ChannelTypeTraits<half>::denormalizef(*i42);
            v417[1] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(i42[1]);
            uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(i42[2]);
            v417[2] = result;
            i42 += 4;
            v417 += 4;
          }
          v144 += v836;
          v145 += v152;
        }
      }
      break;
    case 16:
      uint64_t v161 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
      uint64_t v162 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
      int v163 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
      int v164 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 48))(a2);
      int v165 = PCPixelFormat::hasAlpha(0x10u);
      int v166 = PCPixelFormat::hasAlpha(0x10u);
      int v167 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
      int v168 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
      uint64_t v169 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
      uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
      if (v165)
      {
        if (v166)
        {
          if (v163 == v164)
          {
            if (v168)
            {
              for (int i43 = 0; i43 != v168; ++i43)
              {
                if (v167)
                {
                  uint64_t v505 = 0;
                  int v506 = v167;
                  do
                  {
                    v507 = (_DWORD *)(v162 + v505);
                    _DWORD *v507 = *(_DWORD *)(v161 + v505);
                    v507[1] = *(_DWORD *)(v161 + v505 + 4);
                    v507[2] = *(_DWORD *)(v161 + v505 + 8);
                    v507[3] = *(_DWORD *)(v161 + v505 + 12);
                    v505 += 16;
                    --v506;
                  }
                  while (v506);
                }
                v161 += v169;
                v162 += result;
              }
            }
          }
          else if (v163)
          {
            if (v168)
            {
              for (int i44 = 0; i44 != v168; ++i44)
              {
                if (v167)
                {
                  uint64_t v171 = 0;
                  int v172 = v167;
                  do
                  {
                    float32x2_t v173 = *(float32x2_t *)(v161 + v171);
                    float v175 = *(float *)(v161 + v171 + 8);
                    float v174 = *(float *)(v161 + v171 + 12);
                    if (v174 != 1.0)
                    {
                      if (v174 == 0.0)
                      {
                        float32x2_t v173 = 0;
                        float v175 = 0.0;
                      }
                      else
                      {
                        float32x2_t v173 = vmul_n_f32(v173, 1.0 / v174);
                        float v175 = v175 * (float)(1.0 / v174);
                      }
                    }
                    v176 = (float32x2_t *)(v162 + v171);
                    float32x2_t *v176 = v173;
                    v176[1].f32[0] = v175;
                    v176[1].f32[1] = v174;
                    v171 += 16;
                    --v172;
                  }
                  while (v172);
                }
                v161 += v169;
                v162 += result;
              }
            }
          }
          else if (v168)
          {
            for (int i45 = 0; i45 != v168; ++i45)
            {
              if (v167)
              {
                uint64_t v714 = 0;
                int v715 = v167;
                do
                {
                  v716 = (float *)(v162 + v714);
                  float v717 = *(float *)(v161 + v714);
                  float *v716 = v717;
                  float v718 = *(float *)(v161 + v714 + 4);
                  v716[1] = v718;
                  float v719 = *(float *)(v161 + v714 + 8);
                  v716[2] = v719;
                  float v720 = *(float *)(v161 + v714 + 12);
                  float *v716 = v717 * v720;
                  v716[1] = v718 * v720;
                  v716[2] = v719 * v720;
                  v716[3] = v720;
                  v714 += 16;
                  --v715;
                }
                while (v715);
              }
              v161 += v169;
              v162 += result;
            }
          }
        }
        else if (v163)
        {
          if (v168)
          {
            for (int i46 = 0; i46 != v168; ++i46)
            {
              if (v167)
              {
                uint64_t v348 = 0;
                int v349 = v167;
                do
                {
                  uint64_t v350 = (_DWORD *)(v162 + v348);
                  *uint64_t v350 = *(_DWORD *)(v161 + v348);
                  v350[1] = *(_DWORD *)(v161 + v348 + 4);
                  v350[2] = *(_DWORD *)(v161 + v348 + 8);
                  v348 += 16;
                  --v349;
                }
                while (v349);
              }
              v161 += v169;
              v162 += result;
            }
          }
        }
        else if (v168)
        {
          for (int i47 = 0; i47 != v168; ++i47)
          {
            if (v167)
            {
              uint64_t v601 = 0;
              int v602 = v167;
              do
              {
                v603 = (float32x2_t *)(v162 + v601);
                float v604 = *(float *)(v161 + v601 + 12);
                float32_t v605 = *(float *)(v161 + v601 + 8) * v604;
                float32x2_t *v603 = vmul_n_f32(*(float32x2_t *)(v161 + v601), v604);
                v603[1].f32[0] = v605;
                v601 += 16;
                --v602;
              }
              while (v602);
            }
            v161 += v169;
            v162 += result;
          }
        }
      }
      else if (v166)
      {
        if (v168)
        {
          for (int i48 = 0; i48 != v168; ++i48)
          {
            if (v167)
            {
              uint64_t v260 = 0;
              int v261 = v167;
              do
              {
                v262 = (_DWORD *)(v162 + v260);
                _DWORD *v262 = *(_DWORD *)(v161 + v260);
                v262[1] = *(_DWORD *)(v161 + v260 + 4);
                v262[2] = *(_DWORD *)(v161 + v260 + 8);
                v262[3] = 1065353216;
                v260 += 16;
                --v261;
              }
              while (v261);
            }
            v161 += v169;
            v162 += result;
          }
        }
      }
      else if (v168)
      {
        for (int i49 = 0; i49 != v168; ++i49)
        {
          if (v167)
          {
            uint64_t v420 = 0;
            int v421 = v167;
            do
            {
              int v422 = (_DWORD *)(v162 + v420);
              *int v422 = *(_DWORD *)(v161 + v420);
              v422[1] = *(_DWORD *)(v161 + v420 + 4);
              v422[2] = *(_DWORD *)(v161 + v420 + 8);
              v420 += 16;
              --v421;
            }
            while (v421);
          }
          v161 += v169;
          v162 += result;
        }
      }
      break;
    case 17:
      if ((*(unsigned int (**)(PCBitmap *))(*(void *)a2 + 48))(a2))
      {
      }
      else
      {
        uint64_t v263 = (*(uint64_t (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
        uint64_t v264 = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 16))(*((void *)a2 + 8));
        int v265 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this);
        int v266 = (*(uint64_t (**)(PCBitmap *))(*(void *)a2 + 48))(a2);
        int v267 = PCPixelFormat::hasAlpha(0x10u);
        int v268 = PCPixelFormat::hasAlpha(0x11u);
        int v269 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
        int v270 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
        uint64_t v271 = (*(unsigned int (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
        uint64_t result = (*(uint64_t (**)(void))(**((void **)a2 + 8) + 64))(*((void *)a2 + 8));
        if (v267)
        {
          if (v268)
          {
            if (v265 == v266)
            {
              if (v270)
              {
                for (int i50 = 0; i50 != v270; ++i50)
                {
                  if (v269)
                  {
                    uint64_t v738 = 0;
                    int v739 = v269;
                    do
                    {
                      v740 = (_DWORD *)(v264 + v738);
                      v740[1] = *(_DWORD *)(v263 + v738);
                      v740[2] = *(_DWORD *)(v263 + v738 + 4);
                      v740[3] = *(_DWORD *)(v263 + v738 + 8);
                      _DWORD *v740 = *(_DWORD *)(v263 + v738 + 12);
                      v738 += 16;
                      --v739;
                    }
                    while (v739);
                  }
                  v263 += v271;
                  v264 += result;
                }
              }
            }
            else if (v265)
            {
              if (v270)
              {
                for (int i51 = 0; i51 != v270; ++i51)
                {
                  if (v269)
                  {
                    uint64_t v273 = 0;
                    int v274 = v269;
                    do
                    {
                      float32x2_t v275 = *(float32x2_t *)(v263 + v273);
                      float v277 = *(float *)(v263 + v273 + 8);
                      float v276 = *(float *)(v263 + v273 + 12);
                      if (v276 != 1.0)
                      {
                        if (v276 == 0.0)
                        {
                          float32x2_t v275 = 0;
                          float v277 = 0.0;
                        }
                        else
                        {
                          float32x2_t v275 = vmul_n_f32(v275, 1.0 / v276);
                          float v277 = v277 * (float)(1.0 / v276);
                        }
                      }
                      uint64_t v278 = v264 + v273;
                      *(float32x2_t *)(v278 + 4) = v275;
                      *(float *)(v278 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = v277;
                      *(float *)uint64_t v278 = v276;
                      v273 += 16;
                      --v274;
                    }
                    while (v274);
                  }
                  v263 += v271;
                  v264 += result;
                }
              }
            }
            else if (v270)
            {
              for (int i52 = 0; i52 != v270; ++i52)
              {
                if (v269)
                {
                  uint64_t v816 = 0;
                  int v817 = v269;
                  do
                  {
                    v818 = (float *)(v264 + v816);
                    float v819 = *(float *)(v263 + v816);
                    v818[1] = v819;
                    float v820 = *(float *)(v263 + v816 + 4);
                    v818[2] = v820;
                    float v821 = *(float *)(v263 + v816 + 8);
                    v818[3] = v821;
                    float v822 = *(float *)(v263 + v816 + 12);
                    float *v818 = v822;
                    v818[1] = v819 * v822;
                    v818[2] = v820 * v822;
                    v818[3] = v821 * v822;
                    v816 += 16;
                    --v817;
                  }
                  while (v817);
                }
                v263 += v271;
                v264 += result;
              }
            }
          }
          else if (v265)
          {
            if (v270)
            {
              for (int i53 = 0; i53 != v270; ++i53)
              {
                if (v269)
                {
                  uint64_t v522 = 0;
                  int v523 = v269;
                  do
                  {
                    v524 = (_DWORD *)(v264 + v522);
                    v524[1] = *(_DWORD *)(v263 + v522);
                    v524[2] = *(_DWORD *)(v263 + v522 + 4);
                    v524[3] = *(_DWORD *)(v263 + v522 + 8);
                    v522 += 16;
                    --v523;
                  }
                  while (v523);
                }
                v263 += v271;
                v264 += result;
              }
            }
          }
          else if (v270)
          {
            for (int i54 = 0; i54 != v270; ++i54)
            {
              if (v269)
              {
                uint64_t v772 = 0;
                int v773 = v269;
                do
                {
                  float v774 = *(float *)(v263 + v772 + 12);
                  float v775 = *(float *)(v263 + v772 + 8) * v774;
                  uint64_t v776 = v264 + v772;
                  *(float32x2_t *)(v776 + 4) = vmul_n_f32(*(float32x2_t *)(v263 + v772), v774);
                  *(float *)(v776 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = v775;
                  v772 += 16;
                  --v773;
                }
                while (v773);
              }
              v263 += v271;
              v264 += result;
            }
          }
        }
        else if (v268)
        {
          if (v270)
          {
            for (int i55 = 0; i55 != v270; ++i55)
            {
              if (v269)
              {
                uint64_t v424 = 0;
                int v425 = v269;
                do
                {
                  v426 = (_DWORD *)(v264 + v424);
                  v426[1] = *(_DWORD *)(v263 + v424);
                  v426[2] = *(_DWORD *)(v263 + v424 + 4);
                  v426[3] = *(_DWORD *)(v263 + v424 + 8);
                  _DWORD *v426 = 1065353216;
                  v424 += 16;
                  --v425;
                }
                while (v425);
              }
              v263 += v271;
              v264 += result;
            }
          }
        }
        else if (v270)
        {
          for (int i56 = 0; i56 != v270; ++i56)
          {
            if (v269)
            {
              uint64_t v620 = 0;
              int v621 = v269;
              do
              {
                v622 = (_DWORD *)(v264 + v620);
                v622[1] = *(_DWORD *)(v263 + v620);
                v622[2] = *(_DWORD *)(v263 + v620 + 4);
                v622[3] = *(_DWORD *)(v263 + v620 + 8);
                v620 += 16;
                --v621;
              }
              while (v621);
            }
            v263 += v271;
            v264 += result;
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

const vImage_Buffer *anonymous namespace'::swizzleFloatCopy(_anonymous_namespace_ *this, PCBitmap *a2, vImage_Buffer *a3)
{
  int v4 = this;
}

const vImage_Buffer *anonymous namespace'::swizzle8BitCopy(_anonymous_namespace_ *this, PCBitmap *a2, vImage_Buffer *a3)
{
  int v4 = this;
}

uint64_t anonymous namespace'::getVImageBuffer(_anonymous_namespace_ *this, PCBitmap *a2, vImage_Buffer *a3)
{
  *(void *)a2 = (*(uint64_t (**)(void, PCBitmap *, vImage_Buffer *))(**((void **)this + 8) + 16))(*((void *)this + 8), a2, a3);
  *((void *)a2 + 1) = (*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)this + 24))(this);
  *((void *)a2 + OZChannelFontBase::~OZChannelFontBase(this - 2) = (*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)this + 16))(this);
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 8) + 64))(*((void *)this + 8));
  *((void *)a2 + 3) = result;
  return result;
}

uint64_t anonymous namespace'::getSwizzleOrder(_anonymous_namespace_ *this, const PCBitmap *a2)
{
  int v2 = (*(uint64_t (**)(void, const PCBitmap *))(**((void **)this + 8) + 48))(*((void *)this + 8), a2);
  uint64_t result = 0;
  if (v2 > 5)
  {
    if (v2 == 6) {
      return 3;
    }
    if (v2 != 16) {
      return result;
    }
    return 1;
  }
  if (v2 == 4) {
    return 2;
  }
  if (v2 == 5) {
    return 1;
  }
  return result;
}

const vImage_Buffer *anonymous namespace'::swizzleFloatPixels(const vImage_Buffer *result, unsigned int a2, vImage_Buffer *dest, int a4)
{
  if (a2 != a4 || result->data != dest->data)
  {
    if (a2 <= 3) {
      unsigned int v4 = 0x2030001u >> (8 * a2);
    }
    else {
      LOBYTE(v4) = 0;
    }
    if (a2 <= 3) {
      unsigned int v5 = 0x1020102u >> (8 * a2);
    }
    else {
      LOBYTE(v5) = 1;
    }
    if (a2 <= 3) {
      char v6 = 3 - a2;
    }
    else {
      char v6 = 2;
    }
    if (a2 <= 3) {
      unsigned int v7 = 0x3000300u >> (8 * a2);
    }
    else {
      LOBYTE(v7) = 3;
    }
    uint8_t v8 = v4;
    uint8_t v9 = v5;
    uint8_t v10 = v6;
    switch(a4)
    {
      case 0:
        uint8_t v8 = v7;
        uint8_t v9 = v4;
        uint8_t v10 = v5;
        LOBYTE(v7) = v6;
        goto LABEL_19;
      case 1:
        goto LABEL_19;
      case 2:
        uint8_t v8 = v7;
        uint8_t v9 = v6;
        uint8_t v10 = v5;
        LOBYTE(v7) = v4;
        goto LABEL_19;
      case 3:
        uint8_t v8 = v6;
        uint8_t v9 = v5;
        uint8_t v10 = v4;
LABEL_19:
        permuteMap[0] = v8;
        permuteMap[1] = v9;
        permuteMap[2] = v10;
        permuteMap[3] = v7;
        break;
      default:
        return (const vImage_Buffer *)vImagePermuteChannels_ARGBFFFF(result, dest, permuteMap, 0);
    }
    return (const vImage_Buffer *)vImagePermuteChannels_ARGBFFFF(result, dest, permuteMap, 0);
  }
  return result;
}

const vImage_Buffer *anonymous namespace'::swizzle8BitPixels(const vImage_Buffer *result, unsigned int a2, vImage_Buffer *dest, int a4)
{
  if (a2 != a4 || result->data != dest->data)
  {
    if (a2 <= 3) {
      unsigned int v4 = 0x2030001u >> (8 * a2);
    }
    else {
      LOBYTE(v4) = 0;
    }
    if (a2 <= 3) {
      unsigned int v5 = 0x1020102u >> (8 * a2);
    }
    else {
      LOBYTE(v5) = 1;
    }
    if (a2 <= 3) {
      char v6 = 3 - a2;
    }
    else {
      char v6 = 2;
    }
    if (a2 <= 3) {
      unsigned int v7 = 0x3000300u >> (8 * a2);
    }
    else {
      LOBYTE(v7) = 3;
    }
    uint8_t v8 = v4;
    uint8_t v9 = v5;
    uint8_t v10 = v6;
    switch(a4)
    {
      case 0:
        uint8_t v8 = v7;
        uint8_t v9 = v4;
        uint8_t v10 = v5;
        LOBYTE(v7) = v6;
        goto LABEL_19;
      case 1:
        goto LABEL_19;
      case 2:
        uint8_t v8 = v7;
        uint8_t v9 = v6;
        uint8_t v10 = v5;
        LOBYTE(v7) = v4;
        goto LABEL_19;
      case 3:
        uint8_t v8 = v6;
        uint8_t v9 = v5;
        uint8_t v10 = v4;
LABEL_19:
        permuteMap[0] = v8;
        permuteMap[1] = v9;
        permuteMap[2] = v10;
        permuteMap[3] = v7;
        break;
      default:
        return (const vImage_Buffer *)vImagePermuteChannels_ARGB8888(result, dest, permuteMap, 0);
    }
    return (const vImage_Buffer *)vImagePermuteChannels_ARGB8888(result, dest, permuteMap, 0);
  }
  return result;
}

unsigned __int16 *PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>::unpremultiply(unsigned __int16 *result)
{
  unsigned int v1 = result[3];
  if (v1 != 0xFFFF)
  {
    if (result[3])
    {
      float v2 = (double)v1 * 0.0000152590219;
      float v3 = 1.0 / v2;
      v4.i64[0] = *result;
      v4.i64[1] = result[1];
      __asm { FMOV            V3.2D, #0.5 }
      unint64_t v10 = (unint64_t)vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vmul_n_f32(vcvt_f32_f64(vmulq_f64(vcvtq_f64_u64(v4), (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL))), v3), (float32x2_t)vdup_n_s32(0x477FFF00u))), _Q3), (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL))))), (int32x2_t)0xFFFF0000FFFFLL), 0);
      *uint64_t result = v10;
      LOWORD(v10) = result[2];
      float v11 = (double)v10 * 0.0000152590219;
      int v12 = vcvtmd_s64_f64((float)((float)(v3 * v11) * 65535.0) + 0.5 + 0.0000001);
      result[1] = WORD2(v10);
      if (v12 >= 0xFFFF) {
        int v13 = 0xFFFF;
      }
      else {
        int v13 = v12;
      }
      result[2] = v13 & ~(unsigned __int16)(v13 >> 31);
    }
    else
    {
      *(_DWORD *)uint64_t result = 0;
      result[2] = 0;
    }
  }
  return result;
}

uint64_t PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>::unpremultiply(unsigned __int16 *a1)
{
  float v2 = half::_toFloat[a1[1]];
  uint64_t result = 15360;
  if (v2 != 1.0)
  {
    float v4 = half::_toFloat[a1[1]];
    if (v4 == 0.0) {
      uint64_t result = 0;
    }
    else {
      uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef(half::_toFloat[*a1] / v4);
    }
    *a1 = result;
  }
  return result;
}

uint64_t PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>::premultiply(unsigned __int16 *a1)
{
  float v2 = half::_toFloat[*a1] * half::_toFloat[a1[1]];
  if (v2 == 0.0)
  {
    uint64_t result = 0;
  }
  else
  {
    float v4 = half::_toFloat[*a1] * half::_toFloat[a1[1]];
    if (half::_eLut[LODWORD(v2) >> 23]) {
      uint64_t result = half::_eLut[LODWORD(v2) >> 23] + (((LODWORD(v4) & 0x7FF000u) + 4096) >> 13);
    }
    else {
      uint64_t result = half::convert((half *)LODWORD(v2));
    }
  }
  *a1 = result;
  return result;
}

uint64_t ProCore::Private::ChannelTypeTraits<half>::denormalizef(float a1)
{
  if (a1 == 0.0) {
    return 0;
  }
  if (half::_eLut[LODWORD(a1) >> 23]) {
    return half::_eLut[LODWORD(a1) >> 23] + (((LODWORD(a1) & 0x7FF000u) + 4096) >> 13);
  }
  return half::convert((half *)LODWORD(a1));
}

unsigned __int16 *PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>::unpremultiply(unsigned __int16 *result)
{
  float v1 = half::_toFloat[result[3]];
  if (v1 != 1.0)
  {
    float v2 = result;
    if (v1 == 0.0)
    {
      *(_DWORD *)uint64_t result = 0;
      result[2] = 0;
    }
    else
    {
      float v3 = 1.0 / v1;
      *uint64_t result = ProCore::Private::ChannelTypeTraits<half>::denormalizef((float)(1.0 / v1) * half::_toFloat[*result]);
      v2[1] = ProCore::Private::ChannelTypeTraits<half>::denormalizef(v3 * half::_toFloat[v2[1]]);
      uint64_t result = (unsigned __int16 *)ProCore::Private::ChannelTypeTraits<half>::denormalizef(v3 * half::_toFloat[v2[2]]);
      v2[2] = (unsigned __int16)result;
    }
  }
  return result;
}

uint64_t PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>::premultiply(unsigned __int16 *a1)
{
  uint64_t v2 = a1[3];
  float v3 = half::_toFloat[*a1] * half::_toFloat[v2];
  if (v3 == 0.0)
  {
    LOWORD(v4) = 0;
  }
  else
  {
    float v5 = half::_toFloat[*a1] * half::_toFloat[v2];
    if (half::_eLut[LODWORD(v3) >> 23]) {
      unsigned int v4 = half::_eLut[LODWORD(v3) >> 23] + (((LODWORD(v5) & 0x7FF000u) + 4096) >> 13);
    }
    else {
      LOWORD(v4) = half::convert((half *)LODWORD(v3));
    }
  }
  *a1 = v4;
  float v6 = half::_toFloat[a1[1]] * half::_toFloat[v2];
  if (v6 == 0.0)
  {
    LOWORD(v7) = 0;
  }
  else if (half::_eLut[LODWORD(v6) >> 23])
  {
    unsigned int v7 = half::_eLut[LODWORD(v6) >> 23]
       + (((COERCE_UNSIGNED_INT(half::_toFloat[a1[1]] * half::_toFloat[v2]) & 0x7FF000) + 4096) >> 13);
  }
  else
  {
    LOWORD(v7) = half::convert((half *)LODWORD(v6));
  }
  a1[1] = v7;
  float v8 = half::_toFloat[a1[2]] * half::_toFloat[v2];
  if (v8 == 0.0)
  {
    uint64_t result = 0;
  }
  else if (half::_eLut[LODWORD(v8) >> 23])
  {
    uint64_t result = half::_eLut[LODWORD(v8) >> 23]
           + (((COERCE_UNSIGNED_INT(half::_toFloat[a1[2]] * half::_toFloat[v2]) & 0x7FF000) + 4096) >> 13);
  }
  else
  {
    uint64_t result = half::convert((half *)LODWORD(v8));
  }
  a1[2] = result;
  return result;
}

uint64_t anonymous namespace'::bitmapInfoFromPCBitmap(_anonymous_namespace_ *this, const PCBitmap *a2)
{
  int v10 = (*(uint64_t (**)(void, const PCBitmap *))(**((void **)this + 8) + 48))(*((void *)this + 8), a2)- 1;
  uint64_t result = 0;
  switch(v10)
  {
    case 0:
      return result;
    case 1:
    case 4:
      if ((*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this)) {
        return 1;
      }
      else {
        return 3;
      }
    case 2:
      BOOL v12 = (*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this) == 0;
      unsigned int v13 = 4;
      unsigned int v14 = 2;
      goto LABEL_12;
    case 6:
      return 4096;
    case 7:
    case 9:
      BOOL v12 = (*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this) == 0;
      unsigned int v13 = 4099;
      unsigned int v14 = 4097;
      goto LABEL_12;
    case 13:
      return 8448;
    case 14:
    case 15:
      BOOL v12 = (*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this) == 0;
      unsigned int v13 = 8451;
      unsigned int v14 = 8449;
      goto LABEL_12;
    case 16:
      BOOL v12 = (*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)this + 48))(this) == 0;
      unsigned int v13 = 8452;
      unsigned int v14 = 8450;
LABEL_12:
      if (v12) {
        return v13;
      }
      else {
        return v14;
      }
    default:
      PCPrint("File %s, line %d should not have been reached:\n\t", v3, v4, v5, v6, v7, v8, v9, (char)"/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCBitmap.mm");
      pcAbortImpl();
  }
}

void std::shared_ptr<CGDataProvider>::shared_ptr[abi:ne180100]<CGDataProvider,void (*)(CGDataProvider*),void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B7692F78(void *a1)
{
  __cxa_begin_catch(a1);
  v1(v2);
  __cxa_rethrow();
}

void sub_1B7692F8C(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<CGDataProvider *,void (*)(CGDataProvider *),std::allocator<CGDataProvider>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<CGDataProvider *,void (*)(CGDataProvider *),std::allocator<CGDataProvider>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<CGDataProvider *,void (*)(CGDataProvider *),std::allocator<CGDataProvider>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 32;
  else {
    return 0;
  }
}

void std::shared_ptr<CGImage>::shared_ptr[abi:ne180100]<CGImage,void (*)(CGImage*),void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B76930B8(void *a1)
{
  __cxa_begin_catch(a1);
  v1(v2);
  __cxa_rethrow();
}

void sub_1B76930CC(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<CGImage *,void (*)(CGImage *),std::allocator<CGImage>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<CGImage *,void (*)(CGImage *),std::allocator<CGImage>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<CGImage *,void (*)(CGImage *),std::allocator<CGImage>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 32;
  else {
    return 0;
  }
}

void std::shared_ptr<CGContext>::shared_ptr[abi:ne180100]<CGContext,void (*)(CGContext*),void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B76931FC(void *a1)
{
  __cxa_begin_catch(a1);
  v1(v2);
  __cxa_rethrow();
}

void sub_1B7693210(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<CGContext *,void (*)(CGContext *),std::allocator<CGContext>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<CGContext *,void (*)(CGContext *),std::allocator<CGContext>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<CGContext *,void (*)(CGContext *),std::allocator<CGContext>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 32;
  else {
    return 0;
  }
}

unsigned char *PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>::unpremultiply(unsigned char *result, double a2)
{
  unsigned int v2 = result[1];
  if (result[1])
  {
    if (v2 == 255) {
      return result;
    }
    LOBYTE(aOZChannelFontBase::~OZChannelFontBase(this - 2) = *result;
    float v3 = (double)*(unint64_t *)&a2 * 0.00392156863;
    float v4 = (double)v2 * 0.00392156863;
    int v5 = vcvtmd_s64_f64((float)((float)(v3 / v4) * 255.0) + 0.5 + 0.0000001);
    if (v5 >= 255) {
      int v5 = 255;
    }
    unsigned int v2 = v5 & ~(v5 >> 31);
  }
  *uint64_t result = v2;
  return result;
}

_WORD *PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>::unpremultiply(_WORD *result, double a2)
{
  unsigned int v2 = (unsigned __int16)result[1];
  if (result[1])
  {
    if (v2 == 0xFFFF) {
      return result;
    }
    LOWORD(aOZChannelFontBase::~OZChannelFontBase(this - 2) = *result;
    float v3 = (double)*(unint64_t *)&a2 * 0.0000152590219;
    float v4 = (double)v2 * 0.0000152590219;
    int v5 = vcvtmd_s64_f64((float)((float)(v3 / v4) * 65535.0) + 0.5 + 0.0000001);
    if (v5 >= 0xFFFF) {
      int v6 = 0xFFFF;
    }
    else {
      int v6 = v5;
    }
    unsigned int v2 = v6 & ~(v6 >> 31);
  }
  *uint64_t result = v2;
  return result;
}

unsigned __int8 *PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>::unpremultiply(unsigned __int8 *result)
{
  unsigned int v1 = *result;
  if (v1 != 255)
  {
    if (*result)
    {
      float v2 = (double)v1 * 0.00392156863;
      float v3 = 1.0 / v2;
      v4.i64[0] = result[1];
      v4.i64[1] = result[2];
      __asm { FMOV            V3.2D, #0.5 }
      unint64_t v10 = (unint64_t)vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vmul_n_f32(vcvt_f32_f64(vmulq_f64(vcvtq_f64_u64(v4), (float64x2_t)vdupq_n_s64(0x3F70101010101010uLL))), v3), (float32x2_t)vdup_n_s32(0x437F0000u))), _Q3), (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL))))), (int32x2_t)0xFF000000FFLL), 0);
      result[1] = v10;
      LOBYTE(v10) = result[3];
      float v11 = (double)v10 * 0.00392156863;
      int v12 = vcvtmd_s64_f64((float)((float)(v3 * v11) * 255.0) + 0.5 + 0.0000001);
      result[2] = BYTE4(v10);
      if (v12 >= 255) {
        int v12 = 255;
      }
      result[3] = v12 & ~(v12 >> 31);
    }
    else
    {
      *(_WORD *)(result + 1) = 0;
      result[3] = 0;
    }
  }
  return result;
}

unsigned __int8 *PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>::unpremultiply(unsigned __int8 *result)
{
  unsigned int v1 = result[3];
  if (v1 != 255)
  {
    if (result[3])
    {
      float v2 = (double)v1 * 0.00392156863;
      float v3 = 1.0 / v2;
      v4.i64[0] = *result;
      v4.i64[1] = result[1];
      __asm { FMOV            V3.2D, #0.5 }
      unint64_t v10 = (unint64_t)vmax_s32(vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(vmul_n_f32(vcvt_f32_f64(vmulq_f64(vcvtq_f64_u64(v4), (float64x2_t)vdupq_n_s64(0x3F70101010101010uLL))), v3), (float32x2_t)vdup_n_s32(0x437F0000u))), _Q3), (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL))))), (int32x2_t)0xFF000000FFLL), 0);
      *uint64_t result = v10;
      LOBYTE(v10) = result[2];
      float v11 = (double)v10 * 0.00392156863;
      int v12 = vcvtmd_s64_f64((float)((float)(v3 * v11) * 255.0) + 0.5 + 0.0000001);
      result[1] = BYTE4(v10);
      if (v12 >= 255) {
        int v12 = 255;
      }
      result[2] = v12 & ~(v12 >> 31);
    }
    else
    {
      *(_WORD *)uint64_t result = 0;
      result[2] = 0;
    }
  }
  return result;
}

void PCUnsupportedOperationException::~PCUnsupportedOperationException(PCString *this)
{
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

void PCUnsupportedOperationException::className(PCURL *a1@<X8>)
{
}

void PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::shared_ptr<CGColor>::shared_ptr[abi:ne180100]<CGColor,void (*)(void const*),void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B7693864(void *a1)
{
  __cxa_begin_catch(a1);
  v1(v2);
  __cxa_rethrow();
}

void sub_1B7693878(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<CGColor *,void (*)(void const*),std::allocator<CGColor>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<CGColor *,void (*)(void const*),std::allocator<CGColor>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<CGColor *,void (*)(void const*),std::allocator<CGColor>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 32;
  else {
    return 0;
  }
}

void std::shared_ptr<__CFDictionary>::shared_ptr[abi:ne180100]<__CFDictionary,void (*)(void const*),void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B76939A4(void *a1)
{
  __cxa_begin_catch(a1);
  v1(v2);
  __cxa_rethrow();
}

void sub_1B76939B8(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<__CFDictionary *,void (*)(void const*),std::allocator<__CFDictionary>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<__CFDictionary *,void (*)(void const*),std::allocator<__CFDictionary>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<__CFDictionary *,void (*)(void const*),std::allocator<__CFDictionary>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 32;
  else {
    return 0;
  }
}

void std::shared_ptr<CGImageDestination>::shared_ptr[abi:ne180100]<CGImageDestination,void (*)(void const*),void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B7693AE4(void *a1)
{
  __cxa_begin_catch(a1);
  v1(v2);
  __cxa_rethrow();
}

void sub_1B7693AF8(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<CGImageDestination *,void (*)(void const*),std::allocator<CGImageDestination>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<CGImageDestination *,void (*)(void const*),std::allocator<CGImageDestination>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<CGImageDestination *,void (*)(void const*),std::allocator<CGImageDestination>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 32;
  else {
    return 0;
  }
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  int v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7693C14(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C2C38;
  std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7693C88(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2C38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2C38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B7693DA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10B3D18;
  return a1;
}

void sub_1B7693E50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)1>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7693F10(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C2C88;
  std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7693F84(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2C88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2C88;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B76940A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C2CD8;
  return a1;
}

void sub_1B769414C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)2>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B769420C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C2D50;
  std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7694280(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2D50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2D50;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B76943A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C2848;
  return a1;
}

void sub_1B7694448(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B76944CC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C2DA0;
  std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7694540(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2DA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2DA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B7694660(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C28C0;
  return a1;
}

void sub_1B7694708(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B769478C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C2DF0;
  std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7694800(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2DF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2DF0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B7694920(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10B3B38;
  return a1;
}

void sub_1B76949C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7694A4C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C2E40;
  std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7694AC0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2E40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2E40;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B7694BE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C2938;
  return a1;
}

void sub_1B7694C88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7694D0C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C2E90;
  std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7694D80(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2E90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2E90;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B7694EA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10B3C28;
  return a1;
}

void sub_1B7694F48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)7>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7695008(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C2EE0;
  std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B769507C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2EE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2EE0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B769519C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C2F30;
  return a1;
}

void sub_1B7695244(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)8>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7695304(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C2FA8;
  std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7695378(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2FA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2FA8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B7695498(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10B3A48;
  return a1;
}

void sub_1B7695540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>,std::allocator<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B76955C4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C2FF8;
  std::allocator<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7695638(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2FF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C2FF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B7695758(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C3048;
  return a1;
}

void sub_1B7695800(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void PCBitmap_t<PCPixel3<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)9>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B76958C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C30C0;
  std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7695934(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C30C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C30C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B7695A54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C3110;
  return a1;
}

void sub_1B7695AFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)11>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7695BBC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C3188;
  std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7695C30(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C3188;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C3188;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B7695D50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C31D8;
  return a1;
}

void sub_1B7695DF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)12>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7695EB8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C3250;
  std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7695F2C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C3250;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C3250;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B769604C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C29B0;
  return a1;
}

void sub_1B76960F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7696178(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C32A0;
  std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B76961EC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C32A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C32A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B769630C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C32F0;
  return a1;
}

void sub_1B76963B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void PCBitmap_t<PCGrayPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)14>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7696474(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C3368;
  std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B76964E8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C3368;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C3368;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>>::construct[abi:ne180100]<PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B7696608(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C33B8;
  return a1;
}

void sub_1B76966B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void PCBitmap_t<PCGrayAlphaPixel<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)15>>>::~PCBitmap_t(PCBitmap *a1)
{
  PCBitmap::~PCBitmap(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7696770(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C3430;
  std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B76967E4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C3430;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C3430;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B7696904(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C2A28;
  return a1;
}

void sub_1B76969AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7696A30(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>::__shared_ptr_emplace[abi:ne180100]<std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&,std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10C3480;
  std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>((uint64_t)&v5, a1 + 3, a2, a3);
  return a1;
}

void sub_1B7696AA4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C3480;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C3480;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::allocator<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>::construct[abi:ne180100]<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>,std::unique_ptr<ProCore_Private::PCBitmapRepDefault>,CGColorSpace *&>(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a3;
  *a3 = 0;
  uint64_t v6 = v4;
  PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(a2, &v6, *a4);
  uint64_t result = v6;
  uint64_t v6 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1B7696BC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void *PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>::PCBitmap_t<ProCore_Private::PCBitmapRepDefault>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v7 = v4;
  PCBitmap::PCBitmap<ProCore_Private::PCBitmapRepDefault>((uint64_t)a1, &v7, a3);
  uint64_t v5 = v7;
  uint64_t v7 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *a1 = &unk_1F10C2AA0;
  return a1;
}

void sub_1B7696C6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCBitmap::PCBitmap();
  }
  _Unwind_Resume(exception_object);
}

void std::shared_ptr<PCBitmap>::shared_ptr[abi:ne180100]<PCBitmap,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B7696D08(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<PCBitmap>::shared_ptr[abi:ne180100]<PCBitmap,void>();
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<PCBitmap *,std::shared_ptr<PCBitmap>::__shared_ptr_default_delete<PCBitmap,PCBitmap>,std::allocator<PCBitmap>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<PCBitmap *,std::shared_ptr<PCBitmap>::__shared_ptr_default_delete<PCBitmap,PCBitmap>,std::allocator<PCBitmap>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<PCBitmap *,std::shared_ptr<PCBitmap>::__shared_ptr_default_delete<PCBitmap,PCBitmap>,std::allocator<PCBitmap>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t PCBitmap::PCBitmap()
{
  OUTLINED_FUNCTION_0_0();
  return (*(uint64_t (**)(void))(v0 + 8))();
}

uint64_t std::shared_ptr<PCBitmap>::shared_ptr[abi:ne180100]<PCBitmap,void>()
{
  OUTLINED_FUNCTION_0_0();
  return (*(uint64_t (**)(void))(v0 + 8))();
}

void PCImageAttributes::PCImageAttributes(PCImageAttributes *this)
{
  *(_OWORD *)this = xmmword_1B7E7C450;
  *((void *)this + OZChannelFontBase::~OZChannelFontBase(this - 2) = 0x500000004;
  uint64_t v2 = (PCImageAttributes *)((char *)this + 24);
  uint64_t DefaultRGBCGColorSpace = (CGColorSpace *)PCInfo::getDefaultRGBCGColorSpace(this);
  PCColorSpaceHandle::PCColorSpaceHandle(v2, DefaultRGBCGColorSpace);
  *((void *)this + 4) = 3553;
  *((unsigned char *)this + 40) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = 0;
}

uint64_t PCImageAttributes::PCImageAttributes(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  uint64_t v4 = *(CGColorSpace **)(a2 + 24);
  *(void *)(a1 + 24) = v4;
  if (v4) {
    PCCFRefTraits<CGColorSpace *>::retain(v4);
  }
  *(void *)(a1 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = *(void *)(a2 + 32);
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  return a1;
}

uint64_t PCImageAttributes::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)(a1 + 24), (CGColorSpace **)(a2 + 24));
    *(void *)(a1 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = *(void *)(a2 + 32);
    *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
    *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
  }
  return a1;
}

void PCImage::PCImage(PCImage *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + OZChannelFontBase::~OZChannelFontBase(this - 2) = 0;
  *(void *)this = &unk_1F10C3548;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = 0;
  uint64_t DefaultRGBCGColorSpace = (CGColorSpace *)PCInfo::getDefaultRGBCGColorSpace(this);
  PCColorSpaceHandle::PCColorSpaceHandle((PCImage *)((char *)this + 48), DefaultRGBCGColorSpace);
  *((unsigned char *)this + 56) = 0;
}

void sub_1B7696FDC(_Unwind_Exception *exception_object)
{
  float v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void PCImage::PCImage(PCImage *this, int a2, int a3, int a4, int a5, CGColorSpaceRef space)
{
  *((void *)this + 1) = 0;
  *((void *)this + OZChannelFontBase::~OZChannelFontBase(this - 2) = 0;
  *(void *)this = &unk_1F10C3548;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 7) = a2;
  *((_DWORD *)this + 8) = a3;
  *((_DWORD *)this + 9) = a4;
  *((_DWORD *)this + 10) = a5;
  *((_DWORD *)this + 11) = 0;
  PCColorSpaceHandle::PCColorSpaceHandle((PCImage *)((char *)this + 48), space);
  *((unsigned char *)this + 56) = 0;
}

void sub_1B7697054(_Unwind_Exception *exception_object)
{
  float v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t PCImage::PCImage(uint64_t a1, int a2, int a3, int a4, int a5, CGColorSpace **a6)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F10C3548;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = a2;
  *(_DWORD *)(a1 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = a3;
  *(_DWORD *)(a1 + 36) = a4;
  *(_DWORD *)(a1 + 40) = a5;
  *(_DWORD *)(a1 + 44) = 0;
  uint64_t v7 = *a6;
  *(void *)(a1 + 48) = *a6;
  if (v7) {
    PCCFRefTraits<CGColorSpace *>::retain(v7);
  }
  *(unsigned char *)(a1 + 56) = 0;
  return a1;
}

void sub_1B76970D0(_Unwind_Exception *exception_object)
{
  float v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t PCImage::PCImage(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F10C3548;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  uint64_t v4 = *(CGColorSpace **)(a2 + 48);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    PCCFRefTraits<CGColorSpace *>::retain(v4);
  }
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  return a1;
}

void sub_1B7697158(_Unwind_Exception *exception_object)
{
  float v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void PCImage::~PCImage(CGColorSpace **this)
{
  *this = (CGColorSpace *)&unk_1F10C3548;
  PCCFRef<CGColorSpace *>::~PCCFRef(this + 6);
  uint64_t v2 = (std::__shared_weak_count *)this[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t PCImage::getWidth(PCImage *this)
{
  return *((unsigned int *)this + 7);
}

uint64_t PCImage::getHeight(PCImage *this)
{
  return *((unsigned int *)this + 8);
}

CGColorSpace **PCImage::getAttributes(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 40);
  uint64_t result = PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)(a2 + 24), (CGColorSpace **)(a1 + 48));
  *(unsigned char *)(a2 + 40) = *(unsigned char *)(a1 + 56);
  return result;
}

uint64_t PCImage::setGuaranteeMemoryCallback(uint64_t this, BOOL (*a2)(unsigned int))
{
  PCImage::_guaranteeMemory = this;
  return this;
}

CGColorSpace **PCImage::setColorSpace(PCImage *this, CGColorSpace *a2)
{
  PCColorSpaceHandle::PCColorSpaceHandle((PCColorSpaceHandle *)&v4, a2);
  (*(void (**)(PCImage *, CGColorSpace **))(*(void *)this + 56))(this, &v4);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v4);
}

void sub_1B7697290(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

CGColorSpace **PCImage::setColorSpace(uint64_t a1, CGColorSpace **a2)
{
  return PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)(a1 + 48), a2);
}

uint64_t PCImage::getCGColorSpace(PCImage *this)
{
  return PCColorSpaceHandle::getCGColorSpace((PCImage *)((char *)this + 48));
}

CGColorSpace *PCImage::getColorSpace@<X0>(PCImage *this@<X0>, CGColorSpace **a2@<X8>)
{
  uint64_t result = (CGColorSpace *)*((void *)this + 6);
  *a2 = result;
  if (result) {
    return PCCFRefTraits<CGColorSpace *>::retain(result);
  }
  return result;
}

uint64_t PCImage::isPremultiplied(PCImage *this)
{
  return *((unsigned __int8 *)this + 56);
}

uint64_t PCImage::setIsPremultiplied(uint64_t this, char a2)
{
  *(unsigned char *)(this + 56) = a2;
  return this;
}

int *PCColor::RED(PCColor *this)
{
  {
    getDefaultColorSpace(&v2);
    PCColor::RED(void)::RED = 4;
    qword_1E9EE4B08 = 0x3FF0000000000000;
    unk_1E9EE4B10 = 0;
    qword_1E9EE4B18 = 0;
    unk_1E9EE4B20 = 0x3FF0000000000000;
    sanitizeColorSpace(&v2, &qword_1E9EE4B30);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v2);
    __cxa_atexit((void (*)(void *))PCColor::~PCColor, &PCColor::RED(void)::RED, &dword_1B73F3000);
  }
  return &PCColor::RED(void)::RED;
}

void sub_1B7697394(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

CGColorSpace *getDefaultColorSpace@<X0>(void *a1@<X8>)
{
  {
    allocDefaultColorSpace();
  }
  uint64_t result = *(CGColorSpace **)getDefaultColorSpace(void)::result;
  *a1 = *(void *)getDefaultColorSpace(void)::result;
  if (result)
  {
    return PCCFRefTraits<CGColorSpace *>::retain(result);
  }
  return result;
}

void sub_1B7697444(_Unwind_Exception *a1)
{
}

void PCColor::~PCColor(PCColor *this)
{
}

int *PCColor::BLACK(PCColor *this)
{
  {
    getDefaultColorSpace(&v2);
    PCColor::BLACK(void)::BLACK = 4;
    qword_1E9EE4B48 = 0;
    unk_1E9EE4B50 = 0;
    qword_1E9EE4B58 = 0;
    unk_1E9EE4B60 = 0x3FF0000000000000;
    sanitizeColorSpace(&v2, &qword_1E9EE4B70);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v2);
    __cxa_atexit((void (*)(void *))PCColor::~PCColor, &PCColor::BLACK(void)::BLACK, &dword_1B73F3000);
  }
  return &PCColor::BLACK(void)::BLACK;
}

void sub_1B7697540(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

int *PCColor::WHITE(PCColor *this)
{
  {
    getDefaultColorSpace(&v7);
    PCColor::WHITE(void)::WHITE = 4;
    __asm { FMOV            V0.2D, #1.0 }
    unk_1E9EE4B88 = _Q0;
    unk_1E9EE4B98 = _Q0;
    sanitizeColorSpace(&v7, &qword_1E9EE4BB0);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v7);
    __cxa_atexit((void (*)(void *))PCColor::~PCColor, &PCColor::WHITE(void)::WHITE, &dword_1B73F3000);
  }
  return &PCColor::WHITE(void)::WHITE;
}

void sub_1B7697620(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

int *PCColor::CLEAR(PCColor *this)
{
  {
    getDefaultColorSpace(&v2);
    PCColor::CLEAR(void)::CLEAR = 4;
    unk_1EB9A09D8 = 0u;
    unk_1EB9A09E8 = 0u;
    sanitizeColorSpace(&v2, &qword_1EB9A0A00);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v2);
    __cxa_atexit((void (*)(void *))PCColor::~PCColor, &PCColor::CLEAR(void)::CLEAR, &dword_1B73F3000);
  }
  return &PCColor::CLEAR(void)::CLEAR;
}

void sub_1B7697700(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PCColor::PCColor(PCColor *this)
{
  getDefaultColorSpace(&v2);
  this->var0.var0 = 4;
  this->var0.var1[0] = 0.0;
  this->var0.var1[1] = 0.0;
  this->var0.var1[2] = 0.0;
  this->var0.var1[3] = 1.0;
  sanitizeColorSpace(&v2, &this->var1._obj);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v2);
}

void sub_1B7697784(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PCColor::PCColor(PCColor *this, float a2, float a3, float a4, CGColorSpace *a5)
{
}

void PCColor::PCColor(PCColor *this, float a2, float a3, float a4, float a5, CGColorSpace *a6)
{
  if (a6) {
    PCCFRefTraits<CGColorSpace *>::retain(a6);
  }
  int v12 = a6;
  this->var0.var0 = 4;
  this->var0.var1[0] = a2;
  this->var0.var1[1] = a3;
  this->var0.var1[2] = a4;
  this->var0.var1[3] = a5;
  sanitizeColorSpace(&v12, &this->var1._obj);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v12);
}

void sub_1B7697834(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PCColor::PCColor(PCColor *this, float a2, float a3, float a4, OZChannelBase *a5)
{
  uint64_t v9 = (CGColorSpaceRef *)OZChannelBase::setRangeName(a5, (const PCString *)a5);
  this->var0.var0 = 4;
  this->var0.var1[0] = a2;
  this->var0.var1[1] = a3;
  this->var0.var1[2] = a4;
  this->var0.var1[3] = 1.0;
  sanitizeColorSpace(v9, &this->var1._obj);
}

void PCColor::PCColor(PCColor *this, float a2, float a3, float a4, float a5, OZChannelBase *a6)
{
  float v11 = (CGColorSpaceRef *)OZChannelBase::setRangeName(a6, (const PCString *)a6);
  this->var0.var0 = 4;
  this->var0.var1[0] = a2;
  this->var0.var1[1] = a3;
  this->var0.var1[2] = a4;
  this->var0.var1[3] = a5;
  sanitizeColorSpace(v11, &this->var1._obj);
}

void sanitizeColorSpace(CGColorSpaceRef *a1@<X0>, CGColorSpace **a2@<X8>)
{
  if (*a1) {
    PCGetCachedExtendedRangeColorSpace(a1, a2);
  }
  else {
    getDefaultColorSpace(a2);
  }
}

uint64_t PCColor::PCColor(uint64_t a1, uint64_t a2, CGColorSpaceRef *a3)
{
  *(_DWORD *)a1 = 0;
  sanitizeColorSpace(a3, (CGColorSpace **)(a1 + 48));
  transformColor<PCColor::ColorComponents>((double *)a2, *(CGColorSpace **)(a2 + 48), (double *)a1, *(CGColorSpaceRef *)(a1 + 48));
  return a1;
}

void sub_1B7697998(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

void PCColor::PCColor(PCColor *this, const PCColor *a2, CGColorSpaceRef space)
{
  if (space) {
    PCCFRefTraits<CGColorSpace *>::retain(space);
  }
  uint64_t v6 = space;
  PCColor::PCColor((uint64_t)this, (uint64_t)a2, &v6);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v6);
}

void sub_1B7697A10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

double PCColor::setAlpha(PCColor *this, float a2)
{
  double result = a2;
  *((double *)&this->var0.var0 + this->var0.var0) = result;
  return result;
}

float PCColor::getAlpha(PCColor *this)
{
  return *((double *)&this->var0.var0 + this->var0.var0);
}

CGColorSpace *PCColor::getCGColorSpace(PCColor *this)
{
  return this->var1._obj;
}

CGColorSpace **PCColor::getColorSpace@<X0>(PCColor *this@<X0>, CGColorSpace **a2@<X8>)
{
  return PCColorSpaceHandle::PCColorSpaceHandle(a2, &this->var1._obj);
}

CGColorSpace **PCColor::setRGB(PCColor *this, float a2, float a3, float a4, CGColorSpace *a5)
{
  float v6 = *((double *)&this->var0.var0 + this->var0.var0);
  PCColor::PCColor(&v11, a2, a3, a4, v6, a5);
  long long v7 = *(_OWORD *)&v11.var0.var1[1];
  *(_OWORD *)&this->var0.var0 = *(_OWORD *)&v11.var0.var0;
  *(_OWORD *)&this->var0.var1[1] = v7;
  *(_OWORD *)&this->var0.var1[3] = *(_OWORD *)&v11.var0.var1[3];
  obint j = this->var1._obj;
  uint64_t v9 = v11.var1._obj;
  if (obj && obj != v11.var1._obj)
  {
    PCCFRefTraits<CGColorSpace *>::release(obj);
    uint64_t v9 = v11.var1._obj;
  }
  this->var1._obint j = v9;
  v11.var1._obint j = 0;
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v11.var1._obj);
}

void sub_1B7697ADC(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

CGColorSpace **PCColor::setRGB(PCColor *this, float a2, float a3, float a4, OZChannelBase *a5)
{
  float v9 = *((double *)&this->var0.var0 + this->var0.var0);
  unint64_t v10 = (CGColorSpaceRef *)OZChannelBase::setRangeName(a5, (const PCString *)a5);
  LODWORD(v14) = 4;
  *((double *)&v14 + 1) = a2;
  *(double *)&long long v15 = a3;
  *((double *)&v15 + 1) = a4;
  *(double *)&long long v16 = v9;
  sanitizeColorSpace(v10, &v17);
  *(_OWORD *)&this->var0.var0 = v14;
  *(_OWORD *)&this->var0.var1[1] = v15;
  *(_OWORD *)&this->var0.var1[3] = v16;
  obint j = this->var1._obj;
  int v12 = v17;
  if (obj && obj != v17)
  {
    PCCFRefTraits<CGColorSpace *>::release(obj);
    int v12 = v17;
  }
  this->var1._obint j = v12;
  int v17 = 0;
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v17);
}

void sub_1B7697BB8(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

CGColorSpace **PCColor::setRGBA(PCColor *this, float a2, float a3, float a4, float a5, CGColorSpace *a6)
{
  PCColor::PCColor(&v12, a2, a3, a4, a5, a6);
  long long v7 = *(_OWORD *)&v12.var0.var1[1];
  *(_OWORD *)&this->var0.var0 = *(_OWORD *)&v12.var0.var0;
  *(_OWORD *)&this->var0.var1[1] = v7;
  *(_OWORD *)&this->var0.var1[3] = *(_OWORD *)&v12.var0.var1[3];
  obint j = this->var1._obj;
  float v9 = v12.var1._obj;
  if (obj) {
    BOOL v10 = obj == v12.var1._obj;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    PCCFRefTraits<CGColorSpace *>::release(obj);
    float v9 = v12.var1._obj;
  }
  this->var1._obint j = v9;
  v12.var1._obint j = 0;
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v12.var1._obj);
}

void sub_1B7697C44(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

CGColorSpace **PCColor::setRGBA(PCColor *this, float a2, float a3, float a4, float a5, OZChannelBase *a6)
{
  PCColor v11 = (CGColorSpaceRef *)OZChannelBase::setRangeName(a6, (const PCString *)a6);
  LODWORD(v15) = 4;
  *((double *)&v15 + 1) = a2;
  *(double *)&long long v16 = a3;
  *((double *)&v16 + 1) = a4;
  *(double *)&long long v17 = a5;
  sanitizeColorSpace(v11, &v18);
  *(_OWORD *)&this->var0.var0 = v15;
  *(_OWORD *)&this->var0.var1[1] = v16;
  *(_OWORD *)&this->var0.var1[3] = v17;
  obint j = this->var1._obj;
  unsigned int v13 = v18;
  if (obj && obj != v18)
  {
    PCCFRefTraits<CGColorSpace *>::release(obj);
    unsigned int v13 = v18;
  }
  this->var1._obint j = v13;
  uint64_t v18 = 0;
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v18);
}

void sub_1B7697D18(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

CGColorSpace **PCColor::getRGB(PCColor *this, float *a2, float *a3, float *a4, CGColorSpaceRef space)
{
  return PCColor::getRGBA(&this->var0.var0, a2, a3, a4, &v6, space, 0, (PCToneMapMethod *)&kPCNoToneMapMethod);
}

CGColorSpace **PCColor::getRGBA(PCColor *this, float *a2, float *a3, float *a4, float *a5, CGColorSpace *a6)
{
  return PCColor::getRGBA(&this->var0.var0, a2, a3, a4, a5, a6, 0, (PCToneMapMethod *)&kPCNoToneMapMethod);
}

CGColorSpace **PCColor::getRGB(PCColor *this, float *a2, float *a3, float *a4, const PCColorSpaceHandle *a5)
{
  CGColorSpace = (CGColorSpace *)PCColorSpaceHandle::getCGColorSpace(a5);
  return PCColor::getRGBA(&this->var0.var0, a2, a3, a4, &v11, CGColorSpace, 0, (PCToneMapMethod *)&kPCNoToneMapMethod);
}

CGColorSpace **PCColor::getRGBA(int *a1, float *a2, float *a3, float *a4, float *a5, CGColorSpaceRef space, int a7, PCToneMapMethod *a8)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (a7)
  {
    uint64_t v15 = *a1;
    if (v15)
    {
      long long v16 = (double *)(a1 + 2);
      uint64_t v17 = 8 * v15;
      uint64_t v18 = (float *)v40;
      do
      {
        double v19 = *v16++;
        float v20 = v19;
        *v18++ = v20;
        v17 -= 8;
      }
      while (v17);
    }
    uint64_t v21 = *((void *)a1 + 6);
    *(void *)&long long v37 = 1;
    *((void *)&v37 + 1) = v40;
    *(void *)&long long v38 = v15;
    *((void *)&v38 + 1) = v21;
    uint64_t v39 = 2;
    PCGetCachedExtendedRangeColorSpace(space, &v35);
    v32[0] = (CGColorSpace *)1;
    v32[1] = (CGColorSpace *)v36;
    v32[2] = (CGColorSpace *)4;
    v32[3] = v35;
    int v33 = 2;
    int v34 = a7;
    PCColorUtil::transformColorWithDynamicRange((uint64_t)&v37, (uint64_t)v32, a8);
    int v22 = v36[1];
    *a2 = *(float *)v36;
    *(_DWORD *)a3 = v22;
    int v23 = v36[3];
    *a4 = *(float *)&v36[2];
    *(_DWORD *)a5 = v23;
    float v24 = &v35;
  }
  else
  {
    long long v37 = 0u;
    long long v38 = 0u;
    PCGetCachedExtendedRangeColorSpace(space, v32);
    transformColor((double *)a1 + 1, *a1, *((CGColorSpace **)a1 + 6), (double *)&v37, 4, v32[0]);
    double v25 = *((double *)&v37 + 1);
    float v26 = *(double *)&v37;
    *a2 = v26;
    float v27 = v25;
    *a3 = v27;
    double v28 = *((double *)&v38 + 1);
    float v29 = *(double *)&v38;
    *a4 = v29;
    float v30 = v28;
    *a5 = v30;
    float v24 = v32;
  }
  return PCCFRef<CGColorSpace *>::~PCCFRef(v24);
}

void sub_1B7697F68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGColorSpace *a9)
{
}

CGColorSpace **PCColor::getRGBA(PCColor *this, float *a2, float *a3, float *a4, float *a5, const PCColorSpaceHandle *a6)
{
  CGColorSpace = (CGColorSpace *)PCColorSpaceHandle::getCGColorSpace(a6);

  return PCColor::getRGBA(&this->var0.var0, a2, a3, a4, a5, CGColorSpace, 0, (PCToneMapMethod *)&kPCNoToneMapMethod);
}

CGColorSpace **PCColor::getRGB(int *a1, float *a2, float *a3, float *a4, CGColorSpaceRef space, int a6, PCToneMapMethod *a7)
{
  return PCColor::getRGBA(a1, a2, a3, a4, &v8, space, a6, a7);
}

void PCColor::setRGBA(int *a1, CGColorSpaceRef space, int a3, PCToneMapMethod *a4, float a5, float a6, float a7, float a8)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (space) {
    PCGetCachedExtendedRangeColorSpace(space, v20);
  }
  else {
    getDefaultColorSpace(v20);
  }
  uint64_t v15 = (CGColorSpace *)*((void *)a1 + 6);
  long long v16 = v20[0];
  if (v15 && v15 != v20[0])
  {
    PCCFRefTraits<CGColorSpace *>::release(v15);
    long long v16 = v20[0];
  }
  *((void *)a1 + 6) = v16;
  v20[0] = 0;
  PCCFRef<CGColorSpace *>::~PCCFRef(v20);
  if (a3 == 1)
  {
    *(float *)int v22 = a5;
    *(float *)&v22[1] = a6;
    *(float *)&v22[2] = a7;
    *(float *)&v22[3] = a8;
    uint64_t v17 = (CGColorSpace *)*((void *)a1 + 6);
    v20[0] = (CGColorSpace *)1;
    v20[1] = (CGColorSpace *)v22;
    v20[2] = (CGColorSpace *)4;
    v20[3] = v17;
    v20[4] = (CGColorSpace *)0x100000002;
    v19[0] = 1;
    v19[1] = v21;
    v19[2] = 4;
    _OWORD v19[3] = v17;
    v19[4] = 2;
    PCColorUtil::transformColorWithDynamicRange((uint64_t)v20, (uint64_t)v19, a4);
    a5 = *(float *)v21;
    a6 = *(float *)&v21[1];
    a7 = *(float *)&v21[2];
    a8 = *(float *)&v21[3];
  }
  uint64_t v18 = *a1;
  if ((int)v18 <= 3) {
    bzero(&a1[2 * v18 + 2], 32 - 8 * v18);
  }
  *a1 = 4;
  *((double *)a1 + 1) = a5;
  *((double *)a1 + OZChannelFontBase::~OZChannelFontBase(this - 2) = a6;
  *((double *)a1 + 3) = a7;
  *((double *)a1 + 4) = a8;
}

void sub_1B76981AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

double PCColor::getComponents(int *a1, char **a2)
{
  unint64_t v4 = *a1;
  uint64_t v10 = 0;
  std::vector<double>::assign(a2, v4, &v10);
  if ((int)v4 >= 1)
  {
    uint64_t v6 = v4;
    long long v7 = *a2;
    float v8 = (double *)(a1 + 2);
    do
    {
      double v9 = *v8++;
      double result = v9;
      *(double *)long long v7 = v9;
      v7 += 8;
      --v6;
    }
    while (v6);
  }
  return result;
}

char *std::vector<double>::assign(char **a1, unint64_t a2, void *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  double result = *a1;
  if (a2 <= (v6 - (uint64_t)result) >> 3)
  {
    unsigned int v13 = a1[1];
    unint64_t v14 = (v13 - result) >> 3;
    if (v14 >= a2) {
      uint64_t v15 = a2;
    }
    else {
      uint64_t v15 = (v13 - result) >> 3;
    }
    if (v15)
    {
      long long v16 = result;
      do
      {
        *(void *)long long v16 = *a3;
        v16 += 8;
        --v15;
      }
      while (v15);
    }
    if (a2 <= v14)
    {
      a1[1] = &result[8 * a2];
    }
    else
    {
      uint64_t v17 = &v13[8 * (a2 - v14)];
      uint64_t v18 = 8 * a2 - 8 * v14;
      do
      {
        *(void *)unsigned int v13 = *a3;
        v13 += 8;
        v18 -= 8;
      }
      while (v18);
      a1[1] = v17;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a2 >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = v6 >> 2;
    if (v6 >> 2 <= a2) {
      uint64_t v8 = a2;
    }
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    double result = std::vector<double>::__vallocate[abi:ne180100](a1, v9);
    uint64_t v10 = a1[1];
    float v11 = &v10[8 * a2];
    uint64_t v12 = 8 * a2;
    do
    {
      *(void *)uint64_t v10 = *a3;
      v10 += 8;
      v12 -= 8;
    }
    while (v12);
    a1[1] = v11;
  }
  return result;
}

void PCColor::mix(PCColor *this, const PCColor *a2, float a3)
{
  LODWORD(v11) = 0;
  memset(v12, 0, sizeof(v12));
  uint64_t v13 = 0;
  transformColor<PCColor::ColorComponents>((double *)&a2->var0.var0, a2->var1._obj, &v11, this->var1._obj);
  uint64_t v5 = (LODWORD(v11) - 1);
  if (LODWORD(v11) != 1)
  {
    var1 = this->var0.var1;
    long long v7 = (double *)v12;
    do
    {
      double v8 = *v7++;
      float v9 = v8;
      float v10 = *var1;
      *var1++ = (float)((float)(v9 * a3) + (float)((float)(1.0 - a3) * v10));
      --v5;
    }
    while (v5);
  }
}

double transformColor<PCColor::ColorComponents>(double *a1, CGColorSpace *a2, double *a3, CGColorSpaceRef space)
{
  int NumberOfComponents = CGColorSpaceGetNumberOfComponents(space);
  if (NumberOfComponents + 1 < 5) {
    int v9 = NumberOfComponents + 1;
  }
  else {
    int v9 = 5;
  }
  uint64_t v10 = *(int *)a3;
  if (v9 <= (int)v10)
  {
    uint64_t v11 = v9;
  }
  else
  {
    uint64_t v11 = v9;
    int64_t v12 = 8 * v9 - 8 * v10;
    if (v12 >= 1) {
      bzero(&a3[v10 + 1], v12);
    }
  }
  *(_DWORD *)a3 = v9;
  uint64_t v13 = *(int *)a1;

  return transformColor(a1 + 1, v13, a2, a3 + 1, v11, space);
}

void PCWorkingColor::WHITE(PCWorkingColor *this@<X0>, PCWorkingColor *a2@<X8>)
{
}

void PCWorkingColor::PCWorkingColor(PCWorkingColor *this, float a2, float a3, float a4, float a5, CGColorSpace *a6)
{
  if (a6) {
    PCCFRefTraits<CGColorSpace *>::retain(a6);
  }
  int64_t v12 = a6;
  PCWorkingColor::PCWorkingColor((uint64_t)this, &v12, 0, (PCToneMapMethod *)&kPCNoToneMapMethod, a2, a3, a4, a5);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v12);
}

void sub_1B7698558(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PCWorkingColor::PCWorkingColor(PCWorkingColor *this, CGColorSpaceRef space)
{
  if (space) {
    PCCFRefTraits<CGColorSpace *>::retain(space);
  }
  unint64_t v4 = space;
  PCWorkingColor::PCWorkingColor((uint64_t)this, &v4, 0, (PCToneMapMethod *)&kPCNoToneMapMethod, 0.0, 0.0, 0.0, 1.0);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v4);
}

void sub_1B76985DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PCWorkingColor::PCWorkingColor(PCWorkingColor *this, OZChannelBase *a2)
{
  float v3 = (CGColorSpaceRef *)OZChannelBase::setRangeName(a2, (const PCString *)a2);

  PCWorkingColor::PCWorkingColor((uint64_t)this, v3, 0, (PCToneMapMethod *)&kPCNoToneMapMethod, 0.0, 0.0, 0.0, 1.0);
}

uint64_t PCWorkingColor::PCWorkingColor(uint64_t a1, CGColorSpaceRef *a2, int a3, PCToneMapMethod *a4)
{
  return PCWorkingColor::PCWorkingColor(a1, a2, a3, a4, 0.0, 0.0, 0.0, 1.0);
}

uint64_t PCWorkingColor::PCWorkingColor(uint64_t a1, CGColorSpaceRef *a2, int a3, PCToneMapMethod *a4, float a5, float a6, float a7, float a8)
{
  int v13 = 4;
  double v14 = a5;
  double v15 = a6;
  double v16 = a7;
  double v17 = a8;
  sanitizeColorSpace(a2, &v18);
  PCWorkingColor::PCWorkingColor(a1, &v13, a2, a3, a4);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v18);
  return a1;
}

void sub_1B76986FC(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

uint64_t PCWorkingColor::PCWorkingColor(uint64_t a1, int *a2, CGColorSpaceRef *a3, int a4, PCToneMapMethod *a5)
{
  uint64_t v10 = *a3;
  *(void *)(a1 + 16) = *a3;
  if (v10) {
    PCCFRefTraits<CGColorSpace *>::retain(v10);
  }
  *(_DWORD *)(a1 + 24) = a4;
  *(PCToneMapMethod *)(a1 + 28) = *a5;
  PCColor::getRGBA(a2, (float *)a1, (float *)(a1 + 4), (float *)(a1 + 8), (float *)(a1 + 12), *a3, a4, a5);
  return a1;
}

void sub_1B7698798(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

void PCWorkingColor::PCWorkingColor(PCWorkingColor *this, const PCColor *a2, CGColorSpaceRef space)
{
  if (space) {
    PCCFRefTraits<CGColorSpace *>::retain(space);
  }
  uint64_t v6 = space;
  PCWorkingColor::PCWorkingColor((uint64_t)this, &a2->var0.var0, &v6, 0, (PCToneMapMethod *)&kPCNoToneMapMethod);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v6);
}

void sub_1B7698820(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

__n128 PCWorkingColor::operator=(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t PCWorkingColor::operator=(uint64_t a1, int *a2)
{
  return a1;
}

float *PCWorkingColor::setRGB(float *this, float a2, float a3, float a4)
{
  *this = a2;
  this[1] = a3;
  this[2] = a4;
  return this;
}

float PCWorkingColor::getRGBA(PCWorkingColor *this, float *a2, float *a3, float *a4, float *a5)
{
  *a2 = *(float *)this;
  *a3 = *((float *)this + 1);
  *a4 = *((float *)this + 2);
  float result = *((float *)this + 3);
  *a5 = result;
  return result;
}

float32x4_t operator*@<Q0>(uint64_t a1@<X0>, float32x4_t *a2@<X1>, float32x4_t *a3@<X8>)
{
  *a3 = *(float32x4_t *)a1;
  uint64_t v6 = *(CGColorSpace **)(a1 + 16);
  a3[1].i64[0] = (uint64_t)v6;
  if (v6) {
    PCCFRefTraits<CGColorSpace *>::retain(v6);
  }
  a3[1].i64[1] = *(void *)(a1 + 24);
  a3[2].i32[0] = *(_DWORD *)(a1 + 32);
  float32x4_t result = vmulq_f32(*a3, *a2);
  *a3 = result;
  return result;
}

BOOL operator==(uint64_t a1, uint64_t a2)
{
  if (vabds_f32(*(float *)(a1 + 12), *(float *)(a2 + 12)) >= 0.00001) {
    return 0;
  }
  int v3 = *(_DWORD *)(a2 + 8);
  uint64_t v10 = *(void *)a2;
  int v11 = v3;
  uint64_t v4 = *(void *)(a2 + 16);
  int v5 = *(_DWORD *)(a2 + 24);
  uint64_t v6 = *(void *)(a1 + 16);
  int v7 = *(_DWORD *)(a1 + 24);
  PCToneMapMethod v9 = *(PCToneMapMethod *)(a1 + 28);
  PCColorUtil::transform(&v9, &v10, v4, v5, v6, v7, (uint64_t)v12);
  return vabds_f32(*(float *)a1, v12[0]) < 0.00001
      && vabds_f32(*(float *)(a1 + 4), v12[1]) < 0.00001
      && vabds_f32(*(float *)(a1 + 8), v12[2]) < 0.00001;
}

{
  return *(void *)a1 == *(void *)a2 && *(_DWORD *)(a1 + 8) == (unint64_t)*(unsigned int *)(a2 + 8);
}

BOOL operator!=(uint64_t a1, uint64_t a2)
{
  return !operator==(a1, a2);
}

void PCWorkingColorVector::PCWorkingColorVector(PCWorkingColorVector *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
}

void PCWorkingColorVector::PCWorkingColorVector(PCWorkingColorVector *this, float a2, float a3, float a4, float a5)
{
  *(float *)this = a2;
  *((float *)this + 1) = a3;
  *((float *)this + OZChannelFontBase::~OZChannelFontBase(this - 2) = a4;
  *((float *)this + 3) = a5;
}

float32_t PCWorkingColorVector::operator*=(float32x2_t *a1, float a2)
{
  *a1 = vmul_n_f32(*a1, a2);
  float32_t result = a1[1].f32[0] * a2;
  a1[1].f32[0] = result;
  return result;
}

BOOL operator==(float *a1, float *a2)
{
  return vabds_f32(*a1, *a2) < 0.00001
      && vabds_f32(a1[1], a2[1]) < 0.00001
      && vabds_f32(a1[2], a2[2]) < 0.00001
      && vabds_f32(a1[3], a2[3]) < 0.00001;
}

BOOL operator!=(float *a1, float *a2)
{
  return !operator==(a1, a2);
}

float operator+(float *a1, float *a2)
{
  return *a1 + *a2;
}

double operator*(float32x4_t *a1, float32x4_t *a2)
{
  *(void *)&double result = vmulq_f32(*a1, *a2).u64[0];
  return result;
}

float operator*(float *a1, float a2)
{
  return *a1 * a2;
}

void allocDefaultColorSpace(void)
{
  PCColorSpaceCache::sRGB(v2);
  uint64_t v1 = *(CGColorSpace **)OZChannelBase::setRangeName((OZChannelBase *)v2, v0);
  v2[1] = v1;
  if (v1) {
    PCCFRefTraits<CGColorSpace *>::retain(v1);
  }
  PCCFRef<CGColorSpace *>::~PCCFRef(v2);
  operator new();
}

void sub_1B7698B98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v3 = v2;
  MEMORY[0x1BA9BFBA0](v3, 0x20C4093837F09);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

double transformColor(double *a1, uint64_t a2, CGColorSpace *a3, double *a4, uint64_t a5, CGColorSpace *a6)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v8 = 8 * a2;
    PCToneMapMethod v9 = (float *)v19;
    do
    {
      double v10 = *a1++;
      float v11 = v10;
      *v9++ = v11;
      v8 -= 8;
    }
    while (v8);
  }
  v17[0] = 1;
  v17[1] = v19;
  v17[2] = a2;
  v17[3] = a3;
  v17[4] = 2;
  v16[0] = 1;
  v16[1] = v18;
  v16[2] = a5;
  void v16[3] = a6;
  v16[4] = 2;
  PCColorUtil::transformColor((uint64_t)v17, (uint64_t)v16);
  if (a5)
  {
    uint64_t v13 = 4 * a5;
    double v14 = (float *)v18;
    do
    {
      float v15 = *v14++;
      double result = v15;
      *a4++ = v15;
      v13 -= 4;
    }
    while (v13);
  }
  return result;
}

void std::vector<double>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<double>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<double>::__append(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  int v5 = v6;
  int v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      double v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v4, v13);
      uint64_t v8 = *a1;
      int v7 = a1[1];
    }
    else
    {
      double v14 = 0;
    }
    float v15 = &v14[8 * v11];
    double v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    double v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      uint64_t v18 = *((void *)v7 - 1);
      v7 -= 8;
      *((void *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

BOOL PCColorSpaceHandle::isSameColorSpace(CGColorSpaceRef space, CGColorSpace *a2, CGColorSpace *a3)
{
  BOOL v3 = ((unint64_t)space | (unint64_t)a2) == 0;
  if (space && a2)
  {
    if (space == a2)
    {
      return 1;
    }
    else
    {
      PCCFRefTraits<CGColorSpace *>::retain(space);
      uint64_t v9 = space;
      PCCFRefTraits<CGColorSpace *>::retain(a2);
      uint64_t v8 = a2;
      PCCFRef<CGColorSpace *>::~PCCFRef(&v8);
      PCCFRef<CGColorSpace *>::~PCCFRef(&v9);
    }
  }
  return v3;
}

void sub_1B7698E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGColorSpace *a9, CGColorSpace *a10)
{
}

BOOL anonymous namespace'::colorSpacesAreEquivalent(CGColorSpace **this, CGColorSpace **a2, const PCColorSpaceHandle *a3)
{
  unint64_t v9 = PCGetNCLCCodeForColorSpace(*this);
  int v10 = v4;
  unint64_t v7 = PCGetNCLCCodeForColorSpace(*a2);
  int v8 = v5;
  return operator==((uint64_t)&v9, (uint64_t)&v7);
}

void PCColorSpaceHandle::PCColorSpaceHandle(PCColorSpaceHandle *this, CGColorSpaceRef space)
{
  if (space) {
    PCCFRefTraits<CGColorSpace *>::retain(space);
  }
  *(void *)this = space;
}

BOOL PCColorSpaceHandle::isSameColorSpace(CGColorSpace **this, CGColorSpace **a2, const PCColorSpaceHandle *a3)
{
  int v4 = *this;
  int v5 = *a2;
  BOOL result = ((unint64_t)*this | (unint64_t)*a2) == 0;
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
  return result;
  }
}

BOOL operator==(void *a1)
{
  return *a1 == 0;
}

uint64_t PCColorSpaceHandle::getCGColorSpace(PCColorSpaceHandle *this)
{
  return *(void *)this;
}

void PCColorSpaceHandle::getMD5(CGColorSpace **this@<X0>, PCWorkingColorVector *a2@<X8>)
{
  if (*this) {
  else
  }
    PCWorkingColorVector::PCWorkingColorVector(a2);
}

void PCCachedFunctionImpl<PCHash128,PCColorSpaceHandle const&>::operator()(os_unfair_lock_s *a1@<X0>, CGColorSpace **a2@<X1>, PCWorkingColorVector *a3@<X8>)
{
  uint64_t v6 = a1 + 8;
  v11[1] = (CGColorSpace *)&a1[8];
  PCSpinLock::lock(a1 + 8);
  BOOL v7 = *a2;
  v11[0] = v7;
  if (v7) {
    PCCFRefTraits<CGColorSpace *>::retain(v7);
  }
  char v10 = 0;
  PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::findValue(*(void **)&a1[10]._os_unfair_lock_opaque, (unint64_t *)v11, &v10, a3);
  if (!v10)
  {
    uint64_t v8 = *(void *)&a1[6]._os_unfair_lock_opaque;
    if (!v8) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(long long *__return_ptr))(*(void *)v8 + 48))(&v9);
    *(_OWORD *)a3 = v9;
    PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::addValue(*(void *)&a1[10]._os_unfair_lock_opaque, v11, a3, 0);
  }
  PCCFRef<CGColorSpace *>::~PCCFRef(v11);
  PCSpinLock::unlock(v6);
}

void sub_1B7699098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void PCColorSpaceHandle::getMD5(PCColorSpaceHandle *this@<X0>, PCWorkingColorVector *a2@<X8>)
{
  if (this)
  {
    PCCFRefTraits<CGColorSpace *>::retain(this);
    int v5 = this;
    PCCFRef<CGColorSpace *>::~PCCFRef(&v5);
  }
  else
  {
    PCWorkingColorVector::PCWorkingColorVector(a2);
  }
}

void sub_1B7699140(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PCColorSpaceHandle::PCColorSpaceHandle(PCColorSpaceHandle *this, CFStringRef name)
{
  *(void *)this = CGColorSpaceCreateWithName(name);
}

CGColorSpace **PCColorSpaceHandle::PCColorSpaceHandle(CGColorSpace **a1, CGColorSpace **a2)
{
  BOOL v3 = *a2;
  *a1 = *a2;
  if (v3) {
    PCCFRefTraits<CGColorSpace *>::retain(v3);
  }
  return a1;
}

CGColorSpace **PCColorSpaceHandle::setColorSpace(CGColorSpace **this, CGColorSpaceRef space)
{
  unint64_t v2 = space;
  if (space) {
    PCCFRefTraits<CGColorSpace *>::retain(space);
  }
  BOOL v7 = v2;
  int v4 = *this;
  if (*this) {
    BOOL v5 = v4 == v2;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    PCCFRefTraits<CGColorSpace *>::release(v4);
    unint64_t v2 = v7;
  }
  *this = v2;
  BOOL v7 = 0;
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v7);
}

void sub_1B769921C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

BOOL operator!=(void *a1)
{
  return *a1 != 0;
}

BOOL operator!=(void *a1, void *a2)
{
  return *a1 != *a2;
}

void anonymous namespace'::makeColorSpaceFromCacheKey(uint64_t a1@<X0>, CGColorSpace **a2@<X8>)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = *(void *)a1;
  int v30 = *(_DWORD *)(a1 + 8);
  int v4 = PCGetNCLCColorSpace((unsigned int *)&v29);
  BOOL v5 = v4;
  if (v4)
  {
    PCCFRefTraits<CGColorSpace *>::retain(v4);
    *a2 = v5;
  }
  else
  {
    if (!v8) {
      goto LABEL_10;
    }
    do
    {
      uint64_t v11 = (uint64_t *)(v8 + 8);
      if (!v10)
      {
        uint64_t v11 = (uint64_t *)v8;
        uint64_t v9 = v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
    {
LABEL_10:
      float v12 = *(float *)(a1 + 44);
      if (v12 != 0.0)
      {
        if (v12 == 1.0) {
          operator new();
        }
        operator new();
      }
      switch(*(_DWORD *)(a1 + 4))
      {
        case 0:
          operator new();
        case 1:
        case 7:
        case 0xE:
          operator new();
        case 2:
          operator new();
        case 8:
          operator new();
        case 0xD:
          operator new();
        case 0x11:
          operator new();
        default:
          PCMakeDisplayRGBProfile((float *)(a1 + 12), 0, (PCICCProfile *)&v29);
          long long v15 = *(_OWORD *)(a1 + 16);
          long long v24 = *(_OWORD *)a1;
          long long v25 = v15;
          long long v26 = *(_OWORD *)(a1 + 32);
          double v16 = *a2;
          float v27 = v16;
          if (v16) {
            PCCFRefTraits<CGColorSpace *>::retain(v16);
          }
          uint64_t v18 = (void *)(v14 + 8);
          uint64_t v17 = *(void *)(v14 + 8);
          if (v17)
          {
            do
            {
              while (1)
              {
                double v19 = (void *)v17;
                uint64_t v20 = (float *)(v17 + 32);
                  break;
                uint64_t v17 = *v19;
                uint64_t v18 = v19;
                if (!*v19) {
                  goto LABEL_30;
                }
              }
                goto LABEL_33;
              uint64_t v17 = v19[1];
            }
            while (v17);
            uint64_t v18 = v19 + 1;
          }
          else
          {
            double v19 = (void *)(v14 + 8);
          }
LABEL_30:
          uint64_t v21 = operator new(0x58uLL);
          long long v22 = v25;
          v21[2] = v24;
          v21[3] = v22;
          _DWORD v21[4] = v26;
          *((void *)v21 + 10) = v16;
          float v27 = 0;
          *(void *)uint64_t v21 = 0;
          *((void *)v21 + 1) = 0;
          *((void *)v21 + OZChannelFontBase::~OZChannelFontBase(this - 2) = v19;
          *uint64_t v18 = v21;
          uint64_t v23 = **(void **)v14;
          if (v23)
          {
            *(void *)uint64_t v14 = v23;
            uint64_t v21 = (_OWORD *)*v18;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v14 + 8), (uint64_t *)v21);
          ++*(void *)(v14 + 16);
          uint64_t v6 = (os_unfair_lock_s *)v28;
LABEL_33:
          PCCFRef<CGColorSpace *>::~PCCFRef(&v27);
          PCICCProfile::~PCICCProfile((PCICCProfile *)&v29);
          (*(void (**)(void))(MEMORY[0] + 8))(0);
          if (v6) {
            goto LABEL_34;
          }
          return;
      }
    }
    unint64_t v13 = *(CGColorSpace **)(v9 + 80);
    *a2 = v13;
    if (v13) {
      PCCFRefTraits<CGColorSpace *>::retain(v13);
    }
    if (v6) {
LABEL_34:
    }
      PCSpinLock::unlock(v6);
  }
}

void sub_1B7699674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  MEMORY[0x1BA9BFBA0](v9, 0x1081C409227ACB4);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void PCMakeColorSpaceFromNCLC(int a1@<W0>, int a2@<W1>, int a3@<W2>, CGColorSpace **a4@<X8>, float a5@<S0>)
{
  memset(v8, 0, sizeof(v8));
  v7[0] = a1;
  v7[1] = a2;
  v7[2] = a3;
  float v9 = a5;
}

__n128 anonymous namespace'::getChromaticities@<Q0>(int a1@<W0>, long long *a2@<X8>)
{
  switch(a1)
  {
    case 0:
    case 1:
      unint64_t v2 = &kPCChromaticities_ITU_R709_2;
      goto LABEL_9;
    case 2:
      unint64_t v2 = &kPCChromaticities_Generic;
      goto LABEL_9;
    case 5:
      unint64_t v2 = &kPCChromaticities_EBU_3213;
      goto LABEL_9;
    case 6:
      unint64_t v2 = &kPCChromaticities_SMPTE_C;
      goto LABEL_9;
    case 9:
      unint64_t v2 = &kPCChromaticities_ITU_R2020;
      goto LABEL_9;
    case 11:
      unint64_t v2 = &kPCChromaticities_DCI_P3;
      goto LABEL_9;
    case 12:
      unint64_t v2 = &kPCChromaticities_P3_D65;
LABEL_9:
      __n128 result = (__n128)*v2;
      long long v4 = v2[1];
      *a2 = *v2;
      a2[1] = v4;
      break;
    default:
      return result;
  }
  return result;
}

const void **anonymous namespace'::makeColorSpaceFromProfile@<X0>(_anonymous_namespace_ *this@<X0>, CGColorSpace **a2@<X8>)
{
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  ProfileData = (const UInt8 *)PCICCProfile::getProfileData(this);
  unsigned int Size = PCICCProfile::getSize((ProCore::Private **)this);
  CFDataRef v11 = CFDataCreate(v5, ProfileData, Size);
  uint64_t v8 = (CGColorSpace *)MEMORY[0x1BA9BE620]();
  float v9 = v8;
  if (v8) {
    PCCFRefTraits<CGColorSpace *>::retain(v8);
  }
  *a2 = v9;
  CGColorSpaceRelease(v9);
  return PCCFRef<__CTLine const*>::~PCCFRef((const void **)&v11);
}

void sub_1B7699964(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef(v2);
  PCCFRef<__CTLine const*>::~PCCFRef((const void **)va);
  _Unwind_Resume(a1);
}

void PCMakeColorSpaceFromProfile(const PCICCProfile *a1@<X0>, CGColorSpace **a2@<X8>)
{
  PCICCProfile::getMD5Hash(a1, &v13);
  long long v4 = (os_unfair_lock_s *)profileCacheLock;
  v12[1] = (const void *)profileCacheLock;
  PCSpinLock::lock((os_unfair_lock_t)profileCacheLock);
  CFAllocatorRef v5 = *(void **)profileCache;
  LOBYTE(v12[0]) = 0;
  PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::findValue(v5, (const PCHash128 *)&v13, v12, a2);
  if (*a2)
  {
    if (!v4) {
      return;
    }
LABEL_10:
    PCSpinLock::unlock(v4);
    return;
  }
  ProfileData = (const UInt8 *)PCICCProfile::getProfileData(a1);
  unsigned int Size = PCICCProfile::getSize((ProCore::Private **)a1);
  v12[0] = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ProfileData, Size);
  uint64_t v8 = (CGColorSpace *)MEMORY[0x1BA9BE630]();
  float v9 = v8;
  if (v8) {
    PCCFRefTraits<CGColorSpace *>::retain(v8);
  }
  CFDataRef v11 = v9;
  BOOL v10 = *a2;
  if (*a2)
  {
    if (v10 != v9)
    {
      PCCFRefTraits<CGColorSpace *>::release(v10);
      float v9 = v11;
    }
  }
  *a2 = v9;
  CFDataRef v11 = 0;
  PCCFRef<CGColorSpace *>::~PCCFRef(&v11);
  CGColorSpaceRelease(*a2);
  PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::addValue(*(void *)profileCache, (const PCHash128 *)&v13, a2, 0);
  PCCFRef<__CTLine const*>::~PCCFRef(v12);
  if (v4) {
    goto LABEL_10;
  }
}

void sub_1B7699AB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  long long v4 = va_arg(va1, CGColorSpace *);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, const void *);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<__CTLine const*>::~PCCFRef((const void **)va1);
  PCCFRef<CGColorSpace *>::~PCCFRef(v2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va2);
  _Unwind_Resume(a1);
}

os_unfair_lock_s **PCLockSentry<PCSpinLock>::~PCLockSentry(os_unfair_lock_s **a1)
{
  unint64_t v2 = *a1;
  if (v2) {
    PCSpinLock::unlock(v2);
  }
  return a1;
}

void ProCore::Private::initColorSpaceHandle(ProCore::Private *this)
{
}

void sub_1B7699D30(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::testColorSpaceEquivalence(CFTypeRef *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (CFEqual(*a1, a1[1])) {
    return 1;
  }
  PCICCProfile::PCICCProfile((PCICCProfile *)v5, (CGColorSpace *)*a1);
  PCICCProfile::PCICCProfile((PCICCProfile *)v4, (CGColorSpace *)a1[1]);
  BOOL v2 = PCSameColorTransform((const PCICCProfile *)v5, (const PCICCProfile *)v4);
  PCICCProfile::~PCICCProfile((PCICCProfile *)v4);
  PCICCProfile::~PCICCProfile((PCICCProfile *)v5);
  return v2;
}

void sub_1B7699E34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  if (a2)
  {
    PCICCProfile::~PCICCProfile((PCICCProfile *)&a10);
    PCICCProfile::~PCICCProfile((PCICCProfile *)&a38);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1B7699E04);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::getMD5FromProfile(PCWorkingColorVector *a1@<X8>)
{
}

BOOL std::less<anonymous namespace'::CacheKey>::operator()[abi:ne180100](float *a1, uint64_t a2)
{
  float v2 = *a1;
  if (*(_DWORD *)a1 < *(_DWORD *)a2) {
    return 1;
  }
  if (SLODWORD(v2) > *(_DWORD *)a2) {
    return 0;
  }
  int v5 = *((_DWORD *)a1 + 1);
  int v6 = *(_DWORD *)(a2 + 4);
  if (v5 < v6) {
    return 1;
  }
  if (v5 > v6) {
    return 0;
  }
  int v7 = *((_DWORD *)a1 + 2);
  int v8 = *(_DWORD *)(a2 + 8);
  if (v7 < v8) {
    return 1;
  }
  if (v7 > v8) {
    return 0;
  }
  if (LODWORD(v2) != 2)
  {
    if (v5 != 2) {
      return 0;
    }
    return a1[11] < *(float *)(a2 + 44);
  }
  float v9 = a1[3];
  float v10 = *(float *)(a2 + 12);
  if (v9 < v10) {
    return 1;
  }
  if (v9 > v10) {
    return 0;
  }
  float v11 = a1[4];
  float v12 = *(float *)(a2 + 16);
  if (v11 < v12) {
    return 1;
  }
  if (v11 > v12) {
    return 0;
  }
  float v13 = a1[5];
  float v14 = *(float *)(a2 + 20);
  if (v13 < v14) {
    return 1;
  }
  if (v13 > v14) {
    return 0;
  }
  float v15 = a1[6];
  float v16 = *(float *)(a2 + 24);
  if (v15 < v16) {
    return 1;
  }
  if (v15 > v16) {
    return 0;
  }
  float v17 = a1[7];
  float v18 = *(float *)(a2 + 28);
  if (v17 < v18) {
    return 1;
  }
  if (v17 > v18) {
    return 0;
  }
  float v19 = a1[8];
  float v20 = *(float *)(a2 + 32);
  if (v19 < v20) {
    return 1;
  }
  if (v19 > v20) {
    return 0;
  }
  float v21 = a1[9];
  float v22 = *(float *)(a2 + 36);
  if (v21 < v22) {
    return 1;
  }
  if (v21 > v22) {
    return 0;
  }
  float v23 = a1[10];
  float v24 = *(float *)(a2 + 40);
  if (v23 < v24) {
    return 1;
  }
  uint64_t v3 = 0;
  if (v5 == 2 && v23 <= v24) {
    return a1[11] < *(float *)(a2 + 44);
  }
  return v3;
}

void PCICCProfile::~PCICCProfile(PCICCProfile *this)
{
  float v2 = (void *)*((void *)this + 23);
  if (v2)
  {
    *((void *)this + 24) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void **)((char *)this + 152);
  std::vector<PCICCProfile::Tag>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v3 = (void **)((char *)this + 128);
  std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void std::vector<PCICCProfile::Tag>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  float v2 = *a1;
  if (*v2)
  {
    std::vector<PCICCProfile::Tag>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<PCICCProfile::Tag>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    long long v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
  a1[1] = v2;
}

void *std::function<BOOL ()(anonymous namespace'::EquivalenceKey const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<PCHash128 ()(PCColorSpaceHandle const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::findValue(void *a1@<X0>, unint64_t *a2@<X1>, unsigned char *a3@<X2>, PCWorkingColorVector *a4@<X8>)
{
  int v5 = (void *)a1[4];
  if (!v5) {
    goto LABEL_12;
  }
  unint64_t v6 = *a2;
  int v7 = a1 + 4;
  do
  {
    unint64_t v8 = v5[4];
    BOOL v9 = v8 >= v6;
    if (v8 >= v6) {
      float v10 = v5;
    }
    else {
      float v10 = v5 + 1;
    }
    if (v9) {
      int v7 = v5;
    }
    int v5 = (void *)*v10;
  }
  while (*v10);
  if (v7 != a1 + 4 && v6 >= v7[4])
  {
    float v12 = v7;
    *(_DWORD *)a4 = *((_DWORD *)v7 + 10);
    *((_DWORD *)a4 + 1) = *((_DWORD *)v7 + 11);
    *((_DWORD *)a4 + OZChannelFontBase::~OZChannelFontBase(this - 2) = *((_DWORD *)v7 + 12);
    *((_DWORD *)a4 + 3) = *((_DWORD *)v7 + 13);
    uint64_t v11 = a1[9] + 1;
    a1[9] = v11;
    v7[8] = v11;
    PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::bubble(a1 + 6, (uint64_t)&v12);
    *a3 = 1;
  }
  else
  {
LABEL_12:
    *a3 = 0;
    PCWorkingColorVector::PCWorkingColorVector(a4);
  }
}

uint64_t *PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::bubble(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1] - *result;
  unint64_t v4 = *(void *)(*(void *)a2 + 72);
  unint64_t v5 = (2 * v4) | 1;
  if (v5 >= v3 >> 3)
  {
LABEL_24:
    if (v4)
    {
      uint64_t v17 = *(void *)(v2 + 8 * v4);
      do
      {
        unint64_t v18 = v4 - 1;
        unint64_t v19 = (v4 - 1) >> 1;
        uint64_t v20 = *(void *)(v2 + 8 * v19);
        if (*(void *)(v20 + 64) <= *(void *)(v17 + 64)) {
          break;
        }
        *(void *)(v2 + 8 * v4) = v20;
        *(void *)(v2 + 8 * v19) = v17;
        uint64_t v2 = *result;
        *(void *)(*(void *)(*result + 8 * v4) + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v4;
        uint64_t v17 = *(void *)(v2 + 8 * v19);
        *(void *)(v17 + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v19;
        unint64_t v4 = (v4 - 1) >> 1;
      }
      while (v18 > 1);
    }
    return result;
  }
  char v6 = 0;
  unint64_t v7 = v3 >> 3;
  uint64_t v8 = 2 * v4;
  uint64_t v9 = *(void *)(v2 + 8 * v4);
  while (1)
  {
    unint64_t v10 = v8 + 2;
    unint64_t v11 = *(void *)(v9 + 64);
    BOOL v12 = v10 < v7 && v11 > *(void *)(*(void *)(v2 + 8 * v10) + 64);
    unint64_t v13 = *(void *)(*(void *)(v2 + 8 * v5) + 64);
    if (v11 <= v13 && !v12) {
      break;
    }
    BOOL v15 = v11 > v13 && v12;
    if (v12) {
      unint64_t v16 = v10;
    }
    else {
      unint64_t v16 = v5;
    }
    if (v15)
    {
      if (v13 <= *(void *)(*(void *)(v2 + 8 * v10) + 64)) {
        unint64_t v16 = v5;
      }
      else {
        unint64_t v16 = v10;
      }
    }
    *(void *)(v2 + 8 * v4) = *(void *)(v2 + 8 * v16);
    *(void *)(v2 + 8 * v16) = v9;
    uint64_t v2 = *result;
    *(void *)(*(void *)(*result + 8 * v4) + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v4;
    uint64_t v9 = *(void *)(v2 + 8 * v16);
    *(void *)(v9 + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v16;
    uint64_t v8 = 2 * v16;
    char v6 = 1;
    unint64_t v5 = (2 * v16) | 1;
    unint64_t v4 = v16;
    if (v5 >= v7) {
      return result;
    }
  }
  if ((v6 & 1) == 0)
  {
    unint64_t v4 = *(void *)(*(void *)a2 + 72);
    goto LABEL_24;
  }
  return result;
}

void PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::addValue(uint64_t a1, CGColorSpace **a2, _OWORD *a3, unint64_t a4)
{
  if (*(void *)(a1 + 88) >= a4 || *(void *)(a1 + 104))
  {
    uint64_t v6 = a1 + 32;
    unint64_t v7 = *(void **)(a1 + 32);
    uint64_t v8 = *a2;
    if (!v7) {
      goto LABEL_14;
    }
    uint64_t v9 = a1 + 32;
    do
    {
      unint64_t v10 = v7[4];
      BOOL v11 = v10 >= (unint64_t)v8;
      if (v10 >= (unint64_t)v8) {
        BOOL v12 = v7;
      }
      else {
        BOOL v12 = v7 + 1;
      }
      if (v11) {
        uint64_t v9 = (uint64_t)v7;
      }
      unint64_t v7 = (void *)*v12;
    }
    while (*v12);
    if (v9 != v6 && (unint64_t)v8 >= *(void *)(v9 + 32))
    {
      uint64_t v27 = v9;
      *(_OWORD *)(v9 + 40) = *a3;
      PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::update(a1, (uint64_t)&v27, a4);
    }
    else
    {
LABEL_14:
      uint64_t v13 = *(void *)(a1 + 72) + 1;
      *(void *)(a1 + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v13;
      long long v14 = *a3;
      float v21 = v8;
      if (v8)
      {
        long long v20 = v14;
        PCCFRefTraits<CGColorSpace *>::retain(v8);
        long long v14 = v20;
      }
      long long v22 = v14;
      unint64_t v23 = a4;
      uint64_t v24 = v13;
      uint64_t v25 = 0;
      v26[0] = (uint64_t)std::__tree<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__map_value_compare<std::tuple<PCColorSpaceHandle const>,std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::less<std::tuple<PCColorSpaceHandle const>>,true>,std::allocator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>>>::__emplace_unique_key_args<std::tuple<PCColorSpaceHandle const>,std::pair<std::tuple<PCColorSpaceHandle const> const,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>>(a1 + 24, (unint64_t *)&v21, (uint64_t)&v21);
      v26[1] = v15;
      PCCFRef<CGColorSpace *>::~PCCFRef(&v21);
      PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::add((void **)(a1 + 48), v26);
      unint64_t v16 = *(void *)(a1 + 80) + a4;
      *(void *)(a1 + 80) = v16;
      if (!*(void *)(a1 + 104))
      {
        while (v16 > *(void *)(a1 + 88) || *(void *)(a1 + 40) > *(void *)(a1 + 96))
        {
          unint64_t v19 = *(CGColorSpace ***)(a1 + 48);
          if (v19 == *(CGColorSpace ***)(a1 + 56)) {
            break;
          }
          float v21 = *v19;
          PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::remove((uint64_t *)(a1 + 48), (uint64_t)&v21);
          uint64_t v17 = (uint64_t *)v21;
          unint64_t v18 = (CGColorSpace **)((char *)v21 + 32);
          *(void *)(a1 + 80) -= *((void *)v21 + 7);
          std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v17);
          PCCFRef<CGColorSpace *>::~PCCFRef(v18);
          operator delete(v17);
          unint64_t v16 = *(void *)(a1 + 80);
        }
      }
    }
  }
}

void sub_1B769A568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::add(void **a1, uint64_t *a2)
{
  unint64_t v4 = (char *)*a1;
  unint64_t v5 = a1[1];
  uint64_t v6 = ((char *)v5 - (unsigned char *)*a1) >> 3;
  uint64_t v7 = *a2;
  *(void *)(*a2 + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v6;
  unint64_t v10 = (unint64_t)a1[2];
  uint64_t v8 = (uint64_t)(a1 + 2);
  unint64_t v9 = v10;
  if ((unint64_t)v5 >= v10)
  {
    if ((unint64_t)(v6 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v9 - (void)v4;
    uint64_t v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v6 + 1)) {
      uint64_t v13 = v6 + 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14)
    {
      unsigned __int8 v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8, v14);
      uint64_t v7 = *a2;
    }
    else
    {
      unsigned __int8 v15 = 0;
    }
    unint64_t v16 = &v15[8 * v6];
    uint64_t v17 = &v15[8 * v14];
    *(void *)unint64_t v16 = v7;
    BOOL v11 = v16 + 8;
    unint64_t v19 = (char *)*a1;
    unint64_t v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      unint64_t v18 = (char *)*a1;
    }
    *a1 = v16;
    a1[1] = v11;
    a1[2] = v17;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *unint64_t v5 = v7;
    BOOL v11 = v5 + 1;
  }
  a1[1] = v11;
  unint64_t v21 = *(void *)(*a2 + 72);
  if (v21)
  {
    long long v22 = (char *)*a1;
    uint64_t v23 = *((void *)*a1 + v21);
    do
    {
      unint64_t v24 = v21 - 1;
      unint64_t v25 = (v21 - 1) >> 1;
      uint64_t v26 = *(void *)&v22[8 * v25];
      if (*(void *)(v26 + 64) <= *(void *)(v23 + 64)) {
        break;
      }
      *(void *)&v22[8 * v21] = v26;
      *(void *)&v22[8 * v25] = v23;
      long long v22 = (char *)*a1;
      *(void *)(*((void *)*a1 + v21) + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v21;
      uint64_t v23 = *(void *)&v22[8 * v25];
      *(void *)(v23 + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v25;
      unint64_t v21 = (v21 - 1) >> 1;
    }
    while (v24 > 1);
  }
}

void PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::update(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 72) + 1;
  *(void *)(a1 + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v6;
  *(void *)(*(void *)a2 + 64) = v6;
  uint64_t v7 = (uint64_t *)(a1 + 48);
  PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::bubble((uint64_t *)(a1 + 48), a2);
  uint64_t v8 = *(void *)a2;
  uint64_t v9 = a3 - *(void *)(*(void *)a2 + 56);
  if (v9)
  {
    unint64_t v10 = v9 + *(void *)(a1 + 80);
    *(void *)(a1 + 80) = v10;
    *(void *)(v8 + 56) = a3;
    if (!*(void *)(a1 + 104))
    {
      while (v10 > *(void *)(a1 + 88) || *(void *)(a1 + 40) > *(void *)(a1 + 96))
      {
        BOOL v11 = *(uint64_t **)(a1 + 48);
        if (v11 == *(uint64_t **)(a1 + 56)) {
          break;
        }
        uint64_t v14 = *v11;
        PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::remove(v7, (uint64_t)&v14);
        uint64_t v12 = (uint64_t *)v14;
        uint64_t v13 = (CGColorSpace **)(v14 + 32);
        *(void *)(a1 + 80) -= *(void *)(v14 + 56);
        std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v12);
        PCCFRef<CGColorSpace *>::~PCCFRef(v13);
        operator delete(v12);
        unint64_t v10 = *(void *)(a1 + 80);
      }
    }
  }
}

uint64_t *std::__tree<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__map_value_compare<std::tuple<PCColorSpaceHandle const>,std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::less<std::tuple<PCColorSpaceHandle const>>,true>,std::allocator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>>>::__emplace_unique_key_args<std::tuple<PCColorSpaceHandle const>,std::pair<std::tuple<PCColorSpaceHandle const> const,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v5 = (uint64_t **)(a1 + 8);
  unint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    unint64_t v6 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v7 = v4;
        unint64_t v8 = v4[4];
        if (v6 >= v8) {
          break;
        }
        unint64_t v4 = (uint64_t *)*v7;
        unint64_t v5 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_10;
        }
      }
      if (v8 >= v6) {
        break;
      }
      unint64_t v4 = (uint64_t *)v7[1];
      if (!v4)
      {
        unint64_t v5 = (uint64_t **)(v7 + 1);
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v7 = (uint64_t *)(a1 + 8);
LABEL_10:
    std::__tree<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__map_value_compare<std::tuple<PCColorSpaceHandle const>,std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::less<std::tuple<PCColorSpaceHandle const>>,true>,std::allocator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>>>::__construct_node<std::pair<std::tuple<PCColorSpaceHandle const> const,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>>(a1, a3, (uint64_t)v10);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v7, v5, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *>>>>::reset[abi:ne180100]((uint64_t)v10, 0);
  }
  return v7;
}

uint64_t std::__tree<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__map_value_compare<std::tuple<PCColorSpaceHandle const>,std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::less<std::tuple<PCColorSpaceHandle const>>,true>,std::allocator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>>>::__construct_node<std::pair<std::tuple<PCColorSpaceHandle const> const,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  unint64_t v6 = operator new(0x50uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = std::pair<std::tuple<PCColorSpaceHandle const> const,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>::pair[abi:ne180100]((uint64_t)v6 + 32, a2);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1B769A8D0(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::tuple<PCColorSpaceHandle const> const,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>::pair[abi:ne180100](uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(CGColorSpace **)a2;
  *(void *)a1 = *(void *)a2;
  if (v4) {
    PCCFRefTraits<CGColorSpace *>::retain(v4);
  }
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  long long v5 = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = v5;
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(CGColorSpace ***)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      PCCFRef<CGColorSpace *>::~PCCFRef(v2 + 4);
    }
    operator delete(v2);
  }
}

void PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::remove(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(*(void *)a2 + 72);
  unint64_t v4 = ((a1[1] - *a1) >> 3) - 1;
  if (v3 == v4)
  {
    std::vector<std::__map_iterator<std::__tree_iterator<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,std::__tree_node<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,void *> *,long>>>::resize((uint64_t)a1, v3);
  }
  else
  {
    *(void *)(*a1 + 8 * v3) = *(void *)(*a1 + 8 * v4);
    *(void *)(*(void *)(*a1 + 8 * v3) + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v3;
    std::vector<std::__map_iterator<std::__tree_iterator<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,std::__tree_node<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,void *> *,long>>>::resize((uint64_t)a1, v4);
    uint64_t v5 = *a1 + 8 * v3;
    PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::bubble(a1, v5);
  }
}

void *PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::findValue@<X0>(void *a1@<X0>, const PCHash128 *a2@<X1>, unsigned char *a3@<X2>, CGColorSpace **a4@<X8>)
{
  uint64_t result = std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::find<PCHash128>((uint64_t)(a1 + 3), a2);
  BOOL v11 = result;
  if (a1 + 4 == result)
  {
    *a3 = 0;
    *a4 = 0;
  }
  else
  {
    unint64_t v8 = result;
    uint64_t v9 = (CGColorSpace *)result[6];
    *a4 = v9;
    if (v9) {
      PCCFRefTraits<CGColorSpace *>::retain(v9);
    }
    uint64_t v10 = a1[9] + 1;
    a1[9] = v10;
    v8[8] = v10;
    uint64_t result = PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::bubble(a1 + 6, (uint64_t)&v11);
    *a3 = 1;
  }
  return result;
}

void sub_1B769AAD8(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

void PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::addValue(uint64_t a1, const PCHash128 *a2, CGColorSpace **a3, unint64_t a4)
{
  if (*(void *)(a1 + 88) >= a4 || *(void *)(a1 + 104))
  {
    unint64_t v8 = (CGColorSpace **)std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::find<PCHash128>(a1 + 24, a2);
    unint64_t v24 = v8;
    if ((CGColorSpace **)(a1 + 32) == v8)
    {
      uint64_t v9 = *(void *)(a1 + 72) + 1;
      *(void *)(a1 + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v9;
      uint64_t v10 = *a3;
      unint64_t v21 = v10;
      if (v10) {
        PCCFRefTraits<CGColorSpace *>::retain(v10);
      }
      *(void *)&long long v22 = a4;
      *((void *)&v22 + 1) = v9;
      uint64_t v23 = 0;
      long long v16 = *(_OWORD *)a2;
      uint64_t v17 = v10;
      if (v10) {
        PCCFRefTraits<CGColorSpace *>::retain(v10);
      }
      long long v18 = v22;
      uint64_t v19 = v23;
      v20[0] = (uint64_t)std::__tree<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>>>::__emplace_unique_key_args<PCHash128,std::pair<PCHash128 const,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>>((uint64_t **)(a1 + 24), (const PCHash128 *)&v16, (uint64_t)&v16);
      v20[1] = v11;
      PCCFRef<CGColorSpace *>::~PCCFRef(&v17);
      PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::add((void **)(a1 + 48), v20);
      unint64_t v12 = *(void *)(a1 + 80) + a4;
      *(void *)(a1 + 80) = v12;
      if (!*(void *)(a1 + 104))
      {
        while (v12 > *(void *)(a1 + 88) || *(void *)(a1 + 40) > *(void *)(a1 + 96))
        {
          unsigned __int8 v15 = *(void **)(a1 + 48);
          if (v15 == *(void **)(a1 + 56)) {
            break;
          }
          *(void *)&long long v16 = *v15;
          PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::remove((uint64_t *)(a1 + 48), (uint64_t)&v16);
          uint64_t v13 = (uint64_t *)v16;
          uint64_t v14 = (CGColorSpace **)(v16 + 48);
          *(void *)(a1 + 80) -= *(void *)(v16 + 56);
          std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v13);
          PCCFRef<CGColorSpace *>::~PCCFRef(v14);
          operator delete(v13);
          unint64_t v12 = *(void *)(a1 + 80);
        }
      }
      PCCFRef<CGColorSpace *>::~PCCFRef(&v21);
    }
    else
    {
      PCCFRef<CGColorSpace *>::operator=(v8 + 6, a3);
      PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::update(a1, (uint64_t)&v24, a4);
    }
  }
}

void sub_1B769ACA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::update(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 72) + 1;
  *(void *)(a1 + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v6;
  *(void *)(*(void *)a2 + 64) = v6;
  uint64_t v7 = (uint64_t *)(a1 + 48);
  PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::bubble((uint64_t *)(a1 + 48), a2);
  uint64_t v8 = *(void *)a2;
  uint64_t v9 = a3 - *(void *)(*(void *)a2 + 56);
  if (v9)
  {
    unint64_t v10 = v9 + *(void *)(a1 + 80);
    *(void *)(a1 + 80) = v10;
    *(void *)(v8 + 56) = a3;
    if (!*(void *)(a1 + 104))
    {
      while (v10 > *(void *)(a1 + 88) || *(void *)(a1 + 40) > *(void *)(a1 + 96))
      {
        unsigned __int8 v11 = *(uint64_t **)(a1 + 48);
        if (v11 == *(uint64_t **)(a1 + 56)) {
          break;
        }
        uint64_t v14 = *v11;
        PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCColorSpaceHandle const>,PCCacheImpl<std::tuple<PCColorSpaceHandle const>,PCHash128,PCNoLock,std::less<std::tuple<PCColorSpaceHandle const>>>::Data>,void *> *,long>>>::remove(v7, (uint64_t)&v14);
        unint64_t v12 = (uint64_t *)v14;
        uint64_t v13 = (CGColorSpace **)(v14 + 48);
        *(void *)(a1 + 80) -= *(void *)(v14 + 56);
        std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v12);
        PCCFRef<CGColorSpace *>::~PCCFRef(v13);
        operator delete(v12);
        unint64_t v10 = *(void *)(a1 + 80);
      }
    }
  }
}

uint64_t *std::__tree<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>>>::__emplace_unique_key_args<PCHash128,std::pair<PCHash128 const,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>>(uint64_t **a1, const PCHash128 *a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t **)std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::__find_equal<PCHash128>((uint64_t)a1, &v10, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = v5;
    std::__tree<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>>>::__construct_node<std::pair<PCHash128 const,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>>((uint64_t)a1, a3, (uint64_t)v9);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v7, v9[0]);
    uint64_t v6 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,void *>>>>::reset[abi:ne180100]((uint64_t)v9, 0);
  }
  return v6;
}

uint64_t std::__tree<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>>>::__construct_node<std::pair<PCHash128 const,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x50uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = std::pair<PCHash128 const,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>::pair[abi:ne180100]((uint64_t)v6 + 32, a2);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1B769AEBC(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t std::pair<PCHash128 const,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>::pair[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_DWORD *)(a2 + 12);
  unint64_t v4 = *(CGColorSpace **)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    PCCFRefTraits<CGColorSpace *>::retain(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = v5;
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PCColorSpaceHandle,PCNoLock,std::less<PCHash128>>::Data>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(CGColorSpace ***)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      PCCFRef<CGColorSpace *>::~PCCFRef(v2 + 6);
    }
    operator delete(v2);
  }
}

void std::__function::__func<BOOL (*)(anonymous namespace'::EquivalenceKey const&),std::allocator<BOOL (*)(anonymous namespace'::EquivalenceKey const&)>,BOOL ()(anonymous namespace'::EquivalenceKey const&)>::~__func()
{
}

void *std::__function::__func<BOOL (*)(anonymous namespace'::EquivalenceKey const&),std::allocator<BOOL (*)(anonymous namespace'::EquivalenceKey const&)>,BOOL ()(anonymous namespace'::EquivalenceKey const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F10C35E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BOOL (*)(anonymous namespace'::EquivalenceKey const&),std::allocator<BOOL (*)(anonymous namespace'::EquivalenceKey const&)>,BOOL ()(anonymous namespace'::EquivalenceKey const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F10C35E0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<BOOL (*)(anonymous namespace'::EquivalenceKey const&),std::allocator<BOOL (*)(anonymous namespace'::EquivalenceKey const&)>,BOOL ()(anonymous namespace'::EquivalenceKey const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t std::__function::__func<BOOL (*)(anonymous namespace'::EquivalenceKey const&),std::allocator<BOOL (*)(anonymous namespace'::EquivalenceKey const&)>,BOOL ()(anonymous namespace'::EquivalenceKey const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL (*)(anonymous namespace'::EquivalenceKey const&),std::allocator<BOOL (*)(anonymous namespace'::EquivalenceKey const&)>,BOOL ()(anonymous namespace'::EquivalenceKey const&)>::target_type()
{
}

void PCCachedFunctionImpl<PCHash128,PCColorSpaceHandle const&>::PCCachedFunctionImpl<PCHash128 (*)(PCColorSpaceHandle const&)>(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0;
  if (a2)
  {
    *(void *)a1 = &unk_1F10C3690;
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 24) = a1;
  }
  *(_DWORD *)(a1 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = 0;
  operator new();
}

void sub_1B769B120(_Unwind_Exception *a1)
{
  PCSpinLock::~PCSpinLock(v2);
  std::__function::__value_func<PCHash128 ()(PCColorSpaceHandle const&)>::~__value_func[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<PCHash128 (*)(PCColorSpaceHandle const&),std::allocator<PCHash128 (*)(PCColorSpaceHandle const&)>,PCHash128 ()(PCColorSpaceHandle const&)>::~__func()
{
}

void *std::__function::__func<PCHash128 (*)(PCColorSpaceHandle const&),std::allocator<PCHash128 (*)(PCColorSpaceHandle const&)>,PCHash128 ()(PCColorSpaceHandle const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F10C3690;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<PCHash128 (*)(PCColorSpaceHandle const&),std::allocator<PCHash128 (*)(PCColorSpaceHandle const&)>,PCHash128 ()(PCColorSpaceHandle const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F10C3690;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<PCHash128 (*)(PCColorSpaceHandle const&),std::allocator<PCHash128 (*)(PCColorSpaceHandle const&)>,PCHash128 ()(PCColorSpaceHandle const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t std::__function::__func<PCHash128 (*)(PCColorSpaceHandle const&),std::allocator<PCHash128 (*)(PCColorSpaceHandle const&)>,PCHash128 ()(PCColorSpaceHandle const&)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<PCHash128 (*)(PCColorSpaceHandle const&),std::allocator<PCHash128 (*)(PCColorSpaceHandle const&)>,PCHash128 ()(PCColorSpaceHandle const&)>::target_type()
{
}

void PCToneMapMethod::PCToneMapMethod(PCToneMapMethod *this)
{
  PCColorUtil::getHLGDiffuseWhiteGain((PCColorUtil *)this);
  this->_type = 5;
  this->_gaiint n = v2;
}

float PCToneMapMethod::getGain(PCToneMapMethod *this)
{
  return this->_gain;
}

uint64_t PCHashToneMapMethod(uint64_t a1, unsigned int *a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 48))(a1, *a2);
  if (*a2 == 5)
  {
    v5.n128_u32[0] = a2[1];
    uint64_t v6 = *(uint64_t (**)(uint64_t, __n128))(*(void *)a1 + 80);
    return v6(a1, v5);
  }
  return result;
}

BOOL operator<(float *a1, uint64_t a2)
{
  float v2 = *a1;
  if (*(_DWORD *)a1 != *(_DWORD *)a2) {
    return SLODWORD(v2) < *(_DWORD *)a2;
  }
  if (LODWORD(v2) == 5) {
    return a1[1] < *(float *)(a2 + 4);
  }
  return 0;
}

uint64_t PCColorDescription::PCColorDescription(uint64_t a1, CGColorSpaceRef space, int a3, void *a4)
{
  if (space)
  {
    PCCFRefTraits<CGColorSpace *>::retain(space);
    uint64_t v9 = space;
    *(void *)a1 = space;
    PCCFRefTraits<CGColorSpace *>::retain(space);
  }
  else
  {
    uint64_t v9 = 0;
    *(void *)a1 = 0;
  }
  *(_DWORD *)(a1 + 8) = a3;
  *(void *)(a1 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = *a4;
  PCCFRef<CGColorSpace *>::~PCCFRef(&v9);
  return a1;
}

void sub_1B769B3B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

PCToneMapMethod *PCColorDescription::getToneMapMethod(PCColorDescription *this)
{
  return &this->_toneMapMethod;
}

void PCColorDescription::PCColorDescription(PCColorDescription *this, const PCColorDescription *a2, CGColorSpaceRef space)
{
  if (space)
  {
    PCCFRefTraits<CGColorSpace *>::retain(space);
    uint64_t v7 = space;
    int dynamicRange = a2->_dynamicRange;
    this->_colorSpaceRef._obint j = space;
    PCCFRefTraits<CGColorSpace *>::retain(space);
  }
  else
  {
    uint64_t v7 = 0;
    int dynamicRange = a2->_dynamicRange;
    this->_colorSpaceRef._obint j = 0;
  }
  this->_int dynamicRange = dynamicRange;
  this->_toneMapMethod = a2->_toneMapMethod;
  PCCFRef<CGColorSpace *>::~PCCFRef(&v7);
}

void sub_1B769B44C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

uint64_t PCColorDescription::PCColorDescription(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(CGColorSpace **)a2;
  *(void *)a1 = *(void *)a2;
  if (v6) {
    PCCFRefTraits<CGColorSpace *>::retain(v6);
  }
  *(_DWORD *)(a1 + 8) = a3;
  *(void *)(a1 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = *(void *)(a2 + 12);
  return a1;
}

void PCColorDescription::PCColorDescription(PCColorDescription *this, const PCColorDescription *a2, const PCToneMapMethod *a3)
{
  int dynamicRange = a2->_dynamicRange;
  obint j = a2->_colorSpaceRef._obj;
  this->_colorSpaceRef._obint j = a2->_colorSpaceRef._obj;
  if (obj) {
    PCCFRefTraits<CGColorSpace *>::retain(obj);
  }
  this->_int dynamicRange = dynamicRange;
  this->_toneMapMethod = *a3;
}

void PCColorDescription::PCColorDescription(PCColorDescription *this, CGColorSpaceRef space, PCToneMapMethod *a3)
{
  if (space) {
    PCCFRefTraits<CGColorSpace *>::retain(space);
  }
  uint64_t v6 = space;
  PCColorDescription::PCColorDescription((uint64_t)this, &v6, a3);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v6);
}

void sub_1B769B564(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

uint64_t PCColorDescription::PCColorDescription(uint64_t a1, CGColorSpace **a2, void *a3)
{
  BOOL v6 = PCIsHDRColorSpace(*a2);
  uint64_t v7 = *a2;
  *(void *)a1 = *a2;
  if (v7) {
    PCCFRefTraits<CGColorSpace *>::retain(v7);
  }
  *(_DWORD *)(a1 + 8) = v6;
  *(void *)(a1 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = *a3;
  return a1;
}

CGColorSpace **PCColorDescription::setCGColorSpace(PCColorDescription *this, CGColorSpaceRef space)
{
  float v2 = space;
  if (space) {
    PCCFRefTraits<CGColorSpace *>::retain(space);
  }
  uint64_t v7 = v2;
  obint j = this->_colorSpaceRef._obj;
  if (this->_colorSpaceRef._obj) {
    BOOL v5 = obj == v2;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    PCCFRefTraits<CGColorSpace *>::release(obj);
    float v2 = v7;
  }
  this->_colorSpaceRef._obint j = v2;
  uint64_t v7 = 0;
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v7);
}

void sub_1B769B638(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

PCColorDescription *PCColorDescription::setToneMapMethod(PCColorDescription *this, const PCToneMapMethod *a2)
{
  this->_toneMapMethod = *a2;
  return this;
}

BOOL PCColorDescription::isHDR(PCColorDescription *this)
{
  return this->_dynamicRange == 1 && this->_colorSpaceRef._obj && this->_toneMapMethod._type != 0;
}

BOOL PCColorDescription::isDynamicRangeManaged(PCColorDescription *this)
{
  return this->_colorSpaceRef._obj && this->_toneMapMethod._type != 0;
}

BOOL PCColorDescription::isSDR(PCColorDescription *this)
{
  return !this->_dynamicRange && this->_colorSpaceRef._obj && this->_toneMapMethod._type != 0;
}

BOOL PCColorDescriptionCanToneMap(const PCColorDescription *a1)
{
  return a1->_toneMapMethod._type != 0;
}

uint64_t PCHashColorDescription(int8x8_t *a1, const PCColorDescription *a2)
{
  PCColorSpaceHandle::getMD5(a2->_colorSpaceRef._obj, (PCWorkingColorVector *)v5);
  PCHashWriteStream::writeValue(a1, (const PCHash128 *)v5);
  (*(void (**)(int8x8_t *, void))(*(void *)a1 + 48))(a1, a2->_dynamicRange);
  return PCHashToneMapMethod((uint64_t)a1, (unsigned int *)&a2->_toneMapMethod);
}

BOOL operator==(uint64_t a1, uint64_t a2, CGColorSpace *a3)
{
  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && (int v3 = *(_DWORD *)(a1 + 12), v3 == *(_DWORD *)(a2 + 12))
    && (v3 != 5 || *(float *)(a1 + 16) == *(float *)(a2 + 16)))
  {
    return PCColorSpaceHandle::isSameColorSpace(*(CGColorSpaceRef *)a1, *(CGColorSpace **)a2, a3);
  }
  else
  {
    return 0;
  }
}

{
  return (*(unsigned char *)(a1 + 24) != 0) == (*(unsigned char *)(a2 + 24) != 0) && operator==(a1, a2, a3);
}

void ProCore::Private::initColorSpaceCache(ProCore::Private *this)
{
}

uint64_t PCColorSpaceCache::identifyColorSpace(PCColorSpaceCache *this, CGColorSpace *a2)
{
  uint64_t v3 = 1;
  CGColorSpaceByID = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)1);
  if (!PCColorSpaceHandle::isSameColorSpace(this, CGColorSpaceByID, v5))
  {
    uint64_t v3 = 4;
    BOOL v6 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)4);
    if (!PCColorSpaceHandle::isSameColorSpace(this, v6, v7))
    {
      uint64_t v3 = 10;
      uint64_t v8 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0xA);
      if (!PCColorSpaceHandle::isSameColorSpace(this, v8, v9))
      {
        uint64_t v3 = 9;
        uint64_t v10 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)9);
        if (!PCColorSpaceHandle::isSameColorSpace(this, v10, v11))
        {
          uint64_t v3 = 18;
          unint64_t v12 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0x12);
          if (!PCColorSpaceHandle::isSameColorSpace(this, v12, v13))
          {
            uint64_t v3 = 17;
            uint64_t v14 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0x11);
            if (!PCColorSpaceHandle::isSameColorSpace(this, v14, v15))
            {
              uint64_t v3 = 3;
              long long v16 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)3);
              if (!PCColorSpaceHandle::isSameColorSpace(this, v16, v17))
              {
                uint64_t v3 = 12;
                long long v18 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0xC);
                if (!PCColorSpaceHandle::isSameColorSpace(this, v18, v19))
                {
                  uint64_t v3 = 5;
                  uint64_t v20 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)5);
                  if (!PCColorSpaceHandle::isSameColorSpace(this, v20, v21))
                  {
                    uint64_t v3 = 6;
                    long long v22 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)6);
                    if (!PCColorSpaceHandle::isSameColorSpace(this, v22, v23))
                    {
                      uint64_t v3 = 11;
                      unint64_t v24 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0xB);
                      if (!PCColorSpaceHandle::isSameColorSpace(this, v24, v25))
                      {
                        uint64_t v3 = 13;
                        uint64_t v26 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0xD);
                        if (!PCColorSpaceHandle::isSameColorSpace(this, v26, v27))
                        {
                          uint64_t v3 = 19;
                          uint64_t v28 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0x13);
                          if (!PCColorSpaceHandle::isSameColorSpace(this, v28, v29))
                          {
                            uint64_t v3 = 20;
                            int v30 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0x14);
                            if (!PCColorSpaceHandle::isSameColorSpace(this, v30, v31))
                            {
                              uint64_t v3 = 21;
                              int v32 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0x15);
                              if (!PCColorSpaceHandle::isSameColorSpace(this, v32, v33))
                              {
                                uint64_t v3 = 7;
                                int v34 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)7);
                                if (!PCColorSpaceHandle::isSameColorSpace(this, v34, v35))
                                {
                                  uint64_t v3 = 8;
                                  int v36 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)8);
                                  if (!PCColorSpaceHandle::isSameColorSpace(this, v36, v37))
                                  {
                                    uint64_t v3 = 14;
                                    long long v38 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0xE);
                                    if (!PCColorSpaceHandle::isSameColorSpace(this, v38, v39))
                                    {
                                      uint64_t v3 = 2;
                                      int v40 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)2);
                                      if (!PCColorSpaceHandle::isSameColorSpace(this, v40, v41))
                                      {
                                        double v42 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID(0);
                                        uint64_t v3 = 0;
                                        if (!PCColorSpaceHandle::isSameColorSpace(this, v42, v43))
                                        {
                                          uint64_t v3 = 15;
                                          int v44 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0xF);
                                          if (!PCColorSpaceHandle::isSameColorSpace(this, v44, v45))
                                          {
                                            int v46 = (CGColorSpace *)PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0x10);
                                            if (PCColorSpaceHandle::isSameColorSpace(this, v46, v47)) {
                                              return 16;
                                            }
                                            else {
                                              return 0xFFFFFFFFLL;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v3;
}

uint64_t PCColorSpaceCache::cgRec709Linear(PCColorSpaceCache *this)
{
  return PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)1);
}

uint64_t PCColorSpaceCache::cgRec709(PCColorSpaceCache *this)
{
  return PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)4);
}

uint64_t PCColorSpaceCache::cgRec2020Linear(PCColorSpaceCache *this)
{
  return PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0xA);
}

uint64_t PCColorSpaceCache::cgsRGB(PCColorSpaceCache *this)
{
  return PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)3);
}

uint64_t PCColorSpaceCache::cgGenericRGB(PCColorSpaceCache *this)
{
  return PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)2);
}

uint64_t PCColorSpaceCache::cgLinearGray(PCColorSpaceCache *this)
{
  return PCColorSpaceCache::getCGColorSpaceByID((CGColorSpace **)0xF);
}

uint64_t PCColorSpaceCache::intToColorSpaceID(uint64_t result, unsigned int a2)
{
  if ((result - 22) >= 0xFFFFFFE9) {
    return result;
  }
  else {
    return a2;
  }
}

uint64_t PCColorSpaceCache::getCGColorSpaceByID(CGColorSpace **a1)
{
  PCInit();
  if (a1 == -1) {
    return 0;
  }
  uint64_t CGColorSpace = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)v5);
  PCCFRef<CGColorSpace *>::~PCCFRef(v5);
  if (v2) {
    PCSpinLock::unlock(v2);
  }
  return CGColorSpace;
}

void sub_1B769BB90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGColorSpace *a9, os_unfair_lock_s *a10)
{
}

CGColorSpace **anonymous namespace'::lookUpColorSpace@<X0>(CGColorSpace **result@<X0>, CGColorSpace **a2@<X8>)
{
  v21[27] = *(CGColorSpace **)MEMORY[0x1E4F143B8];
  if (result == -1)
  {
    *a2 = 0;
  }
  else
  {
    int v3 = (int)result;
    if (!v4) {
      goto LABEL_12;
    }
    do
    {
      int v6 = *(_DWORD *)(v4 + 32);
      BOOL v7 = v6 < (int)result;
      if (v6 >= (int)result) {
        uint64_t v8 = (uint64_t *)v4;
      }
      else {
        uint64_t v8 = (uint64_t *)(v4 + 8);
      }
      if (!v7) {
        uint64_t v5 = v4;
      }
      uint64_t v4 = *v8;
    }
    while (*v8);
    {
      unint64_t v12 = *(CGColorSpace **)(v5 + 40);
      *a2 = v12;
      if (v12) {
        PCCFRefTraits<CGColorSpace *>::retain(v12);
      }
    }
    else
    {
LABEL_12:
      *a2 = 0;
    }
    uint64_t result = (CGColorSpace **)operator==(a2);
    if (result)
    {
      uint64_t v9 = (CFStringRef *)MEMORY[0x1E4F1DB70];
      int v10 = 6;
      unsigned __int8 v11 = (uint64_t *)&kPCNCLC_Rec709Linear;
      switch(v3)
      {
        case 1:
          goto LABEL_39;
        case 3:
          unsigned __int8 v11 = (uint64_t *)&kPCNCLC_sRGB;
          goto LABEL_39;
        case 4:
          unsigned __int8 v11 = &kPCNCLC_Rec709;
          goto LABEL_39;
        case 5:
          goto LABEL_30;
        case 6:
          int v10 = 5;
LABEL_30:
          PCMakeColorSpaceFromNCLC(v10, 1, 6, &v18, 0.0);
          break;
        case 7:
          goto LABEL_25;
        case 8:
          PCICCTransferFunctionParametric0::PCICCTransferFunctionParametric0((PCICCTransferFunctionParametric0 *)v19, 1.961);
          PCMakeDisplayRGBProfile((float *)&kPCChromaticities_ACEScg, (uint64_t)v19, (PCICCProfile *)&v20);
          PCMakeColorSpaceFromProfile((const PCICCProfile *)&v20, &v18);
          PCICCProfile::~PCICCProfile((PCICCProfile *)&v20);
          PCICCTransferFunctionParametric0::~PCICCTransferFunctionParametric0((PCICCTransferFunctionParametric0 *)v19);
          break;
        case 9:
          unsigned __int8 v11 = &kPCNCLC_Rec2020;
          goto LABEL_39;
        case 10:
          unsigned __int8 v11 = &kPCNCLC_Rec2020Linear;
          goto LABEL_39;
        case 11:
          unsigned __int8 v11 = (uint64_t *)&kPCNCLC_DCI_P3;
          goto LABEL_39;
        case 12:
          unsigned __int8 v11 = (uint64_t *)&kPCNCLC_P3_D65;
          goto LABEL_39;
        case 13:
          unsigned __int8 v11 = (uint64_t *)&kPCNCLC_P3_D65Linear;
          goto LABEL_39;
        case 14:
          uint64_t v9 = (CFStringRef *)MEMORY[0x1E4F1DB78];
LABEL_25:
          PCColorSpaceHandle::PCColorSpaceHandle((PCColorSpaceHandle *)&v18, *v9);
          break;
        case 15:
          PCMakeDisplayGrayProfile(0.3127, 0.329, 1.0, (PCICCProfile *)&v20);
          PCMakeColorSpaceFromProfile((const PCICCProfile *)&v20, &v18);
          goto LABEL_35;
        case 16:
          PCMakeDisplayGrayProfile(0.3127, 0.329, 2.2, (PCICCProfile *)&v20);
          PCMakeColorSpaceFromProfile((const PCICCProfile *)&v20, &v18);
LABEL_35:
          PCICCProfile::~PCICCProfile((PCICCProfile *)&v20);
          break;
        case 17:
          unsigned __int8 v11 = (uint64_t *)&kPCNCLC_Rec2020HLG;
          goto LABEL_39;
        case 18:
          unsigned __int8 v11 = (uint64_t *)&kPCNCLC_Rec2020PQ;
          goto LABEL_39;
        case 19:
          unsigned __int8 v11 = (uint64_t *)&kPCNCLC_P3_D65PQ;
          goto LABEL_39;
        case 20:
          unsigned __int8 v11 = (uint64_t *)&kPCNCLC_P3_D65HLG;
          goto LABEL_39;
        case 21:
          unsigned __int8 v11 = (uint64_t *)&kPCNCLC_DCI_P3PQ;
LABEL_39:
          uint64_t v13 = PCGetNCLCColorSpace((unsigned int *)v11);
          PCColorSpaceHandle::PCColorSpaceHandle((PCColorSpaceHandle *)&v18, v13);
          break;
        default:
          break;
      }
      uint64_t v14 = *a2;
      unsigned __int8 v15 = v18;
      if (*a2 && v14 != v18)
      {
        PCCFRefTraits<CGColorSpace *>::release(v14);
        unsigned __int8 v15 = v18;
      }
      *a2 = v15;
      long long v18 = 0;
      PCCFRef<CGColorSpace *>::~PCCFRef(&v18);
      int v20 = v3;
      uint64_t v17 = *a2;
      v21[0] = v17;
      if (v17) {
        PCCFRefTraits<CGColorSpace *>::retain(v17);
      }
      std::__tree<std::__value_type<PCColorSpaceCache::ID,PCColorSpaceHandle>,std::__map_value_compare<PCColorSpaceCache::ID,std::__value_type<PCColorSpaceCache::ID,PCColorSpaceHandle>,std::less<PCColorSpaceCache::ID>,true>,std::allocator<std::__value_type<PCColorSpaceCache::ID,PCColorSpaceHandle>>>::__emplace_unique_key_args<PCColorSpaceCache::ID,std::pair<PCColorSpaceCache::ID const,PCColorSpaceHandle>>(v16, &v20, (uint64_t)&v20);
      return PCCFRef<CGColorSpace *>::~PCCFRef(v21);
    }
  }
  return result;
}

void sub_1B769BEDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PCICCProfile::~PCICCProfile((PCICCProfile *)va);
  PCCFRef<CGColorSpace *>::~PCCFRef(v4);
  _Unwind_Resume(a1);
}

void PCColorSpaceCache::getColorSpaceByID(CGColorSpace **a1@<X0>, CGColorSpace **a2@<X8>)
{
  if (v4) {
    PCSpinLock::unlock(v4);
  }
}

void sub_1B769C004(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void PCColorSpaceCache::rec709Linear(CGColorSpace **a1@<X8>)
{
}

void PCColorSpaceCache::sRGB(CGColorSpace **a1@<X8>)
{
}

void PCColorSpaceCache::linearGray(CGColorSpace **a1@<X8>)
{
}

void PCColorSpaceCache::gamma22Gray(CGColorSpace **a1@<X8>)
{
}

void PCGetCachedExtendedRangeColorSpace(CGColorSpaceRef *a1@<X0>, CGColorSpace **a2@<X8>)
{
  if (CGColorSpaceUsesExtendedRange(*a1))
  {
    uint64_t v4 = *a1;
    *a2 = *a1;
    if (v4)
    {
      PCCFRefTraits<CGColorSpace *>::retain(v4);
    }
    return;
  }
  unint64_t v61 = PCGetNCLCCodeForColorSpace(*a1);
  int v62 = v5;
  CFTypeRef cf = (CFTypeRef)0x200000002;
  LODWORD(space) = 2;
  if (operator!=(&v61, &cf))
  {
    int v6 = PCGetNCLCColorSpace((unsigned int *)&v61, 1);
    BOOL v7 = v6;
    if (v6) {
      PCCFRefTraits<CGColorSpace *>::retain(v6);
    }
    *a2 = v7;
    return;
  }
  {
    operator new();
  }
  uint64_t v8 = (void *)getExtendedColorSpaceCache(void)::cache;
  {
    operator new();
  }
  uint64_t v9 = (PCMutex *)getExtendedColorSpaceLock(void)::mutex;
  uint64_t v60 = getExtendedColorSpaceLock(void)::mutex;
  PCMutex::lock((PCMutex *)getExtendedColorSpaceLock(void)::mutex);
  int v10 = (void *)*v8;
  unint64_t v12 = v11;
  CFTypeRef cf = v11;
  if (v10 + 4 == v11)
  {
    *a2 = 0;
  }
  else
  {
    uint64_t v13 = (CGColorSpace *)v11[5];
    *a2 = v13;
    if (v13) {
      PCCFRefTraits<CGColorSpace *>::retain(v13);
    }
    uint64_t v14 = v10[9] + 1;
    v10[9] = v14;
    v12[7] = v14;
    if (*a2)
    {
LABEL_24:
      if (!v9) {
        return;
      }
      goto LABEL_75;
    }
  }
  PCCreateExtendedColorSpace(a1, (CGColorSpaceRef *)&cf);
  unsigned __int8 v15 = *a2;
  long long v16 = (CGColorSpace *)cf;
  if (*a2 && v15 != cf)
  {
    PCCFRefTraits<CGColorSpace *>::release(v15);
    long long v16 = (CGColorSpace *)cf;
  }
  *a2 = v16;
  CFTypeRef cf = 0;
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&cf);
  uint64_t v17 = (void *)*v8;
  long long v18 = (void **)(*v8 + 24);
  uint64_t v20 = v19;
  uint64_t v70 = v19;
  if (v17 + 4 != (void *)v19)
  {
    PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)(v19 + 40), a2);
    uint64_t v21 = v17[9] + 1;
    v17[9] = v21;
    *(void *)(v20 + 56) = v21;
    uint64_t v22 = *(void *)(v20 + 48);
    if (v22)
    {
      v17[10] -= v22;
      *(void *)(v20 + 48) = 0;
    }
    goto LABEL_24;
  }
  uint64_t v23 = v17[9] + 1;
  v17[9] = v23;
  unint64_t v24 = *a2;
  uint64_t v67 = v24;
  if (v24) {
    PCCFRefTraits<CGColorSpace *>::retain(v24);
  }
  *(void *)&long long v68 = 0;
  *((void *)&v68 + 1) = v23;
  uint64_t v69 = 0;
  CGColorSpaceRef v25 = *a1;
  CFTypeRef cf = v25;
  if (v25)
  {
    PCCFRefTraits<CGColorSpace *>::retain(v25);
    unint64_t v24 = v67;
  }
  CGColorSpaceRef space = v24;
  if (v24) {
    PCCFRefTraits<CGColorSpace *>::retain(v24);
  }
  long long v65 = v68;
  uint64_t v66 = v69;
  uint64_t v26 = *(uint64_t **)v20;
  uint64_t v27 = (CGColorSpace *)cf;
  uint64_t v28 = (uint64_t **)v20;
  if (!*(void *)v20)
  {
    uint64_t v29 = (uint64_t *)v20;
LABEL_44:
    long long v38 = operator new(0x48uLL);
    v71[0] = v38;
    v71[1] = v20;
    char v72 = 0;
    v38[4] = v27;
    if (v27) {
      PCCFRefTraits<CGColorSpace *>::retain(v27);
    }
    uint64_t v39 = space;
    v38[5] = space;
    if (v39) {
      PCCFRefTraits<CGColorSpace *>::retain(v39);
    }
    v38[8] = v66;
    *((_OWORD *)v38 + 3) = v65;
    char v72 = 1;
    int v40 = (uint64_t *)v71[0];
    *(void *)v71[0] = 0;
    v40[1] = 0;
    v40[2] = (uint64_t)v29;
    *uint64_t v28 = v40;
    uint64_t v41 = (void *)**v18;
    if (v41)
    {
      *long long v18 = v41;
      int v40 = *v28;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)v20, v40);
    ++v17[5];
    double v42 = (uint64_t *)v71[0];
    v71[0] = 0;
    goto LABEL_51;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v29 = v26;
      CFHashCode v30 = CFHash(v27);
      CFHashCode v31 = CFHash((CFTypeRef)v29[4]);
      uint64_t v27 = (CGColorSpace *)cf;
      CFTypeRef v32 = (CFTypeRef)v29[4];
      BOOL v33 = v30 == v31;
      BOOL v34 = v30 < v31;
      if (v33) {
        BOOL v34 = cf < v32;
      }
      if (!v34) {
        break;
      }
      uint64_t v26 = (uint64_t *)*v29;
      uint64_t v28 = (uint64_t **)v29;
      if (!*v29) {
        goto LABEL_44;
      }
    }
    CFHashCode v35 = CFHash(v32);
    CFHashCode v36 = CFHash(cf);
    uint64_t v27 = (CGColorSpace *)cf;
    BOOL v37 = v29[4] < (unint64_t)cf;
    if (v35 != v36) {
      BOOL v37 = v35 < v36;
    }
    if (!v37) {
      break;
    }
    uint64_t v28 = (uint64_t **)(v29 + 1);
    uint64_t v26 = (uint64_t *)v29[1];
    if (!v26) {
      goto LABEL_44;
    }
  }
  double v42 = *v28;
  if (!*v28) {
    goto LABEL_44;
  }
LABEL_51:
  PCCFRef<CGColorSpace *>::~PCCFRef(&space);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&cf);
  int v44 = (void *)v17[6];
  uint64_t v43 = (uint64_t **)v17[7];
  uint64_t v45 = v43 - (uint64_t **)v44;
  v42[8] = v45;
  unint64_t v46 = v17[8];
  if ((unint64_t)v43 >= v46)
  {
    unint64_t v48 = v45 + 1;
    if ((unint64_t)(v45 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v49 = v46 - (void)v44;
    if (v49 >> 2 > v48) {
      unint64_t v48 = v49 >> 2;
    }
    if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v50 = v48;
    }
    if (v50)
    {
      if (v50 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v51 = (char *)operator new(8 * v50);
    }
    else
    {
      uint64_t v51 = 0;
    }
    int v52 = (uint64_t **)&v51[8 * v45];
    *int v52 = v42;
    uint64_t v47 = v52 + 1;
    if (v43 != v44)
    {
      do
      {
        uint64_t v53 = *--v43;
        *--int v52 = v53;
      }
      while (v43 != v44);
      uint64_t v43 = (uint64_t **)v17[6];
    }
    v17[6] = v52;
    v17[7] = v47;
    v17[8] = &v51[8 * v50];
    if (v43) {
      operator delete(v43);
    }
  }
  else
  {
    *uint64_t v43 = v42;
    uint64_t v47 = v43 + 1;
  }
  v17[7] = v47;
  unint64_t v54 = v42[8];
  if (v54)
  {
    uint64_t v55 = v17[6];
    uint64_t v56 = *(void *)(v55 + 8 * v54);
    do
    {
      unint64_t v57 = v54 - 1;
      unint64_t v58 = (v54 - 1) >> 1;
      uint64_t v59 = *(void *)(v55 + 8 * v58);
      if (*(void *)(v59 + 56) <= *(void *)(v56 + 56)) {
        break;
      }
      *(void *)(v55 + 8 * v54) = v59;
      *(void *)(v55 + 8 * v58) = v56;
      uint64_t v55 = v17[6];
      *(void *)(*(void *)(v55 + 8 * v54) + 64) = v54;
      uint64_t v56 = *(void *)(v55 + 8 * v58);
      *(void *)(v56 + 64) = v58;
      unint64_t v54 = (v54 - 1) >> 1;
    }
    while (v57 > 1);
  }
  PCCFRef<CGColorSpace *>::~PCCFRef(&v67);
  uint64_t v9 = (PCMutex *)v60;
  if (v60) {
LABEL_75:
  }
    PCMutex::unlock(v9);
}

void sub_1B769C654(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

uint64_t PCLockSentry<PCMutex>::~PCLockSentry(uint64_t a1)
{
  float v2 = *(PCMutex **)a1;
  if (v2 && *(unsigned char *)(a1 + 8))
  {
    PCMutex::unlock(v2);
    *(unsigned char *)(a1 + 8) = 0;
  }
  return a1;
}

CGColorSpace **PCGetCachedExtendedRangeColorSpace@<X0>(CGColorSpaceRef space@<X0>, CGColorSpace **a2@<X8>)
{
  if (space) {
    PCCFRefTraits<CGColorSpace *>::retain(space);
  }
  int v5 = space;
  PCGetCachedExtendedRangeColorSpace(&v5, a2);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v5);
}

void sub_1B769C7D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void anonymous namespace'::makeDeviceRGBColorSpace(PCColorSpaceHandle *a1@<X8>)
{
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  PCColorSpaceHandle::PCColorSpaceHandle(a1, DeviceRGB);
  CGColorSpaceRelease(DeviceRGB);
}

void sub_1B769C828(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<PCColorSpaceCache::ID,PCColorSpaceHandle>,std::__map_value_compare<PCColorSpaceCache::ID,std::__value_type<PCColorSpaceCache::ID,PCColorSpaceHandle>,std::less<PCColorSpaceCache::ID>,true>,std::allocator<std::__value_type<PCColorSpaceCache::ID,PCColorSpaceHandle>>>::__emplace_unique_key_args<PCColorSpaceCache::ID,std::pair<PCColorSpaceCache::ID const,PCColorSpaceHandle>>(uint64_t **a1, int *a2, uint64_t a3)
{
  int v6 = a1 + 1;
  int v5 = a1[1];
  BOOL v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (v5)
  {
    int v9 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        int v10 = *((_DWORD *)v5 + 8);
        if (v9 >= v10) {
          break;
        }
        int v5 = *v8;
        BOOL v7 = v8;
        if (!*v8) {
          goto LABEL_9;
        }
      }
      if (v10 >= v9) {
        break;
      }
      int v5 = v8[1];
      if (!v5)
      {
        BOOL v7 = v8 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    unsigned __int8 v11 = operator new(0x30uLL);
    v13[1] = v6;
    v11[8] = *(_DWORD *)a3;
    *((void *)v11 + 5) = *(void *)(a3 + 8);
    *(void *)(a3 + 8) = 0;
    char v14 = 1;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, (uint64_t)v8, v7, (uint64_t *)v11);
    v13[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<PCColorSpaceCache::ID,PCColorSpaceHandle>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<PCColorSpaceCache::ID,PCColorSpaceHandle>,void *>>>>::reset[abi:ne180100]((uint64_t)v13, 0);
    return (uint64_t **)v11;
  }
  return v8;
}

void std::unique_ptr<std::__tree_node<std::__value_type<PCColorSpaceCache::ID,PCColorSpaceHandle>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<PCColorSpaceCache::ID,PCColorSpaceHandle>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  float v2 = *(CGColorSpace ***)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      PCCFRef<CGColorSpace *>::~PCCFRef(v2 + 5);
    }
    operator delete(v2);
  }
}

uint64_t std::map<PCCFRef<CGColorSpace *>,PCCacheImpl<PCCFRef<CGColorSpace *>,PCCFRef<CGColorSpace *>,PCNoLock,anonymous namespace'::CompareColorSpaceRef>::Data,anonymous namespace'::CompareColorSpaceRef,std::allocator<std::pair<PCCFRef<CGColorSpace *> const,PCCacheImpl<PCCFRef<CGColorSpace *>,PCCFRef<CGColorSpace *>,PCNoLock,anonymous namespace'::CompareColorSpaceRef>::Data>>>::find[abi:ne180100](uint64_t a1, CFTypeRef *a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    CFHashCode v6 = CFHash(*(CFTypeRef *)(v3 + 32));
    CFHashCode v7 = CFHash(*a2);
    BOOL v9 = v6 == v7;
    BOOL v8 = v6 < v7;
    if (v9) {
      BOOL v8 = *(void *)(v3 + 32) < (unint64_t)*a2;
    }
    BOOL v9 = !v8;
    if (v8) {
      int v10 = (uint64_t *)(v3 + 8);
    }
    else {
      int v10 = (uint64_t *)v3;
    }
    if (v9) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v10;
  }
  while (*v10);
  if (v5 == v2) {
    return v2;
  }
  CFHashCode v11 = CFHash(*a2);
  CFHashCode v12 = CFHash(*(CFTypeRef *)(v5 + 32));
  BOOL v13 = (unint64_t)*a2 < *(void *)(v5 + 32);
  if (v11 != v12) {
    BOOL v13 = v11 < v12;
  }
  if (v13) {
    return v2;
  }
  return v5;
}

uint64_t *PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCCFRef<CGColorSpace *>,PCCacheImpl<PCCFRef<CGColorSpace *>,PCCFRef<CGColorSpace *>,PCNoLock,anonymous namespace'::CompareColorSpaceRef>::Data>,std::__tree_node<std::__value_type<PCCFRef<CGColorSpace *>,PCCacheImpl<PCCFRef<CGColorSpace *>,PCCFRef<CGColorSpace *>,PCNoLock,anonymous namespace'::CompareColorSpaceRef>::Data>,void *> *,long>>>::bubble(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1] - *result;
  unint64_t v4 = *(void *)(*(void *)a2 + 64);
  unint64_t v5 = (2 * v4) | 1;
  if (v5 >= v3 >> 3)
  {
LABEL_24:
    if (v4)
    {
      uint64_t v17 = *(void *)(v2 + 8 * v4);
      do
      {
        unint64_t v18 = v4 - 1;
        unint64_t v19 = (v4 - 1) >> 1;
        uint64_t v20 = *(void *)(v2 + 8 * v19);
        if (*(void *)(v20 + 56) <= *(void *)(v17 + 56)) {
          break;
        }
        *(void *)(v2 + 8 * v4) = v20;
        *(void *)(v2 + 8 * v19) = v17;
        uint64_t v2 = *result;
        *(void *)(*(void *)(*result + 8 * v4) + 64) = v4;
        uint64_t v17 = *(void *)(v2 + 8 * v19);
        *(void *)(v17 + 64) = v19;
        unint64_t v4 = (v4 - 1) >> 1;
      }
      while (v18 > 1);
    }
    return result;
  }
  char v6 = 0;
  unint64_t v7 = v3 >> 3;
  uint64_t v8 = 2 * v4;
  uint64_t v9 = *(void *)(v2 + 8 * v4);
  while (1)
  {
    unint64_t v10 = v8 + 2;
    unint64_t v11 = *(void *)(v9 + 56);
    BOOL v12 = v10 < v7 && v11 > *(void *)(*(void *)(v2 + 8 * v10) + 56);
    unint64_t v13 = *(void *)(*(void *)(v2 + 8 * v5) + 56);
    if (v11 <= v13 && !v12) {
      break;
    }
    BOOL v15 = v11 > v13 && v12;
    if (v12) {
      unint64_t v16 = v10;
    }
    else {
      unint64_t v16 = v5;
    }
    if (v15)
    {
      if (v13 <= *(void *)(*(void *)(v2 + 8 * v10) + 56)) {
        unint64_t v16 = v5;
      }
      else {
        unint64_t v16 = v10;
      }
    }
    *(void *)(v2 + 8 * v4) = *(void *)(v2 + 8 * v16);
    *(void *)(v2 + 8 * v16) = v9;
    uint64_t v2 = *result;
    *(void *)(*(void *)(*result + 8 * v4) + 64) = v4;
    uint64_t v9 = *(void *)(v2 + 8 * v16);
    *(void *)(v9 + 64) = v16;
    uint64_t v8 = 2 * v16;
    char v6 = 1;
    unint64_t v5 = (2 * v16) | 1;
    unint64_t v4 = v16;
    if (v5 >= v7) {
      return result;
    }
  }
  if ((v6 & 1) == 0)
  {
    unint64_t v4 = *(void *)(*(void *)a2 + 64);
    goto LABEL_24;
  }
  return result;
}

void PCCacheImpl<PCCFRef<CGColorSpace *>,PCCFRef<CGColorSpace *>,PCNoLock,anonymous namespace'::CompareColorSpaceRef>::evictIfNecessary(void *a1)
{
  if (!a1[13])
  {
    uint64_t v2 = (char **)(a1 + 6);
    while (a1[10] > a1[11] || a1[5] > a1[12])
    {
      uint64_t v3 = (uint64_t *)a1[6];
      unint64_t v4 = (uint64_t *)a1[7];
      if (v3 == v4) {
        break;
      }
      uint64_t v5 = *v3;
      uint64_t v6 = *(void *)(*v3 + 64);
      unint64_t v7 = v4 - v3 - 1;
      if (v6 == v7)
      {
      }
      else
      {
        v3[v6] = v3[v7];
        *(void *)(*(void *)&(*v2)[8 * v6] + 64) = v6;
      }
      a1[10] -= *(void *)(v5 + 48);
      uint64_t v8 = *(void **)(v5 + 8);
      uint64_t v9 = (void *)v5;
      if (v8)
      {
        do
        {
          unint64_t v10 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          unint64_t v10 = (void *)v9[2];
          BOOL v11 = *v10 == (void)v9;
          uint64_t v9 = v10;
        }
        while (!v11);
      }
      if (a1[3] == v5) {
        a1[3] = v10;
      }
      BOOL v12 = (uint64_t *)a1[4];
      --a1[5];
      std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v12, (uint64_t *)v5);
      PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v5 + 40));
      PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v5 + 32));
      operator delete((void *)v5);
    }
  }
}

uint64_t std::unique_ptr<std::__tree_node<std::__value_type<PCCFRef<CGColorSpace *>,PCCacheImpl<PCCFRef<CGColorSpace *>,PCCFRef<CGColorSpace *>,PCNoLock,anonymous namespace'::CompareColorSpaceRef>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<PCCFRef<CGColorSpace *>,PCCacheImpl<PCCFRef<CGColorSpace *>,PCCFRef<CGColorSpace *>,PCNoLock,anonymous namespace'::CompareColorSpaceRef>::Data>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(CGColorSpace ***)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      PCCFRef<CGColorSpace *>::~PCCFRef(v2 + 5);
      PCCFRef<CGColorSpace *>::~PCCFRef(v2 + 4);
    }
    operator delete(v2);
  }
  return a1;
}

void std::vector<std::__map_iterator<std::__tree_iterator<std::__value_type<PCCFRef<CGColorSpace *>,PCCacheImpl<PCCFRef<CGColorSpace *>,PCCFRef<CGColorSpace *>,PCNoLock,anonymous namespace'::CompareColorSpaceRef>::Data>,std::__tree_node<std::__value_type<PCCFRef<CGColorSpace *>,PCCacheImpl<PCCFRef<CGColorSpace *>,PCCFRef<CGColorSpace *>,PCNoLock,anonymous namespace'::CompareColorSpaceRef>::Data>,void *> *,long>>>::resize(char **a1, unint64_t a2)
{
  unint64_t v4 = *a1;
  uint64_t v3 = a1[1];
  unint64_t v5 = (v3 - *a1) >> 3;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    unint64_t v16 = &v4[8 * a2];
    goto LABEL_20;
  }
  unint64_t v6 = a2 - v5;
  unint64_t v7 = a1[2];
  if (a2 - v5 <= (v7 - v3) >> 3)
  {
    bzero(a1[1], 8 * v6);
    unint64_t v16 = &v3[8 * v6];
LABEL_20:
    a1[1] = v16;
    return;
  }
  if (a2 >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = v7 - v4;
  uint64_t v9 = v8 >> 2;
  if (v8 >> 2 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  if (v10 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  BOOL v11 = (char *)operator new(8 * v10);
  BOOL v12 = &v11[8 * v5];
  unint64_t v13 = &v11[8 * v10];
  bzero(v12, 8 * v6);
  char v14 = &v12[8 * v6];
  if (v3 != v4)
  {
    do
    {
      uint64_t v15 = *((void *)v3 - 1);
      v3 -= 8;
      *((void *)v12 - 1) = v15;
      v12 -= 8;
    }
    while (v3 != v4);
    uint64_t v3 = v4;
  }
  *a1 = v12;
  a1[1] = v14;
  a1[2] = v13;
  if (v3)
  {
    operator delete(v3);
  }
}

void PCICCProfile::PCICCProfile(PCICCProfile *this)
{
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((unsigned char *)this + 176) = 1;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 25) = 0;
  PCWorkingColorVector::PCWorkingColorVector((PCICCProfile *)((char *)this + 208));
  PCICCProfile::setUpHeader(this, 0x7DFu, 9u, 0xFu, 0, 0, 0);
}

void sub_1B769CEB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  BOOL v12 = v11;
  char v14 = *v12;
  if (*v12)
  {
    *(void *)(v10 + 19OZChannelFontBase::~OZChannelFontBase(this - 2) = v14;
    operator delete(v14);
  }
  a10 = (void **)(v10 + 152);
  std::vector<PCICCProfile::Tag>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

double PCICCProfile::setUpHeader(PCICCProfile *this, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 a5, unsigned __int16 a6, unsigned __int16 a7)
{
  ProCore::Private::setUInt32Number((_DWORD *)this + 1, (unsigned __int8 *)0x6170706C);
  ProCore::Private::setUInt32Number((_DWORD *)this + 2, (unsigned __int8 *)0x4030000);
  ProCore::Private::setUInt32Number((_DWORD *)this + 3, (unsigned __int8 *)0x6D6E7472);
  ProCore::Private::setUInt32Number((_DWORD *)this + 4, (unsigned __int8 *)0x52474220);
  ProCore::Private::setUInt32Number((_DWORD *)this + 5, (unsigned __int8 *)0x58595A20);
  ProCore::Private::setUInt16Number((_WORD *)this + 12, (unsigned __int8 *)a2);
  ProCore::Private::setUInt16Number((_WORD *)this + 13, (unsigned __int8 *)a3);
  ProCore::Private::setUInt16Number((_WORD *)this + 14, (unsigned __int8 *)a4);
  ProCore::Private::setUInt16Number((_WORD *)this + 15, (unsigned __int8 *)a5);
  ProCore::Private::setUInt16Number((_WORD *)this + 16, (unsigned __int8 *)a6);
  ProCore::Private::setUInt16Number((_WORD *)this + 17, (unsigned __int8 *)a7);
  ProCore::Private::setUInt32Number((_DWORD *)this + 9, (unsigned __int8 *)0x61637370);
  ProCore::Private::setUInt32Number((_DWORD *)this + 10, (unsigned __int8 *)0x4150504C);
  ProCore::Private::setUInt32Number((_DWORD *)this + 11, 0);
  ProCore::Private::setUInt32Number((_DWORD *)this + 12, 0);
  ProCore::Private::setUInt32Number((_DWORD *)this + 13, 0);
  *((void *)this + 7) = 0;
  ProCore::Private::setUInt32Number((_DWORD *)this + 16, 0);
  ProCore::Private::setUInt32Number((_DWORD *)this + 17, (unsigned __int8 *)0xF6D6);
  ProCore::Private::setUInt32Number((_DWORD *)this + 18, (unsigned __int8 *)0x10000);
  ProCore::Private::setUInt32Number((_DWORD *)this + 19, (unsigned __int8 *)0xD32D);
  ProCore::Private::setUInt32Number((_DWORD *)this + 20, (unsigned __int8 *)0x4150504C);
  double result = 0.0;
  *((_OWORD *)this + 7) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
  *(_OWORD *)((char *)this + 84) = 0u;
  return result;
}

void PCICCProfile::PCICCProfile(PCICCProfile *this, CGColorSpace *a2)
{
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((unsigned char *)this + 176) = 1;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 25) = 0;
  PCWorkingColorVector::PCWorkingColorVector((PCICCProfile *)((char *)this + 208));
  CFDataRef v4 = CGColorSpaceCopyICCData(a2);
  CFDataRef theData = v4;
  if (!v4)
  {
    exceptioint n = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v9, "Color space without an ICC profile given to PCICCProfile");
    PCString::PCString(&v8, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCICCProfile.cpp");
    PCException::PCException(exception, &v9, &v8, 158);
  }
  BytePtr = CFDataGetBytePtr(v4);
  CFIndex Length = CFDataGetLength(theData);
  PCICCProfile::parseProfileData(this, BytePtr, Length);
  PCCFRef<__CTLine const*>::~PCCFRef((const void **)&theData);
}

void sub_1B769D180(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10, PCString a11, uint64_t a12)
{
  PCString::~PCString(&a10);
  PCString::~PCString(&a11);
  if (v15) {
    __cxa_free_exception(v13);
  }
  PCCFRef<__CTLine const*>::~PCCFRef((const void **)&a12);
  uint64_t v17 = *v14;
  if (*v14)
  {
    *(void *)(v12 + 19OZChannelFontBase::~OZChannelFontBase(this - 2) = v17;
    operator delete(v17);
  }
  a12 = v12 + 152;
  std::vector<PCICCProfile::Tag>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void PCICCProfile::parseProfileData(PCICCProfile *this, const unsigned __int8 *a2, size_t a3)
{
  if (!a2)
  {
    exceptioint n = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString((PCString *)__p, "Corrupt ColorSync profile given to PCICCProfile");
    PCString::PCString(&v40, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCICCProfile.cpp");
    PCException::PCException(exception, (const PCString *)__p, &v40, 193);
  }
  if (a3 <= 0x80)
  {
    BOOL v34 = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString((PCString *)__p, "Corrupt ICC profile given to PCICCProfile");
    PCString::PCString(&v40, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCICCProfile.cpp");
    PCException::PCException(v34, (const PCString *)__p, &v40, 199);
  }
  long long v6 = *(_OWORD *)a2;
  long long v7 = *((_OWORD *)a2 + 1);
  long long v8 = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + OZChannelFontBase::~OZChannelFontBase(this - 2) = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 3) = v8;
  *(_OWORD *)this = v6;
  *((_OWORD *)this + 1) = v7;
  long long v9 = *((_OWORD *)a2 + 4);
  long long v10 = *((_OWORD *)a2 + 5);
  long long v11 = *((_OWORD *)a2 + 7);
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
  *((_OWORD *)this + 7) = v11;
  *((_OWORD *)this + 4) = v9;
  *((_OWORD *)this + 5) = v10;
  int Int32Number = ProCore::Private::getInt32Number((ProCore::Private *)(a2 + 128), a2);
  if ((12 * Int32Number + 132) >= a3)
  {
    CFHashCode v35 = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString((PCString *)__p, "Corrupt ICC profile given to PCICCProfile");
    PCString::PCString(&v40, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCICCProfile.cpp");
    PCException::PCException(v35, (const PCString *)__p, &v40, 211);
  }
  int v14 = Int32Number;
  if (Int32Number)
  {
    unsigned int v15 = 132;
    do
    {
      unsigned int v16 = v15;
      if (v15 >= a3)
      {
        CFTypeRef v32 = (PCException *)__cxa_allocate_exception(0x40uLL);
        PCString::PCString((PCString *)__p, "Corrupt ICC profile given to PCICCProfile");
        PCString::PCString(&v40, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCICCProfile.cpp");
        PCException::PCException(v32, (const PCString *)__p, &v40, 217);
      }
      LODWORD(__p[0]) = 0;
      long long v38 = 0;
      uint64_t v39 = 0;
      uint64_t v17 = (unsigned __int8 *)&a2[v15];
      __p[1] = 0;
      unint64_t v18 = (unsigned __int8 *)ProCore::Private::getInt32Number((ProCore::Private *)v17, v13);
      ProCore::Private::setUInt32NumberLE(__p, v18);
      int v20 = ProCore::Private::getInt32Number((ProCore::Private *)(v17 + 4), v19);
      unsigned int v22 = ProCore::Private::getInt32Number((ProCore::Private *)(v17 + 8), v21);
      if (v22 + v20 > a3)
      {
        CFHashCode v31 = (PCException *)__cxa_allocate_exception(0x40uLL);
        PCString::PCString(&v40, "Corrupt ICC profile given to PCICCProfile");
        PCString::PCString(&v36, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCICCProfile.cpp");
        PCException::PCException(v31, &v40, &v36, 228);
      }
      size_t v23 = v22;
      PCICCTag::resize((PCICCTag *)__p, v22);
      FactoryForSerializatioint n = (void *)OZFactoryBase::getFactoryForSerialization((uint64_t)__p);
      memcpy(FactoryForSerialization, &a2[v20], v23);
      PCICCProfile::addTag(this, (const PCICCTag *)__p);
      if (__p[1])
      {
        long long v38 = __p[1];
        operator delete(__p[1]);
      }
      unsigned int v15 = v16 + 12;
      --v14;
    }
    while (v14);
  }
  CGColorSpaceRef v25 = (char *)*((void *)this + 23);
  size_t v26 = *((void *)this + 24) - (void)v25;
  if (a3 <= v26)
  {
    if (a3 < v26) {
      *((void *)this + 24) = &v25[a3];
    }
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this + 23, a3 - v26);
    CGColorSpaceRef v25 = (char *)*((void *)this + 23);
  }
  memcpy(v25, a2, a3);
  int Size = PVPerfStats::FrameStats::GetSize((PCICCProfile *)((char *)this + 84));
  int v28 = PVPerfStats::FrameStats::GetSize((PCICCProfile *)((char *)this + 88));
  int v29 = PVPerfStats::FrameStats::GetSize((PCICCProfile *)((char *)this + 92));
  int v30 = PVPerfStats::FrameStats::GetSize((PCICCProfile *)((char *)this + 96));
  if (Size || v28 || v29 || v30)
  {
    PCHash128::PCHash128((PCHash128 *)__p, Size, v28, v29, v30);
    *((_OWORD *)this + 13) = *(_OWORD *)__p;
  }
  else
  {
    PCICCProfile::computeMD5(this);
  }
  *((unsigned char *)this + 176) = 0;
}

void sub_1B769D60C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10, void *__p, uint64_t a12, uint64_t a13, PCString a14)
{
  PCString::~PCString(&a14);
  PCString::~PCString(&a10);
  if (v15) {
    __cxa_free_exception(v14);
  }
  _Unwind_Resume(a1);
}

void PCICCProfile::addTag(PCICCProfile *this, const PCICCTag *a2)
{
  uint64_t v5 = *((void *)this + 19);
  long long v6 = (_DWORD *)*((void *)this + 20);
  CFDataRef v4 = (uint64_t *)((char *)this + 152);
  if ((_DWORD *)v5 != v6)
  {
    uint64_t v7 = -v5;
    while (1)
    {
      int v8 = *(_DWORD *)v5;
      if (v8 == PVPerfStats::FrameStats::GetSize(a2)) {
        break;
      }
      v5 += 24;
      v7 -= 24;
      if ((_DWORD *)v5 == v6) {
        goto LABEL_11;
      }
    }
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<PCICCProfile::Tag *,PCICCProfile::Tag *,PCICCProfile::Tag *>((uint64_t)v36, 24 - v7, *((void *)this + 20), -v7);
    uint64_t v10 = v9;
    uint64_t v11 = *((void *)this + 20);
    if (v11 != v9)
    {
      do
      {
        uint64_t v12 = *(std::__shared_weak_count **)(v11 - 8);
        if (v12) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v12);
        }
        v11 -= 24;
      }
      while (v11 != v10);
    }
    *((void *)this + 20) = v10;
  }
LABEL_11:
  uint64_t v13 = PCICCTag::size(a2);
  int v14 = (const void ***)*((void *)this + 16);
  int v15 = (const void ***)*((void *)this + 17);
  if (v14 == v15) {
LABEL_18:
  }
    operator new();
  unsigned int v16 = (char *)v13;
  while (1)
  {
    uint64_t v17 = **v14;
    FactoryForSerializatioint n = (const void *)OZFactoryBase::getFactoryForSerialization((uint64_t)a2);
    unint64_t v19 = *v14;
    int v20 = **v14;
    size_t v21 = (unsigned char *)(*v14)[1] - v20 >= (unint64_t)v16 ? (size_t)v16 : (unsigned char *)(*v14)[1] - v20;
    if (!memcmp(v17, FactoryForSerialization, v21)) {
      break;
    }
    v14 += 2;
    if (v14 == v15) {
      goto LABEL_18;
    }
  }
  unsigned int v22 = v14[1];
  if (v22) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v22 + 1, 1uLL, memory_order_relaxed);
  }
  *(void *)&long long v35 = v19;
  *((void *)&v35 + 1) = v22;
  int Size = PVPerfStats::FrameStats::GetSize(a2);
  if (*((void *)&v35 + 1))
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v35 + 1) + 8), 1uLL, memory_order_relaxed);
    unint64_t v24 = (char *)this + 168;
    unint64_t v25 = *((void *)this + 21);
    unint64_t v26 = *((void *)this + 20);
    if (v26 < v25)
    {
      *(_DWORD *)unint64_t v26 = Size;
      *(_OWORD *)(v26 + 8) = v35;
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v35 + 1) + 8), 1uLL, memory_order_relaxed);
LABEL_26:
      unint64_t v27 = v26 + 24;
      goto LABEL_36;
    }
  }
  else
  {
    unint64_t v24 = (char *)this + 168;
    unint64_t v25 = *((void *)this + 21);
    unint64_t v26 = *((void *)this + 20);
    if (v26 < v25)
    {
      *(_DWORD *)unint64_t v26 = Size;
      *(_OWORD *)(v26 + 8) = (unint64_t)v19;
      goto LABEL_26;
    }
  }
  unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - *v4) >> 3);
  unint64_t v29 = v28 + 1;
  if (v28 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - *v4) >> 3);
  if (2 * v30 > v29) {
    unint64_t v29 = 2 * v30;
  }
  if (v30 >= 0x555555555555555) {
    unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v31 = v29;
  }
  _DWORD v36[4] = v24;
  CFTypeRef v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)v24, v31);
  BOOL v33 = &v32[24 * v28];
  v36[0] = v32;
  v36[1] = v33;
  _OWORD v36[3] = &v32[24 * v34];
  *(_DWORD *)BOOL v33 = Size;
  *((void *)v33 + 1) = v19;
  *((void *)v33 + OZChannelFontBase::~OZChannelFontBase(this - 2) = *((void *)&v35 + 1);
  if (*((void *)&v35 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v35 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  v36[2] = v33 + 24;
  std::vector<PCICCProfile::Tag>::__swap_out_circular_buffer(v4, v36);
  unint64_t v27 = *((void *)this + 20);
  std::__split_buffer<PCICCProfile::Tag>::~__split_buffer(v36);
LABEL_36:
  *((void *)this + 20) = v27;
  *((unsigned char *)this + 176) = 1;
  if (*((void *)&v35 + 1))
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v35 + 1));
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v35 + 1));
  }
}

void sub_1B769D9D8(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, ...)
{
  va_start(va, a3);
  std::__split_buffer<PCICCProfile::Tag>::~__split_buffer((void **)va);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if (a3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a3);
  }
  _Unwind_Resume(a1);
}

__n128 PCICCProfile::computeMD5(PCICCProfile *this)
{
  uint64_t v2 = *((void *)this + 23);
  int v3 = *(_DWORD *)(v2 + 44);
  int v4 = *(_DWORD *)(v2 + 64);
  *(_DWORD *)(v2 + 44) = 0;
  *(_DWORD *)(*((void *)this + 23) + 64) = 0;
  uint64_t v5 = *((void *)this + 23);
  *(void *)(v5 + 9OZChannelFontBase::~OZChannelFontBase(this - 2) = 0;
  *(void *)(v5 + 84) = 0;
  uint64_t v8 = 0;
  long long v9 = xmmword_1B7E7C6E0;
  char v10 = 0;
  int v11 = 0;
  PCMD5::writeBytes((PCMD5 *)&v8, *((char **)this + 23), *((void *)this + 24) - *((void *)this + 23));
  PCMD5::getHash((PCMD5 *)&v8, (PCHash128 *)&v7);
  *((_OWORD *)this + 13) = v7;
  ProCore::Private::setUInt32NumberLE((_DWORD *)this + 21, (unsigned __int8 *)*((unsigned int *)this + 52));
  ProCore::Private::setUInt32NumberLE((_DWORD *)this + 22, (unsigned __int8 *)*((unsigned int *)this + 53));
  ProCore::Private::setUInt32NumberLE((_DWORD *)this + 23, (unsigned __int8 *)*((unsigned int *)this + 54));
  ProCore::Private::setUInt32NumberLE((_DWORD *)this + 24, (unsigned __int8 *)*((unsigned int *)this + 55));
  *(_DWORD *)(*((void *)this + 23) + 44) = v3;
  *(_DWORD *)(*((void *)this + 23) + 64) = v4;
  __n128 result = *(__n128 *)((char *)this + 84);
  *(__n128 *)(*((void *)this + 23) + 84) = result;
  return result;
}

__n128 PCICCProfile::getMD5Hash@<Q0>(PCICCProfile *this@<X0>, __n128 *a2@<X8>)
{
  PCICCProfile::buildProfile(this);
  __n128 result = *((__n128 *)this + 13);
  *a2 = result;
  return result;
}

void PCICCProfile::buildProfile(PCICCProfile *this)
{
  if (*((unsigned char *)this + 176))
  {
    int v3 = (_OWORD **)((char *)this + 184);
    uint64_t v2 = (_OWORD *)*((void *)this + 23);
    unint64_t v4 = ((uint64_t)(*((void *)this + 20) - *((void *)this + 19)) >> 1) + 132;
    unint64_t v5 = *((void *)this + 24) - (void)v2;
    long long v38 = (unint64_t *)((char *)this + 184);
    if (v4 <= v5)
    {
      if (v4 < v5) {
        *((void *)this + 24) = (char *)v2 + v4;
      }
    }
    else
    {
      std::vector<unsigned char>::__append((unint64_t *)this + 23, v4 - v5);
      uint64_t v2 = *v3;
    }
    long long v6 = *(_OWORD *)this;
    long long v7 = *((_OWORD *)this + 1);
    long long v8 = *((_OWORD *)this + 3);
    v2[2] = *((_OWORD *)this + 2);
    v2[3] = v8;
    _OWORD *v2 = v6;
    v2[1] = v7;
    long long v9 = *((_OWORD *)this + 4);
    long long v10 = *((_OWORD *)this + 5);
    long long v11 = *((_OWORD *)this + 7);
    v2[6] = *((_OWORD *)this + 6);
    v2[7] = v11;
    v2[4] = v9;
    v2[5] = v10;
    ProCore::Private::setUInt32Number((_DWORD *)(*((void *)this + 23) + 128), (unsigned __int8 *)(-1431655765 * ((*((void *)this + 20) - *((void *)this + 19)) >> 3)));
    PCString v40 = 0;
    uint64_t v41 = 0;
    uint64_t v39 = &v40;
    uint64_t v12 = *((void *)this + 19);
    if (*((void *)this + 20) != v12)
    {
      uint64_t v13 = 0;
      int v14 = 0;
      unsigned int v15 = 132;
      do
      {
        unsigned int v16 = (unsigned int *)(v12 + 24 * v13);
        uint64_t v17 = (uint64_t *)*((void *)v16 + 1);
        uint64_t v19 = *v17;
        uint64_t v18 = v17[1];
        int v20 = (std::__shared_weak_count *)*((void *)v16 + 2);
        if (v20) {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        size_t v21 = v18 - v19;
        unsigned int v22 = v40;
        if (!v40) {
          goto LABEL_20;
        }
        size_t v23 = &v40;
        do
        {
          unint64_t v24 = v22;
          unint64_t v25 = v23;
          unint64_t v26 = v22[5];
          if (v26 >= (unint64_t)v17) {
            size_t v23 = (uint64_t **)v22;
          }
          else {
            ++v22;
          }
          unsigned int v22 = (uint64_t *)*v22;
        }
        while (v22);
        if (v23 == &v40) {
          goto LABEL_20;
        }
        if (v26 < (unint64_t)v17) {
          unint64_t v24 = (uint64_t *)v25;
        }
        if ((unint64_t)v17 >= v24[5])
        {
          unint64_t v28 = (unsigned __int8 *)v23[4];
          BOOL v33 = v38;
        }
        else
        {
LABEL_20:
          unint64_t v27 = *((void *)this + 23);
          unint64_t v28 = (unsigned __int8 *)(*((void *)this + 24) - v27);
          if (v28 >= &v28[v21])
          {
            if (v28 > &v28[v21]) {
              *((void *)this + 24) += v21;
            }
          }
          else
          {
            std::vector<unsigned char>::__append(v38, v21);
            unint64_t v27 = *v38;
          }
          memcpy(&v28[v27], **((const void ***)v16 + 1), v21);
          unint64_t v29 = v40;
          for (i = &v40; ; unint64_t v29 = *i)
          {
            unint64_t v31 = i;
            if (!v29) {
              break;
            }
            while (1)
            {
              uint64_t i = (uint64_t **)v29;
              unint64_t v32 = v29[5];
              if ((unint64_t)v17 < v32) {
                break;
              }
              if (v32 >= (unint64_t)v17) {
                goto LABEL_37;
              }
              unint64_t v29 = i[1];
              if (!v29)
              {
                unint64_t v31 = i + 1;
                goto LABEL_32;
              }
            }
          }
LABEL_32:
          uint64_t v34 = (uint64_t *)operator new(0x38uLL);
          long long v35 = v34;
          v34[4] = (uint64_t)v28;
          v34[5] = (uint64_t)v17;
          v34[6] = (uint64_t)v20;
          if (v20) {
            atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          *uint64_t v34 = 0;
          v34[1] = 0;
          v34[2] = (uint64_t)i;
          *unint64_t v31 = v34;
          if (*v39)
          {
            uint64_t v39 = (uint64_t **)*v39;
            long long v35 = *v31;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v40, v35);
          ++v41;
LABEL_37:
          size_t v36 = ((v21 + 3) & 0xFFFFFFFFFFFFFFFCLL) - v21;
          size_t v37 = *((void *)this + 24) - *((void *)this + 23);
          if (v37 >= v37 + v36)
          {
            BOOL v33 = v38;
            if (v37 > v37 + v36) {
              *((void *)this + 24) += v36;
            }
          }
          else
          {
            BOOL v33 = v38;
            std::vector<unsigned char>::__append(v38, v36);
          }
        }
        ProCore::Private::setUInt32Number((_DWORD *)(*v33 + v15), (unsigned __int8 *)*v16);
        ProCore::Private::setUInt32Number((_DWORD *)(*v33 + v15 + 4), v28);
        ProCore::Private::setUInt32Number((_DWORD *)(*v33 + v15 + 8), (unsigned __int8 *)v21);
        if (v20) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v20);
        }
        v15 += 12;
        uint64_t v12 = *((void *)this + 19);
        uint64_t v13 = ++v14;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 20) - v12) >> 3) != v14);
    }
    ProCore::Private::setUInt32Number(*((_DWORD **)this + 23), (unsigned __int8 *)(*((_DWORD *)this + 48) - *((void *)this + 23)));
    PCICCProfile::computeMD5(this);
    *((unsigned char *)this + 176) = 0;
  }
}

void sub_1B769DE98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
}

void PCICCProfile::findTagBySignature(PCICCProfile *this@<X0>, int a2@<W1>, PCICCTag *a3@<X8>)
{
  for (uint64_t i = *((void *)this + 19); ; i += 24)
  {
    if (i == *((void *)this + 20))
    {
      *(_OWORD *)a3 = 0u;
      *((_OWORD *)a3 + 1) = 0u;
      return;
    }
    if (*(_DWORD *)i == a2) {
      break;
    }
  }
  PCICCTag::PCICCTag(a3, a2, **(const unsigned __int8 ***)(i + 8), *(const unsigned __int8 **)(*(void *)(i + 8) + 8));
}

void **std::vector<std::shared_ptr<std::vector<unsigned char>>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  __n128 result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  long long v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    int v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)result, v13);
    unsigned int v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    _OWORD v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)unsigned int v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<std::vector<unsigned char>>>::__swap_out_circular_buffer(a1, v18);
    long long v9 = (void *)a1[1];
    __n128 result = std::__split_buffer<std::shared_ptr<TXTextObject>>::~__split_buffer(v18);
  }
  else
  {
    *long long v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    long long v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1B769E008(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<TXTextObject>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t PCICCProfile::getSize(ProCore::Private **this)
{
  PCICCProfile::buildProfile((PCICCProfile *)this);
  int v3 = this[23];

  return ProCore::Private::getInt32Number(v3, v2);
}

uint64_t PCICCProfile::getProfileData(PCICCProfile *this)
{
  return *((void *)this + 23);
}

unsigned char *anonymous namespace'::addXYZToTag(ProCore::Private *a1, double *a2)
{
  ProCore::Private::addInt32ToTag(a1, (PCICCTag *)0x58595A20);
  ProCore::Private::addInt32ToTag(a1, 0);
  ProCore::Private::add15Fixed16ToTag(a1, v4, *a2);
  ProCore::Private::add15Fixed16ToTag(a1, v5, a2[1]);
  double v7 = a2[2];

  return ProCore::Private::add15Fixed16ToTag(a1, v6, v7);
}

unsigned char *PCMakeChromaticAdaptationICCTag(ProCore::Private *a1, uint64_t a2)
{
  PCICCTag::reset((uint64_t)a1, 1667785060);
  ProCore::Private::addInt32ToTag(a1, (PCICCTag *)0x73663332);
  ProCore::Private::addInt32ToTag(a1, 0);
  for (uint64_t i = 0; i != 3; ++i)
  {
    for (uint64_t j = 0; j != 24; j += 8)
      __n128 result = ProCore::Private::add15Fixed16ToTag(a1, v4, *(double *)(a2 + j));
    a2 += 24;
  }
  return result;
}

void anonymous namespace'::addMultiLocalizedUnicodeToTag(_anonymous_namespace_ *this, PCICCTag *a2, const char *a3)
{
  ProCore::Private::addInt32ToTag(this, (PCICCTag *)0x6D6C7563);
  ProCore::Private::addInt32ToTag(this, 0);
  ProCore::Private::addInt32ToTag(this, (PCICCTag *)1);
  ProCore::Private::addInt32ToTag(this, (PCICCTag *)0xC);
  ProCore::Private::addInt16ToTag(this, (PCICCTag *)0x656E);
  ProCore::Private::addInt16ToTag(this, (PCICCTag *)0x7573);
  int v5 = strlen((const char *)a2);
  ProCore::Private::addInt32ToTag(this, (PCICCTag *)(2 * v5));
  ProCore::Private::addInt32ToTag(this, (PCICCTag *)0x1C);
  char v6 = *(unsigned char *)a2;
  if (*(unsigned char *)a2)
  {
    do
    {
      ProCore::Private::addInt16ToTag(this, (PCICCTag *)(unsigned __int16)v6);
      int v7 = *((unsigned __int8 *)a2 + 1);
      a2 = (PCICCTag *)((char *)a2 + 1);
      char v6 = v7;
    }
    while (v7);
  }

  ProCore::Private::addStringToTag(this, a2, (const char *)1);
}

void PCMakeDisplayRGBProfile(float *a1@<X0>, uint64_t a2@<X1>, PCICCTag *a3@<X2>, PCICCTag *a4@<X3>, PCICCProfile *a5@<X8>)
{
  PCICCProfile::PCICCProfile(a5);
  PCConvertChromaticitiesToXYZ(a1, (uint64_t)&v60, (uint64_t)&v58, (uint64_t)&v56, (uint64_t)v55);
  v54[0] = 0x3FF0000000000000;
  memset(&v54[1], 0, 24);
  v54[4] = 0x3FF0000000000000;
  memset(&v54[5], 0, 24);
  v54[8] = 0x3FF0000000000000;
  double v11 = 1.0;
  if (v61 <= 1.0) {
    double v12 = v61;
  }
  else {
    double v12 = 1.0;
  }
  double v13 = 0.0;
  if (v61 < 0.0) {
    double v12 = 0.0;
  }
  double v61 = v12;
  if (v59 <= 1.0) {
    double v14 = v59;
  }
  else {
    double v14 = 1.0;
  }
  if (v59 >= 0.0) {
    double v15 = v14;
  }
  else {
    double v15 = 0.0;
  }
  double v59 = v15;
  if (v57 <= 1.0) {
    double v11 = v57;
  }
  if (v57 >= 0.0) {
    double v13 = v11;
  }
  double v57 = v13;
  int v50 = 0;
  int v52 = 0;
  uint64_t v53 = 0;
  uint64_t v51 = 0;
  int v46 = 0;
  unint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v47 = 0;
  int v42 = 0;
  int v44 = 0;
  uint64_t v45 = 0;
  uint64_t v43 = 0;
  int v38 = 0;
  PCString v40 = 0;
  uint64_t v41 = 0;
  uint64_t v39 = 0;
  PCICCTag::reset((uint64_t)&v50, 1918392666);
  PCICCTag::reset((uint64_t)&v46, 1733843290);
  PCICCTag::reset((uint64_t)&v42, 1649957210);
  PCICCTag::reset((uint64_t)&v38, 2004119668);
  PCICCProfile::addTag(a5, (const PCICCTag *)&v50);
  PCICCProfile::addTag(a5, (const PCICCTag *)&v46);
  PCICCProfile::addTag(a5, (const PCICCTag *)&v42);
  PCICCProfile::addTag(a5, (const PCICCTag *)&v38);
  if (v10)
  {
    int v34 = 0;
    size_t v36 = 0;
    uint64_t v37 = 0;
    __p = 0;
    PCMakeChromaticAdaptationICCTag((ProCore::Private *)&v34, (uint64_t)v54);
    PCICCProfile::addTag(a5, (const PCICCTag *)&v34);
    if (__p)
    {
      size_t v36 = __p;
      operator delete(__p);
    }
  }
  int v34 = 0;
  size_t v36 = 0;
  uint64_t v37 = 0;
  __p = 0;
  int v30 = 0;
  unint64_t v32 = 0;
  uint64_t v33 = 0;
  unint64_t v31 = 0;
  int v26 = 0;
  unint64_t v28 = 0;
  uint64_t v29 = 0;
  unint64_t v27 = 0;
  PCMakeTRCTag(a2, (uint64_t)&v34, 0);
  PCMakeTRCTag(a2, (uint64_t)&v30, 1);
  PCMakeTRCTag(a2, (uint64_t)&v26, 2);
  PCICCProfile::addTag(a5, (const PCICCTag *)&v34);
  PCICCProfile::addTag(a5, (const PCICCTag *)&v30);
  PCICCProfile::addTag(a5, (const PCICCTag *)&v26);
  int v22 = 0;
  unint64_t v24 = 0;
  uint64_t v25 = 0;
  size_t v23 = 0;
  PCICCTag::reset((uint64_t)&v22, 1684370275);
  PCICCProfile::addTag(a5, (const PCICCTag *)&v22);
  int v18 = 0;
  int v20 = 0;
  uint64_t v21 = 0;
  uint64_t v19 = 0;
  PCICCTag::reset((uint64_t)&v18, 1668313716);
  PCICCProfile::addTag(a5, (const PCICCTag *)&v18);
  if (v19)
  {
    int v20 = v19;
    operator delete(v19);
  }
  if (v23)
  {
    unint64_t v24 = v23;
    operator delete(v23);
  }
  if (v27)
  {
    unint64_t v28 = v27;
    operator delete(v27);
  }
  if (v31)
  {
    unint64_t v32 = v31;
    operator delete(v31);
  }
  if (__p)
  {
    size_t v36 = __p;
    operator delete(__p);
  }
  if (v39)
  {
    PCString v40 = v39;
    operator delete(v39);
  }
  if (v43)
  {
    int v44 = v43;
    operator delete(v43);
  }
  if (v47)
  {
    unint64_t v48 = v47;
    operator delete(v47);
  }
  if (v51)
  {
    int v52 = v51;
    operator delete(v51);
  }
}

void sub_1B769E598(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40)
{
  if (__p) {
    operator delete(__p);
  }
  if (a31) {
    operator delete(a31);
  }
  if (a35) {
    operator delete(a35);
  }
  if (a39) {
    operator delete(a39);
  }
  uint64_t v43 = *(void **)(v41 - 240);
  if (v43)
  {
    *(void *)(v41 - 23OZChannelFontBase::~OZChannelFontBase(this - 2) = v43;
    operator delete(v43);
  }
  PCICCProfile::~PCICCProfile(v40);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::adaptXYZColors(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, uint64_t a5)
{
  if (v9)
  {
    PCTransformXYZ(a5, a1, a1);
    PCTransformXYZ(a5, a2, a2);
    PCTransformXYZ(a5, a3, a3);
  }
  return v9;
}

void PCMakeDisplayRGBProfile(float *a1@<X0>, uint64_t a2@<X1>, PCICCProfile *a3@<X8>)
{
  PCGetDescriptionForProfile((uint64_t)a1, a2, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = (PCICCTag *)&__p;
  }
  else {
    p_p = (PCICCTag *)__p.__r_.__value_.__r.__words[0];
  }
  PCMakeDisplayRGBProfile(a1, a2, p_p, (PCICCTag *)"Copyright (c) 2016 Apple Inc.", a3);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1B769E768(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void PCMakeDisplayGrayProfile(uint64_t a1@<X0>, PCICCTag *a2@<X1>, PCICCTag *a3@<X2>, PCICCProfile *a4@<X8>, float a5@<S0>, float a6@<S1>)
{
  PCICCProfile::PCICCProfile(a4);
  PCICCProfile::setUpHeader(a4, 0x7DFu, 7u, 0xAu, 0, 0, 0);
  ProCore::Private::setUInt32Number((_DWORD *)a4 + 4, (unsigned __int8 *)0x47524159);
  v32[0] = (float)(a5 / a6);
  v32[1] = 1.0;
  v32[2] = (float)((float)((float)(1.0 - a5) - a6) / a6);
  v31[0] = 0x3FF0000000000000;
  memset(&v31[1], 0, 24);
  void v31[4] = 0x3FF0000000000000;
  memset(&v31[5], 0, 24);
  v31[8] = 0x3FF0000000000000;
  int v27 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  unint64_t v28 = 0;
  PCICCTag::reset((uint64_t)&v27, 2004119668);
  PCICCProfile::addTag(a4, (const PCICCTag *)&v27);
  if (v12)
  {
    int v23 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    std::string __p = 0;
    PCMakeChromaticAdaptationICCTag((ProCore::Private *)&v23, (uint64_t)v31);
    PCICCProfile::addTag(a4, (const PCICCTag *)&v23);
    if (__p)
    {
      uint64_t v25 = __p;
      operator delete(__p);
    }
  }
  int v23 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  std::string __p = 0;
  PCMakeTRCTag(a1, (uint64_t)&v23, 3);
  PCICCProfile::addTag(a4, (const PCICCTag *)&v23);
  int v19 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  int v20 = 0;
  PCICCTag::reset((uint64_t)&v19, 1684370275);
  PCICCProfile::addTag(a4, (const PCICCTag *)&v19);
  int v15 = 0;
  long long v17 = 0;
  uint64_t v18 = 0;
  uint64_t v16 = 0;
  PCICCTag::reset((uint64_t)&v15, 1668313716);
  PCICCProfile::addTag(a4, (const PCICCTag *)&v15);
  if (v16)
  {
    long long v17 = v16;
    operator delete(v16);
  }
  if (v20)
  {
    uint64_t v21 = v20;
    operator delete(v20);
  }
  if (__p)
  {
    uint64_t v25 = __p;
    operator delete(__p);
  }
  if (v28)
  {
    uint64_t v29 = v28;
    operator delete(v28);
  }
}

void sub_1B769E99C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23)
{
  if (__p) {
    operator delete(__p);
  }
  if (a22) {
    operator delete(a22);
  }
  PCICCProfile::~PCICCProfile(v23);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::computeAdaptationMatrix(double *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  PCComputeChromaticAdaptation(a1, (double *)&kPCD50XYZ, a2);
  uint64_t v4 = 0;
  while (2)
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      int v3 = (ProCore::Private *)ProCore::Private::convertToS15Fixed16(v3, *(double *)(v2 + 8 * i));
      if (v4 == i)
      {
        if (v3 != 0x10000) {
          return 1;
        }
      }
      else if (v3)
      {
        return 1;
      }
    }
    ++v4;
    v2 += 24;
    if (v4 != 3) {
      continue;
    }
    break;
  }
  return 0;
}

void PCMakeDisplayGrayProfile(float a1@<S0>, float a2@<S1>, float a3@<S2>, PCICCTag *a4@<X0>, PCICCTag *a5@<X1>, PCICCProfile *a6@<X8>)
{
  PCICCTransferFunctionGamma::PCICCTransferFunctionGamma((PCICCTransferFunctionGamma *)v11, a3);
  PCMakeDisplayGrayProfile((uint64_t)v11, a4, a5, a6, a1, a2);
  PCICCTransferFunctionGamma::~PCICCTransferFunctionGamma((PCICCTransferFunctionGamma *)v11);
}

void sub_1B769EB18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t PCMakeDisplayGrayProfile@<X0>(float a1@<S0>, float a2@<S1>, float a3@<S2>, PCICCProfile *a4@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v12);
  std::stringbuf::str();
  if (v11 >= 0) {
    p_p = (PCICCTag *)&__p;
  }
  else {
    p_p = (PCICCTag *)__p;
  }
  PCMakeDisplayGrayProfile(a1, a2, a3, p_p, (PCICCTag *)"Copyright (c) 2016 Apple Inc.", a4);
  if (v11 < 0) {
    operator delete(__p);
  }
  v12[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v12 + *(void *)(v12[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v12[1] = MEMORY[0x1E4FBA470] + 16;
  if (v13 < 0) {
    operator delete((void *)v12[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v14);
}

void sub_1B769ECC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void *anonymous namespace'::writeMonochromeIlluminantName(void *a1, float a2, float a3)
{
  if (vabds_f32(a2, 0.3127) >= 0.00001 || vabds_f32(a3, 0.329) >= 0.00001)
  {
    if (vabds_f32(a2, 0.3457) >= 0.00001 || vabds_f32(a3, 0.3585) >= 0.00001)
    {
      if (vabds_f32(a2, 0.32168) >= 0.00001 || vabds_f32(a3, 0.33767) >= 0.00001)
      {
        if (vabds_f32(a2, 0.314) >= 0.00001 || vabds_f32(a3, 0.351) >= 0.00001)
        {
          int v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"(", 1);
          *(void *)((char *)v5 + *(void *)(*v5 - 24) + 16) = 5;
          char v6 = (void *)std::ostream::operator<<();
          int v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)", ", 2);
          *(void *)((char *)v7 + *(void *)(*v7 - 24) + 16) = 5;
          a1 = (void *)std::ostream::operator<<();
          int v3 = ")";
          uint64_t v4 = 1;
        }
        else
        {
          int v3 = "DCI P3 Monochrome";
          uint64_t v4 = 17;
        }
        goto LABEL_15;
      }
      int v3 = "D60 Monochrome";
    }
    else
    {
      int v3 = "D50 Monochrome";
    }
  }
  else
  {
    int v3 = "D65 Monochrome";
  }
  uint64_t v4 = 14;
LABEL_15:

  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v3, v4);
}

void *anonymous namespace'::writeGamma(void *a1, float a2)
{
  if (a2 == 1.0)
  {
    uint64_t v2 = " Linear";
    uint64_t v3 = 7;
LABEL_5:
    return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v2, v3);
  }
  if (fabsf(a2 + -1.961) < 0.00001)
  {
    uint64_t v2 = ", QuickTime Gamma";
    uint64_t v3 = 17;
    goto LABEL_5;
  }
  int v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)", gamma ", 8);
  *(void *)((char *)v5 + *(void *)(*v5 - 24) + 16) = 4;

  return (void *)std::ostream::operator<<();
}

void PCMakeDisplayRGBProfileFromGrayProfile(const PCICCProfile *a1@<X0>, PCICCProfile *a2@<X8>)
{
  PCICCProfile::PCICCProfile(a2);
  PCICCProfile::setUpHeader(a2, 0x7DFu, 8u, 4u, 0, 0, 0);
  PCICCProfile::findTagBySignature(a1, 2004119668, (PCICCTag *)v48);
  PCICCProfile::findTagBySignature(a1, 1800688195, (PCICCTag *)&v45);
  long long v40 = kPCChromaticities_ITU_R709_2;
  uint64_t v41 = 0x3D75C28F3E19999ALL;
  float32x2_t v42 = vcvt_f32_f64(vdivq_f64(v43, (float64x2_t)vdupq_lane_s64(COERCE__INT64(vaddvq_f64(v43) + v44), 0)));
  if ((PCConvertChromaticitiesToXYZ((float *)&v40, (uint64_t)&v38, (uint64_t)&v36, (uint64_t)&v34, (uint64_t)v33) & 1) == 0) {
    PCConvertChromaticitiesToXYZ((float *)&kPCChromaticities_ITU_R709_2, (uint64_t)&v38, (uint64_t)&v36, (uint64_t)&v34, (uint64_t)&v43);
  }
  v32[0] = 0x3FF0000000000000;
  memset(&v32[1], 0, 24);
  v32[4] = 0x3FF0000000000000;
  memset(&v32[5], 0, 24);
  v32[8] = 0x3FF0000000000000;
  double v5 = 1.0;
  if (v39 <= 1.0) {
    double v6 = v39;
  }
  else {
    double v6 = 1.0;
  }
  double v7 = 0.0;
  if (v39 < 0.0) {
    double v6 = 0.0;
  }
  double v39 = v6;
  if (v37 <= 1.0) {
    double v8 = v37;
  }
  else {
    double v8 = 1.0;
  }
  if (v37 >= 0.0) {
    double v9 = v8;
  }
  else {
    double v9 = 0.0;
  }
  double v37 = v9;
  if (v35 <= 1.0) {
    double v5 = v35;
  }
  if (v35 >= 0.0) {
    double v7 = v5;
  }
  double v35 = v7;
  int v28 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v29 = 0;
  int v24 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v25 = 0;
  int v20 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v21 = 0;
  PCICCTag::reset((uint64_t)&v28, 1918392666);
  PCICCTag::reset((uint64_t)&v24, 1733843290);
  PCICCTag::reset((uint64_t)&v20, 1649957210);
  PCICCTag::reset((uint64_t)v48, 2004119668);
  PCICCProfile::addTag(a2, (const PCICCTag *)&v28);
  PCICCProfile::addTag(a2, (const PCICCTag *)&v24);
  PCICCProfile::addTag(a2, (const PCICCTag *)&v20);
  PCICCProfile::addTag(a2, (const PCICCTag *)v48);
  if (v4)
  {
    int v16 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    std::string __p = 0;
    PCMakeChromaticAdaptationICCTag((ProCore::Private *)&v16, (uint64_t)v32);
    PCICCProfile::addTag(a2, (const PCICCTag *)&v16);
    if (__p)
    {
      uint64_t v18 = __p;
      operator delete(__p);
    }
  }
  ProCore::Private::setUInt32NumberLE(&v45, (unsigned __int8 *)0x72545243);
  PCICCProfile::addTag(a2, (const PCICCTag *)&v45);
  ProCore::Private::setUInt32NumberLE(&v45, (unsigned __int8 *)0x67545243);
  PCICCProfile::addTag(a2, (const PCICCTag *)&v45);
  ProCore::Private::setUInt32NumberLE(&v45, (unsigned __int8 *)0x62545243);
  PCICCProfile::addTag(a2, (const PCICCTag *)&v45);
  int v16 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  std::string __p = 0;
  PCICCTag::reset((uint64_t)&v16, 1684370275);
  PCICCProfile::addTag(a2, (const PCICCTag *)&v16);
  int v12 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  char v13 = 0;
  PCICCTag::reset((uint64_t)&v12, 1668313716);
  PCICCProfile::addTag(a2, (const PCICCTag *)&v12);
  if (v13)
  {
    uint64_t v14 = v13;
    operator delete(v13);
  }
  if (__p)
  {
    uint64_t v18 = __p;
    operator delete(__p);
  }
  if (v21)
  {
    uint64_t v22 = v21;
    operator delete(v21);
  }
  if (v25)
  {
    uint64_t v26 = v25;
    operator delete(v25);
  }
  if (v29)
  {
    uint64_t v30 = v29;
    operator delete(v29);
  }
  if (v46)
  {
    uint64_t v47 = v46;
    operator delete(v46);
  }
  if (v49)
  {
    int v50 = v49;
    operator delete(v49);
  }
}

void sub_1B769F34C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28)
{
  if (__p) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  if (a23) {
    operator delete(a23);
  }
  if (a27) {
    operator delete(a27);
  }
  uint64_t v31 = *(void **)(v29 - 88);
  if (v31)
  {
    *(void *)(v29 - 80) = v31;
    operator delete(v31);
  }
  unint64_t v32 = *(void **)(v29 - 56);
  if (v32)
  {
    *(void *)(v29 - 48) = v32;
    operator delete(v32);
  }
  PCICCProfile::~PCICCProfile(v28);
  _Unwind_Resume(a1);
}

void anonymous namespace'::getXYZFromTag(uint64_t a1, double *a2)
{
  FactoryForSerializatioint n = OZFactoryBase::getFactoryForSerialization(a1);
  *a2 = ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 8), v4);
  a2[1] = ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 12), v5);
  a2[2] = ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 16), v6);
}

void PCMakeDisplayGrayProfileFromRGBProfile(const PCICCProfile *a1@<X0>, PCICCProfile *a2@<X8>)
{
  PCICCProfile::findTagBySignature(a1, 2004119668, (PCICCTag *)v22);
  PCICCProfile::findTagBySignature(a1, 1918128707, (PCICCTag *)v16);
  PCICCProfile::findTagBySignature(a1, 1733579331, (PCICCTag *)v13);
  PCICCProfile::findTagBySignature(a1, 1649693251, (PCICCTag *)v10);
  float v4 = 2.2;
  if (!PCICCTag::empty((PCICCTag *)v16) && !PCICCTag::empty((PCICCTag *)v13) && !PCICCTag::empty((PCICCTag *)v10))
  {
    float v5 = PCEstimateGammaFromTag((const PCICCTag *)v16);
    float v6 = PCEstimateGammaFromTag((const PCICCTag *)v13);
    float v4 = (float)((float)(v5 + v6) + PCEstimateGammaFromTag((const PCICCTag *)v10)) / 3.0;
  }
  double v7 = v19 + v20 + v21;
  float v8 = v19 / v7;
  float v9 = v20 / v7;
  PCMakeDisplayGrayProfile(v8, v9, v4, a2);
  if (__p)
  {
    int v12 = __p;
    operator delete(__p);
  }
  if (v14)
  {
    uint64_t v15 = v14;
    operator delete(v14);
  }
  if (v17)
  {
    uint64_t v18 = v17;
    operator delete(v17);
  }
  if (v23)
  {
    int v24 = v23;
    operator delete(v23);
  }
}

void sub_1B769F5A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20)
{
  if (__p) {
    operator delete(__p);
  }
  if (a15) {
    operator delete(a15);
  }
  if (a19) {
    operator delete(a19);
  }
  uint64_t v22 = *(void **)(v20 - 56);
  if (v22)
  {
    *(void *)(v20 - 48) = v22;
    operator delete(v22);
  }
  _Unwind_Resume(exception_object);
}

BOOL PCSameColorTransform(const PCICCProfile *a1, const PCICCProfile *a2)
{
  uint64_t v4 = *((void *)a1 + 19);
  uint64_t v5 = (*((void *)a1 + 20) - v4) >> 3;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * v5;
  uint64_t v7 = (-1431655765 * v5);
  if (-1431655765 * v5)
  {
    unint64_t v8 = 0;
    float v9 = (int *)*((void *)a1 + 19);
    while (1)
    {
      if ((int v10 = 0, !v4) || v6 <= v8 || ((int v10 = *v9, *v9 != 1668313716) ? (v11 = v10 == 1852074350) : (v11 = 1), !v11))
      {
        if (!result) {
          break;
        }
      }
      ++v8;
      v9 += 6;
      if (v7 == v8) {
        goto LABEL_11;
      }
    }
  }
  else
  {
LABEL_11:
    uint64_t v13 = *((void *)a2 + 19);
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)a2 + 20) - v13) >> 3);
    uint64_t v15 = -1431655765 * ((*((void *)a2 + 20) - v13) >> 3);
    if (-1431655765 * ((*((void *)a2 + 20) - v13) >> 3))
    {
      unint64_t v16 = 0;
      for (uint64_t i = (int *)*((void *)a2 + 19); ; i += 6)
      {
        if ((int v18 = 0, !v13)
          || v14 <= v16
          || ((v18 = *i, *i != 1668313716) ? (BOOL v19 = v18 == 1852074350) : (BOOL v19 = 1), !v19))
        {
          if (!result) {
            break;
          }
        }
        if (v15 == ++v16) {
          return 1;
        }
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

BOOL anonymous namespace'::sameTagData(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 152);
  uint64_t v4 = *(void *)(a1 + 160);
  if (v3 == v4)
  {
LABEL_5:
    size_t v6 = 0;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 152);
    while (*(_DWORD *)v5 != a3)
    {
      v5 += 24;
      if (v5 == v4) {
        goto LABEL_5;
      }
    }
    size_t v6 = *(void *)(*(void *)(v5 + 8) + 8) - **(void **)(v5 + 8);
  }
  uint64_t v7 = *(void *)(a2 + 152);
  uint64_t v8 = *(void *)(a2 + 160);
  if (v7 == v8)
  {
LABEL_11:
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v9 = *(void *)(a2 + 152);
    while (*(_DWORD *)v9 != a3)
    {
      v9 += 24;
      if (v9 == v8) {
        goto LABEL_11;
      }
    }
    uint64_t v10 = *(void *)(*(void *)(v9 + 8) + 8) - **(void **)(v9 + 8);
  }
  if (v6 != v10) {
    return 0;
  }
  while (1)
  {
    if (v3 == v4)
    {
      int v12 = 0;
      goto LABEL_20;
    }
    if (*(_DWORD *)v3 == a3) {
      break;
    }
    v3 += 24;
  }
  int v12 = **(const void ***)(v3 + 8);
  while (1)
  {
LABEL_20:
    if (v7 == v8) {
      return 1;
    }
    if (*(_DWORD *)v7 == a3) {
      break;
    }
    v7 += 24;
  }
  uint64_t v11 = 1;
  if (v12)
  {
    uint64_t v13 = **(const void ***)(v7 + 8);
    if (v13) {
      return memcmp(v12, v13, v6) == 0;
    }
  }
  return v11;
}

void PCGetChromaticities(PCICCProfile *a1, float32x4_t *a2)
{
  PCICCProfile::findTagBySignature(a1, 2004119668, (PCICCTag *)v37);
  long long v35 = kPCD50XYZ;
  double v36 = 0.8249;
  if (!PCICCTag::empty((PCICCTag *)v37)) {
  PCICCProfile::findTagBySignature(a1, 1918392666, (PCICCTag *)v32);
  }
  float64_t v31 = 1.0;
  long long v30 = xmmword_1B7E7C6F8;
  if (!PCICCTag::empty((PCICCTag *)v32)) {
  PCICCProfile::findTagBySignature(a1, 1733843290, (PCICCTag *)v27);
  }
  float64_t v26 = 1.0;
  long long v25 = xmmword_1B7E7C6F8;
  if (!PCICCTag::empty((PCICCTag *)v27)) {
  PCICCProfile::findTagBySignature(a1, 1649957210, (PCICCTag *)v22);
  }
  float64_t v21 = 1.0;
  long long v20 = xmmword_1B7E7C6F8;
  if (!PCICCTag::empty((PCICCTag *)v22)) {
  PCICCProfile::findTagBySignature(a1, 1667785060, (PCICCTag *)v17);
  }
  v16[0] = 1.0;
  memset(&v16[1], 0, 24);
  v16[4] = 1.0;
  memset(&v16[5], 0, 24);
  unsigned char v16[8] = 1.0;
  if (PCICCTag::empty((PCICCTag *)v17))
  {
    PCComputeChromaticAdaptation((double *)&kPCD50XYZ, (double *)&v35, (uint64_t)v16);
  }
  else
  {
    uint64_t v4 = 0;
    size_t v6 = (ProCore::Private *)(OZFactoryBase::getFactoryForSerialization((uint64_t)v17) + 8);
    uint64_t v7 = v16;
    do
    {
      for (uint64_t i = 0; i != 3; ++i)
      {
        v7[i] = ProCore::Private::getS15Fixed16Number(v6, v5);
        size_t v6 = (ProCore::Private *)((char *)v6 + 4);
      }
      ++v4;
      v7 += 3;
    }
    while (v4 != 3);
    PCMatrix33Tmpl<double>::invert(v16, v16, 0.0);
  }
  if (vabdd_f64(*(double *)&v35, 0.9642) < 0.001
    && vabdd_f64(*((double *)&v35 + 1), 1.0) < 0.001
    && vabdd_f64(v36, 0.8249) < 0.001)
  {
    PCTransformXYZ(v16, &v35, &v35);
  }
  PCTransformXYZ(v16, &v30, &v30);
  PCTransformXYZ(v16, &v25, &v25);
  PCTransformXYZ(v16, &v20, &v20);
  v9.f64[0] = v31;
  *(void *)&v10.f64[0] = vdupq_laneq_s64((int64x2_t)v30, 1).u64[0];
  v10.f64[1] = *((float64_t *)&v25 + 1);
  v9.f64[1] = v26;
  int64x2_t v11 = (int64x2_t)vaddq_f64(vaddq_f64((float64x2_t)vzip1q_s64((int64x2_t)v30, (int64x2_t)v25), v10), v9);
  float32x4_t v12 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64((float64x2_t)v30, (float64x2_t)vdupq_lane_s64(v11.i64[0], 0))), vdivq_f64((float64x2_t)v25, (float64x2_t)vdupq_laneq_s64(v11, 1)));
  *(void *)&v10.f64[0] = vdupq_laneq_s64((int64x2_t)v20, 1).u64[0];
  v10.f64[1] = *((float64_t *)&v35 + 1);
  float64x2_t v13 = vaddq_f64((float64x2_t)vzip1q_s64((int64x2_t)v20, (int64x2_t)v35), v10);
  v10.f64[0] = v21;
  v10.f64[1] = v36;
  int64x2_t v14 = (int64x2_t)vaddq_f64(v13, v10);
  float32x4_t v15 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64((float64x2_t)v20, (float64x2_t)vdupq_lane_s64(v14.i64[0], 0))), vdivq_f64((float64x2_t)v35, (float64x2_t)vdupq_laneq_s64(v14, 1)));
  *a2 = v12;
  a2[1] = v15;
  if (__p)
  {
    BOOL v19 = __p;
    operator delete(__p);
  }
  if (v23)
  {
    int v24 = v23;
    operator delete(v23);
  }
  if (v28)
  {
    uint64_t v29 = v28;
    operator delete(v28);
  }
  if (v33)
  {
    double v34 = v33;
    operator delete(v33);
  }
  if (v38)
  {
    double v39 = v38;
    operator delete(v38);
  }
}

void sub_1B769FBAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39)
{
  if (__p) {
    operator delete(__p);
  }
  if (a38) {
    operator delete(a38);
  }
  uint64_t v41 = *(void **)(v39 - 152);
  if (v41)
  {
    *(void *)(v39 - 144) = v41;
    operator delete(v41);
  }
  float32x2_t v42 = *(void **)(v39 - 88);
  if (v42)
  {
    *(void *)(v39 - 80) = v42;
    operator delete(v42);
  }
  _Unwind_Resume(exception_object);
}

BOOL PCMatrix33Tmpl<double>::invert(double *a1, double *a2, double a3)
{
  double v4 = a2[7];
  double v3 = a2[8];
  double v5 = a2[4];
  double v6 = a2[5];
  double v7 = a2[6];
  double v8 = v5 * v3 - v4 * v6;
  double v9 = a2[2];
  double v10 = a2[3];
  double v11 = v6 * v7 - v3 * v10;
  double v13 = *a2;
  double v12 = a2[1];
  double v14 = v4 * v10 - v5 * v7;
  double v15 = v9 * v14 + v8 * *a2 + v12 * v11;
  BOOL v16 = fabs(v15) >= a3 && v15 != 0.0;
  if (v16)
  {
    *a1 = v8 * (1.0 / v15);
    a1[1] = (v4 * v9 - v3 * v12) * (1.0 / v15);
    a1[2] = (v6 * v12 - v5 * v9) * (1.0 / v15);
    a1[3] = v11 * (1.0 / v15);
    a1[4] = (v3 * v13 - v9 * v7) * (1.0 / v15);
    a1[5] = (v9 * v10 - v6 * v13) * (1.0 / v15);
    a1[6] = v14 * (1.0 / v15);
    a1[7] = (v12 * v7 - v4 * v13) * (1.0 / v15);
    a1[8] = (v5 * v13 - v12 * v10) * (1.0 / v15);
  }
  return v16;
}

void *std::operator<<[abi:ne180100]<std::char_traits<char>>(void *a1, char *a2)
{
  double v3 = (char *)a1 + *(void *)(*a1 - 24);
  int v4 = *a2;
  if (*((_DWORD *)v3 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    double v5 = std::locale::use_facet(&v8, MEMORY[0x1E4FBA258]);
    int v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 32);
    std::locale::~locale(&v8);
    *((_DWORD *)v3 + 36) = v6;
  }
  *((_DWORD *)v3 + 36) = v4;
  return a1;
}

void sub_1B769FDE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  double v5 = (char *)a1[1];
  int v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    double v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    double v12 = &v7[v11];
    double v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      double v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      double v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<PCICCProfile::Tag *,PCICCProfile::Tag *,PCICCProfile::Tag *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    *(_DWORD *)a4 = *(_DWORD *)v5;
    long long v7 = *(_OWORD *)(v5 + 8);
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    unint64_t v8 = *(std::__shared_weak_count **)(a4 + 16);
    *(_OWORD *)(a4 + 8) = v7;
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    a4 += 24;
    v5 += 24;
  }
  while (v5 != v6);
  return v6;
}

void *std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    BOOL result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B76A0010(_Unwind_Exception *exception_object)
{
  double v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::shared_ptr<std::vector<unsigned char>>::shared_ptr[abi:ne180100]<std::vector<unsigned char>,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B76A009C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    std::default_delete<std::vector<unsigned char>>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<std::vector<unsigned char> *,std::shared_ptr<std::vector<unsigned char>>::__shared_ptr_default_delete<std::vector<unsigned char>,std::vector<unsigned char>>,std::allocator<std::vector<unsigned char>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::__shared_ptr_pointer<std::vector<unsigned char> *,std::shared_ptr<std::vector<unsigned char>>::__shared_ptr_default_delete<std::vector<unsigned char>,std::vector<unsigned char>>,std::allocator<std::vector<unsigned char>>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<std::vector<unsigned char> *,std::shared_ptr<std::vector<unsigned char>>::__shared_ptr_default_delete<std::vector<unsigned char>,std::vector<unsigned char>>,std::allocator<std::vector<unsigned char>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::default_delete<std::vector<unsigned char>>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void **)a2;
    if (*(void *)a2)
    {
      *(void *)(a2 + 8) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x1BA9BFBA0);
  }
}

uint64_t std::vector<std::shared_ptr<std::vector<unsigned char>>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<std::vector<unsigned char>>>,std::reverse_iterator<std::shared_ptr<std::vector<unsigned char>>*>,std::reverse_iterator<std::shared_ptr<std::vector<unsigned char>>*>,std::reverse_iterator<std::shared_ptr<std::vector<unsigned char>>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<std::vector<unsigned char>>>,std::reverse_iterator<std::shared_ptr<std::vector<unsigned char>>*>,std::reverse_iterator<std::shared_ptr<std::vector<unsigned char>>*>,std::reverse_iterator<std::shared_ptr<std::vector<unsigned char>>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  _OWORD v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<std::vector<unsigned char>>>,std::reverse_iterator<std::shared_ptr<std::vector<unsigned char>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<std::vector<unsigned char>>>,std::reverse_iterator<std::shared_ptr<std::vector<unsigned char>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TXTextObject>>,std::reverse_iterator<std::shared_ptr<TXTextObject>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

uint64_t std::vector<PCICCProfile::Tag>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PCICCProfile::Tag>,std::reverse_iterator<PCICCProfile::Tag*>,std::reverse_iterator<PCICCProfile::Tag*>,std::reverse_iterator<PCICCProfile::Tag*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PCICCProfile::Tag>,std::reverse_iterator<PCICCProfile::Tag*>,std::reverse_iterator<PCICCProfile::Tag*>,std::reverse_iterator<PCICCProfile::Tag*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  _OWORD v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = a7 - 24;
    do
    {
      int v9 = *(_DWORD *)(a3 - 24);
      a3 -= 24;
      *(_DWORD *)uint64_t v8 = v9;
      *(_OWORD *)(v8 + 8) = *(_OWORD *)(a3 + 8);
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      *((void *)&v15 + 1) = v8;
      v8 -= 24;
      v7 -= 24;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<PCICCProfile::Tag>,std::reverse_iterator<PCICCProfile::Tag*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<PCICCProfile::Tag>,std::reverse_iterator<PCICCProfile::Tag*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<PCICCProfile::Tag>,std::reverse_iterator<PCICCProfile::Tag*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<PCICCProfile::Tag>,std::reverse_iterator<PCICCProfile::Tag*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    double v3 = *(std::__shared_weak_count **)(v1 + 16);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    v1 += 24;
  }
}

void **std::__split_buffer<PCICCProfile::Tag>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<PCICCProfile::Tag>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 24;
    int v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 24;
    }
  }
}

void std::__tree<anonymous namespace'::WrittenTag>::destroy(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (std::__shared_weak_count *)a1[6];
    if (v2) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v2);
    }
    operator delete(a1);
  }
}

BOOL PCIs709TransferFunction(float a1, float a2, float a3, float a4, float a5)
{
  return fabsf(a1 + -2.2222) < 0.001
      && fabsf(a2 + -0.90992) < 0.001
      && fabsf(a3 + -0.090082) < 0.001
      && fabsf(a4 + -0.22222) < 0.001
      && fabsf(a5 + -0.081) < 0.001;
}

BOOL PCIssRGBTransferFunction(float a1, float a2, float a3, float a4, float a5)
{
  if (fabsf(a1 + -2.4) >= 0.001
    || fabsf(a2 + -0.94787) >= 0.001
    || fabsf(a3 + -0.052133) >= 0.001
    || fabsf(a4 + -0.077399) >= 0.001)
  {
    return 0;
  }
  if (fabsf(a5 + -0.0405) >= 0.001) {
    return fabsf(a5 + -0.039) < 0.001;
  }
  return 1;
}

double ProCore::Private::initChromaticityMath(ProCore::Private *this, uint64_t a2, double *a3)
{
}

double anonymous namespace'::invert(_anonymous_namespace_ *this, double *a2, double *a3)
{
  double v3 = *((double *)this + 7);
  double v4 = *((double *)this + 8);
  double result = *((double *)this + 4);
  double v6 = *((double *)this + 5);
  double v7 = *((double *)this + 6);
  double v8 = result * v4 - v6 * v3;
  double v10 = *((double *)this + 2);
  double v9 = *((double *)this + 3);
  double v11 = v6 * v7 - v4 * v9;
  double v12 = v3 * v9 - result * v7;
  double v14 = *(double *)this;
  double v13 = *((double *)this + 1);
  double v15 = v8 * *(double *)this + v13 * v11 + v12 * v10;
  if (v15 >= 0.0000001 || v15 <= -0.0000001)
  {
    double v17 = 1.0 / v15;
    *a2 = v8 * v17;
    a2[1] = (v3 * v10 - v4 * v13) * v17;
    a2[2] = (v6 * v13 - result * v10) * v17;
    a2[3] = v11 * v17;
    a2[4] = (v4 * v14 - v7 * v10) * v17;
    a2[5] = (v9 * v10 - v6 * v14) * v17;
    a2[6] = v12 * v17;
    a2[7] = (v7 * v13 - v3 * v14) * v17;
    double result = (result * v14 - v9 * v13) * v17;
    a2[8] = result;
  }
  return result;
}

uint64_t PCConvertChromaticitiesToXYZ(float *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  double v9 = *a1;
  double v10 = a1[1];
  double v11 = 1.0 - v9 - v10;
  double v12 = a1[2];
  double v13 = a1[3];
  double v14 = a1[4];
  double v15 = a1[5];
  float v17 = a1[6];
  float v16 = a1[7];
  double v44 = v9 / v10;
  double v45 = v12 / v13;
  double v46 = v14 / v15;
  __asm { FMOV            V0.2D, #1.0 }
  long long v47 = _Q0;
  uint64_t v48 = 0x3FF0000000000000;
  double v49 = v11 / v10;
  double v50 = (1.0 - v12 - v13) / v13;
  double v51 = (1.0 - v14 - v15) / v15;
  double v43 = 0.0;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  uint64_t v25 = v24;
  if (v24)
  {
    double v26 = v17 / v16;
    double v27 = (1.0 - v17 - v16) / v16;
    v38[0] = v26 * *(double *)&v39 + *((double *)&v39 + 1) + v27 * *(double *)&v40;
    memset(&v38[1], 0, 24);
    v38[4] = v26 * *((double *)&v40 + 1) + *(double *)&v41 + v27 * *((double *)&v41 + 1);
    memset(&v38[5], 0, 24);
    v38[8] = v26 * *(double *)&v42 + *((double *)&v42 + 1) + v27 * v43;
    double v28 = v44;
    double v29 = v45;
    double v31 = v46;
    uint64_t v30 = v47;
    *(double *)a2 = v44;
    *(void *)(a2 + 8) = v30;
    double v32 = v49;
    double v33 = v50;
    *(double *)(a2 + 16) = v49;
    uint64_t v34 = *((void *)&v47 + 1);
    uint64_t v35 = v48;
    *(double *)a3 = v29;
    *(void *)(a3 + 8) = v34;
    *(double *)(a3 + 16) = v33;
    *(double *)a4 = v31;
    *(void *)(a4 + 8) = v35;
    double v36 = v51;
    *(double *)(a4 + 16) = v51;
    *(double *)a5 = v28 + v29 + v31;
    *(void *)(a5 + 8) = 0x3FF0000000000000;
    *(double *)(a5 + 16) = v32 + v33 + v36;
  }
  return v25;
}

double anonymous namespace'::multiply(_anonymous_namespace_ *this, const double *a2, double *a3, double *a4)
{
  double v4 = *((double *)this + 1);
  double v5 = a2[1];
  double v7 = a2[2];
  double v6 = a2[3];
  double v8 = a2[6];
  double v9 = a2[7];
  double v10 = *((double *)this + 2);
  double v11 = *((double *)this + 3);
  double v12 = *(double *)this * *a2 + v4 * v6 + v10 * v8;
  double v13 = a2[4];
  double v14 = a2[5];
  double v15 = *(double *)this * v5 + v4 * v13 + v10 * v9;
  double v16 = *(double *)this * v7 + v4 * v14;
  double v17 = a2[8];
  double v18 = v16 + v10 * v17;
  double v19 = *((double *)this + 4);
  double v20 = *((double *)this + 5);
  double v21 = *a2 * v11 + v6 * v19 + v8 * v20;
  double v22 = v5 * v11 + v13 * v19 + v9 * v20;
  double v23 = v7 * v11 + v14 * v19 + v17 * v20;
  double v24 = *((double *)this + 6);
  double v25 = *((double *)this + 7);
  double v26 = *a2 * v24 + v6 * v25;
  double v27 = *((double *)this + 8);
  *a3 = v12;
  a3[1] = v15;
  a3[2] = v18;
  a3[3] = v21;
  a3[4] = v22;
  a3[5] = v23;
  double result = v5 * v24 + v13 * v25 + v9 * v27;
  a3[6] = v26 + v8 * v27;
  a3[7] = result;
  a3[8] = v7 * v24 + v14 * v25 + v17 * v27;
  return result;
}

double PCComputeChromaticAdaptation(double *a1, double *a2, uint64_t a3)
{
  v12[9] = *(double *)MEMORY[0x1E4F143B8];
  double result = 0.0000001;
  if (vabdd_f64(*a1, *a2) >= 0.0000001 || vabdd_f64(a1[1], a2[1]) >= 0.0000001 || vabdd_f64(a1[2], a2[2]) >= 0.0000001)
  {
    v12[0] = v8[0] / v9[0];
    memset(&v12[1], 0, 24);
    v12[4] = v8[1] / v9[1];
    memset(&v12[5], 0, 24);
    v12[8] = v8[2] / v9[2];
    uint64_t v11 = 0;
    memset(v10, 0, sizeof(v10));
  }
  else
  {
    *(void *)a3 = 0x3FF0000000000000;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = 0x3FF0000000000000;
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 48) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)(a3 + 64) = 0x3FF0000000000000;
  }
  return result;
}

double anonymous namespace'::transform(double *a1, double *a2, double *a3)
{
  double v3 = a2[1];
  double v4 = a2[2];
  double result = *a1 * *a2 + a1[1] * v3 + a1[2] * v4;
  double v6 = *a2 * a1[3] + v3 * a1[4] + v4 * a1[5];
  double v7 = *a2 * a1[6] + v3 * a1[7] + v4 * a1[8];
  a3[1] = v6;
  a3[2] = v7;
  *a3 = result;
  return result;
}

float *PCGetLuminanceCoefficients@<X0>(float *result@<X0>, float *a2@<X8>)
{
  if ((vabds_f32(*result, 0.64) >= 0.00001
     || vabds_f32(result[1], 0.33) >= 0.00001
     || vabds_f32(result[2], 0.29) >= 0.00001
     || vabds_f32(result[3], 0.6) >= 0.00001
     || vabds_f32(result[4], 0.15) >= 0.00001
     || vabds_f32(result[5], 0.06) >= 0.00001
     || vabds_f32(result[6], 0.3127) >= 0.00001
     || vabds_f32(result[7], 0.329) >= 0.00001)
    && (vabds_f32(*result, 0.63) >= 0.00001
     || vabds_f32(result[1], 0.34) >= 0.00001
     || vabds_f32(result[2], 0.31) >= 0.00001
     || vabds_f32(result[3], 0.595) >= 0.00001
     || vabds_f32(result[4], 0.155) >= 0.00001
     || vabds_f32(result[5], 0.07) >= 0.00001
     || vabds_f32(result[6], 0.3127) >= 0.00001
     || vabds_f32(result[7], 0.329) >= 0.00001))
  {
    double result = (float *)PCConvertChromaticitiesToXYZ(result, (uint64_t)v11, (uint64_t)v9, (uint64_t)v7, (uint64_t)&v6);
    float v3 = 0.0;
    float v4 = 0.0;
    float v5 = 0.0;
    if (result)
    {
      float v3 = v12;
      float v4 = v10;
      float v5 = v8;
    }
    *a2 = v3;
    a2[1] = v4;
    a2[2] = v5;
  }
  else
  {
    *(void *)a2 = 0x3F1645A23E991687;
    a2[2] = 0.114;
  }
  return result;
}

float PCGetRec709LuminanceCoefficients@<S0>(uint64_t a1@<X8>)
{
  {
    uint64_t v3 = a1;
    a1 = v3;
    if (v2)
    {
      PCGetLuminanceCoefficients((float *)&kPCChromaticities_ITU_R709_2, (float *)&PCGetRec709LuminanceCoefficients(void)::coefficients);
      a1 = v3;
    }
  }
  *(void *)a1 = PCGetRec709LuminanceCoefficients(void)::coefficients;
  float result = *(float *)&dword_1E9EE4BF8;
  *(_DWORD *)(a1 + 8) = dword_1E9EE4BF8;
  return result;
}

float *PCGetRGBToYCbCrMatrix(float *a1, uint64_t a2)
{
  float result = PCGetLuminanceCoefficients(a1, (float *)&v18);
  float v5 = *((float *)&v18 + 1);
  float v4 = v19;
  float v6 = 1.0 / (float)((float)(v19 + -1.0) + (float)(v19 + -1.0));
  float v7 = *(float *)&v18;
  float v8 = 1.0 / (float)((float)(*(float *)&v18 + -1.0) + (float)(*(float *)&v18 + -1.0));
  *(void *)a2 = v18;
  *(float *)(a2 + 8) = v19;
  float v9 = v7 * v6;
  float v10 = v5 * v6;
  float v11 = v10 + (float)(v9 + 0.5);
  if (v11 != 0.0)
  {
    float v10 = -0.5 - (float)(v9 + (float)(v11 * 0.5));
    float v9 = v9 + (float)(v11 * 0.5);
  }
  *(float *)(a2 + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = v9;
  *(float *)(a2 + 16) = v10;
  float v12 = v5 * v8;
  float v13 = v4 * v8;
  float v14 = v13 + (float)(v12 + 0.5);
  float v15 = v12 + (float)(v14 * 0.5);
  BOOL v16 = v14 == 0.0;
  if (v14 == 0.0) {
    float v17 = v12;
  }
  else {
    float v17 = v12 + (float)(v14 * 0.5);
  }
  *(void *)(a2 + 20) = 0x3F0000003F000000;
  if (!v16) {
    float v13 = -0.5 - v15;
  }
  *(float *)(a2 + 28) = v17;
  *(float *)(a2 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v13;
  return result;
}

double PCGetYCbCrToRGBMatrix(float *a1, uint64_t a2)
{
  PCGetRGBToYCbCrMatrix(a1, a2);
  if (!PCMatrix33Tmpl<float>::invert((float *)a2, (float *)a2, 0.0))
  {
    *(void *)&double result = 1065353216;
    *(_OWORD *)a2 = xmmword_1B7E736B0;
    *(_OWORD *)(a2 + 16) = xmmword_1B7E736B0;
    *(_DWORD *)(a2 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = 1065353216;
  }
  return result;
}

float *PCGetRec709YCbCrMatrix@<X0>(uint64_t a1@<X8>)
{
  *(_OWORD *)a1 = xmmword_1B7E736B0;
  *(_OWORD *)(a1 + 16) = xmmword_1B7E736B0;
  *(_DWORD *)(a1 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = 1065353216;
  return PCGetRGBToYCbCrMatrix((float *)&kPCChromaticities_ITU_R709_2, a1);
}

BOOL PCMatrix33Tmpl<float>::invert(float *a1, float *a2, float a3)
{
  float v4 = a2[7];
  float v3 = a2[8];
  float v5 = a2[4];
  float v6 = a2[5];
  float v7 = a2[6];
  float v8 = (float)(v5 * v3) - (float)(v4 * v6);
  float v9 = a2[2];
  float v10 = a2[3];
  float v11 = (float)(v6 * v7) - (float)(v3 * v10);
  float v13 = *a2;
  float v12 = a2[1];
  float v14 = (float)(v4 * v10) - (float)(v5 * v7);
  float v15 = (float)(v9 * v14) + (float)((float)(v8 * *a2) + (float)(v12 * v11));
  BOOL v16 = fabsf(v15) >= a3 && v15 != 0.0;
  if (v16)
  {
    *a1 = v8 * (float)(1.0 / v15);
    a1[1] = (float)((float)(v4 * v9) - (float)(v3 * v12)) * (float)(1.0 / v15);
    a1[2] = (float)((float)(v6 * v12) - (float)(v5 * v9)) * (float)(1.0 / v15);
    a1[3] = v11 * (float)(1.0 / v15);
    a1[4] = (float)((float)(v3 * v13) - (float)(v9 * v7)) * (float)(1.0 / v15);
    a1[5] = (float)((float)(v9 * v10) - (float)(v6 * v13)) * (float)(1.0 / v15);
    a1[6] = v14 * (float)(1.0 / v15);
    a1[7] = (float)((float)(v12 * v7) - (float)(v4 * v13)) * (float)(1.0 / v15);
    a1[8] = (float)((float)(v5 * v13) - (float)(v12 * v10)) * (float)(1.0 / v15);
  }
  return v16;
}

void PCException::addCallStackSymbols(PCException *this)
{
  int v2 = (void *)MEMORY[0x1BA9C0A20]();
  float v3 = (const void *)[MEMORY[0x1E4F29060] callStackSymbols];
  float v4 = v3;
  if (v3) {
    CFRetain(v3);
  }
  float v7 = v4;
  float v5 = (const void *)*((void *)this + 1);
  if (v5) {
    BOOL v6 = v5 == v4;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    CFRelease(v5);
    float v4 = v7;
  }
  *((void *)this + 1) = v4;
  float v7 = 0;
  PCCFRef<__CFArray const*>::~PCCFRef(&v7);
}

void sub_1B76A116C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<__CFArray const*>::~PCCFRef((const void **)va);
  _Unwind_Resume(a1);
}

float PCEstimateGamma(const PCICCProfile *a1)
{
  PCICCProfile::findTagBySignature(a1, 1918128707, (PCICCTag *)v15);
  PCICCProfile::findTagBySignature(a1, 1733579331, (PCICCTag *)v12);
  PCICCProfile::findTagBySignature(a1, 1649693251, (PCICCTag *)v9);
  if (PCICCTag::empty((PCICCTag *)v15) || PCICCTag::empty((PCICCTag *)v12) || PCICCTag::empty((PCICCTag *)v9))
  {
    PCICCProfile::findTagBySignature(a1, 1800688195, (PCICCTag *)&v6);
    float v2 = 0.0;
    if (!PCICCTag::empty((PCICCTag *)&v6)) {
      float v2 = PCEstimateGammaFromTag((const PCICCTag *)&v6);
    }
    if (__p)
    {
      float v8 = __p;
      operator delete(__p);
    }
  }
  else
  {
    float v4 = PCEstimateGammaFromTag((const PCICCTag *)v15);
    float v5 = PCEstimateGammaFromTag((const PCICCTag *)v12);
    float v2 = (float)((float)(v4 + v5) + PCEstimateGammaFromTag((const PCICCTag *)v9)) / 3.0;
  }
  if (v10)
  {
    float v11 = v10;
    operator delete(v10);
  }
  if (v13)
  {
    float v14 = v13;
    operator delete(v13);
  }
  if (v16)
  {
    float v17 = v16;
    operator delete(v16);
  }
  return v2;
}

void sub_1B76A12B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  double v21 = *(void **)(v19 - 56);
  if (v21)
  {
    *(void *)(v19 - 48) = v21;
    operator delete(v21);
  }
  _Unwind_Resume(exception_object);
}

float PCEstimateGamma(CGColorSpace *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  PCICCProfile::PCICCProfile((PCICCProfile *)v3, a1);
  float v1 = PCEstimateGamma((const PCICCProfile *)v3);
  PCICCProfile::~PCICCProfile((PCICCProfile *)v3);
  return v1;
}

void sub_1B76A13A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2)
  {
    PCICCProfile::~PCICCProfile((PCICCProfile *)&a10);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1B76A1370);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ProCore::Private::getInt32Number(ProCore::Private *this, const unsigned __int8 *a2)
{
  return bswap32(*(_DWORD *)this);
}

_DWORD *ProCore::Private::setUInt32Number(_DWORD *this, unsigned __int8 *a2)
{
  *this = bswap32(a2);
  return this;
}

uint64_t ProCore::Private::getUInt16Number(ProCore::Private *this, const unsigned __int8 *a2)
{
  return bswap32(*(unsigned __int16 *)this) >> 16;
}

_WORD *ProCore::Private::setUInt16Number(_WORD *this, unsigned __int8 *a2)
{
  *this = __rev16(a2);
  return this;
}

double ProCore::Private::getS15Fixed16Number(ProCore::Private *this, const unsigned __int8 *a2)
{
  return (double)(int)bswap32(*(_DWORD *)this) * 0.0000152587891;
}

double ProCore::Private::convertFromS15Fixed16(ProCore::Private *this)
{
  return (double)(int)this * 0.0000152587891;
}

unint64_t ProCore::Private::convertToS15Fixed16(ProCore::Private *this, double a2)
{
  double v2 = a2 * 131072.0;
  if (a2 > 32768.0) {
    double v2 = 4294967290.0;
  }
  BOOL v3 = a2 < -32768.0;
  double v4 = -4294967300.0;
  if (!v3) {
    double v4 = v2;
  }
  return (unint64_t)((uint64_t)v4 + 1) >> 1;
}

double ProCore::Private::convertFromU8Fixed8(ProCore::Private *this)
{
  return (double)this * 0.00390625;
}

uint64_t ProCore::Private::convertToU8Fixed8(ProCore::Private *this, double a2)
{
  double v2 = a2 * 512.0;
  if (a2 > 255.996094) {
    double v2 = 131070.0;
  }
  BOOL v3 = a2 < 0.0;
  double v4 = 0.0;
  if (!v3) {
    double v4 = v2;
  }
  return (unsigned __int16)(((uint64_t)v4 + 1) >> 1);
}

_DWORD *ProCore::Private::setUInt32NumberLE(_DWORD *this, unsigned __int8 *a2)
{
  *this = a2;
  return this;
}

unsigned char *ProCore::Private::add8Fixed8ToTag(ProCore::Private *this, PCICCTag *a2, double a3)
{
  uint64_t v5 = PCICCTag::size(this);
  PCICCTag::resize(this, v5 + 2);
  double result = (unsigned char *)PCICCTag::operator[]((uint64_t)this, v5);
  double v7 = a3 * 512.0;
  if (a3 > 255.996094) {
    double v7 = 131070.0;
  }
  if (a3 < 0.0) {
    double v7 = 0.0;
  }
  unint64_t v8 = (uint64_t)v7 + 1;
  *double result = v8 >> 9;
  result[1] = v8 >> 1;
  return result;
}

_WORD *ProCore::Private::addInt16ToTag(ProCore::Private *this, PCICCTag *a2)
{
  unsigned int v2 = a2;
  uint64_t v4 = PCICCTag::size(this);
  PCICCTag::resize(this, v4 + 2);
  double result = (_WORD *)PCICCTag::operator[]((uint64_t)this, v4);
  *double result = __rev16(v2);
  return result;
}

_DWORD *ProCore::Private::addInt32ToTag(ProCore::Private *this, PCICCTag *a2)
{
  unsigned int v2 = a2;
  uint64_t v4 = PCICCTag::size(this);
  PCICCTag::resize(this, v4 + 4);
  double result = (_DWORD *)PCICCTag::operator[]((uint64_t)this, v4);
  *double result = bswap32(v2);
  return result;
}

unsigned char *ProCore::Private::add15Fixed16ToTag(ProCore::Private *this, PCICCTag *a2, double a3)
{
  uint64_t v5 = PCICCTag::size(this);
  PCICCTag::resize(this, v5 + 4);
  double result = (unsigned char *)PCICCTag::operator[]((uint64_t)this, v5);
  double v7 = a3 * 131072.0;
  if (a3 > 32768.0) {
    double v7 = 4294967290.0;
  }
  if (a3 < -32768.0) {
    double v7 = -4294967300.0;
  }
  unint64_t v8 = (uint64_t)v7 + 1;
  *double result = v8 >> 25;
  result[1] = v8 >> 17;
  result[2] = v8 >> 9;
  result[3] = v8 >> 1;
  return result;
}

void ProCore::Private::addStringToTag(ProCore::Private *this, PCICCTag *a2, const char *a3)
{
  int v3 = (int)a3;
  char v5 = *(unsigned char *)a2;
  if (*(unsigned char *)a2)
  {
    uint64_t v6 = (unsigned __int8 *)a2 + 1;
    do
    {
      PCICCTag::push_back(this, v5);
      int v7 = *v6++;
      char v5 = v7;
    }
    while (v7);
  }
  if (v3)
  {
    PCICCTag::push_back(this, 0);
  }
}

void pcAbortImpl()
{
}

uint64_t PCGetPrimariesString(int a1)
{
  uint64_t result = 0;
  switch(a1)
  {
    case 1:
      int v3 = (uint64_t *)MEMORY[0x1E4F24AB0];
      goto LABEL_8;
    case 5:
      int v3 = (uint64_t *)MEMORY[0x1E4F24AA0];
      goto LABEL_8;
    case 6:
      int v3 = (uint64_t *)MEMORY[0x1E4F24AC8];
      goto LABEL_8;
    case 9:
      int v3 = (uint64_t *)MEMORY[0x1E4F24AA8];
      goto LABEL_8;
    case 11:
      int v3 = (uint64_t *)MEMORY[0x1E4F24A98];
      goto LABEL_8;
    case 12:
      int v3 = (uint64_t *)MEMORY[0x1E4F24AC0];
LABEL_8:
      uint64_t result = *v3;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t PCGetTransferFunctionString(int a1)
{
  uint64_t result = 0;
  switch(a1)
  {
    case 1:
      int v3 = (uint64_t *)MEMORY[0x1E4F24BE0];
      goto LABEL_11;
    case 2:
      int v3 = (uint64_t *)MEMORY[0x1E4F24C08];
      goto LABEL_11;
    case 7:
      int v3 = (uint64_t *)MEMORY[0x1E4F24BF0];
      goto LABEL_11;
    case 8:
      int v3 = (uint64_t *)MEMORY[0x1E4F24BE8];
      goto LABEL_11;
    case 13:
      int v3 = (uint64_t *)MEMORY[0x1E4F24C10];
      goto LABEL_11;
    case 14:
      int v3 = (uint64_t *)MEMORY[0x1E4F24BD0];
      goto LABEL_11;
    case 16:
      int v3 = (uint64_t *)MEMORY[0x1E4F24BF8];
      goto LABEL_11;
    case 17:
      int v3 = (uint64_t *)MEMORY[0x1E4F24C00];
      goto LABEL_11;
    case 18:
      int v3 = (uint64_t *)MEMORY[0x1E4F24BD8];
LABEL_11:
      uint64_t result = *v3;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t PCGetMatrixString(int a1)
{
  uint64_t result = 0;
  switch(a1)
  {
    case 1:
      int v3 = (uint64_t *)MEMORY[0x1E4F24C48];
      goto LABEL_6;
    case 6:
      int v3 = (uint64_t *)MEMORY[0x1E4F24C40];
      goto LABEL_6;
    case 7:
      int v3 = (uint64_t *)MEMORY[0x1E4F24C60];
      goto LABEL_6;
    case 9:
      int v3 = (uint64_t *)MEMORY[0x1E4F24C30];
LABEL_6:
      uint64_t result = *v3;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t PCClassifyPrimaries(float *a1)
{
  float v1 = *a1;
  if (vabds_f32(*a1, 0.64) < 0.001
    && vabds_f32(a1[1], 0.33) < 0.001
    && vabds_f32(a1[2], 0.3) < 0.001
    && vabds_f32(a1[3], 0.6) < 0.001
    && vabds_f32(a1[4], 0.15) < 0.001
    && vabds_f32(a1[5], 0.06) < 0.001
    && vabds_f32(a1[6], 0.3127) < 0.001
    && vabds_f32(a1[7], 0.329) < 0.001)
  {
    return 1;
  }
  if (vabds_f32(v1, 0.64) < 0.001
    && vabds_f32(a1[1], 0.33) < 0.001
    && vabds_f32(a1[2], 0.29) < 0.001
    && vabds_f32(a1[3], 0.6) < 0.001
    && vabds_f32(a1[4], 0.15) < 0.001
    && vabds_f32(a1[5], 0.06) < 0.001
    && vabds_f32(a1[6], 0.3127) < 0.001
    && vabds_f32(a1[7], 0.329) < 0.001)
  {
    return 5;
  }
  if (vabds_f32(v1, 0.63) < 0.001
    && vabds_f32(a1[1], 0.34) < 0.001
    && vabds_f32(a1[2], 0.31) < 0.001
    && vabds_f32(a1[3], 0.595) < 0.001
    && vabds_f32(a1[4], 0.155) < 0.001
    && vabds_f32(a1[5], 0.07) < 0.001
    && vabds_f32(a1[6], 0.3127) < 0.001
    && vabds_f32(a1[7], 0.329) < 0.001)
  {
    return 6;
  }
  if (vabds_f32(v1, 0.708) < 0.001
    && vabds_f32(a1[1], 0.292) < 0.001
    && vabds_f32(a1[2], 0.17) < 0.001
    && vabds_f32(a1[3], 0.797) < 0.001
    && vabds_f32(a1[4], 0.131) < 0.001
    && vabds_f32(a1[5], 0.046) < 0.001
    && vabds_f32(a1[6], 0.3127) < 0.001
    && vabds_f32(a1[7], 0.329) < 0.001)
  {
    return 9;
  }
  if (vabds_f32(v1, 0.68) < 0.001
    && vabds_f32(a1[1], 0.32) < 0.001
    && vabds_f32(a1[2], 0.265) < 0.001
    && vabds_f32(a1[3], 0.69) < 0.001
    && vabds_f32(a1[4], 0.15) < 0.001
    && vabds_f32(a1[5], 0.06) < 0.001
    && vabds_f32(a1[6], 0.314) < 0.001
    && vabds_f32(a1[7], 0.351) < 0.001)
  {
    return 11;
  }
  if (vabds_f32(v1, 0.68) >= 0.001
    || vabds_f32(a1[1], 0.32) >= 0.001
    || vabds_f32(a1[2], 0.265) >= 0.001
    || vabds_f32(a1[3], 0.69) >= 0.001
    || vabds_f32(a1[4], 0.15) >= 0.001
    || vabds_f32(a1[5], 0.06) >= 0.001)
  {
    return 2;
  }
  uint64_t v2 = 2;
  if (vabds_f32(a1[6], 0.3127) < 0.001)
  {
    if (fabsf(a1[7] - 0.329) >= 0.001) {
      return 2;
    }
    else {
      return 12;
    }
  }
  return v2;
}

uint64_t PCClassifyTransfer(float a1)
{
  if (fabsf(a1 + -1.961) < 0.001) {
    return 1;
  }
  if (fabsf(a1 + -1.0) < 0.001) {
    return 8;
  }
  if (fabsf(a1 + -2.6) >= 0.001) {
    return 2;
  }
  return 17;
}

uint64_t PCPrimariesToMatrix(int a1)
{
  if ((a1 - 1) > 0xB) {
    return 2;
  }
  else {
    return dword_1B7E7CA8C[a1 - 1];
  }
}

unint64_t PCMakeNCLCCode(unsigned int a1, uint64_t a2)
{
  return a1 | (unint64_t)(a2 << 32);
}

unint64_t PCMakeCanonicalNCLCCode(unsigned int a1, uint64_t a2, unsigned int a3)
{
  unsigned int v3 = 2;
  if (a1 > 0xC || a2 > 0x12)
  {
    uint64_t v4 = 2;
    return v3 | (unint64_t)(v4 << 32);
  }
  uint64_t v4 = 2;
  if (supportedPrimariesTable[a1])
  {
    if (a3 > 9) {
      goto LABEL_16;
    }
    uint64_t v4 = 2;
    if (!supportedTransfersTable[a2]) {
      return v3 | (unint64_t)(v4 << 32);
    }
    if (!supportedMatricesTable[a3])
    {
LABEL_16:
      uint64_t v4 = 2;
      return v3 | (unint64_t)(v4 << 32);
    }
    if (a2 == 14) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = a2;
    }
    if (v4 == 8 || v4 == 13)
    {
      unsigned int v3 = a1;
LABEL_13:
      uint64_t v4 = a2;
      return v3 | (unint64_t)(v4 << 32);
    }
    if (a1 == 12 && v4 == 1)
    {
      uint64_t v4 = 1;
      unsigned int v3 = 12;
      return v3 | (unint64_t)(v4 << 32);
    }
    if (a1 == 11 && v4 == 17)
    {
      uint64_t v4 = 17;
      unsigned int v3 = 11;
      return v3 | (unint64_t)(v4 << 32);
    }
    int v6 = v4 & 0xFFFFFFFD;
    if (a1 == 9 && v6 == 16)
    {
      unsigned int v3 = 9;
      uint64_t v4 = a2;
      return v3 | (unint64_t)(v4 << 32);
    }
    if (a1 == 12 && v6 == 16)
    {
      unsigned int v3 = 12;
      goto LABEL_13;
    }
    if (a3)
    {
      unsigned int v3 = a1;
    }
    else if (((1 << a1) & 0x1802) != 0 || ((1 << a1) & 0x60) != 0 || a1 != 9)
    {
      unsigned int v3 = a1;
    }
    else
    {
      unsigned int v3 = 9;
    }
  }
  return v3 | (unint64_t)(v4 << 32);
}

unint64_t PCMakeCanonicalNCLCCode(unsigned int *a1)
{
  return PCMakeCanonicalNCLCCode(*a1, a1[1], a1[2]);
}

BOOL PCIsUsableNCLCCode(unsigned int *a1)
{
  uint64_t v1 = *a1;
  if (v1 > 0xC) {
    return 0;
  }
  uint64_t v2 = a1[1];
  int v3 = supportedPrimariesTable[v1];
  if (v2 > 0x12 || v3 == 0) {
    return 0;
  }
  uint64_t v5 = a1[2];
  int v6 = supportedTransfersTable[v2];
  return v5 <= 9 && v6 != 0 && supportedMatricesTable[v5] != 0;
}

unint64_t PCMakeRGBNCLCCode(unsigned int a1, uint64_t a2)
{
  return a1 | (unint64_t)(a2 << 32);
}

uint64_t PCMakeRGBNCLCCode(uint64_t a1)
{
  return *(void *)a1;
}

BOOL PCNCLCCodeIsKnownRGB(_DWORD *a1)
{
  return (a1[1] & 0xFFFFFFFD) != 0 && (*a1 & 0xFFFFFFFD) != 0;
}

BOOL PCNCLCCodeCompareRGB(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

BOOL operator!=(_DWORD *a1, _DWORD *a2)
{
  return *a1 != *a2 || a1[1] != a2[1] || a1[2] != a2[2];
}

BOOL operator<(_DWORD *a1, _DWORD *a2)
{
  BOOL v2 = *a1 < *a2;
  if (*a1 == *a2)
  {
    int v3 = a1[1];
    int v4 = a2[1];
    BOOL v2 = v3 < v4;
    if (v3 == v4) {
      return a1[2] < a2[2];
    }
  }
  return v2;
}

void *PCMD5::writeBytes(PCMD5 *this, char *__src, size_t __n)
{
  size_t v3 = __n;
  *(void *)this += __n;
  int v6 = (char *)this + 28;
  uint64_t v7 = *((unsigned int *)this + 151);
  if (v7 + __n >= 0x200)
  {
    unint64_t v8 = &v6[v7];
    size_t v9 = (512 - v7);
    do
    {
      memcpy(v8, __src, v9);
      PCMD5::flushBlocks((uint64_t)this, 8);
      __src += v9;
      *((_DWORD *)this + 151) = 0;
      v3 -= v9;
      size_t v9 = 512;
      unint64_t v8 = v6;
    }
    while (v3 > 0x1FF);
    uint64_t v7 = 0;
  }
  uint64_t result = memcpy(&v6[v7], __src, v3);
  *((_DWORD *)this + 151) += v3;
  return result;
}

uint64_t PCMD5::flushBlocks(uint64_t this, uint64_t a2)
{
  int v2 = *(_DWORD *)(this + 8);
  int v3 = *(_DWORD *)(this + 12);
  int v4 = *(_DWORD *)(this + 16);
  int v5 = *(_DWORD *)(this + 20);
  uint64_t v86 = (_DWORD *)this;
  if (a2)
  {
    int v6 = (_DWORD *)(this + 44);
    do
    {
      int v7 = *(v6 - 4);
      int v8 = *(v6 - 3);
      HIDWORD(v9) = v2 + (v4 & v3 | v5 & ~v3) - 680876936 + v7;
      LODWORD(v9) = HIDWORD(v9);
      int v10 = (v9 >> 25) + v3;
      HIDWORD(v9) = v5 + v8 - 389564586 + (v3 & v10 | v4 & ~v10);
      LODWORD(v9) = HIDWORD(v9);
      int v11 = (v9 >> 20) + v10;
      int v13 = *(v6 - 2);
      int v12 = *(v6 - 1);
      HIDWORD(v9) = v4 + v13 + 606105819 + (v10 & v11 | v3 & ~v11);
      LODWORD(v9) = HIDWORD(v9);
      int v14 = (v9 >> 15) + v11;
      HIDWORD(v9) = v3 + v12 - 1044525330 + (v11 & v14 | v10 & ~v14);
      LODWORD(v9) = HIDWORD(v9);
      int v15 = (v9 >> 10) + v14;
      int v16 = v6[1];
      HIDWORD(v9) = *v6 + v10 - 176418897 + (v14 & v15 | v11 & ~v15);
      LODWORD(v9) = HIDWORD(v9);
      int v17 = (v9 >> 25) + v15;
      HIDWORD(v9) = v16 + v11 + 1200080426 + (v15 & v17 | v14 & ~v17);
      LODWORD(v9) = HIDWORD(v9);
      int v18 = (v9 >> 20) + v17;
      int v20 = v6[2];
      int v19 = v6[3];
      HIDWORD(v9) = v20 + v14 - 1473231341 + (v17 & v18 | v15 & ~v18);
      LODWORD(v9) = HIDWORD(v9);
      int v21 = (v9 >> 15) + v18;
      HIDWORD(v9) = v19 + v15 - 45705983 + (v18 & v21 | v17 & ~v21);
      LODWORD(v9) = HIDWORD(v9);
      int v22 = (v9 >> 10) + v21;
      int v23 = v6[4];
      int v24 = v6[5];
      HIDWORD(v9) = v23 + v17 + 1770035416 + (v21 & v22 | v18 & ~v22);
      LODWORD(v9) = HIDWORD(v9);
      int v25 = (v9 >> 25) + v22;
      HIDWORD(v9) = v24 + v18 - 1958414417 + (v22 & v25 | v21 & ~v25);
      LODWORD(v9) = HIDWORD(v9);
      int v26 = (v9 >> 20) + v25;
      int v27 = v6[6];
      int v28 = v6[7];
      HIDWORD(v9) = v27 + v21 - 42063 + (v25 & v26 | v22 & ~v26);
      LODWORD(v9) = HIDWORD(v9);
      int v29 = (v9 >> 15) + v26;
      HIDWORD(v9) = v28 + v22 - 1990404162 + (v26 & v29 | v25 & ~v29);
      LODWORD(v9) = HIDWORD(v9);
      int v30 = (v9 >> 10) + v29;
      int v32 = v6[8];
      int v31 = v6[9];
      HIDWORD(v9) = v32 + v25 + 1804603682 + (v29 & v30 | v26 & ~v30);
      LODWORD(v9) = HIDWORD(v9);
      int v33 = (v9 >> 25) + v30;
      HIDWORD(v9) = v31 + v26 - 40341101 + (v30 & v33 | v29 & ~v33);
      LODWORD(v9) = HIDWORD(v9);
      int v34 = (v9 >> 20) + v33;
      int v36 = v6[10];
      int v35 = v6[11];
      HIDWORD(v9) = v36 + v29 - 1502002290 + (v33 & v34 | v30 & ~v34);
      LODWORD(v9) = HIDWORD(v9);
      int v37 = (v9 >> 15) + v34;
      HIDWORD(v9) = v35 + v30 + 1236535329 + (v34 & v37 | v33 & ~v37);
      LODWORD(v9) = HIDWORD(v9);
      int v38 = (v9 >> 10) + v37;
      HIDWORD(v9) = v8 + v33 + (v37 & ~v34) - 165796510 + (v38 & v34);
      LODWORD(v9) = HIDWORD(v9);
      int v39 = (v9 >> 27) + v38;
      HIDWORD(v9) = v20 + v34 + (v38 & ~v37) - 1069501632 + (v39 & v37);
      LODWORD(v9) = HIDWORD(v9);
      int v40 = (v9 >> 23) + v39;
      HIDWORD(v9) = v28 + v37 + (v39 & ~v38) + 643717713 + (v40 & v38);
      LODWORD(v9) = HIDWORD(v9);
      int v41 = (v9 >> 18) + v40;
      HIDWORD(v9) = v7 + v38 + (v40 & ~v39) - 373897302 + (v41 & v39);
      LODWORD(v9) = HIDWORD(v9);
      int v42 = (v9 >> 12) + v41;
      HIDWORD(v9) = v16 + v39 + (v41 & ~v40) - 701558691 + (v42 & v40);
      LODWORD(v9) = HIDWORD(v9);
      int v43 = (v9 >> 27) + v42;
      HIDWORD(v9) = v27 + v40 + (v42 & ~v41) + 38016083 + (v43 & v41);
      LODWORD(v9) = HIDWORD(v9);
      int v44 = (v9 >> 23) + v43;
      HIDWORD(v9) = v35 + v41 + (v43 & ~v42) - 660478335 + (v44 & v42);
      LODWORD(v9) = HIDWORD(v9);
      int v45 = (v9 >> 18) + v44;
      HIDWORD(v9) = *v6 + v42 + (v44 & ~v43) - 405537848 + (v45 & v43);
      LODWORD(v9) = HIDWORD(v9);
      int v46 = (v9 >> 12) + v45;
      HIDWORD(v9) = v24 + v43 + (v45 & ~v44) + 568446438 + (v46 & v44);
      LODWORD(v9) = HIDWORD(v9);
      int v47 = (v9 >> 27) + v46;
      HIDWORD(v9) = v36 + v44 + (v46 & ~v45) - 1019803690 + (v47 & v45);
      LODWORD(v9) = HIDWORD(v9);
      int v48 = (v9 >> 23) + v47;
      HIDWORD(v9) = v12 + v45 + (v47 & ~v46) - 187363961 + (v48 & v46);
      LODWORD(v9) = HIDWORD(v9);
      int v49 = (v9 >> 18) + v48;
      HIDWORD(v9) = v23 + v46 + (v48 & ~v47) + 1163531501 + (v49 & v47);
      LODWORD(v9) = HIDWORD(v9);
      int v50 = (v9 >> 12) + v49;
      HIDWORD(v9) = v31 + v47 + (v49 & ~v48) - 1444681467 + (v50 & v48);
      LODWORD(v9) = HIDWORD(v9);
      int v51 = (v9 >> 27) + v50;
      HIDWORD(v9) = v13 + v48 + (v50 & ~v49) - 51403784 + (v51 & v49);
      LODWORD(v9) = HIDWORD(v9);
      int v52 = (v9 >> 23) + v51;
      HIDWORD(v9) = v19 + v49 + (v51 & ~v50) + 1735328473 + (v52 & v50);
      LODWORD(v9) = HIDWORD(v9);
      int v53 = (v9 >> 18) + v52;
      HIDWORD(v9) = v32 + v50 + (v52 & ~v51) - 1926607734 + (v53 & v51);
      LODWORD(v9) = HIDWORD(v9);
      int v54 = (v9 >> 12) + v53;
      HIDWORD(v9) = v16 + v51 - 378558 + (v54 ^ v53 ^ v52);
      LODWORD(v9) = HIDWORD(v9);
      int v55 = (v9 >> 28) + v54;
      HIDWORD(v9) = v23 + v52 - 2022574463 + (v55 ^ v54 ^ v53);
      LODWORD(v9) = HIDWORD(v9);
      int v56 = (v9 >> 21) + v55;
      HIDWORD(v9) = v28 + v53 + 1839030562 + (v56 ^ v55 ^ v54);
      LODWORD(v9) = HIDWORD(v9);
      int v57 = (v9 >> 16) + v56;
      HIDWORD(v9) = v36 + v54 - 35309556 + (v56 ^ v55 ^ v57);
      LODWORD(v9) = HIDWORD(v9);
      int v58 = (v9 >> 9) + v57;
      HIDWORD(v9) = v8 + v55 - 1530992060 + (v57 ^ v56 ^ v58);
      LODWORD(v9) = HIDWORD(v9);
      int v59 = (v9 >> 28) + v58;
      HIDWORD(v9) = *v6 + v56 + 1272893353 + (v58 ^ v57 ^ v59);
      LODWORD(v9) = HIDWORD(v9);
      int v60 = (v9 >> 21) + v59;
      HIDWORD(v9) = v19 + v57 - 155497632 + (v59 ^ v58 ^ v60);
      LODWORD(v9) = HIDWORD(v9);
      int v61 = (v9 >> 16) + v60;
      HIDWORD(v9) = v27 + v58 - 1094730640 + (v60 ^ v59 ^ v61);
      LODWORD(v9) = HIDWORD(v9);
      int v62 = (v9 >> 9) + v61;
      HIDWORD(v9) = v31 + v59 + 681279174 + (v61 ^ v60 ^ v62);
      LODWORD(v9) = HIDWORD(v9);
      int v63 = (v9 >> 28) + v62;
      HIDWORD(v9) = v7 + v60 - 358537222 + (v62 ^ v61 ^ v63);
      LODWORD(v9) = HIDWORD(v9);
      int v64 = (v9 >> 21) + v63;
      HIDWORD(v9) = v12 + v61 - 722521979 + (v63 ^ v62 ^ v64);
      LODWORD(v9) = HIDWORD(v9);
      int v65 = (v9 >> 16) + v64;
      HIDWORD(v9) = v20 + v62 + 76029189 + (v64 ^ v63 ^ v65);
      LODWORD(v9) = HIDWORD(v9);
      int v66 = (v9 >> 9) + v65;
      HIDWORD(v9) = v24 + v63 - 640364487 + (v65 ^ v64 ^ v66);
      LODWORD(v9) = HIDWORD(v9);
      int v67 = (v9 >> 28) + v66;
      HIDWORD(v9) = v32 + v64 - 421815835 + (v66 ^ v65 ^ v67);
      LODWORD(v9) = HIDWORD(v9);
      int v68 = (v9 >> 21) + v67;
      HIDWORD(v9) = v35 + v65 + 530742520 + (v67 ^ v66 ^ v68);
      LODWORD(v9) = HIDWORD(v9);
      int v69 = (v9 >> 16) + v68;
      HIDWORD(v9) = v13 + v66 - 995338651 + (v68 ^ v67 ^ v69);
      LODWORD(v9) = HIDWORD(v9);
      int v70 = (v9 >> 9) + v69;
      HIDWORD(v9) = v7 + v67 - 198630844 + ((v70 | ~v68) ^ v69);
      LODWORD(v9) = HIDWORD(v9);
      int v71 = (v9 >> 26) + v70;
      HIDWORD(v9) = v19 + v68 + 1126891415 + ((v71 | ~v69) ^ v70);
      LODWORD(v9) = HIDWORD(v9);
      int v72 = (v9 >> 22) + v71;
      HIDWORD(v9) = v36 + v69 - 1416354905 + ((v72 | ~v70) ^ v71);
      LODWORD(v9) = HIDWORD(v9);
      int v73 = (v9 >> 17) + v72;
      HIDWORD(v9) = v16 + v70 - 57434055 + ((v73 | ~v71) ^ v72);
      LODWORD(v9) = HIDWORD(v9);
      int v74 = (v9 >> 11) + v73;
      HIDWORD(v9) = v32 + v71 + 1700485571 + ((v74 | ~v72) ^ v73);
      LODWORD(v9) = HIDWORD(v9);
      int v75 = (v9 >> 26) + v74;
      HIDWORD(v9) = v12 + v72 - 1894986606 + ((v75 | ~v73) ^ v74);
      LODWORD(v9) = HIDWORD(v9);
      int v76 = (v9 >> 22) + v75;
      HIDWORD(v9) = v27 + v73 - 1051523 + ((v76 | ~v74) ^ v75);
      LODWORD(v9) = HIDWORD(v9);
      int v77 = (v9 >> 17) + v76;
      HIDWORD(v9) = v8 + v74 - 2054922799 + ((v77 | ~v75) ^ v76);
      LODWORD(v9) = HIDWORD(v9);
      int v78 = (v9 >> 11) + v77;
      HIDWORD(v9) = v23 + v75 + 1873313359 + ((v78 | ~v76) ^ v77);
      LODWORD(v9) = HIDWORD(v9);
      int v79 = (v9 >> 26) + v78;
      HIDWORD(v9) = v35 + v76 - 30611744 + ((v79 | ~v77) ^ v78);
      LODWORD(v9) = HIDWORD(v9);
      int v80 = (v9 >> 22) + v79;
      HIDWORD(v9) = v20 + v77 - 1560198380 + ((v80 | ~v78) ^ v79);
      LODWORD(v9) = HIDWORD(v9);
      int v81 = (v9 >> 17) + v80;
      HIDWORD(v9) = v31 + v78 + 1309151649 + ((v81 | ~v79) ^ v80);
      LODWORD(v9) = HIDWORD(v9);
      int v82 = (v9 >> 11) + v81;
      HIDWORD(v9) = *v6 + v79 - 145523070 + ((v82 | ~v80) ^ v81);
      LODWORD(v9) = HIDWORD(v9);
      int v83 = (v9 >> 26) + v82;
      HIDWORD(v9) = v28 + v80 - 1120210379 + ((v83 | ~v81) ^ v82);
      LODWORD(v9) = HIDWORD(v9);
      int v84 = (v9 >> 22) + v83;
      HIDWORD(v9) = v13 + v81 + 718787259 + ((v84 | ~v82) ^ v83);
      LODWORD(v9) = HIDWORD(v9);
      int v85 = (v9 >> 17) + v84;
      this = 3951481745;
      v2 += v83;
      HIDWORD(v9) = v24 + v82 - 343485551 + ((v85 | ~v83) ^ v84);
      LODWORD(v9) = HIDWORD(v9);
      v3 += v85 + (v9 >> 11);
      v4 += v85;
      v5 += v84;
      v6 += 16;
      --a2;
    }
    while (a2);
  }
  v86[2] = v2;
  v86[3] = v3;
  v86[4] = v4;
  v86[5] = v5;
  return this;
}

uint64_t PCMD5::finish(PCMD5 *this)
{
  uint64_t v2 = *((unsigned int *)this + 151);
  unsigned int v3 = ((v2 + 63) & 0xFFFFFFC0) - v2;
  if (v3 >= 9) {
    int v4 = -8;
  }
  else {
    int v4 = 56;
  }
  uint64_t v5 = v4 + v3;
  *((unsigned char *)this + v2 + 28) = 0x80;
  int v6 = (char *)this + v2 + 29;
  if (v5 != 1)
  {
    bzero(v6, v5 - 1);
    int v6 = (char *)this + v2 + v5 + 28;
  }
  uint64_t v7 = 0;
  unint64_t v8 = 8 * *(void *)this;
  do
  {
    v6[v7] = v8;
    v8 >>= 8;
    ++v7;
  }
  while (v7 != 8);
  uint64_t v9 = v6 - (char *)this + 43;
  if (v6 - (char *)this - 20 >= 0) {
    uint64_t v9 = v6 - (char *)this - 20;
  }
  uint64_t result = PCMD5::flushBlocks((uint64_t)this, v9 >> 6);
  *((unsigned char *)this + 24) = 1;
  return result;
}

void PCMD5::getHash(PCMD5 *this@<X0>, PCHash128 *a2@<X8>)
{
  if (!*((unsigned char *)this + 24)) {
    PCMD5::finish(this);
  }
  int v4 = *((_DWORD *)this + 2);
  int v5 = *((_DWORD *)this + 3);
  int v6 = *((_DWORD *)this + 4);
  int v7 = *((_DWORD *)this + 5);

  PCHash128::PCHash128(a2, v4, v5, v6, v7);
}

FILE *PCPrint(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return PCPrintVA(a1, &a9);
}

FILE *PCPrintVA(char *a1, va_list a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (_pcPrint_Initialized)
  {
    if (_pcPrint_UseLogFile)
    {
LABEL_3:
      pid_t v4 = getpid();
      snprintf(__str, 0x400uLL, "/tmp/output.%d.log", v4);
      uint64_t result = (FILE *)PCPrintVA::logFile;
      if (PCPrintVA::logFile || (uint64_t result = fopen(__str, "w"), (PCPrintVA::logFile = (uint64_t)result) != 0))
      {
        vfprintf(result, a1, a2);
        return (FILE *)fflush((FILE *)PCPrintVA::logFile);
      }
      return result;
    }
  }
  else
  {
    _pcPrint_UseLogFile = 0;
    BOOL v6 = getenv("pcPrintUseLogFile") != 0;
    _pcPrint_UseLogFile = v6;
    _pcPrint_Initialized = 1;
    if (v6) {
      goto LABEL_3;
    }
  }

  return (FILE *)vprintf(a1, a2);
}

void PCException_WriteError::~PCException_WriteError(PCString *this)
{
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

id *ProCore_Impl::PCNSRefImpl::operator=(id *a1, id *a2)
{
  if (*a2 != *a1)
  {
    id v4 = *a2;

    *a1 = *a2;
  }
  return a1;
}

{
  if (*a2 != *a1)
  {

    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

id ProCore_Impl::PCNSRefImpl::retain(id *this)
{
  return *this;
}

void ProCore_Impl::PCNSRefImpl::release(id *this)
{
}

void PCBufferWriteStream::PCBufferWriteStream(PCBufferWriteStream *this, int a2, int a3)
{
  PCStream::PCStream(this);
  *BOOL v6 = &unk_1F10C3838;
  int v7 = (char *)malloc_type_malloc(a2, 0x78F915A1uLL);
  *((void *)this + 1) = v7;
  if (!v7)
  {
    exceptioint n = (PCException *)__cxa_allocate_exception(0x40uLL);
    *(_OWORD *)exceptioint n = 0u;
    *((_OWORD *)exception + 1) = 0u;
    *((_OWORD *)exception + OZChannelFontBase::~OZChannelFontBase(this - 2) = 0u;
    *((_OWORD *)exception + 3) = 0u;
    PCException::PCException(exception);
    *(void *)exceptioint n = &unk_1F10C37F8;
  }
  *((void *)this + OZChannelFontBase::~OZChannelFontBase(this - 2) = v7;
  *((void *)this + 3) = &v7[a2];
  *((void *)this + 4) = v7;
  *((_DWORD *)this + 10) = a2;
  *((_DWORD *)this + 11) = a3;
}

void sub_1B76A303C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  OZChannelBase::setRangeName(v1, v4);
  _Unwind_Resume(a1);
}

void PCBufferWriteStream::~PCBufferWriteStream(OZChannelBase *this, const PCString *a2)
{
  this->var0 = (void **)&unk_1F10C3838;
  var1 = this->var1;
  if (var1) {
    free(var1);
  }

  OZChannelBase::setRangeName(this, a2);
}

{
  uint64_t vars8;

  PCBufferWriteStream::~PCBufferWriteStream(this, a2);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PCBufferWriteStream::read(PCBufferWriteStream *this, void *a2)
{
  return 0;
}

size_t PCBufferWriteStream::write(PCBufferWriteStream *this, const void *__src, size_t __n)
{
  BOOL v6 = (char *)*((void *)this + 2);
  unint64_t v7 = *((void *)this + 3);
  if ((unint64_t)&v6[__n] >= v7)
  {
    unsigned int v8 = v6 + __n - v7;
    if (*((_DWORD *)this + 11) > v8) {
      unsigned int v8 = *((_DWORD *)this + 11);
    }
    size_t v9 = *((_DWORD *)this + 10) + v8;
    uint64_t v10 = *((void *)this + 1);
    size_t v11 = *((void *)this + 4) - v10;
    int v12 = &v6[-v10];
    int v13 = malloc_type_malloc(v9, 0x4242E35FuLL);
    memcpy(v13, *((const void **)this + 1), v11);
    free(*((void **)this + 1));
    BOOL v6 = &v12[(void)v13];
    *((void *)this + 1) = v13;
    *((void *)this + OZChannelFontBase::~OZChannelFontBase(this - 2) = &v12[(void)v13];
    *((_DWORD *)this + 10) = v9;
    *((void *)this + 3) = (char *)v13 + v9;
    *((void *)this + 4) = (char *)v13 + v11;
  }
  memcpy(v6, __src, __n);
  size_t v14 = *((void *)this + 2) + __n;
  *((void *)this + OZChannelFontBase::~OZChannelFontBase(this - 2) = v14;
  if (v14 > *((void *)this + 4)) {
    *((void *)this + 4) = v14;
  }
  return __n;
}

uint64_t PCBufferWriteStream::getPos(PCBufferWriteStream *this)
{
  return *((void *)this + 2) - *((void *)this + 1);
}

uint64_t PCBufferWriteStream::setPos(uint64_t this, uint64_t a2)
{
  *(void *)(this + 16) = *(void *)(this + 8) + a2;
  return this;
}

void PCBufferWriteStream::getError(PCSharedCount *a1@<X8>)
{
}

CFDataRef PCBufferWriteStream::copyData(const UInt8 **this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  char v6 = 0;
  (*((void (**)(const UInt8 **, char *, uint64_t))*this + 3))(this, &v6, 1);
  unsigned int v3 = this[1];
  uint64_t v4 = (uint64_t)(this[2] - 1);
  this[2] = (const UInt8 *)v4;
  return CFDataCreate(v2, v3, v4 - (void)v3);
}

void PCStream::PCStream(PCStream *this)
{
  *(void *)this = &unk_1F10C3898;
}

uint64_t PCStream::operator<<(uint64_t a1, char *__s)
{
  if (__s && *__s)
  {
    if (__s[1]) {
      size_t v4 = strlen(__s);
    }
    else {
      size_t v4 = 1;
    }
    (*(void (**)(uint64_t, char *, size_t))(*(void *)a1 + 24))(a1, __s, v4);
  }
  return a1;
}

void PCURL::PCURL(PCURL *this, const char *__s, Boolean a3)
{
  CFIndex v6 = strlen(__s);
  if (v6) {
    CFIndex v6 = (CFIndex)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)__s, v6, a3);
  }
  *(void *)this = v6;
}

void PCURL::PCURL(PCURL *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  *(void *)this = cf;
}

void PCURL::PCURL(PCURL *this, PCString *a2, Boolean a3)
{
  PCURL::PCURL((PCURL *)&v10, @"://");
  int v6 = PCString::find(a2, &v10);
  PCString::~PCString(&v10);
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  unsigned int v8 = PCString::cf_str(a2);
  if (v6 < 0) {
    CFURLRef v9 = CFURLCreateWithFileSystemPath(v7, v8, kCFURLPOSIXPathStyle, a3);
  }
  else {
    CFURLRef v9 = CFURLCreateWithString(v7, v8, 0);
  }
  *(void *)this = v9;
}

void sub_1B76A346C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PCURL::PCURL(PCURL *this, CFURLRef *a2)
{
  *(void *)this = 0;
  if (*a2)
  {
    CFStringRef v3 = CFURLGetString(*a2);
    *(void *)this = CFURLCreateWithString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v3, 0);
  }
}

void PCURL::~PCURL(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

const void **PCURL::operator=(const void **a1, const __CFURL **a2)
{
  size_t v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = 0;
  CFURLRef v5 = *a2;
  if (*a2)
  {
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v7 = CFURLGetString(v5);
    *a1 = CFURLCreateWithString(v6, v7, 0);
  }
  return a1;
}

void PCURL::getAbsoluteString(const __CFURL **this@<X0>, PCURL *a2@<X8>)
{
  CFURLRef v3 = *this;
  if (v3)
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v5 = CFURLGetString(v3);
    CFStringRef Copy = CFStringCreateCopy(v4, v5);
    PCURL::PCURL(a2, Copy);
    if (Copy) {
      CFRelease(Copy);
    }
  }
  else
  {
    PCSharedCount::PCSharedCount((PCSharedCount *)a2);
  }
}

void sub_1B76A35F4(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PCURL::getPathAsFileSystemString(CFURLRef *this@<X0>, PCURL *a2@<X8>)
{
  if (*this)
  {
    CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *this);
    CFStringRef v4 = CFURLCopyFileSystemPath(PathComponent, kCFURLPOSIXPathStyle);
    PCURL::PCURL(a2, v4);
    if (v4) {
      CFRelease(v4);
    }
    CFRelease(PathComponent);
  }
  else
  {
    PCSharedCount::PCSharedCount((PCSharedCount *)a2);
  }
}

void sub_1B76A369C(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PCURL::getContainingFolderAsURLString(CFURLRef *this@<X0>, PCURL *a2@<X8>)
{
  if (*this)
  {
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *this);
    CFStringRef v5 = CFURLGetString(PathComponent);
    CFStringRef Copy = CFStringCreateCopy(v3, v5);
    PCURL::PCURL(a2, Copy);
    if (PathComponent) {
      CFRelease(PathComponent);
    }
    if (Copy) {
      CFRelease(Copy);
    }
  }
  else
  {
    PCSharedCount::PCSharedCount((PCSharedCount *)a2);
  }
}

void sub_1B76A3754(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PCURL::getFilename(const __CFURL **this@<X0>, PCString *a2@<X8>)
{
  CFURLRef v3 = *this;
  if (v3)
  {
    CFStringRef PathComponent = CFURLCopyLastPathComponent(v3);
    PCString::PCString(a2, PathComponent, 0);
    if (PathComponent) {
      CFRelease(PathComponent);
    }
  }
  else
  {
    PCSharedCount::PCSharedCount((PCSharedCount *)a2);
  }
}

void sub_1B76A37D4(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PCURL::getShortFilename(CFURLRef *this@<X0>, PCString *a2@<X8>)
{
  if (*this)
  {
    CFURLRef v3 = CFURLCreateCopyDeletingPathExtension((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *this);
    CFStringRef PathComponent = CFURLCopyLastPathComponent(v3);
    PCString::PCString(a2, PathComponent, 0);
    if (PathComponent) {
      CFRelease(PathComponent);
    }
    CFRelease(v3);
  }
  else
  {
    PCSharedCount::PCSharedCount((PCSharedCount *)a2);
  }
}

void sub_1B76A387C(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PCURL::getExtension(const __CFURL **this@<X0>, PCURL *a2@<X8>)
{
  CFURLRef v3 = *this;
  if (v3)
  {
    CFStringRef v4 = CFURLCopyPathExtension(v3);
    PCURL::PCURL(a2, v4);
    if (v4) {
      CFRelease(v4);
    }
  }
  else
  {
    PCSharedCount::PCSharedCount((PCSharedCount *)a2);
  }
}

void sub_1B76A38F8(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PCURL::getAsFileSystemString(const __CFURL **this@<X0>, PCString *a2@<X8>)
{
  CFURLRef v3 = *this;
  if (v3)
  {
    CFStringRef v4 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
    PCString::PCString(a2, v4, 0);
    if (v4) {
      CFRelease(v4);
    }
  }
  else
  {
    PCSharedCount::PCSharedCount((PCSharedCount *)a2);
  }
}

void sub_1B76A397C(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PCURL::getAsURLString(const __CFURL **this@<X0>, PCURL *a2@<X8>)
{
  CFURLRef v3 = *this;
  if (v3)
  {
    CFStringRef v4 = CFURLGetString(v3);
    PCURL::PCURL(a2, v4);
  }
  else
  {
    PCSharedCount::PCSharedCount((PCSharedCount *)a2);
  }
}

uint64_t PCURL::getString(const __CFURL **this, unsigned int *a2)
{
  *a2 = 0;
  CFURLRef v2 = *this;
  if (v2)
  {
    CFStringRef v3 = CFURLCopyFileSystemPath(v2, kCFURLPOSIXPathStyle);
    if (v3)
    {
      CFIndex v5 = 0;
      CFStringGetLength(v3);
      operator new[]();
    }
  }
  return 0;
}

uint64_t PCURL::isSequence(const __CFURL **this)
{
  if (!*this) {
    return 0;
  }
  unsigned int v9 = 0;
  unint64_t String = PCURL::getString(this, &v9);
  uint64_t v2 = 0;
  if (v9 < 2)
  {
LABEL_19:
    if (!String) {
      return v2;
    }
LABEL_20:
    MEMORY[0x1BA9BFB70](String, 0x1000C8077774924);
    return v2;
  }
  int v3 = 0;
  CFStringRef v4 = (unsigned __int8 *)(String + v9 - 1);
  while (1)
  {
    int v5 = *v4;
    if (v5 == 47
      || (v3 & 1) != 0
      && ((v5 - 35) <= 0x38
        ? (BOOL v6 = ((1 << (v5 - 35)) & 0x100000020000001) == 0)
        : (BOOL v6 = 1),
          v6))
    {
LABEL_18:
      uint64_t v2 = 0;
      goto LABEL_19;
    }
    if (v5 == 93) {
      int v3 = 1;
    }
    if (v5 == 91 && v3 != 0) {
      break;
    }
    if ((unint64_t)--v4 <= String) {
      goto LABEL_18;
    }
  }
  uint64_t v2 = 1;
  if (String) {
    goto LABEL_20;
  }
  return v2;
}

uint64_t PCURL::getSequenceStart(PCURL *this, char *a2, int a3)
{
  uint64_t result = 0xFFFFFFFFLL;
  unsigned int v8 = -1;
  if (a3 != 1)
  {
    char v5 = 0;
    BOOL v6 = &a2[a3 - 1];
    while (1)
    {
      int v7 = *v6;
      if (v7 == 58)
      {
        if ((v5 & 1) != 0 && sscanf(v6 + 1, "%d", &v8) == 1) {
          return v8;
        }
        char v5 = 1;
      }
      else if (v7 == 47)
      {
        return v8;
      }
      if (--v6 <= a2) {
        return v8;
      }
    }
  }
  return result;
}

uint64_t PCURL::getSequenceEnd(PCURL *this, char *a2, int a3)
{
  uint64_t result = 0xFFFFFFFFLL;
  unsigned int v9 = -1;
  if (a3 != 1)
  {
    char v5 = &a2[a3 - 1];
    do
    {
      while (1)
      {
        int v6 = *v5;
        if (v6 == 58) {
          break;
        }
        if (v6 != 47 && --v5 > a2) {
          continue;
        }
        return v9;
      }
      int v7 = sscanf(v5-- + 1, "%d", &v9);
    }
    while (v7 != 1 && v5 > a2);
    return v9;
  }
  return result;
}

uint64_t PCURL::getSequenceStart(const __CFURL **this)
{
  unsigned int v4 = 0;
  unint64_t String = (PCURL *)PCURL::getString(this, &v4);
  uint64_t SequenceStart = PCURL::getSequenceStart(String, (char *)String, v4);
  if (String) {
    MEMORY[0x1BA9BFB70](String, 0x1000C8077774924);
  }
  return SequenceStart;
}

uint64_t PCURL::getSequenceEnd(const __CFURL **this)
{
  unsigned int v4 = 0;
  unint64_t String = (PCURL *)PCURL::getString(this, &v4);
  uint64_t SequenceEnd = PCURL::getSequenceEnd(String, (char *)String, v4);
  if (String) {
    MEMORY[0x1BA9BFB70](String, 0x1000C8077774924);
  }
  return SequenceEnd;
}

uint64_t PCURL::getSequenceLength(const __CFURL **this)
{
  unsigned int v7 = 0;
  unint64_t String = (PCURL *)PCURL::getString(this, &v7);
  unsigned int v2 = v7;
  uint64_t SequenceEnd = (PCURL *)PCURL::getSequenceEnd(String, (char *)String, v7);
  int v4 = (int)SequenceEnd;
  int SequenceStart = PCURL::getSequenceStart(SequenceEnd, (char *)String, v2);
  if (String) {
    MEMORY[0x1BA9BFB70](String, 0x1000C8077774924);
  }
  return (v4 - SequenceStart + 1);
}

uint64_t PCURL::getURLforIndex(const __CFURL **this, int a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (*this)
  {
    unsigned int v35 = 0;
    unint64_t String = (PCURL *)PCURL::getString(this, &v35);
    unsigned int v5 = v35;
    int SequenceStart = (PCURL *)PCURL::getSequenceStart(String, (char *)String, v35);
    int v7 = (int)SequenceStart;
    int SequenceEnd = PCURL::getSequenceEnd(SequenceStart, (char *)String, v5);
    if (SequenceEnd - v7 >= a2 || (SequenceEnd | v7) < 0)
    {
      unsigned int v9 = v5 - 1;
      if (v5 != 1)
      {
        char v10 = 0;
        int v11 = v7 & ~(v7 >> 31);
        int v12 = (char *)String + v9;
        while (1)
        {
          if (*v12 == 47) {
            goto LABEL_16;
          }
          int v13 = *v12;
          if ((v10 & 1) == 0)
          {
            v10 |= v13 == 93;
            goto LABEL_15;
          }
          if ((v13 - 35) > 0x38 || ((1 << (v13 - 35)) & 0x100000020000001) == 0) {
            goto LABEL_16;
          }
          if (v13 == 91 && (v10 & 1) != 0) {
            break;
          }
          char v10 = 1;
LABEL_15:
          if (--v12 <= (unsigned char *)String) {
            goto LABEL_16;
          }
        }
        int v16 = 0;
        char v17 = 0;
        int v18 = cStr;
        unsigned __int8 v19 = 91;
        for (uint64_t i = 1; ; ++i)
        {
          if (v19 > 0x5Au)
          {
            if (v19 == 91)
            {
              *(_WORD *)int v18 = 13605;
              v18[2] = 66;
LABEL_27:
              v18 += 3;
              goto LABEL_28;
            }
            if (v19 == 93)
            {
              *(_DWORD *)int v18 = 4470053;
              CFStringRef v21 = CFURLGetString(*this);
              CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
              CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v21);
              if (v17)
              {
                snprintf(v36, 0x20uLL, "%d");
              }
              else
              {
                snprintf(__str, 0x20uLL, "%%0%dd", v16);
                int v24 = fmtcheck(__str, "%d");
                snprintf(v36, 0x20uLL, v24, (v11 + a2));
              }
              CFStringRef v25 = CFStringCreateWithCString(v22, cStr, 0x600u);
              CFStringRef v26 = CFStringCreateWithCString(v22, v36, 0x600u);
              v41.length = CFStringGetLength(MutableCopy);
              v41.locatioint n = 0;
              CFStringFindAndReplace(MutableCopy, v25, v26, v41, 0);
              CFIndex Length = CFStringGetLength(MutableCopy);
              int v28 = (PCURL *)((char *)String + v35 - 1);
              if (v35 == 1)
              {
                CFIndex v30 = Length;
LABEL_47:
                if (*(unsigned char *)v28 == 58)
                {
                  v40.locatioint n = v30 - 1;
                  v40.length = Length - (v30 - 1);
                  CFStringDelete(MutableCopy, v40);
                }
              }
              else
              {
                int v29 = 0;
                CFIndex v30 = Length;
                while (1)
                {
                  int v31 = *(char *)v28;
                  if (v31 == 47 || v31 < 0) {
                    break;
                  }
                  int v32 = *(unsigned __int8 *)v28;
                  if (v32 == 58 || (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *(unsigned __int8 *)v28 + 60) & 0x400) != 0)
                  {
                    if (v32 == 58) {
                      ++v29;
                    }
                    if (v29 != 2)
                    {
                      int v28 = (PCURL *)((char *)v28 - 1);
                      --v30;
                      if (v28 > String) {
                        continue;
                      }
                    }
                  }
                  goto LABEL_47;
                }
              }
              PCURL::PCURL((PCURL *)&v34, MutableCopy);
              operator new();
            }
          }
          else
          {
            if (v19 == 35)
            {
              ++v16;
              *(_WORD *)int v18 = 12837;
              v18[2] = 51;
              goto LABEL_27;
            }
            if (v19 == 64)
            {
              *v18++ = 64;
              char v17 = 1;
            }
          }
LABEL_28:
          unsigned __int8 v19 = v12[i];
        }
      }
    }
LABEL_16:
    if (String) {
      MEMORY[0x1BA9BFB70](String, 0x1000C8077774924);
    }
  }
  return 0;
}

void sub_1B76A420C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCString a11, PCString a12)
{
  PCString::~PCString(&a11);
  MEMORY[0x1BA9BFBA0](v12, 0x60C4044C4A2DFLL);
  PCString::~PCString(&a12);
  _Unwind_Resume(a1);
}

double PCCalculus::ellipticE(PCCalculus *this, double result, double a3)
{
  if (a3 != 0.0)
  {
    unsigned int v4 = vcvtmd_s64_f64(result / 1.57079633);
    double v5 = (double)(int)((v4 & 1) + v4);
    double v6 = result - v5 * 1.57079633;
    if (v6 >= 0.0) {
      long double v7 = result - v5 * 1.57079633;
    }
    else {
      long double v7 = -v6;
    }
    double v8 = 1.0;
    double v9 = 1.0 - a3;
    if (1.0 - a3 <= 0.0 || v9 > 1.0)
    {
      if (v9 != 0.0) {
        double v8 = acos(-5.0);
      }
    }
    else
    {
      double v11 = 0.000153552577;
      uint64_t v12 = 8u;
      do
      {
        double v11 = v9 * v11 + *(double *)((char *)&PCCalculus::ellpe(double)::P + v12);
        v12 += 8;
      }
      while (v12 != 88);
      double v13 = 0.0000327954899;
      uint64_t v14 = 8u;
      do
      {
        double v13 = v9 * v13 + *(double *)((char *)&PCCalculus::ellpe(double)::Q + v14);
        v14 += 8;
      }
      while (v14 != 80);
      double v8 = v11 - log(1.0 - a3) * (v9 * v13);
    }
    if (v9 == 0.0)
    {
      double v15 = sin(v7);
    }
    else
    {
      double v39 = v8;
      double v16 = tan(v7);
      double v17 = sqrt(v9);
      if (fabs(v16) <= 10.0 || (double v18 = 1.0 / (v17 * v16), fabs(v18) >= 10.0))
      {
        double v37 = v6;
        double v38 = v5;
        if (fabs(sqrt(a3)) <= 1.11022302e-16)
        {
          double v25 = 0.0;
          double v27 = 1.0;
          double v31 = 1.0;
          double v30 = 0.0;
        }
        else
        {
          int v24 = 0;
          double v25 = 0.0;
          int v26 = 1;
          double v27 = 1.0;
          do
          {
            long double v7 = (double)v24 * 3.14159265 + v7 + atan(v17 / v27 * v16);
            int v24 = vcvtmd_s64_f64((v7 + 1.57079633) / 3.14159265);
            double v16 = (v17 / v27 + 1.0) * v16 / (1.0 - v16 * (v17 / v27 * v16));
            double v28 = (v27 - v17) * 0.5;
            double v29 = sqrt(v27 * v17);
            double v27 = (v27 + v17) * 0.5;
            v26 *= 2;
            double v25 = v25 + v28 * sin(v7);
            double v17 = v29;
          }
          while (fabs(v28 / v27) > 1.11022302e-16);
          double v30 = (double)v24 * 3.14159265;
          double v31 = (double)v26;
        }
        double v8 = v39;
        if (v9 < 0.0 || v9 > 1.0)
        {
          double v36 = asin(-5.0);
        }
        else if (v9 <= 1.11022302e-16)
        {
          double v36 = log(v9) * -0.5 + 1.38629436;
        }
        else
        {
          double v32 = 0.000137982865;
          uint64_t v33 = 8u;
          do
          {
            double v32 = v9 * v32 + *(double *)((char *)&PCCalculus::ellpk(double)::P + v33);
            v33 += 8;
          }
          while (v33 != 88);
          double v34 = 0.0000294078955;
          uint64_t v35 = 8u;
          do
          {
            double v34 = v9 * v34 + *(double *)((char *)&PCCalculus::ellpk(double)::Q + v35);
            v35 += 8;
          }
          while (v35 != 88);
          double v36 = v32 - log(v9) * v34;
          double v8 = v39;
        }
        double v15 = v25 + v8 / v36 * ((v30 + atan(v16)) / (v27 * v31));
        double v6 = v37;
        double v5 = v38;
      }
      else
      {
        long double v19 = atan(v18);
        long double v20 = sin(v7) * a3;
        double v8 = v39;
        long double v21 = v39 + v20 * sin(v19);
        PCCalculus::ellipticE(v22, v19, a3);
        double v15 = v21 - v23;
      }
    }
    if (v6 < 0.0) {
      double v15 = -v15;
    }
    return v8 * v5 + v15;
  }
  return result;
}

double PCCalculus::ellipseLineIntegral(PCCalculus *this, double a2, double a3, double a4)
{
  if (a3 <= a4) {
    double v5 = a3;
  }
  else {
    double v5 = a4;
  }
  if (a3 < a4) {
    a3 = a4;
  }
  double v6 = v5 * v5;
  double v7 = a3 * a3;
  double v8 = v5 * v5 + a3 * a3 + cos(a2 + a2) * (a3 * a3 - v5 * v5);
  return sqrt(v8) * PCCalculus::ellipticE(v9, a2, sqrt(1.0 - v6 / v7)) / sqrt(v8 / v7);
}

double doInverseToneMap_BT2390(float32x4_t a1)
{
  int32x4_t v19 = vcltzq_f32(a1);
  simd_float4 v1 = (simd_float4)vabsq_f32(a1);
  v1.i32[3] = 0;
  simd_float4 v2 = _simd_pow_f4(v1, (simd_float4)xmmword_1B7E75850);
  int32x4_t v3 = v19;
  v3.i32[3] = 0;
  __asm
  {
    FMOV            V2.4S, #1.0
    FMOV            V3.4S, #-1.0
  }
  float32x4_t v10 = vmulq_f32(vmulq_f32((float32x4_t)v2, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v3), _Q3, _Q2)), (float32x4_t)vdupq_n_s32(0x3E87AE14u));
  float32x4_t v20 = v10;
  v10.i32[3] = 0;
  simd_float4 v11 = (simd_float4)vmaxnmq_f32(v10, (float32x4_t)0);
  v11.i32[3] = 0;
  simd_float4 v12 = _simd_pow_f4(v11, (simd_float4)xmmword_1B7E7CCA0);
  float32x4_t v13 = vmulq_f32((float32x4_t)v12, (float32x4_t)xmmword_1B7E7CCB0);
  float v14 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0];
  float v15 = 1.0;
  if (v14 != 0.0)
  {
    float32x4_t v16 = vmulq_f32(v20, (float32x4_t)xmmword_1B7E7CCB0);
    float v15 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0]/ v14;
  }
  __asm { FMOV            V1.4S, #12.0 }
  *(void *)&double result = vmulq_f32(vmulq_n_f32((float32x4_t)v12, v15), _Q1).u64[0];
  return result;
}

double toneMap_BT2446_A_DisplayLinearToGamma(float32x4_t a1)
{
  a1.i32[3] = 0;
  simd_float4 v1 = (simd_float4)vmaxnmq_f32(a1, (float32x4_t)0);
  v1.i32[3] = 0;
  simd_float4 v15 = _simd_pow_f4(v1, (simd_float4)xmmword_1B7E7CCC0);
  float32x4_t v2 = vmulq_f32((float32x4_t)v15, (float32x4_t)xmmword_1B7E7CCD0);
  float32x4_t v14 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1)));
  float v3 = logf((float)(12.26 * v14.f32[0]) + 1.0) / 2.5847;
  if (v3 <= 0.7399)
  {
    float v6 = v3 * 1.077;
  }
  else
  {
    if (v3 >= 0.9909)
    {
      float v5 = 0.5;
      float v4 = v3 * 0.5;
    }
    else
    {
      float v4 = v3 * (float)((float)(v3 * -1.151) + 2.7811);
      float v5 = -0.6302;
    }
    float v6 = v4 + v5;
  }
  *(float *)v7.int i32 = (float)(powf(5.697, v6) + -1.0) / 4.697;
  float v8 = v14.f32[0] * 1.1;
  if ((float)(v14.f32[0] * 1.1) < 0.000000059605) {
    float v8 = 0.000000059605;
  }
  float v9 = *(float *)v7.i32 / v8;
  float v10 = (float)(vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), v14).f32[0] / 1.8814) * v9;
  float v11 = (float)(vsubq_f32((float32x4_t)v15, v14).f32[0] / 1.4746) * v9;
  float v12 = v11 * 0.1;
  if ((float)(v11 * 0.1) < 0.0) {
    float v12 = 0.0;
  }
  *(float *)v7.int i32 = *(float *)v7.i32 - v12;
  *(void *)&double result = vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v7, 0), (float32x4_t)xmmword_1B7E7CCE0, v10), (float32x4_t)xmmword_1B7E7CCF0, v11).u64[0];
  return result;
}

double doInverseToneMap_BT2446_A(float32x4_t a1)
{
  int8x16_t v12 = (int8x16_t)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B7E7CD00, a1.f32[0]), (float32x4_t)xmmword_1B7E7CD10, *(float32x2_t *)a1.f32, 1), (float32x4_t)xmmword_1B7E7CD20, a1, 2);
  float v1 = powf(255.0 * *(float *)v12.i32, flt_1B7E7CE48[(float)(255.0 * *(float *)v12.i32) > 70.0]+ (float)((float)(255.0 * *(float *)v12.i32)* (float)(flt_1B7E7CE40[(float)(255.0 * *(float *)v12.i32) > 70.0]+ (float)((float)(255.0 * *(float *)v12.i32)* flt_1B7E7CE38[(float)(255.0 * *(float *)v12.i32) > 70.0]))));
  float v2 = 1.0;
  if (*(float *)v12.i32 > 0.0) {
    float v2 = (float)(v1 / *(float *)v12.i32) * 1.075;
  }
  float32x2_t v3 = vmul_n_f32((float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 4uLL), v2);
  float32x2_t v4 = vmul_f32(v3, (float32x2_t)0x3F1243FE3E287FCCLL);
  v5.f32[0] = v1 + vmuls_lane_f32(1.4746, v3, 1);
  v5.f32[1] = (float)(v1 - v4.f32[0]) - v4.f32[1];
  v5.i64[1] = COERCE_UNSIGNED_INT(v1 + (float)(1.8814 * v3.f32[0]));
  float32x4_t v6 = vmaxnmq_f32(v5, (float32x4_t)0);
  v6.i32[3] = 0;
  simd_float4 v7 = (simd_float4)vdivq_f32(vminnmq_f32(v6, (float32x4_t)xmmword_1B7E7CD30), (float32x4_t)vdupq_n_s32(0x447A0000u));
  v7.i32[3] = 0;
  simd_float4 v13 = _simd_pow_f4(v7, (simd_float4)xmmword_1B7E7CD40);
  float32x4_t v8 = vmulq_f32((float32x4_t)v13, (float32x4_t)xmmword_1B7E7CCD0);
  float v11 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0];
  float v9 = powf(v11, -0.16667) * 12.0;
  if (v11 <= 0.0) {
    float v9 = 0.0;
  }
  *(void *)&double result = vmulq_n_f32((float32x4_t)v13, v9).u64[0];
  return result;
}

double doToneMap_OS(float32x4_t a1)
{
  float32x4_t v1 = vmulq_f32(a1, (float32x4_t)xmmword_1B7E7CCD0);
  float v29 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1, 2), vaddq_f32(v1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v1.f32, 1))).f32[0];
  float v2 = powf(v29, -0.15409) * 0.12221;
  if (v29 <= 0.0) {
    float v2 = 0.0;
  }
  float32x4_t v3 = vmulq_n_f32(a1, v2);
  float32x4_t v4 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B7E7CD50, v3.f32[0]), (float32x4_t)xmmword_1B7E7CD60, *(float32x2_t *)v3.f32, 1), (float32x4_t)xmmword_1B7E7CD70, v3, 2);
  int32x4_t v32 = vcltzq_f32(v4);
  float32x4_t v26 = vabsq_f32(v4);
  simd_float4 v5 = (simd_float4)v26;
  v5.i32[3] = 0;
  simd_float4 v6 = _simd_pow_f4(v5, (simd_float4)xmmword_1B7E7CCC0);
  int32x4_t v7 = vcgeq_f32((float32x4_t)vdupq_n_s32(0x3B4D2E1Cu), v26);
  v7.i32[3] = 0;
  float32x4_t v8 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v7), (int8x16_t)vmulq_f32(v26, (float32x4_t)vdupq_n_s32(0x414EB852u)), (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)v6, (float32x4_t)vdupq_n_s32(0x3F870A3Du)), (float32x4_t)vdupq_n_s32(0xBD6147AE)));
  int32x4_t v9 = v32;
  v9.i32[3] = 0;
  __asm { FMOV            V2.4S, #1.0 }
  int8x16_t v30 = _Q2;
  __asm { FMOV            V3.4S, #-1.0 }
  int8x16_t v33 = _Q3;
  float32x4_t v16 = vmulq_f32(v8, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v9), _Q3, _Q2));
  int32x4_t v27 = vcltzq_f32(v16);
  simd_float4 v17 = (simd_float4)vabsq_f32(v16);
  v17.i32[3] = 0;
  simd_float4 v18 = _simd_pow_f4(v17, (simd_float4)xmmword_1B7E7CD80);
  int32x4_t v19 = v27;
  v19.i32[3] = 0;
  float32x4_t v20 = vmulq_f32((float32x4_t)v18, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v19), v33, v30));
  float32x4_t v21 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B7E7CD90, v20.f32[0]), (float32x4_t)xmmword_1B7E7CDA0, *(float32x2_t *)v20.f32, 1), (float32x4_t)xmmword_1B7E7CDB0, v20, 2);
  int32x4_t v28 = vcltzq_f32(v21);
  simd_float4 v22 = (simd_float4)vabsq_f32(v21);
  v22.i32[3] = 0;
  simd_float4 v23 = _simd_pow_f4(v22, (simd_float4)xmmword_1B7E7CDC0);
  int32x4_t v24 = v28;
  v24.i32[3] = 0;
  *(void *)&double result = vmulq_f32((float32x4_t)v23, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v24), v33, v30)).u64[0];
  return result;
}

double doInverseToneMap_OS(float32x4_t a1)
{
  int32x4_t v29 = vcltzq_f32(a1);
  simd_float4 v1 = (simd_float4)vabsq_f32(a1);
  v1.i32[3] = 0;
  simd_float4 v2 = _simd_pow_f4(v1, (simd_float4)xmmword_1B7E7CD80);
  int32x4_t v3 = v29;
  v3.i32[3] = 0;
  __asm
  {
    FMOV            V2.4S, #1.0
    FMOV            V3.4S, #-1.0
  }
  int8x16_t v28 = _Q2;
  int8x16_t v30 = _Q3;
  float32x4_t v10 = vmulq_f32((float32x4_t)v2, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v3), _Q3, _Q2));
  float32x4_t v11 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B7E7CD50, v10.f32[0]), (float32x4_t)xmmword_1B7E7CD60, *(float32x2_t *)v10.f32, 1), (float32x4_t)xmmword_1B7E7CD70, v10, 2);
  int32x4_t v26 = vcltzq_f32(v11);
  simd_float4 v12 = (simd_float4)vabsq_f32(v11);
  v12.i32[3] = 0;
  simd_float4 v13 = _simd_pow_f4(v12, (simd_float4)xmmword_1B7E7CDC0);
  int32x4_t v14 = v26;
  v14.i32[3] = 0;
  float32x4_t v15 = vmulq_f32((float32x4_t)v13, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v14), v30, v28));
  float32x4_t v25 = vabsq_f32(v15);
  int32x4_t v27 = vcltzq_f32(v15);
  simd_float4 v16 = (simd_float4)vdivq_f32(vaddq_f32(v25, (float32x4_t)vdupq_n_s32(0x3D6147AEu)), (float32x4_t)vdupq_n_s32(0x3F870A3Du));
  v16.i32[3] = 0;
  simd_float4 v17 = _simd_pow_f4(v16, (simd_float4)xmmword_1B7E7CD40);
  int32x4_t v18 = vcgeq_f32((float32x4_t)vdupq_n_s32(0x3D25E354u), v25);
  v18.i32[3] = 0;
  float32x4_t v19 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v18), (int8x16_t)vdivq_f32(v25, (float32x4_t)vdupq_n_s32(0x414EB852u)), (int8x16_t)v17);
  int32x4_t v20 = v27;
  v20.i32[3] = 0;
  float32x4_t v21 = vmulq_f32(v19, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v20), v30, v28));
  float32x4_t v31 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B7E7CD90, v21.f32[0]), (float32x4_t)xmmword_1B7E7CDA0, *(float32x2_t *)v21.f32, 1), (float32x4_t)xmmword_1B7E7CDB0, v21, 2);
  float32x4_t v22 = vmulq_f32(v31, (float32x4_t)xmmword_1B7E7CCD0);
  *(float *)v28.int i32 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0];
  float v23 = powf(*(float *)v28.i32, 0.18216) * 12.0;
  if (*(float *)v28.i32 <= 0.0) {
    float v23 = 0.0;
  }
  *(void *)&double result = vmulq_n_f32(v31, v23).u64[0];
  return result;
}

double doToneMap_OSFA(float32x4_t a1)
{
  {
    float32x4_t v21 = a1;
    a1 = v21;
    if (v16)
    {
      xmmword_1E9EE4C30 = (__int128)vdupq_n_s32(0x3F333333u);
      a1 = v21;
    }
  }
  int32x4_t v19 = vcltzq_f32(a1);
  simd_float4 v1 = (simd_float4)vabsq_f32(a1);
  simd_float4 v2 = (simd_float4)xmmword_1E9EE4C30;
  v1.i32[3] = 0;
  v2.i32[3] = 0;
  int32x4_t v4 = v19;
  v4.i32[3] = 0;
  __asm { FMOV            V2.4S, #1.0 }
  int8x16_t v18 = _Q2;
  __asm { FMOV            V3.4S, #-1.0 }
  int8x16_t v20 = _Q3;
  float32x4_t v11 = vmulq_f32(v3, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v4), _Q3, _Q2));
  int32x4_t v17 = vcltzq_f32(v11);
  simd_float4 v12 = (simd_float4)vabsq_f32(v11);
  v12.i32[3] = 0;
  simd_float4 v13 = _simd_pow_f4(v12, (simd_float4)xmmword_1B7E7CDC0);
  int32x4_t v14 = v17;
  v14.i32[3] = 0;
  *(void *)&double result = vmulq_f32((float32x4_t)v13, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v14), v20, v18)).u64[0];
  return result;
}

double doInverseToneMap_OSFA(float32x4_t a1)
{
  simd_float4 v1 = (simd_float4)vabsq_f32(a1);
  v1.i32[3] = 0;
  float32x4_t v2 = (float32x4_t)_simd_pow_f4(v1, (simd_float4)xmmword_1B7E7CD80);
  float32x4_t v3 = v2;
  {
    simd_float4 v20 = (simd_float4)v2;
    float32x4_t v3 = (float32x4_t)v20;
    if (v17)
    {
      unk_1E9EE4C60 = vdupq_n_s32(0x3FB6DB6Eu);
      float32x4_t v3 = (float32x4_t)v20;
    }
  }
  int32x4_t v4 = vcltzq_f32(a1);
  v4.i32[3] = 0;
  __asm { FMOV            V2.4S, #1.0 }
  int8x16_t v19 = _Q2;
  __asm { FMOV            V3.4S, #-1.0 }
  int8x16_t v22 = _Q3;
  float32x4_t v11 = vmulq_f32(v3, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v4), _Q3, _Q2));
  int32x4_t v18 = vcltzq_f32(v11);
  simd_float4 v12 = (simd_float4)unk_1E9EE4C60;
  v13.i32[3] = 0;
  v12.i32[3] = 0;
  simd_float4 v14 = _simd_pow_f4(v13, v12);
  int32x4_t v15 = v18;
  v15.i32[3] = 0;
  *(void *)&double result = vmulq_f32((float32x4_t)v14, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v15), v22, v19)).u64[0];
  return result;
}

void anonymous namespace'::HLG::getTransferFunction(_anonymous_namespace_::HLG *this)
{
  {
    if (v1)
    {
    }
  }
}

double PCColorUtil::applyToneMap_BT2446_A(float32x4_t a1)
{
  float32x4_t v1 = vmulq_f32(a1, (float32x4_t)xmmword_1B7E7CCD0);
  float v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1, 2), vaddq_f32(v1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v1.f32, 1))).f32[0];
  float v2 = powf(v5, 0.2) * 0.050697;
  if (v5 <= 0.0) {
    float v2 = 0.0;
  }
  float32x4_t v3 = vmulq_n_f32(a1, v2);

  return toneMap_BT2446_A_DisplayLinearToGamma(v3);
}

double PCColorUtil::applyToneMap_HLGDiffuseWhite(float32x4_t a1)
{
  float32x4_t v1 = vmulq_n_f32(a1, 1.0 / getWhiteGainForHLG_75());
  int32x4_t v12 = vcltzq_f32(v1);
  simd_float4 v2 = (simd_float4)vabsq_f32(v1);
  v2.i32[3] = 0;
  simd_float4 v3 = _simd_pow_f4(v2, (simd_float4)xmmword_1B7E7CDC0);
  int32x4_t v4 = v12;
  v4.i32[3] = 0;
  __asm
  {
    FMOV            V2.4S, #1.0
    FMOV            V3.4S, #-1.0
  }
  *(void *)&double result = vmulq_f32((float32x4_t)v3, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v4), _Q3, _Q2)).u64[0];
  return result;
}

double PCColorUtil::applyInverseToneMap_HLGDiffuseWhite(float32x4_t a1)
{
  int32x4_t v11 = vcltzq_f32(a1);
  simd_float4 v1 = (simd_float4)vabsq_f32(a1);
  v1.i32[3] = 0;
  float32x4_t v2 = (float32x4_t)_simd_pow_f4(v1, (simd_float4)xmmword_1B7E7CD80);
  int32x4_t v3 = v11;
  v3.i32[3] = 0;
  __asm
  {
    FMOV            V2.4S, #1.0
    FMOV            V3.4S, #-1.0
  }
  *(void *)&double result = vmulq_n_f32(vmulq_f32(v2, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v3), _Q3, _Q2)), getWhiteGainForHLG_75()).u64[0];
  return result;
}

double PCColorUtil::applyToneMap_LinearGain(float32x4_t a1, float a2)
{
  if (a2 <= -0.00001 || (double v2 = 0.0, a2 >= 0.00001))
  {
    float32x4_t v3 = vmulq_n_f32(a1, 1.0 / a2);
    int32x4_t v14 = vcltzq_f32(v3);
    simd_float4 v4 = (simd_float4)vabsq_f32(v3);
    v4.i32[3] = 0;
    simd_float4 v5 = _simd_pow_f4(v4, (simd_float4)xmmword_1B7E7CDC0);
    int32x4_t v6 = v14;
    v6.i32[3] = 0;
    __asm
    {
      FMOV            V2.4S, #1.0
      FMOV            V3.4S, #-1.0
    }
    *(void *)&double v2 = vmulq_f32((float32x4_t)v5, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v6), _Q3, _Q2)).u64[0];
  }
  return v2;
}

double PCColorUtil::applyInverseToneMap_LinearGain(float32x4_t a1, float a2)
{
  int32x4_t v12 = vcltzq_f32(a1);
  simd_float4 v2 = (simd_float4)vabsq_f32(a1);
  v2.i32[3] = 0;
  simd_float4 v3 = _simd_pow_f4(v2, (simd_float4)xmmword_1B7E7CD80);
  int32x4_t v4 = v12;
  v4.i32[3] = 0;
  __asm
  {
    FMOV            V2.4S, #1.0
    FMOV            V3.4S, #-1.0
  }
  *(void *)&double result = vmulq_n_f32(vmulq_f32((float32x4_t)v3, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v4), _Q3, _Q2)), a2).u64[0];
  return result;
}

float getWhiteGainForHLG_75(void)
{
  uint64_t v0 = &PSEmitter::PSEmitter_wavePhaseChanInfo::_PSEmitter_wavePhaseChanInfo;
  {
    uint64_t v0 = &PSEmitter::PSEmitter_wavePhaseChanInfo::_PSEmitter_wavePhaseChanInfo;
    if (v2)
    {
      v3.i32[0] = 0.75;
      double WhiteGainForHLGLevel = PCColorUtil::getWhiteGainForHLGLevel(v2, v3);
      getWhiteGainForHLG_75(void)::double result = LODWORD(WhiteGainForHLGLevel);
      uint64_t v0 = &PSEmitter::PSEmitter_wavePhaseChanInfo::_PSEmitter_wavePhaseChanInfo;
    }
  }
  return *((float *)v0 + 826);
}

double PCColorUtil::getWhiteGainForHLGLevel(PCColorUtil *this, int32x2_t a2)
{
  float32x4_t v2 = (float32x4_t)vdupq_lane_s32(a2, 0);
  v2.i32[3] = 0;
  float32x4_t v3 = vmaxnmq_f32(v2, (float32x4_t)0);
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  __asm { FMOV            V2.4S, #4.0 }
  int8x16_t v14 = (int8x16_t)vmulq_f32(vmulq_f32(v3, v3), _Q2);
  int8x16_t v16 = (int8x16_t)vcgeq_f32(v4, v3);
  simd_float4 v10 = (simd_float4)vaddq_f32(vmulq_f32(v3, (float32x4_t)xmmword_1E9EE4CC0), (float32x4_t)xmmword_1E9EE4CD0);
  v10.i32[3] = 0;
  float32x4_t v11 = (float32x4_t)_simd_exp2_f4(v10);
  v12.i32[0] = 1049739296;
  *(void *)&double result = vbslq_s8(v16, v14, (int8x16_t)vaddq_f32(v11, v12)).u64[0];
  return result;
}

float32x4_t anonymous namespace'::HLG::TransferFunction::TransferFunction(_anonymous_namespace_::HLG::TransferFunction *this)
{
  float32x4_t v1 = (float32x4_t)_simd_log_f4((simd_float4)xmmword_1B7E7CDD0);
  float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x3E371FF0u);
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  *(float32x4_t *)algn_1E9EE4C90 = v2;
  xmmword_1E9EE4CA0 = (__int128)vdupq_n_s32(0x3DFDDD65u);
  xmmword_1E9EE4CC0 = (__int128)vdupq_n_s32(0x4101139Au);
  xmmword_1E9EE4CD0 = (__int128)result;
  return result;
}

void PCCurveFit::~PCCurveFit(PCCurveFit *this)
{
  PCSingleton::~PCSingleton(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PCCurveFit::getInstance(PCCurveFit *this)
{
  if (PCCurveFit::getInstance(void)::once != -1) {
    dispatch_once(&PCCurveFit::getInstance(void)::once, &__block_literal_global_54);
  }
  return PCCurveFit::_instance;
}

void ___ZN10PCCurveFit11getInstanceEv_block_invoke()
{
}

void sub_1B76A5BB0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x81C40B8603338);
  _Unwind_Resume(a1);
}

double PCCurveFit::FitCurve(uint64_t a1, float64x2_t **a2, uint64_t a3)
{
  simd_float4 v5 = *a2;
  float64x2_t v6 = vsubq_f64((*a2)[1], **a2);
  double v7 = sqrt(vaddvq_f64(vmulq_f64(v6, v6)));
  if (v7 <= -0.000000100000001 || v7 >= 0.000000100000001) {
    float64x2_t v6 = vdivq_f64(v6, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v7, 0));
  }
  float64x2_t v14 = v6;
  uint64_t v8 = a2[1] - v5 - 1;
  PCCurveFit::ComputeRightTangent(a2, v8, &v13);
  PCCurveFit::FitCubic((uint64_t *)a2, 0, v8, v14.f64, &v13, &v11);
  int32x4_t v9 = *(void **)a3;
  if (*(void *)a3)
  {
    *(void *)(a3 + 8) = v9;
    operator delete(v9);
  }
  double result = *(double *)&v11;
  *(_OWORD *)a3 = v11;
  *(void *)(a3 + 16) = v12;
  return result;
}

void PCCurveFit::ComputeRightTangent(void *a1@<X1>, uint64_t a2@<X2>, float64x2_t *a3@<X8>)
{
  float64x2_t v3 = vsubq_f64(*(float64x2_t *)(*a1 + 16 * a2 - 16), *(float64x2_t *)(*a1 + 16 * a2));
  double v4 = sqrt(vaddvq_f64(vmulq_f64(v3, v3)));
  if (v4 <= -0.000000100000001 || v4 >= 0.000000100000001) {
    float64x2_t v3 = vdivq_f64(v3, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v4, 0));
  }
  *a3 = v3;
}

void PCCurveFit::FitCubic(uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, double *a4@<X4>, float64x2_t *a5@<X5>, void *a6@<X8>)
{
  *a6 = 0;
  a6[1] = 0;
  a6[2] = 0;
  if (a3 - a2 != 1) {
    PCCurveFit::ChordLengthParameterize();
  }
  uint64_t v12 = (double *)(*a1 + 16 * a3);
  float64x2_t v13 = (double *)(*a1 + 16 * a2);
  double v14 = *v12;
  double v15 = v12[1];
  double v17 = *v13;
  double v16 = v13[1];
  int32x4_t v18 = (char **)(a6 + 2);
  int8x16_t v19 = std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)(a6 + 2), 1uLL);
  float32x4_t v21 = (char *)&v19[v20];
  *int8x16_t v19 = *(_OWORD *)v13;
  int8x16_t v22 = (char *)(v19 + 1);
  float v23 = (float64x2_t *)*a6;
  int32x4_t v24 = (float64x2_t *)a6[1];
  float32x4_t v25 = v19;
  while (v24 != v23)
  {
    float64x2_t v26 = v24[-1];
    --v24;
    *--float32x4_t v25 = v26;
  }
  *a6 = v25;
  a6[1] = v22;
  a6[2] = v21;
  if (v23)
  {
    operator delete(v23);
    float32x4_t v21 = *v18;
  }
  a6[1] = v22;
  uint64_t v27 = *a1;
  if (v22 >= v21)
  {
    uint64_t v29 = (uint64_t)&v22[-*a6] >> 4;
    if ((unint64_t)(v29 + 1) >> 60) {
      goto LABEL_52;
    }
    uint64_t v30 = (uint64_t)&v21[-*a6];
    uint64_t v31 = v30 >> 3;
    if (v30 >> 3 <= (unint64_t)(v29 + 1)) {
      uint64_t v31 = v29 + 1;
    }
    if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v32 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v32 = v31;
    }
    int8x16_t v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)(a6 + 2), v32);
    double v34 = &v33[16 * v29];
    float32x4_t v21 = &v33[16 * v35];
    *(_OWORD *)double v34 = *(_OWORD *)(v27 + 16 * a2);
    int8x16_t v28 = v34 + 16;
    double v36 = (float64x2_t *)*a6;
    for (uint64_t i = (float64x2_t *)a6[1]; i != v36; --i)
    {
      float64x2_t v38 = i[-1];
      *((float64x2_t *)v34 - 1) = v38;
      v34 -= 16;
    }
    *a6 = v34;
    a6[1] = v28;
    a6[2] = v21;
    if (v36)
    {
      operator delete(v36);
      float32x4_t v21 = *v18;
    }
  }
  else
  {
    v19[1] = *(_OWORD *)(v27 + 16 * a2);
    int8x16_t v28 = (char *)(v19 + 2);
  }
  a6[1] = v28;
  uint64_t v39 = *a1;
  if (v28 >= v21)
  {
    uint64_t v41 = (uint64_t)&v28[-*a6] >> 4;
    if ((unint64_t)(v41 + 1) >> 60) {
      goto LABEL_52;
    }
    uint64_t v42 = (uint64_t)&v21[-*a6];
    uint64_t v43 = v42 >> 3;
    if (v42 >> 3 <= (unint64_t)(v41 + 1)) {
      uint64_t v43 = v41 + 1;
    }
    if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v44 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v44 = v43;
    }
    int v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)(a6 + 2), v44);
    int v46 = &v45[16 * v41];
    float32x4_t v21 = &v45[16 * v47];
    *(_OWORD *)int v46 = *(_OWORD *)(v39 + 16 * a2);
    CFRange v40 = v46 + 16;
    int v48 = (float64x2_t *)*a6;
    for (uint64_t j = (float64x2_t *)a6[1]; j != v48; --j)
    {
      float64x2_t v50 = j[-1];
      *((float64x2_t *)v46 - 1) = v50;
      v46 -= 16;
    }
    *a6 = v46;
    a6[1] = v40;
    a6[2] = v21;
    if (v48)
    {
      operator delete(v48);
      float32x4_t v21 = *v18;
    }
  }
  else
  {
    *(_OWORD *)int8x16_t v28 = *(_OWORD *)(v39 + 16 * a2);
    CFRange v40 = v28 + 16;
  }
  a6[1] = v40;
  uint64_t v51 = *a1;
  if (v40 < v21)
  {
    *(_OWORD *)CFRange v40 = *(_OWORD *)(v51 + 16 * a3);
    int v52 = v40 + 16;
    goto LABEL_47;
  }
  uint64_t v53 = (uint64_t)&v40[-*a6] >> 4;
  if ((unint64_t)(v53 + 1) >> 60) {
LABEL_52:
  }
    std::vector<double>::__throw_length_error[abi:ne180100]();
  uint64_t v54 = (uint64_t)&v21[-*a6];
  uint64_t v55 = v54 >> 3;
  if (v54 >> 3 <= (unint64_t)(v53 + 1)) {
    uint64_t v55 = v53 + 1;
  }
  if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v56 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v56 = v55;
  }
  int v57 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)(a6 + 2), v56);
  int v58 = &v57[16 * v53];
  int v60 = &v57[16 * v59];
  *(_OWORD *)int v58 = *(_OWORD *)(v51 + 16 * a3);
  int v52 = v58 + 16;
  int v61 = (float64x2_t *)*a6;
  for (int k = (float64x2_t *)a6[1]; k != v61; --k)
  {
    float64x2_t v63 = k[-1];
    *((float64x2_t *)v58 - 1) = v63;
    v58 -= 16;
  }
  *a6 = v58;
  a6[1] = v52;
  a6[2] = v60;
  if (v61) {
    operator delete(v61);
  }
LABEL_47:
  double v64 = sqrt((v14 - v17) * (v14 - v17) + (v15 - v16) * (v15 - v16)) / 3.0;
  a6[1] = v52;
  double v65 = *a4;
  double v66 = a4[1];
  double v67 = sqrt(v65 * v65 + v66 * v66);
  if (v67 != 0.0)
  {
    double v68 = v64 / v67;
    double v65 = v65 * v68;
    double v66 = v66 * v68;
    *a4 = v65;
    a4[1] = v66;
  }
  double v69 = a5->f64[0];
  double v70 = a5->f64[1];
  double v71 = sqrt(v69 * v69 + v70 * v70);
  if (v71 != 0.0)
  {
    a5->f64[0] = v69 * (v64 / v71);
    a5->f64[1] = v70 * (v64 / v71);
    double v65 = *a4;
    double v66 = a4[1];
  }
  int v72 = (float64x2_t *)*a6;
  double v73 = *(double *)(*a6 + 8);
  v72[1].f64[0] = *(double *)*a6 + v65;
  v72[1].f64[1] = v73 + v66;
  v72[2] = vaddq_f64(v72[3], *a5);
}

void sub_1B76A62D4(_Unwind_Exception *exception_object)
{
  if (v2) {
    operator delete(v2);
  }
  double v4 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void PCCurveFit::ChordLengthParameterize()
{
}

void PCCurveFit::GenerateBezier(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  operator new[]();
}

void sub_1B76A6D54(_Unwind_Exception *exception_object)
{
  float64x2_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double PCCurveFit::ComputeMaxError(uint64_t a1, void *a2, long long **a3, uint64_t a4, unint64_t a5, uint64_t a6, unint64_t *a7)
{
  *a7 = (a5 - a4 + 1) >> 1;
  unint64_t v7 = a4 + 1;
  double v8 = 0.0;
  if (a4 + 1 < a5)
  {
    float64x2_t v13 = (double *)(a6 + 8);
    do
    {
      PCCurveFit::Bezier(3, a3, &v17, *v13);
      float64x2_t v14 = vsubq_f64(v17, *(float64x2_t *)(*a2 + 16 * v7));
      double v15 = vaddvq_f64(vmulq_f64(v14, v14));
      if (v15 >= v8)
      {
        *a7 = v7;
        double v8 = v15;
      }
      ++v7;
      ++v13;
    }
    while (a5 != v7);
  }
  return v8;
}

void PCCurveFit::Reparameterize()
{
}

void PCCurveFit::ComputeCenterTangent(void *a1@<X1>, uint64_t a2@<X2>, float64x2_t *a3@<X8>)
{
  __asm { FMOV            V1.2D, #0.5 }
  float64x2_t v8 = vmulq_f64(vaddq_f64(vsubq_f64(*(float64x2_t *)(*a1 + 16 * a2 - 16), *(float64x2_t *)(*a1 + 16 * a2)), vsubq_f64(*(float64x2_t *)(*a1 + 16 * a2), *(float64x2_t *)(*a1 + 16 * a2 + 16))), _Q1);
  double v9 = sqrt(vaddvq_f64(vmulq_f64(v8, v8)));
  if (v9 <= -0.000000100000001 || v9 >= 0.000000100000001) {
    float64x2_t v8 = vdivq_f64(v8, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v9, 0));
  }
  *a3 = v8;
}

double PCCurveFit::NewtonRaphsonRootFind(double a1, uint64_t a2, long long **a3, double *a4)
{
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  unint64_t v56 = 0;
  std::string __p = 0;
  int v52 = 0;
  uint64_t v53 = 0;
  PCCurveFit::Bezier(3, a3, &v50, a1);
  unint64_t v7 = 0;
  float64x2_t v8 = 0;
  uint64_t v9 = 0;
  float64x2_t v10 = v50;
  __asm { FMOV            V2.2D, #3.0 }
  float64x2_t v49 = _Q2;
  do
  {
    if (v8 >= v56)
    {
      uint64_t v16 = (v8 - v7) >> 4;
      if ((unint64_t)(v16 + 1) >> 60) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v17 = v56 - v7;
      uint64_t v18 = v17 >> 3;
      if (v17 >> 3 <= (unint64_t)(v16 + 1)) {
        uint64_t v18 = v16 + 1;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v18;
      }
      uint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v56, v19);
      int8x16_t v22 = &v20[16 * v16];
      *(void *)int8x16_t v22 = 0;
      *((void *)v22 + 1) = 0;
      float v23 = (char *)v54;
      int32x4_t v24 = v55;
      float32x4_t v25 = v22;
      while (v24 != v23)
      {
        long long v26 = *((_OWORD *)v24 - 1);
        v24 -= 16;
        *((_OWORD *)v25 - 1) = v26;
        v25 -= 16;
      }
      float64x2_t v8 = v22 + 16;
      uint64_t v54 = v25;
      uint64_t v55 = v22 + 16;
      unint64_t v56 = &v20[16 * v21];
      if (v23) {
        operator delete(v23);
      }
      _Q2 = v49;
    }
    else
    {
      *(void *)float64x2_t v8 = 0;
      *((void *)v8 + 1) = 0;
      v8 += 16;
    }
    uint64_t v55 = v8;
    unint64_t v7 = v54;
    *((float64x2_t *)v54 + v9) = vmulq_f64(vsubq_f64((float64x2_t)(*a3)[v9 + 1], (float64x2_t)(*a3)[v9]), _Q2);
    ++v9;
  }
  while (v9 != 3);
  uint64_t v27 = 0;
  int8x16_t v28 = 0;
  uint64_t v29 = 0;
  char v30 = 1;
  do
  {
    char v31 = v30;
    if (v28 >= v53)
    {
      uint64_t v32 = (v28 - v27) >> 4;
      if ((unint64_t)(v32 + 1) >> 60) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v33 = v53 - v27;
      uint64_t v34 = v33 >> 3;
      if (v33 >> 3 <= (unint64_t)(v32 + 1)) {
        uint64_t v34 = v32 + 1;
      }
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v35 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v35 = v34;
      }
      double v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v53, v35);
      float64x2_t v38 = &v36[16 * v32];
      *(void *)float64x2_t v38 = 0;
      *((void *)v38 + 1) = 0;
      uint64_t v39 = (char *)__p;
      CFRange v40 = v52;
      uint64_t v41 = v38;
      while (v40 != v39)
      {
        long long v42 = *((_OWORD *)v40 - 1);
        v40 -= 16;
        *((_OWORD *)v41 - 1) = v42;
        v41 -= 16;
      }
      int8x16_t v28 = v38 + 16;
      std::string __p = v41;
      int v52 = v38 + 16;
      uint64_t v53 = &v36[16 * v37];
      if (v39) {
        operator delete(v39);
      }
    }
    else
    {
      *(void *)int8x16_t v28 = 0;
      *((void *)v28 + 1) = 0;
      v28 += 16;
    }
    char v30 = 0;
    int v52 = v28;
    uint64_t v27 = __p;
    float64x2_t v43 = vsubq_f64(*((float64x2_t *)v54 + v29 + 1), *((float64x2_t *)v54 + v29));
    *((float64x2_t *)__p + v29) = vaddq_f64(v43, v43);
    uint64_t v29 = 1;
  }
  while ((v31 & 1) != 0);
  PCCurveFit::Bezier(2, (long long **)&v54, &v50, a1);
  float64x2_t v44 = v50;
  PCCurveFit::Bezier(1, (long long **)&__p, &v50, a1);
  float64x2_t v45 = v50;
  double v46 = *a4;
  double v47 = a4[1];
  if (__p)
  {
    int v52 = (char *)__p;
    operator delete(__p);
  }
  if (v54)
  {
    uint64_t v55 = (char *)v54;
    operator delete(v54);
  }
  return a1
       - (v44.f64[0] * (v10.f64[0] - v46) + v44.f64[1] * (v10.f64[1] - v47))
       / (v44.f64[0] * v44.f64[0]
        + v44.f64[1] * v44.f64[1]
        + v45.f64[0] * (v10.f64[0] - v46)
        + v45.f64[1] * (v10.f64[1] - v47));
}

void sub_1B76A724C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void PCCurveFit::Bezier(int a1@<W1>, long long **a2@<X2>, float64x2_t *a3@<X8>, double a4@<D0>)
{
  a3->f64[0] = 0.0;
  a3->f64[1] = 0.0;
  std::string __p = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  std::vector<PCVector2<double>>::__init_with_size[abi:ne180100]<PCVector2<double>*,PCVector2<double>*>((char *)&__p, *a2, a2[1], a2[1] - *a2);
  float64x2_t v6 = (float64x2_t *)__p;
  if (a1 >= 1)
  {
    int v7 = 1;
    unsigned int v8 = a1;
    do
    {
      if (v7 <= a1)
      {
        float64x2_t v9 = *v6;
        uint64_t v10 = v8;
        long long v11 = v6 + 1;
        do
        {
          float64x2_t v12 = vmulq_n_f64(v9, 1.0 - a4);
          float64x2_t v9 = *v11;
          v11[-1] = vaddq_f64(v12, vmulq_n_f64(*v11, a4));
          ++v11;
          --v10;
        }
        while (v10);
      }
      --v8;
    }
    while (v7++ != a1);
  }
  *a3 = *v6;
  uint64_t v16 = v6;
  operator delete(v6);
}

long long *std::vector<PCVector2<double>>::__insert_with_size[abi:ne180100]<std::__wrap_iter<PCVector2<double>*>,std::__wrap_iter<PCVector2<double>*>>(uint64_t a1, uint64_t a2, long long *a3, long long *a4, uint64_t a5)
{
  simd_float4 v5 = *(long long **)a1;
  uint64_t v6 = a2 - *(void *)a1;
  int v7 = (long long *)(*(void *)a1 + (v6 & 0xFFFFFFFFFFFFFFF0));
  if (a5 < 1) {
    return v7;
  }
  float64x2_t v9 = a3;
  uint64_t v11 = v6 >> 4;
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v12 = a1 + 16;
  uint64_t v13 = v14;
  unint64_t v15 = *(void *)(v12 - 8);
  if (a5 > (uint64_t)(v14 - v15) >> 4)
  {
    unint64_t v16 = a5 + ((uint64_t)(v15 - (void)v5) >> 4);
    if (v16 >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v17 = v13 - (void)v5;
    uint64_t v18 = v17 >> 3;
    if (v17 >> 3 <= v16) {
      uint64_t v18 = v16;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v18;
    }
    uint64_t v45 = v12;
    if (v19) {
      uint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v12, v19);
    }
    else {
      uint64_t v20 = 0;
    }
    double v36 = &v20[16 * v11];
    std::string __p = v20;
    long long v42 = v36;
    float64x2_t v44 = &v20[16 * v19];
    uint64_t v37 = 16 * a5;
    float64x2_t v38 = &v36[16 * a5];
    do
    {
      long long v39 = *v9++;
      *(_OWORD *)double v36 = v39;
      v36 += 16;
      v37 -= 16;
    }
    while (v37);
    float64x2_t v43 = v38;
    int v7 = std::vector<PCVector2<double>>::__swap_out_circular_buffer((long long **)a1, &__p, v7);
    if (v43 != v42) {
      v43 += (v42 - v43 + 15) & 0xFFFFFFFFFFFFFFF0;
    }
    if (__p) {
      operator delete(__p);
    }
    return v7;
  }
  uint64_t v21 = (uint64_t)(v15 - (void)v7) >> 4;
  if (v21 >= a5)
  {
    int8x16_t v22 = &a3[a5];
    float v23 = *(_OWORD **)(v12 - 8);
LABEL_18:
    uint64_t v27 = &v7[a5];
    int8x16_t v28 = &v23[-a5];
    uint64_t v29 = v23;
    if ((unint64_t)v28 < v15)
    {
      uint64_t v29 = v23;
      do
      {
        long long v30 = *v28++;
        *v29++ = v30;
      }
      while ((unint64_t)v28 < v15);
    }
    *(void *)(a1 + 8) = v29;
    if (v23 != v27)
    {
      char v31 = v23 - 1;
      uint64_t v32 = 16 * (v23 - v27);
      uint64_t v33 = (uint64_t)&v5[v11 - 1];
      do
      {
        *v31-- = *(_OWORD *)(v33 + v32);
        v32 -= 16;
      }
      while (v32);
    }
    if (v22 != a3)
    {
      uint64_t v34 = v7;
      do
      {
        long long v35 = *v9++;
        *v34++ = v35;
      }
      while (v9 != v22);
    }
    return v7;
  }
  int8x16_t v22 = &a3[v21];
  float v23 = *(_OWORD **)(v12 - 8);
  if (v22 != a4)
  {
    int32x4_t v24 = v22;
    float32x4_t v25 = *(_OWORD **)(v12 - 8);
    do
    {
      long long v26 = *v24++;
      *v25++ = v26;
      ++v23;
    }
    while (v24 != a4);
  }
  *(void *)(a1 + 8) = v23;
  if ((uint64_t)(v15 - (void)v7) >= 1) {
    goto LABEL_18;
  }
  return v7;
}

void sub_1B76A755C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

long long *std::vector<PCVector2<double>>::__swap_out_circular_buffer(long long **a1, void *a2, long long *a3)
{
  double result = (long long *)a2[1];
  simd_float4 v5 = *a1;
  uint64_t v6 = result;
  if (*a1 != a3)
  {
    int v7 = a3;
    uint64_t v6 = (long long *)a2[1];
    do
    {
      long long v8 = *--v7;
      *--uint64_t v6 = v8;
    }
    while (v7 != v5);
  }
  a2[1] = v6;
  float64x2_t v9 = a1[1];
  for (uint64_t i = (_OWORD *)a2[2]; a3 != v9; ++i)
  {
    long long v11 = *a3++;
    *uint64_t i = v11;
  }
  a2[2] = i;
  uint64_t v12 = *a1;
  *a1 = v6;
  a2[1] = v12;
  uint64_t v13 = a1[1];
  a1[1] = (long long *)a2[2];
  a2[2] = v13;
  uint64_t v14 = a1[2];
  a1[2] = (long long *)a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return result;
}

char *std::vector<PCVector2<double>>::__init_with_size[abi:ne180100]<PCVector2<double>*,PCVector2<double>*>(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    double result = std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__vallocate[abi:ne180100](result, a4);
    int v7 = (_OWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      long long v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B76A767C(_Unwind_Exception *exception_object)
{
  float64x2_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL PCEvaluatorWaveData::operator==(uint64_t a1, uint64_t a2)
{
  return vabdd_f64(*(double *)a1, *(double *)a2) < 0.0000001
      && vabdd_f64(*(double *)(a1 + 8), *(double *)(a2 + 8)) < 0.0000001
      && vabdd_f64(*(double *)(a1 + 16), *(double *)(a2 + 16)) < 0.0000001
      && vabdd_f64(*(double *)(a1 + 24), *(double *)(a2 + 24)) < 0.0000001
      && vabdd_f64(*(double *)(a1 + 40), *(double *)(a2 + 40)) < 0.0000001
      && vabdd_f64(*(double *)(a1 + 32), *(double *)(a2 + 32)) < 0.0000001
      && *(_DWORD *)(a1 + 48) == *(_DWORD *)(a2 + 48);
}

double PCEvaluatorWaveData::operator=(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_OWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  double v4 = (_OWORD *)(a1 + 56);
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8000313F17);
  }
  uint64_t v5 = *(void *)(a1 + 64);
  if (v5) {
    MEMORY[0x1BA9BFB70](v5, 0x1000C8000313F17);
  }
  uint64_t v6 = *(void *)(a1 + 72);
  if (v6) {
    MEMORY[0x1BA9BFB70](v6, 0x1000C8000313F17);
  }
  uint64_t v7 = *(void *)(a1 + 80);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8000313F17);
  }
  double result = 0.0;
  *double v4 = 0u;
  v4[1] = 0u;
  return result;
}

void PCEvaluatorWaveData::~PCEvaluatorWaveData(PCEvaluatorWaveData *this)
{
  float32x4_t v2 = (PCSpinLock *)((char *)this + 88);
  PCSpinLock::lock((os_unfair_lock_t)this + 22);
  uint64_t v3 = *((void *)this + 7);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8000313F17);
  }
  uint64_t v4 = *((void *)this + 8);
  if (v4) {
    MEMORY[0x1BA9BFB70](v4, 0x1000C8000313F17);
  }
  uint64_t v5 = *((void *)this + 9);
  if (v5) {
    MEMORY[0x1BA9BFB70](v5, 0x1000C8000313F17);
  }
  uint64_t v6 = *((void *)this + 10);
  if (v6) {
    MEMORY[0x1BA9BFB70](v6, 0x1000C8000313F17);
  }
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = 0u;
  PCSpinLock::unlock(&v2->_lock);
  PCSpinLock::~PCSpinLock(v2);
}

void PCEvaluatorWaveData::refreshWaveArrays(PCEvaluatorWaveData *this)
{
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    MEMORY[0x1BA9BFB70](v2, 0x1000C8000313F17);
  }
  uint64_t v3 = *((void *)this + 8);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8000313F17);
  }
  uint64_t v4 = *((void *)this + 9);
  if (v4) {
    MEMORY[0x1BA9BFB70](v4, 0x1000C8000313F17);
  }
  uint64_t v5 = *((void *)this + 10);
  if (v5) {
    MEMORY[0x1BA9BFB70](v5, 0x1000C8000313F17);
  }
  operator new[]();
}

void PCEvaluator::PCEvaluator(PCEvaluator *this)
{
  *((_DWORD *)this + 1OZChannelFontBase::~OZChannelFontBase(this - 2) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + OZChannelFontBase::~OZChannelFontBase(this - 2) = 0u;
  *(_OWORD *)this = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = 0u;
  *((_DWORD *)this + 2OZChannelFontBase::~OZChannelFontBase(this - 2) = 0;
}

double PCEvaluator::findLengthOfEllipse(PCEvaluator *this, double a2, double a3, double a4, double a5)
{
  double v7 = fabs(a2);
  double v8 = fabs(a3);
  if (v7 >= 0.0000001)
  {
    if (v8 >= 0.0000001) {
      return PCCalculus::ellipseLineIntegral(this, 1.57079633, a2, a3) * 4.0;
    }
    else {
      return a2 * 4.0;
    }
  }
  else
  {
    BOOL v9 = v8 < 0.0000001;
    double result = 0.0;
    if (!v9) {
      return a3 * 4.0;
    }
  }
  return result;
}

void PCEvaluator::findPointOnEllipse(PCEvaluator *this, double a2, double a3, double a4, double a5, double a6, double *a7, double *a8, double *a9)
{
  double v12 = a4;
  double v13 = a3;
  if (vabdd_f64(a3, a4) < 0.0000001)
  {
    double v15 = a2 * 3.14159265 + a2 * 3.14159265;
    goto LABEL_46;
  }
  if (a3 < 0.00001) {
    a3 = 0.00001;
  }
  if (a4 >= 0.00001) {
    double v16 = a4;
  }
  else {
    double v16 = 0.00001;
  }
  double v17 = 1.57079633;
  double v38 = a3;
  double v19 = PCCalculus::ellipseLineIntegral(this, 1.57079633, a3, v16) * 4.0;
  double v20 = floor(a2);
  if (a2 < 1.0) {
    double v20 = 0.0;
  }
  double v21 = a2 - v20;
  if (v21 >= 0.0) {
    double v22 = v21;
  }
  else {
    double v22 = v21 + 1.0;
  }
  double v36 = v13;
  double v37 = v12;
  double v35 = v22;
  if (v22 >= 0.25)
  {
    if (v22 >= 0.5)
    {
      double v24 = 1.0 - v22;
      if (v13 > v12) {
        double v24 = 0.25 - (1.0 - v22);
      }
      double v25 = 0.25 - (v22 + -0.5);
      if (v13 <= v12) {
        double v25 = v22 + -0.5;
      }
      if (v22 < 0.75) {
        double v23 = v25;
      }
      else {
        double v23 = v24;
      }
    }
    else
    {
      double v23 = 0.5 - v22;
      if (v13 > v12) {
        double v23 = 0.25 - v23;
      }
    }
  }
  else
  {
    double v23 = 0.25 - v22;
    if (v13 <= v12) {
      double v23 = v22;
    }
  }
  double v26 = v19 * v23;
  double v27 = 0.0;
  double v28 = PCCalculus::ellipseLineIntegral(v18, 0.0, v38, v16);
  double v31 = PCCalculus::ellipseLineIntegral(v29, 1.57079633, v38, v16);
  while (1)
  {
    double v32 = v27 + (v17 - v27) * (v26 - v28) / (v31 - v28);
    double v33 = PCCalculus::ellipseLineIntegral(v30, v32, v38, v16);
    if (vabdd_f64(v33, v26) < 0.05) {
      break;
    }
    if (v26 <= v33) {
      double v17 = v27 + (v17 - v27) * (v26 - v28) / (v31 - v28);
    }
    else {
      double v27 = v27 + (v17 - v27) * (v26 - v28) / (v31 - v28);
    }
    if (v26 <= v33) {
      double v31 = v33;
    }
    else {
      double v28 = v33;
    }
  }
  double v13 = v36;
  double v12 = v37;
  if (v36 <= v37) {
    double v15 = v32;
  }
  else {
    double v15 = 1.57079633 - v32;
  }
  if (v35 >= 0.25)
  {
    if (v35 >= 0.5)
    {
      if (v35 < 0.75)
      {
        double v15 = v15 + 3.14159265;
        goto LABEL_46;
      }
      double v34 = 6.28318531;
    }
    else
    {
      double v34 = 3.14159265;
    }
    double v15 = v34 - v15;
  }
LABEL_46:
  if (a7) {
    *a7 = -(v13 * cos(v15));
  }
  if (a8) {
    *a8 = sin(v15) * v12;
  }
  if (a9) {
    *a9 = v15;
  }
}

void PCEvaluator::findPointOnSineWave(os_unfair_lock_s *this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, int a9, double *a10, double *a11)
{
  int v37 = 0;
  *(double *)double v33 = a7;
  *(double *)&v33[1] = a8;
  *(double *)&v33[2] = a3;
  *(double *)&_OWORD v33[3] = a4;
  *(double *)&v33[4] = a5;
  *(double *)&v33[5] = a6;
  int v34 = a9;
  long long v35 = 0u;
  long long v36 = 0u;
  double v16 = this + 22;
  PCSpinLock::lock(this + 22);
  if (!PCEvaluatorWaveData::operator==((uint64_t)this, (uint64_t)v33))
  {
    PCEvaluatorWaveData::operator=((uint64_t)this, (uint64_t)v33);
    PCEvaluatorWaveData::refreshWaveArrays((PCEvaluatorWaveData *)this);
  }
  int v32 = 0;
  uint64_t v18 = *(double **)&this[20]._os_unfair_lock_opaque;
  os_unfair_lock_opaque = (double *)this[12]._os_unfair_lock_opaque;
  double v20 = v18[(int)os_unfair_lock_opaque - 1] * a2;
  PCAlgorithm::bisect(v18, os_unfair_lock_opaque, &v32, v20, v17);
  uint64_t v21 = *(void *)&this[20]._os_unfair_lock_opaque;
  uint64_t v22 = v32 + 1;
  double v23 = *(double *)(v21 + 8 * v32);
  double v24 = *(double *)(v21 + 8 * v22) - v23;
  double v25 = fabs(a6);
  if (ceil(v24 + v24) > 1.0) {
    operator new[]();
  }
  if (v32 >= (signed int)(this[12]._os_unfair_lock_opaque - 1))
  {
    double v27 = *(double *)(*(void *)&this[18]._os_unfair_lock_opaque + 8 * v32);
  }
  else
  {
    uint64_t v26 = *(void *)&this[18]._os_unfair_lock_opaque;
    if (fabs(v24) >= 0.0000001)
    {
      double v31 = *(double *)(v26 + 8 * v22);
      double v27 = *(double *)(v26 + 8 * v32);
      if (vabdd_f64(v31, v27) >= 0.0000001) {
        double v27 = v27 + (v20 - v23) / (v24 / (v31 - v27));
      }
    }
    else
    {
      double v27 = *(double *)(v26 + 8 * v32);
    }
  }
  double v28 = 1.0 - v27;
  if (a6 >= 0.0) {
    double v28 = v27;
  }
  double v29 = exp(-(v25 * v28));
  if (a10) {
    *a10 = v27;
  }
  if (a11)
  {
    double v30 = v29 * *(double *)&this[4]._os_unfair_lock_opaque;
    *a11 = v30
         * sin(v27 * 6.28318531 * *(double *)&this[6]._os_unfair_lock_opaque + *(double *)&this[8]._os_unfair_lock_opaque);
  }
  PCSpinLock::unlock(v16);
  PCEvaluatorWaveData::~PCEvaluatorWaveData((PCEvaluatorWaveData *)v33);
}

void sub_1B76A833C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  PCEvaluatorWaveData::~PCEvaluatorWaveData((PCEvaluatorWaveData *)va);
  _Unwind_Resume(a1);
}

double PCEvaluator::findLengthOfSineWave(os_unfair_lock_s *this, double a2, double a3, double a4, double a5, double a6, double a7, int a8)
{
  int v16 = 0;
  *(double *)double v12 = a6;
  *(double *)&v12[1] = a7;
  *(double *)&_OWORD v12[2] = a2;
  *(double *)&void v12[3] = a3;
  *(double *)&v12[4] = a4;
  *(double *)&v12[5] = a5;
  int v13 = a8;
  long long v14 = 0u;
  BOOL v9 = this + 22;
  long long v15 = 0u;
  PCSpinLock::lock(this + 22);
  if (!PCEvaluatorWaveData::operator==((uint64_t)this, (uint64_t)v12))
  {
    PCEvaluatorWaveData::operator=((uint64_t)this, (uint64_t)v12);
    PCEvaluatorWaveData::refreshWaveArrays((PCEvaluatorWaveData *)this);
  }
  double v10 = *(double *)(*(void *)&this[20]._os_unfair_lock_opaque + 8 * (int)this[12]._os_unfair_lock_opaque - 8);
  PCSpinLock::unlock(v9);
  PCEvaluatorWaveData::~PCEvaluatorWaveData((PCEvaluatorWaveData *)v12);
  return v10;
}

void sub_1B76A840C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t PCMath::quadratic(PCMath *this, double a2, int8x16_t a3, double a4, double *a5, double *a6, int8x16_t a7)
{
  if (a2 > -0.0000001 && a2 < 0.0000001)
  {
    if (*(double *)a3.i64 <= -0.0000001 || *(double *)a3.i64 >= 0.0000001)
    {
      double v7 = -a4 / *(double *)a3.i64;
LABEL_20:
      *(double *)this = v7;
      return 1;
    }
    return 0;
  }
  double v8 = *(double *)a3.i64 * *(double *)a3.i64 + a2 * -4.0 * a4;
  if (v8 < 0.0)
  {
    if (v8 > -*(double *)a7.i64 && v8 < *(double *)a7.i64)
    {
      double v7 = *(double *)a3.i64 * -0.5 / a2;
      goto LABEL_20;
    }
    return 0;
  }
  *(double *)a7.i64 = sqrt(v8);
  v11.f64[0] = NAN;
  v11.f64[1] = NAN;
  double v12 = (*(double *)vbslq_s8((int8x16_t)vnegq_f64(v11), a7, a3).i64 + *(double *)a3.i64) * -0.5;
  if (v12 > -0.0000001 && v12 < 0.0000001)
  {
    *(void *)this = 0;
    return 1;
  }
  *(double *)this = v12 / a2;
  double v13 = a4 / v12;
  *a5 = a4 / v12;
  double v14 = *(double *)this;
  if (vabdd_f64(*(double *)this, v13) < 0.0000001) {
    return 1;
  }
  if (v14 > v13)
  {
    *(double *)this = v13;
    *a5 = v14;
  }
  return 2;
}

uint64_t PCMath::cubic(PCMath *this, double a2, double a3, int8x16_t a4, double *a5, double *a6, double *a7)
{
  double v9 = (a2 * a2 + a3 * -3.0) / 9.0;
  *(double *)a4.i64 = (*(double *)a4.i64 * 27.0 + (a2 + a2) * a2 * a2 - a2 * 9.0 * a3) / 54.0;
  double v10 = v9 * (v9 * v9);
  if (*(double *)a4.i64 * *(double *)a4.i64 >= v10)
  {
    int8x16_t v25 = a4;
    *(double *)v18.i64 = pow(fabs(*(double *)a4.i64) + sqrt(*(double *)a4.i64 * *(double *)a4.i64 - v10), 0.333333333);
    v19.f64[0] = NAN;
    v19.f64[1] = NAN;
    double v20 = *(double *)vbslq_s8((int8x16_t)vnegq_f64(v19), v18, v25).i64;
    BOOL v21 = v20 > -0.0000001 && v20 < 0.0000001;
    double v22 = v9 / -v20;
    if (v21) {
      double v22 = 0.0;
    }
    *(double *)this = v22 - v20 + a2 / -3.0;
    return 1;
  }
  else
  {
    double v13 = acos(*(double *)a4.i64 / sqrt(v10));
    double v14 = sqrt(v9) * -2.0;
    double v15 = a2 / 3.0;
    *(long double *)this = v14 * cos(v13 / 3.0) - v15;
    *a5 = v14 * cos((v13 + 6.28318531) / 3.0) - v15;
    double v16 = v14 * cos((v13 + -6.28318531) / 3.0) - v15;
    *a6 = v16;
    double v17 = *(double *)this;
    if (*(double *)this <= *a5)
    {
      double v17 = *a5;
    }
    else
    {
      *(double *)this = *a5;
      *a5 = v17;
      double v16 = *a6;
    }
    if (v17 > v16)
    {
      *a5 = v16;
      *a6 = v17;
      double v24 = *(double *)this;
      if (*(double *)this > *a5)
      {
        *(double *)this = *a5;
        *a5 = v24;
      }
    }
    return 3;
  }
}

double *PCMath::easeInOut(double *this, double a2, double a3, double a4, double a5, double a6, double *a7, double *a8)
{
  double v8 = 0.0;
  if (a3 < 0.0) {
    a3 = 0.0;
  }
  if (a4 >= 0.0) {
    double v9 = a4;
  }
  else {
    double v9 = 1.0;
  }
  double v10 = a3 + v9;
  if (fabs(a3 + v9) < 0.0000001)
  {
    if (this) {
      *this = a2;
    }
    double v8 = 1.0;
    goto LABEL_27;
  }
  double v11 = a2 - a5;
  double v12 = a6 - a5;
  if (v10 <= 1.0)
  {
    double v13 = a3;
  }
  else
  {
    double v9 = v9 / v10;
    double v13 = a3 / v10;
  }
  if (v10 > 1.0) {
    double v14 = 1.0;
  }
  else {
    double v14 = v10;
  }
  double v15 = v11 / v12;
  if (v11 / v12 < 0.0)
  {
    double v16 = 0.0;
    goto LABEL_25;
  }
  double v17 = v14 + -2.0;
  if (v15 >= v13)
  {
    double v16 = 1.0;
    if (v15 <= 1.0 - v9)
    {
      double v16 = (v13 - (v15 + v15)) / v17;
      double v18 = -2.0;
    }
    else
    {
      if (v15 >= 1.0) {
        goto LABEL_25;
      }
      double v17 = v9 * v17;
      double v16 = (1.0 - v15) * (1.0 - v15) / v17 + 1.0;
      double v18 = v15 + -1.0 + v15 + -1.0;
    }
  }
  else
  {
    double v17 = v13 * v17;
    double v16 = -(v15 * v15) / v17;
    double v18 = v15 * -2.0;
  }
  double v8 = v18 / v17;
LABEL_25:
  if (this) {
    *this = v12 * v16 + a5;
  }
LABEL_27:
  if (a7) {
    *a7 = v8;
  }
  return this;
}

FILE *_pcCheckGetTransformation(FILE *result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((result & 1) == 0) {
    return PCPrint("getTransformation failed (file %s, line %d)", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)a2);
  }
  return result;
}

void PCMatrix44Tmpl<double>::leftRotate(double *a1, int a2, double a3)
{
  if (a3 != 0.0)
  {
    double v5 = 1.0;
    double cosval = 0.0;
    if (vabdd_f64(-1.57079633, a3) >= 0.0000001 && vabdd_f64(4.71238898, a3) >= 0.0000001)
    {
      double v5 = -1.0;
      if (vabdd_f64(1.57079633, a3) >= 0.0000001 && vabdd_f64(-4.71238898, a3) >= 0.0000001)
      {
        double v5 = 0.0;
        double cosval = -1.0;
        if (vabdd_f64(-3.14159265, a3) >= 0.0000001 && vabdd_f64(3.14159265, a3) >= 0.0000001)
        {
          __double2 v7 = __sincos_stret(a3);
          double cosval = v7.__cosval;
          double v5 = -v7.__sinval;
        }
      }
    }
    if (a2)
    {
      if (a2 != 1)
      {
        if (a2 == 2)
        {
          double v8 = a1[1];
          double v9 = a1[4];
          double v10 = a1[5];
          double v11 = a1[2];
          double v12 = a1[3];
          double v13 = a1[6];
          double v14 = a1[7];
          double v15 = cosval * v9 - v5 * *a1;
          *a1 = cosval * *a1 + v5 * v9;
          a1[1] = cosval * v8 + v5 * v10;
          a1[2] = cosval * v11 + v5 * v13;
          a1[3] = cosval * v12 + v5 * v14;
          a1[4] = v15;
          a1[5] = cosval * v10 - v5 * v8;
          a1[6] = cosval * v13 - v5 * v11;
          a1[7] = cosval * v14 - v5 * v12;
        }
        return;
      }
      double v28 = a1[1];
      double v29 = a1[8];
      double v30 = a1[9];
      double v31 = cosval * *a1 - v5 * v29;
      double v32 = a1[2];
      double v33 = a1[3];
      double v34 = a1[10];
      double v35 = a1[11];
      double v36 = v5 * *a1 + cosval * v29;
      double v26 = v5 * v32 + cosval * v34;
      *a1 = v31;
      a1[1] = cosval * v28 - v5 * v30;
      a1[2] = cosval * v32 - v5 * v34;
      a1[3] = cosval * v33 - v5 * v35;
      a1[8] = v36;
      a1[9] = v5 * v28 + cosval * v30;
      double v27 = v5 * v33 + cosval * v35;
    }
    else
    {
      double v16 = a1[4];
      double v17 = a1[5];
      double v18 = a1[8];
      double v19 = a1[9];
      double v20 = cosval * v16 + v5 * v18;
      double v21 = a1[6];
      double v22 = a1[7];
      double v23 = a1[10];
      double v24 = a1[11];
      double v25 = cosval * v18 - v5 * v16;
      double v26 = cosval * v23 - v5 * v21;
      a1[4] = v20;
      a1[5] = cosval * v17 + v5 * v19;
      a1[6] = cosval * v21 + v5 * v23;
      a1[7] = cosval * v22 + v5 * v24;
      a1[8] = v25;
      a1[9] = cosval * v19 - v5 * v17;
      double v27 = cosval * v24 - v5 * v22;
    }
    a1[10] = v26;
    a1[11] = v27;
  }
}

double PCMatrix44Tmpl<double>::transpose(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 72);
  *(void *)(a1 + 8) = *(void *)(a1 + 32);
  *(void *)(a1 + 16) = v4;
  uint64_t v6 = *(void *)(a1 + 88);
  *(void *)(a1 + 24) = *(void *)(a1 + 96);
  *(void *)(a1 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v1;
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)(a1 + 64) = v2;
  *(void *)(a1 + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = v7;
  double result = *(double *)(a1 + 104);
  uint64_t v10 = *(void *)(a1 + 112);
  *(void *)(a1 + 48) = v5;
  *(double *)(a1 + 56) = result;
  *(void *)(a1 + 88) = v10;
  *(void *)(a1 + 96) = v3;
  *(void *)(a1 + 104) = v8;
  *(void *)(a1 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = v6;
  return result;
}

double PCVector4<double>::scale(double *a1, double result)
{
  double v2 = *a1;
  double v3 = a1[1];
  double v4 = a1[2];
  double v5 = a1[3];
  double v6 = sqrt(v2 * v2 + v3 * v3 + v4 * v4 + v5 * v5);
  if (v6 != 0.0)
  {
    double v7 = result / v6;
    *a1 = v2 * v7;
    a1[1] = v3 * v7;
    double v8 = v4 * v7;
    double result = v5 * v7;
    a1[2] = v8;
    a1[3] = result;
  }
  return result;
}

BOOL PCMath::equal(double *a1, double *a2, double a3)
{
  double v3 = a1[3];
  double v4 = a1[4];
  double v5 = a1[5];
  double v7 = a2[3];
  double v6 = a2[4];
  double v8 = a2[5];
  double v9 = sqrt((v3 * v3 + v4 * v4 + v5 * v5) / (v7 * v7 + v6 * v6 + v8 * v8));
  if (v3 * v7 + v4 * v6 + v5 * v8 >= 0.0) {
    double v10 = v9;
  }
  else {
    double v10 = -v9;
  }
  if (vabdd_f64(v3, v7 * v10) >= 0.0000001
    || vabdd_f64(v4, v6 * v10) >= 0.0000001
    || vabdd_f64(v5, v8 * v10) >= 0.0000001)
  {
    return 0;
  }
  double v12 = a1[1];
  double v13 = a2[1];
  return vabdd_f64(*a1, *a2) < 0.0000001 && vabdd_f64(v12, v13) < 0.0000001 && vabdd_f64(a1[2], a2[2]) < 0.0000001
      || vabdd_f64(v3 * *a1 + v4 * v12 + v5 * a1[2], v3 * *a2 + v4 * v13 + v5 * a2[2]) < a3;
}

uint64_t PCComparePlanes(double *a1, double *a2)
{
  double v2 = *a1;
  double v3 = a1[1];
  double v4 = a1[2];
  double v5 = sqrt(v2 * v2 + v3 * v3 + v4 * v4);
  double v6 = *a2;
  double v7 = a2[1];
  double v8 = a2[2];
  if (v5 > -0.0000001 && v5 < 0.0000001) {
    return a1[3] < 0.0;
  }
  double v10 = sqrt(v6 * v6 + v7 * v7 + v8 * v8);
  if (v10 <= -0.0000001 || v10 >= 0.0000001)
  {
    double v11 = v2 * v10;
    double v12 = v3 * v10;
    double v13 = v4 * v10;
    double v14 = v10 * a1[3];
    double v15 = v6 * v5;
    double v16 = v7 * v5;
    double v17 = v8 * v5;
    double v18 = v5 * a2[3];
    if (vabdd_f64(v11, v15) >= 0.0000001 || vabdd_f64(v12, v16) >= 0.0000001 || vabdd_f64(v13, v17) >= 0.0000001)
    {
      if (fabs(v15 + v11) >= 0.0000001 || fabs(v16 + v12) >= 0.0000001 || fabs(v17 + v13) >= 0.0000001) {
        return 8;
      }
      BOOL v19 = v14 <= -v18;
      unsigned int v20 = 7;
      unsigned int v21 = 6;
    }
    else
    {
      BOOL v19 = v14 <= v18;
      unsigned int v20 = 4;
      unsigned int v21 = 5;
    }
    if (v19) {
      return v20;
    }
    else {
      return v21;
    }
  }
  else if (a2[3] < 0.0)
  {
    return 3;
  }
  else
  {
    return 2;
  }
}

uint64_t PCPlaneType(double *a1)
{
  double v2 = *a1;
  uint64_t result = 8;
  if (v2 > -0.0000001 && v2 < 0.0000001)
  {
    double v4 = a1[1];
    if (v4 > -0.0000001 && v4 < 0.0000001)
    {
      double v5 = a1[2];
      if (v5 > -0.0000001 && v5 < 0.0000001) {
        return a1[3] <= 0.0;
      }
    }
  }
  return result;
}

void PCDivideByZeroException::~PCDivideByZeroException(PCString *this)
{
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

void PCDivideByZeroException::className(PCURL *a1@<X8>)
{
}

double PCComputeSquareToQuadProjectionMatrix(double *a1, double *a2, double *a3, double *a4, uint64_t a5)
{
  double v6 = *a2;
  double v5 = a2[1];
  double v8 = *a1;
  double v7 = a1[1];
  double v10 = *a3;
  double v9 = a3[1];
  double v12 = *a4;
  double v11 = a4[1];
  double v13 = *a3 + *a1 - *a2 - *a4;
  double v14 = v9 + v7 - v5 - v11;
  if (v13 <= -0.0000001 || v13 >= 0.0000001 || v14 <= -0.0000001 || v14 >= 0.0000001)
  {
    double v21 = v6 - v10;
    double v22 = v12 - v10;
    double v23 = v5 - v9;
    double v24 = v11 - v9;
    double v25 = v21 * v24 - v22 * v23;
    double v19 = (v13 * v24 - v22 * v14) / v25;
    double v20 = (v21 * v14 - v23 * v13) / v25;
    double v15 = v6 - v8 + v6 * v19;
    double v16 = v12 - v8 + v12 * v20;
    double v17 = v5 - v7 + v5 * v19;
    double v18 = v11 - v7 + v11 * v20;
  }
  else
  {
    double v15 = v6 - v8;
    double v16 = v10 - v6;
    double v17 = v5 - v7;
    double v18 = v9 - v5;
    double v19 = 0.0;
    double v20 = 0.0;
  }
  *(double *)a5 = v15;
  *(double *)(a5 + 8) = v16;
  *(void *)(a5 + 16) = 0;
  *(double *)(a5 + 24) = v8;
  *(double *)(a5 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v17;
  *(double *)(a5 + 40) = v18;
  *(void *)(a5 + 48) = 0;
  *(double *)(a5 + 56) = v7;
  *(void *)(a5 + 64) = 0;
  *(void *)(a5 + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = 0;
  *(_OWORD *)(a5 + 80) = xmmword_1B7E733D0;
  *(double *)(a5 + 96) = v19;
  *(double *)(a5 + 104) = v20;
  double result = 0.0;
  *(_OWORD *)(a5 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = xmmword_1B7E733E0;
  return result;
}

float64x2_t *PCComputeQuadToSquareProjectionMatrix(float64x2_t *result, float64x2_t *a2, float64x2_t *a3, float64x2_t *a4, uint64_t a5)
{
  float64x2_t v5 = *a2;
  float64x2_t v6 = *a3;
  float64x2_t v7 = *result;
  float64x2_t v8 = vsubq_f64(vaddq_f64(*a3, vsubq_f64(*result, *a2)), *a4);
  if (v8.f64[0] <= -0.0000001 || v8.f64[0] >= 0.0000001 || v8.f64[1] <= -0.0000001 || v8.f64[1] >= 0.0000001)
  {
    v14.f64[0] = a4->f64[0];
    v14.f64[1] = a2->f64[1];
    v5.f64[1] = a4->f64[1];
    float64x2_t v15 = vsubq_f64(v14, v6);
    int64x2_t v16 = (int64x2_t)vsubq_f64(v5, v6);
    float64x2_t v17 = (float64x2_t)vextq_s8((int8x16_t)v16, (int8x16_t)v16, 8uLL);
    float64x2_t v18 = vmulq_f64(v8, v17);
    v17.f64[1] = v15.f64[1];
    float64x2_t v19 = vmulq_f64((float64x2_t)vzip1q_s64(v16, (int64x2_t)v15), v17);
    float64x2_t v20 = vmulq_f64(v15, (float64x2_t)vextq_s8((int8x16_t)v8, (int8x16_t)v8, 8uLL));
    float64x2_t v21 = vsubq_f64(v5, v7);
    float64x2_t v13 = vdivq_f64(vsubq_f64(v18, v20), (float64x2_t)vdupq_lane_s64(*(_OWORD *)&vsubq_f64(v19, (float64x2_t)vdupq_laneq_s64((int64x2_t)v19, 1)), 0));
    float64x2_t v22 = vmulq_f64(v5, v13);
    float64x2_t v11 = vaddq_f64(vsubq_f64(v14, v7), vmulq_f64(v14, (float64x2_t)vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL)));
    float64x2_t v12 = vaddq_f64(v21, v22);
  }
  else
  {
    v9.f64[0] = a2->f64[0];
    v9.f64[1] = a3->f64[1];
    v6.f64[1] = a2->f64[1];
    v10.f64[0] = result->f64[0];
    v10.f64[1] = v6.f64[1];
    v5.f64[1] = result->f64[1];
    float64x2_t v11 = vsubq_f64(v6, v5);
    float64x2_t v12 = vsubq_f64(v9, v10);
    float64x2_t v13 = 0uLL;
  }
  uint64_t v23 = 0;
  double v24 = vmuld_lane_f64(v7.f64[0], v13, 1) - v11.f64[0];
  double v25 = vmuld_lane_f64(v11.f64[0], v7, 1);
  double v26 = vmuld_lane_f64(v7.f64[0], v12, 1);
  double v27 = vmuld_lane_f64(v13.f64[0], v7, 1) - v11.f64[1];
  uint64_t v28 = *(_OWORD *)&vsubq_f64(v12, vmulq_f64(v7, v13));
  double v29 = vmuld_lane_f64(v7.f64[0], v11, 1);
  v7.f64[0] = vmuld_lane_f64(v12.f64[0], v7, 1);
  float64x2_t v30 = vmulq_f64(v13, v11);
  float64x2_t v31 = vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL), v12);
  v12.f64[0] = vmuld_lane_f64(v12.f64[0], v12, 1);
  double v32 = vmuld_lane_f64(v11.f64[0], v11, 1);
  *(double *)a5 = v12.f64[1] - vmuld_lane_f64(v7.f64[1], v13, 1);
  *(double *)(a5 + 8) = v24;
  *(void *)(a5 + 16) = 0;
  *(double *)(a5 + 24) = v25 - v26;
  *(double *)(a5 + 3OZChannelFontBase::~OZChannelFontBase(this - 2) = v27;
  *(void *)(a5 + 40) = v28;
  *(void *)(a5 + 48) = 0;
  *(double *)(a5 + 56) = v29 - v7.f64[0];
  *(void *)(a5 + 64) = 0;
  *(void *)(a5 + 7OZChannelFontBase::~OZChannelFontBase(this - 2) = 0;
  *(double *)(a5 + 80) = v12.f64[0] - v32;
  *(void *)(a5 + 88) = 0;
  int8x16_t v33 = (int8x16_t)vsubq_f64(v30, v31);
  *(int8x16_t *)(a5 + 96) = vextq_s8(v33, v33, 8uLL);
  *(void *)(a5 + 11OZChannelFontBase::~OZChannelFontBase(this - 2) = 0;
  *(double *)(a5 + 120) = v12.f64[0] - v32;
  v7.f64[0] = 1.0
            / (vmuld_lane_f64(v29, v13, 1)
             + v12.f64[0]
             + v25 * v13.f64[0]
             - v26 * v13.f64[0]
             - v32
             - vmuld_lane_f64(v7.f64[0], v13, 1));
  do
  {
    for (uint64_t i = 0; i != 32; i += 16)
      *(float64x2_t *)(a5 + i) = vmulq_n_f64(*(float64x2_t *)(a5 + i), v7.f64[0]);
    ++v23;
    a5 += 32;
  }
  while (v23 != 4);
  return result;
}

uint64_t PCComputeQuadToQuadProjectionMatrix(float64x2_t *a1, float64x2_t *a2, float64x2_t *a3, float64x2_t *a4, double *a5, double *a6, double *a7, double *a8, uint64_t a9)
{
  uint64_t v50 = 0x3FF0000000000000;
  uint64_t v47 = 0x3FF0000000000000;
  uint64_t v44 = 0x3FF0000000000000;
  uint64_t v41 = 0x3FF0000000000000;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  uint64_t v40 = 0x3FF0000000000000;
  uint64_t v37 = 0x3FF0000000000000;
  uint64_t v34 = 0x3FF0000000000000;
  uint64_t v31 = 0x3FF0000000000000;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  PCComputeQuadToSquareProjectionMatrix(a1, a2, a3, a4, (uint64_t)&v31);
  PCComputeSquareToQuadProjectionMatrix(a5, a6, a7, a8, (uint64_t)&v41);
  PCMatrix44Tmpl<double>::operator*((uint64_t)&v41, (long long *)&v31, (uint64_t)&v29);
  if (&v29 != (long long *)a9)
  {
    for (uint64_t i = 0; i != 128; i += 32)
    {
      float64x2_t v18 = (_OWORD *)(a9 + i);
      long long v19 = *(long long *)((char *)&v29 + i + 16);
      *float64x2_t v18 = *(long long *)((char *)&v29 + i);
      v18[1] = v19;
    }
  }
  double v20 = sqrt(*(double *)(a9 + 96) * *(double *)(a9 + 96)+ *(double *)(a9 + 104) * *(double *)(a9 + 104)+ *(double *)(a9 + 112) * *(double *)(a9 + 112)+ *(double *)(a9 + 120) * *(double *)(a9 + 120));
  if (v20 <= -0.0000001 || v20 >= 0.0000001)
  {
    uint64_t v21 = 0;
    uint64_t v22 = a9;
    double v23 = 1.0 / v20;
    do
    {
      for (uint64_t j = 0; j != 32; j += 16)
        *(float64x2_t *)(v22 + j) = vmulq_n_f64(*(float64x2_t *)(v22 + j), v23);
      ++v21;
      v22 += 32;
    }
    while (v21 != 4);
  }
  long long v29 = 0u;
  long long v30 = 0u;
  PCMatrix44Tmpl<double>::transform<double>((double *)a9, a1->f64, (double *)&v29);
  uint64_t result = 0;
  double v26 = *((double *)&v30 + 1);
  if (*((double *)&v30 + 1) != 0.0)
  {
    long long v29 = 0u;
    long long v30 = 0u;
    PCMatrix44Tmpl<double>::transform<double>((double *)a9, a2->f64, (double *)&v29);
    double v27 = *((double *)&v30 + 1);
    if (*((double *)&v30 + 1) > 0.0)
    {
      if (v26 <= 0.0) {
        return 0;
      }
    }
    else if (v26 > 0.0 || *((double *)&v30 + 1) >= 0.0)
    {
      return 0;
    }
    long long v29 = 0u;
    long long v30 = 0u;
    PCMatrix44Tmpl<double>::transform<double>((double *)a9, a3->f64, (double *)&v29);
    double v28 = *((double *)&v30 + 1);
    if (*((double *)&v30 + 1) <= 0.0)
    {
      if (v27 > 0.0 || *((double *)&v30 + 1) >= 0.0) {
        return 0;
      }
LABEL_21:
      long long v29 = 0u;
      long long v30 = 0u;
      PCMatrix44Tmpl<double>::transform<double>((double *)a9, a4->f64, (double *)&v29);
      if (*((double *)&v30 + 1) <= 0.0)
      {
        if (v28 > 0.0 || *((double *)&v30 + 1) >= 0.0) {
          return 0;
        }
      }
      else if (v28 <= 0.0)
      {
        return 0;
      }
      return 1;
    }
    if (v27 > 0.0) {
      goto LABEL_21;
    }
    return 0;
  }
  return result;
}

void sub_1B76AB20C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B76AB374(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B76AB3D8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void RandMersenne::RandMersenne(RandMersenne *this)
{
  *(void *)this = &unk_1F10C39E0;
  *((void *)this + 386) = 0;
  *((void *)this + 388) = 0;
  *((void *)this + 387) = 0;
}

void RandMersenne::~RandMersenne(RandMersenne *this)
{
  *(void *)this = &unk_1F10C39E0;
  *((void *)this + 386) = 0;
  *((void *)this + 388) = 0;
  *((void *)this + 387) = 0;
}

{
  *(void *)this = &unk_1F10C39E0;
  *((void *)this + 386) = 0;
  *((void *)this + 388) = 0;
  *((void *)this + 387) = 0;
  JUMPOUT(0x1BA9BFBA0);
}

double RandMersenne::SetSeed(RandMersenne *this, unsigned int a2)
{
  dsfmt_chk_init_gen_rand((uint64_t)this + 8, a2, 19937);
  *((void *)this + 388) = 0;
  double result = 0.0;
  *((_OWORD *)this + 193) = 0u;
  return result;
}

BOOL PCRectClipTest(double a1, double a2, double *a3, double *a4)
{
  if (a1 >= 0.0)
  {
    if (a1 <= 0.0) {
      return a2 >= 0.0;
    }
    double v5 = a2 / a1;
    if (v5 >= *a3)
    {
      if (v5 < *a4) {
        *a4 = v5;
      }
      return 1;
    }
    return 0;
  }
  double v4 = a2 / a1;
  if (v4 > *a4) {
    return 0;
  }
  if (v4 > *a3) {
    *a3 = v4;
  }
  return 1;
}

void *getNCLCToCGNameMap(void)
{
  {
    makeNCLCToCGNameMap();
    __cxa_atexit((void (*)(void *))std::map<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>::~map[abi:ne180100], &getNCLCToCGNameMap(void)::result, &dword_1B73F3000);
  }
  return &getNCLCToCGNameMap(void)::result;
}

void sub_1B76AB6DC(_Unwind_Exception *a1)
{
}

uint64_t makeNCLCToCGNameMap(void)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = *MEMORY[0x1E4F1DC88];
  uint64_t v1 = *MEMORY[0x1E4F1DBE0];
  int v11 = 0;
  uint64_t v10 = 0x800000001;
  uint64_t v12 = v0;
  uint64_t v13 = v1;
  uint64_t v2 = *MEMORY[0x1E4F1DC98];
  uint64_t v3 = *MEMORY[0x1E4F1DBE8];
  uint64_t v14 = 0xD00000001;
  int v15 = 0;
  uint64_t v16 = v2;
  uint64_t v17 = v3;
  uint64_t v4 = *MEMORY[0x1E4F1DC80];
  uint64_t v5 = *MEMORY[0x1E4F1DBD8];
  uint64_t v18 = 0x800000009;
  int v19 = 0;
  uint64_t v20 = v4;
  uint64_t v21 = v5;
  uint64_t v6 = *MEMORY[0x1E4F1DB90];
  uint64_t v7 = *MEMORY[0x1E4F1DBB0];
  uint64_t v22 = 0xD0000000CLL;
  int v23 = 0;
  uint64_t v24 = v6;
  uint64_t v25 = v7;
  uint64_t v8 = *MEMORY[0x1E4F1DB88];
  int v27 = 0;
  uint64_t v26 = 0x110000000BLL;
  uint64_t v28 = v8;
  uint64_t v29 = 0;
  return std::map<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>::map[abi:ne180100]((uint64_t)&getNCLCToCGNameMap(void)::result, &v10, 5);
}

uint64_t std::map<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>::~map[abi:ne180100](uint64_t a1)
{
  return a1;
}

uint64_t getAPILock@<X0>(uint64_t a1@<X8>)
{
  {
    operator new();
  }
  uint64_t v2 = (PCMutex *)getAPILock(void)::mutex;
  *(void *)a1 = getAPILock(void)::mutex;
  *(unsigned char *)(a1 + 8) = 0;
  uint64_t result = PCMutex::lock(v2);
  *(unsigned char *)(a1 + 8) = 1;
  return result;
}

void sub_1B76AB8EC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

CGColorSpaceRef PCGetNCLCColorSpace(unsigned int *a1)
{
  BOOL v2 = operator==((uint64_t)a1, (uint64_t)&kPCNCLC_Rec2020Linear);

  return PCGetNCLCColorSpace(a1, v2);
}

CGColorSpaceRef PCGetNCLCColorSpace(unsigned int *a1, int a2)
{
  unint64_t v8 = PCMakeCanonicalNCLCCode(a1);
  int v9 = v3;
  if (!PCIsUsableNCLCCode((unsigned int *)&v8)) {
    return 0;
  }
  getAPILock((uint64_t)&v6);
  CGColorSpaceRef ColorSpace_Locked = findOrMakeColorSpace_Locked(&v8, a2, 1);
  if (v6 && v7) {
    PCMutex::unlock(v6);
  }
  return ColorSpace_Locked;
}

void sub_1B76AB9E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

CGColorSpaceRef findOrMakeColorSpace_Locked(_DWORD *a1, int a2, uint64_t a3)
{
  values[3] = *(void **)MEMORY[0x1E4F143B8];
  *(void *)&long long v41 = *(void *)a1;
  DWORD2(v41) = a1[2];
  BYTE12(v41) = a2;
  {
    operator new();
  }
  uint64_t v6 = getColorSpaceMap(void)::result;
  char v7 = (void *)(getColorSpaceMap(void)::result + 8);
  unint64_t v8 = *(void **)(getColorSpaceMap(void)::result + 8);
  if (!v8) {
    goto LABEL_9;
  }
  uint64_t v9 = getColorSpaceMap(void)::result + 8;
  do
  {
    int v11 = v8 + 1;
    if (!v10)
    {
      int v11 = v8;
      uint64_t v9 = (uint64_t)v8;
    }
    unint64_t v8 = (void *)*v11;
  }
  while (*v11);
  if ((void *)v9 == v7
  {
LABEL_9:
    ColorSpaceList = (uint64_t *)getColorSpaceList();
    CGColorSpaceRef space = 0;
    if (!a3) {
      goto LABEL_18;
    }
    getNCLCToCGNameMap();
    uint64_t v13 = (char *)std::__tree<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::__map_value_compare<PCNCLCCode,std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::less<PCNCLCCode>,true>,std::allocator<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>>>::find<PCNCLCCode>((uint64_t)&getNCLCToCGNameMap(void)::result, a1);
    if (v13 == (char *)&unk_1E9EE4D40)
    {
      int v15 = 0;
    }
    else
    {
      uint64_t v14 = 56;
      if (!a2) {
        uint64_t v14 = 48;
      }
      int v15 = *(__CFString **)&v13[v14];
      if (v15) {
        int v15 = (__CFString *)CGColorSpaceCreateWithName(v15);
      }
    }
    CGColorSpaceRef space = (CGColorSpaceRef)v15;
    keys[0] = 0;
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)keys);
    if (!space)
    {
LABEL_18:
      if (a2 == 1)
      {
        CGColorSpaceRef ColorSpace_Locked = (CGColorSpace *)findOrMakeColorSpace_Locked(a1, 0, a3);
        uint64_t v18 = ColorSpace_Locked;
        if (ColorSpace_Locked) {
          PCCFRefTraits<CGColorSpace *>::retain(ColorSpace_Locked);
        }
        keys[0] = v18;
        PCCreateExtendedColorSpace((CGColorSpace **)keys, (CGColorSpaceRef *)values);
        CGColorSpaceRef space = (CGColorSpaceRef)values[0];
        values[0] = 0;
        PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)values);
        int v19 = (CGColorSpace **)keys;
      }
      else
      {
        if (operator==((uint64_t)&v41, (uint64_t)&kPCNCLC_P3_D65Linear))
        {
          PCICCTransferFunctionLinear::PCICCTransferFunctionLinear((PCICCTransferFunctionLinear *)values);
          PCMakeDisplayRGBProfile((float *)&kPCChromaticities_P3_D65, (uint64_t)values, (PCICCProfile *)keys);
          makeColorSpaceRef((const PCICCProfile *)keys, &v39);
          PCICCProfile::~PCICCProfile((PCICCProfile *)keys);
          PCICCTransferFunctionLinear::~PCICCTransferFunctionLinear((PCICCTransferFunctionLinear *)values);
        }
        else if (operator==((uint64_t)&v41, (uint64_t)&kPCNCLC_P3_D65))
        {
          PCICCTransferFunctionGamma::PCICCTransferFunctionGamma((PCICCTransferFunctionGamma *)values, 1.961);
          PCMakeDisplayRGBProfile((float *)&kPCChromaticities_P3_D65, (uint64_t)values, (PCICCProfile *)keys);
          makeColorSpaceRef((const PCICCProfile *)keys, &v39);
          PCICCProfile::~PCICCProfile((PCICCProfile *)keys);
          PCICCTransferFunctionGamma::~PCICCTransferFunctionGamma((PCICCTransferFunctionGamma *)values);
        }
        else
        {
          uint64_t v20 = (void *)PCGetPrimariesString(v41);
          uint64_t v21 = (void *)PCGetTransferFunctionString(SDWORD1(v41));
          uint64_t v22 = (void *)PCGetMatrixString(SDWORD2(v41));
          int v23 = (void *)*MEMORY[0x1E4F24BC8];
          keys[0] = *(void **)MEMORY[0x1E4F24A90];
          keys[1] = v23;
          keys[2] = *(void **)MEMORY[0x1E4F24C18];
          values[0] = v20;
          values[1] = v21;
          values[2] = v22;
          CFDictionaryRef v42 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          long long v39 = PCCreateColorSpaceFromAttachments(v42);
          PCCFRef<__CFDictionary const*>::~PCCFRef((const void **)&v42);
        }
        uint64_t v24 = v39;
        if (space && space != v39)
        {
          PCCFRefTraits<CGColorSpace *>::release(space);
          uint64_t v24 = v39;
        }
        long long v39 = 0;
        CGColorSpaceRef space = v24;
        int v19 = &v39;
      }
      PCCFRef<CGColorSpace *>::~PCCFRef(v19);
    }
    uint64_t v25 = (CGColorSpaceRef *)ColorSpaceList[1];
    if ((unint64_t)v25 >= ColorSpaceList[2])
    {
      uint64_t v27 = std::vector<PCCFRef<CGColorSpace *>>::__push_back_slow_path<PCCFRef<CGColorSpace *> const&>(ColorSpaceList, &space);
    }
    else
    {
      uint64_t v26 = space;
      *uint64_t v25 = space;
      if (v26) {
        PCCFRefTraits<CGColorSpace *>::retain(v26);
      }
      uint64_t v27 = (uint64_t)(v25 + 1);
      ColorSpaceList[1] = (uint64_t)(v25 + 1);
    }
    ColorSpaceList[1] = v27;
    CGColorSpaceRef v28 = space;
    uint64_t v29 = (_OWORD *)*v7;
    if (*v7)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v30 = v29;
          uint64_t v31 = (uint64_t)(v29 + 2);
          uint64_t v29 = (_OWORD *)*v30;
          char v7 = v30;
          if (!*v30) {
            goto LABEL_45;
          }
        }
          break;
        char v7 = v30 + 1;
        uint64_t v29 = (_OWORD *)v30[1];
        if (!v29) {
          goto LABEL_45;
        }
      }
      long long v32 = (_OWORD *)*v7;
      if (*v7) {
        goto LABEL_48;
      }
    }
    else
    {
      uint64_t v30 = v7;
    }
LABEL_45:
    long long v32 = operator new(0x38uLL);
    v32[2] = v41;
    *((void *)v32 + 6) = 0;
    *(void *)long long v32 = 0;
    *((void *)v32 + 1) = 0;
    *((void *)v32 + OZChannelFontBase::~OZChannelFontBase(this - 2) = v30;
    *char v7 = v32;
    uint64_t v33 = **(void **)v6;
    uint64_t v34 = (uint64_t *)v32;
    if (v33)
    {
      *(void *)uint64_t v6 = v33;
      uint64_t v34 = (uint64_t *)*v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v6 + 8), v34);
    ++*(void *)(v6 + 16);
LABEL_48:
    *((void *)v32 + 6) = v28;
    NCLCHashTable = (float *)getNCLCHashTable();
    keys[0] = space;
    CGColorSpaceRef v16 = space;
    uint64_t v37 = v41;
    *((_DWORD *)v36 + OZChannelFontBase::~OZChannelFontBase(this - 2) = DWORD2(v41);
    *(void *)long long v36 = v37;
    PCCFRef<CGColorSpace *>::~PCCFRef(&space);
    return v16;
  }
  return *(CGColorSpaceRef *)(v9 + 48);
}

void sub_1B76ABEB0(_Unwind_Exception *a1)
{
}

unint64_t PCGetNCLCCodeForColorSpace(CGColorSpace *a1)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  CFTypeRef v37 = a1;
  if (a1)
  {
    NCLCHashTable = (void *)getNCLCHashTable();
    getAPILock((uint64_t)&v35);
    if (v2) {
      goto LABEL_31;
    }
    if ((initNamedNCLCCodeColorSpaces_Locked(void)::done & 1) == 0)
    {
      uint64_t v3 = 0;
      initNamedNCLCCodeColorSpaces_Locked(void)::done = 1;
      long long v48 = xmmword_1B7E7CFA4;
      long long v49 = unk_1B7E7CFB4;
      long long v50 = xmmword_1B7E7CFC4;
      long long v51 = unk_1B7E7CFD4;
      long long v44 = xmmword_1B7E7CF64;
      long long v45 = unk_1B7E7CF74;
      long long v46 = xmmword_1B7E7CF84;
      long long v47 = unk_1B7E7CF94;
      long long v40 = xmmword_1B7E7CF24;
      long long v41 = unk_1B7E7CF34;
      long long v42 = xmmword_1B7E7CF44;
      long long v43 = unk_1B7E7CF54;
      do
      {
        findOrMakeColorSpace_Locked((long long *)((char *)&v40 + v3), 0, 1);
        findOrMakeColorSpace_Locked((long long *)((char *)&v40 + v3), 1, 1);
        v3 += 12;
      }
      while (v3 != 192);
    }
    if (v2) {
      goto LABEL_31;
    }
    if ((initCGColorSpaces_Locked(void)::done & 1) == 0)
    {
      uint64_t v4 = 0;
      initCGColorSpaces_Locked(void)::done = 1;
      *(void *)&long long v40 = *MEMORY[0x1E4F1DC98];
      *((void *)&v40 + 1) = 0xD00000001;
      LODWORD(v41) = 0;
      *((void *)&v41 + 1) = *MEMORY[0x1E4F1DBE8];
      *(void *)&long long v42 = 0xD00000001;
      DWORD2(v4OZChannelFontBase::~OZChannelFontBase(this - 2) = 0;
      *(void *)&long long v43 = *MEMORY[0x1E4F1DC88];
      *((void *)&v43 + 1) = 0x800000001;
      LODWORD(v44) = 0;
      *((void *)&v44 + 1) = *MEMORY[0x1E4F1DBE0];
      *(void *)&long long v45 = 0x800000001;
      DWORD2(v45) = 0;
      *(void *)&long long v46 = *MEMORY[0x1E4F1DC58];
      *((void *)&v46 + 1) = 0x100000001;
      LODWORD(v47) = 1;
      uint64_t v5 = *MEMORY[0x1E4F1DC28];
      DWORD2(v48) = 9;
      *((void *)&v47 + 1) = v5;
      *(void *)&long long v48 = 0x100000009;
      *(void *)&long long v49 = *MEMORY[0x1E4F1DBC0];
      *((void *)&v49 + 1) = 0x100000009;
      LODWORD(v50) = 9;
      *((void *)&v50 + 1) = *MEMORY[0x1E4F1DC80];
      *(void *)&long long v51 = 0x800000009;
      DWORD2(v51) = 0;
      uint64_t v52 = *MEMORY[0x1E4F1DBD8];
      uint64_t v53 = 0x800000009;
      int v54 = 0;
      uint64_t v55 = *MEMORY[0x1E4F1DB88];
      uint64_t v56 = 0x110000000BLL;
      int v57 = 0;
      uint64_t v58 = *MEMORY[0x1E4F1DB90];
      uint64_t v59 = 0xD0000000CLL;
      int v60 = 0;
      uint64_t v6 = *MEMORY[0x1E4F1DBB0];
      int v63 = 0;
      uint64_t v61 = v6;
      uint64_t v62 = 0xD0000000CLL;
      uint64_t v7 = *MEMORY[0x1E4F1DC70];
      int v66 = 0;
      uint64_t v64 = v7;
      uint64_t v65 = 0x80000000CLL;
      uint64_t v8 = *MEMORY[0x1E4F1DBC8];
      int v69 = 0;
      uint64_t v67 = v8;
      uint64_t v68 = 0x80000000CLL;
      uint64_t v9 = *MEMORY[0x1E4F1DC50];
      int v72 = 9;
      uint64_t v70 = v9;
      uint64_t v71 = 0x1000000009;
      uint64_t v10 = *MEMORY[0x1E4F1DC48];
      int v75 = 9;
      uint64_t v73 = v10;
      uint64_t v74 = 0x1200000009;
      uint64_t v11 = *MEMORY[0x1E4F1DBA0];
      int v78 = 1;
      uint64_t v76 = v11;
      uint64_t v77 = 0x100000000CLL;
      uint64_t v12 = *MEMORY[0x1E4F1DB98];
      int v81 = 1;
      uint64_t v79 = v12;
      uint64_t v80 = 0x120000000CLL;
      do
      {
        CFStringRef v13 = *(const __CFString **)((char *)&v40 + v4);
        if (v13) {
          CFStringRef v13 = (const __CFString *)CGColorSpaceCreateWithName(v13);
        }
        space[0] = (CGColorSpaceRef)v13;
        uint64_t v14 = (float *)getNCLCHashTable();
        CGColorSpaceRef v38 = space[0];
        {
          ColorSpaceList = (uint64_t *)getColorSpaceList();
          CGColorSpaceRef v16 = ColorSpaceList;
          uint64_t v17 = (CGColorSpaceRef *)ColorSpaceList[1];
          if ((unint64_t)v17 >= ColorSpaceList[2])
          {
            uint64_t v19 = std::vector<PCCFRef<CGColorSpace *>>::__push_back_slow_path<PCCFRef<CGColorSpace *> const&>(ColorSpaceList, space);
          }
          else
          {
            uint64_t v18 = space[0];
            CGColorSpaceRef *v17 = space[0];
            if (v18) {
              PCCFRefTraits<CGColorSpace *>::retain(v18);
            }
            uint64_t v19 = (uint64_t)(v17 + 1);
            v16[1] = (uint64_t)(v17 + 1);
          }
          v16[1] = v19;
          CGColorSpaceRef v38 = space[0];
          *(void *)uint64_t v20 = *(void *)((char *)&v40 + v4 + 8);
          *((_DWORD *)v20 + OZChannelFontBase::~OZChannelFontBase(this - 2) = *(_DWORD *)((char *)&v40 + v4 + 16);
        }
        PCCFRef<CGColorSpace *>::~PCCFRef(space);
        v4 += 24;
      }
      while (v4 != 432);
    }
    if (v2) {
      goto LABEL_31;
    }
    if ((initAllNCLCCodeColorSpaces_Locked(void)::done & 1) == 0)
    {
      uint64_t v21 = 0;
      initAllNCLCCodeColorSpaces_Locked(void)::done = 1;
      do
      {
        uint64_t v22 = 0;
        unsigned int v23 = dword_1B7E7CFE4[v21];
        do
        {
          uint64_t v24 = 0;
          uint64_t v25 = dword_1B7E7CFFC[v22];
          do
          {
            *(void *)&long long v40 = PCMakeCanonicalNCLCCode(v23, v25, dword_1B7E7DA20[v24]);
            DWORD2(v40) = v26;
            findOrMakeColorSpace_Locked(&v40, 0, 0);
            findOrMakeColorSpace_Locked(&v40, 1, 0);
            ++v24;
          }
          while (v24 != 4);
          ++v22;
        }
        while (v22 != 7);
        ++v21;
      }
      while (v21 != 6);
    }
    if (v2) {
      goto LABEL_31;
    }
    if ((initBugFixColorSpaces_Locked(void)::done & 1) == 0)
    {
      initBugFixColorSpaces_Locked(void)::done = 1;
      addDataBlobColorSpace_Locked(&kPCNCLC_P3_D65, p3D65Profile_OS12_1, 664);
      PCICCTransferFunctionParametric0::PCICCTransferFunctionParametric0((PCICCTransferFunctionParametric0 *)space, 1.961);
      PCMakeDisplayRGBProfile((float *)&kPCChromaticities_P3_D65, (uint64_t)space, (PCICCProfile *)&v40);
      ProfileData = (const UInt8 *)PCICCProfile::getProfileData((PCICCProfile *)&v40);
      unsigned int Size = PCICCProfile::getSize((ProCore::Private **)&v40);
      addDataBlobColorSpace_Locked(&kPCNCLC_P3_D65, ProfileData, Size);
      PCICCProfile::~PCICCProfile((PCICCProfile *)&v40);
      PCICCTransferFunctionParametric0::~PCICCTransferFunctionParametric0((PCICCTransferFunctionParametric0 *)space);
      addDataBlobColorSpace_Locked(&kPCNCLC_Rec709, Rec709Profile_OS12_1, 660);
      addDataBlobColorSpace_Locked(&kPCNCLC_Rec709, Rec709Profile_OS12_2, 556);
      addDataBlobColorSpace_Locked(&kPCNCLC_Rec2020, Rec2020Profile_OS12_1, 688);
    }
    if (v2)
    {
LABEL_31:
      int v29 = 0;
      uint64_t v30 = v2[3];
      unint64_t v31 = (unint64_t)v30 & 0xFFFFFFFF00000000;
    }
    else
    {
      unint64_t v31 = 0;
      LODWORD(v30) = 0;
      int v29 = 1;
    }
    if (v35 && v36) {
      PCMutex::unlock(v35);
    }
    if (v29) {
      uint64_t v32 = 0x200000000;
    }
    else {
      uint64_t v32 = v31;
    }
    if (v29) {
      unsigned int v33 = 2;
    }
    else {
      unsigned int v33 = v30;
    }
  }
  else
  {
    uint64_t v32 = 0x200000000;
    unsigned int v33 = 2;
  }
  return v32 & 0xFFFFFFFF00000000 | v33;
}

void sub_1B76AC540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t getNCLCHashTable(void)
{
  {
    operator new();
  }
  return getNCLCHashTable(void)::result;
}

void sub_1B76AC650(_Unwind_Exception *a1)
{
}

uint64_t **std::unordered_map<CGColorSpace *,PCNCLCCode,anonymous namespace'::Hash,anonymous namespace'::Equal,std::allocator<std::pair<CGColorSpace * const,PCNCLCCode>>>::find[abi:ne180100](void *a1, CFTypeRef *a2)
{
  CFHashCode v4 = CFHash(*a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  CFHashCode v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    CFHashCode v9 = v4;
    if (v4 >= *(void *)&v5) {
      CFHashCode v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    CFHashCode v9 = (*(void *)&v5 - 1) & v4;
  }
  uint64_t v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  for (uint64_t i = *v10; i; uint64_t i = (uint64_t **)*i)
  {
    unint64_t v12 = (unint64_t)i[1];
    if (v12 == v6)
    {
      if (CFEqual(i[2], *a2)) {
        return i;
      }
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(void *)&v5) {
          v12 %= *(void *)&v5;
        }
      }
      else
      {
        v12 &= *(void *)&v5 - 1;
      }
      if (v12 != v9) {
        return 0;
      }
    }
  }
  return i;
}

uint64_t std::map<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>::map[abi:ne180100](uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  CFHashCode v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 32 * a3;
    do
    {
      std::__tree<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::__map_value_compare<PCNCLCCode,std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::less<PCNCLCCode>,true>,std::allocator<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>>>::__emplace_hint_unique_key_args<PCNCLCCode,std::pair<PCNCLCCode const,std::pair<__CFString const*,__CFString const*>> const&>((uint64_t **)a1, v4, a2, a2);
      a2 += 8;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_1B76AC7CC(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::__map_value_compare<PCNCLCCode,std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::less<PCNCLCCode>,true>,std::allocator<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>>>::__emplace_hint_unique_key_args<PCNCLCCode,std::pair<PCNCLCCode const,std::pair<__CFString const*,__CFString const*>> const&>(uint64_t **a1, uint64_t *a2, _DWORD *a3, _OWORD *a4)
{
  uint64_t v6 = std::__tree<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::__map_value_compare<PCNCLCCode,std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::less<PCNCLCCode>,true>,std::allocator<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>>>::__find_equal<PCNCLCCode>(a1, a2, &v12, &v11, a3);
  uint8x8_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    unint64_t v8 = (uint64_t **)v6;
    uint8x8_t v7 = (uint64_t *)operator new(0x40uLL);
    long long v9 = a4[1];
    *((_OWORD *)v7 + OZChannelFontBase::~OZChannelFontBase(this - 2) = *a4;
    *((_OWORD *)v7 + 3) = v9;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, (uint64_t)v12, v8, v7);
  }
  return v7;
}

uint64_t *std::__tree<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::__map_value_compare<PCNCLCCode,std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::less<PCNCLCCode>,true>,std::allocator<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>>>::__find_equal<PCNCLCCode>(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, _DWORD *a5)
{
  long long v9 = a1 + 1;
  if (a1 + 1 != a2 && !operator<(a5, (_DWORD *)a2 + 8))
  {
    if (!operator<((_DWORD *)a2 + 8, a5))
    {
      *a3 = a2;
      *a4 = (uint64_t)a2;
      return a4;
    }
    a4 = a2 + 1;
    uint64_t v13 = a2[1];
    if (v13)
    {
      uint64_t v14 = (uint64_t *)a2[1];
      do
      {
        int v15 = v14;
        uint64_t v14 = (uint64_t *)*v14;
      }
      while (v14);
    }
    else
    {
      uint64_t v18 = a2;
      do
      {
        int v15 = (uint64_t *)v18[2];
        BOOL v17 = *v15 == (void)v18;
        uint64_t v18 = v15;
      }
      while (!v17);
    }
    if (v15 != v9)
    {
      if (!operator<(a5, (_DWORD *)v15 + 8)) {
        goto LABEL_28;
      }
      uint64_t v13 = *a4;
    }
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = a2;
    }
    return a4;
  }
  if ((uint64_t *)*a1 == a2)
  {
    unint64_t v12 = a2;
LABEL_16:
    if (*a2)
    {
      *a3 = v12;
      return v12 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  uint64_t v11 = (uint64_t *)*a2;
  if (*a2)
  {
    do
    {
      unint64_t v12 = v11;
      uint64_t v11 = (uint64_t *)v11[1];
    }
    while (v11);
  }
  else
  {
    CGColorSpaceRef v16 = a2;
    do
    {
      unint64_t v12 = (uint64_t *)v16[2];
      BOOL v17 = *v12 == (void)v16;
      CGColorSpaceRef v16 = v12;
    }
    while (v17);
  }
  if (operator<((_DWORD *)v12 + 8, a5)) {
    goto LABEL_16;
  }
LABEL_28:

  return std::__tree<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::__map_value_compare<PCNCLCCode,std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::less<PCNCLCCode>,true>,std::allocator<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>>>::__find_equal<PCNCLCCode>((uint64_t)a1, a3, a5);
}

void *std::__tree<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::__map_value_compare<PCNCLCCode,std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::less<PCNCLCCode>,true>,std::allocator<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>>>::__find_equal<PCNCLCCode>(uint64_t a1, void *a2, _DWORD *a3)
{
  int8x8_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint8x8_t v7 = (void *)v4;
        unint64_t v8 = (_DWORD *)(v4 + 32);
        if (!operator<(a3, (_DWORD *)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v7;
        int8x8_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!operator<(v8, a3)) {
        break;
      }
      int8x8_t v5 = v7 + 1;
      uint64_t v4 = v7[1];
    }
    while (v4);
  }
  else
  {
    uint8x8_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t getColorSpaceList(void)
{
  {
    operator new();
  }
  return getColorSpaceList(void)::result;
}

void sub_1B76ACB10(_Unwind_Exception *a1)
{
}

char *std::unordered_map<CGColorSpace *,PCNCLCCode,anonymous namespace'::Hash,anonymous namespace'::Equal,std::allocator<std::pair<CGColorSpace * const,PCNCLCCode>>>::operator[](float *a1, CFTypeRef *a2)
{
  CFHashCode v5 = CFHash(*a2);
  CFHashCode v6 = v5;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    unint64_t v9 = v8.u32[0];
    if (v8.u32[0] > 1uLL)
    {
      CFHashCode v2 = v5;
      if (v5 >= v7) {
        CFHashCode v2 = v5 % v7;
      }
    }
    else
    {
      CFHashCode v2 = (v7 - 1) & v5;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v2);
    if (v10)
    {
      uint64_t v11 = (char *)*v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = *((void *)v11 + 1);
          if (v12 == v6)
          {
            if (CFEqual(*((CFTypeRef *)v11 + 2), *a2)) {
              return v11 + 24;
            }
          }
          else
          {
            if (v9 > 1)
            {
              if (v12 >= v7) {
                v12 %= v7;
              }
            }
            else
            {
              v12 &= v7 - 1;
            }
            if (v12 != v2) {
              break;
            }
          }
          uint64_t v11 = *(char **)v11;
        }
        while (v11);
      }
    }
  }
  uint64_t v11 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = v6;
  *((void *)v11 + OZChannelFontBase::~OZChannelFontBase(this - 2) = *a2;
  *((void *)v11 + 3) = 0x200000002;
  *((_DWORD *)v11 + 8) = 2;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = (v7 & (v7 - 1)) == 0;
    if (v7 < 3) {
      BOOL v15 = 0;
    }
    unint64_t v16 = (2 * v7) | !v15;
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v7 = *((void *)a1 + 1);
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v19 = operator new(8 * *(void *)&prime);
          uint64_t v20 = *(void **)a1;
          *(void *)a1 = v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          uint64_t v22 = (void *)*((void *)a1 + 2);
          if (v22)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v23) = a1 + 4;
            CGColorSpaceRef v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v29))
                  {
                    *(void *)(*(void *)a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *uint64_t v22 = *v28;
                  *CGColorSpaceRef v28 = **(void **)(*(void *)a1 + 8 * v29);
                  **(void **)(*(void *)a1 + 8 * v29) = v28;
                  CGColorSpaceRef v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_55:
                uint64_t v22 = v28;
                CGColorSpaceRef v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v34 = *(void **)a1;
        *(void *)a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        CFHashCode v2 = v6 % v7;
      }
      else {
        CFHashCode v2 = v6;
      }
    }
    else
    {
      CFHashCode v2 = (v7 - 1) & v6;
    }
  }
  uint64_t v30 = *(void **)a1;
  unint64_t v31 = *(void **)(*(void *)a1 + 8 * v2);
  if (v31)
  {
    *(void *)uint64_t v11 = *v31;
LABEL_72:
    *unint64_t v31 = v11;
    goto LABEL_73;
  }
  *(void *)uint64_t v11 = *((void *)a1 + 2);
  *((void *)a1 + OZChannelFontBase::~OZChannelFontBase(this - 2) = v11;
  v30[v2] = a1 + 4;
  if (*(void *)v11)
  {
    unint64_t v32 = *(void *)(*(void *)v11 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    unint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v11 + 24;
}

void sub_1B76ACF24(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL std::less<anonymous namespace'::ColorSpaceKey>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (!operator!=((_DWORD *)a1, (_DWORD *)a2)) {
    return *(unsigned __int8 *)(a1 + 12) < *(unsigned __int8 *)(a2 + 12);
  }

  return operator<((_DWORD *)a1, (_DWORD *)a2);
}

uint64_t std::__tree<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::__map_value_compare<PCNCLCCode,std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>,std::less<PCNCLCCode>,true>,std::allocator<std::__value_type<PCNCLCCode,std::pair<__CFString const*,__CFString const*>>>>::find<PCNCLCCode>(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    BOOL v6 = operator<((_DWORD *)(v3 + 32), a2);
    unint64_t v7 = (uint64_t *)(v3 + 8);
    if (!v6)
    {
      unint64_t v7 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v5 == v2 || operator<(a2, (_DWORD *)(v5 + 32))) {
    return v2;
  }
  return v5;
}

const void **makeColorSpaceRef@<X0>(const PCICCProfile *a1@<X0>, void *a2@<X8>)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  ProfileData = (const UInt8 *)PCICCProfile::getProfileData(a1);
  unsigned int Size = PCICCProfile::getSize((ProCore::Private **)a1);
  CFDataRef v8 = CFDataCreate(v4, ProfileData, Size);
  *a2 = MEMORY[0x1BA9BE620]();
  return PCCFRef<__CTLine const*>::~PCCFRef((const void **)&v8);
}

void sub_1B76AD088(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<__CTLine const*>::~PCCFRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<PCCFRef<CGColorSpace *>>::__push_back_slow_path<PCCFRef<CGColorSpace *> const&>(uint64_t *a1, CGColorSpace **a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 3;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 2 > v5) {
    unint64_t v5 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v18 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = (CGColorSpace **)&v10[8 * v4];
  v15[0] = v10;
  v15[1] = v11;
  unint64_t v16 = v11;
  unint64_t v17 = &v10[8 * v9];
  unint64_t v12 = *a2;
  *uint64_t v11 = *a2;
  if (v12)
  {
    PCCFRefTraits<CGColorSpace *>::retain(v12);
    uint64_t v11 = v16;
  }
  unint64_t v16 = v11 + 1;
  std::vector<PCCFRef<CGColorSpace *>>::__swap_out_circular_buffer(a1, v15);
  uint64_t v13 = a1[1];
  std::__split_buffer<PCCFRef<CGColorSpace *>>::~__split_buffer((uint64_t)v15);
  return v13;
}

void sub_1B76AD174(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<PCCFRef<CGColorSpace *>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<PCCFRef<CGColorSpace *>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PCCFRef<CGColorSpace *>>,std::reverse_iterator<PCCFRef<CGColorSpace *>*>,std::reverse_iterator<PCCFRef<CGColorSpace *>*>,std::reverse_iterator<PCCFRef<CGColorSpace *>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PCCFRef<CGColorSpace *>>,std::reverse_iterator<PCCFRef<CGColorSpace *>*>,std::reverse_iterator<PCCFRef<CGColorSpace *>*>,std::reverse_iterator<PCCFRef<CGColorSpace *>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0;
    do
    {
      unint64_t v12 = *(CGColorSpace **)(a3 + v11 - 8);
      *(void *)(a7 - 8 + v11) = v12;
      if (v12) {
        PCCFRefTraits<CGColorSpace *>::retain(v12);
      }
      v11 -= 8;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void sub_1B76AD27C(_Unwind_Exception *exception_object)
{
  for (; v2; v2 += 8)
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v1 + v2));
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<PCCFRef<CGColorSpace *>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

const void **addDataBlobColorSpace_Locked(uint64_t *a1, const UInt8 *a2, CFIndex a3)
{
  CFDataRef v14 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3);
  CGColorSpaceRef space = (CGColorSpaceRef)MEMORY[0x1BA9BE620]();
  ColorSpaceList = (uint64_t *)getColorSpaceList();
  uint64_t v5 = ColorSpaceList;
  uint64_t v6 = (CGColorSpaceRef *)ColorSpaceList[1];
  if ((unint64_t)v6 >= ColorSpaceList[2])
  {
    uint64_t v8 = std::vector<PCCFRef<CGColorSpace *>>::__push_back_slow_path<PCCFRef<CGColorSpace *> const&>(ColorSpaceList, &space);
  }
  else
  {
    uint64_t v7 = space;
    *uint64_t v6 = space;
    if (v7) {
      PCCFRefTraits<CGColorSpace *>::retain(v7);
    }
    uint64_t v8 = (uint64_t)(v6 + 1);
    v5[1] = (uint64_t)(v6 + 1);
  }
  v5[1] = v8;
  NCLCHashTable = (float *)getNCLCHashTable();
  CGColorSpaceRef v15 = space;
  uint64_t v11 = *a1;
  *((_DWORD *)v10 + OZChannelFontBase::~OZChannelFontBase(this - 2) = *((_DWORD *)a1 + 2);
  *(void *)uint64_t v10 = v11;
  PCCFRef<CGColorSpace *>::~PCCFRef(&space);
  return PCCFRef<__CTLine const*>::~PCCFRef((const void **)&v14);
}

void sub_1B76AD3AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, CGColorSpace *);
  *(void *)(v2 + 8) = v3;
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<__CTLine const*>::~PCCFRef((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t dsfmt_gen_rand_all(uint64_t result)
{
  uint64_t v1 = 0;
  int8x16_t v2 = (int8x16_t)vshlq_n_s64(*(int64x2_t *)result, 0x13uLL);
  int64x2_t v3 = (int64x2_t)veorq_s8(veorq_s8(vorrq_s8((int8x16_t)vshlq_n_s64(*(int64x2_t *)(result + 3056), 0x20uLL), (int8x16_t)vshrq_n_u64(*(uint64x2_t *)(result + 3056), 0x20uLL)), vextq_s8(v2, v2, 8uLL)), vextq_s8(*(int8x16_t *)(result + 1872), *(int8x16_t *)(result + 1872), 8uLL));
  int8x16_t v4 = vextq_s8((int8x16_t)v3, (int8x16_t)v3, 8uLL);
  *(int8x16_t *)uint64_t result = veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v4, 0xCuLL), vandq_s8(v4, (int8x16_t)xmmword_1B7E7DA30)), *(int8x16_t *)result);
  do
  {
    int8x16_t v5 = vorrq_s8((int8x16_t)vshlq_n_s64(v3, 0x20uLL), (int8x16_t)vshrq_n_u64((uint64x2_t)v3, 0x20uLL));
    int64x2_t v6 = *(int64x2_t *)(result + v1 + 16);
    int8x16_t v7 = veorq_s8(veorq_s8(v5, *(int8x16_t *)(result + v1 + 1888)), (int8x16_t)vshlq_n_s64(v6, 0x13uLL));
    *(int8x16_t *)(result + v1 + 16) = veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v7, 0xCuLL), vandq_s8(v7, (int8x16_t)xmmword_1B7E7DA30)), (int8x16_t)v6);
    int64x2_t v3 = (int64x2_t)vextq_s8(v7, v7, 8uLL);
    v1 += 16;
  }
  while (v1 != 1168);
  uint64_t v8 = 0;
  unint64_t v9 = v7.u64[1];
  unint64_t v10 = v7.i64[0];
  do
  {
    uint64_t v11 = result + v8;
    uint64_t v12 = *(void *)(result + v8 + 1184);
    uint64_t v13 = __ROR8__(v10, 32);
    unint64_t v10 = __ROR8__(v9, 32) ^ (v12 << 19) ^ *(void *)(result + v8);
    uint64_t v14 = *(void *)(result + v8 + 1192);
    unint64_t v9 = v13 ^ (v14 << 19) ^ *(void *)(result + v8 + 8);
    *(void *)(v11 + 1184) = v10 & 0xFFAFFFFFFFB3FLL ^ (v10 >> 12) ^ v12;
    *(void *)(v11 + 119OZChannelFontBase::~OZChannelFontBase(this - 2) = v9 & 0xFFDFFFC90FFFDLL ^ (v9 >> 12) ^ v14;
    v8 += 16;
  }
  while (v8 != 1872);
  *(void *)(result + 3056) = v10;
  *(void *)(result + 3064) = v9;
  return result;
}

uint64_t dsfmt_chk_init_gen_rand(uint64_t result, unsigned int a2, int a3)
{
  if (a3 != 19937)
  {
    fwrite("DSFMT_MEXP doesn't match with dSFMT.c\n", 0x26uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
    exit(1);
  }
  *(_DWORD *)uint64_t result = a2;
  for (uint64_t i = 1; i != 768; ++i)
  {
    a2 = i + 1812433253 * (a2 ^ (a2 >> 30));
    *(_DWORD *)(result + 4 * i) = a2;
  }
  uint64_t v4 = 0;
  int8x16_t v5 = (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFuLL);
  __asm { FMOV            V1.2D, #1.0 }
  do
  {
    *(int8x16_t *)(result + v4) = vorrq_s8(vandq_s8(*(int8x16_t *)(result + v4), v5), _Q1);
    v4 += 16;
  }
  while (v4 != 3056);
  unint64_t v11 = (*(void *)(result + 3056) & 0x3D84E1AC0DC82880 | *(void *)(result + 3064) & 1) ^ 0x1000412401080000;
  unint64_t v12 = 32;
  do
  {
    v11 ^= v11 >> v12;
    BOOL v13 = v12 > 1;
    v12 >>= 1;
  }
  while (v13);
  if ((v11 & 1) == 0) {
    *(void *)(result + 3064) ^= 1uLL;
  }
  *(_DWORD *)(result + 307OZChannelFontBase::~OZChannelFontBase(this - 2) = 382;
  return result;
}

void PCAutoreleasePool::PCAutoreleasePool(PCAutoreleasePool *this)
{
  *(void *)this = objc_alloc_init(MEMORY[0x1E4F28B28]);
}

void PCAutoreleasePool::~PCAutoreleasePool(id *this)
{
}

float PCRenderModel::getDefaultBlendingGamma(PCRenderModel *this)
{
  return 1.956;
}

uint64_t PCRenderModel::PCRenderModel(uint64_t a1, int a2)
{
  *(_DWORD *)a1 = a2;
  PCColorSpaceCache::sRGB((CGColorSpace **)(a1 + 8));
  int64x2_t v3 = PCGetWorkingColorSpace((PCColorSpaceCache *)1);
  PCColorSpaceHandle::PCColorSpaceHandle((PCColorSpaceHandle *)(a1 + 16), v3);
  *(void *)(a1 + 24) = 0x3FFA5E353F800000;
  return a1;
}

void sub_1B76AD6BC(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

BOOL PCRenderModel::is_iOS(PCRenderModel *this)
{
  return (*(_DWORD *)this - 1) < 2;
}

uint64_t PCRenderModel::getWorkingColorSpace(uint64_t result, int a2)
{
  if (a2 == 1) {
    return PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)(result + 16));
  }
  if (!a2) {
    return PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)(result + 8));
  }
  return result;
}

float PCRenderModel::getBlendingGamma(uint64_t a1, int a2)
{
  if (a2 == 1) {
    return *(float *)(a1 + 28);
  }
  if (!a2) {
    return *(float *)(a1 + 24);
  }
  return result;
}

void *PCGetDefaultRenderModel(void)
{
  {
    PCRenderModel::PCRenderModel((uint64_t)&PCGetDefaultRenderModel(void)::defaultRenderModel, 0);
    __cxa_atexit((void (*)(void *))PCRenderModel::~PCRenderModel, &PCGetDefaultRenderModel(void)::defaultRenderModel, &dword_1B73F3000);
  }
  return &PCGetDefaultRenderModel(void)::defaultRenderModel;
}

void sub_1B76AD7AC(_Unwind_Exception *a1)
{
}

void PCRenderModel::~PCRenderModel(CGColorSpace **this)
{
}

const void **PCLoadBitmap@<X0>(const __CFURL *a1@<X0>, void *a2@<X8>)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  keys[0] = *(void **)MEMORY[0x1E4F2FF00];
  values = (void *)*MEMORY[0x1E4F1CFD0];
  CFDictionaryRef options = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CGImageSourceRef v4 = CGImageSourceCreateWithURL(a1, options);
  keys[0] = v4;
  if (v4)
  {
    CGImageRef ImageAtIndex = CGImageSourceCreateImageAtIndex(v4, 0, options);
    values = ImageAtIndex;
    if (ImageAtIndex)
    {
      PCBitmapFromCGImageRef(ImageAtIndex, 0, a2);
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"PCLoadBitmap: CGImageSourceCreateImageAtIndex failed.\n", 54);
      *a2 = 0;
      a2[1] = 0;
    }
    PCCFRef<CGImage *>::~PCCFRef((CGImage **)&values);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"PCLoadBitmap: CGImageSourceCreateWithURL failed.\n", 49);
    *a2 = 0;
    a2[1] = 0;
  }
  PCCFRef<__CTLine const*>::~PCCFRef((const void **)keys);
  return PCCFRef<__CFDictionary const*>::~PCCFRef((const void **)&options);
}

void sub_1B76AD924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11)
{
}

void PCBitmapFromCGImageRef(CGImage *a1@<X0>, CGColorSpace *a2@<X1>, void *a3@<X8>)
{
  if (!a1)
  {
    uint64_t v14 = (void *)MEMORY[0x1E4FBA250];
    CGColorSpaceRef v15 = "null CGImageRef passed to PCBitmapFromCGImageRef()\n";
    uint64_t v16 = 51;
LABEL_50:
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)v15, v16);
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  *(_OWORD *)uint64_t v30 = 0u;
  memset(v31, 0, sizeof(v31));
  size_t BitsPerComponent = CGImageGetBitsPerComponent(a1);
  size_t BitsPerPixel = CGImageGetBitsPerPixel(a1);
  ColorSpace = CGImageGetColorSpace(a1);
  unint64_t v9 = ColorSpace;
  if (ColorSpace) {
    PCCFRefTraits<CGColorSpace *>::retain(ColorSpace);
  }
  CGColorSpaceRef space = v9;
  CGColorSpaceModel Model = CGColorSpaceGetModel(v9);
  CGBitmapInfo BitmapInfo = CGImageGetBitmapInfo(a1);
  if (BitsPerComponent <= 8) {
    uint64_t v12 = 8;
  }
  else {
    uint64_t v12 = BitsPerComponent;
  }
  if (Model >= kCGColorSpaceModelCMYK)
  {
    if (Model == kCGColorSpaceModelIndexed)
    {
      BaseColorSpace = CGColorSpaceGetBaseColorSpace(space);
      uint64_t v18 = BaseColorSpace;
      if (BaseColorSpace) {
        PCCFRefTraits<CGColorSpace *>::retain(BaseColorSpace);
      }
      unint64_t v32 = v18;
      uint64_t v19 = space;
      if (!space || space == v18) {
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v20 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
      uint64_t v18 = v20;
      if (v20) {
        PCCFRefTraits<CGColorSpace *>::retain(v20);
      }
      unint64_t v32 = v18;
      uint64_t v19 = space;
      if (!space || space == v18) {
        goto LABEL_26;
      }
    }
    PCCFRefTraits<CGColorSpace *>::release(v19);
    uint64_t v18 = v32;
LABEL_26:
    CGColorSpaceRef space = v18;
    unint64_t v32 = 0;
    PCCFRef<CGColorSpace *>::~PCCFRef(&v32);
    if (v12 == 8)
    {
      CGBitmapInfo BitmapInfo = 2;
      LODWORD(BitsPerPixel) = 32;
      goto LABEL_46;
    }
    if (v12 != 32)
    {
      if (v12 == 16)
      {
        CGBitmapInfo BitmapInfo = 4097;
        LODWORD(BitsPerPixel) = 64;
      }
      else
      {
        CGBitmapInfo BitmapInfo = 0;
        LODWORD(BitsPerPixel) = 4 * v12;
      }
      goto LABEL_46;
    }
    CGBitmapInfo BitmapInfo = 8449;
LABEL_43:
    LODWORD(BitsPerPixel) = 128;
    goto LABEL_46;
  }
  if (BitsPerPixel / BitsPerComponent != 3)
  {
    if (BitsPerPixel / BitsPerComponent == 2)
    {
      int v13 = BitmapInfo & 0x1F;
      if ((v13 - 5) < 2)
      {
        BitmapInfo &= 0xFFFFFFE0;
        LODWORD(BitsPerPixel) = v12;
      }
      else if (v13 == 4)
      {
        CGBitmapInfo BitmapInfo = BitmapInfo & 0xFFFFFFE0 | 3;
      }
      else if (v13 == 2)
      {
        CGBitmapInfo BitmapInfo = BitmapInfo & 0xFFFFFFE0 | 1;
      }
    }
    goto LABEL_46;
  }
  if (BitsPerComponent > 8)
  {
    if (v12 != 32) {
      goto LABEL_46;
    }
    if ((BitmapInfo & 0x1F) <= 6 && ((1 << (BitmapInfo & 0x1F)) & 0x61) != 0) {
      CGBitmapInfo BitmapInfo = BitmapInfo & 0xFFFFFFE0 | 1;
    }
    BitmapInfo |= 0x100u;
    goto LABEL_43;
  }
  LODWORD(BitsPerPixel) = 32;
  if ((BitmapInfo & 0x1F) <= 6 && ((1 << (BitmapInfo & 0x1F)) & 0x61) != 0)
  {
    LODWORD(BitsPerPixel) = 32;
    CGBitmapInfo BitmapInfo = BitmapInfo & 0xFFFFFFE0 | 2;
  }
LABEL_46:
  v30[0] = (CGColorSpaceRef)__PAIR64__(BitsPerPixel, v12);
  v30[1] = space;
  *(_DWORD *)unint64_t v31 = BitmapInfo;
  memset(&v31[4], 0, 20);
  PCCFRef<CGColorSpace *>::~PCCFRef(&space);
  if (a2) {
    v30[1] = a2;
  }
  if (MEMORY[0x1BA9C13A0](&space, v30, 0, a1, 0))
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"PCBitmapFromCGImageRef(): vImageBuffer_InitWithCGImage failed, error = ", 71);
    uint64_t v14 = (void *)std::ostream::operator<<();
    CGColorSpaceRef v15 = "\n";
    uint64_t v16 = 1;
    goto LABEL_50;
  }
  if (CGColorSpaceGetModel(v30[1]) < kCGColorSpaceModelCMYK)
  {
    unsigned int v21 = ((v31[0] & 0x1Fu) < 8) & (0xD4u >> v31[0]);
    BOOL v22 = (*(_WORD *)v31 & 0x7000) != 0x2000 && (*(_WORD *)v31 & 0x6000) != 0;
    int v23 = HIDWORD(v30[0]) / LODWORD(v30[0]);
    BOOL v24 = (*(_WORD *)v31 & 0x7000) == 0x4000 || (*(_WORD *)v31 & 0x7000) == 0x2000;
    if ((*(_WORD *)v31 & 0x100) != 0 && LODWORD(v30[0]) == 32 && v24)
    {
      if (v23 == 1)
      {
        int v23 = 14;
      }
      else if (v23 == 2)
      {
        int v23 = 15;
      }
      else if (v21)
      {
        int v23 = 17;
      }
      else
      {
        int v23 = 16;
      }
      goto LABEL_94;
    }
    if (LODWORD(v30[0]) == 16 && (*(_WORD *)v31 & 0x5000) == 0x1000)
    {
      if ((*(_WORD *)v31 & 0x100) != 0)
      {
        if ((((v31[0] & 0x1Fu) < 8) & (0xD4u >> v31[0])) == 0)
        {
          int v23 = 13;
          goto LABEL_94;
        }
      }
      else
      {
        switch(v23)
        {
          case 1:
            int v23 = 7;
            goto LABEL_94;
          case 3:
            int v23 = 9;
            goto LABEL_94;
          case 2:
            int v23 = 8;
            goto LABEL_94;
        }
        if ((((v31[0] & 0x1Fu) < 8) & (0xD4u >> v31[0])) == 0)
        {
          int v23 = 10;
          goto LABEL_94;
        }
      }
    }
    else if (LODWORD(v30[0]) == 8)
    {
      if (v23 != 1 && v23 != 2)
      {
        if (v21) {
          int v25 = 3;
        }
        else {
          int v25 = 5;
        }
        if (v21) {
          int v26 = 6;
        }
        else {
          int v26 = 4;
        }
        if (v22) {
          int v23 = v26;
        }
        else {
          int v23 = v25;
        }
      }
LABEL_94:
      PCCreateBitmap(v29[0], v28[0], v23, v30[1]);
    }
    int v23 = 0;
    goto LABEL_94;
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"PCLoadBitmap: only RGB or grayscale images are supported.\n", 58);
  *a3 = 0;
  a3[1] = 0;
  free(space);
}

void sub_1B76AE024(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGColorSpace *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, CGColorSpace *a18)
{
}

void sub_1B76AE058()
{
  uint64_t v1 = *(std::__shared_weak_count **)(v0 + 8);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  JUMPOUT(0x1B76AE050);
}

CGImage **PCCFRef<CGImage *>::~PCCFRef(CGImage **a1)
{
  int8x16_t v2 = *a1;
  if (v2) {
    PCCFRefTraits<CGImage *>::release(v2);
  }
  return a1;
}

uint64_t PCInfo::texturesShouldUseQuarterRes(PCInfo *this)
{
  if (PCInfo::texturesShouldUseQuarterRes(void)::predicate != -1) {
    dispatch_once(&PCInfo::texturesShouldUseQuarterRes(void)::predicate, &__block_literal_global_12_0);
  }
  return PCInfo::texturesShouldUseQuarterRes(void)::ret;
}

unint64_t ___ZN6PCInfo27texturesShouldUseQuarterResEv_block_invoke(PCInfo *a1)
{
  unint64_t result = PCInfo::availableVRAM(a1);
  PCInfo::texturesShouldUseQuarterRes(void)::ret = result < 0x3E8;
  return result;
}

uint64_t PCInfo::getPhysicalRAM(PCInfo *this)
{
  {
    PCInfo::getPhysicalRAM(void)::physicalRAM = computePhysicalRAM();
  }
  return PCInfo::getPhysicalRAM(void)::physicalRAM;
}

void sub_1B76AE168(_Unwind_Exception *a1)
{
}

uint64_t computePhysicalRAM(void)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *(void *)int64x2_t v3 = 0x1800000006;
  size_t v1 = 8;
  uint64_t v2 = 0;
  if (sysctl(v3, 2u, &v2, &v1, 0, 0)) {
    return 0x100000000;
  }
  else {
    return v2;
  }
}

BOOL PCInfo::getMemoryInfo(PCInfo *this, unint64_t *a2, unint64_t a3, unint64_t a4, unint64_t *a5, unint64_t *a6, unint64_t *a7, unint64_t *a8, unint64_t *a9)
{
  vm_address_t address = 0;
  vm_size_t v56 = 0;
  natural_t nesting_depth = 0;
  vm_size_t size = 0;
  mach_msg_type_number_t infoCnt = 0;
  unint64_t PhysicalRAM = PCInfo::getPhysicalRAM(this);
  host_t v16 = MEMORY[0x1BA9C0890]();
  uint64_t v17 = host_page_size(v16, &v56);
  mach_msg_type_number_t host_info_outCnt = 15;
  host_t v18 = MEMORY[0x1BA9C0890](v17);
  if (host_statistics(v18, 2, host_info_out, &host_info_outCnt))
  {
    BOOL result = 0;
    unint64_t v20 = 0;
    unint64_t v21 = 0;
    unint64_t v22 = 0;
    unint64_t v23 = 0;
    unint64_t v24 = 0;
    unint64_t v25 = 0;
    unint64_t v26 = 0;
  }
  else
  {
    long long v40 = a2;
    long long v41 = a5;
    mach_msg_type_number_t task_info_outCnt = 0;
    uint64_t v27 = host_info_out[0];
    vm_size_t v28 = v56;
    unint64_t v29 = (vm_map_read_t *)MEMORY[0x1E4F14960];
    unint64_t v30 = a3 | a4;
    if (a3 | a4)
    {
      uint64_t v43 = host_info_out[0];
      unint64_t v31 = 0;
      vm_address_t address = 1879048192;
      do
      {
        natural_t nesting_depth = 1;
        mach_msg_type_number_t infoCnt = 19;
        if (vm_region_recurse_64(*v29, &address, &size, &nesting_depth, info, &infoCnt)) {
          break;
        }
        vm_address_t v32 = address;
        if (address >> 28 > 8) {
          break;
        }
        v31 += size;
        address += size;
      }
      while ((size + v32) >> 28 < 9);
      uint64_t v27 = v43;
      if (v31 <= PhysicalRAM) {
        unint64_t v33 = PhysicalRAM;
      }
      else {
        unint64_t v33 = v31;
      }
      unint64_t v30 = PhysicalRAM - v31;
      if (PhysicalRAM < v31) {
        unint64_t v30 = 0;
      }
    }
    else
    {
      unint64_t v33 = 0;
    }
    unint64_t v38 = v30;
    unint64_t v39 = v33;
    unint64_t v25 = 0;
    if (a6)
    {
      natural_t nesting_depth = 0;
      for (vm_address_t address = 0; address < 0xFFFFFFFF; address += size)
      {
        mach_msg_type_number_t infoCnt = 19;
        if (vm_region_recurse_64(*v29, &address, &size, &nesting_depth, info, &infoCnt)) {
          break;
        }
        v25 += size;
      }
    }
    unint64_t v20 = v28 * v27;
    long long v42 = a7;
    unint64_t v26 = 0;
    if (a7)
    {
      vm_size_t v34 = 0;
      natural_t nesting_depth = 0;
      vm_address_t address = 0;
      do
      {
        mach_msg_type_number_t infoCnt = 19;
        if (vm_region_recurse_64(*v29, &address, &size, &nesting_depth, info, &infoCnt)) {
          break;
        }
        vm_address_t v35 = address;
        vm_address_t v36 = address - v34;
        if (address - v34 <= v26) {
          vm_address_t v36 = v26;
        }
        if (address != v34) {
          unint64_t v26 = v36;
        }
        vm_size_t v34 = size + address;
        address += size;
      }
      while (size + v35 <= 0xFFFFFFFE);
    }
    mach_msg_type_number_t task_info_outCnt = 10;
    BOOL v37 = task_info(*v29, 0x12u, &task_info_out, &task_info_outCnt) == 0;
    BOOL result = v37;
    if (v37) {
      unint64_t v23 = v49;
    }
    else {
      unint64_t v23 = 0;
    }
    if (v37) {
      unint64_t v24 = v48 - 0x20000000;
    }
    else {
      unint64_t v24 = 0;
    }
    a7 = v42;
    a2 = v40;
    a5 = v41;
    unint64_t v22 = v38;
    unint64_t v21 = v39;
  }
  if (this) {
    *(void *)this = PhysicalRAM;
  }
  if (a2) {
    *a2 = v20;
  }
  if (a3) {
    *(void *)a3 = v21;
  }
  if (a4) {
    *(void *)a4 = v22;
  }
  if (a5) {
    *a5 = v23;
  }
  if (a6) {
    *a6 = v25;
  }
  if (a7) {
    *a7 = v26;
  }
  if (a8) {
    *a8 = v24;
  }
  return result;
}

BOOL PCInfo::isMemoryAvailable(PCInfo *this)
{
  unint64_t v2 = 0;
  vm_size_t v3 = 0;
  natural_t nesting_depth = 0;
  vm_size_t size = 0;
  vm_address_t address = 0;
  uint64_t v4 = (vm_map_read_t *)MEMORY[0x1E4F14960];
  do
  {
    mach_msg_type_number_t infoCnt = 19;
    if (vm_region_recurse_64(*v4, &address, &size, &nesting_depth, info, &infoCnt)) {
      break;
    }
    vm_address_t v5 = address;
    vm_address_t v6 = address - v3;
    if (address - v3 <= v2) {
      vm_address_t v6 = v2;
    }
    if (address != v3) {
      unint64_t v2 = v6;
    }
    vm_size_t v3 = size + address;
    address += size;
  }
  while (size + v5 <= 0xFFFFFFFE && v2 <= (unint64_t)this);
  return v2 > (unint64_t)this;
}

float PCInfo::getWorkingGamma(PCInfo *this)
{
  return *(float *)&s_workingGamma;
}

uint64_t PCInfo::availableVRAM(PCInfo *this)
{
  if (PCInfo::availableVRAM(void)::onceToken != -1) {
    dispatch_once(&PCInfo::availableVRAM(void)::onceToken, &__block_literal_global_57);
  }
  return PCInfo::availableVRAM(void)::vramAvailable;
}

void ___ZN6PCInfo13availableVRAMEv_block_invoke()
{
  id v0 = MTLCreateSystemDefaultDevice();
  PCInfo::availableVRAM(void)::vramAvailable = (unint64_t)PCInfo::getPhysicalRAM((PCInfo *)[v0 hasUnifiedMemory]) >> 20;
}

uint64_t PCInfo::getDefaultRGBCGColorSpace(PCInfo *this)
{
  {
    PCColorSpaceCache::rec709Linear(&PCInfo::getDefaultRGBCGColorSpace(void)::result);
    __cxa_atexit((void (*)(void *))PCColorSpaceHandle::~PCColorSpaceHandle, &PCInfo::getDefaultRGBCGColorSpace(void)::result, &dword_1B73F3000);
  }

  return PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&PCInfo::getDefaultRGBCGColorSpace(void)::result);
}

void sub_1B76AE6CC(_Unwind_Exception *a1)
{
}

CGColorSpace *PCInfo::getDefaultRGBColorSpace@<X0>(void *a1@<X8>)
{
  {
    PCColorSpaceCache::rec709Linear((CGColorSpace **)&PCInfo::getDefaultRGBColorSpace(void)::result);
    __cxa_atexit((void (*)(void *))PCColorSpaceHandle::~PCColorSpaceHandle, &PCInfo::getDefaultRGBColorSpace(void)::result, &dword_1B73F3000);
  }
  BOOL result = (CGColorSpace *)PCInfo::getDefaultRGBColorSpace(void)::result;
  *a1 = PCInfo::getDefaultRGBColorSpace(void)::result;
  if (result)
  {
    return PCCFRefTraits<CGColorSpace *>::retain(result);
  }
  return result;
}

void sub_1B76AE794(_Unwind_Exception *a1)
{
}

uint64_t PCInfo::getDefaultGrayscaleCGColorSpace(PCInfo *this)
{
  {
    PCColorSpaceCache::gamma22Gray(&PCInfo::getDefaultGrayscaleCGColorSpace(void)::result);
    __cxa_atexit((void (*)(void *))PCColorSpaceHandle::~PCColorSpaceHandle, &PCInfo::getDefaultGrayscaleCGColorSpace(void)::result, &dword_1B73F3000);
  }

  return PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&PCInfo::getDefaultGrayscaleCGColorSpace(void)::result);
}

void sub_1B76AE840(_Unwind_Exception *a1)
{
}

uint64_t PCInfo_IsUnitTesting()
{
  if (PCInfo_IsUnitTesting::onceToken != -1) {
    dispatch_once(&PCInfo_IsUnitTesting::onceToken, &__block_literal_global_8);
  }
  return PCInfo_IsUnitTesting::sIsUnitTesting;
}

void PCTime::PCTime(PCTime *this)
{
  *(void *)this = 0x7FFFFFFFLL;
  *((_DWORD *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0x7FFFFFFF;
}

void PCTimer::PCTimer(PCTimer *this)
{
  *((_DWORD *)this + 5) = 0;
  *((void *)this + 3) = 0;
  *(void *)this = 0;
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  *((_WORD *)this + 8) = 0;
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep PCTimer::start(PCTimer *this)
{
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result = std::chrono::steady_clock::now().__d_.__rep_;
  *(void *)this = result;
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  *((unsigned char *)this + 16) = 1;
  return result;
}

double PCTimer::stop(PCTimer *this)
{
  *((void *)this + 1) += std::chrono::steady_clock::now().__d_.__rep_ - *(void *)this;
  *((unsigned char *)this + 16) = 0;
  ++*((_DWORD *)this + 5);
  double result = PCTimer::getSeconds(this) + *((double *)this + 3);
  *((double *)this + 3) = result;
  return result;
}

double PCTimer::getSeconds(PCTimer *this)
{
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v1 = *((void *)this + 1);
  if (*((unsigned char *)this + 16) && !*((unsigned char *)this + 17)) {
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v1 = std::chrono::steady_clock::now().__d_.__rep_ + v1 - *(void *)this;
  }
  return (double)v1 / 1000000000.0;
}

void PCICCTag::PCICCTag(PCICCTag *this, int a2, const unsigned __int8 *a3, const unsigned __int8 *a4)
{
  *(_DWORD *)this = a2;
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((void *)this + 1, a3, (uint64_t)a4, a4 - a3);
}

uint64_t PCICCTag::reset(uint64_t this, int a2)
{
  *(_DWORD *)this = a2;
  *(void *)(this + 16) = *(void *)(this + 8);
  return this;
}

BOOL PCICCTag::empty(PCICCTag *this)
{
  return *((void *)this + 1) == *((void *)this + 2);
}

uint64_t PCICCTag::size(PCICCTag *this)
{
  return *((void *)this + 2) - *((void *)this + 1);
}

void PCICCTag::resize(PCICCTag *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2) - v2;
  BOOL v4 = a2 >= v3;
  size_t v5 = a2 - v3;
  if (v5 != 0 && v4)
  {
    std::vector<unsigned char>::__append((unint64_t *)this + 1, v5);
  }
  else if (!v4)
  {
    *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v2 + a2;
  }
}

uint64_t PCICCTag::operator[](uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 8) + a2;
}

void PCICCTag::push_back(PCICCTag *this, char a2)
{
  size_t v5 = (unsigned char *)*((void *)this + 2);
  unint64_t v4 = *((void *)this + 3);
  if ((unint64_t)v5 >= v4)
  {
    int8x16_t v7 = (unsigned char **)((char *)this + 8);
    unint64_t v8 = *((void *)this + 1);
    unint64_t v9 = &v5[-v8];
    uint64_t v10 = (uint64_t)&v5[-v8 + 1];
    if (v10 < 0) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = v4 - v8;
    if (2 * v11 > v10) {
      uint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v12 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v12 = v10;
    }
    if (v12) {
      int v13 = operator new(v12);
    }
    else {
      int v13 = 0;
    }
    uint64_t v14 = &v13[v12];
    v9[(void)v13] = a2;
    uint64_t v6 = (uint64_t)&v9[(void)v13 + 1];
    if (v5 == (unsigned char *)v8)
    {
      int v13 = &v9[(void)v13];
    }
    else
    {
      CGColorSpaceRef v15 = &v5[~v8];
      do
      {
        char v16 = *--v5;
        (v15--)[(void)v13] = v16;
      }
      while (v5 != (unsigned char *)v8);
      size_t v5 = *v7;
    }
    *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v13;
    *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v6;
    *((void *)this + 3) = v14;
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *size_t v5 = a2;
    uint64_t v6 = (uint64_t)(v5 + 1);
  }
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v6;
}

double *PCAlgorithm::bisect(double *this, double *a2, int *a3, double a4, int *a5)
{
  int v5 = a2 + 1;
  double v6 = this[(int)a2 - 1];
  double v7 = *this;
  if ((int)a2 + 1 < 2)
  {
    int v8 = 0;
  }
  else
  {
    int v8 = 0;
    do
    {
      if (v6 >= v7 != this[((v8 + v5) >> 1) - 1] > a4) {
        int v8 = (v8 + v5) >> 1;
      }
      else {
        int v5 = (v8 + v5) >> 1;
      }
    }
    while (v5 - v8 > 1);
  }
  if (v7 == a4)
  {
    int v9 = 0;
  }
  else if (v6 == a4)
  {
    int v9 = a2 - 2;
    if (a2 < 2) {
      int v9 = 0;
    }
  }
  else
  {
    BOOL v10 = __OFSUB__(v8, 1);
    int v9 = v8 - 1;
    if ((v9 < 0) ^ v10 | (v9 == 0)) {
      int v9 = 0;
    }
  }
  *a3 = v9;
  return this;
}

double PCAlgorithm::DeCasteljauSubdivide(PCAlgorithm *this, double a2, double a3, double a4, double *a5, double *a6, double *a7, double *a8, double *a9, double *a10, double *a11, double *a12, double *a13)
{
  if (a3 == a2) {
    double v13 = 0.0;
  }
  else {
    double v13 = (a4 - a2) / (a3 - a2);
  }
  *a7 = *(double *)this;
  *a8 = *a5;
  *a9 = *a6;
  a7[1] = *(double *)this + v13 * (*((double *)this + 1) - *(double *)this);
  a8[1] = *a5 + v13 * (a5[1] - *a5);
  a9[1] = *a6 + v13 * (a6[1] - *a6);
  a7[2] = (1.0 - v13) * a7[1] + v13 * (*((double *)this + 1) + v13 * (*((double *)this + 2) - *((double *)this + 1)));
  a8[2] = (1.0 - v13) * a8[1] + v13 * (a5[1] + v13 * (a5[2] - a5[1]));
  a9[2] = (1.0 - v13) * a9[1] + v13 * (a6[1] + v13 * (a6[2] - a6[1]));
  a10[3] = *((double *)this + 3);
  a11[3] = a5[3];
  a12[3] = a6[3];
  a10[2] = *((double *)this + 2) + v13 * (*((double *)this + 3) - *((double *)this + 2));
  a11[2] = a5[2] + v13 * (a5[3] - a5[2]);
  a12[2] = a6[2] + v13 * (a6[3] - a6[2]);
  a10[1] = v13 * a10[2] + (1.0 - v13) * (*((double *)this + 1) + v13 * (*((double *)this + 2) - *((double *)this + 1)));
  a11[1] = v13 * a11[2] + (1.0 - v13) * (a5[1] + v13 * (a5[2] - a5[1]));
  a12[1] = v13 * a12[2] + (1.0 - v13) * (a6[1] + v13 * (a6[2] - a6[1]));
  double v14 = (1.0 - v13) * a7[2] + v13 * a10[1];
  *a10 = v14;
  a7[3] = v14;
  double v15 = (1.0 - v13) * a8[2] + v13 * a11[1];
  *a11 = v15;
  a8[3] = v15;
  double result = (1.0 - v13) * a9[2] + v13 * a12[1];
  *a12 = result;
  a9[3] = result;
  return result;
}

void PCAlgorithm::BezierSubdivide(float64x2_t *a1, float64x2_t *a2, float64x2_t *a3, float64x2_t *a4, int a5, double *a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11, uint64_t a12)
{
  double v22 = a1->f64[0];
  double v23 = a1->f64[1];
  double v122 = a1->f64[0];
  double v123 = v23;
  double v25 = a1[1].f64[0];
  double v24 = a1[1].f64[1];
  double v124 = v25;
  double v125 = v24;
  float64x2_t v26 = a2[1];
  float64x2_t v120 = *a2;
  float64x2_t v121 = v26;
  float64x2_t v27 = a3[1];
  float64x2_t v118 = *a3;
  float64x2_t v119 = v27;
  double v28 = a4->f64[0];
  double v29 = a4->f64[1];
  double v114 = a4->f64[0];
  double v115 = v29;
  double v30 = a4[1].f64[0];
  double v31 = a4[1].f64[1];
  double v116 = v30;
  double v117 = v31;
  if (a6)
  {
    PCMatrix44Tmpl<double>::transform<double>(a6, &v122, &v122);
    PCMatrix44Tmpl<double>::transform<double>(a6, v120.f64, v120.f64);
    PCMatrix44Tmpl<double>::transform<double>(a6, v118.f64, v118.f64);
    PCMatrix44Tmpl<double>::transform<double>(a6, &v114, &v114);
    double v28 = v114;
    double v29 = v115;
    double v22 = v122;
    double v23 = v123;
    double v30 = v116;
    double v31 = v117;
    double v25 = v124;
    double v24 = v125;
  }
  double v32 = (v24 * v28 - v31 * v22) / (v24 * v31);
  double v33 = (v24 * v29 - v31 * v23) / (v24 * v31);
  double v34 = (v24 * v30 - v31 * v25) / (v24 * v31);
  double v35 = sqrt(v32 * v32 + v33 * v33 + v34 * v34);
  double v36 = 0.0;
  double v37 = 0.0;
  if (fabs(v35) >= 0.0000001)
  {
    double v37 = vabdd_f64(v32 * (v23 * v121.f64[1] - v24 * v120.f64[1]) / (v24 * v121.f64[1]), v33 * (v22 * v121.f64[1] - v24 * v120.f64[0]) / (v24 * v121.f64[1]))/ v35;
    double v36 = vabdd_f64(v32 * (v23 * v119.f64[1] - v24 * v118.f64[1]) / (v24 * v119.f64[1]), v33 * (v22 * v119.f64[1] - v24 * v118.f64[0]) / (v24 * v119.f64[1]))/ v35;
  }
  if (v37 >= v36) {
    double v38 = v37;
  }
  else {
    double v38 = v36;
  }
  if (a5 && v38 >= 0.25)
  {
    float64x2_t v39 = a2[1];
    __asm { FMOV            V4.2D, #0.5 }
    float64x2_t v45 = vmulq_f64(vaddq_f64(*a1, *a2), _Q4);
    float64x2_t v46 = a3[1];
    float64x2_t v47 = vmulq_f64(vaddq_f64(*a2, *a3), _Q4);
    float64x2_t v48 = a4[1];
    float64x2_t v49 = vaddq_f64(*a3, *a4);
    float64x2_t v50 = vmulq_f64(vaddq_f64(v45, v47), _Q4);
    float64x2_t v51 = vmulq_f64(vaddq_f64(a1[1], v39), _Q4);
    v113[0] = v45;
    v113[1] = v51;
    float64x2_t v52 = vmulq_f64(vaddq_f64(v39, v46), _Q4);
    float64x2_t v109 = v50;
    float64x2_t v110 = vmulq_f64(vaddq_f64(v51, v52), _Q4);
    float64x2_t v111 = vmulq_f64(v49, _Q4);
    float64x2_t v112 = vmulq_f64(vaddq_f64(v46, v48), _Q4);
    float64x2_t v107 = vmulq_f64(vaddq_f64(v47, v111), _Q4);
    float64x2_t v108 = vmulq_f64(vaddq_f64(v52, v112), _Q4);
    v106[0] = vmulq_f64(vaddq_f64(v50, v107), _Q4);
    v106[1] = vmulq_f64(vaddq_f64(v110, v108), _Q4);
    uint64_t v53 = (a5 - 1);
    double v54 = a10 * 0.5;
    ((void (*)(float64x2_t *, _OWORD *, float64x2_t *, _OWORD *, uint64_t, double *, uint64_t, uint64_t, double, double, uint64_t, uint64_t))PCAlgorithm::BezierSubdivide)(a1, v113, &v109, v106, v53, a6, a7, a8, a9, v54, a11, a12);
    ((void (*)(_OWORD *, float64x2_t *, float64x2_t *, float64x2_t *, uint64_t, double *, uint64_t, uint64_t, double, double, uint64_t, uint64_t))PCAlgorithm::BezierSubdivide)(v106, &v107, &v111, a4, v53, a6, a7, a8, v54 + a9, v54, a11, a12);
  }
  else
  {
    float64_t v55 = a1->f64[0];
    unint64_t v56 = *(void *)(a7 + 16);
    int v57 = *(void **)(a7 + 8);
    if ((unint64_t)v57 >= v56)
    {
      uint64_t v59 = *(void **)a7;
      uint64_t v60 = ((uint64_t)v57 - *(void *)a7) >> 3;
      unint64_t v61 = v60 + 1;
      if ((unint64_t)(v60 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v62 = v56 - (void)v59;
      if (v62 >> 2 > v61) {
        unint64_t v61 = v62 >> 2;
      }
      if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v63 = v61;
      }
      if (v63)
      {
        uint64_t v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a7 + 16, v63);
        uint64_t v59 = *(void **)a7;
        int v57 = *(void **)(a7 + 8);
      }
      else
      {
        uint64_t v64 = 0;
      }
      uint64_t v65 = &v64[8 * v60];
      int v66 = &v64[8 * v63];
      *(float64_t *)uint64_t v65 = v55;
      uint64_t v58 = v65 + 8;
      while (v57 != v59)
      {
        uint64_t v67 = *--v57;
        *((void *)v65 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v67;
        v65 -= 8;
      }
      *(void *)a7 = v65;
      *(void *)(a7 + 8) = v58;
      *(void *)(a7 + 16) = v66;
      if (v59) {
        operator delete(v59);
      }
    }
    else
    {
      *(float64_t *)int v57 = v55;
      uint64_t v58 = v57 + 1;
    }
    *(void *)(a7 + 8) = v58;
    float64_t v68 = a1->f64[1];
    unint64_t v69 = *(void *)(a8 + 16);
    uint64_t v70 = *(void **)(a8 + 8);
    if ((unint64_t)v70 >= v69)
    {
      int v72 = *(void **)a8;
      uint64_t v73 = ((uint64_t)v70 - *(void *)a8) >> 3;
      unint64_t v74 = v73 + 1;
      if ((unint64_t)(v73 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v75 = v69 - (void)v72;
      if (v75 >> 2 > v74) {
        unint64_t v74 = v75 >> 2;
      }
      if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v76 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v76 = v74;
      }
      if (v76)
      {
        uint64_t v77 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a8 + 16, v76);
        int v72 = *(void **)a8;
        uint64_t v70 = *(void **)(a8 + 8);
      }
      else
      {
        uint64_t v77 = 0;
      }
      int v78 = &v77[8 * v73];
      uint64_t v79 = &v77[8 * v76];
      *(float64_t *)int v78 = v68;
      uint64_t v71 = v78 + 8;
      while (v70 != v72)
      {
        uint64_t v80 = *--v70;
        *((void *)v78 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v80;
        v78 -= 8;
      }
      *(void *)a8 = v78;
      *(void *)(a8 + 8) = v71;
      *(void *)(a8 + 16) = v79;
      if (v72) {
        operator delete(v72);
      }
    }
    else
    {
      *(float64_t *)uint64_t v70 = v68;
      uint64_t v71 = v70 + 1;
    }
    *(void *)(a8 + 8) = v71;
    if (a11)
    {
      float64_t v81 = a1[1].f64[0];
      unint64_t v82 = *(void *)(a11 + 16);
      int v83 = *(void **)(a11 + 8);
      if ((unint64_t)v83 >= v82)
      {
        int v85 = *(void **)a11;
        uint64_t v86 = ((uint64_t)v83 - *(void *)a11) >> 3;
        unint64_t v87 = v86 + 1;
        if ((unint64_t)(v86 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v88 = v82 - (void)v85;
        if (v88 >> 2 > v87) {
          unint64_t v87 = v88 >> 2;
        }
        if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v89 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v89 = v87;
        }
        if (v89)
        {
          int v90 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a11 + 16, v89);
          int v85 = *(void **)a11;
          int v83 = *(void **)(a11 + 8);
        }
        else
        {
          int v90 = 0;
        }
        int v91 = &v90[8 * v86];
        int v92 = &v90[8 * v89];
        *(float64_t *)int v91 = v81;
        int v84 = v91 + 8;
        while (v83 != v85)
        {
          uint64_t v93 = *--v83;
          *((void *)v91 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v93;
          v91 -= 8;
        }
        *(void *)a11 = v91;
        *(void *)(a11 + 8) = v84;
        *(void *)(a11 + 16) = v92;
        if (v85) {
          operator delete(v85);
        }
      }
      else
      {
        *(float64_t *)int v83 = v81;
        int v84 = v83 + 1;
      }
      *(void *)(a11 + 8) = v84;
    }
    unint64_t v94 = *(void *)(a12 + 16);
    double v95 = *(double **)(a12 + 8);
    if ((unint64_t)v95 >= v94)
    {
      int v97 = *(double **)a12;
      uint64_t v98 = ((uint64_t)v95 - *(void *)a12) >> 3;
      unint64_t v99 = v98 + 1;
      if ((unint64_t)(v98 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v100 = v94 - (void)v97;
      if (v100 >> 2 > v99) {
        unint64_t v99 = v100 >> 2;
      }
      if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v101 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v101 = v99;
      }
      if (v101)
      {
        unint64_t v102 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a12 + 16, v101);
        int v97 = *(double **)a12;
        double v95 = *(double **)(a12 + 8);
      }
      else
      {
        unint64_t v102 = 0;
      }
      float64x2_t v103 = (double *)&v102[8 * v98];
      unint64_t v104 = &v102[8 * v101];
      *float64x2_t v103 = a9;
      uint64_t v96 = v103 + 1;
      while (v95 != v97)
      {
        uint64_t v105 = *((void *)v95-- - 1);
        *((void *)v103-- - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v105;
      }
      *(void *)a12 = v103;
      *(void *)(a12 + 8) = v96;
      *(void *)(a12 + 16) = v104;
      if (v97) {
        operator delete(v97);
      }
    }
    else
    {
      *double v95 = a9;
      uint64_t v96 = v95 + 1;
    }
    *(void *)(a12 + 8) = v96;
  }
}

BOOL PCAlgorithm::findIntersection(double *a1, double *a2, double *a3, double *a4, double *a5)
{
  double v5 = *a2;
  double v6 = a2[1];
  double v7 = *a4;
  double v8 = a4[1];
  float v9 = *a2 * v8 - v6 * *a4;
  float v10 = v5 * v5 + v6 * v6;
  float v11 = v8 * v8 + v7 * v7;
  float v12 = (float)(v10 * 0.1) * v11;
  if ((float)(v9 * v9) > v12)
  {
    float v13 = (v8 * (*a3 - *a1) - v7 * (a3[1] - a1[1])) / v9;
    double v14 = v13;
    double v15 = v5 * v14;
    double v16 = v6 * v14;
    *a2 = v15;
    a2[1] = v16;
    double v17 = a1[1] + v16;
    *a5 = *a1 + v15;
    a5[1] = v17;
  }
  return (float)(v9 * v9) > v12;
}

void PCAlgorithm::superEllipse(PCAlgorithm *this, double a2, double a3, double a4, double a5, double *a6, double *a7)
{
  float v13 = a2;
  __float2 v14 = __sincosf_stret(v13);
  *(float *)&a5 = a5;
  *(double *)this = powf(fabsf(v14.__cosval), *(float *)&a5) * a3;
  double v15 = powf(fabsf(v14.__sinval), *(float *)&a5) * a4;
  *a6 = v15;
  if (a2 <= 4.71238898)
  {
    if (a2 <= 3.14159265)
    {
      if (a2 <= 1.57079633) {
        return;
      }
      double v15 = *(double *)this;
      a6 = (double *)this;
    }
    else
    {
      *(double *)this = -*(double *)this;
      double v15 = *a6;
    }
  }
  *a6 = -v15;
}

uint64_t PCArray_base::gnomesortImpl(uint64_t this, void *a2, uint64_t a3, uint64_t (*a4)(void, void), int (*a5)(const void *, const void *))
{
  if ((int)a2 >= 2)
  {
    int v5 = (int)a2;
    uint64_t v6 = this;
    int v7 = 1;
    uint64_t v10 = (int)a3;
    do
    {
      uint64_t v8 = a3;
      float v9 = a4;
      this = a4(v6 + (v7 - 1) * v10, v6 + v7 * (uint64_t)(int)a3);
      if ((int)this > 0) {
        operator new[]();
      }
      ++v7;
      a4 = v9;
      a3 = v8;
    }
    while (v7 < v5);
  }
  return this;
}

void PCArray_base::badIndex(PCArray_base *this)
{
  exceptioint n = (PCException *)__cxa_allocate_exception(0x40uLL);
  PCString::PCString(&v2, "PCArray::operator[]");
  PCException::PCException(exception, &v2);
  *(void *)exceptioint n = &unk_1F10C3A88;
}

void sub_1B76B0A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PCBadIndexException::~PCBadIndexException(PCString *this)
{
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

void PCBadIndexException::className(PCURL *a1@<X8>)
{
}

uint64_t PCBlend::modeMenuString(PCBlend *this)
{
  if (this)
  {
    uint64_t v1 = PCBlend::modeMenuString(BOOL)::pModeMenuCombineString;
    if (!PCBlend::modeMenuString(BOOL)::pModeMenuCombineString) {
      operator new();
    }
  }
  else
  {
    uint64_t v1 = PCBlend::modeMenuString(BOOL)::pModeMenuString;
    if (!PCBlend::modeMenuString(BOOL)::pModeMenuString) {
      operator new();
    }
  }
  return v1;
}

void sub_1B76B0BC0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t PCBlend::lightWrapModeMenuString(PCBlend *this)
{
  if (!PCBlend::lightWrapModeMenuString(void)::pLightWrapModeMenuString) {
    operator new();
  }
  return PCBlend::lightWrapModeMenuString(void)::pLightWrapModeMenuString;
}

void sub_1B76B0C48(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t PCBlend::reflectionModeMenuString(PCBlend *this)
{
  if (!PCBlend::reflectionModeMenuString(void)::pReflectionModeMenuString) {
    operator new();
  }
  return PCBlend::reflectionModeMenuString(void)::pReflectionModeMenuString;
}

void sub_1B76B0CCC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

void *PCBlend::getElementBlendModes(PCBlend *this, unsigned int *a2)
{
  *(_DWORD *)this = 33;
  return &PCBlend::getElementBlendModes(unsigned int &)::elementBlendModes;
}

void *PCBlend::getLayerBlendModes(PCBlend *this, unsigned int *a2)
{
  *(_DWORD *)this = 35;
  return &PCBlend::getLayerBlendModes(unsigned int &)::layerBlendModes;
}

uint64_t PCBlend::isAbelian(unsigned int a1)
{
  return (a1 < 0x18) & (0xC00718u >> a1);
}

uint64_t PCBlend::isAssociative(int a1)
{
  uint64_t result = 1;
  switch(a1)
  {
    case 0:
    case 3:
    case 4:
    case 8:
    case 9:
    case 10:
    case 23:
    case 31:
    case 35:
    case 48:
      return result;
    case 2:
    case 5:
    case 6:
    case 11:
    case 12:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 22:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 32:
    case 34:
      uint64_t result = 0;
      break;
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 49:
    case 50:
    case 51:
      exceptioint n = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString(&v6, "not implemented yet");
      PCString::PCString(&v5, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCBlend.cpp");
      PCException::PCException(exception, &v6, &v5, 496);
      *(void *)exceptioint n = &unk_1F10B1208;
    default:
      unint64_t v4 = (PCIllegalArgumentException *)__cxa_allocate_exception(0x40uLL);
      PCIllegalArgumentException::PCIllegalArgumentException(v4);
  }
  return result;
}

void sub_1B76B0E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

void PCIllegalArgumentException::PCIllegalArgumentException(PCIllegalArgumentException *this)
{
  PCException::PCException(this);
  void *v1 = &unk_1F1199218;
}

uint64_t PCBlend::isNormalOverNothing(unsigned int a1)
{
  if (a1 > 0x33) {
    goto LABEL_9;
  }
  if (((1 << a1) & 0x1000DA0DFDF7DLL) == 0)
  {
    if (((1 << a1) & 0x1E000000) != 0) {
      return 0;
    }
    if (((1 << a1) & 0xEFFC000000000) != 0)
    {
      exceptioint n = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString(&v5, "not implemented yet");
      PCString::PCString(&v4, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCBlend.cpp");
      PCException::PCException(exception, &v5, &v4, 564);
      *(void *)exceptioint n = &unk_1F10B1208;
    }
LABEL_9:
    unint64_t v3 = (PCIllegalArgumentException *)__cxa_allocate_exception(0x40uLL);
    PCIllegalArgumentException::PCIllegalArgumentException(v3);
  }
  return 1;
}

void sub_1B76B10DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

uint64_t PCBlend::isNothingOverNothing(unsigned int a1)
{
  if (a1 > 0x33) {
    goto LABEL_9;
  }
  if (((1 << a1) & 0x1000DA0DFDF7DLL) == 0)
  {
    if (((1 << a1) & 0x1E000000) != 0) {
      return 1;
    }
    if (((1 << a1) & 0xEFFC000000000) != 0)
    {
      exceptioint n = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString(&v5, "not implemented yet");
      PCString::PCString(&v4, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCBlend.cpp");
      PCException::PCException(exception, &v5, &v4, 632);
      *(void *)exceptioint n = &unk_1F10B1208;
    }
LABEL_9:
    unint64_t v3 = (PCIllegalArgumentException *)__cxa_allocate_exception(0x40uLL);
    PCIllegalArgumentException::PCIllegalArgumentException(v3);
  }
  return 0;
}

void sub_1B76B1264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

unint64_t PCBlend::treatsBlackLikeNormal(unsigned int a1)
{
  if (a1 >= 0x34 || ((0xFFFCDBEDFDF7DuLL >> a1) & 1) == 0)
  {
    exceptioint n = (PCIllegalArgumentException *)__cxa_allocate_exception(0x40uLL);
    PCIllegalArgumentException::PCIllegalArgumentException(exception);
  }
  return (0x32412161FFuLL >> a1) & 1;
}

void sub_1B76B1328(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t PCBlend::lrBlendToPCBlend(int a1)
{
  if ((a1 - 1) > 3) {
    return 0;
  }
  else {
    return dword_1B7E7DA70[a1 - 1];
  }
}

void std::vector<PCString>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  PCString v2 = (PCString *)**a1;
  if (v2)
  {
    PCString v4 = (PCString *)v1[1];
    PCString v5 = v2;
    if (v4 != v2)
    {
      do
        PCString::~PCString(v4 - 1);
      while (v4 != v2);
      PCString v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<PCString>::push_back[abi:ne180100](uint64_t *a1, PCString *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v9 = (uint64_t)(v7 - *a1) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v5 - *a1;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v18 = v4;
    if (v12) {
      float v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v4, v12);
    }
    else {
      float v13 = 0;
    }
    __float2 v14 = v13;
    double v15 = (PCString *)&v13[8 * v9];
    double v17 = &v13[8 * v12];
    PCString::PCString(v15, a2);
    double v16 = v15 + 1;
    std::vector<PCString>::__swap_out_circular_buffer(a1, &v14);
    uint64_t v8 = a1[1];
    std::__split_buffer<PCString>::~__split_buffer((uint64_t)&v14);
  }
  else
  {
    PCString::PCString(*(PCString **)(v4 - 8), a2);
    uint64_t v8 = v7 + 8;
    a1[1] = v7 + 8;
  }
  a1[1] = v8;
}

{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  PCString *v15;
  PCString *v16;
  char *v17;
  uint64_t v18;

  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v9 = (uint64_t)(v7 - *a1) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v5 - *a1;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v18 = v4;
    if (v12) {
      float v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v4, v12);
    }
    else {
      float v13 = 0;
    }
    __float2 v14 = v13;
    double v15 = (PCString *)&v13[8 * v9];
    double v17 = &v13[8 * v12];
    PCString::PCString(v15, a2);
    double v16 = v15 + 1;
    std::vector<PCString>::__swap_out_circular_buffer(a1, &v14);
    uint64_t v8 = a1[1];
    std::__split_buffer<PCString>::~__split_buffer((uint64_t)&v14);
  }
  else
  {
    PCString::PCString(*(PCString **)(v4 - 8), a2);
    uint64_t v8 = v7 + 8;
    a1[1] = v7 + 8;
  }
  a1[1] = v8;
}

void sub_1B76B14D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

void sub_1B76B15EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<PCString>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PCString>,std::reverse_iterator<PCString*>,std::reverse_iterator<PCString*>,std::reverse_iterator<PCString*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PCString>,std::reverse_iterator<PCString*>,std::reverse_iterator<PCString*>,std::reverse_iterator<PCString*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0;
  uint64_t v11 = a7 - 8;
  while (a3 + v10 != a5)
  {
    unint64_t v12 = (PCString *)(v11 + v10);
    v10 -= 8;
    PCString::PCString(v12, (const PCString *)(v10 + a3));
  }
  return a6;
}

uint64_t std::__split_buffer<PCString>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    PCString::~PCString((PCString *)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t PCPixelFormat::getGLInternalFormat(unsigned int a1)
{
  if (a1 <= 0x11) {
    unsigned int v1 = a1;
  }
  else {
    unsigned int v1 = 0;
  }
}

uint64_t PCPixelFormat::getGLDataFormat(unsigned int a1)
{
  if (a1 <= 0x11) {
    unsigned int v1 = a1;
  }
  else {
    unsigned int v1 = 0;
  }
}

uint64_t PCPixelFormat::getGLDataType(unsigned int a1)
{
  if (a1 <= 0x11) {
    unsigned int v1 = a1;
  }
  else {
    unsigned int v1 = 0;
  }
}

uint64_t PCPixelFormat::getPixelFormat(PCPixelFormat *this, int a2)
{
  int v2 = (int)this;
  uint64_t result = 0;
  for (uint64_t i = &dword_1B7E7DA88; *(i - 1) != v2 || *i != a2; i += 3)
  {
    if (++result == 18) {
      return 0;
    }
  }
  return result;
}

uint64_t PCPixelFormat::getBitsPerPixel(unsigned int a1)
{
  if (a1 <= 0x11) {
    unsigned int v1 = a1;
  }
  else {
    unsigned int v1 = 0;
  }
}

uint64_t PCPixelFormat::getBitsPerChannel(unsigned int a1)
{
  if (a1 <= 0x11) {
    unsigned int v1 = a1;
  }
  else {
    unsigned int v1 = 0;
  }
}

uint64_t PCPixelFormat::getBytesPerPixel(unsigned int a1)
{
  if (a1 <= 0x11) {
    unsigned int v1 = a1;
  }
  else {
    unsigned int v1 = 0;
  }
}

unint64_t PCPixelFormat::hasRGB(unsigned int a1)
{
  if (a1 <= 0x11) {
    char v1 = a1;
  }
  else {
    char v1 = 0;
  }
  return (0x32678uLL >> v1) & 1;
}

unint64_t PCPixelFormat::hasGray(unsigned int a1)
{
  if (a1 <= 0x11) {
    char v1 = a1;
  }
  else {
    char v1 = 0;
  }
  return (0xD986uLL >> v1) & 1;
}

unint64_t PCPixelFormat::hasAlpha(unsigned int a1)
{
  if (a1 <= 0x11) {
    char v1 = a1;
  }
  else {
    char v1 = 0;
  }
  return (0x3B57CuLL >> v1) & 1;
}

BOOL PCPixelFormat::isFloat(unsigned int a1)
{
  if (a1 <= 0x11) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = 0;
  }
  return (unint64_t)(v1 - 11) < 7;
}

uint64_t PCPixelFormat::getNumChannels(unsigned int a1)
{
  if (a1 <= 0x11) {
    unsigned int v1 = a1;
  }
  else {
    unsigned int v1 = 0;
  }
}

BOOL PCPixelFormat::is8Bit(unsigned int a1)
{
  if (a1 <= 0x11) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = 0;
  }
  return (unint64_t)(v1 - 1) < 6;
}

BOOL PCPixelFormat::is16Bit(unsigned int a1)
{
  if (a1 <= 0x11) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = 0;
  }
  return (unint64_t)(v1 - 7) < 7;
}

BOOL PCPixelFormat::is32Bit(unsigned int a1)
{
  if (a1 <= 0x11) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = 0;
  }
  return (unint64_t)(v1 - 14) < 4;
}

uint64_t PCPixelFormat::setGray(uint64_t result)
{
  int v1 = result - 3;
  if (result - 3) <= 0xE && ((0x64CFu >> v1)) {
    return dword_1B7E7DD08[v1];
  }
  return result;
}

uint64_t PCPixelFormat::removeAlpha(uint64_t result)
{
  switch((int)result)
  {
    case 8:
      uint64_t result = 7;
      break;
    case 9:
    case 11:
    case 13:
    case 14:
      return result;
    case 10:
      uint64_t result = 9;
      break;
    case 12:
      uint64_t result = 11;
      break;
    case 15:
      uint64_t result = 14;
      break;
    default:
      if (result == 2) {
        uint64_t result = 1;
      }
      break;
  }
  return result;
}

uint64_t PCPixelFormat::setDepth(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2 == 32)
    {
      int v3 = result - 1;
      if ((result - 1) >= 0xD) {
        return result;
      }
      uint64_t v4 = (unsigned int *)&unk_1B7E7DD88;
      return v4[v3];
    }
    if (a2 == 16)
    {
      int v3 = result - 1;
      if (result - 1) < 0x11 && ((0x1E3FFu >> v3))
      {
        uint64_t v4 = (unsigned int *)&unk_1B7E7DD44;
        return v4[v3];
      }
    }
  }
  else if (a2 == 16)
  {
    int v3 = result - 1;
    if (result - 1) < 0x11 && ((0x1FC3Fu >> v3))
    {
      uint64_t v4 = (unsigned int *)&unk_1B7E7DDE8;
      return v4[v3];
    }
  }
  else if (a2 == 8)
  {
    int v3 = result - 7;
    if ((result - 7) < 0xB)
    {
      uint64_t v4 = (unsigned int *)&unk_1B7E7DDBC;
      return v4[v3];
    }
  }
  return result;
}

uint64_t makeCGFormat@<X0>(CGColorSpace *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t result = CGColorSpaceGetModel(a1);
  if (result > 7) {
    int v7 = 3;
  }
  else {
    int v7 = dword_1B7E7E000[(int)result];
  }
  if (a2 == 1) {
    int v8 = 8452;
  }
  else {
    int v8 = 8448;
  }
  if (a2 == 2) {
    int v8 = 8451;
  }
  if ((a2 - 1) < 2) {
    ++v7;
  }
  *(_DWORD *)a3 = 32;
  *(_DWORD *)(a3 + 4) = 32 * v7;
  *(void *)(a3 + 8) = a1;
  *(_DWORD *)(a3 + 16) = v8;
  *(void *)(a3 + 28) = 0;
  *(void *)(a3 + 20) = 0;
  return result;
}

vImageConverter *createConverter@<X0>(CGColorSpace **a1@<X0>, int a2@<W1>, CGColorSpace **a3@<X2>, int a4@<W3>, vImageConverterRef *a5@<X8>)
{
  memset(&srcFormat, 0, sizeof(srcFormat));
  makeCGFormat(*a1, a2, (uint64_t)&srcFormat);
  memset(&destFormat, 0, sizeof(destFormat));
  makeCGFormat(*a3, a4, (uint64_t)&destFormat);
  vImage_Error error = 0;
  uint64_t result = vImageConverter_CreateWithCGImageFormat(&srcFormat, &destFormat, 0, 0x400u, &error);
  *a5 = result;
  if (!result)
  {
    unint64_t v12 = CGColorConversionInfoCreate(*a1, *a3);
    *a5 = vImageConverter_CreateWithCGColorConversionInfo(v12, &srcFormat, &destFormat, 0, 0x400u, &error);
    uint64_t v11 = 0;
    PCCFRef<vImageConverter *>::~PCCFRef(&v11);
    uint64_t result = (vImageConverter *)PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v12);
  }
  if (error)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error in vImageConverter_CreateWithCGImageFormat: ", 50);
    uint64_t v10 = (void *)std::ostream::operator<<();
    return (vImageConverter *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"\n", 1);
  }
  return result;
}

void sub_1B76B1E30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  PCCFRef<vImageConverter *>::~PCCFRef((const void **)va);
  PCCFRef<vImageConverter *>::~PCCFRef(v3);
  _Unwind_Resume(a1);
}

vImagePixelCount PCColorUtil::transformColor(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2 >= *(void *)a1) {
    vImagePixelCount result = *(void *)a1;
  }
  else {
    vImagePixelCount result = *(void *)a2;
  }
  if (result)
  {
    long long v4 = *(_OWORD *)(a1 + 8);
    uint64_t v5 = *(void *)(a1 + 24);
    unsigned int v6 = *(_DWORD *)(a1 + 32);
    long long v11 = v4;
    uint64_t v12 = v5;
    uint64_t v13 = v6;
    uint64_t v7 = *(void *)(a2 + 24);
    LODWORD(v5) = *(_DWORD *)(a2 + 32);
    long long v8 = *(_OWORD *)(a2 + 8);
    uint64_t v9 = v7;
    uint64_t v10 = v5;
    return doSimpleTransform(result, (uint64_t)&v11, (uint64_t)&v8);
  }
  return result;
}

uint64_t doSimpleTransform(vImagePixelCount a1, uint64_t a2, uint64_t a3)
{
  if (CFEqual(*(CFTypeRef *)(a2 + 16), *(CFTypeRef *)(a3 + 16)))
  {
    uint64_t result = CGColorSpaceUsesExtendedRange(*(CGColorSpaceRef *)(a2 + 16));
    int v7 = *(_DWORD *)(a2 + 24);
    int v8 = *(_DWORD *)(a3 + 24);
    uint64_t v39 = a1;
    if (v7 == v8)
    {
      char v9 = result;
      vImagePixelCount v10 = *(void *)(a2 + 8) * a1;
      if (!v10) {
        goto LABEL_55;
      }
      long long v11 = *(float **)a2;
      size_t v12 = 4 * v10;
      uint64_t v13 = *(float **)a3;
      goto LABEL_5;
    }
    double v16 = *(float **)a3;
    double v17 = (char *)(*(void *)a3 + 4 * (v8 == 1));
    long long v11 = *(float **)a2;
    uint64_t v18 = *(void *)(a2 + 8);
    unsigned int v19 = v7 - 1;
    unint64_t v20 = (char *)(*(void *)a2 + 4 * (v7 == 1));
    if (v7 == 1)
    {
      unint64_t v21 = *(float **)a2;
    }
    else if (v7 == 2)
    {
      unint64_t v21 = &v11[v18 - 1];
    }
    else
    {
      unint64_t v21 = 0;
    }
    if (v8 == 1)
    {
      uint64_t v31 = v18 - (v19 < 2);
      if (v16)
      {
LABEL_29:
        char v9 = result;
        if (v21)
        {
          for (; a1; --a1)
          {
            if (v31)
            {
              uint64_t result = (uint64_t)memmove(v17, v20, 4 * v31);
              uint64_t v18 = *(void *)(a2 + 8);
            }
            float *v16 = *v21;
            v20 += 4 * v18;
            uint64_t v32 = *(void *)(a3 + 8);
            v17 += 4 * v32;
            v21 += v18;
            v16 += v32;
          }
        }
        else if (a1)
        {
          vImagePixelCount v33 = a1;
          do
          {
            if (v31)
            {
              uint64_t result = (uint64_t)memmove(v17, v20, 4 * v31);
              uint64_t v18 = *(void *)(a2 + 8);
            }
            float *v16 = 1.0;
            v20 += 4 * v18;
            uint64_t v34 = *(void *)(a3 + 8);
            v17 += 4 * v34;
            v16 += v34;
            --v33;
          }
          while (v33);
        }
        goto LABEL_55;
      }
    }
    else
    {
      if (v8 == 2)
      {
        double v16 = &v16[*(void *)(a3 + 8) - 1];
        uint64_t v31 = v18 - (v19 < 2);
        goto LABEL_29;
      }
      uint64_t v31 = v18 - (v19 < 2);
    }
    char v9 = result;
    if (v21)
    {
      for (; a1; --a1)
      {
        if (v31)
        {
          uint64_t result = (uint64_t)memmove(v17, v20, 4 * v31);
          uint64_t v18 = *(void *)(a2 + 8);
        }
        v20 += 4 * v18;
        v17 += 4 * *(void *)(a3 + 8);
      }
      goto LABEL_55;
    }
    vImagePixelCount v35 = v18 * a1;
    if (!v35)
    {
LABEL_55:
      if ((v9 & 1) == 0)
      {
        double v36 = *(float **)a3;
        uint64_t v37 = *(void *)(a3 + 8);
        unsigned int v38 = *(_DWORD *)(a3 + 24);
        return clampComponents(v39, v36, v37, v38);
      }
      return result;
    }
    size_t v12 = 4 * v35;
    uint64_t v13 = *(float **)a3;
LABEL_5:
    uint64_t result = (uint64_t)memmove(v13, v11, v12);
    goto LABEL_55;
  }
  getCachedColorConverter(*(CGColorSpaceRef *)(a2 + 16), *(CGColorSpaceRef *)(a3 + 16), *(_DWORD *)(a2 + 24), *(_DWORD *)(a3 + 24), (const void **)&v48);
  if (v48)
  {
    __float2 v14 = *(CGColorSpace **)(a2 + 16);
    int v15 = !CGColorSpaceUsesExtendedRange(v14) && CGColorSpaceGetModel(v14) != kCGColorSpaceModelLab;
    double v22 = *(CGColorSpace **)(a3 + 16);
    BOOL v23 = !CGColorSpaceUsesExtendedRange(v22) && CGColorSpaceGetModel(v22) != kCGColorSpaceModelLab;
    double v24 = *(_DWORD **)a2;
    if (v44)
    {
      uint64_t v25 = v41;
      uint64_t v26 = v42;
      if (v42 * v41)
      {
        memmove(__dst, v24, 4 * v42 * v41);
        uint64_t v25 = v41;
        uint64_t v26 = v42;
      }
      clampComponents(v25, (float *)__dst, v26, v43);
      double v24 = __dst;
    }
    uint64_t v27 = *(void *)(a2 + 8);
    uint64_t v28 = *(void *)(a2 + 16);
    unsigned int v29 = *(_DWORD *)(a2 + 24);
    v40[0] = v24;
    v40[1] = v27;
    v40[2] = v28;
    _OWORD v40[3] = v29;
    if (dovImageTransform(a1, v48, (uint64_t)v40, a3))
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; vImageConvert_AnyToAny failed, error code is ",
        52);
      double v30 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)"\n", 1);
      writeOpaqueBlack(a1, a3);
    }
    else if (v23)
    {
      clampComponents(a1, *(float **)a3, *(void *)(a3 + 8), *(_DWORD *)(a3 + 24));
    }
    if (__p)
    {
      float64x2_t v46 = __p;
      operator delete(__p);
    }
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
      62);
    writeOpaqueBlack(a1, a3);
  }
  return (uint64_t)PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v48);
}

void sub_1B76B22A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  PCCFRef<vImageConverter *>::~PCCFRef((const void **)(v21 - 88));
  _Unwind_Resume(a1);
}

void PCColorUtil::transformColorWithDynamicRange(uint64_t a1, uint64_t a2, PCToneMapMethod *this)
{
  if (*(void *)a2 >= *(void *)a1) {
    vImagePixelCount v3 = *(void *)a1;
  }
  else {
    vImagePixelCount v3 = *(void *)a2;
  }
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 24);
    long long v16 = *(_OWORD *)(a1 + 8);
    uint64_t v17 = v4;
    uint64_t v18 = 0;
    int v5 = *(_DWORD *)(a1 + 36);
    LODWORD(v18) = *(_DWORD *)(a1 + 32);
    uint64_t v6 = *(void *)(a2 + 24);
    long long v13 = *(_OWORD *)(a2 + 8);
    uint64_t v14 = v6;
    uint64_t v15 = 0;
    int v7 = *(_DWORD *)(a2 + 36);
    LODWORD(v15) = *(_DWORD *)(a2 + 32);
    if (v5 == v7 || !PVPerfStats::FrameStats::GetSize((PVPerfStats::FrameStats *)this))
    {
      doSimpleTransform(v3, (uint64_t)&v16, (uint64_t)&v13);
    }
    else if (v5 || v7 != 1)
    {
      if (v5 != 1 || v7)
      {
        writeOpaqueBlack(v3, (uint64_t)&v13);
      }
      else
      {
        long long v11 = PCGetNCLCColorSpace((unsigned int *)&kPCNCLC_Rec2020Linear, 1);
        size_t v12 = PCGetNCLCColorSpace((unsigned int *)&kPCNCLC_Rec2020, 1);
        switch(PVPerfStats::FrameStats::GetSize((PVPerfStats::FrameStats *)this))
        {
          case 2u:
            doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_6>(v11, v12, v3, (char **)&v16, (uint64_t)&v13);
            break;
          case 3u:
            doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_7>(v11, v12, v3, (char **)&v16, (uint64_t)&v13);
            break;
          case 4u:
            doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_8>(v11, v12, v3, (char **)&v16, (uint64_t)&v13);
            break;
          case 5u:
            doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_9>(this, v11, v12, v3, (char **)&v16, (uint64_t)&v13);
            break;
          case 6u:
            doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_10>(v11, v12, v3, (char **)&v16, (uint64_t)&v13);
            break;
          default:
            return;
        }
      }
    }
    else
    {
      char v9 = PCGetNCLCColorSpace((unsigned int *)&kPCNCLC_Rec2020, 1);
      vImagePixelCount v10 = PCGetNCLCColorSpace((unsigned int *)&kPCNCLC_Rec2020Linear, 1);
      switch(PVPerfStats::FrameStats::GetSize((PVPerfStats::FrameStats *)this))
      {
        case 1u:
          doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_0>(v9, v10, v3, (char **)&v16, (uint64_t)&v13);
          break;
        case 2u:
          doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_1>(v9, v10, v3, (char **)&v16, (uint64_t)&v13);
          break;
        case 3u:
          doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_2>(v9, v10, v3, (char **)&v16, (uint64_t)&v13);
          break;
        case 4u:
          doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_3>(v9, v10, v3, (char **)&v16, (uint64_t)&v13);
          break;
        case 5u:
          doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_4>(this, v9, v10, v3, (char **)&v16, (uint64_t)&v13);
          break;
        case 6u:
          doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_5>(v9, v10, v3, (char **)&v16, (uint64_t)&v13);
          break;
        default:
          return;
      }
    }
  }
}

const void **doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_0>(CGColorSpaceRef a1, CGColorSpace *a2, uint64_t a3, char **a4, uint64_t a5)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  getCachedColorConverter((CGColorSpaceRef)a4[2], a1, *((_DWORD *)a4 + 6), 2, (const void **)&converter);
  if (converter)
  {
    getCachedColorConverter(a2, *(CGColorSpaceRef *)(a5 + 16), 2, *(_DWORD *)(a5 + 24), (const void **)&v33);
    if (v33)
    {
      int v8 = (CGColorSpace *)a4[2];
      int v9 = !CGColorSpaceUsesExtendedRange(v8) && CGColorSpaceGetModel(v8) != kCGColorSpaceModelLab;
      vImagePixelCount v10 = *(CGColorSpace **)(a5 + 16);
      BOOL v11 = !CGColorSpaceUsesExtendedRange(v10) && CGColorSpaceGetModel(v10) != kCGColorSpaceModelLab;
      if (a3)
      {
        unsigned int v23 = *(_DWORD *)(a5 + 24);
        size_t v12 = *(char **)a5;
        long long v13 = *a4;
        size_t v14 = 4 * (void)a4[1];
        uint64_t v22 = *(void *)(a5 + 8);
        int64x2_t v24 = vdupq_n_s64(1uLL);
        do
        {
          uint64_t v15 = v13;
          if (v29)
          {
            uint64_t v16 = v26;
            uint64_t v17 = v27;
            if (v27 * v26)
            {
              memmove(__dst, v13, 4 * v27 * v26);
              uint64_t v16 = v26;
              uint64_t v17 = v27;
            }
            clampComponents(v16, (float *)__dst, v17, v28);
            uint64_t v15 = __dst;
          }
          *(int64x2_t *)&srcs.height = v24;
          srcs.data = v15;
          srcs.rowBytes = v14;
          dests.data = &v37;
          *(int64x2_t *)&dests.height = v24;
          dests.rowBytes = 16;
          vImage_Error v18 = vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0);
          v19.n128_f64[0] = PCColorUtil::applyInverseToneMap_BT2390(v18, v37);
          unsigned __int32 v20 = v37.n128_u32[3];
          __n128 v37 = v19;
          v37.n128_u32[3] = v20;
          *(int64x2_t *)&srcs.height = vdupq_n_s64(1uLL);
          srcs.data = &v37;
          srcs.rowBytes = 16;
          dests.data = v12;
          *(_OWORD *)&dests.height = *(_OWORD *)&srcs.height;
          dests.rowBytes = 4 * v22;
          vImageConvert_AnyToAny(v33, &srcs, &dests, 0, 0);
          if (v11) {
            clampComponents(1, (float *)v12, v22, v23);
          }
          v13 += 4 * (void)a4[1];
          v12 += 4 * *(void *)(a5 + 8);
          --a3;
        }
        while (a3);
      }
      if (__p)
      {
        uint64_t v31 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
        62);
      writeOpaqueBlack(a3, a5);
    }
    PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v33);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
      62);
    writeOpaqueBlack(a3, a5);
  }
  return PCCFRef<vImageConverter *>::~PCCFRef((const void **)&converter);
}

void sub_1B76B288C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26)
{
}

const void **doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_1>(CGColorSpaceRef a1, CGColorSpace *a2, uint64_t a3, char **a4, uint64_t a5)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  getCachedColorConverter((CGColorSpaceRef)a4[2], a1, *((_DWORD *)a4 + 6), 2, (const void **)&converter);
  if (converter)
  {
    getCachedColorConverter(a2, *(CGColorSpaceRef *)(a5 + 16), 2, *(_DWORD *)(a5 + 24), (const void **)&v33);
    if (v33)
    {
      int v8 = (CGColorSpace *)a4[2];
      int v9 = !CGColorSpaceUsesExtendedRange(v8) && CGColorSpaceGetModel(v8) != kCGColorSpaceModelLab;
      vImagePixelCount v10 = *(CGColorSpace **)(a5 + 16);
      BOOL v11 = !CGColorSpaceUsesExtendedRange(v10) && CGColorSpaceGetModel(v10) != kCGColorSpaceModelLab;
      if (a3)
      {
        unsigned int v23 = *(_DWORD *)(a5 + 24);
        size_t v12 = *(char **)a5;
        long long v13 = *a4;
        size_t v14 = 4 * (void)a4[1];
        uint64_t v22 = *(void *)(a5 + 8);
        int64x2_t v24 = vdupq_n_s64(1uLL);
        do
        {
          uint64_t v15 = v13;
          if (v29)
          {
            uint64_t v16 = v26;
            uint64_t v17 = v27;
            if (v27 * v26)
            {
              memmove(__dst, v13, 4 * v27 * v26);
              uint64_t v16 = v26;
              uint64_t v17 = v27;
            }
            clampComponents(v16, (float *)__dst, v17, v28);
            uint64_t v15 = __dst;
          }
          *(int64x2_t *)&srcs.height = v24;
          srcs.data = v15;
          srcs.rowBytes = v14;
          dests.data = &v37;
          *(int64x2_t *)&dests.height = v24;
          dests.rowBytes = 16;
          vImage_Error v18 = vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0);
          v19.n128_f64[0] = PCColorUtil::applyInverseToneMap_BT2446_A(v18, v37);
          unsigned __int32 v20 = v37.n128_u32[3];
          __n128 v37 = v19;
          v37.n128_u32[3] = v20;
          *(int64x2_t *)&srcs.height = vdupq_n_s64(1uLL);
          srcs.data = &v37;
          srcs.rowBytes = 16;
          dests.data = v12;
          *(_OWORD *)&dests.height = *(_OWORD *)&srcs.height;
          dests.rowBytes = 4 * v22;
          vImageConvert_AnyToAny(v33, &srcs, &dests, 0, 0);
          if (v11) {
            clampComponents(1, (float *)v12, v22, v23);
          }
          v13 += 4 * (void)a4[1];
          v12 += 4 * *(void *)(a5 + 8);
          --a3;
        }
        while (a3);
      }
      if (__p)
      {
        uint64_t v31 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
        62);
      writeOpaqueBlack(a3, a5);
    }
    PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v33);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
      62);
    writeOpaqueBlack(a3, a5);
  }
  return PCCFRef<vImageConverter *>::~PCCFRef((const void **)&converter);
}

void sub_1B76B2BB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26)
{
}

const void **doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_2>(CGColorSpaceRef a1, CGColorSpace *a2, uint64_t a3, char **a4, uint64_t a5)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  getCachedColorConverter((CGColorSpaceRef)a4[2], a1, *((_DWORD *)a4 + 6), 2, (const void **)&converter);
  if (converter)
  {
    getCachedColorConverter(a2, *(CGColorSpaceRef *)(a5 + 16), 2, *(_DWORD *)(a5 + 24), (const void **)&v33);
    if (v33)
    {
      int v8 = (CGColorSpace *)a4[2];
      int v9 = !CGColorSpaceUsesExtendedRange(v8) && CGColorSpaceGetModel(v8) != kCGColorSpaceModelLab;
      vImagePixelCount v10 = *(CGColorSpace **)(a5 + 16);
      BOOL v11 = !CGColorSpaceUsesExtendedRange(v10) && CGColorSpaceGetModel(v10) != kCGColorSpaceModelLab;
      if (a3)
      {
        unsigned int v23 = *(_DWORD *)(a5 + 24);
        size_t v12 = *(char **)a5;
        long long v13 = *a4;
        size_t v14 = 4 * (void)a4[1];
        uint64_t v22 = *(void *)(a5 + 8);
        int64x2_t v24 = vdupq_n_s64(1uLL);
        do
        {
          uint64_t v15 = v13;
          if (v29)
          {
            uint64_t v16 = v26;
            uint64_t v17 = v27;
            if (v27 * v26)
            {
              memmove(__dst, v13, 4 * v27 * v26);
              uint64_t v16 = v26;
              uint64_t v17 = v27;
            }
            clampComponents(v16, (float *)__dst, v17, v28);
            uint64_t v15 = __dst;
          }
          *(int64x2_t *)&srcs.height = v24;
          srcs.data = v15;
          srcs.rowBytes = v14;
          dests.data = &v37;
          *(int64x2_t *)&dests.height = v24;
          dests.rowBytes = 16;
          vImage_Error v18 = vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0);
          v19.n128_f64[0] = PCColorUtil::applyInverseToneMap_OS(v18, v37);
          unsigned __int32 v20 = v37.n128_u32[3];
          __n128 v37 = v19;
          v37.n128_u32[3] = v20;
          *(int64x2_t *)&srcs.height = vdupq_n_s64(1uLL);
          srcs.data = &v37;
          srcs.rowBytes = 16;
          dests.data = v12;
          *(_OWORD *)&dests.height = *(_OWORD *)&srcs.height;
          dests.rowBytes = 4 * v22;
          vImageConvert_AnyToAny(v33, &srcs, &dests, 0, 0);
          if (v11) {
            clampComponents(1, (float *)v12, v22, v23);
          }
          v13 += 4 * (void)a4[1];
          v12 += 4 * *(void *)(a5 + 8);
          --a3;
        }
        while (a3);
      }
      if (__p)
      {
        uint64_t v31 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
        62);
      writeOpaqueBlack(a3, a5);
    }
    PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v33);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
      62);
    writeOpaqueBlack(a3, a5);
  }
  return PCCFRef<vImageConverter *>::~PCCFRef((const void **)&converter);
}

void sub_1B76B2EDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26)
{
}

const void **doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_3>(CGColorSpaceRef a1, CGColorSpace *a2, uint64_t a3, char **a4, uint64_t a5)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  getCachedColorConverter((CGColorSpaceRef)a4[2], a1, *((_DWORD *)a4 + 6), 2, (const void **)&converter);
  if (converter)
  {
    getCachedColorConverter(a2, *(CGColorSpaceRef *)(a5 + 16), 2, *(_DWORD *)(a5 + 24), (const void **)&v32);
    if (v32)
    {
      int v8 = (CGColorSpace *)a4[2];
      int v9 = !CGColorSpaceUsesExtendedRange(v8) && CGColorSpaceGetModel(v8) != kCGColorSpaceModelLab;
      vImagePixelCount v10 = *(CGColorSpace **)(a5 + 16);
      BOOL v11 = !CGColorSpaceUsesExtendedRange(v10) && CGColorSpaceGetModel(v10) != kCGColorSpaceModelLab;
      if (a3)
      {
        unsigned int v22 = *(_DWORD *)(a5 + 24);
        size_t v12 = *(char **)a5;
        long long v13 = *a4;
        size_t v14 = 4 * (void)a4[1];
        uint64_t v21 = *(void *)(a5 + 8);
        int64x2_t v23 = vdupq_n_s64(1uLL);
        do
        {
          uint64_t v15 = v13;
          if (v28)
          {
            uint64_t v16 = v25;
            uint64_t v17 = v26;
            if (v26 * v25)
            {
              memmove(__dst, v13, 4 * v26 * v25);
              uint64_t v16 = v25;
              uint64_t v17 = v26;
            }
            clampComponents(v16, (float *)__dst, v17, v27);
            uint64_t v15 = __dst;
          }
          *(int64x2_t *)&srcs.height = v23;
          srcs.data = v15;
          srcs.rowBytes = v14;
          dests.data = &v36;
          *(int64x2_t *)&dests.height = v23;
          dests.rowBytes = 16;
          vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0);
          *(double *)v18.i64 = PCColorUtil::applyInverseToneMap_HLGDiffuseWhite(v36);
          __int32 v19 = v36.i32[3];
          float32x4_t v36 = v18;
          v36.i32[3] = v19;
          *(int64x2_t *)&srcs.height = vdupq_n_s64(1uLL);
          srcs.data = &v36;
          srcs.rowBytes = 16;
          dests.data = v12;
          *(_OWORD *)&dests.height = *(_OWORD *)&srcs.height;
          dests.rowBytes = 4 * v21;
          vImageConvert_AnyToAny(v32, &srcs, &dests, 0, 0);
          if (v11) {
            clampComponents(1, (float *)v12, v21, v22);
          }
          v13 += 4 * (void)a4[1];
          v12 += 4 * *(void *)(a5 + 8);
          --a3;
        }
        while (a3);
      }
      if (__p)
      {
        double v30 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
        62);
      writeOpaqueBlack(a3, a5);
    }
    PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v32);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
      62);
    writeOpaqueBlack(a3, a5);
  }
  return PCCFRef<vImageConverter *>::~PCCFRef((const void **)&converter);
}

void sub_1B76B3204(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26)
{
}

const void **doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_4>(PCToneMapMethod *a1, CGColorSpaceRef a2, CGColorSpace *a3, uint64_t a4, char **a5, uint64_t a6)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  getCachedColorConverter((CGColorSpaceRef)a5[2], a2, *((_DWORD *)a5 + 6), 2, (const void **)&converter);
  if (converter)
  {
    getCachedColorConverter(a3, *(CGColorSpaceRef *)(a6 + 16), 2, *(_DWORD *)(a6 + 24), (const void **)&v36);
    if (v36)
    {
      int v9 = (CGColorSpace *)a5[2];
      int v10 = !CGColorSpaceUsesExtendedRange(v9) && CGColorSpaceGetModel(v9) != kCGColorSpaceModelLab;
      BOOL v11 = *(CGColorSpace **)(a6 + 16);
      BOOL v12 = !CGColorSpaceUsesExtendedRange(v11) && CGColorSpaceGetModel(v11) != kCGColorSpaceModelLab;
      if (a4)
      {
        unsigned int v24 = *(_DWORD *)(a6 + 24);
        long long v13 = *(char **)a6;
        size_t v14 = *a5;
        size_t v15 = 4 * (void)a5[1];
        uint64_t v23 = *(void *)(a6 + 8);
        int64x2_t v25 = vdupq_n_s64(1uLL);
        do
        {
          uint64_t v16 = v14;
          if (v32)
          {
            uint64_t v17 = v29;
            uint64_t v18 = v30;
            if (v30 * v29)
            {
              memmove(__dst, v14, 4 * v30 * v29);
              uint64_t v17 = v29;
              uint64_t v18 = v30;
            }
            clampComponents(v17, (float *)__dst, v18, v31);
            uint64_t v16 = __dst;
          }
          *(int64x2_t *)&srcs.height = v25;
          srcs.data = v16;
          srcs.rowBytes = v15;
          dests.data = &v40;
          *(int64x2_t *)&dests.height = v25;
          dests.rowBytes = 16;
          vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0);
          float32x4_t v28 = v40;
          Gaiint n = PCToneMapMethod::getGain(a1);
          *(double *)v20.i64 = PCColorUtil::applyInverseToneMap_LinearGain(v28, Gain);
          __int32 v21 = v40.i32[3];
          float32x4_t v40 = v20;
          v40.i32[3] = v21;
          *(int64x2_t *)&srcs.height = vdupq_n_s64(1uLL);
          srcs.data = &v40;
          srcs.rowBytes = 16;
          dests.data = v13;
          *(_OWORD *)&dests.height = *(_OWORD *)&srcs.height;
          dests.rowBytes = 4 * v23;
          vImageConvert_AnyToAny(v36, &srcs, &dests, 0, 0);
          if (v12) {
            clampComponents(1, (float *)v13, v23, v24);
          }
          v14 += 4 * (void)a5[1];
          v13 += 4 * *(void *)(a6 + 8);
          --a4;
        }
        while (a4);
      }
      if (__p)
      {
        uint64_t v34 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
        62);
      writeOpaqueBlack(a4, a6);
    }
    PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v36);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
      62);
    writeOpaqueBlack(a4, a6);
  }
  return PCCFRef<vImageConverter *>::~PCCFRef((const void **)&converter);
}

void sub_1B76B3540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,uint64_t a25,uint64_t a26,const void *a27,const void *a28)
{
}

const void **doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_5>(CGColorSpaceRef a1, CGColorSpace *a2, uint64_t a3, char **a4, uint64_t a5)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  getCachedColorConverter((CGColorSpaceRef)a4[2], a1, *((_DWORD *)a4 + 6), 2, (const void **)&converter);
  if (converter)
  {
    getCachedColorConverter(a2, *(CGColorSpaceRef *)(a5 + 16), 2, *(_DWORD *)(a5 + 24), (const void **)&v33);
    if (v33)
    {
      int v8 = (CGColorSpace *)a4[2];
      int v9 = !CGColorSpaceUsesExtendedRange(v8) && CGColorSpaceGetModel(v8) != kCGColorSpaceModelLab;
      int v10 = *(CGColorSpace **)(a5 + 16);
      BOOL v11 = !CGColorSpaceUsesExtendedRange(v10) && CGColorSpaceGetModel(v10) != kCGColorSpaceModelLab;
      if (a3)
      {
        unsigned int v23 = *(_DWORD *)(a5 + 24);
        BOOL v12 = *(char **)a5;
        long long v13 = *a4;
        size_t v14 = 4 * (void)a4[1];
        uint64_t v22 = *(void *)(a5 + 8);
        int64x2_t v24 = vdupq_n_s64(1uLL);
        do
        {
          size_t v15 = v13;
          if (v29)
          {
            uint64_t v16 = v26;
            uint64_t v17 = v27;
            if (v27 * v26)
            {
              memmove(__dst, v13, 4 * v27 * v26);
              uint64_t v16 = v26;
              uint64_t v17 = v27;
            }
            clampComponents(v16, (float *)__dst, v17, v28);
            size_t v15 = __dst;
          }
          *(int64x2_t *)&srcs.height = v24;
          srcs.data = v15;
          srcs.rowBytes = v14;
          dests.data = &v37;
          *(int64x2_t *)&dests.height = v24;
          dests.rowBytes = 16;
          vImage_Error v18 = vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0);
          v19.n128_f64[0] = PCColorUtil::applyInverseToneMap_OSFA(v18, v37);
          unsigned __int32 v20 = v37.n128_u32[3];
          __n128 v37 = v19;
          v37.n128_u32[3] = v20;
          *(int64x2_t *)&srcs.height = vdupq_n_s64(1uLL);
          srcs.data = &v37;
          srcs.rowBytes = 16;
          dests.data = v12;
          *(_OWORD *)&dests.height = *(_OWORD *)&srcs.height;
          dests.rowBytes = 4 * v22;
          vImageConvert_AnyToAny(v33, &srcs, &dests, 0, 0);
          if (v11) {
            clampComponents(1, (float *)v12, v22, v23);
          }
          v13 += 4 * (void)a4[1];
          v12 += 4 * *(void *)(a5 + 8);
          --a3;
        }
        while (a3);
      }
      if (__p)
      {
        unsigned int v31 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
        62);
      writeOpaqueBlack(a3, a5);
    }
    PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v33);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
      62);
    writeOpaqueBlack(a3, a5);
  }
  return PCCFRef<vImageConverter *>::~PCCFRef((const void **)&converter);
}

void sub_1B76B3868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26)
{
}

const void **doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_6>(CGColorSpaceRef a1, CGColorSpace *a2, uint64_t a3, char **a4, uint64_t a5)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  getCachedColorConverter((CGColorSpaceRef)a4[2], a1, *((_DWORD *)a4 + 6), 2, (const void **)&converter);
  if (converter)
  {
    getCachedColorConverter(a2, *(CGColorSpaceRef *)(a5 + 16), 2, *(_DWORD *)(a5 + 24), (const void **)&v32);
    if (v32)
    {
      int v8 = (CGColorSpace *)a4[2];
      int v9 = !CGColorSpaceUsesExtendedRange(v8) && CGColorSpaceGetModel(v8) != kCGColorSpaceModelLab;
      int v10 = *(CGColorSpace **)(a5 + 16);
      BOOL v11 = !CGColorSpaceUsesExtendedRange(v10) && CGColorSpaceGetModel(v10) != kCGColorSpaceModelLab;
      if (a3)
      {
        unsigned int v22 = *(_DWORD *)(a5 + 24);
        BOOL v12 = *(char **)a5;
        long long v13 = *a4;
        size_t v14 = 4 * (void)a4[1];
        uint64_t v21 = *(void *)(a5 + 8);
        int64x2_t v23 = vdupq_n_s64(1uLL);
        do
        {
          size_t v15 = v13;
          if (v28)
          {
            uint64_t v16 = v25;
            uint64_t v17 = v26;
            if (v26 * v25)
            {
              memmove(__dst, v13, 4 * v26 * v25);
              uint64_t v16 = v25;
              uint64_t v17 = v26;
            }
            clampComponents(v16, (float *)__dst, v17, v27);
            size_t v15 = __dst;
          }
          *(int64x2_t *)&srcs.height = v23;
          srcs.data = v15;
          srcs.rowBytes = v14;
          dests.data = &v36;
          *(int64x2_t *)&dests.height = v23;
          dests.rowBytes = 16;
          vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0);
          *(double *)v18.i64 = PCColorUtil::applyToneMap_BT2446_A(v36);
          __int32 v19 = v36.i32[3];
          float32x4_t v36 = v18;
          v36.i32[3] = v19;
          *(int64x2_t *)&srcs.height = vdupq_n_s64(1uLL);
          srcs.data = &v36;
          srcs.rowBytes = 16;
          dests.data = v12;
          *(_OWORD *)&dests.height = *(_OWORD *)&srcs.height;
          dests.rowBytes = 4 * v21;
          vImageConvert_AnyToAny(v32, &srcs, &dests, 0, 0);
          if (v11) {
            clampComponents(1, (float *)v12, v21, v22);
          }
          v13 += 4 * (void)a4[1];
          v12 += 4 * *(void *)(a5 + 8);
          --a3;
        }
        while (a3);
      }
      if (__p)
      {
        uint64_t v30 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
        62);
      writeOpaqueBlack(a3, a5);
    }
    PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v32);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
      62);
    writeOpaqueBlack(a3, a5);
  }
  return PCCFRef<vImageConverter *>::~PCCFRef((const void **)&converter);
}

void sub_1B76B3B90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26)
{
}

const void **doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_7>(CGColorSpaceRef a1, CGColorSpace *a2, uint64_t a3, char **a4, uint64_t a5)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  getCachedColorConverter((CGColorSpaceRef)a4[2], a1, *((_DWORD *)a4 + 6), 2, (const void **)&converter);
  if (converter)
  {
    getCachedColorConverter(a2, *(CGColorSpaceRef *)(a5 + 16), 2, *(_DWORD *)(a5 + 24), (const void **)&v33);
    if (v33)
    {
      int v8 = (CGColorSpace *)a4[2];
      int v9 = !CGColorSpaceUsesExtendedRange(v8) && CGColorSpaceGetModel(v8) != kCGColorSpaceModelLab;
      int v10 = *(CGColorSpace **)(a5 + 16);
      BOOL v11 = !CGColorSpaceUsesExtendedRange(v10) && CGColorSpaceGetModel(v10) != kCGColorSpaceModelLab;
      if (a3)
      {
        unsigned int v23 = *(_DWORD *)(a5 + 24);
        BOOL v12 = *(char **)a5;
        long long v13 = *a4;
        size_t v14 = 4 * (void)a4[1];
        uint64_t v22 = *(void *)(a5 + 8);
        int64x2_t v24 = vdupq_n_s64(1uLL);
        do
        {
          size_t v15 = v13;
          if (v29)
          {
            uint64_t v16 = v26;
            uint64_t v17 = v27;
            if (v27 * v26)
            {
              memmove(__dst, v13, 4 * v27 * v26);
              uint64_t v16 = v26;
              uint64_t v17 = v27;
            }
            clampComponents(v16, (float *)__dst, v17, v28);
            size_t v15 = __dst;
          }
          *(int64x2_t *)&srcs.height = v24;
          srcs.data = v15;
          srcs.rowBytes = v14;
          dests.data = &v37;
          *(int64x2_t *)&dests.height = v24;
          dests.rowBytes = 16;
          vImage_Error v18 = vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0);
          v19.n128_f64[0] = PCColorUtil::applyToneMap_OS(v18, v37);
          unsigned __int32 v20 = v37.n128_u32[3];
          __n128 v37 = v19;
          v37.n128_u32[3] = v20;
          *(int64x2_t *)&srcs.height = vdupq_n_s64(1uLL);
          srcs.data = &v37;
          srcs.rowBytes = 16;
          dests.data = v12;
          *(_OWORD *)&dests.height = *(_OWORD *)&srcs.height;
          dests.rowBytes = 4 * v22;
          vImageConvert_AnyToAny(v33, &srcs, &dests, 0, 0);
          if (v11) {
            clampComponents(1, (float *)v12, v22, v23);
          }
          v13 += 4 * (void)a4[1];
          v12 += 4 * *(void *)(a5 + 8);
          --a3;
        }
        while (a3);
      }
      if (__p)
      {
        unsigned int v31 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
        62);
      writeOpaqueBlack(a3, a5);
    }
    PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v33);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
      62);
    writeOpaqueBlack(a3, a5);
  }
  return PCCFRef<vImageConverter *>::~PCCFRef((const void **)&converter);
}

void sub_1B76B3EB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26)
{
}

const void **doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_8>(CGColorSpaceRef a1, CGColorSpace *a2, uint64_t a3, char **a4, uint64_t a5)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  getCachedColorConverter((CGColorSpaceRef)a4[2], a1, *((_DWORD *)a4 + 6), 2, (const void **)&converter);
  if (converter)
  {
    getCachedColorConverter(a2, *(CGColorSpaceRef *)(a5 + 16), 2, *(_DWORD *)(a5 + 24), (const void **)&v32);
    if (v32)
    {
      int v8 = (CGColorSpace *)a4[2];
      int v9 = !CGColorSpaceUsesExtendedRange(v8) && CGColorSpaceGetModel(v8) != kCGColorSpaceModelLab;
      int v10 = *(CGColorSpace **)(a5 + 16);
      BOOL v11 = !CGColorSpaceUsesExtendedRange(v10) && CGColorSpaceGetModel(v10) != kCGColorSpaceModelLab;
      if (a3)
      {
        unsigned int v22 = *(_DWORD *)(a5 + 24);
        BOOL v12 = *(char **)a5;
        long long v13 = *a4;
        size_t v14 = 4 * (void)a4[1];
        uint64_t v21 = *(void *)(a5 + 8);
        int64x2_t v23 = vdupq_n_s64(1uLL);
        do
        {
          size_t v15 = v13;
          if (v28)
          {
            uint64_t v16 = v25;
            uint64_t v17 = v26;
            if (v26 * v25)
            {
              memmove(__dst, v13, 4 * v26 * v25);
              uint64_t v16 = v25;
              uint64_t v17 = v26;
            }
            clampComponents(v16, (float *)__dst, v17, v27);
            size_t v15 = __dst;
          }
          *(int64x2_t *)&srcs.height = v23;
          srcs.data = v15;
          srcs.rowBytes = v14;
          dests.data = &v36;
          *(int64x2_t *)&dests.height = v23;
          dests.rowBytes = 16;
          vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0);
          *(double *)v18.i64 = PCColorUtil::applyToneMap_HLGDiffuseWhite(v36);
          __int32 v19 = v36.i32[3];
          float32x4_t v36 = v18;
          v36.i32[3] = v19;
          *(int64x2_t *)&srcs.height = vdupq_n_s64(1uLL);
          srcs.data = &v36;
          srcs.rowBytes = 16;
          dests.data = v12;
          *(_OWORD *)&dests.height = *(_OWORD *)&srcs.height;
          dests.rowBytes = 4 * v21;
          vImageConvert_AnyToAny(v32, &srcs, &dests, 0, 0);
          if (v11) {
            clampComponents(1, (float *)v12, v21, v22);
          }
          v13 += 4 * (void)a4[1];
          v12 += 4 * *(void *)(a5 + 8);
          --a3;
        }
        while (a3);
      }
      if (__p)
      {
        uint64_t v30 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
        62);
      writeOpaqueBlack(a3, a5);
    }
    PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v32);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
      62);
    writeOpaqueBlack(a3, a5);
  }
  return PCCFRef<vImageConverter *>::~PCCFRef((const void **)&converter);
}

void sub_1B76B41E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26)
{
}

const void **doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_9>(PCToneMapMethod *a1, CGColorSpaceRef a2, CGColorSpace *a3, uint64_t a4, char **a5, uint64_t a6)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  getCachedColorConverter((CGColorSpaceRef)a5[2], a2, *((_DWORD *)a5 + 6), 2, (const void **)&converter);
  if (converter)
  {
    getCachedColorConverter(a3, *(CGColorSpaceRef *)(a6 + 16), 2, *(_DWORD *)(a6 + 24), (const void **)&v36);
    if (v36)
    {
      int v9 = (CGColorSpace *)a5[2];
      int v10 = !CGColorSpaceUsesExtendedRange(v9) && CGColorSpaceGetModel(v9) != kCGColorSpaceModelLab;
      BOOL v11 = *(CGColorSpace **)(a6 + 16);
      BOOL v12 = !CGColorSpaceUsesExtendedRange(v11) && CGColorSpaceGetModel(v11) != kCGColorSpaceModelLab;
      if (a4)
      {
        unsigned int v24 = *(_DWORD *)(a6 + 24);
        long long v13 = *(char **)a6;
        size_t v14 = *a5;
        size_t v15 = 4 * (void)a5[1];
        uint64_t v23 = *(void *)(a6 + 8);
        int64x2_t v25 = vdupq_n_s64(1uLL);
        do
        {
          uint64_t v16 = v14;
          if (v32)
          {
            uint64_t v17 = v29;
            uint64_t v18 = v30;
            if (v30 * v29)
            {
              memmove(__dst, v14, 4 * v30 * v29);
              uint64_t v17 = v29;
              uint64_t v18 = v30;
            }
            clampComponents(v17, (float *)__dst, v18, v31);
            uint64_t v16 = __dst;
          }
          *(int64x2_t *)&srcs.height = v25;
          srcs.data = v16;
          srcs.rowBytes = v15;
          dests.data = &v40;
          *(int64x2_t *)&dests.height = v25;
          dests.rowBytes = 16;
          vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0);
          float32x4_t v28 = v40;
          Gaiint n = PCToneMapMethod::getGain(a1);
          *(double *)v20.i64 = PCColorUtil::applyToneMap_LinearGain(v28, Gain);
          __int32 v21 = v40.i32[3];
          float32x4_t v40 = v20;
          v40.i32[3] = v21;
          *(int64x2_t *)&srcs.height = vdupq_n_s64(1uLL);
          srcs.data = &v40;
          srcs.rowBytes = 16;
          dests.data = v13;
          *(_OWORD *)&dests.height = *(_OWORD *)&srcs.height;
          dests.rowBytes = 4 * v23;
          vImageConvert_AnyToAny(v36, &srcs, &dests, 0, 0);
          if (v12) {
            clampComponents(1, (float *)v13, v23, v24);
          }
          v14 += 4 * (void)a5[1];
          v13 += 4 * *(void *)(a6 + 8);
          --a4;
        }
        while (a4);
      }
      if (__p)
      {
        uint64_t v34 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
        62);
      writeOpaqueBlack(a4, a6);
    }
    PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v36);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
      62);
    writeOpaqueBlack(a4, a6);
  }
  return PCCFRef<vImageConverter *>::~PCCFRef((const void **)&converter);
}

void sub_1B76B451C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,uint64_t a25,uint64_t a26,const void *a27,const void *a28)
{
}

const void **doDynamicRangeTransform<PCColorUtil::transformColorWithDynamicRange(PCColorUtil::Buffer const&,PCColorUtil::Buffer&,PCToneMapMethod const&)::$_10>(CGColorSpaceRef a1, CGColorSpace *a2, uint64_t a3, char **a4, uint64_t a5)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  getCachedColorConverter((CGColorSpaceRef)a4[2], a1, *((_DWORD *)a4 + 6), 2, (const void **)&converter);
  if (converter)
  {
    getCachedColorConverter(a2, *(CGColorSpaceRef *)(a5 + 16), 2, *(_DWORD *)(a5 + 24), (const void **)&v33);
    if (v33)
    {
      int v8 = (CGColorSpace *)a4[2];
      int v9 = !CGColorSpaceUsesExtendedRange(v8) && CGColorSpaceGetModel(v8) != kCGColorSpaceModelLab;
      int v10 = *(CGColorSpace **)(a5 + 16);
      BOOL v11 = !CGColorSpaceUsesExtendedRange(v10) && CGColorSpaceGetModel(v10) != kCGColorSpaceModelLab;
      if (a3)
      {
        unsigned int v23 = *(_DWORD *)(a5 + 24);
        BOOL v12 = *(char **)a5;
        long long v13 = *a4;
        size_t v14 = 4 * (void)a4[1];
        uint64_t v22 = *(void *)(a5 + 8);
        int64x2_t v24 = vdupq_n_s64(1uLL);
        do
        {
          size_t v15 = v13;
          if (v29)
          {
            uint64_t v16 = v26;
            uint64_t v17 = v27;
            if (v27 * v26)
            {
              memmove(__dst, v13, 4 * v27 * v26);
              uint64_t v16 = v26;
              uint64_t v17 = v27;
            }
            clampComponents(v16, (float *)__dst, v17, v28);
            size_t v15 = __dst;
          }
          *(int64x2_t *)&srcs.height = v24;
          srcs.data = v15;
          srcs.rowBytes = v14;
          dests.data = &v37;
          *(int64x2_t *)&dests.height = v24;
          dests.rowBytes = 16;
          vImage_Error v18 = vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0);
          v19.n128_f64[0] = PCColorUtil::applyToneMap_OSFA(v18, v37);
          unsigned __int32 v20 = v37.n128_u32[3];
          __n128 v37 = v19;
          v37.n128_u32[3] = v20;
          *(int64x2_t *)&srcs.height = vdupq_n_s64(1uLL);
          srcs.data = &v37;
          srcs.rowBytes = 16;
          dests.data = v12;
          *(_OWORD *)&dests.height = *(_OWORD *)&srcs.height;
          dests.rowBytes = 4 * v22;
          vImageConvert_AnyToAny(v33, &srcs, &dests, 0, 0);
          if (v11) {
            clampComponents(1, (float *)v12, v22, v23);
          }
          v13 += 4 * (void)a4[1];
          v12 += 4 * *(void *)(a5 + 8);
          --a3;
        }
        while (a3);
      }
      if (__p)
      {
        unsigned int v31 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
        62);
      writeOpaqueBlack(a3, a5);
    }
    PCCFRef<vImageConverter *>::~PCCFRef((const void **)&v33);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"error; unable to create a converter; no conversion is applied\n",
      62);
    writeOpaqueBlack(a3, a5);
  }
  return PCCFRef<vImageConverter *>::~PCCFRef((const void **)&converter);
}

void sub_1B76B4844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26)
{
}

void writeOpaqueBlack(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  int v3 = *(_DWORD *)(a2 + 24);
  uint64_t v5 = *(void *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v6 = *(void *)a2 + 4 * (v3 == 1);
  if (v3 == 1)
  {
    if (v5)
    {
LABEL_5:
      if (a1)
      {
        uint64_t v7 = 0;
        uint64_t v8 = 4 * v4;
        uint64_t v9 = 4 * v4 - 4;
        size_t v10 = 4 * (((unint64_t)v9 >> 2) - (4 * v4 != 4)) + 4;
        do
        {
          if (v9 >= 1) {
            bzero((void *)(v6 + v7), v10);
          }
          *(_DWORD *)(v5 + v7) = 1065353216;
          v7 += v8;
          --v2;
        }
        while (v2);
      }
      return;
    }
  }
  else if (v3 == 2)
  {
    uint64_t v5 = v5 + 4 * v4 - 4;
    goto LABEL_5;
  }
  uint64_t v11 = v4 * a1;
  if (v11 >= 1)
  {
    bzero((void *)(v5 + 4 * (v3 == 1)), 4 * (v11 - ((v11 & 0x3FFFFFFFFFFFFFFFLL) != 0)) + 4);
  }
}

float PCColorUtil::transform@<S0>(PCToneMapMethod *this@<X5>, uint64_t *a2@<X0>, uint64_t a3@<X1>, int a4@<W2>, uint64_t a5@<X3>, int a6@<W4>, uint64_t a7@<X8>)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = *a2;
  int v18 = *((_DWORD *)a2 + 2);
  int v19 = 1065353216;
  v12[0] = 1;
  v12[1] = &v17;
  _OWORD v12[2] = 4;
  void v12[3] = a3;
  int v13 = 2;
  int v14 = a4;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  v9[0] = 1;
  v9[1] = &v15;
  v9[2] = 4;
  double v9[3] = a5;
  int v10 = 2;
  int v11 = a6;
  PCColorUtil::transformColorWithDynamicRange((uint64_t)v12, (uint64_t)v9, this);
  float result = *(float *)&v16;
  *(void *)a7 = v15;
  *(float *)(a7 + 8) = result;
  return result;
}

CGColorSpace **getCachedColorConverter@<X0>(CGColorSpaceRef space@<X0>, CGColorSpaceRef a2@<X2>, int a3@<W1>, int a4@<W3>, const void **a5@<X8>)
{
  {
    operator new();
  }
  uint64_t v10 = getConverterCache(void)::cache;
  if (space) {
    PCCFRefTraits<CGColorSpace *>::retain(space);
  }
  uint64_t v15 = space;
  if (a2)
  {
    PCCFRefTraits<CGColorSpace *>::retain(a2);
    CGColorSpaceRef space = v15;
  }
  int v13 = space;
  int v14 = a2;
  if (space)
  {
    PCCFRefTraits<CGColorSpace *>::retain(space);
    a2 = v14;
  }
  BOOL v12 = a2;
  if (a2) {
    PCCFRefTraits<CGColorSpace *>::retain(a2);
  }
  PCCachedFunctionImpl<PCCFRef<vImageConverter *>,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>::operator()(v10, &v13, a3, &v12, a4, a5);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v12);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v13);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v14);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v15);
}

void sub_1B76B4BA0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1020C404DE315E0);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::ClampBuffer::ClampBuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 16) = a4;
  *(unsigned char *)(a1 + 20) = a5;
  *(_OWORD *)(a1 + 48) = 0u;
  uint64_t v6 = (uint64_t *)(a1 + 48);
  *(_OWORD *)(a1 + 64) = 0u;
  if (a5)
  {
    unint64_t v7 = a3 * a2;
    if (v7 < 6)
    {
      uint64_t v8 = a1 + 24;
    }
    else
    {
      std::vector<float>::resize(a1 + 48, v7);
      uint64_t v8 = *v6;
    }
    *(void *)(a1 + 7PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v8;
  }
  return a1;
}

void sub_1B76B4C88(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 56) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

vImage_Error dovImageTransform(vImagePixelCount a1, vImageConverterRef converter, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a3 + 8);
  srcs.data = *(void **)a3;
  srcs.height = 1;
  srcs.width = a1;
  srcs.rowBytes = v4 * 4 * a1;
  uint64_t v5 = *(void *)(a4 + 8);
  v7.data = *(void **)a4;
  v7.height = 1;
  v7.width = a1;
  v7.rowBytes = v5 * 4 * a1;
  return vImageConvert_AnyToAny(converter, &srcs, &v7, 0, 0);
}

uint64_t clampComponents(uint64_t result, float *a2, uint64_t a3, unsigned int a4)
{
  if (a4)
  {
    if (result)
    {
      uint64_t v4 = 0;
      uint64_t v5 = a3 - (a4 < 3);
      uint64_t v6 = &a2[a4 == 1];
      do
      {
        if (v5)
        {
          for (uint64_t i = 0; i != v5; ++i)
          {
            float v8 = v6[i];
            if (v8 <= 1.0) {
              float v9 = v6[i];
            }
            else {
              float v9 = 1.0;
            }
            if (v8 >= 0.0) {
              float v10 = v9;
            }
            else {
              float v10 = 0.0;
            }
            v6[i] = v10;
          }
        }
        ++v4;
        v6 += a3;
      }
      while (v4 != result);
    }
  }
  else
  {
    for (uint64_t j = a3 * result; j; --j)
    {
      if (*a2 <= 1.0) {
        float v12 = *a2;
      }
      else {
        float v12 = 1.0;
      }
      if (*a2 >= 0.0) {
        float v13 = v12;
      }
      else {
        float v13 = 0.0;
      }
      *a2++ = v13;
    }
  }
  return result;
}

void PCCachedFunctionImpl<PCCFRef<vImageConverter *>,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>::operator()(uint64_t a1@<X0>, CGColorSpace **a2@<X1>, int a3@<W2>, CGColorSpace **a4@<X3>, int a5@<W4>, const void **a6@<X8>)
{
  int v22 = a5;
  int v23 = a3;
  float v10 = (os_unfair_lock_s *)(a1 + 32);
  v21[2] = (CGColorSpace *)(a1 + 32);
  PCSpinLock::lock((os_unfair_lock_t)(a1 + 32));
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3EEEEJ7PCCFRefIP12CGColorSpaceEN11PCColorUtil11AlphaFormatES6_S8_EEC2B8ne180100IJLm0ELm1ELm2ELm3EEJS6_S8_S6_S8_EJEJEJKS6_KS8_SB_SC_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSE_IJDpT2_EEEDpOT3_((uint64_t)v20, a2, &v23, a4, &v22);
  char v19 = 0;
  PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::findValue(*(void **)(a1 + 40), (uint64_t)v20, &v19, a6);
  if (!v19)
  {
    int v11 = *a2;
    uint64_t v17 = v11;
    if (v11) {
      PCCFRefTraits<CGColorSpace *>::retain(v11);
    }
    int v12 = v23;
    float v13 = *a4;
    uint64_t v16 = v13;
    if (v13) {
      PCCFRefTraits<CGColorSpace *>::retain(v13);
    }
    std::function<PCCFRef<vImageConverter *> ()(PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat)>::operator()(a1, (uint64_t)&v17, v12, (uint64_t)&v16, v22);
    int v14 = *a6;
    uint64_t v15 = v18;
    if (*a6 && v14 != v18)
    {
      PCCFRefTraits<vImageConverter *>::release(v14);
      uint64_t v15 = v18;
    }
    *a6 = v15;
    int v18 = 0;
    PCCFRef<vImageConverter *>::~PCCFRef(&v18);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v16);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v17);
    PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::addValue(*(uint64_t **)(a1 + 40), (uint64_t)v20, a6, 0);
  }
  PCCFRef<CGColorSpace *>::~PCCFRef(v21);
  PCCFRef<CGColorSpace *>::~PCCFRef(v20);
  PCSpinLock::unlock(v10);
}

void sub_1B76B4EE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGColorSpace *a9, CGColorSpace *a10, const void *a11, uint64_t a12, CGColorSpace *a13, uint64_t a14, CGColorSpace *a15, uint64_t a16, os_unfair_lock_s *a17)
{
  PCCFRef<vImageConverter *>::~PCCFRef(&a11);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a9);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a10);
  PCCFRef<vImageConverter *>::~PCCFRef(v17);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a15);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a13);
  PCLockSentry<PCSpinLock>::~PCLockSentry(&a17);
  _Unwind_Resume(a1);
}

void PCCachedFunctionImpl<PCCFRef<vImageConverter *>,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>::PCCachedFunctionImpl<PCCFRef<vImageConverter *> (*)(PCCFRef<CGColorSpace *> const&,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *> const&,PCColorUtil::AlphaFormat)>(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0;
  if (a2)
  {
    *(void *)a1 = &unk_1F10C3AC8;
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 24) = a1;
  }
  *(_DWORD *)(a1 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  operator new();
}

void sub_1B76B5004(_Unwind_Exception *a1)
{
  PCSpinLock::~PCSpinLock(v2);
  std::__function::__value_func<PCCFRef<vImageConverter *> ()(PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat)>::~__value_func[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<PCCFRef<vImageConverter *> (*)(PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat),std::allocator<PCCFRef<vImageConverter *> (*)(PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat)>,PCCFRef<vImageConverter *> ()(CGColorSpace,PCColorUtil::AlphaFormat,CGColorSpace,PCColorUtil::AlphaFormat)>::~__func()
{
}

void *std::__function::__func<PCCFRef<vImageConverter *> (*)(PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat),std::allocator<PCCFRef<vImageConverter *> (*)(PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat)>,PCCFRef<vImageConverter *> ()(CGColorSpace,PCColorUtil::AlphaFormat,CGColorSpace,PCColorUtil::AlphaFormat)>::__clone(uint64_t a1)
{
  float result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *float result = &unk_1F10C3AC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<PCCFRef<vImageConverter *> (*)(PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat),std::allocator<PCCFRef<vImageConverter *> (*)(PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat)>,PCCFRef<vImageConverter *> ()(CGColorSpace,PCColorUtil::AlphaFormat,CGColorSpace,PCColorUtil::AlphaFormat)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F10C3AC8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<PCCFRef<vImageConverter *> (*)(PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat),std::allocator<PCCFRef<vImageConverter *> (*)(PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat)>,PCCFRef<vImageConverter *> ()(CGColorSpace,PCColorUtil::AlphaFormat,CGColorSpace,PCColorUtil::AlphaFormat)>::operator()(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, unsigned int *a5)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, void))(a1 + 8))(a2, *a3, a4, *a5);
}

uint64_t std::__function::__func<PCCFRef<vImageConverter *> (*)(PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat),std::allocator<PCCFRef<vImageConverter *> (*)(PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat)>,PCCFRef<vImageConverter *> ()(CGColorSpace,PCColorUtil::AlphaFormat,CGColorSpace,PCColorUtil::AlphaFormat)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<PCCFRef<vImageConverter *> (*)(PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat),std::allocator<PCCFRef<vImageConverter *> (*)(PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef const&<CGColorSpace *>,PCColorUtil::AlphaFormat)>,PCCFRef<vImageConverter *> ()(CGColorSpace,PCColorUtil::AlphaFormat,CGColorSpace,PCColorUtil::AlphaFormat)>::target_type()
{
}

void *std::__function::__value_func<PCCFRef<vImageConverter *> ()(PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::function<PCCFRef<vImageConverter *> ()(PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat)>::operator()(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  int v8 = a3;
  int v7 = a5;
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v5) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, int *, uint64_t, int *))(*(void *)v5 + 48))(v5, a2, &v8, a4, &v7);
}

uint64_t _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3EEEEJ7PCCFRefIP12CGColorSpaceEN11PCColorUtil11AlphaFormatES6_S8_EEC2B8ne180100IJLm0ELm1ELm2ELm3EEJS6_S8_S6_S8_EJEJEJKS6_KS8_SB_SC_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSE_IJDpT2_EEEDpOT3_(uint64_t a1, CGColorSpace **a2, _DWORD *a3, CGColorSpace **a4, _DWORD *a5)
{
  float v9 = *a2;
  *(void *)a1 = *a2;
  if (v9) {
    PCCFRefTraits<CGColorSpace *>::retain(v9);
  }
  *(_DWORD *)(a1 + 8) = *a3;
  float v10 = *a4;
  *(void *)(a1 + 16) = *a4;
  if (v10) {
    PCCFRefTraits<CGColorSpace *>::retain(v10);
  }
  *(_DWORD *)(a1 + 24) = *a5;
  return a1;
}

void sub_1B76B5260(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

void *PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::findValue@<X0>(void *a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X2>, void *a4@<X8>)
{
  float result = std::__tree<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__map_value_compare<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>,true>,std::allocator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>>::find<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>((uint64_t)(a1 + 3), a2);
  int v11 = result;
  if (a1 + 4 == result)
  {
    *a3 = 0;
    *a4 = 0;
  }
  else
  {
    int v8 = result;
    float v9 = (const void *)result[8];
    *a4 = v9;
    if (v9) {
      PCCFRefTraits<vImageConverter *>::retain(v9);
    }
    uint64_t v10 = a1[9] + 1;
    a1[9] = v10;
    v8[10] = v10;
    float result = PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::bubble(a1 + 6, (uint64_t)&v11);
    *a3 = 1;
  }
  return result;
}

void sub_1B76B5308(_Unwind_Exception *a1)
{
  PCCFRef<vImageConverter *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

void *std::__tree<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__map_value_compare<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>,true>,std::allocator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>>::find<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = (void *)(a1 + 8);
  do
  {
    BOOL v6 = std::__tuple_less<4ul>::operator()[abi:ne180100]<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>((uint64_t)&v9, (uint64_t)(v3 + 4), a2);
    int v7 = v3 + 1;
    if (!v6)
    {
      int v7 = v3;
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2
    || std::__tuple_less<4ul>::operator()[abi:ne180100]<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>((uint64_t)&v10, a2, (uint64_t)(v5 + 4)))
  {
    return v2;
  }
  return v5;
}

BOOL std::__tuple_less<4ul>::operator()[abi:ne180100]<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a2 < *(void *)a3) {
    return 1;
  }
  if (*(void *)a3 < *(void *)a2) {
    return 0;
  }
  int v3 = *(_DWORD *)(a2 + 8);
  int v4 = *(_DWORD *)(a3 + 8);
  if (v3 < v4) {
    return 1;
  }
  if (v4 < v3) {
    return 0;
  }
  unint64_t v5 = *(void *)(a2 + 16);
  unint64_t v6 = *(void *)(a3 + 16);
  if (v5 < v6) {
    return 1;
  }
  return v6 >= v5 && *(_DWORD *)(a2 + 24) < *(_DWORD *)(a3 + 24);
}

uint64_t *PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::bubble(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1] - *result;
  unint64_t v4 = *(void *)(*(void *)a2 + 88);
  unint64_t v5 = (2 * v4) | 1;
  if (v5 >= v3 >> 3)
  {
LABEL_24:
    if (v4)
    {
      uint64_t v17 = *(void *)(v2 + 8 * v4);
      do
      {
        unint64_t v18 = v4 - 1;
        unint64_t v19 = (v4 - 1) >> 1;
        uint64_t v20 = *(void *)(v2 + 8 * v19);
        if (*(void *)(v20 + 80) <= *(void *)(v17 + 80)) {
          break;
        }
        *(void *)(v2 + 8 * v4) = v20;
        *(void *)(v2 + 8 * v19) = v17;
        uint64_t v2 = *result;
        *(void *)(*(void *)(*result + 8 * v4) + 88) = v4;
        uint64_t v17 = *(void *)(v2 + 8 * v19);
        *(void *)(v17 + 88) = v19;
        unint64_t v4 = (v4 - 1) >> 1;
      }
      while (v18 > 1);
    }
    return result;
  }
  char v6 = 0;
  unint64_t v7 = v3 >> 3;
  uint64_t v8 = 2 * v4;
  uint64_t v9 = *(void *)(v2 + 8 * v4);
  while (1)
  {
    unint64_t v10 = v8 + 2;
    unint64_t v11 = *(void *)(v9 + 80);
    BOOL v12 = v10 < v7 && v11 > *(void *)(*(void *)(v2 + 8 * v10) + 80);
    unint64_t v13 = *(void *)(*(void *)(v2 + 8 * v5) + 80);
    if (v11 <= v13 && !v12) {
      break;
    }
    BOOL v15 = v11 > v13 && v12;
    if (v12) {
      unint64_t v16 = v10;
    }
    else {
      unint64_t v16 = v5;
    }
    if (v15)
    {
      if (v13 <= *(void *)(*(void *)(v2 + 8 * v10) + 80)) {
        unint64_t v16 = v5;
      }
      else {
        unint64_t v16 = v10;
      }
    }
    *(void *)(v2 + 8 * v4) = *(void *)(v2 + 8 * v16);
    *(void *)(v2 + 8 * v16) = v9;
    uint64_t v2 = *result;
    *(void *)(*(void *)(*result + 8 * v4) + 88) = v4;
    uint64_t v9 = *(void *)(v2 + 8 * v16);
    *(void *)(v9 + 88) = v16;
    uint64_t v8 = 2 * v16;
    char v6 = 1;
    unint64_t v5 = (2 * v16) | 1;
    unint64_t v4 = v16;
    if (v5 >= v7) {
      return result;
    }
  }
  if ((v6 & 1) == 0)
  {
    unint64_t v4 = *(void *)(*(void *)a2 + 88);
    goto LABEL_24;
  }
  return result;
}

uint64_t *PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::addValue(uint64_t *result, uint64_t a2, const void **a3, unint64_t a4)
{
  unint64_t v7 = result;
  if (result[11] >= a4 || result[13])
  {
    uint64_t v8 = (const void **)std::__tree<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__map_value_compare<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>,true>,std::allocator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>>::find<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>((uint64_t)(result + 3), a2);
    uint64_t v26 = v8;
    if (v7 + 4 == (uint64_t *)v8)
    {
      unint64_t v16 = (const void *)(v7[9] + 1);
      v7[9] = (uint64_t)v16;
      uint64_t v17 = *a3;
      v25[0] = v17;
      if (v17) {
        PCCFRefTraits<vImageConverter *>::retain(v17);
      }
      v25[1] = (const void *)a4;
      v25[2] = v16;
      v25[3] = 0;
      std::pair<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat> const,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>::pair[abi:ne180100]<true,0>((uint64_t)v21, a2, (uint64_t)v25);
      v24[0] = (uint64_t)std::__tree<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__map_value_compare<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>,true>,std::allocator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>>::__emplace_unique_key_args<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::pair<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat> const,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>((uint64_t **)v7 + 3, (uint64_t)v21, (uint64_t)v21);
      v24[1] = v18;
      PCCFRef<vImageConverter *>::~PCCFRef(&v23);
      PCCFRef<CGColorSpace *>::~PCCFRef(&v22);
      PCCFRef<CGColorSpace *>::~PCCFRef(v21);
      PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::add((void **)v7 + 6, v24);
      v7[10] += a4;
      if (!v7[13])
      {
        while (v7[10] > (unint64_t)v7[11] || v7[5] > (unint64_t)v7[12])
        {
          uint64_t v20 = (CGColorSpace **)v7[6];
          if (v20 == (CGColorSpace **)v7[7]) {
            break;
          }
          v21[0] = *v20;
          PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::remove(v7 + 6, (uint64_t)v21);
          unint64_t v19 = v21[0];
          v7[10] -= *((void *)v21[0] + 9);
          std::__tree<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__map_value_compare<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>,true>,std::allocator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>>::erase((uint64_t **)v7 + 3, (uint64_t)v19);
        }
      }
      return (uint64_t *)PCCFRef<vImageConverter *>::~PCCFRef(v25);
    }
    else
    {
      uint64_t v9 = v8;
      PCCFRef<vImageConverter *>::operator=(v8 + 8, a3);
      uint64_t v10 = v7[9] + 1;
      v7[9] = v10;
      v9[10] = (const void *)v10;
      float result = PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::bubble(v7 + 6, (uint64_t)&v26);
      unint64_t v11 = v26;
      BOOL v12 = (char *)(a4 - (void)v26[9]);
      if (v12)
      {
        unint64_t v13 = &v12[v7[10]];
        v7[10] = (uint64_t)v13;
        v11[9] = (const void *)a4;
        if (!v7[13])
        {
          while ((unint64_t)v13 > v7[11] || v7[5] > (unint64_t)v7[12])
          {
            BOOL v15 = (CGColorSpace **)v7[6];
            if (v15 == (CGColorSpace **)v7[7]) {
              break;
            }
            v21[0] = *v15;
            PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::remove(v7 + 6, (uint64_t)v21);
            int v14 = v21[0];
            v7[10] -= *((void *)v21[0] + 9);
            float result = std::__tree<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__map_value_compare<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>,true>,std::allocator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>>::erase((uint64_t **)v7 + 3, (uint64_t)v14);
            unint64_t v13 = (char *)v7[10];
          }
        }
      }
    }
  }
  return result;
}

void sub_1B76B5768(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  PCCFRef<vImageConverter *>::~PCCFRef((const void **)va);
  _Unwind_Resume(a1);
}

CGColorSpace **std::pair<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat> const,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>::~pair(uint64_t a1)
{
  PCCFRef<vImageConverter *>::~PCCFRef((const void **)(a1 + 32));
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(a1 + 16));

  return PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)a1);
}

void PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::add(void **a1, uint64_t *a2)
{
  unint64_t v4 = (char *)*a1;
  unint64_t v5 = a1[1];
  uint64_t v6 = ((char *)v5 - (unsigned char *)*a1) >> 3;
  uint64_t v7 = *a2;
  *(void *)(*a2 + 88) = v6;
  unint64_t v10 = (unint64_t)a1[2];
  uint64_t v8 = (uint64_t)(a1 + 2);
  unint64_t v9 = v10;
  if ((unint64_t)v5 >= v10)
  {
    if ((unint64_t)(v6 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v9 - (void)v4;
    uint64_t v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v6 + 1)) {
      uint64_t v13 = v6 + 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14)
    {
      BOOL v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8, v14);
      uint64_t v7 = *a2;
    }
    else
    {
      BOOL v15 = 0;
    }
    unint64_t v16 = &v15[8 * v6];
    uint64_t v17 = &v15[8 * v14];
    *(void *)unint64_t v16 = v7;
    unint64_t v11 = v16 + 8;
    unint64_t v19 = (char *)*a1;
    unsigned __int8 v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v16 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      unsigned __int8 v18 = (char *)*a1;
    }
    *a1 = v16;
    a1[1] = v11;
    a1[2] = v17;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *unint64_t v5 = v7;
    unint64_t v11 = v5 + 1;
  }
  a1[1] = v11;
  unint64_t v21 = *(void *)(*a2 + 88);
  if (v21)
  {
    int v22 = (char *)*a1;
    uint64_t v23 = *((void *)*a1 + v21);
    do
    {
      unint64_t v24 = v21 - 1;
      unint64_t v25 = (v21 - 1) >> 1;
      uint64_t v26 = *(void *)&v22[8 * v25];
      if (*(void *)(v26 + 80) <= *(void *)(v23 + 80)) {
        break;
      }
      *(void *)&v22[8 * v21] = v26;
      *(void *)&v22[8 * v25] = v23;
      int v22 = (char *)*a1;
      *(void *)(*((void *)*a1 + v21) + 88) = v21;
      uint64_t v23 = *(void *)&v22[8 * v25];
      *(void *)(v23 + 88) = v25;
      unint64_t v21 = (v21 - 1) >> 1;
    }
    while (v24 > 1);
  }
}

const void **PCCFRef<vImageConverter *>::operator=(const void **a1, const void **a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = *a2;
  if (v3 != *a2)
  {
    if (v3)
    {
      PCCFRefTraits<vImageConverter *>::release(v3);
      unint64_t v4 = *a2;
    }
    *a1 = v4;
    if (*a2) {
      PCCFRefTraits<vImageConverter *>::retain(v4);
    }
  }
  return a1;
}

uint64_t *std::__tree<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__map_value_compare<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>,true>,std::allocator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>>::__emplace_unique_key_args<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::pair<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat> const,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (uint64_t **)std::__tree<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__map_value_compare<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>,true>,std::allocator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>>::__find_equal<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>((uint64_t)a1, &v8, a2);
  float result = *v5;
  if (!*v5)
  {
    std::__tree<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__map_value_compare<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>,true>,std::allocator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>>::__construct_node<std::pair<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat> const,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>((uint64_t)a1, a3, (uint64_t)&v7);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

void *std::__tree<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__map_value_compare<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>,true>,std::allocator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>>::__find_equal<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t v5 = (void *)(a1 + 8);
  unint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = v4;
        uint64_t v8 = (uint64_t)(v4 + 4);
        if (!std::__tuple_less<4ul>::operator()[abi:ne180100]<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>((uint64_t)&v10, a3, (uint64_t)(v4 + 4)))break; {
        unint64_t v4 = (void *)*v7;
        }
        unint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!std::__tuple_less<4ul>::operator()[abi:ne180100]<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>((uint64_t)&v11, v8, a3))break; {
      unint64_t v5 = v7 + 1;
      }
      unint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t std::__tree<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__map_value_compare<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>,true>,std::allocator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>>::__construct_node<std::pair<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat> const,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x60uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = std::pair<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat> const,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>::pair[abi:ne180100]((uint64_t)v6 + 32, a2);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1B76B5AF4(_Unwind_Exception *a1)
{
  void *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat> const,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>::pair[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul,3ul>,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>::__tuple_impl(a1, a2);
  unint64_t v4 = *(const void **)(a2 + 32);
  *(void *)(a1 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v4;
  if (v4) {
    PCCFRefTraits<vImageConverter *>::retain(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  return a1;
}

void sub_1B76B5B5C(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1 + 2);
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul,3ul>,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>::__tuple_impl(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(CGColorSpace **)a2;
  *(void *)a1 = *(void *)a2;
  if (v4) {
    PCCFRefTraits<CGColorSpace *>::retain(v4);
  }
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  long long v5 = *(CGColorSpace **)(a2 + 16);
  *(void *)(a1 + 16) = v5;
  if (v5) {
    PCCFRefTraits<CGColorSpace *>::retain(v5);
  }
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  return a1;
}

void sub_1B76B5BD0(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    PCCFRef<vImageConverter *>::~PCCFRef((const void **)__p + 8);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)__p + 6);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)__p + 4);
  }
  if (__p)
  {
    operator delete(__p);
  }
}

uint64_t std::pair<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat> const,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>::pair[abi:ne180100]<true,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::__tuple_impl<std::__tuple_indices<0ul,1ul,2ul,3ul>,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>::__tuple_impl(a1, a2);
  long long v5 = *(const void **)a3;
  *(void *)(a1 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *(void *)a3;
  if (v5) {
    PCCFRefTraits<vImageConverter *>::retain(v5);
  }
  long long v6 = *(_OWORD *)(a3 + 8);
  *(void *)(a1 + 56) = *(void *)(a3 + 24);
  *(_OWORD *)(a1 + 40) = v6;
  return a1;
}

void sub_1B76B5C98(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1 + 2);
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

void PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::remove(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(*(void *)a2 + 88);
  unint64_t v4 = ((a1[1] - *a1) >> 3) - 1;
  if (v3 == v4)
  {
    std::vector<std::__map_iterator<std::__tree_iterator<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,std::__tree_node<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,void *> *,long>>>::resize((uint64_t)a1, v3);
  }
  else
  {
    *(void *)(*a1 + 8 * v3) = *(void *)(*a1 + 8 * v4);
    *(void *)(*(void *)(*a1 + 8 * v3) + 88) = v3;
    std::vector<std::__map_iterator<std::__tree_iterator<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,std::__tree_node<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,void *> *,long>>>::resize((uint64_t)a1, v4);
    uint64_t v5 = *a1 + 8 * v3;
    PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::bubble(a1, v5);
  }
}

uint64_t *std::__tree<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__map_value_compare<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>,true>,std::allocator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>>>::erase(uint64_t **a1, uint64_t a2)
{
  unint64_t v3 = std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(a1, (uint64_t *)a2);
  PCCFRef<vImageConverter *>::~PCCFRef((const void **)(a2 + 64));
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(a2 + 48));
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(a2 + 32));
  operator delete((void *)a2);
  return v3;
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<float>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<float>::__append(char **a1, unint64_t a2)
{
  long long v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 2);
    if (v10 >> 62) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = v5 - v8;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v4, v13);
      uint64_t v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      unint64_t v14 = 0;
    }
    BOOL v15 = &v14[4 * v11];
    unint64_t v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    uint64_t v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      int v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

const void **PCCFRef<vImageConverter *>::~PCCFRef(const void **a1)
{
  unint64_t v2 = *a1;
  if (v2) {
    PCCFRefTraits<vImageConverter *>::release(v2);
  }
  return a1;
}

float64_t getScaleTranslate(float64x2_t *a1, uint64_t a2, float64x2_t *a3)
{
  float64x2_t v9 = 0uLL;
  uint64_t v10 = 0;
  __asm { FMOV            V0.2D, #1.0 }
  long long v11 = _Q0;
  uint64_t v12 = 0x3FF0000000000000;
  return getScaleTranslate(a1, &v9, (double *)&v11, a2, a3);
}

float64_t getScaleTranslate(float64x2_t *a1, float64x2_t *a2, double *a3, uint64_t a4, float64x2_t *a5)
{
  getScale(a1, a2->f64, a3, a4, 0);
  PCMatrix44Tmpl<double>::transform<double>(a1->f64, a2->f64, a5->f64);
  *a5 = vsubq_f64(*a5, *a2);
  float64_t result = a5[1].f64[0] - a2[1].f64[0];
  a5[1].f64[0] = result;
  return result;
}

void getScale(float64x2_t *a1, double *a2, double *a3, uint64_t a4, int a5)
{
  long long v16 = 0u;
  long long v17 = 0u;
  PCMatrix44Tmpl<double>::transform<double>(a1->f64, a2, (double *)&v16);
  PCMatrix44Tmpl<double>::jacobianPost(a1, (double *)&v16, (uint64_t)v15);
  for (uint64_t i = 0; i != 24; i += 8)
  {
    double v10 = *(double *)&v15[i + 32];
    double v11 = *(double *)&v15[i + 64];
    double v12 = a3[1];
    double v13 = *(double *)&v15[i] * *a3;
    *(void *)&long long v16 = *(void *)&v15[i];
    *((double *)&v16 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v10;
    *(double *)&long long v17 = v11;
    double v14 = sqrt(v13 * v13 + v10 * v12 * (v10 * v12) + v11 * a3[2] * (v11 * a3[2]));
    *(double *)(a4 + i) = v14;
    if (a5)
    {
      if (*(double *)((char *)&v16 + i) < 0.0) {
        *(double *)(a4 + i) = -v14;
      }
    }
  }
}

float64_t getScaleTranslateFlip(float64x2_t *a1, uint64_t a2, float64x2_t *a3)
{
  float64x2_t v9 = 0uLL;
  uint64_t v10 = 0;
  __asm { FMOV            V0.2D, #1.0 }
  long long v11 = _Q0;
  uint64_t v12 = 0x3FF0000000000000;
  return getScaleTranslateFlip(a1, &v9, (double *)&v11, a2, a3);
}

float64_t getScaleTranslateFlip(float64x2_t *a1, float64x2_t *a2, double *a3, uint64_t a4, float64x2_t *a5)
{
  getScale(a1, a2->f64, a3, a4, 1);
  PCMatrix44Tmpl<double>::transform<double>(a1->f64, a2->f64, a5->f64);
  *a5 = vsubq_f64(*a5, *a2);
  float64_t result = a5[1].f64[0] - a2[1].f64[0];
  a5[1].f64[0] = result;
  return result;
}

__n128 getScale(float64x2_t *a1, uint64_t a2)
{
  memset(v8, 0, sizeof(v8));
  __asm { FMOV            V0.2D, #1.0 }
  long long v9 = _Q0;
  uint64_t v10 = 0x3FF0000000000000;
  getScale(a1, v8, (double *)&v9, a2, 0);
  return result;
}

__n128 getScale(float64x2_t *a1, double *a2, uint64_t a3)
{
  __asm { FMOV            V0.2D, #1.0 }
  long long v9 = _Q0;
  uint64_t v10 = 0x3FF0000000000000;
  getScale(a1, a2, (double *)&v9, a3, 0);
  return result;
}

float64_t getScaleTranslateRotate(float64x2_t *a1, uint64_t a2, float64x2_t *a3, long double *a4)
{
  float64x2_t v10 = 0uLL;
  uint64_t v11 = 0;
  __asm { FMOV            V0.2D, #1.0 }
  long long v12 = _Q0;
  uint64_t v13 = 0x3FF0000000000000;
  return getScaleTranslateRotate(a1, &v10, (double *)&v12, a2, a3, a4);
}

float64_t getScaleTranslateRotate(float64x2_t *a1, float64x2_t *a2, double *a3, uint64_t a4, float64x2_t *a5, long double *a6)
{
  memset(v22, 0, sizeof(v22));
  PCMatrix44Tmpl<double>::transform<double>(a1->f64, a2->f64, (double *)v22);
  PCMatrix44Tmpl<double>::jacobianPost(a1, (double *)v22, (uint64_t)v18);
  for (uint64_t i = 0; i != 3; ++i)
  {
    double v13 = *(double *)&v18[i + 4] * a3[1];
    double v14 = *(double *)&v21[i * 8] * a3[2];
    *(double *)(a4 + i * 8) = sqrt(*(double *)&v18[i] * *a3 * (*(double *)&v18[i] * *a3) + v13 * v13 + v14 * v14);
  }
  long double v16 = *(double *)v18;
  double v15 = *(double *)&v18[1];
  if (v16 * v16 + v15 * v15 <= v19 * v19 + v20 * v20)
  {
    double v15 = -v19;
    long double v16 = v20;
  }
  *a6 = atan2(v15, v16);
  PCMatrix44Tmpl<double>::transform<double>(a1->f64, a2->f64, a5->f64);
  *a5 = vsubq_f64(*a5, *a2);
  float64_t result = a5[1].f64[0] - a2[1].f64[0];
  a5[1].f64[0] = result;
  return result;
}

float64x2_t perspectiveToAffine(float64x2_t *a1, double *a2, double *a3)
{
  uint64_t v22 = 0x3FF0000000000000;
  uint64_t v19 = 0x3FF0000000000000;
  void v16[5] = 1.0;
  v16[0] = 1.0;
  memset(&v16[1], 0, 32);
  long long v17 = 0u;
  long long v18 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  memset(v23, 0, sizeof(v23));
  PCMatrix44Tmpl<double>::transform<double>(a1->f64, a2, (double *)v23);
  PCMatrix44Tmpl<double>::jacobianPost(a1, (double *)v23, (uint64_t)&v14);
  for (uint64_t i = 0; i != 16; i += 4)
  {
    uint64_t v7 = &v16[i];
    long long v8 = *(long long *)&v15[i];
    *(_OWORD *)uint64_t v7 = *(long long *)&v15[i - 2];
    *((_OWORD *)v7 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v8;
  }
  long long v14 = 0u;
  *(_OWORD *)double v15 = 0u;
  PCMatrix44Tmpl<double>::transform<double>(a1->f64, a2, (double *)&v14);
  PCMatrix44Tmpl<double>::jacobianPost(a1, (double *)&v14, (uint64_t)v16);
  long long v14 = 0uLL;
  v15[0] = 0.0;
  PCMatrix44Tmpl<double>::transform<double>(a1->f64, a2, (double *)&v14);
  PCMatrix44Tmpl<double>::rightTranslate(v16, -*a2, -a2[1], -a2[2]);
  *(void *)&v9.f64[0] = v14;
  *(void *)&result.f64[0] = *(_OWORD *)&PCMatrix44Tmpl<double>::leftTranslate((float64x2_t *)v16, v9, *((double *)&v14 + 1), v15[0]);
  if (v16 != a3)
  {
    for (uint64_t j = 0; j != 16; j += 4)
    {
      long long v12 = &a3[j];
      float64x2_t result = *(float64x2_t *)&v16[j];
      long long v13 = *(_OWORD *)&v16[j + 2];
      *(float64x2_t *)long long v12 = result;
      *((_OWORD *)v12 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v13;
    }
  }
  return result;
}

uint64_t pointInPolygon(double *a1, uint64_t a2, int a3)
{
  int v3 = a3 - 1;
  if (a3 < 1)
  {
    char v5 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    char v5 = 0;
    double v6 = a1[1];
    uint64_t v7 = (double *)(a2 + 8);
    do
    {
      double v8 = *v7;
      double v9 = *(double *)(a2 + 16 * v3 + 8);
      BOOL v10 = *v7 <= v6 && v6 < v9;
      if (v10 || (v6 < v8 ? (BOOL v11 = v9 > v6) : (BOOL v11 = 1), !v11))
      {
        if (*a1 < *(v7 - 1) + (v6 - v8) * (*(double *)(a2 + 16 * v3) - *(v7 - 1)) / (v9 - v8)) {
          v5 ^= 1u;
        }
      }
      int v3 = v4;
      v7 += 2;
      ++v4;
    }
    while (a3 != v4);
  }
  return v5 & 1;
}

BOOL PCVector3<double>::normalize(double *a1, double a2)
{
  double v2 = *a1;
  double v3 = a1[1];
  double v4 = a1[2];
  double v5 = sqrt(v2 * v2 + v3 * v3 + v4 * v4);
  BOOL v6 = v5 >= a2 || v5 <= -a2;
  if (v6)
  {
    *a1 = v2 / v5;
    a1[1] = v3 / v5;
    a1[2] = v4 / v5;
  }
  return v6;
}

double PCCalcRaySphereIntersection<double>(double *a1, double *a2, double *a3, double *a4, double a5)
{
  double v5 = *a1;
  double v6 = a1[1];
  double v7 = a3[1];
  double v8 = *a1 - *a3;
  double v9 = a1[2];
  double v10 = a3[2];
  double v11 = *a2;
  double v12 = a2[1];
  double v13 = a2[2];
  double v14 = v8 * *a2 + (v6 - v7) * v12 + (v9 - v10) * v13;
  double v15 = a5 * a5 - (v8 * v8 + (v6 - v7) * (v6 - v7) + (v9 - v10) * (v9 - v10)) + v14 * v14;
  if (v15 < 0.0) {
    double v16 = (*a3 - v5) * v11 + (v7 - v6) * v12 + (v10 - v9) * v13;
  }
  else {
    double v16 = -v14 - sqrt(v15);
  }
  double result = v9 + v13 * v16;
  *a4 = v5 + v11 * v16;
  a4[1] = v6 + v12 * v16;
  a4[2] = result;
  return result;
}

double PCIntersectRayWithPlane(double *a1, double *a2, double *a3)
{
  return PCPlane<double>::intersect(a2, a1, a3);
}

BOOL PCRayIntersectsBox(double *a1, double *a2, double *a3)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  double v5 = *a2;
  double v6 = a2[1];
  double v7 = a2[2];
  double v8 = a2[3];
  double v9 = a2[4];
  double v10 = a2[5];
  if (vabdd_f64(v9, v10) >= 0.0000001)
  {
    unint64_t v16 = 0;
    double v25 = a2[1];
    double v26 = v8;
    double v27 = v10;
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    unint64_t v30 = 0x3FF0000000000000;
    double v31 = v5;
    double v32 = v7;
    double v33 = v9;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    unint64_t v36 = 0xBFF0000000000000;
    double v37 = v6;
    double v38 = v8;
    double v39 = v10;
    long long v40 = xmmword_1B7E733E0;
    uint64_t v41 = 0;
    double v42 = v5;
    double v43 = v7;
    double v44 = v9;
    long long v45 = xmmword_1B7E7E030;
    uint64_t v46 = 0;
    double v47 = v5;
    double v48 = v7;
    double v49 = v9;
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    unint64_t v50 = 0xBFF0000000000000;
    double v53 = v6;
    double v54 = v8;
    double v55 = v10;
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    BOOL v12 = 1;
    long long v17 = &v25;
    uint64_t v56 = 0x3FF0000000000000;
    do
    {
      PCPlane<double>::intersect(v17, a1, a3);
      if (v18)
      {
        if (v17[3] != 0.0 || (*a3 >= v5 ? (BOOL v19 = *a3 > v6) : (BOOL v19 = 1), !v19))
        {
          if (v17[4] != 0.0 || ((double v20 = a3[1], v20 >= v7) ? (v21 = v20 > v8) : (v21 = 1), !v21))
          {
            if (v17[5] != 0.0) {
              break;
            }
            double v22 = a3[2];
            if (v22 >= v9 && v22 <= v10) {
              break;
            }
          }
        }
      }
      BOOL v12 = v16 < 5;
      v17 += 6;
      ++v16;
    }
    while (v16 != 6);
  }
  else
  {
    double v25 = *a2;
    double v26 = v7;
    double v27 = v9;
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    unint64_t v30 = 0xBFF0000000000000;
    PCPlane<double>::intersect(&v25, a1, a3);
    if (!v11) {
      return 0;
    }
    BOOL v12 = 0;
    if (v6 - v5 >= 0.0 && v8 - v7 >= 0.0)
    {
      double v13 = a3[1];
      if (v5 <= *a3 && v5 + v6 - v5 >= *a3 && v7 <= v13) {
        return v7 + v8 - v7 >= v13;
      }
      return 0;
    }
  }
  return v12;
}

double PCPlane<double>::intersect(double *a1, double *a2, double *a3)
{
  double v4 = a1[3];
  double v3 = a1[4];
  double v5 = a1[5];
  double v6 = sqrt(v4 * v4 + v3 * v3 + v5 * v5);
  if (v6 <= -0.000000100000001 || v6 >= 0.000000100000001)
  {
    double v4 = v4 / v6;
    double v3 = v3 / v6;
    double v5 = v5 / v6;
  }
  double v7 = a2[1];
  double v8 = a2[2];
  double v9 = a2[3];
  double v10 = v4 * (*a1 - *a2) + v3 * (a1[1] - v7) + v5 * (a1[2] - v8);
  double v11 = v4 * v9;
  double v12 = a2[4];
  double v13 = a2[5];
  double result = v10 / (v11 + v3 * v12 + v5 * v13);
  if ((*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    double v15 = *a2 + v9 * result;
    double v16 = v7 + result * v12;
    double result = v8 + result * v13;
    *a3 = v15;
    a3[1] = v16;
    a3[2] = result;
  }
  return result;
}

BOOL PCClipPointToPlane(uint64_t a1, uint64_t a2)
{
  float64x2_t v2 = vmulq_f64(vsubq_f64(*(float64x2_t *)(a2 + 8), *(float64x2_t *)(a1 + 8)), *(float64x2_t *)(a1 + 32));
  return (*(double *)a2 - *(double *)a1) * *(double *)(a1 + 24) + v2.f64[0] + v2.f64[1] > 0.0;
}

double PCClipLineToPlane2D@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X2>, double *a4@<X8>)
{
  long long v27 = 0u;
  long long v28 = 0u;
  long long v26 = 0u;
  uint64_t v24 = 0;
  uint64_t v25 = 0x3FF0000000000000;
  long long v22 = 0u;
  long long v23 = 0u;
  planeIntersection<double>(a1, a1 + 3, (double *)&v22, (double *)&v23 + 1, (double *)&v26, (double *)&v27 + 1);
  double v8 = *((double *)&v26 + 1);
  double result = *(double *)&v26;
  double v9 = *((double *)&v27 + 1);
  double v10 = *(double *)&v28;
  *a4 = 0.0;
  a4[1] = 0.0;
  double v11 = result + v9 - result;
  double v12 = v8 + v10 - v8;
  double v13 = a2[1];
  double v14 = *a3 - *a2;
  double v15 = a3[1] - v13;
  double v16 = v12 * v14 - v11 * v15;
  if (v16 != 0.0)
  {
    double v17 = result - *a2;
    double v18 = v8 - v13;
    double v19 = (v12 * v17 - v11 * v18) / v16;
    if (v19 >= 0.0 && v19 <= 1.0)
    {
      double v21 = (v17 * v15 - v14 * v18) / v16;
      double result = result + v9 * v21;
      *a4 = result;
      a4[1] = v8 + v10 * v21;
    }
  }
  return result;
}

void PCClipLinesToPlane2D(uint64_t a1, double *a2, int a3, uint64_t a4, uint64_t *a5)
{
  std::vector<BOOL>::resize((uint64_t)a5, a3, 0);
  if (a3 >= 1)
  {
    unint64_t v9 = 0;
    float64x2_t v10 = *(float64x2_t *)a1;
    float64x2_t v11 = *(float64x2_t *)(a1 + 24);
    double v12 = (0.0 - *(double *)(a1 + 16)) * *(double *)(a1 + 40);
    uint64_t v13 = *a5;
    uint64_t v14 = a3;
    do
    {
      unint64_t v15 = v9 >> 6;
      uint64_t v16 = 1 << v9;
      if (vaddvq_f64(vmulq_f64(vsubq_f64(*(float64x2_t *)&a2[2 * v9], v10), v11)) + v12 <= 0.0) {
        uint64_t v17 = *(void *)(v13 + 8 * v15) & ~v16;
      }
      else {
        uint64_t v17 = *(void *)(v13 + 8 * v15) | v16;
      }
      *(void *)(v13 + 8 * v15) = v17;
      ++v9;
    }
    while (a3 != v9);
    unint64_t v18 = 0;
    uint64_t v19 = a4 + 16;
    uint64_t v20 = a3 - 1;
    double v21 = a2;
    do
    {
      uint64_t v22 = 1 << v18;
      if (v20 == v18) {
        unint64_t v23 = 0;
      }
      else {
        unint64_t v23 = v18 + 1;
      }
      uint64_t v24 = *(void *)(*a5 + ((v23 >> 3) & 0x1FFFFFFFFFFFFFF8)) & (1 << v23);
      if ((*(void *)(*a5 + 8 * (v18 >> 6)) & v22) != 0)
      {
        if (!v24) {
          goto LABEL_15;
        }
        *(_OWORD *)(v19 - 16) = *(_OWORD *)v21;
        *(_OWORD *)uint64_t v19 = *(_OWORD *)&a2[2 * v23];
      }
      else
      {
        if (v24)
        {
LABEL_15:
          uint64_t v25 = &a2[2 * v23];
          PCClipLineToPlane2D((double *)a1, v21, v25, (double *)&v29);
          long long v26 = (_OWORD *)(v19 - 16);
          if ((*(void *)(*a5 + 8 * (v18 >> 6)) & v22) != 0)
          {
            *long long v26 = *(_OWORD *)v21;
            long long v27 = v29;
          }
          else
          {
            *long long v26 = v29;
            long long v27 = *(_OWORD *)v25;
          }
          *(_OWORD *)uint64_t v19 = v27;
          goto LABEL_20;
        }
        *(void *)(v19 - 16) = 0;
        *(void *)(v19 - 8) = 0;
        *(void *)uint64_t v19 = 0;
        *(void *)(v19 + 8) = 0;
      }
LABEL_20:
      ++v18;
      v21 += 2;
      v19 += 32;
    }
    while (v14 != v18);
  }
}

double PCMatrix44Tmpl<double>::jacobianPost@<D0>(float64x2_t *a1@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 120) = 0x3FF0000000000000;
  *(void *)(a3 + 24) = 0;
  *(void *)(a3 + 56) = 0;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_OWORD *)(a3 + 104) = 0u;
  double v4 = a2[2];
  double v3 = a2[3];
  double v5 = *a2;
  double v6 = a2[1];
  float64x2_t v7 = a1[6];
  float64x2_t v8 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v3 * v3), 0);
  *(float64x2_t *)a3 = vdivq_f64(vsubq_f64(vmulq_n_f64(*a1, v3), vmulq_n_f64(v7, *a2)), v8);
  *(float64x2_t *)(a3 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = vdivq_f64(vsubq_f64(vmulq_n_f64(a1[2], v3), vmulq_n_f64(v7, v6)), v8);
  *(float64x2_t *)(a3 + 64) = vdivq_f64(vsubq_f64(vmulq_n_f64(a1[4], v3), vmulq_n_f64(v7, v4)), v8);
  v7.f64[0] = a1[7].f64[0];
  *(double *)(a3 + 16) = (v3 * a1[1].f64[0] - v5 * v7.f64[0]) / (v3 * v3);
  *(double *)(a3 + 48) = (v3 * a1[3].f64[0] - v6 * v7.f64[0]) / (v3 * v3);
  double result = (v3 * a1[5].f64[0] - v4 * v7.f64[0]) / (v3 * v3);
  *(double *)(a3 + 80) = result;
  return result;
}

BOOL planeIntersection<double>(double *a1, double *a2, double *a3, double *a4, double *a5, double *a6)
{
  double v7 = a4[1];
  double v6 = a4[2];
  double v8 = a2[1];
  double v9 = v8 * v6;
  double v10 = a2[2];
  double v11 = v10 * v7;
  double v12 = v8 * v6 - v10 * v7;
  double v13 = v10 * *a4;
  double v14 = v6 * *a2;
  double v15 = v13 - v14;
  double v16 = v7 * *a2;
  double v17 = v8 * *a4;
  double v18 = v16 - v17;
  *a6 = v12;
  a6[1] = v13 - v14;
  a6[2] = v16 - v17;
  unsigned int v19 = vabdd_f64(v13, v14) > vabdd_f64(v9, v11);
  if (vabdd_f64(v16, v17) > fabs(a6[v19])) {
    unsigned int v19 = 2;
  }
  double v20 = a6[v19];
  if (v20 != 0.0)
  {
    double v21 = a2[1];
    double v22 = a2[2];
    double v23 = *a2 * *a1 + v21 * a1[1] + v22 * a1[2];
    double v24 = a4[1];
    double v25 = a4[2];
    double v26 = *a4 * *a3 + v24 * a3[1] + v25 * a3[2];
    if (v19 == 2)
    {
      *a5 = (v23 * v24 - v21 * v26) / v18;
      a5[1] = (v26 * *a2 - v23 * *a4) / v18;
      double v28 = 0.0;
    }
    else if (v19 == 1)
    {
      *a5 = (v22 * v26 - v23 * v25) / v15;
      a5[1] = 0.0;
      double v28 = (v23 * *a4 - v26 * *a2) / a6[1];
    }
    else
    {
      *a5 = 0.0;
      double v27 = *a6;
      a5[1] = (v23 * v25 - v22 * v26) / *a6;
      double v28 = (v26 * a2[1] - v23 * a4[1]) / v27;
    }
    a5[2] = v28;
    PCVector3<double>::normalize(a6, 0.000000100000001);
  }
  return v20 != 0.0;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  double v4 = *(void **)a1;
  int v5 = *(_DWORD *)(a1 + 8);
  for (i = *(_DWORD *)(a3 + 8); *(void *)a1 != *(void *)a2 || v5 != *(_DWORD *)(a2 + 8); int v5 = *(_DWORD *)(a1 + 8))
  {
    double v8 = *(uint64_t **)a3;
    uint64_t v9 = 1 << i;
    if ((*v4 >> v5)) {
      uint64_t v10 = *v8 | v9;
    }
    else {
      uint64_t v10 = *v8 & ~v9;
    }
    *double v8 = v10;
    if (v5 == 63)
    {
      int v11 = 0;
      *(void *)a1 = v4 + 1;
    }
    else
    {
      int v11 = v5 + 1;
    }
    *(_DWORD *)(a1 + 8) = v11;
    int v12 = *(_DWORD *)(a3 + 8);
    if (v12 == 63)
    {
      int i = 0;
      *(void *)a3 += 8;
    }
    else
    {
      int i = v12 + 1;
    }
    *(_DWORD *)(a3 + 8) = i;
    double v4 = *(void **)a1;
  }
  *(void *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v5;
  *(void *)(a4 + 16) = *(void *)a3;
  *(_DWORD *)(a4 + 24) = i;
}

void sub_1B76B8430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__15(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
}

void sub_1B76B9DC4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B76B9EF0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B76B9F84(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

int8x8_t *PCHash128::addData(int8x8_t *this, const unsigned __int8 *a2, size_t __n)
{
  unsigned int v3 = __n;
  double v4 = a2;
  int v5 = this;
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (!*(void *)&vorr_s8(*this, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)this->i8, *(int8x16_t *)this->i8, 8uLL))) {
    *(_OWORD *)this->int i8 = xmmword_1B7E7C6E0;
  }
  if (__n >= 0x40)
  {
    uint64_t v6 = a2 & 3;
    do
    {
      if (v6)
      {
        long long v7 = *((_OWORD *)v4 + 1);
        v11[0] = *(_OWORD *)v4;
        v11[1] = v7;
        long long v8 = *((_OWORD *)v4 + 3);
        v11[2] = *((_OWORD *)v4 + 2);
        v11[3] = v8;
        uint64_t v9 = (const unsigned int *)v11;
        uint64_t v10 = v5;
      }
      else
      {
        uint64_t v10 = v5;
        uint64_t v9 = (const unsigned int *)v4;
      }
      this = (int8x8_t *)PCHash128::transform(v10, v9);
      v4 += 64;
      v3 -= 64;
    }
    while (v3 > 0x3F);
  }
  if (v3)
  {
    memcpy(v11, v4, v3);
    memcpy((char *)v11 + v3, &PADDING, 64 - v3);
    return (int8x8_t *)PCHash128::transform(v5, (const unsigned int *)v11);
  }
  return this;
}

void PCHash128::PCHash128(PCHash128 *this, PCString *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  *(void *)this = 0;
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  CStr = PCString::createCStr(a2);
  uint64_t v4 = 0;
  uint64_t v5 = MEMORY[0x1E4F14390];
  uint64_t v6 = CStr;
LABEL_2:
  uint64_t v7 = 0;
  int v8 = 0;
  while (1)
  {
    unsigned int v9 = v6[v7];
    if ((v9 & 0x80000000) != 0 || (*(_DWORD *)(v5 + 4 * v9 + 60) & 0x10000) == 0) {
      break;
    }
    v8 *= 16;
    ++v7;
    unsigned int v10 = v9 - 48;
    unsigned int v11 = v9 - 97;
    unsigned int v12 = v9 - 65;
    int v13 = v8 + v9;
    if (v12 <= 5) {
      int v8 = v13 - 55;
    }
    if (v11 <= 5) {
      int v8 = v13 - 87;
    }
    int v14 = v13 - 48;
    if (v10 <= 9) {
      int v8 = v14;
    }
    if (v7 == 8)
    {
      *((_DWORD *)&v15 + v4++) = v8;
      v6 += 8;
      if (v4 != 4) {
        goto LABEL_2;
      }
      *(_OWORD *)this = v15;
      break;
    }
  }
  free(CStr);
}

void PCHash128::PCHash128(PCHash128 *this, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)this = a2;
  *((_DWORD *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = a3;
  *((_DWORD *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a4;
  *((_DWORD *)this + 3) = a5;
}

PCString *PCHash128::getString@<X0>(PCHash128 *this@<X0>, PCString *a2@<X8>)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x40uLL, "%08x%08x%08x%08x", *(_DWORD *)this, *((_DWORD *)this + 1), *((_DWORD *)this + 2), *((_DWORD *)this + 3));
  return PCString::PCString(a2, __str);
}

_DWORD *PCHash128::transform(_DWORD *this, const unsigned int *a2)
{
  int v2 = this[1];
  int v4 = this[2];
  int v3 = this[3];
  int v6 = *a2;
  unsigned int v5 = a2[1];
  unsigned int v8 = a2[2];
  unsigned int v7 = a2[3];
  unsigned int v10 = a2[4];
  unsigned int v9 = a2[5];
  unsigned int v11 = a2[6];
  unsigned int v12 = a2[7];
  unsigned int v13 = a2[8];
  unsigned int v14 = a2[9];
  unsigned int v15 = a2[10];
  unsigned int v16 = a2[11];
  unsigned int v17 = a2[12];
  unsigned int v18 = a2[13];
  unsigned int v20 = a2[14];
  unsigned int v19 = a2[15];
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *this + (v4 & v2) + (v3 & ~v2) + v6 - 680876936;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v22 = (v21 >> 25) + v2;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v3 + v5 + (v4 & ~v22) + (v22 & v2) - 389564586;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v23 = (v21 >> 20) + v22;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v4 + v8 + (v2 & ~v23) + (v23 & v22) + 606105819;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v24 = (v21 >> 15) + v23;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v2 + v7 + (v22 & ~v24) + (v24 & v23) - 1044525330;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v25 = (v21 >> 10) + v24;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v10 + v22 + (v23 & ~v25) + (v25 & v24) - 176418897;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v26 = (v21 >> 25) + v25;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v9 + v23 + (v24 & ~v26) + (v26 & v25) + 1200080426;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v27 = (v21 >> 20) + v26;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v11 + v24 + (v25 & ~v27) + (v27 & v26) - 1473231341;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v28 = (v21 >> 15) + v27;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v12 + v25 + (v26 & ~v28) + (v28 & v27) - 45705983;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v29 = (v21 >> 10) + v28;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v13 + v26 + (v27 & ~v29) + (v29 & v28) + 1770035416;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v30 = (v21 >> 25) + v29;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v14 + v27 + (v28 & ~v30) + (v30 & v29) - 1958414417;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v31 = (v21 >> 20) + v30;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v15 + v28 + (v29 & ~v31) + (v31 & v30) - 42063;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v32 = (v21 >> 15) + v31;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v16 + v29 + (v30 & ~v32) + (v32 & v31) - 1990404162;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v33 = (v21 >> 10) + v32;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v17 + v30 + (v31 & ~v33) + (v33 & v32) + 1804603682;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v34 = (v21 >> 25) + v33;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v18 + v31 + (v32 & ~v34) + (v34 & v33) - 40341101;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v35 = (v21 >> 20) + v34;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v20 + v32 + (v33 & ~v35) + (v35 & v34) - 1502002290;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v36 = (v21 >> 15) + v35;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v19 + v33 + (v34 & ~v36) + (v36 & v35) + 1236535329;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v37 = (v21 >> 10) + v36;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v5 + v34 + (v36 & ~v35) - 165796510 + (v37 & v35);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v38 = (v21 >> 27) + v37;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v11 + v35 + (v37 & ~v36) - 1069501632 + (v38 & v36);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v39 = (v21 >> 23) + v38;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v16 + v36 + (v38 & ~v37) + 643717713 + (v39 & v37);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v40 = (v21 >> 18) + v39;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v6 + v37 + (v39 & ~v38) - 373897302 + (v40 & v38);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v41 = (v21 >> 12) + v40;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v9 + v38 + (v40 & ~v39) - 701558691 + (v41 & v39);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v42 = (v21 >> 27) + v41;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v15 + v39 + (v41 & ~v40) + 38016083 + (v42 & v40);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v43 = (v21 >> 23) + v42;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v19 + v40 + (v42 & ~v41) - 660478335 + (v43 & v41);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v44 = (v21 >> 18) + v43;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v10 + v41 + (v43 & ~v42) - 405537848 + (v44 & v42);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v45 = (v21 >> 12) + v44;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v14 + v42 + (v44 & ~v43) + 568446438 + (v45 & v43);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v46 = (v21 >> 27) + v45;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v20 + v43 + (v45 & ~v44) - 1019803690 + (v46 & v44);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v47 = (v21 >> 23) + v46;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v7 + v44 + (v46 & ~v45) - 187363961 + (v47 & v45);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v48 = (v21 >> 18) + v47;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v13 + v45 + (v47 & ~v46) + 1163531501 + (v48 & v46);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v49 = (v21 >> 12) + v48;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v18 + v46 + (v48 & ~v47) - 1444681467 + (v49 & v47);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v50 = (v21 >> 27) + v49;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v8 + v47 + (v49 & ~v48) - 51403784 + (v50 & v48);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v51 = (v21 >> 23) + v50;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v12 + v48 + (v50 & ~v49) + 1735328473 + (v51 & v49);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v52 = (v21 >> 18) + v51;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v17 + v49 + (v51 & ~v50) - 1926607734 + (v52 & v50);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v53 = (v21 >> 12) + v52;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v9 + v50 - 378558 + (v53 ^ v52 ^ v51);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v54 = (v21 >> 28) + v53;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v13 + v51 - 2022574463 + (v53 ^ v52 ^ v54);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v55 = (v21 >> 21) + v54;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v16 + v52 + 1839030562 + (v54 ^ v53 ^ v55);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v56 = (v21 >> 16) + v55;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v20 + v53 - 35309556 + (v55 ^ v54 ^ v56);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v57 = (v21 >> 9) + v56;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v5 + v54 - 1530992060 + (v56 ^ v55 ^ v57);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v58 = (v21 >> 28) + v57;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v10 + v55 + 1272893353 + (v57 ^ v56 ^ v58);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v59 = (v21 >> 21) + v58;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v12 + v56 - 155497632 + (v58 ^ v57 ^ v59);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v60 = (v21 >> 16) + v59;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v15 + v57 - 1094730640 + (v59 ^ v58 ^ v60);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v61 = (v21 >> 9) + v60;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v18 + v58 + 681279174 + (v60 ^ v59 ^ v61);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v62 = (v21 >> 28) + v61;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v6 + v59 - 358537222 + (v61 ^ v60 ^ v62);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v63 = (v21 >> 21) + v62;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v7 + v60 - 722521979 + (v62 ^ v61 ^ v63);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v64 = (v21 >> 16) + v63;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v11 + v61 + 76029189 + (v63 ^ v62 ^ v64);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v65 = (v21 >> 9) + v64;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v14 + v62 - 640364487 + (v64 ^ v63 ^ v65);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v66 = (v21 >> 28) + v65;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v17 + v63 - 421815835 + (v65 ^ v64 ^ v66);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v67 = (v21 >> 21) + v66;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v19 + v64 + 530742520 + (v66 ^ v65 ^ v67);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v68 = (v21 >> 16) + v67;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v8 + v65 - 995338651 + (v67 ^ v66 ^ v68);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v69 = (v21 >> 9) + v68;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v6 + v66 - 198630844 + ((v69 | ~v67) ^ v68);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v70 = (v21 >> 26) + v69;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v12 + v67 + 1126891415 + ((v70 | ~v68) ^ v69);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v71 = (v21 >> 22) + v70;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v20 + v68 - 1416354905 + ((v71 | ~v69) ^ v70);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v72 = (v21 >> 17) + v71;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v9 + v69 - 57434055 + ((v72 | ~v70) ^ v71);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v73 = (v21 >> 11) + v72;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v17 + v70 + 1700485571 + ((v73 | ~v71) ^ v72);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v74 = (v21 >> 26) + v73;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v7 + v71 - 1894986606 + ((v74 | ~v72) ^ v73);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v75 = (v21 >> 22) + v74;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v15 + v72 - 1051523 + ((v75 | ~v73) ^ v74);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v76 = (v21 >> 17) + v75;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v5 + v73 - 2054922799 + ((v76 | ~v74) ^ v75);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v77 = (v21 >> 11) + v76;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v13 + v74 + 1873313359 + ((v77 | ~v75) ^ v76);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v78 = (v21 >> 26) + v77;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v19 + v75 - 30611744 + ((v78 | ~v76) ^ v77);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v79 = (v21 >> 22) + v78;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v11 + v76 - 1560198380 + ((v79 | ~v77) ^ v78);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v80 = (v21 >> 17) + v79;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v18 + v77 + 1309151649 + ((v80 | ~v78) ^ v79);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v81 = (v21 >> 11) + v80;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v10 + v78 - 145523070 + ((v81 | ~v79) ^ v80);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v82 = (v21 >> 26) + v81;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v16 + v79 - 1120210379 + ((v82 | ~v80) ^ v81);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v83 = (v21 >> 22) + v82;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v8 + v80 + 718787259 + ((v83 | ~v81) ^ v82);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  int v84 = (v21 >> 17) + v83;
  HIDWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v14 + v81 - 343485551 + ((v84 | ~v82) ^ v83);
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HIDWORD(v21);
  *this += v82;
  this[1] = v84 + v2 + (v21 >> 11);
  this[2] = v84 + v4;
  this[3] = v83 + v3;
  return this;
}

int *PCHash128::operator+=(int *result, int *a2)
{
  int v2 = *result;
  int v3 = result[1];
  int v4 = result[2];
  int v5 = result[3];
  if (!(v3 | *result | v4 | v5))
  {
    *(_OWORD *)double result = xmmword_1B7E7C6E0;
    int v2 = 1732584193;
    int v3 = -271733879;
    int v4 = -1732584194;
    int v5 = 271733878;
  }
  int v7 = *a2;
  int v6 = a2[1];
  HIDWORD(v8) = v2 + (v4 & v3) + (v5 & ~v3) + *a2 - 680876936;
  LODWORD(v8) = HIDWORD(v8);
  int v9 = (v8 >> 25) + v3;
  HIDWORD(v8) = v5 + v6 + (v4 & ~v9) + (v9 & v3) - 389564586;
  LODWORD(v8) = HIDWORD(v8);
  int v10 = a2[2];
  int v11 = a2[3];
  int v12 = (v8 >> 20) + v9;
  HIDWORD(v8) = v4 + v10 + (v3 & ~v12) + (v12 & v9) + 606105819;
  LODWORD(v8) = HIDWORD(v8);
  int v13 = (v8 >> 15) + v12;
  HIDWORD(v8) = v3 + v11 + (v9 & ~v13) + (v13 & v12) - 1044525330;
  LODWORD(v8) = HIDWORD(v8);
  int v14 = (v8 >> 10) + v13;
  HIDWORD(v8) = v9 + (v12 & ~v14) + (v14 & v13) + 1971064751;
  LODWORD(v8) = HIDWORD(v8);
  int v15 = (v8 >> 25) + v14;
  HIDWORD(v8) = v12 + (v13 & ~v15) + (v15 & v14) + 1200080426;
  LODWORD(v8) = HIDWORD(v8);
  int v16 = (v8 >> 20) + v15;
  HIDWORD(v8) = v13 + (v14 & ~v16) + (v16 & v15) - 1473231341;
  LODWORD(v8) = HIDWORD(v8);
  int v17 = (v8 >> 15) + v16;
  HIDWORD(v8) = v14 + (v15 & ~v17) + (v17 & v16) - 45705983;
  LODWORD(v8) = HIDWORD(v8);
  int v18 = (v8 >> 10) + v17;
  HIDWORD(v8) = v15 + (v16 & ~v18) + (v18 & v17) + 1770035416;
  LODWORD(v8) = HIDWORD(v8);
  int v19 = (v8 >> 25) + v18;
  HIDWORD(v8) = v16 + (v17 & ~v19) + (v19 & v18) - 1958414417;
  LODWORD(v8) = HIDWORD(v8);
  int v20 = (v8 >> 20) + v19;
  HIDWORD(v8) = v17 + (v18 & ~v20) + (v20 & v19) - 42063;
  LODWORD(v8) = HIDWORD(v8);
  int v21 = (v8 >> 15) + v20;
  HIDWORD(v8) = v18 + (v19 & ~v21) + (v21 & v20) - 1990404162;
  LODWORD(v8) = HIDWORD(v8);
  int v22 = (v8 >> 10) + v21;
  HIDWORD(v8) = v19 + (v20 & ~v22) + (v22 & v21) + 1804603682;
  LODWORD(v8) = HIDWORD(v8);
  int v23 = (v8 >> 25) + v22;
  HIDWORD(v8) = v20 + (v21 & ~v23) + (v23 & v22) - 40341101;
  LODWORD(v8) = HIDWORD(v8);
  int v24 = (v8 >> 20) + v23;
  HIDWORD(v8) = v21 + (v22 & ~v24) + (v24 & v23) - 1502002290;
  LODWORD(v8) = HIDWORD(v8);
  int v25 = (v8 >> 15) + v24;
  HIDWORD(v8) = v22 + (v23 & ~v25) + (v25 & v24) + 1236535329;
  LODWORD(v8) = HIDWORD(v8);
  int v26 = (v8 >> 10) + v25;
  HIDWORD(v8) = v6 + v23 + (v25 & ~v24) - 165796510 + (v26 & v24);
  LODWORD(v8) = HIDWORD(v8);
  int v27 = (v8 >> 27) + v26;
  HIDWORD(v8) = v24 + (v26 & ~v25) - 1069501632 + (v27 & v25);
  LODWORD(v8) = HIDWORD(v8);
  int v28 = (v8 >> 23) + v27;
  HIDWORD(v8) = v25 + (v27 & ~v26) + 643717713 + (v28 & v26);
  LODWORD(v8) = HIDWORD(v8);
  int v29 = (v8 >> 18) + v28;
  HIDWORD(v8) = v7 + v26 + (v28 & ~v27) - 373897302 + (v29 & v27);
  LODWORD(v8) = HIDWORD(v8);
  int v30 = (v8 >> 12) + v29;
  HIDWORD(v8) = v27 + (v29 & ~v28) - 701558691 + (v30 & v28);
  LODWORD(v8) = HIDWORD(v8);
  int v31 = (v8 >> 27) + v30;
  HIDWORD(v8) = v28 + (v30 & ~v29) + 38016083 + (v31 & v29);
  LODWORD(v8) = HIDWORD(v8);
  int v32 = (v8 >> 23) + v31;
  HIDWORD(v8) = v29 + (v31 & ~v30) - 660478335 + (v32 & v30);
  LODWORD(v8) = HIDWORD(v8);
  int v33 = (v8 >> 18) + v32;
  HIDWORD(v8) = v30 + (v32 & ~v31) + 1741945800 + (v33 & v31);
  LODWORD(v8) = HIDWORD(v8);
  int v34 = (v8 >> 12) + v33;
  HIDWORD(v8) = v31 + (v33 & ~v32) + 568446438 + (v34 & v32);
  LODWORD(v8) = HIDWORD(v8);
  int v35 = (v8 >> 27) + v34;
  HIDWORD(v8) = v32 + (v34 & ~v33) - 1019803690 + (v35 & v33);
  LODWORD(v8) = HIDWORD(v8);
  int v36 = (v8 >> 23) + v35;
  HIDWORD(v8) = v11 + v33 + (v35 & ~v34) - 187363961 + (v36 & v34);
  LODWORD(v8) = HIDWORD(v8);
  int v37 = (v8 >> 18) + v36;
  HIDWORD(v8) = v34 + (v36 & ~v35) + 1163531501 + (v37 & v35);
  LODWORD(v8) = HIDWORD(v8);
  int v38 = (v8 >> 12) + v37;
  HIDWORD(v8) = v35 + (v37 & ~v36) - 1444681467 + (v38 & v36);
  LODWORD(v8) = HIDWORD(v8);
  int v39 = (v8 >> 27) + v38;
  HIDWORD(v8) = v10 + v36 + (v38 & ~v37) - 51403784 + (v39 & v37);
  LODWORD(v8) = HIDWORD(v8);
  int v40 = (v8 >> 23) + v39;
  HIDWORD(v8) = v37 + (v39 & ~v38) + 1735328473 + (v40 & v38);
  LODWORD(v8) = HIDWORD(v8);
  int v41 = (v8 >> 18) + v40;
  HIDWORD(v8) = v38 + (v40 & ~v39) - 1926607734 + (v41 & v39);
  LODWORD(v8) = HIDWORD(v8);
  int v42 = (v8 >> 12) + v41;
  HIDWORD(v8) = v39 - 378558 + (v42 ^ v41 ^ v40);
  LODWORD(v8) = HIDWORD(v8);
  int v43 = (v8 >> 28) + v42;
  HIDWORD(v8) = v40 - 2022574463 + (v42 ^ v41 ^ v43);
  LODWORD(v8) = HIDWORD(v8);
  int v44 = (v8 >> 21) + v43;
  HIDWORD(v8) = v41 + 1839030562 + (v43 ^ v42 ^ v44);
  LODWORD(v8) = HIDWORD(v8);
  int v45 = (v8 >> 16) + v44;
  HIDWORD(v8) = v42 - 35309556 + (v44 ^ v43 ^ v45);
  LODWORD(v8) = HIDWORD(v8);
  int v46 = (v8 >> 9) + v45;
  HIDWORD(v8) = v6 + v43 - 1530992060 + (v45 ^ v44 ^ v46);
  LODWORD(v8) = HIDWORD(v8);
  int v47 = (v8 >> 28) + v46;
  HIDWORD(v8) = v44 - 874590295 + (v46 ^ v45 ^ v47);
  LODWORD(v8) = HIDWORD(v8);
  int v48 = (v8 >> 21) + v47;
  HIDWORD(v8) = v45 - 155497632 + (v47 ^ v46 ^ v48);
  LODWORD(v8) = HIDWORD(v8);
  int v49 = (v8 >> 16) + v48;
  HIDWORD(v8) = v46 - 1094730640 + (v48 ^ v47 ^ v49);
  LODWORD(v8) = HIDWORD(v8);
  int v50 = (v8 >> 9) + v49;
  HIDWORD(v8) = v47 + 681279174 + (v49 ^ v48 ^ v50);
  LODWORD(v8) = HIDWORD(v8);
  int v51 = (v8 >> 28) + v50;
  HIDWORD(v8) = v7 + v48 - 358537222 + (v50 ^ v49 ^ v51);
  LODWORD(v8) = HIDWORD(v8);
  int v52 = (v8 >> 21) + v51;
  HIDWORD(v8) = v11 + v49 - 722521979 + (v51 ^ v50 ^ v52);
  LODWORD(v8) = HIDWORD(v8);
  int v53 = (v8 >> 16) + v52;
  HIDWORD(v8) = v50 + 76029189 + (v52 ^ v51 ^ v53);
  LODWORD(v8) = HIDWORD(v8);
  int v54 = (v8 >> 9) + v53;
  HIDWORD(v8) = v51 - 640364487 + (v53 ^ v52 ^ v54);
  LODWORD(v8) = HIDWORD(v8);
  int v55 = (v8 >> 28) + v54;
  HIDWORD(v8) = v52 - 421815835 + (v54 ^ v53 ^ v55);
  LODWORD(v8) = HIDWORD(v8);
  int v56 = (v8 >> 21) + v55;
  HIDWORD(v8) = v53 + 530742520 + (v55 ^ v54 ^ v56);
  LODWORD(v8) = HIDWORD(v8);
  int v57 = (v8 >> 16) + v56;
  HIDWORD(v8) = v10 + v54 - 995338651 + (v56 ^ v55 ^ v57);
  LODWORD(v8) = HIDWORD(v8);
  int v58 = (v8 >> 9) + v57;
  HIDWORD(v8) = v7 + v55 - 198630844 + ((v58 | ~v56) ^ v57);
  LODWORD(v8) = HIDWORD(v8);
  int v59 = (v8 >> 26) + v58;
  HIDWORD(v8) = v56 + 1126891415 + ((v59 | ~v57) ^ v58);
  LODWORD(v8) = HIDWORD(v8);
  int v60 = (v8 >> 22) + v59;
  HIDWORD(v8) = v57 - 1416354905 + ((v60 | ~v58) ^ v59);
  LODWORD(v8) = HIDWORD(v8);
  int v61 = (v8 >> 17) + v60;
  HIDWORD(v8) = v58 - 57434055 + ((v61 | ~v59) ^ v60);
  LODWORD(v8) = HIDWORD(v8);
  int v62 = (v8 >> 11) + v61;
  HIDWORD(v8) = v59 + 1700485571 + ((v62 | ~v60) ^ v61);
  LODWORD(v8) = HIDWORD(v8);
  int v63 = (v8 >> 26) + v62;
  HIDWORD(v8) = v11 + v60 - 1894986606 + ((v63 | ~v61) ^ v62);
  LODWORD(v8) = HIDWORD(v8);
  int v64 = (v8 >> 22) + v63;
  HIDWORD(v8) = v61 - 1051523 + ((v64 | ~v62) ^ v63);
  LODWORD(v8) = HIDWORD(v8);
  int v65 = (v8 >> 17) + v64;
  HIDWORD(v8) = v6 + v62 - 2054922799 + ((v65 | ~v63) ^ v64);
  LODWORD(v8) = HIDWORD(v8);
  int v66 = (v8 >> 11) + v65;
  HIDWORD(v8) = v63 + 1873313359 + ((v66 | ~v64) ^ v65);
  LODWORD(v8) = HIDWORD(v8);
  int v67 = (v8 >> 26) + v66;
  HIDWORD(v8) = v64 - 30611744 + ((v67 | ~v65) ^ v66);
  LODWORD(v8) = HIDWORD(v8);
  int v68 = (v8 >> 22) + v67;
  HIDWORD(v8) = v65 - 1560198380 + ((v68 | ~v66) ^ v67);
  LODWORD(v8) = HIDWORD(v8);
  int v69 = (v8 >> 17) + v68;
  HIDWORD(v8) = v66 + 1309151649 + ((v69 | ~v67) ^ v68);
  LODWORD(v8) = HIDWORD(v8);
  int v70 = (v8 >> 11) + v69;
  HIDWORD(v8) = v67 + 2001960578 + ((v70 | ~v68) ^ v69);
  LODWORD(v8) = HIDWORD(v8);
  int v71 = (v8 >> 26) + v70;
  HIDWORD(v8) = v68 - 1120210379 + ((v71 | ~v69) ^ v70);
  LODWORD(v8) = HIDWORD(v8);
  int v72 = (v8 >> 22) + v71;
  HIDWORD(v8) = v10 + v69 + 718787259 + ((v72 | ~v70) ^ v71);
  LODWORD(v8) = HIDWORD(v8);
  int v73 = (v8 >> 17) + v72;
  HIDWORD(v8) = v70 - 343485551 + ((v73 | ~v71) ^ v72);
  LODWORD(v8) = HIDWORD(v8);
  *double result = v71 + v2;
  result[1] = v73 + v3 + (v8 >> 11);
  result[2] = v73 + v4;
  result[3] = v72 + v5;
  return result;
}

uint64_t compare(const PCHash128 *a1, const PCHash128 *a2)
{
  if (*(_DWORD *)a1 < *(_DWORD *)a2) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 > *(_DWORD *)a2) {
    return 1;
  }
  unsigned int v2 = *((_DWORD *)a1 + 1);
  unsigned int v3 = *((_DWORD *)a2 + 1);
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 > v3) {
    return 1;
  }
  unsigned int v4 = *((_DWORD *)a1 + 2);
  unsigned int v5 = *((_DWORD *)a2 + 2);
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (v4 > v5) {
    return 1;
  }
  unsigned int v7 = *((_DWORD *)a1 + 3);
  unsigned int v8 = *((_DWORD *)a2 + 3);
  BOOL v9 = v7 >= v8;
  BOOL v10 = v7 > v8;
  if (v9) {
    return v10;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

BOOL operator<(const PCHash128 *a1, const PCHash128 *a2)
{
  return compare(a1, a2) == -1;
}

BOOL operator>(const PCHash128 *a1, const PCHash128 *a2)
{
  return compare(a1, a2) == 1;
}

void *operator<<(void *a1)
{
  int v2 = *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 8);
  unsigned int v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"(", 1);
  uint64_t v4 = *v3;
  *(_DWORD *)((char *)v3 + *(void *)(*v3 - 24) + 8) |= 0x4000u;
  *(_DWORD *)((char *)v3 + *(void *)(v4 - 24) + 8) = *(_DWORD *)((unsigned char *)v3 + *(void *)(v4 - 24) + 8) & 0xFFFFFFB5 | 8;
  unsigned int v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"0x", 2);
  char v24 = 48;
  int v6 = std::operator<<[abi:ne180100]<std::char_traits<char>>(v5, &v24);
  *(void *)((char *)v6 + *(void *)(*v6 - 24) + 24) = 8;
  unsigned int v7 = (void *)std::ostream::operator<<();
  unsigned int v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)", ", 2);
  *(_DWORD *)((char *)v8 + *(void *)(*v8 - 24) + 8) = *(_DWORD *)((unsigned char *)v8 + *(void *)(*v8 - 24) + 8) & 0xFFFFFFB5 | 8;
  BOOL v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"0x", 2);
  char v23 = 48;
  BOOL v10 = std::operator<<[abi:ne180100]<std::char_traits<char>>(v9, &v23);
  *(void *)((char *)v10 + *(void *)(*v10 - 24) + 24) = 8;
  int v11 = (void *)std::ostream::operator<<();
  int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)", ", 2);
  *(_DWORD *)((char *)v12 + *(void *)(*v12 - 24) + 8) = *(_DWORD *)((unsigned char *)v12 + *(void *)(*v12 - 24) + 8) & 0xFFFFFFB5 | 8;
  int v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"0x", 2);
  char v22 = 48;
  int v14 = std::operator<<[abi:ne180100]<std::char_traits<char>>(v13, &v22);
  *(void *)((char *)v14 + *(void *)(*v14 - 24) + 24) = 8;
  int v15 = (void *)std::ostream::operator<<();
  int v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)", ", 2);
  *(_DWORD *)((char *)v16 + *(void *)(*v16 - 24) + 8) = *(_DWORD *)((unsigned char *)v16 + *(void *)(*v16 - 24) + 8) & 0xFFFFFFB5 | 8;
  int v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"0x", 2);
  char v21 = 48;
  int v18 = std::operator<<[abi:ne180100]<std::char_traits<char>>(v17, &v21);
  *(void *)((char *)v18 + *(void *)(*v18 - 24) + 24) = 8;
  int v19 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)")", 1);
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 8) = v2;
  return a1;
}

CGColorSpaceRef __sRGBColorSpace_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBE8]);
  sRGBColorSpace_CGColorSpaceRef result = (uint64_t)result;
  return result;
}

CGColorSpaceRef __GenericGrayGamma22ColorSpace_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
  GenericGrayGamma22ColorSpace_CGColorSpaceRef result = (uint64_t)result;
  return result;
}

CGColorSpaceRef __CalibratedGray_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBF8]);
  CalibratedGray_CGColorSpaceRef result = (uint64_t)result;
  return result;
}

CGColorSpaceRef __DeviceRGB_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateDeviceRGB();
  DeviceRGB_CGColorSpaceRef result = (uint64_t)result;
  return result;
}

CGColorSpaceRef __CalibratedRGB_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC10]);
  CalibratedRGB_CGColorSpaceRef result = (uint64_t)result;
  return result;
}

uint64_t bignum_s256_init_from_s64(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = 0x101010101010101 * (result >> 63);
  a2[2] = v2;
  a2[3] = v2;
  *a2 = result;
  a2[1] = v2;
  return result;
}

uint64_t bignum_s256_sub(uint64_t result, uint64_t a2, uint64_t a3)
{
  _BOOL1 v3 = *(_OWORD *)result >= *(_OWORD *)a2;
  *(_OWORD *)a3 = *(_OWORD *)result - *(_OWORD *)a2;
  uint64_t v4 = *(void *)(result + 16);
  uint64_t v5 = *(void *)(result + 24);
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = *(void *)(a2 + 24);
  *(void *)(a3 + 16) = v4 - (v6 + !v3);
  *(void *)(a3 + 24) = v5 - (v7 + !__CFSUB__(v4, v6, v3));
  return result;
}

unint64_t *bignum_s128_full_multiply(unint64_t *result, unint64_t *a2, void *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  unint64_t v5 = result[1];
  unsigned long long v6 = *result * (unsigned __int128)*a2 + 0;
  *a3 = *result * *a2;
  unint64_t v8 = result[1] * v3 + *((void *)&v6 + 1);
  unint64_t v7 = (result[1] * (unsigned __int128)v3 + *((unint64_t *)&v6 + 1)) >> 64;
  a3[2] = v7;
  BOOL v9 = a3 + 2;
  *((void *)v9 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v8;
  unint64_t v10 = a2[1];
  unsigned long long v11 = v8 + 0 + *result * (unsigned __int128)v10;
  *((void *)v9 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v8 + *result * v10;
  *BOOL v9 = v7 + *((unint64_t *)&v11 + 1) + result[1] * (unsigned __int128)v10;
  if ((v5 & 0x8000000000000000) == 0)
  {
    if ((v4 & 0x8000000000000000) == 0) {
      return result;
    }
LABEL_5:
    *v9 -= *(_OWORD *)result;
    return result;
  }
  *v9 -= *(_OWORD *)a2;
  if ((v4 & 0x8000000000000000) != 0) {
    goto LABEL_5;
  }
  return result;
}

void bignum_s256_divide(int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, int8x16_t *a4)
{
  unint64_t v4 = a4;
  uint64_t v273 = *MEMORY[0x1E4F143B8];
  int8x16_t v6 = a1[1];
  int8x16_t v265 = *a1;
  uint64x2_t v266 = (uint64x2_t)v6;
  int8x16_t v7 = a2[1];
  int8x16_t v263 = *a2;
  int8x16_t v264 = v7;
  int8x16_t v261 = 0u;
  int8x16_t v262 = 0u;
  uint64_t v8 = a1[1].i64[1];
  unint64_t v9 = a2[1].i64[1] & 0x8000000000000000;
  if (v8 < 0)
  {
    uint64_t v10 = v265.i64[0];
    int8x16_t v11 = vmvnq_s8(v265);
    int8x16_t v265 = v11;
    uint64x2_t v266 = (uint64x2_t)vmvnq_s8((int8x16_t)v266);
    if (v10)
    {
      v265.i64[0] = v11.i64[0] + 1;
    }
    else
    {
      _BOOL1 v71 = __CFADD__(__CFADD__(v265.i64[0], 1), v265.i64[1]);
      *(_OWORD *)&v265 += 1uLL;
      *(_OWORD *)&v266 += v71;
    }
  }
  unint64_t v12 = v8 & 0x8000000000000000;
  if (v9)
  {
    uint64_t v13 = v263.i64[0];
    int8x16_t v14 = vmvnq_s8(v263);
    int8x16_t v263 = v14;
    int8x16_t v264 = vmvnq_s8(v264);
    if (v13)
    {
      v263.i64[0] = v14.i64[0] + 1;
    }
    else
    {
      _BOOL1 v71 = __CFADD__(__CFADD__(v263.i64[0], 1), v263.i64[1]);
      *(_OWORD *)&v263 += 1uLL;
      *(_OWORD *)&v264 += v71;
    }
  }
  uint64_t v15 = 0;
  uint64_t v16 = 3;
  LODWORD(v17) = 256;
  while (1)
  {
    unint64_t v18 = v265.u64[v16];
    if (v18) {
      break;
    }
    --v16;
    v15 -= 64;
    if (v16 == -1) {
      goto LABEL_14;
    }
  }
  uint64_t v17 = __clz(v18) - v15;
LABEL_14:
  uint64_t v19 = 0;
  uint64_t v20 = 3;
  LODWORD(v2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 256;
  while (1)
  {
    unint64_t v22 = v263.u64[v20];
    if (v22) {
      break;
    }
    --v20;
    v19 -= 64;
    if (v20 == -1)
    {
      if (!a3) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
  }
  uint64_t v21 = __clz(v22) - v19;
  if (a3)
  {
LABEL_18:
    *a3 = 0u;
    a3[1] = 0u;
  }
LABEL_19:
  if ((int)v21 < (int)v17)
  {
    if ((&v261 & 0x10) != 0)
    {
      for (uint64_t i = 0; i != 32; i += 16)
        *(int8x16_t *)((char *)&v261 + i) = *(int8x16_t *)((char *)&v265 + i);
    }
    else
    {
      int8x16_t v261 = v265;
      int8x16_t v262 = (int8x16_t)v266;
    }
    goto LABEL_209;
  }
  unsigned int v23 = v21 & 0x3F;
  if ((v21 & 0x3F) != 0)
  {
    uint64x2_t v24 = (uint64x2_t)vdupq_lane_s64(v265.i64[0], 0);
    v24.i64[0] = 0;
    int32x2_t v25 = vdup_n_s32(v23);
    v26.i64[0] = v25.u32[0];
    v26.i64[1] = v25.u32[1];
    uint64x2_t v27 = (uint64x2_t)v26;
    int8x16_t v28 = (int8x16_t)vshlq_u64(v266, (uint64x2_t)v26);
    int8x16_t v29 = (int8x16_t)vshlq_u64((uint64x2_t)v265, (uint64x2_t)v26);
    int32x2_t v30 = vdup_n_s32(64 - v23);
    v26.i64[0] = v30.u32[0];
    v26.i64[1] = v30.u32[1];
    uint64x2_t v31 = (uint64x2_t)vnegq_s64(v26);
    int8x16_t v268 = vorrq_s8((int8x16_t)vshlq_u64((uint64x2_t)vextq_s8(v265, (int8x16_t)v266, 8uLL), v31), v28);
    int8x16_t v267 = vorrq_s8((int8x16_t)vshlq_u64(v24, v31), v29);
    unint64_t v269 = (unint64_t)v266.i64[1] >> -(char)v23;
    uint64x2_t v32 = (uint64x2_t)vdupq_lane_s64(v263.i64[0], 0);
    v32.i64[0] = 0;
    int8x16_t v33 = vorrq_s8((int8x16_t)vshlq_u64((uint64x2_t)vextq_s8(v263, v264, 8uLL), v31), (int8x16_t)vshlq_u64((uint64x2_t)v264, v27));
    int8x16_t v34 = vorrq_s8((int8x16_t)vshlq_u64(v32, v31), (int8x16_t)vshlq_u64((uint64x2_t)v263, v27));
LABEL_26:
    int8x16_t v271 = v34;
    int8x16_t v272 = v33;
    goto LABEL_38;
  }
  if (((unint64_t)&v267 & 0x18) != 0)
  {
    for (uint64_t j = 0; j != 32; j += 16)
      *(int8x16_t *)((char *)&v267 + j) = *(int8x16_t *)((char *)&v265 + j);
  }
  else
  {
    int8x16_t v268 = (int8x16_t)v266;
    int8x16_t v267 = v265;
  }
  unint64_t v269 = 0;
  if (((unint64_t)&v271 & 0x18) == 0)
  {
    int8x16_t v34 = v263;
    int8x16_t v33 = v264;
    goto LABEL_26;
  }
  for (uint64_t k = 0; k != 32; k += 16)
    *(int8x16_t *)((char *)&v271 + k) = *(int8x16_t *)((char *)&v263 + k);
LABEL_38:
  unint64_t v258 = v12;
  unint64_t v259 = v9;
  uint64_t v260 = a4;
  uint64_t v270 = 0;
  uint64_t v38 = 4;
  do
  {
    uint64_t v39 = v38;
    if (v38 == -1) {
      break;
    }
  }
  while (!v267.i64[v38--]);
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  int v43 = &v263;
  uint64_t v44 = 4;
  do
  {
    unint64_t v45 = v44;
    uint64_t v46 = v42;
    int v47 = (uint64_t *)v43;
    uint64_t v48 = v41;
    if (!v44)
    {
      unint64_t v49 = 0;
      goto LABEL_54;
    }
    --v44;
    unint64_t v49 = v271.u64[v45 - 1];
    ++v42;
    int v43 = (int8x16_t *)((char *)v43 - 8);
    v41 -= 8;
  }
  while (!v49);
  if (v45 != 1)
  {
LABEL_54:
    unint64_t v54 = v45 - 1;
    uint64_t v55 = -(uint64_t)v49;
    int v56 = 6;
    uint64_t v57 = -(uint64_t)v49;
    uint64_t v58 = -(uint64_t)v49;
    do
    {
      v57 += ((unint64_t)v57 * (unsigned __int128)(unint64_t)v58) >> 64;
      uint64_t v58 = ((unint64_t)v58 * (unsigned __int128)(unint64_t)v58) >> 64;
      --v56;
    }
    while (v56);
    int v257 = v21 & 0x3F;
    char v59 = 1;
    do
    {
      char v60 = v59;
      uint64_t v57 = (((unint64_t)v57 * (unsigned __int128)(unint64_t)v55) >> 64)
          - v49
          + (((unint64_t)(v55 - v57 + (((unint64_t)v57 * (unsigned __int128)(unint64_t)v55) >> 64))
            * (unsigned __int128)(unint64_t)v57) >> 64);
      char v59 = 0;
    }
    while ((v60 & 1) != 0);
    uint64_t v61 = v39 + 2;
    if (v39 + 2 > v45)
    {
      if (v57 * v55 < v49) {
        uint64_t v62 = v57;
      }
      else {
        uint64_t v62 = v57 + 1;
      }
      do
      {
        uint64_t v63 = v266.i64[v61 + 1];
        unint64_t v64 = v61 - 1;
        unint64_t v65 = v267.u64[v61 - 1];
        if (v49 < 0x8000000000000001)
        {
          unint64_t v69 = v63 & 0x7FFFFFFFFFFFFFFFLL;
          unint64_t v68 = v65 >> 63;
          *((void *)&v72 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v267.i64[v61 - 1];
          *(void *)&long long v72 = v266.i64[v61 + 1];
          uint64_t v67 = v72 >> 63;
        }
        else
        {
          uint64_t v66 = (v65 * (unsigned __int128)(unint64_t)v62) >> 64;
          _BOOL1 v71 = __CFADD__(v66, v65);
          uint64_t v67 = v66 + v65;
          unint64_t v68 = v71;
          unint64_t v69 = v63 - v67 * v49;
          if (v71) {
            unint64_t v70 = (__PAIR128__(v65, v63) - (unint64_t)v67 * (unsigned __int128)v49 - __PAIR128__(v49, 0)) >> 64;
          }
          else {
            unint64_t v70 = (__PAIR128__(v65, v63) - (unint64_t)v67 * (unsigned __int128)v49) >> 64;
          }
          if (v70) {
            _BOOL1 v71 = 1;
          }
          else {
            _BOOL1 v71 = v69 >= v49;
          }
          if (v71)
          {
            do
            {
              unint64_t v68 = (__PAIR128__(v68, v67++) + 1) >> 64;
              unint64_t v70 = (__PAIR128__(v70, v69) - v49) >> 64;
              v69 -= v49;
            }
            while (__PAIR128__(v70, v69) >= v49);
          }
        }
        unint64_t v73 = 0;
        if (v68 && (v67 & 0x8000000000000000) == 0)
        {
          uint64_t v74 = v67 + 1;
          do
          {
            unint64_t v73 = (__PAIR128__(v73, v69) + v49) >> 64;
            v69 += v49;
            --v74;
          }
          while (v74);
          uint64_t v67 = -1;
        }
        if (!v73)
        {
          uint64_t v75 = v271.i64[v45 - 2];
          unint64_t v76 = v75 * v67;
          unint64_t v77 = ((unint64_t)v75 * (unsigned __int128)(unint64_t)v67) >> 64;
          unint64_t v78 = v266.u64[v61];
          BOOL v79 = v69 >= v77;
          if (v69 == v77) {
            BOOL v79 = v78 >= v75 * v67;
          }
          if (!v79)
          {
            --v67;
            _BOOL1 v71 = __CFADD__(v69, v49);
            v69 += v49;
            if (v71) {
              goto LABEL_89;
            }
            unint64_t v76 = v75 * v67;
            unint64_t v77 = ((unint64_t)v75 * (unsigned __int128)(unint64_t)v67) >> 64;
          }
          BOOL v80 = v78 < v76;
          BOOL v81 = v69 == v77;
          LODWORD(v69) = v69 < v77;
          if (v81) {
            unint64_t v69 = v80;
          }
          else {
            unint64_t v69 = v69;
          }
          v67 -= v69;
        }
LABEL_89:
        if (v67)
        {
          int v82 = (unint64_t *)&v267 + v61 - v45 - 1;
          if (v45)
          {
            uint64_t v85 = (*v82 - (0 + v271.u64[0] * (unsigned __int128)(unint64_t)v67)) >> 64;
            *v82 -= v271.i64[0] * v67;
            unint64_t v83 = -v85;
            unint64_t v84 = 1;
            if ((v45 & 2) != 0) {
              goto LABEL_94;
            }
          }
          else
          {
            unint64_t v83 = 0;
            unint64_t v84 = 0;
            if ((v45 & 2) == 0) {
              goto LABEL_95;
            }
LABEL_94:
            uint64_t v86 = &v82[v84];
            unint64_t v87 = (unint64_t *)&v271 + v84;
            unint64_t v88 = v86[1];
            unsigned long long v89 = *v86 - (v83 + *v87 * (unsigned __int128)(unint64_t)v67);
            *uint64_t v86 = v89;
            uint64_t v91 = ((unint64_t)-*((void *)&v89 + 1) + v87[1] * (unsigned __int128)(unint64_t)v67) >> 64;
            unint64_t v90 = v87[1] * v67 - *((void *)&v89 + 1);
            v86[1] = v88 - v90;
            unint64_t v83 = v91 + (v88 < v90);
            v84 |= 2uLL;
          }
LABEL_95:
          if ((v45 & 4) != 0)
          {
            int v92 = &v82[v84];
            uint64_t v93 = (unint64_t *)&v271 + v84;
            unint64_t v94 = v92[1];
            unsigned long long v95 = *v92 - (v83 + *v93 * (unsigned __int128)(unint64_t)v67);
            *int v92 = v95;
            unsigned long long v96 = v94 - ((unint64_t)-*((void *)&v95 + 1) + v93[1] * (unsigned __int128)(unint64_t)v67);
            v92[1] = v94 - (v93[1] * v67 - *((void *)&v95 + 1));
            unint64_t v97 = v92[3];
            unsigned long long v98 = v92[2]
                - ((unint64_t)-*((void *)&v96 + 1)
                 + v93[2] * (unsigned __int128)(unint64_t)v67);
            v92[2] -= v93[2] * v67 - *((void *)&v96 + 1);
            uint64_t v99 = ((unint64_t)-*((void *)&v98 + 1) + v93[3] * (unsigned __int128)(unint64_t)v67) >> 64;
            _BOOL1 v71 = v97 >= v93[3] * v67 - *((void *)&v98 + 1);
            v92[3] = v97 - (v93[3] * v67 - *((void *)&v98 + 1));
            unint64_t v83 = v99 + !v71;
            v84 |= 4uLL;
          }
          if (v84 < v45)
          {
            uint64_t v100 = &v82[v84];
            unint64_t v101 = (unint64_t *)&v271 + v84;
            unint64_t v102 = v100[1];
            unsigned long long v103 = *v100 - (v83 + *v101 * (unsigned __int128)(unint64_t)v67);
            *uint64_t v100 = v103;
            unsigned long long v104 = v102
                 - ((unint64_t)-*((void *)&v103 + 1)
                  + v101[1] * (unsigned __int128)(unint64_t)v67);
            v100[1] = v102 - (v101[1] * v67 - *((void *)&v103 + 1));
            unint64_t v105 = v100[3];
            unsigned long long v106 = v100[2]
                 - ((unint64_t)-*((void *)&v104 + 1)
                  + v101[2] * (unsigned __int128)(unint64_t)v67);
            v100[2] -= v101[2] * v67 - *((void *)&v104 + 1);
            unsigned long long v107 = v105
                 - ((unint64_t)-*((void *)&v106 + 1)
                  + v101[3] * (unsigned __int128)(unint64_t)v67);
            v100[3] = v105 - (v101[3] * v67 - *((void *)&v106 + 1));
            unint64_t v108 = v100[5];
            unsigned long long v109 = v100[4]
                 - ((unint64_t)-*((void *)&v107 + 1)
                  + v101[4] * (unsigned __int128)(unint64_t)v67);
            v100[4] -= v101[4] * v67 - *((void *)&v107 + 1);
            unsigned long long v110 = v108
                 - ((unint64_t)-*((void *)&v109 + 1)
                  + v101[5] * (unsigned __int128)(unint64_t)v67);
            v100[5] = v108 - (v101[5] * v67 - *((void *)&v109 + 1));
            unint64_t v111 = v100[7];
            unsigned long long v112 = v100[6]
                 - ((unint64_t)-*((void *)&v110 + 1)
                  + v101[6] * (unsigned __int128)(unint64_t)v67);
            v100[6] -= v101[6] * v67 - *((void *)&v110 + 1);
            uint64_t v113 = ((unint64_t)-*((void *)&v112 + 1) + v101[7] * (unsigned __int128)(unint64_t)v67) >> 64;
            _BOOL1 v71 = v111 >= v101[7] * v67 - *((void *)&v112 + 1);
            v100[7] = v111 - (v101[7] * v67 - *((void *)&v112 + 1));
            unint64_t v83 = v113 + !v71;
          }
          if (v83 > v267.i64[v64])
          {
            --v67;
            _BOOL1 v71 = __CFADD__(__CFADD__(v271.i64[0], *v82), v82[1]) | __CFADD__(v271.i64[1], (*(_OWORD *)&v271 + *(_OWORD *)v82) >> 64);
            *(_OWORD *)v82 += *(_OWORD *)&v271;
            unint64_t v114 = v82[2];
            BOOL v116 = v71;
            _BOOL1 v71 = __CFADD__(v71, v114);
            unint64_t v115 = v116 + v114;
            unint64_t v117 = v272.i64[1] + (v71 | __CFADD__(v272.i64[0], v115)) + v82[3];
            v82[2] = v272.i64[0] + v115;
            v82[3] = v117;
          }
        }
        if (a3) {
          a3->i64[v61 + ~v45] = v67;
        }
        --v61;
      }
      while (v64 > v45);
    }
    int v118 = v257;
    while (v48 != -32)
    {
      unint64_t v119 = *(unint64_t *)((char *)&v268.u64[1] + v48);
      unint64_t v120 = *(unint64_t *)((char *)&v272.u64[1] + v48);
      if (v119 < v120) {
        break;
      }
      v48 -= 8;
      if (v120 < v119)
      {
        if (v45)
        {
          unint64_t v121 = 1;
          _BOOL1 v71 = v267.i64[0] >= (unint64_t)v271.i64[0];
          v267.i64[0] -= v271.i64[0];
          BOOL v122 = !v71;
          if ((v45 & 2) != 0) {
            goto LABEL_113;
          }
        }
        else
        {
          unint64_t v121 = 0;
          BOOL v122 = 0;
          if ((v45 & 2) == 0) {
            goto LABEL_114;
          }
LABEL_113:
          double v123 = &v267.i64[v121];
          double v124 = &v271.i64[v121];
          uint64_t v125 = v123[1];
          uint64_t v126 = v124[1];
          _BOOL1 v71 = __CFSUB__(v125, v126, __PAIR128__(*v123, !v122) >= __PAIR128__(*v124, 1));
          uint64_t v127 = v125 - (v126 + (__PAIR128__(*v123, !v122) < __PAIR128__(*v124, 1)));
          *v123 -= *v124 + v122;
          v123[1] = v127;
          BOOL v122 = !v71;
          v121 |= 2uLL;
        }
LABEL_114:
        if ((v45 & 4) != 0)
        {
          double v128 = &v267.i64[v121];
          int v129 = &v271.i64[v121];
          uint64_t v130 = v128[1];
          uint64_t v131 = v129[1];
          BOOL v132 = __PAIR128__(*v128, !v122) >= __PAIR128__(*v129, 1);
          _BOOL1 v71 = __CFSUB__(v130, v131, __PAIR128__(*v128, !v122) >= __PAIR128__(*v129, 1));
          *v128 -= *v129 + v122;
          v128[1] = v130 - (v131 + !v132);
          uint64_t v133 = v128[2];
          uint64_t v134 = v128[3];
          uint64_t v135 = v129[2];
          uint64_t v136 = v129[3];
          _BOOL1 v137 = v71;
          _BOOL1 v71 = __CFSUB__(v133, v135, v71);
          v128[2] = v133 - (v135 + !v137);
          v128[3] = v134 - (v136 + !v71);
          BOOL v122 = !__CFSUB__(v134, v136, v71);
          v121 |= 4uLL;
        }
        if (v121 < v45)
        {
          int v138 = &v267.i64[v121];
          int v139 = &v271.i64[v121];
          uint64_t v140 = v138[1];
          uint64_t v141 = v139[1];
          BOOL v142 = __PAIR128__(*v138, !v122) >= __PAIR128__(*v139, 1);
          _BOOL1 v71 = __CFSUB__(v140, v141, __PAIR128__(*v138, !v122) >= __PAIR128__(*v139, 1));
          *v138 -= *v139 + v122;
          v138[1] = v140 - (v141 + !v142);
          uint64_t v143 = v138[2];
          uint64_t v144 = v138[3];
          uint64_t v145 = v139[2];
          uint64_t v146 = v139[3];
          _BOOL1 v148 = v71;
          _BOOL1 v71 = __CFSUB__(v143, v145, v71);
          uint64_t v147 = v143 - (v145 + !v148);
          _BOOL1 v149 = v71;
          _BOOL1 v71 = __CFSUB__(v144, v146, v71);
          v138[2] = v147;
          v138[3] = v144 - (v146 + !v149);
          uint64_t v150 = v138[4];
          uint64_t v151 = v138[5];
          uint64_t v152 = v139[4];
          uint64_t v153 = v139[5];
          _BOOL1 v155 = v71;
          _BOOL1 v71 = __CFSUB__(v150, v152, v71);
          uint64_t v154 = v150 - (v152 + !v155);
          _BOOL1 v156 = v71;
          _BOOL1 v71 = __CFSUB__(v151, v153, v71);
          v138[4] = v154;
          v138[5] = v151 - (v153 + !v156);
          uint64_t v157 = v138[6];
          uint64_t v158 = v138[7];
          uint64_t v159 = v139[6];
          uint64_t v160 = v139[7];
          v138[6] = v157 - (v159 + !v71);
          v138[7] = v158 - (v160 + !__CFSUB__(v157, v159, v71));
        }
        if (a3)
        {
          _BOOL1 v71 = *(_OWORD *)a3 >= 1uLL;
          *(_OWORD *)a3 -= 1uLL;
          uint64_t v161 = a3[1].i64[1] - (*(_OWORD *)&a3[1] < (unsigned __int128)!v71);
          a3[1].i64[0] -= !v71;
          a3[1].i64[1] = v161;
        }
        break;
      }
    }
    if (v45 <= 3)
    {
      unint64_t v162 = 4 - v45;
      int v163 = &v261.i8[8 * v45];
      if ((v163 & 0x18) != 0)
      {
        unint64_t v164 = 0;
        do
        {
          ++v164;
          *v47++ = 0;
        }
        while (v164 < v162);
      }
      else
      {
        unint64_t v164 = 0;
      }
      unint64_t v165 = v164 + 4;
      if (v164 + 4 <= v162)
      {
        int v166 = &v163[8 * v164];
        *(_OWORD *)int v166 = 0u;
        *((_OWORD *)v166 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
        unint64_t v164 = v165;
      }
      if (v164 < v162)
      {
        bzero(&v163[8 * v164], 8 * (v46 - v164));
        int v118 = v257;
      }
    }
    if (!v118)
    {
      unint64_t m = 0;
      if ((&v261 & 0x10) != 0 && v45)
      {
        for (unint64_t m = 0; m < v45; ++m)
          v261.i64[m] = v267.i64[m];
      }
      unint64_t v169 = m + 4;
      if (m + 4 <= v45)
      {
        int v170 = &v267.i8[8 * m];
        long long v171 = *((_OWORD *)v170 + 1);
        int v172 = &v261.i8[8 * m];
        *(_OWORD *)int v172 = *(_OWORD *)v170;
        *((_OWORD *)v172 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v171;
        unint64_t m = v169;
      }
      unint64_t v9 = v259;
      unint64_t v4 = v260;
      unint64_t v12 = v258;
      if (m < v45) {
        memcpy((char *)&v261 + 8 * m, (char *)&v267 + 8 * m, 32 - (8 * m + 8 * v46));
      }
      goto LABEL_209;
    }
    if (v45)
    {
      unint64_t v167 = v267.u64[v54];
      v261.i64[v54] = v167 >> v21;
      if ((v45 & 2) == 0)
      {
LABEL_144:
        if ((v45 & 4) != 0)
        {
          v54 -= 4;
          v177 = &v261.i64[v54];
          uint64_t v178 = &v267.i64[v54];
          unint64_t v179 = *v178;
          unint64_t v180 = v178[1];
          unint64_t v182 = v178[2];
          unint64_t v181 = v178[3];
          uint64_t *v177 = (v180 << -(char)v118) | (v179 >> v21);
          v177[1] = (v182 << -(char)v118) | (v180 >> v21);
          v177[2] = (v181 << -(char)v118) | (v182 >> v21);
          v177[3] = (v181 >> v21) | (v167 << -(char)v118);
          unint64_t v167 = v179;
        }
        unint64_t v9 = v259;
        unint64_t v4 = v260;
        unint64_t v12 = v258;
        if (v54)
        {
          char v183 = 64 - v118;
          char v184 = v21 & 0x3F;
          v185 = (unint64_t *)&v256[8 * v54];
          float v186 = &v267.i64[v54 - 4];
          do
          {
            unint64_t v187 = *(v186 - 4);
            unint64_t v188 = *(v186 - 3);
            unint64_t v189 = *(v186 - 2);
            unint64_t v190 = *(v186 - 1);
            unint64_t v191 = *v186;
            unint64_t v192 = v186[1];
            unint64_t v193 = v186[2];
            unint64_t v194 = v186[3];
            uint64_t v195 = *v186 << v183;
            *(v185 - 4) = (v188 << v183) | (v187 >> v184);
            *(v185 - 3) = (v189 << v183) | (v188 >> v184);
            *(v185 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = (v190 << v183) | (v189 >> v184);
            *(v185 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v195 | (v190 >> v184);
            unint64_t *v185 = (v192 << v183) | (v191 >> v184);
            v185[1] = (v193 << v183) | (v192 >> v184);
            v185[2] = (v194 << v183) | (v193 >> v184);
            v185[3] = (v194 >> v184) | (v167 << v183);
            v185 -= 8;
            v186 -= 8;
            unint64_t v167 = v187;
            v54 -= 8;
          }
          while (v54);
        }
        goto LABEL_209;
      }
    }
    else
    {
      unint64_t v167 = 0;
      unint64_t v54 = v45;
      if ((v45 & 2) == 0) {
        goto LABEL_144;
      }
    }
    v54 -= 2;
    float32x2_t v173 = &v261.i64[v54];
    float v174 = &v267.i64[v54];
    unint64_t v176 = *v174;
    unint64_t v175 = v174[1];
    *float32x2_t v173 = (v175 << -(char)v118) | (v176 >> v21);
    v173[1] = (v175 >> v21) | (v167 << -(char)v118);
    unint64_t v167 = v176;
    goto LABEL_144;
  }
  unint64_t v9 = v259;
  unint64_t v4 = v260;
  unint64_t v12 = v258;
  int8x16_t v261 = 0u;
  int8x16_t v262 = 0u;
  if (!a3)
  {
    if (v263.i64[0])
    {
      unsigned int v50 = __clz(v263.u64[0]);
      unint64_t v196 = v263.i64[0] << v50;
      if (v263.i64[0] << v50 == 0x8000000000000000)
      {
        uint64_t v52 = v263.i64[0] - 1;
        if (v263.i64[0] == 1)
        {
          if (((unint64_t)&v267 & 0x18) != 0)
          {
            for (uint64_t n = 0; n != 32; n += 16)
              *(int8x16_t *)((char *)&v267 + n) = *(int8x16_t *)((char *)&v265 + n);
LABEL_156:
            uint64_t v198 = 0;
          }
          else
          {
            uint64_t v198 = 0;
            int8x16_t v268 = (int8x16_t)v266;
            int8x16_t v267 = v265;
          }
          goto LABEL_208;
        }
        char v222 = v50 ^ 0x3F;
        uint64_t v218 = v265.i64[0];
        v267.i64[0] = (v265.i64[1] << -v222) | ((unint64_t)v265.i64[0] >> v222);
        v267.i64[1] = (v266.i64[0] << -v222) | ((unint64_t)v265.i64[1] >> v222);
        v268.i64[0] = (v266.i64[1] << -v222) | ((unint64_t)v266.i64[0] >> v222);
        v268.i64[1] = (unint64_t)v266.i64[1] >> v222;
LABEL_167:
        uint64_t v198 = v218 & v52;
        goto LABEL_208;
      }
      if (v50)
      {
        uint64x2_t v210 = (uint64x2_t)vdupq_lane_s64(v265.i64[0], 0);
        v210.i64[0] = 0;
        int32x2_t v211 = vdup_n_s32(v50);
        v212.i64[0] = v211.u32[0];
        v212.i64[1] = v211.u32[1];
        int8x16_t v213 = (int8x16_t)vshlq_u64(v266, v212);
        int8x16_t v214 = (int8x16_t)vshlq_u64((uint64x2_t)v265, v212);
        int32x2_t v215 = vdup_n_s32(64 - v50);
        v212.i64[0] = v215.u32[0];
        v212.i64[1] = v215.u32[1];
        uint64x2_t v216 = (uint64x2_t)vnegq_s64((int64x2_t)v212);
        int8x16_t v268 = vorrq_s8((int8x16_t)vshlq_u64((uint64x2_t)vextq_s8(v265, (int8x16_t)v266, 8uLL), v216), v213);
        int8x16_t v267 = vorrq_s8((int8x16_t)vshlq_u64(v210, v216), v214);
        unint64_t v209 = (unint64_t)v266.i64[1] >> -(char)v50;
      }
      else if (((unint64_t)&v267 & 0x18) != 0)
      {
        for (iuint64_t i = 0; ii != 32; ii += 16)
          *(int8x16_t *)((char *)&v267 + ii) = *(int8x16_t *)((char *)&v265 + ii);
        unint64_t v209 = 0;
      }
      else
      {
        unint64_t v209 = 0;
        int8x16_t v268 = (int8x16_t)v266;
        int8x16_t v267 = v265;
      }
      uint64_t v237 = -(uint64_t)v196;
      int v238 = 6;
      uint64_t v239 = -(uint64_t)v196;
      uint64_t v240 = -(uint64_t)v196;
      do
      {
        v239 += ((unint64_t)v239 * (unsigned __int128)(unint64_t)v240) >> 64;
        uint64_t v240 = ((unint64_t)v240 * (unsigned __int128)(unint64_t)v240) >> 64;
        --v238;
      }
      while (v238);
      char v241 = 1;
      do
      {
        char v242 = v241;
        uint64_t v239 = (((unint64_t)v239 * (unsigned __int128)(unint64_t)v237) >> 64)
             - v196
             + (((unint64_t)(v237
                                  - v239
                                  + (((unint64_t)v239 * (unsigned __int128)(unint64_t)v237) >> 64))
               * (unsigned __int128)(unint64_t)v239) >> 64);
        char v241 = 0;
      }
      while ((v242 & 1) != 0);
      if (v239 * v237 < v196) {
        uint64_t v243 = v239;
      }
      else {
        uint64_t v243 = v239 + 1;
      }
      uint64_t v244 = 4;
      do
      {
        --v244;
        uint64_t v245 = v209 + ((v209 * (unsigned __int128)(unint64_t)v243) >> 64);
        unint64_t v246 = (__PAIR128__(v209, v267.i64[v244]) - (unint64_t)v245 * (unsigned __int128)v196) >> 64;
        unint64_t v209 = v267.i64[v244] - v245 * v196;
        if (v246) {
          BOOL v247 = 1;
        }
        else {
          BOOL v247 = v209 >= v196;
        }
        if (v247)
        {
          do
          {
            ++v245;
            unint64_t v246 = (__PAIR128__(v246, v209) - v196) >> 64;
            v209 -= v196;
          }
          while (__PAIR128__(v246, v209) >= v196);
        }
        v267.i64[v244] = v245;
      }
      while (v244);
LABEL_207:
      uint64_t v198 = v209 >> v50;
      goto LABEL_208;
    }
LABEL_223:
    __break(1u);
    return;
  }
  if (!v263.i64[0]) {
    goto LABEL_223;
  }
  unsigned int v50 = __clz(v263.u64[0]);
  unint64_t v51 = v263.i64[0] << v50;
  if (v263.i64[0] << v50 != 0x8000000000000000)
  {
    if (v50)
    {
      unint64_t v199 = v266.u64[1];
      uint64x2_t v200 = (uint64x2_t)vdupq_lane_s64(v265.i64[0], 0);
      v200.i64[0] = 0;
      int32x2_t v201 = vdup_n_s32(v50);
      v202.i64[0] = v201.u32[0];
      v202.i64[1] = v201.u32[1];
      int8x16_t v203 = (int8x16_t)vshlq_u64(v266, v202);
      int8x16_t v204 = (int8x16_t)vshlq_u64((uint64x2_t)v265, v202);
      int32x2_t v205 = vdup_n_s32(64 - v50);
      v202.i64[0] = v205.u32[0];
      v202.i64[1] = v205.u32[1];
      uint64x2_t v206 = (uint64x2_t)vnegq_s64((int64x2_t)v202);
      int8x16_t v207 = vorrq_s8((int8x16_t)vshlq_u64(v200, v206), v204);
      int8x16_t v208 = vorrq_s8((int8x16_t)vshlq_u64((uint64x2_t)vextq_s8(v265, (int8x16_t)v266, 8uLL), v206), v203);
      *a3 = v207;
      a3[1] = v208;
      unint64_t v209 = v199 >> -(char)v50;
    }
    else if ((a3 & 0x1F) != 0)
    {
      for (uint64_t jj = 0; jj != 2; ++jj)
        a3[jj] = *(int8x16_t *)((char *)&v265 + jj * 16);
      unint64_t v209 = 0;
    }
    else
    {
      unint64_t v209 = 0;
      int8x16_t v225 = (int8x16_t)v266;
      *a3 = v265;
      a3[1] = v225;
    }
    uint64_t v226 = -(uint64_t)v51;
    int v227 = 6;
    uint64_t v228 = -(uint64_t)v51;
    uint64_t v229 = -(uint64_t)v51;
    do
    {
      v228 += ((unint64_t)v228 * (unsigned __int128)(unint64_t)v229) >> 64;
      uint64_t v229 = ((unint64_t)v229 * (unsigned __int128)(unint64_t)v229) >> 64;
      --v227;
    }
    while (v227);
    char v230 = 1;
    do
    {
      char v231 = v230;
      uint64_t v228 = (((unint64_t)v228 * (unsigned __int128)(unint64_t)v226) >> 64)
           - v51
           + (((unint64_t)(v226
                                - v228
                                + (((unint64_t)v228 * (unsigned __int128)(unint64_t)v226) >> 64))
             * (unsigned __int128)(unint64_t)v228) >> 64);
      char v230 = 0;
    }
    while ((v231 & 1) != 0);
    if (v228 * v226 < v51) {
      uint64_t v232 = v228;
    }
    else {
      uint64_t v232 = v228 + 1;
    }
    uint64_t v233 = 4;
    do
    {
      --v233;
      uint64_t v234 = v209 + ((v209 * (unsigned __int128)(unint64_t)v232) >> 64);
      unint64_t v235 = (__PAIR128__(v209, a3->i64[v233]) - (unint64_t)v234 * (unsigned __int128)v51) >> 64;
      unint64_t v209 = a3->i64[v233] - v234 * v51;
      if (v235) {
        BOOL v236 = 1;
      }
      else {
        BOOL v236 = v209 >= v51;
      }
      if (v236)
      {
        do
        {
          ++v234;
          unint64_t v235 = (__PAIR128__(v235, v209) - v51) >> 64;
          v209 -= v51;
        }
        while (__PAIR128__(v235, v209) >= v51);
      }
      a3->i64[v233] = v234;
    }
    while (v233);
    goto LABEL_207;
  }
  uint64_t v52 = v263.i64[0] - 1;
  if (v263.i64[0] != 1)
  {
    char v217 = v50 ^ 0x3F;
    uint64_t v218 = v265.i64[0];
    int8x16_t v219 = (int8x16_t)v266;
    unint64_t v220 = (v266.i64[0] << -v217) | ((unint64_t)v265.i64[1] >> v217);
    a3->i64[0] = (v265.i64[1] << -v217) | ((unint64_t)v265.i64[0] >> v217);
    a3->i64[1] = v220;
    a3[1].i64[0] = (v219.i64[1] << -v217) | ((unint64_t)v219.i64[0] >> v217);
    a3[1].i64[1] = (unint64_t)v219.i64[1] >> v217;
    goto LABEL_167;
  }
  if ((a3 & 0x1F) != 0)
  {
    for (kuint64_t k = 0; kk != 2; ++kk)
      a3[kk] = *(int8x16_t *)((char *)&v265 + kk * 16);
    goto LABEL_156;
  }
  uint64_t v198 = 0;
  int8x16_t v224 = (int8x16_t)v266;
  *a3 = v265;
  a3[1] = v224;
LABEL_208:
  v261.i64[0] = v198;
LABEL_209:
  if (v12 == v9)
  {
    if (!v12) {
      goto LABEL_211;
    }
LABEL_216:
    uint64_t v252 = v261.i64[0];
    int8x16_t v253 = vmvnq_s8(v261);
    int8x16_t v261 = v253;
    int8x16_t v262 = vmvnq_s8(v262);
    if (v252)
    {
      v261.i64[0] = v253.i64[0] + 1;
      if (!v4) {
        return;
      }
LABEL_212:
      int8x16_t v248 = v262;
      *unint64_t v4 = v261;
      v4[1] = v248;
      return;
    }
    _BOOL1 v71 = __CFADD__(__CFADD__(v261.i64[0], 1), v261.i64[1]);
    *(_OWORD *)&v261 += 1uLL;
    *(_OWORD *)&v262 += v71;
    if (v4) {
      goto LABEL_212;
    }
  }
  else
  {
    uint64_t v249 = a3->i64[0];
    int8x16_t v250 = vmvnq_s8(a3[1]);
    int8x16_t v251 = vmvnq_s8(*a3);
    *a3 = v251;
    a3[1] = v250;
    if (v249)
    {
      a3->i64[0] = v251.i64[0] + 1;
      if (v12) {
        goto LABEL_216;
      }
    }
    else
    {
      _BOOL1 v71 = __CFADD__(__CFADD__(a3->i64[0], 1), a3->i64[1]);
      *(_OWORD *)a3 += 1uLL;
      uint64_t v254 = a3[1].i64[0];
      uint64_t v255 = a3[1].i64[1];
      a3[1].i64[0] = v71 + v254;
      a3[1].i64[1] = __CFADD__(v71, v254) + v255;
      if (v12) {
        goto LABEL_216;
      }
    }
LABEL_211:
    if (v4) {
      goto LABEL_212;
    }
  }
}

PC_Sp_counted_base *PC_Sp_counted_base::destroy(PC_Sp_counted_base *this)
{
  if (this) {
    return (PC_Sp_counted_base *)(*(uint64_t (**)(void))(*(void *)this + 8))();
  }
  return this;
}

PC_Sp_counted_base *PC_Sp_counted_base::release(PC_Sp_counted_base *this)
{
  if (atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF) == 1)
  {
    uint64_t v1 = this;
    uint64_t v2 = (PCMutex *)((char *)this + 16);
    (*(void (**)(PC_Sp_counted_base *))(*(void *)this + 16))(this);
    PCMutex::lock(v2);
    PCMutex::unlock(v2);
    return PC_Sp_counted_base::weak_release(v1);
  }
  return this;
}

PC_Sp_counted_base *PC_Sp_counted_base::weak_release(PC_Sp_counted_base *this)
{
  if (atomic_fetch_add((atomic_uint *volatile)this + 3, 0xFFFFFFFF) == 1)
  {
    uint64_t v1 = this;
    uint64_t v2 = (PCMutex *)((char *)this + 16);
    PCMutex::lock((PCMutex *)((char *)this + 16));
    PCMutex::unlock(v2);
    unint64_t v3 = *(uint64_t (**)(PC_Sp_counted_base *))(*(void *)v1 + 24);
    return (PC_Sp_counted_base *)v3(v1);
  }
  return this;
}

uint64_t PC_Sp_counted_base_impl::dispose(PC_Sp_counted_base_impl *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 11) + 16))();
}

void PCSharedCount::PCSharedCount(PCSharedCount *this)
{
  this->var0 = 0;
}

void PCSharedCount::PCSharedCount(PCSharedCount *this, PCShared_base *a2)
{
  if (a2)
  {
    PCWeakCount::alloc((void *)a2 + 1, a2);
    uint64_t v4 = *((void *)a2 + 1);
    this->var0 = (PC_Sp_counted_base *)v4;
    if (v4)
    {
      if (!atomic_fetch_add((atomic_uint *volatile)(v4 + 8), 1u)) {
        atomic_fetch_add((atomic_uint *volatile)(v4 + 12), 1u);
      }
    }
  }
  else
  {
    this->var0 = 0;
  }
}

void PCSharedCount::PCSharedCount(PCSharedCount *this, const PCSharedCount *a2)
{
  var0 = a2->var0;
  this->var0 = a2->var0;
  if (var0)
  {
    if (!atomic_fetch_add((atomic_uint *volatile)var0 + 2, 1u)) {
      atomic_fetch_add((atomic_uint *volatile)var0 + 3, 1u);
    }
  }
}

void PCSharedCount::~PCSharedCount(PCSharedCount *this)
{
  var0 = this->var0;
  if (var0) {
    PC_Sp_counted_base::release(var0);
  }
}

uint64_t *PCSharedCount::operator=(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = *result;
  *CGColorSpaceRef result = v2;
  return result;
}

BOOL PCSharedCount::unique(PCSharedCount *this)
{
  if (!this->var0) {
    return 0;
  }
  unsigned int v1 = atomic_load((unsigned int *)this->var0 + 2);
  return v1 == 1;
}

void PC_Sp_counted_base_impl::~PC_Sp_counted_base_impl(PC_Sp_counted_base_impl *this)
{
  *(void *)this = &unk_1F10C3D18;
  PCMutex::~PCMutex((PCMutex *)((char *)this + 16));
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F10C3D18;
  PCMutex::~PCMutex((PCMutex *)((char *)this + 16));

  JUMPOUT(0x1BA9BFBA0);
}

void *PCWeakCount::alloc(void *this, PCShared_base *a2)
{
  if (!*this) {
    operator new();
  }
  return this;
}

void sub_1B76BEEAC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40A4C9ED57);
  _Unwind_Resume(a1);
}

uint64_t PCSingleton::getSingletons(PCSingleton *this)
{
  {
    operator new();
  }
  return PCSingleton::getSingletons(void)::singletons;
}

void sub_1B76BEF48(_Unwind_Exception *a1)
{
}

uint64_t PCSingleton::getLock(PCSingleton *this)
{
  {
    operator new();
  }
  return PCSingleton::getLock(void)::lock;
}

void sub_1B76BEFDC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

void PCSingleton::PCSingleton(PCSingleton *this, int a2)
{
  *(void *)this = &unk_1F10C3DA0;
  Locuint64_t k = (PCMutex *)PCSingleton::getLock(this);
  unint64_t v5 = (PCSingleton *)PCMutex::lock(Lock);
  Singletons = (void **)PCSingleton::getSingletons(v5);
  int8x16_t v7 = (char *)Singletons[2];
  uint64_t v8 = (char *)Singletons[1];
  if (v8 >= v7)
  {
    uint64_t v10 = (v8 - (unsigned char *)*Singletons) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v7 - (unsigned char *)*Singletons;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13) {
      int8x16_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)(Singletons + 2), v13);
    }
    else {
      int8x16_t v14 = 0;
    }
    uint64_t v15 = &v14[16 * v10];
    uint64_t v16 = &v14[16 * v13];
    *(void *)uint64_t v15 = this;
    *((_DWORD *)v15 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a2;
    unint64_t v9 = v15 + 16;
    unint64_t v18 = (char *)*Singletons;
    uint64_t v17 = (char *)Singletons[1];
    if (v17 != *Singletons)
    {
      do
      {
        *((_OWORD *)v15 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *((_OWORD *)v17 - 1);
        v15 -= 16;
        v17 -= 16;
      }
      while (v17 != v18);
      uint64_t v17 = (char *)*Singletons;
    }
    *Singletons = v15;
    Singletons[1] = v9;
    Singletons[2] = v16;
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    *(void *)uint64_t v8 = this;
    *((_DWORD *)v8 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a2;
    unint64_t v9 = v8 + 16;
  }
  Singletons[1] = v9;
  PCMutex::unlock(Lock);
}

void sub_1B76BF160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void PCSingleton::~PCSingleton(PCSingleton *this)
{
  *(void *)this = &unk_1F10C3DA0;
  Locuint64_t k = (PCMutex *)PCSingleton::getLock(this);
  unint64_t v3 = (PCSingleton *)PCMutex::lock(Lock);
  Singletons = (char **)PCSingleton::getSingletons(v3);
  int8x16_t v6 = *Singletons;
  unint64_t v5 = Singletons[1];
  if (*Singletons != v5)
  {
    uint64_t v7 = 0;
    while (*(PCSingleton **)&v6[v7] != this)
    {
      v7 += 16;
      if (&v6[v7] == v5) {
        goto LABEL_9;
      }
    }
    uint64_t v8 = &v6[v7];
    unint64_t v9 = &v6[v7 + 16];
    int64_t v10 = v5 - v9;
    if (v5 != v9) {
      memmove(&v6[v7], v9, v5 - v9);
    }
    Singletons[1] = &v8[v10];
  }
LABEL_9:
  PCMutex::unlock(Lock);
}

{
  uint64_t vars8;

  PCSingleton::~PCSingleton(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PCSingleton::deleteSingletons(PCSingleton *this)
{
  unsigned int v1 = 0;
  do
  {
    std::string __p = 0;
    uint64x2_t v27 = 0;
    uint64_t v28 = 0;
    Locuint64_t k = (PCMutex *)PCSingleton::getLock(this);
    uint64x2_t v24 = Lock;
    unint64_t v3 = (PCSingleton *)PCMutex::lock(Lock);
    char v25 = 1;
    Singletons = (char *)PCSingleton::getSingletons(v3);
    if (&__p != (void **)Singletons) {
      Singletons = std::vector<PCSingleton::Info>::__assign_with_size[abi:ne180100]<PCSingleton::Info*,PCSingleton::Info*>((char *)&__p, *(char **)Singletons, *((void *)Singletons + 1), (uint64_t)(*((void *)Singletons + 1) - *(void *)Singletons) >> 4);
    }
    unint64_t v5 = (void *)PCSingleton::getSingletons((PCSingleton *)Singletons);
    v5[1] = *v5;
    PCMutex::unlock(Lock);
    unint64_t v6 = 126 - 2 * __clz(((char *)v27 - (unsigned char *)__p) >> 4);
    if (v27 == __p) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = v6;
    }
    std::__introsort<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *,false>((unint64_t)__p, v27, (uint64_t)&v24, v7, 1);
LABEL_8:
    unint64_t v9 = v27;
    while (__p != v9)
    {
      int64_t v10 = (PCSingleton *)v9[-1].n128_u64[0];
      --v9;
      uint64_t v8 = v10;
      uint64x2_t v27 = v9;
      if (v10)
      {
        uint64_t v8 = (PCSingleton *)(*(uint64_t (**)(PCSingleton *))(*(void *)v8 + 8))(v8);
        goto LABEL_8;
      }
    }
    unint64_t v11 = (PCMutex *)PCSingleton::getLock(v8);
    uint64x2_t v24 = v11;
    uint64_t v12 = (PCSingleton *)PCMutex::lock(v11);
    char v25 = 1;
    unint64_t v13 = (uint64_t *)PCSingleton::getSingletons(v12);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    PCMutex::unlock(v11);
    this = (PCSingleton *)__p;
    if (__p)
    {
      uint64x2_t v27 = (__n128 *)__p;
      operator delete(__p);
    }
    if (v14 == v15) {
      break;
    }
  }
  while (v1++ < 5);
  if (v14 != v15)
  {
    uint64_t v17 = (void *)MEMORY[0x1E4FBA250];
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"ProCore: PCSingleton could not successfully release all singletons in ", 70);
    unint64_t v18 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"tries.\n", 7);
    this = (PCSingleton *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"This is caused by singletons being created during the application teardown process.\n", 84);
  }
  uint64_t v19 = PCSingleton::getSingletons(this);
  uint64_t v20 = *(void **)v19;
  if (*(void *)v19)
  {
    *(void *)(v19 + 8) = v20;
    operator delete(v20);
  }
  uint64_t v21 = (PCSingleton *)MEMORY[0x1BA9BFBA0](v19, 0x20C40960023A9);
  uint64_t v22 = PCSingleton::getLock(v21);
  return (*(uint64_t (**)(uint64_t))(*(void *)v22 + 8))(v22);
}

void sub_1B76BF47C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
  {
    a13 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

char *std::vector<PCSingleton::Info>::__assign_with_size[abi:ne180100]<PCSingleton::Info*,PCSingleton::Info*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    CGColorSpaceRef result = std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__vallocate[abi:ne180100](v7, v11);
    unint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    unint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    CGColorSpaceRef result = (char *)memmove(*(void **)result, __src, v14 - v9);
    unint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    CGColorSpaceRef result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *,false>(unint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, char a5)
{
_DWORD *std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(_DWORD *result, void *a2)
{
  if (result != (_DWORD *)a2)
  {
    uint64_t v2 = result + 4;
    if (result + 4 != (_DWORD *)a2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = result;
      do
      {
        char v5 = v2;
        unsigned int v6 = v4[6];
        if (v6 > v4[2])
        {
          uint64_t v7 = *v5;
          int v8 = v4[7];
          uint64_t v9 = v3;
          while (1)
          {
            *(_OWORD *)((char *)result + v9 + 16) = *(_OWORD *)((char *)result + v9);
            if (!v9) {
              break;
            }
            unsigned int v10 = *(_DWORD *)((char *)result + v9 - 8);
            v9 -= 16;
            if (v6 <= v10)
            {
              uint64_t v11 = (uint64_t)result + v9 + 16;
              goto LABEL_10;
            }
          }
          uint64_t v11 = (uint64_t)result;
LABEL_10:
          *(void *)uint64_t v11 = v7;
          *(_DWORD *)(v11 + 8) = v6;
          *(_DWORD *)(v11 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v8;
        }
        uint64_t v2 = v5 + 2;
        v3 += 16;
        uint64_t v4 = v5;
      }
      while (v5 + 2 != a2);
    }
  }
  return result;
}

_DWORD *std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(_DWORD *result, _DWORD *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 4;
    while (v2 != (void *)a2)
    {
      uint64_t v3 = v2;
      unsigned int v4 = result[6];
      if (v4 > result[2])
      {
        uint64_t v5 = *v3;
        int v6 = result[7];
        uint64_t v7 = v3;
        do
        {
          *(_OWORD *)uint64_t v7 = *((_OWORD *)v7 - 1);
          unsigned int v8 = *((_DWORD *)v7 - 6);
          v7 -= 2;
        }
        while (v4 > v8);
        *uint64_t v7 = v5;
        *((_DWORD *)v7 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v4;
        *((_DWORD *)v7 + 3) = v6;
      }
      uint64_t v2 = v3 + 2;
      CGColorSpaceRef result = v3;
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(long long *a1, long long *a2, long long *a3)
{
  unsigned int v3 = *((_DWORD *)a2 + 2);
  unsigned int v4 = *((_DWORD *)a3 + 2);
  if (v3 > *((_DWORD *)a1 + 2))
  {
    if (v4 > v3)
    {
      long long v5 = *a1;
      *a1 = *a3;
      *a3 = v5;
      return 1;
    }
    long long v8 = *a1;
    *a1 = *a2;
    *a2 = v8;
    if (*((_DWORD *)a3 + 2) <= *((_DWORD *)a2 + 2)) {
      return 1;
    }
    long long v9 = *a2;
    *a2 = *a3;
    *a3 = v9;
    return 2;
  }
  if (v4 > v3)
  {
    long long v6 = *a2;
    *a2 = *a3;
    *a3 = v6;
    if (*((_DWORD *)a2 + 2) <= *((_DWORD *)a1 + 2)) {
      return 1;
    }
    long long v7 = *a1;
    *a1 = *a2;
    *a2 = v7;
    return 2;
  }
  return 0;
}

unint64_t std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Info *,PCSingleton::Compare &>(void *a1, _OWORD *a2)
{
  uint64_t v2 = a1[1];
  if (v2 <= *((_DWORD *)a2 - 2))
  {
    long long v6 = a1 + 2;
    do
    {
      unint64_t v4 = (unint64_t)v6;
      if (v6 >= (void *)a2) {
        break;
      }
      unsigned int v7 = *((_DWORD *)v6 + 2);
      v6 += 2;
    }
    while (v2 <= v7);
  }
  else
  {
    unsigned int v3 = a1;
    do
    {
      unint64_t v4 = (unint64_t)(v3 + 2);
      unsigned int v5 = *((_DWORD *)v3 + 6);
      v3 += 2;
    }
    while (v2 <= v5);
  }
  if (v4 >= (unint64_t)a2)
  {
    long long v8 = a2;
  }
  else
  {
    do
    {
      long long v8 = a2 - 1;
      unsigned int v9 = *((_DWORD *)a2-- - 2);
    }
    while (v2 > v9);
  }
  uint64_t v10 = *a1;
  while (v4 < (unint64_t)v8)
  {
    long long v14 = *(_OWORD *)v4;
    *(_OWORD *)unint64_t v4 = *v8;
    *long long v8 = v14;
    do
    {
      unsigned int v11 = *(_DWORD *)(v4 + 24);
      v4 += 16;
    }
    while (v2 <= v11);
    do
      unsigned int v12 = *((_DWORD *)v8-- - 2);
    while (v2 > v12);
  }
  if ((void *)(v4 - 16) != a1) {
    *(_OWORD *)a1 = *(_OWORD *)(v4 - 16);
  }
  *(void *)(v4 - 16) = v10;
  *(void *)(v4 - 8) = v2;
  return v4;
}

unint64_t std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Info *,PCSingleton::Compare &>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  do
  {
    unsigned int v5 = a1[v2 + 3];
    v2 += 2;
  }
  while (v5 > v4);
  long long v6 = &a1[v2];
  if (v2 == 2)
  {
    while (v6 < a2)
    {
      unsigned int v7 = a2 - 2;
      unsigned int v9 = *((_DWORD *)a2 - 2);
      a2 -= 2;
      if (v9 > v4) {
        goto LABEL_9;
      }
    }
    unsigned int v7 = a2;
  }
  else
  {
    do
    {
      unsigned int v7 = a2 - 2;
      unsigned int v8 = *((_DWORD *)a2 - 2);
      a2 -= 2;
    }
    while (v8 <= v4);
  }
LABEL_9:
  unint64_t v10 = (unint64_t)v6;
  if (v6 < v7)
  {
    unsigned int v11 = v7;
    do
    {
      long long v12 = *(_OWORD *)v10;
      *(_OWORD *)unint64_t v10 = *(_OWORD *)v11;
      *(_OWORD *)unsigned int v11 = v12;
      do
      {
        unsigned int v13 = *(_DWORD *)(v10 + 24);
        v10 += 16;
      }
      while (v13 > v4);
      do
      {
        unsigned int v14 = *((_DWORD *)v11 - 2);
        v11 -= 2;
      }
      while (v14 <= v4);
    }
    while (v10 < (unint64_t)v11);
  }
  if ((uint64_t *)(v10 - 16) != a1) {
    *(_OWORD *)a1 = *(_OWORD *)(v10 - 16);
  }
  *(void *)(v10 - 16) = v3;
  *(void *)(v10 - 8) = v4;
  return v10 - 16;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(_DWORD *)(a2 - 8) > *(_DWORD *)(a1 + 8))
      {
        long long v6 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)(a2 - 16) = v6;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((long long *)a1, (long long *)(a1 + 16), (long long *)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((__n128 *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      uint64_t v7 = a1 + 32;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((long long *)a1, (long long *)(a1 + 16), (long long *)(a1 + 32));
      uint64_t v8 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    unsigned int v11 = *(_DWORD *)(v8 + 8);
    if (v11 > *(_DWORD *)(v7 + 8))
    {
      uint64_t v12 = *(void *)v8;
      int v13 = *(_DWORD *)(v8 + 12);
      uint64_t v14 = v9;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        unsigned int v15 = *(_DWORD *)(a1 + v14 + 24);
        v14 -= 16;
        if (v11 <= v15)
        {
          uint64_t v16 = a1 + v14 + 48;
          goto LABEL_12;
        }
      }
      uint64_t v16 = a1;
LABEL_12:
      *(void *)uint64_t v16 = v12;
      *(_DWORD *)(v16 + 8) = v11;
      *(_DWORD *)(v16 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v13;
      if (++v10 == 8) {
        return v8 + 16 == a2;
      }
    }
    uint64_t v7 = v8;
    v9 += 16;
    v8 += 16;
    if (v8 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((long long *)a1, (long long *)a2, (long long *)a3);
  if (*(_DWORD *)(a4 + 8) > *(_DWORD *)(a3 + 8))
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(__n128 *)a4 = result;
    if (*(_DWORD *)(a3 + 8) > *(_DWORD *)(a2 + 8))
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (*(_DWORD *)(a2 + 8) > *(_DWORD *)(a1 + 8))
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  result.n128_u64[0] = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>((uint64_t)a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4).n128_u64[0];
  if (a5->n128_u32[2] > a4->n128_u32[2])
  {
    __n128 result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (a4->n128_u32[2] > a3->n128_u32[2])
    {
      __n128 result = *a3;
      *a3 = *a4;
      *a4 = result;
      if (a3->n128_u32[2] > a2->n128_u32[2])
      {
        __n128 result = *a2;
        *a2 = *a3;
        *a3 = result;
        if (a2->n128_u32[2] > a1->n128_u32[2])
        {
          __n128 result = *a1;
          *a1 = *a2;
          *a2 = result;
        }
      }
    }
  }
  return result;
}

_OWORD *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *,PCSingleton::Info *>(uint64_t a1, _OWORD *a2, _OWORD *a3, uint64_t a4)
{
  if ((_OWORD *)a1 != a2)
  {
    long long v6 = a2;
    uint64_t v8 = (uint64_t)a2 - a1;
    uint64_t v9 = ((uint64_t)a2 - a1) >> 4;
    if ((uint64_t)a2 - a1 >= 17)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = (uint64_t *)(a1 + 16 * v10);
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    int v13 = v6;
    if (v6 != a3)
    {
      uint64_t v14 = v6;
      do
      {
        if (*((_DWORD *)v14 + 2) > *(_DWORD *)(a1 + 8))
        {
          long long v15 = *v14;
          *uint64_t v14 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(a1, a4, v9, (uint64_t *)a1);
        }
        ++v14;
      }
      while (v14 != a3);
      int v13 = a3;
    }
    if (v8 >= 17)
    {
      uint64_t v16 = (unint64_t)v8 >> 4;
      do
      {
        uint64_t v17 = 0;
        long long v26 = *(_OWORD *)a1;
        unint64_t v18 = (_OWORD *)a1;
        do
        {
          char v19 = &v18[v17 + 1];
          uint64_t v20 = (2 * v17) | 1;
          uint64_t v21 = 2 * v17 + 2;
          if (v21 < v16)
          {
            unsigned int v22 = *((_DWORD *)v19 + 2);
            unsigned int v23 = *((_DWORD *)v19 + 6);
            v19 += v22 > v23;
            if (v22 > v23) {
              uint64_t v20 = v21;
            }
          }
          *unint64_t v18 = *v19;
          unint64_t v18 = v19;
          uint64_t v17 = v20;
        }
        while (v20 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v19 == --v6)
        {
          *char v19 = v26;
        }
        else
        {
          *char v19 = *v6;
          *long long v6 = v26;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(a1, (uint64_t)(v19 + 1), a4, ((uint64_t)v19 - a1 + 16) >> 4);
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 4)
    {
      uint64_t v6 = v4 >> 3;
      uint64_t v7 = (v4 >> 3) + 1;
      uint64_t v8 = (uint64_t *)(result + 16 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3)
      {
        unsigned int v10 = *((_DWORD *)v8 + 2);
        unsigned int v11 = *((_DWORD *)v8 + 6);
        v8 += 2 * (v10 > v11);
        if (v10 > v11) {
          uint64_t v7 = v9;
        }
      }
      unsigned int v12 = *((_DWORD *)a4 + 2);
      if (*((_DWORD *)v8 + 2) <= v12)
      {
        uint64_t v13 = *a4;
        int v14 = *((_DWORD *)a4 + 3);
        do
        {
          long long v15 = a4;
          a4 = v8;
          *long long v15 = *(_OWORD *)v8;
          if (v5 < v7) {
            break;
          }
          uint64_t v16 = (2 * v7) | 1;
          uint64_t v8 = (uint64_t *)(result + 16 * v16);
          uint64_t v17 = 2 * v7 + 2;
          if (v17 < a3)
          {
            unsigned int v18 = *((_DWORD *)v8 + 2);
            unsigned int v19 = *((_DWORD *)v8 + 6);
            v8 += 2 * (v18 > v19);
            if (v18 > v19) {
              uint64_t v16 = v17;
            }
          }
          uint64_t v7 = v16;
        }
        while (*((_DWORD *)v8 + 2) <= v12);
        *a4 = v13;
        *((_DWORD *)a4 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v12;
        *((_DWORD *)a4 + 3) = v14;
      }
    }
  }
  return result;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,PCSingleton::Compare &,PCSingleton::Info *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v5 = v4 >> 1;
    unsigned int v6 = *(_DWORD *)(result + 16 * (v4 >> 1) + 8);
    unsigned int v7 = *(_DWORD *)(a2 - 8);
    if (v6 > v7)
    {
      uint64_t v10 = *(void *)(a2 - 16);
      uint64_t v8 = a2 - 16;
      uint64_t v9 = v10;
      int v11 = *(_DWORD *)(v8 + 12);
      do
      {
        unsigned int v12 = (_OWORD *)v8;
        uint64_t v8 = result + 16 * v5;
        *unsigned int v12 = *(_OWORD *)v8;
        if (!v5) {
          break;
        }
        unint64_t v5 = (v5 - 1) >> 1;
      }
      while (*(_DWORD *)(result + 16 * v5 + 8) > v7);
      *(void *)uint64_t v8 = v9;
      *(_DWORD *)(v8 + 8) = v7;
      *(_DWORD *)(v8 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v11;
    }
  }
  return result;
}

void PCGetDescriptionForProfile(uint64_t a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  v4[0] = &unk_1F10C3DD0;
  v4[1] = a1;
  std::string::size_type v6 = 0;
  long long __p = 0uLL;
  (*(void (**)(uint64_t, void *))(*(void *)a2 + 24))(a2, v4);
  if (SHIBYTE(v6) < 0)
  {
    std::string::__init_copy_ctor_external(a3, (const std::string::value_type *)__p, *((std::string::size_type *)&__p + 1));
    v4[0] = &unk_1F10C3DD0;
    if (SHIBYTE(v6) < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = __p;
    a3->__r_.__value_.__r.__words[2] = v6;
  }
}

void sub_1B76C03E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::DescriptionVisitor::~DescriptionVisitor(void **this)
{
  *this = &unk_1F10C3DD0;
  if (*((char *)this + 39) < 0) {
    operator delete(this[2]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1F10C3DD0;
  if (*((char *)this + 39) < 0) {
    operator delete(this[2]);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void anonymous namespace'::DescriptionVisitor::visit(_anonymous_namespace_::DescriptionVisitor *this, const PCICCTransferFunctionLinear *a2)
{
  _OWORD v12[2] = *MEMORY[0x1E4F143B8];
  getDefaultChromaticitiesName(*((float **)this + 1), &v11);
  std::string::basic_string[abi:ne180100]<0>(__p, " Linear");
  if ((v10 & 0x80u) == 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  if ((v10 & 0x80u) == 0) {
    std::string::size_type v4 = v10;
  }
  else {
    std::string::size_type v4 = (std::string::size_type)__p[1];
  }
  unint64_t v5 = std::string::append(&v11, (const std::string::value_type *)v3, v4);
  std::string::size_type v6 = v5->__r_.__value_.__r.__words[0];
  v12[0] = v5->__r_.__value_.__l.__size_;
  *(void *)((char *)v12 + 7) = *(std::string::size_type *)((char *)&v5->__r_.__value_.__r.__words[1] + 7);
  char v7 = HIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if (*((char *)this + 39) < 0) {
    operator delete(*((void **)this + 2));
  }
  uint64_t v8 = v12[0];
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v6;
  *((void *)this + 3) = v8;
  *(void *)((char *)this + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(void *)((char *)v12 + 7);
  *((unsigned char *)this + 39) = v7;
  if ((char)v10 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
}

void sub_1B76C05BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::DescriptionVisitor::visit(float **this, const PCICCTransferFunctionGamma *a2)
{
  float Gamma = PCICCTransferFunctionGamma::getGamma(a2);
  int v4 = PCClassifyPrimaries(this[1]);
  int v5 = PCClassifyTransfer(Gamma);
  if (v5 == 1)
  {
    switch(v4)
    {
      case 1:
        std::string::size_type v6 = "HDTV";
        break;
      case 5:
        std::string::size_type v6 = "Composite PAL";
        break;
      case 6:
        std::string::size_type v6 = "Composite NTSC";
        break;
      case 9:
        std::string::size_type v6 = "Ultra HDTV";
        break;
      case 12:
        std::string::size_type v6 = "P3D65";
        break;
      default:
        goto LABEL_4;
    }
    std::string::basic_string[abi:ne180100]<0>(&v15, v6);
    goto LABEL_20;
  }
LABEL_4:
  if (v4 == 2 || v5 == 2)
  {
    getDefaultDescription(this[1], Gamma);
LABEL_20:
    unsigned int v12 = (void **)(this + 2);
    if (*((char *)this + 39) < 0) {
      operator delete(*v12);
    }
    *(_OWORD *)unsigned int v12 = v15;
    this[4] = v16;
    return;
  }
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v15);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v15, (uint64_t)"QuickTime 'nclc' Video(", 23);
  uint64_t v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)",", 1);
  uint64_t v9 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)",", 1);
  PCPrimariesToMatrix(v4);
  unsigned __int8 v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)")", 1);
  std::stringbuf::str();
  std::string v11 = (void **)(this + 2);
  if (*((char *)this + 39) < 0) {
    operator delete(*v11);
  }
  *(_OWORD *)std::string v11 = v13;
  this[4] = v14;
  *(void *)&long long v15 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v15 + *(void *)(v15 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *((void *)&v15 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = MEMORY[0x1E4FBA470] + 16;
  if (v18 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BA9BFAB0](&v19);
}

void sub_1B76C0894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

double anonymous namespace'::DescriptionVisitor::visit(_anonymous_namespace_::DescriptionVisitor *this, const PCICCTransferFunctionLUT *a2)
{
  uint64_t v3 = (float *)*((void *)this + 1);
  float v4 = PCEstimateGammaFromTransferFunction((uint64_t)a2);
  getDefaultDescription(v3, v4);
  int v5 = (void **)((char *)this + 16);
  if (*((char *)this + 39) < 0) {
    operator delete(*v5);
  }
  double result = *(double *)&v7;
  *(_OWORD *)int v5 = v7;
  *((void *)this + 4) = v8;
  return result;
}

double anonymous namespace'::DescriptionVisitor::visit(_anonymous_namespace_::DescriptionVisitor *this, const PCICCTransferFunctionParametric0 *a2)
{
  uint64_t v3 = (float *)*((void *)this + 1);
  float v4 = PCEstimateGammaFromTransferFunction((uint64_t)a2);
  getDefaultDescription(v3, v4);
  int v5 = (void **)((char *)this + 16);
  if (*((char *)this + 39) < 0) {
    operator delete(*v5);
  }
  double result = *(double *)&v7;
  *(_OWORD *)int v5 = v7;
  *((void *)this + 4) = v8;
  return result;
}

double anonymous namespace'::DescriptionVisitor::visit(_anonymous_namespace_::DescriptionVisitor *this, const PCICCTransferFunctionParametric1 *a2)
{
  uint64_t v3 = (float *)*((void *)this + 1);
  float v4 = PCEstimateGammaFromTransferFunction((uint64_t)a2);
  getDefaultDescription(v3, v4);
  int v5 = (void **)((char *)this + 16);
  if (*((char *)this + 39) < 0) {
    operator delete(*v5);
  }
  double result = *(double *)&v7;
  *(_OWORD *)int v5 = v7;
  *((void *)this + 4) = v8;
  return result;
}

double anonymous namespace'::DescriptionVisitor::visit(_anonymous_namespace_::DescriptionVisitor *this, const PCICCTransferFunctionParametric2 *a2)
{
  uint64_t v3 = (float *)*((void *)this + 1);
  float v4 = PCEstimateGammaFromTransferFunction((uint64_t)a2);
  getDefaultDescription(v3, v4);
  int v5 = (void **)((char *)this + 16);
  if (*((char *)this + 39) < 0) {
    operator delete(*v5);
  }
  double result = *(double *)&v7;
  *(_OWORD *)int v5 = v7;
  *((void *)this + 4) = v8;
  return result;
}

double anonymous namespace'::DescriptionVisitor::visit(_anonymous_namespace_::DescriptionVisitor *this, const PCICCTransferFunctionParametric3 *a2)
{
  float Gamma = PCICCTransferFunctionGamma::getGamma(a2);
  float v5 = PCICCTransferFunctionParametric3::getA(a2);
  float v6 = PCICCTransferFunctionParametric3::getB(a2);
  float v7 = PCICCTransferFunctionParametric3::getC(a2);
  float v8 = PCICCTransferFunctionParametric3::getD(a2);
  if (PCIs709TransferFunction(Gamma, v5, v6, v7, v8))
  {
    uint64_t v9 = (float *)*((void *)this + 1);
    if (vabds_f32(*v9, 0.64) < 0.001
      && vabds_f32(v9[1], 0.33) < 0.001
      && vabds_f32(v9[2], 0.3) < 0.001
      && vabds_f32(v9[3], 0.6) < 0.001
      && vabds_f32(v9[4], 0.15) < 0.001
      && vabds_f32(v9[5], 0.06) < 0.001
      && vabds_f32(v9[6], 0.3127) < 0.001
      && vabds_f32(v9[7], 0.329) < 0.001
      || vabds_f32(*v9, 0.708) < 0.001
      && vabds_f32(v9[1], 0.292) < 0.001
      && vabds_f32(v9[2], 0.17) < 0.001
      && vabds_f32(v9[3], 0.797) < 0.001
      && vabds_f32(v9[4], 0.131) < 0.001
      && vabds_f32(v9[5], 0.046) < 0.001
      && vabds_f32(v9[6], 0.3127) < 0.001
      && vabds_f32(v9[7], 0.329) < 0.001)
    {
      goto LABEL_38;
    }
  }
  else
  {
    BOOL v10 = PCIssRGBTransferFunction(Gamma, v5, v6, v7, v8);
    uint64_t v9 = (float *)*((void *)this + 1);
    if (v10
      && (vabds_f32(*v9, 0.64) < 0.001
       && vabds_f32(v9[1], 0.33) < 0.001
       && vabds_f32(v9[2], 0.3) < 0.001
       && vabds_f32(v9[3], 0.6) < 0.001
       && vabds_f32(v9[4], 0.15) < 0.001
       && vabds_f32(v9[5], 0.06) < 0.001
       && vabds_f32(v9[6], 0.3127) < 0.001
       && vabds_f32(v9[7], 0.329) < 0.001
       || vabds_f32(*v9, 0.68) < 0.001
       && vabds_f32(v9[1], 0.32) < 0.001
       && vabds_f32(v9[2], 0.265) < 0.001
       && vabds_f32(v9[3], 0.69) < 0.001
       && vabds_f32(v9[4], 0.15) < 0.001
       && vabds_f32(v9[5], 0.06) < 0.001
       && vabds_f32(v9[6], 0.3127) < 0.001
       && vabds_f32(v9[7], 0.329) < 0.001))
    {
LABEL_38:
      JUMPOUT(0x1BA9BF660);
    }
  }
  float v11 = PCEstimateGammaFromTransferFunction((uint64_t)a2);
  getDefaultDescription(v9, v11);
  unsigned int v12 = (void **)((char *)this + 16);
  if (*((char *)this + 39) < 0) {
    operator delete(*v12);
  }
  double result = *(double *)&v14;
  *(_OWORD *)unsigned int v12 = v14;
  *((void *)this + 4) = v15;
  return result;
}

double anonymous namespace'::DescriptionVisitor::visit(_anonymous_namespace_::DescriptionVisitor *this, const PCICCTransferFunctionParametric4 *a2)
{
  uint64_t v3 = (float *)*((void *)this + 1);
  float v4 = PCEstimateGammaFromTransferFunction((uint64_t)a2);
  getDefaultDescription(v3, v4);
  float v5 = (void **)((char *)this + 16);
  if (*((char *)this + 39) < 0) {
    operator delete(*v5);
  }
  double result = *(double *)&v7;
  *(_OWORD *)float v5 = v7;
  *((void *)this + 4) = v8;
  return result;
}

void *getDefaultChromaticitiesName@<X0>(float *a1@<X0>, void *a2@<X8>)
{
  double result = (void *)PCClassifyPrimaries(a1);
  switch((int)result)
  {
    case 0:
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      return result;
    case 1:
      float v5 = "Rec. 709";
      goto LABEL_28;
    case 2:
      if (vabds_f32(*a1, 0.63) >= 0.001
        || vabds_f32(a1[1], 0.34) >= 0.001
        || vabds_f32(a1[2], 0.295) >= 0.001
        || vabds_f32(a1[3], 0.605) >= 0.001
        || vabds_f32(a1[4], 0.155) >= 0.001
        || vabds_f32(a1[5], 0.077) >= 0.001
        || vabds_f32(a1[6], 0.3127) >= 0.001
        || vabds_f32(a1[7], 0.329) >= 0.001)
      {
        if (vabds_f32(*a1, 0.713) >= 0.001
          || vabds_f32(a1[1], 0.293) >= 0.001
          || vabds_f32(a1[2], 0.165) >= 0.001
          || vabds_f32(a1[3], 0.83) >= 0.001
          || vabds_f32(a1[4], 0.128) >= 0.001
          || vabds_f32(a1[5], 0.044) >= 0.001
          || vabds_f32(a1[6], 0.32168) >= 0.001
          || vabds_f32(a1[7], 0.33767) >= 0.001)
        {
LABEL_27:
          float v5 = "RGB";
        }
        else
        {
          float v5 = "ACEScg";
        }
      }
      else
      {
        float v5 = "Generic RGB";
      }
LABEL_28:
      return std::string::basic_string[abi:ne180100]<0>(a2, v5);
    case 5:
      float v5 = "EBU 3213";
      goto LABEL_28;
    case 6:
      float v5 = "SMPTE C";
      goto LABEL_28;
    case 9:
      float v5 = "Rec. 2020";
      goto LABEL_28;
    case 11:
      float v5 = "P3DCI";
      goto LABEL_28;
    case 12:
      float v5 = "P3D65";
      goto LABEL_28;
    default:
      goto LABEL_27;
  }
}

uint64_t getDefaultDescription(float *a1, float a2)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v10);
  getDefaultChromaticitiesName(a1, __p);
  if ((v9 & 0x80u) == 0) {
    float v4 = __p;
  }
  else {
    float v4 = (void **)__p[0];
  }
  if ((v9 & 0x80u) == 0) {
    uint64_t v5 = v9;
  }
  else {
    uint64_t v5 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)v4, v5);
  if ((char)v9 < 0) {
    operator delete(__p[0]);
  }
  if (a2 != 0.0
    && (a2 != 1.0
     || vabds_f32(*a1, 0.713) >= 0.001
     || vabds_f32(a1[1], 0.293) >= 0.001
     || vabds_f32(a1[2], 0.165) >= 0.001
     || vabds_f32(a1[3], 0.83) >= 0.001
     || vabds_f32(a1[4], 0.128) >= 0.001
     || vabds_f32(a1[5], 0.044) >= 0.001
     || vabds_f32(a1[6], 0.32168) >= 0.001
     || vabds_f32(a1[7], 0.33767) >= 0.001)
    && (fabsf(a2 + -2.6) >= 0.001
     || vabds_f32(*a1, 0.68) >= 0.001
     || vabds_f32(a1[1], 0.32) >= 0.001
     || vabds_f32(a1[2], 0.265) >= 0.001
     || vabds_f32(a1[3], 0.69) >= 0.001
     || vabds_f32(a1[4], 0.15) >= 0.001
     || vabds_f32(a1[5], 0.06) >= 0.001
     || vabds_f32(a1[6], 0.314) >= 0.001
     || vabds_f32(a1[7], 0.351) >= 0.001)
    && (fabsf(a2 + -1.961) >= 0.001
     || vabds_f32(*a1, 0.68) >= 0.001
     || vabds_f32(a1[1], 0.32) >= 0.001
     || vabds_f32(a1[2], 0.265) >= 0.001
     || vabds_f32(a1[3], 0.69) >= 0.001
     || vabds_f32(a1[4], 0.15) >= 0.001
     || vabds_f32(a1[5], 0.06) >= 0.001
     || vabds_f32(a1[6], 0.3127) >= 0.001
     || vabds_f32(a1[7], 0.329) >= 0.001))
  {
    if (a2 == 1.0)
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" Linear", 7);
    }
    else
    {
      float v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" Gamma ", 7);
      *(void *)((char *)v6 + *(void *)(*v6 - 24) + 16) = 5;
      std::ostream::operator<<();
    }
  }
  std::stringbuf::str();
  v10[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v10 + *(void *)(v10[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v10[1] = MEMORY[0x1E4FBA470] + 16;
  if (v11 < 0) {
    operator delete((void *)v10[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v12);
}

void sub_1B76C156C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void PCAsciiStream::PCAsciiStream(PCAsciiStream *this)
{
  *((unsigned char *)this + 35) = 0;
  *(unsigned char *)this = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 7PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
}

void PCAsciiStream::~PCAsciiStream(void **this)
{
  if (!*(unsigned char *)this && *((unsigned char *)this + 35)) {
    PCAsciiStream::close((PCAsciiStream *)this);
  }
  if (*((char *)this + 87) < 0) {
    operator delete(this[8]);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

void PCAsciiStream::close(PCAsciiStream *this)
{
  if (!*(unsigned char *)this && *((unsigned char *)this + 35))
  {
    if (*((unsigned char *)this + 35) == 2) {
      *((unsigned char *)this + 33) = 0;
    }
    *((unsigned char *)this + 34) = 0;
    PCAsciiStream::encodeNewSize(this);
    std::string::push_back((std::string *)((char *)this + 8), encodeVals[(unint64_t)*((unsigned __int8 *)this + 32) >> 2]);
    std::string::push_back((std::string *)((char *)this + 8), encodeVals[((unint64_t)*((unsigned __int8 *)this + 33) >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16* (*((unsigned char *)this + 32) & 3))]);
    std::string::push_back((std::string *)((char *)this + 8), encodeVals[((unint64_t)*((unsigned __int8 *)this + 34) >> 6) & 0xFFFFFFFFFFFFFFC3 | (4* (*((unsigned char *)this + 33) & 0xF))]);
    std::string::push_back((std::string *)((char *)this + 8), encodeVals[*((unsigned char *)this + 34) & 0x3F]);
    *((unsigned char *)this + 35) = 0;
  }
}

BOOL PCAsciiStream::open(PCAsciiStream *this, const char *a2)
{
  MEMORY[0x1BA9BF660]((char *)this + 8);
  *((unsigned char *)this + 35) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(unsigned char *)this = 1;
  if (*((char *)this + 31) < 0) {
    unint64_t v4 = *((void *)this + 2);
  }
  else {
    unint64_t v4 = *((unsigned __int8 *)this + 31);
  }
  if (v4 < 0xC)
  {
    MEMORY[0x1BA9BF660]((char *)this + 64, "Not enough data");
    return 0;
  }
  else
  {
    uint64_t v5 = 0;
    unint64_t v15 = 0;
    float v6 = (char *)&v15 + 2;
    long long v7 = a2 + 1;
    while (1)
    {
      *((void *)this + 6) = v5 + 1;
      uint64_t v8 = a2[v5];
      *((void *)this + 6) = v5 + 2;
      uint64_t v9 = v7[v5];
      *((void *)this + 6) = v5 + 3;
      uint64_t v10 = v7[v5 + 1];
      *((void *)this + 6) = v5 + 4;
      uint64_t v11 = v7[v5 + 2];
      LODWORD(v9) = decodeVals[v9];
      LODWORD(v8) = (4 * decodeVals[v8]) | (v9 >> 4) & 3;
      *((unsigned char *)this + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v8;
      LODWORD(v10) = decodeVals[v10];
      LODWORD(v9) = (16 * v9) | (v10 >> 2) & 0xF;
      *((unsigned char *)this + 33) = v9;
      char v12 = decodeVals[v11] & 0x3F | ((_BYTE)v10 << 6);
      *((unsigned char *)this + 34) = v12;
      *(v6 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v8;
      *(v6 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v9;
      if (v5 == 8) {
        break;
      }
      *float v6 = v12;
      v6 += 3;
      v5 += 4;
    }
    *((void *)this + 7) = bswap64(v15);
    BOOL v13 = v12 == 42;
    if (v12 != 42) {
      MEMORY[0x1BA9BF660]((char *)this + 64, "Magic Number does not match");
    }
  }
  return v13;
}

unint64_t PCAsciiStream::read(PCAsciiStream *this, unsigned char *a2, unint64_t a3)
{
  uint64_t v3 = *((void *)this + 5);
  unint64_t v4 = v3 + a3;
  unint64_t v5 = *((void *)this + 7);
  unint64_t v6 = v5 - v3;
  if (v4 < v5) {
    unint64_t v6 = a3;
  }
  if (v6)
  {
    unint64_t v7 = 0;
    uint64_t v8 = (char **)((char *)this + 8);
    LOBYTE(v9) = *((unsigned char *)this + 35);
    while (v9 != 1)
    {
      if (v9 != 2) {
        goto LABEL_12;
      }
      a2[v7] = *((unsigned char *)this + 33);
      unint64_t v10 = v7 + 1;
      ++*((void *)this + 5);
      LOBYTE(v9) = *((unsigned char *)this + 35) - 1;
      *((unsigned char *)this + 35) = v9;
      if (v7 + 1 < v6)
      {
        uint64_t v9 = 2;
LABEL_10:
        a2[v10] = *((unsigned char *)this + 34);
        v7 += v9;
        ++*((void *)this + 5);
        LOBYTE(v9) = *((unsigned char *)this + 35) - 1;
        *((unsigned char *)this + 35) = v9;
        goto LABEL_12;
      }
      ++v7;
LABEL_12:
      if (v7 < v6 && !(_BYTE)v9)
      {
        uint64_t v11 = *((void *)this + 6);
        *((void *)this + 6) = v11 + 1;
        char v12 = (char *)this + 8;
        if (*((char *)this + 31) < 0) {
          char v12 = *v8;
        }
        uint64_t v9 = v12[v11];
        *((void *)this + 6) = v11 + 2;
        BOOL v13 = (char *)this + 8;
        if (*((char *)this + 31) < 0) {
          BOOL v13 = *v8;
        }
        uint64_t v14 = v13[v11 + 1];
        uint64_t v15 = v11 + 3;
        *((void *)this + 6) = v11 + 3;
        uint64_t v16 = (char *)this + 8;
        if (*((char *)this + 31) < 0) {
          uint64_t v16 = *v8;
        }
        uint64_t v17 = v16[v11 + 2];
        *((void *)this + 6) = v11 + 4;
        char v18 = (char *)this + 8;
        if (*((char *)this + 31) < 0) {
          char v18 = *v8;
        }
        uint64_t v19 = v18[v15];
        unsigned int v20 = decodeVals[v14];
        char v21 = (4 * decodeVals[v9]) | (v20 >> 4) & 3;
        *((unsigned char *)this + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v21;
        unsigned __int8 v22 = decodeVals[v17];
        *((unsigned char *)this + 33) = (16 * v20) | (v22 >> 2) & 0xF;
        *((unsigned char *)this + 34) = decodeVals[v19] & 0x3F | (v22 << 6);
        a2[v7++] = v21;
        ++*((void *)this + 5);
        LOBYTE(v9) = 2;
        *((unsigned char *)this + 35) = 2;
      }
      if (v7 >= v6) {
        return v6;
      }
    }
    uint64_t v9 = v9;
    unint64_t v10 = v7;
    goto LABEL_10;
  }
  return v6;
}

unint64_t PCAsciiStream::write(PCAsciiStream *this, unsigned char *a2, unint64_t a3)
{
  if (a3)
  {
    unint64_t v6 = 0;
    unint64_t v7 = (std::string *)((char *)this + 8);
    while (1)
    {
      int v8 = *((unsigned __int8 *)this + 35);
      if (!*((unsigned char *)this + 35)) {
        break;
      }
      if (v8 == 2)
      {
        *((unsigned char *)this + 35) = 1;
        *((unsigned char *)this + 33) = a2[v6];
        unint64_t v9 = v6 + 1;
        uint64_t v10 = *((void *)this + 7);
        *((void *)this + 7) = v10 + 1;
        if (v6 + 1 < a3)
        {
          *((unsigned char *)this + 35) = 0;
          *((unsigned char *)this + 34) = a2[v9];
          unint64_t v9 = v6 + 2;
          uint64_t v11 = v10 + 2;
LABEL_11:
          *((void *)this + 7) = v11;
LABEL_13:
          PCAsciiStream::encodeNewSize(this);
          std::string::push_back(v7, encodeVals[(unint64_t)*((unsigned __int8 *)this + 32) >> 2]);
          std::string::push_back(v7, encodeVals[((unint64_t)*((unsigned __int8 *)this + 33) >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (*((unsigned char *)this + 32) & 3))]);
          std::string::push_back(v7, encodeVals[((unint64_t)*((unsigned __int8 *)this + 34) >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (*((unsigned char *)this + 33) & 0xF))]);
          std::string::push_back(v7, encodeVals[*((unsigned char *)this + 34) & 0x3F]);
        }
      }
      else
      {
        char v14 = v8 - 1;
        *((unsigned char *)this + 35) = v14;
        *((unsigned char *)this + 34) = a2[v6];
        unint64_t v9 = v6 + 1;
        ++*((void *)this + 7);
        if (!v14) {
          goto LABEL_13;
        }
      }
LABEL_14:
      unint64_t v6 = v9;
      if (v9 >= a3) {
        return a3;
      }
    }
    *((unsigned char *)this + 35) = 2;
    *((unsigned char *)this + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a2[v6];
    unint64_t v9 = v6 + 1;
    uint64_t v12 = *((void *)this + 7);
    uint64_t v13 = v12 + 1;
    *((void *)this + 7) = v12 + 1;
    if (v6 + 1 < a3)
    {
      *((unsigned char *)this + 35) = 1;
      *((unsigned char *)this + 33) = a2[v9];
      unint64_t v9 = v6 + 2;
      uint64_t v13 = v12 + 2;
      *((void *)this + 7) = v12 + 2;
    }
    if (v9 >= a3) {
      goto LABEL_14;
    }
    *((unsigned char *)this + 35) = 0;
    *((unsigned char *)this + 34) = a2[v9++];
    uint64_t v11 = v13 + 1;
    goto LABEL_11;
  }
  return a3;
}

void PCAsciiStream::encodeNewSize(PCAsciiStream *this)
{
  int v2 = *((char *)this + 31);
  if (v2 < 0) {
    uint64_t v3 = *((void *)this + 2);
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)this + 31);
  }
  unint64_t v4 = bswap64(*((void *)this + 7));
  unint64_t v5 = (char *)this + 8;
  if (!v3)
  {
    int v6 = 12;
    do
    {
      std::string::push_back((std::string *)((char *)this + 8), 0);
      --v6;
    }
    while (v6);
    LOBYTE(vPCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *((unsigned char *)this + 31);
  }
  unint64_t v7 = (char *)this + 8;
  if ((v2 & 0x80) != 0) {
    unint64_t v7 = *(unsigned char **)v5;
  }
  *unint64_t v7 = encodeVals[v4 >> 2];
  int v8 = (char *)this + 8;
  if (*((char *)this + 31) < 0) {
    int v8 = *(char **)v5;
  }
  v8[1] = encodeVals[((unsigned __int16)v4 >> 12) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v4 & 3))];
  unint64_t v9 = (char *)this + 8;
  if (*((char *)this + 31) < 0) {
    unint64_t v9 = *(char **)v5;
  }
  v9[2] = encodeVals[(v4 >> 6) & 0x3C | (v4 >> 22) & 3];
  uint64_t v10 = (char *)this + 8;
  if (*((char *)this + 31) < 0) {
    uint64_t v10 = *(char **)v5;
  }
  v10[3] = encodeVals[(v4 >> 16) & 0x3F];
  uint64_t v11 = (char *)this + 8;
  if (*((char *)this + 31) < 0) {
    uint64_t v11 = *(char **)v5;
  }
  _OWORD v11[4] = encodeVals[v4 >> 26];
  uint64_t v12 = (char *)this + 8;
  if (*((char *)this + 31) < 0) {
    uint64_t v12 = *(char **)v5;
  }
  v12[5] = encodeVals[(v4 >> 20) & 0x30 | (v4 >> 36) & 0xF];
  uint64_t v13 = (char *)this + 8;
  if (*((char *)this + 31) < 0) {
    uint64_t v13 = *(char **)v5;
  }
  v13[6] = encodeVals[(v4 >> 30) & 0x3C | (v4 >> 46) & 3];
  char v14 = (char *)this + 8;
  if (*((char *)this + 31) < 0) {
    char v14 = *(char **)v5;
  }
  v14[7] = encodeVals[(v4 >> 40) & 0x3F];
  uint64_t v15 = (char *)this + 8;
  if (*((char *)this + 31) < 0) {
    uint64_t v15 = *(char **)v5;
  }
  unsigned char v15[8] = encodeVals[(v4 >> 50) & 0x3F];
  uint64_t v16 = (char *)this + 8;
  if (*((char *)this + 31) < 0) {
    uint64_t v16 = *(char **)v5;
  }
  double v16[9] = encodeVals[(v4 >> 44) & 0x30 | (v4 >> 60)];
  uint64_t v17 = (char *)this + 8;
  if (*((char *)this + 31) < 0) {
    uint64_t v17 = *(char **)v5;
  }
  v17[10] = encodeVals[(v4 >> 54) & 0x3C];
  if (*((char *)this + 31) < 0) {
    unint64_t v5 = *(char **)v5;
  }
  v5[11] = 101;
}

PCString *PCAsciiStream::getString@<X0>(PCAsciiStream *this@<X0>, PCString *a2@<X8>)
{
  int v2 = (char *)this + 8;
  if (*((char *)this + 31) < 0) {
    int v2 = *(const char **)v2;
  }
  return PCString::PCString(a2, v2);
}

void PCSharedMutex::PCSharedMutex(PCSharedMutex *this)
{
  *(void *)this = 850045863;
  *((void *)this + 10) = 0;
  *((void *)this + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  *((void *)this + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 0;
  std::vector<PCSharedMutex::ReaderInfo>::reserve((char **)this + 10, 3uLL);
}

void sub_1B76C1DF8(_Unwind_Exception *a1)
{
  unint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 88) = v4;
    operator delete(v4);
  }
  std::mutex::~mutex((std::mutex *)v1);
  _Unwind_Resume(a1);
}

void std::vector<PCSharedMutex::ReaderInfo>::reserve(char **a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    int v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v3, a2);
    unint64_t v7 = &v6[v5];
    unint64_t v9 = &v6[16 * v8];
    uint64_t v11 = *a1;
    uint64_t v10 = a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 2);
        v10 -= 16;
        int v14 = *((_DWORD *)v10 + 2);
        *((void *)v12 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v13;
        v12 -= 16;
        *((_DWORD *)v12 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v14;
      }
      while (v10 != v11);
      uint64_t v10 = *a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void PCSharedMutex::lock(std::mutex *this)
{
  pthread_t v2 = pthread_self();
  std::mutex::lock(this);
  unint64_t v3 = atomic_load((unint64_t *)&this[1]);
  if (v3)
  {
    if (v2 && v2 == (pthread_t)v3)
    {
LABEL_4:
      ++*(_DWORD *)this[1].__m_.__opaque;
      std::mutex::unlock(this);
      return;
    }
  }
  else if (!v2)
  {
    goto LABEL_4;
  }
  std::mutex::unlock(this);
  uint64_t v4 = 0;
  atomic_compare_exchange_strong(&this[1].__m_.__sig, (unint64_t *)&v4, (unint64_t)v2);
  if (v4)
  {
    do
    {
      __ns.__rep_ = 100000;
      std::this_thread::sleep_for (&__ns);
      uint64_t v5 = 0;
      atomic_compare_exchange_strong(&this[1].__m_.__sig, (unint64_t *)&v5, (unint64_t)v2);
    }
    while (v5);
  }
  do
  {
    std::mutex::lock(this);
    uint64_t v7 = *(void *)&this[1].__m_.__opaque[8];
    uint64_t v6 = *(void *)&this[1].__m_.__opaque[16];
    std::mutex::unlock(this);
  }
  while (v6 != v7);
}

void PCSharedMutex::lock_shared(std::mutex *this)
{
  pthread_t v2 = pthread_self();
  std::mutex::lock(this);
  unint64_t v3 = atomic_load((unint64_t *)&this[1]);
  if (v3)
  {
    if (v2 && v2 == (pthread_t)v3)
    {
LABEL_4:
      opaque = this[1].__m_.__opaque;
LABEL_26:
      ++*(_DWORD *)opaque;
      goto LABEL_34;
    }
  }
  else if (!v2)
  {
    goto LABEL_4;
  }
  uint64_t v5 = *(void **)&this[1].__m_.__opaque[8];
  uint64_t v6 = &this[1].__m_.__opaque[8];
  while (v5 != *(void **)&this[1].__m_.__opaque[16])
  {
    if (*v5)
    {
      if (v2 && (pthread_t)*v5 == v2)
      {
LABEL_25:
        opaque = (char *)(v5 + 1);
        goto LABEL_26;
      }
    }
    else if (!v2)
    {
      goto LABEL_25;
    }
    v5 += 2;
  }
  do
  {
    std::mutex::unlock(this);
    std::mutex::lock(this);
  }
  while (atomic_load((unint64_t *)&this[1]));
  unint64_t v8 = *(void *)&this[1].__m_.__opaque[24];
  unint64_t v9 = *(void *)&this[1].__m_.__opaque[16];
  if (v9 >= v8)
  {
    uint64_t v11 = (uint64_t)(v9 - *(void *)v6) >> 4;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v13 = v8 - *(void *)v6;
    if (v13 >> 3 > v12) {
      unint64_t v12 = v13 >> 3;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14) {
      uint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&this[1].__m_.__opaque[24], v14);
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v16 = &v15[16 * v11];
    uint64_t v17 = &v15[16 * v14];
    *(void *)uint64_t v16 = v2;
    *((_DWORD *)v16 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 1;
    uint64_t v10 = v16 + 16;
    uint64_t v19 = *(_DWORD **)&this[1].__m_.__opaque[8];
    char v18 = *(_DWORD **)&this[1].__m_.__opaque[16];
    if (v18 != v19)
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 2);
        v18 -= 4;
        int v21 = v18[2];
        *((void *)v16 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v20;
        v16 -= 16;
        *((_DWORD *)v16 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v21;
      }
      while (v18 != v19);
      char v18 = *(_DWORD **)v6;
    }
    *(void *)&this[1].__m_.__opaque[8] = v16;
    *(void *)&this[1].__m_.__opaque[16] = v10;
    *(void *)&this[1].__m_.__opaque[24] = v17;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *(void *)unint64_t v9 = v2;
    *(_DWORD *)(v9 + 8) = 1;
    uint64_t v10 = (char *)(v9 + 16);
  }
  *(void *)&this[1].__m_.__opaque[16] = v10;
LABEL_34:

  std::mutex::unlock(this);
}

void sub_1B76C2164(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void PCSharedMutex::unlock(std::mutex *this)
{
  std::mutex::lock(this);
  int v2 = *(_DWORD *)this[1].__m_.__opaque;
  if (v2) {
    *(_DWORD *)this[1].__m_.__opaque = v2 - 1;
  }
  else {
    atomic_store(0, (unint64_t *)&this[1]);
  }

  std::mutex::unlock(this);
}

void PCSharedMutex::unlock_shared(std::mutex *this)
{
  pthread_t v2 = pthread_self();
  std::mutex::lock(this);
  unint64_t v3 = atomic_load((unint64_t *)&this[1]);
  if (v3)
  {
    if (v2 && v2 == (pthread_t)v3) {
      goto LABEL_4;
    }
  }
  else if (!v2)
  {
LABEL_4:
    --*(_DWORD *)this[1].__m_.__opaque;
    goto LABEL_20;
  }
  uint64_t v5 = *(char **)&this[1].__m_.__opaque[8];
  uint64_t v4 = *(char **)&this[1].__m_.__opaque[16];
  if (v5 == v4) {
    goto LABEL_20;
  }
  uint64_t v6 = 0;
  while (1)
  {
    uint64_t v7 = *(_opaque_pthread_t **)&v5[v6];
    if (v7) {
      break;
    }
    if (!v2) {
      goto LABEL_15;
    }
LABEL_13:
    v6 += 16;
    if (&v5[v6] == v4) {
      goto LABEL_20;
    }
  }
  if (!v2 || v7 != v2) {
    goto LABEL_13;
  }
LABEL_15:
  unint64_t v8 = &v5[v6];
  int v9 = *(_DWORD *)&v5[v6 + 8] - 1;
  if (v9)
  {
    *((_DWORD *)v8 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v9;
  }
  else
  {
    int64_t v10 = v4 - (v8 + 16);
    if (v4 != v8 + 16) {
      memmove(v8, v8 + 16, v10 - 4);
    }
    *(void *)&this[1].__m_.__opaque[16] = &v8[v10];
  }
LABEL_20:

  std::mutex::unlock(this);
}

void PCHashWriteStream::PCHashWriteStream(PCHashWriteStream *this)
{
  PCSerializerWriteStream::PCSerializerWriteStream(this);
  void *v2 = &unk_1F10C3E48;
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)(v2 + 4));
  *((void *)this + 6) = 0x100000001000;
  *((void *)this + 7) = (char *)this + 64;
}

void sub_1B76C231C(_Unwind_Exception *exception_object)
{
  void *v1 = &unk_1F10C3F60;
  unint64_t v3 = (void *)v1[1];
  if (v3)
  {
    v1[2] = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void PCHashWriteStream::~PCHashWriteStream(PCHashWriteStream *this)
{
  *(void *)this = &unk_1F10C3F60;
  pthread_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10C3F60;
  pthread_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

int8x8_t *PCHashWriteStream::close(int8x8_t *this)
{
  uint64_t v1 = this;
  __int32 v3 = this[6].i32[0];
  __int32 v2 = this[6].i32[1];
  if (v3 != v2)
  {
    this = PCHash128::addData(this + 4, (const unsigned __int8 *)&this[8], (v3 - v2));
    __int32 v2 = v1[6].i32[0];
  }
  v1[6].i32[1] = v2;
  v1[7] = (int8x8_t)&v1[8];
  return this;
}

uint64_t PCHashWriteStream::reset(uint64_t this)
{
  *(_DWORD *)(this + 5PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *(_DWORD *)(this + 48);
  *(void *)(this + 56) = this + 64;
  *(void *)(this + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *(void *)(this + 40) = 0;
  return this;
}

int8x8_t *PCHashWriteStream::writeValue(int8x8_t *this, int a2)
{
  __int32 v2 = this;
  int __src = a2;
  unsigned int v3 = this[6].u32[1];
  if (v3 <= 3)
  {
    uint64_t v4 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v5 = 4;
    p_src = &__src;
    do
    {
      if (v5 >= v3) {
        size_t v7 = v3;
      }
      else {
        size_t v7 = v5;
      }
      memcpy(this, p_src, v7);
      size_t v8 = v2[6].u32[0];
      if (v7 == v2[6].i32[1])
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        unsigned int v3 = v2[6].u32[0];
        this = v2 + 8;
      }
      else
      {
        unsigned int v3 = v8 - v7;
        this = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)this;
      p_src = (int *)((char *)p_src + v7);
      v5 -= v7;
    }
    while (v5);
  }
  else
  {
    **(_DWORD **)&this[7] = a2;
    this[6].i32[1] -= 4;
    *(void *)&this[7] += 4;
  }
  return this;
}

{
  int8x8_t *v2;
  unsigned int v3;
  int8x8_t *v4;
  unsigned int v5;
  int *p_src;
  size_t v7;
  size_t v8;
  int __src;

  __int32 v2 = this;
  int __src = a2;
  unsigned int v3 = this[6].u32[1];
  if (v3 <= 3)
  {
    uint64_t v4 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v5 = 4;
    p_src = &__src;
    do
    {
      if (v5 >= v3) {
        size_t v7 = v3;
      }
      else {
        size_t v7 = v5;
      }
      memcpy(this, p_src, v7);
      size_t v8 = v2[6].u32[0];
      if (v7 == v2[6].i32[1])
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        unsigned int v3 = v2[6].u32[0];
        this = v2 + 8;
      }
      else
      {
        unsigned int v3 = v8 - v7;
        this = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)this;
      p_src = (int *)((char *)p_src + v7);
      v5 -= v7;
    }
    while (v5);
  }
  else
  {
    **(_DWORD **)&this[7] = a2;
    this[6].i32[1] -= 4;
    *(void *)&this[7] += 4;
  }
  return this;
}

int8x8_t *PCHashWriteStream::writeValue(int8x8_t *this, uint64_t a2)
{
  __int32 v2 = this;
  uint64_t __src = a2;
  unsigned int v3 = this[6].u32[1];
  if (v3 <= 7)
  {
    uint64_t v4 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v5 = 8;
    p_src = &__src;
    do
    {
      if (v5 >= v3) {
        size_t v7 = v3;
      }
      else {
        size_t v7 = v5;
      }
      memcpy(this, p_src, v7);
      size_t v8 = v2[6].u32[0];
      if (v7 == v2[6].i32[1])
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        unsigned int v3 = v2[6].u32[0];
        this = v2 + 8;
      }
      else
      {
        unsigned int v3 = v8 - v7;
        this = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)this;
      p_src = (uint64_t *)((char *)p_src + v7);
      v5 -= v7;
    }
    while (v5);
  }
  else
  {
    **(void **)&this[7] = a2;
    this[6].i32[1] -= 8;
    *(void *)&this[7] += 8;
  }
  return this;
}

{
  int8x8_t *v2;
  unsigned int v3;
  int8x8_t *v4;
  unsigned int v5;
  uint64_t *p_src;
  size_t v7;
  size_t v8;
  uint64_t __src;

  __int32 v2 = this;
  uint64_t __src = a2;
  unsigned int v3 = this[6].u32[1];
  if (v3 <= 7)
  {
    uint64_t v4 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v5 = 8;
    p_src = &__src;
    do
    {
      if (v5 >= v3) {
        size_t v7 = v3;
      }
      else {
        size_t v7 = v5;
      }
      memcpy(this, p_src, v7);
      size_t v8 = v2[6].u32[0];
      if (v7 == v2[6].i32[1])
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        unsigned int v3 = v2[6].u32[0];
        this = v2 + 8;
      }
      else
      {
        unsigned int v3 = v8 - v7;
        this = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)this;
      p_src = (uint64_t *)((char *)p_src + v7);
      v5 -= v7;
    }
    while (v5);
  }
  else
  {
    **(void **)&this[7] = a2;
    this[6].i32[1] -= 8;
    *(void *)&this[7] += 8;
  }
  return this;
}

int8x8_t *PCHashWriteStream::writeValue(int8x8_t *this, float a2)
{
  __int32 v2 = this;
  float __src = a2;
  unsigned int v3 = this[6].u32[1];
  if (v3 <= 3)
  {
    uint64_t v4 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v5 = 4;
    p_src = &__src;
    do
    {
      if (v5 >= v3) {
        size_t v7 = v3;
      }
      else {
        size_t v7 = v5;
      }
      memcpy(this, p_src, v7);
      size_t v8 = v2[6].u32[0];
      if (v7 == v2[6].i32[1])
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        unsigned int v3 = v2[6].u32[0];
        this = v2 + 8;
      }
      else
      {
        unsigned int v3 = v8 - v7;
        this = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)this;
      p_src = (float *)((char *)p_src + v7);
      v5 -= v7;
    }
    while (v5);
  }
  else
  {
    *(float *)this[7].i32[0] = a2;
    this[6].i32[1] -= 4;
    *(void *)&this[7] += 4;
  }
  return this;
}

int8x8_t *PCHashWriteStream::writeValue(int8x8_t *this, double a2)
{
  __int32 v2 = this;
  double __src = a2;
  unsigned int v3 = this[6].u32[1];
  if (v3 <= 7)
  {
    uint64_t v4 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v5 = 8;
    p_src = &__src;
    do
    {
      if (v5 >= v3) {
        size_t v7 = v3;
      }
      else {
        size_t v7 = v5;
      }
      memcpy(this, p_src, v7);
      size_t v8 = v2[6].u32[0];
      if (v7 == v2[6].i32[1])
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        unsigned int v3 = v2[6].u32[0];
        this = v2 + 8;
      }
      else
      {
        unsigned int v3 = v8 - v7;
        this = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)this;
      p_src = (double *)((char *)p_src + v7);
      v5 -= v7;
    }
    while (v5);
  }
  else
  {
    *(double *)this[7] = a2;
    this[6].i32[1] -= 8;
    *(void *)&this[7] += 8;
  }
  return this;
}

int8x8_t *PCHashWriteStream::writeValue(int8x8_t *result, long long *a2)
{
  __int32 v2 = result;
  long long v9 = *a2;
  unsigned int v3 = result[6].u32[1];
  if (v3 <= 0xF)
  {
    uint64_t v4 = result + 8;
    double result = (int8x8_t *)result[7];
    unsigned int v5 = 16;
    uint64_t v6 = &v9;
    do
    {
      if (v5 >= v3) {
        size_t v7 = v3;
      }
      else {
        size_t v7 = v5;
      }
      memcpy(result, v6, v7);
      size_t v8 = v2[6].u32[0];
      if (v7 == v2[6].i32[1])
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        unsigned int v3 = v2[6].u32[0];
        double result = v2 + 8;
      }
      else
      {
        unsigned int v3 = v8 - v7;
        double result = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)result;
      uint64_t v6 = (long long *)((char *)v6 + v7);
      v5 -= v7;
    }
    while (v5);
  }
  else
  {
    *(_OWORD *)*(void *)&result[7] = v9;
    result[6].i32[1] -= 16;
    *(void *)&result[7] += 16;
  }
  return result;
}

int8x8_t *PCHashWriteStream::writeValue(int8x8_t *this, const CMTime *__src)
{
  __int32 v2 = __src;
  unsigned int v3 = this;
  unsigned int v4 = this[6].u32[1];
  if (v4 <= 0x17)
  {
    size_t v7 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v8 = 24;
    do
    {
      if (v8 >= v4) {
        size_t v9 = v4;
      }
      else {
        size_t v9 = v8;
      }
      memcpy(this, v2, v9);
      size_t v10 = v3[6].u32[0];
      if (v9 == v3[6].i32[1])
      {
        PCHash128::addData(v3 + 4, (const unsigned __int8 *)&v3[8], v10);
        unsigned int v4 = v3[6].u32[0];
        this = v3 + 8;
      }
      else
      {
        unsigned int v4 = v10 - v9;
        this = (int8x8_t *)((char *)v7 + v9);
      }
      v3[6].i32[1] = v4;
      v3[7] = (int8x8_t)this;
      __int32 v2 = (const CMTime *)((char *)v2 + v9);
      v8 -= v9;
    }
    while (v8);
  }
  else
  {
    int8x8_t v5 = this[7];
    long long v6 = *(_OWORD *)&__src->value;
    *(void *)(*(void *)&v5 + 16) = __src->epoch;
    *(_OWORD *)*(void *)&int8x8_t v5 = v6;
    this[6].i32[1] -= 24;
    *(void *)&this[7] += 24;
  }
  return this;
}

void PCHashWriteStream::writeValue(int8x8_t *this, PCString *a2)
{
  UniStr = PCString::createUniStr(a2);
  unsigned int v4 = UniStr;
  if (!UniStr) {
    goto LABEL_20;
  }
  if (*UniStr)
  {
    uint64_t v5 = 2;
    do
    {
      int v6 = *(UniChar *)((char *)UniStr + v5);
      v5 += 2;
    }
    while (v6);
    unsigned int v7 = this[6].u32[1];
    if (v7 < v5)
    {
      if ((int)v5 < 1) {
        goto LABEL_20;
      }
      goto LABEL_9;
    }
LABEL_19:
    memcpy(*(void **)&this[7], UniStr, (int)v5);
    this[6].i32[1] -= v5;
    *(void *)&this[7] += (int)v5;
    goto LABEL_20;
  }
  unsigned int v7 = this[6].u32[1];
  LODWORD(v5) = 2;
  if (v7 >= 2) {
    goto LABEL_19;
  }
LABEL_9:
  unsigned int v8 = (int8x8_t *)this[7];
  size_t v9 = v4;
  do
  {
    if (v5 >= v7) {
      size_t v10 = v7;
    }
    else {
      size_t v10 = v5;
    }
    memcpy(v8, v9, v10);
    size_t v11 = this[6].u32[0];
    if (v10 == this[6].i32[1])
    {
      PCHash128::addData(this + 4, (const unsigned __int8 *)&this[8], v11);
      unsigned int v7 = this[6].u32[0];
      unsigned int v8 = this + 8;
    }
    else
    {
      unsigned int v7 = v11 - v10;
      unsigned int v8 = (int8x8_t *)((char *)this + v10 + 64);
    }
    this[6].i32[1] = v7;
    this[7] = (int8x8_t)v8;
    size_t v9 = (UniChar *)((char *)v9 + v10);
    BOOL v12 = __OFSUB__(v5, v10);
    LODWORD(v5) = v5 - v10;
  }
  while (!(((int)v5 < 0) ^ v12 | (v5 == 0)));
LABEL_20:

  free(v4);
}

int8x8_t *PCHashWriteStream::writeValue(int8x8_t *this, const void *a2)
{
  __int32 v2 = this;
  double __src = a2;
  unsigned int v3 = this[6].u32[1];
  if (v3 <= 7)
  {
    unsigned int v4 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v5 = 8;
    p_src = &__src;
    do
    {
      if (v5 >= v3) {
        size_t v7 = v3;
      }
      else {
        size_t v7 = v5;
      }
      memcpy(this, p_src, v7);
      size_t v8 = v2[6].u32[0];
      if (v7 == v2[6].i32[1])
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        unsigned int v3 = v2[6].u32[0];
        this = v2 + 8;
      }
      else
      {
        unsigned int v3 = v8 - v7;
        this = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)this;
      p_src = (const void **)((char *)p_src + v7);
      v5 -= v7;
    }
    while (v5);
  }
  else
  {
    **(void **)&this[7] = a2;
    this[6].i32[1] -= 8;
    *(void *)&this[7] += 8;
  }
  return this;
}

int8x8_t *PCHashWriteStream::writeValue(int8x8_t *this, const PCHash128 *a2)
{
  __int32 v2 = this;
  long long v9 = *(_OWORD *)a2;
  unsigned int v3 = this[6].u32[1];
  if (v3 <= 0xF)
  {
    unsigned int v4 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v5 = 16;
    int v6 = &v9;
    do
    {
      if (v5 >= v3) {
        size_t v7 = v3;
      }
      else {
        size_t v7 = v5;
      }
      memcpy(this, v6, v7);
      size_t v8 = v2[6].u32[0];
      if (v7 == v2[6].i32[1])
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        unsigned int v3 = v2[6].u32[0];
        this = v2 + 8;
      }
      else
      {
        unsigned int v3 = v8 - v7;
        this = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)this;
      int v6 = (long long *)((char *)v6 + v7);
      v5 -= v7;
    }
    while (v5);
  }
  else
  {
    *(_OWORD *)*(void *)&this[7] = v9;
    this[6].i32[1] -= 16;
    *(void *)&this[7] += 16;
  }
  return this;
}

int8x8_t *PCHashWriteStream::writeValue(int8x8_t *this, const char *__s)
{
  __int32 v2 = __s;
  unsigned __int32 v4 = strlen(__s);
  unsigned __int32 v5 = this[6].u32[1];
  if (v5 >= v4)
  {
    double result = (int8x8_t *)memcpy(*(void **)&this[7], v2, v4);
    this[6].i32[1] -= v4;
    *(void *)&this[7] += v4;
  }
  else
  {
    double result = (int8x8_t *)this[7];
    do
    {
      if (v4 >= v5) {
        size_t v7 = v5;
      }
      else {
        size_t v7 = v4;
      }
      memcpy(result, v2, v7);
      size_t v8 = this[6].u32[0];
      if (v7 == this[6].i32[1])
      {
        PCHash128::addData(this + 4, (const unsigned __int8 *)&this[8], v8);
        unsigned __int32 v5 = this[6].u32[0];
        double result = this + 8;
      }
      else
      {
        unsigned __int32 v5 = v8 - v7;
        double result = (int8x8_t *)((char *)this + v7 + 64);
      }
      this[6].i32[1] = v5;
      this[7] = (int8x8_t)result;
      v2 += v7;
      v4 -= v7;
    }
    while (v4);
  }
  return result;
}

int8x8_t *PCHashWriteStream::writeValue(int8x8_t *this, char a2)
{
  __int32 v2 = this;
  char __src = a2;
  __int32 v3 = this[6].i32[1];
  if (v3)
  {
    **(unsigned char **)&this[7] = a2;
    --this[6].i32[1];
    ++*(void *)&this[7];
  }
  else
  {
    unsigned __int32 v4 = this + 8;
    this = (int8x8_t *)this[7];
    p_src = &__src;
    do
    {
      __int32 v6 = v3;
      size_t v7 = v3 != 0;
      memcpy(this, p_src, v7);
      size_t v8 = v2[6].u32[0];
      if (v2[6].i32[1] == v7)
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        __int32 v3 = v2[6].i32[0];
        this = v2 + 8;
      }
      else
      {
        __int32 v3 = v8 - v7;
        this = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)this;
      p_src += v7;
    }
    while (!v6);
  }
  return this;
}

int8x8_t *PCHashWriteStream::writeValue(int8x8_t *this, __int16 a2)
{
  __int32 v2 = this;
  __int16 __src = a2;
  unsigned int v3 = this[6].u32[1];
  if (v3 <= 1)
  {
    unsigned __int32 v4 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v5 = 2;
    p_src = &__src;
    do
    {
      if (v5 >= v3) {
        size_t v7 = v3;
      }
      else {
        size_t v7 = v5;
      }
      memcpy(this, p_src, v7);
      size_t v8 = v2[6].u32[0];
      if (v7 == v2[6].i32[1])
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        unsigned int v3 = v2[6].u32[0];
        this = v2 + 8;
      }
      else
      {
        unsigned int v3 = v8 - v7;
        this = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)this;
      p_src = (__int16 *)((char *)p_src + v7);
      v5 -= v7;
    }
    while (v5);
  }
  else
  {
    **(_WORD **)&this[7] = a2;
    this[6].i32[1] -= 2;
    *(void *)&this[7] += 2;
  }
  return this;
}

int8x8_t *PCHashWriteStream::writeData(int8x8_t *this, char *__src, size_t __n)
{
  unsigned int v3 = __n;
  unsigned __int32 v4 = __src;
  unsigned int v6 = this[6].u32[1];
  if (v6 >= __n)
  {
    double result = (int8x8_t *)memcpy(*(void **)&this[7], __src, __n);
    this[6].i32[1] -= v3;
    *(void *)&this[7] += v3;
  }
  else
  {
    size_t v7 = this + 8;
    double result = (int8x8_t *)this[7];
    do
    {
      if (v3 >= v6) {
        size_t v9 = v6;
      }
      else {
        size_t v9 = v3;
      }
      memcpy(result, v4, v9);
      size_t v10 = this[6].u32[0];
      if (v9 == this[6].i32[1])
      {
        PCHash128::addData(this + 4, (const unsigned __int8 *)&this[8], v10);
        unsigned int v6 = this[6].u32[0];
        double result = this + 8;
      }
      else
      {
        unsigned int v6 = v10 - v9;
        double result = (int8x8_t *)((char *)v7 + v9);
      }
      this[6].i32[1] = v6;
      this[7] = (int8x8_t)result;
      v4 += v9;
      v3 -= v9;
    }
    while (v3);
  }
  return result;
}

int8x8_t *PCHashWriteStream::writeAttribute(int8x8_t *this, unsigned int a2, int a3)
{
  unsigned int v3 = this;
  int __src = a3;
  unsigned int v4 = this[6].u32[1];
  if (v4 <= 3)
  {
    unsigned int v5 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v6 = 4;
    p_src = &__src;
    do
    {
      if (v6 >= v4) {
        size_t v8 = v4;
      }
      else {
        size_t v8 = v6;
      }
      memcpy(this, p_src, v8);
      size_t v9 = v3[6].u32[0];
      if (v8 == v3[6].i32[1])
      {
        PCHash128::addData(v3 + 4, (const unsigned __int8 *)&v3[8], v9);
        unsigned int v4 = v3[6].u32[0];
        this = v3 + 8;
      }
      else
      {
        unsigned int v4 = v9 - v8;
        this = (int8x8_t *)((char *)v5 + v8);
      }
      v3[6].i32[1] = v4;
      v3[7] = (int8x8_t)this;
      p_src = (int *)((char *)p_src + v8);
      v6 -= v8;
    }
    while (v6);
  }
  else
  {
    **(_DWORD **)&this[7] = a3;
    this[6].i32[1] -= 4;
    *(void *)&this[7] += 4;
  }
  return this;
}

{
  int8x8_t *v3;
  unsigned int v4;
  int8x8_t *v5;
  unsigned int v6;
  int *p_src;
  size_t v8;
  size_t v9;
  int __src;

  unsigned int v3 = this;
  int __src = a3;
  unsigned int v4 = this[6].u32[1];
  if (v4 <= 3)
  {
    unsigned int v5 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v6 = 4;
    p_src = &__src;
    do
    {
      if (v6 >= v4) {
        size_t v8 = v4;
      }
      else {
        size_t v8 = v6;
      }
      memcpy(this, p_src, v8);
      size_t v9 = v3[6].u32[0];
      if (v8 == v3[6].i32[1])
      {
        PCHash128::addData(v3 + 4, (const unsigned __int8 *)&v3[8], v9);
        unsigned int v4 = v3[6].u32[0];
        this = v3 + 8;
      }
      else
      {
        unsigned int v4 = v9 - v8;
        this = (int8x8_t *)((char *)v5 + v8);
      }
      v3[6].i32[1] = v4;
      v3[7] = (int8x8_t)this;
      p_src = (int *)((char *)p_src + v8);
      v6 -= v8;
    }
    while (v6);
  }
  else
  {
    **(_DWORD **)&this[7] = a3;
    this[6].i32[1] -= 4;
    *(void *)&this[7] += 4;
  }
  return this;
}

int8x8_t *PCHashWriteStream::writeAttribute(int8x8_t *this, unsigned int a2, uint64_t a3)
{
  unsigned int v3 = this;
  uint64_t __src = a3;
  unsigned int v4 = this[6].u32[1];
  if (v4 <= 7)
  {
    unsigned int v5 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v6 = 8;
    p_src = &__src;
    do
    {
      if (v6 >= v4) {
        size_t v8 = v4;
      }
      else {
        size_t v8 = v6;
      }
      memcpy(this, p_src, v8);
      size_t v9 = v3[6].u32[0];
      if (v8 == v3[6].i32[1])
      {
        PCHash128::addData(v3 + 4, (const unsigned __int8 *)&v3[8], v9);
        unsigned int v4 = v3[6].u32[0];
        this = v3 + 8;
      }
      else
      {
        unsigned int v4 = v9 - v8;
        this = (int8x8_t *)((char *)v5 + v8);
      }
      v3[6].i32[1] = v4;
      v3[7] = (int8x8_t)this;
      p_src = (uint64_t *)((char *)p_src + v8);
      v6 -= v8;
    }
    while (v6);
  }
  else
  {
    **(void **)&this[7] = a3;
    this[6].i32[1] -= 8;
    *(void *)&this[7] += 8;
  }
  return this;
}

{
  int8x8_t *v3;
  unsigned int v4;
  int8x8_t *v5;
  unsigned int v6;
  uint64_t *p_src;
  size_t v8;
  size_t v9;
  uint64_t __src;

  unsigned int v3 = this;
  uint64_t __src = a3;
  unsigned int v4 = this[6].u32[1];
  if (v4 <= 7)
  {
    unsigned int v5 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v6 = 8;
    p_src = &__src;
    do
    {
      if (v6 >= v4) {
        size_t v8 = v4;
      }
      else {
        size_t v8 = v6;
      }
      memcpy(this, p_src, v8);
      size_t v9 = v3[6].u32[0];
      if (v8 == v3[6].i32[1])
      {
        PCHash128::addData(v3 + 4, (const unsigned __int8 *)&v3[8], v9);
        unsigned int v4 = v3[6].u32[0];
        this = v3 + 8;
      }
      else
      {
        unsigned int v4 = v9 - v8;
        this = (int8x8_t *)((char *)v5 + v8);
      }
      v3[6].i32[1] = v4;
      v3[7] = (int8x8_t)this;
      p_src = (uint64_t *)((char *)p_src + v8);
      v6 -= v8;
    }
    while (v6);
  }
  else
  {
    **(void **)&this[7] = a3;
    this[6].i32[1] -= 8;
    *(void *)&this[7] += 8;
  }
  return this;
}

int8x8_t *PCHashWriteStream::writeAttribute(int8x8_t *this, float a2)
{
  __int32 v2 = this;
  float __src = a2;
  unsigned int v3 = this[6].u32[1];
  if (v3 <= 3)
  {
    unsigned int v4 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v5 = 4;
    p_src = &__src;
    do
    {
      if (v5 >= v3) {
        size_t v7 = v3;
      }
      else {
        size_t v7 = v5;
      }
      memcpy(this, p_src, v7);
      size_t v8 = v2[6].u32[0];
      if (v7 == v2[6].i32[1])
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        unsigned int v3 = v2[6].u32[0];
        this = v2 + 8;
      }
      else
      {
        unsigned int v3 = v8 - v7;
        this = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)this;
      p_src = (float *)((char *)p_src + v7);
      v5 -= v7;
    }
    while (v5);
  }
  else
  {
    *(float *)this[7].i32[0] = a2;
    this[6].i32[1] -= 4;
    *(void *)&this[7] += 4;
  }
  return this;
}

int8x8_t *PCHashWriteStream::writeAttribute(int8x8_t *this, double a2)
{
  __int32 v2 = this;
  double __src = a2;
  unsigned int v3 = this[6].u32[1];
  if (v3 <= 7)
  {
    unsigned int v4 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v5 = 8;
    p_src = &__src;
    do
    {
      if (v5 >= v3) {
        size_t v7 = v3;
      }
      else {
        size_t v7 = v5;
      }
      memcpy(this, p_src, v7);
      size_t v8 = v2[6].u32[0];
      if (v7 == v2[6].i32[1])
      {
        PCHash128::addData(v2 + 4, (const unsigned __int8 *)&v2[8], v8);
        unsigned int v3 = v2[6].u32[0];
        this = v2 + 8;
      }
      else
      {
        unsigned int v3 = v8 - v7;
        this = (int8x8_t *)((char *)v4 + v7);
      }
      v2[6].i32[1] = v3;
      v2[7] = (int8x8_t)this;
      p_src = (double *)((char *)p_src + v7);
      v5 -= v7;
    }
    while (v5);
  }
  else
  {
    *(double *)this[7] = a2;
    this[6].i32[1] -= 8;
    *(void *)&this[7] += 8;
  }
  return this;
}

int8x8_t *PCHashWriteStream::writeAttribute(int8x8_t *result, uint64_t a2, long long *a3)
{
  unsigned int v3 = result;
  long long v10 = *a3;
  unsigned int v4 = result[6].u32[1];
  if (v4 <= 0xF)
  {
    unsigned int v5 = result + 8;
    double result = (int8x8_t *)result[7];
    unsigned int v6 = 16;
    size_t v7 = &v10;
    do
    {
      if (v6 >= v4) {
        size_t v8 = v4;
      }
      else {
        size_t v8 = v6;
      }
      memcpy(result, v7, v8);
      size_t v9 = v3[6].u32[0];
      if (v8 == v3[6].i32[1])
      {
        PCHash128::addData(v3 + 4, (const unsigned __int8 *)&v3[8], v9);
        unsigned int v4 = v3[6].u32[0];
        double result = v3 + 8;
      }
      else
      {
        unsigned int v4 = v9 - v8;
        double result = (int8x8_t *)((char *)v5 + v8);
      }
      v3[6].i32[1] = v4;
      v3[7] = (int8x8_t)result;
      size_t v7 = (long long *)((char *)v7 + v8);
      v6 -= v8;
    }
    while (v6);
  }
  else
  {
    *(_OWORD *)*(void *)&result[7] = v10;
    result[6].i32[1] -= 16;
    *(void *)&result[7] += 16;
  }
  return result;
}

int8x8_t *PCHashWriteStream::writeAttribute(int8x8_t *this, unsigned int a2, const CMTime *__src)
{
  unsigned int v3 = __src;
  unsigned int v4 = this;
  unsigned int v5 = this[6].u32[1];
  if (v5 <= 0x17)
  {
    size_t v8 = this + 8;
    this = (int8x8_t *)this[7];
    unsigned int v9 = 24;
    do
    {
      if (v9 >= v5) {
        size_t v10 = v5;
      }
      else {
        size_t v10 = v9;
      }
      memcpy(this, v3, v10);
      size_t v11 = v4[6].u32[0];
      if (v10 == v4[6].i32[1])
      {
        PCHash128::addData(v4 + 4, (const unsigned __int8 *)&v4[8], v11);
        unsigned int v5 = v4[6].u32[0];
        this = v4 + 8;
      }
      else
      {
        unsigned int v5 = v11 - v10;
        this = (int8x8_t *)((char *)v8 + v10);
      }
      v4[6].i32[1] = v5;
      v4[7] = (int8x8_t)this;
      unsigned int v3 = (const CMTime *)((char *)v3 + v10);
      v9 -= v10;
    }
    while (v9);
  }
  else
  {
    int8x8_t v6 = this[7];
    long long v7 = *(_OWORD *)&__src->value;
    *(void *)(*(void *)&v6 + 16) = __src->epoch;
    *(_OWORD *)*(void *)&int8x8_t v6 = v7;
    this[6].i32[1] -= 24;
    *(void *)&this[7] += 24;
  }
  return this;
}

uint64_t PCHashWriteStream::writeAttribute(PCHashWriteStream *this, unsigned int a2, const PCString *a3)
{
  return (*(uint64_t (**)(PCHashWriteStream *, const PCString *))(*(void *)this + 104))(this, a3);
}

int8x8_t *PCHashWriteStream::getHash(int8x8_t *this)
{
  __int32 v3 = this[6].i32[0];
  __int32 v2 = this[6].i32[1];
  if (v3 != v2)
  {
    PCHash128::addData(this + 4, (const unsigned __int8 *)&this[8], (v3 - v2));
    __int32 v2 = this[6].i32[0];
  }
  this[6].i32[1] = v2;
  this[7] = (int8x8_t)&this[8];
  return this + 4;
}

__n128 PCHashWriteStream::setHash(__n128 *this, __n128 *a2)
{
  this[3].n128_u32[1] = this[3].n128_u32[0];
  this[3].n128_u64[1] = (unint64_t)this[4].n128_u64;
  __n128 result = *a2;
  this[2] = *a2;
  return result;
}

uint64_t PCHashWriteStream::isHashStream(PCHashWriteStream *this)
{
  return 1;
}

uint64_t PCSerializerWriteStream::isHashStream(PCSerializerWriteStream *this)
{
  return 0;
}

void PCSerializerReadStream::~PCSerializerReadStream(PCSerializerReadStream *this)
{
  *(void *)this = &unk_1F10C4060;
  for (uint64_t i = (void *)((char *)this + 8); ; std::deque<unsigned long>::__maybe_remove_back_spare[abi:ne180100](i, 1))
  {
    uint64_t v3 = *((void *)this + 6);
    if (!v3) {
      break;
    }
    (*(void (**)(PCSerializerReadStream *, void))(*(void *)this + 48))(this, *(void *)(*(void *)(*((void *)this + 2)+ (((unint64_t)(v3 + *((void *)this + 5) - 1) >> 6) & 0x3FFFFFFFFFFFFF8))+ 8 * ((v3 + *((void *)this + 5) - 1) & 0x1FF)));
    --*((void *)this + 6);
  }
  std::deque<PCSerializerReadStream::HandlerInfo>::~deque[abi:ne180100]((void *)this + 7);
  std::deque<unsigned long>::~deque[abi:ne180100](i);
}

uint64_t PCSerializerReadStream::pushHandler(PCSerializerReadStream *this, PCSerializer *a2)
{
  long long __p = 0;
  unsigned int v9 = 0;
  uint64_t v10 = 0;
  size_t v11 = a2;
  uint64_t v4 = *((void *)this + 6);
  if (v4) {
    uint64_t v12 = *(void *)(*(void *)(*((void *)this + 2)
  }
                                + (((unint64_t)(v4 + *((void *)this + 5) - 1) >> 6) & 0x3FFFFFFFFFFFFF8))
                    + 8 * ((v4 + *((void *)this + 5) - 1) & 0x1FF));
  __n128 v5 = std::deque<PCSerializerReadStream::HandlerInfo>::push_back((void *)this + 7, (uint64_t)&__p);
  uint64_t v6 = (*(uint64_t (**)(PCSerializer *, PCSerializerReadStream *, __n128))(*(void *)a2 + 40))(a2, this, v5);
  if (__p)
  {
    unsigned int v9 = __p;
    operator delete(__p);
  }
  return v6;
}

void sub_1B76C3A30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *PCSerializerReadStream::popHandler(void *this)
{
  uint64_t v1 = this[12];
  if (v1)
  {
    __int32 v2 = this;
    uint64_t v3 = this + 7;
    uint64_t v4 = *(void *)(*(void *)(this[8] + 8 * ((v1 + this[11] - 1) / 0x66uLL))
                   + 40 * ((v1 + this[11] - 1) % 0x66uLL)
                   + 24);
    (*(void (**)(uint64_t, void *))(*(void *)v4 + 48))(v4, v2);
    return (void *)std::deque<PCSerializerReadStream::HandlerInfo>::pop_back(v3);
  }
  return this;
}

void *PCSerializerReadStream::popAllHandlers(void *this)
{
  uint64_t v1 = this[12];
  if (v1)
  {
    __int32 v2 = this;
    uint64_t v3 = this + 7;
    do
    {
      uint64_t v4 = *(void *)(*(void *)(v2[8] + 8 * ((v1 + v2[11] - 1) / 0x66uLL)) + 40 * ((v1 + v2[11] - 1) % 0x66uLL) + 24);
      (*(void (**)(uint64_t, void *))(*(void *)v4 + 48))(v4, v2);
      this = (void *)std::deque<PCSerializerReadStream::HandlerInfo>::pop_back(v3);
      uint64_t v1 = v2[12];
    }
    while (v1);
  }
  return this;
}

uint64_t PCSerializerReadStream::ignoreElement(PCSerializerReadStream *this)
{
  {
    uint64_t v3 = this;
    this = v3;
    if (v2)
    {
      __cxa_atexit((void (*)(void *))PCIgnoreElement::~PCIgnoreElement, &PCSerializerReadStream::ignoreElement(void)::ignoreHandler, &dword_1B73F3000);
      this = v3;
    }
  }

  return PCSerializerReadStream::pushHandler(this, (PCSerializer *)&PCSerializerReadStream::ignoreElement(void)::ignoreHandler);
}

void PCSerializerReadStream::pushElement(PCSerializerReadStream *this, PCStreamElement *a2)
{
  int v2 = a2;
  std::deque<PCStreamElement *>::push_back((void *)this + 1, &v2);
}

void *PCSerializerReadStream::popElement(void *this)
{
  uint64_t v1 = this[6];
  if (v1)
  {
    int v2 = this;
    uint64_t v3 = this + 1;
    (*(void (**)(void *, void))(*this + 48))(this, *(void *)(*(void *)(this[2] + (((unint64_t)(v1 + this[5] - 1) >> 6) & 0x3FFFFFFFFFFFFF8))+ 8 * ((v1 + this[5] - 1) & 0x1FF)));
    --v2[6];
    return (void *)std::deque<unsigned long>::__maybe_remove_back_spare[abi:ne180100](v3, 1);
  }
  return this;
}

void PCSerializerReadStream::pushScope(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[12];
  if (v2)
  {
    uint64_t v4 = (void **)(*(void *)(a1[8] + 8 * ((v2 + a1[11] - 1) / 0x66uLL)) + 40 * ((v2 + a1[11] - 1) % 0x66uLL));
    __n128 v5 = v4[1];
    unint64_t v6 = (unint64_t)v4[2];
    if ((unint64_t)v5 >= v6)
    {
      uint64_t v8 = ((char *)v5 - (unsigned char *)*v4) >> 3;
      if ((unint64_t)(v8 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v9 = v6 - (void)*v4;
      uint64_t v10 = v9 >> 2;
      if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
        uint64_t v10 = v8 + 1;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v11 = v10;
      }
      if (v11) {
        uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(v4 + 2), v11);
      }
      else {
        uint64_t v12 = 0;
      }
      uint64_t v13 = &v12[8 * v8];
      unint64_t v14 = &v12[8 * v11];
      *(void *)uint64_t v13 = a2;
      long long v7 = v13 + 8;
      uint64_t v16 = (char *)*v4;
      uint64_t v15 = (char *)v4[1];
      if (v15 != *v4)
      {
        do
        {
          uint64_t v17 = *((void *)v15 - 1);
          v15 -= 8;
          *((void *)v13 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v17;
          v13 -= 8;
        }
        while (v15 != v16);
        uint64_t v15 = (char *)*v4;
      }
      *uint64_t v4 = v13;
      v4[1] = v7;
      void v4[2] = v14;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *__n128 v5 = a2;
      long long v7 = v5 + 1;
    }
    v4[1] = v7;
  }
}

uint64_t PCSerializerReadStream::currentElement(PCSerializerReadStream *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (v1) {
    return *(void *)(*(void *)(*((void *)this + 2)
  }
                                 + (((unint64_t)(v1 + *((void *)this + 5) - 1) >> 6) & 0x3FFFFFFFFFFFFF8))
                     + 8 * ((v1 + *((void *)this + 5) - 1) & 0x1FF));
  else {
    return 0;
  }
}

uint64_t PCSerializerReadStream::currentHandlerElement(PCSerializerReadStream *this)
{
  uint64_t v1 = *((void *)this + 12);
  if (v1) {
    return *(void *)(*(void *)(*((void *)this + 8) + 8 * ((v1 + *((void *)this + 11) - 1) / 0x66uLL))
  }
                     + 40 * ((v1 + *((void *)this + 11) - 1) % 0x66uLL)
                     + 32);
  else {
    return 0;
  }
}

BOOL PCSerializerReadStream::isLessThanVersion(PCSerializerReadStream *this, unsigned int a2, unsigned int a3)
{
  unsigned int v3 = *((_DWORD *)this + 26);
  if (v3 < a2) {
    return 1;
  }
  if (v3 == a2) {
    return *((_DWORD *)this + 27) < a3;
  }
  return 0;
}

void PCSerializerReadStream::setTimeScale(PCSerializerReadStream *this, const CMTime *a2)
{
  long long v3 = *(_OWORD *)&a2->value;
  *((void *)this + 16) = a2->epoch;
  *((_OWORD *)this + 7) = v3;
  CMTime v4 = *a2;
  *((Float64 *)this + 17) = CMTimeGetSeconds(&v4);
  *((unsigned char *)this + 144) = 1;
}

uint64_t PCSerializerReadStream::getElementInfo(void *a1, char *__s2, void *a3, void *a4, void *a5)
{
  uint64_t v5 = a1[12];
  if (!v5) {
    return 0;
  }
  unint64_t v9 = v5 + a1[11] - 1;
  uint64_t v10 = *(void *)(a1[8] + 8 * (v9 / 0x66));
  unint64_t v11 = v9 % 0x66;
  uint64_t v12 = (uint64_t *)(v10 + 40 * (v9 % 0x66));
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  uint64_t v13 = *v12;
  if (v12[1] == *v12) {
    return 0;
  }
  uint64_t v20 = v10;
  unint64_t v15 = 0;
  while (1)
  {
    uint64_t v16 = *(void *)(v13 + 8 * v15);
    *a4 = v16;
    if (v16)
    {
      uint64_t v17 = *(const char **)v16;
      if (*(void *)v16) {
        break;
      }
    }
LABEL_10:
    ++v15;
    uint64_t v13 = *v12;
    if (v15 >= (v12[1] - *v12) >> 3) {
      return 0;
    }
  }
  while (*(_DWORD *)(v16 + 12) || strcmp(v17, __s2) && strcmp(v17, "*"))
  {
    char v18 = *(const char **)(v16 + 16);
    v16 += 16;
    uint64_t v17 = v18;
    if (!v18) {
      goto LABEL_10;
    }
  }
  *a3 = v16;
  *a4 = *(void *)(*v12 + 8 * v15);
  *a5 = *(void *)(v20 + 40 * v11 + 24);
  return 1;
}

uint64_t PCSerializerReadStream::destroyElement(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

uint64_t PCSerializerReadStream::processElement(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a2 + 24);
  if (result)
  {
    *(unsigned char *)(a2 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 1;
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 56))(result, a1);
  }
  return result;
}

uint64_t PCSerializerReadStream::getAsString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a3);
}

uint64_t PCSerializerReadStream::getAsInt32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, a3);
}

uint64_t PCSerializerReadStream::getAsUInt32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 32))(a2, a3);
}

uint64_t PCSerializerReadStream::getAsUInt64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2, a3);
}

uint64_t PCSerializerReadStream::getAsDouble(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 64))(a2, a3);
}

uint64_t PCSerializerReadStream::getAsFigTime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 88))(a2, a3);
}

uint64_t PCSerializerReadStream::getAttributeAsString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 96))(a2, a3, a4);
}

uint64_t PCSerializerReadStream::getAttributeAsInt32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 104))(a2, a3, a4);
}

uint64_t PCSerializerReadStream::getAttributeAsUInt32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 112))(a2, a3, a4);
}

uint64_t PCSerializerReadStream::getAttributeAsInt64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 120))(a2, a3, a4);
}

uint64_t PCSerializerReadStream::getAttributeAsUInt64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 128))(a2, a3, a4);
}

uint64_t PCSerializerReadStream::getAttributeAsDouble(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 144))(a2, a3, a4);
}

uint64_t PCSerializerReadStream::getAttributeAsBool(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 152))(a2, a3, a4);
}

uint64_t PCSerializerReadStream::getAttributeAsUUID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 160))(a2, a3);
}

void PCIgnoreElement::~PCIgnoreElement(PCIgnoreElement *this)
{
}

uint64_t PCIgnoreElement::parseBegin(PCIgnoreElement *this, PCSerializerReadStream *a2)
{
  return 1;
}

uint64_t PCIgnoreElement::parseEnd(PCIgnoreElement *this, PCSerializerReadStream *a2)
{
  return 1;
}

uint64_t PCIgnoreElement::parseElement()
{
  return 1;
}

uint64_t std::deque<PCSerializerReadStream::HandlerInfo>::~deque[abi:ne180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  long long v3 = (void **)a1[2];
  if (v3 == v2)
  {
    CMTime v4 = a1 + 5;
    long long v3 = (void **)a1[1];
  }
  else
  {
    CMTime v4 = a1 + 5;
    unint64_t v5 = a1[4];
    unint64_t v6 = &v2[v5 / 0x66];
    unint64_t v7 = (unint64_t)*v6;
    unint64_t v8 = (unint64_t)*v6 + 40 * (v5 % 0x66);
    unint64_t v9 = (unint64_t)v2[(a1[5] + v5) / 0x66] + 40 * ((a1[5] + v5) % 0x66);
    if (v8 != v9)
    {
      do
      {
        uint64_t v10 = *(void **)v8;
        if (*(void *)v8)
        {
          *(void *)(v8 + 8) = v10;
          operator delete(v10);
          unint64_t v7 = (unint64_t)*v6;
        }
        v8 += 40;
        if (v8 - v7 == 4080)
        {
          unint64_t v11 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v11;
          unint64_t v8 = v11;
        }
      }
      while (v8 != v9);
      uint64_t v2 = (void **)a1[1];
      long long v3 = (void **)a1[2];
    }
  }
  *CMTime v4 = 0;
  unint64_t v12 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      long long v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v12 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v13 = v12 >> 3;
  if (v13 == 1)
  {
    uint64_t v14 = 51;
  }
  else
  {
    if (v13 != 2) {
      goto LABEL_18;
    }
    uint64_t v14 = 102;
  }
  a1[4] = v14;
LABEL_18:
  while (v2 != v3)
  {
    unint64_t v15 = *v2++;
    operator delete(v15);
  }

  return std::__split_buffer<unsigned long *>::~__split_buffer((uint64_t)a1);
}

void *std::vector<PCScope *>::__init_with_size[abi:ne180100]<PCScope **,PCScope **>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = std::vector<double>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B76C4588(_Unwind_Exception *exception_object)
{
  long long v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::deque<PCSerializerReadStream::HandlerInfo>::push_back(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 102 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<PCSerializerReadStream::HandlerInfo>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x66)) + 40 * (v7 % 0x66);
  *(void *)unint64_t v8 = 0;
  *(void *)(v8 + 8) = 0;
  *(void *)(v8 + 16) = 0;
  std::vector<PCScope *>::__init_with_size[abi:ne180100]<PCScope **,PCScope **>((void *)v8, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  __n128 result = *(__n128 *)(a2 + 24);
  *(__n128 *)(v8 + 24) = result;
  ++a1[5];
  return result;
}

void std::deque<PCSerializerReadStream::HandlerInfo>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x66;
  unint64_t v4 = v2 - 102;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      int8x16_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v5, v33);
      int v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      unint64_t v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFF0uLL);
      std::__split_buffer<unsigned long *>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFF0uLL);
    std::__split_buffer<unsigned long *>::push_front((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    unint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      int8x16_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 3), v46);
      int v35 = &v34[8 * (v46 >> 2)];
      int v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        unint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)unint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      int v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  int v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v54 + 8 * v26;
  int v53 = operator new(0xFF0uLL);
  std::__split_buffer<unsigned long *>::push_back(&v54, &v53);
  uint64x2_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<unsigned long *>::push_front((uint64_t)&v54, v27);
  }
  int8x16_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1B76C4944(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::deque<PCSerializerReadStream::HandlerInfo>::pop_back(void *a1)
{
  uint64_t v2 = a1[5] - 1;
  unint64_t v3 = *(void *)(a1[1] + 8 * ((v2 + a1[4]) / 0x66uLL)) + 40 * ((v2 + a1[4]) % 0x66uLL);
  unint64_t v4 = *(void **)v3;
  if (*(void *)v3)
  {
    *(void *)(v3 + 8) = v4;
    operator delete(v4);
    uint64_t v2 = a1[5] - 1;
  }
  a1[5] = v2;

  return std::deque<PCSerializerReadStream::HandlerInfo>::__maybe_remove_back_spare[abi:ne180100](a1, 1);
}

uint64_t std::deque<PCSerializerReadStream::HandlerInfo>::__maybe_remove_back_spare[abi:ne180100](void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 102 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x66) {
    a2 = 1;
  }
  if (v5 < 0xCC) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

void std::deque<PCStreamElement *>::push_back(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<PCStreamElement *>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void std::deque<PCStreamElement *>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      int8x16_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v5, v33);
      int v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      unint64_t v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<unsigned long *>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<unsigned long *>::push_front((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    unint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      int8x16_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 3), v46);
      int v35 = &v34[8 * (v46 >> 2)];
      int v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        unint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)unint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      int v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  int v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v54 + 8 * v26;
  int v53 = operator new(0x1000uLL);
  std::__split_buffer<unsigned long *>::push_back(&v54, &v53);
  uint64x2_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<unsigned long *>::push_front((uint64_t)&v54, v27);
  }
  int8x16_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1B76C4DEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void PCSerializerWriteStream::PCSerializerWriteStream(PCSerializerWriteStream *this)
{
  *(void *)this = &unk_1F10C3F60;
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *((void *)this + 3) = 0;
}

uint64_t PCSerializerWriteStream::popScope(uint64_t this)
{
  *(void *)(this + 16) -= 8;
  return this;
}

uint64_t PCStreamElement::atoUUID(PCStreamElement *this, const char **a2)
{
  uint64_t v2 = 0;
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)this;
  uint64_t v4 = MEMORY[0x1E4F14390];
LABEL_2:
  uint64_t v5 = 0;
  int v6 = 0;
  uint64_t v7 = v3 + 8;
  while (1)
  {
    unsigned int v8 = *(char *)(v3 + v5);
    if ((v8 & 0x80000000) != 0 || (*(_DWORD *)(v4 + 4 * v8 + 60) & 0x10000) == 0) {
      return 0;
    }
    v6 *= 16;
    ++v5;
    unsigned int v9 = v8 - 48;
    unsigned int v10 = v8 - 97;
    unsigned int v11 = v8 - 65;
    int v12 = v6 + v8;
    if (v11 <= 5) {
      int v6 = v12 - 55;
    }
    if (v10 <= 5) {
      int v6 = v12 - 87;
    }
    int v13 = v12 - 48;
    if (v9 <= 9) {
      int v6 = v13;
    }
    if (v5 == 8)
    {
      *((_DWORD *)&v15 + v2++) = v6;
      v3 += 8;
      if (v2 == 4)
      {
        *(void *)this = v7;
        operator new();
      }
      goto LABEL_2;
    }
  }
}

uint64_t PCStreamElement::aToFigTime(uint64_t this, const char **a2, CMTime *a3)
{
  if (this)
  {
    uint64_t v3 = (char **)this;
    uint64_t v4 = *(const char **)this;
    if (*(void *)this)
    {
      __endptr = 0;
      *__error() = 0;
      int v6 = (const char *)strtoll(v4, &__endptr, 10);
      uint64_t v7 = __error();
      this = 0;
      if (*v7 == 34) {
        return this;
      }
      int v8 = strtol(__endptr, &__endptr, 10);
      if (*__error() != 34)
      {
        int v9 = strtoull(__endptr, &__endptr, 16);
        if (*__error() != 34)
        {
          unsigned int v10 = strtoull(__endptr, &__endptr, 10);
          if (*__error() != 34)
          {
            *a2 = v6;
            *((_DWORD *)a2 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v8;
            *((_DWORD *)a2 + 3) = v9;
            a2[2] = (const char *)v10;
            *uint64_t v3 = __endptr;
            return 1;
          }
        }
      }
    }
    return 0;
  }
  return this;
}

uint64_t PCXMLStreamElement::PCXMLStreamElement(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)(a1 + 8) = a2;
  *(unsigned char *)(a1 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  *(void *)(a1 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  *(void *)a1 = &unk_1F10C4128;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 48));
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 19PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  return a1;
}

void PCXMLStreamElement::~PCXMLStreamElement(PCXMLStreamElement *this)
{
  *(void *)this = &unk_1F10C4128;
  uint64_t v2 = (void *)*((void *)this + 8);
  if (v2) {
    free(v2);
  }
  uint64_t v3 = *((void *)this + 24);
  if (v3)
  {
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(*((void *)this + 24), *(void **)(v3 + 8));
    MEMORY[0x1BA9BFBA0](v3, 0x1020C4062D53EE8);
  }
  *((void *)this + 24) = 0;
  PCString::~PCString((PCString *)this + 6);
}

{
  uint64_t vars8;

  PCXMLStreamElement::~PCXMLStreamElement(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PCXMLStreamElement::getAsString(PCString *this, PCString *a2)
{
  uint64_t v4 = this + 6;
  if (PCString::empty(this + 6))
  {
    var0 = (const char *)this[8].var0;
    if (var0)
    {
      CFStringRef v6 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], var0, 0x8000100u);
      if (CFStringFind(v6, @"&", 0).location == -1)
      {
        CFMutableStringRef MutableCopy = (__CFString *)CFRetain(v6);
      }
      else
      {
        CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v6);
        v9.length = CFStringGetLength(MutableCopy);
        v9.locatiouint64_t n = 0;
        CFStringFindAndReplace(MutableCopy, @"&amp;", @"&", v9, 0);
        v10.length = CFStringGetLength(MutableCopy);
        v10.locatiouint64_t n = 0;
        CFStringFindAndReplace(MutableCopy, @"&lt;", @"<", v10, 0);
        v11.length = CFStringGetLength(MutableCopy);
        v11.locatiouint64_t n = 0;
        CFStringFindAndReplace(MutableCopy, @"&gt;", @">", v11, 0);
        v12.length = CFStringGetLength(MutableCopy);
        v12.locatiouint64_t n = 0;
        CFStringFindAndReplace(MutableCopy, @"&quot;", @"\"", v12, 0);
      }
      CFRelease(v6);
      PCString::set(v4, MutableCopy);
      CFRelease(MutableCopy);
    }
  }
  PCString::set(a2, v4);
  return 1;
}

uint64_t PCXMLStreamElement::getAsInt32(PCXMLStreamElement *this, int *a2)
{
  uint64_t v2 = (unsigned char *)*((void *)this + 7);
  if (!v2 || !*v2) {
    return 0;
  }
  __endptr = 0;
  *__error() = 0;
  *a2 = strtol(*((const char **)this + 7), &__endptr, 10);
  uint64_t v5 = __error();
  uint64_t result = 0;
  if (*v5 != 34)
  {
    uint64_t v7 = __endptr - 1;
    uint64_t v8 = MEMORY[0x1E4F14390];
    do
    {
      unsigned int v9 = v7[1];
      if ((v9 & 0x80000000) != 0) {
        int v10 = __maskrune(v9, 0x4000uLL);
      }
      else {
        int v10 = *(_DWORD *)(v8 + 4 * v9 + 60) & 0x4000;
      }
      ++v7;
    }
    while (v10);
    *((void *)this + 7) = v7;
    return 1;
  }
  return result;
}

uint64_t PCXMLStreamElement::getAsUInt32(PCXMLStreamElement *this, unsigned int *a2)
{
  uint64_t v2 = (unsigned char *)*((void *)this + 7);
  if (!v2 || !*v2) {
    return 0;
  }
  __endptr = 0;
  *__error() = 0;
  *a2 = strtoul(*((const char **)this + 7), &__endptr, 10);
  uint64_t v5 = __error();
  uint64_t result = 0;
  if (*v5 != 34)
  {
    uint64_t v7 = __endptr - 1;
    uint64_t v8 = MEMORY[0x1E4F14390];
    do
    {
      unsigned int v9 = v7[1];
      if ((v9 & 0x80000000) != 0) {
        int v10 = __maskrune(v9, 0x4000uLL);
      }
      else {
        int v10 = *(_DWORD *)(v8 + 4 * v9 + 60) & 0x4000;
      }
      ++v7;
    }
    while (v10);
    *((void *)this + 7) = v7;
    return 1;
  }
  return result;
}

uint64_t PCXMLStreamElement::getAsInt64(PCXMLStreamElement *this, uint64_t *a2)
{
  uint64_t v2 = (unsigned char *)*((void *)this + 7);
  if (!v2 || !*v2) {
    return 0;
  }
  __endptr = 0;
  *__error() = 0;
  *a2 = strtoll(*((const char **)this + 7), &__endptr, 10);
  uint64_t v5 = __error();
  uint64_t result = 0;
  if (*v5 != 34)
  {
    uint64_t v7 = __endptr - 1;
    uint64_t v8 = MEMORY[0x1E4F14390];
    do
    {
      unsigned int v9 = v7[1];
      if ((v9 & 0x80000000) != 0) {
        int v10 = __maskrune(v9, 0x4000uLL);
      }
      else {
        int v10 = *(_DWORD *)(v8 + 4 * v9 + 60) & 0x4000;
      }
      ++v7;
    }
    while (v10);
    *((void *)this + 7) = v7;
    return 1;
  }
  return result;
}

uint64_t PCXMLStreamElement::getAsUInt64(PCXMLStreamElement *this, unint64_t *a2)
{
  uint64_t v2 = (unsigned char *)*((void *)this + 7);
  if (!v2 || !*v2) {
    return 0;
  }
  __endptr = 0;
  *__error() = 0;
  *a2 = strtoull(*((const char **)this + 7), &__endptr, 10);
  uint64_t v5 = __error();
  uint64_t result = 0;
  if (*v5 != 34)
  {
    uint64_t v7 = __endptr - 1;
    uint64_t v8 = MEMORY[0x1E4F14390];
    do
    {
      unsigned int v9 = v7[1];
      if ((v9 & 0x80000000) != 0) {
        int v10 = __maskrune(v9, 0x4000uLL);
      }
      else {
        int v10 = *(_DWORD *)(v8 + 4 * v9 + 60) & 0x4000;
      }
      ++v7;
    }
    while (v10);
    *((void *)this + 7) = v7;
    return 1;
  }
  return result;
}

uint64_t PCXMLStreamElement::getAsFloat(PCXMLStreamElement *this, float *a2)
{
  uint64_t v2 = (unsigned char *)*((void *)this + 7);
  if (!v2) {
    return 0;
  }
  CFRange v11 = 0;
  if (!*v2) {
    return 0;
  }
  *__error() = 0;
  *a2 = strtof(*((const char **)this + 7), &v11);
  uint64_t v5 = __error();
  uint64_t result = 0;
  if (*v5 != 34)
  {
    uint64_t v7 = v11;
    uint64_t v8 = MEMORY[0x1E4F14390];
    while (1)
    {
      unsigned int v9 = *v7;
      if (!((v9 & 0x80000000) != 0 ? __maskrune(v9, 0x4000uLL) : *(_DWORD *)(v8 + 4 * v9 + 60) & 0x4000)) {
        break;
      }
      uint64_t v7 = ++v11;
    }
    *((void *)this + 7) = v11;
    return 1;
  }
  return result;
}

uint64_t PCXMLStreamElement::getAsDouble(PCXMLStreamElement *this, double *a2)
{
  uint64_t v2 = (unsigned char *)*((void *)this + 7);
  if (!v2) {
    return 0;
  }
  CFRange v11 = 0;
  if (!*v2) {
    return 0;
  }
  *__error() = 0;
  *a2 = strtod(*((const char **)this + 7), &v11);
  uint64_t v5 = __error();
  uint64_t result = 0;
  if (*v5 != 34)
  {
    uint64_t v7 = v11;
    uint64_t v8 = MEMORY[0x1E4F14390];
    while (1)
    {
      unsigned int v9 = *v7;
      if (!((v9 & 0x80000000) != 0 ? __maskrune(v9, 0x4000uLL) : *(_DWORD *)(v8 + 4 * v9 + 60) & 0x4000)) {
        break;
      }
      uint64_t v7 = ++v11;
    }
    *((void *)this + 7) = v11;
    return 1;
  }
  return result;
}

uint64_t PCXMLStreamElement::getAsBool(PCXMLStreamElement *this, BOOL *a2)
{
  uint64_t v2 = (unsigned char *)*((void *)this + 7);
  if (!v2 || !*v2) {
    return 0;
  }
  __endptr = 0;
  *__error() = 0;
  *a2 = strtoul(*((const char **)this + 7), &__endptr, 10) != 0;
  uint64_t v5 = __error();
  uint64_t result = 0;
  if (*v5 != 34)
  {
    uint64_t v7 = __endptr - 1;
    uint64_t v8 = MEMORY[0x1E4F14390];
    do
    {
      unsigned int v9 = v7[1];
      if ((v9 & 0x80000000) != 0) {
        int v10 = __maskrune(v9, 0x4000uLL);
      }
      else {
        int v10 = *(_DWORD *)(v8 + 4 * v9 + 60) & 0x4000;
      }
      ++v7;
    }
    while (v10);
    *((void *)this + 7) = v7;
    return 1;
  }
  return result;
}

uint64_t PCXMLStreamElement::getAsUUID(PCXMLStreamElement *this, const char **a2)
{
  uint64_t v4 = (unsigned char *)*((void *)this + 7);
  uint64_t v2 = (PCXMLStreamElement *)((char *)this + 56);
  uint64_t v3 = v4;
  if (v4 && *v3) {
    return PCStreamElement::atoUUID(v2, a2);
  }
  else {
    return 0;
  }
}

uint64_t PCXMLStreamElement::getAsFigTime(PCXMLStreamElement *this, CMTime *a2, CMTime *a3)
{
  uint64_t v5 = (unsigned char *)*((void *)this + 7);
  uint64_t v3 = (char *)this + 56;
  uint64_t v4 = v5;
  if (v5 && *v4) {
    return PCStreamElement::aToFigTime((uint64_t)v3, (const char **)a2, a3);
  }
  else {
    return 0;
  }
}

uint64_t **PCXMLStreamElement::addAttribute(uint64_t **this, unsigned int a2, const char *a3)
{
  unsigned int v7 = a2;
  uint64_t v4 = *((unsigned int *)this + 46);
  if (v4 > 6)
  {
    CFStringRef v6 = (uint64_t **)this[24];
    if (!v6) {
      operator new();
    }
    uint64_t v8 = &v7;
    this = std::__tree<std::__value_type<unsigned int,PVImageBuffer * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVImageBuffer * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVImageBuffer * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(v6, &v7, (uint64_t)&std::piecewise_construct, &v8);
    this[5] = (uint64_t *)a3;
  }
  else
  {
    uint64_t v5 = &this[2 * v4];
    *((_DWORD *)v5 + 18) = a2;
    v5[10] = (uint64_t *)a3;
    *((_DWORD *)this + 46) = v4 + 1;
  }
  return this;
}

uint64_t PCXMLStreamElement::addAttribute(uint64_t this, const char *__s2, const char *a3)
{
  uint64_t v3 = *(uint64_t **)(this + 16);
  if (v3)
  {
    uint64_t v4 = this;
    this = *v3;
    if (*v3)
    {
      unsigned int v7 = v3 + 2;
      do
      {
        if (*((_DWORD *)v7 - 2) == *(_DWORD *)(v4 + 8))
        {
          unsigned int v8 = *((_DWORD *)v7 - 1);
          if (v8)
          {
            if (!strcmp((const char *)this, __s2)) {
              PCXMLStreamElement::addAttribute((uint64_t **)v4, v8, a3);
            }
          }
        }
        uint64_t v9 = *v7;
        v7 += 2;
        this = v9;
      }
      while (v9);
    }
  }
  return this;
}

uint64_t PCXMLStreamElement::getAttributeAsCString(PCXMLStreamElement *this, unsigned int a2)
{
  uint64_t v2 = *((unsigned int *)this + 46);
  if (v2)
  {
    uint64_t v3 = (char *)this + 80;
    while (*((_DWORD *)v3 - 2) != a2)
    {
      v3 += 16;
      if (!--v2) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    uint64_t v4 = *((void *)this + 24);
    if (!v4) {
      return 0;
    }
    uint64_t v7 = *(void *)(v4 + 8);
    uint64_t v5 = v4 + 8;
    uint64_t v6 = v7;
    if (!v7) {
      return 0;
    }
    uint64_t v8 = v5;
    do
    {
      unsigned int v9 = *(_DWORD *)(v6 + 32);
      BOOL v10 = v9 >= a2;
      if (v9 >= a2) {
        CFRange v11 = (uint64_t *)v6;
      }
      else {
        CFRange v11 = (uint64_t *)(v6 + 8);
      }
      if (v10) {
        uint64_t v8 = v6;
      }
      uint64_t v6 = *v11;
    }
    while (*v11);
    if (v8 == v5 || *(_DWORD *)(v8 + 32) > a2) {
      return 0;
    }
    uint64_t v3 = (char *)(v8 + 40);
  }
  return *(void *)v3;
}

uint64_t PCXMLStreamElement::getAttributeAsString(PCXMLStreamElement *this, unsigned int a2, PCString *a3)
{
  uint64_t v4 = *((unsigned int *)this + 46);
  if (v4)
  {
    uint64_t v5 = (const char **)((char *)this + 80);
    while (*((_DWORD *)v5 - 2) != a2)
    {
      v5 += 2;
      if (!--v4) {
        goto LABEL_5;
      }
    }
    PCString::PCString(&v15, *v5);
    PCString::set(a3, &v15);
  }
  else
  {
LABEL_5:
    uint64_t v6 = *((void *)this + 24);
    if (!v6) {
      return 0;
    }
    uint64_t v9 = *(void *)(v6 + 8);
    uint64_t v7 = v6 + 8;
    uint64_t v8 = v9;
    if (!v9) {
      return 0;
    }
    uint64_t v10 = v7;
    do
    {
      unsigned int v11 = *(_DWORD *)(v8 + 32);
      BOOL v12 = v11 >= a2;
      if (v11 >= a2) {
        int v13 = (uint64_t *)v8;
      }
      else {
        int v13 = (uint64_t *)(v8 + 8);
      }
      if (v12) {
        uint64_t v10 = v8;
      }
      uint64_t v8 = *v13;
    }
    while (*v13);
    if (v10 == v7 || *(_DWORD *)(v10 + 32) > a2) {
      return 0;
    }
    PCString::PCString(&v15, *(const char **)(v10 + 40));
    PCString::set(a3, &v15);
  }
  PCString::~PCString(&v15);
  return 1;
}

void sub_1B76C5B34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

const char *PCXMLStreamElement::getAttributeAsInt32(PCXMLStreamElement *this, unsigned int a2, int *a3)
{
  uint64_t result = (const char *)PCXMLStreamElement::getAttributeAsCString(this, a2);
  if (result)
  {
    uint64_t v5 = result;
    *__error() = 0;
    *a3 = strtol(v5, 0, 10);
    return (const char *)(*__error() != 34);
  }
  return result;
}

const char *PCXMLStreamElement::getAttributeAsUInt32(PCXMLStreamElement *this, unsigned int a2, unsigned int *a3)
{
  uint64_t result = (const char *)PCXMLStreamElement::getAttributeAsCString(this, a2);
  if (result)
  {
    uint64_t v5 = result;
    *__error() = 0;
    *a3 = strtoul(v5, 0, 10);
    return (const char *)(*__error() != 34);
  }
  return result;
}

const char *PCXMLStreamElement::getAttributeAsInt64(PCXMLStreamElement *this, unsigned int a2, uint64_t *a3)
{
  uint64_t result = (const char *)PCXMLStreamElement::getAttributeAsCString(this, a2);
  if (result)
  {
    uint64_t v5 = result;
    *__error() = 0;
    *a3 = strtoll(v5, 0, 10);
    return (const char *)(*__error() != 34);
  }
  return result;
}

const char *PCXMLStreamElement::getAttributeAsUInt64(PCXMLStreamElement *this, unsigned int a2, unint64_t *a3)
{
  uint64_t result = (const char *)PCXMLStreamElement::getAttributeAsCString(this, a2);
  if (result)
  {
    uint64_t v5 = result;
    *__error() = 0;
    *a3 = strtoull(v5, 0, 10);
    return (const char *)(*__error() != 34);
  }
  return result;
}

const char *PCXMLStreamElement::getAttributeAsFloat(PCXMLStreamElement *this, unsigned int a2, float *a3)
{
  uint64_t result = (const char *)PCXMLStreamElement::getAttributeAsCString(this, a2);
  if (result)
  {
    uint64_t v5 = result;
    *__error() = 0;
    *a3 = strtof(v5, 0);
    return (const char *)(*__error() != 34);
  }
  return result;
}

const char *PCXMLStreamElement::getAttributeAsDouble(PCXMLStreamElement *this, unsigned int a2, double *a3)
{
  uint64_t result = (const char *)PCXMLStreamElement::getAttributeAsCString(this, a2);
  if (result)
  {
    uint64_t v5 = result;
    *__error() = 0;
    *a3 = strtod(v5, 0);
    return (const char *)(*__error() != 34);
  }
  return result;
}

const char *PCXMLStreamElement::getAttributeAsBool(PCXMLStreamElement *this, unsigned int a2, BOOL *a3)
{
  uint64_t result = (const char *)PCXMLStreamElement::getAttributeAsCString(this, a2);
  if (result)
  {
    uint64_t v5 = result;
    *__error() = 0;
    *a3 = strtoul(v5, 0, 10) != 0;
    return (const char *)(*__error() != 34);
  }
  return result;
}

uint64_t PCXMLStreamElement::getAttributeAsUUID(PCXMLStreamElement *this, unsigned int a2)
{
  uint64_t result = PCXMLStreamElement::getAttributeAsCString(this, a2);
  if (result)
  {
    uint64_t v4 = result;
    return PCStreamElement::atoUUID((PCStreamElement *)&v4, v3);
  }
  return result;
}

uint64_t PCXMLStreamElement::getAttributeAsFigTime(PCXMLStreamElement *this, unsigned int a2, CMTime *a3)
{
  uint64_t result = PCXMLStreamElement::getAttributeAsCString(this, a2);
  if (result)
  {
    uint64_t v6 = result;
    return PCStreamElement::aToFigTime((uint64_t)&v6, (const char **)a3, v5);
  }
  return result;
}

char *PCXMLStreamElement::appendContentWithNewline(PCXMLStreamElement *this, char *a2, int a3)
{
  uint64_t result = (char *)*((void *)this + 8);
  if (result)
  {
    size_t v7 = strlen(result);
    size_t v8 = strlen(a2);
    uint64_t v9 = 1;
    if (a3) {
      uint64_t v9 = 2;
    }
    uint64_t v10 = (const char *)malloc_type_realloc(*((void **)this + 7), v7 + v9 + v8, 0x9F909D42uLL);
    unsigned int v11 = (char *)v10;
    if (a3) {
      *(_WORD *)&v10[strlen(v10)] = 10;
    }
    uint64_t result = strcat(v11, a2);
    *((void *)this + 7) = v11;
    *((void *)this + 8) = v11;
  }
  else
  {
    *((void *)this + 7) = a2;
    *((void *)this + 8) = a2;
  }
  return result;
}

uint64_t PCXMLStreamElement::isXMLStreamElement(PCXMLStreamElement *this)
{
  return 1;
}

double PC_CMTimeSaferAdd@<D0>(CMTime *a1@<X0>, CMTime *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  CMTime lhs = *a1;
  CMTime rhs = *a2;
  CMTimeAdd((CMTime *)a3, &lhs, &rhs);
  if ((*(_DWORD *)(a3 + 12) & 0x1F) == 3 && ((a2->flags | a1->flags) & 2) == 0)
  {
    char v7 = SimpCMTime(a1);
    int v8 = SimpCMTime(a2);
    if ((v7 & 1) != 0 || v8)
    {
      CMTime v10 = *a1;
      CMTime v9 = *a2;
      CMTimeAdd(&v11, &v10, &v9);
      double result = *(double *)&v11.value;
      *(CMTime *)a3 = v11;
    }
  }
  return result;
}

double PC_CMTimeSaferSubtract@<D0>(CMTime *a1@<X0>, CMTime *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  CMTime lhs = *a1;
  CMTime rhs = *a2;
  CMTimeSubtract((CMTime *)a3, &lhs, &rhs);
  if ((*(_DWORD *)(a3 + 12) & 0x1F) == 3 && ((a2->flags | a1->flags) & 2) == 0)
  {
    char v7 = SimpCMTime(a1);
    int v8 = SimpCMTime(a2);
    if ((v7 & 1) != 0 || v8)
    {
      CMTime v10 = *a1;
      CMTime v9 = *a2;
      CMTimeSubtract(&v11, &v10, &v9);
      double result = *(double *)&v11.value;
      *(CMTime *)a3 = v11;
    }
  }
  return result;
}

double PC_CMTimeMultiply64Divide64@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  if (a3)
  {
    uint64_t v8 = *(void *)a1;
    int v9 = *(_DWORD *)(a1 + 8);
    int v10 = *(_DWORD *)(a1 + 12);
    if ((v10 & 0x1D) != 1)
    {
      uint64_t v15 = *(void *)(a1 + 16);
      *(void *)a4 = 0;
      *(void *)(a4 + 8) = 0;
      *(void *)(a4 + 16) = 0;
      *(void *)CMTime time = v8;
      *(_DWORD *)&time[8] = v9;
      *(_DWORD *)&time[12] = v10;
      *(void *)&time[16] = v15;
      CMTimeMultiplyByFloat64((CMTime *)a4, (CMTime *)time, (double)a2 / (double)a3);
      goto LABEL_37;
    }
    if (v9)
    {
      uint64_t v11 = v9;
      bignum_s256_init_from_s64(v8, (uint64_t *)time);
      bignum_s256_init_from_s64(a2, (uint64_t *)v27);
      if (*(void *)time == *(int *)time)
      {
        uint64_t v12 = *(void *)&time[16];
        if ((*(void *)time & 0x8000000000000000) != 0)
        {
          if (*(void *)&time[8] != -1 || *(void *)&time[16] != -1) {
            goto LABEL_20;
          }
        }
        else
        {
          uint64_t v12 = *(void *)&time[8] | *(void *)&time[16];
          if (*(_OWORD *)&time[8] != 0) {
            goto LABEL_20;
          }
        }
        if (*(void *)&time[24] != v12 || *(void *)v27 != *(int *)v27) {
          goto LABEL_20;
        }
        uint64_t v16 = *(void *)&v27[16];
        if ((*(void *)v27 & 0x8000000000000000) != 0)
        {
          if (*(_OWORD *)&v27[8] != __PAIR128__(-1, -1)) {
            goto LABEL_20;
          }
        }
        else
        {
          uint64_t v16 = *(void *)&v27[8] | *(void *)&v27[16];
          if (*(_OWORD *)&v27[8] != 0) {
            goto LABEL_20;
          }
        }
        if (*(void *)&v27[24] == v16)
        {
          bignum_s256_init_from_s64(*(void *)v27 * *(void *)time, (uint64_t *)v26);
          goto LABEL_21;
        }
      }
LABEL_20:
      bignum_s256_init_from_s64(0, (uint64_t *)v26);
      int8x16_t v24 = *(int8x16_t *)time;
      v23[0] = *(int8x16_t *)v27;
      bignum_s128_full_multiply((unint64_t *)&v24, (unint64_t *)v23, v26);
LABEL_21:
      bignum_s256_init_from_s64(v11, v24.i64);
      *(int8x16_t *)CMTime time = v24;
      *(int8x16_t *)&time[16] = v25;
      bignum_s256_init_from_s64(a3, v24.i64);
      *(int8x16_t *)uint64x2_t v27 = v24;
      *(int8x16_t *)&v27[16] = v25;
      if (*(void *)time == *(int *)time)
      {
        uint64_t v17 = *(void *)&time[16];
        if ((*(void *)time & 0x8000000000000000) != 0)
        {
          if (*(void *)&time[8] != -1 || *(void *)&time[16] != -1) {
            goto LABEL_35;
          }
        }
        else
        {
          uint64_t v17 = *(void *)&time[8] | *(void *)&time[16];
          if (*(_OWORD *)&time[8] != 0) {
            goto LABEL_35;
          }
        }
        if (*(void *)&time[24] != v17 || *(void *)v27 != *(int *)v27) {
          goto LABEL_35;
        }
        uint64_t v18 = *(void *)&v27[16];
        if ((*(void *)v27 & 0x8000000000000000) != 0)
        {
          if (*(_OWORD *)&v27[8] != __PAIR128__(-1, -1)) {
            goto LABEL_35;
          }
        }
        else
        {
          uint64_t v18 = *(void *)&v27[8] | *(void *)&v27[16];
          if (*(_OWORD *)&v27[8] != 0) {
            goto LABEL_35;
          }
        }
        if (*(void *)&v27[24] == v18)
        {
          bignum_s256_init_from_s64(*(void *)v27 * *(void *)time, v24.i64);
LABEL_36:
          *(void *)a4 = 0;
          *(void *)(a4 + 8) = 0;
          *(void *)(a4 + 16) = 0;
          v23[0] = (int8x16_t)v26[0];
          v23[1] = (int8x16_t)v26[1];
          v22[0] = v24;
          v22[1] = v25;
          IntermediateLargeInteger::makeCMTime(v23, v22, (v10 & 0x1F) == 3, 0, a4);
          goto LABEL_37;
        }
      }
LABEL_35:
      bignum_s256_init_from_s64(0, v24.i64);
      v23[0] = *(int8x16_t *)time;
      v22[0] = *(int8x16_t *)v27;
      bignum_s128_full_multiply((unint64_t *)v23, (unint64_t *)v22, &v24);
      goto LABEL_36;
    }
  }
  uint64_t v13 = MEMORY[0x1E4F1F9F8];
  long long v14 = *MEMORY[0x1E4F1F9F8];
  *(_OWORD *)a4 = *MEMORY[0x1E4F1F9F8];
  *(void *)(a4 + 16) = *(void *)(v13 + 16);
LABEL_37:
  if ((*(_DWORD *)(a4 + 12) & 0x1F) != 3)
  {
    int32_t v19 = *(_DWORD *)(a1 + 8);
    if (*(_DWORD *)(a4 + 8) > v19)
    {
      memset(time, 0, 24);
      CMTime v21 = *(CMTime *)a4;
      CMTimeConvertScale((CMTime *)time, &v21, v19, kCMTimeRoundingMethod_RoundTowardZero);
      if ((time[12] & 0x1F) != 3)
      {
        *(void *)&long long v14 = *(void *)time;
        *(_OWORD *)a4 = *(_OWORD *)time;
        *(void *)(a4 + 16) = *(void *)&time[16];
      }
    }
  }
  return *(double *)&v14;
}

uint64_t PC_CMTimeGetSampleNumber(CMTime *a1, CMTime *a2)
{
  unsigned int timescale = a1->timescale;
  if (!timescale || (a1->flags & 0x1D) != 1 || (int32_t v5 = a2->timescale) == 0 || !a2->value)
  {
    if ((~a2->flags & 0x11) != 0 && a2->value)
    {
      CMTime v18 = *a1;
      int v9 = PC_CMTimeToFractionString(&v18);
      CMTime v17 = *a2;
      int v10 = PC_CMTimeToFractionString(&v17);
      NSLog(&cfstr_ErrorPcCmtimeg.isa, v9, v10);
    }
    return 0;
  }
  if ((unint64_t)a1->value >> 63 == timescale >> 31) {
    CMTimeRoundingMethod v6 = kCMTimeRoundingMethod_RoundTowardZero;
  }
  else {
    CMTimeRoundingMethod v6 = kCMTimeRoundingMethod_RoundAwayFromZero;
  }
  memset(&v16, 0, sizeof(v16));
  CMTime time = *a1;
  CMTimeConvertScale(&v16, &time, v5, v6);
  if ((v16.flags & 0x1F) != 3) {
    return v16.value / a2->value;
  }
  memset(&v14, 0, sizeof(v14));
  CMTime v13 = *a2;
  CMTimeConvertScale(&v14, &v13, a1->timescale, v6);
  if ((v14.flags & 0x1F) == 3)
  {
    CMTime v12 = *a1;
    double Seconds = CMTimeGetSeconds(&v12);
    CMTime v11 = *a2;
    return (uint64_t)(Seconds / CMTimeGetSeconds(&v11));
  }
  if (!v14.value) {
    return 0;
  }
  return a1->value / v14.value;
}

__CFString *PC_CMTimeToFractionString(CMTime *a1)
{
  CMTimeFlags flags = a1->flags;
  if ((flags & 0x1D) != 1)
  {
    CMTime v20 = *a1;
    return PC_CMTimeToString(&v20);
  }
  CMTimeEpoch epoch = a1->epoch;
  if ((flags & 2) == 0 && !epoch)
  {
    if ((~flags & 0x11) != 0)
    {
      CMTime time = *a1;
      return (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"%lf(%lld/%d)", CMTimeGetSeconds(&time), a1->value, a1->timescale, v17, v18, v19);
    }
    goto LABEL_16;
  }
  if (!epoch)
  {
LABEL_16:
    CMTime v11 = NSString;
    CMTime v21 = *a1;
    double Seconds = CMTimeGetSeconds(&v21);
    CMTime v13 = "+round";
    CMTimeFlags v14 = a1->flags;
    if ((v14 & 2) == 0) {
      CMTime v13 = "";
    }
    if ((a1->flags & 0x1D) == 1) {
      uint64_t v15 = v13;
    }
    else {
      uint64_t v15 = "";
    }
    CMTime v16 = "+indef";
    if ((~v14 & 0x11) != 0) {
      CMTime v16 = "";
    }
    return (__CFString *)objc_msgSend(v11, "stringWithFormat:", @"%lf(%lld/%d%s%s)", *(void *)&Seconds, a1->value, a1->timescale, v15, v16, v19);
  }
  int32_t v5 = NSString;
  CMTime v22 = *a1;
  double v6 = CMTimeGetSeconds(&v22);
  char v7 = "+round";
  CMTimeFlags v8 = a1->flags;
  if ((v8 & 2) == 0) {
    char v7 = "";
  }
  if ((a1->flags & 0x1D) == 1) {
    int v9 = v7;
  }
  else {
    int v9 = "";
  }
  int v10 = "+indef";
  if ((~v8 & 0x11) != 0) {
    int v10 = "";
  }
  return (__CFString *)objc_msgSend(v5, "stringWithFormat:", @"%lf(%lld/%d+epoch=%lld%s%s)", *(void *)&v6, a1->value, a1->timescale, a1->epoch, v9, v10);
}

double PC_CMTimeFromSampleNumberAndDuration@<D0>(uint64_t multiplier@<X0>, CMTime *a2@<X1>, CMTime *a3@<X8>)
{
  if (multiplier == (int)multiplier)
  {
    CMTime time = *a2;
    CMTimeMultiply(&v8, &time, multiplier);
  }
  else
  {
    long long v5 = *(_OWORD *)&a2->value;
    CMTimeEpoch epoch = a2->epoch;
    PC_CMTimeMultiply64Divide64((uint64_t)&v5, multiplier, 1, (uint64_t)&v8);
  }
  double result = *(double *)&v8.value;
  *a3 = v8;
  return result;
}

__n128 PC_CMTimeFloorToSampleDuration@<Q0>(CMTime *a1@<X0>, CMTime *a2@<X1>, uint64_t a3@<X8>)
{
  if ((a2->flags & 0x1D) == 1
    && (CMTime time1 = *a2,
        double v6 = (CMTime *)MEMORY[0x1E4F1FA48],
        CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48],
        CMTimeCompare(&time1, &time2)))
  {
    CMTime v14 = *a1;
    CMTime v13 = *v6;
    if (CMTimeCompare(&v14, &v13) >= 0) {
      CMTimeRoundingMethod v7 = kCMTimeRoundingMethod_RoundTowardZero;
    }
    else {
      CMTimeRoundingMethod v7 = kCMTimeRoundingMethod_RoundAwayFromZero;
    }
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    CMTime v12 = *a1;
    CMTimeConvertScale((CMTime *)a3, &v12, a2->timescale, v7);
    uint64_t value = a2->value;
    if (a2->value >= 2)
    {
      uint64_t v10 = *(void *)a3 / (unint64_t)value * value;
      uint64_t v11 = (*(void *)a3 - value + 1) / value * value;
      if (*(uint64_t *)a3 >= 0) {
        uint64_t v11 = v10;
      }
      *(void *)a3 = v11;
    }
    *(_DWORD *)(a3 + 12) &= ~2u;
  }
  else
  {
    __n128 result = *(__n128 *)&a1->value;
    *(_OWORD *)a3 = *(_OWORD *)&a1->value;
    *(void *)(a3 + 16) = a1->epoch;
  }
  return result;
}

__n128 PC_CMTimeCeilingToSampleDuration@<Q0>(CMTime *a1@<X0>, CMTime *a2@<X1>, uint64_t a3@<X8>)
{
  if ((a2->flags & 0x1D) == 1
    && (CMTime time1 = *a2,
        double v6 = (CMTime *)MEMORY[0x1E4F1FA48],
        CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48],
        CMTimeCompare(&time1, &time2)))
  {
    CMTime v14 = *a1;
    CMTime v13 = *v6;
    if (CMTimeCompare(&v14, &v13) < 0) {
      CMTimeRoundingMethod v7 = kCMTimeRoundingMethod_RoundTowardZero;
    }
    else {
      CMTimeRoundingMethod v7 = kCMTimeRoundingMethod_RoundAwayFromZero;
    }
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    CMTime v12 = *a1;
    CMTimeConvertScale((CMTime *)a3, &v12, a2->timescale, v7);
    uint64_t value = a2->value;
    if (a2->value >= 2)
    {
      uint64_t v10 = (value + *(void *)a3 - 1) / value * value;
      uint64_t v11 = -*(void *)a3 % (unint64_t)value + *(void *)a3;
      if (*(uint64_t *)a3 >= 0) {
        uint64_t v11 = v10;
      }
      *(void *)a3 = v11;
    }
    *(_DWORD *)(a3 + 12) &= ~2u;
  }
  else
  {
    __n128 result = *(__n128 *)&a1->value;
    *(_OWORD *)a3 = *(_OWORD *)&a1->value;
    *(void *)(a3 + 16) = a1->epoch;
  }
  return result;
}

CMTime *PC_CMTimeMakeWithSecondsRoundToNearest@<X0>(int32_t a1@<W0>, CMTime *a2@<X8>, double a3@<D0>)
{
  return CMTimeMakeWithSeconds(a2, 0.5 / (double)a1 + a3, a1);
}

CMTime *PC_CMTimeRangeMakeWithStartEnd@<X0>(CMTime *a1@<X0>, CMTime *a2@<X1>, uint64_t a3@<X8>)
{
  if ((~a1->flags & 9) == 0 && (a2->flags & 0x1D) == 1)
  {
    CMTime lhs = *a2;
    CMTime rhs = *(CMTime *)kPC_CMTimeOneYear;
    CMTimeSubtract(&v13, &lhs, &rhs);
    *a1 = v13;
  }
  memset(&v13, 0, sizeof(v13));
  CMTime v10 = *a2;
  CMTime v9 = *a1;
  PC_CMTimeSaferSubtract(&v10, &v9, (uint64_t)&v13);
  CMTime v8 = *a1;
  CMTime v7 = v13;
  return CMTimeRangeSaferMake(&v8, &v7, a3);
}

__n128 PC_CMTimeHalve@<Q0>(CMTime *a1@<X0>, uint64_t a2@<X8>)
{
  if ((a1->flags & 0x1D) == 1)
  {
    if (a1->value)
    {
      unint64_t timescale = a1->timescale;
      if ((int)timescale > 0x3FFFFFFF)
      {
        uint64_t v6 = a1->timescale;
        uint64_t value = a1->value;
        do
        {
          uint64_t v8 = value;
          uint64_t value = v6;
          uint64_t v6 = v8 % v6;
        }
        while (v6);
        if (value < 0) {
          uint64_t value = -value;
        }
        if ((unint64_t)value < 2)
        {
          NSLog(&cfstr_PcCmtimehalveW.isa, a1->value, timescale);
          CMTime time = *a1;
          CMTimeMultiplyByFloat64(&v11, &time, 0.5);
          *a1 = v11;
          a1->flags |= 2u;
          goto LABEL_14;
        }
        a1->value /= value;
        CMTimeScale v5 = 2 * (timescale / value);
      }
      else
      {
        CMTimeScale v5 = 2 * timescale;
      }
      a1->unint64_t timescale = v5;
      goto LABEL_14;
    }
    a1->value /= 2;
  }
LABEL_14:
  __n128 result = *(__n128 *)&a1->value;
  *(_OWORD *)a2 = *(_OWORD *)&a1->value;
  *(void *)(a2 + 16) = a1->epoch;
  return result;
}

double PC_CMTimeRangeEnd@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if ((~*(_DWORD *)(a1 + 12) & 9) != 0 || (~*(_DWORD *)(a1 + 36) & 5) != 0)
  {
    CMTime v6 = *(CMTime *)a1;
    CMTime v5 = *(CMTime *)(a1 + 24);
    *(double *)&long long v3 = PC_CMTimeSaferAdd(&v6, &v5, a2);
  }
  else
  {
    uint64_t v2 = MEMORY[0x1E4F1FA10];
    long long v3 = *MEMORY[0x1E4F1FA10];
    *(_OWORD *)a2 = *MEMORY[0x1E4F1FA10];
    *(void *)(a2 + 16) = *(void *)(v2 + 16);
  }
  return *(double *)&v3;
}

uint64_t GetCMTimeHash(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 8);
  if (v1) {
    return ((*(void *)a1 << 10) / v1);
  }
  else {
    return 0;
  }
}

uint64_t PC_CMTimeRangeToString(CMTimeRange *a1)
{
  memset(&v53, 0, sizeof(v53));
  long long v2 = *(_OWORD *)&a1->start.epoch;
  v52[0] = *(_OWORD *)&a1->start.value;
  v52[1] = v2;
  v52[2] = *(_OWORD *)&a1->duration.timescale;
  PC_CMTimeRangeEnd((uint64_t)v52, (uint64_t)&v53);
  CMTimeFlags flags = a1->start.flags;
  if ((flags & 0x1D) != 1) {
    goto LABEL_16;
  }
  if ((flags & 1) == 0) {
    goto LABEL_16;
  }
  if ((v53.flags & 0x1D) != 1) {
    goto LABEL_16;
  }
  if ((a1->duration.flags & 1) == 0) {
    goto LABEL_16;
  }
  p_CMTime duration = &a1->duration;
  CMTime time1 = a1->duration;
  CMTime v5 = (CMTime *)MEMORY[0x1E4F1FA48];
  CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  int32_t v6 = CMTimeCompare(&time1, &time2);
  CMTimeFlags flags = a1->start.flags;
  if (v6 < 0) {
    goto LABEL_16;
  }
  if ((~flags & 5) == 0)
  {
    *(_OWORD *)&v49.uint64_t value = *(_OWORD *)&p_duration->value;
    v49.CMTimeEpoch epoch = a1->duration.epoch;
    CMTime v48 = *v5;
    int32_t v7 = CMTimeCompare(&v49, &v48);
    CMTimeFlags flags = a1->start.flags;
    if (v7) {
      goto LABEL_16;
    }
  }
  if ((~flags & 9) == 0)
  {
    *(_OWORD *)&v47.uint64_t value = *(_OWORD *)&p_duration->value;
    v47.CMTimeEpoch epoch = a1->duration.epoch;
    CMTime v46 = *v5;
    if (CMTimeCompare(&v47, &v46))
    {
      CMTimeFlags flags = a1->start.flags;
      if ((~a1->duration.flags & 5) != 0)
      {
LABEL_16:
        BOOL v8 = (v53.flags & 0x1F) != 3 || (flags & 0x1F) == 3;
        if (v8 || (a1->duration.flags & 0x1F) == 3)
        {
          CMTime v9 = NSString;
          if (flags & 1) != 0 && (a1->duration.flags)
          {
            uint64_t v18 = &a1->duration;
            CMTime duration = a1->duration;
            uint64_t v19 = (CMTime *)MEMORY[0x1E4F1FA48];
            CMTime v33 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
            CMTime v10 = @"INVALID:";
            if ((CMTimeCompare(&duration, &v33) & 0x80000000) == 0)
            {
              CMTimeFlags v20 = a1->start.flags;
              if ((~v20 & 5) == 0)
              {
                *(_OWORD *)&v32.uint64_t value = *(_OWORD *)&v18->value;
                v32.CMTimeEpoch epoch = a1->duration.epoch;
                CMTime v31 = *v19;
                if (CMTimeCompare(&v32, &v31)) {
                  goto LABEL_24;
                }
                CMTimeFlags v20 = a1->start.flags;
              }
              if ((~v20 & 9) != 0
                || (*(_OWORD *)&v30.uint64_t value = *(_OWORD *)&v18->value,
                    v30.CMTimeEpoch epoch = a1->duration.epoch,
                    CMTime v29 = *v19,
                    !CMTimeCompare(&v30, &v29))
                || (~a1->duration.flags & 5) == 0)
              {
                if (a1->start.epoch == a1->duration.epoch) {
                  CMTime v10 = &stru_1F119C770;
                }
              }
            }
          }
          else
          {
            CMTime v10 = @"INVALID:";
          }
LABEL_24:
          CMTime start = a1->start;
          CMTime v11 = PC_CMTimeToString(&start);
          CMTime v27 = v53;
          return [v9 stringWithFormat:@"[%@%@ - %@]", v10, v11, PC_CMTimeToString(&v27), v26];
        }
        CMTime v13 = &a1->duration;
        CMTime v14 = NSString;
        if (flags & a1->duration.flags)
        {
          *(_OWORD *)&v43.uint64_t value = *(_OWORD *)&v13->value;
          v43.CMTimeEpoch epoch = a1->duration.epoch;
          uint64_t v15 = (CMTime *)MEMORY[0x1E4F1FA48];
          CMTime v42 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
          CMTime v16 = @"INVALID:";
          if ((CMTimeCompare(&v43, &v42) & 0x80000000) == 0)
          {
            CMTimeFlags v17 = a1->start.flags;
            if ((~v17 & 5) != 0) {
              goto LABEL_30;
            }
            *(_OWORD *)&v41.uint64_t value = *(_OWORD *)&v13->value;
            v41.CMTimeEpoch epoch = a1->duration.epoch;
            CMTime v40 = *v15;
            if (!CMTimeCompare(&v41, &v40))
            {
              CMTimeFlags v17 = a1->start.flags;
LABEL_30:
              if ((~v17 & 9) != 0
                || (*(_OWORD *)&v39.uint64_t value = *(_OWORD *)&v13->value,
                    v39.CMTimeEpoch epoch = a1->duration.epoch,
                    CMTime v38 = *v15,
                    !CMTimeCompare(&v39, &v38))
                || (~a1->duration.flags & 5) == 0)
              {
                if (a1->start.epoch == a1->duration.epoch) {
                  CMTime v16 = &stru_1F119C770;
                }
              }
            }
          }
        }
        else
        {
          CMTime v16 = @"INVALID:";
        }
        CMTime v37 = a1->start;
        CMTime v21 = PC_CMTimeToString(&v37);
        CMTime v36 = v53;
        CMTime v22 = PC_CMTimeToString(&v36);
        CMTime v35 = *v13;
        return objc_msgSend(v14, "stringWithFormat:", @"[%@%@ - %@ (end rounded; start&dur weren't) dur=%@]",
                 v16,
                 v21,
                 v22,
                 PC_CMTimeToString(&v35));
      }
    }
    else
    {
      CMTimeFlags flags = a1->start.flags;
    }
  }
  if (a1->duration.epoch | a1->start.epoch || (flags & 0x1F) == 3 || (v53.flags & 0x1F) == 3) {
    goto LABEL_16;
  }
  uint64_t v23 = NSString;
  CMTime time = a1->start;
  Float64 Seconds = CMTimeGetSeconds(&time);
  CMTime v44 = v53;
  return objc_msgSend(v23, "stringWithFormat:", @"[%lf - %lf]", *(void *)&Seconds, CMTimeGetSeconds(&v44), v25, v26);
}

__CFString *PC_CMTimeToString(CMTime *a1)
{
  CMTimeFlags flags = a1->flags;
  if ((flags & 0x1D) == 1 || (~flags & 5) == 0 || (flags & 9) == 9)
  {
    if (a1->epoch)
    {
      CMTime v5 = NSString;
      CMTime time = *a1;
      double Seconds = CMTimeGetSeconds(&time);
      CMTimeFlags v7 = a1->flags;
      BOOL v8 = "+round";
      if ((v7 & 2) == 0) {
        BOOL v8 = "";
      }
      if ((a1->flags & 0x1D) == 1) {
        CMTime v9 = v8;
      }
      else {
        CMTime v9 = "";
      }
      if ((~v7 & 0x11) != 0) {
        CMTime v10 = "";
      }
      else {
        CMTime v10 = "+indef";
      }
      return (__CFString *)objc_msgSend(v5, "stringWithFormat:", @"%lf+epoch=%lld%s%s", *(void *)&Seconds, a1->epoch, v9, v10);
    }
    else
    {
      int v12 = flags & 0x1F;
      int v13 = flags & 0x11;
      CMTime v14 = NSString;
      if (v12 == 3 || v13 == 17)
      {
        CMTime v25 = *a1;
        double v16 = CMTimeGetSeconds(&v25);
        CMTimeFlags v17 = a1->flags;
        uint64_t v18 = "+round";
        if ((v17 & 2) == 0) {
          uint64_t v18 = "";
        }
        if ((a1->flags & 0x1D) == 1) {
          uint64_t v19 = v18;
        }
        else {
          uint64_t v19 = "";
        }
        if ((~v17 & 0x11) != 0) {
          CMTimeFlags v20 = "";
        }
        else {
          CMTimeFlags v20 = "+indef";
        }
        return (__CFString *)objc_msgSend(v14, "stringWithFormat:", @"%lf%s%s", *(void *)&v16, v19, v20, v24);
      }
      else
      {
        CMTime v27 = *a1;
        return (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"%lf", CMTimeGetSeconds(&v27), v22, v23, v24);
      }
    }
  }
  else
  {
    CMTime v21 = @"indef";
    if ((flags & 0x10) == 0) {
      CMTime v21 = @"nan";
    }
    if (flags) {
      return v21;
    }
    else {
      return @"inval";
    }
  }
}

void PCXMLReadStream::PCXMLReadStream(PCXMLReadStream *this, const PCURL *a2)
{
  PCSerializerReadStream::PCSerializerReadStream(this);
  *uint64_t v4 = &unk_1F10C4220;
  PCURL::PCURL((PCURL *)(v4 + 19), a2);
  *((void *)this + 24) = 0;
  *((unsigned char *)this + 160) = 0;
  *((_DWORD *)this + 46) = 0;
  *((void *)this + 25) = 0;
  *((_DWORD *)this + 5PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  if (*(void *)a2)
  {
    CFStringRef v5 = CFURLCopyPath(*(CFURLRef *)a2);
    PCURL::PCURL((PCURL *)&v8, v5);
    int32_t v6 = PCString::createCStr(&v8);
    CFRelease(v5);
    *((void *)this + 24) = xmlReaderForFile(v6, 0, 0x80000);
    free(v6);
    PCString::~PCString(&v8);
  }
  CMTimeFlags v7 = (PCXMLReadStream *)malloc_type_malloc(0xC80uLL, 0x10F10407CD822B3uLL);
  *((void *)this + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v7;
  PCXMLReadStream::fixLocale(v7);
}

void sub_1B76C8468(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCURL::~PCURL(v11);
  PCSerializerReadStream::~PCSerializerReadStream(v10);
  _Unwind_Resume(a1);
}

void PCSerializerReadStream::PCSerializerReadStream(PCSerializerReadStream *this)
{
  *(void *)this = &unk_1F10C4060;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 7PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((void *)this + 13) = 0;
  CMTimeMake((CMTime *)((char *)this + 112), 1, 1);
  *((void *)this + 17) = 0x3FF0000000000000;
  *((unsigned char *)this + 144) = 0;
}

void sub_1B76C852C(_Unwind_Exception *a1)
{
  std::deque<PCSerializerReadStream::HandlerInfo>::~deque[abi:ne180100]((void *)(v1 + 56));
  std::deque<unsigned long>::~deque[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

char *PCXMLReadStream::fixLocale(PCXMLReadStream *this)
{
  uint64_t v1 = setlocale(4, 0);
  __n128 result = (char *)strcmp("C", v1);
  if (result)
  {
    return setlocale(4, "C");
  }
  return result;
}

void PCXMLReadStream::PCXMLReadStream(PCXMLReadStream *this, const __CFData *a2)
{
  PCSerializerReadStream::PCSerializerReadStream(this);
  *uint64_t v4 = &unk_1F10C4220;
  PCURL::PCURL((PCURL *)(v4 + 19), 0);
  *((unsigned char *)this + 160) = 0;
  *((_DWORD *)this + 46) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 25) = 0;
  *((_DWORD *)this + 5PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  BytePtr = CFDataGetBytePtr(a2);
  CFIndex Length = CFDataGetLength(a2);
  CMTimeFlags v7 = malloc_type_malloc(Length + 1, 0x1CCDB95DuLL);
  memcpy(v7, BytePtr, Length);
  *((unsigned char *)v7 + Length) = 0;
  *((void *)this + 24) = xmlReaderForMemory((const char *)v7, Length, 0, 0, 0x80000);
  *((void *)this + 25) = v7;
  PCString v8 = (PCXMLReadStream *)malloc_type_malloc(0xC80uLL, 0x10F10407CD822B3uLL);
  *((void *)this + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v8;
  PCXMLReadStream::fixLocale(v8);
}

void sub_1B76C8694(_Unwind_Exception *a1)
{
  PCURL::~PCURL(v2);
  PCSerializerReadStream::~PCSerializerReadStream(v1);
  _Unwind_Resume(a1);
}

void PCXMLReadStream::~PCXMLReadStream(PCXMLReadStream *this)
{
  *(void *)this = &unk_1F10C4220;
  for (uint64_t i = (void *)((char *)this + 8); ; std::deque<unsigned long>::__maybe_remove_back_spare[abi:ne180100](i, 1))
  {
    uint64_t v3 = *((void *)this + 6);
    if (!v3) {
      break;
    }
    (*(void (**)(PCXMLReadStream *, void))(*(void *)this + 48))(this, *(void *)(*(void *)(*((void *)this + 2)+ (((unint64_t)(v3 + *((void *)this + 5) - 1) >> 6) & 0x3FFFFFFFFFFFFF8))+ 8 * ((v3 + *((void *)this + 5) - 1) & 0x1FF)));
    --*((void *)this + 6);
  }
  uint64_t v4 = (void *)*((void *)this + 25);
  if (v4) {
    free(v4);
  }
  xmlFreeTextReader(*((xmlTextReaderPtr *)this + 24));
  free(*((void **)this + 22));
  PCURL::~PCURL((PCXMLReadStream *)((char *)this + 152));

  PCSerializerReadStream::~PCSerializerReadStream(this);
}

{
  uint64_t vars8;

  PCXMLReadStream::~PCXMLReadStream(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PCXMLReadStream::parse(PCXMLReadStream *this)
{
  long long v2 = (xmlTextReader *)*((void *)this + 24);
  if (!v2)
  {
    PCSerializerReadStream::popAllHandlers(this);
    return 0;
  }
  int v3 = xmlTextReaderRead(v2);
  if (v3 < 1)
  {
LABEL_5:
    int v5 = v3;
    PCSerializerReadStream::popAllHandlers(this);
    if (v5 < 0) {
      goto LABEL_10;
    }
  }
  else
  {
    while (1)
    {
      PCXMLReadStream::processNode((xmlTextReaderPtr *)this);
      int v4 = *((_DWORD *)this + 52);
      if (v4) {
        break;
      }
      int v3 = xmlTextReaderRead(*((xmlTextReaderPtr *)this + 24));
      if (v3 <= 0) {
        goto LABEL_5;
      }
    }
    if (v4 == 1)
    {
      PCSerializerReadStream::popAllHandlers(this);
LABEL_10:
      PCURL::getFilename((const __CFURL **)this + 19, &v8);
      int32_t v6 = PCString::createCStr(&v8);
      PCString::~PCString(&v8);
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s : parsing error\n", v6);
      free(v6);
      return 0;
    }
    PCSerializerReadStream::popAllHandlers(this);
  }
  return 1;
}

void sub_1B76C88D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PCXMLReadStream::processNode(xmlTextReaderPtr *this)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  long long v2 = xmlTextReaderConstName(this[24]);
  if (v2) {
    int v3 = (char *)v2;
  }
  else {
    int v3 = "--";
  }
  int IsEmptyElement = xmlTextReaderIsEmptyElement(this[24]);
  int v5 = xmlTextReaderNodeType(this[24]);
  switch(v5)
  {
    case 1:
      uint64_t v12 = PCSerializerReadStream::currentElement((PCSerializerReadStream *)this);
      if (v12)
      {
        uint64_t v13 = v12;
        if ((*(unsigned int (**)(uint64_t))(*(void *)v12 + 184))(v12))
        {
          if (!*(unsigned char *)(v13 + 12)) {
            PCSerializerReadStream::processElement((uint64_t)this, v13);
          }
        }
      }
      uint64_t v23 = 0;
      v24.var0 = 0;
      uint64_t v22 = 0;
      if (PCSerializerReadStream::getElementInfo(this, v3, &v23, &v24, &v22))
      {
        Element = (PCStreamElement *)PCXMLReadStream::createElement((uint64_t)this, *(_DWORD *)(v23 + 8), (uint64_t)v24.var0, v22);
        PCSerializerReadStream::pushElement((PCSerializerReadStream *)this, Element);
        if (xmlTextReaderHasAttributes(this[24]) && xmlTextReaderMoveToNextAttribute(this[24]))
        {
          do
          {
            uint64_t v15 = (const char *)xmlTextReaderConstName(this[24]);
            double v16 = (const char *)xmlTextReaderConstValue(this[24]);
            PCXMLStreamElement::addAttribute((uint64_t)Element, v15, v16);
          }
          while (xmlTextReaderMoveToNextAttribute(this[24]));
        }
        if (IsEmptyElement)
        {
          if (!*((unsigned char *)Element + 40) && !*((unsigned char *)Element + 12)) {
            PCSerializerReadStream::processElement((uint64_t)this, (uint64_t)Element);
          }
          if (Element == (PCStreamElement *)PCSerializerReadStream::currentHandlerElement((PCSerializerReadStream *)this)) {
            PCSerializerReadStream::popHandler(this);
          }
          PCSerializerReadStream::popElement(this);
        }
      }
      else
      {
        xmlTextReaderNext(this[24]);
      }
      return;
    case 3:
    case 13:
    case 14:
      int v6 = v5;
      uint64_t v7 = PCSerializerReadStream::currentElement((PCSerializerReadStream *)this);
      if (v7)
      {
        PCString v8 = (void **)v7;
        if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 184))(v7))
        {
          if (v6 != 14 || (*(unsigned int (**)(void *))(*v8[3] + 64))(v8[3]))
          {
            unint64_t String = xmlTextReaderReadString(this[24]);
            ((void (*)(void **, xmlChar *, BOOL))(*v8)[22])(v8, String, *((unsigned char *)this + 160) == 0);
            goto LABEL_18;
          }
        }
      }
      return;
    case 5:
      uint64_t v17 = PCSerializerReadStream::currentElement((PCSerializerReadStream *)this);
      if (!v17) {
        return;
      }
      uint64_t v18 = v17;
      if (!(*(unsigned int (**)(uint64_t))(*(void *)v17 + 184))(v17)) {
        return;
      }
      CFStringRef v19 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v3, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
      PCSharedCount::PCSharedCount(&v24);
      if (CFStringCompare(v19, @"amp", 0))
      {
        if (CFStringCompare(v19, @"lt", 0))
        {
          if (CFStringCompare(v19, @"gt", 0))
          {
            if (CFStringCompare(v19, @"quot", 0))
            {
              if (CFStringCompare(v19, @"apos", 0))
              {
                if (CFStringCompare(v19, @"space", 0))
                {
                  v27.locatiouint64_t n = 0;
                  v27.length = 2;
                  if (CFStringCompareWithOptions(v19, @"#x", v27, 0))
                  {
                    v28.locatiouint64_t n = 0;
                    v28.length = 1;
                    if (CFStringCompareWithOptions(v19, @"#", v28, 0)) {
                      goto LABEL_54;
                    }
                    CFStringGetCString(v19, buffer, 512, 0);
                    LODWORD(v23) = 0;
                    if (sscanf(buffer, "#%d", &v23) != 1) {
                      goto LABEL_54;
                    }
                  }
                  else
                  {
                    CFStringGetCString(v19, buffer, 512, 0);
                    LODWORD(v23) = 0;
                    if (sscanf(buffer, "#x%x", &v23) != 1) {
                      goto LABEL_54;
                    }
                  }
                  buffer[0] = v23;
                  buffer[1] = 0;
                  PCString::set((PCString *)&v24, buffer);
LABEL_54:
                  CStr = PCString::createCStr((PCString *)&v24);
                  (*(void (**)(uint64_t, char *, void))(*(void *)v18 + 176))(v18, CStr, 0);
                  *((unsigned char *)this + 160) = 1;
                  CFRelease(v19);
                  PCString::~PCString((PCString *)&v24);
                  return;
                }
                CMTimeFlags v20 = " ";
              }
              else
              {
                CMTimeFlags v20 = "'";
              }
            }
            else
            {
              CMTimeFlags v20 = "\"";
            }
          }
          else
          {
            CMTimeFlags v20 = ">";
          }
        }
        else
        {
          CMTimeFlags v20 = "<";
        }
      }
      else
      {
        CMTimeFlags v20 = "&";
      }
      PCString::set((PCString *)&v24, v20);
      goto LABEL_54;
    case 15:
      uint64_t v10 = PCSerializerReadStream::currentElement((PCSerializerReadStream *)this);
      if (v10)
      {
        uint64_t v11 = v10;
        if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 184))(v10))
        {
          if (!*(unsigned char *)(v11 + 40) && !*(unsigned char *)(v11 + 12)) {
            PCSerializerReadStream::processElement((uint64_t)this, v11);
          }
          if (v11 == PCSerializerReadStream::currentHandlerElement((PCSerializerReadStream *)this)) {
            PCSerializerReadStream::popHandler(this);
          }
          PCSerializerReadStream::popElement(this);
        }
      }
LABEL_18:
      *((unsigned char *)this + 160) = 0;
      return;
    default:
      return;
  }
}

void sub_1B76C8E7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, PCString a13)
{
}

uint64_t PCXMLReadStream::abortParse(uint64_t this)
{
  *(_DWORD *)(this + 208) = 1;
  return this;
}

uint64_t PCXMLReadStream::stopParse(uint64_t this)
{
  *(_DWORD *)(this + 208) = 2;
  return this;
}

uint64_t PCXMLReadStream::getURL(PCXMLReadStream *this)
{
  return (uint64_t)this + 152;
}

uint64_t PCXMLReadStream::createElement(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v5 = *(_DWORD *)(a1 + 184);
  if (v5 > 0xF) {
    operator new();
  }
  uint64_t v6 = *(void *)(a1 + 176) + 200 * v5;
  PCXMLStreamElement::PCXMLStreamElement(v6, a2, a3, a4);
  ++*(_DWORD *)(a1 + 184);
  return v6;
}

void sub_1B76C8FA4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C407CD822B3);
  _Unwind_Resume(a1);
}

uint64_t PCXMLReadStream::destroyElement(uint64_t this, PCStreamElement *a2)
{
  uint64_t v2 = this;
  unint64_t v3 = *(void *)(this + 176);
  if (v3 <= (unint64_t)a2 && v3 + 3200 >= (unint64_t)a2)
  {
    this = (**(uint64_t (***)(PCStreamElement *))a2)(a2);
  }
  else if (a2)
  {
    this = (*(uint64_t (**)(PCStreamElement *))(*(void *)a2 + 8))(a2);
  }
  --*(_DWORD *)(v2 + 184);
  return this;
}

__n128 IntermediateLargeInteger::gcd@<Q0>(int8x16_t *a1@<X0>, int8x16_t *a2@<X1>, int8x16_t *a3@<X8>)
{
  bignum_s256_init_from_s64(0, v28.i64);
  uint64_t v6 = a1->i64[1];
  if (a1->i64[0] < 0)
  {
    if (v6 == -1)
    {
      uint64_t v7 = a1[1].i64[0];
      if (v7 == -1) {
        goto LABEL_47;
      }
    }
LABEL_7:
    BOOL v8 = 0;
    goto LABEL_8;
  }
  if (v6) {
    goto LABEL_7;
  }
  uint64_t v7 = a1[1].i64[0];
  if (v7) {
    goto LABEL_7;
  }
LABEL_47:
  BOOL v8 = a1[1].i64[1] == v7;
LABEL_8:
  uint64_t v9 = a2->i64[0];
  uint64_t v10 = a2->i64[1];
  if (a2->i64[0] < 0)
  {
    if (v10 == -1)
    {
      uint64_t v11 = a2[1].i64[0];
      if (v11 == -1) {
        goto LABEL_48;
      }
    }
LABEL_14:
    BOOL v12 = 0;
    goto LABEL_15;
  }
  if (v10) {
    goto LABEL_14;
  }
  uint64_t v11 = a2[1].i64[0];
  if (v11) {
    goto LABEL_14;
  }
LABEL_48:
  BOOL v12 = a2[1].i64[1] == v11;
  while (1)
  {
LABEL_15:
    BOOL v13 = v12;
    if (!v12) {
      goto LABEL_18;
    }
    if (v8) {
      break;
    }
    if (!v9) {
      goto LABEL_46;
    }
LABEL_18:
    int8x16_t v14 = a2[1];
    int8x16_t v28 = *a2;
    int8x16_t v29 = v14;
    uint64_t v15 = a1->i64[1];
    if (a1->i64[0] < 0)
    {
      if (v15 != -1 || (uint64_t v16 = a1[1].i64[0], v16 != -1))
      {
LABEL_33:
        bignum_s256_init_from_s64(0, v30[0].i64);
        bignum_s256_init_from_s64(0, v27[0].i64);
        bignum_s256_divide(a1, a2, v30, v27);
        goto LABEL_34;
      }
    }
    else
    {
      if (v15) {
        goto LABEL_33;
      }
      uint64_t v16 = a1[1].i64[0];
      if (v16) {
        goto LABEL_33;
      }
    }
    if (a1[1].i64[1] != v16) {
      goto LABEL_33;
    }
    uint64_t v17 = a2[1].i64[0];
    if (v9 < 0)
    {
      if (v10 != -1 || v17 != -1) {
        goto LABEL_33;
      }
      uint64_t v18 = -1;
    }
    else
    {
      uint64_t v18 = v10 | v17;
      if (v18) {
        goto LABEL_33;
      }
    }
    if (a2[1].i64[1] != v18) {
      goto LABEL_33;
    }
    bignum_s256_init_from_s64(a1->i64[0] % v9, v27[0].i64);
LABEL_34:
    int8x16_t v19 = v27[1];
    *a2 = v27[0];
    a2[1] = v19;
    int8x16_t v20 = v29;
    *a1 = v28;
    a1[1] = v20;
    uint64_t v9 = a2->i64[0];
    uint64_t v10 = a2->i64[1];
    BOOL v12 = 0;
    BOOL v8 = v13;
    if (a2->i64[0] < 0)
    {
      if (v10 == -1)
      {
        BOOL v12 = 0;
        BOOL v8 = v13;
        if (a2[1].i64[0] == -1)
        {
          uint64_t v21 = -1;
LABEL_41:
          BOOL v12 = a2[1].i64[1] == v21;
          BOOL v8 = v13;
        }
      }
    }
    else if (!v10)
    {
      BOOL v12 = 0;
      BOOL v8 = v13;
      if (!a2[1].i64[0])
      {
        uint64_t v21 = 0;
        goto LABEL_41;
      }
    }
  }
  if (v9)
  {
    uint64_t v22 = a1->i64[0];
    do
    {
      uint64_t v23 = v22;
      uint64_t v22 = v9;
      uint64_t v9 = v23 % v9;
    }
    while (v9);
    bignum_s256_init_from_s64(v22, v30[0].i64);
    int8x16_t v24 = v30[1];
    *a1 = v30[0];
    a1[1] = v24;
  }
LABEL_46:
  __n128 result = *(__n128 *)a1;
  int8x16_t v26 = a1[1];
  *a3 = *a1;
  a3[1] = v26;
  return result;
}

void IntermediateLargeInteger::makeCMTime(int8x16_t *a1@<X0>, int8x16_t *a2@<X1>, int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  if ((a4 & 1) == 0)
  {
    int64_t v9 = a1->i64[0];
    uint64_t v10 = a1->i64[1];
    if (a1->i64[0] < 0)
    {
      if (v10 != -1) {
        goto LABEL_13;
      }
      uint64_t v11 = a1[1].i64[0];
      if (v11 != -1) {
        goto LABEL_13;
      }
    }
    else
    {
      if (v10) {
        goto LABEL_13;
      }
      uint64_t v11 = a1[1].i64[0];
      if (v11) {
        goto LABEL_13;
      }
    }
    if (a1[1].i64[1] == v11)
    {
      uint64_t v12 = a2->i64[0];
      if (!HIDWORD(a2->i64[0]) && !a2->i64[1] && !a2[1].i64[1] && !(a2[1].i64[0] | v12 & 0x80000000))
      {
        *(void *)a5 = 0;
        *(void *)(a5 + 8) = 0;
        *(void *)(a5 + 16) = 0;
        CMTimeMake((CMTime *)a5, v9, v12);
        if (a3) {
          *(_DWORD *)(a5 + 12) |= 2u;
        }
        return;
      }
    }
  }
LABEL_13:
  if (IntermediateLargeInteger::operator==(a2, 0))
  {
    uint64_t v13 = MEMORY[0x1E4F1F9F8];
    *(_OWORD *)a5 = *MEMORY[0x1E4F1F9F8];
    uint64_t v14 = *(void *)(v13 + 16);
    goto LABEL_103;
  }
  bignum_s256_init_from_s64(0, v66);
  unint64_t v15 = a1[1].u64[1];
  unint64_t v16 = v15 >> 63;
  if ((v15 & 0x8000000000000000) != 0)
  {
    bignum_s256_init_from_s64(0, (uint64_t *)v65);
    bignum_s256_sub((uint64_t)v66, (uint64_t)a1, (uint64_t)v65);
    int8x16_t v17 = *(int8x16_t *)&v65[16];
    *a1 = *(int8x16_t *)v65;
    a1[1] = v17;
  }
  if (a2[1].i64[1] < 0)
  {
    bignum_s256_init_from_s64(0, (uint64_t *)v65);
    bignum_s256_sub((uint64_t)v66, (uint64_t)a2, (uint64_t)v65);
    int8x16_t v18 = *(int8x16_t *)&v65[16];
    *a2 = *(int8x16_t *)v65;
    a2[1] = v18;
    LODWORD(v16) = v16 ^ 1;
  }
  int8x16_t v19 = a1[1];
  v64[0] = *a1;
  v64[1] = v19;
  int8x16_t v20 = a2[1];
  v63[0] = *a2;
  v63[1] = v20;
  IntermediateLargeInteger::gcd(v64, v63, (int8x16_t *)v65);
  if ((*(void *)v65 & 0x8000000000000000) == 0
    && *(_OWORD *)&v65[8] == 0
    && *(void *)v65 == 1
    && !*(void *)&v65[24])
  {
    goto LABEL_53;
  }
  uint64_t v21 = a1->i64[1];
  if (a1->i64[0] < 0)
  {
    if (v21 != -1) {
      goto LABEL_37;
    }
    uint64_t v22 = a1[1].i64[0];
    if (v22 != -1) {
      goto LABEL_37;
    }
  }
  else
  {
    if (v21) {
      goto LABEL_37;
    }
    uint64_t v22 = a1[1].i64[0];
    if (v22) {
      goto LABEL_37;
    }
  }
  if (a1[1].i64[1] == v22)
  {
    if ((*(void *)v65 & 0x8000000000000000) != 0)
    {
      if (*(_OWORD *)&v65[8] != __PAIR128__(-1, -1)) {
        goto LABEL_37;
      }
      uint64_t v23 = -1;
    }
    else
    {
      uint64_t v23 = *(void *)&v65[8] | *(void *)&v65[16];
      if (*(_OWORD *)&v65[8] != 0) {
        goto LABEL_37;
      }
    }
    if (*(void *)&v65[24] == v23)
    {
      bignum_s256_init_from_s64(a1->i64[0] / *(uint64_t *)v65, (uint64_t *)v62);
      goto LABEL_38;
    }
  }
LABEL_37:
  bignum_s256_init_from_s64(0, (uint64_t *)v62);
  bignum_s256_divide(a1, (int8x16_t *)v65, (int8x16_t *)v62, 0);
LABEL_38:
  int8x16_t v24 = *(int8x16_t *)&v62[16];
  *a1 = *(int8x16_t *)v62;
  a1[1] = v24;
  uint64_t v25 = a2->i64[1];
  if (a2->i64[0] < 0)
  {
    if (v25 != -1) {
      goto LABEL_51;
    }
    uint64_t v26 = a2[1].i64[0];
    if (v26 != -1) {
      goto LABEL_51;
    }
  }
  else
  {
    if (v25) {
      goto LABEL_51;
    }
    uint64_t v26 = a2[1].i64[0];
    if (v26) {
      goto LABEL_51;
    }
  }
  if (a2[1].i64[1] != v26) {
    goto LABEL_51;
  }
  uint64_t v27 = *(void *)&v65[16];
  if ((*(void *)v65 & 0x8000000000000000) != 0)
  {
    if (*(_OWORD *)&v65[8] == __PAIR128__(-1, -1)) {
      goto LABEL_49;
    }
LABEL_51:
    bignum_s256_init_from_s64(0, (uint64_t *)v62);
    bignum_s256_divide(a2, (int8x16_t *)v65, (int8x16_t *)v62, 0);
    goto LABEL_52;
  }
  uint64_t v27 = *(void *)&v65[8] | *(void *)&v65[16];
  if (*(_OWORD *)&v65[8] != 0) {
    goto LABEL_51;
  }
LABEL_49:
  if (*(void *)&v65[24] != v27) {
    goto LABEL_51;
  }
  bignum_s256_init_from_s64(a2->i64[0] / *(uint64_t *)v65, (uint64_t *)v62);
LABEL_52:
  int8x16_t v28 = *(int8x16_t *)&v62[16];
  *a2 = *(int8x16_t *)v62;
  a2[1] = v28;
LABEL_53:
  int8x16_t v29 = (CMTime *)MEMORY[0x1E4F1FA48];
  *(_OWORD *)a5 = *MEMORY[0x1E4F1FA48];
  *(void *)(a5 + 16) = v29->epoch;
  if (a3) {
    *(_DWORD *)(a5 + 12) |= 2u;
  }
  while (1)
  {
    uint64_t v30 = a1->i64[1];
    if (a1->i64[0] < 0)
    {
      if (v30 != -1) {
        goto LABEL_62;
      }
      uint64_t v31 = a1[1].i64[0];
      if (v31 != -1) {
        goto LABEL_62;
      }
    }
    else
    {
      if (v30) {
        goto LABEL_62;
      }
      uint64_t v31 = a1[1].i64[0];
      if (v31) {
        goto LABEL_62;
      }
    }
    if (a1[1].i64[1] == v31) {
      break;
    }
LABEL_62:
    if (!HIDWORD(a2->i64[0]) && !a2->i64[1] && !a2[1].i64[1] && a2->i64[0] <= 1uLL && !a2[1].i64[0]) {
      break;
    }
    *(_DWORD *)(a5 + 12) |= 2u;
    bignum_s256_init_from_s64(0, (uint64_t *)v62);
    uint64_t v32 = 0;
    uint64_t v33 = a1->i64[0];
    do
    {
      unint64_t v34 = a1->u64[v32 + 1];
      *((void *)&v35 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v34;
      *(void *)&long long v35 = v33;
      *(void *)&v62[v32 * 8] = v35 >> 1;
      ++v32;
      uint64_t v33 = v34;
    }
    while (v32 != 3);
    *(void *)&v62[24] = v34 >> 1;
    int8x16_t v36 = *(int8x16_t *)&v62[16];
    *a1 = *(int8x16_t *)v62;
    a1[1] = v36;
    bignum_s256_init_from_s64(0, (uint64_t *)v62);
    uint64_t v37 = 0;
    uint64_t v38 = a2->i64[0];
    do
    {
      unint64_t v39 = a2->u64[v37 + 1];
      *((void *)&v40 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v39;
      *(void *)&long long v40 = v38;
      *(void *)&v62[v37 * 8] = v40 >> 1;
      ++v37;
      uint64_t v38 = v39;
    }
    while (v37 != 3);
    *(void *)&v62[24] = v39 >> 1;
    int8x16_t v41 = *(int8x16_t *)&v62[16];
    *a2 = *(int8x16_t *)v62;
    a2[1] = v41;
  }
  char v42 = 0;
  while (2)
  {
    uint64_t v43 = a2->i64[0];
    if (HIDWORD(a2->i64[0]) || a2->i64[1] || a2[1].i64[1] || a2[1].i64[0])
    {
      if (v43 < 2) {
        goto LABEL_90;
      }
    }
    else if ((v43 & 0x80000000) == 0)
    {
      goto LABEL_90;
    }
    *(_DWORD *)(a5 + 12) |= 2u;
    if (!IntermediateLargeInteger::operator==(a1, 1))
    {
      bignum_s256_init_from_s64(0, (uint64_t *)v62);
      uint64_t v44 = 0;
      uint64_t v45 = a1->i64[0];
      do
      {
        unint64_t v46 = a1->u64[v44 + 1];
        *((void *)&v47 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v46;
        *(void *)&long long v47 = v45;
        *(void *)&v62[v44 * 8] = v47 >> 1;
        ++v44;
        uint64_t v45 = v46;
      }
      while (v44 != 3);
      *(void *)&v62[24] = v46 >> 1;
      goto LABEL_84;
    }
    if ((v42 & 1) == 0)
    {
      char v42 = 1;
      bignum_s256_init_from_s64(1, (uint64_t *)v62);
LABEL_84:
      int8x16_t v48 = *(int8x16_t *)&v62[16];
      *a1 = *(int8x16_t *)v62;
      a1[1] = v48;
      bignum_s256_init_from_s64(0, (uint64_t *)v62);
      uint64_t v49 = 0;
      uint64_t v50 = a2->i64[0];
      do
      {
        unint64_t v51 = a2->u64[v49 + 1];
        *((void *)&v52 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v51;
        *(void *)&long long v52 = v50;
        *(void *)&v62[v49 * 8] = v52 >> 1;
        ++v49;
        uint64_t v50 = v51;
      }
      while (v49 != 3);
      *(void *)&v62[24] = v51 >> 1;
      int8x16_t v53 = *(int8x16_t *)&v62[16];
      *a2 = *(int8x16_t *)v62;
      a2[1] = v53;
      continue;
    }
    break;
  }
  bignum_s256_init_from_s64(0, (uint64_t *)v62);
  int8x16_t v54 = *(int8x16_t *)&v62[16];
  *a1 = *(int8x16_t *)v62;
  a1[1] = v54;
  bignum_s256_init_from_s64(1, (uint64_t *)v62);
  int8x16_t v55 = *(int8x16_t *)&v62[16];
  *a2 = *(int8x16_t *)v62;
  a2[1] = v55;
LABEL_90:
  uint64_t v56 = a1->i64[0];
  uint64_t v57 = a1->i64[1];
  if (a1->i64[0] < 0)
  {
    if (v57 != -1) {
      goto LABEL_97;
    }
    uint64_t v58 = a1[1].i64[0];
    if (v58 != -1) {
      goto LABEL_97;
    }
LABEL_96:
    if (a1[1].i64[1] != v58) {
      goto LABEL_97;
    }
LABEL_101:
    *(void *)a5 = v56;
    *(_DWORD *)(a5 + 8) = a2->i64[0];
    if (v16) {
      goto LABEL_102;
    }
    return;
  }
  if (!v57)
  {
    uint64_t v58 = a1[1].i64[0];
    if (!v58) {
      goto LABEL_96;
    }
  }
LABEL_97:
  if (!IntermediateLargeInteger::operator==(a2, 1))
  {
    uint64_t v56 = a1->i64[0];
    goto LABEL_101;
  }
  uint64_t v59 = MEMORY[0x1E4F1FA10];
  *(_OWORD *)a5 = *MEMORY[0x1E4F1FA10];
  *(void *)(a5 + 16) = *(void *)(v59 + 16);
  if (!v16) {
    return;
  }
LABEL_102:
  CMTime lhs = *v29;
  CMTime v60 = *(CMTime *)a5;
  CMTimeSubtract((CMTime *)v62, &lhs, &v60);
  *(_OWORD *)a5 = *(_OWORD *)v62;
  uint64_t v14 = *(void *)&v62[16];
LABEL_103:
  *(void *)(a5 + 16) = v14;
}

BOOL IntermediateLargeInteger::operator==(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[1];
  if ((*a1 & 0x8000000000000000) == 0)
  {
    if (!v2)
    {
      uint64_t v3 = a1[2];
      if (!v3) {
        return *a1 == a2 && a1[3] == v3;
      }
    }
    return 0;
  }
  if (v2 != -1) {
    return 0;
  }
  uint64_t v3 = a1[2];
  if (v3 != -1) {
    return 0;
  }
  return *a1 == a2 && a1[3] == v3;
}

void PCXMLWriteStream::PCXMLWriteStream(PCXMLWriteStream *this, PCStream *a2, int a3, int a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  PCSerializerWriteStream::PCSerializerWriteStream(this);
  *(void *)uint64_t v8 = &unk_1F10C4280;
  *(_OWORD *)(v8 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
  *(_OWORD *)(v8 + 48) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(void *)(v8 + 80) = a2;
  PCURL::PCURL((PCURL *)(v8 + 1120), 0);
  int64_t v9 = setlocale(4, 0);
  if (strcmp("C", v9)) {
    setlocale(4, "C");
  }
  PCStream::operator<<(*((void *)this + 10), "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
  PCStream::operator<<(*((void *)this + 10), "<!DOCTYPE ozxmlscene>\n");
  snprintf(__str, 0x20uLL, "%d.%d", a3, a4);
  uint64_t v10 = PCStream::operator<<(*((void *)this + 10), "<ozml version=\"");
  uint64_t v11 = PCStream::operator<<(v10, __str);
  PCStream::operator<<(v11, "\">\n\n");
  *((_DWORD *)this + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
}

void sub_1B76C9A1C(_Unwind_Exception *a1)
{
  std::deque<PCHash128>::~deque[abi:ne180100](v2);
  void *v1 = &unk_1F10C3F60;
  int v4 = (void *)v1[1];
  if (v4)
  {
    v1[2] = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t PCXMLWriteStream::close(PCXMLWriteStream *this)
{
  return PCStream::operator<<(*((void *)this + 10), "\n</ozml>\n");
}

uint64_t PCXMLWriteStream::getURL(PCXMLWriteStream *this)
{
  uint64_t v2 = (const void *)*((void *)this + 10);
  if (v2
  {
    return (uint64_t)v3 + 8;
  }
  else
  {
    return (uint64_t)this + 1120;
  }
}

void PCXMLWriteStream::startElement(PCXMLWriteStream *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int32 v8 = a2;
  uint64_t v10 = (char *)this + 92;
  uint64_t v11 = *((void *)this + 2);
  if (*((void *)this + 1) == v11) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = *(void *)(v11 - 8);
  }
  uint64_t v13 = *((void *)this + 9);
  uint64_t v14 = (char *)this + 92;
  if (v13)
  {
    unint64_t v15 = v13 + *((void *)this + 8) - 1;
    uint64_t v16 = *(void *)(*((void *)this + 5) + ((v15 >> 5) & 0x7FFFFFFFFFFFFF8));
    uint64_t v17 = v16 + 16 * v15;
    int v19 = *(unsigned __int8 *)(v17 + 13);
    int8x16_t v18 = (unsigned char *)(v17 + 13);
    uint64_t v14 = (char *)this + 92;
    if (!v19)
    {
      *((_WORD *)this + 46) = 2622;
      uint64_t v14 = (char *)this + 94;
      uint64_t v20 = v16 + 16 * v15;
      *(unsigned char *)(v20 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
      *int8x16_t v18 = 1;
      *(unsigned char *)(v20 + 14) = 1;
    }
  }
  if (!v12)
  {
    PCPrint("scope not defined!\n", a2, a3, a4, a5, a6, a7, a8, v33);
    exceptiouint64_t n = (PCException_ScopeUndefined *)__cxa_allocate_exception(0x40uLL);
    *(_OWORD *)exceptiouint64_t n = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
    *((_OWORD *)exception + 3) = 0u;
    PCException_ScopeUndefined::PCException_ScopeUndefined(exception);
    uint64_t v31 = (void (*)(void *))PCException_ScopeUndefined::~PCException_ScopeUndefined;
LABEL_13:
    __cxa_throw(exception, v30, v31);
  }
  if (!*(void *)v12)
  {
LABEL_12:
    PCStream::operator<<(*((void *)this + 10), v10);
    PCPrint("Token not defined in scope %s!\n", v22, v23, v24, v25, v26, v27, v28, **(void **)(*((void *)this + 2) - 8));
    exceptiouint64_t n = (PCException_ScopeUndefined *)__cxa_allocate_exception(0x40uLL);
    *(_OWORD *)exceptiouint64_t n = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
    *((_OWORD *)exception + 3) = 0u;
    PCException_NoElementDefined::PCException_NoElementDefined(exception);
    uint64_t v31 = (void (*)(void *))PCException_NoElementDefined::~PCException_NoElementDefined;
    goto LABEL_13;
  }
  while (*(_DWORD *)(v12 + 8) != a2 || *(_DWORD *)(v12 + 12))
  {
    uint64_t v21 = *(void *)(v12 + 16);
    v12 += 16;
    if (!v21) {
      goto LABEL_12;
    }
  }
  if (*((_DWORD *)this + 22))
  {
    uint64_t v32 = 0;
    do
      v14[v32++] = 9;
    while (v32 < *((_DWORD *)this + 22));
    v14 += v32;
  }
  *(_WORD *)uint64_t v14 = 60;
  strcat((char *)this + 92, *(const char **)v12);
  PCStream::operator<<(*((void *)this + 10), v10);
  v34.n128_u64[0] = *(void *)v12;
  v34.n128_u32[2] = v8;
  v34.n128_u16[6] = 1;
  v34.n128_u8[14] = 0;
  std::deque<PCXMLWriteStream::PCXMLElementInfo>::push_back((void *)this + 4, &v34);
  ++*((_DWORD *)this + 22);
}

void sub_1B76C9CF8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void PCException_ScopeUndefined::PCException_ScopeUndefined(PCException_ScopeUndefined *this)
{
  PCException::PCException(this);
  void *v1 = &unk_1F10C43E0;
}

void PCException_NoElementDefined::PCException_NoElementDefined(PCException_NoElementDefined *this)
{
  PCException::PCException(this);
  void *v1 = &unk_1F10C4420;
}

uint64_t PCXMLWriteStream::endElement(PCXMLWriteStream *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *((void *)this + 9);
  if (!v8)
  {
    PCPrint("endElement() called without startElement()!\n", a2, a3, a4, a5, a6, a7, a8, v20);
    exceptiouint64_t n = (PCException_NoElementDefined *)__cxa_allocate_exception(0x40uLL);
    *(_OWORD *)exceptiouint64_t n = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
    *((_OWORD *)exception + 3) = 0u;
    PCException_NoElementDefined::PCException_NoElementDefined(exception);
  }
  int v10 = *((_DWORD *)this + 22) - 1;
  *((_DWORD *)this + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v10;
  unint64_t v11 = v8 + *((void *)this + 8) - 1;
  uint64_t v12 = *(void *)(*((void *)this + 5) + ((v11 >> 5) & 0x7FFFFFFFFFFFFF8));
  uint64_t v13 = v12 + 16 * v11;
  if (*(unsigned char *)(v13 + 12))
  {
    uint64_t v14 = "/>\n";
  }
  else
  {
    uint64_t v14 = (char *)this + 92;
    if (*(unsigned char *)(v12 + 16 * v11 + 14)) {
      BOOL v15 = v10 == 0;
    }
    else {
      BOOL v15 = 1;
    }
    uint64_t v16 = (char *)this + 92;
    if (!v15)
    {
      uint64_t v17 = 0;
      do
        v14[v17++] = 9;
      while (v17 < *((_DWORD *)this + 22));
      uint64_t v16 = &v14[v17];
    }
    *(_WORD *)uint64_t v16 = 12092;
    strcpy(v16 + 2, *(const char **)v13);
    strcpy(&v14[strlen((const char *)this + 92)], ">\n");
  }
  PCStream::operator<<(*((void *)this + 10), v14);
  --*((void *)this + 9);

  return std::deque<PVLoadedEffectItem>::__maybe_remove_back_spare[abi:ne180100]((void *)this + 4, 1);
}

void sub_1B76C9EC8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t PCXMLWriteStream::writeBlankLine(PCXMLWriteStream *this)
{
  return PCStream::operator<<(*((void *)this + 10), "\n");
}

char *PCXMLWriteStream::terminateStartTag(PCXMLWriteStream *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *((void *)this + 9);
  if (!v8)
  {
    PCPrint("endElement() called without startElement()!\n", a2, a3, a4, a5, a6, a7, a8, v18);
    exceptiouint64_t n = (PCException_NoElementDefined *)__cxa_allocate_exception(0x40uLL);
    *(_OWORD *)exceptiouint64_t n = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
    *((_OWORD *)exception + 3) = 0u;
    PCException_NoElementDefined::PCException_NoElementDefined(exception);
  }
  unint64_t v9 = v8 + *((void *)this + 8) - 1;
  uint64_t v10 = *(void *)(*((void *)this + 5) + ((v9 >> 5) & 0x7FFFFFFFFFFFFF8));
  uint64_t v11 = v10 + 16 * v9;
  int v13 = *(unsigned __int8 *)(v11 + 13);
  uint64_t v12 = (unsigned char *)(v11 + 13);
  if (v13) {
    return (char *)this + 92;
  }
  uint64_t v15 = v9;
  uint64_t v14 = (char *)this + 93;
  *((_WORD *)this + 46) = 62;
  *(unsigned char *)(v10 + 16 * v15 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *uint64_t v12 = 1;
  return v14;
}

void sub_1B76C9FAC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t PCXMLWriteStream::writeValue(PCXMLWriteStream *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  started = PCXMLWriteStream::terminateStartTag(this, a2, a3, a4, a5, a6, a7, a8);
  snprintf(started, (PCXMLWriteStream *)((char *)this + 92) - (PCXMLWriteStream *)started + 1024, "%d", v8);
  uint64_t v11 = *((void *)this + 10);

  return PCStream::operator<<(v11, (char *)this + 92);
}

{
  int v8;
  char *started;
  uint64_t v11;
  uint64_t vars8;

  int v8 = a2;
  started = PCXMLWriteStream::terminateStartTag(this, a2, a3, a4, a5, a6, a7, a8);
  snprintf(started, (PCXMLWriteStream *)((char *)this + 92) - (PCXMLWriteStream *)started + 1024, "%u", v8);
  uint64_t v11 = *((void *)this + 10);

  return PCStream::operator<<(v11, (char *)this + 92);
}

{
  char *started;
  uint64_t v11;
  uint64_t vars8;

  started = PCXMLWriteStream::terminateStartTag(this, a2, a3, a4, a5, a6, a7, a8);
  snprintf(started, (PCXMLWriteStream *)((char *)this + 92) - (PCXMLWriteStream *)started + 1024, "%lld", a2);
  uint64_t v11 = *((void *)this + 10);

  return PCStream::operator<<(v11, (char *)this + 92);
}

{
  char *started;
  uint64_t v11;
  uint64_t vars8;

  started = PCXMLWriteStream::terminateStartTag(this, a2, a3, a4, a5, a6, a7, a8);
  snprintf(started, (PCXMLWriteStream *)((char *)this + 92) - (PCXMLWriteStream *)started + 1024, "%llu", a2);
  uint64_t v11 = *((void *)this + 10);

  return PCStream::operator<<(v11, (char *)this + 92);
}

uint64_t PCXMLWriteStream::writeValue(PCXMLWriteStream *this, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  started = PCXMLWriteStream::terminateStartTag(this, a3, a4, a5, a6, a7, a8, a9);
  snprintf(started, (PCXMLWriteStream *)((char *)this + 92) - (PCXMLWriteStream *)started + 1024, "%.10g", a2);
  uint64_t v12 = *((void *)this + 10);

  return PCStream::operator<<(v12, (char *)this + 92);
}

uint64_t PCXMLWriteStream::writeValue(PCXMLWriteStream *this, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  started = PCXMLWriteStream::terminateStartTag(this, a3, a4, a5, a6, a7, a8, a9);
  snprintf(started, (PCXMLWriteStream *)((char *)this + 92) - (PCXMLWriteStream *)started + 1024, "%.17lg", a2);
  uint64_t v12 = *((void *)this + 10);

  return PCStream::operator<<(v12, (char *)this + 92);
}

uint64_t PCXMLWriteStream::writeValue(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  started = PCXMLWriteStream::terminateStartTag((PCXMLWriteStream *)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  snprintf(started, a1 + 92 - (void)started + 1024, "%08x%08x%08x%08x", *a2, a2[1], a2[2], a2[3]);
  uint64_t v11 = *(void *)(a1 + 80);

  return PCStream::operator<<(v11, (char *)(a1 + 92));
}

void PCXMLWriteStream::writeValue(PCXMLWriteStream *this, PCString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*((void *)this + 9))
  {
    PCPrint("value not within an element body!\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v22);
    exceptiouint64_t n = (PCException_NoElementDefined *)__cxa_allocate_exception(0x40uLL);
    *(_OWORD *)exceptiouint64_t n = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
    *((_OWORD *)exception + 3) = 0u;
    PCException_NoElementDefined::PCException_NoElementDefined(exception);
  }
  unint64_t v9 = PCString::cf_str(a2);
  CFStringRef v10 = myCFXMLCreateStringByEscapingEntities(v9);
  CFIndex v11 = 4 * CFStringGetLength(v10);
  uint64_t v12 = (char *)malloc_type_malloc(v11 + 256, 0x6B92E561uLL);
  if (v12)
  {
    int v13 = v12;
    unint64_t v14 = *((void *)this + 9) + *((void *)this + 8) - 1;
    uint64_t v15 = *(void *)(*((void *)this + 5) + ((v14 >> 5) & 0x7FFFFFFFFFFFFF8));
    uint64_t v16 = v15 + 16 * v14;
    int v18 = *(unsigned __int8 *)(v16 + 13);
    uint64_t v17 = (unsigned char *)(v16 + 13);
    int v19 = v12;
    if (!v18)
    {
      *uint64_t v12 = 62;
      int v19 = v12 + 1;
      *(unsigned char *)(v15 + 16 * v14 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
      unsigned char *v17 = 1;
    }
    *int v19 = 0;
    size_t v20 = strlen(v12);
    CFStringGetCString(v10, &v13[v20], v11, 0x8000100u);
    PCStream::operator<<(*((void *)this + 10), v13);
    free(v13);
  }

  CFRelease(v10);
}

void sub_1B76CA404(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

CFMutableStringRef myCFXMLCreateStringByEscapingEntities(CFStringRef theString)
{
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, theString);
  v3.length = CFStringGetLength(MutableCopy);
  v3.locatiouint64_t n = 0;
  CFStringFindAndReplace(MutableCopy, @"&", @"&amp;", v3, 0);
  v4.length = CFStringGetLength(MutableCopy);
  v4.locatiouint64_t n = 0;
  CFStringFindAndReplace(MutableCopy, @"<", @"&lt;", v4, 0);
  v5.length = CFStringGetLength(MutableCopy);
  v5.locatiouint64_t n = 0;
  CFStringFindAndReplace(MutableCopy, @">", @"&gt;", v5, 0);
  v6.length = CFStringGetLength(MutableCopy);
  v6.locatiouint64_t n = 0;
  CFStringFindAndReplace(MutableCopy, @"\"", @"&quot;", v6, 0);
  return MutableCopy;
}

uint64_t PCXMLWriteStream::writeValue(PCXMLWriteStream *this, const CMTime *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  started = PCXMLWriteStream::terminateStartTag(this, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  snprintf(started, (PCXMLWriteStream *)((char *)this + 92) - (PCXMLWriteStream *)started + 1024, "%lld %d %x %lld", a2->value, a2->timescale, a2->flags, a2->epoch);
  uint64_t v11 = *((void *)this + 10);

  return PCStream::operator<<(v11, (char *)this + 92);
}

uint64_t PCXMLWriteStream::getAttributeInfo(PCXMLWriteStream *this, int a2)
{
  uint64_t v2 = *((void *)this + 9);
  if (!v2)
  {
    exceptiouint64_t n = (PCException_NoElementDefined *)__cxa_allocate_exception(0x40uLL);
    *(_OWORD *)exceptiouint64_t n = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
    *((_OWORD *)exception + 3) = 0u;
    PCException_NoElementDefined::PCException_NoElementDefined(exception);
    CFStringRef v10 = (void (*)(void *))PCException_NoElementDefined::~PCException_NoElementDefined;
LABEL_10:
    __cxa_throw(exception, v9, v10);
  }
  uint64_t v4 = *((void *)this + 2);
  if (*((void *)this + 1) == v4 || (uint64_t result = *(void *)(v4 - 8)) == 0)
  {
    exceptiouint64_t n = (PCException_NoElementDefined *)__cxa_allocate_exception(0x40uLL);
    *(_OWORD *)exceptiouint64_t n = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
    *((_OWORD *)exception + 3) = 0u;
    PCException_ScopeUndefined::PCException_ScopeUndefined(exception);
    CFStringRef v10 = (void (*)(void *))PCException_ScopeUndefined::~PCException_ScopeUndefined;
    goto LABEL_10;
  }
  if (!*(void *)result)
  {
LABEL_9:
    exceptiouint64_t n = (PCException_NoElementDefined *)__cxa_allocate_exception(0x40uLL);
    *(_OWORD *)exceptiouint64_t n = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
    *((_OWORD *)exception + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
    *((_OWORD *)exception + 3) = 0u;
    PCException_AttributeUndefined::PCException_AttributeUndefined(exception);
    CFStringRef v10 = (void (*)(void *))PCException_AttributeUndefined::~PCException_AttributeUndefined;
    goto LABEL_10;
  }
  int v6 = *(_DWORD *)(*(void *)(*((void *)this + 5)
                             + (((unint64_t)(v2 + *((void *)this + 8) - 1) >> 5) & 0x7FFFFFFFFFFFFF8))
                 + 16 * (v2 + *((unsigned char *)this + 64) - 1)
                 + 8);
  while (*(_DWORD *)(result + 8) != v6 || *(_DWORD *)(result + 12) != a2)
  {
    uint64_t v7 = *(void *)(result + 16);
    result += 16;
    if (!v7) {
      goto LABEL_9;
    }
  }
  return result;
}

void sub_1B76CA6AC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void PCException_AttributeUndefined::PCException_AttributeUndefined(PCException_AttributeUndefined *this)
{
  PCException::PCException(this);
  void *v1 = &unk_1F10C4460;
}

uint64_t PCXMLWriteStream::writeAttribute(PCXMLWriteStream *this, int a2, int a3)
{
  AttributeInfo = (const char **)PCXMLWriteStream::getAttributeInfo(this, a2);
  snprintf((char *)this + 92, 0x400uLL, " %s=\"%u\"", *AttributeInfo, a3);
  uint64_t v6 = *((void *)this + 10);

  return PCStream::operator<<(v6, (char *)this + 92);
}

{
  const char **AttributeInfo;
  uint64_t v6;
  uint64_t vars8;

  AttributeInfo = (const char **)PCXMLWriteStream::getAttributeInfo(this, a2);
  snprintf((char *)this + 92, 0x400uLL, " %s=\"%d\"", *AttributeInfo, a3);
  uint64_t v6 = *((void *)this + 10);

  return PCStream::operator<<(v6, (char *)this + 92);
}

uint64_t PCXMLWriteStream::writeAttribute(PCXMLWriteStream *this, int a2, uint64_t a3)
{
  AttributeInfo = (const char **)PCXMLWriteStream::getAttributeInfo(this, a2);
  snprintf((char *)this + 92, 0x400uLL, " %s=\"%llu\"", *AttributeInfo, a3);
  uint64_t v6 = *((void *)this + 10);

  return PCStream::operator<<(v6, (char *)this + 92);
}

{
  const char **AttributeInfo;
  uint64_t v6;
  uint64_t vars8;

  AttributeInfo = (const char **)PCXMLWriteStream::getAttributeInfo(this, a2);
  snprintf((char *)this + 92, 0x400uLL, " %s=\"%lld\"", *AttributeInfo, a3);
  uint64_t v6 = *((void *)this + 10);

  return PCStream::operator<<(v6, (char *)this + 92);
}

uint64_t PCXMLWriteStream::writeAttribute(PCXMLWriteStream *this, int a2, float a3)
{
  AttributeInfo = (const char **)PCXMLWriteStream::getAttributeInfo(this, a2);
  snprintf((char *)this + 92, 0x400uLL, " %s=\"%.10g\"", *AttributeInfo, a3);
  uint64_t v6 = *((void *)this + 10);

  return PCStream::operator<<(v6, (char *)this + 92);
}

uint64_t PCXMLWriteStream::writeAttribute(PCXMLWriteStream *this, int a2, double a3)
{
  AttributeInfo = (const char **)PCXMLWriteStream::getAttributeInfo(this, a2);
  snprintf((char *)this + 92, 0x400uLL, " %s=\"%.17lg\"", *AttributeInfo, a3);
  uint64_t v6 = *((void *)this + 10);

  return PCStream::operator<<(v6, (char *)this + 92);
}

uint64_t PCXMLWriteStream::writeAttribute(uint64_t a1, int a2, _DWORD *a3)
{
  AttributeInfo = (const char **)PCXMLWriteStream::getAttributeInfo((PCXMLWriteStream *)a1, a2);
  snprintf((char *)(a1 + 92), 0x400uLL, " %s=\"%08x%08x%08x%08x\"", *AttributeInfo, *a3, a3[1], a3[2], a3[3]);
  uint64_t v6 = *(void *)(a1 + 80);

  return PCStream::operator<<(v6, (char *)(a1 + 92));
}

void PCXMLWriteStream::writeAttribute(PCXMLWriteStream *this, int a2, PCString *a3)
{
  AttributeInfo = (const char **)PCXMLWriteStream::getAttributeInfo(this, a2);
  uint64_t v6 = PCString::cf_str(a3);
  CFStringRef v7 = myCFXMLCreateStringByEscapingEntities(v6);
  CFIndex v8 = 4 * CFStringGetLength(v7);
  unint64_t v9 = (char *)malloc_type_malloc(v8 + 256, 0xDDCDE674uLL);
  if (v9)
  {
    CFStringRef v10 = v9;
    *unint64_t v9 = 32;
    strcpy(v9 + 1, *AttributeInfo);
    strcat(v10, "=\"");
    size_t v11 = strlen(v10);
    CFStringGetCString(v7, &v10[v11], v8, 0x8000100u);
    *(_WORD *)&v10[strlen(v10)] = 34;
    PCStream::operator<<(*((void *)this + 10), v10);
    free(v10);
  }

  CFRelease(v7);
}

uint64_t PCXMLWriteStream::writeAttribute(PCXMLWriteStream *this, int a2, const CMTime *a3)
{
  AttributeInfo = (const char **)PCXMLWriteStream::getAttributeInfo(this, a2);
  snprintf((char *)this + 92, 0x400uLL, " %s=\"%lld %d %x %lld\"", *AttributeInfo, a3->value, a3->timescale, a3->flags, a3->epoch);
  uint64_t v6 = *((void *)this + 10);

  return PCStream::operator<<(v6, (char *)this + 92);
}

uint64_t PCXMLWriteStream::writeOptionalAttribute(PCXMLWriteStream *this, uint64_t a2, const PCString *a3)
{
  return (*(uint64_t (**)(PCXMLWriteStream *, uint64_t, const PCString *))(*(void *)this + 200))(this, a2, a3);
}

void PCXMLWriteStream::~PCXMLWriteStream(PCXMLWriteStream *this)
{
  *(void *)this = &unk_1F10C4280;
  PCURL::~PCURL((PCXMLWriteStream *)((char *)this + 1120));
  std::deque<PCHash128>::~deque[abi:ne180100]((void *)this + 4);
  *(void *)this = &unk_1F10C3F60;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10C4280;
  PCURL::~PCURL((PCXMLWriteStream *)((char *)this + 1120));
  std::deque<PCHash128>::~deque[abi:ne180100]((void *)this + 4);
  *(void *)this = &unk_1F10C3F60;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void PCException_ScopeUndefined::~PCException_ScopeUndefined(PCString *this)
{
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

void PCException_NoElementDefined::~PCException_NoElementDefined(PCString *this)
{
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

void PCException_AttributeUndefined::~PCException_AttributeUndefined(PCString *this)
{
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

__n128 std::deque<PCXMLWriteStream::PCXMLElementInfo>::push_back(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<PCXMLWriteStream::PCXMLElementInfo>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  __n128 result = *a2;
  *(__n128 *)(*(void *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v7) = *a2;
  ++a1[5];
  return result;
}

void std::deque<PCXMLWriteStream::PCXMLElementInfo>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    CFIndex v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)CFIndex v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      __n128 v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v5, v33);
      long long v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      CFIndex v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        CFIndex v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int8x16_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int8x16_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    int v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      unint64_t v9 = (char *)a1[1];
    }
    CFIndex v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<unsigned long *>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<unsigned long *>::push_front((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    CFIndex v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    unint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      __n128 v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 3), v46);
      long long v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      int8x16_t v48 = (uint64_t *)a1[1];
      CFIndex v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        CFIndex v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        unint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)unint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        CFIndex v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v54 + 8 * v26;
  int8x16_t v53 = operator new(0x1000uLL);
  std::__split_buffer<unsigned long *>::push_back(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<unsigned long *>::push_front((uint64_t)&v54, v27);
  }
  int8x16_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1B76CB0D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

float PCEstimateGammaFromTag(const PCICCTag *a1)
{
  PCGetTransferFunctionFromTag(a1, &v4);
  if (!v4) {
    return 0.0;
  }
  uint64_t v5 = &unk_1F10C44A0;
  float v6 = 0.0;
  (*(void (**)(uint64_t, void **))(*(void *)v4 + 24))(v4, &v5);
  float v1 = v6;
  uint64_t v2 = v4;
  uint64_t v4 = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return v1;
}

void sub_1B76CB1EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    PCEstimateGammaFromTag(a10);
  }
  _Unwind_Resume(exception_object);
}

float PCEstimateGammaFromTransferFunction(uint64_t a1)
{
  uint64_t v2 = &unk_1F10C44A0;
  float v3 = 0.0;
  (*(void (**)(uint64_t, void **))(*(void *)a1 + 24))(a1, &v2);
  return v3;
}

void anonymous namespace'::EstimateGammaVisitor::~EstimateGammaVisitor(_anonymous_namespace_::EstimateGammaVisitor *this)
{
}

uint64_t anonymous namespace'::EstimateGammaVisitor::visit(uint64_t result)
{
  *(_DWORD *)(result + 8) = 1065353216;
  return result;
}

void anonymous namespace'::EstimateGammaVisitor::visit(_anonymous_namespace_::EstimateGammaVisitor *this, const PCICCTransferFunctionGamma *a2)
{
  *((float *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = PCICCTransferFunctionGamma::getGamma(a2);
}

void anonymous namespace'::EstimateGammaVisitor::visit(_anonymous_namespace_::EstimateGammaVisitor *this, const PCICCTransferFunctionLUT *a2)
{
  uint64_t LUTEnd = PCICCTransferFunctionLUT::getLUTEnd(a2);
  FactoryForSerializatiouint64_t n = OZFactoryBase::getFactoryForSerialization((uint64_t)a2);
  float v6 = 1.0;
  if (LUTEnd - FactoryForSerialization != 8) {
    float v6 = PCEstimateGammaNumerically<PCICCTransferFunctionLUT>((uint64_t)a2);
  }
  *((float *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v6;
}

void anonymous namespace'::EstimateGammaVisitor::visit(_anonymous_namespace_::EstimateGammaVisitor *this, const PCICCTransferFunctionParametric0 *a2)
{
  *((float *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = PCICCTransferFunctionGamma::getGamma(a2);
}

void anonymous namespace'::EstimateGammaVisitor::visit(_anonymous_namespace_::EstimateGammaVisitor *this, const PCICCTransferFunctionParametric1 *a2)
{
  *((float *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = PCEstimateGammaNumerically<PCICCTransferFunctionLUT>((uint64_t)a2);
}

void anonymous namespace'::EstimateGammaVisitor::visit(_anonymous_namespace_::EstimateGammaVisitor *this, const PCICCTransferFunctionParametric2 *a2)
{
  *((float *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = PCEstimateGammaNumerically<PCICCTransferFunctionLUT>((uint64_t)a2);
}

void anonymous namespace'::EstimateGammaVisitor::visit(_anonymous_namespace_::EstimateGammaVisitor *this, const PCICCTransferFunctionParametric3 *a2)
{
  float Gamma = PCICCTransferFunctionGamma::getGamma(a2);
  float v5 = PCICCTransferFunctionParametric3::getA(a2);
  float v6 = PCICCTransferFunctionParametric3::getB(a2);
  float v7 = PCICCTransferFunctionParametric3::getC(a2);
  float v8 = PCICCTransferFunctionParametric3::getD(a2);
  if (PCIs709TransferFunction(Gamma, v5, v6, v7, v8))
  {
    float v9 = 1.961;
  }
  else if (PCIssRGBTransferFunction(Gamma, v5, v6, v7, v8))
  {
    float v9 = 2.2;
  }
  else
  {
    float v9 = PCEstimateGammaNumerically<PCICCTransferFunctionLUT>((uint64_t)a2);
  }
  *((float *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v9;
}

void anonymous namespace'::EstimateGammaVisitor::visit(_anonymous_namespace_::EstimateGammaVisitor *this, const PCICCTransferFunctionParametric4 *a2)
{
  *((float *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = PCEstimateGammaNumerically<PCICCTransferFunctionLUT>((uint64_t)a2);
}

float PCEstimateGammaNumerically<PCICCTransferFunctionLUT>(uint64_t a1)
{
  float v2 = (*(float (**)(uint64_t, float))(*(void *)a1 + 16))(a1, 0.5);
  if (v2 < 0.01 || v2 > 0.99) {
    goto LABEL_7;
  }
  float v3 = 0.0;
  float v4 = logf(v2) / -0.69315;
  do
  {
    float v5 = (*(float (**)(uint64_t, float))(*(void *)a1 + 16))(a1, v3 * 0.00097656);
    float v6 = vabds_f32(v5, powf(v3 * 0.00097656, v4));
    if (v6 >= 0.001) {
      break;
    }
    float v3 = v3 + 1.0;
  }
  while (v3 != 1025.0);
  if (v6 >= 0.001)
  {
LABEL_7:
    float v7 = 0.0;
    int v8 = 52;
    float v9 = 0.0;
    do
    {
      float v10 = (*(float (**)(uint64_t, float))(*(void *)a1 + 16))(a1, (float)v8 * 0.00097656);
      if ((v10 <= -0.00001 || v10 >= 0.00001) && fabsf(v10 + -1.0) >= 0.00001)
      {
        float v11 = logf(v10);
        float v9 = v9 + (float)(v11 / logf((float)v8 * 0.00097656));
        float v7 = v7 + 1.0;
      }
      ++v8;
    }
    while (v8 != 1024);
    float v12 = 0.0;
    float v13 = v9 / v7;
    do
    {
      float v14 = (*(float (**)(uint64_t, float))(*(void *)a1 + 16))(a1, v12 * 0.00097656);
      float v15 = powf(v12 * 0.00097656, v13);
      if ((float)(v12 * 0.00097656) > 0.9 || (float)(v12 * 0.00097656) < 0.1) {
        float v17 = 0.01;
      }
      else {
        float v17 = 0.05;
      }
      float v18 = vabds_f32(v14, v15);
      if (v18 >= v17) {
        break;
      }
      float v12 = v12 + 1.0;
    }
    while (v12 != 1025.0);
    float v4 = 0.0;
    if (v18 < v17) {
      return floorf((float)(v13 * 10.0) + 0.5) / 10.0;
    }
  }
  return v4;
}

uint64_t PCEstimateGammaFromTag(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 8))(a1);
}

void PCString::PCString(PCString *this, const char *a2)
{
  if (a2 && *a2) {
    CFStringRef Copy = (__CFString *)CFStringCreateWithCString(0, a2, 0x8000100u);
  }
  else {
    CFStringRef Copy = (__CFString *)CFStringCreateCopy(0, &stru_1F119C770);
  }
  this->var0 = Copy;
}

void PCString::PCString(PCString *this, const char *a2, const char *a3)
{
  float v4 = 0;
  if (a2 && a3) {
    float v4 = (__CFString *)CFStringCreateWithCString(0, a2, 0x8000100u);
  }
  this->var0 = v4;
}

void PCString::PCString(PCString *this, const unsigned __int16 *a2)
{
  if (a2)
  {
    uint64_t v2 = 0;
    while (a2[v2++])
      ;
    this->var0 = (__CFString *)CFStringCreateWithCharacters(0, a2, v2 - 1);
  }
}

void PCString::PCString(PCString *this, const PCString *a2)
{
  this->var0 = 0;
  var0 = a2->var0;
  if (var0) {
    this->var0 = (__CFString *)CFStringCreateCopy(0, var0);
  }
}

void PCString::PCString(PCString *this, const __CFString *cf, int a3)
{
  if (!a3)
  {
    if (cf)
    {
      CFStringRef Copy = (__CFString *)CFStringCreateCopy(0, cf);
      goto LABEL_7;
    }
LABEL_6:
    CFStringRef Copy = 0;
    goto LABEL_7;
  }
  if (!cf) {
    goto LABEL_6;
  }
  CFStringRef Copy = (__CFString *)CFRetain(cf);
LABEL_7:
  this->var0 = Copy;
}

void PCString::~PCString(PCString *this)
{
  var0 = this->var0;
  if (var0) {
    CFRelease(var0);
  }
}

uint64_t *PCString::intern(PCString *this, const PCString *a2)
{
  {
    operator new();
  }
  return std::__tree<PCString>::__emplace_unique_key_args<PCString,PCString const&>((PCString *)PCString::intern(PCString const&)::sTable, this, (CFStringRef *)&this->var0)+ 4;
}

void sub_1B76CBED4(_Unwind_Exception *a1)
{
}

void PCString::set(PCString *this, const PCString *a2)
{
  var0 = this->var0;
  if (var0)
  {
    this->var0 = 0;
    CFRelease(var0);
  }
  if (a2->var0) {
    this->var0 = (__CFString *)CFStringCreateCopy(0, a2->var0);
  }
}

void PCString::clear(PCString *this)
{
  var0 = this->var0;
  if (var0)
  {
    this->var0 = 0;
    CFRelease(var0);
  }
}

void PCString::set(PCString *this, const char *a2)
{
  float v3 = (__CFString *)CFStringCreateWithCString(0, a2, 0x8000100u);
  var0 = this->var0;
  if (this->var0)
  {
    this->var0 = 0;
    CFRelease(var0);
  }
  this->var0 = v3;
}

__CFString *PCString::set(PCString *this, UniChar *chars)
{
  if (*chars)
  {
    uint64_t v4 = 0;
    while (chars[++v4])
      ;
    CFIndex v6 = v4;
  }
  else
  {
    CFIndex v6 = 0;
  }
  var0 = this->var0;
  if (this->var0)
  {
    this->var0 = 0;
    CFRelease(var0);
  }
  __n128 result = (__CFString *)CFStringCreateWithCharacters(0, chars, v6);
  this->var0 = result;
  return result;
}

void PCString::set(PCString *this, CFStringRef theString)
{
  var0 = this->var0;
  if (var0)
  {
    this->var0 = 0;
    CFRelease(var0);
  }
  if (theString) {
    this->var0 = (__CFString *)CFStringCreateCopy(0, theString);
  }
}

BOOL PCString::empty(PCString *this)
{
  var0 = this->var0;
  return !var0 || CFStringGetLength(var0) == 0;
}

__CFString *PCString::size(PCString *this)
{
  __n128 result = this->var0;
  if (result) {
    return (__CFString *)CFStringGetLength(result);
  }
  return result;
}

char *PCString::createCStr(PCString *this)
{
  var0 = this->var0;
  if (var0)
  {
    CFIndex Length = CFStringGetLength(var0);
    CFIndex v4 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    float v5 = (char *)malloc_type_malloc(v4, 0xB8E0C132uLL);
    if (v5) {
      CFStringGetCString(this->var0, v5, v4, 0x8000100u);
    }
  }
  else
  {
    float v5 = (char *)malloc_type_malloc(1uLL, 0x100004077774924uLL);
    *float v5 = 0;
  }
  return v5;
}

char *PCString::createUTF8Str(PCString *this)
{
  var0 = this->var0;
  if (!var0) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(var0);
  CFIndex v4 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  float v5 = (char *)malloc_type_malloc(v4, 0xF3DDC59EuLL);
  if (v5) {
    CFStringGetCString(this->var0, v5, v4, 0x8000100u);
  }
  return v5;
}

__CFString *PCString::cf_str(PCString *this)
{
  if (this->var0) {
    return this->var0;
  }
  else {
    return &stru_1F119C770;
  }
}

UniChar *PCString::createUniStr(PCString *this)
{
  var0 = this->var0;
  if (!var0) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(var0);
  CFIndex v4 = (UniChar *)malloc_type_malloc(2 * Length + 2, 0x1000040BDFB0063uLL);
  if (v4)
  {
    v6.locatiouint64_t n = 0;
    v6.length = Length;
    CFStringGetCharacters(this->var0, v6, v4);
    v4[Length] = 0;
  }
  return v4;
}

char *PCString::createVerifiedFormatString(PCString *this, const char *a2)
{
  CStr = PCString::createCStr(this);
  int v4 = strlen(a2);
  float v5 = (char *)malloc_type_malloc(v4 + 1, 0x34160C44uLL);
  strcpy(v5, a2);
  CFRange v6 = fmtcheck(CStr, v5);
  free(v5);
  if (v6 != CStr)
  {
    free(CStr);
    return 0;
  }
  return CStr;
}

CFComparisonResult PCString::compare(PCString *this, const PCString *a2)
{
  var0 = this->var0;
  float v3 = a2->var0;
  if (!((unint64_t)var0 | (unint64_t)v3)) {
    return 0;
  }
  if (var0) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v3 == 0;
  }
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  if (var0) {
    BOOL v6 = v3 == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6) {
    return 1;
  }
  else {
    return CFStringCompare(var0, v3, 0x20uLL);
  }
}

CFComparisonResult PCString::caseInsensitiveCompare(PCString *this, const PCString *a2)
{
  var0 = this->var0;
  float v3 = a2->var0;
  if (!((unint64_t)var0 | (unint64_t)v3)) {
    return 0;
  }
  if (var0) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v3 == 0;
  }
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  if (var0) {
    BOOL v6 = v3 == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6) {
    return 1;
  }
  else {
    return CFStringCompare(var0, v3, 0x21uLL);
  }
}

PCString *PCString::insert(PCString *this, CFIndex a2, const PCString *a3)
{
  var0 = this->var0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (var0)
  {
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v6, 0, var0);
    CFStringInsert(MutableCopy, a2, a3->var0);
    float v9 = this->var0;
    if (this->var0)
    {
      this->var0 = 0;
      CFRelease(v9);
    }
  }
  else
  {
    CFMutableStringRef MutableCopy = (__CFString *)CFStringCreateCopy(v6, a3->var0);
  }
  this->var0 = MutableCopy;
  return this;
}

PCString *PCString::append(PCString *this, const PCString *a2)
{
  values[2] = *(void **)MEMORY[0x1E4F143B8];
  var0 = a2->var0;
  if (a2->var0)
  {
    if (this->var0)
    {
      values[0] = this->var0;
      values[1] = var0;
      CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFArrayRef v5 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 2, MEMORY[0x1E4F1D510]);
      CFAllocatorRef v6 = (__CFString *)CFStringCreateByCombiningStrings(v4, v5, &stru_1F119C770);
      CFRelease(v5);
      float v7 = this->var0;
      if (this->var0)
      {
        this->var0 = 0;
        CFRelease(v7);
      }
      this->var0 = v6;
    }
    else
    {
      PCString::set(this, a2);
    }
  }
  return this;
}

PCString *PCString::append(PCString *this, const char *a2)
{
  if (a2)
  {
    if (this->var0)
    {
      CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, this->var0);
      CFStringAppendCString(MutableCopy, a2, 0x8000100u);
      var0 = this->var0;
      if (this->var0)
      {
        this->var0 = 0;
        CFRelease(var0);
      }
      this->var0 = MutableCopy;
    }
    else
    {
      PCString::set(this, a2);
    }
  }
  return this;
}

PCString *PCString::erase(PCString *this, CFIndex a2, unsigned int a3)
{
  if (a3 && this->var0)
  {
    CFIndex v5 = a3;
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, this->var0);
    v9.locatiouint64_t n = a2;
    v9.length = v5;
    CFStringDelete(MutableCopy, v9);
    var0 = this->var0;
    if (this->var0)
    {
      this->var0 = 0;
      CFRelease(var0);
    }
    this->var0 = MutableCopy;
  }
  return this;
}

PCString *PCString::replace(PCString *this, CFIndex a2, unsigned int a3, const PCString *a4)
{
  if (a4->var0 && this->var0)
  {
    CFIndex v7 = a3;
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, this->var0);
    v11.locatiouint64_t n = a2;
    v11.length = v7;
    CFStringReplace(MutableCopy, v11, a4->var0);
    var0 = this->var0;
    if (this->var0)
    {
      this->var0 = 0;
      CFRelease(var0);
    }
    this->var0 = MutableCopy;
  }
  return this;
}

uint64_t PCString::find(PCString *this, const PCString *a2)
{
  var0 = this->var0;
  if (!var0) {
    return 0xFFFFFFFFLL;
  }
  CFRange v3 = CFStringFind(var0, a2->var0, 0);
  if (v3.length) {
    BOOL v4 = v3.location == -1;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return LODWORD(v3.location);
  }
}

void PCString::substr(PCString *this@<X0>, CFIndex a2@<X1>, unsigned int a3@<W2>, CFStringRef *a4@<X8>)
{
  if (this->var0)
  {
    v7.length = a3;
    v7.locatiouint64_t n = a2;
    CFStringRef v5 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], this->var0, v7);
    CFStringRef v6 = v5;
    if (v5) {
      CFRetain(v5);
    }
    *a4 = v6;
    CFRelease(v6);
  }
  else
  {
    *a4 = 0;
  }
}

void sub_1B76CC734(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PCString::substrTo(PCString *this@<X0>, uint64_t a2@<X1>, CFStringRef *a3@<X8>)
{
  if (this->var0
    && (v6.length = a2 + 1,
        v6.locatiouint64_t n = 0,
        (CFStringRef v4 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], this->var0, v6)) != 0))
  {
    CFStringRef v5 = v4;
    CFRetain(v4);
    *a3 = v5;
    CFRelease(v5);
  }
  else
  {
    *a3 = 0;
  }
}

void sub_1B76CC7AC(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PCString::substrFrom(PCString *this@<X0>, CFIndex a2@<X1>, CFStringRef *a3@<X8>)
{
  var0 = this->var0;
  if (var0 && (v7.length = CFStringGetLength(var0) - a2, v7.length >= 0))
  {
    v7.locatiouint64_t n = a2;
    CFStringRef v8 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], this->var0, v7);
    CFStringRef v9 = v8;
    if (v8) {
      CFRetain(v8);
    }
    *a3 = v9;
    CFRelease(v9);
  }
  else
  {
    *a3 = 0;
  }
}

void sub_1B76CC840(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PCString::sprintf(PCString *this, CFStringRef format, ...)
{
  va_start(va, format);
  var0 = this->var0;
  if (var0)
  {
    this->var0 = 0;
    CFRelease(var0);
  }
  if (format) {
    this->var0 = (__CFString *)CFStringCreateWithFormatAndArguments(0, 0, format, va);
  }
}

void PCString::sprintf(PCString *this, const char *__format, ...)
{
  va_start(va, __format);
  vsnprintf(sprintf_buf, 0x800uLL, __format, va);
  byte_1E9EE571F = 0;
  PCString::set(this, sprintf_buf);
}

void PCString::ssprintf(PCString *this@<X0>, PCString *a2@<X8>, ...)
{
  va_start(va, a2);
  a2->var0 = 0;
  vsnprintf(sprintf_buf, 0x800uLL, (const char *)this, va);
  byte_1E9EE571F = 0;
  PCString::set(a2, sprintf_buf);
}

void sub_1B76CC970(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PCString::format(PCString *this@<X0>, PCString *a2@<X8>)
{
  a2->var0 = 0;
  PCString::sprintf(a2, @"%d", this);
}

void sub_1B76CC9C4(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PCString::format(PCString *this@<X0>, double a2@<D0>, PCString *a3@<X8>)
{
  a3->var0 = 0;
  PCString::sprintf(a3, @"%lg", *(void *)&a2);
}

void sub_1B76CCA18(_Unwind_Exception *a1)
{
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<PCString>::__emplace_unique_key_args<PCString,PCString const&>(PCString *a1, PCString *this, CFStringRef *a3)
{
  CFStringRef v5 = std::__tree<std::__value_type<PCString,TXFont *>,std::__map_value_compare<PCString,std::__value_type<PCString,TXFont *>,std::less<PCString>,true>,std::allocator<std::__value_type<PCString,TXFont *>>>::__find_equal<PCString>(a1, &v10, this);
  var0 = (uint64_t *)v5->var0;
  if (!v5->var0)
  {
    CFRange v7 = (uint64_t **)v5;
    std::__tree<PCString>::__construct_node<PCString const&>((uint64_t)a1, a3, (uint64_t)v9);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v10, v7, v9[0]);
    var0 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<PCString,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<PCString,void *>>>>::reset[abi:ne180100]((uint64_t)v9, 0);
  }
  return var0;
}

void *std::__tree<PCString>::__construct_node<PCString const&>@<X0>(uint64_t a1@<X0>, CFStringRef *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  __n128 result = operator new(0x28uLL);
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  result[4] = 0;
  if (*a2)
  {
    CFRange v7 = result;
    __n128 result = CFStringCreateCopy(0, *a2);
    v7[4] = result;
  }
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1B76CCB24(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<PCString,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<PCString,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<PCString,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<PCString,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(PCString **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      PCString::~PCString(v2 + 4);
    }
    operator delete(v2);
  }
}

__CFString *PCString::ns_str(PCString *this)
{
  if (!this->var0) {
    return &stru_1F119C770;
  }
  uint64_t v1 = this->var0;

  return v1;
}

void PCString::stringWithoutSpacesAndNewlines(PCString *this@<X0>, PCString *a2@<X8>)
{
  CFStringRef v3 = (const __CFString *)-[__CFString stringByRemovingCharactersInSet:](this->var0, "stringByRemovingCharactersInSet:", [MEMORY[0x1E4F28B88] whitespaceAndNewlineCharacterSet]);
  a2->var0 = 0;

  PCString::set(a2, v3);
}

uint64_t PCString::composedCharacterCount(PCString *this)
{
  return [(__CFString *)this->var0 composedCharacterCount];
}

uint64_t PCString::isWhitespaceAndNewline(PCString *this)
{
  return [(__CFString *)this->var0 isAllWhitespaceAndNewline];
}

uint64_t PCString::isNewline(PCString *this)
{
  return [(__CFString *)this->var0 isNewline];
}

void PCConditionVariable::~PCConditionVariable(pthread_cond_t *this)
{
}

uint64_t PCConditionVariable::wait(pthread_cond_t *this, PCMutex *a2)
{
  return pthread_cond_wait(this, &a2->_Mutex);
}

void PCMutex::PCMutex(PCMutex *this, int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  this->_vptr$PCMutex = (void **)&unk_1F10C4518;
  if (a2)
  {
    uint64_t v3 = pthread_mutexattr_init(&v16);
    if (v3)
    {
      exceptiouint64_t n = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"error: %s returned %d", &v15, "pthread_mutexattr_init(&rmta)", v3);
      PCString::PCString(&v14, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCMutex.cpp");
      PCException::PCException(exception, &v15, &v14, 47);
      *(void *)exceptiouint64_t n = &unk_1F10C4560;
    }
    uint64_t v4 = pthread_mutexattr_settype(&v16, 2);
    if (v4)
    {
      float v12 = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"error: %s returned %d", &v15, "pthread_mutexattr_settype(&rmta, PTHREAD_MUTEX_RECURSIVE)", v4);
      PCString::PCString(&v14, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCMutex.cpp");
      PCException::PCException(v12, &v15, &v14, 48);
      *(void *)float v12 = &unk_1F10C4560;
    }
    uint64_t v5 = pthread_mutex_init(&this->_Mutex, &v16);
    if (v5)
    {
      float v13 = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"error: %s returned %d", &v15, "pthread_mutex_init(&_Mutex, &rmta)", v5);
      PCString::PCString(&v14, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCMutex.cpp");
      PCException::PCException(v13, &v15, &v14, 50);
      *(void *)float v13 = &unk_1F10C4560;
    }
    uint64_t v6 = pthread_mutexattr_destroy(&v16);
    if (v6)
    {
      CFRange v7 = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"error: %s returned %d", &v15, "pthread_mutexattr_destroy(&rmta)", v6);
      PCString::PCString(&v14, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCMutex.cpp");
      PCException::PCException(v7, &v15, &v14, 52);
      *(void *)CFRange v7 = &unk_1F10C4560;
    }
  }
  else
  {
    uint64_t v8 = pthread_mutex_init(&this->_Mutex, 0);
    if (v8)
    {
      uint64_t v9 = v8;
      float v10 = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"error: %s returned %d", (PCString *)&v16, "pthread_mutex_init(&_Mutex, NULL)", v9);
      PCString::PCString(&v15, "/Library/Caches/com.apple.xbs/Sources/ProCoreiOS/PCMutex.cpp");
      PCException::PCException(v10, (const PCString *)&v16, &v15, 56);
      *(void *)float v10 = &unk_1F10C4560;
    }
  }
}

void sub_1B76CD044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12, PCString a13, PCString a14)
{
  PCString::~PCString(&a12);
  PCString::~PCString(&a13);
  if (v15) {
    __cxa_free_exception(v14);
  }
  _Unwind_Resume(a1);
}

void PCMutex::~PCMutex(PCMutex *this)
{
  this->_vptr$PCMutex = (void **)&unk_1F10C4518;
  pthread_mutex_destroy(&this->_Mutex);
}

{
  uint64_t vars8;

  PCMutex::~PCMutex(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PCMutex::lock(PCMutex *this)
{
  return pthread_mutex_lock(&this->_Mutex);
}

uint64_t PCMutex::unlock(PCMutex *this)
{
  return pthread_mutex_unlock(&this->_Mutex);
}

void PCSystemException::~PCSystemException(PCString *this)
{
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

void PCSystemException::className(PCURL *a1@<X8>)
{
}

void PCSemaphore::PCSemaphore(PCSemaphore *this, unsigned int a2)
{
  *(void *)this = a2;
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 56);
  pthread_cond_init((pthread_cond_t *)((char *)this + 8), 0);
  pthread_mutex_init(v2, 0);
}

void PCSemaphore::~PCSemaphore(PCSemaphore *this)
{
}

uint64_t PCSemaphore::wait(PCSemaphore *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 56);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 56));
  for (uint64_t i = *(void *)this; !*(void *)this; uint64_t i = *(void *)this)
    pthread_cond_wait((pthread_cond_t *)((char *)this + 8), v2);
  *(void *)this = i - 1;

  return pthread_mutex_unlock(v2);
}

uint64_t PCSemaphore::signal(PCSemaphore *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 56);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 56));
  ++*(void *)this;
  pthread_cond_signal((pthread_cond_t *)((char *)this + 8));

  return pthread_mutex_unlock(v2);
}

void PCThread::PCThread(PCThread *this, void (*a2)(void *), void *a3, const char *a4)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t PCThread::startup(PCThread *this, void *a2)
{
  uint64_t v3 = (const char *)*((void *)this + 2);
  if (v3) {
    pthread_setname_np(v3);
  }
  (*(void (**)(void, void *))this)(*((void *)this + 1), a2);
  uint64_t v4 = *((void *)this + 2);
  if (v4)
  {
    MEMORY[0x1BA9BFB70](v4, 0x1000C8077774924);
    *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  }
  MEMORY[0x1BA9BFBA0](this, 0x90C401993945DLL);
  return 0;
}

void PCThread::PCThread(PCThread *this)
{
  *(void *)this = pthread_self();
}

uint64_t PCThread::detach(pthread_t *this)
{
  return pthread_detach(*this);
}

BOOL PCThread::isSelf(_opaque_pthread_t **this)
{
  uint64_t v1 = *this;
  uint64_t v2 = pthread_self();
  return pthread_equal(v1, v2) != 0;
}

void *operator<<(void *a1, int a2)
{
  switch(a2)
  {
    case 0:
      uint64_t v3 = "PC_BLEND_NORMAL";
      goto LABEL_54;
    case 1:
      uint64_t v3 = "PC_BLEND_SEPARATOR0";
      goto LABEL_62;
    case 2:
      uint64_t v3 = "PC_BLEND_SUBTRACT";
      goto LABEL_58;
    case 3:
      uint64_t v3 = "PC_BLEND_DARKEN";
      goto LABEL_54;
    case 4:
      uint64_t v3 = "PC_BLEND_MULTIPLY";
      goto LABEL_58;
    case 5:
      uint64_t v3 = "PC_BLEND_COLOR_BURN";
      goto LABEL_62;
    case 6:
      uint64_t v3 = "PC_BLEND_LINEAR_BURN";
      goto LABEL_20;
    case 7:
      uint64_t v3 = "PC_BLEND_SEPARATOR1";
      goto LABEL_62;
    case 8:
      uint64_t v3 = "PC_BLEND_ADD";
      goto LABEL_52;
    case 9:
      uint64_t v3 = "PC_BLEND_LIGHTEN";
      goto LABEL_45;
    case 10:
      uint64_t v3 = "PC_BLEND_SCREEN";
      goto LABEL_54;
    case 11:
      uint64_t v3 = "PC_BLEND_COLOR_DODGE";
      goto LABEL_20;
    case 12:
      uint64_t v3 = "PC_BLEND_LINEAR_DODGE";
      goto LABEL_30;
    case 13:
      uint64_t v3 = "PC_BLEND_SEPARATOR2";
      goto LABEL_62;
    case 14:
      uint64_t v3 = "PC_BLEND_OVERLAY";
      goto LABEL_45;
    case 15:
      uint64_t v3 = "PC_BLEND_SOFT_LIGHT";
      goto LABEL_62;
    case 16:
      uint64_t v3 = "PC_BLEND_HARD_LIGHT";
      goto LABEL_62;
    case 17:
      uint64_t v3 = "PC_BLEND_VIVID_LIGHT";
LABEL_20:
      uint64_t v4 = 20;
      goto LABEL_65;
    case 18:
      uint64_t v3 = "PC_BLEND_LINEAR_LIGHT";
      goto LABEL_30;
    case 19:
      uint64_t v3 = "PC_BLEND_PIN_LIGHT";
      goto LABEL_43;
    case 20:
      uint64_t v3 = "PC_BLEND_HARD_MIX";
      goto LABEL_58;
    case 21:
      uint64_t v3 = "PC_BLEND_SEPARATOR3";
      goto LABEL_62;
    case 22:
      uint64_t v3 = "PC_BLEND_DIFFERENCE";
      goto LABEL_62;
    case 23:
      uint64_t v3 = "PC_BLEND_EXCLUSION";
      goto LABEL_43;
    case 24:
      uint64_t v3 = "PC_BLEND_SEPARATOR4";
      goto LABEL_62;
    case 25:
      uint64_t v3 = "PC_BLEND_STENCIL_ALPHA";
      uint64_t v4 = 22;
      goto LABEL_65;
    case 26:
      uint64_t v3 = "PC_BLEND_STENCIL_LUMA";
LABEL_30:
      uint64_t v4 = 21;
      goto LABEL_65;
    case 27:
      uint64_t v3 = "PC_BLEND_SILHOUETTE_ALPHA";
      uint64_t v4 = 25;
      goto LABEL_65;
    case 28:
      uint64_t v3 = "PC_BLEND_SILHOUETTE_LUMA";
      uint64_t v4 = 24;
      goto LABEL_65;
    case 29:
      uint64_t v3 = "PC_BLEND_BEHIND";
      goto LABEL_54;
    case 30:
      uint64_t v3 = "PC_BLEND_SEPARATOR5";
      goto LABEL_62;
    case 31:
      uint64_t v3 = "PC_BLEND_ALPHA_ADD";
      goto LABEL_43;
    case 32:
      uint64_t v3 = "PC_BLEND_LUMINESCENT_PREMUL";
      goto LABEL_41;
    case 33:
      uint64_t v3 = "PC_BLEND_SEPARATOR6";
      goto LABEL_62;
    case 34:
      uint64_t v3 = "PC_BLEND_COMBINE";
      goto LABEL_45;
    case 35:
      uint64_t v3 = "PC_BLEND_LIGHT_WRAP";
      goto LABEL_62;
    case 36:
      uint64_t v3 = "PC_BLEND_SUPPORTED_LIST_END";
LABEL_41:
      uint64_t v4 = 27;
      goto LABEL_65;
    case 37:
      uint64_t v3 = "PC_BLEND_SEPARATOR";
LABEL_43:
      uint64_t v4 = 18;
      goto LABEL_65;
    case 38:
      uint64_t v3 = "PC_BLEND_AVERAGE";
LABEL_45:
      uint64_t v4 = 16;
      goto LABEL_65;
    case 39:
      uint64_t v3 = "PC_BLEND_CLEAR";
      goto LABEL_48;
    case 40:
      uint64_t v3 = "PC_BLEND_COLOR";
LABEL_48:
      uint64_t v4 = 14;
      goto LABEL_65;
    case 41:
      uint64_t v3 = "PC_BLEND_DISSOLVE";
      goto LABEL_58;
    case 42:
      uint64_t v3 = "PC_BLEND_GRAY";
      goto LABEL_64;
    case 43:
      uint64_t v3 = "PC_BLEND_HUE";
LABEL_52:
      uint64_t v4 = 12;
      goto LABEL_65;
    case 44:
      uint64_t v3 = "PC_BLEND_INVERT";
LABEL_54:
      uint64_t v4 = 15;
      goto LABEL_65;
    case 45:
      uint64_t v3 = "PC_BLEND_LUMINOSITY";
      goto LABEL_62;
    case 46:
      uint64_t v3 = "PC_BLEND_MASK";
      goto LABEL_64;
    case 47:
      uint64_t v3 = "PC_BLEND_NEGATION";
LABEL_58:
      uint64_t v4 = 17;
      goto LABEL_65;
    case 48:
      uint64_t v3 = "PC_BLEND_NONE";
      goto LABEL_64;
    case 49:
      uint64_t v3 = "PC_BLEND_OVER";
      goto LABEL_64;
    case 50:
      uint64_t v3 = "PC_BLEND_SATURATION";
LABEL_62:
      uint64_t v4 = 19;
      goto LABEL_65;
    case 51:
      uint64_t v3 = "PC_BLEND_TEST";
LABEL_64:
      uint64_t v4 = 13;
LABEL_65:
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v3, v4);
      break;
    default:
      return a1;
  }
  return a1;
}

PCColorSpaceCache *PCGetWorkingColorSpace(PCColorSpaceCache *result)
{
  if (result == 1) {
    return (PCColorSpaceCache *)PCColorSpaceCache::cgRec2020Linear(result);
  }
  if (!result) {
    return (PCColorSpaceCache *)PCColorSpaceCache::cgsRGB(result);
  }
  return result;
}

uint64_t PCGetUIColorSpaceID()
{
  return 3;
}

float PCGetWorkingColorSpaceLuminanceCoefficients(int a1, uint64_t a2)
{
  return PCGetGamutColorSpaceLuminanceCoefficients(4 * (a1 != 0), a2);
}

float PCGetGamutColorSpaceLuminanceCoefficients(unsigned int a1, uint64_t a2)
{
  if (a1 <= 5)
  {
    if (initGamutInfo(void)::once != -1) {
      dispatch_once_f(&initGamutInfo(void)::once, 0, (dispatch_function_t)actuallyInitGamutInfo);
    }
    uint64_t v4 = gamutInfo + 72 * a1;
    *(_DWORD *)a2 = *(_DWORD *)v4;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v4 + 4);
    float result = *(float *)(v4 + 8);
    *(float *)(a2 + 8) = result;
  }
  return result;
}

uint64_t PCGetColorGamut(int a1)
{
  return 4 * (a1 != 0);
}

void PCGetColorSpaceLuminanceCoefficients(CGColorSpace *a1, float *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (CGColorSpaceGetModel(a1))
  {
    PCICCProfile::PCICCProfile((PCICCProfile *)v9, a1);
    PCGetChromaticities((PCICCProfile *)v9, v8);
    PCGetLuminanceCoefficients(v8[0].f32, v7);
    float v4 = v7[0];
    float v5 = v7[1];
    float v6 = v7[2];
    PCICCProfile::~PCICCProfile((PCICCProfile *)v9);
    if (v4 == 0.0 && v5 == 0.0 && v6 == 0.0)
    {
      PCGetRec709LuminanceCoefficients((uint64_t)v9);
      float v4 = *(float *)v9;
      float v5 = *(float *)&v9[1];
      float v6 = *(float *)&v9[2];
    }
  }
  else
  {
    float v5 = 0.0;
    float v4 = 1.0;
    float v6 = 0.0;
  }
  *a2 = v4;
  a2[1] = v5;
  a2[2] = v6;
}

void sub_1B76CDAE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  if (a2)
  {
    PCICCProfile::~PCICCProfile((PCICCProfile *)&a16);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1B76CDA84);
  }
  _Unwind_Resume(exception_object);
}

uint64_t PCGetWorkingColorSpaceRGBToYCbCrMatrix(int a1, uint64_t a2)
{
  uint64_t result = getGamutInfoForWorkingGamut(a1);
  for (uint64_t i = 0; i != 3; ++i)
  {
    for (uint64_t j = 0; j != 12; j += 4)
      *(_DWORD *)(a2 + j) = *(_DWORD *)(result + j);
    result += 12;
    a2 += 12;
  }
  return result;
}

uint64_t getGamutInfoForWorkingGamut(int a1)
{
  if (initGamutInfo(void)::once != -1) {
    dispatch_once_f(&initGamutInfo(void)::once, 0, (dispatch_function_t)actuallyInitGamutInfo);
  }
  uint64_t v2 = 288;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return gamutInfo + v2;
}

uint64_t PCGetWorkingColorSpaceYCbCrToRGBMatrix(int a1, uint64_t a2)
{
  uint64_t result = getGamutInfoForWorkingGamut(a1);
  uint64_t v4 = 0;
  uint64_t v5 = result + 36;
  do
  {
    for (uint64_t i = 0; i != 12; i += 4)
      *(_DWORD *)(a2 + i) = *(_DWORD *)(v5 + i);
    ++v4;
    v5 += 12;
    a2 += 12;
  }
  while (v4 != 3);
  return result;
}

void actuallyInitGamutInfo(void *a1)
{
}

void PCICCTransferFunctionLinear::PCICCTransferFunctionLinear(PCICCTransferFunctionLinear *this)
{
  *(void *)this = &unk_1F10C45A0;
}

void PCICCTransferFunctionLinear::~PCICCTransferFunctionLinear(PCICCTransferFunctionLinear *this)
{
}

uint64_t PCICCTransferFunctionLinear::accept(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
}

void PCICCTransferFunctionGamma::PCICCTransferFunctionGamma(PCICCTransferFunctionGamma *this, float a2)
{
  *(void *)this = &unk_1F10C45D0;
  *((float *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a2;
}

void PCICCTransferFunctionGamma::~PCICCTransferFunctionGamma(PCICCTransferFunctionGamma *this)
{
}

float PCICCTransferFunctionGamma::operator()(uint64_t a1, float a2)
{
  return powf(a2, *(float *)(a1 + 8));
}

float PCICCTransferFunctionGamma::getGamma(PCICCTransferFunctionGamma *this)
{
  return *((float *)this + 2);
}

uint64_t PCICCTransferFunctionGamma::accept(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, a1);
}

void PCICCTransferFunctionLUT::~PCICCTransferFunctionLUT(PCICCTransferFunctionLUT *this)
{
  *(void *)this = &unk_1F10C4600;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10C4600;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

float PCICCTransferFunctionLUT::operator()(uint64_t a1, float a2)
{
  if (a2 <= 0.0) {
    return **(float **)(a1 + 8);
  }
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = ((*(void *)(a1 + 16) - v2) >> 2) - 1;
  if (a2 >= 1.0) {
    return *(float *)(v2 + 4 * v3);
  }
  float v4 = (float)(unint64_t)v3 * a2;
  unint64_t v5 = vcvtms_u32_f32(v4);
  return (1.0 - (float)(v4 - (float)v5)) * *(float *)(v2 + 4 * v5)
       + (float)(v4 - (float)v5) * *(float *)(v2 + 4 * v5 + 4);
}

uint64_t PCICCTransferFunctionLUT::getLUTEnd(PCICCTransferFunctionLUT *this)
{
  return *((void *)this + 2);
}

uint64_t PCICCTransferFunctionLUT::accept(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 32))(a2, a1);
}

void PCICCTransferFunctionParametric0::PCICCTransferFunctionParametric0(PCICCTransferFunctionParametric0 *this, float a2)
{
  *(void *)this = &unk_1F10C4630;
  *((float *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a2;
}

void PCICCTransferFunctionParametric0::~PCICCTransferFunctionParametric0(PCICCTransferFunctionParametric0 *this)
{
}

float PCICCTransferFunctionParametric0::operator()(uint64_t a1, float a2)
{
  return powf(a2, *(float *)(a1 + 8));
}

uint64_t PCICCTransferFunctionParametric0::accept(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, a1);
}

void PCICCTransferFunctionParametric1::~PCICCTransferFunctionParametric1(PCICCTransferFunctionParametric1 *this)
{
}

float PCICCTransferFunctionParametric1::operator()(float *a1, float a2)
{
  float v3 = a1[3];
  float v2 = a1[4];
  if ((float)((float)-v2 / v3) <= a2) {
    return powf(v2 + (float)(v3 * a2), a1[2]);
  }
  else {
    return 0.0;
  }
}

uint64_t PCICCTransferFunctionParametric1::accept(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2, a1);
}

void PCICCTransferFunctionParametric2::~PCICCTransferFunctionParametric2(PCICCTransferFunctionParametric2 *this)
{
}

float PCICCTransferFunctionParametric2::operator()(float *a1, float a2)
{
  float v3 = a1[3];
  float v2 = a1[4];
  if ((float)((float)-v2 / v3) <= a2) {
    return powf(v2 + (float)(v3 * a2), a1[2]) + a1[5];
  }
  else {
    return a1[5];
  }
}

uint64_t PCICCTransferFunctionParametric2::accept(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 56))(a2, a1);
}

void PCICCTransferFunctionParametric3::PCICCTransferFunctionParametric3(PCICCTransferFunctionParametric3 *this, float a2, float a3, float a4, float a5, float a6)
{
  *(void *)this = &unk_1F10C46C0;
  *((float *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a2;
  *((float *)this + 3) = a3;
  *((float *)this + 4) = a4;
  *((float *)this + 5) = a5;
  *((float *)this + 6) = a6;
}

void PCICCTransferFunctionParametric3::~PCICCTransferFunctionParametric3(PCICCTransferFunctionParametric3 *this)
{
}

float PCICCTransferFunctionParametric3::operator()(float *a1, float a2)
{
  if (a1[6] <= a2) {
    return powf((float)(a1[3] * a2) + a1[4], a1[2]);
  }
  else {
    return a1[5] * a2;
  }
}

float PCICCTransferFunctionParametric3::getA(PCICCTransferFunctionParametric3 *this)
{
  return *((float *)this + 3);
}

float PCICCTransferFunctionParametric3::getB(PCICCTransferFunctionParametric3 *this)
{
  return *((float *)this + 4);
}

float PCICCTransferFunctionParametric3::getC(PCICCTransferFunctionParametric3 *this)
{
  return *((float *)this + 5);
}

float PCICCTransferFunctionParametric3::getD(PCICCTransferFunctionParametric3 *this)
{
  return *((float *)this + 6);
}

uint64_t PCICCTransferFunctionParametric3::accept(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 64))(a2, a1);
}

void PCICCTransferFunctionParametric4::~PCICCTransferFunctionParametric4(PCICCTransferFunctionParametric4 *this)
{
}

float PCICCTransferFunctionParametric4::operator()(float *a1, float a2)
{
  if (a1[6] <= a2)
  {
    float v3 = powf((float)(a1[3] * a2) + a1[4], a1[2]);
    float v4 = a1[7];
  }
  else
  {
    float v3 = a1[5] * a2;
    float v4 = a1[8];
  }
  return v3 + v4;
}

uint64_t PCICCTransferFunctionParametric4::accept(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 72))(a2, a1);
}

uint64_t PCGetTransferFunctionFromTag@<X0>(const PCICCTag *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = PVPerfStats::FrameStats::GetSize(a1);
  if ((int)result > 1800688194)
  {
    if (result != 1800688195)
    {
      int v5 = 1918128707;
LABEL_6:
      if (result != v5) {
        goto LABEL_15;
      }
    }
  }
  else if (result != 1649693251)
  {
    int v5 = 1733579331;
    goto LABEL_6;
  }
  FactoryForSerializatiouint64_t n = OZFactoryBase::getFactoryForSerialization((uint64_t)a1);
  uint64_t result = ProCore::Private::getInt32Number((ProCore::Private *)FactoryForSerialization, v7);
  if (result == 1885434465)
  {
    uint64_t result = ProCore::Private::getUInt16Number((ProCore::Private *)(FactoryForSerialization + 8), v8);
    switch((int)result)
    {
      case 0:
        int Int32Number = (ProCore::Private *)ProCore::Private::getInt32Number((ProCore::Private *)(FactoryForSerialization + 12), v13);
        if (Int32Number >> 1 != 58982) {
          ProCore::Private::convertFromS15Fixed16(Int32Number);
        }
        operator new();
      case 1:
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 12), v13);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 16), v20);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 20), v21);
        operator new();
      case 2:
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 12), v13);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 16), v22);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 20), v23);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 24), v24);
        operator new();
      case 3:
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 12), v13);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 16), v25);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 20), v26);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 24), v27);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 28), v28);
        operator new();
      case 4:
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 12), v13);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 16), v29);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 20), v30);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 24), v31);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 28), v32);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 32), v33);
        ProCore::Private::getS15Fixed16Number((ProCore::Private *)(FactoryForSerialization + 36), v34);
        operator new();
      default:
        break;
    }
  }
  else if (result == 1668641398)
  {
    unsigned int v9 = ProCore::Private::getInt32Number((ProCore::Private *)(FactoryForSerialization + 8), v8);
    CFRange v11 = (char *)(FactoryForSerialization + 12);
    if (v9 != 1)
    {
      unsigned int v12 = v9;
      if (!v9) {
        operator new();
      }
      if ((v9 & 0x7FFFFFFF) != 0x400
        || memcmp(v11, &is_sRGB_LUT(unsigned char const*,unsigned int)::sRGB_LUT, 0x800uLL))
      {
        std::vector<float>::vector(&__p, v12);
        int v17 = 0;
        uint64_t v18 = 0;
        do
        {
          float v19 = (double)ProCore::Private::getUInt16Number((ProCore::Private *)&v11[v17 & 0xFFFFFFFE], v16)
              / 65535.0;
          *((float *)__p + v18++) = v19;
          v17 += 2;
        }
        while (v12 != v18);
        operator new();
      }
      operator new();
    }
    UInt16Number = (ProCore::Private *)ProCore::Private::getUInt16Number((ProCore::Private *)v11, v10);
    if (((unsigned __int16)UInt16Number & 0xFFFE) != 0x1CC) {
      ProCore::Private::convertFromU8Fixed8(UInt16Number);
    }
    operator new();
  }
LABEL_15:
  *a2 = 0;
  return result;
}

void sub_1B76CE7C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  MEMORY[0x1BA9BFBA0](v11, 0x81C4018A671A6);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t PCMakeTRCTag(uint64_t a1, uint64_t a2, int a3)
{
  v4[0] = &unk_1F10C47F0;
  v4[1] = a2;
  int v5 = a3;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)a1 + 24))(a1, v4);
}

void anonymous namespace'::MakeTagVisitor::~MakeTagVisitor(_anonymous_namespace_::MakeTagVisitor *this)
{
}

_WORD *anonymous namespace'::MakeTagVisitor::visit(_anonymous_namespace_::MakeTagVisitor *this, const PCICCTransferFunctionLinear *a2)
{
  beginCurveTag(*((ProCore::Private **)this + 1), *((_DWORD *)this + 4));
  float v3 = (PCICCTag *)*((void *)this + 1);

  return addTableToTag(v3, 0, 0);
}

_WORD *anonymous namespace'::MakeTagVisitor::visit(_anonymous_namespace_::MakeTagVisitor *this, const PCICCTransferFunctionGamma *a2)
{
  beginCurveTag(*((ProCore::Private **)this + 1), *((_DWORD *)this + 4));
  float v5 = *((float *)a2 + 2);
  return addTableToTag(*((PCICCTag **)this + 1), &v5, (const float *)&v6);
}

_WORD *anonymous namespace'::MakeTagVisitor::visit(_anonymous_namespace_::MakeTagVisitor *this, const PCICCTransferFunctionLUT *a2)
{
  beginCurveTag(*((ProCore::Private **)this + 1), *((_DWORD *)this + 4));
  float v4 = (PCICCTag *)*((void *)this + 1);
  float v5 = (const float *)*((void *)a2 + 1);
  uint64_t v6 = (const float *)*((void *)a2 + 2);

  return addTableToTag(v4, v5, v6);
}

unsigned char *anonymous namespace'::MakeTagVisitor::visit(_anonymous_namespace_::MakeTagVisitor *this, const PCICCTransferFunctionParametric0 *a2)
{
  beginParametricTag(*((ProCore::Private **)this + 1), *((_DWORD *)this + 4), 0);
  float v5 = *((float *)a2 + 2);
  uint64_t v6 = (ProCore::Private *)*((void *)this + 1);
  if (fabsf(v5 + -1.8) >= 0.00001)
  {
    double v8 = v5;
    return ProCore::Private::add15Fixed16ToTag(v6, v4, v8);
  }
  else
  {
    return ProCore::Private::addInt32ToTag(v6, (PCICCTag *)0x1CCCC);
  }
}

unsigned char *anonymous namespace'::MakeTagVisitor::visit(_anonymous_namespace_::MakeTagVisitor *this, const PCICCTransferFunctionParametric1 *a2)
{
  beginParametricTag(*((ProCore::Private **)this + 1), *((_DWORD *)this + 4), (PCICCTag *)1);
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v4, *((float *)a2 + 2));
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v5, *((float *)a2 + 3));
  CFRange v7 = (ProCore::Private *)*((void *)this + 1);
  double v8 = *((float *)a2 + 4);

  return ProCore::Private::add15Fixed16ToTag(v7, v6, v8);
}

unsigned char *anonymous namespace'::MakeTagVisitor::visit(_anonymous_namespace_::MakeTagVisitor *this, const PCICCTransferFunctionParametric2 *a2)
{
  beginParametricTag(*((ProCore::Private **)this + 1), *((_DWORD *)this + 4), (PCICCTag *)2);
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v4, *((float *)a2 + 2));
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v5, *((float *)a2 + 3));
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v6, *((float *)a2 + 4));
  double v8 = (ProCore::Private *)*((void *)this + 1);
  double v9 = *((float *)a2 + 5);

  return ProCore::Private::add15Fixed16ToTag(v8, v7, v9);
}

unsigned char *anonymous namespace'::MakeTagVisitor::visit(_anonymous_namespace_::MakeTagVisitor *this, const PCICCTransferFunctionParametric3 *a2)
{
  beginParametricTag(*((ProCore::Private **)this + 1), *((_DWORD *)this + 4), (PCICCTag *)3);
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v4, *((float *)a2 + 2));
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v5, *((float *)a2 + 3));
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v6, *((float *)a2 + 4));
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v7, *((float *)a2 + 5));
  double v9 = (ProCore::Private *)*((void *)this + 1);
  double v10 = *((float *)a2 + 6);

  return ProCore::Private::add15Fixed16ToTag(v9, v8, v10);
}

unsigned char *anonymous namespace'::MakeTagVisitor::visit(_anonymous_namespace_::MakeTagVisitor *this, const PCICCTransferFunctionParametric4 *a2)
{
  beginParametricTag(*((ProCore::Private **)this + 1), *((_DWORD *)this + 4), (PCICCTag *)4);
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v4, *((float *)a2 + 2));
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v5, *((float *)a2 + 3));
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v6, *((float *)a2 + 4));
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v7, *((float *)a2 + 5));
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v8, *((float *)a2 + 6));
  ProCore::Private::add15Fixed16ToTag(*((ProCore::Private **)this + 1), v9, *((float *)a2 + 7));
  uint64_t v11 = (ProCore::Private *)*((void *)this + 1);
  double v12 = *((float *)a2 + 8);

  return ProCore::Private::add15Fixed16ToTag(v11, v10, v12);
}

_DWORD *beginCurveTag(ProCore::Private *this, unsigned int a2)
{
  if (a2 <= 3) {
    PCICCTag::reset((uint64_t)this, dword_1B7E7E3C0[a2]);
  }
  ProCore::Private::addInt32ToTag(this, (PCICCTag *)0x63757276);

  return ProCore::Private::addInt32ToTag(this, 0);
}

_WORD *addTableToTag(PCICCTag *a1, const float *a2, const float *a3)
{
  float v4 = a2;
  if ((char *)a3 - (char *)a2 != 4)
  {
    uint64_t v6 = (PCICCTag *)((unint64_t)((char *)a3 - (char *)a2) >> 2);
LABEL_5:
    for (uint64_t result = ProCore::Private::addInt32ToTag(a1, v6); v4 != a3; uint64_t result = ProCore::Private::addInt16ToTag(a1, v11))
    {
      float v8 = *v4++;
      int v9 = vcvtmd_s64_f64((float)(v8 * 65535.0) + 0.5 + 0.0000001);
      float v10 = (float)v9;
      if ((float)v9 > 65535.0) {
        float v10 = 65535.0;
      }
      if (v9 >= 0) {
        uint64_t v11 = (PCICCTag *)(int)v10;
      }
      else {
        uint64_t v11 = 0;
      }
    }
    return result;
  }
  if (ProCore::Private::convertToU8Fixed8(a1, *a2) == 256)
  {
    uint64_t v6 = 0;
    goto LABEL_5;
  }
  ProCore::Private::addInt32ToTag(a1, (PCICCTag *)1);
  float v13 = 4.0;
  if (*v4 <= 4.0) {
    float v13 = *v4;
  }
  if (*v4 >= 0.25) {
    float v14 = v13;
  }
  else {
    float v14 = 0.25;
  }
  double v15 = v14;
  if (v14 >= 2.25 || v15 <= 2.15)
  {
    if (v14 <= 1.75 || v15 >= 1.85)
    {
      if (v15 > 0.95 && v15 < 1.05) {
        float v14 = 1.0;
      }
    }
    else
    {
      float v14 = 1.8;
    }
  }
  else
  {
    float v14 = 2.2;
  }
  if (fabsf(v14 + -1.8) >= 0.00001)
  {
    double v17 = v14;
    return ProCore::Private::add8Fixed8ToTag(a1, v12, v17);
  }
  else
  {
    return ProCore::Private::addInt16ToTag(a1, (PCICCTag *)0x1CC);
  }
}

_WORD *beginParametricTag(ProCore::Private *this, unsigned int a2, PCICCTag *a3)
{
  if (a2 <= 3) {
    PCICCTag::reset((uint64_t)this, dword_1B7E7E3C0[a2]);
  }
  ProCore::Private::addInt32ToTag(this, (PCICCTag *)0x70617261);
  ProCore::Private::addInt32ToTag(this, 0);
  ProCore::Private::addInt16ToTag(this, a3);

  return ProCore::Private::addInt16ToTag(this, 0);
}

void *std::vector<float>::__init_with_size[abi:ne180100]<float const*,float const*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B76CEF70(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

Float64 OZChannelSecondsForFigTime(const CMTime *a1, int32_t a2)
{
  memset(&v5, 0, sizeof(v5));
  CMTime time = *a1;
  CMTimeConvertScale(&v5, &time, a2, kCMTimeRoundingMethod_RoundTowardZero);
  CMTime v3 = v5;
  return CMTimeGetSeconds(&v3);
}

double FigTimeToFrameWithRate(const CMTime *a1, double a2)
{
  return floor(OZChannelSecondsForFigTime(a1, a1->timescale) * a2 + 0.0000001);
}

BOOL PCMath::equal(PCMath *this, const CMTime *a2, const CMTime *a3, const CMTime *a4)
{
  int v4 = *((_DWORD *)this + 3);
  if ((v4 & 0x1D) != 1 || (a2->flags & 0x1D) != 1) {
    return (~v4 & 5) == 0 && (~a2->flags & 5) == 0 || (~v4 & 9) == 0 && (~a2->flags & 9) == 0;
  }
  CMTime time1 = *(CMTime *)this;
  CMTime time2 = *a2;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v7);
  CMTime v8 = v7;
  CMTime time1 = v7;
  CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  if (CMTimeCompare(&time1, &time2) < 0) {
    operator*(&v8, &time1, -1.0);
  }
  else {
    CMTime time1 = v8;
  }
  CMTime v8 = time1;
  CMTime time2 = *a3;
  return CMTimeCompare(&time1, &time2) < 1;
}

void sub_1B76CF240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double PCTimeRange::getRangeEnclosingWholeFrames@<D0>(PCTimeRange *this@<X0>, const CMTime *a2@<X1>, uint64_t a3@<X8>)
{
  memset(&v11, 0, sizeof(v11));
  CMTime v13 = *(CMTime *)this;
  CMTime v12 = *(CMTime *)((unsigned char *)this + 1);
  PC_CMTimeSaferAdd(&v13, &v12, (uint64_t)&v11);
  memset(&v10, 0, sizeof(v10));
  CMTime v13 = *(CMTime *)this;
  CMTime v12 = *a2;
  PC_CMTimeFloorToSampleDuration(&v13, &v12, (uint64_t)&v10);
  long long v8 = 0uLL;
  uint64_t v9 = 0;
  CMTime v13 = v11;
  CMTime v12 = v10;
  PC_CMTimeSaferSubtract(&v13, &v12, (uint64_t)&v7);
  CMTime v13 = v7;
  CMTime v12 = *a2;
  PC_CMTimeCeilingToSampleDuration(&v13, &v12, (uint64_t)&v8);
  *(CMTime *)a3 = v10;
  double result = *(double *)&v8;
  *(_OWORD *)(a3 + 24) = v8;
  *(void *)(a3 + 40) = v9;
  return result;
}

uint64_t half::convert(half *this)
{
  unsigned int v1 = (this >> 16) & 0x8000;
  unsigned int v2 = (this >> 23);
  unsigned int v3 = this & 0x7FFFFF;
  unsigned int v4 = v2 - 112;
  if (v2 > 0x70)
  {
    if (v2 == 255)
    {
      int v6 = (v3 < 0x2000) | (v3 >> 13) | v1 | 0x7C00;
      LOWORD(vPCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v1 | 0x7C00;
      if (v3) {
        LOWORD(vPCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v6;
      }
    }
    else
    {
      unsigned int v7 = v3 + 0x2000;
      unsigned int v8 = v2 - 111;
      if (v3 >= 0x7FE000) {
        unsigned int v7 = 0;
      }
      else {
        unsigned int v8 = v4;
      }
      if (((unsigned __int16)this & 0x1000) != 0) {
        unsigned int v3 = v7;
      }
      else {
        unsigned int v8 = v4;
      }
      if (v8 < 0x1F)
      {
        v1 |= (v8 << 10) | (v3 >> 13);
      }
      else
      {
        float v11 = 1.0e10;
        int v9 = 10;
        do
        {
          float v11 = v11 * v11;
          --v9;
        }
        while (v9);
        LOWORD(vPCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v1 | 0x7C00;
      }
    }
  }
  else
  {
    unsigned int v5 = (v3 | 0x800000) >> (113 - v2);
    if ((v5 & 0x1000) != 0) {
      v5 += 0x2000;
    }
    v1 |= v5 >> 13;
    if (v2 < 0x66) {
      LOWORD(vPCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
    }
  }
  return (__int16)v1;
}

void HGParamBufferDesc::printParamValuesFromBuffer(HGParamBufferDesc *this@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  a4->__r_.__value_.__r.__words[0] = 0;
  a4->__r_.__value_.__l.__size_ = 0;
  a4->__r_.__value_.__r.__words[2] = 0;
  if (*((void *)this + 5) == a3)
  {
    uint64_t v6 = *((void *)this + 2);
    if (*((void *)this + 3) != v6)
    {
      unint64_t v8 = 0;
      int v9 = &a2[a3];
      do
      {
        uint64_t v10 = PVInstructionGraphContext::HGNodeCache(*(PVInstructionGraphContext **)(v6 + 8 * v8));
        if (&a2[v10 + HGParamField::fieldSize(*(HGParamField **)(*((void *)this + 2) + 8 * v8))] > v9) {
          break;
        }
        (*(void (**)(void **__return_ptr))(**(void **)(*((void *)this + 2) + 8 * v8) + 40))(__p);
        float v11 = (v14 & 0x80u) == 0 ? (const std::string::value_type *)__p : (const std::string::value_type *)__p[0];
        CMTime v12 = (v14 & 0x80u) == 0 ? (void *)v14 : __p[1];
        std::string::append(a4, v11, (std::string::size_type)v12);
        if ((char)v14 < 0) {
          operator delete(__p[0]);
        }
        ++v8;
        uint64_t v6 = *((void *)this + 2);
      }
      while (v8 < (*((void *)this + 3) - v6) >> 3);
    }
  }
  else
  {
    std::string::append(a4, " paramBufferData and ParamBufferDesc.size() does not match, Aborting logging param values\n");
  }
}

void sub_1B76CF7E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if ((*(char *)(v15 + 23) & 0x80000000) == 0) {
    _Unwind_Resume(exception_object);
  }
  operator delete(*(void **)v15);
  _Unwind_Resume(exception_object);
}

uint64_t HGParamField::fieldSize(HGParamField *this)
{
  return *((void *)this + 4);
}

void HGComicStrokeAndBlend::HGComicStrokeAndBlend(HGComicStrokeAndBlend *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v2 = &unk_1F10C4868;
  *(void *)(v2 + 408) = 0x3F80000000000000;
  *(_DWORD *)(v2 + 416) = 1065353216;
  *(void *)(v2 + 428) = 0;
  *(void *)(v2 + 420) = 0;
  HGNode::SetFlags((HGNode *)v2, 2, 4);
  *((_DWORD *)this + 4) |= 0x620u;
}

void sub_1B76CF8D8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGComicStrokeAndBlend::~HGComicStrokeAndBlend(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGComicStrokeAndBlend::SetParameter(HGComicStrokeAndBlend *this, int a2, float a3, float a4, float a5, float a6)
{
  switch(a2)
  {
    case 0:
      if (*((float *)this + 102) == a3) {
        goto LABEL_17;
      }
      *((float *)this + 10PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a3;
      uint64_t result = 1;
      break;
    case 1:
      if (*((float *)this + 105) == a3) {
        goto LABEL_17;
      }
      *((float *)this + 105) = a3;
      uint64_t result = 1;
      break;
    case 2:
      if (*((float *)this + 106) == a3) {
        goto LABEL_17;
      }
      *((float *)this + 106) = a3;
      uint64_t result = 1;
      break;
    case 3:
      if (*((float *)this + 107) == a3) {
        goto LABEL_17;
      }
      *((float *)this + 107) = a3;
      uint64_t result = 1;
      break;
    case 4:
      if (*((float *)this + 108) == a3) {
        goto LABEL_17;
      }
      *((float *)this + 108) = a3;
      uint64_t result = 1;
      break;
    case 5:
      if (*((float *)this + 103) == a3) {
        goto LABEL_17;
      }
      *((float *)this + 103) = a3;
      uint64_t result = 1;
      break;
    case 6:
      if (*((float *)this + 104) == a3)
      {
LABEL_17:
        uint64_t result = 0;
      }
      else
      {
        *((float *)this + 104) = a3;
        uint64_t result = 1;
      }
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HGComicStrokeAndBlend::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicStrokeAndBlend::GetDOD(HGComicStrokeAndBlend *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGRect v13 = a4;
  if (a3 != 1) {
    return 0;
  }
  if (HGRect::IsInfinite(&v13)) {
    return *(void *)&v13.var0;
  }
  double v6 = *((float *)this + 104);
  HGTransform::HGTransform((HGTransform *)v12);
  HGTransform::Scale((HGTransform *)v12, v6, v6, 1.0);
  unsigned int v7 = *(const HGTransform **)&v13.var0;
  uint64_t v8 = *(void *)&v13.var2;
  float v10 = HGTransformUtils::MinW(v9);
  *(void *)&v14.var0 = v8;
  uint64_t DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v12, v7, v14, 0.5, v10);
  HGTransform::~HGTransform((HGTransform *)v12);
  return DOD;
}

void sub_1B76CFADC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76CFAF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGComicStrokeAndBlend::GetROI(HGComicStrokeAndBlend *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  unint64_t v5 = *(void *)&a4.var0;
  switch(a3)
  {
    case 0:
      double v7 = (float)(*((float *)this + 103) * (float)(1.0 / *((float *)this + 104)));
      HGTransform::HGTransform((HGTransform *)v26);
      HGTransform::Scale((HGTransform *)v26, v7, v7, 1.0);
      *(void *)&v27.var0 = 0;
      *(void *)&v27.var2 = 0;
      float v9 = HGTransformUtils::MinW(v8);
      *(void *)&v32.var0 = v4;
      *(void *)&v27.var0 = HGTransformUtils::GetROI((HGTransformUtils *)v26, v5, v32, 0.5, v9);
      *(void *)&v27.var2 = *(void *)&v28.var0;
      LODWORD(v10) = vcvtps_s32_f32(*((float *)this + 102) + *((float *)this + 102));
      *(void *)&v28.var2 = v10 | (v10 << 32);
      v28.var0 = -(int)v10;
      v28.var1 = -(int)v10;
      HGRect::Grow(&v27, v28);
      uint64_t v11 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      uint64_t v13 = v12;
      *(void *)&v29.var0 = v11;
      *(void *)&v29.var2 = v13;
      HGRect::Grow(&v27, v29);
      goto LABEL_7;
    case 1:
      double v18 = 1.0 / *((float *)this + 104);
      HGTransform::HGTransform((HGTransform *)v26);
      HGTransform::Scale((HGTransform *)v26, v18, v18, 1.0);
      *(void *)&v27.var0 = 0;
      *(void *)&v27.var2 = 0;
      float v20 = HGTransformUtils::MinW(v19);
      *(void *)&v33.var0 = v4;
      *(void *)&v27.var0 = HGTransformUtils::GetROI((HGTransformUtils *)v26, v5, v33, 0.5, v20);
      *(void *)&v27.var2 = v21;
      uint64_t v22 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      uint64_t v24 = v23;
      *(void *)&v31.var0 = v22;
      *(void *)&v31.var2 = v24;
      HGRect::Grow(&v27, v31);
LABEL_7:
      HGTransform::~HGTransform((HGTransform *)v26);
      break;
    case 2:
      *(void *)&v27.var0 = HGRectMake4i(0, 0, 0x200u, 0x200u);
      *(void *)&v27.var2 = v14;
      break;
    case 3:
      HGRect v27 = a4;
      uint64_t v15 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      uint64_t v17 = v16;
      *(void *)&v30.var0 = v15;
      *(void *)&v30.var2 = v17;
      HGRect::Grow(&v27, v30);
      break;
    default:
      HGRect v27 = (HGRect)HGRectNull;
      break;
  }
  return *(void *)&v27.var0;
}

void sub_1B76CFD04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76CFD18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76CFD2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76CFD40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76CFD54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGComicStrokeAndBlend::RenderTile(HGComicStrokeAndBlend *this, HGTile *a2)
{
  float v4 = *((float *)this + 104);
  float v5 = *((float *)this + 103);
  uint64_t v6 = HGTile::Renderer(a2);
  int v7 = (*(uint64_t (**)(HGComicStrokeAndBlend *, uint64_t))(*(void *)this + 312))(this, v6);
  int32x2_t v9 = *(int32x2_t *)a2;
  int v115 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v115 >= 1)
  {
    uint64_t v10 = (*((_DWORD *)a2 + 2) - v9.i32[0]);
    if ((int)v10 >= 1)
    {
      int v11 = v7;
      int v12 = 0;
      *(float32x2_t *)v13.f32 = vadd_f32(vcvt_f32_s32(v9), (float32x2_t)0x3F0000003F000000);
      v13.i64[1] = 0x3F80000000000000;
      float v14 = *((float *)this + 102);
      float v15 = 1.0 / (float)(v14 * (float)(v14 * 3.0));
      float v16 = v14 + v14;
      float v118 = v5 * (float)(1.0 / v4);
      uint64_t v17 = *((void *)a2 + 2);
      v18.i64[0] = 0x3F0000003F000000;
      v18.i64[1] = 0x3F0000003F000000;
      __asm { FMOV            V11.2S, #-1.0 }
      float32x4_t v24 = 0uLL;
      float32x4_t v25 = v13;
      float32x4_t v121 = v13;
      do
      {
        int v117 = v12;
        uint64_t v26 = 0;
        float32x4_t v116 = v25;
        float32x4_t v27 = v25;
        do
        {
          float32x4_t v28 = vmulq_n_f32(v27, v118);
          uint64_t v29 = *((void *)a2 + 10);
          uint64_t v30 = *((int *)a2 + 22);
          float32x4_t v31 = vsubq_f32(v28, v13);
          if (v11)
          {
            int32x4_t v32 = vaddq_s32(vcvtq_s32_f32(v31), vcltzq_f32(v31));
            float32x2_t v33 = (float32x2_t)vsubq_f32(v31, vcvtq_f32_s32(v32)).u64[0];
            __n128 v34 = (float32x4_t *)(v29 + 16 * (v32.i32[0] + v32.i32[1] * (int)v30));
            float32x4_t v35 = vaddq_f32(*v34, vmulq_n_f32(vsubq_f32(v34[1], *v34), v33.f32[0]));
            int8x16_t v36 = (int8x16_t)vaddq_f32(v35, vmulq_lane_f32(vsubq_f32(vaddq_f32(v34[v30], vmulq_n_f32(vsubq_f32(v34[(int)v30 + 1], v34[v30]), v33.f32[0])), v35), v33, 1));
            float v37 = 0.5;
            float32x4_t v119 = v27;
            if (v16 <= 1.0) {
              goto LABEL_16;
            }
          }
          else
          {
            float32x4_t v38 = vaddq_f32(v31, v18);
            int32x4_t v39 = vcvtq_s32_f32(v38);
            v38.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v38)).u64[0];
            int8x16_t v36 = *(int8x16_t *)(v29 + 16 * (v38.i32[0] + v38.i32[1] * (int)v30));
            float v37 = 0.5;
            float32x4_t v119 = v27;
            if (v16 <= 1.0) {
              goto LABEL_16;
            }
          }
          float32x4_t v120 = v28;
          float32x2_t v40 = (float32x2_t)vextq_s8(v36, v36, 4uLL).u64[0];
          *(float32x2_t *)v8.f32 = vadd_f32(vadd_f32(v40, v40), _D11);
          float32x4_t v41 = vnegq_f32(v8);
          uint64_t v42 = (int)v30 + 1;
          float v43 = 1.0;
          do
          {
            float32x4_t v122 = v41;
            float32x4_t v124 = v8;
            int8x16_t v123 = v36;
            float v57 = expf(-(float)(v43 * v15));
            float32x4_t v58 = vsubq_f32(vaddq_f32(v120, v124), v121);
            if (v11)
            {
              int32x4_t v59 = vaddq_s32(vcvtq_s32_f32(v58), vcltzq_f32(v58));
              float32x4_t v60 = vsubq_f32(v58, vcvtq_f32_s32(v59));
              uint64_t v61 = (float32x4_t *)(v29 + 16 * (v59.i32[0] + v59.i32[1] * (int)v30));
              float32x4_t v62 = *v61;
              float32x4_t v63 = vsubq_f32(v61[1], *v61);
              float32x4_t v64 = v61[v30];
              float32x4_t v65 = vaddq_f32(*v61, vmulq_f32(v63, v60));
              float32x4_t v66 = vsubq_f32(v61[v42], v64);
              float v67 = vaddq_f32(v65, vmulq_lane_f32(vsubq_f32(vaddq_f32(v64, vmulq_f32(v60, v66)), v65), *(float32x2_t *)v60.f32, 1)).f32[0];
              float32x4_t v48 = v122;
              float32x4_t v68 = vsubq_f32(vaddq_f32(v120, v122), v121);
              int32x4_t v69 = vaddq_s32(vcvtq_s32_f32(v68), vcltzq_f32(v68));
              float32x4_t v70 = vsubq_f32(v68, vcvtq_f32_s32(v69));
              _BOOL1 v71 = (float32x4_t *)(v29 + 16 * (v69.i32[0] + v69.i32[1] * (int)v30));
              *(float *)v69.int i32 = vaddq_f32(*v71, vmulq_f32(vsubq_f32(v71[1], *v71), v70)).f32[0];
              float v52 = v67
                  + (float)(*(float *)v69.i32
                          + vmuls_lane_f32((float)(v71[v30].f32[0] + (float)((float)(v71[v42].f32[0] - v71[v30].f32[0]) * v70.f32[0]))- *(float *)v69.i32, *(float32x2_t *)v70.f32, 1));
              float32x4_t v72 = vaddq_f32(v62, vmulq_n_f32(v63, v60.f32[0]));
              int8x16_t v47 = (int8x16_t)vaddq_f32(v72, vmulq_lane_f32(vsubq_f32(vaddq_f32(v64, vmulq_n_f32(v66, v60.f32[0])), v72), *(float32x2_t *)v60.f32, 1));
              float32x4_t v24 = 0uLL;
              int32x4_t v53 = vaddq_s32(vcvtq_s32_f32(v68), vcltzq_f32(v68));
              v68.i64[0] = vsubq_f32(v68, vcvtq_f32_s32(v53)).u64[0];
              long long v54 = (float32x4_t *)(v29 + 16 * (v53.i32[0] + v53.i32[1] * (int)v30));
              float32x4_t v28 = vaddq_f32(*v54, vmulq_n_f32(vsubq_f32(v54[1], *v54), v68.f32[0]));
              int8x16_t v74 = (int8x16_t)vaddq_f32(v28, vmulq_lane_f32(vsubq_f32(vaddq_f32(v54[v30], vmulq_n_f32(vsubq_f32(v54[v42], v54[v30]), v68.f32[0])), v28), *(float32x2_t *)v68.f32, 1));
            }
            else
            {
              v44.i64[0] = 0x3F0000003F000000;
              v44.i64[1] = 0x3F0000003F000000;
              float32x4_t v45 = vaddq_f32(v58, v44);
              int32x4_t v46 = vcvtq_s32_f32(v45);
              v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
              int8x16_t v47 = *(int8x16_t *)(v29 + 16 * (v45.i32[0] + v45.i32[1] * (int)v30));
              float32x4_t v48 = v122;
              float32x4_t v49 = vsubq_f32(vaddq_f32(v120, v122), v121);
              float32x4_t v50 = vaddq_f32(v49, v44);
              float32x4_t v51 = (float32x4_t)vcvtq_s32_f32(v50);
              v50.i64[0] = vaddq_s32((int32x4_t)v51, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v51), v50)).u64[0];
              float v52 = *(float *)v47.i32 + *(float *)(v29 + 16 * (v50.i32[0] + v50.i32[1] * (int)v30));
              float32x4_t v24 = 0uLL;
              v51.i64[0] = 0x3F0000003F000000;
              v51.i64[1] = 0x3F0000003F000000;
              float32x4_t v73 = vaddq_f32(v49, v51);
              float32x4_t v28 = (float32x4_t)vcvtq_s32_f32(v73);
              v73.i64[0] = vaddq_s32((int32x4_t)v28, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v28), v73)).u64[0];
              int8x16_t v74 = *(int8x16_t *)(v29 + 16 * (v73.i32[0] + v73.i32[1] * (int)v30));
            }
            int8x16_t v36 = v123;
            *(float *)v36.int i32 = *(float *)v123.i32 + (float)(v57 * v52);
            float v37 = v37 + v57;
            float32x4_t v55 = (float32x4_t)vextq_s8(v47, v47, 4uLL);
            *(float32x2_t *)v55.f32 = vadd_f32(vadd_f32(*(float32x2_t *)v55.f32, *(float32x2_t *)v55.f32), _D11);
            float32x4_t v8 = vaddq_f32(v124, v55);
            float32x4_t v56 = (float32x4_t)vextq_s8(v74, v74, 4uLL);
            *(float32x2_t *)v56.f32 = vadd_f32(vadd_f32(*(float32x2_t *)v56.f32, *(float32x2_t *)v56.f32), _D11);
            float32x4_t v41 = vaddq_f32(v48, (float32x4_t)vnegq_f32(v56).u64[0]);
            float v43 = v43 + 1.0;
          }
          while (v43 < v16);
LABEL_16:
          float v75 = (float)(*(float *)v36.i32 * 0.5) / v37;
          float v76 = 0.0;
          v18.i64[0] = 0x3F0000003F000000;
          v18.i64[1] = 0x3F0000003F000000;
          if (v75 > 0.0)
          {
            float v77 = fminf(fmaxf(v75 / 0.8, 0.0), 1.0);
            float v76 = (float)(v77 * v77) * (float)(3.0 - (float)(v77 + v77));
          }
          uint64_t v78 = *((void *)a2 + 12);
          uint64_t v79 = *((int *)a2 + 26);
          float32x4_t v13 = v121;
          float32x4_t v80 = vsubq_f32(vmulq_n_f32(v119, 1.0 / v4), v121);
          if (v11)
          {
            int32x4_t v81 = vaddq_s32(vcvtq_s32_f32(v80), vcltzq_f32(v80));
            float32x2_t v82 = (float32x2_t)vsubq_f32(v80, vcvtq_f32_s32(v81)).u64[0];
            unint64_t v83 = (float32x4_t *)(v78 + 16 * (v81.i32[0] + v81.i32[1] * (int)v79));
            float32x4_t v28 = v83[v79];
            float32x4_t v84 = vaddq_f32(*v83, vmulq_n_f32(vsubq_f32(v83[1], *v83), v82.f32[0]));
            float32x4_t v85 = vaddq_f32(v84, vmulq_lane_f32(vsubq_f32(vaddq_f32(v28, vmulq_n_f32(vsubq_f32(v83[(int)v79 + 1], v28), v82.f32[0])), v84), v82, 1));
            if (*((float *)this + 108) != 0.0)
            {
              uint64_t v86 = *((int *)a2 + 34);
              float32x4_t v87 = vsubq_f32(v119, v121);
              int32x4_t v88 = vaddq_s32(vcvtq_s32_f32(v87), vcltzq_f32(v87));
              v87.i64[0] = vsubq_f32(v87, vcvtq_f32_s32(v88)).u64[0];
              unsigned long long v89 = (float32x4_t *)(*((void *)a2 + 16) + 16 * (v88.i32[0] + v88.i32[1] * (int)v86));
              float32x4_t v90 = vaddq_f32(*v89, vmulq_n_f32(vsubq_f32(v89[1], *v89), v87.f32[0]));
              float32x4_t v28 = vsubq_f32(vaddq_f32(v89[v86], vmulq_n_f32(vsubq_f32(v89[(int)v86 + 1], v89[v86]), v87.f32[0])), v90);
              float32x4_t v91 = vaddq_f32(v90, vmulq_lane_f32(v28, *(float32x2_t *)v87.f32, 1));
              goto LABEL_24;
            }
          }
          else
          {
            float32x4_t v92 = vaddq_f32(v80, v18);
            int32x4_t v93 = vcvtq_s32_f32(v92);
            v92.i64[0] = vaddq_s32(v93, vcgtq_f32(vcvtq_f32_s32(v93), v92)).u64[0];
            float32x4_t v85 = *(float32x4_t *)(v78 + 16 * (v92.i32[0] + v92.i32[1] * (int)v79));
            if (*((float *)this + 108) != 0.0)
            {
              float32x4_t v94 = vaddq_f32(vsubq_f32(v119, v121), v18);
              int32x4_t v95 = vcvtq_s32_f32(v94);
              float32x4_t v28 = vcvtq_f32_s32(v95);
              v94.i64[0] = vaddq_s32(v95, vcgtq_f32(v28, v94)).u64[0];
              float32x4_t v91 = *(float32x4_t *)(*((void *)a2 + 16) + 16 * (v94.i32[0] + v94.i32[1] * *((_DWORD *)a2 + 34)));
              goto LABEL_24;
            }
          }
          float32x4_t v91 = v85;
LABEL_24:
          float v96 = 1.0 - v76;
          float32_t v97 = v96 * v96;
          v98.f32[0] = v96 * (float)(v96 * v96);
          v98.f32[1] = v97;
          __asm { FMOV            V3.2S, #1.0 }
          float32x2_t v100 = vsub_f32(_D3, v98);
          *(float32x2_t *)v28.f32 = vmul_f32(v100, *(float32x2_t *)v85.f32);
          v28.i32[2] = vmuls_lane_f32(v100.f32[1], v85, 2);
          float32x4_t v101 = v28;
          v101.i32[3] = v85.i32[3];
          if (*((float *)this + 105) != 0.0)
          {
            v28.i32[3] = 0;
            int8x16_t v102 = (int8x16_t)vmulq_f32(v28, (float32x4_t)xmmword_1B7EBF150);
            *(float32x2_t *)v102.int i8 = vadd_f32(*(float32x2_t *)v102.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v102, v102, 8uLL));
            int32x4_t v103 = vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v102.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v102.i8, 1)), 0);
            v103.i32[3] = v101.i32[3];
            float32x4_t v101 = (float32x4_t)v103;
          }
          __asm { FMOV            V2.4S, #1.0 }
          float32x4_t v105 = vmaxnmq_f32(vminnmq_f32(v101, _Q2), v24);
          if (*((float *)this + 106) != 0.0)
          {
            float v106 = ceilf(vmuls_lane_f32(63.0, v105, 2));
            float v107 = floorf(v106 * 0.125);
            v108.f32[0] = v106 + (float)(v107 * -8.0);
            v108.f32[1] = v107;
            float32x2_t v109 = vmaxnm_f32(vminnm_f32(vmul_f32(vmaxnm_f32(vminnm_f32(vadd_f32(vmul_f32(*(float32x2_t *)v105.f32, (float32x2_t)vdup_n_s32(0x3DFC0000u)), vadd_f32(vmul_f32(v108, (float32x2_t)0x3E0000003E000000), (float32x2_t)vdup_n_s32(0x3A800000u))), _D3), 0), (float32x2_t)0x4400000044000000), (float32x2_t)0x4400000044000000), 0);
            float32x4_t v110 = *(float32x4_t *)(*((void *)a2 + 14)
                                  + 16 * ((int)v109.f32[0] + *((_DWORD *)a2 + 30) * (int)v109.f32[1]));
            v110.i32[3] = 0;
            float32x4_t v111 = vminnmq_f32(v110, (float32x4_t)xmmword_1B7E75890);
            v111.i32[3] = 0;
            float32x4_t v112 = vmaxnmq_f32(v111, v24);
            v112.i32[3] = v105.i32[3];
            float32x4_t v105 = v112;
          }
          if (*((float *)this + 107) == 1.0)
          {
            float32x4_t v113 = vmulq_laneq_f32(v105, v91, 3);
            v113.i32[3] = v105.i32[3];
            float32x4_t v105 = v113;
          }
          v105.i32[3] = v91.i32[3];
          *(float32x4_t *)(v17 + 16 * v26) = v105;
          float32x4_t v27 = vaddq_f32(v119, (float32x4_t)xmmword_1B7E736B0);
          ++v26;
        }
        while (v26 != v10);
        float32x4_t v25 = vaddq_f32(v116, (float32x4_t)xmmword_1B7E736C0);
        v17 += 16 * *((int *)a2 + 6);
        int v12 = v117 + 1;
      }
      while (v117 + 1 != v115);
    }
  }
  return 0;
}

HGComicStrokeAndBlend *HGComicStrokeAndBlend::GetOutput(HGComicStrokeAndBlend *this, HGRenderer *a2, char *a3)
{
  HGNode::SetParameter((HGNode *)this, 0, *((float *)this + 102), 0.0, 0.0, 0.0, a3);
  HGNode::SetParameter((HGNode *)this, 1, *((float *)this + 105), 0.0, 0.0, 0.0, v4);
  HGNode::SetParameter((HGNode *)this, 2, *((float *)this + 106), 0.0, 0.0, 0.0, v5);
  if (*((float *)this + 107) == 1.0) {
    float v7 = 1.0;
  }
  else {
    float v7 = 0.0;
  }
  HGNode::SetParameter((HGNode *)this, 3, v7, 0.0, 0.0, 0.0, v6);
  if (*((float *)this + 108) == 1.0) {
    float v9 = 1.0;
  }
  else {
    float v9 = 0.0;
  }
  HGNode::SetParameter((HGNode *)this, 4, v9, 0.0, 0.0, 0.0, v8);
  if (*((float *)this + 106) == 0.0)
  {
    uint64_t v11 = (*(uint64_t (**)(HGComicStrokeAndBlend *, void))(*(void *)this + 128))(this, 0);
    (*(void (**)(HGComicStrokeAndBlend *, uint64_t, uint64_t))(*(void *)this + 120))(this, 2, v11);
    if (*((float *)this + 108) != 0.0) {
      return this;
    }
  }
  else if (*((float *)this + 108) != 0.0)
  {
    return this;
  }
  uint64_t v12 = (*(uint64_t (**)(HGComicStrokeAndBlend *, void))(*(void *)this + 128))(this, 0);
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, uint64_t))(*(void *)this + 120))(this, 3, v12);
  return this;
}

const char *HGComicStrokeAndBlend::GetProgram(HGComicStrokeAndBlend *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) > 0x60B0F) {
    return aMetal10Len0000_366;
  }
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)) {
    return aGlfs10Len00000;
  }
  return 0;
}

uint64_t HGComicStrokeAndBlend::BindTexture(HGComicStrokeAndBlend *this, HGHandler *a2, uint64_t a3)
{
  if (a3 == 1)
  {
    float v5 = 1.0 / *((float *)this + 104);
    uint64_t v6 = a2;
    int v7 = 1;
  }
  else
  {
    if (a3)
    {
      HGHandler::TexCoord(a2, a3, 0, 0, 0);
      goto LABEL_7;
    }
    float v5 = *((float *)this + 103) * (float)(1.0 / *((float *)this + 104));
    uint64_t v6 = a2;
    int v7 = 0;
  }
  HGHandler::TexCoord(v6, v7, 0, 0, 0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, v5, v5, 1.0);
LABEL_7:
  (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(void *)a2 + 48))(a2, 1, 1);
  return 0;
}

uint64_t HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::Visitor::willVisitChildren()
{
  return 1;
}

BOOL HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::Visitor::willVisitChild(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 128))(a3, a4) != 0;
}

uint64_t HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::Visitor::terminate()
{
  return 0;
}

uint64_t HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::operator()(uint64_t result, HGRenderer *a2, uint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    uint64_t v7 = result;
    uint64_t result = (*(uint64_t (**)(uint64_t *))(*a4 + 72))(a4);
    if ((result & 1) == 0)
    {
      (*(void (**)(uint64_t *, HGRenderer *, uint64_t))(*a4 + 16))(a4, a2, a3);
      int v8 = (*(uint64_t (**)(uint64_t *, HGRenderer *, uint64_t))(*a4 + 24))(a4, a2, a3);
      uint64_t v9 = *a4;
      if (v8)
      {
        (*(void (**)(uint64_t *, HGRenderer *, uint64_t))v9)(a4, a2, a3);
        if ((*(unsigned int (**)(uint64_t *, HGRenderer *, uint64_t))(*a4 + 32))(a4, a2, a3))
        {
          int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 112))(a3);
          if (v10)
          {
            int v11 = v10;
            uint64_t v12 = 0;
            do
            {
              (*(void (**)(uint64_t *, HGRenderer *, uint64_t, uint64_t))(*a4 + 40))(a4, a2, a3, v12);
              if ((*(unsigned int (**)(uint64_t *, HGRenderer *, uint64_t, uint64_t))(*a4 + 48))(a4, a2, a3, v12))
              {
                (*(void (**)(uint64_t *, HGRenderer *, uint64_t, uint64_t))(*a4 + 56))(a4, a2, a3, v12);
                float32x4_t v13 = (HGNode *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 128))(a3, v12);
                if (v13)
                {
                  Output = HGRenderer::GetOutput(a2, v13);
                  if (Output) {
                    HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::operator()(v7, a2, Output, a4);
                  }
                }
              }
              uint64_t v12 = (v12 + 1);
            }
            while (v11 != v12);
          }
        }
        float v16 = *(uint64_t (**)(uint64_t *, HGRenderer *, uint64_t))(*a4 + 8);
        return v16(a4, a2, a3);
      }
      else
      {
        float v15 = *(uint64_t (**)(uint64_t *, HGRenderer *, uint64_t))(v9 + 64);
        return v15(a4, a2, a3);
      }
    }
  }
  return result;
}

uint64_t HGTraversal::IterativeUniqueTraversal<(HGTraversal::NodeInput)0,(HGTraversal::IteratorOrder)0,(HGTraversal::TraversalOrder)0,(HGTraversal::InputOrder)0>::Visitor::terminate()
{
  return 0;
}

void HGTraversal::IterativeUniqueTraversal<(HGTraversal::NodeInput)0,(HGTraversal::IteratorOrder)0,(HGTraversal::TraversalOrder)0,(HGTraversal::InputOrder)0>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  float32x4_t v58 = 0;
  int32x4_t v59 = 0;
  float32x4_t v60 = 0;
  long long v56 = 0u;
  long long v57 = 0u;
  *(_OWORD *)long long __p = 0u;
  int32x4_t v53 = 0;
  uint64_t v54 = 0;
  float v52 = &v53;
  float v5 = (char *)operator new(8uLL);
  *(void *)float v5 = a3;
  uint64_t v6 = v5 + 8;
  float32x4_t v58 = v5;
  float32x4_t v60 = v5 + 8;
  do
  {
    unint64_t v7 = *((void *)v6 - 1);
    int32x4_t v59 = v6 - 8;
    int v8 = v53;
    uint64_t v9 = &v53;
LABEL_5:
    int v10 = v9;
    if (v8)
    {
      do
      {
        uint64_t v9 = (uint64_t **)v8;
        unint64_t v11 = v8[4];
        if (v7 < v11)
        {
          int v8 = *v9;
          goto LABEL_5;
        }
        if (v11 >= v7) {
          goto LABEL_2;
        }
        int v8 = v9[1];
      }
      while (v8);
      int v10 = v9 + 1;
    }
    uint64_t v12 = (uint64_t *)operator new(0x28uLL);
    void v12[4] = v7;
    *uint64_t v12 = 0;
    v12[1] = 0;
    _OWORD v12[2] = (uint64_t)v9;
    *int v10 = v12;
    if (*v52)
    {
      float v52 = (uint64_t **)*v52;
      uint64_t v12 = *v10;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v53, v12);
    float32x4_t v13 = (char *)__p[1];
    ++v54;
    if ((void *)v56 == __p[1]) {
      unint64_t v14 = 0;
    }
    else {
      unint64_t v14 = (((void)v56 - (unint64_t)__p[1]) << 6) - 1;
    }
    uint64_t v15 = *((void *)&v57 + 1);
    unint64_t v16 = *((void *)&v57 + 1) + v57;
    if (v14 == *((void *)&v57 + 1) + (void)v57)
    {
      std::deque<HGNode *>::__add_back_capacity((uint64_t)__p);
      uint64_t v15 = *((void *)&v57 + 1);
      float32x4_t v13 = (char *)__p[1];
      unint64_t v16 = v57 + *((void *)&v57 + 1);
    }
    *(void *)(*(void *)&v13[(v16 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v16 & 0x1FF)) = v7;
    *((void *)&v57 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v15 + 1;
    int v17 = (*(uint64_t (**)(unint64_t))(*(void *)v7 + 112))(v7);
    if (v17)
    {
      uint64_t v18 = 0;
      while (1)
      {
        uint64_t v20 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v7 + 128))(v7, v18);
        uint64_t v21 = v20;
        if (!v20) {
          goto LABEL_21;
        }
        uint64_t v22 = v59;
        if (v59 >= v60) {
          break;
        }
        *(void *)int32x4_t v59 = v20;
        uint64_t v19 = (uint64_t)(v22 + 8);
LABEL_20:
        int32x4_t v59 = (char *)v19;
LABEL_21:
        uint64_t v18 = (v18 + 1);
        if (v18 == v17) {
          goto LABEL_2;
        }
      }
      uint64_t v23 = v58;
      int64_t v24 = v59 - (unsigned char *)v58;
      uint64_t v25 = (v59 - (unsigned char *)v58) >> 3;
      unint64_t v26 = v25 + 1;
      if ((unint64_t)(v25 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v27 = v60 - (unsigned char *)v58;
      if ((v60 - (unsigned char *)v58) >> 2 > v26) {
        unint64_t v26 = v27 >> 2;
      }
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v28 = v26;
      }
      if (v28)
      {
        if (v28 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v29 = operator new(8 * v28);
        uint64_t v30 = (uint64_t *)&v29[8 * v25];
        *uint64_t v30 = v21;
        uint64_t v19 = (uint64_t)(v30 + 1);
        if (v22 == v23)
        {
LABEL_33:
          float32x4_t v58 = v30;
          float32x4_t v60 = &v29[8 * v28];
          if (!v22) {
            goto LABEL_20;
          }
          goto LABEL_43;
        }
      }
      else
      {
        uint64_t v29 = 0;
        uint64_t v30 = (uint64_t *)(8 * v25);
        *(void *)(8 * v25) = v21;
        uint64_t v19 = 8 * v25 + 8;
        if (v22 == v23) {
          goto LABEL_33;
        }
      }
      unint64_t v31 = v22 - 8 - v23;
      if (v31 < 0x58) {
        goto LABEL_75;
      }
      if ((unint64_t)(v22 - &v29[v24]) < 0x20) {
        goto LABEL_75;
      }
      uint64_t v32 = (v31 >> 3) + 1;
      uint64_t v33 = 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
      __n128 v34 = &v22[-v33];
      uint64_t v30 = (uint64_t *)((char *)v30 - v33);
      float32x4_t v35 = &v29[8 * v25 - 16];
      int8x16_t v36 = (long long *)(v22 - 16);
      uint64_t v37 = v32 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v38 = *v36;
        *(v35 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(v36 - 1);
        *float32x4_t v35 = v38;
        v35 -= 2;
        v36 -= 2;
        v37 -= 4;
      }
      while (v37);
      uint64_t v22 = v34;
      if (v32 != (v32 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_75:
        do
        {
          uint64_t v39 = *((void *)v22 - 1);
          v22 -= 8;
          *--uint64_t v30 = v39;
        }
        while (v22 != v23);
      }
      uint64_t v22 = v58;
      float32x4_t v58 = v30;
      float32x4_t v60 = &v29[8 * v28];
      if (!v22) {
        goto LABEL_20;
      }
LABEL_43:
      operator delete(v22);
      goto LABEL_20;
    }
LABEL_2:
    uint64_t v6 = v59;
  }
  while (v58 != v59);
  float32x2_t v40 = (char *)__p[1] + 8 * ((unint64_t)v57 >> 9);
  if ((void *)v56 == __p[1]) {
    float32x4_t v41 = 0;
  }
  else {
    float32x4_t v41 = (void *)(*v40 + 8 * (v57 & 0x1FF));
  }
LABEL_47:
  uint64_t v42 = v41 - 512;
  while (1)
  {
    if ((void *)v56 == __p[1])
    {
      if (!v41) {
        break;
      }
    }
    else if (v41 == (void *)(*(void *)((char *)__p[1] {
                                          + (((*((void *)&v57 + 1) + (void)v57) >> 6) & 0x3FFFFFFFFFFFFF8))
    }
                              + 8 * ((*((void *)&v57 + 1) + v57) & 0x1FF)))
    {
      break;
    }
    if ((*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a4 + 8))(a4, a2, *v41)) {
      break;
    }
    (**(void (***)(uint64_t, uint64_t, void))a4)(a4, a2, *v41++);
    if ((void *)*v40 == ++v42)
    {
      float v43 = (void *)v40[1];
      ++v40;
      float32x4_t v41 = v43;
      goto LABEL_47;
    }
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v52, v53);
  float32x4_t v44 = (void **)__p[1];
  float32x4_t v45 = (void **)v56;
  *((void *)&v57 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  unint64_t v46 = v56 - (unint64_t)__p[1];
  if ((unint64_t)v56 - (unint64_t)__p[1] >= 0x11)
  {
    do
    {
      operator delete(*v44);
      float32x4_t v45 = (void **)v56;
      float32x4_t v44 = (void **)((char *)__p[1] + 8);
      __p[1] = v44;
      unint64_t v46 = v56 - (void)v44;
    }
    while ((void)v56 - (void)v44 > 0x10uLL);
  }
  unint64_t v47 = v46 >> 3;
  if (v47 == 1)
  {
    uint64_t v48 = 256;
LABEL_61:
    *(void *)&long long v57 = v48;
  }
  else if (v47 == 2)
  {
    uint64_t v48 = 512;
    goto LABEL_61;
  }
  if (v44 != v45)
  {
    do
    {
      float32x4_t v49 = *v44++;
      operator delete(v49);
    }
    while (v44 != v45);
    if ((void *)v56 != __p[1]) {
      *(void *)&long long v56 = v56 + (((unint64_t)__p[1] - v56 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (__p[0]) {
    operator delete(__p[0]);
  }
  if (v58) {
    operator delete(v58);
  }
}

void sub_1B76D1150(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  if (__p)
  {
    a23 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t HGTraversal::IterativeUniqueTraversal<(HGTraversal::NodeInput)1,(HGTraversal::IteratorOrder)0,(HGTraversal::TraversalOrder)0,(HGTraversal::InputOrder)0>::Visitor::terminate()
{
  return 0;
}

void HGTraversal::IterativeUniqueTraversal<(HGTraversal::NodeInput)1,(HGTraversal::IteratorOrder)0,(HGTraversal::TraversalOrder)0,(HGTraversal::InputOrder)0>::operator()(uint64_t a1, HGRenderer *a2, uint64_t a3, uint64_t a4)
{
  int32x4_t v59 = 0;
  float32x4_t v60 = 0;
  uint64_t v61 = 0;
  long long v57 = 0u;
  long long v58 = 0u;
  *(_OWORD *)long long __p = 0u;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  int32x4_t v53 = &v54;
  float v5 = (char *)operator new(8uLL);
  *(void *)float v5 = a3;
  uint64_t v6 = v5 + 8;
  int32x4_t v59 = v5;
  uint64_t v61 = v5 + 8;
  do
  {
    unint64_t v7 = *((void *)v6 - 1);
    float32x4_t v60 = v6 - 8;
    int v8 = v54;
    uint64_t v9 = &v54;
LABEL_5:
    int v10 = v9;
    if (v8)
    {
      do
      {
        uint64_t v9 = (uint64_t **)v8;
        unint64_t v11 = v8[4];
        if (v7 < v11)
        {
          int v8 = *v9;
          goto LABEL_5;
        }
        if (v11 >= v7) {
          goto LABEL_2;
        }
        int v8 = v9[1];
      }
      while (v8);
      int v10 = v9 + 1;
    }
    uint64_t v12 = (uint64_t *)operator new(0x28uLL);
    void v12[4] = v7;
    *uint64_t v12 = 0;
    v12[1] = 0;
    _OWORD v12[2] = (uint64_t)v9;
    *int v10 = v12;
    if (*v53)
    {
      int32x4_t v53 = (uint64_t **)*v53;
      uint64_t v12 = *v10;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v54, v12);
    float32x4_t v13 = (char *)__p[1];
    ++v55;
    if ((void *)v57 == __p[1]) {
      unint64_t v14 = 0;
    }
    else {
      unint64_t v14 = (((void)v57 - (unint64_t)__p[1]) << 6) - 1;
    }
    uint64_t v15 = *((void *)&v58 + 1);
    unint64_t v16 = *((void *)&v58 + 1) + v58;
    if (v14 == *((void *)&v58 + 1) + (void)v58)
    {
      std::deque<HGNode *>::__add_back_capacity((uint64_t)__p);
      uint64_t v15 = *((void *)&v58 + 1);
      float32x4_t v13 = (char *)__p[1];
      unint64_t v16 = v58 + *((void *)&v58 + 1);
    }
    *(void *)(*(void *)&v13[(v16 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v16 & 0x1FF)) = v7;
    *((void *)&v58 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v15 + 1;
    int v17 = (*(uint64_t (**)(unint64_t))(*(void *)v7 + 112))(v7);
    if (v17)
    {
      uint64_t v18 = 0;
      while (1)
      {
        uint64_t v20 = (HGNode *)(*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v7 + 128))(v7, v18);
        if (!v20) {
          goto LABEL_21;
        }
        Output = HGRenderer::GetOutput(a2, v20);
        uint64_t v22 = Output;
        if (!Output) {
          goto LABEL_21;
        }
        uint64_t v23 = v60;
        if (v60 >= v61) {
          break;
        }
        *(void *)float32x4_t v60 = Output;
        uint64_t v19 = (uint64_t)(v23 + 8);
LABEL_20:
        float32x4_t v60 = (char *)v19;
LABEL_21:
        uint64_t v18 = (v18 + 1);
        if (v18 == v17) {
          goto LABEL_2;
        }
      }
      int64_t v24 = v59;
      int64_t v25 = v60 - (unsigned char *)v59;
      uint64_t v26 = (v60 - (unsigned char *)v59) >> 3;
      unint64_t v27 = v26 + 1;
      if ((unint64_t)(v26 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v28 = v61 - (unsigned char *)v59;
      if ((v61 - (unsigned char *)v59) >> 2 > v27) {
        unint64_t v27 = v28 >> 2;
      }
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v29 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v29 = v27;
      }
      if (v29)
      {
        if (v29 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v30 = operator new(8 * v29);
        unint64_t v31 = (HGNode **)&v30[8 * v26];
        *unint64_t v31 = v22;
        uint64_t v19 = (uint64_t)(v31 + 1);
        if (v23 == v24)
        {
LABEL_34:
          int32x4_t v59 = v31;
          uint64_t v61 = &v30[8 * v29];
          if (!v23) {
            goto LABEL_20;
          }
          goto LABEL_44;
        }
      }
      else
      {
        uint64_t v30 = 0;
        unint64_t v31 = (HGNode **)(8 * v26);
        *(void *)(8 * v26) = v22;
        uint64_t v19 = 8 * v26 + 8;
        if (v23 == v24) {
          goto LABEL_34;
        }
      }
      unint64_t v32 = v23 - 8 - v24;
      if (v32 < 0x58) {
        goto LABEL_76;
      }
      if ((unint64_t)(v23 - &v30[v25]) < 0x20) {
        goto LABEL_76;
      }
      uint64_t v33 = (v32 >> 3) + 1;
      uint64_t v34 = 8 * (v33 & 0x3FFFFFFFFFFFFFFCLL);
      float32x4_t v35 = &v23[-v34];
      unint64_t v31 = (HGNode **)((char *)v31 - v34);
      int8x16_t v36 = &v30[8 * v26 - 16];
      uint64_t v37 = (long long *)(v23 - 16);
      uint64_t v38 = v33 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v39 = *v37;
        *(v36 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(v37 - 1);
        *int8x16_t v36 = v39;
        v36 -= 2;
        v37 -= 2;
        v38 -= 4;
      }
      while (v38);
      uint64_t v23 = v35;
      if (v33 != (v33 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_76:
        do
        {
          float32x2_t v40 = (HGNode *)*((void *)v23 - 1);
          v23 -= 8;
          *--unint64_t v31 = v40;
        }
        while (v23 != v24);
      }
      uint64_t v23 = v59;
      int32x4_t v59 = v31;
      uint64_t v61 = &v30[8 * v29];
      if (!v23) {
        goto LABEL_20;
      }
LABEL_44:
      operator delete(v23);
      goto LABEL_20;
    }
LABEL_2:
    uint64_t v6 = v60;
  }
  while (v59 != v60);
  float32x4_t v41 = (char *)__p[1] + 8 * ((unint64_t)v58 >> 9);
  if ((void *)v57 == __p[1]) {
    uint64_t v42 = 0;
  }
  else {
    uint64_t v42 = (void *)(*v41 + 8 * (v58 & 0x1FF));
  }
LABEL_48:
  float v43 = v42 - 512;
  while (1)
  {
    if ((void *)v57 == __p[1])
    {
      if (!v42) {
        break;
      }
    }
    else if (v42 == (void *)(*(void *)((char *)__p[1] {
                                          + (((*((void *)&v58 + 1) + (void)v58) >> 6) & 0x3FFFFFFFFFFFFF8))
    }
                              + 8 * ((*((void *)&v58 + 1) + v58) & 0x1FF)))
    {
      break;
    }
    if ((*(uint64_t (**)(uint64_t, HGRenderer *, void))(*(void *)a4 + 8))(a4, a2, *v42)) {
      break;
    }
    (**(void (***)(uint64_t, HGRenderer *, void))a4)(a4, a2, *v42++);
    if ((void *)*v41 == ++v43)
    {
      float32x4_t v44 = (void *)v41[1];
      ++v41;
      uint64_t v42 = v44;
      goto LABEL_48;
    }
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v53, v54);
  float32x4_t v45 = (void **)__p[1];
  unint64_t v46 = (void **)v57;
  *((void *)&v58 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  unint64_t v47 = v57 - (unint64_t)__p[1];
  if ((unint64_t)v57 - (unint64_t)__p[1] >= 0x11)
  {
    do
    {
      operator delete(*v45);
      unint64_t v46 = (void **)v57;
      float32x4_t v45 = (void **)((char *)__p[1] + 8);
      __p[1] = v45;
      unint64_t v47 = v57 - (void)v45;
    }
    while ((void)v57 - (void)v45 > 0x10uLL);
  }
  unint64_t v48 = v47 >> 3;
  if (v48 == 1)
  {
    uint64_t v49 = 256;
LABEL_62:
    *(void *)&long long v58 = v49;
  }
  else if (v48 == 2)
  {
    uint64_t v49 = 512;
    goto LABEL_62;
  }
  if (v45 != v46)
  {
    do
    {
      float32x4_t v50 = *v45++;
      operator delete(v50);
    }
    while (v45 != v46);
    if ((void *)v57 != __p[1]) {
      *(void *)&long long v57 = v57 + (((unint64_t)__p[1] - v57 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (__p[0]) {
    operator delete(__p[0]);
  }
  if (v59) {
    operator delete(v59);
  }
}

void sub_1B76D16A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  if (__p)
  {
    a23 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::deque<HGNode *>::~deque[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  unsigned int v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unsigned int v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 512;
LABEL_7:
    *(void *)(a1 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      unint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::deque<HGNode *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    *(void *)(a1 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    unint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)unint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        uint64_t v34 = (char *)operator new(8 * v31);
        float32x4_t v35 = &v34[8 * v32];
        int8x16_t v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        unint64_t v5 = v35;
        if (!v37)
        {
          unint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            int8x16_t v74 = &v34[8 * v32];
            float32x2_t v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              float32x2_t v40 = &v35[v76];
              v7 += v76;
              float v77 = (long long *)(v6 + 3);
              uint64_t v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(v77 - 1);
                *uint64_t v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            float32x2_t v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)float32x2_t v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    uint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      unint64_t v7 = *(char **)(a1 + 8);
    }
    unint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      float32x4_t v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    float32x4_t v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    float32x4_t v41 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    unint64_t v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        uint64_t v34 = (char *)operator new(8 * v42);
        float32x4_t v35 = &v34[8 * v43];
        int8x16_t v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        unint64_t v5 = v35;
        if (!v37)
        {
          unint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            float32x2_t v82 = &v34[8 * v43];
            unint64_t v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v47 = &v35[v84];
              v7 += v84;
              float32x4_t v85 = (long long *)(v41 + 3);
              uint64_t v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(v85 - 1);
                *uint64_t v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            unint64_t v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          unint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  int64_t v25 = (char *)operator new(8 * v24);
  uint64_t v26 = operator new(0x1000uLL);
  unint64_t v27 = &v25[8 * v21];
  uint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    float32x4_t v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v49 = (char *)operator new(8 * v48);
      unint64_t v27 = &v49[8 * (v48 >> 2)];
      uint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      int64_t v25 = v49;
      *(void *)unint64_t v27 = v90;
      unint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)unint64_t v27 = v26;
      unint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          float32x4_t v60 = (char *)operator new(8 * v59);
          int64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          int32x4_t v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          unint64_t v29 = v53;
          if (!v37)
          {
            unint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            float32x4_t v64 = &v60[8 * v61];
            float32x4_t v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            float32x4_t v64 = &v60[8 * v61];
            float32x4_t v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            float32x4_t v64 = &v53[v68];
            float32x4_t v65 = &v27[v68];
            int32x4_t v69 = (long long *)(v27 + 16);
            float32x4_t v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(v69 - 1);
              *(_OWORD *)float32x4_t v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)float32x4_t v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          uint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          long long v57 = &v29[8 * (v56 >> 1)];
          int32x4_t v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          unint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          int64_t v25 = v27;
        }
      }
      else
      {
        int32x4_t v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v54;
      float32x4_t v51 = v53 - 8;
      unint64_t v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)unint64_t v27 = v26;
  unint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  float32x4_t v51 = v27;
LABEL_46:
  float v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B76D1D28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B76D1D44(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D1D58(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D1D70(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__split_buffer<HGNode **>::push_back(char **a1, void *a2)
{
  unint64_t v4 = a1[2];
  if (v4 != a1[3]) {
    goto LABEL_22;
  }
  unint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  if (v6 > *a1)
  {
    uint64_t v7 = (v6 - *a1) >> 3;
    if (v7 >= -1) {
      uint64_t v8 = v7 + 1;
    }
    else {
      uint64_t v8 = v7 + 2;
    }
    uint64_t v9 = v8 >> 1;
    uint64_t v10 = -v9;
    uint64_t v11 = &v6[-8 * v9];
    int64_t v12 = v4 - v6;
    if (v4 != v6)
    {
      memmove(&v6[-8 * v9], a1[1], v4 - v6);
      unint64_t v4 = a1[1];
    }
    uint64_t v13 = &v4[8 * v10];
    unint64_t v4 = &v11[v12];
    a1[1] = v13;
    a1[2] = &v11[v12];
    goto LABEL_22;
  }
  unint64_t v14 = (v4 - v5) >> 2;
  if (v4 == v5) {
    unint64_t v14 = 1;
  }
  if (v14 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  unint64_t v15 = v14 >> 2;
  uint64_t v16 = 8 * v14;
  uint64_t v17 = (char *)operator new(8 * v14);
  uint64_t v18 = &v17[8 * v15];
  int64_t v20 = v4 - v6;
  BOOL v19 = v4 == v6;
  unint64_t v4 = v18;
  if (!v19)
  {
    unint64_t v4 = &v18[v20 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v21 = v20 - 8;
    if ((unint64_t)(v20 - 8) < 0x38)
    {
      uint64_t v22 = &v17[8 * v15];
      do
      {
LABEL_19:
        uint64_t v31 = *(void *)v6;
        v6 += 8;
        *(void *)uint64_t v22 = v31;
        v22 += 8;
      }
      while (v22 != v4);
      goto LABEL_20;
    }
    uint64_t v23 = &v17[8 * v15];
    uint64_t v22 = v23;
    if ((unint64_t)(v23 - v6) < 0x20) {
      goto LABEL_19;
    }
    uint64_t v24 = (v21 >> 3) + 1;
    uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v22 = &v18[v25];
    uint64_t v26 = &v6[v25];
    unint64_t v27 = (long long *)(v6 + 16);
    uint64_t v28 = v23 + 16;
    uint64_t v29 = v24 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v30 = *v27;
      *(v28 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(v27 - 1);
      *uint64_t v28 = v30;
      v27 += 2;
      v28 += 2;
      v29 -= 4;
    }
    while (v29);
    uint64_t v6 = v26;
    if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_19;
    }
  }
LABEL_20:
  *a1 = v17;
  a1[1] = v18;
  a1[2] = v4;
  a1[3] = &v17[v16];
  if (v5)
  {
    operator delete(v5);
    unint64_t v4 = a1[2];
  }
LABEL_22:
  *(void *)unint64_t v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<HGNode **>::push_front(void **a1, void *a2)
{
  unint64_t v4 = (char *)a1[1];
  if (v4 == *a1)
  {
    uint64_t v7 = a1[2];
    uint64_t v6 = a1[3];
    if (v7 >= v6)
    {
      uint64_t v13 = v6 - v4;
      BOOL v12 = v13 == 0;
      unint64_t v14 = v13 >> 2;
      if (v12) {
        unint64_t v14 = 1;
      }
      if (v14 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v15 = (v14 + 3) >> 2;
      uint64_t v16 = 8 * v14;
      uint64_t v17 = (char *)operator new(8 * v14);
      unint64_t v5 = &v17[8 * v15];
      uint64_t v18 = v5;
      uint64_t v19 = v7 - v4;
      if (v7 != v4)
      {
        uint64_t v18 = &v5[v19 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v20 = v19 - 8;
        unint64_t v21 = &v17[8 * v15];
        uint64_t v22 = v4;
        if (v20 < 0x38) {
          goto LABEL_27;
        }
        uint64_t v23 = &v17[8 * v15];
        unint64_t v21 = v23;
        uint64_t v22 = v4;
        if ((unint64_t)(v23 - v4) < 0x20) {
          goto LABEL_27;
        }
        uint64_t v24 = (v20 >> 3) + 1;
        uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v21 = &v5[v25];
        uint64_t v22 = &v4[v25];
        uint64_t v26 = (long long *)(v4 + 16);
        unint64_t v27 = v23 + 16;
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v26;
          *(v27 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(v26 - 1);
          *unint64_t v27 = v29;
          v26 += 2;
          v27 += 2;
          v28 -= 4;
        }
        while (v28);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_27:
          do
          {
            uint64_t v30 = *(void *)v22;
            v22 += 8;
            *(void *)unint64_t v21 = v30;
            v21 += 8;
          }
          while (v21 != v18);
        }
      }
      *a1 = v17;
      a1[1] = v5;
      a1[2] = v18;
      a1[3] = &v17[v16];
      if (v4)
      {
        operator delete(v4);
        unint64_t v5 = (char *)a1[1];
      }
    }
    else
    {
      uint64_t v8 = (v6 - v7) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v11 = &v7[8 * (v9 >> 1)];
      unint64_t v5 = &v11[-(v7 - v4)];
      if (v7 != v4)
      {
        memmove(&v11[-(v7 - v4)], v4, v7 - v4);
        unint64_t v4 = (char *)a1[2];
      }
      a1[1] = v5;
      a1[2] = &v4[8 * v10];
    }
  }
  else
  {
    unint64_t v5 = (char *)a1[1];
  }
  *((void *)v5 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *a2;
  a1[1] = (char *)a1[1] - 8;
}

void HFGrabCutInterface::HFGrabCutInterface(HFGrabCutInterface *this, const __CFUUID *a2)
{
  this->var0 = (void **)&unk_1F10C4B00;
  operator new();
}

void sub_1B76D2118(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40C5845091);
  _Unwind_Resume(a1);
}

void HFGrabCutInterface::~HFGrabCutInterface(HFGrabCutInterface *this)
{
  this->var0 = (void **)&unk_1F10C4B00;
  var1 = this->var1;
  if (var1) {
    (*(void (**)(HFGrabCut *))(*(void *)var1 + 8))(var1);
  }
}

{
  HFGrabCut *var1;
  uint64_t vars8;

  this->var0 = (void **)&unk_1F10C4B00;
  var1 = this->var1;
  if (var1) {
    (*(void (**)(HFGrabCut *))(*(void *)var1 + 8))(var1);
  }

  JUMPOUT(0x1BA9BFBA0);
}

HFGrabCut *HFGrabCutInterface::InitDataModels(HFGrabCutInterface *this, HGBitmap *a2, HGBitmap *a3, unint64_t a4)
{
  return HFGrabCut::InitDataModels(this->var1, a2, a3, a4);
}

void *HFGrabCutInterface::GenerateMask(HFGrabCutInterface *this, HGBitmap *a2, HGBitmap *a3, HGBitmap *a4, double a5, double a6, __n128 a7)
{
  return HFGrabCut::GenerateMask(this->var1, a2, a3, a4, a5, a6, a7);
}

HFGrabCut *HFGrabCutInterface::Reset(HFGrabCutInterface *this)
{
  return HFGrabCut::Reset(this->var1);
}

void HGGradient::HGGradient(HGGradient *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v2 = &unk_1F10C4B30;
  v2[51] = 0;
  BOOL v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  unint64_t v4 = (HGNode *)*((void *)this + 51);
  if (v4 == v3)
  {
    if (v3) {
      (*(void (**)(HGNode *))(*(void *)v3 + 24))(v3);
    }
  }
  else
  {
    if (v4) {
      (*(void (**)(HGNode *))(*(void *)v4 + 24))(v4);
    }
    *((void *)this + 5PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v3;
  }
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_DWORD *)this + 117) = 1065353216;
  *((_DWORD *)this + 12PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 1065353216;
  *((_DWORD *)this + 128) = 1065353216;
}

void sub_1B76D2338(_Unwind_Exception *a1)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v4 = *(void *)(v1 + 408);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGGradient::~HGGradient(HGNode *this)
{
  *(void *)this = &unk_1F10C4B30;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10C4B30;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGGradient::SetGradientMode(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 416) = a2;
  Gradientuint64_t Node = HGGradient::_createGradientNode(a1, a2);
  uint64_t result = *(void *)(a1 + 408);
  if ((HGGradientRadial *)result == GradientNode)
  {
    if (GradientNode) {
      return (*(uint64_t (**)(HGGradientRadial *))(*(void *)GradientNode + 24))(GradientNode);
    }
  }
  else
  {
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    }
    *(void *)(a1 + 408) = GradientNode;
  }
  return result;
}

void sub_1B76D256C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

HGGradientRadial *HGGradient::_createGradientNode(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    uint64_t v2 = (HGGradientRadial *)HGObject::operator new(0x1B0uLL);
    HGGradientRadial::HGGradientRadial(v2);
  }
  else if (a2)
  {
    uint64_t v2 = (HGGradientRadial *)HGObject::operator new(0x1A0uLL);
    HGNode::HGNode((HGNode *)v2);
  }
  else
  {
    uint64_t v2 = (HGGradientRadial *)HGObject::operator new(0x1B0uLL);
    HGGradientLinear::HGGradientLinear(v2);
  }
  return v2;
}

void sub_1B76D260C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D2620(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D2634(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGGradient::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(void, void, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, *((float *)this + 105), *((float *)this + 106), *((float *)this + 107), *((float *)this + 108));
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, *((float *)this + 109), *((float *)this + 110), *((float *)this + 111), *((float *)this + 112));
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 2, *((float *)this + 113), *((float *)this + 114), *((float *)this + 115), *((float *)this + 116));
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 3, *((float *)this + 117), *((float *)this + 118), *((float *)this + 119), *((float *)this + 120));
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 4, *((float *)this + 121), *((float *)this + 122), *((float *)this + 123), *((float *)this + 124));
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 5, *((float *)this + 125), *((float *)this + 126), *((float *)this + 127), *((float *)this + 128));
  (*(void (**)(void, void, HGNode *))(**((void **)this + 51) + 120))(*((void *)this + 51), 0, Input);
  return *((void *)this + 51);
}

uint64_t HGGradient::SetParameter(HGNode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = (char *)this + 420;
  uint64_t v8 = (float *)((char *)this + 16 * a2 + 420);
  if (*v8 == a3)
  {
    uint64_t v9 = &v7[16 * a2];
    if (*((float *)v9 + 1) == a4 && *((float *)v9 + 2) == a5 && *(float *)&v7[16 * a2 + 12] == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)&v7[16 * a2];
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits(this, a2, a7);
  return 1;
}

uint64_t HGCVPixelBufferPoolImpl::HGCVPixelBufferPoolImpl(uint64_t a1, void *a2)
{
  uint64_t v4 = (void *)HGPool::BasePool::BasePool(a1);
  *uint64_t v4 = &unk_1F10C4EE8;
  void v4[2] = *a2;
  uint64_t v5 = a2[1];
  v4[3] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 56) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 11PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 15PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 160) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 23PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0uLL;
  *(_OWORD *)(a1 + 216) = 0uLL;
  *(_OWORD *)(a1 + 200) = 0uLL;
  *(_OWORD *)(a1 + 184) = 0uLL;
  *(_OWORD *)(a1 + 168) = 0uLL;
  *(_OWORD *)(a1 + 264) = 0uLL;
  *(_OWORD *)(a1 + 280) = 0uLL;
  *(_OWORD *)(a1 + 296) = 0uLL;
  *(unsigned char *)(a1 + 343) = 14;
  *(void *)(a1 + 31PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  strcpy((char *)(a1 + 320), "(unnamed) pool");
  *(unsigned char *)(a1 + 367) = 6;
  strcpy((char *)(a1 + 344), "hgpool");
  *(_DWORD *)(a1 + 368) = 0;
  *(_WORD *)(a1 + 37PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 257;
  *(unsigned char *)(a1 + 374) = 1;
  *(_WORD *)(a1 + 8) = 17;
  uint64_t v8 = *(unsigned __int16 *)(a1 + 10) | 0x110000;
  *(void *)(a1 + 144) = v8;
  *(void *)(a1 + 248) = v8;
  *(void *)(a1 + 256) = 850045863;
  *(void *)a1 = &unk_1F10C4D98;
  uint64_t v9 = operator new(0x38uLL);
  v9[1] = 0;
  *uint64_t v9 = &unk_1F10C4F58;
  v9[2] = 0;
  double v9[3] = &unk_1F10C4FA8;
  *((_OWORD *)v9 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = xmmword_1B7EBF2B0;
  v9[6] = 5000000000;
  unint64_t v14 = (char *)(v9 + 3);
  unint64_t v15 = (std::__shared_weak_count *)v9;
  __str.__r_.__value_.__r.__words[0] = (std::string::size_type)(v9 + 3);
  __str.__r_.__value_.__l.__size_ = (std::string::size_type)v9;
  atomic_fetch_add_explicit(v9 + 1, 1uLL, memory_order_relaxed);
  std::mutex::lock((std::mutex *)(a1 + 256));
  atomic_fetch_add_explicit(v9 + 1, 1uLL, memory_order_relaxed);
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 176);
  *(void *)(a1 + 168) = v9 + 3;
  *(void *)(a1 + 176) = v9;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::mutex::unlock((std::mutex *)(a1 + 256));
  if (__str.__r_.__value_.__l.__size_
    && !atomic_fetch_add((atomic_ullong *volatile)(__str.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(std::string::size_type))(*(void *)__str.__r_.__value_.__l.__size_ + 16))(__str.__r_.__value_.__l.__size_);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)__str.__r_.__value_.__l.__size_);
  }
  *((unsigned char *)&__str.__r_.__value_.__s + 23) = 4;
  strcpy((char *)&__str, "hgcv");
  std::string::operator=((std::string *)(a1 + 344), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  uint64_t v11 = v15;
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return a1;
}

void sub_1B76D2BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~Pool(v16, v18);
  _Unwind_Resume(a1);
}

void sub_1B76D2C28(_Unwind_Exception *a1, HGPool::BasePool *a2)
{
  HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~Pool(v2, a2);
  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(std::__shared_weak_count **)(result + 8);
  if (v2)
  {
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
      return v1;
    }
  }
  return result;
}

uint64_t HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  *(void *)a1 = &unk_1F10C4EE8;
  HGPool::unregisterPool((HGPool *)a1, a2);
  if (*(char *)(a1 + 367) < 0)
  {
    operator delete(*(void **)(a1 + 344));
    if ((*(char *)(a1 + 343) & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_16:
    operator delete(*(void **)(a1 + 320));
    goto LABEL_3;
  }
  if (*(char *)(a1 + 343) < 0) {
    goto LABEL_16;
  }
LABEL_3:
  std::mutex::~mutex((std::mutex *)(a1 + 256));
  HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::~List((int64x2_t *)(a1 + 152));
  std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::~deque[abi:ne180100](a1 + 80);
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v6 || atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
  std::__shared_weak_count::__release_weak(v6);
  return a1;
}

void HGCVPixelBufferPool::HGCVPixelBufferPool(HGCVPixelBufferPool *this)
{
  HGObject::HGObject((HGObject *)this);
  void *v1 = &unk_1F10C4E08;
  uint64_t v2 = operator new(0x20uLL);
  v2[1] = 0;
  void *v2 = &unk_1F10C5008;
  v2[2] = 0;
  v2[3] = &unk_1F10C5058;
  BOOL v3 = v2 + 3;
  uint64_t v4 = v2;
  operator new();
}

void sub_1B76D2FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  MEMORY[0x1BA9BFBA0](v12, 0x10B3C40C3EE8A59);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  HGObject::~HGObject(v11);
  _Unwind_Resume(a1);
}

void sub_1B76D3024(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D3038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  HGObject::~HGObject(v3);
  _Unwind_Resume(a1);
}

void HGCVPixelBufferPool::~HGCVPixelBufferPool(HGCVPixelBufferPool *this, HGPool::BasePool *a2)
{
  *(void *)this = &unk_1F10C4E08;
  HGPool::unregisterPool(*((HGPool **)this + 2), a2);
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }

  HGObject::~HGObject((HGObject *)this);
}

{
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10C4E08;
  HGPool::unregisterPool(*((HGPool **)this + 2), a2);
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  HGObject::~HGObject((HGObject *)this);

  HGObject::operator delete(v4);
}

std::string *HGCVPixelBufferPool::setLabel(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(*(void *)(a1 + 16) + 320), a2);
}

void HGCVPixelBufferPool::setServicingPolicy(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  std::mutex::lock((std::mutex *)(v3 + 256));
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v3 + 176);
  *(void *)(v3 + 168) = v5;
  *(void *)(v3 + 176) = v4;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    uint64_t v7 = (std::mutex *)(v3 + 256);
  }
  else
  {
    uint64_t v7 = (std::mutex *)(v3 + 256);
  }
  std::mutex::unlock(v7);
}

void HGCVPixelBufferPool::setRecyclingPolicy(HGCVPixelBufferPool *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a3 << 20;
  uint64_t v7 = 1000000 * a4;
  uint64_t v8 = (std::__shared_weak_count *)operator new(0x38uLL);
  v8->__shared_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C4F58;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C4FA8;
  v8[1].__shared_owners_ = a2;
  v8[1].__shared_weak_owners_ = v6;
  v8[2].__vftable = (std::__shared_weak_count_vtbl *)v7;
  uint64_t v9 = *((void *)this + 2);
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::lock((std::mutex *)(v9 + 256));
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v10 = *(std::__shared_weak_count **)(v9 + 176);
  *(void *)(v9 + 168) = v8 + 1;
  *(void *)(v9 + 176) = v8;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::mutex::unlock((std::mutex *)(v9 + 256));
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    uint64_t v11 = v8;
  }
  else
  {
    uint64_t v11 = v8;
    if (!v8) {
      return;
    }
  }
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_1B76D342C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::service(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v8 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (*(void *)(a1 + 224))
  {
    uint64_t v9 = 0;
    do
    {
      unint64_t v10 = atomic_load((unint64_t *)(a1 + 232));
      if (v10 <= a2)
      {
        unint64_t v11 = atomic_load((unint64_t *)(a1 + 240));
        if (v11 <= a4)
        {
          unint64_t v12 = *(void *)(a1 + 216);
          uint64_t v13 = *(void *)(*(void *)(a1 + 192) + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8));
          if (std::chrono::steady_clock::now().__d_.__rep_ - *(void *)(v13 + ((v12 & 0x3F) << 6) + 40) <= a3) {
            break;
          }
        }
      }
      HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152));
      ++v9;
    }
    while (*(void *)(a1 + 224));
    if (v9)
    {
      (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
      (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
      kdebug_trace();
    }
  }

  std::mutex::unlock(v8);
}

void sub_1B76D35E4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D35F8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGCVPixelBufferPool::clear(HGCVPixelBufferPool *this)
{
}

void HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (*(void *)(a1 + 224))
  {
    uint64_t v3 = 0;
    do
    {
      HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152));
      --v3;
    }
    while (*(void *)(a1 + 224));
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
      (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
      kdebug_trace();
    }
  }

  std::mutex::unlock(v2);
}

void sub_1B76D372C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D3740(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

CVPixelBufferRef HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::newObject(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) != 0 || (uint64_t v4 = *(void *)(a1 + 32)) == 0)
  {
    *(_OWORD *)uint64_t v28 = *(_OWORD *)a2;
    *(void *)&v28[16] = *(void *)(a2 + 16);
  }
  else
  {
    (*(void (**)(unsigned char *__return_ptr))(*(void *)v4 + 16))(v28);
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), (long long *)v28, (uint64_t)pixelBuffer);
  std::mutex::unlock((std::mutex *)(a1 + 256));
  if (pixelBuffer[0])
  {
    BYTE8(v27) = 1;
    *(std::chrono::steady_clock::time_point *)&v26[24] = std::chrono::steady_clock::now();
    *(void *)&long long v27 = v27 + 1;
    HGPool::EntryEventHandler<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::reused((uint64_t)pixelBuffer);
    kdebug_trace();
    int v7 = *(_DWORD *)(a1 + 368);
    if (v7 == 1)
    {
      kdebug_trace();
      CVPixelBufferRef v12 = pixelBuffer[0];
      uint64_t v13 = (__CVBuffer *)(*(uint64_t (**)(void, unsigned char *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), v28);
      HGPool::EntryEventHandler<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::deleted((uint64_t)pixelBuffer);
      pixelBuffer[0] = v13;
      *(_OWORD *)uint64_t v26 = *(_OWORD *)v28;
      *(void *)&v26[13] = *(void *)&v28[13];
      HGPool::EntryEventHandler<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::allocated((uint64_t)pixelBuffer);
      kdebug_trace();
      (*(void (**)(void, CVPixelBufferRef))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16), v12);
      kdebug_trace();
    }
    else if (v7 == 2)
    {
      kdebug_trace();
      uint64_t v9 = pixelBuffer[0];
      CVPixelBufferRef v8 = pixelBuffer[1];
      unint64_t v10 = (__CVBuffer *)(*(uint64_t (**)(void, unsigned char *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), v28);
      HGPool::EntryEventHandler<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::deleted((uint64_t)pixelBuffer);
      pixelBuffer[0] = v10;
      pixelBuffer[1] = v9;
      *(_OWORD *)uint64_t v26 = *(_OWORD *)v28;
      *(void *)&v26[13] = *(void *)&v28[13];
      HGPool::EntryEventHandler<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::allocated((uint64_t)pixelBuffer);
      kdebug_trace();
      (*(void (**)(void, CVPixelBufferRef))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16), v8);
      kdebug_trace();
    }
  }
  else
  {
    kdebug_trace();
    unint64_t v11 = (__CVBuffer *)(*(uint64_t (**)(void, unsigned char *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), v28);
    *(_OWORD *)uint64_t v26 = *(_OWORD *)v28;
    *(void *)&long long v27 = 0;
    *(_OWORD *)&v26[16] = *(unint64_t *)&v28[16];
    pixelBuffer[0] = v11;
    pixelBuffer[1] = 0;
    BYTE8(v27) = 1;
    *(std::chrono::steady_clock::time_point *)&v26[24] = std::chrono::steady_clock::now();
    *(void *)&long long v27 = v27 + 1;
    HGPool::EntryEventHandler<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::allocated((uint64_t)pixelBuffer);
    kdebug_trace();
    kdebug_trace();
  }
  if (pixelBuffer[0])
  {
    std::mutex::lock((std::mutex *)(a1 + 256));
    uint64_t v14 = *(void *)(a1 + 96);
    uint64_t v15 = *(void *)(a1 + 88);
    uint64_t v16 = 8 * (v14 - v15) - 1;
    if (v14 == v15) {
      uint64_t v16 = 0;
    }
    unint64_t v17 = *(void *)(a1 + 120) + *(void *)(a1 + 112);
    if (v16 == v17)
    {
      std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::__add_back_capacity(a1 + 80);
      uint64_t v15 = *(void *)(a1 + 88);
      unint64_t v17 = *(void *)(a1 + 120) + *(void *)(a1 + 112);
    }
    uint64_t v18 = (_OWORD *)(*(void *)(v15 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((v17 & 0x3F) << 6));
    long long v19 = *(_OWORD *)pixelBuffer;
    long long v20 = *(_OWORD *)v26;
    long long v21 = v27;
    v18[2] = *(_OWORD *)&v26[16];
    _OWORD v18[3] = v21;
    *uint64_t v18 = v19;
    v18[1] = v20;
    ++*(void *)(a1 + 120);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 128), 1uLL);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 136), CVPixelBufferGetDataSize(pixelBuffer[0]));
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    kdebug_trace();
    std::mutex::unlock((std::mutex *)(a1 + 256));
  }
  else
  {
    unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
    if (v22)
    {
      uint64_t v23 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0) {
        uint64_t v23 = *(HGLogger **)v23;
      }
      HGLogger::log(v23, (const char *)1, (HGLogger *)"HGPool::newObject() - Failed to recycle or allocate object! Oops.", v5, v6);
    }
  }
  return pixelBuffer[0];
}

void sub_1B76D3CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B76D3D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B76D3D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B76D3D28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B76D3D3C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::releaseObject(uint64_t a1, uint64_t a2)
{
  uint64_t v29 = a2;
  uint64_t v3 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,true>::retrieveObject((int64x2_t *)(a1 + 48), &v29, (uint64_t)pixelBuffer);
  if (pixelBuffer[0])
  {
    unsigned char v28[24] = 0;
    *(std::chrono::steady_clock::time_point *)&v28[8] = std::chrono::steady_clock::now();
    HGPool::EntryEventHandler<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::recycled((uint64_t)pixelBuffer);
    kdebug_trace();
    uint64_t v4 = *(void *)(a1 + 200);
    uint64_t v5 = *(void *)(a1 + 192);
    uint64_t v6 = 8 * (v4 - v5) - 1;
    if (v4 == v5) {
      uint64_t v6 = 0;
    }
    unint64_t v7 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
    if (v6 == v7)
    {
      std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::__add_back_capacity(a1 + 184);
      uint64_t v5 = *(void *)(a1 + 192);
      unint64_t v7 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
    }
    CVPixelBufferRef v8 = (_OWORD *)(*(void *)(v5 + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((v7 & 0x3F) << 6));
    long long v9 = *(_OWORD *)pixelBuffer;
    long long v10 = v27;
    long long v11 = *(_OWORD *)&v28[16];
    float32x4_t v8[2] = *(_OWORD *)v28;
    double v8[3] = v11;
    *CVPixelBufferRef v8 = v9;
    v8[1] = v10;
    ++*(void *)(a1 + 224);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 232), 1uLL);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 240), CVPixelBufferGetDataSize(pixelBuffer[0]));
    HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1);
  }
  else
  {
    HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v29, (uint64_t)v24);
    *(_OWORD *)pixelBuffer = v24[0];
    long long v27 = v24[1];
    *(_OWORD *)uint64_t v28 = v25[0];
    *(_OWORD *)&v28[9] = *(_OWORD *)((char *)v25 + 9);
    CVPixelBufferRef v14 = *(CVPixelBufferRef *)&v24[0];
    if (*(void *)&v24[0])
    {
      uint64_t v15 = *(void *)(a1 + 200);
      uint64_t v16 = *(void *)(a1 + 192);
      uint64_t v17 = 8 * (v15 - v16) - 1;
      if (v15 == v16) {
        uint64_t v17 = 0;
      }
      unint64_t v18 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
      if (v17 == v18)
      {
        std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::__add_back_capacity(a1 + 184);
        uint64_t v16 = *(void *)(a1 + 192);
        unint64_t v18 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
      }
      long long v19 = (_OWORD *)(*(void *)(v16 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((v18 & 0x3F) << 6));
      long long v20 = *(_OWORD *)pixelBuffer;
      long long v21 = v27;
      long long v22 = *(_OWORD *)&v28[16];
      v19[2] = *(_OWORD *)v28;
      _OWORD v19[3] = v22;
      *long long v19 = v20;
      v19[1] = v21;
      ++*(void *)(a1 + 224);
      atomic_fetch_add((atomic_ullong *volatile)(a1 + 232), 1uLL);
      atomic_fetch_add((atomic_ullong *volatile)(a1 + 240), CVPixelBufferGetDataSize(pixelBuffer[0]));
      uint64_t v23 = "HGPool::releaseObject() - Attempting to double-release a free object: <%p>";
      CVPixelBufferRef v14 = pixelBuffer[0];
    }
    else
    {
      uint64_t v23 = "HGPool::releaseObject() - Attempting to release an unmanaged object: <%p>";
    }
    HGLogger::warning((HGLogger *)v23, v12, v13, v14);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  kdebug_trace();
  std::mutex::unlock(v3);
}

void sub_1B76D4018(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D402C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGCVPixelBuffer::~HGCVPixelBuffer(HGCVPixelBuffer *this)
{
  *(void *)this = &unk_1F10C4E40;
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 2);
    if (v3) {
      HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::releaseObject(*(void *)(v3 + 16), v2);
    }
    else {
      CVPixelBufferRelease(*((CVPixelBufferRef *)this + 3));
    }
  }
  uint64_t v4 = *((void *)this + 2);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }

  HGObject::~HGObject((HGObject *)this);
}

{
  void *v1;
  uint64_t vars8;

  HGCVPixelBuffer::~HGCVPixelBuffer(this);

  HGObject::operator delete(v1);
}

void HGCVPixelBuffer::create(HGCVPixelBuffer *this@<X0>, HGObject **a2@<X8>)
{
  *a2 = 0;
  if (this)
  {
    CVPixelBufferRetain((CVPixelBufferRef)this);
    uint64_t v5 = (HGObject *)HGObject::operator new(0x20uLL);
    HGObject::HGObject(v5);
    *(void *)uint64_t v5 = &unk_1F10C4E40;
    *((void *)v5 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
    *((void *)v5 + 3) = this;
    *a2 = v5;
  }
}

void sub_1B76D4180(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGCVPixelBuffer::convert(HGCVPixelBuffer *this@<X0>, HGObject **a2@<X8>)
{
  *a2 = 0;
  if (this)
  {
    uint64_t v5 = (HGObject *)HGObject::operator new(0x20uLL);
    HGObject::HGObject(v5);
    *(void *)uint64_t v5 = &unk_1F10C4E40;
    *((void *)v5 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
    *((void *)v5 + 3) = this;
    *a2 = v5;
  }
}

void sub_1B76D41FC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGCVPixelBuffer::create(HGCVPixelBuffer *this@<X0>, size_t a2@<X1>, OSType a3@<W2>, int a4@<W3>, HGObject **a5@<X8>)
{
  *a5 = 0;
  if (CVPixelBuffer)
  {
    CVPixelBufferRef v7 = CVPixelBuffer;
    CVPixelBufferRef v8 = (HGObject *)HGObject::operator new(0x20uLL);
    HGObject::HGObject(v8);
    *(void *)CVPixelBufferRef v8 = &unk_1F10C4E40;
    *((void *)v8 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
    *((void *)v8 + 3) = v7;
    *a5 = v8;
  }
}

void sub_1B76D427C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGCVPixelBuffer::create(HGCVPixelBuffer *this@<X0>, size_t a2@<X1>, OSType a3@<W2>, HGObject **a4@<X8>)
{
  *a4 = 0;
  if (CVPixelBuffer)
  {
    CVPixelBufferRef v6 = CVPixelBuffer;
    CVPixelBufferRef v7 = (HGObject *)HGObject::operator new(0x20uLL);
    HGObject::HGObject(v7);
    *(void *)CVPixelBufferRef v7 = &unk_1F10C4E40;
    *((void *)v7 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
    *((void *)v7 + 3) = v6;
    *a4 = v7;
  }
}

void sub_1B76D4300(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

CVPixelBufferRef anonymous namespace'::_allocateCVPixelBuffer(_anonymous_namespace_ *this, size_t a2, OSType a3, int a4)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v19, "hgcv", 1, "allocateCVPixelBuffer()");
  keys[0] = *(void **)MEMORY[0x1E4F2F158];
  CVPixelBufferRef v8 = (void **)MEMORY[0x1E4F1CFD0];
  if (!a4) {
    CVPixelBufferRef v8 = (void **)MEMORY[0x1E4F1CFC8];
  }
  values = *v8;
  CFDictionaryRef v9 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  long long v10 = (void *)*MEMORY[0x1E4F24D20];
  long long v20 = v9;
  long long v21 = v10;
  CFDictionaryRef v11 = CFDictionaryCreate(0, (const void **)&v21, (const void **)&v20, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CVPixelBufferRef pixelBufferOut = 0;
  uint64_t v12 = CVPixelBufferCreate(0, (size_t)this, a2, a3, v11, &pixelBufferOut);
  if (v12)
  {
    unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
    if (v15) {
      HGLogger::log((HGLogger *)"hgcv", (const char *)1, (HGLogger *)" **** CVPixelBufferRef() error! booo! (%d)\n", v13, v14, v12);
    }
    CVPixelBufferRef pixelBufferOut = 0;
  }
  CFRelease(v9);
  CFRelease(v11);
  CVPixelBufferRef v16 = pixelBufferOut;
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v19);
  return v16;
}

void sub_1B76D44A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76D44BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76D44D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

const char *HGCVPixelBuffer::create@<X0>(_anonymous_namespace_ *this@<X1>, const char **a2@<X0>, char *a3@<X2>, OSType a4@<W3>, char a5@<W4>, HGObject **a6@<X8>)
{
  *a6 = 0;
  if (this && a3)
  {
    CVPixelBufferRef v8 = *a2;
    if (*a2)
    {
      v14[0] = this;
      v14[1] = a3;
      OSType v15 = a4;
      char v16 = a5;
      CVPixelBufferRef CVPixelBuffer = HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::newObject(*((void *)v8 + 2), (uint64_t)v14, 0);
      if (CVPixelBuffer)
      {
LABEL_5:
        uint64_t v12 = (HGObject *)HGObject::operator new(0x20uLL);
        HGObject::HGObject(v12);
        *(void *)uint64_t v12 = &unk_1F10C4E40;
        uint64_t result = *a2;
        *((void *)v12 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *a2;
        if (result) {
          uint64_t result = (const char *)(*(uint64_t (**)(const char *))(*(void *)result + 16))(result);
        }
        *((void *)v12 + 3) = CVPixelBuffer;
        *a6 = v12;
        return result;
      }
    }
    else
    {
      if (CVPixelBuffer) {
        goto LABEL_5;
      }
    }
    return HGLogger::warning((HGLogger *)"HGCVPixelBuffer::create() failed. Could not allocate CVPixelBuffer.", v9, v10);
  }

  return HGLogger::warning((HGLogger *)"HGCVPixelBuffer::create() failed. Invalid size (width == 0 || height == 0).", (const char *)this, a3);
}

void sub_1B76D4620(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B76D4638(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

const char *HGCVPixelBuffer::create@<X0>(const char **a1@<X0>, _anonymous_namespace_ *a2@<X1>, char *a3@<X2>, OSType a4@<W3>, HGObject **a5@<X8>)
{
  return HGCVPixelBuffer::create(a2, a1, a3, a4, 1, a5);
}

size_t HGCVPixelBuffer::w(HGCVPixelBuffer *this, size_t a2)
{
  size_t PlaneCount = CVPixelBufferGetPlaneCount(*((CVPixelBufferRef *)this + 3));
  uint64_t v5 = (__CVBuffer *)*((void *)this + 3);
  if (PlaneCount)
  {
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v5);
    CVPixelBufferRef v7 = (__CVBuffer *)*((void *)this + 3);
    if (PixelFormatType == 1647392369)
    {
      return CVPixelBufferGetWidth(v7) >> 1;
    }
    else
    {
      return CVPixelBufferGetWidthOfPlane(v7, a2);
    }
  }
  else
  {
    return CVPixelBufferGetWidth(v5);
  }
}

size_t HGCVPixelBuffer::h(HGCVPixelBuffer *this, size_t a2)
{
  size_t PlaneCount = CVPixelBufferGetPlaneCount(*((CVPixelBufferRef *)this + 3));
  uint64_t v5 = (__CVBuffer *)*((void *)this + 3);
  if (PlaneCount)
  {
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v5);
    CVPixelBufferRef v7 = (__CVBuffer *)*((void *)this + 3);
    if (PixelFormatType == 1647392369)
    {
      return CVPixelBufferGetHeight(v7) >> 1;
    }
    else
    {
      return CVPixelBufferGetHeightOfPlane(v7, a2);
    }
  }
  else
  {
    return CVPixelBufferGetHeight(v5);
  }
}

size_t HGCVPixelBuffer::rowBytes(HGCVPixelBuffer *this, size_t a2)
{
  size_t PlaneCount = CVPixelBufferGetPlaneCount(*((CVPixelBufferRef *)this + 3));
  uint64_t v5 = (__CVBuffer *)*((void *)this + 3);
  if (PlaneCount)
  {
    return CVPixelBufferGetBytesPerRowOfPlane(v5, a2);
  }
  else
  {
    return CVPixelBufferGetBytesPerRow(v5);
  }
}

BOOL HGCVPixelBuffer::lock(HGCVPixelBuffer *this, CVPixelBufferLockFlags lockFlags)
{
  return CVPixelBufferLockBaseAddress(*((CVPixelBufferRef *)this + 3), lockFlags) == 0;
}

BOOL HGCVPixelBuffer::unlock(HGCVPixelBuffer *this, CVPixelBufferLockFlags unlockFlags)
{
  return CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)this + 3), unlockFlags) == 0;
}

void *HGCVPixelBuffer::ptr(HGCVPixelBuffer *this, size_t a2)
{
  size_t PlaneCount = CVPixelBufferGetPlaneCount(*((CVPixelBufferRef *)this + 3));
  uint64_t v5 = (__CVBuffer *)*((void *)this + 3);
  if (PlaneCount)
  {
    return CVPixelBufferGetBaseAddressOfPlane(v5, a2);
  }
  else
  {
    return CVPixelBufferGetBaseAddress(v5);
  }
}

void HGCVPixelBufferPoolImpl::~HGCVPixelBufferPoolImpl(HGCVPixelBufferPoolImpl *this, HGPool::BasePool *a2)
{
  HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~Pool((uint64_t)this, a2);

  JUMPOUT(0x1BA9BFBA0);
}

unint64_t HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::usedObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 128));
}

unint64_t HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::usedTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 136));
}

unint64_t HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::freeObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 232));
}

unint64_t HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::freeTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 240));
}

void HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::service(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1))
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    kdebug_trace();
  }

  std::mutex::unlock(v2);
}

void sub_1B76D4A0C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::trace(std::mutex *a1)
{
  uint64_t v2 = a1 + 4;
  std::mutex::lock(a1 + 4);
  sig = a1 + 5;
  if (a1[5].__m_.__opaque[15] < 0) {
    sig = (std::mutex *)sig->__m_.__sig;
  }
  (*(void (**)(std::mutex *, std::mutex *))(a1->__m_.__sig + 24))(a1, sig);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 16))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 40))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 32))(a1);
  std::mutex::unlock(v2);
}

void sub_1B76D4C5C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D4C70(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D4C84(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D4C98(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::log(uint64_t a1, const char *a2)
{
  uint64_t v3 = (HGLogger *)(a1 + 344);
  if (*(char *)(a1 + 367) < 0)
  {
    uint64_t v3 = *(HGLogger **)v3;
    if ((int)HGLogger::getLevel(v3, a2) < 2) {
      return;
    }
  }
  else if ((int)HGLogger::getLevel((HGLogger *)(a1 + 344), a2) < 2)
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6)
  {
    CVPixelBufferRef v7 = (void *)(a1 + 320);
    if (*(char *)(a1 + 343) < 0) {
      CVPixelBufferRef v7 = (void *)*v7;
    }
    HGLogger::log(v3, (const char *)2, (HGLogger *)"pool '%s' (%p)\n", v4, v5, v7, a1);
  }
  HGLogger::indent(1);
  unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
  if (v10) {
    HGLogger::log(v3, (const char *)2, (HGLogger *)"live objects:\n", v8, v9);
  }
  HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,true>::log((void *)(a1 + 48), v3);
  unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
  if (v13) {
    HGLogger::log(v3, (const char *)2, (HGLogger *)"free objects:\n", v11, v12);
  }
  HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::log((void *)(a1 + 152), v3);
  HGLogger::indent(0xFFFFFFFFLL);

  std::mutex::unlock((std::mutex *)(a1 + 256));
}

void sub_1B76D4DD8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::canService(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 372);
}

uint64_t HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::canTrace(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 373);
}

uint64_t HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::canLog(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 374);
}

void HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~Pool(a1, a2);

  JUMPOUT(0x1BA9BFBA0);
}

int64x2_t *HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::~List(int64x2_t *a1)
{
  while (a1[4].i64[1])
    HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::_pop_front(a1);
  std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::~deque[abi:ne180100]((uint64_t)a1[2].i64);
  uint64_t v2 = (std::__shared_weak_count *)a1[1].i64[1];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1->i64[1];
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

uint64_t HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::_pop_front(int64x2_t *a1)
{
  uint64_t v2 = (long long *)(*(void *)(a1[2].i64[1] + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8))
                  + ((a1[4].i64[0] & 0x3F) << 6));
  long long v3 = v2[3];
  long long v5 = *v2;
  long long v4 = v2[1];
  long long v11 = v2[2];
  long long v12 = v3;
  *(_OWORD *)pixelBuffer = v5;
  long long v10 = v4;
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -(uint64_t)CVPixelBufferGetDataSize((CVPixelBufferRef)v5));
  unsigned __int8 v6 = (void **)a1[2].i64[1];
  int64x2_t v7 = vaddq_s64(a1[4], (int64x2_t)xmmword_1B7E73580);
  a1[4] = v7;
  if (v7.i64[0] >= 0x80uLL)
  {
    operator delete(*v6);
    a1[2].i64[1] += 8;
    a1[4].i64[0] -= 64;
  }
  HGPool::EntryEventHandler<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::deleted((uint64_t)pixelBuffer);
  kdebug_trace();
  kdebug_trace();
  (*(void (**)(uint64_t, CVPixelBufferRef))(*(void *)a1->i64[0] + 24))(a1->i64[0], pixelBuffer[0]);
  if (pixelBuffer[1]) {
    (*(void (**)(void))(*(void *)a1->i64[0] + 24))();
  }
  return kdebug_trace();
}

void sub_1B76D50C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void HGSignPost::EventScopeGuard::~EventScopeGuard(HGSignPost::EventScopeGuard *this)
{
}

uint64_t HGPool::EntryEventHandler<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::deleted(uint64_t a1)
{
  CVPixelBufferGetDataSize(*(CVPixelBufferRef *)a1);
  HGPool::DescriptorString<HGCVPixelBufferPool::Descriptor>::str((unsigned char *)(a1 + 16));
  IOSurface = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)a1);
  ID = (const char *)IOSurfaceGetID(IOSurface);
  if (v9 < 0)
  {
    operator delete(__p);
    unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
    if ((v7 & 1) == 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
  if (v5) {
LABEL_3:
  }
    HGLogger::log((HGLogger *)"hgcv", (const char *)1, (HGLogger *)"HGCV - deleted entry: \n", ID, v4);
LABEL_4:
  HGLogger::indent(1);
  HGPool::EntryLog<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::log(a1, (HGLogger *)"hgcv", (const char *)1);
  return HGLogger::indent(0xFFFFFFFFLL);
}

void sub_1B76D5218(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGPool::DescriptorString<HGCVPixelBufferPool::Descriptor>::str(unsigned char *a1)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v12);
  uint64_t v2 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)" x ", 3);
  long long v3 = (void *)std::ostream::operator<<();
  long long v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)", ", 2);
  char v16 = a1[19];
  unsigned __int8 v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)&v16, 1);
  char v16 = a1[18];
  unsigned __int8 v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)&v16, 1);
  char v16 = a1[17];
  unsigned __int8 v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)&v16, 1);
  char v16 = a1[16];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)&v16, 1);
  CVPixelBufferRef v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)", PSC:", 6);
  if (a1[20]) {
    char v9 = "Y";
  }
  else {
    char v9 = "N";
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)v9, 1);
  std::stringbuf::str();
  v12[0] = *MEMORY[0x1E4FBA408];
  uint64_t v10 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v12 + *(void *)(v12[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v13[0] = v10;
  v13[1] = MEMORY[0x1E4FBA470] + 16;
  if (v14 < 0) {
    operator delete((void *)v13[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BA9BFAB0](&v15);
}

void sub_1B76D5458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGPool::EntryLog<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::log(uint64_t a1, HGLogger *a2, const char *a3)
{
  unsigned __int8 v7 = (unsigned char *)(a1 + 16);
  CVPixelBufferRef v6 = *(CVPixelBufferRef *)a1;
  Dataunsigned int Size = (HGLoggerUtils *)CVPixelBufferGetDataSize(*(CVPixelBufferRef *)a1);
  HGLoggerUtils::bytesPrettyString(DataSize);
  HGPool::DescriptorString<HGCVPixelBufferPool::Descriptor>::str(v7);
  if (*(unsigned char *)(a1 + 56))
  {
    unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
    if (v11)
    {
      long long v12 = v25;
      if (v26 < 0) {
        long long v12 = (void **)v25[0];
      }
      unsigned __int8 v13 = v23;
      if (v24 < 0) {
        unsigned __int8 v13 = (void **)v23[0];
      }
      HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu   %s\n", v9, v10, v6, v12, *(void *)(a1 + 48), v13);
    }
    goto LABEL_17;
  }
  v14.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  HGLoggerUtils::timePrettyString((HGLoggerUtils *)(v14.__d_.__rep_ - *(void *)(a1 + 40)));
  unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
  if (v17)
  {
    unint64_t v18 = v25;
    if (v26 < 0) {
      unint64_t v18 = (void **)v25[0];
    }
    p_p = &__p;
    if (v22 < 0) {
      p_p = __p;
    }
    long long v20 = v23;
    if (v24 < 0) {
      long long v20 = (void **)v23[0];
    }
    HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu  %10s   %s\n", v15, v16, v6, v18, *(void *)(a1 + 48), p_p, v20);
  }
  if ((v22 & 0x80000000) == 0)
  {
LABEL_17:
    if ((v24 & 0x80000000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_21;
  }
  operator delete(__p);
  if ((v24 & 0x80000000) == 0)
  {
LABEL_18:
    if ((v26 & 0x80000000) == 0) {
      return;
    }
LABEL_22:
    operator delete(v25[0]);
    return;
  }
LABEL_21:
  operator delete(v23[0]);
  if (v26 < 0) {
    goto LABEL_22;
  }
}

void sub_1B76D5610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v25 - 49) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);
  if ((*(char *)(v25 - 49) & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*(void **)(v25 - 72));
  _Unwind_Resume(exception_object);
}

uint64_t std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::~deque[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  long long v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      long long v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 32;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 64;
LABEL_7:
    *(void *)(a1 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      unsigned __int8 v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__shared_ptr_emplace<HGPool::FixedServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C4F58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HGPool::FixedServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C4F58;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<HGPool::FixedServicingPolicy>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void HGPool::FixedServicingPolicy::~FixedServicingPolicy(HGPool::FixedServicingPolicy *this)
{
}

void std::__shared_ptr_emplace<anonymous namespace'::HGCVPixelBufferAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C5008;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<anonymous namespace'::HGCVPixelBufferAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10C5008;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<anonymous namespace'::HGCVPixelBufferAllocator>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void anonymous namespace'::HGCVPixelBufferAllocator::~HGCVPixelBufferAllocator(_anonymous_namespace_::HGCVPixelBufferAllocator *this)
{
}

CVPixelBufferRef anonymous namespace'::HGCVPixelBufferAllocator::allocate(uint64_t a1, uint64_t a2)
{
}

void anonymous namespace'::HGCVPixelBufferAllocator::release(_anonymous_namespace_::HGCVPixelBufferAllocator *this, CVPixelBufferRef texture)
{
}

void *HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    return a1;
  }
  else
  {
    if (v2) {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    return a1;
  }
}

uint64_t HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  char v16 = 0;
  long long v17 = *a2;
  uint64_t v18 = *((void *)a2 + 2);
  uint64_t v10 = 0;
  long long v11 = v17;
  uint64_t v12 = v18;
  std::chrono::steady_clock::time_point v14 = 0;
  uint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v6 = &unk_1F10C50B0;
  *((void *)v6 + 4) = 0;
  *(_OWORD *)(v6 + 40) = *a2;
  *((void *)v6 + 7) = *((void *)a2 + 2);
  std::chrono::steady_clock::time_point v14 = v6;
  HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::_retrieve(a1, v13, a3);
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
    unsigned __int8 v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v14) {
      (*(void (**)(void))(*v14 + 40))();
    }
    unsigned __int8 v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v16;
      if (v16 != v15) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v15[0] + 32))(v15);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v16;
  if (v16 == v15) {
    return (*(uint64_t (**)(void *))(v15[0] + 32))(v15);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B76D5B7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va1);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B76D5BA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void **HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::_retrieve@<X0>(int64x2_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a3 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(unsigned char *)(a3 + 36) = 1;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(unsigned char *)(a3 + 56) = 1;
  unint64_t v5 = a1[4].i64[0] + a1[4].i64[1];
  uint64_t v6 = a1[2].i64[1];
  uint64_t v7 = (uint64_t *)(v6 + 8 * (v5 >> 6));
  if (a1[3].i64[0] != v6)
  {
    uint64_t v8 = *v7 + ((v5 & 0x3F) << 6);
    uint64_t v9 = *(void *)(v6 + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((a1[4].i64[0] & 0x3F) << 6);
    uint64_t v10 = (void *)a2[3];
    if (v10) {
      goto LABEL_3;
    }
LABEL_6:
    char v24 = 0;
    goto LABEL_8;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = (void *)a2[3];
  if (!v10) {
    goto LABEL_6;
  }
LABEL_3:
  if (v10 == a2)
  {
    char v24 = (void **)v23;
    (*(void (**)(void *, void *))(*a2 + 24))(a2, v23);
  }
  else
  {
    char v24 = (void **)(*(uint64_t (**)(void *))(*v10 + 16))(v10);
  }
LABEL_8:
  if (v8 != v9)
  {
    uint64_t v11 = *v7;
    while (1)
    {
      uint64_t v12 = v8;
      if (v8 == v11) {
        uint64_t v12 = *(v7 - 1) + 4096;
      }
      if (!v24) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      if ((*((uint64_t (**)(void **, uint64_t))*v24 + 6))(v24, v12 - 64)) {
        break;
      }
      uint64_t v11 = *v7;
      if (v8 == *v7)
      {
        uint64_t v13 = *--v7;
        uint64_t v11 = v13;
        uint64_t v8 = v13 + 4096;
      }
      v8 -= 64;
      if (v8 == v9)
      {
        uint64_t v8 = v9;
        break;
      }
    }
  }
  uint64_t result = v24;
  if (v24 == v23)
  {
    uint64_t result = (void **)(*(uint64_t (**)(void *))(v23[0] + 32))(v23);
    uint64_t v15 = a1[2].i64[1];
    if (a1[3].i64[0] != v15) {
      goto LABEL_22;
    }
LABEL_25:
    if (!v8) {
      return result;
    }
    goto LABEL_26;
  }
  if (v24) {
    uint64_t result = (void **)(*((uint64_t (**)(void))*v24 + 5))();
  }
  uint64_t v15 = a1[2].i64[1];
  if (a1[3].i64[0] == v15) {
    goto LABEL_25;
  }
LABEL_22:
  if (v8 == *(void *)(v15 + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8))
           + ((a1[4].i64[0] & 0x3F) << 6))
    return result;
LABEL_26:
  uint64_t v16 = v8 - *v7;
  uint64_t v17 = v16 >> 6;
  if (v16 < 65)
  {
    unint64_t v21 = 64 - v17;
    uint64_t v19 = (char *)&v7[-(v21 >> 6)];
    unint64_t v20 = *(void *)v19 + ((unint64_t)(~(_BYTE)v21 & 0x3F) << 6);
  }
  else
  {
    unint64_t v18 = v17 - 1;
    uint64_t v19 = (char *)&v7[v18 >> 6];
    unint64_t v20 = *(void *)v19 + ((v18 & 0x3F) << 6);
  }
  long long v22 = *(_OWORD *)(v20 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v20;
  *(_OWORD *)(a3 + 16) = v22;
  *(_OWORD *)(a3 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *(_OWORD *)(v20 + 32);
  *(_OWORD *)(a3 + 4PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(_OWORD *)(v20 + 41);
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -(uint64_t)CVPixelBufferGetDataSize(*(CVPixelBufferRef *)a3));
  return std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::erase(a1 + 2, v19, (char *)v20);
}

void sub_1B76D5ED8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B76D5EEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va);
  _Unwind_Resume(a1);
}

void **std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::erase(int64x2_t *a1, char *a2, char *a3)
{
  unint64_t v6 = a1[2].u64[0];
  uint64_t v7 = a1->i64[1];
  uint64_t v8 = a1[1].i64[0];
  uint64_t v9 = (const void **)(v7 + 8 * (v6 >> 6));
  if (v8 != v7)
  {
    uint64_t v10 = (char *)*v9 + 64 * (a1[2].i64[0] & 0x3F);
    if (a3 != v10) {
      goto LABEL_3;
    }
LABEL_7:
    unint64_t v14 = 0;
    uint64_t v12 = *v9;
    goto LABEL_8;
  }
  uint64_t v10 = 0;
  if (!a3) {
    goto LABEL_7;
  }
LABEL_3:
  uint64_t v11 = ((uint64_t)&a3[-*(void *)a2] >> 6) + 8 * (a2 - (char *)v9);
  uint64_t v12 = *v9;
  uint64_t v13 = v10 - (unsigned char *)*v9;
  unint64_t v14 = v11 - (v13 >> 6);
  if (v11 != v13 >> 6)
  {
    if (v11 < 1)
    {
      unint64_t v23 = 63 - v11;
      LOBYTE(v1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = ~(63 - v11);
      uint64_t v15 = &v9[-(v23 >> 6)];
    }
    else
    {
      uint64_t v15 = &v9[(unint64_t)v11 >> 6];
    }
    char v24 = *v15;
    uint64_t v17 = (const void **)((char *)*v15 + 64 * (unint64_t)(v11 & 0x3F));
    uint64_t v25 = a1[2].i64[1];
    if (v14 > (unint64_t)(v25 - 1) >> 1)
    {
      uint64_t v26 = (char *)v17 - v24;
      uint64_t v27 = ((char *)v17 - v24) >> 6;
      if (v26 < -63)
      {
        unint64_t v42 = 62 - v27;
        uint64_t v29 = &v15[-(v42 >> 6)];
        uint64_t v30 = (char *)*v29 + 64 * (unint64_t)(~(_BYTE)v42 & 0x3F);
        char v31 = v25 + v6;
        unint64_t v32 = (const void **)(v7 + 8 * ((v25 + v6) >> 6));
        if (v8 != v7) {
          goto LABEL_14;
        }
      }
      else
      {
        unint64_t v28 = v27 + 1;
        uint64_t v29 = &v15[v28 >> 6];
        uint64_t v30 = (char *)*v29 + 64 * (v28 & 0x3F);
        char v31 = v25 + v6;
        unint64_t v32 = (const void **)(v7 + 8 * ((v25 + v6) >> 6));
        if (v8 != v7)
        {
LABEL_14:
          uint64_t v33 = (char *)*v32 + 64 * (unint64_t)(v31 & 0x3F);
LABEL_28:
          v46[0] = v15;
          v46[1] = v17;
          std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>*,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>&,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>**,long,64l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>*,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>&,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>**,long,64l>,std::__deque_iterator<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>*,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>&,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>**,long,64l>>>(v29, v30, v32, v33, (uint64_t)v46);
          int64_t v38 = (void **)a1->i64[1];
          unint64_t v43 = (void **)a1[1].i64[0];
          unint64_t v37 = a1[2].u64[0];
          uint64_t v44 = a1[2].i64[1];
          a1[2].i64[1] = v44 - 1;
          uint64_t v45 = 8 * ((char *)v43 - (char *)v38) - 1;
          if (v43 == v38) {
            uint64_t v45 = 0;
          }
          if (v45 - (v44 + v37) + 1 >= 0x80)
          {
            operator delete(*(v43 - 1));
            char v16 = 0;
            int64_t v38 = (void **)a1->i64[1];
            a1[1].i64[0] -= 8;
            unint64_t v37 = a1[2].u64[0];
          }
          else
          {
            char v16 = 0;
          }
          goto LABEL_19;
        }
      }
      uint64_t v33 = 0;
      goto LABEL_28;
    }
    char v16 = 0;
    uint64_t v34 = (char *)v17 - v24;
    uint64_t v19 = ((char *)v17 - v24) >> 6;
    if (v34 < -63) {
      goto LABEL_16;
    }
LABEL_9:
    unint64_t v20 = v19 + 1;
    unint64_t v21 = &v15[v20 >> 6];
    long long v22 = (char *)*v21 + 64 * (v20 & 0x3F);
    goto LABEL_17;
  }
LABEL_8:
  char v16 = 1;
  uint64_t v15 = (const void **)(v7 + 8 * (v6 >> 6));
  uint64_t v17 = (const void **)v10;
  uint64_t v18 = v10 - v12;
  uint64_t v19 = (v10 - v12) >> 6;
  if (v18 >= -63) {
    goto LABEL_9;
  }
LABEL_16:
  unint64_t v35 = 62 - v19;
  unint64_t v21 = &v15[-(v35 >> 6)];
  long long v22 = (char *)*v21 + 64 * (unint64_t)(~(_BYTE)v35 & 0x3F);
LABEL_17:
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>*,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>&,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>**,long,64l>,std::__deque_iterator<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>*,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>&,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>**,long,64l>,0>(v9, v10, v15, (char *)v17, v21, v22, v46);
  int64x2_t v36 = vaddq_s64(a1[2], (int64x2_t)xmmword_1B7E73580);
  a1[2] = v36;
  unint64_t v37 = v36.i64[0];
  int64_t v38 = (void **)a1->i64[1];
  if (v36.i64[0] >= 0x80uLL)
  {
    operator delete(*v38);
    int64_t v38 = (void **)(a1->i64[1] + 8);
    a1->i64[1] = (uint64_t)v38;
    unint64_t v37 = a1[2].i64[0] - 64;
    a1[2].i64[0] = v37;
  }
LABEL_19:
  uint64_t result = &v38[v37 >> 6];
  if ((void **)a1[1].i64[0] == v38)
  {
    unint64_t v40 = 0;
    if (v16) {
      return result;
    }
  }
  else
  {
    unint64_t v40 = (unint64_t)*result + 64 * (v37 & 0x3F);
    if (v16) {
      return result;
    }
  }
  uint64_t v41 = v14 + ((uint64_t)(v40 - (void)*result) >> 6);
  if (v41 < 1) {
    result -= (unint64_t)(63 - v41) >> 6;
  }
  else {
    result += (unint64_t)v41 >> 6;
  }
  return result;
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>*,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>&,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>**,long,64l>,std::__deque_iterator<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>*,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>&,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>**,long,64l>,0>@<X0>(const void **a1@<X1>, char *a2@<X2>, const void **a3@<X3>, char *a4@<X4>, const void **a5@<X5>, char *a6@<X6>, const void ***a7@<X8>)
{
  uint64_t v8 = a5;
  if (a1 == a3)
  {
    if (a2 == a4) {
      goto LABEL_42;
    }
    uint64_t v35 = (uint64_t)*a5;
    int64x2_t v36 = a4;
    while (1)
    {
      uint64_t v37 = (uint64_t)&a6[-v35] >> 6;
      uint64_t v38 = (v36 - a2) >> 6;
      if (v38 >= v37) {
        uint64_t v38 = v37;
      }
      v36 -= 64 * v38;
      a6 -= 64 * v38;
      if (v38) {
        uint64_t result = memmove(a6, v36, (v38 << 6) - 7);
      }
      if (v36 == a2) {
        break;
      }
      uint64_t v39 = (uint64_t)*--v8;
      uint64_t v35 = v39;
      a6 = (char *)(v39 + 4096);
    }
    goto LABEL_40;
  }
  unint64_t v14 = *a3;
  if (*a3 != a4)
  {
    uint64_t v15 = (uint64_t)*a5;
    char v16 = a4;
    while (1)
    {
      uint64_t v17 = (uint64_t)&a6[-v15] >> 6;
      uint64_t v18 = (v16 - v14) >> 6;
      if (v18 >= v17) {
        uint64_t v18 = v17;
      }
      v16 -= 64 * v18;
      a6 -= 64 * v18;
      if (v18) {
        uint64_t result = memmove(a6, v16, (v18 << 6) - 7);
      }
      if (v16 == v14) {
        break;
      }
      uint64_t v20 = (uint64_t)*--v8;
      uint64_t v15 = v20;
      a6 = (char *)(v20 + 4096);
    }
    if ((char *)*v8 + 4096 == a6)
    {
      unint64_t v21 = (char *)v8[1];
      ++v8;
      a6 = v21;
    }
  }
  long long v22 = a3 - 1;
  if (a3 - 1 != a1)
  {
    unint64_t v23 = (char *)*v8;
    do
    {
      while (1)
      {
        char v24 = *v22;
        uint64_t v25 = (char *)*v22 + 4096;
        while (1)
        {
          uint64_t v26 = (a6 - v23) >> 6;
          uint64_t v27 = (v25 - v24) >> 6;
          if (v27 >= v26) {
            uint64_t v27 = v26;
          }
          v25 -= 64 * v27;
          a6 -= 64 * v27;
          if (v27) {
            uint64_t result = memmove(a6, v25, (v27 << 6) - 7);
          }
          if (v25 == v24) {
            break;
          }
          unint64_t v28 = (char *)*--v8;
          unint64_t v23 = v28;
          a6 = v28 + 4096;
        }
        unint64_t v23 = (char *)*v8;
        if ((char *)*v8 + 4096 == a6) {
          break;
        }
        if (--v22 == a1) {
          goto LABEL_24;
        }
      }
      uint64_t v29 = (char *)v8[1];
      ++v8;
      unint64_t v23 = v29;
      a6 = v29;
      --v22;
    }
    while (v22 != a1);
  }
LABEL_24:
  uint64_t v30 = (char *)*a1 + 4096;
  if (v30 != a2)
  {
    uint64_t v31 = (uint64_t)*v8;
    while (1)
    {
      uint64_t v32 = (uint64_t)&a6[-v31] >> 6;
      uint64_t v33 = (v30 - a2) >> 6;
      if (v33 >= v32) {
        uint64_t v33 = v32;
      }
      v30 -= 64 * v33;
      a6 -= 64 * v33;
      if (v33) {
        uint64_t result = memmove(a6, v30, (v33 << 6) - 7);
      }
      if (v30 == a2) {
        break;
      }
      uint64_t v34 = (uint64_t)*--v8;
      uint64_t v31 = v34;
      a6 = (char *)(v34 + 4096);
    }
LABEL_40:
    if ((char *)*v8 + 4096 == a6)
    {
      unint64_t v40 = (char *)v8[1];
      ++v8;
      a6 = v40;
    }
  }
LABEL_42:
  *a7 = a3;
  a7[1] = (const void **)a4;
  a7[2] = v8;
  a7[3] = (const void **)a6;
  return result;
}

const void **std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>*,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>&,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>**,long,64l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>*,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>&,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>**,long,64l>,std::__deque_iterator<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>*,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>&,HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>**,long,64l>>>(const void **result, unsigned char *__src, const void **a3, unsigned char *a4, uint64_t a5)
{
  uint64_t v7 = __src;
  uint64_t v9 = *(void ***)a5;
  uint64_t v8 = *(char **)(a5 + 8);
  if (result != a3)
  {
    uint64_t v11 = result;
    uint64_t v12 = (char *)*result + 4096;
    if (v12 != __src)
    {
      unint64_t v14 = (char *)*v9++;
      uint64_t v13 = v14;
      while (1)
      {
        uint64_t v15 = (v13 - v8 + 4096) >> 6;
        if ((v12 - v7) >> 6 >= v15) {
          uint64_t v16 = v15;
        }
        else {
          uint64_t v16 = (v12 - v7) >> 6;
        }
        if (v16) {
          uint64_t result = (const void **)memmove(v8, v7, (v16 << 6) - 7);
        }
        v7 += 64 * v16;
        if (v7 == v12) {
          break;
        }
        uint64_t v17 = (char *)*v9++;
        uint64_t v13 = v17;
        uint64_t v8 = v17;
      }
      v8 += 64 * v16;
      if ((char *)*(v9 - 1) + 4096 == v8)
      {
        uint64_t v8 = (char *)*v9;
        *(void *)a5 = v9;
        *(void *)(a5 + 8) = v8;
        uint64_t i = v11 + 1;
        if (v11 + 1 != a3) {
          goto LABEL_16;
        }
LABEL_39:
        uint64_t v33 = *a3;
        if (v33 == a4) {
          goto LABEL_50;
        }
        uint64_t v35 = (char *)*v9++;
        uint64_t v34 = v35;
        while (1)
        {
          uint64_t v36 = (v34 - v8 + 4096) >> 6;
          uint64_t v37 = (a4 - v33) >> 6 >= v36 ? v36 : (a4 - v33) >> 6;
          if (v37) {
            uint64_t result = (const void **)memmove(v8, v33, (v37 << 6) - 7);
          }
          v33 += 64 * v37;
          if (v33 == a4) {
            break;
          }
          uint64_t v38 = (char *)*v9++;
          uint64_t v34 = v38;
          uint64_t v8 = v38;
        }
        v8 += 64 * v37;
        uint64_t v32 = v9 - 1;
        if ((char *)*(v9 - 1) + 4096 != v8)
        {
LABEL_49:
          uint64_t v9 = v32;
          goto LABEL_50;
        }
        goto LABEL_37;
      }
      --v9;
    }
    *(void *)a5 = v9;
    *(void *)(a5 + 8) = v8;
    for (uint64_t i = v11 + 1; i != a3; ++i)
    {
LABEL_16:
      while (1)
      {
        uint64_t v19 = 0;
        uint64_t v20 = (char *)*i;
        long long v22 = (char *)*v9++;
        unint64_t v21 = v22;
        while (1)
        {
          uint64_t v23 = (v21 - v8 + 4096) >> 6;
          if ((4096 - (v19 << 6)) >> 6 >= v23) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = (4096 - (v19 << 6)) >> 6;
          }
          if (v24) {
            uint64_t result = (const void **)memmove(v8, &v20[64 * v19], (v24 << 6) - 7);
          }
          v19 += v24;
          if (v19 == 64) {
            break;
          }
          uint64_t v25 = (char *)*v9++;
          unint64_t v21 = v25;
          uint64_t v8 = v25;
        }
        v8 += 64 * v24;
        uint64_t v26 = v9 - 1;
        if ((char *)*(v9 - 1) + 4096 != v8) {
          break;
        }
        uint64_t v8 = (char *)*v9;
        *(void *)a5 = v9;
        *(void *)(a5 + 8) = v8;
        if (++i == a3) {
          goto LABEL_39;
        }
      }
      --v9;
      *(void *)a5 = v26;
      *(void *)(a5 + 8) = v8;
    }
    goto LABEL_39;
  }
  if (__src != a4)
  {
    unint64_t v28 = (char *)*v9++;
    uint64_t v27 = v28;
    while (1)
    {
      uint64_t v29 = (v27 - v8 + 4096) >> 6;
      if ((a4 - v7) >> 6 >= v29) {
        uint64_t v30 = v29;
      }
      else {
        uint64_t v30 = (a4 - v7) >> 6;
      }
      if (v30) {
        uint64_t result = (const void **)memmove(v8, v7, (v30 << 6) - 7);
      }
      v7 += 64 * v30;
      if (v7 == a4) {
        break;
      }
      uint64_t v31 = (char *)*v9++;
      uint64_t v27 = v31;
      uint64_t v8 = v31;
    }
    v8 += 64 * v30;
    uint64_t v32 = v9 - 1;
    if ((char *)*(v9 - 1) + 4096 != v8) {
      goto LABEL_49;
    }
LABEL_37:
    uint64_t v8 = (char *)*v9;
  }
LABEL_50:
  *(void *)a5 = v9;
  *(void *)(a5 + 8) = v8;
  return result;
}

void *std::__function::__func<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10C50B0;
  uint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    return a1;
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    return a1;
  }
}

void std::__function::__func<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10C50B0;
  uint64_t v1 = a1 + 1;
  uint64_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

char *std::__function::__func<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1F10C50B0;
  uint64_t v3 = v2 + 8;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    if (v4 == a1 + 8)
    {
      *((void *)v2 + 4) = v3;
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      goto LABEL_6;
    }
    uint64_t v4 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v4 + 16))(v4, v3);
  }
  *((void *)v2 + 4) = v4;
LABEL_6:
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return v2;
}

void sub_1B76D6940(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F10C50B0;
  uint64_t v4 = a2 + 8;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    if (v5 == a1 + 8)
    {
      *(void *)(a2 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v4;
      (*(void (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
    }
    else
    {
      *(void *)(a2 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 16))(v5, v4);
    }
  }
  else
  {
    *(void *)(a2 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  }
  __n128 result = *(__n128 *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

uint64_t std::__function::__func<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__function::__func<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::destroy_deallocate(char *__p)
{
  uint64_t v2 = __p + 8;
  uint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    uint64_t v4 = __p;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = __p;
  }
  operator delete(v4);
}

BOOL std::__function::__func<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16) == *(void *)(a1 + 40)
      && *(void *)(a2 + 24) == *(void *)(a1 + 48)
      && *(_DWORD *)(a2 + 32) == *(_DWORD *)(a1 + 56)
      && *(unsigned __int8 *)(a2 + 36) == *(unsigned __int8 *)(a1 + 60);
}

uint64_t std::__function::__func<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "N6HGPool16MatchDescriptionIP10__CVBufferN19HGCVPixelBufferPool10DescriptorEEE") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"N6HGPool16MatchDescriptionIP10__CVBufferN19HGCVPixelBufferPool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool16MatchDescriptionIP10__CVBufferN19HGCVPixelBufferPool10DescriptorEEE")) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool16MatchDescriptionIP10__CVBufferN19HGCVPixelBufferPool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchDescription<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::target_type()
{
}

uint64_t HGPool::EntryEventHandler<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::reused(uint64_t a1)
{
  CVPixelBufferGetDataSize(*(CVPixelBufferRef *)a1);
  HGPool::DescriptorString<HGCVPixelBufferPool::Descriptor>::str((unsigned char *)(a1 + 16));
  IOSurface = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)a1);
  ID = (const char *)IOSurfaceGetID(IOSurface);
  if (v9 < 0)
  {
    operator delete(__p);
    unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
    if ((v7 & 1) == 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
  if (v5) {
LABEL_3:
  }
    HGLogger::log((HGLogger *)"hgcv", (const char *)1, (HGLogger *)"HGCV - reused entry:\n", ID, v4);
LABEL_4:
  HGLogger::indent(1);
  HGPool::EntryLog<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::log(a1, (HGLogger *)"hgcv", (const char *)1);
  return HGLogger::indent(0xFFFFFFFFLL);
}

void sub_1B76D6CE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGPool::EntryEventHandler<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::allocated(uint64_t a1)
{
  CVPixelBufferGetDataSize(*(CVPixelBufferRef *)a1);
  HGPool::DescriptorString<HGCVPixelBufferPool::Descriptor>::str((unsigned char *)(a1 + 16));
  IOSurface = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)a1);
  ID = (const char *)IOSurfaceGetID(IOSurface);
  if (v9 < 0)
  {
    operator delete(__p);
    unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
    if ((v7 & 1) == 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
  if (v5) {
LABEL_3:
  }
    HGLogger::log((HGLogger *)"hgcv", (const char *)1, (HGLogger *)"HGCV - allocated entry:\n", ID, v4);
LABEL_4:
  HGLogger::indent(1);
  HGPool::EntryLog<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::log(a1, (HGLogger *)"hgcv", (const char *)1);
  return HGLogger::indent(0xFFFFFFFFLL);
}

void sub_1B76D6DF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x40;
  unint64_t v4 = v2 - 64;
  if (v3)
  {
    *(void *)(a1 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v4;
    unint64_t v6 = *(void **)(a1 + 8);
    unsigned __int8 v5 = *(char **)(a1 + 16);
    unsigned __int8 v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)unsigned __int8 v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    char v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        uint64_t v34 = (char *)operator new(8 * v31);
        uint64_t v35 = &v34[8 * v32];
        uint64_t v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        unsigned __int8 v5 = v35;
        if (!v37)
        {
          unsigned __int8 v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            int8x16_t v74 = &v34[8 * v32];
            unint64_t v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v40 = &v35[v76];
              v7 += v76;
              float v77 = (long long *)(v6 + 3);
              uint64_t v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(v77 - 1);
                *uint64_t v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            unint64_t v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    uint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      unsigned __int8 v7 = *(char **)(a1 + 8);
    }
    unsigned __int8 v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      float32x4_t v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    float32x4_t v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    unsigned __int8 v5 = *(char **)(a1 + 16);
    unsigned __int8 v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    char v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        uint64_t v34 = (char *)operator new(8 * v42);
        uint64_t v35 = &v34[8 * v43];
        uint64_t v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        unsigned __int8 v5 = v35;
        if (!v37)
        {
          unsigned __int8 v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            float32x2_t v82 = &v34[8 * v43];
            unint64_t v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v47 = &v35[v84];
              v7 += v84;
              float32x4_t v85 = (long long *)(v41 + 3);
              uint64_t v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(v85 - 1);
                *uint64_t v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            unint64_t v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          unsigned __int8 v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  uint64_t v26 = operator new(0x1000uLL);
  uint64_t v27 = &v25[8 * v21];
  unint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    float32x4_t v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v49 = (char *)operator new(8 * v48);
      uint64_t v27 = &v49[8 * (v48 >> 2)];
      unint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v25 = v49;
      *(void *)uint64_t v27 = v90;
      uint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)uint64_t v27 = v26;
      uint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          float32x4_t v60 = (char *)operator new(8 * v59);
          uint64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          int32x4_t v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v53;
          if (!v37)
          {
            uint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            float32x4_t v64 = &v60[8 * v61];
            float32x4_t v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            float32x4_t v64 = &v60[8 * v61];
            float32x4_t v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            float32x4_t v64 = &v53[v68];
            float32x4_t v65 = &v27[v68];
            int32x4_t v69 = (long long *)(v27 + 16);
            float32x4_t v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(v69 - 1);
              *(_OWORD *)float32x4_t v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)float32x4_t v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          unint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          long long v57 = &v29[8 * (v56 >> 1)];
          int32x4_t v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          uint64_t v25 = v27;
        }
      }
      else
      {
        int32x4_t v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v54;
      float32x4_t v51 = v53 - 8;
      uint64_t v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)uint64_t v27 = v26;
  uint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  float32x4_t v51 = v27;
LABEL_46:
  float v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B76D7380(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B76D739C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D73B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76D73C8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,true>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v15 = 0;
  uint64_t v16 = v5;
  uint64_t v10 = 0;
  uint64_t v11 = v5;
  unint64_t v6 = operator new(0x30uLL);
  *unint64_t v6 = &unk_1F10C51B8;
  v6[4] = 0;
  v6[5] = v5;
  uint64_t v13 = v6;
  HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,true>::_retrieve(a1, v12, a3);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
    unsigned __int8 v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v13) {
      (*(void (**)(void))(*v13 + 40))();
    }
    unsigned __int8 v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v15;
      if (v15 != v14) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B76D75D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va1);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B76D75F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::service(int64x2_t *a1, uint64_t a2)
{
  if (!a1[1].i64[0]) {
    return 0;
  }
  if (a1[4].i64[1])
  {
    uint64_t v4 = 0;
    do
    {
      unint64_t v5 = atomic_load((unint64_t *)&a1[5]);
      if (v5 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[1].i64[0] + 16))(a1[1].i64[0], a2))
      {
        unint64_t v6 = atomic_load(&a1[5].u64[1]);
        if (v6 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[1].i64[0] + 24))(a1[1].i64[0], a2))
        {
          unint64_t v7 = a1[4].u64[0];
          uint64_t v8 = *(void *)(a1[2].i64[1] + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8));
          unint64_t v9 = std::chrono::steady_clock::now().__d_.__rep_ - *(void *)(v8 + ((v7 & 0x3F) << 6) + 40);
          if (v9 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[1].i64[0] + 32))(a1[1].i64[0], a2)) {
            break;
          }
        }
      }
      HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::_pop_front(a1);
      ++v4;
    }
    while (a1[4].i64[1]);
    return v4;
  }
  return 0;
}

uint64_t HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v15 = 0;
  uint64_t v16 = v5;
  uint64_t v10 = 0;
  uint64_t v11 = v5;
  unint64_t v6 = operator new(0x30uLL);
  *unint64_t v6 = &unk_1F10C51B8;
  v6[4] = 0;
  v6[5] = v5;
  uint64_t v13 = v6;
  HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::_retrieve(a1, v12, a3);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
    unint64_t v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v13) {
      (*(void (**)(void))(*v13 + 40))();
    }
    unint64_t v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v15;
      if (v15 != v14) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B76D7974(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va1);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B76D7998(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void **HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,true>::_retrieve@<X0>(int64x2_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a3 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(unsigned char *)(a3 + 36) = 1;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(unsigned char *)(a3 + 56) = 1;
  unint64_t v5 = a1[4].i64[0] + a1[4].i64[1];
  uint64_t v6 = a1[2].i64[1];
  uint64_t v7 = (uint64_t *)(v6 + 8 * (v5 >> 6));
  if (a1[3].i64[0] != v6)
  {
    uint64_t v8 = *v7 + ((v5 & 0x3F) << 6);
    uint64_t v9 = *(void *)(v6 + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((a1[4].i64[0] & 0x3F) << 6);
    uint64_t v10 = (void *)a2[3];
    if (v10) {
      goto LABEL_3;
    }
LABEL_6:
    unint64_t v24 = 0;
    goto LABEL_8;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = (void *)a2[3];
  if (!v10) {
    goto LABEL_6;
  }
LABEL_3:
  if (v10 == a2)
  {
    unint64_t v24 = (void **)v23;
    (*(void (**)(void *, void *))(*a2 + 24))(a2, v23);
  }
  else
  {
    unint64_t v24 = (void **)(*(uint64_t (**)(void *))(*v10 + 16))(v10);
  }
LABEL_8:
  if (v8 != v9)
  {
    uint64_t v11 = *v7;
    while (1)
    {
      uint64_t v12 = v8;
      if (v8 == v11) {
        uint64_t v12 = *(v7 - 1) + 4096;
      }
      if (!v24) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      if ((*((uint64_t (**)(void **, uint64_t))*v24 + 6))(v24, v12 - 64)) {
        break;
      }
      uint64_t v11 = *v7;
      if (v8 == *v7)
      {
        uint64_t v13 = *--v7;
        uint64_t v11 = v13;
        uint64_t v8 = v13 + 4096;
      }
      v8 -= 64;
      if (v8 == v9)
      {
        uint64_t v8 = v9;
        break;
      }
    }
  }
  uint64_t result = v24;
  if (v24 == v23)
  {
    uint64_t result = (void **)(*(uint64_t (**)(void *))(v23[0] + 32))(v23);
    uint64_t v15 = a1[2].i64[1];
    if (a1[3].i64[0] != v15) {
      goto LABEL_22;
    }
LABEL_25:
    if (!v8) {
      return result;
    }
    goto LABEL_26;
  }
  if (v24) {
    uint64_t result = (void **)(*((uint64_t (**)(void))*v24 + 5))();
  }
  uint64_t v15 = a1[2].i64[1];
  if (a1[3].i64[0] == v15) {
    goto LABEL_25;
  }
LABEL_22:
  if (v8 == *(void *)(v15 + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8))
           + ((a1[4].i64[0] & 0x3F) << 6))
    return result;
LABEL_26:
  uint64_t v16 = v8 - *v7;
  uint64_t v17 = v16 >> 6;
  if (v16 < 65)
  {
    unint64_t v21 = 64 - v17;
    uint64_t v19 = (char *)&v7[-(v21 >> 6)];
    unint64_t v20 = *(void *)v19 + ((unint64_t)(~(_BYTE)v21 & 0x3F) << 6);
  }
  else
  {
    unint64_t v18 = v17 - 1;
    uint64_t v19 = (char *)&v7[v18 >> 6];
    unint64_t v20 = *(void *)v19 + ((v18 & 0x3F) << 6);
  }
  long long v22 = *(_OWORD *)(v20 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v20;
  *(_OWORD *)(a3 + 16) = v22;
  *(_OWORD *)(a3 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *(_OWORD *)(v20 + 32);
  *(_OWORD *)(a3 + 4PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(_OWORD *)(v20 + 41);
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -(uint64_t)CVPixelBufferGetDataSize(*(CVPixelBufferRef *)a3));
  return std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::erase(a1 + 2, v19, (char *)v20);
}

void sub_1B76D7CD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B76D7CE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::~MatchObject((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__func<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10C51B8;
  unint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    return a1;
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    return a1;
  }
}

void std::__function::__func<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10C51B8;
  uint64_t v1 = a1 + 1;
  unint64_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void *std::__function::__func<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::__clone(uint64_t a1)
{
  unint64_t v2 = operator new(0x30uLL);
  void *v2 = &unk_1F10C51B8;
  uint64_t v3 = v2 + 1;
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4) {
    goto LABEL_4;
  }
  if (v4 != a1 + 8)
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 16))(v4, v3);
LABEL_4:
    uint64_t v5 = *(void *)(a1 + 40);
    v2[4] = v4;
    v2[5] = v5;
    return v2;
  }
  v2[4] = v3;
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  v2[5] = *(void *)(a1 + 40);
  return v2;
}

void sub_1B76D7F3C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F10C51B8;
  uint64_t v4 = a2 + 1;
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 16))(result, v4);
      a2[4] = result;
    }
    a2[5] = *(void *)(a1 + 40);
  }
  else
  {
    a2[4] = 0;
    a2[5] = *(void *)(a1 + 40);
  }
  return result;
}

uint64_t std::__function::__func<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__function::__func<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::destroy_deallocate(char *__p)
{
  unint64_t v2 = __p + 8;
  uint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    uint64_t v4 = __p;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = __p;
  }
  operator delete(v4);
}

BOOL std::__function::__func<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::operator()(uint64_t a1, void *a2)
{
  return *a2 == *(void *)(a1 + 40);
}

uint64_t std::__function::__func<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "N6HGPool11MatchObjectIP10__CVBufferN19HGCVPixelBufferPool10DescriptorEEE") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"N6HGPool11MatchObjectIP10__CVBufferN19HGCVPixelBufferPool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool11MatchObjectIP10__CVBufferN19HGCVPixelBufferPool10DescriptorEEE")) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool11MatchObjectIP10__CVBufferN19HGCVPixelBufferPool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>,std::allocator<HGPool::MatchObject<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>,BOOL ()(HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor> const&)>::target_type()
{
}

uint64_t HGPool::EntryEventHandler<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::recycled(uint64_t a1)
{
  CVPixelBufferGetDataSize(*(CVPixelBufferRef *)a1);
  HGPool::DescriptorString<HGCVPixelBufferPool::Descriptor>::str((unsigned char *)(a1 + 16));
  IOSurface = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)a1);
  ID = (const char *)IOSurfaceGetID(IOSurface);
  if (v9 < 0)
  {
    operator delete(__p);
    unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
    if ((v7 & 1) == 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
  if (v5) {
LABEL_3:
  }
    HGLogger::log((HGLogger *)"hgcv", (const char *)1, (HGLogger *)"HGCV - recycled entry:\n", ID, v4);
LABEL_4:
  HGLogger::indent(1);
  HGPool::EntryLog<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::log(a1, (HGLogger *)"hgcv", (const char *)1);
  return HGLogger::indent(0xFFFFFFFFLL);
}

void sub_1B76D82C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGPool::EntryTrace<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::trace(uint64_t a1)
{
  IOSurface = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)a1);
  IOSurfaceGetID(IOSurface);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v23);
  unint64_t v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)",  sid: ", 8);
  uint64_t v4 = v3;
  uint64_t v5 = *v3;
  uint64_t v6 = (char *)v3 + *(void *)(*v3 - 24);
  if (*((_DWORD *)v6 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)v3 + *(void *)(*v3 - 24)));
    unsigned __int8 v7 = std::locale::use_facet(v21, MEMORY[0x1E4FBA258]);
    int v8 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 32);
    std::locale::~locale(v21);
    *((_DWORD *)v6 + 36) = v8;
    uint64_t v5 = *v4;
  }
  *((_DWORD *)v6 + 36) = 48;
  *(uint64_t *)((char *)v4 + *(void *)(v5 - 24) + 24) = 8;
  *(_DWORD *)((char *)v4 + *(void *)(v5 - 24) + 8) = *(_DWORD *)((unsigned char *)v4 + *(void *)(v5 - 24) + 8) & 0xFFFFFFB5 | 8;
  char v9 = (void *)std::ostream::operator<<();
  uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" (", 2);
  *(_DWORD *)((char *)v10 + *(void *)(*v10 - 24) + 8) = *(_DWORD *)((unsigned char *)v10 + *(void *)(*v10 - 24) + 8) & 0xFFFFFFB5 | 2;
  uint64_t v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)")", 1);
  HGPool::DescriptorString<HGCVPixelBufferPool::Descriptor>::str((unsigned char *)(a1 + 16));
  std::stringbuf::str();
  if ((v19 & 0x80u) == 0) {
    uint64_t v12 = v18;
  }
  else {
    uint64_t v12 = (void **)v18[0];
  }
  if ((v19 & 0x80u) == 0) {
    std::string::size_type v13 = v19;
  }
  else {
    std::string::size_type v13 = (std::string::size_type)v18[1];
  }
  uint64_t v14 = std::string::append(&v20, (const std::string::value_type *)v12, v13);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  std::string::size_type v22 = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21[0].__locale_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if ((char)v19 < 0)
  {
    operator delete(v18[0]);
    if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_11;
    }
  }
  else if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_11;
  }
  operator delete(v20.__r_.__value_.__l.__data_);
LABEL_11:
  CVPixelBufferGetDataSize(*(CVPixelBufferRef *)a1);
  if (*(unsigned char *)(a1 + 56))
  {
    if ((SHIBYTE(v22) & 0x80000000) == 0) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  std::chrono::steady_clock::now();
  if (SHIBYTE(v22) < 0) {
LABEL_13:
  }
    operator delete(v21[0].__locale_);
LABEL_14:
  v23[0] = *MEMORY[0x1E4FBA408];
  uint64_t v16 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v23 + *(void *)(v23[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v24[0] = v16;
  v24[1] = MEMORY[0x1E4FBA470] + 16;
  if (v25 < 0) {
    operator delete((void *)v24[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BA9BFAB0](&v26);
}

void sub_1B76D86A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,std::locale a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
}

void HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,true>::log(void *a1, HGLogger *a2)
{
  if (a1[9])
  {
    HGLogger::indent(1);
    uint64_t v4 = a1[5];
    if (a1[6] != v4)
    {
      unint64_t v5 = a1[8];
      uint64_t v6 = (void *)(v4 + 8 * (v5 >> 6));
      unsigned __int8 v7 = (long long *)(*v6 + ((v5 & 0x3F) << 6));
      uint64_t v8 = *(void *)(v4 + (((a1[9] + v5) >> 3) & 0x1FFFFFFFFFFFFFF8)) + (((a1[9] + v5) & 0x3F) << 6);
      while (v7 != (long long *)v8)
      {
        long long v9 = *v7;
        long long v10 = v7[1];
        long long v11 = v7[3];
        long long v21 = v7[2];
        long long v22 = v11;
        *(_OWORD *)long long __p = v9;
        long long v20 = v10;
        HGPool::EntryLog<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::log((uint64_t)__p, a2, (const char *)3);
        v7 += 4;
        if ((long long *)((char *)v7 - *v6) == (long long *)4096)
        {
          uint64_t v12 = (long long *)v6[1];
          ++v6;
          unsigned __int8 v7 = v12;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    std::string::size_type v13 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v13);
    unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
    if (v16)
    {
      if ((SBYTE7(v20) & 0x80u) == 0) {
        uint64_t v17 = __p;
      }
      else {
        uint64_t v17 = (void **)__p[0];
      }
      unint64_t v18 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v14, v15, v17, v18);
    }
    if (SBYTE7(v20) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1B76D8890(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::List<__CVBuffer *,HGCVPixelBufferPool::Descriptor,false>::log(void *a1, HGLogger *a2)
{
  if (a1[9])
  {
    HGLogger::indent(1);
    uint64_t v4 = a1[5];
    if (a1[6] != v4)
    {
      unint64_t v5 = a1[8];
      uint64_t v6 = (void *)(v4 + 8 * (v5 >> 6));
      unsigned __int8 v7 = (long long *)(*v6 + ((v5 & 0x3F) << 6));
      uint64_t v8 = *(void *)(v4 + (((a1[9] + v5) >> 3) & 0x1FFFFFFFFFFFFFF8)) + (((a1[9] + v5) & 0x3F) << 6);
      while (v7 != (long long *)v8)
      {
        long long v9 = *v7;
        long long v10 = v7[1];
        long long v11 = v7[3];
        long long v21 = v7[2];
        long long v22 = v11;
        *(_OWORD *)long long __p = v9;
        long long v20 = v10;
        HGPool::EntryLog<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::log((uint64_t)__p, a2, (const char *)3);
        v7 += 4;
        if ((long long *)((char *)v7 - *v6) == (long long *)4096)
        {
          uint64_t v12 = (long long *)v6[1];
          ++v6;
          unsigned __int8 v7 = v12;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    std::string::size_type v13 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v13);
    unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
    if (v16)
    {
      if ((SBYTE7(v20) & 0x80u) == 0) {
        uint64_t v17 = __p;
      }
      else {
        uint64_t v17 = (void **)__p[0];
      }
      unint64_t v18 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v14, v15, v17, v18);
    }
    if (SBYTE7(v20) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1B76D89FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGCVBitmap::~HGCVBitmap(HGBitmap *this, void *a2)
{
  *(void *)this = &unk_1F10C5240;
  uint64_t v3 = *((void *)this + 16);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGBitmap::~HGBitmap(this, a2);
}

{
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10C5240;
  uint64_t v3 = *((void *)this + 16);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGBitmap::~HGBitmap(this, a2);

  HGObject::operator delete(v4);
}

HGCVPixelBuffer *HGCVBitmap::_create@<X0>(HGCVPixelBuffer **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, size_t a5@<X4>, void *a6@<X8>)
{
  *a6 = 0;
  long long v9 = *a1;
  if (v9)
  {
    size_t v10 = a5;
    int v13 = HGCVPixelBuffer::rowBytes(v9, a5);
    uint64_t v14 = HGObject::operator new(0x90uLL);
    HGBitmap::HGBitmap((uint64_t)v14, a2, a3, a4, 0, v13);
    *uint64_t v14 = &unk_1F10C5240;
    uint64_t result = *a1;
    v14[16] = *a1;
    if (result) {
      uint64_t result = (HGCVPixelBuffer *)(*(uint64_t (**)(HGCVPixelBuffer *))(*(void *)result + 16))(result);
    }
  }
  else
  {
    uint64_t v14 = HGObject::operator new(0x90uLL);
    HGBitmap::HGBitmap((uint64_t)v14, 0, 0, a4, 0, 0);
    *uint64_t v14 = &unk_1F10C5240;
    uint64_t result = *a1;
    v14[16] = *a1;
    if (result) {
      uint64_t result = (HGCVPixelBuffer *)(*(uint64_t (**)(HGCVPixelBuffer *))(*(void *)result + 16))(result);
    }
    size_t v10 = 0;
  }
  v14[17] = v10;
  *((_DWORD *)v14 + 3) |= 1u;
  *a6 = v14;
  return result;
}

void sub_1B76D8C80(_Unwind_Exception *a1, void *a2)
{
  HGBitmap::~HGBitmap(v2, a2);
  HGObject::operator delete(v4);
  _Unwind_Resume(a1);
}

void sub_1B76D8CB0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGCVPixelBuffer *HGCVBitmap::create@<X0>(HGCVPixelBuffer *a1@<X0>, int a2@<W1>, size_t a3@<X2>, void *a4@<X8>)
{
  HGCVPixelBuffer::create(a1, (HGObject **)&v13);
  if (v13)
  {
    unsigned int v7 = HGCVPixelBuffer::w(v13, a3);
    unsigned int v8 = HGCVPixelBuffer::h(v13, a3);
    uint64_t v9 = HGRectMake4i(0, 0, v7, v8);
    uint64_t v11 = v10;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v11 = 0;
  }
  HGCVBitmap::_create(&v13, v9, v11, a2, a3, a4);
  uint64_t result = v13;
  if (v13) {
    return (HGCVPixelBuffer *)(*(uint64_t (**)(HGCVPixelBuffer *))(*(void *)v13 + 24))(v13);
  }
  return result;
}

void sub_1B76D8D98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

HGCVPixelBuffer *HGCVBitmap::create@<X0>(HGCVPixelBuffer **a1@<X0>, int a2@<W1>, size_t a3@<X2>, void *a4@<X8>)
{
  unsigned int v8 = *a1;
  if (v8)
  {
    unsigned int v9 = HGCVPixelBuffer::w(v8, a3);
    unsigned int v10 = HGCVPixelBuffer::h(*a1, a3);
    uint64_t v11 = HGRectMake4i(0, 0, v9, v10);
    uint64_t v13 = v12;
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v13 = 0;
  }

  return HGCVBitmap::_create(a1, v11, v13, a2, a3, a4);
}

HGCVPixelBuffer *HGCVBitmap::create@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, void *a4@<X8>)
{
  uint64_t v15 = a1;
  uint64_t v16 = a2;
  unint64_t v6 = HGFormatUtils::collapseRectForFormat(&v15, a3);
  unsigned int v8 = (HGCVPixelBuffer *)(v7 - v6);
  size_t v10 = (v9 - HIDWORD(v6));
  OSType v11 = HGCV::CVPixelFormatForHGFormat(a3);
  BOOL v12 = HGCV::AllowPixelSizeCastingForHGFormat(a3);
  HGCVPixelBuffer::create(v8, v10, v11, v12, (HGObject **)&v14);
  HGCVBitmap::_create(&v14, v15, v16, a3, 0, a4);
  uint64_t result = v14;
  if (v14) {
    return (HGCVPixelBuffer *)(*(uint64_t (**)(HGCVPixelBuffer *))(*(void *)v14 + 24))(v14);
  }
  return result;
}

void sub_1B76D8F54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

HGCVPixelBuffer *HGCVBitmap::create@<X0>(const char **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  uint64_t v17 = a2;
  uint64_t v18 = a3;
  unint64_t v8 = HGFormatUtils::collapseRectForFormat(&v17, a4);
  size_t v10 = (_anonymous_namespace_ *)(v9 - v8);
  BOOL v12 = (char *)(v11 - HIDWORD(v8));
  OSType v13 = HGCV::CVPixelFormatForHGFormat(a4);
  char v14 = HGCV::AllowPixelSizeCastingForHGFormat(a4);
  HGCVPixelBuffer::create(v10, a1, v12, v13, v14, (HGObject **)&v16);
  HGCVBitmap::_create(&v16, v17, v18, a4, 0, a5);
  uint64_t result = v16;
  if (v16) {
    return (HGCVPixelBuffer *)(*(uint64_t (**)(HGCVPixelBuffer *))(*(void *)v16 + 24))(v16);
  }
  return result;
}

void sub_1B76D906C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL HGCVBitmap::lock(HGCVBitmap *this, CVPixelBufferLockFlags a2)
{
  BOOL v3 = HGCVPixelBuffer::lock(*((HGCVPixelBuffer **)this + 16), a2);
  if (v3)
  {
    uint64_t v4 = HGCVPixelBuffer::ptr(*((HGCVPixelBuffer **)this + 16), *((void *)this + 17));
    if (v4 == *((void **)this + 10)) {
      return v3;
    }
    goto LABEL_5;
  }
  uint64_t v4 = 0;
  if (*((void *)this + 10)) {
LABEL_5:
  }
    *((void *)this + 10) = v4;
  return v3;
}

BOOL HGCVBitmap::unlock(HGCVBitmap *this, CVPixelBufferLockFlags a2)
{
  BOOL v3 = HGCVPixelBuffer::unlock(*((HGCVPixelBuffer **)this + 16), a2);
  if (v3)
  {
    uint64_t v4 = HGCVPixelBuffer::ptr(*((HGCVPixelBuffer **)this + 16), *((void *)this + 17));
    if (v4 == *((void **)this + 10)) {
      return v3;
    }
    goto LABEL_5;
  }
  uint64_t v4 = 0;
  if (*((void *)this + 10)) {
LABEL_5:
  }
    *((void *)this + 10) = v4;
  return v3;
}

void *HGCVBitmap::getCVBitmapStorage(HGBitmap *this, HGBitmap *a2)
{
  unint64_t v3 = 0;
  while (v3 | (unint64_t)this)
  {
    if (v3)
    {
      this = 0;
      uint64_t v4 = *(void **)(v3 + 16);
      unint64_t v3 = 0;
    }
    else if (this)
    {
      Storage = (const void *)HGBitmap::GetStorage(this);
      if (Storage)
      {
        unint64_t v6 = (const void *)HGBitmap::GetStorage(this);
        if (!v6) {
          goto LABEL_12;
        }
      }
      else
      {
        unint64_t v3 = 0;
        unint64_t v6 = (const void *)HGBitmap::GetStorage(this);
        if (!v6)
        {
LABEL_12:
          this = 0;
          goto LABEL_3;
        }
      }
    }
    else
    {
      unint64_t v3 = 0;
      uint64_t v4 = 0;
    }
LABEL_3:
    if (v4) {
      return v4;
    }
  }
  return 0;
}

void HGeometryData::HGeometryData(HGeometryData *this, HGRasterizer *a2)
{
  *(void *)this = 0;
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  *((_DWORD *)this + 3) = 34;
  HGArrayDataRef::allocate(this);
}

void sub_1B76D955C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _Unwind_Exception *a11)
{
  if (*v13)
  {
    HGeometryData::HGeometryData(*v13);
    a1 = a11;
  }
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(v12);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(v14);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(v11);
  _Unwind_Resume(a1);
}

uint64_t *HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1 && atomic_fetch_add((atomic_uint *volatile)v2, 0xFFFFFFFF) == 1)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3) {
      MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v2, 0x1080C4098BBCF0FLL);
  }
  return a1;
}

double HGeometryData::operator=(atomic_uint **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = *(atomic_uint **)a2;
  if (*a1 != *(atomic_uint **)a2)
  {
    if (v4)
    {
      if (atomic_fetch_add(v4, 0xFFFFFFFF) == 1)
      {
        uint64_t v6 = *((void *)v4 + 2);
        if (v6) {
          MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v4, 0x1080C4098BBCF0FLL);
      }
      unint64_t v5 = *(atomic_uint **)a2;
    }
    *a1 = v5;
    if (v5) {
      atomic_fetch_add(v5, 1u);
    }
  }
  a1[1] = *(atomic_uint **)(a2 + 8);
  int v7 = a1[2];
  unint64_t v8 = *(atomic_uint **)(a2 + 16);
  if (v7 != v8)
  {
    if (v7)
    {
      if (atomic_fetch_add(v7, 0xFFFFFFFF) == 1)
      {
        uint64_t v9 = *((void *)v7 + 2);
        if (v9) {
          MEMORY[0x1BA9BFB70](v9, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v7, 0x1080C4098BBCF0FLL);
      }
      unint64_t v8 = *(atomic_uint **)(a2 + 16);
    }
    a1[2] = v8;
    if (v8) {
      atomic_fetch_add(v8, 1u);
    }
  }
  a1[3] = *(atomic_uint **)(a2 + 24);
  size_t v10 = a1[4];
  int v11 = *(atomic_uint **)(a2 + 32);
  if (v10 != v11)
  {
    if (v10)
    {
      if (atomic_fetch_add(v10, 0xFFFFFFFF) == 1)
      {
        uint64_t v12 = *((void *)v10 + 2);
        if (v12) {
          MEMORY[0x1BA9BFB70](v12, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v10, 0x1080C4098BBCF0FLL);
      }
      int v11 = *(atomic_uint **)(a2 + 32);
    }
    a1[4] = v11;
    if (v11) {
      atomic_fetch_add(v11, 1u);
    }
  }
  a1[5] = *(atomic_uint **)(a2 + 40);
  OSType v13 = a1[6];
  char v14 = *(atomic_uint **)(a2 + 48);
  if (v13 != v14)
  {
    if (v13)
    {
      if (atomic_fetch_add(v13, 0xFFFFFFFF) == 1)
      {
        uint64_t v15 = *((void *)v13 + 2);
        if (v15) {
          MEMORY[0x1BA9BFB70](v15, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v13, 0x1080C4098BBCF0FLL);
      }
      char v14 = *(atomic_uint **)(a2 + 48);
    }
    a1[6] = v14;
    if (v14) {
      atomic_fetch_add(v14, 1u);
    }
  }
  a1[7] = *(atomic_uint **)(a2 + 56);
  uint64_t v16 = a1[8];
  uint64_t v17 = *(atomic_uint **)(a2 + 64);
  if (v16 != v17)
  {
    if (v16)
    {
      if (atomic_fetch_add(v16, 0xFFFFFFFF) == 1)
      {
        uint64_t v18 = *((void *)v16 + 2);
        if (v18) {
          MEMORY[0x1BA9BFB70](v18, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v16, 0x1080C4098BBCF0FLL);
      }
      uint64_t v17 = *(atomic_uint **)(a2 + 64);
    }
    a1[8] = v17;
    if (v17) {
      atomic_fetch_add(v17, 1u);
    }
  }
  a1[9] = *(atomic_uint **)(a2 + 72);
  unsigned __int8 v19 = a1[10];
  long long v20 = *(atomic_uint **)(a2 + 80);
  if (v19 != v20)
  {
    if (v19)
    {
      if (atomic_fetch_add(v19, 0xFFFFFFFF) == 1)
      {
        uint64_t v21 = *((void *)v19 + 2);
        if (v21) {
          MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v19, 0x1080C4098BBCF0FLL);
      }
      long long v20 = *(atomic_uint **)(a2 + 80);
    }
    a1[10] = v20;
    if (v20) {
      atomic_fetch_add(v20, 1u);
    }
  }
  a1[11] = *(atomic_uint **)(a2 + 88);
  long long v22 = a1[12];
  uint64_t v23 = *(atomic_uint **)(a2 + 96);
  if (v22 != v23)
  {
    if (v22)
    {
      if (atomic_fetch_add(v22, 0xFFFFFFFF) == 1)
      {
        uint64_t v24 = *((void *)v22 + 2);
        if (v24) {
          MEMORY[0x1BA9BFB70](v24, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v22, 0x1080C4098BBCF0FLL);
      }
      uint64_t v23 = *(atomic_uint **)(a2 + 96);
    }
    a1[12] = v23;
    if (v23) {
      atomic_fetch_add(v23, 1u);
    }
  }
  a1[13] = *(atomic_uint **)(a2 + 104);
  char v25 = a1[14];
  uint64_t v26 = *(atomic_uint **)(a2 + 112);
  if (v25 != v26)
  {
    if (v25)
    {
      if (atomic_fetch_add(v25, 0xFFFFFFFF) == 1)
      {
        uint64_t v27 = *((void *)v25 + 2);
        if (v27) {
          MEMORY[0x1BA9BFB70](v27, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v25, 0x1080C4098BBCF0FLL);
      }
      uint64_t v26 = *(atomic_uint **)(a2 + 112);
    }
    a1[14] = v26;
    if (v26) {
      atomic_fetch_add(v26, 1u);
    }
  }
  a1[15] = *(atomic_uint **)(a2 + 120);
  unint64_t v28 = a1[16];
  uint64_t v29 = *(atomic_uint **)(a2 + 128);
  if (v28 != v29)
  {
    if (v28)
    {
      if (atomic_fetch_add(v28, 0xFFFFFFFF) == 1)
      {
        uint64_t v30 = *((void *)v28 + 2);
        if (v30) {
          MEMORY[0x1BA9BFB70](v30, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v28, 0x1080C4098BBCF0FLL);
      }
      uint64_t v29 = *(atomic_uint **)(a2 + 128);
    }
    a1[16] = v29;
    if (v29) {
      atomic_fetch_add(v29, 1u);
    }
  }
  a1[17] = *(atomic_uint **)(a2 + 136);
  unint64_t v31 = a1[18];
  unint64_t v32 = *(atomic_uint **)(a2 + 144);
  if (v31 != v32)
  {
    if (v31)
    {
      if (atomic_fetch_add(v31, 0xFFFFFFFF) == 1)
      {
        uint64_t v33 = *((void *)v31 + 2);
        if (v33) {
          MEMORY[0x1BA9BFB70](v33, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v31, 0x1080C4098BBCF0FLL);
      }
      unint64_t v32 = *(atomic_uint **)(a2 + 144);
    }
    a1[18] = v32;
    if (v32) {
      atomic_fetch_add(v32, 1u);
    }
  }
  a1[19] = *(atomic_uint **)(a2 + 152);
  uint64_t v34 = a1[20];
  uint64_t v35 = *(atomic_uint **)(a2 + 160);
  if (v34 != v35)
  {
    if (v34)
    {
      if (atomic_fetch_add(v34, 0xFFFFFFFF) == 1)
      {
        uint64_t v36 = *((void *)v34 + 2);
        if (v36) {
          MEMORY[0x1BA9BFB70](v36, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v34, 0x1080C4098BBCF0FLL);
      }
      uint64_t v35 = *(atomic_uint **)(a2 + 160);
    }
    a1[20] = v35;
    if (v35) {
      atomic_fetch_add(v35, 1u);
    }
  }
  a1[21] = *(atomic_uint **)(a2 + 168);
  BOOL v37 = a1[22];
  int64_t v38 = *(atomic_uint **)(a2 + 176);
  if (v37 != v38)
  {
    if (v37)
    {
      if (atomic_fetch_add(v37, 0xFFFFFFFF) == 1)
      {
        uint64_t v39 = *((void *)v37 + 2);
        if (v39) {
          MEMORY[0x1BA9BFB70](v39, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v37, 0x1080C4098BBCF0FLL);
      }
      int64_t v38 = *(atomic_uint **)(a2 + 176);
    }
    a1[22] = v38;
    if (v38) {
      atomic_fetch_add(v38, 1u);
    }
  }
  a1[23] = *(atomic_uint **)(a2 + 184);
  unint64_t v40 = a1[24];
  uint64_t v41 = *(atomic_uint **)(a2 + 192);
  if (v40 != v41)
  {
    if (v40)
    {
      if (atomic_fetch_add(v40, 0xFFFFFFFF) == 1)
      {
        uint64_t v42 = *((void *)v40 + 2);
        if (v42) {
          MEMORY[0x1BA9BFB70](v42, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v40, 0x1080C4098BBCF0FLL);
      }
      uint64_t v41 = *(atomic_uint **)(a2 + 192);
    }
    a1[24] = v41;
    if (v41) {
      atomic_fetch_add(v41, 1u);
    }
  }
  a1[25] = *(atomic_uint **)(a2 + 200);
  unint64_t v43 = a1[26];
  uint64_t v44 = *(atomic_uint **)(a2 + 208);
  if (v43 != v44)
  {
    if (v43)
    {
      if (atomic_fetch_add(v43, 0xFFFFFFFF) == 1)
      {
        uint64_t v45 = *((void *)v43 + 2);
        if (v45) {
          MEMORY[0x1BA9BFB70](v45, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v43, 0x1080C4098BBCF0FLL);
      }
      uint64_t v44 = *(atomic_uint **)(a2 + 208);
    }
    a1[26] = v44;
    if (v44) {
      atomic_fetch_add(v44, 1u);
    }
  }
  a1[27] = *(atomic_uint **)(a2 + 216);
  unint64_t v46 = a1[28];
  unint64_t v47 = *(atomic_uint **)(a2 + 224);
  if (v46 != v47)
  {
    if (v46)
    {
      if (atomic_fetch_add(v46, 0xFFFFFFFF) == 1)
      {
        uint64_t v48 = *((void *)v46 + 2);
        if (v48) {
          MEMORY[0x1BA9BFB70](v48, 0x1000C8077774924);
        }
        MEMORY[0x1BA9BFBA0](v46, 0x1080C4098BBCF0FLL);
      }
      unint64_t v47 = *(atomic_uint **)(a2 + 224);
    }
    a1[28] = v47;
    if (v47) {
      atomic_fetch_add(v47, 1u);
    }
  }
  a1[29] = *(atomic_uint **)(a2 + 232);
  *((unsigned char *)a1 + 240) = *(unsigned char *)(a2 + 240);
  *((_DWORD *)a1 + 6PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(_DWORD *)(a2 + 244);
  double result = *(double *)(a2 + 252);
  *(double *)((char *)a1 + 25PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = result;
  *((_DWORD *)a1 + 65) = *(_DWORD *)(a2 + 260);
  *((unsigned char *)a1 + 248) = *(unsigned char *)(a2 + 248);
  return result;
}

__n128 HGeometryData::CopyVertex(uint64_t a1, uint64_t a2, int *a3, int a4, char a5)
{
  *(_OWORD *)(*(void *)(*(void *)(a1 + 64) + 16)
            + *(int *)(*(void *)(a1 + 64) + 4) * (uint64_t)*a3
            + *(int *)(a1 + 7HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = *(_OWORD *)(*(void *)(*(void *)(a2 + 64) + 16)
                                             + *(int *)(*(void *)(a2 + 64) + 4) * (uint64_t)a4
                                             + *(int *)(a2 + 72));
  *(_OWORD *)(*(void *)(*(void *)(a1 + 80) + 16)
            + *(int *)(*(void *)(a1 + 80) + 4) * (uint64_t)*a3
            + *(int *)(a1 + 8pthread_cond_destroy((pthread_cond_t *)((char *)this + 8)) = *(_OWORD *)(*(void *)(*(void *)(a2 + 80) + 16)
                                             + *(int *)(*(void *)(a2 + 80) + 4) * (uint64_t)a4
                                             + *(int *)(a2 + 88));
  __n128 result = *(__n128 *)(*(void *)(*(void *)(a2 + 96) + 16)
                     + *(int *)(*(void *)(a2 + 96) + 4) * (uint64_t)a4
                     + *(int *)(a2 + 104));
  *(__n128 *)(*(void *)(*(void *)(a1 + 96) + 16)
            + *(int *)(*(void *)(a1 + 96) + 4) * (uint64_t)*a3
            + *(int *)(a1 + 104)) = result;
  if (a5)
  {
    __n128 result = *(__n128 *)(*(void *)(*(void *)(a2 + 112) + 16)
                       + *(int *)(*(void *)(a2 + 112) + 4) * (uint64_t)a4
                       + *(int *)(a2 + 120));
    *(__n128 *)(*(void *)(*(void *)(a1 + 112) + 16)
              + *(int *)(*(void *)(a1 + 112) + 4) * (uint64_t)*a3
              + *(int *)(a1 + 120)) = result;
    if ((a5 & 2) == 0)
    {
LABEL_3:
      if ((a5 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }
  else if ((a5 & 2) == 0)
  {
    goto LABEL_3;
  }
  __n128 result = *(__n128 *)(*(void *)(*(void *)(a2 + 128) + 16)
                     + *(int *)(*(void *)(a2 + 128) + 4) * (uint64_t)a4
                     + *(int *)(a2 + 136));
  *(__n128 *)(*(void *)(*(void *)(a1 + 128) + 16)
            + *(int *)(*(void *)(a1 + 128) + 4) * (uint64_t)*a3
            + *(int *)(a1 + 136)) = result;
  if ((a5 & 4) == 0)
  {
LABEL_4:
    if ((a5 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
LABEL_12:
  __n128 result = *(__n128 *)(*(void *)(*(void *)(a2 + 144) + 16)
                     + *(int *)(*(void *)(a2 + 144) + 4) * (uint64_t)a4
                     + *(int *)(a2 + 152));
  *(__n128 *)(*(void *)(*(void *)(a1 + 144) + 16)
            + *(int *)(*(void *)(a1 + 144) + 4) * (uint64_t)*a3
            + *(int *)(a1 + 15HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = result;
  if ((a5 & 8) == 0)
  {
LABEL_5:
    if ((a5 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_14;
  }
LABEL_13:
  __n128 result = *(__n128 *)(*(void *)(*(void *)(a2 + 160) + 16)
                     + *(int *)(*(void *)(a2 + 160) + 4) * (uint64_t)a4
                     + *(int *)(a2 + 168));
  *(__n128 *)(*(void *)(*(void *)(a1 + 160) + 16)
            + *(int *)(*(void *)(a1 + 160) + 4) * (uint64_t)*a3
            + *(int *)(a1 + 16pthread_cond_destroy((pthread_cond_t *)((char *)this + 8)) = result;
  if ((a5 & 0x10) == 0)
  {
LABEL_6:
    if ((a5 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_15;
  }
LABEL_14:
  __n128 result = *(__n128 *)(*(void *)(*(void *)(a2 + 176) + 16)
                     + *(int *)(*(void *)(a2 + 176) + 4) * (uint64_t)a4
                     + *(int *)(a2 + 184));
  *(__n128 *)(*(void *)(*(void *)(a1 + 176) + 16)
            + *(int *)(*(void *)(a1 + 176) + 4) * (uint64_t)*a3
            + *(int *)(a1 + 184)) = result;
  if ((a5 & 0x20) == 0)
  {
LABEL_7:
    if ((a5 & 0x40) == 0) {
      goto LABEL_8;
    }
LABEL_16:
    __n128 result = *(__n128 *)(*(void *)(*(void *)(a2 + 208) + 16)
                       + *(int *)(*(void *)(a2 + 208) + 4) * (uint64_t)a4
                       + *(int *)(a2 + 216));
    *(__n128 *)(*(void *)(*(void *)(a1 + 208) + 16)
              + *(int *)(*(void *)(a1 + 208) + 4) * (uint64_t)*a3
              + *(int *)(a1 + 2TXTextSequenceBehavior::~TXTextSequenceBehavior((TXTextSequenceBehavior *)((char *)this - 16)) = result;
    if ((a5 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_17;
  }
LABEL_15:
  __n128 result = *(__n128 *)(*(void *)(*(void *)(a2 + 192) + 16)
                     + *(int *)(*(void *)(a2 + 192) + 4) * (uint64_t)a4
                     + *(int *)(a2 + 200));
  *(__n128 *)(*(void *)(*(void *)(a1 + 192) + 16)
            + *(int *)(*(void *)(a1 + 192) + 4) * (uint64_t)*a3
            + *(int *)(a1 + 200)) = result;
  if ((a5 & 0x40) != 0) {
    goto LABEL_16;
  }
LABEL_8:
  if ((a5 & 0x80) == 0)
  {
LABEL_9:
    ++*a3;
    return result;
  }
LABEL_17:
  __n128 result = *(__n128 *)(*(void *)(*(void *)(a2 + 224) + 16)
                     + *(int *)(*(void *)(a2 + 224) + 4) * (uint64_t)a4
                     + *(int *)(a2 + 232));
  *(__n128 *)(*(void *)(*(void *)(a1 + 224) + 16)
            + *(int *)(*(void *)(a1 + 224) + 4) * (uint64_t)(*a3)++
            + *(int *)(a1 + 23HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = result;
  return result;
}

float64x2_t HGeometryData::InterpVertex(uint64_t a1, uint64_t a2, int *a3, int a4, int a5, char a6, float64x2_t result)
{
  uint64_t v7 = *(void *)(a2 + 64);
  uint64_t v8 = *(void *)(v7 + 16);
  LODWORD(v7) = *(_DWORD *)(v7 + 4);
  uint64_t v9 = *(int *)(a2 + 72);
  float32x4_t v10 = *(float32x4_t *)(v8 + (int)v7 * (uint64_t)a5 + v9);
  float32x4_t v11 = *(float32x4_t *)(v8 + (int)v7 * (uint64_t)a4 + v9);
  float64x2_t v12 = vcvtq_f64_f32(*(float32x2_t *)v10.f32);
  float64x2_t v13 = vcvt_hight_f64_f32(v10);
  *(float32x4_t *)(*(void *)(*(void *)(a1 + 64) + 16)
                 + *(int *)(*(void *)(a1 + 64) + 4) * (uint64_t)*a3
                 + *(int *)(a1 + 7HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)v11.f32), v12), result.f64[0]), v12)), vaddq_f64(vmulq_n_f64(vsubq_f64(vcvt_hight_f64_f32(v11), v13), result.f64[0]), v13));
  uint64_t v14 = *(void *)(a2 + 80);
  uint64_t v15 = *(void *)(v14 + 16);
  LODWORD(v14) = *(_DWORD *)(v14 + 4);
  uint64_t v16 = *(int *)(a2 + 88);
  float32x4_t v17 = *(float32x4_t *)(v15 + (int)v14 * (uint64_t)a5 + v16);
  float32x4_t v18 = *(float32x4_t *)(v15 + (int)v14 * (uint64_t)a4 + v16);
  float64x2_t v19 = vcvtq_f64_f32(*(float32x2_t *)v17.f32);
  float64x2_t v20 = vcvt_hight_f64_f32(v17);
  *(float32x4_t *)(*(void *)(*(void *)(a1 + 80) + 16)
                 + *(int *)(*(void *)(a1 + 80) + 4) * (uint64_t)*a3
                 + *(int *)(a1 + 8pthread_cond_destroy((pthread_cond_t *)((char *)this + 8)) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)v18.f32), v19), result.f64[0]), v19)), vaddq_f64(vmulq_n_f64(vsubq_f64(vcvt_hight_f64_f32(v18), v20), result.f64[0]), v20));
  uint64_t v21 = *(void *)(a2 + 96);
  uint64_t v22 = *(void *)(v21 + 16);
  int v23 = *(_DWORD *)(v21 + 4);
  uint64_t v24 = *(int *)(a2 + 104);
  float32x4_t v25 = *(float32x4_t *)(v22 + v23 * (uint64_t)a5 + v24);
  float32x4_t v26 = *(float32x4_t *)(v22 + v23 * (uint64_t)a4 + v24);
  float64x2_t v27 = vcvtq_f64_f32(*(float32x2_t *)v25.f32);
  float64x2_t v28 = vcvt_hight_f64_f32(v25);
  *(float32x4_t *)(*(void *)(*(void *)(a1 + 96) + 16)
                 + *(int *)(*(void *)(a1 + 96) + 4) * (uint64_t)*a3
                 + *(int *)(a1 + 104)) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)v26.f32), v27), result.f64[0]), v27)), vaddq_f64(vmulq_n_f64(vsubq_f64(vcvt_hight_f64_f32(v26), v28), result.f64[0]), v28));
  if (a6)
  {
    uint64_t v29 = *(void *)(a2 + 112);
    uint64_t v30 = *(void *)(v29 + 16);
    LODWORD(v29) = *(_DWORD *)(v29 + 4);
    uint64_t v31 = *(int *)(a2 + 120);
    float32x4_t v32 = *(float32x4_t *)(v30 + (int)v29 * (uint64_t)a5 + v31);
    float32x4_t v33 = *(float32x4_t *)(v30 + (int)v29 * (uint64_t)a4 + v31);
    float64x2_t v34 = vcvtq_f64_f32(*(float32x2_t *)v32.f32);
    float64x2_t v35 = vcvt_hight_f64_f32(v32);
    *(float32x4_t *)(*(void *)(*(void *)(a1 + 112) + 16)
                   + *(int *)(*(void *)(a1 + 112) + 4) * (uint64_t)*a3
                   + *(int *)(a1 + 120)) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)v33.f32), v34), result.f64[0]), v34)), vaddq_f64(vmulq_n_f64(vsubq_f64(vcvt_hight_f64_f32(v33), v35), result.f64[0]), v35));
    if ((a6 & 2) == 0)
    {
LABEL_3:
      if ((a6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }
  else if ((a6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t v36 = *(void *)(a2 + 128);
  uint64_t v37 = *(void *)(v36 + 16);
  LODWORD(v36) = *(_DWORD *)(v36 + 4);
  uint64_t v38 = *(int *)(a2 + 136);
  float32x4_t v39 = *(float32x4_t *)(v37 + (int)v36 * (uint64_t)a5 + v38);
  float32x4_t v40 = *(float32x4_t *)(v37 + (int)v36 * (uint64_t)a4 + v38);
  float64x2_t v41 = vcvtq_f64_f32(*(float32x2_t *)v39.f32);
  float64x2_t v42 = vcvt_hight_f64_f32(v39);
  *(float32x4_t *)(*(void *)(*(void *)(a1 + 128) + 16)
                 + *(int *)(*(void *)(a1 + 128) + 4) * (uint64_t)*a3
                 + *(int *)(a1 + 136)) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)v40.f32), v41), result.f64[0]), v41)), vaddq_f64(vmulq_n_f64(vsubq_f64(vcvt_hight_f64_f32(v40), v42), result.f64[0]), v42));
  if ((a6 & 4) == 0)
  {
LABEL_4:
    if ((a6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v43 = *(void *)(a2 + 144);
  uint64_t v44 = *(void *)(v43 + 16);
  LODWORD(v43) = *(_DWORD *)(v43 + 4);
  uint64_t v45 = *(int *)(a2 + 152);
  float32x4_t v46 = *(float32x4_t *)(v44 + (int)v43 * (uint64_t)a5 + v45);
  float32x4_t v47 = *(float32x4_t *)(v44 + (int)v43 * (uint64_t)a4 + v45);
  float64x2_t v48 = vcvtq_f64_f32(*(float32x2_t *)v46.f32);
  float64x2_t v49 = vcvt_hight_f64_f32(v46);
  *(float32x4_t *)(*(void *)(*(void *)(a1 + 144) + 16)
                 + *(int *)(*(void *)(a1 + 144) + 4) * (uint64_t)*a3
                 + *(int *)(a1 + 15HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)v47.f32), v48), result.f64[0]), v48)), vaddq_f64(vmulq_n_f64(vsubq_f64(vcvt_hight_f64_f32(v47), v49), result.f64[0]), v49));
  if ((a6 & 8) == 0)
  {
LABEL_5:
    if ((a6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_14;
  }
LABEL_13:
  uint64_t v50 = *(void *)(a2 + 160);
  uint64_t v51 = *(void *)(v50 + 16);
  LODWORD(v50) = *(_DWORD *)(v50 + 4);
  uint64_t v52 = *(int *)(a2 + 168);
  float32x4_t v53 = *(float32x4_t *)(v51 + (int)v50 * (uint64_t)a5 + v52);
  float32x4_t v54 = *(float32x4_t *)(v51 + (int)v50 * (uint64_t)a4 + v52);
  float64x2_t v55 = vcvtq_f64_f32(*(float32x2_t *)v53.f32);
  float64x2_t v56 = vcvt_hight_f64_f32(v53);
  *(float32x4_t *)(*(void *)(*(void *)(a1 + 160) + 16)
                 + *(int *)(*(void *)(a1 + 160) + 4) * (uint64_t)*a3
                 + *(int *)(a1 + 16pthread_cond_destroy((pthread_cond_t *)((char *)this + 8)) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)v54.f32), v55), result.f64[0]), v55)), vaddq_f64(vmulq_n_f64(vsubq_f64(vcvt_hight_f64_f32(v54), v56), result.f64[0]), v56));
  if ((a6 & 0x10) == 0)
  {
LABEL_6:
    if ((a6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_15;
  }
LABEL_14:
  uint64_t v57 = *(void *)(a2 + 176);
  uint64_t v58 = *(void *)(v57 + 16);
  LODWORD(v57) = *(_DWORD *)(v57 + 4);
  uint64_t v59 = *(int *)(a2 + 184);
  float32x4_t v60 = *(float32x4_t *)(v58 + (int)v57 * (uint64_t)a5 + v59);
  float32x4_t v61 = *(float32x4_t *)(v58 + (int)v57 * (uint64_t)a4 + v59);
  float64x2_t v62 = vcvtq_f64_f32(*(float32x2_t *)v60.f32);
  float64x2_t v63 = vcvt_hight_f64_f32(v60);
  *(float32x4_t *)(*(void *)(*(void *)(a1 + 176) + 16)
                 + *(int *)(*(void *)(a1 + 176) + 4) * (uint64_t)*a3
                 + *(int *)(a1 + 184)) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)v61.f32), v62), result.f64[0]), v62)), vaddq_f64(vmulq_n_f64(vsubq_f64(vcvt_hight_f64_f32(v61), v63), result.f64[0]), v63));
  if ((a6 & 0x20) == 0)
  {
LABEL_7:
    if ((a6 & 0x40) == 0) {
      goto LABEL_8;
    }
LABEL_16:
    uint64_t v71 = *(void *)(a2 + 208);
    uint64_t v72 = *(void *)(v71 + 16);
    LODWORD(v7PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(_DWORD *)(v71 + 4);
    uint64_t v73 = *(int *)(a2 + 216);
    float32x4_t v74 = *(float32x4_t *)(v72 + (int)v71 * (uint64_t)a5 + v73);
    float32x4_t v75 = *(float32x4_t *)(v72 + (int)v71 * (uint64_t)a4 + v73);
    float64x2_t v76 = vcvtq_f64_f32(*(float32x2_t *)v74.f32);
    float64x2_t v77 = vcvt_hight_f64_f32(v74);
    *(float32x4_t *)(*(void *)(*(void *)(a1 + 208) + 16)
                   + *(int *)(*(void *)(a1 + 208) + 4) * (uint64_t)*a3
                   + *(int *)(a1 + 2TXTextSequenceBehavior::~TXTextSequenceBehavior((TXTextSequenceBehavior *)((char *)this - 16)) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)v75.f32), v76), result.f64[0]), v76)), vaddq_f64(vmulq_n_f64(vsubq_f64(vcvt_hight_f64_f32(v75), v77), result.f64[0]), v77));
    if ((a6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_17;
  }
LABEL_15:
  uint64_t v64 = *(void *)(a2 + 192);
  uint64_t v65 = *(void *)(v64 + 16);
  LODWORD(v64) = *(_DWORD *)(v64 + 4);
  uint64_t v66 = *(int *)(a2 + 200);
  float32x4_t v67 = *(float32x4_t *)(v65 + (int)v64 * (uint64_t)a5 + v66);
  float32x4_t v68 = *(float32x4_t *)(v65 + (int)v64 * (uint64_t)a4 + v66);
  float64x2_t v69 = vcvtq_f64_f32(*(float32x2_t *)v67.f32);
  float64x2_t v70 = vcvt_hight_f64_f32(v67);
  *(float32x4_t *)(*(void *)(*(void *)(a1 + 192) + 16)
                 + *(int *)(*(void *)(a1 + 192) + 4) * (uint64_t)*a3
                 + *(int *)(a1 + 200)) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)v68.f32), v69), result.f64[0]), v69)), vaddq_f64(vmulq_n_f64(vsubq_f64(vcvt_hight_f64_f32(v68), v70), result.f64[0]), v70));
  if ((a6 & 0x40) != 0) {
    goto LABEL_16;
  }
LABEL_8:
  if ((a6 & 0x80) == 0)
  {
LABEL_9:
    ++*a3;
    return result;
  }
LABEL_17:
  uint64_t v78 = *(void *)(a2 + 224);
  uint64_t v79 = *(void *)(v78 + 16);
  LODWORD(v78) = *(_DWORD *)(v78 + 4);
  uint64_t v80 = *(int *)(a2 + 232);
  float32x4_t v81 = *(float32x4_t *)(v79 + (int)v78 * (uint64_t)a5 + v80);
  float32x4_t v82 = *(float32x4_t *)(v79 + (int)v78 * (uint64_t)a4 + v80);
  float64x2_t v83 = vcvtq_f64_f32(*(float32x2_t *)v81.f32);
  float64x2_t v84 = vcvt_hight_f64_f32(v81);
  float64x2_t v85 = vmulq_n_f64(vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)v82.f32), v83), result.f64[0]);
  __n128 result = vaddq_f64(vmulq_n_f64(vsubq_f64(vcvt_hight_f64_f32(v82), v84), result.f64[0]), v84);
  *(float32x4_t *)(*(void *)(*(void *)(a1 + 224) + 16)
                 + *(int *)(*(void *)(a1 + 224) + 4) * (uint64_t)(*a3)++
                 + *(int *)(a1 + 23HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(v85, v83)), result);
  return result;
}

void HGeometryData::ClipToEdge(int a1, int a2, uint64_t a3, int a4, uint64_t a5, int *a6, char a7, float a8)
{
  *a6 = 0;
  float64x2_t v30 = *(float64x2_t *)(*(void *)(*(void *)(a3 + 80) + 16) + *(int *)(a3 + 88));
  if ((a4 - 1) <= 0xFFFFFFFD)
  {
    int v14 = 0;
    char v15 = a1 ^ 1;
    double v16 = a8;
    int v17 = -a4;
    int v18 = 1;
    uint64_t v19 = 4 * a2;
    do
    {
      int v20 = v14;
      if (v17 + v18) {
        int v14 = v18;
      }
      else {
        int v14 = 0;
      }
      float64x2_t v22 = *(float64x2_t *)(*(void *)(*(void *)(a3 + 80) + 16)
                           + *(int *)(*(void *)(a3 + 80) + 4) * (uint64_t)v14
                           + *(int *)(a3 + 88));
      float64x2_t v29 = v22;
      float v21 = *(float *)((char *)v30.f64 + v19);
      LODWORD(v22.f64[0]) = *(_DWORD *)((char *)v29.f64 + v19);
      if (*(float *)v22.f64 < a8) {
        int v23 = 1;
      }
      else {
        int v23 = a1;
      }
      if ((v23 & 1) != 0 || v21 < a8)
      {
        char v24 = *(float *)v22.f64 > a8 ? 1 : v15;
        if ((v24 & 1) != 0 || v21 > a8)
        {
          if ((a1 & 1) == 0 && (*(float *)v22.f64 < a8 ? (BOOL v25 = v21 < a8) : (BOOL v25 = 1), !v25)
            || (*(float *)v22.f64 <= a8 ? (char v26 = 1) : (char v26 = v15), (v26 & 1) == 0 && v21 <= a8))
          {
            v22.f64[0] = (v16 - v21) / (*(float *)v22.f64 - v21);
            HGeometryData::InterpVertex(a5, a3, a6, v14, v20, a7, v22);
            goto LABEL_5;
          }
          if (v21 >= a8) {
            int v27 = 1;
          }
          else {
            int v27 = v23;
          }
          if (v21 <= a8) {
            char v28 = 1;
          }
          else {
            char v28 = v24;
          }
          if (v27 == 1 && (v28 & 1) != 0) {
            goto LABEL_5;
          }
          v22.f64[0] = (v16 - v21) / (*(float *)v22.f64 - v21);
          HGeometryData::InterpVertex(a5, a3, a6, v14, v20, a7, v22);
        }
      }
      HGeometryData::CopyVertex(a5, a3, a6, v14, a7);
LABEL_5:
      float64x2_t v30 = v29;
      ++v18;
    }
    while (v17 + v18 != 1);
  }
}

void HGeometryData::ClipPoly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  int v7 = a6;
  v6[0] = 0;
  v6[1] = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)v6);
}

void sub_1B76DB5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B76DB608(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, atomic_uint *a20)
{
  if (a20)
  {
    HGeometryData::HGeometryData(a20);
    exception_object = *(_Unwind_Exception **)(v20 - 96);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B76DB630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B76DB644(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B76DB658(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B76DB66C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t HGeometryData::GetValidPolygons(uint64_t this, HGArrayDataRef *a2, uint64_t a3, uint64_t a4, int *a5, unsigned int a6, int a7)
{
  unsigned int v7 = a6;
  float32x4_t v10 = (HGArrayDataRef *)this;
  *(void *)&v25.var0 = a3;
  *(void *)&v25.var2 = a4;
  if (a7 == -1)
  {
    if (*(void *)a5)
    {
      unsigned int v12 = *(_DWORD *)(*(void *)a5 + 8);
      uint64_t v15 = *(void *)this;
      if (!*(void *)this) {
        goto LABEL_31;
      }
    }
    else
    {
      unsigned int v12 = 0;
      uint64_t v15 = *(void *)this;
      if (!*(void *)this)
      {
LABEL_31:
        uint64_t v20 = *(void *)a2;
        if (*(void *)a2 && *(int *)(v20 + 12) <= -2)
        {
          int v21 = *(_DWORD *)(v20 + 4);
          *(_DWORD *)(v20 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = -1;
          if (v21) {
            operator new[]();
          }
          uint64_t v22 = *(void *)(v20 + 16);
          if (v22) {
            this = MEMORY[0x1BA9BFB70](v22, 0x1000C8077774924);
          }
          *(void *)(v20 + 16) = 0;
        }
LABEL_38:
        if (v12 <= v7) {
          return this;
        }
        goto LABEL_41;
      }
    }
    if (*(int *)(v15 + 12) <= -2)
    {
      int v18 = *(_DWORD *)(v15 + 4);
      *(_DWORD *)(v15 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = -1;
      if (v18) {
        operator new[]();
      }
      uint64_t v19 = *(void *)(v15 + 16);
      if (v19) {
        this = MEMORY[0x1BA9BFB70](v19, 0x1000C8077774924);
      }
      *(void *)(v15 + 16) = 0;
    }
    goto LABEL_31;
  }
  unsigned int v12 = a7 + a6;
  uint64_t v13 = *(void *)this;
  if (*(void *)this)
  {
    if (*(_DWORD *)(v13 + 12) < a7)
    {
      int v14 = *(_DWORD *)(v13 + 4) * a7;
      *(_DWORD *)(v13 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a7;
      if (v14) {
        operator new[]();
      }
      this = *(void *)(v13 + 16);
      if (this) {
        this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
      }
      *(void *)(v13 + 16) = 0;
      uint64_t v16 = *(void *)a2;
      if (!*(void *)a2) {
        goto LABEL_22;
      }
      goto LABEL_12;
    }
  }
  else if (a7 > 0)
  {
    HGArrayDataRef::allocate((HGArrayDataRef *)this);
  }
  uint64_t v16 = *(void *)a2;
  if (!*(void *)a2)
  {
LABEL_22:
    if (a7 > 0) {
      HGArrayDataRef::allocate(a2);
    }
    goto LABEL_38;
  }
LABEL_12:
  if (*(_DWORD *)(v16 + 12) >= a7) {
    goto LABEL_38;
  }
  int v17 = *(_DWORD *)(v16 + 4) * a7;
  *(_DWORD *)(v16 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a7;
  if (v17) {
    operator new[]();
  }
  this = *(void *)(v16 + 16);
  if (this) {
    this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
  }
  *(void *)(v16 + 16) = 0;
  if (v12 > v7)
  {
    do
    {
LABEL_41:
      int v23 = (uint64_t *)(*(void *)(*(void *)a5 + 16) + *(int *)(*(void *)a5 + 4) * (uint64_t)(int)v7 + a5[2]);
      this = HGRectExcludesRect(*(uint64_t *)&v25.var0, *(uint64_t *)&v25.var2, *v23, v23[1]);
      if (!this)
      {
        *(_DWORD *)HGArray<int,(HGFormat)34>::append(v10) = v7;
        BOOL v24 = !HGRect::ContainsRect(&v25, *(HGRect *)(*(void *)(*(void *)a5 + 16) + *(int *)(*(void *)a5 + 4) * (uint64_t)(int)v7 + a5[2]));
        this = HGArray<BOOL,(HGFormat)0>::append(a2);
        *(unsigned char *)this = v24;
      }
      ++v7;
    }
    while (v12 != v7);
  }
  return this;
}

void HGeometryData::ClipPolygons()
{
  v0[0] = 0;
  v0[1] = 0x2200000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)v0);
}

void sub_1B76DCB24(_Unwind_Exception *a1)
{
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v1 - 120));
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v1 - 104));
  _Unwind_Resume(a1);
}

uint64_t HGeometryData::AllocArrays(uint64_t this, unsigned int a2, unsigned int a3)
{
  unsigned int v3 = *(_DWORD *)(this + 260);
  if (v3 >= a2) {
    return this;
  }
  uint64_t v5 = this;
  if (v3)
  {
    LODWORD(v6) = 2 * v3;
LABEL_5:
    unsigned int v7 = (HGArrayDataRef *)(this + 64);
    uint64_t v8 = *(void *)(v5 + 64);
    *(_DWORD *)(v5 + 260) = v6;
    if (v8) {
      goto LABEL_6;
    }
    if ((int)v6 <= 0) {
      goto LABEL_11;
    }
LABEL_10:
    HGArrayDataRef::allocate(v7);
  }
  uint64_t v6 = *(void *)(this + 272);
  if (v6) {
    goto LABEL_5;
  }
  unsigned int v7 = (HGArrayDataRef *)(this + 64);
  uint64_t v8 = *(void *)(v5 + 64);
  LODWORD(v6) = 256;
  *(_DWORD *)(v5 + 260) = 256;
  if (!v8) {
    goto LABEL_10;
  }
LABEL_6:
  if (*(_DWORD *)(v8 + 12) < (int)v6)
  {
    int v9 = *(_DWORD *)(v8 + 4) * v6;
    *(_DWORD *)(v8 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v6;
    if (v9) {
      operator new[]();
    }
    uint64_t v14 = *(void *)(v8 + 16);
    if (v14) {
      MEMORY[0x1BA9BFB70](v14, 0x1000C8077774924);
    }
    *(void *)(v8 + 16) = 0;
    float32x4_t v10 = (HGArrayDataRef *)(v5 + 80);
    uint64_t v11 = *(void *)(v5 + 80);
    int v12 = *(_DWORD *)(v5 + 260);
    if (!v11) {
      goto LABEL_20;
    }
LABEL_12:
    if (*(_DWORD *)(v11 + 12) < v12)
    {
      int v13 = *(_DWORD *)(v11 + 4) * v12;
      *(_DWORD *)(v11 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v12;
      if (v13) {
        operator new[]();
      }
      uint64_t v15 = *(void *)(v11 + 16);
      if (v15) {
        MEMORY[0x1BA9BFB70](v15, 0x1000C8077774924);
      }
      *(void *)(v11 + 16) = 0;
    }
    int v12 = *(_DWORD *)(v5 + 260);
    goto LABEL_26;
  }
LABEL_11:
  float32x4_t v10 = (HGArrayDataRef *)(v5 + 80);
  uint64_t v11 = *(void *)(v5 + 80);
  int v12 = *(_DWORD *)(v5 + 260);
  if (v11) {
    goto LABEL_12;
  }
LABEL_20:
  if (v12 >= 1) {
    HGArrayDataRef::allocate(v10);
  }
LABEL_26:
  this = v5 + 96;
  uint64_t v16 = *(void *)(v5 + 96);
  if (v16)
  {
    if (*(_DWORD *)(v16 + 12) < v12)
    {
      int v17 = *(_DWORD *)(v16 + 4) * v12;
      *(_DWORD *)(v16 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v12;
      if (v17) {
        operator new[]();
      }
      this = *(void *)(v16 + 16);
      if (this) {
        this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
      }
      *(void *)(v16 + 16) = 0;
    }
  }
  else if (v12 >= 1)
  {
    HGArrayDataRef::allocate((HGArrayDataRef *)this);
  }
  uint64_t v18 = 0;
  uint64_t v19 = (HGArrayDataRef *)(v5 + 112);
  do
  {
    if ((a3 >> v18))
    {
      int v20 = *(_DWORD *)(v5 + 260);
      uint64_t v21 = *(void *)v19;
      if (*(void *)v19)
      {
        if (*(_DWORD *)(v21 + 12) < v20)
        {
          int v22 = *(_DWORD *)(v21 + 4) * v20;
          *(_DWORD *)(v21 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v20;
          if (v22) {
            operator new[]();
          }
          this = *(void *)(v21 + 16);
          if (this) {
            this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
          }
          *(void *)(v21 + 16) = 0;
        }
      }
      else if (v20 > 0)
      {
        HGArrayDataRef::allocate(v19);
      }
    }
    ++v18;
    uint64_t v19 = (HGArrayDataRef *)((char *)v19 + 16);
  }
  while (v18 != 8);
  return this;
}

void HGeometryData::ClipPolyW(HGRasterizer **this, unsigned int a2, HGeometryData *a3)
{
  HGeometryData::HGeometryData((HGeometryData *)v3, this[33]);
}

void sub_1B76DDCC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
}

uint64_t HGeometryData::SizeIndexArrays(uint64_t this, unsigned int a2, int a3)
{
  uint64_t v5 = this;
  uint64_t v6 = (HGArrayDataRef *)(this + 48);
  uint64_t v7 = *(void *)(this + 48);
  if (v7)
  {
    unsigned int v8 = *(_DWORD *)(this + 252);
    if (*(_DWORD *)(v7 + 8) + a2 <= v8) {
      goto LABEL_25;
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)(this + 252);
    if (a2 <= v8) {
      goto LABEL_25;
    }
  }
  int v9 = 2 * v8;
  if (2 * v8 <= v8 + a2) {
    int v9 = v8 + a2;
  }
  if (v8) {
    int v10 = v9;
  }
  else {
    int v10 = a2;
  }
  *(_DWORD *)(this + 25PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v10;
  if (v7)
  {
    if (*(_DWORD *)(v7 + 12) < v10)
    {
      int v11 = *(_DWORD *)(v7 + 4) * v10;
      *(_DWORD *)(v7 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v10;
      if (v11) {
        operator new[]();
      }
      this = *(void *)(v7 + 16);
      if (this) {
        this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
      }
      *(void *)(v7 + 16) = 0;
      int v10 = *(_DWORD *)(v5 + 252);
    }
  }
  else if (v10 > 0)
  {
    HGArrayDataRef::allocate((HGArrayDataRef *)(this + 48));
  }
  uint64_t v12 = *(void *)v5;
  if (!*(void *)v5)
  {
    if (v10 > 0) {
      HGArrayDataRef::allocate((HGArrayDataRef *)v5);
    }
LABEL_25:
    uint64_t v14 = (HGArrayDataRef *)(v5 + 16);
    uint64_t v15 = *(void *)(v5 + 16);
    if (v15) {
      goto LABEL_26;
    }
    goto LABEL_31;
  }
  if (*(_DWORD *)(v12 + 12) >= v10) {
    goto LABEL_25;
  }
  int v13 = *(_DWORD *)(v12 + 4) * v10;
  *(_DWORD *)(v12 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v10;
  if (v13) {
    operator new[]();
  }
  this = *(void *)(v12 + 16);
  if (this) {
    this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
  }
  *(void *)(v12 + 16) = 0;
  uint64_t v14 = (HGArrayDataRef *)(v5 + 16);
  uint64_t v15 = *(void *)(v5 + 16);
  if (v15)
  {
LABEL_26:
    unsigned int v16 = *(_DWORD *)(v5 + 256);
    if (*(_DWORD *)(v15 + 8) + a3 <= v16) {
      goto LABEL_43;
    }
    goto LABEL_32;
  }
LABEL_31:
  unsigned int v16 = *(_DWORD *)(v5 + 256);
  if (a3 <= v16) {
    goto LABEL_43;
  }
LABEL_32:
  int v17 = 2 * v16;
  if (2 * v16 <= v16 + a3) {
    int v17 = v16 + a3;
  }
  if (v16) {
    int v18 = v17;
  }
  else {
    int v18 = a3;
  }
  *(_DWORD *)(v5 + 256) = v18;
  if (v15)
  {
    if (*(_DWORD *)(v15 + 12) < v18)
    {
      int v19 = *(_DWORD *)(v15 + 4) * v18;
      *(_DWORD *)(v15 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v18;
      if (v19) {
        operator new[]();
      }
      this = *(void *)(v15 + 16);
      if (this) {
        this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
      }
      *(void *)(v15 + 16) = 0;
      int v20 = *(_DWORD *)(v5 + 244) + a2;
      *(_DWORD *)(v5 + 244) = v20;
      uint64_t v21 = *(void *)(v5 + 16);
      if (v21) {
        goto LABEL_44;
      }
      goto LABEL_54;
    }
  }
  else if (v18 > 0)
  {
    HGArrayDataRef::allocate(v14);
  }
LABEL_43:
  int v20 = *(_DWORD *)(v5 + 244) + a2;
  *(_DWORD *)(v5 + 244) = v20;
  uint64_t v21 = *(void *)(v5 + 16);
  if (v21)
  {
LABEL_44:
    int v22 = *(_DWORD *)(v21 + 8) + a3;
    if (*(_DWORD *)(v21 + 12) < v22)
    {
      int v23 = *(_DWORD *)(v21 + 4) * v22;
      *(_DWORD *)(v21 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v22;
      if (v23) {
        operator new[]();
      }
      this = *(void *)(v21 + 16);
      if (this) {
        this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
      }
      *(void *)(v21 + 16) = 0;
    }
    *(_DWORD *)(v21 + 8) = v22;
    int v20 = *(_DWORD *)(v5 + 244);
    goto LABEL_56;
  }
LABEL_54:
  if (a3 > 0) {
    HGArrayDataRef::allocate(v14);
  }
LABEL_56:
  uint64_t v24 = *(void *)v6;
  if (*(void *)v6)
  {
    if (*(_DWORD *)(v24 + 12) < v20)
    {
      int v25 = *(_DWORD *)(v24 + 4) * v20;
      *(_DWORD *)(v24 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v20;
      if (v25) {
        operator new[]();
      }
      this = *(void *)(v24 + 16);
      if (this) {
        this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
      }
      *(void *)(v24 + 16) = 0;
    }
    *(_DWORD *)(v24 + 8) = v20;
    int v26 = *(_DWORD *)(v5 + 244);
    uint64_t v27 = *(void *)v5;
    if (!*(void *)v5)
    {
LABEL_70:
      if (v26 > 0)
      {
        HGArrayDataRef::allocate((HGArrayDataRef *)v5);
      }
      return this;
    }
  }
  else
  {
    if (v20 > 0) {
      HGArrayDataRef::allocate(v6);
    }
    int v26 = *(_DWORD *)(v5 + 244);
    uint64_t v27 = *(void *)v5;
    if (!*(void *)v5) {
      goto LABEL_70;
    }
  }
  if (*(_DWORD *)(v27 + 12) < v26)
  {
    int v28 = *(_DWORD *)(v27 + 4) * v26;
    *(_DWORD *)(v27 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v26;
    if (v28) {
      operator new[]();
    }
    this = *(void *)(v27 + 16);
    if (this) {
      this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
    }
    *(void *)(v27 + 16) = 0;
  }
  *(_DWORD *)(v27 + 8) = v26;
  return this;
}

void HGeometryData::ClipW(HGRasterizer **this)
{
  HGeometryData::HGeometryData((HGeometryData *)v1, this[33]);
}

void sub_1B76DE300(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGeometryData::~HGeometryData((HGeometryData *)va);
  _Unwind_Resume(a1);
}

void sub_1B76DE314(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGeometryData::~HGeometryData((HGeometryData *)va);
  _Unwind_Resume(a1);
}

void HGeometryData::BuildShapeEdgeList(uint64_t a1, HGArrayDataRef *this, int a3)
{
  int v5 = *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 16)
                 + *(int *)(*(void *)(a1 + 48) + 4) * (uint64_t)a3
                 + *(int *)(a1 + 56));
  int v6 = *(_DWORD *)(*(void *)(*(void *)a1 + 16) + *(int *)(*(void *)a1 + 4) * (uint64_t)a3 + *(int *)(a1 + 8));
  uint64_t v7 = *(void *)this;
  if (*(void *)this)
  {
    if (*(_DWORD *)(v7 + 12) < v5)
    {
      int v8 = *(_DWORD *)(v7 + 4) * v5;
      *(_DWORD *)(v7 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v5;
      if (v8) {
        operator new[]();
      }
      uint64_t v9 = *(void *)(v7 + 16);
      if (v9) {
        MEMORY[0x1BA9BFB70](v9, 0x1000C8077774924);
      }
      *(void *)(v7 + 16) = 0;
    }
    if (v5 >= 1)
    {
      int v10 = 0;
      int v11 = 0;
      int v12 = -v5;
      do
      {
        int v13 = v6 + v10;
        if (v12 + v10 == -1) {
          int v14 = v6;
        }
        else {
          int v14 = v13 + 1;
        }
        uint64_t v15 = *(void *)(a1 + 80);
        uint64_t v16 = *(void *)(v15 + 16);
        LODWORD(v15) = *(_DWORD *)(v15 + 4);
        uint64_t v17 = *(int *)(a1 + 88);
        float v18 = *(float *)(v16 + (int)v15 * v13 + v17 + 4);
        float v19 = *(float *)(v16 + (int)v15 * v14 + v17 + 4);
        if (v18 != v19)
        {
          HGArray<HEdge,(HGFormat)0>::append(this);
          uint64_t v21 = (float32x4_t *)(*(void *)(*(void *)this + 16)
                              + *(int *)(*(void *)this + 4) * (uint64_t)v11
                              + *((int *)this + 2));
          v21[34].i64[0] = a1;
          if (v18 >= v19) {
            int v22 = v14;
          }
          else {
            int v22 = v6 + v10;
          }
          if (v18 >= v19) {
            int v23 = v6 + v10;
          }
          else {
            int v23 = v14;
          }
          v21->i32[0] = v22;
          v21->i32[1] = v23;
          uint64_t v24 = *(void *)(a1 + 80);
          if (v24)
          {
            uint64_t v25 = *(void *)(v24 + 16);
            if (v25) {
              v25 += *(int *)(v24 + 4) * (uint64_t)v22 + *(int *)(a1 + 88);
            }
            v21->i64[1] = v25;
            uint64_t v26 = *(void *)(v24 + 16);
            if (v26) {
              uint64_t v24 = v26 + *(int *)(v24 + 4) * (uint64_t)v23 + *(int *)(a1 + 88);
            }
            else {
              uint64_t v24 = 0;
            }
          }
          else
          {
            v21->i64[1] = 0;
          }
          v21[1].i64[0] = v24;
          HGeometryData::InitEdge(a1, v22, v23, *(_DWORD *)(*(void *)(a1 + 264) + 1068), (uint64_t)&v21[2], v21 + 18, &v32, &v31, v20);
          ++v11;
        }
        ++v10;
      }
      while (v12 + v10);
      if (v11 >= 2)
      {
        uint64_t v27 = *(void *)this;
        if (*(void *)this)
        {
          uint64_t v28 = *(void *)(v27 + 16);
          if (v28) {
            float64x2_t v29 = (void *)(v28 + *((int *)this + 2));
          }
          else {
            float64x2_t v29 = 0;
          }
          size_t v30 = *(int *)(v27 + 4);
        }
        else
        {
          float64x2_t v29 = 0;
          size_t v30 = 0;
        }
        qsort(v29, v11, v30, (int (__cdecl *)(const void *, const void *))CompareEdgeY);
      }
    }
  }
  else if (v5 > 0)
  {
    HGArrayDataRef::allocate(this);
  }
}

uint64_t HGArray<HEdge,(HGFormat)0>::append(HGArrayDataRef *this)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this) {
    HGArrayDataRef::allocate(this);
  }
  int v4 = *(_DWORD *)(v2 + 8);
  int v3 = *(_DWORD *)(v2 + 12);
  int v5 = v4 + 1;
  int v6 = 2 * (v4 + 1);
  if (v4 >= v3 && v3 < v6)
  {
    int v8 = *(_DWORD *)(v2 + 4) * v6;
    *(_DWORD *)(v2 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v6;
    if (v8) {
      operator new[]();
    }
    uint64_t v9 = *(void *)(v2 + 16);
    if (v9) {
      MEMORY[0x1BA9BFB70](v9, 0x1000C8077774924);
    }
    *(void *)(v2 + 16) = 0;
    uint64_t v2 = *(void *)this;
    if (!*(void *)this)
    {
      if ((v4 & 0x80000000) == 0) {
        HGArrayDataRef::allocate(this);
      }
      return 0;
    }
  }
  if (*(_DWORD *)(v2 + 12) >= v5)
  {
    *(_DWORD *)(v2 + 8) = v5;
    uint64_t v11 = *(void *)this;
    if (!*(void *)this) {
      return 0;
    }
  }
  else
  {
    int v10 = *(_DWORD *)(v2 + 4) * v5;
    *(_DWORD *)(v2 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v5;
    if (v10) {
      operator new[]();
    }
    uint64_t v12 = *(void *)(v2 + 16);
    if (v12) {
      MEMORY[0x1BA9BFB70](v12, 0x1000C8077774924);
    }
    *(void *)(v2 + 16) = 0;
    *(_DWORD *)(v2 + 8) = v5;
    uint64_t v11 = *(void *)this;
    if (!*(void *)this) {
      return 0;
    }
  }
  uint64_t v13 = *(void *)(v11 + 16);
  if (v13) {
    return v13 + *(int *)(v11 + 4) * (uint64_t)v4 + *((int *)this + 2);
  }
  return 0;
}

float HGeometryData::InitEdge(uint64_t a1, int a2, int a3, char a4, uint64_t a5, float32x4_t *a6, float *a7, _DWORD *a8, double a9)
{
  LODWORD(a9) = *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 16)
                          + *(int *)(*(void *)(a1 + 80) + 4) * (uint64_t)a3
                          + *(int *)(a1 + 88)
                          + 4);
  *a8 = LODWORD(a9);
  HGeometryData::GetEdgeDeltas(a1, a2, a3, (uint64_t)a6, a9);
  *(_OWORD *)(a5 + 144) = *(_OWORD *)(*(void *)(*(void *)(a1 + 64) + 16)
                                    + *(int *)(*(void *)(a1 + 64) + 4) * (uint64_t)a2
                                    + *(int *)(a1 + 72));
  float32x4_t v15 = *(float32x4_t *)(*(void *)(*(void *)(a1 + 80) + 16)
                       + *(int *)(*(void *)(a1 + 80) + 4) * (uint64_t)a2
                       + *(int *)(a1 + 88));
  *(float32x4_t *)a5 = v15;
  *(_OWORD *)(a5 + 208) = *(_OWORD *)(*(void *)(*(void *)(a1 + 80) + 16)
                                    + *(int *)(*(void *)(a1 + 80) + 4) * (uint64_t)a2
                                    + *(int *)(a1 + 88));
  *(_OWORD *)(a5 + 240) = *(_OWORD *)(*(void *)(*(void *)(a1 + 96) + 16)
                                    + *(int *)(*(void *)(a1 + 96) + 4) * (uint64_t)a2
                                    + *(int *)(a1 + 104));
  if (a4)
  {
    *(_OWORD *)(a5 + 16) = *(_OWORD *)(*(void *)(*(void *)(a1 + 112) + 16)
                                     + *(int *)(*(void *)(a1 + 112) + 4) * (uint64_t)a2
                                     + *(int *)(a1 + 120));
    if ((a4 & 2) == 0)
    {
LABEL_3:
      if ((a4 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_17;
    }
  }
  else if ((a4 & 2) == 0)
  {
    goto LABEL_3;
  }
  *(_OWORD *)(a5 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *(_OWORD *)(*(void *)(*(void *)(a1 + 128) + 16)
                                   + *(int *)(*(void *)(a1 + 128) + 4) * (uint64_t)a2
                                   + *(int *)(a1 + 136));
  if ((a4 & 4) == 0)
  {
LABEL_4:
    if ((a4 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_18;
  }
LABEL_17:
  *(_OWORD *)(a5 + 48) = *(_OWORD *)(*(void *)(*(void *)(a1 + 144) + 16)
                                   + *(int *)(*(void *)(a1 + 144) + 4) * (uint64_t)a2
                                   + *(int *)(a1 + 152));
  if ((a4 & 8) == 0)
  {
LABEL_5:
    if ((a4 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_19;
  }
LABEL_18:
  *(_OWORD *)(a5 + 64) = *(_OWORD *)(*(void *)(*(void *)(a1 + 160) + 16)
                                   + *(int *)(*(void *)(a1 + 160) + 4) * (uint64_t)a2
                                   + *(int *)(a1 + 168));
  if ((a4 & 0x10) == 0)
  {
LABEL_6:
    if ((a4 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_20;
  }
LABEL_19:
  *(_OWORD *)(a5 + 80) = *(_OWORD *)(*(void *)(*(void *)(a1 + 176) + 16)
                                   + *(int *)(*(void *)(a1 + 176) + 4) * (uint64_t)a2
                                   + *(int *)(a1 + 184));
  if ((a4 & 0x20) == 0)
  {
LABEL_7:
    if ((a4 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_21;
  }
LABEL_20:
  *(_OWORD *)(a5 + 96) = *(_OWORD *)(*(void *)(*(void *)(a1 + 192) + 16)
                                   + *(int *)(*(void *)(a1 + 192) + 4) * (uint64_t)a2
                                   + *(int *)(a1 + 200));
  if ((a4 & 0x40) == 0)
  {
LABEL_8:
    float v16 = v15.f32[1];
    if ((a4 & 0x80) == 0) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_21:
  *(_OWORD *)(a5 + 11PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *(_OWORD *)(*(void *)(*(void *)(a1 + 208) + 16)
                                    + *(int *)(*(void *)(a1 + 208) + 4) * (uint64_t)a2
                                    + *(int *)(a1 + 216));
  float v16 = v15.f32[1];
  if (a4 < 0)
  {
LABEL_9:
    float32x4_t v15 = *(float32x4_t *)(*(void *)(*(void *)(a1 + 224) + 16)
                         + *(int *)(*(void *)(a1 + 224) + 4) * (uint64_t)a2
                         + *(int *)(a1 + 232));
    *(float32x4_t *)(a5 + 128) = v15;
  }
LABEL_10:
  v15.f32[0] = v16 - floorf(v16);
  float v17 = 0.5;
  if (v15.f32[0] > 0.5) {
    float v17 = 1.5;
  }
  float v18 = v17 - v15.f32[0];
  if ((float)(v17 - v15.f32[0]) > 0.0)
  {
    v15.f32[0] = v17 - v15.f32[0];
    HGeometryData::IncrementEdge(a1, (float32x4_t *)a5, a6, v15);
  }
  float result = v16 + v18;
  *a7 = v16 + v18;
  return result;
}

uint64_t CompareEdgeY(void *a1, void *a2)
{
  float v2 = *(float *)(*(void *)(*(void *)(a1[68] + 80) + 16)
                + *(int *)(*(void *)(a1[68] + 80) + 4) * (uint64_t)*(int *)a1
                + *(int *)(a1[68] + 88)
                + 4);
  float v3 = *(float *)(*(void *)(*(void *)(a2[68] + 80) + 16)
                + *(int *)(*(void *)(a2[68] + 80) + 4) * (uint64_t)*(int *)a2
                + *(int *)(a2[68] + 88)
                + 4);
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v2 > v3;
  }
}

float32x4_t HGeometryData::GetEdgeDeltas(uint64_t a1, int a2, int a3, uint64_t a4, double a5)
{
  uint64_t v5 = *(void *)(a1 + 80);
  uint64_t v6 = *(void *)(v5 + 16);
  LODWORD(v5) = *(_DWORD *)(v5 + 4);
  uint64_t v7 = *(int *)(a1 + 88);
  uint64_t v8 = v6 + (int)v5 * (uint64_t)a2 + v7;
  uint64_t v9 = v6 + (int)v5 * (uint64_t)a3 + v7;
  int v10 = *(_DWORD *)(*(void *)(a1 + 264) + 1068);
  LODWORD(a5) = *(_DWORD *)(v9 + 4);
  float v11 = *(float *)(v8 + 4);
  if (*(float *)&a5 == v11)
  {
    float32x4_t result = 0uLL;
    *(_OWORD *)(a4 + 144) = 0u;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 208) = 0u;
    *(_OWORD *)(a4 + 240) = 0u;
    if (v10)
    {
      *(void *)(a4 + 16) = 0;
      *(void *)(a4 + 24) = 0;
      if ((v10 & 2) == 0)
      {
LABEL_13:
        if ((v10 & 4) == 0) {
          goto LABEL_14;
        }
        goto LABEL_30;
      }
    }
    else if ((v10 & 2) == 0)
    {
      goto LABEL_13;
    }
    *(void *)(a4 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
    *(void *)(a4 + 40) = 0;
    if ((v10 & 4) == 0)
    {
LABEL_14:
      if ((v10 & 8) == 0) {
        goto LABEL_15;
      }
      goto LABEL_31;
    }
LABEL_30:
    *(void *)(a4 + 48) = 0;
    *(void *)(a4 + 56) = 0;
    if ((v10 & 8) == 0)
    {
LABEL_15:
      if ((v10 & 0x10) == 0) {
        goto LABEL_16;
      }
      goto LABEL_32;
    }
LABEL_31:
    *(void *)(a4 + 64) = 0;
    *(void *)(a4 + 7PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
    if ((v10 & 0x10) == 0)
    {
LABEL_16:
      if ((v10 & 0x20) == 0) {
        goto LABEL_17;
      }
      goto LABEL_33;
    }
LABEL_32:
    *(void *)(a4 + 80) = 0;
    *(void *)(a4 + 88) = 0;
    if ((v10 & 0x20) == 0)
    {
LABEL_17:
      if ((v10 & 0x40) == 0) {
        goto LABEL_18;
      }
      goto LABEL_34;
    }
LABEL_33:
    *(void *)(a4 + 96) = 0;
    *(void *)(a4 + 104) = 0;
    if ((v10 & 0x40) == 0)
    {
LABEL_18:
      if ((v10 & 0x80) == 0) {
        return result;
      }
      goto LABEL_19;
    }
LABEL_34:
    *(void *)(a4 + 11PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
    *(void *)(a4 + 120) = 0;
    if ((v10 & 0x80) == 0) {
      return result;
    }
LABEL_19:
    *(_OWORD *)(a4 + 128) = 0uLL;
    return result;
  }
  *(float *)&a5 = *(float *)&a5 - v11;
  float32x4_t v12 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0);
  float32x4_t v13 = vrecpeq_f32(v12);
  float32x4_t v14 = vmulq_f32(v13, vrecpsq_f32(v12, v13));
  float32x4_t result = vmulq_f32(vrecpsq_f32(v12, v14), v14);
  uint64_t v16 = *(void *)(a1 + 64);
  *(float32x4_t *)(a4 + 144) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(void *)(v16 + 16)+ *(int *)(v16 + 4) * (uint64_t)a3+ *(int *)(a1 + 72)), *(float32x4_t *)(*(void *)(v16 + 16)+ *(int *)(v16 + 4) * (uint64_t)a2+ *(int *)(a1 + 72))));
  uint64_t v17 = *(void *)(a1 + 80);
  float32x4_t v18 = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(void *)(v17 + 16) + *(int *)(v17 + 4) * (uint64_t)a3 + *(int *)(a1 + 88)), *(float32x4_t *)(*(void *)(v17 + 16) + *(int *)(v17 + 4) * (uint64_t)a2 + *(int *)(a1 + 88))));
  *(float32x4_t *)a4 = v18;
  uint64_t v19 = *(void *)(a1 + 96);
  *(float32x4_t *)(a4 + 240) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(void *)(v19 + 16)+ *(int *)(v19 + 4) * (uint64_t)a3+ *(int *)(a1 + 104)), *(float32x4_t *)(*(void *)(v19 + 16)+ *(int *)(v19 + 4) * (uint64_t)a2+ *(int *)(a1 + 104))));
  *(float32x4_t *)(a4 + 208) = v18;
  if (v10)
  {
    uint64_t v20 = *(void *)(a1 + 112);
    *(float32x4_t *)(a4 + 16) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(void *)(v20 + 16)+ *(int *)(v20 + 4) * (uint64_t)a3+ *(int *)(a1 + 120)), *(float32x4_t *)(*(void *)(v20 + 16)+ *(int *)(v20 + 4) * (uint64_t)a2+ *(int *)(a1 + 120))));
    if ((v10 & 2) == 0)
    {
LABEL_4:
      if ((v10 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_22;
    }
  }
  else if ((v10 & 2) == 0)
  {
    goto LABEL_4;
  }
  uint64_t v21 = *(void *)(a1 + 128);
  *(float32x4_t *)(a4 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(void *)(v21 + 16)+ *(int *)(v21 + 4) * (uint64_t)a3+ *(int *)(a1 + 136)), *(float32x4_t *)(*(void *)(v21 + 16)+ *(int *)(v21 + 4) * (uint64_t)a2+ *(int *)(a1 + 136))));
  if ((v10 & 4) == 0)
  {
LABEL_5:
    if ((v10 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_23;
  }
LABEL_22:
  uint64_t v22 = *(void *)(a1 + 144);
  *(float32x4_t *)(a4 + 48) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(void *)(v22 + 16)+ *(int *)(v22 + 4) * (uint64_t)a3+ *(int *)(a1 + 152)), *(float32x4_t *)(*(void *)(v22 + 16)+ *(int *)(v22 + 4) * (uint64_t)a2+ *(int *)(a1 + 152))));
  if ((v10 & 8) == 0)
  {
LABEL_6:
    if ((v10 & 0x10) == 0) {
      goto LABEL_7;
    }
    goto LABEL_24;
  }
LABEL_23:
  uint64_t v23 = *(void *)(a1 + 160);
  *(float32x4_t *)(a4 + 64) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(void *)(v23 + 16)+ *(int *)(v23 + 4) * (uint64_t)a3+ *(int *)(a1 + 168)), *(float32x4_t *)(*(void *)(v23 + 16)+ *(int *)(v23 + 4) * (uint64_t)a2+ *(int *)(a1 + 168))));
  if ((v10 & 0x10) == 0)
  {
LABEL_7:
    if ((v10 & 0x20) == 0) {
      goto LABEL_8;
    }
LABEL_25:
    uint64_t v25 = *(void *)(a1 + 192);
    *(float32x4_t *)(a4 + 96) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(void *)(v25 + 16)+ *(int *)(v25 + 4) * (uint64_t)a3+ *(int *)(a1 + 200)), *(float32x4_t *)(*(void *)(v25 + 16)+ *(int *)(v25 + 4) * (uint64_t)a2+ *(int *)(a1 + 200))));
    if ((v10 & 0x40) == 0)
    {
LABEL_9:
      if ((v10 & 0x80) == 0) {
        return result;
      }
LABEL_27:
      uint64_t v27 = *(void *)(a1 + 224);
      float32x4_t result = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(void *)(v27 + 16) + *(int *)(v27 + 4) * (uint64_t)a3 + *(int *)(a1 + 232)), *(float32x4_t *)(*(void *)(v27 + 16) + *(int *)(v27 + 4) * (uint64_t)a2 + *(int *)(a1 + 232))));
      *(float32x4_t *)(a4 + 128) = result;
      return result;
    }
    goto LABEL_26;
  }
LABEL_24:
  uint64_t v24 = *(void *)(a1 + 176);
  *(float32x4_t *)(a4 + 80) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(void *)(v24 + 16)+ *(int *)(v24 + 4) * (uint64_t)a3+ *(int *)(a1 + 184)), *(float32x4_t *)(*(void *)(v24 + 16)+ *(int *)(v24 + 4) * (uint64_t)a2+ *(int *)(a1 + 184))));
  if ((v10 & 0x20) != 0) {
    goto LABEL_25;
  }
LABEL_8:
  if ((v10 & 0x40) == 0) {
    goto LABEL_9;
  }
LABEL_26:
  uint64_t v26 = *(void *)(a1 + 208);
  *(float32x4_t *)(a4 + 11PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(void *)(v26 + 16)+ *(int *)(v26 + 4) * (uint64_t)a3+ *(int *)(a1 + 216)), *(float32x4_t *)(*(void *)(v26 + 16)+ *(int *)(v26 + 4) * (uint64_t)a2+ *(int *)(a1 + 216))));
  if ((v10 & 0x80) != 0) {
    goto LABEL_27;
  }
  return result;
}

float32x4_t HGeometryData::IncrementEdge(uint64_t a1, float32x4_t *a2, float32x4_t *a3, float32x4_t result)
{
  int v4 = *(_DWORD *)(*(void *)(a1 + 264) + 1068);
  if (result.f32[0] != 1.0)
  {
    *a2 = vaddq_f32(*a2, vmulq_n_f32(*a3, result.f32[0]));
    a2[9] = vaddq_f32(a2[9], vmulq_n_f32(a3[9], result.f32[0]));
    a2[15] = vaddq_f32(a2[15], vmulq_n_f32(a3[15], result.f32[0]));
    a2[13] = vaddq_f32(a2[13], vmulq_n_f32(a3[13], result.f32[0]));
    if (v4)
    {
      a2[1] = vaddq_f32(a2[1], vmulq_n_f32(a3[1], result.f32[0]));
      if ((v4 & 2) == 0)
      {
LABEL_13:
        if ((v4 & 4) == 0) {
          goto LABEL_14;
        }
        goto LABEL_30;
      }
    }
    else if ((v4 & 2) == 0)
    {
      goto LABEL_13;
    }
    a2[2] = vaddq_f32(a2[2], vmulq_n_f32(a3[2], result.f32[0]));
    if ((v4 & 4) == 0)
    {
LABEL_14:
      if ((v4 & 8) == 0) {
        goto LABEL_15;
      }
      goto LABEL_31;
    }
LABEL_30:
    a2[3] = vaddq_f32(a2[3], vmulq_n_f32(a3[3], result.f32[0]));
    if ((v4 & 8) == 0)
    {
LABEL_15:
      if ((v4 & 0x10) == 0) {
        goto LABEL_16;
      }
      goto LABEL_32;
    }
LABEL_31:
    a2[4] = vaddq_f32(a2[4], vmulq_n_f32(a3[4], result.f32[0]));
    if ((v4 & 0x10) == 0)
    {
LABEL_16:
      if ((v4 & 0x20) == 0) {
        goto LABEL_17;
      }
      goto LABEL_33;
    }
LABEL_32:
    a2[5] = vaddq_f32(a2[5], vmulq_n_f32(a3[5], result.f32[0]));
    if ((v4 & 0x20) == 0)
    {
LABEL_17:
      if ((v4 & 0x40) == 0) {
        goto LABEL_18;
      }
      goto LABEL_34;
    }
LABEL_33:
    a2[6] = vaddq_f32(a2[6], vmulq_n_f32(a3[6], result.f32[0]));
    if ((v4 & 0x40) == 0)
    {
LABEL_18:
      if ((v4 & 0x80) == 0) {
        return result;
      }
      goto LABEL_35;
    }
LABEL_34:
    a2[7] = vaddq_f32(a2[7], vmulq_n_f32(a3[7], result.f32[0]));
    if ((v4 & 0x80) == 0) {
      return result;
    }
LABEL_35:
    float32x4_t result = vaddq_f32(a2[8], vmulq_n_f32(a3[8], result.f32[0]));
    a2[8] = result;
    return result;
  }
  *a2 = vaddq_f32(*a3, *a2);
  a2[9] = vaddq_f32(a3[9], a2[9]);
  a2[15] = vaddq_f32(a3[15], a2[15]);
  float32x4_t result = vaddq_f32(a3[13], a2[13]);
  a2[13] = result;
  if (v4)
  {
    float32x4_t result = vaddq_f32(a3[1], a2[1]);
    a2[1] = result;
    if ((v4 & 2) == 0)
    {
LABEL_4:
      if ((v4 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_22;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_4;
  }
  float32x4_t result = vaddq_f32(a3[2], a2[2]);
  a2[2] = result;
  if ((v4 & 4) == 0)
  {
LABEL_5:
    if ((v4 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_23;
  }
LABEL_22:
  float32x4_t result = vaddq_f32(a3[3], a2[3]);
  a2[3] = result;
  if ((v4 & 8) == 0)
  {
LABEL_6:
    if ((v4 & 0x10) == 0) {
      goto LABEL_7;
    }
    goto LABEL_24;
  }
LABEL_23:
  float32x4_t result = vaddq_f32(a3[4], a2[4]);
  a2[4] = result;
  if ((v4 & 0x10) == 0)
  {
LABEL_7:
    if ((v4 & 0x20) == 0) {
      goto LABEL_8;
    }
LABEL_25:
    float32x4_t result = vaddq_f32(a3[6], a2[6]);
    a2[6] = result;
    if ((v4 & 0x40) == 0)
    {
LABEL_9:
      if ((v4 & 0x80) == 0) {
        return result;
      }
LABEL_27:
      float32x4_t result = vaddq_f32(a3[8], a2[8]);
      a2[8] = result;
      return result;
    }
    goto LABEL_26;
  }
LABEL_24:
  float32x4_t result = vaddq_f32(a3[5], a2[5]);
  a2[5] = result;
  if ((v4 & 0x20) != 0) {
    goto LABEL_25;
  }
LABEL_8:
  if ((v4 & 0x40) == 0) {
    goto LABEL_9;
  }
LABEL_26:
  float32x4_t result = vaddq_f32(a3[7], a2[7]);
  a2[7] = result;
  if ((v4 & 0x80) != 0) {
    goto LABEL_27;
  }
  return result;
}

void HGeometryData::RenderPolygon()
{
  v0[0] = 0;
  v0[1] = 0;
  HGArrayDataRef::allocate((HGArrayDataRef *)v0);
}

void sub_1B76E00B0(_Unwind_Exception *a1)
{
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v1 - 224));
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v1 - 192));
  _Unwind_Resume(a1);
}

uint64_t CompareEdgeX(const void *a1, const void *a2)
{
  float v2 = *(float *)(*(void *)a1 + 32);
  float v3 = *(float *)(*(void *)a2 + 32);
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v2 > v3;
  }
}

uint64_t HGeometryData::RenderPolygons(HGeometryData *this, HGTile *a2, HGSampleRectStat *a3)
{
  int v5 = *(_DWORD *)(*((void *)a2 + 42) + 160);
  uint64_t v6 = (HGRenderer *)HGTile::Renderer(a2);
  uint64_t v7 = (const void *)HGRenderer::DepthManager(v6, v5);
  if (v7) {
  else
  }
    uint64_t v8 = 0;
  int v9 = (*(uint64_t (**)(void))(**((void **)this + 33) + 592))(*((void *)this + 33)) & 0xA;
  if (v9)
  {
    uint64_t v10 = *(void *)a2;
    uint64_t v11 = *((void *)a2 + 1);
    uint64_t v12 = HGTile::Renderer(a2);
    DepthBufferManager::init((uint64_t)v8, v12);
    if (v9 == 2) {
      (*(void (**)(DepthBufferManager *))(*(void *)v8 + 24))(v8);
    }
    (*(void (**)(DepthBufferManager *, void, uint64_t, uint64_t))(*(void *)v8 + 40))(v8, 0, v10, v11);
    uint64_t DepthBuffer = DepthBufferManager::getDepthBuffer(v8);
    *((_DWORD *)a2 + 10) = *(_DWORD *)(DepthBuffer + 64) / *(_DWORD *)(DepthBuffer + 56);
    *((void *)a2 + 4) = *((void *)v8 + 8);
  }
  float32x4_t v14 = (HGRenderer *)HGTile::Renderer(a2);
  HGRenderer::GetTarget(v14, 0);
  ActiveShaderuint64_t Node = HGRasterizer::getActiveShaderNode(*((HGRasterizer **)this + 33));
  uint64_t v16 = HGTile::Renderer(a2);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)ActiveShaderNode + 312))(ActiveShaderNode, v16);
  unsigned int v18 = *((_DWORD *)this + 61);
  if (v18)
  {
    for (unsigned int i = 0; i < v18; ++i)
    {
      if (*(int *)(*(void *)(*((void *)this + 6) + 16)
                  + *(int *)(*((void *)this + 6) + 4) * (uint64_t)(int)i
                  + *((int *)this + 14)) >= 3)
        HGeometryData::RenderPolygon();
    }
  }
  if (v9)
  {
    uint64_t result = (*(uint64_t (**)(DepthBufferManager *))(*(void *)v8 + 48))(v8);
    if (v9 == 2) {
      return (*(uint64_t (**)(DepthBufferManager *))(*(void *)v8 + 32))(v8);
    }
  }
  return result;
}

void HGeometryData::~HGeometryData(HGeometryData *this)
{
  uint64_t v2 = *((void *)this + 28);
  if (v2 && atomic_fetch_add((atomic_uint *volatile)v2, 0xFFFFFFFF) == 1)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3) {
      MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v2, 0x1080C4098BBCF0FLL);
  }
  uint64_t v4 = *((void *)this + 26);
  if (v4 && atomic_fetch_add((atomic_uint *volatile)v4, 0xFFFFFFFF) == 1)
  {
    uint64_t v5 = *(void *)(v4 + 16);
    if (v5) {
      MEMORY[0x1BA9BFB70](v5, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v4, 0x1080C4098BBCF0FLL);
  }
  uint64_t v6 = *((void *)this + 24);
  if (v6 && atomic_fetch_add((atomic_uint *volatile)v6, 0xFFFFFFFF) == 1)
  {
    uint64_t v7 = *(void *)(v6 + 16);
    if (v7) {
      MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v6, 0x1080C4098BBCF0FLL);
  }
  uint64_t v8 = *((void *)this + 22);
  if (v8 && atomic_fetch_add((atomic_uint *volatile)v8, 0xFFFFFFFF) == 1)
  {
    uint64_t v9 = *(void *)(v8 + 16);
    if (v9) {
      MEMORY[0x1BA9BFB70](v9, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v8, 0x1080C4098BBCF0FLL);
  }
  uint64_t v10 = *((void *)this + 20);
  if (v10 && atomic_fetch_add((atomic_uint *volatile)v10, 0xFFFFFFFF) == 1)
  {
    uint64_t v11 = *(void *)(v10 + 16);
    if (v11) {
      MEMORY[0x1BA9BFB70](v11, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v10, 0x1080C4098BBCF0FLL);
  }
  uint64_t v12 = *((void *)this + 18);
  if (v12 && atomic_fetch_add((atomic_uint *volatile)v12, 0xFFFFFFFF) == 1)
  {
    uint64_t v13 = *(void *)(v12 + 16);
    if (v13) {
      MEMORY[0x1BA9BFB70](v13, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v12, 0x1080C4098BBCF0FLL);
  }
  uint64_t v14 = *((void *)this + 16);
  if (v14 && atomic_fetch_add((atomic_uint *volatile)v14, 0xFFFFFFFF) == 1)
  {
    uint64_t v15 = *(void *)(v14 + 16);
    if (v15) {
      MEMORY[0x1BA9BFB70](v15, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v14, 0x1080C4098BBCF0FLL);
  }
  uint64_t v16 = *((void *)this + 14);
  if (v16 && atomic_fetch_add((atomic_uint *volatile)v16, 0xFFFFFFFF) == 1)
  {
    uint64_t v17 = *(void *)(v16 + 16);
    if (v17) {
      MEMORY[0x1BA9BFB70](v17, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v16, 0x1080C4098BBCF0FLL);
  }
  uint64_t v18 = *((void *)this + 12);
  if (v18 && atomic_fetch_add((atomic_uint *volatile)v18, 0xFFFFFFFF) == 1)
  {
    uint64_t v19 = *(void *)(v18 + 16);
    if (v19) {
      MEMORY[0x1BA9BFB70](v19, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v18, 0x1080C4098BBCF0FLL);
  }
  uint64_t v20 = *((void *)this + 10);
  if (v20 && atomic_fetch_add((atomic_uint *volatile)v20, 0xFFFFFFFF) == 1)
  {
    uint64_t v21 = *(void *)(v20 + 16);
    if (v21) {
      MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v20, 0x1080C4098BBCF0FLL);
  }
  uint64_t v22 = *((void *)this + 8);
  if (v22 && atomic_fetch_add((atomic_uint *volatile)v22, 0xFFFFFFFF) == 1)
  {
    uint64_t v23 = *(void *)(v22 + 16);
    if (v23) {
      MEMORY[0x1BA9BFB70](v23, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v22, 0x1080C4098BBCF0FLL);
  }
  uint64_t v24 = *((void *)this + 6);
  if (v24 && atomic_fetch_add((atomic_uint *volatile)v24, 0xFFFFFFFF) == 1)
  {
    uint64_t v25 = *(void *)(v24 + 16);
    if (v25) {
      MEMORY[0x1BA9BFB70](v25, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v24, 0x1080C4098BBCF0FLL);
  }
  uint64_t v26 = *((void *)this + 4);
  if (v26 && atomic_fetch_add((atomic_uint *volatile)v26, 0xFFFFFFFF) == 1)
  {
    uint64_t v27 = *(void *)(v26 + 16);
    if (v27) {
      MEMORY[0x1BA9BFB70](v27, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v26, 0x1080C4098BBCF0FLL);
  }
  uint64_t v28 = *((void *)this + 2);
  if (v28 && atomic_fetch_add((atomic_uint *volatile)v28, 0xFFFFFFFF) == 1)
  {
    uint64_t v29 = *(void *)(v28 + 16);
    if (v29) {
      MEMORY[0x1BA9BFB70](v29, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v28, 0x1080C4098BBCF0FLL);
  }
  uint64_t v30 = *(void *)this;
  if (*(void *)this && atomic_fetch_add((atomic_uint *volatile)v30, 0xFFFFFFFF) == 1)
  {
    uint64_t v31 = *(void *)(v30 + 16);
    if (v31) {
      MEMORY[0x1BA9BFB70](v31, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v30, 0x1080C4098BBCF0FLL);
  }
}

void HGArrayDataRef::allocate(HGArrayDataRef *this)
{
}

void sub_1B76E0A5C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1080C4098BBCF0FLL);
  _Unwind_Resume(a1);
}

uint64_t HGArray<__simd128_float32_t,(HGFormat)28>::append(HGArrayDataRef *this)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this) {
    HGArrayDataRef::allocate(this);
  }
  int v4 = *(_DWORD *)(v2 + 8);
  int v3 = *(_DWORD *)(v2 + 12);
  int v5 = v4 + 1;
  int v6 = 2 * (v4 + 1);
  if (v4 >= v3 && v3 < v6)
  {
    int v8 = *(_DWORD *)(v2 + 4) * v6;
    *(_DWORD *)(v2 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v6;
    if (v8) {
      operator new[]();
    }
    uint64_t v9 = *(void *)(v2 + 16);
    if (v9) {
      MEMORY[0x1BA9BFB70](v9, 0x1000C8077774924);
    }
    *(void *)(v2 + 16) = 0;
    uint64_t v2 = *(void *)this;
    if (!*(void *)this)
    {
      if ((v4 & 0x80000000) == 0) {
        HGArrayDataRef::allocate(this);
      }
      return 0;
    }
  }
  if (*(_DWORD *)(v2 + 12) >= v5)
  {
    *(_DWORD *)(v2 + 8) = v5;
    uint64_t v11 = *(void *)this;
    if (!*(void *)this) {
      return 0;
    }
  }
  else
  {
    int v10 = *(_DWORD *)(v2 + 4) * v5;
    *(_DWORD *)(v2 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v5;
    if (v10) {
      operator new[]();
    }
    uint64_t v12 = *(void *)(v2 + 16);
    if (v12) {
      MEMORY[0x1BA9BFB70](v12, 0x1000C8077774924);
    }
    *(void *)(v2 + 16) = 0;
    *(_DWORD *)(v2 + 8) = v5;
    uint64_t v11 = *(void *)this;
    if (!*(void *)this) {
      return 0;
    }
  }
  uint64_t v13 = *(void *)(v11 + 16);
  if (v13) {
    return v13 + *(int *)(v11 + 4) * (uint64_t)v4 + *((int *)this + 2);
  }
  return 0;
}

uint64_t HGArray<int,(HGFormat)34>::append(HGArrayDataRef *this)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this) {
    HGArrayDataRef::allocate(this);
  }
  int v4 = *(_DWORD *)(v2 + 8);
  int v3 = *(_DWORD *)(v2 + 12);
  int v5 = v4 + 1;
  int v6 = 2 * (v4 + 1);
  if (v4 >= v3 && v3 < v6)
  {
    int v8 = *(_DWORD *)(v2 + 4) * v6;
    *(_DWORD *)(v2 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v6;
    if (v8) {
      operator new[]();
    }
    uint64_t v9 = *(void *)(v2 + 16);
    if (v9) {
      MEMORY[0x1BA9BFB70](v9, 0x1000C8077774924);
    }
    *(void *)(v2 + 16) = 0;
    uint64_t v2 = *(void *)this;
    if (!*(void *)this)
    {
      if ((v4 & 0x80000000) == 0) {
        HGArrayDataRef::allocate(this);
      }
      return 0;
    }
  }
  if (*(_DWORD *)(v2 + 12) >= v5)
  {
    *(_DWORD *)(v2 + 8) = v5;
    uint64_t v11 = *(void *)this;
    if (!*(void *)this) {
      return 0;
    }
  }
  else
  {
    int v10 = *(_DWORD *)(v2 + 4) * v5;
    *(_DWORD *)(v2 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v5;
    if (v10) {
      operator new[]();
    }
    uint64_t v12 = *(void *)(v2 + 16);
    if (v12) {
      MEMORY[0x1BA9BFB70](v12, 0x1000C8077774924);
    }
    *(void *)(v2 + 16) = 0;
    *(_DWORD *)(v2 + 8) = v5;
    uint64_t v11 = *(void *)this;
    if (!*(void *)this) {
      return 0;
    }
  }
  uint64_t v13 = *(void *)(v11 + 16);
  if (v13) {
    return v13 + *(int *)(v11 + 4) * (uint64_t)v4 + *((int *)this + 2);
  }
  return 0;
}

uint64_t HGArray<BOOL,(HGFormat)0>::append(HGArrayDataRef *this)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this) {
    HGArrayDataRef::allocate(this);
  }
  int v4 = *(_DWORD *)(v2 + 8);
  int v3 = *(_DWORD *)(v2 + 12);
  int v5 = v4 + 1;
  int v6 = 2 * (v4 + 1);
  if (v4 >= v3 && v3 < v6)
  {
    int v8 = *(_DWORD *)(v2 + 4) * v6;
    *(_DWORD *)(v2 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v6;
    if (v8) {
      operator new[]();
    }
    uint64_t v9 = *(void *)(v2 + 16);
    if (v9) {
      MEMORY[0x1BA9BFB70](v9, 0x1000C8077774924);
    }
    *(void *)(v2 + 16) = 0;
    uint64_t v2 = *(void *)this;
    if (!*(void *)this)
    {
      if ((v4 & 0x80000000) == 0) {
        HGArrayDataRef::allocate(this);
      }
      return 0;
    }
  }
  if (*(_DWORD *)(v2 + 12) >= v5)
  {
    *(_DWORD *)(v2 + 8) = v5;
    uint64_t v11 = *(void *)this;
    if (!*(void *)this) {
      return 0;
    }
  }
  else
  {
    int v10 = *(_DWORD *)(v2 + 4) * v5;
    *(_DWORD *)(v2 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v5;
    if (v10) {
      operator new[]();
    }
    uint64_t v12 = *(void *)(v2 + 16);
    if (v12) {
      MEMORY[0x1BA9BFB70](v12, 0x1000C8077774924);
    }
    *(void *)(v2 + 16) = 0;
    *(_DWORD *)(v2 + 8) = v5;
    uint64_t v11 = *(void *)this;
    if (!*(void *)this) {
      return 0;
    }
  }
  uint64_t v13 = *(void *)(v11 + 16);
  if (v13) {
    return v13 + *(int *)(v11 + 4) * (uint64_t)v4 + *((int *)this + 2);
  }
  return 0;
}

atomic_uint *OUTLINED_FUNCTION_0_1(atomic_uint *result)
{
  return result;
}

void OUTLINED_FUNCTION_1()
{
  JUMPOUT(0x1BA9BFBA0);
}

void OUTLINED_FUNCTION_2()
{
  JUMPOUT(0x1BA9BFB70);
}

uint64_t OUTLINED_FUNCTION_3(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void OUTLINED_FUNCTION_4()
{
  *(void *)uint64_t v0 = v2;
  *(_DWORD *)(v0 + 8) = v1;
}

uint64_t OUTLINED_FUNCTION_5()
{
  return v0;
}

uint64_t HGeometryData::HGeometryData(uint64_t result)
{
  if (atomic_fetch_add((atomic_uint *volatile)result, 0xFFFFFFFF) == 1)
  {
    if (*(void *)(result + 16)) {
      OUTLINED_FUNCTION_2();
    }
    OUTLINED_FUNCTION_5();
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

void HGeometryData::HGeometryData(atomic_uint *a1)
{
  int v1 = OUTLINED_FUNCTION_0_1(a1);
  if (v2)
  {
    if (OUTLINED_FUNCTION_3((uint64_t)v1)) {
      OUTLINED_FUNCTION_2();
    }
    OUTLINED_FUNCTION_1();
  }
  OUTLINED_FUNCTION_4();
}

void HGGLNode::HGGLNode(HGGLNode *this, unint64_t a2)
{
  HGNode::HGNode((HGNode *)this);
  *int v4 = &unk_1F10C52C0;
  v4[52] = 0;
  int v5 = (HGRasterizer *)HGObject::operator new(0x4D0uLL);
  HGRasterizer::HGRasterizer(v5, a2);
  *((void *)this + 5PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v5;
  *((_DWORD *)this + 106) = 1;
}

void sub_1B76E1208(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  uint64_t v4 = *(void *)(v1 + 416);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGGLNode::~HGGLNode(HGGLNode *this)
{
  *(void *)this = &unk_1F10C52C0;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode((HGNode *)this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10C52C0;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode((HGNode *)this);

  HGObject::operator delete(v3);
}

uint64_t HGGLNode::addFragmentShader(HGGLNode *this, HGNode3D *a2)
{
  return HGRasterizer::addFragmentShader(*((void *)this + 51), a2);
}

uint64_t HGGLNode::enableXFormConcatenation(HGGLNode *this, HGNode3D *a2)
{
  return HGRasterizer::enableXFormConcatenation(*((void *)this + 51), (uint64_t)a2);
}

uint64_t HGGLNode::enableInplaceBlending(HGGLNode *this)
{
  return HGRasterizer::enableInplaceBlending(*((void *)this + 51));
}

uint64_t HGGLNode::SetParameter(HGGLNode *this, uint64_t a2, float a3, float a4, float a5, float a6)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  float v9 = fmaxf(fminf(a4, 4.0), 0.0);
  (*(void (**)(void, uint64_t, float *))(**((void **)this + 51) + 104))(*((void *)this + 51), a2, v15);
  if ((int)v9 > 4) {
    int v13 = 1;
  }
  else {
    int v13 = dword_1B7EBF8AC[v9];
  }
  if ((a3 == 1.0) != (v15[0] != 1.0) && *((_DWORD *)this + 106) == v13) {
    return 0;
  }
  *((_DWORD *)this + 106) = v13;
  v10.n128_u64[0] = 0;
  if (a3 == 1.0) {
    v10.n128_f32[0] = 1.0;
  }
  v11.n128_u32[0] = *((_DWORD *)&xmmword_1B7E734D0 + v13);
  v12.n128_u32[0] = dword_1B7EBF8C0[v13];
  (*(void (**)(void, void, __n128, __n128, __n128, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, v10, v11, v12, 0.0);
  return 1;
}

uint64_t HGGLNode::SetActiveShaderNodeParameter(HGRasterizer **this, uint64_t a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6)
{
  return HGRasterizer::SetActiveShaderNodeParameter(this[51], a2, a3, a4, a5, a6);
}

void HGGLNode::GetOutput(HGGLNode *this, HGRenderer *a2)
{
  int v3 = (unsigned char *)*((void *)this + 51);
  if (v3[1141])
  {
    (*(void (**)(void, HGRenderer *))(*(void *)v3 + 16))(*((void *)this + 51), a2);
    uint64_t v4 = (unsigned char *)*((void *)this + 52);
    if (v4 == v3)
    {
      (*(void (**)(unsigned char *))(*(void *)v3 + 24))(v3);
    }
    else
    {
      if (v4) {
        (*(void (**)(unsigned char *))(*(void *)v4 + 24))(v4);
      }
      *((void *)this + 5PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v3;
    }
  }
  v5[0] = 0;
  v5[1] = 0;
  HGArrayDataRef::allocate((HGArrayDataRef *)v5);
}

void sub_1B76E1E84(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void sub_1B76E1FC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  HGTransform::~HGTransform((HGTransform *)va);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v3 - 120));
  _Unwind_Resume(a1);
}

void sub_1B76E2018(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v2 - 120));
  _Unwind_Resume(a1);
}

void sub_1B76E2048(_Unwind_Exception *a1)
{
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v1 - 120));
  _Unwind_Resume(a1);
}

uint64_t HGGLNode::hglMatrixMode(HGGLNode *this, int a2)
{
  return HGRasterizer::matrixMode(*((void *)this + 51), a2);
}

char *HGGLNode::hglBegin(char **this, int a2)
{
  return HGRasterizer::begin(this[51], a2);
}

void HGGLNode::hglEnd(HGRasterizer **this)
{
}

double HGGLNode::hglColor4f(HGGLNode *this, __n128 a2, float a3, float a4, float a5)
{
  *(void *)&double result = HGRasterizer::color4f((__n128 *)*((void *)this + 51), a2, a3, a4, a5).n128_u64[0];
  return result;
}

uint64_t HGGLNode::hglActiveTexture(HGGLNode *this, char a2)
{
  return HGRasterizer::activeTexture(*((void *)this + 51), a2);
}

uint64_t HGGLNode::hglLoadTransform(HGGLNode *this, const HGTransform *a2)
{
  return HGRasterizer::loadTransform(*((void *)this + 51));
}

uint64_t HGGLNode::hglTranslatef(HGGLNode *this, float a2, float a3, float a4)
{
  return HGRasterizer::translatef(*((void *)this + 51), a2, a3, a4);
}

uint64_t HGGLNode::hglTexCoord2f(__n128 **this, __n128 a2, float a3)
{
  return HGRasterizer::texCoord2f(this[51], a2, a3);
}

float32x4_t *HGGLNode::hglVertex2f(float32x4_t **this, float a2, float a3)
{
  return HGRasterizer::vertex4f(this[51], a2, a3, 0.0, 1.0);
}

float32x4_t *HGGLNode::hglVertex3f(float32x4_t **this, float a2, float a3, float a4)
{
  return HGRasterizer::vertex4f(this[51], a2, a3, a4, 1.0);
}

void *HGGLNode::hglVertexArray(HGGLNode *this, const HGArrayDataRef *a2, char *a3)
{
  return HGRasterizer::vertexArray(*((void **)this + 51), a2, a3);
}

const char *HGGLNode::hglTexCoordArray(const char **this, const HGArrayDataRef *a2)
{
  return HGRasterizer::texCoordArray(this[51], a2);
}

char *HGGLNode::hglTexParameteri(char **this, const char *a2, char *a3, float a4)
{
  float v5 = a4;
  return HGRasterizer::texParameterfv(this[51], a2, a3, &v5);
}

uint64_t HGGLNode::hglEnableTexCoordGen(HGGLNode *this, int a2)
{
  return HGRasterizer::enableTexCoordGen(*((void *)this + 51), a2);
}

char *HGGLNode::hglEnableClientState(char **this, int a2)
{
  return HGRasterizer::enableClientState(this[51], a2, 1);
}

void HGGLNode::hglDrawArrays(HGRasterizer **this, int a2, int a3, unsigned int a4)
{
}

uint64_t HGGLNode::hglDrawElements(HGGLNode *this, int a2, atomic_uint **a3)
{
  uint64_t v3 = *((void *)this + 51);
  int v8 = 0;
  uint64_t v9 = 0x300000000;
  uint64_t v4 = *a3;
  if (*a3)
  {
    int v8 = *a3;
    atomic_fetch_add(v4, 1u);
  }
  LODWORD(v9) = *((_DWORD *)a3 + 2);
  uint64_t result = HGRasterizer::drawElements(v3, a2, (uint64_t *)&v8);
  int v6 = v8;
  if (v8 && atomic_fetch_add(v8, 0xFFFFFFFF) == 1)
  {
    uint64_t v7 = *((void *)v6 + 2);
    if (v7) {
      MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
    }
    return MEMORY[0x1BA9BFBA0](v6, 0x1080C4098BBCF0FLL);
  }
  return result;
}

void sub_1B76E21B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

char *HGGLNode::hglDisableClientState(char **this, int a2)
{
  return HGRasterizer::enableClientState(this[51], a2, 0);
}

uint64_t HGGLNode::hglClearToBlack(HGGLNode *this)
{
  return HGRasterizer::clearToBlack(*((void *)this + 51));
}

uint64_t HGGLNode::hglEnableBlending(uint64_t a1, int a2, int a3)
{
  return HGRasterizer::enableBlending(*(void *)(a1 + 408), a2, a3);
}

uint64_t HGGLNode::GetOutput(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  if (atomic_fetch_add((atomic_uint *volatile)result, 0xFFFFFFFF) == 1)
  {
    uint64_t v7 = result;
    uint64_t v8 = *(void *)(result + 16);
    if (v8) {
      MEMORY[0x1BA9BFB70](v8, 0x1000C8077774924);
    }
    uint64_t result = MEMORY[0x1BA9BFBA0](v7, 0x1080C4098BBCF0FLL);
  }
  *(void *)a4 = a2;
  *(_DWORD *)(a4 + 8) = a3;
  return result;
}

void HGRasterizer::HGRasterizer(HGRasterizer *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10C5528;
  *(_DWORD *)(v1 + 408) = 897988541;
  *(void *)(v1 + 416) = 0;
  *(void *)(v1 + 424) = 0;
  HGArrayDataRef::allocate((HGArrayDataRef *)(v1 + 416));
}

void sub_1B76E27BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  HGObject::operator delete(v18);
  uint64_t v20 = *(void *)(v11 + 1224);
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 24))(v20);
  }
  if (*(char *)(v11 + 1223) < 0) {
    operator delete(*(void **)(v11 + 1200));
  }
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(v17);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(v16);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(v15);
  HGTransform::~HGTransform(v14);
  HGTransform::~HGTransform(v13);
  uint64_t v21 = *(void *)(v11 + 592);
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 24))(v21);
  }
  uint64_t v22 = *(void *)(v11 + 584);
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
  }
  uint64_t v23 = *(void *)(v11 + 576);
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
  }
  uint64_t v24 = *(void *)(v11 + 568);
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 24))(v24);
  }
  uint64_t v25 = *(void *)(v11 + 560);
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 24))(v25);
  }
  uint64_t v26 = *(void *)(v11 + 552);
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 24))(v26);
  }
  uint64_t v27 = *(void *)(v11 + 544);
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 24))(v27);
  }
  uint64_t v28 = *(void *)(v11 + 536);
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 24))(v28);
  }
  uint64_t v29 = *(void *)(v11 + 528);
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 24))(v29);
  }
  uint64_t v30 = *(void *)(v11 + 520);
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 24))(v30);
  }
  uint64_t v31 = *(void *)(v11 + 512);
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 24))(v31);
  }
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(v12);
  HGNode::~HGNode((HGNode *)v11);
  _Unwind_Resume(a1);
}

void HGRasterizer::~HGRasterizer(HGRasterizer *this)
{
  *(void *)this = &unk_1F10C5528;
  uint64_t v2 = (HGeometryData *)*((void *)this + 62);
  if (v2)
  {
    HGeometryData::~HGeometryData(v2);
    MEMORY[0x1BA9BFBA0]();
  }
  uint64_t v3 = (HGeometryData *)*((void *)this + 63);
  if (v3)
  {
    HGeometryData::~HGeometryData(v3);
    MEMORY[0x1BA9BFBA0]();
  }
  uint64_t v4 = (void *)*((void *)this + 54);
  if (v4)
  {
    (*(void (**)(void))(*(void *)*v4 + 24))();
    uint64_t v5 = v4[19];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    }
    HGTransform::~HGTransform((HGTransform *)(v4 + 1));
    MEMORY[0x1BA9BFBA0](v4, 0x10A0C408B9E766ELL);
  }
  int v6 = (void *)*((void *)this + 55);
  if (v6)
  {
    (*(void (**)(void))(*(void *)*v6 + 24))();
    uint64_t v7 = v6[19];
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
    }
    HGTransform::~HGTransform((HGTransform *)(v6 + 1));
    MEMORY[0x1BA9BFBA0](v6, 0x10A0C408B9E766ELL);
  }
  uint64_t v8 = (void *)*((void *)this + 56);
  if (v8)
  {
    (*(void (**)(void))(*(void *)*v8 + 24))();
    uint64_t v9 = v8[19];
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
    }
    HGTransform::~HGTransform((HGTransform *)(v8 + 1));
    MEMORY[0x1BA9BFBA0](v8, 0x10A0C408B9E766ELL);
  }
  __n128 v10 = (void *)*((void *)this + 57);
  if (v10)
  {
    (*(void (**)(void))(*(void *)*v10 + 24))();
    uint64_t v11 = v10[19];
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
    }
    HGTransform::~HGTransform((HGTransform *)(v10 + 1));
    MEMORY[0x1BA9BFBA0](v10, 0x10A0C408B9E766ELL);
  }
  __n128 v12 = (void *)*((void *)this + 58);
  if (v12)
  {
    (*(void (**)(void))(*(void *)*v12 + 24))();
    uint64_t v13 = v12[19];
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
    }
    HGTransform::~HGTransform((HGTransform *)(v12 + 1));
    MEMORY[0x1BA9BFBA0](v12, 0x10A0C408B9E766ELL);
  }
  uint64_t v14 = (void *)*((void *)this + 59);
  if (v14)
  {
    (*(void (**)(void))(*(void *)*v14 + 24))();
    uint64_t v15 = v14[19];
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
    }
    HGTransform::~HGTransform((HGTransform *)(v14 + 1));
    MEMORY[0x1BA9BFBA0](v14, 0x10A0C408B9E766ELL);
  }
  uint64_t v16 = (void *)*((void *)this + 60);
  if (v16)
  {
    (*(void (**)(void))(*(void *)*v16 + 24))();
    uint64_t v17 = v16[19];
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
    }
    HGTransform::~HGTransform((HGTransform *)(v16 + 1));
    MEMORY[0x1BA9BFBA0](v16, 0x10A0C408B9E766ELL);
  }
  uint64_t v18 = (void *)*((void *)this + 61);
  if (v18)
  {
    (*(void (**)(void))(*(void *)*v18 + 24))();
    uint64_t v19 = v18[19];
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 24))(v19);
    }
    HGTransform::~HGTransform((HGTransform *)(v18 + 1));
    MEMORY[0x1BA9BFBA0](v18, 0x10A0C408B9E766ELL);
  }
  uint64_t v20 = *((void *)this + 94);
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 24))(v20);
  }
  uint64_t v21 = *((void *)this + 95);
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 24))(v21);
  }
  uint64_t v22 = *((void *)this + 153);
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
  }
  if (*((char *)this + 1223) < 0) {
    operator delete(*((void **)this + 150));
  }
  uint64_t v23 = *((void *)this + 147);
  if (v23 && atomic_fetch_add((atomic_uint *volatile)v23, 0xFFFFFFFF) == 1)
  {
    uint64_t v24 = *(void *)(v23 + 16);
    if (v24) {
      MEMORY[0x1BA9BFB70](v24, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v23, 0x1080C4098BBCF0FLL);
  }
  uint64_t v25 = *((void *)this + 145);
  if (v25 && atomic_fetch_add((atomic_uint *volatile)v25, 0xFFFFFFFF) == 1)
  {
    uint64_t v26 = *(void *)(v25 + 16);
    if (v26) {
      MEMORY[0x1BA9BFB70](v26, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v25, 0x1080C4098BBCF0FLL);
  }
  uint64_t v27 = *((void *)this + 143);
  if (v27 && atomic_fetch_add((atomic_uint *volatile)v27, 0xFFFFFFFF) == 1)
  {
    uint64_t v28 = *(void *)(v27 + 16);
    if (v28) {
      MEMORY[0x1BA9BFB70](v28, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v27, 0x1080C4098BBCF0FLL);
  }
  HGTransform::~HGTransform((HGRasterizer *)((char *)this + 912));
  HGTransform::~HGTransform((HGRasterizer *)((char *)this + 768));
  uint64_t v29 = *((void *)this + 74);
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 24))(v29);
  }
  uint64_t v30 = *((void *)this + 73);
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 24))(v30);
  }
  uint64_t v31 = *((void *)this + 72);
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 24))(v31);
  }
  uint64_t v32 = *((void *)this + 71);
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 24))(v32);
  }
  uint64_t v33 = *((void *)this + 70);
  if (v33) {
    (*(void (**)(uint64_t))(*(void *)v33 + 24))(v33);
  }
  uint64_t v34 = *((void *)this + 69);
  if (v34) {
    (*(void (**)(uint64_t))(*(void *)v34 + 24))(v34);
  }
  uint64_t v35 = *((void *)this + 68);
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 24))(v35);
  }
  uint64_t v36 = *((void *)this + 67);
  if (v36) {
    (*(void (**)(uint64_t))(*(void *)v36 + 24))(v36);
  }
  uint64_t v37 = *((void *)this + 66);
  if (v37) {
    (*(void (**)(uint64_t))(*(void *)v37 + 24))(v37);
  }
  uint64_t v38 = *((void *)this + 65);
  if (v38) {
    (*(void (**)(uint64_t))(*(void *)v38 + 24))(v38);
  }
  uint64_t v39 = *((void *)this + 64);
  if (v39) {
    (*(void (**)(uint64_t))(*(void *)v39 + 24))(v39);
  }
  uint64_t v40 = *((void *)this + 52);
  if (v40 && atomic_fetch_add((atomic_uint *volatile)v40, 0xFFFFFFFF) == 1)
  {
    uint64_t v41 = *(void *)(v40 + 16);
    if (v41) {
      MEMORY[0x1BA9BFB70](v41, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v40, 0x1080C4098BBCF0FLL);
  }

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v1;
  uint64_t vars8;

  HGRasterizer::~HGRasterizer(this);

  HGObject::operator delete(v1);
}

uint64_t HGRasterizer::getActiveShaderNode(HGRasterizer *this)
{
  if (*((unsigned char *)this + 1077) && *((void *)this + 95)) {
    return *((void *)this + 95);
  }
  else {
    return *((void *)this + 94);
  }
}

uint64_t HGRasterizer::enableXFormConcatenation(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 1108) |= 0x80u;
  if (!*(unsigned char *)(result + 1141))
  {
    uint64_t v3 = result;
    uint64_t result = *(void *)(result + 760);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    }
    if (a2) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    }
    *(void *)(v3 + 760) = a2;
  }
  return result;
}

uint64_t HGRasterizer::RenderInputOrder(HGRasterizer *this, unsigned int a2)
{
  if (a2 == 1) {
    unsigned int v2 = 0;
  }
  else {
    unsigned int v2 = a2;
  }
  if (a2) {
    return v2;
  }
  else {
    return 1;
  }
}

uint64_t HGRasterizer::GetProgram(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1077) && (uint64_t v2 = *(void *)(a1 + 760)) != 0) {
    return (*(uint64_t (**)(void))(*(void *)v2 + 184))();
  }
  else {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 752) + 184))();
  }
}

uint64_t HGRasterizer::InitProgramDescriptor(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1077) && (uint64_t v2 = *(void *)(a1 + 760)) != 0) {
    return (*(uint64_t (**)(void))(*(void *)v2 + 328))();
  }
  else {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 752) + 328))();
  }
}

uint64_t HGRasterizer::RenderTile(atomic_uint *this, HGTile *a2)
{
  if (((*(uint64_t (**)(atomic_uint *, uint64_t))(*(void *)this + 152))(this, 0xFFFFFFFFLL) & 0x80) != 0)
  {
    unsigned int add = atomic_fetch_add(this + 279, 1u);
    unsigned int v7 = (*(uint64_t (**)(void, uint64_t))(**(void **)(*((void *)a2 + 42) + 152) + 128))(*(void *)(*((void *)a2 + 42) + 152), 5);
    int v8 = *((_DWORD *)a2 + 1);
    unsigned int v9 = (*((_DWORD *)a2 + 3) - v8) / v7;
    int v10 = v9 * add;
    unsigned int v11 = v9 * add + v8;
    unsigned int v12 = v11 + v9;
    if (add == v7 - 1) {
      unsigned int v13 = *((_DWORD *)a2 + 3);
    }
    else {
      unsigned int v13 = v12;
    }
    uint64_t v14 = HGRectMake4i(*(_DWORD *)a2, v11, *((_DWORD *)a2 + 2), v13);
    uint64_t v16 = v15;
    memcpy(v17, a2, sizeof(v17));
    v17[0] = v14;
    v17[1] = v16;
    v17[2] += 16 * (*((_DWORD *)a2 + 6) * v10);
    return (*(uint64_t (**)(atomic_uint *, void *, void))(*(void *)this + 656))(this, v17, 0);
  }
  else
  {
    uint64_t v4 = *(uint64_t (**)(atomic_uint *, HGTile *, uint64_t))(*(void *)this + 656);
    return v4(this, a2, 1);
  }
}

void HGRasterizer::RenderTile(HGRasterizer *this, HGTile *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  HGTile::Renderer(a2);
  operator new();
}

void sub_1B76E3CB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, HGSampleRectStat *a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  HGSampleRectStat::~HGSampleRectStat(v37);
  HGSampleRectStat::~HGSampleRectStat(v38);
  HGSampleRectStat::~HGSampleRectStat(v36);
  HGSampleRectStat::~HGSampleRectStat(v35);
  HGSampleRectStat::~HGSampleRectStat(v34);
  HGSampleRectStat::~HGSampleRectStat(v33);
  HGSampleRectStat::~HGSampleRectStat(a10);
  HGSampleRectStat::~HGSampleRectStat((HGSampleRectStat *)&a33);
  HGTransform::~HGTransform((HGTransform *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B76E3D04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTransform::~HGTransform((HGTransform *)va);
  _Unwind_Resume(a1);
}

char *HGRasterizer::begin(char *this, int a2)
{
  uint64_t v2 = this;
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (this[1140])
  {
    this[1140] = 0;
    *((_DWORD *)this + 274) = a2;
    *((_DWORD *)this + 298) = a2;
  }
  else
  {
    uint64_t v3 = *((void *)this + 62);
    *(unsigned char *)(v3 + 240) = 1;
    uint64_t v4 = *(void *)(v3 + 80);
    if (v4) {
      LODWORD(v4) = *(_DWORD *)(v4 + 8);
    }
    HGRasterizer::drawArrays((HGRasterizer *)this, *((_DWORD *)this + 274), *((_DWORD *)this + 278), v4 - *((_DWORD *)this + 278));
    v2[1140] = 1;
    snprintf(__str, 0x100uLL, "%s: invalid call between hglBegin/hglEnd", "hglBegin");
    *((_DWORD *)v2 + 275) = 1282;
    return (char *)HGLogger::warning((HGLogger *)"%s", v5, v6, __str);
  }
  return this;
}

void HGRasterizer::end(HGRasterizer *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 1140))
  {
    snprintf(__str, 0x100uLL, "%s: invalid call outside hglBegin/hglEnd", "hglEnd");
    *((_DWORD *)this + 275) = 1282;
    HGLogger::warning((HGLogger *)"%s", v2, v3, __str);
  }
  else
  {
    uint64_t v4 = *((void *)this + 62);
    *(unsigned char *)(v4 + 240) = 1;
    uint64_t v5 = *(void *)(v4 + 80);
    if (v5) {
      LODWORD(v5) = *(_DWORD *)(v5 + 8);
    }
    HGRasterizer::drawArrays(this, *((_DWORD *)this + 274), *((_DWORD *)this + 278), v5 - *((_DWORD *)this + 278));
    *((unsigned char *)this + 1140) = 1;
  }
}

void HGRasterizer::drawArrays(HGRasterizer *this, int a2, int a3, unsigned int a4)
{
  unsigned int v4 = a4 - 2;
  if ((int)a4 < 2) {
    return;
  }
  uint64_t v9 = *((void *)this + 62);
  uint64_t v10 = *(void *)(v9 + 16);
  if (v10)
  {
    int v11 = *(_DWORD *)(v10 + 8);
    int v12 = *(_DWORD *)(v9 + 244);
    if (!*(unsigned char *)(v9 + 240)) {
      goto LABEL_7;
    }
  }
  else
  {
    int v11 = 0;
    int v12 = *(_DWORD *)(v9 + 244);
    if (!*(unsigned char *)(v9 + 240))
    {
LABEL_7:
      uint64_t v15 = *(void *)(v9 + 64);
      unsigned int v13 = (HGArrayDataRef *)(v9 + 64);
      uint64_t v14 = v15;
      if (!v15) {
        HGArrayDataRef::allocate(v13);
      }
      signed int v16 = *(_DWORD *)(v14 + 8) + a4;
      if (*(_DWORD *)(v14 + 12) < v16)
      {
        int v17 = *(_DWORD *)(v14 + 4) * v16;
        *(_DWORD *)(v14 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v16;
        if (v17) {
          operator new[]();
        }
        uint64_t v18 = *(void *)(v14 + 16);
        if (v18) {
          MEMORY[0x1BA9BFB70](v18, 0x1000C8077774924);
        }
        *(void *)(v14 + 16) = 0;
      }
      __asm { FMOV            V0.4S, #1.0 }
      long long v83 = _Q0;
      unsigned int v24 = a4;
      do
      {
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(*((void *)this + 62) + 64)) = v83;
        --v24;
      }
      while (v24);
    }
  }
  if (a2 == 1)
  {
    HGRasterizer::drawLines(this);
  }
  else
  {
    *((_DWORD *)this + 278) += a4;
    unsigned int v25 = a2 - 4;
    switch(v25)
    {
      case 0u:
        unsigned int v4 = a4 / 3;
        int v26 = 3 * (a4 / 3);
        uint64_t v27 = *((void *)this + 62);
        if (*(_DWORD *)(v27 + 244)) {
          goto LABEL_29;
        }
        goto LABEL_34;
      case 1u:
      case 2u:
        int v26 = 3 * v4;
        uint64_t v27 = *((void *)this + 62);
        if (!*(_DWORD *)(v27 + 244)) {
          goto LABEL_34;
        }
        goto LABEL_29;
      case 3u:
        unsigned int v4 = (a4 >> 1) & 0x7FFFFFFE;
        int v26 = 3 * v4;
        uint64_t v27 = *((void *)this + 62);
        if (*(_DWORD *)(v27 + 244)) {
          goto LABEL_29;
        }
        goto LABEL_34;
      default:
        puts("Unknown polygon mode in drawArrays");
        int v26 = 0;
        unsigned int v4 = 0;
        uint64_t v27 = *((void *)this + 62);
        if (!*(_DWORD *)(v27 + 244)) {
          goto LABEL_34;
        }
LABEL_29:
        if (*((_DWORD *)this + 273) == 4)
        {
          uint64_t v28 = *(void *)(*((void *)this + 143) + 16)
              + *(int *)(*((void *)this + 143) + 4) * (*(int *)(*((void *)this + 143) + 8) - 1);
          *(_DWORD *)(v28 + *((int *)this + 288)) += v26;
          HGeometryData::SizeIndexArrays(v27, v4, v26);
          if (v25 > 3)
          {
LABEL_31:
            puts("Unknown polygon mode in drawArrays");
            return;
          }
        }
        else
        {
LABEL_34:
          *((_DWORD *)this + 273) = 4;
          *(_DWORD *)HGArray<int,(HGFormat)34>::append((HGRasterizer *)((char *)this + 1144)) = v26;
          *(_DWORD *)HGArray<int,(HGFormat)34>::append((HGRasterizer *)((char *)this + 1160)) = 4;
          int v29 = *(_DWORD *)(*((void *)this + 62) + 244);
          *(_DWORD *)HGArray<int,(HGFormat)34>::append((HGRasterizer *)((char *)this + 1176)) = v29;
          HGeometryData::SizeIndexArrays(*((void *)this + 62), v4, v26);
        }
        switch(v25)
        {
          case 0u:
            if (v4)
            {
              uint64_t v30 = (uint64_t *)*((void *)this + 62);
              uint64_t v31 = v30[2];
              uint64_t v32 = *(void *)(v31 + 16);
              uint64_t v33 = *v30;
              uint64_t v34 = *(void *)(*v30 + 16);
              uint64_t v35 = v30[6];
              uint64_t v36 = *(void *)(v35 + 16);
              do
              {
                int v37 = *(_DWORD *)(v31 + 4);
                uint64_t v38 = *((int *)v30 + 6);
                *(_WORD *)(v32 + v37 * v11 + v38) = a3;
                *(_WORD *)(v32 + v37 + v37 * v11 + v38) = a3 + 1;
                *(_WORD *)(v32 + v37 * (v11 + 2) + v38) = a3 + 2;
                *(_DWORD *)(v34 + *(int *)(v33 + 4) * (uint64_t)v12 + *((int *)v30 + HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = v11;
                *(_DWORD *)(v36 + *(int *)(v35 + 4) * (uint64_t)v12 + *((int *)v30 + 14)) = 3;
                a3 += 3;
                v11 += 3;
                ++v12;
                --v4;
              }
              while (v4);
            }
            break;
          case 1u:
            if (v4)
            {
              unsigned int v39 = 0;
              uint64_t v40 = (uint64_t *)*((void *)this + 62);
              uint64_t v41 = v40[2];
              uint64_t v42 = *(void *)(v41 + 16);
              uint64_t v43 = *v40;
              uint64_t v44 = *(void *)(*v40 + 16);
              uint64_t v45 = v40[6];
              uint64_t v46 = *(void *)(v45 + 16);
              do
              {
                int v47 = *(_DWORD *)(v41 + 4);
                uint64_t v48 = *((int *)v40 + 6);
                *(_WORD *)(v42 + v47 * v11 + v48) = a3 + v39;
                *(_WORD *)(v42 + v47 + v47 * v11 + v48) = a3 + v39 + 1;
                *(_WORD *)(v42 + v47 * (v11 + 2) + v48) = a3 + v39 + 2;
                *(_DWORD *)(v44 + *(int *)(v43 + 4) * (uint64_t)(int)(v12 + v39) + *((int *)v40 + HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = v11;
                *(_DWORD *)(v46 + *(int *)(v45 + 4) * (uint64_t)(int)(v12 + v39) + *((int *)v40 + 14)) = 3;
                v11 += 3;
                v39 += 2;
              }
              while (v39 < v4);
              if (v4 >= 2)
              {
                float64x2_t v49 = (uint64_t *)*((void *)this + 62);
                uint64_t v50 = v49[2];
                uint64_t v51 = *(void *)(v50 + 16);
                uint64_t v52 = *v49;
                uint64_t v53 = *(void *)(*v49 + 16);
                uint64_t v54 = v49[6];
                uint64_t v55 = *(void *)(v54 + 16);
                for (unsigned int i = 1; i < v4; i += 2)
                {
                  int v57 = *(_DWORD *)(v50 + 4);
                  int v58 = v57 * v11;
                  uint64_t v59 = *((int *)v49 + 6);
                  *(_WORD *)(v51 + v58 + v59) = a3 + i + 1;
                  *(_WORD *)(v51 + v57 + v58 + v59) = a3 + i;
                  *(_WORD *)(v51 + v57 * (v11 + 2) + v59) = a3 + i + 2;
                  *(_DWORD *)(v53 + *(int *)(v52 + 4) * (uint64_t)(int)(v12 + i) + *((int *)v49 + HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = v11;
                  *(_DWORD *)(v55 + *(int *)(v54 + 4) * (uint64_t)(int)(v12 + i) + *((int *)v49 + 14)) = 3;
                  v11 += 3;
                }
              }
            }
            break;
          case 2u:
            if (v4)
            {
              float32x4_t v60 = (uint64_t *)*((void *)this + 62);
              uint64_t v61 = v60[2];
              uint64_t v62 = *(void *)(v61 + 16);
              uint64_t v63 = *v60;
              uint64_t v64 = *(void *)(*v60 + 16);
              uint64_t v65 = v60[6];
              uint64_t v66 = *(void *)(v65 + 16);
              int v67 = a3;
              do
              {
                int v68 = *(_DWORD *)(v61 + 4);
                uint64_t v69 = *((int *)v60 + 6);
                *(_WORD *)(v62 + v68 * v11 + v69) = a3;
                __int16 v70 = v67++ + 2;
                *(_WORD *)(v62 + v68 + v68 * v11 + v69) = v67;
                *(_WORD *)(v62 + v68 * (v11 + 2) + v69) = v70;
                *(_DWORD *)(v64 + *(int *)(v63 + 4) * (uint64_t)v12 + *((int *)v60 + HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = v11;
                *(_DWORD *)(v66 + *(int *)(v65 + 4) * (uint64_t)v12 + *((int *)v60 + 14)) = 3;
                v11 += 3;
                ++v12;
                --v4;
              }
              while (v4);
            }
            break;
          case 3u:
            if (a4 >= 4)
            {
              unsigned int v71 = a4 >> 2;
              uint64_t v72 = (uint64_t *)*((void *)this + 62);
              uint64_t v73 = *v72;
              uint64_t v74 = *(void *)(*v72 + 16);
              uint64_t v75 = v72[6];
              uint64_t v76 = *(void *)(v75 + 16);
              uint64_t v77 = v72[2];
              uint64_t v78 = *(void *)(v77 + 16);
              do
              {
                *(_DWORD *)(v74 + *(int *)(v73 + 4) * (uint64_t)v12 + *((int *)v72 + HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = v11;
                *(_DWORD *)(v76 + *(int *)(v75 + 4) * (uint64_t)v12 + *((int *)v72 + 14)) = 3;
                int v79 = *(_DWORD *)(v77 + 4);
                uint64_t v80 = *((int *)v72 + 6);
                *(_WORD *)(v78 + v79 * v11 + v80) = a3;
                *(_WORD *)(v78 + v79 + v79 * v11 + v80) = a3 + 1;
                *(_WORD *)(v78 + v79 * (v11 + 2) + v80) = a3 + 2;
                *(_DWORD *)(v74 + *(int *)(v73 + 4) * (uint64_t)(v12 + 1) + *((int *)v72 + HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = v11 + 3;
                *(_DWORD *)(v76 + *(int *)(v75 + 4) * (uint64_t)(v12 + 1) + *((int *)v72 + 14)) = 3;
                v12 += 2;
                int v81 = *(_DWORD *)(v77 + 4);
                uint64_t v82 = *((int *)v72 + 6);
                *(_WORD *)(v78 + v81 * (v11 + 3) + v8PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a3;
                *(_WORD *)(v78 + v81 * (v11 + 4) + v8PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a3 + 2;
                *(_WORD *)(v78 + v81 * (v11 + 5) + v8PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a3 + 3;
                a3 += 4;
                v11 += 6;
                --v71;
              }
              while (v71);
            }
            break;
          default:
            goto LABEL_31;
        }
        break;
    }
  }
}

uint64_t HGRasterizer::activeTexture(uint64_t this, char a2)
{
  *(unsigned char *)(this + 1088) = a2 + 64;
  return this;
}

uint64_t HGRasterizer::matrixMode(uint64_t this, int a2)
{
  *(_DWORD *)(this + 1104) = a2;
  return this;
}

uint64_t HGRasterizer::getMatrixMode(HGRasterizer *this)
{
  return *((unsigned int *)this + 276);
}

uint64_t HGRasterizer::loadTransform(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 1104);
  if (v1 == 5890)
  {
    uint64_t result = **(void **)(result + 8 * *(unsigned __int8 *)(result + 1088) + 432);
    if (result) {
      return (*(uint64_t (**)(void))(*(void *)result + 96))();
    }
  }
  else if (v1 == 5888)
  {
    return (*(uint64_t (**)(void))(*(void *)(result + 768) + 96))();
  }
  return result;
}

uint64_t HGRasterizer::translatef(uint64_t this, float a2, float a3, float a4)
{
  int v4 = *(_DWORD *)(this + 1104);
  if (v4 == 5890)
  {
    this = **(void **)(this + 8 * *(unsigned __int8 *)(this + 1088) + 432);
    if (!this) {
      return this;
    }
  }
  else
  {
    if (v4 != 5888) {
      return this;
    }
    this += 768;
  }
  return (*(uint64_t (**)(double, double, double))(*(void *)this + 120))(a2, a3, a4);
}

uint64_t HGRasterizer::scalef(uint64_t this, float a2, float a3, float a4)
{
  int v4 = *(_DWORD *)(this + 1104);
  if (v4 == 5890)
  {
    this = **(void **)(this + 8 * *(unsigned __int8 *)(this + 1088) + 432);
    if (!this) {
      return this;
    }
  }
  else
  {
    if (v4 != 5888) {
      return this;
    }
    this += 768;
  }
  return (*(uint64_t (**)(double, double, double))(*(void *)this + 144))(a2, a3, a4);
}

float HGRasterizer::getSuperSampleScale(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1224);
  float result = 1.0;
  if (*(unsigned char *)(v1 + 12))
  {
    if (*(_DWORD *)(v1 + 16) == 1) {
      return (float)*(unsigned int *)(v1 + 20);
    }
  }
  return result;
}

uint64_t HGRasterizer::enableInplaceBlending(uint64_t this)
{
  *(_DWORD *)(this + 1108) |= 0x40u;
  return this;
}

BOOL HGRasterizer::SupportsInplaceHardwareBlending(HGRasterizer *this, float a2)
{
  return (*((_DWORD *)this + 277) & 0x44) == 64;
}

const char *HGRasterizer::label_B(HGRasterizer *this)
{
  v10[2] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 1077))
  {
    if (*((void *)this + 95) || *((void *)this + 94))
    {
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 8;
      strcpy((char *)&__p, "Shader: ");
      uint64_t v2 = *((void *)this + 95);
      if (v2) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
    return "No shader";
  }
  if (!*((void *)this + 94)) {
    return "No shader";
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 8;
  strcpy((char *)&__p, "Shader: ");
LABEL_8:
  uint64_t v2 = *((void *)this + 94);
LABEL_9:
  uint64_t v3 = (const std::string::value_type *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2);
  int v4 = std::string::append(&__p, v3);
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[0];
  v10[0] = v4->__r_.__value_.__l.__size_;
  *(void *)((char *)v10 + 7) = *(std::string::size_type *)((char *)&v4->__r_.__value_.__r.__words[1] + 7);
  char v6 = HIBYTE(v4->__r_.__value_.__r.__words[2]);
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  uint64_t v7 = (void **)((char *)this + 1200);
  if (*((char *)this + 1223) < 0) {
    operator delete(*v7);
  }
  *((void *)this + 150) = v5;
  *((void *)this + 15PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v10[0];
  *(void *)((char *)this + 1215) = *(void *)((char *)v10 + 7);
  *((unsigned char *)this + 1223) = v6;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((*((unsigned char *)this + 1223) & 0x80) == 0) {
      return (const char *)v7;
    }
    return (const char *)*v7;
  }
  if (v6 < 0) {
    return (const char *)*v7;
  }
  return (const char *)v7;
}

void sub_1B76E4988(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGRasterizer::addFragmentShader(uint64_t this, HGNode3D *a2)
{
  if (!*(unsigned char *)(this + 1141))
  {
    uint64_t v3 = this;
    *(unsigned char *)(this + 1064) = 1;
    uint64_t v4 = *(void *)(this + 752);
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
    }
    if (!a2)
    {
      std::string::size_type v5 = (HRasterizerGenerator *)HGObject::operator new(0x1B0uLL);
      HRasterizerGenerator::HRasterizerGenerator(v5);
    }
    this = (*(uint64_t (**)(HGNode3D *))(*(void *)a2 + 16))(a2);
    *(void *)(v3 + 75PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a2;
  }
  return this;
}

void sub_1B76E4A60(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 HGRasterizer::color4f(__n128 *this, __n128 result, float a3, float a4, float a5)
{
  result.n128_f32[1] = a3;
  result.n128_u64[1] = __PAIR64__(LODWORD(a5), LODWORD(a4));
  this[38] = result;
  return result;
}

uint64_t HGRasterizer::texCoord2f(__n128 *this, __n128 a2, float a3)
{
  this[66].n128_u32[3] |= 1u;
  a2.n128_f32[1] = a3;
  a2.n128_u32[2] = 0;
  a2.n128_u32[3] = 1.0;
  this[39] = a2;
  unint64_t v3 = this[27].n128_u64[0];
  uint64_t result = (*(uint64_t (**)(void))(**(void **)v3 + 224))();
  if (!result)
  {
    std::string::size_type v5 = *(uint64_t (**)(void))(**(void **)v3 + 208);
    return v5();
  }
  return result;
}

uint64_t HGRasterizer::enableTexCoordGen(uint64_t this, int a2)
{
  *(unsigned char *)(*(void *)(this + 8 * (a2 - 33984) + 432) + 193) = 1;
  return this;
}

float32x4_t *HGRasterizer::addVertex(float32x4_t *this, float a2, float a3, float a4, float a5)
{
  HGeometryData::AllocArrays(this[31].i64[0], this[67].i32[2] + 1, this[66].u32[3]);
  *(void *)&long long v6 = __PAIR64__(LODWORD(a3), LODWORD(a2));
  *((void *)&v6 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = __PAIR64__(LODWORD(a5), LODWORD(a4));
  *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 80)) = v6;
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v18 = vmaxq_f32(vminq_f32(this[38], _Q1), (float32x4_t)0);
  uint64_t result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 64));
  *uint64_t result = v18;
  __int32 v13 = this[66].i32[3];
  if (v13)
  {
    float32x4_t v20 = this[39];
    uint64_t result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 112));
    *uint64_t result = v20;
    __int32 v13 = this[66].i32[3];
    if ((v13 & 2) == 0)
    {
LABEL_3:
      if ((v13 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_13;
    }
  }
  else if ((v13 & 2) == 0)
  {
    goto LABEL_3;
  }
  float32x4_t v21 = this[40];
  uint64_t result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 128));
  *uint64_t result = v21;
  __int32 v13 = this[66].i32[3];
  if ((v13 & 4) == 0)
  {
LABEL_4:
    if ((v13 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_14;
  }
LABEL_13:
  float32x4_t v22 = this[41];
  uint64_t result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 144));
  *uint64_t result = v22;
  __int32 v13 = this[66].i32[3];
  if ((v13 & 8) == 0)
  {
LABEL_5:
    if ((v13 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_15;
  }
LABEL_14:
  float32x4_t v23 = this[42];
  uint64_t result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 160));
  *uint64_t result = v23;
  __int32 v13 = this[66].i32[3];
  if ((v13 & 0x10) == 0)
  {
LABEL_6:
    if ((v13 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_16;
  }
LABEL_15:
  float32x4_t v24 = this[43];
  uint64_t result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 176));
  *uint64_t result = v24;
  __int32 v13 = this[66].i32[3];
  if ((v13 & 0x20) == 0)
  {
LABEL_7:
    if ((v13 & 0x40) == 0) {
      goto LABEL_8;
    }
LABEL_17:
    float32x4_t v26 = this[45];
    uint64_t result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 208));
    *uint64_t result = v26;
    if ((this[66].i32[3] & 0x80) == 0) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_16:
  float32x4_t v25 = this[44];
  uint64_t result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 192));
  *uint64_t result = v25;
  __int32 v13 = this[66].i32[3];
  if ((v13 & 0x40) != 0) {
    goto LABEL_17;
  }
LABEL_8:
  if ((v13 & 0x80) != 0)
  {
LABEL_9:
    float32x4_t v19 = this[46];
    uint64_t result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 224));
    *uint64_t result = v19;
  }
LABEL_10:
  ++this[67].i32[2];
  return result;
}

float32x4_t *HGRasterizer::vertex4f(float32x4_t *this, float a2, float a3, float a4, float a5)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (this[71].i8[4])
  {
    snprintf(__str, 0x100uLL, "%s: invalid call outside hglBegin/hglEnd", "hglVertex4f");
    this[68].i32[3] = 1282;
    return (float32x4_t *)HGLogger::warning((HGLogger *)"%s", v6, v7, __str);
  }
  else
  {
    return HGRasterizer::addVertex(this, a2, a3, a4, a5);
  }
}

uint64_t HGRasterizer::clearToBlack(uint64_t this)
{
  *(_DWORD *)(this + 1108) |= 1u;
  return this;
}

uint64_t HGRasterizer::forceNoClearToBlack(uint64_t this)
{
  *(_DWORD *)(this + 1108) |= 0x10u;
  return this;
}

HGNode *HGRasterizer::EnableInplaceHardwareBlending(HGNode *this)
{
  (*(void (**)(HGNode *))(*(void *)this + 584))(this);

  return HGNode::EnableInplaceHardwareBlending(this);
}

uint64_t HGRasterizer::enableBlending(uint64_t result, int a2, int a3)
{
  if (a3) {
    int v3 = 37;
  }
  else {
    int v3 = 5;
  }
  *(_DWORD *)(result + 1108) |= v3;
  *(_DWORD *)(result + 1060) = a2;
  return result;
}

uint64_t HGRasterizer::SetParameter(HGRasterizer *this, const char *a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  float v10 = 0.0;
  if (a4 < 0.0) {
    a4 = 0.0;
  }
  if (a5 >= 0.0) {
    float v10 = a5;
  }
  uint64_t v11 = *((void *)this + 153);
  int v12 = *(unsigned __int8 *)(v11 + 12);
  int v13 = *(_DWORD *)(v11 + 16);
  int v14 = *(_DWORD *)(v11 + 20);
  int v15 = a4 != 0.0;
  LODWORD(v1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = vcvtps_s32_f32(v10);
  unsigned int v16 = v11 & 0xFFFFFFFE;
  if ((v11 & 0xFFFFFFFC) != 0) {
    unsigned int v16 = 4;
  }
  if (v10 == 0.0) {
    uint64_t v17 = 4;
  }
  else {
    uint64_t v17 = v16;
  }
  if (v17 != v10) {
    HGLogger::warning((HGLogger *)"Requested raster sample count for anti-aliasing was reduced from %3.2f to %d.\n", a2, a7, v10, v17);
  }
  if ((a3 == 1.0) != (v12 == 0) && v13 == v15 && v14 == v17) {
    return 0;
  }
  uint64_t v20 = *((void *)this + 153);
  *(unsigned char *)(v20 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a3 == 1.0;
  *(_DWORD *)(v20 + 16) = v15;
  *(_DWORD *)(v20 + 20) = v17;
  return 1;
}

float HGRasterizer::GetParameter(HGRasterizer *this, int a2, float *a3, float result)
{
  if (!a2)
  {
    uint64_t v4 = *((void *)this + 153);
    float v5 = 0.0;
    if (*(unsigned char *)(v4 + 12)) {
      float v6 = 1.0;
    }
    else {
      float v6 = 0.0;
    }
    if (*(_DWORD *)(v4 + 16)) {
      float v5 = 1.0;
    }
    *a3 = v6;
    a3[1] = v5;
    uint64_t result = (float)*(unsigned int *)(v4 + 20);
    a3[2] = result;
    a3[3] = 0.0;
  }
  return result;
}

uint64_t HGRasterizer::SetActiveShaderNodeParameter(HGRasterizer *this, uint64_t a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6)
{
  unsigned __int32 v6 = a6.n128_u32[0];
  unsigned __int32 v7 = a5.n128_u32[0];
  unsigned __int32 v8 = a4.n128_u32[0];
  unsigned __int32 v9 = a3.n128_u32[0];
  uint64_t v11 = *((void *)this + 95);
  if (v11) {
    (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)v11 + 96))(v11, a2, a3.n128_f32[0], a4.n128_f32[0], a5.n128_f32[0], a6.n128_f32[0]);
  }
  int v12 = *(uint64_t (**)(__n128, __n128, __n128, __n128))(**((void **)this + 94) + 96);
  a3.n128_u32[0] = v9;
  a4.n128_u32[0] = v8;
  a5.n128_u32[0] = v7;
  a6.n128_u32[0] = v6;

  return v12(a3, a4, a5, a6);
}

uint64_t HGRasterizer::GetROI(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a2 + 304))(a2) & 1) == 0
    && (*(unsigned char *)(a1 + 1109) & 4) != 0
    && (uint64_t v10 = *(void *)(a1 + 752)) != 0)
  {
    uint64_t v11 = *(uint64_t (**)(void))(*(void *)v10 + 400);
    return v11();
  }
  else
  {
    int v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 632);
    return v13(a1, 0xFFFFFFFFLL, a2, a3, a4, a5);
  }
}

uint64_t HGRasterizer::GetROI(HGRasterizer *this, int a2, HGRenderer *a3, uint64_t a4, HGRect a5)
{
  uint64_t v5 = *(void *)&a5.var2;
  if ((*(uint64_t (**)(HGRenderer *))(*(void *)a3 + 304))(a3))
  {
LABEL_14:
    if (a2 == -1)
    {
      uint64_t v19 = *(void *)(*((void *)this + 63) + 80);
      if (v19)
      {
        if (*(_DWORD *)(v19 + 8) >= 0xF4241u) {
          operator new();
        }
      }
    }
    operator new();
  }
  Input = HGRenderer::GetInput(a3, (HGNode *)this, a4);
  uint64_t v11 = (char *)this + 8 * (int)a4;
  if (*(_DWORD *)(*((void *)v11 + 54) + 168)) {
    Input = HGRenderer::GetInput(a3, Input, 0);
  }
  if ((*((unsigned char *)this + 1109) & 2) != 0)
  {
    if (!Input) {
      goto LABEL_14;
    }
  }
  else if (!Input {
         || ((*(uint64_t (**)(HGNode *, uint64_t))(*(void *)Input + 152))(Input, 0xFFFFFFFFLL) & 4) == 0)
  }
  {
    goto LABEL_14;
  }
  uint64_t DOD = HGRenderer::GetDOD(a3, Input);
  uint64_t v14 = v13;
  if (HGRectIsInfinite(DOD, v13) || (HIDWORD(v14) - HIDWORD(DOD)) * ((int)v14 - (int)DOD) > 0x4000) {
    goto LABEL_14;
  }
  int v15 = v11 + 432;
  if (!HGRectIsNull(DOD, v14))
  {
    if (HGTransform::IsIdentity((HGTransform *)(*(void *)v15 + 8)) || (uint64_t v20 = *((void *)this + 95)) == 0)
    {
      uint64_t v16 = (*(uint64_t (**)(void, HGRenderer *, uint64_t, uint64_t, uint64_t))(**((void **)this + 94) + 400))(*((void *)this + 94), a3, a4, DOD, v14);
    }
    else
    {
      (*(void (**)(uint64_t, HGRenderer *, uint64_t, uint64_t, uint64_t))(*(void *)v20 + 400))(v20, a3, a4, DOD, v14);
      uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(*(void *)v15 + 152) + 400))();
    }
    uint64_t v5 = v16;
    *(void *)&v22.var0 = v16;
    *(void *)&v22.var2 = v17;
  }
  uint64_t v21 = *(void *)v15;
  *(unsigned char *)(v21 + 194) = 1;
  *(HGRect *)(v21 + 176) = v22;
  return v5;
}

void sub_1B76E5B08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B76E5B1C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1020C40A6B7C7A9);
  _Unwind_Resume(a1);
}

unint64_t HGRasterizer::GetROI(HGRasterizer *this, HGRenderer *a2, uint64_t a3, HGRect a4, HGeometryData *a5, double a6, double a7, double a8, double a9, double a10, __n128 a11)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (((*((_DWORD *)this + 267) >> a3) & 1) == 0) {
    return 0;
  }
  unint64_t v13 = (char *)this + 8 * (int)a3;
  uint64_t v14 = *((void *)v13 + 54);
  if (*(unsigned char *)(v14 + 194)) {
    return *(void *)(v14 + 176);
  }
  uint64_t v17 = *((void *)this + 64);
  if (v17)
  {
    unsigned int v18 = *(_DWORD *)(v17 + 28) - *(_DWORD *)(v17 + 20);
    if (!v18) {
      return 0;
    }
  }
  else
  {
    uint64_t v19 = *((void *)a5 + 10);
    if (!v19) {
      return 0;
    }
    unsigned int v18 = *(_DWORD *)(v19 + 8);
    if (!v18) {
      return 0;
    }
  }
  uint64_t v20 = 0;
  uint64_t v21 = v13 + 432;
  HGRect v22 = (uint64_t *)((char *)this + 8 * (int)a3 + 536);
  float32x4_t v23 = (int *)((char *)a5 + 16 * (int)a3 + 112);
  uint64_t v24 = v18;
  a11.n128_u64[0] = 0x8000000080000000;
  unint64_t v25 = 0x8000000080000000;
  __asm { FMOV            V8.2S, #-1.0 }
  do
  {
    uint64_t v33 = *v22;
    if (*v22)
    {
      if ((*(unsigned char *)(v33 + 12) & 0x20) != 0)
      {
        __n128 v46 = a11;
        uint64_t Content = HGMetalBuffer::GetContent((id *)v33);
        a11 = v46;
      }
      else
      {
        uint64_t Content = *(void *)(v33 + 80);
      }
      int8x16_t v36 = *(int8x16_t *)(Content + 16 * v20);
      int8x8_t v48 = vext_s8(*(int8x8_t *)v36.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL), 4uLL);
      uint64_t v35 = &v47;
      __int32 v49 = v36.i32[3];
    }
    else
    {
      uint64_t v35 = (char *)(*(void *)(*(void *)v23 + 16) + *(int *)(*(void *)v23 + 4) * (uint64_t)(int)v20 + v23[2]);
      v36.i32[0] = *(_DWORD *)v35;
    }
    int v37 = (const float *)(v35 + 12);
    v38.i32[0] = *((_DWORD *)v35 + 1);
    v38.i32[1] = v36.i32[0];
    float32x2_t v39 = vld1_dup_f32(v37);
    float32x2_t v40 = vdiv_f32(v38, v39);
    if (v40.f32[1] > (float)(int)v25) {
      unint64_t v25 = v25 & 0xFFFFFFFF00000000 | (int)(float)(ceilf(v40.f32[1]) + 1.0);
    }
    float32x2_t v31 = vrndm_f32(v40);
    a11.n128_u64[0] = (unint64_t)vbsl_s8((int8x8_t)vcgt_f32(vcvt_f32_s32((int32x2_t)a11.n128_u64[0]), v40), (int8x8_t)vcvt_s32_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_f32(vsub_f32(v40, v31)), (int8x8_t)vadd_f32(v31, _D8), (int8x8_t)v31)), (int8x8_t)a11.n128_u64[0]);
    unsigned int v32 = (int)(float)(ceilf(v40.f32[0]) + 1.0);
    if (v40.f32[0] > (float)SHIDWORD(v25)) {
      unint64_t v25 = v25 | ((unint64_t)v32 << 32);
    }
    ++v20;
  }
  while (v24 != v20);
  unint64_t v41 = a11.n128_u32[0];
  unsigned __int32 v42 = a11.n128_u32[1];
  unint64_t v43 = a11.n128_u32[1] | ((unint64_t)a11.n128_u32[0] << 32);
  if (!HGRectIsNull(v43, v25))
  {
    if (HGTransform::IsIdentity((HGTransform *)(*(void *)v21 + 8)) || (uint64_t v45 = *((void *)this + 95)) == 0)
    {
      unint64_t v44 = (*(uint64_t (**)(void, HGRenderer *, uint64_t, unint64_t, unint64_t))(**((void **)this + 94) + 400))(*((void *)this + 94), a2, a3, v43, v25);
    }
    else
    {
      (*(void (**)(uint64_t, HGRenderer *, uint64_t, unint64_t, unint64_t))(*(void *)v45 + 400))(v45, a2, a3, v43, v25);
      unint64_t v44 = (*(uint64_t (**)(void))(**(void **)(*(void *)v21 + 152) + 400))();
    }
    unint64_t v41 = HIDWORD(v44);
    unsigned __int32 v42 = v44;
  }
  return v42 | (v41 << 32);
}

uint64_t HGRasterizer::GetDOD(HGRasterizer *this, HGRenderer *a2, int a3, HGRect a4)
{
  if ((*((unsigned char *)this + 1109) & 8) != 0) {
    return *(void *)&a4.var0;
  }
  if (a3 || HGRectIsNull(*(uint64_t *)&a4.var0, *(uint64_t *)&a4.var2) && HGRenderer::GetInput(a2, (HGNode *)this, 0))
  {
    *(void *)&a4.var0 = 0;
    return *(void *)&a4.var0;
  }
  return (*(uint64_t (**)(HGRasterizer *, HGRenderer *))(*(void *)this + 640))(this, a2);
}

uint64_t HGRasterizer::GetDOD(HGNode *this, int a2, HGRenderer *a3, int a4, HGRect a5)
{
  if (a4)
  {
    uint64_t v5 = &HGRectNull;
    return *(void *)v5;
  }
  if (HGRectIsNull(*(uint64_t *)&a5.var0, *(uint64_t *)&a5.var2) && HGRenderer::GetInput(a3, this, 0)) {
    return 0;
  }
  (*(void (**)(HGNode *, HGRenderer *))(*(void *)this + 640))(this, a3);
  uint64_t v5 = (long long *)*((void *)this + 52);
  if (!v5) {
    return *(void *)v5;
  }
  uint64_t v10 = *((void *)v5 + 2);
  if (v10) {
    return *(void *)(v10 + *((int *)v5 + 1) * (uint64_t)a2 + *((int *)this + 106));
  }
  else {
    return MEMORY[0];
  }
}

unint64_t HGRasterizer::CalculatePolygonDODs(HGRasterizer *this, HGRenderer *a2)
{
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (char *)this + 1124;
  if (*((unsigned char *)this + 1076)) {
    goto LABEL_2;
  }
  unsigned __int32 v8 = (HGRasterizer *)((char *)this + 768);
  int v9 = (*(uint64_t (**)(char *))(*((void *)this + 96) + 224))((char *)this + 768);
  if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) == 0)
  {
    uint64_t v10 = *((void *)this + 64);
    if (v10)
    {
      LODWORD(v3) = 0;
      unint64_t v4 = 0;
      unint64_t v11 = 0;
      if ((*(unsigned char *)(v10 + 12) & 0x20) != 0)
      {
        uint64_t Content = (HGTransformUtils *)HGMetalBuffer::GetContent(*((id **)this + 64));
        uint64_t v13 = (*(_DWORD *)(*((void *)this + 64) + 28) - *(_DWORD *)(*((void *)this + 64) + 20));
        if (!v13)
        {
LABEL_34:
          if (!v9)
          {
            float v30 = HGTransformUtils::MinW(Content);
            *(void *)&v122.var0 = v11;
            unint64_t DOD = HGTransformUtils::GetDOD(v8, (const HGTransform *)(v3 | (v4 << 32)), v122, 0.5, v30);
            unint64_t v11 = v32;
            unint64_t v4 = HIDWORD(DOD);
            LODWORD(v3) = DOD;
          }
          *(void *)uint64_t v2 = v3 | (v4 << 32);
          *((void *)v2 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v11;
          return v3 | (v4 << 32);
        }
      }
      else
      {
        uint64_t Content = *(HGTransformUtils **)(v10 + 80);
        uint64_t v13 = (*(_DWORD *)(v10 + 28) - *(_DWORD *)(v10 + 20));
        if (!v13) {
          goto LABEL_34;
        }
      }
      uint64_t v3 = (int)COERCE_FLOAT(*(_OWORD *)Content);
      unint64_t v4 = (int)COERCE_FLOAT(HIDWORD(*(void *)Content));
      unint64_t v11 = v3 | (v4 << 32);
      if (v13 != 1)
      {
        uint64_t v24 = (long long *)((char *)Content + 16);
        uint64_t v25 = v13 - 1;
        do
        {
          long long v26 = *v24++;
          float v27 = *((float *)&v26 + 1);
          LODWORD(v28) = (int)*(float *)&v26;
          if ((int)v3 >= (int)*(float *)&v26) {
            LODWORD(v3) = v28;
          }
          LODWORD(v29) = (int)v27;
          if ((int)v4 >= (int)v27) {
            unint64_t v4 = v29;
          }
          else {
            unint64_t v4 = v4;
          }
          if ((int)v11 <= (int)v28) {
            uint64_t v28 = v28;
          }
          else {
            uint64_t v28 = v11;
          }
          if (SHIDWORD(v11) <= (int)v29) {
            uint64_t v29 = v29;
          }
          else {
            uint64_t v29 = HIDWORD(v11);
          }
          unint64_t v11 = v28 | (v29 << 32);
          --v25;
        }
        while (v25);
      }
      goto LABEL_34;
    }
  }
  if ((*(unsigned int (**)(HGRenderer *))(*(void *)a2 + 304))(a2)
    && *((void *)this + 64)
    && (HGRasterizer::transformBuffersToGeometryInfo((float32x4_t *)this, v14, v15) & 1) == 0)
  {
    LODWORD(v3) = 0;
    unint64_t v4 = 0;
    return v3 | (v4 << 32);
  }
  v16.n128_f64[0] = HGeometryData::operator=(*((atomic_uint ***)this + 63), *((void *)this + 62));
  if ((*(unsigned int (**)(HGRenderer *, __n128))(*(void *)a2 + 304))(a2, v16))
  {
    unint64_t v19 = (*(uint64_t (**)(HGRasterizer *, HGRenderer *))(*(void *)this + 648))(this, a2);
    unint64_t v4 = HIDWORD(v19);
    LODWORD(v3) = v19;
    return v3 | (v4 << 32);
  }
  *((unsigned char *)this + 1076) = 1;
  uint64_t v20 = (HGRasterizer *)((char *)this + 416);
  if (*((unsigned char *)this + 1109))
  {
    uint64_t v33 = *(void *)v20;
    if (*(void *)v20)
    {
      if ((*(_DWORD *)(v33 + 12) & 0x80000000) != 0)
      {
        *(_DWORD *)(v33 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
        uint64_t v20 = *(HGArrayDataRef **)(v33 + 16);
        if (v20) {
          uint64_t v20 = (HGArrayDataRef *)MEMORY[0x1BA9BFB70](v20, 0x1000C8077774924);
        }
        *(void *)(v33 + 16) = 0;
        *(_DWORD *)(v33 + 8) = 0;
      }
      else
      {
        *(_DWORD *)(v33 + 8) = 0;
      }
    }
  }
  else
  {
    int v21 = *(_DWORD *)(*((void *)this + 63) + 244);
    uint64_t v22 = *((void *)this + 52);
    if (v22)
    {
      if (*(_DWORD *)(v22 + 12) < v21)
      {
        int v23 = *(_DWORD *)(v22 + 4) * v21;
        *(_DWORD *)(v22 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v21;
        if (v23) {
          operator new[]();
        }
        uint64_t v20 = *(HGArrayDataRef **)(v22 + 16);
        if (v20) {
          uint64_t v20 = (HGArrayDataRef *)MEMORY[0x1BA9BFB70](v20, 0x1000C8077774924);
        }
        *(void *)(v22 + 16) = 0;
      }
      *(_DWORD *)(v22 + 8) = v21;
    }
    else if (v21 > 0)
    {
      HGArrayDataRef::allocate(v20);
    }
  }
  uint64_t v34 = *((void *)this + 63);
  unsigned int v35 = *(_DWORD *)(v34 + 244);
  if ((*((unsigned char *)this + 1109) & 1) == 0 || v35 < 0x65)
  {
    if (!v35)
    {
LABEL_2:
      LODWORD(v3) = *(_DWORD *)v2;
      unint64_t v4 = *((unsigned int *)v2 + 1);
      return v3 | (v4 << 32);
    }
    int v50 = 0;
    while (1)
    {
      float v53 = 0.0;
      HIDWORD(v54) = 0;
      *(int32x2_t *)&long long v18 = vrev64_s32(0);
      float v55 = 0.0;
      uint64_t v56 = *(void *)(v34 + 48);
      uint64_t v57 = *(void *)(v56 + 16);
      int v58 = *(_DWORD *)(v56 + 4);
      int v59 = v50;
      uint64_t v60 = *(int *)(v34 + 56);
      if (*(int *)(v57 + v58 * (uint64_t)v50 + v60) >= 1) {
        break;
      }
      int v62 = 0;
LABEL_135:
      uint64_t v104 = HGRectIntegral(v34, v53, *((float *)&v18 + 1), *(float *)&v18, v55);
      uint64_t v51 = v104;
      unint64_t v52 = v105;
      if (v62)
      {
        unint64_t v106 = (v105 + 1) | v105 & 0xFFFFFFFF00000000;
        if (v104 != v105) {
          unint64_t v106 = v105;
        }
        if (HIDWORD(v104) == HIDWORD(v106)) {
          unint64_t v52 = v106 | ((v105 & 0xFFFFFFFF00000000) + 0x100000000);
        }
        else {
          unint64_t v52 = v106;
        }
      }
      if ((*((unsigned char *)this + 1109) & 1) == 0)
      {
        float v107 = (uint64_t *)(*(void *)(*((void *)this + 52) + 16)
                         + *(int *)(*((void *)this + 52) + 4) * (uint64_t)v59
                         + *((int *)this + 106));
        *float v107 = v104;
        v107[1] = v52;
      }
      if (v59 && !HGRectIsNull(*(void *)v2, *((void *)v2 + 1)))
      {
        BOOL IsNull = HGRectIsNull(v51, v52);
        uint64_t v109 = *(void *)v2;
        uint64_t v110 = *((void *)v2 + 1);
        if (!IsNull) {
          uint64_t v109 = HGRectUnion(v109, v110, v51, v52);
        }
        uint64_t v51 = v109;
        unint64_t v52 = v110;
      }
      *(void *)uint64_t v2 = v51;
      *((void *)v2 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v52;
      int v50 = v59 + 1;
      uint64_t v34 = *((void *)this + 63);
      if ((v59 + 1) >= *(_DWORD *)(v34 + 244)) {
        goto LABEL_2;
      }
    }
    int v61 = 0;
    int v62 = 0;
    while (1)
    {
      int v64 = *(_DWORD *)(*(void *)(*(void *)v34 + 16)
                      + *(int *)(*(void *)v34 + 4) * (uint64_t)v59
                      + *(int *)(v34 + 8));
      int v65 = *(_DWORD *)(v57 + v59 * (uint64_t)v58 + (int)v60);
      if (v65 <= v61) {
        int v66 = 0;
      }
      else {
        int v66 = v61;
      }
      int v67 = v66 + v64;
      uint64_t v68 = *(void *)(v34 + 16);
      uint64_t v69 = *(void *)(v68 + 16);
      int v70 = *(_DWORD *)(v68 + 4);
      uint64_t v71 = v69 + v67 * v70;
      uint64_t v72 = *(int *)(v34 + 24);
      int v73 = *(__int16 *)(v71 + v72);
      uint64_t v74 = *(void *)(v34 + 80);
      if (v9)
      {
        uint64_t v75 = *(void *)(v74 + 16);
        int v76 = *(_DWORD *)(v74 + 4);
        uint64_t v77 = *(int *)(v34 + 88);
        uint64_t v78 = (__int32 *)(v75 + v76 * (uint64_t)v73 + v77);
        v79.i32[0] = *v78;
        v118.i32[0] = *v78;
        __int32 v80 = v78[1];
        v118.i32[1] = v80;
        __int32 v119 = v78[2];
        v17.i32[0] = v78[3];
        float v120 = *(float *)v17.i32;
        LODWORD(v54) = *((_DWORD *)this + 102);
        if (*(float *)v17.i32 >= *(float *)&v54)
        {
          v79.i32[1] = v80;
          goto LABEL_104;
        }
        int v81 = v61 - 1;
        if (v65 < v61) {
          int v81 = 0;
        }
        if (!v61) {
          int v81 = v65 - 1;
        }
        uint64_t v82 = (float32x2_t *)(v75 + v76 * (uint64_t)*(__int16 *)(v69 + (v81 + v64) * v70 + v72) + v77);
        float32x2_t v115 = *v82;
        __int32 v116 = v82[1].i32[0];
        float v83 = v82[1].f32[1];
        float v117 = v83;
        if (v65 > v61 + 1) {
          int v84 = v61 + 1;
        }
        else {
          int v84 = 0;
        }
        float64x2_t v85 = (float32x2_t *)(v75 + v76 * (uint64_t)*(__int16 *)(v69 + (v84 + v64) * v70 + v72) + v77);
        float32x2_t v112 = *v85;
        __int32 v113 = v85[1].i32[0];
        float v114 = v85[1].f32[1];
        if (v83 < *(float *)&v54) {
          goto LABEL_126;
        }
      }
      else
      {
        long long v111 = v18;
        if (v74 && (uint64_t v86 = *(void *)(v74 + 16)) != 0) {
          uint64_t v87 = v86 + *(int *)(v74 + 4) * (uint64_t)*(__int16 *)(v71 + v72) + *(int *)(v34 + 88);
        }
        else {
          uint64_t v87 = 0;
        }
        (*(void (**)(HGTransformUtils *, float32x2_t *, uint64_t, uint64_t))(*((void *)this + 96) + 208))(v8, &v118, v87, 1);
        *(float *)v17.int i32 = v120;
        if (v120 >= *((float *)this + 102))
        {
          float32x2_t v79 = v118;
          long long v18 = v111;
LABEL_104:
          double v54 = COERCE_DOUBLE(vdiv_f32(v79, (float32x2_t)vdup_lane_s32(v17, 0)));
          if (*(float *)v17.i32 != 1.0) {
            *(double *)&float32x2_t v79 = v54;
          }
          float v95 = v79.f32[0];
          if (v62) {
            goto LABEL_130;
          }
          goto LABEL_73;
        }
        int v88 = v61 - 1;
        uint64_t v89 = (int *)*((void *)this + 63);
        int v90 = *(_DWORD *)(*(void *)(*((void *)v89 + 6) + 16)
                        + *(int *)(*((void *)v89 + 6) + 4) * (uint64_t)v59
                        + v89[14]);
        int v91 = v90 - 1;
        if (v90 < v61) {
          int v88 = 0;
        }
        if (v61) {
          int v91 = v88;
        }
        uint64_t v92 = *((void *)v89 + 10);
        if (v92 && (uint64_t v93 = *(void *)(v92 + 16)) != 0) {
          uint64_t v94 = v93
        }
              + *(int *)(v92 + 4)
              * (uint64_t)*(__int16 *)(*(void *)(*((void *)v89 + 2) + 16)
                                    + *(int *)(*((void *)v89 + 2) + 4)
                                    * (uint64_t)(v91
                                              + *(_DWORD *)(*(void *)(*(void *)v89 + 16)
                                                          + *(int *)(*(void *)v89 + 4) * (uint64_t)v59
                                                          + v89[2]))
                                    + v89[6])
              + v89[22];
        else {
          uint64_t v94 = 0;
        }
        (*(void (**)(HGTransformUtils *, float32x2_t *, uint64_t, uint64_t))(*((void *)this + 96) + 208))(v8, &v115, v94, 1);
        float v96 = (int *)*((void *)this + 63);
        if (*(_DWORD *)(*(void *)(*((void *)v96 + 6) + 16)
                       + *(int *)(*((void *)v96 + 6) + 4) * (uint64_t)v59
                       + v96[14]) > v61 + 1)
          int v97 = v61 + 1;
        else {
          int v97 = 0;
        }
        uint64_t v98 = *((void *)v96 + 10);
        if (v98 && (uint64_t v99 = *(void *)(v98 + 16)) != 0) {
          uint64_t v100 = v99
        }
               + *(int *)(v98 + 4)
               * (uint64_t)*(__int16 *)(*(void *)(*((void *)v96 + 2) + 16)
                                     + *(int *)(*((void *)v96 + 2) + 4)
                                     * (uint64_t)(v97
                                               + *(_DWORD *)(*(void *)(*(void *)v96 + 16)
                                                           + *(int *)(*(void *)v96 + 4) * (uint64_t)v59
                                                           + v96[2]))
                                     + v96[6])
               + v96[22];
        else {
          uint64_t v100 = 0;
        }
        (*(void (**)(HGTransformUtils *, float32x2_t *, uint64_t, uint64_t))(*((void *)this + 96) + 208))(v8, &v112, v100, 1);
        float v83 = v117;
        LODWORD(v54) = *((_DWORD *)this + 102);
        long long v18 = v111;
        if (v117 < *(float *)&v54) {
          goto LABEL_126;
        }
      }
      double v101 = COERCE_DOUBLE(vadd_f32(v118, vmul_n_f32(vsub_f32(v115, v118), (float)(*(float *)&v54 - v120) / (float)(v83 - v120))));
      int32x2_t v17 = (int32x2_t)vdiv_f32(*(float32x2_t *)&v101, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v54, 0));
      if (*(float *)&v54 == 1.0) {
        *(double *)&int32x2_t v17 = v101;
      }
      float v102 = *(float *)v17.i32;
      if (!v62)
      {
        int v62 = 1;
        *(int32x2_t *)&long long v18 = v17;
LABEL_125:
        float v55 = *(float *)&v17.i32[1];
        float v53 = v102;
        goto LABEL_126;
      }
      if (*(float *)v17.i32 >= v53) {
        float v102 = v53;
      }
      *(int8x8_t *)&long long v18 = vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(DWORD1(v18), v17.u32[0]), (float32x2_t)__PAIR64__(v17.u32[1], v18)), (int8x8_t)v17, *(int8x8_t *)&v18);
      float v53 = v102;
      if (*(float *)&v17.i32[1] > v55) {
        goto LABEL_125;
      }
LABEL_126:
      if (v114 < *(float *)&v54) {
        goto LABEL_75;
      }
      int32x2_t v17 = (int32x2_t)vsub_f32(v112, v118);
      float32x2_t v79 = vadd_f32(v118, vmul_n_f32((float32x2_t)v17, (float)(*(float *)&v54 - v120) / (float)(v114 - v120)));
      BOOL v103 = *(float *)&v54 == 1.0;
      double v54 = COERCE_DOUBLE(vdiv_f32(v79, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v54, 0)));
      if (!v103) {
        *(double *)&float32x2_t v79 = v54;
      }
      float v95 = v79.f32[0];
      if (v62)
      {
LABEL_130:
        if (v95 >= v53) {
          float v95 = v53;
        }
        int32x2_t v17 = vcgt_f32((float32x2_t)__PAIR64__(DWORD1(v18), v79.u32[0]), (float32x2_t)__PAIR64__(v79.u32[1], v18));
        *(int8x8_t *)&long long v18 = vbsl_s8((int8x8_t)v17, (int8x8_t)v79, *(int8x8_t *)&v18);
        float v53 = v95;
        if (v79.f32[1] <= v55) {
          goto LABEL_75;
        }
        goto LABEL_74;
      }
LABEL_73:
      int v62 = 1;
      *(float32x2_t *)&long long v18 = v79;
LABEL_74:
      float v55 = v79.f32[1];
      float v53 = v95;
LABEL_75:
      ++v61;
      uint64_t v34 = *((void *)this + 63);
      uint64_t v63 = *(void *)(v34 + 48);
      uint64_t v57 = *(void *)(v63 + 16);
      int v58 = *(_DWORD *)(v63 + 4);
      uint64_t v60 = *(int *)(v34 + 56);
      if (v61 >= *(_DWORD *)(v57 + v58 * (uint64_t)v59 + v60)) {
        goto LABEL_135;
      }
    }
  }
  LODWORD(v3) = 0;
  unint64_t v4 = 0;
  int32x2_t v36 = 0;
  uint64_t v37 = *(void *)(v34 + 80);
  if (v37)
  {
    int v38 = *(_DWORD *)(v37 + 8);
    if (v38)
    {
      float32x2_t v39 = (float32x2_t *)(*(void *)(v37 + 16) + *(int *)(v34 + 88));
      int32x2_t v40 = vcvt_s32_f32(*v39);
      LODWORD(v3) = v40.i32[0];
      unint64_t v4 = v40.u32[1];
      int32x2_t v36 = v40;
      int v41 = v38 - 1;
      if (v41)
      {
        int v42 = *(_DWORD *)(v37 + 4);
        int v43 = v42;
        do
        {
          int32x2_t v44 = vcvt_s32_f32(*(float32x2_t *)((char *)v39 + v43));
          int32x2_t v40 = vmin_s32(v40, v44);
          if (v36.i32[0] <= v44.i32[0]) {
            uint64_t v45 = v44.u32[0];
          }
          else {
            uint64_t v45 = v36.u32[0];
          }
          if (v36.i32[1] <= v44.i32[1]) {
            uint64_t v46 = v44.u32[1];
          }
          else {
            uint64_t v46 = v36.u32[1];
          }
          int32x2_t v36 = (int32x2_t)(v45 | (v46 << 32));
          v43 += v42;
          --v41;
        }
        while (v41);
        unint64_t v4 = v40.u32[1];
        LODWORD(v3) = v40.i32[0];
      }
    }
  }
  if (!v9)
  {
    float v47 = HGTransformUtils::MinW(v20);
    *(int32x2_t *)&v123.var0 = v36;
    unint64_t v48 = HGTransformUtils::GetDOD(v8, (const HGTransform *)(v3 | (v4 << 32)), v123, 0.5, v47);
    int32x2_t v36 = v49;
    unint64_t v4 = HIDWORD(v48);
    LODWORD(v3) = v48;
  }
  *(void *)uint64_t v2 = v3 | (v4 << 32);
  *((int32x2_t *)v2 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v36;
  return v3 | (v4 << 32);
}

uint64_t HGRasterizer::transformBuffersToGeometryInfo(float32x4_t *this, const char *a2, char *a3)
{
  if (this[67].i32[2]) {
    return 0;
  }
  uint64_t v5 = this[32].i64[0];
  if (!v5)
  {
    uint64_t v22 = "Rasterizer::transformBuffersToGeometryInfo - no populated vertexBuffer set.";
LABEL_53:
    HGLogger::warning((HGLogger *)v22, a2, a3);
    return 0;
  }
  uint64_t v70 = *(void *)(v5 + 80);
  uint64_t v6 = this[33].i64[0];
  if (v6 && *(_DWORD *)(v6 + 28) - *(_DWORD *)(v6 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20))
  {
    uint64_t v22 = "Rasterizer::transformBuffersToGeometryInfo - size mismatch between color and vertex buffers.";
    goto LABEL_53;
  }
  uint64_t v68 = *(void *)(v6 + 80);
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  uint64_t v7 = this[33].i64[1];
  if (v7)
  {
    if (*(_DWORD *)(v7 + 28) - *(_DWORD *)(v7 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20)) {
      goto LABEL_30;
    }
    uint64_t v7 = *(void *)(v7 + 80);
  }
  *(void *)&long long v71 = v7;
  uint64_t v8 = this[34].i64[0];
  if (v8)
  {
    if (*(_DWORD *)(v8 + 28) - *(_DWORD *)(v8 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20)) {
      goto LABEL_30;
    }
    uint64_t v8 = *(void *)(v8 + 80);
  }
  *((void *)&v71 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v8;
  uint64_t v9 = this[34].i64[1];
  if (v9)
  {
    if (*(_DWORD *)(v9 + 28) - *(_DWORD *)(v9 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20)) {
      goto LABEL_30;
    }
    uint64_t v9 = *(void *)(v9 + 80);
  }
  *(void *)&long long v72 = v9;
  uint64_t v10 = this[35].i64[0];
  if (v10)
  {
    if (*(_DWORD *)(v10 + 28) - *(_DWORD *)(v10 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20)) {
      goto LABEL_30;
    }
    uint64_t v10 = *(void *)(v10 + 80);
  }
  *((void *)&v72 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v10;
  uint64_t v11 = this[35].i64[1];
  if (v11)
  {
    if (*(_DWORD *)(v11 + 28) - *(_DWORD *)(v11 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20)) {
      goto LABEL_30;
    }
    uint64_t v11 = *(void *)(v11 + 80);
  }
  *(void *)&long long v73 = v11;
  uint64_t v12 = this[36].i64[0];
  if (v12)
  {
    if (*(_DWORD *)(v12 + 28) - *(_DWORD *)(v12 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20)) {
      goto LABEL_30;
    }
    uint64_t v12 = *(void *)(v12 + 80);
  }
  *((void *)&v73 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v12;
  uint64_t v13 = this[36].i64[1];
  if (v13)
  {
    if (*(_DWORD *)(v13 + 28) - *(_DWORD *)(v13 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20)) {
      goto LABEL_30;
    }
    uint64_t v13 = *(void *)(v13 + 80);
  }
  *(void *)&long long v74 = v13;
  uint64_t v14 = this[37].i64[0];
  if (!v14) {
    goto LABEL_31;
  }
  if (*(_DWORD *)(v14 + 28) - *(_DWORD *)(v14 + 20) == *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20))
  {
    *((void *)&v74 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(void *)(v14 + 80);
    goto LABEL_31;
  }
LABEL_30:
  HGLogger::warning((HGLogger *)"Rasterizer::transformBuffersToGeometryInfo - size mismatch between color and tex coord buffers.", a2, a3);
  uint64_t v5 = this[32].i64[0];
LABEL_31:
  if (*(_DWORD *)(v5 + 28) != *(_DWORD *)(v5 + 20))
  {
    unint64_t v23 = 0;
    uint64_t v24 = this + 39;
    __asm { FMOV            V0.4S, #1.0 }
    float32x4_t v69 = _Q0;
    do
    {
      float32x4_t v30 = v69;
      if (this[33].i64[0]) {
        float32x4_t v30 = *(float32x4_t *)(v68 + 16 * v23);
      }
      uint64_t v31 = 0;
      this[38] = v30;
      uint64_t v32 = 39;
      do
      {
        uint64_t v33 = *((void *)&v71 + v31);
        if (v33)
        {
          float32x4_t v34 = *(float32x4_t *)(v33 + 16 * v23);
          this[66].i32[3] |= 1 << v31;
          v24[v31] = v34;
          unsigned int v35 = (void *)this[27].i64[v31];
          if (!(*(unsigned int (**)(void))(*(void *)*v35 + 224))()) {
            (*(void (**)(void, float32x4_t *, float32x4_t *, uint64_t))(*(void *)*v35 + 208))(*v35, &this[v32], &this[v32], 1);
          }
        }
        else
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0A78, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EB9A0A78))
          {
            _MergedGlobals_1 = nanf("");
            __cxa_guard_release(&qword_1EB9A0A78);
          }
          if ((atomic_load_explicit((atomic_uchar *volatile)qword_1EB9A0A80, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(qword_1EB9A0A80))
          {
            int32x2_t v36 = (const float *)&_MergedGlobals_1;
            float32x4_t v37 = vld1q_dup_f32(v36);
            xmmword_1EB9A0A90 = (__int128)v37;
            __cxa_guard_release(qword_1EB9A0A80);
          }
          v24[v31] = (float32x4_t)xmmword_1EB9A0A90;
        }
        ++v31;
        ++v32;
      }
      while (v31 != 8);
      HGRasterizer::addVertex(this, *(float *)(v70 + 16 * v23), *(float *)(v70 + 16 * v23 + 4), *(float *)(v70 + 16 * v23 + 8), *(float *)(v70 + 16 * v23 + 12));
      ++v23;
    }
    while (v23 < (*(_DWORD *)(this[32].i64[0] + 28) - *(_DWORD *)(this[32].i64[0] + 20)));
  }
  uint64_t v15 = this[31].i64[0];
  *(unsigned char *)(v15 + 240) = 1;
  uint64_t v16 = this[32].i64[1];
  if (!v16)
  {
    uint64_t v38 = *(void *)(v15 + 80);
    if (v38) {
      LODWORD(v38) = *(_DWORD *)(v38 + 8);
    }
    HGRasterizer::drawArrays((HGRasterizer *)this, this[68].i32[2], this[69].i32[2], v38 - this[69].i32[2]);
    return 1;
  }
  int v17 = *(_DWORD *)(v16 + 28);
  int v18 = *(_DWORD *)(v16 + 20);
  (*(void (**)(uint64_t))(*(void *)v16 + 16))(this[32].i64[1]);
  unint64_t v19 = *(int16x8_t **)(v16 + 80);
  (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
  uint64_t v20 = (v17 - v18);
  if (v17 == v18)
  {
    int v21 = 0;
    goto LABEL_66;
  }
  if (v20 >= 0x10)
  {
    uint64_t v39 = v20 & 0xFFFFFFF0;
    int32x2_t v40 = v19 + 1;
    int32x4_t v41 = 0uLL;
    v42.i64[0] = -1;
    v42.i64[1] = -1;
    v43.i64[0] = 0x100000001;
    v43.i64[1] = 0x100000001;
    uint64_t v44 = v39;
    int32x4_t v45 = 0uLL;
    int32x4_t v46 = 0uLL;
    int32x4_t v47 = 0uLL;
    do
    {
      uint16x8_t v48 = (uint16x8_t)vceqq_s16(v40[-1], v42);
      uint16x8_t v49 = (uint16x8_t)vceqq_s16(*v40, v42);
      int32x4_t v45 = vaddq_s32(v45, (int32x4_t)vandq_s8((int8x16_t)vmovl_high_u16(v48), v43));
      int32x4_t v41 = vaddq_s32(v41, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v48.i8), v43));
      int32x4_t v47 = vaddq_s32(v47, (int32x4_t)vandq_s8((int8x16_t)vmovl_high_u16(v49), v43));
      int32x4_t v46 = vaddq_s32(v46, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v49.i8), v43));
      v40 += 2;
      v44 -= 16;
    }
    while (v44);
    int v21 = vaddvq_s32(vaddq_s32(vaddq_s32(v46, v41), vaddq_s32(v47, v45)));
    if (v39 == v20) {
      goto LABEL_66;
    }
  }
  else
  {
    uint64_t v39 = 0;
    int v21 = 0;
  }
  int v50 = &v19->i16[v39];
  uint64_t v51 = v20 - v39;
  do
  {
    int v52 = *v50++;
    if (v52 == -1) {
      ++v21;
    }
    --v51;
  }
  while (v51);
LABEL_66:
  int v53 = v21 + v20;
  uint64_t v54 = this[31].i64[0];
  uint64_t v57 = *(void *)(v54 + 32);
  float v55 = (HGArrayDataRef *)(v54 + 32);
  uint64_t v56 = v57;
  if (v57)
  {
    if (*(_DWORD *)(v56 + 12) < v53)
    {
      int v58 = *(_DWORD *)(v56 + 4) * v53;
      *(_DWORD *)(v56 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v53;
      if (v58) {
        operator new[]();
      }
      uint64_t v60 = *(void *)(v56 + 16);
      if (v60) {
        MEMORY[0x1BA9BFB70](v60, 0x1000C8077774924);
      }
      *(void *)(v56 + 16) = 0;
    }
    *(_DWORD *)(v56 + 8) = v53;
    if (v17 != v18) {
      goto LABEL_78;
    }
  }
  else
  {
    if (v53 > 0) {
      HGArrayDataRef::allocate(v55);
    }
    if (v17 != v18)
    {
LABEL_78:
      uint64_t v61 = 0;
      int v62 = 0;
      do
      {
        while (1)
        {
          int v63 = v19->u16[v61];
          if (v63 == 0xFFFF) {
            break;
          }
          uint64_t v59 = this[31].i64[0];
          *(_WORD *)(*(void *)(*(void *)(v59 + 32) + 16)
                   + *(int *)(*(void *)(v59 + 32) + 4) * (uint64_t)v62
                   + *(int *)(v59 + 40)) = v63;
          ++v61;
          ++v62;
          if (v61 == v20) {
            goto LABEL_82;
          }
        }
        uint64_t v59 = this[31].i64[0];
        uint64_t v64 = *(void *)(v59 + 32);
        uint64_t v65 = *(void *)(v64 + 16);
        uint64_t v66 = *(int *)(v64 + 4);
        uint64_t v67 = *(int *)(v59 + 40);
        *(_WORD *)(v65 + (int)v66 * (uint64_t)v62 + v67) = v19->i16[v61++ - 1];
        *(_WORD *)(v65 + v66 * (v62 + 1) + v67) = v19->i16[v61];
        v62 += 2;
      }
      while (v61 != v20);
      goto LABEL_82;
    }
  }
  uint64_t v59 = this[31].i64[0];
LABEL_82:
  HGRasterizer::drawElements((uint64_t)this, this[68].i32[2], (uint64_t *)(v59 + 32));
  return 1;
}

uint64_t HGRasterizer::CalculatePolygonDODsCPU(HGRasterizer *this, HGRenderer *a2)
{
  if (!*((unsigned char *)this + 1076))
  {
    *((unsigned char *)this + 1076) = 1;
    int v3 = *(_DWORD *)(*((void *)this + 63) + 244);
    uint64_t v4 = *((void *)this + 52);
    if (v4)
    {
      if (*(_DWORD *)(v4 + 12) < v3)
      {
        int v5 = *(_DWORD *)(v4 + 4) * v3;
        *(_DWORD *)(v4 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v3;
        if (v5) {
          operator new[]();
        }
        uint64_t v6 = *(void *)(v4 + 16);
        if (v6) {
          MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
        }
        *(void *)(v4 + 16) = 0;
      }
      *(_DWORD *)(v4 + 8) = v3;
    }
    else if (v3 > 0)
    {
      HGArrayDataRef::allocate((HGRasterizer *)((char *)this + 416));
    }
    v7[0] = 0;
    v7[1] = 0x1C00000000;
    HGArrayDataRef::allocate((HGArrayDataRef *)v7);
  }
  return *(void *)((char *)this + 1124);
}

void sub_1B76E77F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76E7804(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, atomic_uint *a9, uint64_t a10, _Unwind_Exception *a11)
{
  if (a9)
  {
    HGRasterizer::HGRasterizer(a9);
    exception_object = a11;
  }
  _Unwind_Resume(exception_object);
}

void sub_1B76E782C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76E7840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76E7854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76E7868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGRasterizer::BindTexture(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3 && (*(unsigned char *)(a1 + 1108) & 0x40) != 0)
  {
    double v5 = (*(double (**)(uint64_t))(*(void *)a1 + 288))(a1);
    (*(void (**)(uint64_t, void, double, float, float, float))(*(void *)a2 + 136))(a2, 0, v5, *(float *)&v5, *(float *)&v5, *(float *)&v5);
  }
  if (!*(unsigned char *)(a1 + 1077) || (uint64_t v6 = *(void *)(a1 + 760)) == 0) {
    uint64_t v6 = *(void *)(a1 + 752);
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 208);

  return v7();
}

uint64_t HGRasterizer::Bind(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1077) && (uint64_t v2 = *(void *)(a1 + 760)) != 0) {
    return (*(uint64_t (**)(void))(*(void *)v2 + 200))();
  }
  else {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 752) + 200))();
  }
}

uint64_t HGRasterizer::UnBind(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1077) && (uint64_t v2 = *(void *)(a1 + 760)) != 0) {
    return (*(uint64_t (**)(void))(*(void *)v2 + 216))();
  }
  else {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 752) + 216))();
  }
}

char *HGRasterizer::GeometryRenderPageMetal(HGRasterizer *this, HGPage *a2, HGMetalHandler *a3)
{
  uint64_t v5 = *((void *)this + 64);
  if (v5)
  {
    (*(void (**)(void, HGPage *))(*(void *)v5 + 16))(*((void *)this + 64), a2);
    __int32 v80 = (char *)v5;
    HGMetalHandler::SetVertices((uint64_t)a3, (uint64_t *)&v80);
    uint64_t result = v80;
    if (v80) {
      uint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)v80 + 24))(v80);
    }
    if (!*((void *)this + 64)) {
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v9 = *((void *)this + 63);
    uint64_t v10 = *(void *)(v9 + 80);
    if (v10)
    {
      uint64_t v11 = *(void *)(v10 + 16);
      if (v11)
      {
        uint64_t result = HGMetalHandler::SetVertices(a3, (const void *)(v11 + *(int *)(v9 + 88)), *(int *)(v10 + 4), *(_DWORD *)(v10 + 8));
        if (!*((void *)this + 64)) {
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t result = HGMetalHandler::SetVertices(a3, 0, *(int *)(v10 + 4), *(_DWORD *)(v10 + 8));
        if (!*((void *)this + 64)) {
          goto LABEL_19;
        }
      }
    }
    else
    {
      uint64_t result = HGMetalHandler::SetVertices(a3, 0, 0, 0);
      if (!*((void *)this + 64)) {
        goto LABEL_19;
      }
    }
  }
  uint64_t v7 = *((void *)this + 65);
  if (v7)
  {
    (*(void (**)(void))(*(void *)v7 + 16))(*((void *)this + 65));
    float32x2_t v79 = (char *)v7;
    HGMetalHandler::SetIndices((uint64_t)a3, (uint64_t *)&v79);
    uint64_t result = v79;
    if (v79) {
      uint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)v79 + 24))(v79);
    }
  }
  if (*((void *)this + 64))
  {
    uint64_t v8 = *((void *)this + 66);
    if (v8)
    {
      (*(void (**)(void))(*(void *)v8 + 16))(*((void *)this + 66));
      uint64_t v78 = (char *)v8;
      HGMetalHandler::SetColors((uint64_t)a3, (uint64_t *)&v78);
      uint64_t result = v78;
      if (v78) {
        uint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)v78 + 24))(v78);
      }
      goto LABEL_27;
    }
  }
LABEL_19:
  uint64_t v12 = *((void *)this + 63);
  if (*(unsigned char *)(v12 + 240))
  {
    uint64_t v13 = *(void *)(v12 + 64);
    if (v13)
    {
      uint64_t v14 = *(void *)(v13 + 16);
      if (v14) {
        uint64_t v15 = (const void *)(v14 + *(int *)(v12 + 72));
      }
      else {
        uint64_t v15 = 0;
      }
      unsigned int v17 = *(_DWORD *)(v13 + 8);
      uint64_t v16 = *(int *)(v13 + 4);
    }
    else
    {
      uint64_t v16 = 0;
      uint64_t v15 = 0;
      unsigned int v17 = 0;
    }
    uint64_t result = HGMetalHandler::SetColors(a3, v15, v16, v17);
  }
LABEL_27:
  if (*((void *)this + 64))
  {
    if (*((unsigned char *)this + 1068))
    {
      uint64_t v18 = *((void *)this + 67);
      if (v18) {
        (*(void (**)(void))(*(void *)v18 + 16))(*((void *)this + 67));
      }
      uint64_t v77 = (char *)v18;
      HGMetalHandler::SetTextureCoords((uint64_t)a3, (uint64_t *)&v77, 0);
      uint64_t result = v77;
      if (v77) {
        uint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)v77 + 24))(v77);
      }
    }
    if ((*((unsigned char *)this + 1068) & 2) != 0)
    {
      uint64_t v19 = *((void *)this + 68);
      if (v19) {
        (*(void (**)(void))(*(void *)v19 + 16))(*((void *)this + 68));
      }
      uint64_t v77 = (char *)v19;
      HGMetalHandler::SetTextureCoords((uint64_t)a3, (uint64_t *)&v77, 1u);
      uint64_t result = v77;
      if (v77) {
        uint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)v77 + 24))(v77);
      }
    }
    if ((*((unsigned char *)this + 1068) & 4) != 0)
    {
      uint64_t v20 = *((void *)this + 69);
      if (v20) {
        (*(void (**)(void))(*(void *)v20 + 16))(*((void *)this + 69));
      }
      uint64_t v77 = (char *)v20;
      HGMetalHandler::SetTextureCoords((uint64_t)a3, (uint64_t *)&v77, 2u);
      uint64_t result = v77;
      if (v77) {
        uint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)v77 + 24))(v77);
      }
    }
    if ((*((unsigned char *)this + 1068) & 8) != 0)
    {
      uint64_t v21 = *((void *)this + 70);
      if (v21) {
        (*(void (**)(void))(*(void *)v21 + 16))(*((void *)this + 70));
      }
      uint64_t v77 = (char *)v21;
      HGMetalHandler::SetTextureCoords((uint64_t)a3, (uint64_t *)&v77, 3u);
      uint64_t result = v77;
      if (v77) {
        uint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)v77 + 24))(v77);
      }
    }
    if ((*((unsigned char *)this + 1068) & 0x10) != 0)
    {
      uint64_t v22 = *((void *)this + 71);
      if (v22) {
        (*(void (**)(void))(*(void *)v22 + 16))(*((void *)this + 71));
      }
      uint64_t v77 = (char *)v22;
      HGMetalHandler::SetTextureCoords((uint64_t)a3, (uint64_t *)&v77, 4u);
      uint64_t result = v77;
      if (v77) {
        uint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)v77 + 24))(v77);
      }
    }
    if ((*((unsigned char *)this + 1068) & 0x20) != 0)
    {
      uint64_t v23 = *((void *)this + 72);
      if (v23) {
        (*(void (**)(void))(*(void *)v23 + 16))(*((void *)this + 72));
      }
      uint64_t v77 = (char *)v23;
      HGMetalHandler::SetTextureCoords((uint64_t)a3, (uint64_t *)&v77, 5u);
      uint64_t result = v77;
      if (v77) {
        uint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)v77 + 24))(v77);
      }
    }
    if ((*((unsigned char *)this + 1068) & 0x40) != 0)
    {
      uint64_t v24 = *((void *)this + 73);
      if (v24) {
        (*(void (**)(void))(*(void *)v24 + 16))(*((void *)this + 73));
      }
      uint64_t v77 = (char *)v24;
      HGMetalHandler::SetTextureCoords((uint64_t)a3, (uint64_t *)&v77, 6u);
      uint64_t result = v77;
      if (v77) {
        uint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)v77 + 24))(v77);
      }
    }
    if ((*((unsigned char *)this + 1068) & 0x80) != 0)
    {
      uint64_t v25 = *((void *)this + 74);
      if (v25) {
        (*(void (**)(void))(*(void *)v25 + 16))(*((void *)this + 74));
      }
      uint64_t v77 = (char *)v25;
      HGMetalHandler::SetTextureCoords((uint64_t)a3, (uint64_t *)&v77, 7u);
      uint64_t result = v77;
      if (v77) {
        uint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)v77 + 24))(v77);
      }
    }
LABEL_76:
    if (*((void *)this + 64)) {
      goto LABEL_77;
    }
    goto LABEL_140;
  }
  int v26 = *((_DWORD *)this + 267);
  if ((v26 & 1) == 0)
  {
    if ((v26 & 2) == 0) {
      goto LABEL_70;
    }
LABEL_91:
    uint64_t v33 = *((void *)this + 63);
    uint64_t v34 = *(void *)(v33 + 128);
    if (v34)
    {
      uint64_t v35 = *(void *)(v34 + 16);
      if (v35) {
        int32x2_t v36 = (const void *)(v35 + *(int *)(v33 + 136));
      }
      else {
        int32x2_t v36 = 0;
      }
      uint64_t result = HGMetalHandler::SetTextureCoords(a3, v36, *(int *)(v34 + 4), *(_DWORD *)(v34 + 8), 1u);
      int v26 = *((_DWORD *)this + 267);
      if ((v26 & 4) != 0) {
        goto LABEL_98;
      }
    }
    else
    {
      uint64_t result = HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 1u);
      int v26 = *((_DWORD *)this + 267);
      if ((v26 & 4) != 0) {
        goto LABEL_98;
      }
    }
LABEL_71:
    if ((v26 & 8) == 0) {
      goto LABEL_72;
    }
LABEL_105:
    uint64_t v41 = *((void *)this + 63);
    uint64_t v42 = *(void *)(v41 + 160);
    if (v42)
    {
      uint64_t v43 = *(void *)(v42 + 16);
      if (v43) {
        uint64_t v44 = (const void *)(v43 + *(int *)(v41 + 168));
      }
      else {
        uint64_t v44 = 0;
      }
      uint64_t result = HGMetalHandler::SetTextureCoords(a3, v44, *(int *)(v42 + 4), *(_DWORD *)(v42 + 8), 3u);
      int v26 = *((_DWORD *)this + 267);
      if ((v26 & 0x10) != 0) {
        goto LABEL_112;
      }
    }
    else
    {
      uint64_t result = HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 3u);
      int v26 = *((_DWORD *)this + 267);
      if ((v26 & 0x10) != 0) {
        goto LABEL_112;
      }
    }
LABEL_73:
    if ((v26 & 0x20) == 0) {
      goto LABEL_74;
    }
LABEL_119:
    uint64_t v49 = *((void *)this + 63);
    uint64_t v50 = *(void *)(v49 + 192);
    if (v50)
    {
      uint64_t v51 = *(void *)(v50 + 16);
      if (v51) {
        int v52 = (const void *)(v51 + *(int *)(v49 + 200));
      }
      else {
        int v52 = 0;
      }
      uint64_t result = HGMetalHandler::SetTextureCoords(a3, v52, *(int *)(v50 + 4), *(_DWORD *)(v50 + 8), 5u);
      int v26 = *((_DWORD *)this + 267);
      if ((v26 & 0x40) != 0) {
        goto LABEL_126;
      }
    }
    else
    {
      uint64_t result = HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 5u);
      int v26 = *((_DWORD *)this + 267);
      if ((v26 & 0x40) != 0) {
        goto LABEL_126;
      }
    }
LABEL_75:
    if ((v26 & 0x80) == 0) {
      goto LABEL_76;
    }
    goto LABEL_133;
  }
  uint64_t v29 = *((void *)this + 63);
  uint64_t v30 = *(void *)(v29 + 112);
  if (v30)
  {
    uint64_t v31 = *(void *)(v30 + 16);
    if (v31) {
      uint64_t v32 = (const void *)(v31 + *(int *)(v29 + 120));
    }
    else {
      uint64_t v32 = 0;
    }
    uint64_t result = HGMetalHandler::SetTextureCoords(a3, v32, *(int *)(v30 + 4), *(_DWORD *)(v30 + 8), 0);
    int v26 = *((_DWORD *)this + 267);
    if ((v26 & 2) != 0) {
      goto LABEL_91;
    }
  }
  else
  {
    uint64_t result = HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 0);
    int v26 = *((_DWORD *)this + 267);
    if ((v26 & 2) != 0) {
      goto LABEL_91;
    }
  }
LABEL_70:
  if ((v26 & 4) == 0) {
    goto LABEL_71;
  }
LABEL_98:
  uint64_t v37 = *((void *)this + 63);
  uint64_t v38 = *(void *)(v37 + 144);
  if (v38)
  {
    uint64_t v39 = *(void *)(v38 + 16);
    if (v39) {
      int32x2_t v40 = (const void *)(v39 + *(int *)(v37 + 152));
    }
    else {
      int32x2_t v40 = 0;
    }
    uint64_t result = HGMetalHandler::SetTextureCoords(a3, v40, *(int *)(v38 + 4), *(_DWORD *)(v38 + 8), 2u);
    int v26 = *((_DWORD *)this + 267);
    if ((v26 & 8) != 0) {
      goto LABEL_105;
    }
  }
  else
  {
    uint64_t result = HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 2u);
    int v26 = *((_DWORD *)this + 267);
    if ((v26 & 8) != 0) {
      goto LABEL_105;
    }
  }
LABEL_72:
  if ((v26 & 0x10) == 0) {
    goto LABEL_73;
  }
LABEL_112:
  uint64_t v45 = *((void *)this + 63);
  uint64_t v46 = *(void *)(v45 + 176);
  if (v46)
  {
    uint64_t v47 = *(void *)(v46 + 16);
    if (v47) {
      uint16x8_t v48 = (const void *)(v47 + *(int *)(v45 + 184));
    }
    else {
      uint16x8_t v48 = 0;
    }
    uint64_t result = HGMetalHandler::SetTextureCoords(a3, v48, *(int *)(v46 + 4), *(_DWORD *)(v46 + 8), 4u);
    int v26 = *((_DWORD *)this + 267);
    if ((v26 & 0x20) != 0) {
      goto LABEL_119;
    }
  }
  else
  {
    uint64_t result = HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 4u);
    int v26 = *((_DWORD *)this + 267);
    if ((v26 & 0x20) != 0) {
      goto LABEL_119;
    }
  }
LABEL_74:
  if ((v26 & 0x40) == 0) {
    goto LABEL_75;
  }
LABEL_126:
  uint64_t v53 = *((void *)this + 63);
  uint64_t v54 = *(void *)(v53 + 208);
  if (v54)
  {
    uint64_t v55 = *(void *)(v54 + 16);
    if (v55) {
      uint64_t v56 = (const void *)(v55 + *(int *)(v53 + 216));
    }
    else {
      uint64_t v56 = 0;
    }
    uint64_t result = HGMetalHandler::SetTextureCoords(a3, v56, *(int *)(v54 + 4), *(_DWORD *)(v54 + 8), 6u);
    if ((*((_DWORD *)this + 267) & 0x80) == 0) {
      goto LABEL_76;
    }
  }
  else
  {
    uint64_t result = HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 6u);
    if ((*((_DWORD *)this + 267) & 0x80) == 0) {
      goto LABEL_76;
    }
  }
LABEL_133:
  uint64_t v57 = *((void *)this + 63);
  uint64_t v58 = *(void *)(v57 + 224);
  if (v58)
  {
    uint64_t v59 = *(void *)(v58 + 16);
    if (v59) {
      uint64_t v60 = (const void *)(v59 + *(int *)(v57 + 232));
    }
    else {
      uint64_t v60 = 0;
    }
    uint64_t result = HGMetalHandler::SetTextureCoords(a3, v60, *(int *)(v58 + 4), *(_DWORD *)(v58 + 8), 7u);
    if (!*((void *)this + 64)) {
      goto LABEL_140;
    }
  }
  else
  {
    uint64_t result = HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 7u);
    if (!*((void *)this + 64))
    {
LABEL_140:
      uint64_t v61 = *((void *)this + 143);
      if (!v61)
      {
        HGMetalHandler::PrimitivesStart(a3);
        goto LABEL_161;
      }
      int v62 = *(_DWORD *)(v61 + 8);
      HGMetalHandler::PrimitivesStart(a3);
      if (v62 < 1) {
        goto LABEL_161;
      }
      int v63 = 0;
      while (1)
      {
        long long v71 = (int *)*((void *)this + 63);
        uint64_t v72 = *((void *)v71 + 2);
        if (v72 && (uint64_t v73 = *(void *)(v72 + 16)) != 0)
        {
          uint64_t v74 = v73
              + *(int *)(v72 + 4)
              * (uint64_t)*(int *)(*(void *)(*(void *)v71 + 16)
                                + *(int *)(*(void *)v71 + 4)
                                * (uint64_t)*(int *)(*(void *)(*((void *)this + 147) + 16)
                                                  + *(int *)(*((void *)this + 147) + 4) * (uint64_t)v63
                                                  + *((int *)this + 296))
                                + v71[2]);
          int v75 = v71[6];
          int v65 = v71[7];
          uint64_t v64 = (const void *)(v74 + v75);
          if (v65 != 34 && v65 != 3) {
            goto LABEL_152;
          }
        }
        else
        {
          uint64_t v64 = 0;
          int v65 = v71[7];
          if (v65 != 34 && v65 != 3) {
            goto LABEL_152;
          }
        }
        if (v65 == 34) {
          unint64_t v67 = 4;
        }
        else {
          unint64_t v67 = 2;
        }
        uint64_t v68 = *(void *)(*((void *)this + 143) + 16) + *(int *)(*((void *)this + 143) + 4) * (uint64_t)v63;
        uint64_t v69 = *((int *)this + 288);
        uint64_t v70 = *(unsigned int *)(v68 + v69);
        HGMetalHandler::SetIndices(a3, v64, v67, *(_DWORD *)(v68 + v69));
        HGMetalHandler::PrimitivesIndexed(a3, 3, 0, v70);
LABEL_152:
        if (v62 == ++v63) {
          goto LABEL_161;
        }
      }
    }
  }
LABEL_77:
  int v27 = *((_DWORD *)this + 298);
  if ((v27 & 0xFFFFFFFE) == 4)
  {
    if (v27 == 4) {
      uint64_t v28 = 3;
    }
    else {
      uint64_t v28 = 4;
    }
    HGMetalHandler::PrimitivesStart(a3);
    if (*((void *)this + 65)) {
      HGMetalHandler::PrimitivesIndexed(a3, v28, 0, 0);
    }
    else {
      HGMetalHandler::Primitives(a3, v28);
    }
LABEL_161:
    HGMetalHandler::PrimitivesEnd(a3);
  }
  return result;
}

void sub_1B76E84FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGRasterizer::drawElements(uint64_t a1, int a2, uint64_t *a3)
{
  if (*a3)
  {
    unsigned int v6 = *(_DWORD *)(*a3 + 8);
    uint64_t v7 = *(void *)(a1 + 496);
    if (*(unsigned char *)(v7 + 240)) {
      goto LABEL_10;
    }
  }
  else
  {
    unsigned int v6 = 0;
    uint64_t v7 = *(void *)(a1 + 496);
    if (*(unsigned char *)(v7 + 240)) {
      goto LABEL_10;
    }
  }
  *(unsigned char *)(v7 + 240) = 1;
  uint64_t v8 = *(void *)(v7 + 80);
  if (v8)
  {
    int v9 = *(_DWORD *)(v8 + 8);
    if (v9 >= 1)
    {
      __asm { FMOV            V0.4S, #1.0 }
      long long v167 = _Q0;
      do
      {
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(*(void *)(a1 + 496) + 64)) = v167;
        --v9;
      }
      while (v9);
      uint64_t v7 = *(void *)(a1 + 496);
    }
  }
LABEL_10:
  int v15 = *(_DWORD *)(v7 + 244);
  uint64_t v16 = *(void *)(v7 + 16);
  if (v16)
  {
    int v17 = *(_DWORD *)(v16 + 8);
    int v18 = a2 - 4;
  }
  else
  {
    int v17 = 0;
    int v18 = a2 - 4;
    if ((a2 - 4) > 3)
    {
LABEL_18:
      uint64_t result = puts("Unknown polygon mode in hglEnd");
      goto LABEL_162;
    }
  }
  switch(v18)
  {
    case 0:
      unsigned int v19 = v6 / 3;
      int v20 = v15 + v6 / 3;
      uint64_t v23 = *(void *)(v7 + 48);
      uint64_t v21 = (HGArrayDataRef *)(v7 + 48);
      uint64_t v22 = v23;
      *((_DWORD *)v21 + 49) = v20;
      if (v23)
      {
        if (*(_DWORD *)(v22 + 12) < v20)
        {
          int v24 = *(_DWORD *)(v22 + 4) * v20;
          *(_DWORD *)(v22 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v20;
          if (v24) {
            operator new[]();
          }
          uint64_t v65 = *(void *)(v22 + 16);
          if (v65) {
            MEMORY[0x1BA9BFB70](v65, 0x1000C8077774924);
          }
          *(void *)(v22 + 16) = 0;
        }
        *(_DWORD *)(v22 + 8) = v20;
        uint64_t result = *(void *)(a1 + 496);
        int v46 = *(_DWORD *)(result + 244);
        uint64_t v47 = *(void *)result;
        if (!*(void *)result)
        {
LABEL_59:
          if (v46 > 0) {
            HGArrayDataRef::allocate((HGArrayDataRef *)result);
          }
          goto LABEL_95;
        }
      }
      else
      {
        if (v20 > 0) {
          HGArrayDataRef::allocate(v21);
        }
        uint64_t result = *(void *)(a1 + 496);
        int v46 = *(_DWORD *)(result + 244);
        uint64_t v47 = *(void *)result;
        if (!*(void *)result) {
          goto LABEL_59;
        }
      }
      if (*(_DWORD *)(v47 + 12) < v46)
      {
        int v48 = *(_DWORD *)(v47 + 4) * v46;
        *(_DWORD *)(v47 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v46;
        if (v48) {
          operator new[]();
        }
        uint64_t result = *(void *)(v47 + 16);
        if (result) {
          uint64_t result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
        }
        *(void *)(v47 + 16) = 0;
      }
      *(_DWORD *)(v47 + 8) = v46;
LABEL_95:
      int v27 = 3 * v19;
      int v84 = *(uint64_t **)(a1 + 496);
      if (v6 >= 3)
      {
        uint64_t v85 = v84[6];
        uint64_t v86 = *(void *)(v85 + 16);
        uint64_t v87 = *v84;
        uint64_t v88 = *(void *)(*v84 + 16);
        if (v19 <= 1) {
          unsigned int v89 = 1;
        }
        else {
          unsigned int v89 = v6 / 3;
        }
        int v90 = v15;
        do
        {
          *(_DWORD *)(v86 + *(int *)(v85 + 4) * (uint64_t)v90 + *((int *)v84 + 14)) = 3;
          *(_DWORD *)(v88 + *(int *)(v87 + 4) * (uint64_t)v90 + *((int *)v84 + HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = v17;
          v17 += 3;
          ++v90;
          --v89;
        }
        while (v89);
      }
      int v91 = v84 + 2;
      uint64_t v92 = v84[2];
      if (!v92)
      {
        uint64_t v93 = (atomic_uint *)*a3;
        if (!*a3) {
          goto LABEL_113;
        }
        *int v91 = v93;
        goto LABEL_112;
      }
      if (*(_DWORD *)(v92 + 8))
      {
        uint64_t result = (uint64_t)HGArray<short,(HGFormat)3>::append((HGArrayDataRef *)(v84 + 2), a3);
        goto LABEL_163;
      }
      if (v92 != *a3)
      {
        if (atomic_fetch_add((atomic_uint *volatile)v92, 0xFFFFFFFF) == 1)
        {
          uint64_t v94 = *(void *)(v92 + 16);
          if (v94) {
            MEMORY[0x1BA9BFB70](v94, 0x1000C8077774924);
          }
          uint64_t result = MEMORY[0x1BA9BFBA0](v92, 0x1080C4098BBCF0FLL);
        }
        uint64_t v93 = (atomic_uint *)*a3;
        *int v91 = *a3;
        if (v93) {
LABEL_112:
        }
          atomic_fetch_add(v93, 1u);
      }
LABEL_113:
      v84[3] = a3[1];
      goto LABEL_163;
    case 1:
      unsigned int v26 = v6 - 2;
      int v27 = 3 * v26;
      int v28 = v15 + v26;
      uint64_t v31 = *(void *)(v7 + 48);
      uint64_t v29 = (HGArrayDataRef *)(v7 + 48);
      uint64_t v30 = v31;
      *((_DWORD *)v29 + 49) = v15 + v26;
      if (v31)
      {
        if (*(_DWORD *)(v30 + 12) < v28)
        {
          int v32 = *(_DWORD *)(v30 + 4) * v28;
          *(_DWORD *)(v30 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v28;
          if (v32) {
            operator new[]();
          }
          uint64_t v66 = *(void *)(v30 + 16);
          if (v66) {
            MEMORY[0x1BA9BFB70](v66, 0x1000C8077774924);
          }
          *(void *)(v30 + 16) = 0;
        }
        *(_DWORD *)(v30 + 8) = v28;
        uint64_t v67 = *(void *)(a1 + 496);
        uint64_t v68 = *(void *)(v67 + 16);
        uint64_t v50 = (HGArrayDataRef *)(v67 + 16);
        uint64_t v51 = v68;
        if (!v68) {
          goto LABEL_65;
        }
      }
      else
      {
        if (v28 > 0) {
          HGArrayDataRef::allocate(v29);
        }
        uint64_t v49 = *(void *)(a1 + 496);
        uint64_t v52 = *(void *)(v49 + 16);
        uint64_t v50 = (HGArrayDataRef *)(v49 + 16);
        uint64_t v51 = v52;
        if (!v52)
        {
LABEL_65:
          if (v27 > 0) {
            HGArrayDataRef::allocate(v50);
          }
          uint64_t result = *(void *)(a1 + 496);
          int v69 = *(_DWORD *)(result + 244);
          uint64_t v70 = *(void *)result;
          if (*(void *)result) {
            goto LABEL_68;
          }
LABEL_118:
          if (v69 > 0) {
            HGArrayDataRef::allocate((HGArrayDataRef *)result);
          }
          if (v26) {
            goto LABEL_142;
          }
          goto LABEL_162;
        }
      }
      int v53 = *(_DWORD *)(v51 + 8) + v27;
      if (*(_DWORD *)(v51 + 12) < v53)
      {
        int v54 = *(_DWORD *)(v51 + 4) * v53;
        *(_DWORD *)(v51 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v53;
        if (v54) {
          operator new[]();
        }
        uint64_t v95 = *(void *)(v51 + 16);
        if (v95) {
          MEMORY[0x1BA9BFB70](v95, 0x1000C8077774924);
        }
        *(void *)(v51 + 16) = 0;
      }
      *(_DWORD *)(v51 + 8) = v53;
      uint64_t result = *(void *)(a1 + 496);
      int v69 = *(_DWORD *)(result + 244);
      uint64_t v70 = *(void *)result;
      if (!*(void *)result) {
        goto LABEL_118;
      }
LABEL_68:
      if (*(_DWORD *)(v70 + 12) < v69)
      {
        int v71 = *(_DWORD *)(v70 + 4) * v69;
        *(_DWORD *)(v70 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v69;
        if (v71) {
          operator new[]();
        }
        uint64_t result = *(void *)(v70 + 16);
        if (result) {
          uint64_t result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
        }
        *(void *)(v70 + 16) = 0;
      }
      *(_DWORD *)(v70 + 8) = v69;
      if (v26)
      {
LABEL_142:
        unsigned int v100 = 0;
        uint64_t v101 = *a3;
        uint64_t v102 = *(void *)(*a3 + 16);
        BOOL v103 = *(uint64_t **)(a1 + 496);
        uint64_t v104 = v103[2];
        uint64_t v105 = *(void *)(v104 + 16);
        uint64_t v106 = *v103;
        uint64_t v107 = *(void *)(*v103 + 16);
        uint64_t v108 = v103[6];
        uint64_t v109 = *(void *)(v108 + 16);
        uint64_t result = 3;
        int v110 = v17;
        do
        {
          int v111 = *(_DWORD *)(v101 + 4);
          uint64_t v112 = *((int *)a3 + 2);
          int v113 = *(_DWORD *)(v104 + 4);
          int v114 = v113 * v110;
          uint64_t v115 = *((int *)v103 + 6);
          *(_WORD *)(v105 + v114 + v115) = *(_WORD *)(v102 + (int)(v111 * v100) + v112);
          *(_WORD *)(v105 + v113 + v114 + v115) = *(_WORD *)(v102 + (int)(v111 + v111 * v100) + v112);
          int v116 = v15 + v100;
          *(_WORD *)(v105 + v113 * (v110 + 2) + v115) = *(_WORD *)(v102 + (int)(v111 * (v100 + 2)) + v112);
          *(_DWORD *)(v107 + *(int *)(v106 + 4) * (uint64_t)v116 + *((int *)v103 + HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = v110;
          *(_DWORD *)(v109 + *(int *)(v108 + 4) * (uint64_t)v116 + *((int *)v103 + 14)) = 3;
          v110 += 6;
          v100 += 2;
        }
        while (v100 < v26);
        if (v26 >= 2)
        {
          uint64_t v117 = *a3;
          uint64_t v118 = *(void *)(*a3 + 16);
          __int32 v119 = *(uint64_t **)(a1 + 496);
          uint64_t v120 = v119[2];
          uint64_t v121 = *(void *)(v120 + 16);
          uint64_t v122 = *v119;
          uint64_t v123 = *(void *)(*v119 + 16);
          uint64_t v124 = v119[6];
          uint64_t v125 = *(void *)(v124 + 16);
          int v126 = v17 + 3;
          unsigned int v127 = 1;
          uint64_t result = 3;
          do
          {
            int v128 = *(_DWORD *)(v117 + 4);
            uint64_t v129 = *((int *)a3 + 2);
            int v130 = *(_DWORD *)(v120 + 4);
            int v131 = v130 * v126;
            uint64_t v132 = *((int *)v119 + 6);
            *(_WORD *)(v121 + v131 + v13PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *(_WORD *)(v118 + (int)(v128 + v128 * v127) + v129);
            *(_WORD *)(v121 + v130 + v131 + v13PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *(_WORD *)(v118 + (int)(v128 * v127) + v129);
            int v133 = v15 + v127;
            *(_WORD *)(v121 + v130 * (v126 + 2) + v13PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *(_WORD *)(v118 + (int)(v128 * (v127 + 2)) + v129);
            *(_DWORD *)(v123 + *(int *)(v122 + 4) * (uint64_t)v133 + *((int *)v119 + HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = v126;
            *(_DWORD *)(v125 + *(int *)(v124 + 4) * (uint64_t)v133 + *((int *)v119 + 14)) = 3;
            v126 += 6;
            v127 += 2;
          }
          while (v127 < v26);
        }
        goto LABEL_163;
      }
LABEL_162:
      int v27 = 0;
LABEL_163:
      if (v15 && *(_DWORD *)(a1 + 1092) == 4)
      {
        uint64_t v166 = *(void *)(*(void *)(a1 + 1144) + 16)
             + *(int *)(*(void *)(a1 + 1144) + 4) * (*(int *)(*(void *)(a1 + 1144) + 8) - 1);
        *(_DWORD *)(v166 + *(int *)(a1 + 1152)) += v27;
      }
      else
      {
        *(_DWORD *)(a1 + 109PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 4;
        *(_DWORD *)HGArray<int,(HGFormat)34>::append((HGArrayDataRef *)(a1 + 1144)) = v27;
        *(_DWORD *)HGArray<int,(HGFormat)34>::append((HGArrayDataRef *)(a1 + 1160)) = 4;
        uint64_t result = HGArray<int,(HGFormat)34>::append((HGArrayDataRef *)(a1 + 1176));
        *(_DWORD *)uint64_t result = v15;
      }
      return result;
    case 2:
      unsigned int v33 = v6 - 2;
      int v34 = v15 + v6 - 2;
      uint64_t v37 = *(void *)(v7 + 48);
      uint64_t v35 = (HGArrayDataRef *)(v7 + 48);
      uint64_t v36 = v37;
      *((_DWORD *)v35 + 49) = v34;
      if (v37)
      {
        if (*(_DWORD *)(v36 + 12) < v34)
        {
          int v38 = *(_DWORD *)(v36 + 4) * v34;
          *(_DWORD *)(v36 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v34;
          if (v38) {
            operator new[]();
          }
          uint64_t v72 = *(void *)(v36 + 16);
          if (v72) {
            MEMORY[0x1BA9BFB70](v72, 0x1000C8077774924);
          }
          *(void *)(v36 + 16) = 0;
        }
        *(_DWORD *)(v36 + 8) = v34;
        int v27 = 3 * v33;
        uint64_t v55 = *(HGArrayDataRef **)(a1 + 496);
        int v56 = *((_DWORD *)v55 + 61);
        uint64_t v57 = *(void *)v55;
        if (!*(void *)v55) {
          goto LABEL_75;
        }
      }
      else
      {
        if (v34 > 0) {
          HGArrayDataRef::allocate(v35);
        }
        int v27 = 3 * v33;
        uint64_t v55 = *(HGArrayDataRef **)(a1 + 496);
        int v56 = *((_DWORD *)v55 + 61);
        uint64_t v57 = *(void *)v55;
        if (!*(void *)v55)
        {
LABEL_75:
          if (v56 > 0) {
            HGArrayDataRef::allocate(v55);
          }
          uint64_t v73 = *(void *)(a1 + 496);
          uint64_t v75 = *(void *)(v73 + 16);
          uint64_t result = v73 + 16;
          uint64_t v74 = v75;
          if (v75) {
            goto LABEL_78;
          }
          goto LABEL_126;
        }
      }
      if (*(_DWORD *)(v57 + 12) < v56)
      {
        int v58 = *(_DWORD *)(v57 + 4) * v56;
        *(_DWORD *)(v57 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v56;
        if (v58) {
          operator new[]();
        }
        uint64_t v96 = *(void *)(v57 + 16);
        if (v96) {
          MEMORY[0x1BA9BFB70](v96, 0x1000C8077774924);
        }
        *(void *)(v57 + 16) = 0;
      }
      *(_DWORD *)(v57 + 8) = v56;
      uint64_t v97 = *(void *)(a1 + 496);
      uint64_t v98 = *(void *)(v97 + 16);
      uint64_t result = v97 + 16;
      uint64_t v74 = v98;
      if (v98)
      {
LABEL_78:
        int v76 = *(_DWORD *)(v74 + 8) + v27;
        if (*(_DWORD *)(v74 + 12) < v76)
        {
          int v77 = *(_DWORD *)(v74 + 4) * v76;
          *(_DWORD *)(v74 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v76;
          if (v77) {
            operator new[]();
          }
          uint64_t result = *(void *)(v74 + 16);
          if (result) {
            uint64_t result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
          }
          *(void *)(v74 + 16) = 0;
        }
        *(_DWORD *)(v74 + 8) = v76;
        if (v6 == 2) {
          goto LABEL_162;
        }
LABEL_152:
        uint64_t v134 = *a3;
        uint64_t v135 = *(void *)(*a3 + 16);
        uint64_t v136 = *(uint64_t **)(a1 + 496);
        uint64_t v137 = v136[2];
        uint64_t v138 = *(void *)(v137 + 16);
        uint64_t v139 = *v136;
        uint64_t v140 = *(void *)(*v136 + 16);
        uint64_t v141 = v136[6];
        uint64_t v142 = *(void *)(v141 + 16);
        int v143 = 2;
        uint64_t result = 3;
        do
        {
          uint64_t v144 = (_WORD *)(v135 + *((int *)a3 + 2));
          int v145 = *(_DWORD *)(v137 + 4);
          uint64_t v146 = *((int *)v136 + 6);
          *(_WORD *)(v138 + v145 * v17 + v146) = *v144;
          int v147 = *(_DWORD *)(v134 + 4);
          *(_WORD *)(v138 + v145 + v145 * v17 + v146) = *(_WORD *)((char *)v144 + v147 * (v143 - 1));
          *(_WORD *)(v138 + v145 * (v17 + 2) + v146) = *(_WORD *)((char *)v144 + v147 * v143);
          LODWORD(v144) = v15 + v143 - 2;
          *(_DWORD *)(v140 + *(int *)(v139 + 4) * (uint64_t)(int)v144 + *((int *)v136 + HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = v17;
          *(_DWORD *)(v142 + *(int *)(v141 + 4) * (uint64_t)(int)v144 + *((int *)v136 + 14)) = 3;
          ++v143;
          v17 += 3;
        }
        while (v6 != v143);
        goto LABEL_163;
      }
LABEL_126:
      if (v27 > 0) {
        HGArrayDataRef::allocate((HGArrayDataRef *)result);
      }
      if (v6 == 2) {
        goto LABEL_162;
      }
      goto LABEL_152;
    case 3:
      unsigned int v39 = (v6 >> 1) & 0x7FFFFFFE;
      int v40 = 3 * v39;
      int v41 = v15 + v39;
      uint64_t v44 = *(void *)(v7 + 48);
      uint64_t v42 = (HGArrayDataRef *)(v7 + 48);
      uint64_t v43 = v44;
      *((_DWORD *)v42 + 49) = v15 + v39;
      if (v44)
      {
        if (*(_DWORD *)(v43 + 12) < v41)
        {
          int v45 = *(_DWORD *)(v43 + 4) * v41;
          *(_DWORD *)(v43 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v41;
          if (v45) {
            operator new[]();
          }
          uint64_t v78 = *(void *)(v43 + 16);
          if (v78) {
            MEMORY[0x1BA9BFB70](v78, 0x1000C8077774924);
          }
          *(void *)(v43 + 16) = 0;
        }
        *(_DWORD *)(v43 + 8) = v41;
        uint64_t v79 = *(void *)(a1 + 496);
        uint64_t v80 = *(void *)(v79 + 16);
        uint64_t v60 = (HGArrayDataRef *)(v79 + 16);
        uint64_t v61 = v80;
        if (!v80) {
          goto LABEL_85;
        }
      }
      else
      {
        if (v41 > 0) {
          HGArrayDataRef::allocate(v42);
        }
        uint64_t v59 = *(void *)(a1 + 496);
        uint64_t v62 = *(void *)(v59 + 16);
        uint64_t v60 = (HGArrayDataRef *)(v59 + 16);
        uint64_t v61 = v62;
        if (!v62)
        {
LABEL_85:
          if (v40 > 0) {
            HGArrayDataRef::allocate(v60);
          }
          uint64_t result = *(void *)(a1 + 496);
          int v81 = *(_DWORD *)(result + 244);
          uint64_t v82 = *(void *)result;
          if (*(void *)result) {
            goto LABEL_88;
          }
          goto LABEL_134;
        }
      }
      int v63 = *(_DWORD *)(v61 + 8) + v40;
      if (*(_DWORD *)(v61 + 12) < v63)
      {
        int v64 = *(_DWORD *)(v61 + 4) * v63;
        *(_DWORD *)(v61 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v63;
        if (v64) {
          operator new[]();
        }
        uint64_t v99 = *(void *)(v61 + 16);
        if (v99) {
          MEMORY[0x1BA9BFB70](v99, 0x1000C8077774924);
        }
        *(void *)(v61 + 16) = 0;
      }
      *(_DWORD *)(v61 + 8) = v63;
      uint64_t result = *(void *)(a1 + 496);
      int v81 = *(_DWORD *)(result + 244);
      uint64_t v82 = *(void *)result;
      if (*(void *)result)
      {
LABEL_88:
        if (*(_DWORD *)(v82 + 12) < v81)
        {
          int v83 = *(_DWORD *)(v82 + 4) * v81;
          *(_DWORD *)(v82 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v81;
          if (v83) {
            operator new[]();
          }
          uint64_t result = *(void *)(v82 + 16);
          if (result) {
            uint64_t result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
          }
          *(void *)(v82 + 16) = 0;
        }
        *(_DWORD *)(v82 + 8) = v81;
        if (!v39) {
          goto LABEL_162;
        }
LABEL_159:
        _BOOL1 v148 = *(uint64_t **)(a1 + 496);
        uint64_t v149 = *v148;
        uint64_t v150 = *(void *)(*v148 + 16);
        uint64_t v151 = v148[6];
        uint64_t v152 = *(void *)(v151 + 16);
        uint64_t v153 = *a3;
        uint64_t v154 = *(void *)(*a3 + 16);
        uint64_t v155 = v148[2];
        uint64_t v156 = *(void *)(v155 + 16);
        int v157 = v17 + 2;
        LODWORD(result) = 1;
        do
        {
          int v158 = v15 + result - 1;
          *(_DWORD *)(v150 + *(int *)(v149 + 4) * (uint64_t)v158 + *((int *)v148 + HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = v157 - 2;
          *(_DWORD *)(v150 + *(int *)(v149 + 4) * (uint64_t)(v15 + (int)result) + *((int *)v148 + HGPool::Pool<__CVBuffer *,HGCVPixelBufferPool::Descriptor>::clear(*((void *)this + 2)) = v157 + 1;
          *(_DWORD *)(v152 + *(int *)(v151 + 4) * (uint64_t)v158 + *((int *)v148 + 14)) = 3;
          *(_DWORD *)(v152 + *(int *)(v151 + 4) * (uint64_t)(v15 + (int)result) + *((int *)v148 + 14)) = 3;
          int v159 = *(_DWORD *)(v153 + 4);
          uint64_t v160 = v154 + v159 * ((int)result - 1);
          uint64_t v161 = *((int *)a3 + 2);
          int v162 = *(_DWORD *)(v155 + 4);
          uint64_t v163 = *((int *)v148 + 6);
          *(_WORD *)(v156 + v162 * (v157 - 2) + v163) = *(_WORD *)(v160 + v161);
          *(_WORD *)(v156 + v162 * (v157 - 1) + v163) = *(_WORD *)(v154 + v159 * (int)result + v161);
          unsigned int v164 = result + 1;
          uint64_t v165 = v154 + v159 * ((int)result + 1);
          *(_WORD *)(v156 + v162 * v157 + v163) = *(_WORD *)(v165 + v161);
          *(_WORD *)(v156 + v162 * (v157 + 1) + v163) = *(_WORD *)(v160 + v161);
          *(_WORD *)(v156 + v162 * (v157 + 2) + v163) = *(_WORD *)(v165 + v161);
          uint64_t result = (result + 2);
          *(_WORD *)(v156 + v162 * (v157 + 3) + v163) = *(_WORD *)(v154 + v159 * (int)result + v161);
          v157 += 6;
        }
        while (v164 < v39);
        int v27 = 3 * v39;
        goto LABEL_163;
      }
LABEL_134:
      if (v81 > 0) {
        HGArrayDataRef::allocate((HGArrayDataRef *)result);
      }
      if (!v39) {
        goto LABEL_162;
      }
      goto LABEL_159;
    default:
      goto LABEL_18;
  }
}

void HGRasterizer::GeometryRenderPage(HGRasterizer *this, HGPage *a2)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 143);
  if (v3) {
    int v4 = *(_DWORD *)(v3 + 8);
  }
  else {
    int v4 = 0;
  }
  buffers[1] = 0;
  glGenVertexArraysOES();
  glBindVertexArrayOES();
  int v5 = *(_DWORD *)(*((void *)this + 63) + 92);
  if (v5 == 21) {
    int v6 = 3;
  }
  else {
    int v6 = 2;
  }
  if (v5 == 28) {
    GLint v7 = 4;
  }
  else {
    GLint v7 = v6;
  }
  buffers[0] = 0;
  glGenBuffers(1, buffers);
  glBindBuffer(0x8892u, buffers[0]);
  uint64_t v8 = *((void *)this + 63);
  uint64_t v9 = *(void *)(v8 + 80);
  if (v9)
  {
    GLsizeiptr v10 = *(int *)(v9 + 8) * (uint64_t)*(int *)(v9 + 4);
    uint64_t v11 = *(void *)(v9 + 16);
    if (v11)
    {
      uint64_t v12 = (const GLvoid *)(v11 + *(int *)(v8 + 88));
      goto LABEL_15;
    }
  }
  else
  {
    GLsizeiptr v10 = 0;
  }
  uint64_t v12 = 0;
LABEL_15:
  glBufferData(0x8892u, v10, v12, 0x88E4u);
  glEnableVertexAttribArray(0);
  glVertexAttribPointer(0, v7, 0x1406u, 0, 0, 0);
  uint64_t v13 = *((void *)this + 63);
  int v45 = v4;
  if (*(unsigned char *)(v13 + 240))
  {
    int v14 = *(_DWORD *)(v13 + 76);
    if (v14 == 21) {
      int v15 = 3;
    }
    else {
      int v15 = 2;
    }
    if (v14 == 28) {
      GLint v16 = 4;
    }
    else {
      GLint v16 = v15;
    }
    buffer[0] = 0;
    glGenBuffers(1, buffer);
    glBindBuffer(0x8892u, buffer[0]);
    uint64_t v17 = *((void *)this + 63);
    uint64_t v18 = *(void *)(v17 + 64);
    if (v18)
    {
      GLsizeiptr v19 = *(int *)(v18 + 8) * (uint64_t)*(int *)(v18 + 4);
      uint64_t v20 = *(void *)(v18 + 16);
      if (v20)
      {
        uint64_t v21 = (const GLvoid *)(v20 + *(int *)(v17 + 72));
LABEL_28:
        glBufferData(0x8892u, v19, v21, 0x88E4u);
        glEnableVertexAttribArray(1u);
        glVertexAttribPointer(1u, v16, 0x1406u, 0, 0, 0);
        goto LABEL_29;
      }
    }
    else
    {
      GLsizeiptr v19 = 0;
    }
    uint64_t v21 = 0;
    goto LABEL_28;
  }
  glDisableVertexAttribArray(1u);
LABEL_29:
  uint64_t v22 = 0;
  int v23 = 0;
  int v24 = 0;
  do
  {
    buffer[v22] = 0;
    if (((*((_DWORD *)this + 267) >> v22) & 1) == 0)
    {
      uint64_t v25 = v22 + 1;
      goto LABEL_31;
    }
    int v26 = *(_DWORD *)(*((void *)this + 63) + 16 * v22 + 124);
    if (v26 == 21) {
      int v27 = 3;
    }
    else {
      int v27 = 2;
    }
    if (v26 == 28) {
      GLint v28 = 4;
    }
    else {
      GLint v28 = v27;
    }
    uint64_t v25 = v22 + 1;
    int v24 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)a2 + 29) + 168))(*((void *)a2 + 29), 10, v22 + 1);
    if (v23 < v24)
    {
      while (1)
      {
        glGenBuffers(1, &buffer[v22]);
        glBindBuffer(0x8892u, buffer[v22]);
        uint64_t v31 = *((void *)this + 63) + 16 * v22;
        uint64_t v34 = *(void *)(v31 + 112);
        uint64_t v32 = v31 + 112;
        uint64_t v33 = v34;
        if (v34)
        {
          GLsizeiptr v29 = *(int *)(v33 + 8) * (uint64_t)*(int *)(v33 + 4);
          uint64_t v35 = *(void *)(v33 + 16);
          if (v35)
          {
            uint64_t v30 = (const GLvoid *)(v35 + *(int *)(v32 + 8));
            goto LABEL_43;
          }
        }
        else
        {
          GLsizeiptr v29 = 0;
        }
        uint64_t v30 = 0;
LABEL_43:
        glBufferData(0x8892u, v29, v30, 0x88E4u);
        glEnableVertexAttribArray(v23 + 8);
        glVertexAttribPointer(v23 + 8, v28, 0x1406u, 0, 0, 0);
        if (v24 == ++v23)
        {
          int v23 = v24;
          break;
        }
      }
    }
LABEL_31:
    uint64_t v22 = v25;
  }
  while (v25 != 8);
  if (v24 <= 7)
  {
    GLuint v36 = v24 + 8;
    do
      glDisableVertexAttribArray(v36++);
    while (v36 != 16);
  }
  glDisableVertexAttribArray(2u);
  if (v45)
  {
    for (int i = 0; i != v45; ++i)
    {
      int v39 = *(_DWORD *)(*(void *)(**((void **)this + 63) + 16)
                      + *(int *)(**((void **)this + 63) + 4)
                      * (uint64_t)*(int *)(*(void *)(*((void *)this + 147) + 16)
                                        + *(int *)(*((void *)this + 147) + 4) * (uint64_t)i
                                        + *((int *)this + 296))
                      + *(int *)(*((void *)this + 63) + 8));
      GLenum v40 = *(_DWORD *)(*(void *)(*((void *)this + 145) + 16)
                      + *(int *)(*((void *)this + 145) + 4) * (uint64_t)i
                      + *((int *)this + 292));
      uint64_t v41 = *(unsigned int *)(*(void *)(*((void *)this + 143) + 16)
                            + *(int *)(*((void *)this + 143) + 4) * (uint64_t)i
                            + *((int *)this + 288));
      GLuint v47 = 0;
      glGenBuffers(1, &v47);
      glBindBuffer(0x8893u, v47);
      uint64_t v42 = *((void *)this + 63);
      uint64_t v43 = *(void *)(v42 + 16);
      if (v43 && (uint64_t v44 = *(void *)(v43 + 16)) != 0) {
        int v38 = (const GLvoid *)(v44 + *(int *)(v43 + 4) * (uint64_t)v39 + *(int *)(v42 + 24));
      }
      else {
        int v38 = 0;
      }
      glBufferData(0x8893u, 2 * v41, v38, 0x88E4u);
      glDrawElements(v40, v41, 0x1403u, 0);
    }
  }
  glDisableVertexAttribArray(0);
  glDisableVertexAttribArray(1u);
  glDisableVertexAttribArray(2u);
  glDisableVertexAttribArray(8u);
  glDisableVertexAttribArray(9u);
  glDisableVertexAttribArray(0xAu);
  glDisableVertexAttribArray(0xBu);
  glDisableVertexAttribArray(0xCu);
  glDisableVertexAttribArray(0xDu);
  glDisableVertexAttribArray(0xEu);
  glDisableVertexAttribArray(0xFu);
  GLuint v47 = 0;
  glBindVertexArrayOES();
  glGetVertexAttribiv(0, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(1u, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(2u, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(3u, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(4u, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(5u, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(6u, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(7u, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(8u, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(9u, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(0xAu, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(0xBu, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(0xCu, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(0xDu, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(0xEu, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetVertexAttribiv(0xFu, 0x889Fu, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glGetIntegerv(0x8895u, (GLint *)&v47);
  if (v47) {
    glDeleteBuffers(1, &v47);
  }
  glDeleteVertexArraysOES();
  glDisable(0xBE2u);
}

uint64_t HGRasterizer::RenderPageMetal(HGNode *this, HGPage *a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  int v5 = (void *)((char *)a2 + 8);
  uint64_t v4 = *((void *)a2 + 1);
  *((void *)a2 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  HGPagePullMetalTexturesGuard::HGPagePullMetalTexturesGuard((HGPagePullMetalTexturesGuard *)&v63, this, a2);
  *int v5 = v4;
  (*(void (**)(void, void))(**(void **)a2 + 144))(*(void *)a2, 0);
  int v6 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)this + 48))(this);
  snprintf(__str, 0x100uLL, "%s::RenderPageMetal( [%d %d %d %d])", v6, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v62, "gpu", 1, __str);
  uint64_t v7 = *((void *)this + 153);
  if (*(unsigned char *)(v7 + 12) && !*(_DWORD *)(v7 + 16)) {
    int v8 = *(_DWORD *)(v7 + 20);
  }
  else {
    int v8 = 1;
  }
  if (((*(uint64_t (**)(HGNode *))(*(void *)this + 592))(this) & 2) != 0)
  {
    unsigned int v9 = 1;
    if (!v4) {
      goto LABEL_7;
    }
LABEL_9:
    (*(void (**)(void))(**((void **)a2 + 1) + 16))(*((void *)a2 + 1));
    goto LABEL_10;
  }
  unsigned int v9 = ((*(unsigned int (**)(HGNode *))(*(void *)this + 592))(this) >> 3) & 1;
  if (v4) {
    goto LABEL_9;
  }
LABEL_7:
  *((void *)a2 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HGGPURenderer::CreateBuffer(*(void *)a2, *((HGRect *)a2 + 1), *((unsigned int *)a2 + 8), 1, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
LABEL_10:
  if (((*(uint64_t (**)(HGNode *))(*(void *)this + 592))(this) & 1) != 0
    && ((*(uint64_t (**)(HGNode *))(*(void *)this + 592))(this) & 0x10) == 0)
  {
    HGGPURenderer::ClearMetal(*(HGGPURenderer **)a2, *((HGBitmap **)a2 + 1), *((HGRect *)a2 + 1), v10);
  }
  if (!*((unsigned char *)this + 1077) || (uint64_t v11 = *((void *)this + 95)) == 0) {
    uint64_t v11 = *((void *)this + 94);
  }
  uint64_t v12 = (HGBitmap *)*((void *)a2 + 1);
  (*(void (**)(uint64_t, void))(*(void *)v11 + 160))(v11, *(unsigned int *)(*((void *)this + 54) + 160));
  uint64_t v13 = (const void *)(*(uint64_t (**)(void, void, HGNode *))(**(void **)a2 + 368))(*(void *)a2, *((void *)this + 8), this);
  if (v13)
  {
    if (v14)
    {
      int v15 = v14;
      unsigned int v57 = v8;
      unsigned int v16 = v9;
      uint64_t v17 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)this + 48))(this);
      size_t v18 = strlen(v17);
      if (v18 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      size_t v19 = v18;
      if (v18 >= 0x17)
      {
        uint64_t v21 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v18 | 7) != 0x17) {
          uint64_t v21 = v18 | 7;
        }
        uint64_t v22 = v21 + 1;
        p_dst = (simd::float4x4 *)operator new(v21 + 1);
        __dst.columns[0].i64[1] = v19;
        __dst.columns[1].i64[0] = v22 | 0x8000000000000000;
        __dst.columns[0].i64[0] = (uint64_t)p_dst;
      }
      else
      {
        __dst.columns[1].i8[7] = v18;
        p_dst = &__dst;
        if (!v18)
        {
LABEL_26:
          p_dst->columns[0].i8[v19] = 0;
          HGMetalHandler::SetDebugLabel(v15, (const std::string *)&__dst);
          unsigned int v23 = v16;
          if (__dst.columns[1].i8[7] < 0) {
            operator delete((void *)__dst.columns[0].i64[0]);
          }
          HGMetalHandler::BindBuffer((HGMetalHandler *)v15, v12, (const char *)v57);
          if (v16) {
            HGMetalHandler::EnableDepthBuffer(v15);
          }
          uint64_t v25 = (HGBitmap *)*((void *)a2 + 21);
          if (v25) {
            __n128 v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 0, v25);
          }
          int v26 = (HGBitmap *)*((void *)a2 + 22);
          if (v26) {
            __n128 v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 1, v26);
          }
          int v27 = (HGBitmap *)*((void *)a2 + 23);
          if (v27) {
            __n128 v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 2, v27);
          }
          GLint v28 = (HGBitmap *)*((void *)a2 + 24);
          if (v28) {
            __n128 v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 3, v28);
          }
          GLsizeiptr v29 = (HGBitmap *)*((void *)a2 + 25);
          if (v29) {
            __n128 v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 4, v29);
          }
          uint64_t v30 = (HGBitmap *)*((void *)a2 + 26);
          if (v30) {
            __n128 v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 5, v30);
          }
          uint64_t v31 = (HGBitmap *)*((void *)a2 + 27);
          if (v31) {
            __n128 v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 6, v31);
          }
          uint64_t v32 = (HGBitmap *)*((void *)a2 + 28);
          if (v32) {
            __n128 v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 7, v32);
          }
          (*(void (**)(HGNode *, HGPage *, void, std::string *, __n128))(*(void *)this + 488))(this, a2, 0, v15, v24);
          if (!HGTransform::IsIdentity((HGTransform *)((char *)this + 768)))
          {
            memset(&__dst, 0, sizeof(__dst));
            float64x2_t Matrixfloat4x4 = HGTransform::GetMatrixfloat4x4((float64x2_t *)this + 48, &__dst);
            (*(void (**)(std::string *, simd::float4x4 *, float64x2_t))(v15->__r_.__value_.__r.__words[0]
                                                                                 + 176))(v15, &__dst, Matrixfloat4x4);
          }
          HGMetalHandler::SetScissorRect((HGMetalHandler *)v15, (__n128 *)a2 + 1);
          HGMetalHandler::SetScissorTest((uint64_t)v15, 1);
          __dst.columns[0].i64[0] = 0;
          *(simd_float4 *)((char *)__dst.columns + 8) = (simd_float4)xmmword_1B7EBF8F0;
          __dst.columns[1].i64[1] = 0;
          if (*((unsigned char *)this + 1141)) {
            goto LABEL_53;
          }
          int v35 = HGNode::IsInPlaceHardwareBlendingEnabled(this);
          uint64_t v36 = *(void *)this;
          if (v35)
          {
            uint64_t v37 = (*(uint64_t (**)(HGNode *))(v36 + 256))(this);
            simd_float4 v38 = *(simd_float4 *)(v37 + 16);
            __dst.columns[0] = *(simd_float4 *)v37;
            __dst.columns[1] = v38;
          }
          else
          {
            if (((*(uint64_t (**)(HGNode *))(v36 + 592))(this) & 4) == 0)
            {
LABEL_53:
              if (*((unsigned char *)this + 1077))
              {
                unsigned int v41 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)a2 + 29) + 168))(*((void *)a2 + 29), 3, 0);
                if (v41)
                {
                  uint64_t v42 = 0;
                  uint64_t v43 = 0;
                  uint64_t v44 = v41;
                  do
                  {
                    uint64_t v45 = v42 + 1;
                    uint64_t v46 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)a2 + 29) + 168))(*((void *)a2 + 29), 10, v42 + 1);
                    if ((int)v43 < (int)v46)
                    {
                      GLuint v47 = (char *)this + 8 * v42 + 432;
                      do
                      {
                        (*(void (**)(std::string *, uint64_t))(v15->__r_.__value_.__r.__words[0] + 80))(v15, v43);
                        uint64_t MatrixPtr = HGTransform::GetMatrixPtr((HGTransform *)(*(void *)v47 + 8));
                        (*(void (**)(std::string *, uint64_t))(v15->__r_.__value_.__r.__words[0] + 112))(v15, MatrixPtr);
                        uint64_t v43 = (v43 + 1);
                      }
                      while (v46 != v43);
                      uint64_t v43 = v46;
                    }
                    uint64_t v42 = v45;
                  }
                  while (v45 != v44);
                }
              }
              HGRasterizer::GeometryRenderPageMetal((HGRasterizer *)this, v34, (HGMetalHandler *)v15);
              HGMetalHandler::SetScissorTest((uint64_t)v15, 0);
              HGMetalHandler::DisableBlending((uint64_t)v15);
              if (v23) {
                HGMetalHandler::DisableDepthBuffer((HGMetalHandler *)v15);
              }
              if (((*(uint64_t (**)(HGNode *))(*(void *)this + 592))(this) & 4) != 0)
              {
                uint64_t v58 = 0;
                *(void *)&long long v50 = 0x100000001;
                *((void *)&v50 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0x100000001;
                long long v59 = v50;
                uint64_t v60 = 0;
                __n128 v49 = HGMetalHandler::SetBlendingInfo((HGMetalHandler *)v15, (const HGBlendingInfo *)&v58);
              }
              (*(void (**)(HGNode *, HGPage *, void, std::string *, __n128))(*(void *)this + 496))(this, a2, 0, v15, v49);
              goto LABEL_66;
            }
            switch((*(unsigned int (**)(HGNode *))(*(void *)this + 600))(this))
            {
              case 0u:
                __dst.columns[0].i64[0] = 0;
                simd_float4 v53 = (simd_float4)xmmword_1B7E7AF00;
                goto LABEL_74;
              case 1u:
                __dst.columns[0].i64[0] = 0;
                simd_float4 v53 = (simd_float4)xmmword_1B7EBF8E0;
                goto LABEL_74;
              case 2u:
                __dst.columns[0].i64[0] = 0;
                v53.i64[0] = 0x100000001;
                v53.i64[1] = 0x100000001;
LABEL_74:
                *(simd_float4 *)((char *)__dst.columns + 8) = v53;
                __dst.columns[1].i64[1] = 0;
                break;
              case 3u:
                __dst.columns[0].i64[0] = 0;
                v56.i64[0] = 0x100000001;
                v56.i64[1] = 0x100000001;
                *(simd_float4 *)((char *)__dst.columns + 8) = v56;
                uint64_t v55 = 0x400000004;
                goto LABEL_72;
              case 4u:
                __dst.columns[0].i64[0] = 0;
                v54.i64[0] = 0x100000001;
                v54.i64[1] = 0x100000001;
                *(simd_float4 *)((char *)__dst.columns + 8) = v54;
                uint64_t v55 = 0x300000003;
LABEL_72:
                __dst.columns[1].i64[1] = v55;
                break;
              default:
                break;
            }
          }
          HGMetalHandler::EnableBlending((uint64_t)v15);
          __n128 v39 = HGMetalHandler::SetBlendingInfo((HGMetalHandler *)v15, (const HGBlendingInfo *)&__dst);
          GLenum v40 = (__n128 *)(*(uint64_t (**)(HGNode *, __n128))(*(void *)this + 272))(this, v39);
          HGMetalHandler::SetBlendingColor((__n128 *)v15, v40);
          goto LABEL_53;
        }
      }
      memmove(p_dst, v17, v19);
      goto LABEL_26;
    }
  }
LABEL_66:
  uint64_t v51 = *((void *)a2 + 1);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v62);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(&v63);
  return v51;
}

void sub_1B76EA4C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,HGPage *a33)
{
}

uint64_t HGRasterizer::RenderPage(HGRasterizer *this, HGPage *a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (const char *)(*(uint64_t (**)(HGRasterizer *))(*(void *)this + 48))(this);
  snprintf(__str, 0x100uLL, "%s::RenderPage( [%d %d %d %d])", v4, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v63, "gpu", 1, __str);
  int v5 = *(HGGPURenderer **)a2;
  uint64_t v6 = *((void *)a2 + 1);
  if (v6) {
    (*(void (**)(void, void))(*(void *)v5 + 144))(*(void *)a2, *((void *)a2 + 1));
  }
  *((void *)a2 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  HGPagePullTexturesGuard::HGPagePullTexturesGuard((HGPagePullTexturesGuard *)&v62, (HGNode *)this, a2);
  *((void *)a2 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v6;
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
    Buffer = (char *)*((void *)a2 + 1);
  }
  else
  {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)v5, *((HGRect *)a2 + 1), *((unsigned int *)a2 + 8), 0, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
    *((void *)a2 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = Buffer;
  }
  (*(void (**)(HGGPURenderer *, char *))(*(void *)v5 + 144))(v5, Buffer);
  if (((*(uint64_t (**)(HGRasterizer *))(*(void *)this + 592))(this) & 2) == 0) {
    (*(void (**)(HGRasterizer *))(*(void *)this + 592))(this);
  }
  uint64_t v9 = *((void *)this + 153);
  if (!*(unsigned char *)(v9 + 12) || *(_DWORD *)(v9 + 16) || (unsigned int v10 = *(_DWORD *)(v9 + 20), v10 < 2))
  {
    int v11 = 0;
  }
  else
  {
    HGGPURenderer::BindMultiSampleBuffer(v5, v10, 0, 0, v8);
    int v11 = 1;
  }
  if (((*(uint64_t (**)(HGRasterizer *))(*(void *)this + 592))(this) & 1) != 0
    && ((*(uint64_t (**)(HGRasterizer *))(*(void *)this + 592))(this) & 0x10) == 0)
  {
    HGGPURenderer::Clear(v5, *((HGRect *)a2 + 1), v12, v13);
  }
  int v14 = (char *)*((void *)a2 + 1);
  uint64_t v15 = *((void *)a2 + 21);
  int v16 = *(_DWORD *)(*((void *)this + 54) + 160);
  if (v16 == -1) {
    int v16 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)v5 + 128))(v5, 23);
  }
  (*(void (**)(HGGPURenderer *, void, uint64_t, void, BOOL))(*(void *)v5 + 152))(v5, 0, v15, 0, v16 == 1);
  uint64_t v17 = *((void *)a2 + 22);
  int v18 = *(_DWORD *)(*((void *)this + 55) + 160);
  if (v18 == -1) {
    int v18 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)v5 + 128))(v5, 23);
  }
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, void, BOOL))(*(void *)v5 + 152))(v5, 1, v17, 0, v18 == 1);
  uint64_t v19 = *((void *)a2 + 23);
  int v20 = *(_DWORD *)(*((void *)this + 56) + 160);
  if (v20 == -1) {
    int v20 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)v5 + 128))(v5, 23);
  }
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, void, BOOL))(*(void *)v5 + 152))(v5, 2, v19, 0, v20 == 1);
  uint64_t v21 = *((void *)a2 + 24);
  int v22 = *(_DWORD *)(*((void *)this + 57) + 160);
  if (v22 == -1) {
    int v22 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)v5 + 128))(v5, 23);
  }
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, void, BOOL))(*(void *)v5 + 152))(v5, 3, v21, 0, v22 == 1);
  uint64_t v23 = *((void *)a2 + 25);
  int v24 = *(_DWORD *)(*((void *)this + 58) + 160);
  if (v24 == -1) {
    int v24 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)v5 + 128))(v5, 23);
  }
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, void, BOOL))(*(void *)v5 + 152))(v5, 4, v23, 0, v24 == 1);
  uint64_t v25 = *((void *)a2 + 26);
  int v26 = *(_DWORD *)(*((void *)this + 59) + 160);
  if (v26 == -1) {
    int v26 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)v5 + 128))(v5, 23);
  }
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, void, BOOL))(*(void *)v5 + 152))(v5, 5, v25, 0, v26 == 1);
  uint64_t v27 = *((void *)a2 + 27);
  int v28 = *(_DWORD *)(*((void *)this + 60) + 160);
  if (v28 == -1) {
    int v28 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)v5 + 128))(v5, 23);
  }
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, void, BOOL))(*(void *)v5 + 152))(v5, 6, v27, 0, v28 == 1);
  uint64_t v29 = *((void *)a2 + 28);
  int v30 = *(_DWORD *)(*((void *)this + 61) + 160);
  if (v30 == -1) {
    int v30 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)v5 + 128))(v5, 23);
  }
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, void, BOOL))(*(void *)v5 + 152))(v5, 7, v29, 0, v30 == 1);
  glActiveTexture(0x84C0u);
  if (!*((unsigned char *)this + 1077) || (uint64_t v31 = *((void *)this + 95)) == 0) {
    uint64_t v31 = *((void *)this + 94);
  }
  (*(void (**)(uint64_t, void))(*(void *)v31 + 160))(v31, *(unsigned int *)(*((void *)this + 54) + 160));
  uint64_t v32 = (*(uint64_t (**)(HGGPURenderer *, void, HGRasterizer *))(*(void *)v5 + 368))(v5, *((void *)this + 8), this);
  (*(void (**)(HGRasterizer *, HGPage *, void, uint64_t))(*(void *)this + 488))(this, a2, 0, v32);
  if (!HGTransform::IsIdentity((HGRasterizer *)((char *)this + 768)))
  {
    memset(&v61, 0, sizeof(v61));
    float64x2_t Matrixfloat4x4 = HGTransform::GetMatrixfloat4x4((float64x2_t *)this + 48, &v61);
    (*(void (**)(uint64_t, simd::float4x4 *, float64x2_t))(*(void *)v32 + 176))(v32, &v61, Matrixfloat4x4);
  }
  if (v14) {
  else
  }
    uint64_t v34 = 0;
  int v35 = (uint64_t *)(v34 + 136);
  if (!v34) {
    int v35 = (uint64_t *)(v14 + 20);
  }
  uint64_t v36 = *v35;
  uint64_t v37 = HGRectIntersection(*((void *)a2 + 2), *((void *)a2 + 3), *v35, v35[1]);
  glScissor(v37 - v36, HIDWORD(v37) - HIDWORD(v36), v38 - v37, v39 - HIDWORD(v37));
  glEnable(0xC11u);
  if (!*((unsigned char *)this + 1141))
  {
    if (HGNode::IsInPlaceHardwareBlendingEnabled((HGNode *)this))
    {
      GLenum v40 = (const HGBlendingInfo *)(*(uint64_t (**)(HGRasterizer *))(*(void *)this + 256))(this);
      HGGLBlendingInfo::HGGLBlendingInfo((HGGLBlendingInfo *)&v61, v40);
      GLenum Size = PVPerfStats::FrameStats::GetSize((PVPerfStats::FrameStats *)&v61);
      GLenum DstRGBFactor = HGGLBlendingInfo::GetDstRGBFactor((HGGLBlendingInfo *)&v61);
      GLenum v43 = LiImageSource::imageSpace((LiImageSource *)&v61);
      GLenum DstAlphaFactor = HGGLBlendingInfo::GetDstAlphaFactor((HGGLBlendingInfo *)&v61);
      glBlendFuncSeparate(Size, DstRGBFactor, v43, DstAlphaFactor);
      RGBOperatiouint64_t n = HGGLBlendingInfo::GetRGBOperation((HGGLBlendingInfo *)&v61);
      AlphaOperatiouint64_t n = HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)&v61);
      glBlendEquationSeparate(RGBOperation, AlphaOperation);
      glEnable(0xBE2u);
    }
    else if (((*(uint64_t (**)(HGRasterizer *))(*(void *)this + 592))(this) & 4) != 0)
    {
      glEnable(0xBE2u);
      int v47 = (*(uint64_t (**)(HGRasterizer *))(*(void *)this + 600))(this);
      GLenum v48 = 32774;
      switch(v47)
      {
        case 0:
          glBlendEquation(0x8006u);
          GLenum v49 = 771;
          GLenum v50 = 1;
          goto LABEL_53;
        case 1:
          glBlendEquation(0x8006u);
          GLenum v49 = 1;
          GLenum v50 = 773;
          goto LABEL_53;
        case 2:
          goto LABEL_52;
        case 3:
          GLenum v48 = 32776;
          goto LABEL_52;
        case 4:
          GLenum v48 = 32775;
LABEL_52:
          glBlendEquation(v48);
          GLenum v50 = 1;
          GLenum v49 = 1;
LABEL_53:
          glBlendFunc(v50, v49);
          break;
        default:
          break;
      }
    }
    else
    {
      glDisable(0xBE2u);
    }
  }
  glEnable(0xDE1u);
  if (*((unsigned char *)this + 1077))
  {
    unsigned int v51 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)a2 + 29) + 168))(*((void *)a2 + 29), 3, 0);
    if (v51)
    {
      uint64_t v52 = 0;
      uint64_t v53 = 0;
      uint64_t v54 = v51;
      do
      {
        uint64_t v55 = v52 + 1;
        uint64_t v56 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)a2 + 29) + 168))(*((void *)a2 + 29), 10, v52 + 1);
        if ((int)v53 < (int)v56)
        {
          unsigned int v57 = (char *)this + 8 * v52 + 432;
          do
          {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v32 + 80))(v32, v53);
            uint64_t MatrixPtr = HGTransform::GetMatrixPtr((HGTransform *)(*(void *)v57 + 8));
            (*(void (**)(uint64_t, uint64_t))(*(void *)v32 + 112))(v32, MatrixPtr);
            uint64_t v53 = (v53 + 1);
          }
          while (v56 != v53);
          uint64_t v53 = v56;
        }
        uint64_t v52 = v55;
      }
      while (v55 != v54);
    }
  }
  (*(void (**)(HGRasterizer *, HGPage *))(*(void *)this + 616))(this, a2);
  if (v11) {
    HGGPURenderer::ResolveMultiSampleBuffer(v5);
  }
  glDisable(0xBE2u);
  glDisable(0xC11u);
  glFlush();
  if (((*(uint64_t (**)(HGRasterizer *))(*(void *)this + 592))(this) & 4) != 0)
  {
    glBlendEquation(0x8006u);
    glBlendFunc(1u, 1u);
  }
  (*(void (**)(HGRasterizer *, HGPage *, void, uint64_t))(*(void *)this + 496))(this, a2, 0, v32);
  uint64_t v59 = *((void *)a2 + 1);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard(&v62);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v63);
  return v59;
}

void sub_1B76EB19C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va1, a16);
  va_start(va, a16);
  uint64_t v17 = va_arg(va1, HGPage *);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard((HGPage **)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va1);
  _Unwind_Resume(a1);
}

uint64_t HGRasterizer::SetState(HGRasterizer *this, HGRenderer *a2, int a3)
{
  if (a3 == 1) {
    atomic_store(0, (unsigned int *)this + 279);
  }
  if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) != 0 || !*((void *)this + 64)) {
    (*(void (**)(HGRasterizer *, HGRenderer *))(*(void *)this + 640))(this, a2);
  }

  return HGNode::SetState((uint64_t)this, (uint64_t)a2, a3);
}

uint64_t HGRasterizer::RenderFragment(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (atomic_load_explicit((atomic_ullong *volatile)HGRasterizer::getIsROIDebug(void)::envCheck, memory_order_acquire) != -1)
  {
    uint64_t v13 = &v11;
    uint64_t v12 = &v13;
    std::__call_once(HGRasterizer::getIsROIDebug(void)::envCheck, &v12, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGRasterizer::getIsROIDebug(void)::$_0 &&>>);
  }
  if (HGRasterizer::_isROIDebug)
  {
    if (!*(unsigned char *)(a1 + 1077) || (uint64_t v8 = *(void *)(a1 + 760)) == 0) {
      uint64_t v8 = *(void *)(a1 + 752);
    }
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v8 + 584))(v8, a2, a3, a4);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 1077) || (uint64_t v10 = *(void *)(a1 + 760)) == 0) {
      uint64_t v10 = *(void *)(a1 + 752);
    }
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10 + 576))(v10, a2, a3);
  }
}

uint64_t HGRasterizer::GetNPolys(void *a1)
{
  return *(unsigned int *)(a1[62] + 244);
}

void *HGRasterizer::vertexArray(void *this, const HGArrayDataRef *a2, char *a3)
{
  uint64_t v3 = (uint64_t)this;
  if ((*((unsigned char *)this + 1084) & 8) != 0)
  {
    int v15 = *((_DWORD *)a2 + 3);
    switch(v15)
    {
      case 13:
        this = CopyArray2f((atomic_uint *volatile *)(this[62] + 80), (int *)a2, 0);
        break;
      case 21:
        this = CopyArray3f((atomic_uint *volatile *)(this[62] + 80), (int *)a2, 0);
        break;
      case 28:
        uint64_t v16 = this[62];
        uint64_t v17 = *(void *)(v16 + 80);
        int v18 = *(atomic_uint **)a2;
        if (v17 != *(void *)a2)
        {
          if (v17)
          {
            if (atomic_fetch_add((atomic_uint *volatile)v17, 0xFFFFFFFF) == 1)
            {
              uint64_t v19 = *(void *)(v17 + 16);
              if (v19) {
                MEMORY[0x1BA9BFB70](v19, 0x1000C8077774924);
              }
              this = (void *)MEMORY[0x1BA9BFBA0](v17, 0x1080C4098BBCF0FLL);
            }
            int v18 = *(atomic_uint **)a2;
          }
          *(void *)(v16 + 80) = v18;
          if (v18) {
            atomic_fetch_add(v18, 1u);
          }
        }
        *(_DWORD *)(v16 + 88) = *((_DWORD *)a2 + 2);
        break;
      default:
        *((_DWORD *)this + 275) = 1280;
        this = HGLogger::warning((HGLogger *)"%s", (const char *)a2, a3, "hglVertexArray: invalid type");
        break;
    }
  }
  char v4 = *(unsigned char *)(v3 + 1088);
  int v5 = *(_DWORD *)(v3 + 1084);
  *(_DWORD *)(v3 + 1084) = 4;
  uint64_t v6 = *(void *)(v3 + 432);
  if (*(unsigned char *)(v6 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 1u;
    *(unsigned char *)(v6 + 19PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 1;
    *(unsigned char *)(v3 + 1088) = 0;
    this = HGRasterizer::texCoordArray((const char *)v3, (const HGArrayDataRef *)(*(void *)(v3 + 496) + 80));
  }
  uint64_t v7 = *(void *)(v3 + 440);
  if (*(unsigned char *)(v7 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 2u;
    *(unsigned char *)(v7 + 19PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 1;
    *(unsigned char *)(v3 + 1088) = 1;
    this = HGRasterizer::texCoordArray((const char *)v3, (const HGArrayDataRef *)(*(void *)(v3 + 496) + 80));
  }
  uint64_t v8 = *(void *)(v3 + 448);
  if (*(unsigned char *)(v8 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 4u;
    *(unsigned char *)(v8 + 19PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 1;
    *(unsigned char *)(v3 + 1088) = 2;
    this = HGRasterizer::texCoordArray((const char *)v3, (const HGArrayDataRef *)(*(void *)(v3 + 496) + 80));
  }
  uint64_t v9 = *(void *)(v3 + 456);
  if (*(unsigned char *)(v9 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 8u;
    *(unsigned char *)(v9 + 19PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 1;
    *(unsigned char *)(v3 + 1088) = 3;
    this = HGRasterizer::texCoordArray((const char *)v3, (const HGArrayDataRef *)(*(void *)(v3 + 496) + 80));
  }
  uint64_t v10 = *(void *)(v3 + 464);
  if (*(unsigned char *)(v10 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 0x10u;
    *(unsigned char *)(v10 + 19PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 1;
    *(unsigned char *)(v3 + 1088) = 4;
    this = HGRasterizer::texCoordArray((const char *)v3, (const HGArrayDataRef *)(*(void *)(v3 + 496) + 80));
  }
  uint64_t v11 = *(void *)(v3 + 472);
  if (*(unsigned char *)(v11 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 0x20u;
    *(unsigned char *)(v11 + 19PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 1;
    *(unsigned char *)(v3 + 1088) = 5;
    this = HGRasterizer::texCoordArray((const char *)v3, (const HGArrayDataRef *)(*(void *)(v3 + 496) + 80));
  }
  uint64_t v12 = *(void *)(v3 + 480);
  if (*(unsigned char *)(v12 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 0x40u;
    *(unsigned char *)(v12 + 19PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 1;
    *(unsigned char *)(v3 + 1088) = 6;
    this = HGRasterizer::texCoordArray((const char *)v3, (const HGArrayDataRef *)(*(void *)(v3 + 496) + 80));
  }
  uint64_t v13 = *(void *)(v3 + 488);
  if (*(unsigned char *)(v13 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 0x80u;
    *(unsigned char *)(v13 + 19PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 1;
    *(unsigned char *)(v3 + 1088) = 7;
    this = HGRasterizer::texCoordArray((const char *)v3, (const HGArrayDataRef *)(*(void *)(v3 + 496) + 80));
  }
  *(unsigned char *)(v3 + 1088) = v4;
  *(_DWORD *)(v3 + 1084) = v5;
  return this;
}

atomic_uint *volatile *CopyArray3f(atomic_uint *volatile *this, int *a2, uint64_t a3)
{
  int v5 = (int *)this;
  if (!*(void *)a2)
  {
    atomic_fetch_add(*this, 1u);
    atomic_uint *volatile v7 = *this;
    if (!*this) {
      goto LABEL_22;
    }
    int v6 = 0;
    if (v7[3] >= 0) {
      goto LABEL_14;
    }
    goto LABEL_7;
  }
  int v6 = *(_DWORD *)(*(void *)a2 + 8);
  atomic_fetch_add(*this, 1u);
  atomic_uint *volatile v7 = *this;
  if (!*this)
  {
    if (v6 > 0) {
      HGArrayDataRef::allocate((HGArrayDataRef *)this);
    }
    goto LABEL_15;
  }
  if (v7[3] < v6)
  {
LABEL_7:
    int v8 = v7[1] * v6;
    float v7[3] = v6;
    if (v8) {
      operator new[]();
    }
    this = (atomic_uint *volatile *)*((void *)v7 + 2);
    if (this) {
      this = (atomic_uint *volatile *)MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
    }
    *((void *)v7 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  }
LABEL_14:
  v7[2] = v6;
LABEL_15:
  if (v6)
  {
    if (a3)
    {
      for (int i = 0; i != v6; ++i)
      {
        uint64_t v10 = (_DWORD *)(*(void *)(*(void *)a2 + 16) + *(int *)(*(void *)a2 + 4) * (uint64_t)i + a2[2]);
        uint64_t v11 = (_DWORD *)(*(void *)(*(void *)v5 + 16) + *(int *)(*(void *)v5 + 4) * (uint64_t)i + v5[2]);
        *uint64_t v11 = *v10;
        v11[1] = v10[1];
        v11[2] = v10[2];
        v11[3] = 1065353216;
        this = (atomic_uint *volatile *)(*(uint64_t (**)(uint64_t, _DWORD *, _DWORD *, uint64_t))(*(void *)a3 + 208))(a3, v11, v11, 1);
      }
    }
    else
    {
      int v12 = 0;
      int v13 = 0;
      int v14 = *(_DWORD *)(*(void *)a2 + 4);
      uint64_t v15 = *(void *)(*(void *)a2 + 16) + a2[2];
      int v16 = *(_DWORD *)(*(void *)v5 + 4);
      uint64_t v17 = *(void *)(*(void *)v5 + 16) + v5[2];
      do
      {
        int v18 = (_DWORD *)(v15 + v12);
        uint64_t v19 = (_DWORD *)(v17 + v13);
        *uint64_t v19 = *v18;
        v19[1] = v18[1];
        v19[2] = v18[2];
        _OWORD v19[3] = 1065353216;
        v13 += v16;
        v12 += v14;
        --v6;
      }
      while (v6);
    }
  }
LABEL_22:
  uint64_t v20 = *(void *)v5;
  unsigned int add = atomic_fetch_add((atomic_uint *volatile)v20, 0xFFFFFFFF);
  if (v20 && add == 1)
  {
    uint64_t v22 = *(void *)(v20 + 16);
    if (v22) {
      MEMORY[0x1BA9BFB70](v22, 0x1000C8077774924);
    }
    JUMPOUT(0x1BA9BFBA0);
  }
  return this;
}

atomic_uint *volatile *CopyArray2f(atomic_uint *volatile *this, int *a2, uint64_t a3)
{
  int v5 = (int *)this;
  if (!*(void *)a2)
  {
    atomic_fetch_add(*this, 1u);
    atomic_uint *volatile v7 = *this;
    if (!*this) {
      goto LABEL_22;
    }
    int v6 = 0;
    if (v7[3] >= 0) {
      goto LABEL_14;
    }
    goto LABEL_7;
  }
  int v6 = *(_DWORD *)(*(void *)a2 + 8);
  atomic_fetch_add(*this, 1u);
  atomic_uint *volatile v7 = *this;
  if (!*this)
  {
    if (v6 > 0) {
      HGArrayDataRef::allocate((HGArrayDataRef *)this);
    }
    goto LABEL_15;
  }
  if (v7[3] < v6)
  {
LABEL_7:
    int v8 = v7[1] * v6;
    float v7[3] = v6;
    if (v8) {
      operator new[]();
    }
    this = (atomic_uint *volatile *)*((void *)v7 + 2);
    if (this) {
      this = (atomic_uint *volatile *)MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
    }
    *((void *)v7 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  }
LABEL_14:
  v7[2] = v6;
LABEL_15:
  if (v6)
  {
    if (a3)
    {
      for (int i = 0; i != v6; ++i)
      {
        uint64_t v10 = (_DWORD *)(*(void *)(*(void *)a2 + 16) + *(int *)(*(void *)a2 + 4) * (uint64_t)i + a2[2]);
        uint64_t v11 = *(void *)(*(void *)v5 + 16) + *(int *)(*(void *)v5 + 4) * (uint64_t)i + v5[2];
        *(_DWORD *)uint64_t v11 = *v10;
        *(_DWORD *)(v11 + 4) = v10[1];
        *(void *)(v11 + 8) = 0x3F80000000000000;
        this = (atomic_uint *volatile *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a3 + 208))(a3, v11, v11, 1);
      }
    }
    else
    {
      int v12 = 0;
      int v13 = 0;
      int v14 = *(_DWORD *)(*(void *)a2 + 4);
      uint64_t v15 = *(void *)(*(void *)a2 + 16) + a2[2];
      int v16 = *(_DWORD *)(*(void *)v5 + 4);
      uint64_t v17 = *(void *)(*(void *)v5 + 16) + v5[2];
      do
      {
        int v18 = (_DWORD *)(v15 + v12);
        uint64_t v19 = v17 + v13;
        *(_DWORD *)uint64_t v19 = *v18;
        *(_DWORD *)(v19 + 4) = v18[1];
        *(void *)(v19 + 8) = 0x3F80000000000000;
        v13 += v16;
        v12 += v14;
        --v6;
      }
      while (v6);
    }
  }
LABEL_22:
  uint64_t v20 = *(void *)v5;
  unsigned int add = atomic_fetch_add((atomic_uint *volatile)v20, 0xFFFFFFFF);
  if (v20 && add == 1)
  {
    uint64_t v22 = *(void *)(v20 + 16);
    if (v22) {
      MEMORY[0x1BA9BFB70](v22, 0x1000C8077774924);
    }
    JUMPOUT(0x1BA9BFBA0);
  }
  return this;
}

const char *HGRasterizer::texCoordArray(const char *this, const HGArrayDataRef *a2)
{
  if ((this[1084] & 4) != 0)
  {
    uint64_t v3 = (uint64_t)this;
    uint64_t v4 = *((unsigned __int8 *)this + 1088);
    *((_DWORD *)this + 267) |= 1 << v4;
    int v5 = *(uint64_t **)&this[8 * v4 + 432];
    this = (const char *)(*(uint64_t (**)(void))(*(void *)*v5 + 224))();
    int v8 = *((_DWORD *)a2 + 3);
    switch(v8)
    {
      case 13:
        if (this) {
          uint64_t v14 = 0;
        }
        else {
          uint64_t v14 = *v5;
        }
        this = (const char *)CopyArray2f((atomic_uint *volatile *)(*(void *)(v3 + 496)+ 16 * *(unsigned __int8 *)(v3 + 1088)+ 112), (int *)a2, v14);
        break;
      case 21:
        if (this) {
          uint64_t v15 = 0;
        }
        else {
          uint64_t v15 = *v5;
        }
        this = (const char *)CopyArray3f((atomic_uint *volatile *)(*(void *)(v3 + 496)+ 16 * *(unsigned __int8 *)(v3 + 1088)+ 112), (int *)a2, v15);
        break;
      case 28:
        uint64_t v9 = *(unsigned __int8 *)(v3 + 1088);
        uint64_t v10 = (int *)(*(void *)(v3 + 496) + 16 * v9 + 112);
        uint64_t v11 = *(atomic_uint **)a2;
        if (this)
        {
          uint64_t v12 = *(void *)v10;
          if (*(atomic_uint **)v10 != v11)
          {
            if (v12)
            {
              if (atomic_fetch_add((atomic_uint *volatile)v12, 0xFFFFFFFF) == 1)
              {
                uint64_t v13 = *(void *)(v12 + 16);
                if (v13) {
                  MEMORY[0x1BA9BFB70](v13, 0x1000C8077774924);
                }
                this = (const char *)MEMORY[0x1BA9BFBA0](v12, 0x1080C4098BBCF0FLL);
              }
              uint64_t v11 = *(atomic_uint **)a2;
            }
            *(void *)uint64_t v10 = v11;
            if (v11) {
              atomic_fetch_add(v11, 1u);
            }
          }
          v10[2] = *((_DWORD *)a2 + 2);
          break;
        }
        uint64_t v16 = *v5;
        if (v11)
        {
          int v17 = v11[2];
          uint64_t v18 = *(void *)v10;
          if (!*(void *)v10)
          {
            if (v17 > 0) {
              HGArrayDataRef::allocate((HGArrayDataRef *)(*(void *)(v3 + 496) + 16 * v9 + 112));
            }
LABEL_40:
            if (v17)
            {
              if (v16)
              {
                for (int i = 0; i != v17; ++i)
                {
                  uint64_t v21 = (_DWORD *)(*(void *)(*(void *)a2 + 16)
                                 + *(int *)(*(void *)a2 + 4) * (uint64_t)i
                                 + *((int *)a2 + 2));
                  uint64_t v22 = (_DWORD *)(*(void *)(*(void *)v10 + 16)
                                 + *(int *)(*(void *)v10 + 4) * (uint64_t)i
                                 + v10[2]);
                  *uint64_t v22 = *v21;
                  v22[1] = v21[1];
                  int8x16_t v22[2] = v21[2];
                  v22[3] = v21[3];
                  this = (const char *)(*(uint64_t (**)(uint64_t, _DWORD *, _DWORD *, uint64_t))(*(void *)v16 + 208))(v16, v22, v22, 1);
                }
              }
              else
              {
                int v23 = 0;
                int v24 = 0;
                int v25 = *(_DWORD *)(*(void *)a2 + 4);
                uint64_t v26 = *(void *)(*(void *)a2 + 16) + *((int *)a2 + 2);
                int v27 = *(_DWORD *)(*(void *)v10 + 4);
                uint64_t v28 = *(void *)(*(void *)v10 + 16) + v10[2];
                do
                {
                  uint64_t v29 = (_DWORD *)(v26 + v23);
                  int v30 = (_DWORD *)(v28 + v24);
                  *int v30 = *v29;
                  v30[1] = v29[1];
                  int8x16_t v30[2] = v29[2];
                  _OWORD v30[3] = v29[3];
                  v24 += v27;
                  v23 += v25;
                  --v17;
                }
                while (v17);
              }
            }
            break;
          }
LABEL_33:
          if (*(_DWORD *)(v18 + 12) < v17)
          {
            int v19 = *(_DWORD *)(v18 + 4) * v17;
            *(_DWORD *)(v18 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v17;
            if (v19) {
              operator new[]();
            }
            this = *(const char **)(v18 + 16);
            if (this) {
              this = (const char *)MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
            }
            *(void *)(v18 + 16) = 0;
          }
          *(_DWORD *)(v18 + 8) = v17;
          goto LABEL_40;
        }
        uint64_t v18 = *(void *)v10;
        if (*(void *)v10)
        {
          int v17 = 0;
          goto LABEL_33;
        }
        break;
      default:
        *(_DWORD *)(v3 + 1100) = 1280;
        return HGLogger::warning((HGLogger *)"%s", v6, v7, "hglTexCoordArray: invalid type");
    }
    *(unsigned char *)(*(void *)(v3 + 8 * *(unsigned __int8 *)(v3 + 1088) + 432) + 19PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 1;
  }
  return this;
}

char *HGRasterizer::texParameterfv(char *this, const char *a2, char *a3, float *a4)
{
  uint64_t v4 = this;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (!this[1140])
  {
    uint64_t v7 = *((void *)this + 62);
    *(unsigned char *)(v7 + 240) = 1;
    uint64_t v8 = *(void *)(v7 + 80);
    if (v8) {
      LODWORD(v8) = *(_DWORD *)(v8 + 8);
    }
    HGRasterizer::drawArrays((HGRasterizer *)this, *((_DWORD *)this + 274), *((_DWORD *)this + 278), v8 - *((_DWORD *)this + 278));
    v4[1140] = 1;
    snprintf(__str, 0x100uLL, "%s: invalid call between hglBegin/hglEnd", "hglTexParameteri");
    int v11 = 1282;
    goto LABEL_23;
  }
  if (a2 != 3553)
  {
LABEL_22:
    snprintf(__str, 0x100uLL, "%s: invalid type", "hglTexParameteri");
    int v11 = 1280;
LABEL_23:
    *((_DWORD *)v4 + 275) = v11;
    return (char *)HGLogger::warning((HGLogger *)"%s", v9, v10, __str);
  }
  switch((int)a3)
  {
    case 10240:
      if (this[1088])
      {
        *((_DWORD *)this + 275) = 1281;
        this = (char *)HGLogger::warning((HGLogger *)"%s", a2, a3, "hglTexParameterfv: HGL_TEXTURE_MAG_FILTER invalid unit.  Currently filter type can only be set on unit 0 and it applies to all inputs.");
        uint64_t v6 = v4[1088];
      }
      else
      {
        uint64_t v6 = 0;
      }
      uint64_t v14 = (int *)(*(void *)&v4[8 * v6 + 432] + 160);
      float v17 = *a4;
      if (*a4 == 9728.0) {
        goto LABEL_27;
      }
      goto LABEL_21;
    case 10241:
      if (this[1088])
      {
        *((_DWORD *)this + 275) = 1281;
        this = (char *)HGLogger::warning((HGLogger *)"%s", a2, a3, "hglTexParameterfv: HGL_TEXTURE_MIN_FILTER invalid unit.  Currently filter type can only be set on unit 0 and it applies to all inputs.");
        uint64_t v13 = v4[1088];
      }
      else
      {
        uint64_t v13 = 0;
      }
      uint64_t v14 = (int *)(*(void *)&v4[8 * v13 + 432] + 164);
      float v17 = *a4;
      if (*a4 == 9728.0)
      {
LABEL_27:
        *uint64_t v14 = 0;
        return this;
      }
LABEL_21:
      if (v17 == 9729.0) {
        goto LABEL_15;
      }
      goto LABEL_22;
    case 10242:
      uint64_t v14 = (int *)(*(void *)&this[8 * this[1088] + 432] + 168);
      float v15 = *a4;
      if (*a4 != 33069.0) {
        goto LABEL_14;
      }
      goto LABEL_17;
    case 10243:
      uint64_t v14 = (int *)(*(void *)&this[8 * this[1088] + 432] + 172);
      float v15 = *a4;
      if (*a4 == 33069.0)
      {
LABEL_17:
        int v16 = 2;
      }
      else
      {
LABEL_14:
        if (v15 != 33071.0) {
          goto LABEL_22;
        }
LABEL_15:
        int v16 = 1;
      }
      *uint64_t v14 = v16;
      break;
    default:
      if (a3 != 4100) {
        goto LABEL_22;
      }
      uint64_t v12 = *(float **)&this[8 * this[1088] + 432];
      v12[49] = *a4;
      v12[50] = a4[1];
      v12[51] = a4[2];
      v12[52] = a4[3];
      return this;
  }
  return this;
}

void *HGArray<short,(HGFormat)3>::append(HGArrayDataRef *this, uint64_t *a2)
{
  uint64_t v4 = *(void *)this;
  if (*(void *)this)
  {
    int v5 = *(_DWORD *)(v4 + 8);
    uint64_t v6 = *a2;
    if (*a2) {
      goto LABEL_3;
    }
  }
  else
  {
    int v5 = 0;
    uint64_t v6 = *a2;
    if (*a2)
    {
LABEL_3:
      int v7 = *(_DWORD *)(v6 + 8);
      if (v4) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  int v7 = 0;
  if (v4)
  {
LABEL_4:
    int v8 = *(_DWORD *)(v4 + 4);
    int v9 = v7 + v5;
    if (*(_DWORD *)(v4 + 12) < v7 + v5)
    {
      *(_DWORD *)(v4 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v9;
      if (v8 * v9) {
        operator new[]();
      }
      uint64_t v14 = *(void *)(v4 + 16);
      if (v14) {
        MEMORY[0x1BA9BFB70](v14, 0x1000C8077774924);
      }
      *(void *)(v4 + 16) = 0;
    }
    *(_DWORD *)(v4 + 8) = v9;
    uint64_t v10 = *(void *)this;
    if (*(void *)this) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }
LABEL_9:
  if (!((v7 + v5 < 0) ^ __OFADD__(v7, v5) | (v7 + v5 == 0))) {
    HGArrayDataRef::allocate(this);
  }
  int v8 = 0;
  uint64_t v10 = *(void *)this;
  if (*(void *)this)
  {
LABEL_18:
    int v11 = (void *)(*(void *)(v10 + 16) + *(int *)(v10 + 4) * (uint64_t)v5);
    uint64_t v12 = *a2;
    if (*a2) {
      goto LABEL_19;
    }
LABEL_13:
    uint64_t v13 = 0;
    goto LABEL_20;
  }
LABEL_12:
  int v11 = 0;
  uint64_t v12 = *a2;
  if (!*a2) {
    goto LABEL_13;
  }
LABEL_19:
  uint64_t v13 = *(const void **)(v12 + 16);
LABEL_20:

  return memmove(v11, v13, v8 * v7);
}

float HGRasterizer::drawLines(HGRasterizer *this)
{
  v2[6] = *MEMORY[0x1E4F143B8];
  float result = *((float *)this + 150);
  if (result >= 1.0)
  {
    v2[0] = 0;
    v2[1] = 0x1C00000000;
    HGArrayDataRef::allocate((HGArrayDataRef *)v2);
  }
  return result;
}

void sub_1B76ED504(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  if (a25 && atomic_fetch_add((atomic_uint *volatile)a25, 0xFFFFFFFF) == 1)
  {
    uint64_t v32 = *(void *)(a25 + 16);
    if (v32) {
      MEMORY[0x1BA9BFB70](v32, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](a25, 0x1080C4098BBCF0FLL);
  }
  if (a23 && atomic_fetch_add((atomic_uint *volatile)a23, 0xFFFFFFFF) == 1)
  {
    uint64_t v33 = *(void *)(a23 + 16);
    if (v33) {
      MEMORY[0x1BA9BFB70](v33, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](a23, 0x1080C4098BBCF0FLL);
  }
  if (a21 && atomic_fetch_add((atomic_uint *volatile)a21, 0xFFFFFFFF) == 1)
  {
    uint64_t v34 = *(void *)(a21 + 16);
    if (v34) {
      MEMORY[0x1BA9BFB70](v34, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](a21, 0x1080C4098BBCF0FLL);
  }
  if (a19 && atomic_fetch_add((atomic_uint *volatile)a19, 0xFFFFFFFF) == 1)
  {
    uint64_t v35 = *(void *)(a19 + 16);
    if (v35) {
      MEMORY[0x1BA9BFB70](v35, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](a19, 0x1080C4098BBCF0FLL);
  }
  if (a17 && atomic_fetch_add((atomic_uint *volatile)a17, 0xFFFFFFFF) == 1)
  {
    uint64_t v36 = *(void *)(a17 + 16);
    if (v36) {
      MEMORY[0x1BA9BFB70](v36, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](a17, 0x1080C4098BBCF0FLL);
  }
  if (a15 && atomic_fetch_add((atomic_uint *volatile)a15, 0xFFFFFFFF) == 1)
  {
    uint64_t v37 = *(void *)(a15 + 16);
    if (v37) {
      MEMORY[0x1BA9BFB70](v37, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](a15, 0x1080C4098BBCF0FLL);
  }
  if (a13 && atomic_fetch_add((atomic_uint *volatile)a13, 0xFFFFFFFF) == 1)
  {
    uint64_t v38 = *(void *)(a13 + 16);
    if (v38) {
      MEMORY[0x1BA9BFB70](v38, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](a13, 0x1080C4098BBCF0FLL);
  }
  if (a11 && atomic_fetch_add((atomic_uint *volatile)a11, 0xFFFFFFFF) == 1)
  {
    uint64_t v39 = *(void *)(a11 + 16);
    if (v39) {
      MEMORY[0x1BA9BFB70](v39, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](a11, 0x1080C4098BBCF0FLL);
  }
  if (a31 && atomic_fetch_add((atomic_uint *volatile)a31, 0xFFFFFFFF) == 1)
  {
    uint64_t v40 = *(void *)(a31 + 16);
    if (v40) {
      MEMORY[0x1BA9BFB70](v40, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](a31, 0x1080C4098BBCF0FLL);
  }
  if (a29 && atomic_fetch_add((atomic_uint *volatile)a29, 0xFFFFFFFF) == 1)
  {
    uint64_t v41 = *(void *)(a29 + 16);
    if (v41) {
      MEMORY[0x1BA9BFB70](v41, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](a29, 0x1080C4098BBCF0FLL);
  }
  if (a27 && atomic_fetch_add((atomic_uint *volatile)a27, 0xFFFFFFFF) == 1)
  {
    uint64_t v42 = *(void *)(a27 + 16);
    if (v42) {
      MEMORY[0x1BA9BFB70](v42, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](a27, 0x1080C4098BBCF0FLL);
  }
  _Unwind_Resume(exception_object);
}

char *HGRasterizer::enableClientState(char *this, int a2, int a3)
{
  uint64_t v3 = this;
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a3) {
    uint64_t v4 = "hglEnableClientState";
  }
  else {
    uint64_t v4 = "hglDisableClientState";
  }
  if (this[1140])
  {
    int v6 = a2 - 32884;
    if (a2 - 32884) < 5 && ((0x17u >> v6))
    {
      int v9 = *(_DWORD *)&asc_1B7EBF938[4 * v6];
      if (a3) {
        goto LABEL_8;
      }
    }
    else
    {
      snprintf(__str, 0x100uLL, "%s: invalid parameter passed to function", v4);
      *((_DWORD *)v3 + 275) = 1280;
      this = (char *)HGLogger::warning((HGLogger *)"%s", v7, v8, __str);
      int v9 = 0;
      if (a3)
      {
LABEL_8:
        int v10 = *((_DWORD *)v3 + 271) | v9;
LABEL_14:
        *((_DWORD *)v3 + 27PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v10;
        return this;
      }
    }
    int v10 = *((_DWORD *)v3 + 271) & ~v9;
    goto LABEL_14;
  }
  uint64_t v11 = *((void *)this + 62);
  *(unsigned char *)(v11 + 240) = 1;
  uint64_t v12 = *(void *)(v11 + 80);
  if (v12) {
    LODWORD(v1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = *(_DWORD *)(v12 + 8);
  }
  HGRasterizer::drawArrays((HGRasterizer *)this, *((_DWORD *)this + 274), *((_DWORD *)this + 278), v12 - *((_DWORD *)this + 278));
  v3[1140] = 1;
  snprintf(__str, 0x100uLL, "%s: invalid call between hglBegin/hglEnd", v4);
  *((_DWORD *)v3 + 275) = 1282;
  return (char *)HGLogger::warning((HGLogger *)"%s", v13, v14, __str);
}

uint64_t HGRasterizer::SetInput(HGNode *this, unsigned int a2, HGNode *a3)
{
  if (a2 || !a3)
  {
    int v7 = 1 << a2;
    if (!a3)
    {
      int v8 = *((_DWORD *)this + 264) & ~v7;
      goto LABEL_15;
    }
  }
  else
  {
    if (!*((unsigned char *)this + 1064))
    {
      uint64_t v4 = *((void *)this + 94);
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      }
      if (*((void *)this + 64))
      {
        uint64_t v5 = *((void *)this + 66);
        int v6 = (HRasterizerTexture *)HGObject::operator new(0x1C0uLL);
        if (v5) {
          HRasterizerTexture::HRasterizerTexture(v6);
        }
        HRasterizerTextureNoColor::HRasterizerTextureNoColor(v6);
      }
      int v9 = (HRasterizerTexture *)HGObject::operator new(0x1C0uLL);
      HRasterizerTexture::HRasterizerTexture(v9);
    }
    int v7 = 1;
  }
  int v8 = *((_DWORD *)this + 264) | v7;
LABEL_15:
  *((_DWORD *)this + 264) = v8;

  return HGNode::SetInput(this, a2, a3);
}

void sub_1B76EDB28(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EDB3C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EDB50(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGRasterizer::addInputTransform(uint64_t a1, int a2, const HGTransform *a3, uint64_t *a4)
{
  *(unsigned char *)(a1 + 1077) = 1;
  uint64_t v6 = *(void *)(a1 + 8 * a2 + 432);
  HGTransform::LoadIdentity((HGTransform *)(v6 + 8));
  HGTransform::LoadTransform((HGTransform *)(v6 + 8), a3);
  v7.n128_f64[0] = HGTransform::Invert2D((HGTransform *)(v6 + 8));
  uint64_t v8 = *(void *)(v6 + 152);
  uint64_t result = *a4;
  if (v8 != *a4)
  {
    if (v8)
    {
      (*(void (**)(void, double))(*(void *)v8 + 24))(*(void *)(v6 + 152), v7.n128_f64[0]);
      uint64_t result = *a4;
    }
    *(void *)(v6 + 15PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = result;
    if (result)
    {
      int v10 = *(uint64_t (**)(__n128))(*(void *)result + 16);
      return v10(v7);
    }
  }
  return result;
}

uint64_t HGRasterizer::GetRasterizerFlags(HGRasterizer *this)
{
  return *((unsigned int *)this + 277);
}

uint64_t HGRasterizer::getBlendMode(HGRasterizer *this)
{
  return *((unsigned int *)this + 265);
}

void HGRasterizerAntiAliasingImplementation::~HGRasterizerAntiAliasingImplementation(HGRasterizerAntiAliasingImplementation *this)
{
  HGObject::~HGObject(this);

  HGObject::operator delete(v1);
}

const char *std::__call_once_proxy[abi:ne180100]<std::tuple<HGRasterizer::getIsROIDebug(void)::$_0 &&>>()
{
  uint64_t result = getenv("ROI_DEBUG");
  if (result)
  {
    uint64_t result = (const char *)atoi(result);
    HGRasterizer::_isROIDebug = result == 1;
  }
  else
  {
    HGRasterizer::_isROIDebug = 0;
  }
  return result;
}

void OUTLINED_FUNCTION_1_0()
{
  JUMPOUT(0x1BA9BFBA0);
}

void HGRasterizer::HGRasterizer(atomic_uint *a1)
{
  uint64_t v1 = OUTLINED_FUNCTION_0_1(a1);
  if (v2)
  {
    if (OUTLINED_FUNCTION_3((uint64_t)v1)) {
      OUTLINED_FUNCTION_2();
    }
    OUTLINED_FUNCTION_1_0();
  }
  OUTLINED_FUNCTION_4();
}

void HGRasterizer::drawLines(uint64_t a1)
{
  if (atomic_fetch_add((atomic_uint *volatile)a1, 0xFFFFFFFF) == 1)
  {
    if (*(void *)(a1 + 16)) {
      OUTLINED_FUNCTION_2();
    }
    OUTLINED_FUNCTION_1_0();
  }
}

uint64_t HGMetalDeviceInfo::getMainDevice(HGMetalDeviceInfo *this)
{
  id v1 = MTLCreateSystemDefaultDevice();
  if (atomic_load_explicit((atomic_ullong *volatile)&_MergedGlobals_2, memory_order_acquire) != -1)
  {
    int v9 = &v7;
    uint64_t v8 = &v9;
    std::__call_once(&_MergedGlobals_2, &v8, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMetalDeviceInfo::_initAllDevices(void)::$_0 &&>>);
  }
  char v2 = (std::mutex *)qword_1EB9A0AA8;
  std::mutex::lock((std::mutex *)qword_1EB9A0AA8);
  uint64_t v3 = *(uint64_t **)qword_1EB9A0AB0;
  uint64_t v4 = *(uint64_t **)(qword_1EB9A0AB0 + 8);
  if (*(uint64_t **)qword_1EB9A0AB0 == v4)
  {
LABEL_6:
    uint64_t v5 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v5 = *v3;
      if (*(id *)(*v3 + 16) == v1) {
        break;
      }
      if (++v3 == v4) {
        goto LABEL_6;
      }
    }
  }
  std::mutex::unlock(v2);

  return v5;
}

uint64_t HGMetalDeviceInfo::getDeviceInfo(uint64_t a1)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&_MergedGlobals_2, memory_order_acquire) != -1)
  {
    int v9 = &v7;
    uint64_t v8 = &v9;
    std::__call_once(&_MergedGlobals_2, &v8, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMetalDeviceInfo::_initAllDevices(void)::$_0 &&>>);
  }
  char v2 = (std::mutex *)qword_1EB9A0AA8;
  std::mutex::lock((std::mutex *)qword_1EB9A0AA8);
  uint64_t v3 = *(uint64_t **)qword_1EB9A0AB0;
  uint64_t v4 = *(uint64_t **)(qword_1EB9A0AB0 + 8);
  if (*(uint64_t **)qword_1EB9A0AB0 == v4)
  {
LABEL_6:
    uint64_t v5 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v5 = *v3;
      if (*(void *)(*v3 + 16) == a1) {
        break;
      }
      if (++v3 == v4) {
        goto LABEL_6;
      }
    }
  }
  std::mutex::unlock(v2);
  return v5;
}

void HGMetalDeviceInfo::_init(HGMetalDeviceInfo *this)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v83, "metal", 1, "HGMetalDeviceInfo::_init()");
  *((void *)this + 3) = [*((id *)this + 2) registryID];
  *((_DWORD *)this + 8) = 4203;
  size_t v81 = 8;
  uint64_t v82 = 0;
  *(void *)int v84 = 0x1800000006;
  sysctl(v84, 2u, &v82, &v81, 0, 0);
  *((void *)this + 5) = v82;
  unsigned __int8 v3 = atomic_load(HGLogger::_enabled);
  if ((v3 & 1) != 0 && (int)HGLogger::getLevel((HGLogger *)"metal", v2) >= 1)
  {
    unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
    if (v6) {
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"device          : %p\n", v4, v5, *((void *)this + 2));
    }
    unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
    if (v7)
    {
      uint64_t v8 = objc_msgSend((id)objc_msgSend(*((id *)this + 2), "name"), "UTF8String");
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"name            : %s\n", v9, v10, v8);
    }
    unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
    if (v11) {
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"registryID      : 0x%llx\n", v4, v5, *((void *)this + 3));
    }
    unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
    if (v12) {
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"  vendorID      : 0x%4x\n", v4, v5, *((unsigned int *)this + 8));
    }
    unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
    if (v13) {
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"  deviceID      : 0x%4x\n", v4, v5, *((unsigned int *)this + 9));
    }
    unsigned __int8 v14 = atomic_load(HGLogger::_enabled);
    if (v14)
    {
      float v15 = "no";
      if (*((_DWORD *)this + 8) == 4098) {
        float v15 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"AMD             : %s\n", v4, v5, v15);
    }
    unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
    if (v16)
    {
      float v17 = "no";
      if (*((_DWORD *)this + 8) == 32902) {
        float v17 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"Intel           : %s\n", v4, v5, v17);
    }
    unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
    if (v18)
    {
      uint64_t v19 = "no";
      if (*((_DWORD *)this + 8) == 4203) {
        uint64_t v19 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"Apple           : %s\n", v4, v5, v19);
    }
    unsigned __int8 v20 = atomic_load(HGLogger::_enabled);
    if (v20) {
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"headless        : %s\n", v4, v5, "no");
    }
    unsigned __int8 v21 = atomic_load(HGLogger::_enabled);
    if (v21) {
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"lowPower        : %s\n", v4, v5, "no");
    }
    unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
    if (v22) {
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"removable       : %s\n", v4, v5, "no");
    }
    unsigned __int8 v23 = atomic_load(HGLogger::_enabled);
    if (v23)
    {
      int v24 = [*((id *)this + 2) hasUnifiedMemory];
      int v27 = "no";
      if (v24) {
        int v27 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"unifiedMemory   : %s\n", v25, v26, v27);
    }
    unsigned __int8 v28 = atomic_load(HGLogger::_enabled);
    if (v28) {
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"memory          : %.1f GB\n", v4, v5, (float)((float)*((unint64_t *)this + 5) * 9.3132e-10));
    }
  }
  int v29 = [*((id *)this + 2) supportsFamily:1001];
  int v30 = [*((id *)this + 2) supportsFamily:1002];
  int v31 = [*((id *)this + 2) supportsFamily:1003];
  int v32 = [*((id *)this + 2) supportsFamily:1004];
  int v33 = [*((id *)this + 2) supportsFamily:1005];
  int v34 = [*((id *)this + 2) supportsFamily:1006];
  int v35 = [*((id *)this + 2) supportsFamily:1007];
  int v36 = [*((id *)this + 2) supportsFamily:2002];
  int v80 = [*((id *)this + 2) supportsFamily:3001];
  int v79 = [*((id *)this + 2) supportsFamily:3002];
  int v78 = [*((id *)this + 2) supportsFamily:3003];
  unsigned __int8 v38 = atomic_load(HGLogger::_enabled);
  if ((v38 & 1) != 0 && (int)HGLogger::getLevel((HGLogger *)"metal", v37) >= 1)
  {
    unsigned __int8 v41 = atomic_load(HGLogger::_enabled);
    if (v41)
    {
      uint64_t v42 = "no";
      if (v29) {
        uint64_t v42 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple1 : %s\n", v39, v40, v42);
    }
    unsigned __int8 v43 = atomic_load(HGLogger::_enabled);
    if (v43)
    {
      uint64_t v44 = "no";
      if (v30) {
        uint64_t v44 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple2 : %s\n", v39, v40, v44);
    }
    unsigned __int8 v45 = atomic_load(HGLogger::_enabled);
    if (v45)
    {
      uint64_t v46 = "no";
      if (v31) {
        uint64_t v46 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple3 : %s\n", v39, v40, v46);
    }
    unsigned __int8 v47 = atomic_load(HGLogger::_enabled);
    if (v47)
    {
      GLenum v48 = "no";
      if (v32) {
        GLenum v48 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple4 : %s\n", v39, v40, v48);
    }
    unsigned __int8 v49 = atomic_load(HGLogger::_enabled);
    if (v49)
    {
      GLenum v50 = "no";
      if (v33) {
        GLenum v50 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple5 : %s\n", v39, v40, v50);
    }
    unsigned __int8 v51 = atomic_load(HGLogger::_enabled);
    if (v51)
    {
      uint64_t v52 = "no";
      if (v34) {
        uint64_t v52 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple6 : %s\n", v39, v40, v52);
    }
    unsigned __int8 v53 = atomic_load(HGLogger::_enabled);
    if (v53)
    {
      uint64_t v54 = "no";
      if (v35) {
        uint64_t v54 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple7 : %s\n", v39, v40, v54);
    }
    unsigned __int8 v55 = atomic_load(HGLogger::_enabled);
    if (v55)
    {
      uint64_t v56 = "no";
      if (v36) {
        uint64_t v56 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyMac2 : %s\n", v39, v40, v56);
    }
    unsigned __int8 v57 = atomic_load(HGLogger::_enabled);
    if (v57)
    {
      uint64_t v58 = "no";
      if (v80) {
        uint64_t v58 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyCommon1 : %s\n", v39, v40, v58);
    }
    unsigned __int8 v59 = atomic_load(HGLogger::_enabled);
    if (v59)
    {
      uint64_t v60 = "no";
      if (v79) {
        uint64_t v60 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyCommon2 : %s\n", v39, v40, v60);
    }
    unsigned __int8 v61 = atomic_load(HGLogger::_enabled);
    if (v61)
    {
      uint64_t v62 = "no";
      if (v78) {
        uint64_t v62 = "yes";
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyCommon3 : %s\n", v39, v40, v62);
    }
  }
  if (v31) {
    int v63 = 0x4000;
  }
  else {
    int v63 = 0x2000;
  }
  *((_DWORD *)this + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v63;
  *((unsigned char *)this + 56) = v30;
  *((unsigned char *)this + 57) = v32;
  int v64 = (void *)*((void *)this + 2);
  if ([v64 supportsTextureSampleCount:8])
  {
    *((_DWORD *)this + 13) = 8;
    unsigned __int8 v67 = atomic_load(HGLogger::_enabled);
    if ((v67 & 1) == 0) {
      goto LABEL_97;
    }
LABEL_96:
    HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"maxTextureGLenum Size = %d\n", v65, v66, *((unsigned int *)this + 12));
    goto LABEL_97;
  }
  if ([v64 supportsTextureSampleCount:4])
  {
    *((_DWORD *)this + 13) = 4;
    unsigned __int8 v68 = atomic_load(HGLogger::_enabled);
    if (v68) {
      goto LABEL_96;
    }
  }
  else
  {
    if ([v64 supportsTextureSampleCount:2]) {
      int v69 = 2;
    }
    else {
      int v69 = 1;
    }
    *((_DWORD *)this + 13) = v69;
    unsigned __int8 v70 = atomic_load(HGLogger::_enabled);
    if (v70) {
      goto LABEL_96;
    }
  }
LABEL_97:
  unsigned __int8 v71 = atomic_load(HGLogger::_enabled);
  if (v71) {
    HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"maxSampleCount = %d\n", v65, v66, *((unsigned int *)this + 13));
  }
  unsigned __int8 v72 = atomic_load(HGLogger::_enabled);
  if (v72)
  {
    if (*((unsigned char *)this + 56)) {
      uint64_t v73 = "yes";
    }
    else {
      uint64_t v73 = "no";
    }
    HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"clampToZeroBuffers = %s\n", v65, v66, v73);
  }
  unsigned __int8 v74 = atomic_load(HGLogger::_enabled);
  if (v74)
  {
    if (*((unsigned char *)this + 57)) {
      uint64_t v75 = "yes";
    }
    else {
      uint64_t v75 = "no";
    }
    HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"quadShuffleSupported = %s\n", v65, v66, v75);
  }
  unsigned __int8 v76 = atomic_load(HGLogger::_enabled);
  if (v76)
  {
    if (*((unsigned char *)this + 58)) {
      int v77 = "yes";
    }
    else {
      int v77 = "no";
    }
    HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"bufferlessClientStorageSupported = %s\n", v65, v66, v77);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v83);
}

void sub_1B76EE7B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76EE7C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76EE7DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76EE7F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76EE804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76EE818(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76EE82C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76EE840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76EE854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76EE868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76EE87C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76EE894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B76EE8A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGMetalDeviceInfo::~HGMetalDeviceInfo(id *this)
{
  *this = &unk_1F10C5838;

  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;
  uint64_t vars8;

  *this = &unk_1F10C5838;

  HGObject::~HGObject((HGObject *)this);

  HGObject::operator delete(v2);
}

uint64_t HGMetalDeviceInfo::name(id *this)
{
  id v1 = (void *)[this[2] name];

  return [v1 UTF8String];
}

BOOL HGMetalDeviceInfo::isAMD(HGMetalDeviceInfo *this)
{
  return *((_DWORD *)this + 8) == 4098;
}

BOOL HGMetalDeviceInfo::isIntel(HGMetalDeviceInfo *this)
{
  return *((_DWORD *)this + 8) == 32902;
}

BOOL HGMetalDeviceInfo::isApple(HGMetalDeviceInfo *this)
{
  return *((_DWORD *)this + 8) == 4203;
}

uint64_t HGMetalDeviceInfo::validateTextureSampleCount(HGMetalDeviceInfo *this, const char *a2, char *a3)
{
  unsigned int v3 = *((_DWORD *)this + 13);
  if (v3 >= a2) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = v3;
  }
  if (v3 < a2) {
    HGLogger::warning((HGLogger *)"Requested sample count: %d, differs from final sample count: %d", a2, a3, a2, v4);
  }
  return v4;
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<HGMetalDeviceInfo::_initAllDevices(void)::$_0 &&>>()
{
}

void sub_1B76EECB4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EECC8(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void HGYUVPlanarToRGBA::HGYUVPlanarToRGBA(HGNode *a1, int a2, char a3)
{
  HGNode::HGNode(a1);
  *(void *)uint64_t v5 = &unk_1F10C5888;
  *(void *)(v5 + 408) = 0;
  *(_DWORD *)(v5 + 416) = a2;
  *(void *)(v5 + 420) = 0x300000001;
  *(unsigned char *)(v5 + 43PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *(unsigned char *)(v5 + 433) = a3;
  *(_DWORD *)(v5 + 436) = 1;
}

void HGYUVPlanarToRGBA::~HGYUVPlanarToRGBA(HGNode *this)
{
  *(void *)this = &unk_1F10C5888;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10C5888;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

HGColorConform *HGYUVPlanarToRGBA::GetOutputForXRsRGB(HGYUVPlanarToRGBA *this, HGRenderer *a2, HGNode *a3)
{
  unsigned int v3 = a3;
  int v5 = *((_DWORD *)this + 109);
  if (!v5)
  {
    int v6 = 2;
LABEL_7:
    unsigned __int8 v7 = (_DWORD *)((char *)this + 428);
    goto LABEL_8;
  }
  if (v5 != 2)
  {
    if (v5 == 3) {
      int v6 = 3;
    }
    else {
      int v6 = 0;
    }
    goto LABEL_7;
  }
  unsigned __int8 v7 = (_DWORD *)((char *)this + 428);
  if (*((_DWORD *)this + 107) == 2)
  {
    unsigned __int8 v13 = (HGGamutMap *)HGObject::operator new(0x1E0uLL);
    HGGamutMap::HGGamutMap(v13);
    int v6 = 5;
    HGGamutMap::SetConversion((uint64_t)v13, 5, 1, 0, 0, 8, 0);
    (*(void (**)(HGGamutMap *, void, HGNode *))(*(void *)v13 + 120))(v13, 0, v3);
    unsigned int v3 = (HGNode *)v13;
    goto LABEL_9;
  }
  int v6 = 5;
LABEL_8:
  (*(void (**)(HGNode *, HGRenderer *))(*(void *)a3 + 16))(a3, a2);
LABEL_9:
  uint64_t v8 = (HGColorConform *)HGObject::operator new(0x320uLL);
  HGColorConform::HGColorConform(v8);
  HGColorConform::SetConversion((uint64_t)v8, v6, 1, 0, 0, 8, 0);
  (*(void (**)(HGColorConform *, void, HGNode *))(*(void *)v8 + 120))(v8, 0, v3);
  if (*v7 == 1 && *((_DWORD *)this + 109) == 2)
  {
    int v9 = (HGColorClamp *)HGObject::operator new(0x1C0uLL);
    HGColorClamp::HGColorClamp(v9);
  }
  (*(void (**)(HGColorConform *))(*(void *)v8 + 16))(v8);
  int v10 = (HGColorConform *)HGObject::operator new(0x320uLL);
  HGColorConform::HGColorConform(v10);
  HGColorConform::SetConversion((uint64_t)v10, 11, v11);
  (*(void (**)(HGColorConform *, void, HGColorConform *))(*(void *)v10 + 120))(v10, 0, v8);
  (*(void (**)(HGNode *))(*(void *)v3 + 24))(v3);
  (*(void (**)(HGColorConform *))(*(void *)v8 + 24))(v8);
  (*(void (**)(HGColorConform *))(*(void *)v8 + 24))(v8);
  return v10;
}

void sub_1B76EF108(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EF11C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EF134(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EF14C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGYUVPlanarToRGBA::GetOutputForPlanar(HGNode *this, HGRenderer *a2)
{
  HGRenderer::GetInput(a2, this, 0);
  HGRenderer::GetInput(a2, this, 1u);
  if (*((unsigned char *)this + 433))
  {
    Input = HGRenderer::GetInput(a2, this, 2u);
    int v5 = *((_DWORD *)this + 104);
    if (v5 != 1) {
      goto LABEL_3;
    }
  }
  else
  {
    Input = 0;
    int v5 = *((_DWORD *)this + 104);
    if (v5 != 1)
    {
LABEL_3:
      if (v5 == 2)
      {
        int v6 = *((_DWORD *)this + 105);
        if (v6 != 2)
        {
          if (!v6)
          {
            unsigned __int8 v7 = (HgcYUV444TriPlanar_601ToRGB *)HGObject::operator new(0x1A0uLL);
            *(_OWORD *)unsigned __int8 v7 = 0u;
            *((_OWORD *)v7 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
            *((_OWORD *)v7 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
            *((_OWORD *)v7 + 3) = 0u;
            *((_OWORD *)v7 + 4) = 0u;
            *((_OWORD *)v7 + 5) = 0u;
            *((_OWORD *)v7 + 6) = 0u;
            *((_OWORD *)v7 + 7) = 0u;
            *((_OWORD *)v7 + 8) = 0u;
            *((_OWORD *)v7 + 9) = 0u;
            *((_OWORD *)v7 + 10) = 0u;
            *((_OWORD *)v7 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
            *((_OWORD *)v7 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
            *((_OWORD *)v7 + 13) = 0u;
            *((_OWORD *)v7 + 14) = 0u;
            *((_OWORD *)v7 + 15) = 0u;
            *((_OWORD *)v7 + 16) = 0u;
            *((_OWORD *)v7 + 17) = 0u;
            *((_OWORD *)v7 + 18) = 0u;
            *((_OWORD *)v7 + 19) = 0u;
            *((_OWORD *)v7 + 20) = 0u;
            *((_OWORD *)v7 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
            *((_OWORD *)v7 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
            *((_OWORD *)v7 + 23) = 0u;
            *((_OWORD *)v7 + 24) = 0u;
            *((_OWORD *)v7 + 25) = 0u;
            if (Input) {
              HgcYUV444TriPlanar_601ToRGB::HgcYUV444TriPlanar_601ToRGB(v7);
            }
            HgcYUV444BiPlanar_601ToRGB::HgcYUV444BiPlanar_601ToRGB(v7);
          }
          unsigned __int8 v13 = (HgcYUV444TriPlanar_709ToRGB *)HGObject::operator new(0x1A0uLL);
          *(_OWORD *)unsigned __int8 v13 = 0u;
          *((_OWORD *)v13 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
          *((_OWORD *)v13 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
          *((_OWORD *)v13 + 3) = 0u;
          *((_OWORD *)v13 + 4) = 0u;
          *((_OWORD *)v13 + 5) = 0u;
          *((_OWORD *)v13 + 6) = 0u;
          *((_OWORD *)v13 + 7) = 0u;
          *((_OWORD *)v13 + 8) = 0u;
          *((_OWORD *)v13 + 9) = 0u;
          *((_OWORD *)v13 + 10) = 0u;
          *((_OWORD *)v13 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
          *((_OWORD *)v13 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
          *((_OWORD *)v13 + 13) = 0u;
          *((_OWORD *)v13 + 14) = 0u;
          *((_OWORD *)v13 + 15) = 0u;
          *((_OWORD *)v13 + 16) = 0u;
          *((_OWORD *)v13 + 17) = 0u;
          *((_OWORD *)v13 + 18) = 0u;
          *((_OWORD *)v13 + 19) = 0u;
          *((_OWORD *)v13 + 20) = 0u;
          *((_OWORD *)v13 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
          *((_OWORD *)v13 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
          *((_OWORD *)v13 + 23) = 0u;
          *((_OWORD *)v13 + 24) = 0u;
          *((_OWORD *)v13 + 25) = 0u;
          if (Input) {
            HgcYUV444TriPlanar_709ToRGB::HgcYUV444TriPlanar_709ToRGB(v13);
          }
          HgcYUV444BiPlanar_709ToRGB::HgcYUV444BiPlanar_709ToRGB(v13);
        }
        unsigned __int8 v12 = (HgcYUV444TriPlanar_2020ToRGB *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)unsigned __int8 v12 = 0u;
        *((_OWORD *)v12 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
        *((_OWORD *)v12 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
        *((_OWORD *)v12 + 3) = 0u;
        *((_OWORD *)v12 + 4) = 0u;
        *((_OWORD *)v12 + 5) = 0u;
        *((_OWORD *)v12 + 6) = 0u;
        *((_OWORD *)v12 + 7) = 0u;
        *((_OWORD *)v12 + 8) = 0u;
        *((_OWORD *)v12 + 9) = 0u;
        *((_OWORD *)v12 + 10) = 0u;
        *((_OWORD *)v12 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
        *((_OWORD *)v12 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
        *((_OWORD *)v12 + 13) = 0u;
        *((_OWORD *)v12 + 14) = 0u;
        *((_OWORD *)v12 + 15) = 0u;
        *((_OWORD *)v12 + 16) = 0u;
        *((_OWORD *)v12 + 17) = 0u;
        *((_OWORD *)v12 + 18) = 0u;
        *((_OWORD *)v12 + 19) = 0u;
        *((_OWORD *)v12 + 20) = 0u;
        *((_OWORD *)v12 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
        *((_OWORD *)v12 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
        *((_OWORD *)v12 + 23) = 0u;
        *((_OWORD *)v12 + 24) = 0u;
        *((_OWORD *)v12 + 25) = 0u;
        if (Input) {
          HgcYUV444TriPlanar_2020ToRGB::HgcYUV444TriPlanar_2020ToRGB(v12);
        }
        HgcYUV444BiPlanar_2020ToRGB::HgcYUV444BiPlanar_2020ToRGB(v12);
      }
      int v10 = *((_DWORD *)this + 105);
      if (v10 != 2)
      {
        if (!v10)
        {
          unsigned __int8 v11 = (HgcYUV420TriPlanar_601ToRGB *)HGObject::operator new(0x1A0uLL);
          *(_OWORD *)unsigned __int8 v11 = 0u;
          *((_OWORD *)v11 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
          *((_OWORD *)v11 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
          *((_OWORD *)v11 + 3) = 0u;
          *((_OWORD *)v11 + 4) = 0u;
          *((_OWORD *)v11 + 5) = 0u;
          *((_OWORD *)v11 + 6) = 0u;
          *((_OWORD *)v11 + 7) = 0u;
          *((_OWORD *)v11 + 8) = 0u;
          *((_OWORD *)v11 + 9) = 0u;
          *((_OWORD *)v11 + 10) = 0u;
          *((_OWORD *)v11 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
          *((_OWORD *)v11 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
          *((_OWORD *)v11 + 13) = 0u;
          *((_OWORD *)v11 + 14) = 0u;
          *((_OWORD *)v11 + 15) = 0u;
          *((_OWORD *)v11 + 16) = 0u;
          *((_OWORD *)v11 + 17) = 0u;
          *((_OWORD *)v11 + 18) = 0u;
          *((_OWORD *)v11 + 19) = 0u;
          *((_OWORD *)v11 + 20) = 0u;
          *((_OWORD *)v11 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
          *((_OWORD *)v11 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
          *((_OWORD *)v11 + 23) = 0u;
          *((_OWORD *)v11 + 24) = 0u;
          *((_OWORD *)v11 + 25) = 0u;
          if (Input) {
            HgcYUV420TriPlanar_601ToRGB::HgcYUV420TriPlanar_601ToRGB(v11);
          }
          HgcYUV420BiPlanar_601ToRGB::HgcYUV420BiPlanar_601ToRGB(v11);
        }
        float v17 = (HgcYUV420TriPlanar_709ToRGB *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)float v17 = 0u;
        *((_OWORD *)v17 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
        *((_OWORD *)v17 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
        *((_OWORD *)v17 + 3) = 0u;
        *((_OWORD *)v17 + 4) = 0u;
        *((_OWORD *)v17 + 5) = 0u;
        *((_OWORD *)v17 + 6) = 0u;
        *((_OWORD *)v17 + 7) = 0u;
        *((_OWORD *)v17 + 8) = 0u;
        *((_OWORD *)v17 + 9) = 0u;
        *((_OWORD *)v17 + 10) = 0u;
        *((_OWORD *)v17 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
        *((_OWORD *)v17 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
        *((_OWORD *)v17 + 13) = 0u;
        *((_OWORD *)v17 + 14) = 0u;
        *((_OWORD *)v17 + 15) = 0u;
        *((_OWORD *)v17 + 16) = 0u;
        *((_OWORD *)v17 + 17) = 0u;
        *((_OWORD *)v17 + 18) = 0u;
        *((_OWORD *)v17 + 19) = 0u;
        *((_OWORD *)v17 + 20) = 0u;
        *((_OWORD *)v17 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
        *((_OWORD *)v17 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
        *((_OWORD *)v17 + 23) = 0u;
        *((_OWORD *)v17 + 24) = 0u;
        *((_OWORD *)v17 + 25) = 0u;
        if (Input) {
          HgcYUV420TriPlanar_709ToRGB::HgcYUV420TriPlanar_709ToRGB(v17);
        }
        HgcYUV420BiPlanar_709ToRGB::HgcYUV420BiPlanar_709ToRGB(v17);
      }
      unsigned __int8 v16 = (HgcYUV420TriPlanar_2020ToRGB *)HGObject::operator new(0x1A0uLL);
      *(_OWORD *)unsigned __int8 v16 = 0u;
      *((_OWORD *)v16 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
      *((_OWORD *)v16 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
      *((_OWORD *)v16 + 3) = 0u;
      *((_OWORD *)v16 + 4) = 0u;
      *((_OWORD *)v16 + 5) = 0u;
      *((_OWORD *)v16 + 6) = 0u;
      *((_OWORD *)v16 + 7) = 0u;
      *((_OWORD *)v16 + 8) = 0u;
      *((_OWORD *)v16 + 9) = 0u;
      *((_OWORD *)v16 + 10) = 0u;
      *((_OWORD *)v16 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
      *((_OWORD *)v16 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
      *((_OWORD *)v16 + 13) = 0u;
      *((_OWORD *)v16 + 14) = 0u;
      *((_OWORD *)v16 + 15) = 0u;
      *((_OWORD *)v16 + 16) = 0u;
      *((_OWORD *)v16 + 17) = 0u;
      *((_OWORD *)v16 + 18) = 0u;
      *((_OWORD *)v16 + 19) = 0u;
      *((_OWORD *)v16 + 20) = 0u;
      *((_OWORD *)v16 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
      *((_OWORD *)v16 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
      *((_OWORD *)v16 + 23) = 0u;
      *((_OWORD *)v16 + 24) = 0u;
      *((_OWORD *)v16 + 25) = 0u;
      if (Input) {
        HgcYUV420TriPlanar_2020ToRGB::HgcYUV420TriPlanar_2020ToRGB(v16);
      }
      HgcYUV420BiPlanar_2020ToRGB::HgcYUV420BiPlanar_2020ToRGB(v16);
    }
  }
  int v8 = *((_DWORD *)this + 105);
  if (v8 != 2)
  {
    if (!v8)
    {
      int v9 = (HgcYUV422TriPlanar_601ToRGB *)HGObject::operator new(0x1A0uLL);
      *(_OWORD *)int v9 = 0u;
      *((_OWORD *)v9 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
      *((_OWORD *)v9 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
      *((_OWORD *)v9 + 3) = 0u;
      *((_OWORD *)v9 + 4) = 0u;
      *((_OWORD *)v9 + 5) = 0u;
      *((_OWORD *)v9 + 6) = 0u;
      *((_OWORD *)v9 + 7) = 0u;
      *((_OWORD *)v9 + 8) = 0u;
      *((_OWORD *)v9 + 9) = 0u;
      *((_OWORD *)v9 + 10) = 0u;
      *((_OWORD *)v9 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
      *((_OWORD *)v9 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
      *((_OWORD *)v9 + 13) = 0u;
      *((_OWORD *)v9 + 14) = 0u;
      *((_OWORD *)v9 + 15) = 0u;
      *((_OWORD *)v9 + 16) = 0u;
      *((_OWORD *)v9 + 17) = 0u;
      *((_OWORD *)v9 + 18) = 0u;
      *((_OWORD *)v9 + 19) = 0u;
      *((_OWORD *)v9 + 20) = 0u;
      *((_OWORD *)v9 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
      *((_OWORD *)v9 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
      *((_OWORD *)v9 + 23) = 0u;
      *((_OWORD *)v9 + 24) = 0u;
      *((_OWORD *)v9 + 25) = 0u;
      if (Input) {
        HgcYUV422TriPlanar_601ToRGB::HgcYUV422TriPlanar_601ToRGB(v9);
      }
      HgcYUV422BiPlanar_601ToRGB::HgcYUV422BiPlanar_601ToRGB(v9);
    }
    float v15 = (HgcYUV422TriPlanar_709ToRGB *)HGObject::operator new(0x1A0uLL);
    *(_OWORD *)float v15 = 0u;
    *((_OWORD *)v15 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
    *((_OWORD *)v15 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
    *((_OWORD *)v15 + 3) = 0u;
    *((_OWORD *)v15 + 4) = 0u;
    *((_OWORD *)v15 + 5) = 0u;
    *((_OWORD *)v15 + 6) = 0u;
    *((_OWORD *)v15 + 7) = 0u;
    *((_OWORD *)v15 + 8) = 0u;
    *((_OWORD *)v15 + 9) = 0u;
    *((_OWORD *)v15 + 10) = 0u;
    *((_OWORD *)v15 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
    *((_OWORD *)v15 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
    *((_OWORD *)v15 + 13) = 0u;
    *((_OWORD *)v15 + 14) = 0u;
    *((_OWORD *)v15 + 15) = 0u;
    *((_OWORD *)v15 + 16) = 0u;
    *((_OWORD *)v15 + 17) = 0u;
    *((_OWORD *)v15 + 18) = 0u;
    *((_OWORD *)v15 + 19) = 0u;
    *((_OWORD *)v15 + 20) = 0u;
    *((_OWORD *)v15 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
    *((_OWORD *)v15 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
    *((_OWORD *)v15 + 23) = 0u;
    *((_OWORD *)v15 + 24) = 0u;
    *((_OWORD *)v15 + 25) = 0u;
    if (Input) {
      HgcYUV422TriPlanar_709ToRGB::HgcYUV422TriPlanar_709ToRGB(v15);
    }
    HgcYUV422BiPlanar_709ToRGB::HgcYUV422BiPlanar_709ToRGB(v15);
  }
  unsigned __int8 v14 = (HgcYUV422TriPlanar_2020ToRGB *)HGObject::operator new(0x1A0uLL);
  *(_OWORD *)unsigned __int8 v14 = 0u;
  *((_OWORD *)v14 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
  *((_OWORD *)v14 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
  *((_OWORD *)v14 + 3) = 0u;
  *((_OWORD *)v14 + 4) = 0u;
  *((_OWORD *)v14 + 5) = 0u;
  *((_OWORD *)v14 + 6) = 0u;
  *((_OWORD *)v14 + 7) = 0u;
  *((_OWORD *)v14 + 8) = 0u;
  *((_OWORD *)v14 + 9) = 0u;
  *((_OWORD *)v14 + 10) = 0u;
  *((_OWORD *)v14 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
  *((_OWORD *)v14 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
  *((_OWORD *)v14 + 13) = 0u;
  *((_OWORD *)v14 + 14) = 0u;
  *((_OWORD *)v14 + 15) = 0u;
  *((_OWORD *)v14 + 16) = 0u;
  *((_OWORD *)v14 + 17) = 0u;
  *((_OWORD *)v14 + 18) = 0u;
  *((_OWORD *)v14 + 19) = 0u;
  *((_OWORD *)v14 + 20) = 0u;
  *((_OWORD *)v14 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
  *((_OWORD *)v14 + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
  *((_OWORD *)v14 + 23) = 0u;
  *((_OWORD *)v14 + 24) = 0u;
  *((_OWORD *)v14 + 25) = 0u;
  if (Input) {
    HgcYUV422TriPlanar_2020ToRGB::HgcYUV422TriPlanar_2020ToRGB(v14);
  }
  HgcYUV422BiPlanar_2020ToRGB::HgcYUV422BiPlanar_2020ToRGB(v14);
}

void sub_1B76EF994(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EF9A8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EF9BC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EF9D0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EF9E4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EF9F8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EFA0C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EFA20(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EFA34(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EFA48(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EFA5C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EFA70(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EFA84(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EFA98(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EFAAC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EFAC0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EFAD4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76EFAE8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGYUVPlanarToRGBA::GetOutput(HGNode *this, HGRenderer *a2)
{
}

void sub_1B76EFC5C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGYUVPlanarToRGBA::SetParameter(HGYUVPlanarToRGBA *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2 == 2)
  {
    int v7 = a3 != 0.0;
    unsigned int v8 = a4;
    unsigned int v9 = a5;
    if (*((unsigned __int8 *)this + 432) == v7 && *((_DWORD *)this + 109) == v8 && *((_DWORD *)this + 107) == v9)
    {
      return 0;
    }
    else
    {
      *((unsigned char *)this + 43PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v7;
      *((_DWORD *)this + 109) = v8;
      *((_DWORD *)this + 107) = v9;
      return 1;
    }
  }
  else if (a2 == 1)
  {
    if (*((_DWORD *)this + 106) == a3)
    {
      return 0;
    }
    else
    {
      *((_DWORD *)this + 106) = a3;
      return 1;
    }
  }
  else if (a2)
  {
    return 0xFFFFFFFFLL;
  }
  else if (*((_DWORD *)this + 105) == a3)
  {
    return 0;
  }
  else
  {
    *((_DWORD *)this + 105) = a3;
    return 1;
  }
}

void HGYUV444ToPlanarLuma::HGYUV444ToPlanarLuma(HGNode *a1, int a2)
{
  HGNode::HGNode(a1);
  *(void *)uint64_t v3 = &unk_1F10C5AD8;
  *(void *)(v3 + 408) = 0;
  *(_DWORD *)(v3 + 416) = a2;
}

void HGYUV444ToPlanarLuma::~HGYUV444ToPlanarLuma(HGNode *this)
{
  *(void *)this = &unk_1F10C5AD8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10C5AD8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

void HGYUV444ToPlanarLuma::GetOutput(HGYUV444ToPlanarLuma *this, HGRenderer *a2)
{
  int v2 = *((_DWORD *)this + 104);
  if (v2 != 1)
  {
    if (!v2)
    {
      uint64_t v3 = (HgcYUV420BiPlanar_luma_pack4 *)HGObject::operator new(0x1A0uLL);
      HgcYUV420BiPlanar_luma_pack4::HgcYUV420BiPlanar_luma_pack4(v3);
    }
    int v5 = (HgcYUV420BiPlanar_luma *)HGObject::operator new(0x1A0uLL);
    HgcYUV420BiPlanar_luma::HgcYUV420BiPlanar_luma(v5);
  }
  uint64_t v4 = (HgcYUV420BiPlanar_luma_pack2 *)HGObject::operator new(0x1A0uLL);
  HgcYUV420BiPlanar_luma_pack2::HgcYUV420BiPlanar_luma_pack2(v4);
}

void sub_1B76F00C4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

void HGYUV444ToPlanarChroma::HGYUV444ToPlanarChroma(HGNode *a1, int a2, int a3)
{
  HGNode::HGNode(a1);
  *(void *)uint64_t v5 = &unk_1F10C5D28;
  *(void *)(v5 + 408) = 0;
  *(_DWORD *)(v5 + 416) = a3;
  *(_DWORD *)(v5 + 420) = a2;
}

void HGYUV444ToPlanarChroma::~HGYUV444ToPlanarChroma(HGNode *this)
{
  *(void *)this = &unk_1F10C5D28;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10C5D28;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

void HGYUV444ToPlanarChroma::GetOutput(HGYUV444ToPlanarChroma *this, HGRenderer *a2)
{
  int v2 = *((_DWORD *)this + 104);
  if (v2 != 1)
  {
    if (!v2)
    {
      int v3 = *((_DWORD *)this + 105);
      uint64_t v4 = (HgcYUV420BiPlanar_chroma *)HGObject::operator new(0x1A0uLL);
      if (v3) {
        HgcYUV420BiPlanar_chroma::HgcYUV420BiPlanar_chroma(v4);
      }
      HgcYUV420BiPlanar_chroma_pack2::HgcYUV420BiPlanar_chroma_pack2(v4);
    }
    if (*((_DWORD *)this + 105))
    {
      int v7 = (HgcYUV444BiPlanar_chroma *)HGObject::operator new(0x200uLL);
      HgcYUV444BiPlanar_chroma::HgcYUV444BiPlanar_chroma(v7);
    }
    unsigned int v8 = (HgcYUV444BiPlanar_chroma_pack2 *)HGObject::operator new(0x1A0uLL);
    HgcYUV444BiPlanar_chroma_pack2::HgcYUV444BiPlanar_chroma_pack2(v8);
  }
  int v5 = *((_DWORD *)this + 105);
  int v6 = (HgcYUV422BiPlanar_chroma *)HGObject::operator new(0x1A0uLL);
  if (v5) {
    HgcYUV422BiPlanar_chroma::HgcYUV422BiPlanar_chroma(v6);
  }
  HgcYUV422BiPlanar_chroma_pack2::HgcYUV422BiPlanar_chroma_pack2(v6);
}

void sub_1B76F0650(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

void PlanarToRGB<HgcYUV444TriPlanar_601ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV444TriPlanar_601ToRGB::~HgcYUV444TriPlanar_601ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV444TriPlanar_601ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV444TriPlanar_601ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV444BiPlanar_601ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV444BiPlanar_601ToRGB::~HgcYUV444BiPlanar_601ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV444BiPlanar_601ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV444BiPlanar_601ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV444TriPlanar_2020ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV444TriPlanar_2020ToRGB::~HgcYUV444TriPlanar_2020ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV444TriPlanar_2020ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV444TriPlanar_2020ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV444BiPlanar_2020ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV444BiPlanar_2020ToRGB::~HgcYUV444BiPlanar_2020ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV444BiPlanar_2020ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV444BiPlanar_2020ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV444TriPlanar_709ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV444TriPlanar_709ToRGB::~HgcYUV444TriPlanar_709ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV444TriPlanar_709ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV444TriPlanar_709ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV444BiPlanar_709ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV444BiPlanar_709ToRGB::~HgcYUV444BiPlanar_709ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV444BiPlanar_709ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV444BiPlanar_709ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV422TriPlanar_601ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV422TriPlanar_601ToRGB::~HgcYUV422TriPlanar_601ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV422TriPlanar_601ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV422TriPlanar_601ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV422BiPlanar_601ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV422BiPlanar_601ToRGB::~HgcYUV422BiPlanar_601ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV422BiPlanar_601ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV422BiPlanar_601ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV422TriPlanar_2020ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV422TriPlanar_2020ToRGB::~HgcYUV422TriPlanar_2020ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV422TriPlanar_2020ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV422TriPlanar_2020ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV422BiPlanar_2020ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV422BiPlanar_2020ToRGB::~HgcYUV422BiPlanar_2020ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV422BiPlanar_2020ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV422BiPlanar_2020ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV422TriPlanar_709ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV422TriPlanar_709ToRGB::~HgcYUV422TriPlanar_709ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV422TriPlanar_709ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV422TriPlanar_709ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV422BiPlanar_709ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV422BiPlanar_709ToRGB::~HgcYUV422BiPlanar_709ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV422BiPlanar_709ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV422BiPlanar_709ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV420TriPlanar_601ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV420TriPlanar_601ToRGB::~HgcYUV420TriPlanar_601ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV420TriPlanar_601ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV420TriPlanar_601ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV420BiPlanar_601ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV420BiPlanar_601ToRGB::~HgcYUV420BiPlanar_601ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV420BiPlanar_601ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV420BiPlanar_601ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV420TriPlanar_2020ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV420TriPlanar_2020ToRGB::~HgcYUV420TriPlanar_2020ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV420TriPlanar_2020ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV420TriPlanar_2020ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV420BiPlanar_2020ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV420BiPlanar_2020ToRGB::~HgcYUV420BiPlanar_2020ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV420BiPlanar_2020ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV420BiPlanar_2020ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV420TriPlanar_709ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV420TriPlanar_709ToRGB::~HgcYUV420TriPlanar_709ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV420TriPlanar_709ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV420TriPlanar_709ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void PlanarToRGB<HgcYUV420BiPlanar_709ToRGB>::~PlanarToRGB(HGNode *a1)
{
  HgcYUV420BiPlanar_709ToRGB::~HgcYUV420BiPlanar_709ToRGB(a1);

  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV420BiPlanar_709ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV420BiPlanar_709ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

const char *HGFormat_repr(unsigned int a1)
{
  if (a1 > 0x29) {
    return "unknown format";
  }
  else {
    return off_1E616BFB8[a1];
  }
}

HGObject *HGComicLookupFilterLUTBitmapResourceImplementation::HGComicLookupFilterLUTBitmapResourceImplementation(HGObject *a1, HGComicLookupFilterLUTBitmapResourceImplementation *a2)
{
  HGObject::HGObject(a1);
  *(void *)uint64_t v4 = &unk_1F10C8B10;
  *(_DWORD *)(v4 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a2;
  {
    __cxa_atexit(MEMORY[0x1E4FBA268], &HGComicLookupFilterLUTBitmapResourceImplementation::getInstanceMutex(void)::instanceMutex, &dword_1B73F3000);
  }
  std::mutex::lock(&HGComicLookupFilterLUTBitmapResourceImplementation::getInstanceMutex(void)::instanceMutex);
  HGComicLookupFilterLUTBitmapResourceImplementation::getCachedLUT(a2, &v20);
  if (v20)
  {
    (*(void (**)(HGComicLUT *))(*(void *)v20 + 24))(v20);
  }
  else
  {
    Rect = (HGComicLUT *)HGComicLUT::GetRect(0);
    uint64_t v7 = v6;
    uint64_t Format = HGComicLUT::GetFormat(Rect);
    Data = HGComicLUT::GetData((int)a2);
    int v10 = HGObject::operator new(0x80uLL);
    unsigned __int8 v11 = (HGComicLUT *)HGBitmap::HGBitmap(v10, Rect, v7, Format, Data);
    unsigned __int8 v12 = (HGComicLUT *)HGComicLUT::GetFormat(v11);
    if (v12 == 17)
    {
      uint64_t v13 = HGComicLUT::GetRect(v12);
      uint64_t v15 = v14;
      unsigned __int8 v16 = HGObject::operator new(0x80uLL);
      HGBitmap::HGBitmap(v16, v13, v15, 24);
      uint64_t v19 = v16;
      HGComicLookupFilterLUTBitmapResourceImplementation::cacheLUT((int)a2, (uint64_t *)&v19);
      if (v16) {
        (*(void (**)(void *))(*(void *)v16 + 24))(v16);
      }
      HGRenderUtils::BufferReformatter::BufferReformatter((HGRenderUtils::BufferReformatter *)v18);
    }
    if (v10) {
      (*(void (**)(void *))(*(void *)v10 + 24))(v10);
    }
  }
  std::mutex::unlock(&HGComicLookupFilterLUTBitmapResourceImplementation::getInstanceMutex(void)::instanceMutex);
  return a1;
}

void sub_1B76F1030(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  HGRenderUtils::BufferReformatter::~BufferReformatter((HGRenderUtils::BufferReformatter *)va);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  std::mutex::unlock(&HGComicLookupFilterLUTBitmapResourceImplementation::getInstanceMutex(void)::instanceMutex);
  HGObject::~HGObject(v2);
  _Unwind_Resume(a1);
}

void sub_1B76F1148(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGComicLookupFilterLUTBitmapResourceImplementation::getCachedLUT(HGComicLookupFilterLUTBitmapResourceImplementation *this@<X0>, void *a2@<X8>)
{
  int v2 = (int)this;
  {
    __cxa_atexit(MEMORY[0x1E4FBA268], &HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex, &dword_1B73F3000);
  }
  std::mutex::lock(&HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex);
  if (v2 > 5)
  {
    *a2 = 0;
  }
  else
  {
    {
      off_1E9E5EB80 = 0u;
      *(_OWORD *)&off_1E9E5EB90 = 0u;
      HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data = 0u;
      __cxa_atexit((void (*)(void *))__cxx_global_array_dtor, 0, &dword_1B73F3000);
    }
    uint64_t v4 = *((void *)&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data + v2);
    *a2 = v4;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
    }
  }
  std::mutex::unlock(&HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex);
}

void sub_1B76F12CC(_Unwind_Exception *a1)
{
}

void HGComicLookupFilterLUTBitmapResourceImplementation::cacheLUT(int a1, uint64_t *a2)
{
  {
    __cxa_atexit(MEMORY[0x1E4FBA268], &HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex, &dword_1B73F3000);
  }
  std::mutex::lock(&HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex);
  if (a1 <= 5)
  {
    {
      off_1E9E5EB80 = 0u;
      *(_OWORD *)&off_1E9E5EB90 = 0u;
      HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data = 0u;
      __cxa_atexit((void (*)(void *))__cxx_global_array_dtor, 0, &dword_1B73F3000);
    }
    uint64_t v4 = *((void *)&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data + a1);
    uint64_t v5 = *a2;
    if (v4 != *a2)
    {
      if (v4)
      {
        (*(void (**)(void))(*(void *)v4 + 24))(*((void *)&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data
                                                                + a1));
        uint64_t v5 = *a2;
      }
      *((void *)&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data + aPCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v5;
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
      }
    }
  }

  std::mutex::unlock(&HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex);
}

void sub_1B76F1464(_Unwind_Exception *a1)
{
}

void HGComicLookupFilterLUTBitmapResourceImplementation::~HGComicLookupFilterLUTBitmapResourceImplementation(HGComicLookupFilterLUTBitmapResourceImplementation *this)
{
  HGObject::~HGObject(this);

  HGObject::operator delete(v1);
}

uint64_t HGComicLookupFilterLUTBitmapResource::HGComicLookupFilterLUTBitmapResource(uint64_t a1, HGComicLookupFilterLUTBitmapResourceImplementation *a2)
{
  HGNode::HGNode((HGNode *)a1);
  *uint64_t v4 = &unk_1F10C8B48;
  v4[51] = 0;
  uint64_t v5 = (HGObject *)HGObject::operator new(0x10uLL);
  HGComicLookupFilterLUTBitmapResourceImplementation::HGComicLookupFilterLUTBitmapResourceImplementation(v5, a2);
  *(void *)(a1 + 416) = v5;
  return a1;
}

void sub_1B76F1514(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  uint64_t v4 = *(void *)(v1 + 408);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGComicLookupFilterLUTBitmapResource::~HGComicLookupFilterLUTBitmapResource(HGNode *this)
{
  *(void *)this = &unk_1F10C8B48;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 51);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10C8B48;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 51);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

HGBitmapLoader *HGComicLookupFilterLUTBitmapResource::GetOutput(HGComicLookupFilterLUTBitmapResource *this, HGRenderer *a2)
{
  HGComicLookupFilterLUTBitmapResourceImplementation::getCachedLUT((HGComicLookupFilterLUTBitmapResourceImplementation *)*(unsigned int *)(*((void *)this + 52) + 12), &v7);
  uint64_t v3 = v7;
  uint64_t v4 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v4, v3);
  if (v3) {
    (*(void (**)(HGBitmap *))(*(void *)v3 + 24))(v3);
  }
  uint64_t v5 = (HGBitmapLoader *)*((void *)this + 51);
  if (v5 == v4)
  {
    if (v4) {
      goto LABEL_9;
    }
  }
  else
  {
    if (v5) {
      (*(void (**)(HGBitmapLoader *))(*(void *)v5 + 24))(v5);
    }
    *((void *)this + 5PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v4;
    if (v4)
    {
      (*(void (**)(HGBitmapLoader *))(*(void *)v4 + 16))(v4);
LABEL_9:
      (*(void (**)(HGBitmapLoader *))(*(void *)v4 + 24))(v4);
    }
  }
  return v4;
}

void sub_1B76F17F4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t __cxx_global_array_dtor()
{
  if (off_1E9E5EB98) {
    (*(void (**)(void *))(*(void *)off_1E9E5EB98 + 24))(off_1E9E5EB98);
  }
  if (off_1E9E5EB90) {
    (*(void (**)(void *))(*(void *)off_1E9E5EB90 + 24))(off_1E9E5EB90);
  }
  if (*(&off_1E9E5EB80 + 1)) {
    (*(void (**)(void))(**(&off_1E9E5EB80 + 1) + 24))(*(&off_1E9E5EB80 + 1));
  }
  if (off_1E9E5EB80) {
    (*(void (**)(void))(*off_1E9E5EB80 + 24))(off_1E9E5EB80);
  }
  if (*(&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data + 1)) {
    (*(void (**)(void))(**(&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data + 1)
  }
                                   + 24))(*(&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data
                                            + 1));
  uint64_t result = HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data;
  if (HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data) {
    return (*(uint64_t (**)(void))(*HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data
  }
                                             + 24))(HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data);
  return result;
}

void HGCache::HGCache(HGCache *this)
{
  *(void *)this = &unk_1F10C8DC8;
  *((_DWORD *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 40), 0);
}

void HGCache::~HGCache(HGCache *this)
{
  *(void *)this = &unk_1F10C8DC8;
  uint64_t v1 = (void *)*((void *)this + 2);
  if (v1)
  {
    do
    {
      uint64_t v3 = v1[5];
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
      }
      uint64_t v2 = (void *)*v1;
      MEMORY[0x1BA9BFBA0](v1, 0x1020C40063BF169);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

{
  void *v1;
  void *v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10C8DC8;
  uint64_t v1 = (void *)*((void *)this + 2);
  if (v1)
  {
    do
    {
      uint64_t v3 = v1[5];
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
      }
      uint64_t v2 = (void *)*v1;
      MEMORY[0x1BA9BFBA0](v1, 0x1020C40063BF169);
      uint64_t v1 = v2;
    }
    while (v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void HGCinematic::HGCinematic(HGCinematic *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v2 = &unk_1F10C8DF8;
  *(_DWORD *)(v2 + 420) = 0;
  *(_WORD *)(v2 + 424) = 256;
  *(void *)(v2 + 440) = 0;
  *(void *)(v2 + 448) = 0;
  *(void *)(v2 + 43PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *(void *)(v2 + 464) = 0;
  *(void *)(v2 + 47PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(v2 + 16) & 0xFFFFF9FF | 0x400;
  atomic_store(0, (unsigned int *)(v2 + 456));
  HGNode::SetFlags((HGNode *)v2, 0, 2);
  (*(void (**)(HGCinematic *, uint64_t, uint64_t))(*(void *)this + 136))(this, 1, 2);
  (*(void (**)(HGCinematic *, uint64_t, uint64_t))(*(void *)this + 136))(this, 0xFFFFFFFFLL, 2);
  (*(void (**)(HGCinematic *, void, uint64_t))(*(void *)this + 136))(this, 0, 0x2000);
  (*(void (**)(HGCinematic *, uint64_t, uint64_t))(*(void *)this + 136))(this, 1, 0x2000);
  (*(void (**)(HGCinematic *, uint64_t, uint64_t))(*(void *)this + 136))(this, 0xFFFFFFFFLL, 128);
  (*(void (**)(HGCinematic *, uint64_t, uint64_t))(*(void *)this + 136))(this, 0xFFFFFFFFLL, 4);
  *((_DWORD *)this + 104) = 100;
}

void sub_1B76F1F58(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 455) < 0) {
    operator delete(*v2);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGCinematic::~HGCinematic(id *this)
{
  *this = &unk_1F10C8DF8;

  if (*((char *)this + 455) < 0)
  {
    operator delete(this[54]);
    uint64_t v2 = (HGNode *)this;
  }
  else
  {
    uint64_t v2 = (HGNode *)this;
  }
  HGNode::~HGNode(v2);
}

{
  void *v2;
  uint64_t vars8;

  *this = &unk_1F10C8DF8;

  if (*((char *)this + 455) < 0)
  {
    operator delete(this[54]);
    HGNode::~HGNode((HGNode *)this);
  }
  else
  {
    HGNode::~HGNode((HGNode *)this);
  }
  HGObject::operator delete(v2);
}

uint64_t HGCinematic::GetDOD(HGCinematic *this, HGRenderer *a2, uint64_t a3, HGRect a4)
{
  uint64_t v5 = (HGNode *)(*(uint64_t (**)(HGCinematic *, void, uint64_t, void, void))(*(void *)this + 128))(this, 0, a3, *(void *)&a4.var0, *(void *)&a4.var2);

  return HGRenderer::GetDOD(a2, v5);
}

uint64_t HGCinematic::GetROI(HGCinematic *this, HGRenderer *a2, uint64_t a3, HGRect a4)
{
  if (a3 > 1) {
    return *(void *)&a4.var0;
  }
  uint64_t v6 = (HGNode *)(*(uint64_t (**)(HGCinematic *, uint64_t))(*(void *)this + 128))(this, a3);
  return HGRenderer::GetDOD(a2, v6);
}

uint64_t HGCinematic::RenderPageMetal(HGNode *this, HGPage *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  HGPagePullMetalTexturesGuard::HGPagePullMetalTexturesGuard((HGPagePullMetalTexturesGuard *)&v26, this, a2);
  uint64_t v4 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)this + 48))(this);
  snprintf(__str, 0x100uLL, "%s::RenderPageMetal( [%d %d %d %d])", v4, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v25, "gpu", 1, __str);
  HGGPURenderer::GetMetalContext(*(HGGPURenderer **)a2);
  uint64_t v5 = *((void *)a2 + 1);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
    Buffer = (char *)*((void *)a2 + 1);
  }
  else
  {
    uint64_t v7 = *(void *)a2;
    uint64_t DOD = HGRenderer::GetDOD(*(HGRenderer **)a2, this);
    uint64_t v10 = v9;
    *(void *)&v29.var0 = DOD;
    *(void *)&v29.var2 = v10;
    Buffer = HGGPURenderer::CreateBuffer(v7, v29, *((unsigned int *)a2 + 8), 1, 1, 0);
    *((void *)a2 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = Buffer;
  }
  unsigned __int8 v11 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, (HGBitmap *)Buffer);
  uint64_t v12 = *(void *)((char *)a2 + 36);
  uint64_t v13 = *(void *)((char *)a2 + 44);
  uint64_t v14 = *(void *)((char *)a2 + 52);
  uint64_t v15 = *(void *)((char *)a2 + 60);
  Input = HGRenderer::GetInput(*(HGRenderer **)a2, this, 0);
  float v17 = HGRenderer::GetInput(*(HGRenderer **)a2, this, 1u);
  *(void *)&v30.var0 = v12;
  *(void *)&v30.var2 = v13;
  NodeMetalTexture = HGGPURenderer::GetNodeMetalTexture(*(HGGPURenderer **)a2, Input, v30, 0, 0);
  int v24 = NodeMetalTexture;
  *(void *)&v31.var0 = v14;
  *(void *)&v31.var2 = v15;
  uint64_t v19 = HGGPURenderer::GetNodeMetalTexture(*(HGGPURenderer **)a2, v17, v31, 0, 0);
  unsigned __int8 v20 = v19;
  unsigned __int8 v23 = v19;
  if (NodeMetalTexture)
  {
    if (v19)
    {
      HGGPURenderer::FlushMetalCommandBuffer(*(HGGPURenderer **)a2);
      if (*((void *)NodeMetalTexture + 18))
      {
        if (*((void *)v20 + 18))
        {
          v22[0] = 0;
          v22[1] = v22;
          int8x16_t v22[2] = 0x2020000000;
          v22[3] = 0;
          operator new();
        }
      }
    }
  }
  (*(void (**)(HGBitmap *))(*(void *)v11 + 24))(v11);
  if (v23) {
    (*(void (**)(HGBitmap *))(*(void *)v23 + 24))(v23);
  }
  if (v24) {
    (*(void (**)(HGBitmap *))(*(void *)v24 + 24))(v24);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v25);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(&v26);
  return *((void *)a2 + 1);
}

void sub_1B76F25E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,HGPage *a30)
{
  *(void *)(v31 + 8) = v30;
  _Block_object_dispose(&a22, 8);
  if (a26) {
    (*(void (**)(uint64_t))(*(void *)a26 + 24))(a26);
  }
  if (a27) {
    (*(void (**)(uint64_t))(*(void *)a27 + 24))(a27);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a28);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(&a30);
  _Unwind_Resume(a1);
}

void sub_1B76F26E4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t ___ZN11HGCinematic15RenderPageMetalEP6HGPage_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void ***)(*(void *)(*(void *)(result + 32) + 8) + 24);
  if (v1)
  {
    uint64_t v2 = (char *)*v1;
    if (*v1)
    {
      uint64_t v3 = (char *)v1[1];
      uint64_t v4 = *v1;
      if (v3 != v2)
      {
        do
        {
          uint64_t v6 = *((void *)v3 - 1);
          v3 -= 8;
          uint64_t v5 = v6;
          if (v6) {
            (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
          }
        }
        while (v3 != v2);
        uint64_t v4 = *v1;
      }
      v1[1] = v2;
      operator delete(v4);
    }
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

uint64_t HGCinematic::setAperture(uint64_t this, float a2)
{
  *(float *)(this + 408) = a2;
  return this;
}

uint64_t HGCinematic::setFocusDistance(uint64_t this, float a2)
{
  *(float *)(this + 41PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a2;
  return this;
}

uint64_t HGCinematic::setRenderDisparity(uint64_t this)
{
  *(unsigned char *)(this + 424) = 1;
  *(_DWORD *)(this + 420) = 2;
  return this;
}

void ___ZN11HGCinematic26prepCachePipelinesAndLocksEv_block_invoke()
{
}

void HGCinematic::performPortraitWithDevice(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (HGCinematic::prepCachePipelinesAndLocks(void)::onceToken != -1) {
    dispatch_once(&HGCinematic::prepCachePipelinesAndLocks(void)::onceToken, &__block_literal_global_60);
  }
  uint64_t v14 = (std::mutex *)HGCinematic::_cachePipelinesLock;
  std::mutex::lock((std::mutex *)HGCinematic::_cachePipelinesLock);
  Pipeline = HGCinematic::getPipeline(a1, a2, a4, a5);
  context = (void *)MEMORY[0x1BA9C0A20]();
  unsigned __int8 v16 = (void *)[a3 commandBuffer];
  if (*(unsigned char *)(a1 + 424) && *(unsigned char *)(a1 + 425))
  {
    float v17 = (void *)[Pipeline[2] upscaleDisparity:a5 inRGBA:a4 commandBuffer:v16];
    unsigned __int8 v18 = v17;
    if (v17)
    {
      uint64_t v19 = [v17 pixelFormat];
      uint64_t v20 = [a6 pixelFormat];
      if (v19 != v20)
      {
        unsigned __int8 v21 = objc_msgSend(MEMORY[0x1E4F35330], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", v20, objc_msgSend(v18, "width"), objc_msgSend(v18, "height"), 0);
        [v21 setUsage:3];
        unsigned __int8 v22 = (void *)[a2 newTextureWithDescriptor:v21];
        unsigned __int8 v23 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC78]);
        int v24 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC58]);
        CGColorConversionInfoRef v25 = CGColorConversionInfoCreate(v23, v24);
        memset(v36, 0, sizeof(v36));
        uint64_t v26 = (void *)[objc_alloc(MEMORY[0x1E4F35558]) initWithDevice:a2 srcAlpha:1 destAlpha:1 backgroundColor:v36 conversionInfo:v25];
        [v26 encodeToCommandBuffer:v16 sourceTexture:v18 destinationTexture:v22];

        CFRelease(v25);
        CGColorSpaceRelease(v23);
        CGColorSpaceRelease(v24);
        uint64_t v27 = [v18 width];
        if (v27 == [a6 width])
        {
          [v18 height];
          [a6 height];
        }
        uint64_t v28 = (void *)[objc_alloc(MEMORY[0x1E4F35548]) initWithDevice:a2];
        [v28 encodeToCommandBuffer:v16 sourceTexture:v22 destinationTexture:a6];
        [v16 addCompletedHandler:&__block_literal_global_24_0];
        [v16 commit];
      }
    }
    goto LABEL_26;
  }
  HGRect v29 = objc_opt_new();
  [v29 setRenderState:Pipeline[3]];
  objc_msgSend(v29, "setSourceColor:", objc_msgSend(MEMORY[0x1E4F92278], "createRGBA:", a4));
  objc_msgSend(v29, "setDestinationColor:", objc_msgSend(MEMORY[0x1E4F92278], "createRGBA:", a6));
  uint64_t v30 = (void *)(a1 + 432);
  if (*(char *)(a1 + 455) < 0)
  {
    if (!*(void *)(a1 + 440)) {
      goto LABEL_16;
    }
    uint64_t v30 = (void *)*v30;
    goto LABEL_15;
  }
  if (*(unsigned char *)(a1 + 455)) {
LABEL_15:
  }
    objc_msgSend((id)objc_msgSend(v29, "sourceColor"), "setTransferFunction:", objc_msgSend(NSString, "stringWithCString:encoding:", v30, objc_msgSend(NSString, "defaultCStringEncoding")));
LABEL_16:
  [v29 setSourceDisparity:a5];
  objc_msgSend((id)objc_msgSend(v29, "destinationColor"), "setTransferFunction:", objc_msgSend((id)objc_msgSend(v29, "sourceColor"), "transferFunction"));
  if (*(void *)(a1 + 472) && (objc_opt_respondsToSelector() & 1) != 0) {
    [*(id *)(a1 + 472) applyToRenderRequest:v29];
  }
  int v32 = *(void **)(a1 + 464);
  if (v32) {
    [v32 applyToRenderRequest:v29];
  }
  LODWORD(v3PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(_DWORD *)(a1 + 408);
  [v29 setAperture:v31];
  LODWORD(v33) = *(_DWORD *)(a1 + 412);
  [v29 setFocusDistance:v33];
  int v34 = [Pipeline[1] encodeRenderTo:v16 withRenderRequest:v29];

  if (v34) {
    NSLog(&cfstr_Error.isa, [MEMORY[0x1E4F28C58] errorWithDomain:*MEMORY[0x1E4F28760] code:v34 userInfo:0]);
  }
  if (a7) {
    [v16 addCompletedHandler:a7];
  }
  [v16 commit];
  [v16 waitUntilScheduled];
LABEL_26:
  std::mutex::unlock(v14);
}

void sub_1B76F2C9C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2CB0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2CC4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2CD8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2CEC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2D00(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2D14(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2D28(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2D3C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2D50(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2D64(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2D78(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2D8C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2DA0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2DB4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F2DC8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void **HGCinematic::getPipeline(uint64_t a1, void *a2, void *a3, void *a4)
{
  double v8 = (double)(unint64_t)[a3 width];
  double v9 = (double)(unint64_t)[a3 height];
  double v10 = (double)(unint64_t)[a4 width];
  double v11 = (double)(unint64_t)[a4 height];
  uint64_t v12 = (void *)HGCinematic::_cachePipelines;
  uint64_t v13 = *(void *)(HGCinematic::_cachePipelines + 8);
  if (*(void *)(HGCinematic::_cachePipelines + 16) == v13
    || (unint64_t v14 = *(void *)(HGCinematic::_cachePipelines + 32),
        uint64_t v15 = (void *)(v13 + 8 * (v14 >> 9)),
        unsigned __int8 v16 = (void ***)(*v15 + 8 * (v14 & 0x1FF)),
        uint64_t v17 = *(void *)(v13 + (((*(void *)(HGCinematic::_cachePipelines + 40) + v14) >> 6) & 0x3FFFFFFFFFFFFF8))
            + 8 * ((*(void *)(HGCinematic::_cachePipelines + 40) + v14) & 0x1FF),
        v16 == (void ***)v17))
  {
    if (*(void *)(HGCinematic::_cachePipelines + 40) == 1) {
      goto LABEL_22;
    }
    goto LABEL_30;
  }
  while (1)
  {
    unsigned __int8 v18 = **v16;
    uint64_t v19 = objc_msgSend((id)objc_msgSend(v18, "device"), "registryID");
    if (v19 == [a2 registryID])
    {
      [v18 colorInputSize];
      if (v21 == v8 && v20 == v9)
      {
        [v18 disparitySize];
        if (v24 == v10 && v23 == v11 && [v18 debugRendering] == *(_DWORD *)(a1 + 420))
        {
          uint64_t result = *v16;
          if (*((_DWORD *)*v16 + 8) == *(_DWORD *)(a1 + 416)) {
            break;
          }
        }
      }
    }
    if ((void ***)((char *)++v16 - *v15) == (void ***)4096)
    {
      uint64_t v27 = (void ***)v15[1];
      ++v15;
      unsigned __int8 v16 = v27;
    }
    if (v16 == (void ***)v17)
    {
      uint64_t v12 = (void *)HGCinematic::_cachePipelines;
      if (*(void *)(HGCinematic::_cachePipelines + 40) == 1)
      {
LABEL_22:
        unint64_t v28 = v12[4];
        uint64_t v29 = v12[1];
        uint64_t v30 = *(id **)(*(void *)(v29 + ((v28 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v28 & 0x1FF));
        if (v30)
        {

          *(_OWORD *)uint64_t v30 = 0u;
          *((_OWORD *)v30 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
          MEMORY[0x1BA9BFBA0](v30, 0x1080C406D05D2F5);
          uint64_t v12 = (void *)HGCinematic::_cachePipelines;
          unint64_t v28 = *(void *)(HGCinematic::_cachePipelines + 32);
          uint64_t v31 = *(void *)(HGCinematic::_cachePipelines + 40);
          uint64_t v29 = *(void *)(HGCinematic::_cachePipelines + 8);
        }
        else
        {
          uint64_t v31 = 1;
        }
        uint64_t v32 = v12[2];
        if (v32 == v29) {
          uint64_t v33 = 0;
        }
        else {
          uint64_t v33 = ((v32 - v29) << 6) - 1;
        }
        v12[5] = v31 - 1;
        if (v33 - (v31 + v28) + 1 >= 0x400)
        {
          operator delete(*(void **)(v32 - 8));
          v12[2] -= 8;
        }
      }
LABEL_30:
      id v34 = objc_alloc(MEMORY[0x1E4F92240]);
      int v35 = objc_msgSend(v34, "initWithDevice:version:colorSize:disparitySize:", a2, objc_msgSend(MEMORY[0x1E4F92238], "latestVersion"), v8, v9, v10, v11);
      [v35 setDebugRendering:*(int *)(a1 + 420)];
      [v35 setUseRGBA:1];
      operator new();
    }
  }
  return result;
}

uint64_t HGCinematic::setDisplayMode(uint64_t this, int a2)
{
  if (a2 != 4)
  {
    if (a2 == 1) {
      int v2 = 2;
    }
    else {
      int v2 = 0;
    }
    if (a2 == 3) {
      int v3 = 4;
    }
    else {
      int v3 = v2;
    }
    *(_DWORD *)(this + 420) = v3;
  }
  return this;
}

uint64_t HGCinematic::RenderTile(atomic_uint *this, HGTile *a2)
{
  if (!atomic_fetch_add(this + 114, 1u))
  {
    int v3 = (HGNode *)this;
    context = (void *)MEMORY[0x1BA9C0A20]();
    int v36 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:2];
    id v38 = MTLCreateSystemDefaultDevice();
    uint64_t v33 = [v38 newCommandQueue];
    uint64_t v4 = (HGRenderer *)HGTile::Renderer(a2);
    Input = HGRenderer::GetInput(v4, v3, 0);
    if (Input)
    {
      uint64_t v6 = Input;
      uint64_t v37 = 0;
      unsigned int v7 = 0;
      int v8 = 1;
      do
      {
        unint64_t ROI = HGRenderer::GetROI(v4, v6);
        unint64_t v11 = v10;
        uint64_t v12 = a2;
        uint64_t v13 = v3;
        HGRenderer::RenderInput((uint64_t)v4, *((void *)a2 + 42), (uint64_t)v3, v7, (uint64_t)&v41, ROI, v10, 0);
        if (v8) {
          uint64_t v14 = 28;
        }
        else {
          uint64_t v14 = 7;
        }
        uint64_t v15 = 16 * v42;
        unsigned __int8 v16 = HGObject::operator new(0x80uLL);
        HGBitmap::HGBitmap(v16, ROI, v11, v14, v41, v15);
        id v17 = objc_alloc_init(MEMORY[0x1E4F35330]);
        unsigned __int8 v18 = v17;
        if (v8) {
          uint64_t v19 = 125;
        }
        else {
          uint64_t v19 = 55;
        }
        objc_msgSend(v17, "setPixelFormat:", v19, v33, context);
        [v18 setWidth:(int)v11 - (int)ROI];
        [v18 setHeight:(uint64_t)(v11 - (ROI & 0xFFFFFFFF00000000)) >> 32];
        double v20 = (void *)[v38 newTextureWithDescriptor:v18];
        int v3 = v13;
        uint64_t v21 = [v18 width];
        uint64_t v22 = [v18 height];
        memset(v40, 0, 24);
        _OWORD v40[3] = v21;
        void v40[4] = v22;
        v40[5] = 1;
        [v20 replaceRegion:v40 mipmapLevel:0 withBytes:v16[10] bytesPerRow:v16[8]];
        if (!v37)
        {
          [v18 setUsage:2];
          uint64_t v37 = (void *)[v38 newTextureWithDescriptor:v18];
        }

        [v36 addObject:v20];
        (*(void (**)(void *))(*v16 + 24))(v16);
        double v23 = HGRenderer::GetInput(v4, v13, v7 + 1);
        a2 = v12;
        if (v7 > 6) {
          break;
        }
        uint64_t v6 = v23;
        --v8;
        ++v7;
      }
      while (v23);
    }
    else
    {
      uint64_t v37 = 0;
    }
    uint64_t v24 = objc_msgSend(v36, "objectAtIndex:", 0, v33);
    uint64_t v25 = (*(uint64_t (**)(HGNode *, id, void *, uint64_t, uint64_t, void *, void))(*(void *)v3 + 576))(v3, v38, v34, v24, [v36 objectAtIndex:1], v37, 0);
    uint64_t v26 = (void *)MEMORY[0x1BA9C0A20](v25);
    uint64_t v27 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v28 = (*((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1));
    uint64_t v29 = (void *)[v34 commandBuffer];
    objc_msgSend((id)objc_msgSend(v29, "blitCommandEncoder"), "endEncoding");
    [v29 commit];
    [v29 waitUntilCompleted];
    uint64_t v30 = *((void *)a2 + 2);
    uint64_t v31 = 16 * *((int *)a2 + 6);
    memset(v39, 0, 24);
    _OWORD v39[3] = v27;
    v39[4] = v28;
    v39[5] = 1;
    [v37 getBytes:v30 bytesPerRow:v31 fromRegion:v39 mipmapLevel:0];
  }
  return 0;
}

void sub_1B76F3530(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F3548(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

PTGlobalRenderingMetadata *HGCinematic::SetGlobalRenderingMetadata(PTGlobalRenderingMetadata *this, PTGlobalRenderingMetadata *a2)
{
  int v2 = (PTGlobalRenderingMetadata *)*((void *)this + 58);
  if (v2 != a2)
  {
    uint64_t v4 = this;

    this = a2;
    *((void *)v4 + 58) = this;
  }
  return this;
}

void *HGCinematic::SetTimedRenderingMetadata(void *result, void *a2)
{
  int v2 = (void *)result[59];
  if (v2 != a2)
  {
    uint64_t v4 = result;

    uint64_t result = a2;
    v4[59] = result;
  }
  return result;
}

void HGCinematic::ClearCachePipelines(HGCinematic *this)
{
  if (HGCinematic::prepCachePipelinesAndLocks(void)::onceToken != -1) {
    dispatch_once(&HGCinematic::prepCachePipelinesAndLocks(void)::onceToken, &__block_literal_global_60);
  }
  uint64_t v1 = (std::mutex *)HGCinematic::_cachePipelinesLock;
  std::mutex::lock((std::mutex *)HGCinematic::_cachePipelinesLock);
  uint64_t v2 = HGCinematic::_cachePipelines;
  uint64_t v3 = *(void *)(HGCinematic::_cachePipelines + 8);
  uint64_t v4 = (char *)(v3 + 8 * (*(void *)(HGCinematic::_cachePipelines + 32) >> 9));
  if (*(void *)(HGCinematic::_cachePipelines + 16) == v3)
  {
    uint64_t v5 = 0;
    goto LABEL_8;
  }
  uint64_t v5 = (char *)(*(void *)v4 + 8 * (*(void *)(HGCinematic::_cachePipelines + 32) & 0x1FFLL));
  while (1)
  {
    unint64_t v6 = *(void *)(v2 + 40) + *(void *)(v2 + 32);
    if (v5 == (char *)(*(void *)(v3 + ((v6 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v6 & 0x1FF))) {
      break;
    }
    while (1)
    {
      unsigned int v7 = *(id **)v5;

      *(_OWORD *)unsigned int v7 = 0u;
      *((_OWORD *)v7 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0u;
      uint64_t v4 = (char *)std::deque<Pipeline *>::erase((int64x2_t *)HGCinematic::_cachePipelines, v4, v5);
      uint64_t v5 = v8;
      uint64_t v2 = HGCinematic::_cachePipelines;
      uint64_t v3 = *(void *)(HGCinematic::_cachePipelines + 8);
      if (*(void *)(HGCinematic::_cachePipelines + 16) != v3) {
        break;
      }
LABEL_8:
      if (!v5) {
        goto LABEL_11;
      }
    }
  }
LABEL_11:

  std::mutex::unlock(v1);
}

void sub_1B76F374C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F3760(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void **std::deque<Pipeline *>::erase(int64x2_t *a1, char *a2, char *a3)
{
  unint64_t v6 = a1[2].u64[0];
  uint64_t v7 = a1->i64[1];
  uint64_t v8 = a1[1].i64[0];
  double v9 = (const void **)(v7 + 8 * (v6 >> 9));
  if (v8 != v7)
  {
    unint64_t v10 = (char *)*v9 + 8 * (a1[2].i64[0] & 0x1FF);
    if (a3 != v10) {
      goto LABEL_3;
    }
LABEL_7:
    unint64_t v14 = 0;
    uint64_t v12 = *v9;
    goto LABEL_8;
  }
  unint64_t v10 = 0;
  if (!a3) {
    goto LABEL_7;
  }
LABEL_3:
  uint64_t v11 = ((uint64_t)&a3[-*(void *)a2] >> 3) + ((a2 - (char *)v9) << 6);
  uint64_t v12 = *v9;
  uint64_t v13 = v10 - (unsigned char *)*v9;
  unint64_t v14 = v11 - (v13 >> 3);
  if (v11 != v13 >> 3)
  {
    if (v11 < 1)
    {
      unint64_t v23 = 511 - v11;
      LOWORD(v1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = ~(511 - v11);
      uint64_t v15 = &v9[-(v23 >> 9)];
    }
    else
    {
      uint64_t v15 = &v9[(unint64_t)v11 >> 9];
    }
    uint64_t v24 = *v15;
    id v17 = (const void **)((char *)*v15 + 8 * (v11 & 0x1FF));
    uint64_t v25 = a1[2].i64[1];
    if (v14 > (unint64_t)(v25 - 1) >> 1)
    {
      uint64_t v26 = (char *)v17 - v24;
      uint64_t v27 = ((char *)v17 - v24) >> 3;
      if (v26 < -7)
      {
        unint64_t v42 = 510 - v27;
        uint64_t v29 = &v15[-(v42 >> 9)];
        uint64_t v30 = (char *)*v29 + 8 * (~(_WORD)v42 & 0x1FF);
        __int16 v31 = v25 + v6;
        uint64_t v32 = (const void **)(v7 + 8 * ((v25 + v6) >> 9));
        if (v8 != v7) {
          goto LABEL_14;
        }
      }
      else
      {
        unint64_t v28 = v27 + 1;
        uint64_t v29 = &v15[v28 >> 9];
        uint64_t v30 = (char *)*v29 + 8 * (v28 & 0x1FF);
        __int16 v31 = v25 + v6;
        uint64_t v32 = (const void **)(v7 + 8 * ((v25 + v6) >> 9));
        if (v8 != v7)
        {
LABEL_14:
          uint64_t v33 = (char *)*v32 + 8 * (v31 & 0x1FF);
LABEL_28:
          v46[0] = v15;
          v46[1] = v17;
          std::__for_each_segment[abi:ne180100]<std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>>>(v29, v30, v32, v33, (uint64_t)v46);
          id v38 = (void **)a1->i64[1];
          unsigned __int8 v43 = (void **)a1[1].i64[0];
          unint64_t v37 = a1[2].u64[0];
          uint64_t v44 = a1[2].i64[1];
          a1[2].i64[1] = v44 - 1;
          uint64_t v45 = (((char *)v43 - (char *)v38) << 6) - 1;
          if (v43 == v38) {
            uint64_t v45 = 0;
          }
          if (v45 - (v44 + v37) + 1 >= 0x400)
          {
            operator delete(*(v43 - 1));
            char v16 = 0;
            id v38 = (void **)a1->i64[1];
            a1[1].i64[0] -= 8;
            unint64_t v37 = a1[2].u64[0];
          }
          else
          {
            char v16 = 0;
          }
          goto LABEL_19;
        }
      }
      uint64_t v33 = 0;
      goto LABEL_28;
    }
    char v16 = 0;
    uint64_t v34 = (char *)v17 - v24;
    uint64_t v19 = ((char *)v17 - v24) >> 3;
    if (v34 < -7) {
      goto LABEL_16;
    }
LABEL_9:
    unint64_t v20 = v19 + 1;
    uint64_t v21 = &v15[v20 >> 9];
    uint64_t v22 = (char *)*v21 + 8 * (v20 & 0x1FF);
    goto LABEL_17;
  }
LABEL_8:
  char v16 = 1;
  uint64_t v15 = (const void **)(v7 + 8 * (v6 >> 9));
  id v17 = (const void **)v10;
  uint64_t v18 = v10 - v12;
  uint64_t v19 = (v10 - v12) >> 3;
  if (v18 >= -7) {
    goto LABEL_9;
  }
LABEL_16:
  unint64_t v35 = 510 - v19;
  uint64_t v21 = &v15[-(v35 >> 9)];
  uint64_t v22 = (char *)*v21 + 8 * (~(_WORD)v35 & 0x1FF);
LABEL_17:
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,0>(v9, v10, v15, (char *)v17, v21, v22, v46);
  int64x2_t v36 = vaddq_s64(a1[2], (int64x2_t)xmmword_1B7E73580);
  a1[2] = v36;
  unint64_t v37 = v36.i64[0];
  id v38 = (void **)a1->i64[1];
  if (v36.i64[0] >= 0x400uLL)
  {
    operator delete(*v38);
    id v38 = (void **)(a1->i64[1] + 8);
    a1->i64[1] = (uint64_t)v38;
    unint64_t v37 = a1[2].i64[0] - 512;
    a1[2].i64[0] = v37;
  }
LABEL_19:
  uint64_t result = &v38[v37 >> 9];
  if ((void **)a1[1].i64[0] == v38)
  {
    uint64_t v40 = 0;
    if (v16) {
      return result;
    }
  }
  else
  {
    uint64_t v40 = (uint64_t)*result + 8 * (v37 & 0x1FF);
    if (v16) {
      return result;
    }
  }
  uint64_t v41 = v14 + ((v40 - (uint64_t)*result) >> 3);
  if (v41 < 1) {
    result -= (unint64_t)(511 - v41) >> 9;
  }
  else {
    result += (unint64_t)v41 >> 9;
  }
  return result;
}

uint64_t HGCinematic::SetRenderQuality(uint64_t this, int a2)
{
  *(_DWORD *)(this + 416) = a2;
  return this;
}

char *std::vector<HGRef<HGMetalTexture>>::__push_back_slow_path<HGRef<HGMetalTexture> const&>(char **a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v5 = (v4 - *a1) >> 3;
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 2 > v6) {
    unint64_t v6 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v6;
  }
  if (v9)
  {
    if (v9 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unint64_t v10 = (char *)operator new(8 * v9);
  }
  else
  {
    unint64_t v10 = 0;
  }
  uint64_t v11 = &v10[8 * v5];
  uint64_t v12 = &v10[8 * v9];
  uint64_t v13 = *a2;
  *(void *)uint64_t v11 = *a2;
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 16))(v13);
    uint64_t v3 = *a1;
    uint64_t v4 = a1[1];
  }
  unint64_t v14 = v11 + 8;
  uint64_t v21 = v11 + 8;
  if (v4 == v3)
  {
    id v17 = v3;
  }
  else
  {
    uint64_t v15 = 0;
    do
    {
      uint64_t v16 = *(void *)&v4[v15 - 8];
      *(void *)&v11[v15 - 8] = v16;
      if (v16) {
        (*(void (**)(uint64_t))(*(void *)v16 + 16))(v16);
      }
      v15 -= 8;
    }
    while (&v4[v15] != v3);
    id v17 = *a1;
    uint64_t v3 = a1[1];
    v11 += v15;
    unint64_t v14 = v21;
  }
  *a1 = v11;
  a1[1] = v14;
  a1[2] = v12;
  if (v3 == v17)
  {
    if (v3) {
LABEL_22:
    }
      operator delete(v3);
  }
  else
  {
    do
    {
      uint64_t v20 = *((void *)v3 - 1);
      v3 -= 8;
      uint64_t v19 = v20;
      if (v20) {
        (*(void (**)(uint64_t))(*(void *)v19 + 24))(v19);
      }
    }
    while (v3 != v17);
    uint64_t v3 = v17;
    if (v17) {
      goto LABEL_22;
    }
  }
  return v14;
}

void sub_1B76F3C7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<HGRef<HGMetalTexture>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B76F3C94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  for (; v2; v2 += 8)
  {
    uint64_t v5 = *(void *)(v3 + v2);
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    }
  }
  std::__split_buffer<HGRef<HGMetalTexture>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<HGRef<HGMetalTexture>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v5 = *(void *)(v2 - 8);
    v2 -= 8;
    uint64_t v4 = v5;
    *(void *)(a1 + 16) = v2;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::deque<Pipeline *>::__add_front_capacity(uint64_t a1)
{
  uint64_t v3 = *(char **)(a1 + 8);
  uint64_t v2 = *(char **)(a1 + 16);
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = ((v2 - v3) << 6) - 1;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if ((unint64_t)(v4 - (*(void *)(a1 + 40) + v5)) >= 0x200)
  {
    *(void *)(a1 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v5 + 512;
    unsigned __int8 v47 = (void *)*((void *)v2 - 1);
    *(void *)(a1 + 16) = v2 - 8;
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
    return;
  }
  unint64_t v6 = *(char **)(a1 + 24);
  uint64_t v7 = *(char **)a1;
  uint64_t v8 = (uint64_t)&v6[-*(void *)a1];
  if (v2 - v3 < (unint64_t)v8)
  {
    if (v3 == v7)
    {
      unsigned __int8 v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v47);
      uint64_t v17 = *(void *)(a1 + 16);
      unsigned __int8 v47 = *(void **)(v17 - 8);
      *(void *)(a1 + 16) = v17 - 8;
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8) {
        goto LABEL_9;
      }
    }
    else
    {
      unsigned __int8 v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8)
      {
LABEL_9:
        uint64_t v9 = 256;
LABEL_19:
        *(void *)(a1 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v9;
        return;
      }
    }
    uint64_t v9 = *(void *)(a1 + 32) + 512;
    goto LABEL_19;
  }
  if (v6 == v7) {
    unint64_t v10 = 1;
  }
  else {
    unint64_t v10 = v8 >> 2;
  }
  if (v10 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v11 = (char *)operator new(8 * v10);
  uint64_t v12 = operator new(0x1000uLL);
  uint64_t v13 = v12;
  if (v10)
  {
    unint64_t v14 = &v11[8 * v10];
    *(void *)uint64_t v11 = v12;
    uint64_t v15 = v11 + 8;
    uint64_t v16 = v11;
    if (v3 != v2) {
      goto LABEL_29;
    }
    goto LABEL_21;
  }
  uint64_t v18 = (char *)operator new(8uLL);
  unint64_t v14 = v18 + 8;
  operator delete(v11);
  uint64_t v3 = *(char **)(a1 + 8);
  uint64_t v19 = *(char **)(a1 + 16);
  uint64_t v11 = v18;
  *(void *)uint64_t v18 = v13;
  uint64_t v15 = v18 + 8;
  uint64_t v16 = v18;
  if (v3 != v19)
  {
    while (1)
    {
LABEL_29:
      if (v15 == v14)
      {
        if (v11 <= v16)
        {
          if (v15 == v16) {
            unint64_t v31 = 1;
          }
          else {
            unint64_t v31 = (v15 - v16) >> 2;
          }
          if (v31 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v32 = (char *)operator new(8 * v31);
          uint64_t v33 = v32;
          unint64_t v34 = v31 >> 2;
          uint64_t v20 = &v32[8 * (v31 >> 2)];
          unint64_t v23 = v20;
          int64_t v35 = v15 - v11;
          if (v15 != v11)
          {
            unint64_t v23 = &v20[v35 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v36 = v35 - 8;
            if (v36 < 0x38 || (uint64_t v37 = 8 * v34, (unint64_t)(&v32[8 * v34] - v11) < 0x20))
            {
              id v38 = &v32[8 * (v31 >> 2)];
              uint64_t v39 = v11;
              goto LABEL_45;
            }
            uint64_t v41 = (v36 >> 3) + 1;
            uint64_t v42 = 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
            id v38 = &v20[v42];
            uint64_t v39 = &v11[v42];
            unsigned __int8 v43 = (long long *)(v11 + 16);
            uint64_t v44 = &v32[v37 + 16];
            uint64_t v45 = v41 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v46 = *v43;
              *((_OWORD *)v44 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(v43 - 1);
              *(_OWORD *)uint64_t v44 = v46;
              v43 += 2;
              v44 += 32;
              v45 -= 4;
            }
            while (v45);
            if (v41 != (v41 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_45:
                uint64_t v40 = *(void *)v39;
                v39 += 8;
                *(void *)id v38 = v40;
                v38 += 8;
              }
              while (v38 != v23);
            }
          }
          uint64_t v15 = &v32[8 * v31];
          if (v16) {
            operator delete(v16);
          }
          uint64_t v16 = v33;
          goto LABEL_28;
        }
        uint64_t v25 = (v11 - v16) >> 3;
        if (v25 >= -1) {
          uint64_t v26 = v25 + 1;
        }
        else {
          uint64_t v26 = v25 + 2;
        }
        uint64_t v27 = v26 >> 1;
        unint64_t v28 = &v11[-8 * (v26 >> 1)];
        uint64_t v29 = v15;
        if (v15 != v11)
        {
          memmove(v28, v11, v15 - v11);
          uint64_t v29 = v11;
        }
        uint64_t v30 = -v27;
        unint64_t v23 = &v28[v15 - v11];
        uint64_t v20 = &v29[8 * v30];
      }
      else
      {
        uint64_t v20 = v11;
        unint64_t v23 = v15;
        uint64_t v15 = v14;
      }
LABEL_28:
      unint64_t v14 = v15;
      uint64_t v24 = *(void *)v3;
      v3 += 8;
      *(void *)unint64_t v23 = v24;
      uint64_t v21 = v23 + 8;
      uint64_t v15 = v21;
      uint64_t v11 = v20;
      if (v3 == *(char **)(a1 + 16)) {
        goto LABEL_22;
      }
    }
  }
LABEL_21:
  uint64_t v20 = v11;
  uint64_t v21 = v15;
LABEL_22:
  uint64_t v22 = *(void **)a1;
  *(void *)a1 = v16;
  *(void *)(a1 + 8) = v20;
  *(void *)(a1 + 16) = v21;
  *(void *)(a1 + 24) = v14;
  if (v21 - v20 == 8)
  {
    *(void *)(a1 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 256;
    if (!v22) {
      return;
    }
  }
  else
  {
    *(void *)(a1 + 32) += 512;
    if (!v22) {
      return;
    }
  }

  operator delete(v22);
}

void sub_1B76F40E8(_Unwind_Exception *a1)
{
  operator delete(v1);
  operator delete(v2);
  _Unwind_Resume(a1);
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,0>@<X0>(const void **a1@<X1>, char *a2@<X2>, const void **a3@<X3>, char *a4@<X4>, const void **a5@<X5>, char *a6@<X6>, const void ***a7@<X8>)
{
  uint64_t v8 = a5;
  if (a1 == a3)
  {
    if (a2 == a4) {
      goto LABEL_42;
    }
    uint64_t v32 = (uint64_t)*a5;
    uint64_t v33 = a4;
    while (1)
    {
      uint64_t v34 = (uint64_t)&a6[-v32] >> 3;
      if ((v33 - a2) >> 3 < v34) {
        uint64_t v34 = (v33 - a2) >> 3;
      }
      v33 -= 8 * v34;
      a6 -= 8 * v34;
      if (v34) {
        uint64_t result = memmove(a6, v33, 8 * v34);
      }
      if (v33 == a2) {
        break;
      }
      uint64_t v35 = (uint64_t)*--v8;
      uint64_t v32 = v35;
      a6 = (char *)(v35 + 4096);
    }
    goto LABEL_40;
  }
  unint64_t v14 = *a3;
  if (*a3 != a4)
  {
    uint64_t v15 = (uint64_t)*a5;
    uint64_t v16 = a4;
    while (1)
    {
      uint64_t v17 = (uint64_t)&a6[-v15] >> 3;
      if ((v16 - v14) >> 3 < v17) {
        uint64_t v17 = (v16 - v14) >> 3;
      }
      v16 -= 8 * v17;
      a6 -= 8 * v17;
      if (v17) {
        uint64_t result = memmove(a6, v16, 8 * v17);
      }
      if (v16 == v14) {
        break;
      }
      uint64_t v19 = (uint64_t)*--v8;
      uint64_t v15 = v19;
      a6 = (char *)(v19 + 4096);
    }
    if ((char *)*v8 + 4096 == a6)
    {
      uint64_t v20 = (char *)v8[1];
      ++v8;
      a6 = v20;
    }
  }
  uint64_t v21 = a3 - 1;
  if (a3 - 1 != a1)
  {
    uint64_t v22 = (char *)*v8;
    do
    {
      while (1)
      {
        unint64_t v23 = *v21;
        uint64_t v24 = (char *)*v21 + 4096;
        while (1)
        {
          uint64_t v25 = (a6 - v22) >> 3;
          if ((v24 - v23) >> 3 < v25) {
            uint64_t v25 = (v24 - v23) >> 3;
          }
          v24 -= 8 * v25;
          a6 -= 8 * v25;
          if (v25) {
            uint64_t result = memmove(a6, v24, 8 * v25);
          }
          if (v24 == v23) {
            break;
          }
          uint64_t v26 = (char *)*--v8;
          uint64_t v22 = v26;
          a6 = v26 + 4096;
        }
        uint64_t v22 = (char *)*v8;
        if ((char *)*v8 + 4096 == a6) {
          break;
        }
        if (--v21 == a1) {
          goto LABEL_24;
        }
      }
      uint64_t v27 = (char *)v8[1];
      ++v8;
      uint64_t v22 = v27;
      a6 = v27;
      --v21;
    }
    while (v21 != a1);
  }
LABEL_24:
  unint64_t v28 = (char *)*a1 + 4096;
  if (v28 != a2)
  {
    uint64_t v29 = (uint64_t)*v8;
    while (1)
    {
      uint64_t v30 = (uint64_t)&a6[-v29] >> 3;
      if ((v28 - a2) >> 3 < v30) {
        uint64_t v30 = (v28 - a2) >> 3;
      }
      v28 -= 8 * v30;
      a6 -= 8 * v30;
      if (v30) {
        uint64_t result = memmove(a6, v28, 8 * v30);
      }
      if (v28 == a2) {
        break;
      }
      uint64_t v31 = (uint64_t)*--v8;
      uint64_t v29 = v31;
      a6 = (char *)(v31 + 4096);
    }
LABEL_40:
    if ((char *)*v8 + 4096 == a6)
    {
      unint64_t v36 = (char *)v8[1];
      ++v8;
      a6 = v36;
    }
  }
LABEL_42:
  *a7 = a3;
  a7[1] = (const void **)a4;
  a7[2] = v8;
  a7[3] = (const void **)a6;
  return result;
}

const void **std::__for_each_segment[abi:ne180100]<std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>>>(const void **result, unsigned char *__src, const void **a3, unsigned char *a4, uint64_t a5)
{
  uint64_t v7 = __src;
  uint64_t v9 = *(void ***)a5;
  uint64_t v8 = *(char **)(a5 + 8);
  if (result != a3)
  {
    uint64_t v11 = result;
    uint64_t v12 = (char *)*result + 4096;
    if (v12 != __src)
    {
      unint64_t v14 = (char *)*v9++;
      uint64_t v13 = v14;
      while (1)
      {
        uint64_t v15 = (v13 - v8 + 4096) >> 3;
        if ((v12 - v7) >> 3 >= v15) {
          uint64_t v16 = v15;
        }
        else {
          uint64_t v16 = (v12 - v7) >> 3;
        }
        if (v16) {
          uint64_t result = (const void **)memmove(v8, v7, 8 * v16);
        }
        v7 += 8 * v16;
        if (v7 == v12) {
          break;
        }
        uint64_t v17 = (char *)*v9++;
        uint64_t v13 = v17;
        uint64_t v8 = v17;
      }
      v8 += 8 * v16;
      if ((char *)*(v9 - 1) + 4096 == v8)
      {
        uint64_t v8 = (char *)*v9;
        *(void *)a5 = v9;
        *(void *)(a5 + 8) = v8;
        int i = v11 + 1;
        if (v11 + 1 != a3) {
          goto LABEL_16;
        }
LABEL_39:
        uint64_t v33 = *a3;
        if (v33 == a4) {
          goto LABEL_50;
        }
        uint64_t v35 = (char *)*v9++;
        uint64_t v34 = v35;
        while (1)
        {
          uint64_t v36 = (v34 - v8 + 4096) >> 3;
          uint64_t v37 = (a4 - v33) >> 3 >= v36 ? v36 : (a4 - v33) >> 3;
          if (v37) {
            uint64_t result = (const void **)memmove(v8, v33, 8 * v37);
          }
          v33 += 8 * v37;
          if (v33 == a4) {
            break;
          }
          id v38 = (char *)*v9++;
          uint64_t v34 = v38;
          uint64_t v8 = v38;
        }
        v8 += 8 * v37;
        uint64_t v32 = v9 - 1;
        if ((char *)*(v9 - 1) + 4096 != v8)
        {
LABEL_49:
          uint64_t v9 = v32;
          goto LABEL_50;
        }
        goto LABEL_37;
      }
      --v9;
    }
    *(void *)a5 = v9;
    *(void *)(a5 + 8) = v8;
    for (int i = v11 + 1; i != a3; ++i)
    {
LABEL_16:
      while (1)
      {
        uint64_t v19 = 0;
        uint64_t v20 = (char *)*i;
        uint64_t v22 = (char *)*v9++;
        uint64_t v21 = v22;
        while (1)
        {
          uint64_t v23 = (v21 - v8 + 4096) >> 3;
          if ((4096 - 8 * v19) >> 3 >= v23) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = (4096 - 8 * v19) >> 3;
          }
          if (v24) {
            uint64_t result = (const void **)memmove(v8, &v20[8 * v19], 8 * v24);
          }
          v19 += v24;
          if (v19 == 512) {
            break;
          }
          uint64_t v25 = (char *)*v9++;
          uint64_t v21 = v25;
          uint64_t v8 = v25;
        }
        v8 += 8 * v24;
        uint64_t v26 = v9 - 1;
        if ((char *)*(v9 - 1) + 4096 != v8) {
          break;
        }
        uint64_t v8 = (char *)*v9;
        *(void *)a5 = v9;
        *(void *)(a5 + 8) = v8;
        if (++i == a3) {
          goto LABEL_39;
        }
      }
      --v9;
      *(void *)a5 = v26;
      *(void *)(a5 + 8) = v8;
    }
    goto LABEL_39;
  }
  if (__src != a4)
  {
    unint64_t v28 = (char *)*v9++;
    uint64_t v27 = v28;
    while (1)
    {
      uint64_t v29 = (v27 - v8 + 4096) >> 3;
      if ((a4 - v7) >> 3 >= v29) {
        uint64_t v30 = v29;
      }
      else {
        uint64_t v30 = (a4 - v7) >> 3;
      }
      if (v30) {
        uint64_t result = (const void **)memmove(v8, v7, 8 * v30);
      }
      v7 += 8 * v30;
      if (v7 == a4) {
        break;
      }
      uint64_t v31 = (char *)*v9++;
      uint64_t v27 = v31;
      uint64_t v8 = v31;
    }
    v8 += 8 * v30;
    uint64_t v32 = v9 - 1;
    if ((char *)*(v9 - 1) + 4096 != v8) {
      goto LABEL_49;
    }
LABEL_37:
    uint64_t v8 = (char *)*v9;
  }
LABEL_50:
  *(void *)a5 = v9;
  *(void *)(a5 + 8) = v8;
  return result;
}

uint64_t HGCV::HGFormatForCVPixelFormat(HGCV *this, const char *a2, char *a3)
{
  if ((int)this <= 1278226533)
  {
    if ((int)this <= 843264103)
    {
      switch(this)
      {
        case 0x20:
          return 22;
        case 0x32433038:
          return 10;
        case 0x32433066:
          return 13;
      }
    }
    else if ((int)this > 1111970368)
    {
      if (this == 1111970369) {
        return 23;
      }
      if (this == 1278226488) {
        return 1;
      }
    }
    else
    {
      if (this == 843264104) {
        return 12;
      }
      if (this == 843264310) {
        return 11;
      }
    }
    goto LABEL_33;
  }
  if ((int)this <= 1380401728)
  {
    switch(this)
    {
      case 0x4C303066:
        return 7;
      case 0x4C303068:
        return 5;
      case 0x4C303136:
        return 3;
    }
  }
  else
  {
    if ((int)this <= 1380411456)
    {
      if (this == 1380401729) {
        return 24;
      }
      if (this == 1380410945) {
        return 28;
      }
      goto LABEL_33;
    }
    if (this == 1380411457) {
      return 27;
    }
    if (this == 1751411059) {
      return 5;
    }
  }
LABEL_33:
  HGLogger::warning((HGLogger *)"unsupported HGFormat for CoreVideo format %c%c%c%c\n", a2, a3, ((int)this >> 24), ((int)(this << 8) >> 24), ((__int16)this >> 8), (char)this, v3, v4);
  return 0;
}

uint64_t HGCV::CVPixelFormatForHGFormat(int a1)
{
  int v1 = a1 - 1;
  if (a1 - 1) < 0x21 && ((0x1DFE0FE57uLL >> v1)) {
    return dword_1B7EBFD40[v1];
  }
  uint64_t v2 = HGFormatUtils::toString(a1);
  HGLogger::warning((HGLogger *)"unsupported CoreVideo format for HGFormat %s\n", v3, v4, v2);
  return 1111970369;
}

BOOL HGCV::AllowPixelSizeCastingForHGFormat(int a1)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&HGCV::AllowPixelSizeCastingForHGFormat(HGFormat)::envCheck, memory_order_acquire) != -1)
  {
    uint64_t v7 = &v5;
    unint64_t v6 = &v7;
    std::__call_once(&HGCV::AllowPixelSizeCastingForHGFormat(HGFormat)::envCheck, &v6, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGCV::AllowPixelSizeCastingForHGFormat(HGFormat)::$_0 &&>>);
  }
  return a1 != 27 && (a1 - 25) < 0xFFFFFFFE
      || HGCV::AllowPixelSizeCastingForHGFormat(HGFormat)::forcePixelSizeCastingAllowed != 0;
}

const char *std::__call_once_proxy[abi:ne180100]<std::tuple<HGCV::AllowPixelSizeCastingForHGFormat(HGFormat)::$_0 &&>>()
{
  uint64_t result = getenv("HG_ENV_FORCE_IOSURFACE_PIXEL_SIZE_CASTING");
  if (result)
  {
    uint64_t result = (const char *)atoi(result);
    HGCV::AllowPixelSizeCastingForHGFormat(HGFormat)::forcePixelSizeCastingAllowed = result != 0;
  }
  return result;
}

void HGDither::HGDither(HGDither *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10C90A8;
  *(void *)(v1 + 408) = 0;
  *(unsigned char *)(v1 + 448) = 1;
}

void HGDither::~HGDither(HGNode *this)
{
  *(void *)this = &unk_1F10C90A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  *((void *)this + 5PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10C90A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  *((void *)this + 5PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGDither::SetParameter(HGDither *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  int v7 = a3 != 0.0;
  if (*((unsigned __int8 *)this + 448) == v7) {
    return 0;
  }
  *((unsigned char *)this + 448) = v7;
  return 1;
}

void HGDither::GetOutput(HGDither *this, HGRenderer *a2)
{
  {
    {
      __cxa_atexit((void (*)(void *))HGDitherLUTEntryFactory::~HGDitherLUTEntryFactory, &HGDither::GetOutput(HGRenderer *)::lutFactory, &dword_1B73F3000);
    }
  }
  operator new();
}

void sub_1B76F4F68(_Unwind_Exception *exception_object)
{
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

void HGDitherLUTEntryFactory::~HGDitherLUTEntryFactory(HGDitherLUTEntryFactory *this)
{
}

void HGDitherLUTEntryFactory::createLUTEntry()
{
}

void sub_1B76F51BC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0xA1C40987D6AD5);
  _Unwind_Resume(a1);
}

void HGDitherLUTInfo::~HGDitherLUTInfo(HGDitherLUTInfo *this)
{
}

void HGDitherLUTInfo::duplicate(HGDitherLUTInfo *this)
{
}

_DWORD *HGDitherLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (result) {
    return (_DWORD *)(*(_DWORD *)(a1 + 8) == result[2]);
  }
  return result;
}

void *HGDitherLUTEntry::HGDitherLUTEntry(void *a1, const void *a2, uint64_t a3)
{
  char v5 = HGLUTCache::LUTEntry::LUTEntry(a1, (uint64_t)a2, a3);
  *char v5 = &unk_1F10C93B8;
  void v5[3] = 0;
  unint64_t v6 = v5 + 3;
  v5[4] = 0;
  if (a2)
  {
    if (v7)
    {
      NumRows = (HGDitherNoise *)HGDitherNoise::getNumRows(v7);
      int v9 = (int)NumRows;
      int v10 = HGDitherNoise::getNumRows(NumRows);
      uint64_t v12 = (HGDitherNoise *)HGRectMake4f(v11, 0.0, 0.0, (float)v9, (float)v10);
      uint64_t v14 = v13;
      uint64_t Format = HGDitherNoise::getFormat(v12);
      uint64_t v16 = HGObject::operator new(0x80uLL);
      __n128 v17 = HGBitmap::HGBitmap(v16, v12, v14, 27);
      uint64_t v18 = (void *)*v6;
      if ((void *)*v6 == v16)
      {
        if (v16) {
          (*(void (**)(void *, __n128))(*(void *)v16 + 24))(v16, v17);
        }
      }
      else
      {
        if (v18) {
          (*(void (**)(void *, __n128))(*(void *)v18 + 24))(v18, v17);
        }
        *unint64_t v6 = v16;
      }
      Noise = HGDitherNoise::getNoise();
      uint64_t v20 = HGObject::operator new(0x80uLL);
      HGBitmap::HGBitmap(v20, v12, v14, Format, Noise);
      if (Format == *(_DWORD *)(*v6 + 16)) {
        HGRenderUtils::BufferCopier::BufferCopier((HGRenderUtils::BufferCopier *)v22);
      }
      HGRenderUtils::BufferReformatter::BufferReformatter((HGRenderUtils::BufferReformatter *)v22);
    }
  }
  return a1;
}

void sub_1B76F5508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  }
  uint64_t v14 = *((void *)v10 + 4);
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  if (*v12) {
    (*(void (**)(void))(*(void *)*v12 + 24))(*v12);
  }
  HGLUTCache::LUTEntry::~LUTEntry(v10);
  _Unwind_Resume(a1);
}

void HGDitherLUTEntry::~HGDitherLUTEntry(HGDitherLUTEntry *this)
{
  *(void *)this = &unk_1F10C93B8;
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 3);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGLUTCache::LUTEntry::~LUTEntry(this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10C93B8;
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 3);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGLUTCache::LUTEntry::~LUTEntry(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t HGDitherLUTEntry::GetBitmap(HGDitherLUTEntry *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (!v2 {
    || ((*(uint64_t (**)(uint64_t))(*(void *)v2 + 304))(v2) & 1) != 0
  }
    || (uint64_t v3 = (uint64_t *)*((void *)this + 2),
        uint64_t v4 = *v3,
  {
    unint64_t v6 = (HGMetalTexture *)*((void *)this + 3);
    int v7 = (char *)this + 24;
    if (!v6) {
      return *(void *)v7;
    }
    goto LABEL_11;
  }
  int v7 = (char *)this + 32;
  unint64_t v6 = (HGMetalTexture *)*((void *)this + 4);
  if (v6) {
    goto LABEL_11;
  }
  uint64_t MetalContext = HGGPURenderer::GetMetalContext(v5);
  HGMetalTexture::createWithCopy(*(void **)(*(void *)(MetalContext + 16) + 16), 0, *((void *)this + 3), *(void *)(*((void *)this + 3) + 20), *(void *)(*((void *)this + 3) + 28), 0, 0, &v11);
  int v9 = (HGMetalTexture *)*((void *)this + 4);
  unint64_t v6 = v11;
  if (v9 == v11)
  {
    if (!v9) {
      return *(void *)v7;
    }
    (*(void (**)(void))(*(void *)v9 + 24))(*((void *)this + 4));
    unint64_t v6 = *(HGMetalTexture **)v7;
    if (!*(void *)v7) {
      return *(void *)v7;
    }
LABEL_11:
    (*(void (**)(HGMetalTexture *))(*(void *)v6 + 16))(v6);
    return *(void *)v7;
  }
  if (v9)
  {
    (*(void (**)(void))(*(void *)v9 + 24))(*((void *)this + 4));
    unint64_t v6 = v11;
  }
  *(void *)int v7 = v6;
  if (v6) {
    goto LABEL_11;
  }
  return *(void *)v7;
}

void sub_1B76F597C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

void HGCFDataRefHolder::HGCFDataRefHolder(HGCFDataRefHolder *this, const __CFData *a2)
{
  HGObject::HGObject(this);
  *uint64_t v3 = &unk_1F10C93F8;
  int v3[2] = a2;
  CFRetain(a2);
}

void sub_1B76F5A0C(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGCFDataRefHolder::~HGCFDataRefHolder(CFTypeRef *this)
{
  *this = &unk_1F10C93F8;
  CFRelease(this[2]);

  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;
  uint64_t vars8;

  *this = &unk_1F10C93F8;
  CFRelease(this[2]);
  HGObject::~HGObject((HGObject *)this);

  HGObject::operator delete(v2);
}

double HGDigestInit(_OWORD *a1)
{
  double result = -3.59869635e230;
  *a1 = xmmword_1B7E7C6E0;
  return result;
}

_DWORD *HGDigestAdd(_DWORD *result, int *a2)
{
  int v2 = result[1];
  int v4 = result[2];
  int v3 = result[3];
  int v5 = *a2;
  int v6 = a2[1];
  HIDWORD(v7) = *result + *a2 - 680876936 + (v4 & v2 | v3 & ~v2);
  LODWORD(v7) = HIDWORD(v7);
  int v8 = (v7 >> 25) + v2;
  HIDWORD(v7) = v3 + v6 - 389564586 + (v2 & v8 | v4 & ~v8);
  LODWORD(v7) = HIDWORD(v7);
  int v9 = (v7 >> 20) + v8;
  int v10 = a2[2];
  int v11 = a2[3];
  HIDWORD(v7) = v4 + v10 + 606105819 + (v8 & v9 | v2 & ~v9);
  LODWORD(v7) = HIDWORD(v7);
  int v12 = (v7 >> 15) + v9;
  HIDWORD(v7) = v2 + v11 - 1044525330 + (v9 & v12 | v8 & ~v12);
  LODWORD(v7) = HIDWORD(v7);
  int v13 = (v7 >> 10) + v12;
  int v15 = a2[4];
  int v14 = a2[5];
  HIDWORD(v7) = v15 + v8 - 176418897 + (v12 & v13 | v9 & ~v13);
  LODWORD(v7) = HIDWORD(v7);
  int v16 = (v7 >> 25) + v13;
  HIDWORD(v7) = v14 + v9 + 1200080426 + (v13 & v16 | v12 & ~v16);
  LODWORD(v7) = HIDWORD(v7);
  int v17 = (v7 >> 20) + v16;
  int v18 = a2[6];
  int v19 = a2[7];
  HIDWORD(v7) = v18 + v12 - 1473231341 + (v16 & v17 | v13 & ~v17);
  LODWORD(v7) = HIDWORD(v7);
  int v20 = (v7 >> 15) + v17;
  HIDWORD(v7) = v19 + v13 - 45705983 + (v17 & v20 | v16 & ~v20);
  LODWORD(v7) = HIDWORD(v7);
  int v21 = (v7 >> 10) + v20;
  int v22 = a2[8];
  int v23 = a2[9];
  HIDWORD(v7) = v22 + v16 + 1770035416 + (v20 & v21 | v17 & ~v21);
  LODWORD(v7) = HIDWORD(v7);
  int v24 = (v7 >> 25) + v21;
  HIDWORD(v7) = v23 + v17 - 1958414417 + (v21 & v24 | v20 & ~v24);
  LODWORD(v7) = HIDWORD(v7);
  int v25 = (v7 >> 20) + v24;
  int v27 = a2[10];
  int v26 = a2[11];
  HIDWORD(v7) = v27 + v20 - 42063 + (v24 & v25 | v21 & ~v25);
  LODWORD(v7) = HIDWORD(v7);
  int v28 = (v7 >> 15) + v25;
  HIDWORD(v7) = v26 + v21 - 1990404162 + (v25 & v28 | v24 & ~v28);
  LODWORD(v7) = HIDWORD(v7);
  int v29 = (v7 >> 10) + v28;
  int v31 = a2[12];
  int v30 = a2[13];
  HIDWORD(v7) = v31 + v24 + 1804603682 + (v28 & v29 | v25 & ~v29);
  LODWORD(v7) = HIDWORD(v7);
  int v32 = (v7 >> 25) + v29;
  HIDWORD(v7) = v30 + v25 - 40341101 + (v29 & v32 | v28 & ~v32);
  LODWORD(v7) = HIDWORD(v7);
  int v33 = (v7 >> 20) + v32;
  int v35 = a2[14];
  int v34 = a2[15];
  HIDWORD(v7) = v35 + v28 - 1502002290 + (v32 & v33 | v29 & ~v33);
  LODWORD(v7) = HIDWORD(v7);
  int v36 = (v7 >> 15) + v33;
  HIDWORD(v7) = v34 + v29 + 1236535329 + (v33 & v36 | v32 & ~v36);
  LODWORD(v7) = HIDWORD(v7);
  int v37 = (v7 >> 10) + v36;
  HIDWORD(v7) = v6 + v32 - 165796510 + (v37 & v33 | v36 & ~v33);
  LODWORD(v7) = HIDWORD(v7);
  int v38 = (v7 >> 27) + v37;
  HIDWORD(v7) = v18 + v33 - 1069501632 + (v38 & v36 | v37 & ~v36);
  LODWORD(v7) = HIDWORD(v7);
  int v39 = (v7 >> 23) + v38;
  HIDWORD(v7) = v26 + v36 + 643717713 + (v39 & v37 | v38 & ~v37);
  LODWORD(v7) = HIDWORD(v7);
  int v40 = (v7 >> 18) + v39;
  HIDWORD(v7) = v5 + v37 - 373897302 + (v40 & v38 | v39 & ~v38);
  LODWORD(v7) = HIDWORD(v7);
  int v41 = (v7 >> 12) + v40;
  HIDWORD(v7) = v14 + v38 - 701558691 + (v41 & v39 | v40 & ~v39);
  LODWORD(v7) = HIDWORD(v7);
  int v42 = (v7 >> 27) + v41;
  HIDWORD(v7) = v27 + v39 + 38016083 + (v42 & v40 | v41 & ~v40);
  LODWORD(v7) = HIDWORD(v7);
  int v43 = (v7 >> 23) + v42;
  HIDWORD(v7) = v34 + v40 - 660478335 + (v43 & v41 | v42 & ~v41);
  LODWORD(v7) = HIDWORD(v7);
  int v44 = (v7 >> 18) + v43;
  HIDWORD(v7) = v15 + v41 - 405537848 + (v44 & v42 | v43 & ~v42);
  LODWORD(v7) = HIDWORD(v7);
  int v45 = (v7 >> 12) + v44;
  HIDWORD(v7) = v23 + v42 + 568446438 + (v45 & v43 | v44 & ~v43);
  LODWORD(v7) = HIDWORD(v7);
  int v46 = (v7 >> 27) + v45;
  HIDWORD(v7) = v35 + v43 - 1019803690 + (v46 & v44 | v45 & ~v44);
  LODWORD(v7) = HIDWORD(v7);
  int v47 = (v7 >> 23) + v46;
  HIDWORD(v7) = v11 + v44 - 187363961 + (v47 & v45 | v46 & ~v45);
  LODWORD(v7) = HIDWORD(v7);
  int v48 = (v7 >> 18) + v47;
  HIDWORD(v7) = v22 + v45 + 1163531501 + (v48 & v46 | v47 & ~v46);
  LODWORD(v7) = HIDWORD(v7);
  int v49 = (v7 >> 12) + v48;
  HIDWORD(v7) = v30 + v46 - 1444681467 + (v49 & v47 | v48 & ~v47);
  LODWORD(v7) = HIDWORD(v7);
  int v50 = (v7 >> 27) + v49;
  HIDWORD(v7) = v10 + v47 - 51403784 + (v50 & v48 | v49 & ~v48);
  LODWORD(v7) = HIDWORD(v7);
  int v51 = (v7 >> 23) + v50;
  HIDWORD(v7) = v19 + v48 + 1735328473 + (v51 & v49 | v50 & ~v49);
  LODWORD(v7) = HIDWORD(v7);
  int v52 = (v7 >> 18) + v51;
  HIDWORD(v7) = v31 + v49 - 1926607734 + ((v52 ^ v51) & v50 ^ v51);
  LODWORD(v7) = HIDWORD(v7);
  int v53 = (v7 >> 12) + v52;
  HIDWORD(v7) = v14 + v50 - 378558 + (v52 ^ v51 ^ v53);
  LODWORD(v7) = HIDWORD(v7);
  int v54 = (v7 >> 28) + v53;
  HIDWORD(v7) = v22 + v51 - 2022574463 + (v53 ^ v52 ^ v54);
  LODWORD(v7) = HIDWORD(v7);
  int v55 = (v7 >> 21) + v54;
  HIDWORD(v7) = v26 + v52 + 1839030562 + (v54 ^ v53 ^ v55);
  LODWORD(v7) = HIDWORD(v7);
  int v56 = (v7 >> 16) + v55;
  HIDWORD(v7) = v35 + v53 - 35309556 + (v55 ^ v54 ^ v56);
  LODWORD(v7) = HIDWORD(v7);
  int v57 = (v7 >> 9) + v56;
  HIDWORD(v7) = v6 + v54 - 1530992060 + (v56 ^ v55 ^ v57);
  LODWORD(v7) = HIDWORD(v7);
  int v58 = (v7 >> 28) + v57;
  HIDWORD(v7) = v15 + v55 + 1272893353 + (v57 ^ v56 ^ v58);
  LODWORD(v7) = HIDWORD(v7);
  int v59 = (v7 >> 21) + v58;
  HIDWORD(v7) = v19 + v56 - 155497632 + (v58 ^ v57 ^ v59);
  LODWORD(v7) = HIDWORD(v7);
  int v60 = (v7 >> 16) + v59;
  HIDWORD(v7) = v27 + v57 - 1094730640 + (v59 ^ v58 ^ v60);
  LODWORD(v7) = HIDWORD(v7);
  int v61 = (v7 >> 9) + v60;
  HIDWORD(v7) = v30 + v58 + 681279174 + (v60 ^ v59 ^ v61);
  LODWORD(v7) = HIDWORD(v7);
  int v62 = (v7 >> 28) + v61;
  HIDWORD(v7) = v5 + v59 - 358537222 + (v61 ^ v60 ^ v62);
  LODWORD(v7) = HIDWORD(v7);
  int v63 = (v7 >> 21) + v62;
  HIDWORD(v7) = v11 + v60 - 722521979 + (v62 ^ v61 ^ v63);
  LODWORD(v7) = HIDWORD(v7);
  int v64 = (v7 >> 16) + v63;
  HIDWORD(v7) = v18 + v61 + 76029189 + (v63 ^ v62 ^ v64);
  LODWORD(v7) = HIDWORD(v7);
  int v65 = (v7 >> 9) + v64;
  HIDWORD(v7) = v23 + v62 - 640364487 + (v64 ^ v63 ^ v65);
  LODWORD(v7) = HIDWORD(v7);
  int v66 = (v7 >> 28) + v65;
  HIDWORD(v7) = v31 + v63 - 421815835 + (v65 ^ v64 ^ v66);
  LODWORD(v7) = HIDWORD(v7);
  int v67 = (v7 >> 21) + v66;
  HIDWORD(v7) = v34 + v64 + 530742520 + (v66 ^ v65 ^ v67);
  LODWORD(v7) = HIDWORD(v7);
  int v68 = (v7 >> 16) + v67;
  HIDWORD(v7) = v10 + v65 - 995338651 + (v67 ^ v66 ^ v68);
  LODWORD(v7) = HIDWORD(v7);
  int v69 = (v7 >> 9) + v68;
  HIDWORD(v7) = v5 + v66 - 198630844 + ((v69 | ~v67) ^ v68);
  LODWORD(v7) = HIDWORD(v7);
  int v70 = (v7 >> 26) + v69;
  HIDWORD(v7) = v19 + v67 + 1126891415 + ((v70 | ~v68) ^ v69);
  LODWORD(v7) = HIDWORD(v7);
  int v71 = (v7 >> 22) + v70;
  HIDWORD(v7) = v35 + v68 - 1416354905 + ((v71 | ~v69) ^ v70);
  LODWORD(v7) = HIDWORD(v7);
  int v72 = (v7 >> 17) + v71;
  HIDWORD(v7) = v14 + v69 - 57434055 + ((v72 | ~v70) ^ v71);
  LODWORD(v7) = HIDWORD(v7);
  int v73 = (v7 >> 11) + v72;
  HIDWORD(v7) = v31 + v70 + 1700485571 + ((v73 | ~v71) ^ v72);
  LODWORD(v7) = HIDWORD(v7);
  int v74 = (v7 >> 26) + v73;
  HIDWORD(v7) = v11 + v71 - 1894986606 + ((v74 | ~v72) ^ v73);
  LODWORD(v7) = HIDWORD(v7);
  int v75 = (v7 >> 22) + v74;
  HIDWORD(v7) = v27 + v72 - 1051523 + ((v75 | ~v73) ^ v74);
  LODWORD(v7) = HIDWORD(v7);
  int v76 = (v7 >> 17) + v75;
  HIDWORD(v7) = v6 + v73 - 2054922799 + ((v76 | ~v74) ^ v75);
  LODWORD(v7) = HIDWORD(v7);
  int v77 = (v7 >> 11) + v76;
  HIDWORD(v7) = v22 + v74 + 1873313359 + ((v77 | ~v75) ^ v76);
  LODWORD(v7) = HIDWORD(v7);
  int v78 = (v7 >> 26) + v77;
  HIDWORD(v7) = v34 + v75 - 30611744 + ((v78 | ~v76) ^ v77);
  LODWORD(v7) = HIDWORD(v7);
  int v79 = (v7 >> 22) + v78;
  HIDWORD(v7) = v18 + v76 - 1560198380 + ((v79 | ~v77) ^ v78);
  LODWORD(v7) = HIDWORD(v7);
  int v80 = (v7 >> 17) + v79;
  HIDWORD(v7) = v30 + v77 + 1309151649 + ((v80 | ~v78) ^ v79);
  LODWORD(v7) = HIDWORD(v7);
  int v81 = (v7 >> 11) + v80;
  HIDWORD(v7) = v15 + v78 - 145523070 + ((v81 | ~v79) ^ v80);
  LODWORD(v7) = HIDWORD(v7);
  int v82 = (v7 >> 26) + v81;
  HIDWORD(v7) = v26 + v79 - 1120210379 + ((v82 | ~v80) ^ v81);
  LODWORD(v7) = HIDWORD(v7);
  int v83 = (v7 >> 22) + v82;
  HIDWORD(v7) = v10 + v80 + 718787259 + ((v83 | ~v81) ^ v82);
  LODWORD(v7) = HIDWORD(v7);
  int v84 = (v7 >> 17) + v83;
  HIDWORD(v7) = v23 + v81 - 343485551 + ((v84 | ~v82) ^ v83);
  LODWORD(v7) = HIDWORD(v7);
  *result += v82;
  result[1] = v84 + v2 + (v7 >> 11);
  result[2] = v84 + v4;
  result[3] = v83 + v3;
  return result;
}

const char *HGGLGetErrorString(int a1)
{
  if ((a1 - 1280) > 6) {
    return "unknown error";
  }
  else {
    return off_1E616C150[a1 - 1280];
  }
}

const char *HGGLGetFramebufferStatusString(int a1)
{
  if ((a1 - 36054) > 7) {
    return "unknown status";
  }
  else {
    return off_1E616C188[a1 - 36054];
  }
}

void HGGLContextPtr::HGGLContextPtr(HGGLContextPtr *this, void *a2)
{
  *(void *)this = a2;
}

void HGGLContext::~HGGLContext(HGGLContext *this)
{
  *(void *)this = &unk_1F10C9448;
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  }

  HGObject::~HGObject((HGObject *)this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10C9448;
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  }
  HGObject::~HGObject((HGObject *)this);

  HGObject::operator delete(v3);
}

uint64_t HGGLContext::context(HGGLContext *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 40))();
}

uint64_t HGGLContext::ptr(HGGLContext *this)
{
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 2) + 40))(&v2);
  return v2;
}

uint64_t HGGLContext::isAccelerated(HGGLContext *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 48))();
}

uint64_t HGGLContext::isES2(HGGLContext *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 64))();
}

uint64_t HGGLContext::setVirtualScreen(HGGLContext *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 88))();
}

uint64_t HGGLContext::getVirtualScreen(HGGLContext *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 96))();
}

uint64_t HGGLContext::setPriority(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 144))();
}

uint64_t HGGLContext::getPriority(HGGLContext *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 136))();
}

uint64_t HGGLContext::setCurrent(HGGLContext *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 128))();
}

void HGGLContext::Create()
{
  uint64_t v0 = (HGObject *)HGObject::operator new(0x18uLL);
  HGObject::HGObject(v0);
  *(void *)uint64_t v0 = &unk_1F10C9448;
  operator new();
}

void sub_1B76F6870(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v2, 0x81C40803F642BLL);
  HGObject::~HGObject(v1);
  HGObject::operator delete(v4);
  _Unwind_Resume(a1);
}

void sub_1B76F68A8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGGLContext::Share()
{
  uint64_t v0 = (HGObject *)HGObject::operator new(0x18uLL);
  HGObject::HGObject(v0);
  *(void *)uint64_t v0 = &unk_1F10C9448;
  operator new();
}

void sub_1B76F6978(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v2, 0x81C40803F642BLL);
  HGObject::~HGObject(v1);
  HGObject::operator delete(v4);
  _Unwind_Resume(a1);
}

void sub_1B76F69B0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGGLSetCurrentContext(PC_Sp_counted_base **a1)
{
  uint64_t v1 = *a1;
  HGGLContextEAGL::setCurrent(&v1);
}

HGGLContextPtr *HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard(HGGLContextPtr *a1, PC_Sp_counted_base **a2)
{
  HGGLContextEAGL::getCurrent(a1);
  *((unsigned char *)a1 + 8) = 0;
  if (*(PC_Sp_counted_base **)a1 != *a2)
  {
    int v5 = *a2;
    HGGLContextEAGL::setCurrent(&v5);
    *((unsigned char *)a1 + 8) = 1;
  }
  return a1;
}

void sub_1B76F6A54(_Unwind_Exception *a1)
{
  void *v1 = 0;
  _Unwind_Resume(a1);
}

void HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard(HGGLSetCurrentContextGuard *this)
{
  if (*((unsigned char *)this + 8))
  {
    uint64_t v2 = *(PC_Sp_counted_base **)this;
    HGGLContextEAGL::setCurrent(&v2);
  }
  *(void *)this = 0;
}

char *HGDitherNoise::getNoise()
{
  return kBlueNoise3RPDF;
}

uint64_t HGDitherNoise::getNumRows(HGDitherNoise *this)
{
  return 256;
}

uint64_t HGDitherNoise::getFormat(HGDitherNoise *this)
{
  return 27;
}

void HGGLContextEAGL::HGGLContextEAGL(HGGLContextEAGL *this)
{
  *(void *)this = &unk_1F10C9498;
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
}

void HGGLContextEAGL::~HGGLContextEAGL(id *this)
{
  *this = &unk_1F10C9498;
}

{
  uint64_t vars8;

  *this = &unk_1F10C9498;

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t HGGLContextEAGL::create(HGGLContextEAGL *this)
{
  uint64_t result = [objc_alloc(MEMORY[0x1E4F38D58]) initWithAPI:2];
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = result;
  return result;
}

uint64_t HGGLContextEAGL::create(uint64_t a1, PC_Sp_counted_base **a2)
{
  v7.var0 = *a2;
  uint64_t CGColorSpace = (void *)PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v7);
  PCSharedCount::PCSharedCount(&v7);
  uint64_t v4 = [CGColorSpace API];
  uint64_t v5 = [CGColorSpace sharegroup];
  uint64_t result = [objc_alloc(MEMORY[0x1E4F38D58]) initWithAPI:v4 sharegroup:v5];
  *(void *)(a1 + 8) = result;
  return result;
}

void sub_1B76F6C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

uint64_t HGGLContextEAGL::share(void *a1, PC_Sp_counted_base **a2)
{
  v4.var0 = *a2;
  a1[1] = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v4);
  PCSharedCount::PCSharedCount(&v4);
  return (*(uint64_t (**)(void *))(*a1 + 112))(a1);
}

void sub_1B76F6CD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void HGGLContextEAGL::context(void **this@<X0>, HGGLContextPtr *a2@<X8>)
{
}

uint64_t HGGLContextEAGL::isAccelerated(HGGLContextEAGL *this)
{
  return 1;
}

uint64_t HGGLContextEAGL::isES2(HGGLContextEAGL *this)
{
  return 1;
}

uint64_t HGGLContextEAGL::isES3(HGGLContextEAGL *this)
{
  return 0;
}

uint64_t HGGLContextEAGL::getShareGroup(id *this)
{
  return [this[1] sharegroup];
}

uint64_t HGGLContextEAGL::getVirtualScreen(HGGLContextEAGL *this)
{
  return 0;
}

uint64_t HGGLContextEAGL::getRegistryID(HGGLContextEAGL *this)
{
  return 0;
}

id HGGLContextEAGL::retain(id *this)
{
  return this[1];
}

void HGGLContextEAGL::release(id *this)
{
}

uint64_t HGGLContextEAGL::setCurrent(HGGLContextEAGL *this)
{
  return [MEMORY[0x1E4F38D58] setCurrentContext:*((void *)this + 1)];
}

void HGGLContextEAGL::setCurrent(PC_Sp_counted_base **a1)
{
  v1.var0 = *a1;
  [MEMORY[0x1E4F38D58] setCurrentContext:PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v1)];
  PCSharedCount::PCSharedCount(&v1);
}

void sub_1B76F6D9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void HGGLContextEAGL::getCurrent(HGGLContextPtr *a1@<X8>)
{
  int v3 = (void *)[MEMORY[0x1E4F38D58] currentContext];

  HGGLContextPtr::HGGLContextPtr(a1, v3);
}

uint64_t HGGLContextEAGL::getPriority(HGGLContextEAGL *this)
{
  return 1;
}

BOOL HGGLContextEAGL::setPriority(uint64_t a1, int a2)
{
  int v4 = 1;
  if (a2 == 2)
  {
    int v2 = 4;
    goto LABEL_5;
  }
  if (!a2)
  {
    int v2 = 2;
LABEL_5:
    int v4 = v2;
  }
  return [*(id *)(a1 + 8) setParameter:608 to:&v4] == 0;
}

uint64_t HGGLContextEAGL::isES(HGGLContextEAGL *this)
{
  return 1;
}

uint64_t HGDemosaicImplementation::GenerateGraph(HGDemosaicImplementation *this, HGRenderer *a2, HGNode *a3)
{
  if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) != 0
    || !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 43)
    || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 43) == 1)
  {
    int v4 = (HgcDemosaic_1 *)HGObject::operator new(0x1A0uLL);
    HgcDemosaic_1::HgcDemosaic_1(v4);
  }
  return 0;
}

void sub_1B76F7218(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HDemosaic_1::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

uint64_t HDemosaic_2::GetROI(HDemosaic_2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  return HGRectGrow(v6, v5, v7);
}

uint64_t HDemosaic_2::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void HGDemosaic::HGDemosaic(HGDemosaic *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v2 = &unk_1F10C9568;
  int v3 = (char *)HGObject::operator new(0x40uLL);
  HGObject::HGObject((HGObject *)v3);
  *(void *)int v3 = &unk_1F10C9CA0;
  *(_OWORD *)(v3 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0u;
  *(_OWORD *)(v3 + 28) = 0u;
  *(_OWORD *)(v3 + 44) = 0u;
  *((_DWORD *)v3 + 15) = 0;
  *((void *)this + 5PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v3;
}

void sub_1B76F73D8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F73F4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGDemosaic::~HGDemosaic(HGNode *this)
{
  *(void *)this = &unk_1F10C9568;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10C9568;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGDemosaic::SetParameter(HGDemosaic *this, int a2, double a3, float a4, float a5, float a6)
{
  uint64_t v6 = *((void *)this + 51);
  switch(a2)
  {
    case 0:
      if (*(float *)(v6 + 12) == *(float *)&a3) {
        goto LABEL_27;
      }
      *(_DWORD *)(v6 + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = LODWORD(a3);
      uint64_t result = 1;
      break;
    case 1:
      if (*(float *)(v6 + 16) == *(float *)&a3) {
        goto LABEL_27;
      }
      *(_DWORD *)(v6 + 16) = LODWORD(a3);
      uint64_t result = 1;
      break;
    case 2:
      if (*(float *)(v6 + 20) == *(float *)&a3) {
        goto LABEL_27;
      }
      *(_DWORD *)(v6 + 20) = LODWORD(a3);
      uint64_t result = 1;
      break;
    case 3:
      if (COERCE_FLOAT(*(void *)(v6 + 24)) == *(float *)&a3 && COERCE_FLOAT(HIDWORD(*(void *)(v6 + 24))) == a4) {
        goto LABEL_27;
      }
      *((float *)&a3 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = a4;
      *(double *)(v6 + 24) = a3;
      uint64_t result = 1;
      break;
    case 4:
      if (*(float *)(v6 + 32) == *(float *)&a3) {
        goto LABEL_27;
      }
      *(_DWORD *)(v6 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = LODWORD(a3);
      uint64_t result = 1;
      break;
    case 5:
      if (*(float *)(v6 + 36) == *(float *)&a3) {
        goto LABEL_27;
      }
      *(_DWORD *)(v6 + 36) = LODWORD(a3);
      uint64_t result = 1;
      break;
    case 6:
      if (*(float *)(v6 + 40) == *(float *)&a3) {
        goto LABEL_27;
      }
      *(_DWORD *)(v6 + 40) = LODWORD(a3);
      uint64_t result = 1;
      break;
    case 7:
      if (*(float *)(v6 + 44) == *(float *)&a3) {
        goto LABEL_27;
      }
      *(_DWORD *)(v6 + 44) = LODWORD(a3);
      uint64_t result = 1;
      break;
    case 8:
      if (COERCE_FLOAT(*(void *)(v6 + 48)) == *(float *)&a3 && COERCE_FLOAT(HIDWORD(*(void *)(v6 + 48))) == a4)
      {
LABEL_27:
        uint64_t result = 0;
      }
      else
      {
        *((float *)&a3 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = a4;
        *(double *)(v6 + 48) = a3;
        uint64_t result = 1;
      }
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

HGNode *HGDemosaic::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t result = HGRenderer::GetInput(a2, this, 0);
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = (HGDemosaicImplementation *)*((void *)this + 51);
    return (HGNode *)HGDemosaicImplementation::GenerateGraph(v6, a2, v5);
  }
  return result;
}

void HDemosaic_1::~HDemosaic_1(HGNode *this)
{
  HgcDemosaic_1::~HgcDemosaic_1(this);

  HGObject::operator delete(v1);
}

void HDemosaic_2::~HDemosaic_2(HGNode *this)
{
  HgcDemosaic_2::~HgcDemosaic_2(this);

  HGObject::operator delete(v1);
}

void HGDemosaicImplementation::~HGDemosaicImplementation(HGDemosaicImplementation *this)
{
  *(void *)this = &unk_1F10C9CA0;
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10C9CA0;
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v3);
}

void HGComicGaussianBlurAndGradientGeneration::HGComicGaussianBlurAndGradientGeneration(HGComicGaussianBlurAndGradientGeneration *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10C9CF0;
  *(_OWORD *)(v1 + 408) = xmmword_1B7E76300;
  *(_DWORD *)(v1 + 16) |= 0x600u;
}

void HGComicGaussianBlurAndGradientGeneration::~HGComicGaussianBlurAndGradientGeneration(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGComicGaussianBlurAndGradientGeneration::SetParameter(HGComicGaussianBlurAndGradientGeneration *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2 == 2)
  {
    if (a3 == 1.0) {
      float v7 = 1.0;
    }
    else {
      float v7 = 0.0;
    }
    if (*((float *)this + 105) != v7)
    {
      if (a3 == 1.0) {
        float v8 = 1.0;
      }
      else {
        float v8 = 0.0;
      }
      *((float *)this + 105) = v8;
      return 1;
    }
  }
  else
  {
    if (a2 != 1)
    {
      if (a2) {
        return 0xFFFFFFFFLL;
      }
      if (*((float *)this + 102) != a3)
      {
        *((float *)this + 10PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a3;
        return 1;
      }
      return 0;
    }
    if (*((float *)this + 103) != a3)
    {
      *((float *)this + 103) = a3;
      float v9 = *((float *)this + 104);
      goto LABEL_19;
    }
    float v9 = *((float *)this + 104);
    if (v9 != a4)
    {
LABEL_19:
      if (v9 != a4)
      {
        *((float *)this + 104) = a4;
        return 1;
      }
      return 1;
    }
  }
  return 0;
}

uint64_t HGComicGaussianBlurAndGradientGeneration::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

uint64_t HGComicGaussianBlurAndGradientGeneration::GetROI(HGComicGaussianBlurAndGradientGeneration *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
  {
    HGRect v13 = (HGRect)HGRectNull;
    return HGRectNull;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  a4.var2 = vcvtps_s32_f32(*((float *)this + 102) + *((float *)this + 102));
  if (*((float *)this + 103) == 1.0)
  {
    int v7 = -a4.var2;
    int v8 = 0;
    a4.var0 = a4.var2;
    a4.var2 = 0;
LABEL_7:
    HGRect::Init(&v12, v7, v8, a4.var0, a4.var2);
    goto LABEL_8;
  }
  if (*((float *)this + 104) == 1.0)
  {
    int v8 = -a4.var2;
    int v7 = 0;
    a4.var0 = 0;
    goto LABEL_7;
  }
LABEL_8:
  *(void *)&v13.var0 = v6;
  *(void *)&v13.var2 = v5;
  HGRect::Grow(&v13, v12);
  uint64_t v9 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  uint64_t v11 = v10;
  *(void *)&v14.var0 = v9;
  *(void *)&v14.var2 = v11;
  HGRect::Grow(&v13, v14);
  return *(void *)&v13.var0;
}

uint64_t HGComicGaussianBlurAndGradientGeneration::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicGaussianBlurAndGradientGeneration::RenderTile(HGComicGaussianBlurAndGradientGeneration *this, HGTile *a2)
{
  float v4 = *((float *)this + 104);
  if (*((float *)this + 103) == 1.0)
  {
    if (v4 == 1.0) {
      return 0xFFFFFFFFLL;
    }
  }
  else if (v4 != 1.0)
  {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = HGTile::Renderer(a2);
  int v7 = (*(uint64_t (**)(HGComicGaussianBlurAndGradientGeneration *, uint64_t))(*(void *)this + 312))(this, v6);
  int32x2_t v8 = *(int32x2_t *)a2;
  int v77 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v77 >= 1)
  {
    uint64_t v9 = (*((_DWORD *)a2 + 2) - v8.i32[0]);
    if ((int)v9 >= 1)
    {
      int v10 = v7;
      int v11 = 0;
      *(float32x2_t *)v12.f32 = vadd_f32(vcvt_f32_s32(v8), (float32x2_t)0x3F0000003F000000);
      v12.i64[1] = 0x3F80000000000000;
      float v13 = *((float *)this + 102);
      float v14 = v13 + v13;
      float v15 = 1.0 / (float)(v13 * (float)(v13 + v13));
      uint64_t v16 = *((void *)a2 + 2);
      v17.i32[0] = 1.0;
      __asm { FMOV            V0.4S, #1.0 }
      float32x4_t v80 = _Q0;
      float32x4_t v23 = v12;
      float32x4_t v82 = v12;
      do
      {
        int v79 = v11;
        uint64_t v24 = 0;
        float32x4_t v78 = v23;
        float32x4_t v25 = v23;
        do
        {
          uint64_t v36 = *((void *)a2 + 10);
          uint64_t v37 = *((int *)a2 + 22);
          float32x4_t v38 = vsubq_f32(v25, v12);
          float32x4_t v83 = v25;
          if (v10)
          {
            int32x4_t v39 = vaddq_s32(vcvtq_s32_f32(v38), vcltzq_f32(v38));
            float32x2_t v40 = (float32x2_t)vsubq_f32(v38, vcvtq_f32_s32(v39)).u64[0];
            int v41 = (float32x4_t *)(v36 + 16 * (v39.i32[0] + v39.i32[1] * (int)v37));
            float32x4_t v42 = vaddq_f32(*v41, vmulq_n_f32(vsubq_f32(v41[1], *v41), v40.f32[0]));
            float32x4_t v43 = vaddq_f32(v42, vmulq_lane_f32(vsubq_f32(vaddq_f32(v41[v37], vmulq_n_f32(vsubq_f32(v41[(int)v37 + 1], v41[v37]), v40.f32[0])), v42), v40, 1));
            float v44 = *((float *)this + 104);
            v45.i64[0] = 0x3F0000003F000000;
            v45.i64[1] = 0x3F0000003F000000;
            int8x16_t v81 = (int8x16_t)v43;
            if (v14 >= v17.f32[0])
            {
              uint64_t v46 = (int)v37 + 1;
              float v47 = *((float *)this + 103);
              float v48 = 1.0;
              float32x4_t v49 = v43;
              do
              {
                float32x4_t v86 = v49;
                float32x4_t v89 = v45;
                *(float *)&unint64_t v50 = v48 * v47;
                *((float *)&v50 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v48 * v44;
                float32x4_t v84 = (float32x4_t)v50;
                *(float *)v51.int i32 = expf(v15 * (float)-(float)(v48 * v48));
                float32x4_t v25 = v83;
                float32x4_t v45 = vaddq_f32(v89, (float32x4_t)vdupq_lane_s32(v51, 0));
                float32x4_t v52 = vsubq_f32(vaddq_f32(v83, v84), v82);
                int32x4_t v53 = vaddq_s32(vcvtq_s32_f32(v52), vcltzq_f32(v52));
                v52.i64[0] = vsubq_f32(v52, vcvtq_f32_s32(v53)).u64[0];
                int v54 = (float32x4_t *)(v36 + 16 * (v53.i32[0] + v53.i32[1] * (int)v37));
                float32x4_t v55 = vsubq_f32(vsubq_f32(v83, v84), v82);
                int32x4_t v56 = vaddq_s32(vcvtq_s32_f32(v55), vcltzq_f32(v55));
                float32x4_t v57 = vaddq_f32(*v54, vmulq_n_f32(vsubq_f32(v54[1], *v54), v52.f32[0]));
                float32x2_t v58 = (float32x2_t)vsubq_f32(v55, vcvtq_f32_s32(v56)).u64[0];
                float32x4_t v59 = vaddq_f32(v54[v37], vmulq_n_f32(vsubq_f32(v54[v46], v54[v37]), v52.f32[0]));
                int v60 = (float32x4_t *)(v36 + 16 * (v56.i32[0] + v56.i32[1] * (int)v37));
                float32x4_t v17 = vaddq_f32(*v60, vmulq_n_f32(vsubq_f32(v60[1], *v60), v58.f32[0]));
                float32x4_t v61 = vaddq_f32(v57, vmulq_lane_f32(vsubq_f32(v59, v57), *(float32x2_t *)v52.f32, 1));
                float32x4_t v62 = vaddq_f32(v17, vmulq_lane_f32(vsubq_f32(vaddq_f32(v60[v37], vmulq_n_f32(vsubq_f32(v60[v46], v60[v37]), v58.f32[0])), v17), v58, 1));
                v17.i32[0] = 1.0;
                float v48 = v48 + 1.0;
                float32x4_t v49 = vaddq_f32(v86, vmulq_n_f32(vaddq_f32(v61, v62), *(float *)v51.i32));
              }
              while (v48 <= v14);
              goto LABEL_21;
            }
          }
          else
          {
            v45.i64[0] = 0x3F0000003F000000;
            v45.i64[1] = 0x3F0000003F000000;
            float32x4_t v63 = vaddq_f32(v38, v45);
            int32x4_t v64 = vcvtq_s32_f32(v63);
            v63.i64[0] = vaddq_s32(v64, vcgtq_f32(vcvtq_f32_s32(v64), v63)).u64[0];
            float32x4_t v43 = *(float32x4_t *)(v36 + 16 * (v63.i32[0] + v63.i32[1] * (int)v37));
            float v44 = *((float *)this + 104);
            int8x16_t v81 = (int8x16_t)v43;
            if (v14 >= v17.f32[0])
            {
              float v65 = *((float *)this + 103);
              float v66 = 1.0;
              float32x4_t v49 = v43;
              do
              {
                float32x4_t v87 = v49;
                float32x4_t v90 = v45;
                *(float *)&unint64_t v67 = v66 * v65;
                *((float *)&v67 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v66 * v44;
                float32x4_t v85 = (float32x4_t)v67;
                *(float *)v68.int i32 = expf(v15 * (float)-(float)(v66 * v66));
                float32x4_t v25 = v83;
                v17.i32[0] = 1.0;
                v69.i64[0] = 0x3F0000003F000000;
                v69.i64[1] = 0x3F0000003F000000;
                float32x4_t v70 = vaddq_f32(vsubq_f32(vaddq_f32(v83, v85), v82), v69);
                int32x4_t v71 = vcvtq_s32_f32(v70);
                v70.i64[0] = vaddq_s32(v71, vcgtq_f32(vcvtq_f32_s32(v71), v70)).u64[0];
                __int32 v72 = v70.i32[1];
                __int32 v73 = v70.i32[0];
                float32x4_t v74 = vaddq_f32(vsubq_f32(vsubq_f32(v83, v85), v82), v69);
                int32x4_t v75 = vcvtq_s32_f32(v74);
                v74.i64[0] = vaddq_s32(v75, vcgtq_f32(vcvtq_f32_s32(v75), v74)).u64[0];
                float32x4_t v45 = vaddq_f32(v90, (float32x4_t)vdupq_lane_s32(v68, 0));
                float v66 = v66 + 1.0;
                float32x4_t v49 = vaddq_f32(v87, vmulq_n_f32(vaddq_f32(*(float32x4_t *)(v36 + 16 * (v73 + v72 * (int)v37)), *(float32x4_t *)(v36 + 16 * (v74.i32[0] + v74.i32[1] * (int)v37))), *(float *)v68.i32));
              }
              while (v66 <= v14);
              goto LABEL_21;
            }
          }
          float32x4_t v49 = v43;
LABEL_21:
          v76.i64[0] = 0x3F0000003F000000;
          v76.i64[1] = 0x3F0000003F000000;
          float32x4_t v29 = vdivq_f32(vmulq_f32(v49, v76), v45);
          if (v44 == v17.f32[0])
          {
            int8x16_t v88 = (int8x16_t)v29;
            float v26 = atan2f((float)((float)(v29.f32[2] + v29.f32[2]) + -1.0) * -2.0, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1), v29).f32[0]);
            __float2 v27 = __sincosf_stret((float)(v26 * 0.5) + 3.1416);
            float32x4_t v25 = v83;
            v17.i32[0] = 1.0;
            v28.i32[0] = *((_DWORD *)this + 105);
            v29.i32[0] = 0;
            v29.f32[1] = (float)(v27.__cosval + 1.0) * 0.5;
            v29.f32[2] = (float)(v27.__sinval + 1.0) * 0.5;
            v29.i32[3] = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)vceqq_f32(v28, v17), 0), v81, v88).i32[3];
          }
          else if (*((float *)this + 105) == v17.f32[0])
          {
            v29.i32[3] = v81.i32[3];
          }
          float32x4_t v12 = v82;
          int8x16_t v30 = (int8x16_t)vmaxnmq_f32(vminnmq_f32(v29, v80), (float32x4_t)0);
          float32x4_t v31 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.i8, 1);
          v29.i64[0] = 0;
          int8x16_t v32 = v30;
          v32.i32[1] = 0;
          int8x16_t v33 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v29, v31), (int8x16_t)vcgeq_f32(v31, v29))), 0), v32, v30);
          float32x4_t v34 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2);
          int8x16_t v35 = v33;
          v35.i32[2] = 0;
          *(int8x16_t *)(v16 + 16 * v24) = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v29, v34), (int8x16_t)vcgeq_f32(v34, v29))), 0), v35, v33);
          float32x4_t v25 = vaddq_f32(v25, (float32x4_t)xmmword_1B7E736B0);
          ++v24;
        }
        while (v24 != v9);
        float32x4_t v23 = vaddq_f32(v78, (float32x4_t)xmmword_1B7E736C0);
        v16 += 16 * *((int *)a2 + 6);
        int v11 = v79 + 1;
      }
      while (v79 + 1 != v77);
    }
  }
  return 0;
}

HGComicGaussianBlurAndGradientGeneration *HGComicGaussianBlurAndGradientGeneration::GetOutput(HGComicGaussianBlurAndGradientGeneration *this, HGRenderer *a2, char *a3)
{
  HGNode::SetParameter((HGNode *)this, 0, *((float *)this + 102), 0.0, 0.0, 0.0, a3);
  HGNode::SetParameter((HGNode *)this, 1, *((float *)this + 103), *((float *)this + 104), 0.0, 0.0, v4);
  HGNode::SetParameter((HGNode *)this, 2, *((float *)this + 105), 0.0, 0.0, 0.0, v5);
  return this;
}

const char *HGComicGaussianBlurAndGradientGeneration::GetProgram(HGComicGaussianBlurAndGradientGeneration *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) < 0x60B10)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
    {
      if (*((float *)this + 103) == 1.0) {
        return "//GLfs1.0      \n"
      }
               "//LEN=0000000632\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#define precision\n"
               "#endif\n"
               "\n"
               "precision highp float;\n"
               "precision highp int;\n"
               "\n"
               "\n"
               "uniform lowp sampler2DRect inputTexture;\n"
               ""uniform mediump vec4 hg_ProgramLocal0;
               ""uniform mediump vec4 hg_ProgramLocal1;
               ""uniform mediump vec4 hg_ProgramLocal2;
               "\n"
               "void main()\n"
               "{\n"
               "    mediump float sigma = hg_ProgramLocal0.x;\n"
               "    mediump float alphaPassthrough = hg_ProgramLocal2.x;\n"
               "    mediump float sigma22 = 1.0 / (2.0 * sigma * sigma);\n"
               "    mediump float sigmax2 = 2.0 * sigma;\n"
               "\n"
               "    highp vec4 texel = texture2DRect(inputTexture, gl_TexCoord[0].xy);\n"
               "    highp vec4 acc = texel;\n"
               "    float norunint64_t m = 0.5;\n"
               "\n"
               "    for (float int i = 1.0; i <=  sigmax2; i++)\n"
               "    {\n"
               "        float coeff = exp(-i*i * sigma22);\n"
               "        \n"
               "        float uPos = gl_TexCoord[0].x + i;\n"
               "        float uNeg = gl_TexCoord[0].x - i;\n"
               "        float v = gl_TexCoord[0].y;\n"
               "     \n"
               "        norm += coeff;\n"
               "        acc += coeff * \n"
               "            (texture2DRect(inputTexture, vec2(uPos, v)) +\n"
               "               texture2DRect(inputTexture, vec2(uNeg, v)));\n"
               "    }\n"
               "    \n"
               "    highp vec4 uint64_t result = acc * 0.5 / norm;\n"
               "    result.a = (texel.a * alphaPassthrough + result.a * (1.0 - alphaPassthrough));\n"
               "    \n"
               "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
               "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
               "    gl_FragColor = clamp(result, 0.0, 1.0);\n"
               "}\n"
               "//MD5=603686a0:96250beb:b6f38426:b3689fdb\n"
               "//SIG=00000000:00000000:00000000:00000000:0012:0003:0000:0000:0000:0000:0000:0000:0001:00:0:1:0\n";
      else {
        return "//GLfs1.0      \n"
      }
               "//LEN=0000000743\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#define precision\n"
               "#endif\n"
               "#define defaultp highp\n"
               "\n"
               "precision highp float;\n"
               "precision highp int;\n"
               "\n"
               "#define M_PI        3.14159265358979323846264338327950288\n"
               "\n"
               "uniform sampler2DRect inputTexture;\n"
               ""uniform mediump vec4 hg_ProgramLocal0;
               ""uniform mediump vec4 hg_ProgramLocal1;
               ""uniform mediump vec4 hg_ProgramLocal2;
               "\n"
               "void main()\n"
               "{\n"
               "    mediump float sigma = hg_ProgramLocal0.x;\n"
               "    mediump float alphaPassthrough = hg_ProgramLocal2.x;\n"
               "    mediump float sigma22 = 1.0 / (2.0 * sigma * sigma);\n"
               "    mediump float sigmax2 = 2.0 * sigma;\n"
               "\n"
               "    vec4 texel = texture2DRect(inputTexture, gl_TexCoord[0].xy);\n"
               "    vec4 acc = texel;\n"
               "    float norunint64_t m = 0.5;\n"
               "\n"
               "    for (float int i = 1.0; i <= sigmax2; i++)\n"
               "    {\n"
               "        float coeff = exp(-i*i * sigma22);\n"
               "        \n"
               "        float u = gl_TexCoord[0].x;\n"
               "        float vPos = gl_TexCoord[0].y + i;\n"
               "        float vNeg = gl_TexCoord[0].y - i;\n"
               "     \n"
               "        norm += coeff;\n"
               "        acc += coeff * \n"
               "            (texture2DRect(inputTexture, vec2(u, vPos)) +\n"
               "               texture2DRect(inputTexture, vec2(u, vNeg)));\n"
               "    }\n"
               "    acc = acc * 0.5 / norm;\n"
               "    \n"
               "    // Generate gradients \n"
               "    float alfa = M_PI + 0.5 * atan(-2.0 * (acc.z * 2.0 - 1.0),  acc.y - acc.x);\n"
               "    \n"
               "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
               "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
               "    gl_FragColor = clamp(vec4(0.0,\n"
               "                              (cos(alfa) + 1.0) * 0.5,\n"
               "                              (sin(alfa) + 1.0) * 0.5,\n"
               "                              (alphaPassthrough == 1.0) ? texel.a : acc.a), 0.0, 1.0);\n"
               "}\n"
               "//MD5=92f7df43:09b533ad:ad6d6e66:e2b97b70\n"
               "//SIG=00000000:00000000:00000000:00000000:0026:0003:0000:0000:0000:0000:0000:0000:0001:00:0:1:0\n";
    }
    else
    {
      return 0;
    }
  }
  else if (*((float *)this + 103) == 1.0)
  {
    return "//Metal1.0     \n"
           "//LEN=00000005fd\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    const half sigma {static_cast<half>(hg_Params[0].x)};\n"
           "    const BOOL alphaPassthrough {static_cast<BOOL>(hg_Params[2].x)};\n"
           "    const half sigma22 {1.0h / (2.0h * sigma * sigma)};\n"
           "    const half sigmax2 {2.0h * sigma};\n"
           "\n"
           "    half4 texel = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "    half4 acc = texel;\n"
           "    half norm {0.5h};\n"
           "\n"
           "    for (half i {1.0h}; i <= sigmax2; i++)\n"
           "    {\n"
           "        const half coeff {exp(-i * i * sigma22)};\n"
           "        \n"
           "        const float uPos {frag._texCoord0.x + i};\n"
           "        const float uNeg {frag._texCoord0.x - i};\n"
           "        const float v {frag._texCoord0.y};\n"
           "     \n"
           "        norm += coeff;\n"
           "        acc += coeff * \n"
           "            (hg_Texture0.sample(hg_Sampler0, float2(uPos, v)) +\n"
           "             hg_Texture0.sample(hg_Sampler0, float2(uNeg, v)));\n"
           "    }\n"
           " \n"
           "    half4 uint64_t result = acc * 0.5h / norm;\n"
           "    result.a = (alphaPassthrough ? texel.a : result.a);\n"
           "\n"
           "    FragmentOut out {static_cast<float4>(result)};\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "\n"
           "    return out;\n"
           "}\n"
           "//MD5=85a34481:c1c78204:e169c439:c39a6324\n"
           "//SIG=00000000:00000000:00000000:00000001:0008:0003:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else
  {
    return "//Metal1.0     \n"
           "//LEN=00000006fe\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    const half sigma {static_cast<half>(hg_Params[0].x)};\n"
           "    const BOOL alphaPassthrough {static_cast<BOOL>(hg_Params[2].x)};\n"
           "    const half sigma22 {1.0h / (2.0h * sigma * sigma)};\n"
           "    const half sigmax2 {2.0h * sigma};\n"
           "\n"
           "    const half4 texel = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "\n"
           "    half4 acc = texel;\n"
           "    half norm {0.5h};\n"
           "\n"
           "    for (half i {1.0h}; i <= sigmax2; i++)\n"
           "    {\n"
           "        const half coeff {exp(-i * i * sigma22)};\n"
           "        \n"
           "        const float u {frag._texCoord0.x};\n"
           "        const float vPos {frag._texCoord0.y + i};\n"
           "        const float vNeg {frag._texCoord0.y - i};\n"
           "\n"
           "        norm += coeff;\n"
           "        acc += coeff * \n"
           "            (hg_Texture0.sample(hg_Sampler0, float2(u, vPos)) +\n"
           "             hg_Texture0.sample(hg_Sampler0, float2(u, vNeg)));\n"
           "    }\n"
           "    acc = acc * 0.5h / norm;\n"
           "\n"
           "    // Generate gradients \n"
           "    const half alfa {M_PI_H + 0.5h * atan2(-2.0h * (acc.z * 2.0h - 1.0h),  acc.y - acc.x)};\n"
           "    \n"
           "    FragmentOut out {float4(0.0h,\n"
           "                     (cos(alfa) + 1.0h) * 0.5h,\n"
           "                     (sin(alfa) + 1.0h) * 0.5h,\n"
           "                     alphaPassthrough ? texel.a : acc.a)};\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "\n"
           "    return out;\n"
           "}\n"
           "//MD5=d4a9c30f:71e94a09:7c9108eb:21ca2c59\n"
           "//SIG=00000000:00000000:00000000:00000001:0011:0003:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
}

uint64_t HGComicGaussianBlurAndGradientGeneration::BindTexture(HGComicGaussianBlurAndGradientGeneration *this, HGHandler *a2, uint64_t a3)
{
  return 0;
}

uint64_t *HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(uint64_t *a1, uint64_t a2, PCColorSpaceHandle *a3)
{
  *a1 = a2;
  uint64_t v5 = (PCColorSpaceHandle *)(a1 + 1);
  HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)(a1 + 1), 0);
  *((unsigned char *)a1 + 16) = 0;
  uint64_t v6 = *a1;
  if (*a1)
  {
    if (*(unsigned char *)(v6 + 40))
    {
      var0 = *(PC_Sp_counted_base **)(v6 + 32);
      v14.var0 = var0;
    }
    else
    {
      HGGLGetCurrentContext();
      var0 = v14.var0;
    }
    *(void *)uint64_t v5 = var0;
    PCSharedCount::PCSharedCount(&v14);
  }
  if (!PCColorSpaceHandle::getCGColorSpace(v5))
  {
    HGGLGetCurrentContext();
    *(PCSharedCount *)uint64_t v5 = v14;
    PCSharedCount::PCSharedCount(&v14);
  }
  uint64_t CGColorSpace = PCColorSpaceHandle::getCGColorSpace(v5);
  if (CGColorSpace != PCColorSpaceHandle::getCGColorSpace(a3))
  {
    uint64_t v9 = *a1;
    if (*a1)
    {
      float v13 = *(PC_Sp_counted_base **)a3;
      int v10 = (PCSharedCount *)&v13;
      HGGLState::setCurrentContext(v9, &v13);
    }
    else
    {
      float32x4_t v12 = *(PC_Sp_counted_base **)a3;
      int v10 = (PCSharedCount *)&v12;
      HGGLSetCurrentContext(&v12);
    }
    PCSharedCount::PCSharedCount(v10);
    *((unsigned char *)a1 + 16) = 1;
  }
  return a1;
}

void sub_1B76F82E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  PCSharedCount::PCSharedCount(v10);
  _Unwind_Resume(a1);
}

void sub_1B76F8300(_Unwind_Exception *a1)
{
  PCSharedCount::PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F8314(_Unwind_Exception *a1)
{
  PCSharedCount::PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void sub_1B76F8328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11)
{
  PCSharedCount::PCSharedCount(&a11);
  PCSharedCount::PCSharedCount(v11);
  _Unwind_Resume(a1);
}

void sub_1B76F8344(_Unwind_Exception *a1)
{
  PCSharedCount::PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void HGGLState::setCurrentContext(uint64_t a1, PC_Sp_counted_base **a2)
{
  if (*(unsigned char *)(a1 + 40))
  {
    int v3 = (PC_Sp_counted_base **)(a1 + 32);
    uint64_t CGColorSpace = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)(a1 + 32));
    if (CGColorSpace != PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)a2))
    {
      v6.var0 = *a2;
      HGGLSetCurrentContext(&v6.var0);
      PCSharedCount::PCSharedCount(&v6);
      *int v3 = *a2;
    }
  }
  else
  {
    v5.var0 = *a2;
    HGGLSetCurrentContext(&v5.var0);
    PCSharedCount::PCSharedCount(&v5);
  }
}

void sub_1B76F83FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
}

void sub_1B76F8410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(PCSharedCount *this)
{
  if (LOBYTE(this[2].var0))
  {
    uint64_t var0 = (uint64_t)this->var0;
    if (this->var0)
    {
      v3.uint64_t var0 = this[1].var0;
      HGGLState::setCurrentContext(var0, &v3.var0);
    }
    else
    {
      v3.uint64_t var0 = this[1].var0;
      HGGLSetCurrentContext(&v3.var0);
    }
    PCSharedCount::PCSharedCount(&v3);
  }
  PCSharedCount::PCSharedCount(this + 1);
}

void HGGLState::HGGLState(HGGLState *this)
{
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  *(void *)this = (char *)this + 8;
  HGGLContextPtr::HGGLContextPtr((HGGLState *)((char *)this + 24), 0);
  HGGLContextPtr::HGGLContextPtr((HGGLState *)((char *)this + 32), 0);
  *((unsigned char *)this + 40) = 0;
  HGLogger::setLevel((HGLogger *)"glstate", (const char *)1);
}

void sub_1B76F850C(_Unwind_Exception *a1)
{
  float v4 = v3;
  PCSharedCount::PCSharedCount(v4);
  PCSharedCount::PCSharedCount(v2);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1B76F8540(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void HGGLState::resetUniforms(HGGLState **this)
{
  uint64_t v2 = this + 1;
  PCSharedCount v3 = *this;
  if (*this != (HGGLState *)(this + 1))
  {
    do
    {
      float v4 = (void *)*((void *)v3 + 5);
      if (v4)
      {
        PCSharedCount v5 = (void *)v4[4];
        if (v5)
        {
          v4[5] = v5;
          operator delete(v5);
        }
        PCSharedCount v6 = (void *)v4[1];
        if (v6)
        {
          void v4[2] = v6;
          operator delete(v6);
        }
        MEMORY[0x1BA9BFBA0](v4, 0x1010C40738DD8B8);
      }
      int v7 = (HGGLState *)*((void *)v3 + 1);
      if (v7)
      {
        do
        {
          int32x2_t v8 = (HGGLState **)v7;
          int v7 = *(HGGLState **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int32x2_t v8 = (HGGLState **)*((void *)v3 + 2);
          BOOL v9 = *v8 == v3;
          PCSharedCount v3 = (HGGLState *)v8;
        }
        while (!v9);
      }
      PCSharedCount v3 = (HGGLState *)v8;
    }
    while (v8 != v2);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this, this[1]);
  this[1] = 0;
  this[2] = 0;
  *this = (HGGLState *)v2;
}

void HGGLState::~HGGLState(HGGLState *this)
{
}

void HGGLState::startContextTracking(HGGLState *this)
{
  if (!*((unsigned char *)this + 40))
  {
    *((unsigned char *)this + 40) = 1;
    HGGLGetCurrentContext();
    *((PCSharedCount *)this + PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v2;
    PCSharedCount::PCSharedCount(&v2);
    *((void *)this + PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = *((void *)this + 4);
  }
}

void HGGLState::stopContextTracking(PCSharedCount *this)
{
  if (LOBYTE(this[5].var0))
  {
    v3.uint64_t var0 = this[3].var0;
    HGGLState::setCurrentContext((uint64_t)this, &v3.var0);
    PCSharedCount::PCSharedCount(&v3);
    LOBYTE(this[5].var0) = 0;
    HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v2, 0);
    this[4].uint64_t var0 = v2.var0;
    PCSharedCount::PCSharedCount(&v2);
    this[3].uint64_t var0 = this[4].var0;
  }
}

void sub_1B76F873C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

uint64_t HGGLState::getUniformLocation(uint64_t **a1, unint64_t a2, int a3, int a4)
{
  GLuint v4 = a2;
  if (a3 == 2)
  {
    return HGGLState::_getProgramLocalLocation(a1, a2, a4);
  }
  else if (a3 == 1)
  {
    return HGGLState::_getTextureMatrixLocation(a1, a2, a4);
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    UniformLocations = HGGLState::_getUniformLocations(a1, a2);
    uint64_t result = *(unsigned int *)UniformLocations;
    if (result == -2)
    {
      uint64_t result = glGetUniformLocation(v4, "hg_ProjectionMatrix");
      *(_DWORD *)UniformLocations = result;
    }
  }
  return result;
}

uint64_t HGGLState::_getTextureMatrixLocation(uint64_t **this, unint64_t a2, int a3)
{
  GLuint v4 = a2;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  UniformLocations = HGGLState::_getUniformLocations(this, a2);
  uint64_t v6 = a3;
  int32x2_t v8 = UniformLocations + 1;
  uint64_t v7 = UniformLocations[1];
  unint64_t v9 = (UniformLocations[2] - v7) >> 2;
  if (v9 <= a3)
  {
    unint64_t v10 = (a3 + 1);
    if (v10 <= v9)
    {
      if (v10 < v9) {
        UniformLocations[2] = v7 + 4 * v10;
      }
    }
    else
    {
      std::vector<int>::__append((std::vector<int> *)(UniformLocations + 1), v10 - v9, &UNKNOWN_LOC);
      uint64_t v7 = *v8;
    }
  }
  uint64_t result = *(unsigned int *)(v7 + 4 * a3);
  if (result == -2)
  {
    __int16 v29 = 0;
    long long v28 = *(_OWORD *)"hg_TextureMatrix";
    int v12 = a3 > 999;
    if (a3 > 9999) {
      ++v12;
    }
    if (a3 > 99) {
      ++v12;
    }
    if (a3 <= 9) {
      int v13 = 0;
    }
    else {
      int v13 = -1;
    }
    if (v12 == v13)
    {
      unsigned int v14 = 16;
    }
    else
    {
      if (a3 <= 9999) {
        unint64_t v15 = a3 > 999;
      }
      else {
        unint64_t v15 = (a3 > 999) + 1;
      }
      if (a3 > 99) {
        ++v15;
      }
      if (a3 > 9) {
        ++v15;
      }
      int v16 = format(char *,int,int)::div[v15];
      int v17 = a3 / v16;
      a3 %= v16;
      LOBYTE(v29) = v17 + 48;
      unint64_t v18 = v15 - 2;
      if (v15 < 2)
      {
        unsigned int v14 = 17;
      }
      else
      {
        int v19 = format(char *,int,int)::div[v15 - 1];
        int v20 = a3 / v19;
        a3 %= v19;
        HIBYTE(v29) = v20 + 48;
        if (v15 - 1 < 2)
        {
          unsigned int v14 = 18;
        }
        else
        {
          int v21 = format(char *,int,int)::div[v18];
          int v22 = a3 / v21;
          a3 %= v21;
          char v30 = v22 + 48;
          if (v18 < 2)
          {
            unsigned int v14 = 19;
          }
          else
          {
            int v23 = format(char *,int,int)::div[v15 - 3];
            int v24 = a3 / v23;
            a3 %= v23;
            char v31 = v24 + 48;
            unsigned int v14 = 20;
          }
        }
      }
    }
    float32x4_t v25 = (char *)&v28 + v14;
    *float32x4_t v25 = a3 + 48;
    v25[1] = 0;
    UniformLocatiouint64_t n = glGetUniformLocation(v4, (const GLchar *)&v28);
    uint64_t v27 = *v8;
    *(_DWORD *)(v27 + 4 * v6) = UniformLocation;
    return *(unsigned int *)(v27 + 4 * v6);
  }
  return result;
}

uint64_t HGGLState::_getProgramLocalLocation(uint64_t **this, unint64_t a2, int a3)
{
  GLuint v4 = a2;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  UniformLocations = HGGLState::_getUniformLocations(this, a2);
  uint64_t v6 = a3;
  int32x2_t v8 = UniformLocations + 4;
  uint64_t v7 = UniformLocations[4];
  unint64_t v9 = (UniformLocations[5] - v7) >> 2;
  if (v9 <= a3)
  {
    unint64_t v10 = (a3 + 1);
    if (v10 <= v9)
    {
      if (v10 < v9) {
        UniformLocations[5] = v7 + 4 * v10;
      }
    }
    else
    {
      std::vector<int>::__append((std::vector<int> *)(UniformLocations + 4), v10 - v9, &UNKNOWN_LOC);
      uint64_t v7 = *v8;
    }
  }
  uint64_t result = *(unsigned int *)(v7 + 4 * a3);
  if (result == -2)
  {
    strcpy(v28, "hg_ProgramLocal");
    *(void *)&v28[13] = 27745;
    int v12 = a3 > 999;
    if (a3 > 9999) {
      ++v12;
    }
    if (a3 > 99) {
      ++v12;
    }
    if (a3 <= 9) {
      int v13 = 0;
    }
    else {
      int v13 = -1;
    }
    if (v12 == v13)
    {
      int v14 = 15;
    }
    else
    {
      if (a3 <= 9999) {
        unint64_t v15 = a3 > 999;
      }
      else {
        unint64_t v15 = (a3 > 999) + 1;
      }
      if (a3 > 99) {
        ++v15;
      }
      if (a3 > 9) {
        ++v15;
      }
      int v16 = format(char *,int,int)::div[v15];
      int v17 = a3 / v16;
      a3 %= v16;
      v28[15] = v17 + 48;
      unint64_t v18 = v15 - 2;
      if (v15 < 2)
      {
        int v14 = 16;
      }
      else
      {
        int v19 = format(char *,int,int)::div[v15 - 1];
        int v20 = a3 / v19;
        a3 %= v19;
        v28[16] = v20 + 48;
        if (v15 - 1 < 2)
        {
          int v14 = 17;
        }
        else
        {
          int v21 = format(char *,int,int)::div[v18];
          int v22 = a3 / v21;
          a3 %= v21;
          v28[17] = v22 + 48;
          if (v18 < 2)
          {
            int v14 = 18;
          }
          else
          {
            int v23 = format(char *,int,int)::div[v15 - 3];
            int v24 = a3 / v23;
            a3 %= v23;
            v28[18] = v24 + 48;
            int v14 = 19;
          }
        }
      }
    }
    float32x4_t v25 = &v28[v14];
    *float32x4_t v25 = a3 + 48;
    v25[1] = 0;
    UniformLocatiouint64_t n = glGetUniformLocation(v4, v28);
    uint64_t v27 = *v8;
    *(_DWORD *)(v27 + 4 * v6) = UniformLocation;
    return *(unsigned int *)(v27 + 4 * v6);
  }
  return result;
}

uint64_t *HGGLState::_getUniformLocations(uint64_t **this, unint64_t a2)
{
  GLuint v4 = this[1];
  if (!v4) {
    goto LABEL_12;
  }
  PCSharedCount v5 = this + 1;
  uint64_t v6 = this[1];
  do
  {
    unint64_t v7 = v6[4];
    BOOL v8 = v7 >= a2;
    if (v7 >= a2) {
      unint64_t v9 = (uint64_t **)v6;
    }
    else {
      unint64_t v9 = (uint64_t **)(v6 + 1);
    }
    if (v8) {
      PCSharedCount v5 = (uint64_t **)v6;
    }
    uint64_t v6 = *v9;
  }
  while (*v9);
  if (v5 == this + 1 || (unint64_t)v5[4] > a2) {
LABEL_12:
  }
    operator new();
  do
  {
    while (1)
    {
      int v11 = (uint64_t **)v4;
      unint64_t v12 = v4[4];
      if (v12 <= a2) {
        break;
      }
      GLuint v4 = *v11;
      unint64_t v10 = v11;
      if (!*v11) {
        goto LABEL_18;
      }
    }
    if (v12 >= a2) {
      return v11[5];
    }
    GLuint v4 = v11[1];
  }
  while (v4);
  unint64_t v10 = v11 + 1;
LABEL_18:
  int v13 = (uint64_t *)v11;
  int v11 = (uint64_t **)operator new(0x30uLL);
  _OWORD v11[4] = (uint64_t *)a2;
  v11[5] = 0;
  *int v11 = 0;
  v11[1] = 0;
  v11[2] = v13;
  *unint64_t v10 = (uint64_t *)v11;
  int v14 = (uint64_t *)**this;
  unint64_t v15 = (uint64_t *)v11;
  if (v14)
  {
    *this = v14;
    unint64_t v15 = *v10;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(this[1], v15);
  this[2] = (uint64_t *)((char *)this[2] + 1);
  return v11[5];
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n, std::vector<int>::const_reference __x)
{
  std::vector<int>::pointer end = this->__end_;
  uint64_t value = this->__end_cap_.__value_;
  BOOL v8 = end;
  if (__n <= value - end)
  {
    if (__n)
    {
      std::vector<int>::size_type v16 = (__n - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v16 < 0xF || end < __x + 1 && &end[__n] > __x) {
        goto LABEL_45;
      }
      std::vector<int>::size_type v17 = v16 + 1;
      BOOL v8 = &end[v17 & 0x7FFFFFFFFFFFFFF8];
      float32x4_t v18 = vld1q_dup_f32((const float *)__x);
      int v19 = (float32x4_t *)(end + 4);
      uint64_t v20 = v17 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v19[-1] = v18;
        *int v19 = v18;
        v19 += 2;
        v20 -= 8;
      }
      while (v20);
      if (v17 != (v17 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_45:
        do
          *v8++ = *__x;
        while (v8 != &end[__n]);
      }
      BOOL v8 = &end[__n];
    }
    this->__end_ = v8;
  }
  else
  {
    begiuint64_t n = this->__begin_;
    uint64_t v10 = (char *)end - (char *)this->__begin_;
    uint64_t v11 = v10 >> 2;
    unint64_t v12 = (v10 >> 2) + __n;
    if (v12 >> 62) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v13 = (char *)value - (char *)begin;
    if (v13 >> 1 > v12) {
      unint64_t v12 = v13 >> 1;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v15 = operator new(4 * v14);
    }
    else
    {
      unint64_t v15 = 0;
    }
    int v21 = (int *)&v15[4 * v11];
    int v22 = &v21[__n];
    std::vector<int>::size_type v23 = (__n - 1) & 0x3FFFFFFFFFFFFFFFLL;
    int v24 = v21;
    if (v23 < 0x13) {
      goto LABEL_46;
    }
    if (v21 < __x + 1)
    {
      int v24 = (int *)&v15[4 * v11];
      if (&v15[4 * __n + v10] > (unsigned char *)__x) {
        goto LABEL_46;
      }
    }
    std::vector<int>::size_type v25 = v23 + 1;
    int v24 = &v21[v25 & 0x7FFFFFFFFFFFFFF8];
    float32x4_t v26 = vld1q_dup_f32((const float *)__x);
    uint64_t v27 = (float32x4_t *)&v15[4 * v11 + 16];
    uint64_t v28 = v25 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v27[-1] = v26;
      *uint64_t v27 = v26;
      v27 += 2;
      v28 -= 8;
    }
    while (v28);
    if (v25 != (v25 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_46:
      do
        *v24++ = *__x;
      while (v24 != v22);
    }
    if (end != begin)
    {
      unint64_t v29 = (char *)end - (char *)begin - 4;
      if (v29 < 0x2C) {
        goto LABEL_47;
      }
      if ((unint64_t)((char *)end - &v15[v10]) < 0x20) {
        goto LABEL_47;
      }
      uint64_t v30 = (v29 >> 2) + 1;
      uint64_t v31 = 4 * (v30 & 0x7FFFFFFFFFFFFFF8);
      BOOL v8 = &end[v31 / 0xFFFFFFFFFFFFFFFCLL];
      int v21 = (int *)((char *)v21 - v31);
      uint64_t v32 = &v15[4 * v11 - 16];
      int8x16_t v33 = (long long *)(end - 4);
      uint64_t v34 = v30 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v35 = *v33;
        *(v32 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *(v33 - 1);
        *uint64_t v32 = v35;
        v32 -= 2;
        v33 -= 2;
        v34 -= 8;
      }
      while (v34);
      if (v30 != (v30 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_47:
        do
        {
          int v36 = *--v8;
          *--int v21 = v36;
        }
        while (v8 != begin);
      }
    }
    this->__begin_ = v21;
    this->__end_ = v22;
    this->__end_cap_.__value_ = (int *)&v15[4 * v14];
    if (begin)
    {
      operator delete(begin);
    }
  }
}

FILE *HGIQA::IQAWriteFile(const char *a1, long long *a2, char *a3)
{
  uint64_t result = fopen(a1, "w");
  long long v6 = a2[1];
  long long __ptr = *a2;
  *(_OWORD *)std::vector<int>::size_type v16 = v6;
  *(_OWORD *)&v16[12] = *(long long *)((char *)a2 + 28);
  if (result)
  {
    unint64_t v7 = result;
    LOBYTE(__ptr) = __ptr | 0x80;
    if (fwrite(&__ptr, 1uLL, 1uLL, result) != 1
      || fwrite((char *)&__ptr + 4, 4uLL, 1uLL, v7) != 1
      || fwrite((char *)&__ptr + 8, 4uLL, 1uLL, v7) != 1)
    {
      goto LABEL_30;
    }
    if ((*(_DWORD *)&v16[8] - 31) > 1)
    {
      if ((*(_DWORD *)&v16[8] - 19) >= 2)
      {
        *(_DWORD *)&v16[20] = 0;
        *(_DWORD *)&v16[24] = 0;
      }
    }
    else
    {
      if (HIDWORD(__ptr) != 1)
      {
        *(_DWORD *)&v16[20] = HIDWORD(__ptr);
        HIDWORD(__ptr) = 1;
      }
      if (*(_DWORD *)v16 != 1)
      {
        *(_DWORD *)&v16[24] = *(_DWORD *)v16;
        *(_DWORD *)std::vector<int>::size_type v16 = 1;
      }
    }
    if (fwrite((const void *)((unint64_t)&__ptr | 0xC), 4uLL, 1uLL, v7) != 1 || fwrite(v16, 4uLL, 1uLL, v7) != 1) {
      goto LABEL_30;
    }
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    int v8 = *(_DWORD *)&v16[8];
    HGIQA::GetPixelInfo(*(int *)&v16[8], &v14, &v13, 0, 0);
    uint64_t v9 = *(int *)&v16[4];
    size_t v10 = v8 == 24 ? vcvts_n_u32_f32(ceilf((float)SHIDWORD(__ptr) / 6.0), 4uLL) : v14 * SHIDWORD(__ptr) * v13;
    if (v10 < *(int *)&v16[4]) {
      *(_DWORD *)&v16[4] = v10;
    }
    if (fwrite(&v16[4], 4uLL, 1uLL, v7) != 1
      || fwrite(&v16[8], 4uLL, 1uLL, v7) != 1
      || fwrite(&v16[12], 4uLL, 1uLL, v7) != 1
      || fwrite(&v16[16], 4uLL, 1uLL, v7) != 1
      || fwrite(&v16[20], 4uLL, 1uLL, v7) != 1
      || fwrite(&v16[24], 4uLL, 1uLL, v7) != 1)
    {
      goto LABEL_30;
    }
    if ((*(_DWORD *)&v16[8] - 31) > 1)
    {
      HGIQA::GetPixelInfo(*(int *)&v16[8], &v14, &v13, 0, 0);
      if (v10 != v9)
      {
        if (*(int *)v16 >= 1)
        {
          uint64_t v12 = 0;
          while (fwrite(a3, v10, 1uLL, v7) == 1)
          {
            ++v12;
            a3 += v9;
            if (v12 >= *(int *)v16) {
              goto LABEL_36;
            }
          }
          goto LABEL_30;
        }
        goto LABEL_36;
      }
      size_t v11 = *(int *)v16 * (uint64_t)*(int *)&v16[4];
    }
    else
    {
      size_t v11 = ((uint64_t)*(int *)&v16[4] << (*(_DWORD *)&v16[12] != 0))
          + ((uint64_t)*(int *)&v16[4] << (*(_DWORD *)&v16[12] != 0)) * (SDWORD2(__ptr) - (uint64_t)SDWORD1(__ptr));
    }
    if (fwrite(a3, v11, 1uLL, v7) != 1)
    {
LABEL_30:
      fclose(v7);
      return 0;
    }
LABEL_36:
    fclose(v7);
    return (FILE *)1;
  }
  return result;
}

const char *HGIQA::GetPixelInfo(int a1, void *a2, void *a3, int *a4, int *a5)
{
  switch(a1)
  {
    case 0:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 22;
      }
      uint64_t result = "r408";
      if (a5)
      {
        int v6 = 4;
        goto LABEL_313;
      }
      return result;
    case 1:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 2;
      }
      if (a4) {
        *a4 = 14;
      }
      uint64_t result = "2vuy_cby0cry1";
      if (a5) {
        goto LABEL_233;
      }
      return result;
    case 2:
      if (a2) {
        *a2 = 4;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 29;
      }
      uint64_t result = "r4fl";
      if (a5)
      {
        int v6 = 7;
        goto LABEL_313;
      }
      return result;
    case 3:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 22;
      }
      uint64_t result = "ARGB 8 bit unsigned int";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 4:
      if (a2) {
        *a2 = 2;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 26;
      }
      uint64_t result = "ARGB 16 bit unsigned int";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 5:
      if (a2) {
        *a2 = 4;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 29;
      }
      uint64_t result = "ARGB 32 bit float";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 6:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 0;
      }
      uint64_t result = "ABGR 8 bit unsigned int";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 7:
      if (a2) {
        *a2 = 2;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 0;
      }
      uint64_t result = "ABGR 16 bit unsigned int";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 8:
      if (a2) {
        *a2 = 4;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 0;
      }
      uint64_t result = "ABGR 32 bit float";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 9:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 24;
      }
      uint64_t result = "RGBA 8 bit float";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 10:
      if (a2) {
        *a2 = 2;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 27;
      }
      uint64_t result = "RGBA 16 bit float";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 11:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 1;
      }
      if (a4) {
        *a4 = 1;
      }
      uint64_t result = "A 8 bit unsigned int";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 12:
      if (a2) {
        *a2 = 2;
      }
      if (a3) {
        *a3 = 1;
      }
      if (a4) {
        *a4 = 3;
      }
      uint64_t result = "A 16 bit unsigned int";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 13:
      if (a2) {
        *a2 = 4;
      }
      if (a3) {
        *a3 = 1;
      }
      if (a4) {
        *a4 = 7;
      }
      uint64_t result = "A 32 bit float";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 14:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 2;
      }
      if (a4) {
        *a4 = 10;
      }
      uint64_t result = "AL 8 bit unsigned int";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 15:
      if (a2) {
        *a2 = 2;
      }
      if (a3) {
        *a3 = 2;
      }
      if (a4) {
        *a4 = 11;
      }
      uint64_t result = "AL 16 bit unsigned int";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 16:
      if (a2) {
        *a2 = 4;
      }
      if (a3) {
        *a3 = 2;
      }
      if (a4) {
        *a4 = 13;
      }
      uint64_t result = "AL 32 bit float";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 18:
      if (a2) {
        *a2 = 2;
      }
      if (a3) {
        *a3 = 2;
      }
      if (a4) {
        *a4 = 12;
      }
      uint64_t result = "AL half float";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 19:
      if (a2) {
        *a2 = 4;
      }
      if (a3) {
        *a3 = 2;
      }
      if (a4) {
        *a4 = 13;
      }
      uint64_t result = "Optical Flow Progressive";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 20:
      if (a2) {
        *a2 = 4;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 28;
      }
      uint64_t result = "Optical Flow Interlaced";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 21:
      if (a2) {
        *a2 = 8;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 0;
      }
      uint64_t result = "LABC";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 22:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 22;
      }
      uint64_t result = "y408";
      if (a5)
      {
        int v6 = 5;
        goto LABEL_313;
      }
      return result;
    case 23:
      if (a2) {
        *a2 = 2;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 26;
      }
      uint64_t result = "y416";
      if (a5)
      {
        int v6 = 6;
        goto LABEL_313;
      }
      return result;
    case 24:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 31;
      }
      uint64_t result = "v210";
      if (a5)
      {
        int v6 = 2;
        goto LABEL_313;
      }
      return result;
    case 25:
      if (a2) {
        *a2 = 2;
      }
      if (a3) {
        *a3 = 2;
      }
      if (a4) {
        *a4 = 16;
      }
      uint64_t result = "v216";
      if (a5)
      {
        int v6 = 3;
        goto LABEL_313;
      }
      return result;
    case 26:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 32;
      }
      uint64_t result = "r10k";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 27:
      if (a2) {
        *a2 = 2;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 33;
      }
      uint64_t result = "b64a";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 28:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 2;
      }
      if (a4) {
        *a4 = 15;
      }
      uint64_t result = "2vuy_y0cby1cr";
      if (a5)
      {
LABEL_233:
        int v6 = 1;
        goto LABEL_313;
      }
      return result;
    case 29:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 23;
      }
      uint64_t result = "BGRA 8 bit unsigned int";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 30:
      if (a2) {
        *a2 = 4;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 29;
      }
      uint64_t result = "AYCbCr float";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 31:
      if (a2) {
        *a2 = 8;
      }
      if (a3) {
        *a3 = 13;
      }
      if (a4) {
        *a4 = 0;
      }
      uint64_t result = "DominantMotionTracker Original Motion Data";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 32:
      if (a2) {
        *a2 = 8;
      }
      if (a3) {
        *a3 = 17;
      }
      if (a4) {
        *a4 = 0;
      }
      uint64_t result = "DominantMotionTracker Processed Motion Data";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 33:
      if (a2) {
        *a2 = 2;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 0;
      }
      uint64_t result = "ARGB half float";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 34:
      if (a2) {
        *a2 = 4;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4) {
        *a4 = 28;
      }
      uint64_t result = "RGBA float";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 35:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 3;
      }
      if (a4) {
        *a4 = 17;
      }
      uint64_t result = "RGB 8 bit unsigned int";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 36:
      if (a2) {
        *a2 = 1;
      }
      if (a3) {
        *a3 = 3;
      }
      if (a4) {
        *a4 = 18;
      }
      uint64_t result = "BGR 8 bit unsigned int";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    case 37:
      if (a2) {
        *a2 = 2;
      }
      if (a3) {
        *a3 = 3;
      }
      if (!a4) {
        goto LABEL_311;
      }
      int v7 = 19;
      goto LABEL_310;
    case 38:
      if (a2) {
        *a2 = 2;
      }
      if (a3) {
        *a3 = 4;
      }
      if (a4)
      {
        int v7 = 25;
LABEL_310:
        *a4 = v7;
      }
LABEL_311:
      uint64_t result = "RGB 16 bit unsigned int";
      if (a5) {
        goto LABEL_312;
      }
      return result;
    default:
      if (a2) {
        *a2 = 0;
      }
      if (a3) {
        *a3 = 0;
      }
      if (a4) {
        *a4 = 0;
      }
      uint64_t result = "Unknown pixel type";
      if (!a5) {
        return result;
      }
LABEL_312:
      int v6 = 0;
LABEL_313:
      *a5 = v6;
      return result;
  }
}

FILE *HGIQA::WriteBitmap(HGIQA *this, const char *a2, HGBitmap *a3)
{
  uint64_t v3 = *((unsigned int *)a2 + 4);
  if (!a3)
  {
    if ((0x3BFCFFC8AuLL >> v3))
    {
      goto LABEL_9;
    }
    return 0;
  }
  if (v3 == 13)
  {
    int v4 = 19;
    goto LABEL_9;
  }
  if (v3 != 28) {
    return 0;
  }
  int v4 = 20;
LABEL_9:
  uint64_t v6 = 0x100000000;
  int v7 = 1;
  int32x2_t v8 = vsub_s32(*(int32x2_t *)(a2 + 28), *(int32x2_t *)(a2 + 20));
  int v9 = *((void *)a2 + 8);
  int v10 = v4;
  uint64_t v12 = 0;
  uint64_t v11 = 0;
  return HGIQA::IQAWriteFile((const char *)this, (long long *)&v6, *((char **)a2 + 10));
}

uint64_t HGLoggerUtils::bytesPrettyString(HGLoggerUtils *this)
{
  if (this) {
    int v1 = (int)(log2((double)(unint64_t)this) / 10.0);
  }
  else {
    int v1 = 0;
  }
  if (v1 >= 4) {
    int v2 = 4;
  }
  else {
    int v2 = v1;
  }
  ldexp(1.0, 10 * v2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v9);
  uint64_t v3 = v10[0];
  *(_DWORD *)((char *)&v10[1] + *(void *)(v10[0] - 24)) = *(_DWORD *)((unsigned char *)&v10[1] + *(void *)(v10[0] - 24)) & 0xFFFFFEFB | 4;
  *(void *)((char *)&v10[2] + *(void *)(v3 - 24)) = 1;
  int v4 = (void *)std::ostream::operator<<();
  PCSharedCount v5 = HGLoggerUtils::bytesPrettyString(unsigned long long)::units[v2];
  size_t v6 = strlen(v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v5, v6);
  std::stringbuf::str();
  v9[0] = *MEMORY[0x1E4FBA408];
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v9 + *(void *)(v9[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v10[0] = v7;
  v10[1] = MEMORY[0x1E4FBA470] + 16;
  if (v11 < 0) {
    operator delete((void *)v10[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BA9BFAB0](&v12);
}

void sub_1B76F9F34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B76F9F48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGLoggerUtils::timePrettyString(HGLoggerUtils *this)
{
  if (this) {
    int v1 = (int)log10((double)(unint64_t)this) / 3;
  }
  else {
    int v1 = 0;
  }
  if (v1 >= 3) {
    int v2 = 3;
  }
  else {
    int v2 = v1;
  }
  __exp10((double)(3 * v2));
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v9);
  uint64_t v3 = v10[0];
  *(_DWORD *)((char *)&v10[1] + *(void *)(v10[0] - 24)) = *(_DWORD *)((unsigned char *)&v10[1] + *(void *)(v10[0] - 24)) & 0xFFFFFEFB | 4;
  *(void *)((char *)&v10[2] + *(void *)(v3 - 24)) = 1;
  int v4 = (void *)std::ostream::operator<<();
  PCSharedCount v5 = HGLoggerUtils::timePrettyString(unsigned long long)::units[v2];
  size_t v6 = strlen(v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v5, v6);
  std::stringbuf::str();
  v9[0] = *MEMORY[0x1E4FBA408];
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v9 + *(void *)(v9[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v10[0] = v7;
  v10[1] = MEMORY[0x1E4FBA470] + 16;
  if (v11 < 0) {
    operator delete((void *)v10[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BA9BFAB0](&v12);
}

void sub_1B76FA1BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B76FA1D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t MatrixPrettyString<double>(uint64_t a1, int a2, int a3, const void **a4, const void **a5)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v46);
  int v8 = *((char *)a4 + 23);
  if (v8 >= 0) {
    size_t v9 = *((unsigned __int8 *)a4 + 23);
  }
  else {
    size_t v9 = (size_t)a4[1];
  }
  unint64_t v10 = v9 + 8;
  if (v9 + 8 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v10 >= 0x17)
  {
    uint64_t v12 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v12 = v10 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_dst = (long long *)operator new(v12 + 1);
    *((void *)&__dst + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v9 + 8;
    int64_t v45 = v13 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_11;
  }
  int64_t v45 = 0;
  long long __dst = 0uLL;
  p_dst = &__dst;
  HIBYTE(v45) = v9 + 8;
  if (v9)
  {
LABEL_11:
    if (v8 >= 0) {
      uint64_t v14 = a4;
    }
    else {
      uint64_t v14 = *a4;
    }
    memmove(p_dst, v14, v9);
  }
  uint64_t v15 = 0;
  uint64_t v38 = a2 & ~(a2 >> 31);
  uint64_t v37 = a2;
  uint64_t v16 = 8 * a2;
  strcpy((char *)p_dst + v9, "    [ [ ");
  while (v15 != v38)
  {
    if (v45 >= 0) {
      int v19 = &__dst;
    }
    else {
      int v19 = (long long *)__dst;
    }
    if (v45 >= 0) {
      uint64_t v20 = HIBYTE(v45);
    }
    else {
      uint64_t v20 = *((void *)&__dst + 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v46, (uint64_t)v19, v20);
    uint64_t v40 = v15;
    int v21 = *((char *)a5 + 23);
    if (v21 >= 0) {
      size_t v22 = *((unsigned __int8 *)a5 + 23);
    }
    else {
      size_t v22 = (size_t)a5[1];
    }
    unint64_t v23 = v22 + 8;
    if (v22 + 8 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v23 >= 0x17)
    {
      int v36 = *((char *)a5 + 23);
      uint64_t v25 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v23 | 7) != 0x17) {
        uint64_t v25 = v23 | 7;
      }
      uint64_t v35 = v25 + 1;
      int v24 = (long long *)operator new(v25 + 1);
      *((void *)&v42 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v22 + 8;
      unint64_t v43 = v35 | 0x8000000000000000;
      *(void *)&long long v42 = v24;
      int v21 = v36;
    }
    else
    {
      unint64_t v43 = 0;
      long long v42 = 0uLL;
      int v24 = &v42;
      HIBYTE(v4PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v22 + 8;
      if (!v22) {
        goto LABEL_44;
      }
    }
    if (v21 >= 0) {
      float32x4_t v26 = a5;
    }
    else {
      float32x4_t v26 = *a5;
    }
    memmove(v24, v26, v22);
LABEL_44:
    strcpy((char *)v24 + v22, "      [ ");
    if (SHIBYTE(v45) < 0) {
      operator delete((void *)__dst);
    }
    long long __dst = v42;
    int64_t v45 = v43;
    uint64_t v28 = a3 - 1;
    uint64_t v27 = a3 & ~(a3 >> 31);
    uint64_t v29 = a1;
    while (v27)
    {
      uint64_t v30 = v46;
      *(_DWORD *)((char *)v47 + *(void *)(v46 - 24)) = *(_DWORD *)((unsigned char *)v47 + *(void *)(v46 - 24)) & 0xFFFFFEFB | 4;
      *(void *)((char *)&v47[1] + *(void *)(v30 - 24)) = 8;
      uint64_t v31 = (void *)std::ostream::operator<<();
      if (v28) {
        uint64_t v32 = ", ";
      }
      else {
        uint64_t v32 = " ";
      }
      if (v28) {
        uint64_t v33 = 2;
      }
      else {
        uint64_t v33 = 1;
      }
      --v27;
      v29 += v16;
      --v28;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)v32, v33);
    }
    uint64_t v15 = v40 + 1;
    if (v40 + 1 == v37) {
      std::vector<int>::size_type v17 = "] ]";
    }
    else {
      std::vector<int>::size_type v17 = "]\n";
    }
    if (v40 + 1 == v37) {
      uint64_t v18 = 3;
    }
    else {
      uint64_t v18 = 2;
    }
    a1 += 8;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v46, (uint64_t)v17, v18);
  }
  std::stringbuf::str();
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)__dst);
  }
  uint64_t v46 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v47[-1] + *(void *)(v46 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v47[0] = MEMORY[0x1E4FBA470] + 16;
  if (v48 < 0) {
    operator delete((void *)v47[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v49);
}

void sub_1B76FA630(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a30);
  _Unwind_Resume(a1);
}

uint64_t MatrixPrettyString<float>(uint64_t a1, int a2, int a3, const void **a4, const void **a5)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v46);
  int v8 = *((char *)a4 + 23);
  if (v8 >= 0) {
    size_t v9 = *((unsigned __int8 *)a4 + 23);
  }
  else {
    size_t v9 = (size_t)a4[1];
  }
  unint64_t v10 = v9 + 8;
  if (v9 + 8 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v10 >= 0x17)
  {
    uint64_t v12 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v12 = v10 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_dst = (long long *)operator new(v12 + 1);
    *((void *)&__dst + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v9 + 8;
    int64_t v45 = v13 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_11;
  }
  int64_t v45 = 0;
  long long __dst = 0uLL;
  p_dst = &__dst;
  HIBYTE(v45) = v9 + 8;
  if (v9)
  {
LABEL_11:
    if (v8 >= 0) {
      uint64_t v14 = a4;
    }
    else {
      uint64_t v14 = *a4;
    }
    memmove(p_dst, v14, v9);
  }
  uint64_t v15 = 0;
  uint64_t v38 = a2 & ~(a2 >> 31);
  uint64_t v37 = a2;
  uint64_t v16 = 4 * a2;
  strcpy((char *)p_dst + v9, "    [ [ ");
  while (v15 != v38)
  {
    if (v45 >= 0) {
      int v19 = &__dst;
    }
    else {
      int v19 = (long long *)__dst;
    }
    if (v45 >= 0) {
      uint64_t v20 = HIBYTE(v45);
    }
    else {
      uint64_t v20 = *((void *)&__dst + 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v46, (uint64_t)v19, v20);
    uint64_t v40 = v15;
    int v21 = *((char *)a5 + 23);
    if (v21 >= 0) {
      size_t v22 = *((unsigned __int8 *)a5 + 23);
    }
    else {
      size_t v22 = (size_t)a5[1];
    }
    unint64_t v23 = v22 + 8;
    if (v22 + 8 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v23 >= 0x17)
    {
      int v36 = *((char *)a5 + 23);
      uint64_t v25 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v23 | 7) != 0x17) {
        uint64_t v25 = v23 | 7;
      }
      uint64_t v35 = v25 + 1;
      int v24 = (long long *)operator new(v25 + 1);
      *((void *)&v42 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v22 + 8;
      unint64_t v43 = v35 | 0x8000000000000000;
      *(void *)&long long v42 = v24;
      int v21 = v36;
    }
    else
    {
      unint64_t v43 = 0;
      long long v42 = 0uLL;
      int v24 = &v42;
      HIBYTE(v4PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v22 + 8;
      if (!v22) {
        goto LABEL_44;
      }
    }
    if (v21 >= 0) {
      float32x4_t v26 = a5;
    }
    else {
      float32x4_t v26 = *a5;
    }
    memmove(v24, v26, v22);
LABEL_44:
    strcpy((char *)v24 + v22, "      [ ");
    if (SHIBYTE(v45) < 0) {
      operator delete((void *)__dst);
    }
    long long __dst = v42;
    int64_t v45 = v43;
    uint64_t v28 = a3 - 1;
    uint64_t v27 = a3 & ~(a3 >> 31);
    uint64_t v29 = a1;
    while (v27)
    {
      uint64_t v30 = v46;
      *(_DWORD *)((char *)v47 + *(void *)(v46 - 24)) = *(_DWORD *)((unsigned char *)v47 + *(void *)(v46 - 24)) & 0xFFFFFEFB | 4;
      *(void *)((char *)&v47[1] + *(void *)(v30 - 24)) = 8;
      uint64_t v31 = (void *)std::ostream::operator<<();
      if (v28) {
        uint64_t v32 = ", ";
      }
      else {
        uint64_t v32 = " ";
      }
      if (v28) {
        uint64_t v33 = 2;
      }
      else {
        uint64_t v33 = 1;
      }
      --v27;
      v29 += v16;
      --v28;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)v32, v33);
    }
    uint64_t v15 = v40 + 1;
    if (v40 + 1 == v37) {
      std::vector<int>::size_type v17 = "] ]";
    }
    else {
      std::vector<int>::size_type v17 = "]\n";
    }
    if (v40 + 1 == v37) {
      uint64_t v18 = 3;
    }
    else {
      uint64_t v18 = 2;
    }
    a1 += 4;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v46, (uint64_t)v17, v18);
  }
  std::stringbuf::str();
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)__dst);
  }
  uint64_t v46 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v47[-1] + *(void *)(v46 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v47[0] = MEMORY[0x1E4FBA470] + 16;
  if (v48 < 0) {
    operator delete((void *)v47[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v49);
}

void sub_1B76FAAC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a30);
  _Unwind_Resume(a1);
}

uint64_t HGLogger::indent(uint64_t this)
{
  return this;
}

uint64_t HGLogger::setLevel(HGLogger *this, const char *a2)
{
  int v2 = (int)a2;
  int v4 = (const char *)this;
  pthread_mutex_lock(&HGLC::_ctxsLock);
  if (!HGLC::getContexts(void)::contexts) {
    operator new();
  }
  PCSharedCount v5 = &v4;
  *((_DWORD *)std::__tree<std::__value_type<char const*,int>,std::__map_value_compare<char const*,std::__value_type<char const*,int>,HGLC::ltstr,true>,std::allocator<std::__value_type<char const*,int>>>::__emplace_unique_key_args<char const*,std::piecewise_construct_t const&,std::tuple<char const* const&>,std::tuple<>>((uint64_t **)HGLC::getContexts(void)::contexts, &v4, (uint64_t)&std::piecewise_construct, &v5)+ 10) = v2;
  return pthread_mutex_unlock(&HGLC::_ctxsLock);
}

uint64_t HGLogger::getLevel(HGLogger *this, const char *a2)
{
  pthread_mutex_lock(&HGLC::_ctxsLock);
  if (!HGLC::getContexts(void)::contexts) {
    operator new();
  }
  uint64_t v3 = HGLC::getContexts(void)::contexts + 8;
  uint64_t v4 = *(void *)(HGLC::getContexts(void)::contexts + 8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = HGLC::getContexts(void)::contexts + 8;
  do
  {
    int v6 = strcmp(*(const char **)(v4 + 32), (const char *)this);
    uint64_t v7 = (uint64_t *)(v4 + 8);
    if (v6 >= 0)
    {
      uint64_t v7 = (uint64_t *)v4;
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v7;
  }
  while (*v7);
  if (v5 == v3 || strcmp((const char *)this, *(const char **)(v5 + 32)) < 0) {
LABEL_10:
  }
    uint64_t v8 = 0;
  else {
    uint64_t v8 = *(unsigned int *)(v5 + 40);
  }
  pthread_mutex_unlock(&HGLC::_ctxsLock);
  return v8;
}

void HGLogger::log(HGLogger *this, const char *a2, HGLogger *a3, const char *a4, char *a5, ...)
{
  va_start(va, a5);
  HGLogger::vlog(this, a2, a3, va, a5);
}

void HGLogger::vlog(HGLogger *this, const char *a2, HGLogger *a3, const char *a4, char *a5)
{
  _OWORD v47[3] = *(std::locale *)MEMORY[0x1E4F143B8];
  va_list v46 = (va_list)a4;
  unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
  if ((int)a2 < 1 || (v5 & 1) == 0 || (int)HGLogger::getLevel(this, a2) < (int)a2) {
    return;
  }
  HGLogger::getFormatPreamble((uint64_t *)__p, a3, v7);
  if (v36 >= 0) {
    uint64_t v8 = __p;
  }
  else {
    uint64_t v8 = (void **)__p[0];
  }
  size_t v9 = strlen((const char *)v8);
  if (v9 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  unint64_t v10 = (void *)v9;
  if (v9 >= 0x17)
  {
    uint64_t v22 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v22 = v9 | 7;
    }
    uint64_t v23 = v22 + 1;
    char v11 = (void **)operator new(v22 + 1);
    __dst[1] = v10;
    int64_t v45 = v23 | 0x8000000000000000;
    __dst[0] = v11;
LABEL_24:
    memmove(v11, v8, (size_t)v10);
    *((unsigned char *)v10 + (void)v1PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
    if ((SHIBYTE(v36) & 0x80000000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_25;
  }
  HIBYTE(v45) = v9;
  char v11 = __dst;
  if (v9) {
    goto LABEL_24;
  }
  LOBYTE(__dst[0]) = 0;
  if ((SHIBYTE(v36) & 0x80000000) == 0) {
    goto LABEL_11;
  }
LABEL_25:
  operator delete(__p[0]);
LABEL_11:
  if (v45 >= 0) {
    uint64_t v12 = (const char *)__dst;
  }
  else {
    uint64_t v12 = (const char *)__dst[0];
  }
  uint64_t v13 = fmtcheck(v12, (const char *)a3);
  va_list v43 = v46;
  int v14 = vsnprintf(0, 0, v13, v46);
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v40 = 0;
  int v41 = 0;
  long long v42 = 0;
  int v17 = v14 + 1;
  if (v14 != -1)
  {
    if (v14 <= -2) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    size_t v18 = v17;
    uint64_t v16 = (char *)operator new(v17);
    uint64_t v15 = &v16[v18];
    uint64_t v40 = v16;
    long long v42 = &v16[v18];
    bzero(v16, v18);
    int v41 = &v16[v18];
  }
  vsnprintf(v16, v15 - v16, v13, v43);
  size_t v19 = strlen(v16);
  if (v19 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v20 = v19;
  if (v19 >= 0x17)
  {
    uint64_t v24 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17) {
      uint64_t v24 = v19 | 7;
    }
    uint64_t v25 = v24 + 1;
    int v21 = operator new(v24 + 1);
    size_t v33 = v20;
    int64_t v34 = v25 | 0x8000000000000000;
    uint64_t v32 = v21;
  }
  else
  {
    HIBYTE(v3PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v19;
    int v21 = &v32;
    if (!v19) {
      goto LABEL_30;
    }
  }
  memcpy(v21, v16, v20);
LABEL_30:
  *((unsigned char *)v21 + v20) = 0;
  std::istringstream::basic_istringstream[abi:ne180100]((uint64_t)__p, (uint64_t)&v32, 8);
  if (SHIBYTE(v34) < 0) {
    operator delete(v32);
  }
  uint64_t v32 = 0;
  size_t v33 = 0;
  int64_t v34 = 0;
  float32x4_t v26 = (std::locale::id *)MEMORY[0x1E4FBA258];
  uint64_t v27 = MEMORY[0x1E4F14500];
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)__p + *((void *)__p[0] - 3)));
    uint64_t v28 = std::locale::use_facet(v47, v26);
    unsigned __int8 v29 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v28->__vftable[2].~facet_0)(v28, 10);
    std::locale::~locale(v47);
    uint64_t v30 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(__p, (uint64_t)&v32, v29);
    if ((*((unsigned char *)v30 + *(void *)(*v30 - 24) + 32) & 5) != 0) {
      break;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      if (v34 >= 0) {
        uint64_t v31 = (std::locale::__imp *)&v32;
      }
      else {
        uint64_t v31 = (std::locale::__imp *)v32;
      }
      LODWORD(v47[0].__locale_) = 136315138;
      *(std::locale::__imp **)((char *)&v47[0].__locale_ + PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v31;
      _os_log_impl(&dword_1B73F3000, v27, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)v47, 0xCu);
    }
  }
  if (SHIBYTE(v34) < 0) {
    operator delete(v32);
  }
  __p[0] = *(void **)MEMORY[0x1E4FBA410];
  *(void **)((char *)__p + *((void *)__p[0] - 3)) = *(void **)(MEMORY[0x1E4FBA410] + 24);
  uint64_t v36 = MEMORY[0x1E4FBA470] + 16;
  if (v38 < 0) {
    operator delete(v37);
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1BA9BFAB0](&v39);
  if (v40) {
    operator delete(v40);
  }
  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_1B76FB184(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  uint64_t v25 = *(void **)(v23 - 176);
  if (v25) {
    operator delete(v25);
  }
  if (*(char *)(v23 - 121) < 0) {
    operator delete(*(void **)(v23 - 144));
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGLogger::getFormatPreamble(HGLogger *this, const char *a2)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v6);
  int v3 = atomic_load((unsigned int *)&HGLogger::_indent);
  if (v3 >= 1)
  {
    do
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"| ", 2);
      --v3;
    }
    while (v3);
  }
  size_t v4 = strlen((const char *)this);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)this, v4);
  std::stringbuf::str();
  v6[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v6 + *(void *)(v6[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v6[1] = MEMORY[0x1E4FBA470] + 16;
  if (v7 < 0) {
    operator delete((void *)v6[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v8);
}

void sub_1B76FB3AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B76FB3C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::istringstream::basic_istringstream[abi:ne180100](uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = MEMORY[0x1E4FBA490] + 64;
  *(void *)(a1 + 120) = MEMORY[0x1E4FBA490] + 64;
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA410] + 16);
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA410] + 8);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  uint64_t v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 16));
  uint64_t v9 = MEMORY[0x1E4FBA490] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  *(void *)a1 = v9;
  *(void *)(a1 + 120) = v5;
  std::streambuf::basic_streambuf();
  uint64_t v10 = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 16) = v10;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 11PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = a3 | 8;
  std::stringbuf::str();
  return a1;
}

void sub_1B76FB568(_Unwind_Exception *a1)
{
  if (*(char *)(v2 + 103) < 0) {
    operator delete(*v3);
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1BA9BFAB0](v1);
  _Unwind_Resume(a1);
}

uint64_t std::istringstream::~istringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA410];
  uint64_t v3 = *MEMORY[0x1E4FBA410];
  *(void *)a1 = *MEMORY[0x1E4FBA410];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1BA9BFAB0](a1 + 120);
  return a1;
}

void HGLogger::print(HGLogger *this, const char *a2, char *a3, ...)
{
  va_start(va, a3);
  HGLogger::vprint(this, va, a3);
}

void HGLogger::vprint(HGLogger *this, const char *a2, char *a3)
{
  _OWORD v44[3] = *(std::locale *)MEMORY[0x1E4F143B8];
  va_list v43 = (va_list)a2;
  unsigned __int8 v3 = atomic_load(HGLogger::_enabled);
  if ((v3 & 1) == 0) {
    return;
  }
  HGLogger::getFormatPreamble((uint64_t *)__p, this, a2);
  if (v33 >= 0) {
    uint64_t v5 = __p;
  }
  else {
    uint64_t v5 = (void **)__p[0];
  }
  size_t v6 = strlen((const char *)v5);
  if (v6 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (void *)v6;
  if (v6 >= 0x17)
  {
    uint64_t v19 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v19 = v6 | 7;
    }
    uint64_t v20 = v19 + 1;
    uint64_t v8 = (void **)operator new(v19 + 1);
    __dst[1] = v7;
    int64_t v42 = v20 | 0x8000000000000000;
    __dst[0] = v8;
LABEL_22:
    memmove(v8, v5, (size_t)v7);
    *((unsigned char *)v7 + (void)v8) = 0;
    if ((SHIBYTE(v33) & 0x80000000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_23;
  }
  HIBYTE(v4PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v6;
  uint64_t v8 = __dst;
  if (v6) {
    goto LABEL_22;
  }
  LOBYTE(__dst[0]) = 0;
  if ((SHIBYTE(v33) & 0x80000000) == 0) {
    goto LABEL_9;
  }
LABEL_23:
  operator delete(__p[0]);
LABEL_9:
  if (v42 >= 0) {
    uint64_t v9 = (const char *)__dst;
  }
  else {
    uint64_t v9 = (const char *)__dst[0];
  }
  uint64_t v10 = fmtcheck(v9, (const char *)this);
  va_list v40 = v43;
  int v11 = vsnprintf(0, 0, v10, v43);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v37 = 0;
  char v38 = 0;
  uint64_t v39 = 0;
  int v14 = v11 + 1;
  if (v11 != -1)
  {
    if (v11 <= -2) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    size_t v15 = v14;
    uint64_t v13 = (char *)operator new(v14);
    uint64_t v12 = &v13[v15];
    uint64_t v37 = v13;
    uint64_t v39 = &v13[v15];
    bzero(v13, v15);
    char v38 = &v13[v15];
  }
  vsnprintf(v13, v12 - v13, v10, v40);
  size_t v16 = strlen(v13);
  if (v16 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v17 = v16;
  if (v16 >= 0x17)
  {
    uint64_t v21 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17) {
      uint64_t v21 = v16 | 7;
    }
    uint64_t v22 = v21 + 1;
    size_t v18 = operator new(v21 + 1);
    size_t v30 = v17;
    int64_t v31 = v22 | 0x8000000000000000;
    unsigned __int8 v29 = v18;
  }
  else
  {
    HIBYTE(v3PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v16;
    size_t v18 = &v29;
    if (!v16) {
      goto LABEL_28;
    }
  }
  memcpy(v18, v13, v17);
LABEL_28:
  *((unsigned char *)v18 + v17) = 0;
  std::istringstream::basic_istringstream[abi:ne180100]((uint64_t)__p, (uint64_t)&v29, 8);
  if (SHIBYTE(v31) < 0) {
    operator delete(v29);
  }
  unsigned __int8 v29 = 0;
  size_t v30 = 0;
  int64_t v31 = 0;
  uint64_t v23 = (std::locale::id *)MEMORY[0x1E4FBA258];
  uint64_t v24 = MEMORY[0x1E4F14500];
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)__p + *((void *)__p[0] - 3)));
    uint64_t v25 = std::locale::use_facet(v44, v23);
    unsigned __int8 v26 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 10);
    std::locale::~locale(v44);
    uint64_t v27 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(__p, (uint64_t)&v29, v26);
    if ((*((unsigned char *)v27 + *(void *)(*v27 - 24) + 32) & 5) != 0) {
      break;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      if (v31 >= 0) {
        uint64_t v28 = (std::locale::__imp *)&v29;
      }
      else {
        uint64_t v28 = (std::locale::__imp *)v29;
      }
      LODWORD(v44[0].__locale_) = 136315138;
      *(std::locale::__imp **)((char *)&v44[0].__locale_ + PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v28;
      _os_log_impl(&dword_1B73F3000, v24, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)v44, 0xCu);
    }
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(v29);
  }
  __p[0] = *(void **)MEMORY[0x1E4FBA410];
  *(void **)((char *)__p + *((void *)__p[0] - 3)) = *(void **)(MEMORY[0x1E4FBA410] + 24);
  uint64_t v33 = MEMORY[0x1E4FBA470] + 16;
  if (v35 < 0) {
    operator delete(v34);
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1BA9BFAB0](&v36);
  if (v37) {
    operator delete(v37);
  }
  if (SHIBYTE(v42) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_1B76FBB94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  uint64_t v25 = *(void **)(v23 - 176);
  if (v25) {
    operator delete(v25);
  }
  if (*(char *)(v23 - 121) < 0) {
    operator delete(*(void **)(v23 - 144));
  }
  _Unwind_Resume(exception_object);
}

const char *HGLogger::warning(HGLogger *this, const char *a2, char *a3, ...)
{
  va_start(va, a3);
  return HGLogger::vwarning((const char *)this, va, a3);
}

const char *HGLogger::vwarning(const char *this, const char *a2, char *a3)
{
  _OWORD v49[3] = *(std::locale *)MEMORY[0x1E4F143B8];
  va_list v48 = (va_list)a2;
  unsigned __int8 v3 = atomic_load(HGLogger::_enabled);
  if ((v3 & 1) == 0) {
    return this;
  }
  size_t v4 = this;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v45);
  uint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"  Helium WARNING -- ", 20);
  size_t v6 = strlen(v4);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)v4, v6);
  std::stringbuf::str();
  if (v35 >= 0) {
    uint64_t v7 = buf;
  }
  else {
    uint64_t v7 = *(uint8_t **)buf;
  }
  size_t v8 = strlen((const char *)v7);
  if (v8 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v21 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v21 = v8 | 7;
    }
    uint64_t v22 = v21 + 1;
    uint64_t v10 = (void **)operator new(v21 + 1);
    __dst[1] = v9;
    int64_t v44 = v22 | 0x8000000000000000;
    __dst[0] = v10;
LABEL_24:
    memmove(v10, v7, (size_t)v9);
    *((unsigned char *)v9 + (void)v10) = 0;
    if ((SHIBYTE(v35) & 0x80000000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_25;
  }
  HIBYTE(v4PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v8;
  uint64_t v10 = __dst;
  if (v8) {
    goto LABEL_24;
  }
  LOBYTE(__dst[0]) = 0;
  if ((SHIBYTE(v35) & 0x80000000) == 0) {
    goto LABEL_9;
  }
LABEL_25:
  operator delete(*(void **)buf);
LABEL_9:
  if (v44 >= 0) {
    int v11 = (const char *)__dst;
  }
  else {
    int v11 = (const char *)__dst[0];
  }
  uint64_t v12 = fmtcheck(v11, v4);
  va_list v42 = v48;
  int v13 = vsnprintf(0, 0, v12, v48);
  int v14 = 0;
  size_t v15 = 0;
  uint64_t v39 = 0;
  va_list v40 = 0;
  int v41 = 0;
  int v16 = v13 + 1;
  if (v13 != -1)
  {
    if (v13 <= -2) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    size_t v17 = v16;
    size_t v15 = (char *)operator new(v16);
    int v14 = &v15[v17];
    uint64_t v39 = v15;
    int v41 = &v15[v17];
    bzero(v15, v17);
    va_list v40 = &v15[v17];
  }
  vsnprintf(v15, v14 - v15, v12, v42);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B73F3000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "------------------------------------------------------------", buf, 2u);
  }
  size_t v18 = strlen(v15);
  if (v18 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v19 = v18;
  if (v18 >= 0x17)
  {
    uint64_t v23 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v18 | 7) != 0x17) {
      uint64_t v23 = v18 | 7;
    }
    uint64_t v24 = v23 + 1;
    p_p = operator new(v23 + 1);
    size_t v32 = v19;
    int64_t v33 = v24 | 0x8000000000000000;
    std::string __p = p_p;
    goto LABEL_29;
  }
  HIBYTE(v3PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v18;
  p_p = &__p;
  if (v18) {
LABEL_29:
  }
    memcpy(p_p, v15, v19);
  *((unsigned char *)p_p + v19) = 0;
  std::istringstream::basic_istringstream[abi:ne180100]((uint64_t)buf, (uint64_t)&__p, 8);
  if (SHIBYTE(v33) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  size_t v32 = 0;
  int64_t v33 = 0;
  uint64_t v25 = (std::locale::id *)MEMORY[0x1E4FBA258];
  unsigned __int8 v26 = MEMORY[0x1E4F14500];
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)&buf[*(void *)(*(void *)buf - 24)]);
    uint64_t v27 = std::locale::use_facet(v49, v25);
    unsigned __int8 v28 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v27->__vftable[2].~facet_0)(v27, 10);
    std::locale::~locale(v49);
    unsigned __int8 v29 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(buf, (uint64_t)&__p, v28);
    if ((*((unsigned char *)v29 + *(void *)(*v29 - 24) + 32) & 5) != 0) {
      break;
    }
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      if (v33 >= 0) {
        size_t v30 = (std::locale::__imp *)&__p;
      }
      else {
        size_t v30 = (std::locale::__imp *)__p;
      }
      LODWORD(v49[0].__locale_) = 136315138;
      *(std::locale::__imp **)((char *)&v49[0].__locale_ + PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v30;
      _os_log_impl(&dword_1B73F3000, v26, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)v49, 0xCu);
    }
  }
  if (SHIBYTE(v33) < 0)
  {
    operator delete(__p);
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
LABEL_41:
    LOWORD(__p) = 0;
    _os_log_impl(&dword_1B73F3000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "------------------------------------------------------------", (uint8_t *)&__p, 2u);
  }
LABEL_42:
  *(void *)buf = *MEMORY[0x1E4FBA410];
  *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x1E4FBA410] + 24);
  uint64_t v35 = MEMORY[0x1E4FBA470] + 16;
  if (v37 < 0) {
    operator delete(v36);
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1BA9BFAB0](&v38);
  if (v39) {
    operator delete(v39);
  }
  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  v45[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v45 + *(void *)(v45[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v45[1] = MEMORY[0x1E4FBA470] + 16;
  if (v46 < 0) {
    operator delete((void *)v45[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return (const char *)MEMORY[0x1BA9BFAB0](&v47);
}

void sub_1B76FC2C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,_Unwind_Exception *exception_object,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62,char a63)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (exception_object) {
    operator delete(exception_object);
  }
  if (a62 < 0) {
    operator delete(a57);
  }
  std::ostringstream::~ostringstream((uint64_t)&a63);
  _Unwind_Resume(a1);
}

const char *HGLogger::error(HGLogger *this, const char *a2, char *a3, ...)
{
  va_start(va, a3);
  return HGLogger::verror((const char *)this, va, a3);
}

const char *HGLogger::verror(const char *this, const char *a2, char *a3)
{
  _OWORD v49[3] = *(std::locale *)MEMORY[0x1E4F143B8];
  va_list v48 = (va_list)a2;
  unsigned __int8 v3 = atomic_load(HGLogger::_enabled);
  if ((v3 & 1) == 0) {
    return this;
  }
  size_t v4 = this;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v45);
  uint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"  Helium ERROR -- ", 18);
  size_t v6 = strlen(v4);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)v4, v6);
  std::stringbuf::str();
  if (v35 >= 0) {
    uint64_t v7 = buf;
  }
  else {
    uint64_t v7 = *(uint8_t **)buf;
  }
  size_t v8 = strlen((const char *)v7);
  if (v8 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v21 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v21 = v8 | 7;
    }
    uint64_t v22 = v21 + 1;
    uint64_t v10 = (void **)operator new(v21 + 1);
    __dst[1] = v9;
    int64_t v44 = v22 | 0x8000000000000000;
    __dst[0] = v10;
LABEL_24:
    memmove(v10, v7, (size_t)v9);
    *((unsigned char *)v9 + (void)v10) = 0;
    if ((SHIBYTE(v35) & 0x80000000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_25;
  }
  HIBYTE(v4PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v8;
  uint64_t v10 = __dst;
  if (v8) {
    goto LABEL_24;
  }
  LOBYTE(__dst[0]) = 0;
  if ((SHIBYTE(v35) & 0x80000000) == 0) {
    goto LABEL_9;
  }
LABEL_25:
  operator delete(*(void **)buf);
LABEL_9:
  if (v44 >= 0) {
    int v11 = (const char *)__dst;
  }
  else {
    int v11 = (const char *)__dst[0];
  }
  uint64_t v12 = fmtcheck(v11, v4);
  va_list v42 = v48;
  int v13 = vsnprintf(0, 0, v12, v48);
  int v14 = 0;
  size_t v15 = 0;
  uint64_t v39 = 0;
  va_list v40 = 0;
  int v41 = 0;
  int v16 = v13 + 1;
  if (v13 != -1)
  {
    if (v13 <= -2) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    size_t v17 = v16;
    size_t v15 = (char *)operator new(v16);
    int v14 = &v15[v17];
    uint64_t v39 = v15;
    int v41 = &v15[v17];
    bzero(v15, v17);
    va_list v40 = &v15[v17];
  }
  vsnprintf(v15, v14 - v15, v12, v42);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B73F3000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "------------------------------------------------------------", buf, 2u);
  }
  size_t v18 = strlen(v15);
  if (v18 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v19 = v18;
  if (v18 >= 0x17)
  {
    uint64_t v23 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v18 | 7) != 0x17) {
      uint64_t v23 = v18 | 7;
    }
    uint64_t v24 = v23 + 1;
    p_p = operator new(v23 + 1);
    size_t v32 = v19;
    int64_t v33 = v24 | 0x8000000000000000;
    std::string __p = p_p;
    goto LABEL_29;
  }
  HIBYTE(v3PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v18;
  p_p = &__p;
  if (v18) {
LABEL_29:
  }
    memcpy(p_p, v15, v19);
  *((unsigned char *)p_p + v19) = 0;
  std::istringstream::basic_istringstream[abi:ne180100]((uint64_t)buf, (uint64_t)&__p, 8);
  if (SHIBYTE(v33) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  size_t v32 = 0;
  int64_t v33 = 0;
  uint64_t v25 = (std::locale::id *)MEMORY[0x1E4FBA258];
  unsigned __int8 v26 = MEMORY[0x1E4F14500];
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)&buf[*(void *)(*(void *)buf - 24)]);
    uint64_t v27 = std::locale::use_facet(v49, v25);
    unsigned __int8 v28 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v27->__vftable[2].~facet_0)(v27, 10);
    std::locale::~locale(v49);
    unsigned __int8 v29 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(buf, (uint64_t)&__p, v28);
    if ((*((unsigned char *)v29 + *(void *)(*v29 - 24) + 32) & 5) != 0) {
      break;
    }
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      if (v33 >= 0) {
        size_t v30 = (std::locale::__imp *)&__p;
      }
      else {
        size_t v30 = (std::locale::__imp *)__p;
      }
      LODWORD(v49[0].__locale_) = 136315138;
      *(std::locale::__imp **)((char *)&v49[0].__locale_ + PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v30;
      _os_log_impl(&dword_1B73F3000, v26, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)v49, 0xCu);
    }
  }
  if (SHIBYTE(v33) < 0)
  {
    operator delete(__p);
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
LABEL_41:
    LOWORD(__p) = 0;
    _os_log_impl(&dword_1B73F3000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "------------------------------------------------------------", (uint8_t *)&__p, 2u);
  }
LABEL_42:
  *(void *)buf = *MEMORY[0x1E4FBA410];
  *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x1E4FBA410] + 24);
  uint64_t v35 = MEMORY[0x1E4FBA470] + 16;
  if (v37 < 0) {
    operator delete(v36);
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1BA9BFAB0](&v38);
  if (v39) {
    operator delete(v39);
  }
  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  v45[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v45 + *(void *)(v45[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v45[1] = MEMORY[0x1E4FBA470] + 16;
  if (v46 < 0) {
    operator delete((void *)v45[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return (const char *)MEMORY[0x1BA9BFAB0](&v47);
}

void sub_1B76FCA24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,_Unwind_Exception *exception_object,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62,char a63)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (exception_object) {
    operator delete(exception_object);
  }
  if (a62 < 0) {
    operator delete(a57);
  }
  std::ostringstream::~ostringstream((uint64_t)&a63);
  _Unwind_Resume(a1);
}

uint64_t HGLogger::getNewlinePreamble(HGLogger *this)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v3);
  int v1 = atomic_load((unsigned int *)&HGLogger::_indent);
  if (v1 >= 1)
  {
    do
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"| ", 2);
      --v1;
    }
    while (v1);
  }
  std::stringbuf::str();
  v3[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v3 + *(void *)(v3[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v3[1] = MEMORY[0x1E4FBA470] + 16;
  if (v4 < 0) {
    operator delete((void *)v3[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v5);
}

void sub_1B76FCC58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B76FCC6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void HGTraceGuard::HGTraceGuard(HGTraceGuard *this, HGLogger *a2, int a3, const char *a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  *(void *)this = 0;
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 0;
  unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
  if (a3 >= 1 && (v5 & 1) != 0 && (int)HGLogger::getLevel(a2, (const char *)a2) >= a3)
  {
    uint64_t v7 = strdup(a4);
    *(void *)this = v7;
    snprintf(__str, 0x64uLL, "/-- %s\n", v7);
    HGLogger::print((HGLogger *)"%s", v8, v9, __str);
    atomic_fetch_add(&HGLogger::_indent, 1u);
    operator new();
  }
}

void sub_1B76FCD88(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1000C40451B5BE8);
  _Unwind_Resume(a1);
}

void HGTraceGuard::~HGTraceGuard(HGProfiler **this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (*this)
  {
    HGProfiler::stop(this[1]);
    uint64_t v2 = *this;
    double Time = HGProfiler::getTime(this[1]);
    snprintf(__str, 0x64uLL, "\\-- %s : %f msec\n", (const char *)v2, Time);
    atomic_fetch_add(&HGLogger::_indent, 0xFFFFFFFF);
    HGLogger::print((HGLogger *)"%s", v4, v5, __str);
    free(*this);
  }
  size_t v6 = this[1];
  if (v6) {
    MEMORY[0x1BA9BFBA0](v6, 0x1000C40451B5BE8);
  }
}

void sub_1B76FCE88(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t **std::__tree<std::__value_type<char const*,int>,std::__map_value_compare<char const*,std::__value_type<char const*,int>,HGLC::ltstr,true>,std::allocator<std::__value_type<char const*,int>>>::__emplace_unique_key_args<char const*,std::piecewise_construct_t const&,std::tuple<char const* const&>,std::tuple<>>(uint64_t **a1, const char **a2, uint64_t a3, void **a4)
{
  uint64_t v7 = a1 + 1;
  size_t v6 = a1[1];
  if (v6)
  {
    uint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        uint64_t v10 = (const char *)v6[4];
        if ((strcmp(v8, v10) & 0x80000000) == 0) {
          break;
        }
        size_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if ((strcmp(v10, v8) & 0x80000000) == 0) {
        return v9;
      }
      size_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_9:
    uint64_t v11 = v9;
    uint64_t v12 = operator new(0x30uLL);
    void v12[4] = **a4;
    *((_DWORD *)v12 + 10) = 0;
    *uint64_t v12 = 0;
    v12[1] = 0;
    void v12[2] = v11;
    *uint64_t v7 = v12;
    int v13 = (uint64_t *)**a1;
    int v14 = v12;
    if (v13)
    {
      *a1 = v13;
      int v14 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return (uint64_t **)v12;
  }
}

void *std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, uint64_t a2, unsigned __int8 a3)
{
  MEMORY[0x1BA9BF720](&v11, a1, 1);
  if (!v11) {
    return a1;
  }
  if (*(char *)(a2 + 23) < 0)
  {
    **(unsigned char **)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 2PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 0;
  }
  uint64_t v6 = 0;
  while (1)
  {
    uint64_t v7 = *(void **)((char *)a1 + *(void *)(*a1 - 24) + 40);
    uint64_t v8 = (unsigned char *)v7[3];
    if (v8 != (unsigned char *)v7[4])
    {
      float v7[3] = v8 + 1;
      LOBYTE(v7) = *v8;
      goto LABEL_9;
    }
    LODWORD(v7) = (*(uint64_t (**)(void *))(*v7 + 80))(v7);
    if (v7 == -1) {
      break;
    }
LABEL_9:
    if (v7 == a3)
    {
      int v9 = 0;
      goto LABEL_17;
    }
    std::string::push_back((std::string *)a2, (std::string::value_type)v7);
    --v6;
    if (*(char *)(a2 + 23) < 0 && *(void *)(a2 + 8) == 0x7FFFFFFFFFFFFFF7)
    {
      int v9 = 4;
      goto LABEL_17;
    }
  }
  if (v6) {
    int v9 = 2;
  }
  else {
    int v9 = 6;
  }
LABEL_17:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | v9);
  return a1;
}

void sub_1B76FD104(void *a1)
{
  __cxa_begin_catch(a1);
  uint64_t v2 = *v1;
  *(_DWORD *)((char *)v1 + *(void *)(*v1 - 24) + 32) |= 1u;
  if ((*((unsigned char *)v1 + *(void *)(v2 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x1B76FD0C4);
  }
  __cxa_rethrow();
}

void sub_1B76FD180(_Unwind_Exception *a1)
{
}

const char *HGLodBlend2::GetProgram(HGLodBlend2 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if ((*(unsigned int (**)(HGLodBlend2 *, HGRenderer *))(*(void *)this + 312))(this, a2)) {
    unsigned int v5 = Target;
  }
  else {
    unsigned int v5 = 394016;
  }
  if (v5 <= 0x6030F) {
    uint64_t v6 = "!!ARBfp1.0     \n"
  }
         "##LEN=00000004f2\n"
         "##                          \n"
         "##                            \n"
         "##                                \n"
         "##                                     \n"
         "##$\n"
         "OUTPUT $o0=result.color;\n"
         "ATTRIB $f0=fragment.texcoord[0];\n"
         "ATTRIB $f1=fragment.texcoord[1];\n"
         "PARAM $p2=program.local[2];\n"
         "PARAM $c0={0.5000000000,1.500000000,0.000000000,0.000000000};\n"
         "##%\n"
         "TEMP r0,r1,r2,r3,r4,r5;\n"
         "##@\n"
         "SUB r0.xy,$f0,$c0.x;\n"
         "FLR r1.xy,r0;\n"
         "FRC r0.xy,r0;\n"
         "ADD r2.xy,r1,$c0.x;\n"
         "##0\n"
         "TEX r2,r2,texture[0],RECT;\n"
         "ADD r3.xy,r1,$c0.yxzw;\n"
         "##0\n"
         "TEX r3,r3,texture[0],RECT;\n"
         "ADD r4.xy,r1,$c0;\n"
         "##0\n"
         "TEX r4,r4,texture[0],RECT;\n"
         "ADD r1.xy,r1,$c0.y;\n"
         "##0\n"
         "TEX r1,r1,texture[0],RECT;\n"
         "SUB r3,r3,r2;\n"
         "MAD r3,r0.x,r3,r2;\n"
         "SUB r1,r1,r4;\n"
         "MAD r4,r0.x,r1,r4;\n"
         "SUB r4,r4,r3;\n"
         "MAD r0,r0.y,r4,r3;\n"
         "SUB r2.xy,$f1,$c0.x;\n"
         "FLR r1.xy,r2;\n"
         "FRC r2.xy,r2;\n"
         "ADD r4.xy,r1,$c0.x;\n"
         "##1\n"
         "TEX r4,r4,texture[1],RECT;\n"
         "ADD r3.xy,r1,$c0.yxzw;\n"
         "##1\n"
         "TEX r3,r3,texture[1],RECT;\n"
         "ADD r5.xy,r1,$c0;\n"
         "##1\n"
         "TEX r5,r5,texture[1],RECT;\n"
         "ADD r1.xy,r1,$c0.y;\n"
         "##1\n"
         "TEX r1,r1,texture[1],RECT;\n"
         "SUB r3,r3,r4;\n"
         "MAD r3,r2.x,r3,r4;\n"
         "SUB r1,r1,r5;\n"
         "MAD r5,r2.x,r1,r5;\n"
         "SUB r5,r5,r3;\n"
         "MAD r2,r2.y,r5,r3;\n"
         "SUB r2,r2,r0;\n"
         "MAD $o0,$p2,r2,r0;\n"
         "END\n"
         "##MD5=5731f160:a6e64969:b14ecbbd:d9ff8c59\n"
         "##SIG=00000000:00000000:00000000:00000000:0001:0003:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  else {
    uint64_t v6 = "!!ARBfp1.0     \n"
  }
         "##LEN=0000000490\n"
         "##                          \n"
         "##                            \n"
         "##                                \n"
         "##                                     \n"
         "##$\n"
         "OUTPUT $o0=result.color;\n"
         "ATTRIB $f0=fragment.texcoord[0];\n"
         "ATTRIB $f1=fragment.texcoord[1];\n"
         "PARAM $p2=program.local[2];\n"
         "PARAM $c0={0.5000000000,1.500000000,0.000000000,0.000000000};\n"
         "##%\n"
         "TEMP r0,r1,r2,r3,r4,r5;\n"
         "##@\n"
         "SUB r0.xy,$f0,$c0.x;\n"
         "FLR r1.xy,r0;\n"
         "FRC r0.xy,r0;\n"
         "ADD r2.xy,r1,$c0.x;\n"
         "##0\n"
         "TEX r2,r2,texture[0],RECT;\n"
         "ADD r3.xy,r1,$c0.yxzw;\n"
         "##0\n"
         "TEX r3,r3,texture[0],RECT;\n"
         "ADD r4.xy,r1,$c0;\n"
         "##0\n"
         "TEX r4,r4,texture[0],RECT;\n"
         "ADD r1.xy,r1,$c0.y;\n"
         "##0\n"
         "TEX r1,r1,texture[0],RECT;\n"
         "LRP r3,r0.x,r3,r2;\n"
         "LRP r4,r0.x,r1,r4;\n"
         "LRP r0,r0.y,r4,r3;\n"
         "SUB r2.xy,$f1,$c0.x;\n"
         "FLR r1.xy,r2;\n"
         "FRC r2.xy,r2;\n"
         "ADD r4.xy,r1,$c0.x;\n"
         "##1\n"
         "TEX r4,r4,texture[1],RECT;\n"
         "ADD r3.xy,r1,$c0.yxzw;\n"
         "##1\n"
         "TEX r3,r3,texture[1],RECT;\n"
         "ADD r5.xy,r1,$c0;\n"
         "##1\n"
         "TEX r5,r5,texture[1],RECT;\n"
         "ADD r1.xy,r1,$c0.y;\n"
         "##1\n"
         "TEX r1,r1,texture[1],RECT;\n"
         "LRP r3,r2.x,r3,r4;\n"
         "LRP r5,r2.x,r1,r5;\n"
         "LRP r2,r2.y,r5,r3;\n"
         "LRP $o0,$p2,r2,r0;\n"
         "END\n"
         "##MD5=1af34882:dae2497c:35308843:34541126\n"
         "##SIG=00000000:00000000:00000000:00000000:0001:0003:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  if (v5 - 394016 < 0xF0 || v5 > 0x6043F) {
    return "!!ARBfp1.0     \n"
  }
           "##LEN=0000000218\n"
           "##                          \n"
           "##                            \n"
           "##                                \n"
           "##                                     \n"
           "##$\n"
           "OUTPUT $o0=result.color;\n"
           "ATTRIB $f0=fragment.texcoord[0];\n"
           "ATTRIB $f1=fragment.texcoord[1];\n"
           "PARAM $p2=program.local[2];\n"
           "##%\n"
           "TEMP r0,r1;\n"
           "##@\n"
           "##0\n"
           "TEX r0,$f0,texture[0],RECT;\n"
           "##1\n"
           "TEX r1,$f1,texture[1],RECT;\n"
           "LRP $o0,$p2,r1,r0;\n"
           "END\n"
           "##MD5=b7dfa253:e221938a:d4b76add:5cea1bcb\n"
           "##SIG=00000000:00000003:00000000:00000000:0000:0003:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  else {
    return v6;
  }
}

uint64_t HGLodBlend2::BindTexture(HGLodBlend2 *this, HGRenderer **a2, int a3)
{
  unsigned int Target = HGRenderer::GetTarget(a2[18], 393216);
  if (a3 == 1)
  {
    if (Target > 0x6043F || Target - 394016 < 0xF0)
    {
      (*((void (**)(HGRenderer **, uint64_t, void))*a2 + 9))(a2, 1, 0);
      uint64_t v9 = (*(uint64_t (**)(HGLodBlend2 *, void))(*(void *)this + 312))(this, 0);
      (*((void (**)(HGRenderer **, uint64_t, uint64_t))*a2 + 6))(a2, v9, v9);
    }
    HGHandler::TexCoord((HGHandler *)a2, 1, 0, 0, 0);
    uint64_t v8 = *((void *)this + 51) + 112;
    goto LABEL_11;
  }
  if (!a3)
  {
    if (Target > 0x6043F || Target - 394016 < 0xF0)
    {
      (*((void (**)(HGRenderer **, void, void))*a2 + 9))(a2, 0, 0);
      uint64_t v7 = (*(uint64_t (**)(HGLodBlend2 *, void))(*(void *)this + 312))(this, 0);
      (*((void (**)(HGRenderer **, uint64_t, uint64_t))*a2 + 6))(a2, v7, v7);
    }
    HGHandler::TexCoord((HGHandler *)a2, 0, 0, 0, 0);
    uint64_t v8 = *((void *)this + 51) + 48;
LABEL_11:
    (*((void (**)(HGRenderer **, uint64_t))*a2 + 15))(a2, v8);
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HGLodBlend2::Bind(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t HGLodBlend2::RenderTile(float32x4_t **this, HGTile *a2)
{
  uint64_t v4 = HGTile::Renderer(a2);
  int v5 = ((uint64_t (*)(float32x4_t **, uint64_t))(*this)[19].i64[1])(this, v4);
  int v6 = *((_DWORD *)a2 + 1);
  int v7 = *((_DWORD *)a2 + 3) - v6;
  if (v7 >= 1)
  {
    int v8 = 0;
    float v9 = (float)*(int *)a2 + 0.5;
    uint64_t v10 = this[51];
    v12.f32[0] = v9;
    v12.f32[1] = (float)v6 + 0.5;
    float32x4_t v11 = vmulq_n_f32(v10[7], v9);
    v12.i32[2] = 0;
    v12.i32[3] = 1.0;
    float32x4_t v13 = 0uLL;
    float32x4_t v14 = vaddq_f32(v10[6], vaddq_f32(vaddq_f32(vmulq_n_f32(v10[3], v9), vmulq_n_f32(v10[4], v12.f32[1])), vmulq_f32(v10[5], (float32x4_t)0)));
    int v15 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    float32x4_t v16 = vaddq_f32(v10[10], vaddq_f32(vaddq_f32(v11, vmulq_n_f32(v10[8], v12.f32[1])), vmulq_f32(v10[9], (float32x4_t)0)));
    size_t v17 = (float32x4_t *)*((void *)a2 + 2);
    size_t v18 = v17 + 2;
    uint64_t v19 = 16 * *((int *)a2 + 6);
    __asm { FMOV            V4.4S, #4.0 }
    v25.i64[0] = 0x3F0000003F000000;
    v25.i64[1] = 0x3F0000003F000000;
    while (1)
    {
      unsigned __int8 v26 = this[51];
      float32x4_t v27 = vaddq_f32(v14, vmulq_f32(v13, v26[4]));
      float32x4_t v28 = vaddq_f32(v16, vmulq_f32(v13, v26[8]));
      if (v15 >= 4) {
        break;
      }
      LODWORD(v109) = 0;
      float32x4_t v30 = 0uLL;
      __asm { FMOV            V17.4S, #1.0 }
      if (v15 > 0) {
        goto LABEL_13;
      }
LABEL_3:
      float32x4_t v13 = vaddq_f32(v13, _Q17);
      ++v8;
      size_t v18 = (float32x4_t *)((char *)v18 + v19);
      size_t v17 = (float32x4_t *)((char *)v17 + v19);
      if (v8 == v7) {
        return 0;
      }
    }
    int v29 = 0;
    float32x4_t v30 = 0uLL;
    int64_t v31 = v18;
    do
    {
      int v77 = this[51];
      float32x4_t v78 = v77[3];
      float32x4_t v79 = vaddq_f32(v27, vmulq_f32(v30, v78));
      float32x4_t v80 = v77[7];
      float32x4_t v81 = vaddq_f32(v28, vmulq_f32(v30, v80));
      float32x4_t v82 = vaddq_f32(v78, v79);
      float32x4_t v83 = vaddq_f32(v80, v81);
      float32x4_t v84 = vaddq_f32(v78, v82);
      float32x4_t v85 = vaddq_f32(v80, v83);
      float32x4_t v86 = vaddq_f32(v78, v84);
      float32x4_t v87 = vaddq_f32(v80, v85);
      uint64_t v88 = *((void *)a2 + 10);
      uint64_t v89 = *((int *)a2 + 22);
      float32x4_t v90 = vsubq_f32(v79, v12);
      if (v5)
      {
        int32x4_t v32 = vaddq_s32(vcvtq_s32_f32(v90), vcltzq_f32(v90));
        float32x2_t v33 = (float32x2_t)vsubq_f32(v90, vcvtq_f32_s32(v32)).u64[0];
        int64_t v34 = (float32x4_t *)(v88 + 16 * (v32.i32[0] + v32.i32[1] * (int)v89));
        float32x4_t v35 = vaddq_f32(*v34, vmulq_n_f32(vsubq_f32(v34[1], *v34), v33.f32[0]));
        uint64_t v36 = (int)v89 + 1;
        float32x4_t v37 = vaddq_f32(v35, vmulq_lane_f32(vsubq_f32(vaddq_f32(v34[v89], vmulq_n_f32(vsubq_f32(v34[v36], v34[v89]), v33.f32[0])), v35), v33, 1));
        float32x4_t v38 = vsubq_f32(v82, v12);
        int32x4_t v39 = vaddq_s32(vcvtq_s32_f32(v38), vcltzq_f32(v38));
        v38.i64[0] = vsubq_f32(v38, vcvtq_f32_s32(v39)).u64[0];
        va_list v40 = (float32x4_t *)(v88 + 16 * (v39.i32[0] + v39.i32[1] * (int)v89));
        float32x4_t v41 = vaddq_f32(*v40, vmulq_n_f32(vsubq_f32(v40[1], *v40), v38.f32[0]));
        float32x4_t v42 = vaddq_f32(v41, vmulq_lane_f32(vsubq_f32(vaddq_f32(v40[v89], vmulq_n_f32(vsubq_f32(v40[v36], v40[v89]), v38.f32[0])), v41), *(float32x2_t *)v38.f32, 1));
        float32x4_t v43 = vsubq_f32(v84, v12);
        int32x4_t v44 = vaddq_s32(vcvtq_s32_f32(v43), vcltzq_f32(v43));
        v43.i64[0] = vsubq_f32(v43, vcvtq_f32_s32(v44)).u64[0];
        int64_t v45 = (float32x4_t *)(v88 + 16 * (v44.i32[0] + v44.i32[1] * (int)v89));
        float32x4_t v46 = vaddq_f32(*v45, vmulq_n_f32(vsubq_f32(v45[1], *v45), v43.f32[0]));
        float32x4_t v47 = vaddq_f32(v46, vmulq_lane_f32(vsubq_f32(vaddq_f32(v45[v89], vmulq_n_f32(vsubq_f32(v45[v36], v45[v89]), v43.f32[0])), v46), *(float32x2_t *)v43.f32, 1));
        float32x4_t v48 = vsubq_f32(v86, v12);
        int32x4_t v49 = vaddq_s32(vcvtq_s32_f32(v48), vcltzq_f32(v48));
        v48.i64[0] = vsubq_f32(v48, vcvtq_f32_s32(v49)).u64[0];
        unint64_t v50 = (float32x4_t *)(v88 + 16 * (v49.i32[0] + v49.i32[1] * (int)v89));
        float32x4_t v51 = vaddq_f32(*v50, vmulq_n_f32(vsubq_f32(v50[1], *v50), v48.f32[0]));
        float32x4_t v52 = vaddq_f32(v51, vmulq_lane_f32(vsubq_f32(vaddq_f32(v50[v89], vmulq_n_f32(vsubq_f32(v50[v36], v50[v89]), v48.f32[0])), v51), *(float32x2_t *)v48.f32, 1));
        uint64_t v53 = *((void *)a2 + 12);
        uint64_t v54 = *((int *)a2 + 26);
        float32x4_t v55 = vsubq_f32(v81, v12);
        int32x4_t v56 = vaddq_s32(vcvtq_s32_f32(v55), vcltzq_f32(v55));
        v55.i64[0] = vsubq_f32(v55, vcvtq_f32_s32(v56)).u64[0];
        float32x4_t v57 = (float32x4_t *)(v53 + 16 * (v56.i32[0] + v56.i32[1] * (int)v54));
        float32x4_t v58 = vaddq_f32(*v57, vmulq_n_f32(vsubq_f32(v57[1], *v57), v55.f32[0]));
        uint64_t v59 = (int)v54 + 1;
        float32x4_t v60 = vaddq_f32(v58, vmulq_lane_f32(vsubq_f32(vaddq_f32(v57[v54], vmulq_n_f32(vsubq_f32(v57[v59], v57[v54]), v55.f32[0])), v58), *(float32x2_t *)v55.f32, 1));
        float32x4_t v61 = vsubq_f32(v83, v12);
        int32x4_t v62 = vaddq_s32(vcvtq_s32_f32(v61), vcltzq_f32(v61));
        v61.i64[0] = vsubq_f32(v61, vcvtq_f32_s32(v62)).u64[0];
        float32x4_t v63 = (float32x4_t *)(v53 + 16 * (v62.i32[0] + v62.i32[1] * (int)v54));
        float32x4_t v64 = vaddq_f32(*v63, vmulq_n_f32(vsubq_f32(v63[1], *v63), v61.f32[0]));
        float32x4_t v65 = vaddq_f32(v64, vmulq_lane_f32(vsubq_f32(vaddq_f32(v63[v54], vmulq_n_f32(vsubq_f32(v63[v59], v63[v54]), v61.f32[0])), v64), *(float32x2_t *)v61.f32, 1));
        float32x4_t v66 = vsubq_f32(v85, v12);
        int32x4_t v67 = vaddq_s32(vcvtq_s32_f32(v66), vcltzq_f32(v66));
        v66.i64[0] = vsubq_f32(v66, vcvtq_f32_s32(v67)).u64[0];
        int32x2_t v68 = (float32x4_t *)(v53 + 16 * (v67.i32[0] + v67.i32[1] * (int)v54));
        float32x4_t v69 = vaddq_f32(*v68, vmulq_n_f32(vsubq_f32(v68[1], *v68), v66.f32[0]));
        float32x4_t v70 = vaddq_f32(v69, vmulq_lane_f32(vsubq_f32(vaddq_f32(v68[v54], vmulq_n_f32(vsubq_f32(v68[v59], v68[v54]), v66.f32[0])), v69), *(float32x2_t *)v66.f32, 1));
        float32x4_t v71 = vsubq_f32(v87, v12);
        int32x4_t v72 = vaddq_s32(vcvtq_s32_f32(v71), vcltzq_f32(v71));
        v71.i64[0] = vsubq_f32(v71, vcvtq_f32_s32(v72)).u64[0];
        __int32 v73 = (float32x4_t *)(v53 + 16 * (v72.i32[0] + v72.i32[1] * (int)v54));
        float32x4_t v74 = vaddq_f32(*v73, vmulq_n_f32(vsubq_f32(v73[1], *v73), v71.f32[0]));
        float32x4_t v75 = vaddq_f32(v74, vmulq_lane_f32(vsubq_f32(vaddq_f32(v73[v54], vmulq_n_f32(vsubq_f32(v73[v59], v73[v54]), v71.f32[0])), v74), *(float32x2_t *)v71.f32, 1));
      }
      else
      {
        float32x4_t v91 = vaddq_f32(v90, v25);
        int32x4_t v92 = vcvtq_s32_f32(v91);
        v91.i64[0] = vaddq_s32(v92, vcgtq_f32(vcvtq_f32_s32(v92), v91)).u64[0];
        float32x4_t v37 = *(float32x4_t *)(v88 + 16 * (v91.i32[0] + v91.i32[1] * (int)v89));
        float32x4_t v93 = vaddq_f32(vsubq_f32(v82, v12), v25);
        int32x4_t v94 = vcvtq_s32_f32(v93);
        v93.i64[0] = vaddq_s32(v94, vcgtq_f32(vcvtq_f32_s32(v94), v93)).u64[0];
        float32x4_t v42 = *(float32x4_t *)(v88 + 16 * (v93.i32[0] + v93.i32[1] * (int)v89));
        float32x4_t v95 = vaddq_f32(vsubq_f32(v84, v12), v25);
        int32x4_t v96 = vcvtq_s32_f32(v95);
        v95.i64[0] = vaddq_s32(v96, vcgtq_f32(vcvtq_f32_s32(v96), v95)).u64[0];
        float32x4_t v47 = *(float32x4_t *)(v88 + 16 * (v95.i32[0] + v95.i32[1] * (int)v89));
        float32x4_t v97 = vaddq_f32(vsubq_f32(v86, v12), v25);
        int32x4_t v98 = vcvtq_s32_f32(v97);
        v97.i64[0] = vaddq_s32(v98, vcgtq_f32(vcvtq_f32_s32(v98), v97)).u64[0];
        float32x4_t v52 = *(float32x4_t *)(v88 + 16 * (v97.i32[0] + v97.i32[1] * (int)v89));
        uint64_t v99 = *((void *)a2 + 12);
        int v100 = *((_DWORD *)a2 + 26);
        float32x4_t v101 = vaddq_f32(vsubq_f32(v81, v12), v25);
        int32x4_t v102 = vcvtq_s32_f32(v101);
        v101.i64[0] = vaddq_s32(v102, vcgtq_f32(vcvtq_f32_s32(v102), v101)).u64[0];
        float32x4_t v60 = *(float32x4_t *)(v99 + 16 * (v101.i32[0] + v101.i32[1] * v100));
        float32x4_t v103 = vaddq_f32(vsubq_f32(v83, v12), v25);
        int32x4_t v104 = vcvtq_s32_f32(v103);
        v103.i64[0] = vaddq_s32(v104, vcgtq_f32(vcvtq_f32_s32(v104), v103)).u64[0];
        float32x4_t v65 = *(float32x4_t *)(v99 + 16 * (v103.i32[0] + v103.i32[1] * v100));
        float32x4_t v105 = vaddq_f32(vsubq_f32(v85, v12), v25);
        int32x4_t v106 = vcvtq_s32_f32(v105);
        v105.i64[0] = vaddq_s32(v106, vcgtq_f32(vcvtq_f32_s32(v106), v105)).u64[0];
        float32x4_t v70 = *(float32x4_t *)(v99 + 16 * (v105.i32[0] + v105.i32[1] * v100));
        float32x4_t v107 = vaddq_f32(vsubq_f32(v87, v12), v25);
        int32x4_t v108 = vcvtq_s32_f32(v107);
        v107.i64[0] = vaddq_s32(v108, vcgtq_f32(vcvtq_f32_s32(v108), v107)).u64[0];
        float32x4_t v75 = *(float32x4_t *)(v99 + 16 * (v107.i32[0] + v107.i32[1] * v100));
      }
      float32x4_t v30 = vaddq_f32(v30, _Q4);
      float32x4_t v76 = v77[2];
      v31[-2] = vaddq_f32(v37, vmulq_f32(vsubq_f32(v60, v37), v76));
      v31[-1] = vaddq_f32(v42, vmulq_f32(vsubq_f32(v65, v42), v76));
      *int64_t v31 = vaddq_f32(v47, vmulq_f32(vsubq_f32(v70, v47), v76));
      v31[1] = vaddq_f32(v52, vmulq_f32(v76, vsubq_f32(v75, v52)));
      v31 += 4;
      v29 -= 4;
    }
    while (v15 + v29 > 3);
    LODWORD(v109) = -v29;
    __asm { FMOV            V17.4S, #1.0 }
    if ((int)v109 >= v15) {
      goto LABEL_3;
    }
LABEL_13:
    uint64_t v109 = v109;
    if (v5)
    {
      do
      {
        int v111 = this[51];
        float32x4_t v112 = v111[2];
        float32x4_t v113 = vaddq_f32(v28, vmulq_f32(v30, v111[7]));
        uint64_t v114 = *((int *)a2 + 22);
        float32x4_t v115 = vsubq_f32(vaddq_f32(v27, vmulq_f32(v30, v111[3])), v12);
        int32x4_t v116 = vaddq_s32(vcvtq_s32_f32(v115), vcltzq_f32(v115));
        v115.i64[0] = vsubq_f32(v115, vcvtq_f32_s32(v116)).u64[0];
        uint64_t v117 = (float32x4_t *)(*((void *)a2 + 10) + 16 * (v116.i32[0] + v116.i32[1] * (int)v114));
        float32x4_t v118 = v117[v114];
        float32x4_t v119 = vsubq_f32(v113, v12);
        int32x4_t v120 = vaddq_s32(vcvtq_s32_f32(v119), vcltzq_f32(v119));
        v119.i64[0] = vsubq_f32(v119, vcvtq_f32_s32(v120)).u64[0];
        float32x4_t v121 = vaddq_f32(*v117, vmulq_n_f32(vsubq_f32(v117[1], *v117), v115.f32[0]));
        float32x4_t v122 = vmulq_n_f32(vsubq_f32(v117[(int)v114 + 1], v118), v115.f32[0]);
        uint64_t v123 = *((int *)a2 + 26);
        uint64_t v124 = (float32x4_t *)(*((void *)a2 + 12) + 16 * (v120.i32[0] + v120.i32[1] * (int)v123));
        float32x4_t v125 = vsubq_f32(vaddq_f32(v118, v122), v121);
        float32x4_t v126 = vaddq_f32(*v124, vmulq_n_f32(vsubq_f32(v124[1], *v124), v119.f32[0]));
        float32x4_t v127 = vaddq_f32(v121, vmulq_lane_f32(v125, *(float32x2_t *)v115.f32, 1));
        v17[v109] = vaddq_f32(v127, vmulq_f32(v112, vsubq_f32(vaddq_f32(v126, vmulq_lane_f32(vsubq_f32(vaddq_f32(v124[v123], vmulq_n_f32(vsubq_f32(v124[(int)v123 + 1], v124[v123]), v119.f32[0])), v126), *(float32x2_t *)v119.f32, 1)), v127)));
        float32x4_t v30 = vaddq_f32(v30, _Q17);
        ++v109;
      }
      while (v109 < v15);
    }
    else
    {
      do
      {
        int v128 = this[51];
        float32x4_t v129 = vaddq_f32(vsubq_f32(vaddq_f32(v27, vmulq_f32(v30, v128[3])), v12), v25);
        int32x4_t v130 = vcvtq_s32_f32(v129);
        v129.i64[0] = vaddq_s32(v130, vcgtq_f32(vcvtq_f32_s32(v130), v129)).u64[0];
        __int32 v131 = v129.i32[1];
        __int32 v132 = v129.i32[0];
        float32x4_t v133 = vaddq_f32(vsubq_f32(vaddq_f32(v28, vmulq_f32(v30, v128[7])), v12), v25);
        int32x4_t v134 = vcvtq_s32_f32(v133);
        v133.i64[0] = vaddq_s32(v134, vcgtq_f32(vcvtq_f32_s32(v134), v133)).u64[0];
        float32x4_t v135 = *(float32x4_t *)(*((void *)a2 + 10) + 16 * (v132 + v131 * *((_DWORD *)a2 + 22)));
        v17[v109] = vaddq_f32(v135, vmulq_f32(v128[2], vsubq_f32(*(float32x4_t *)(*((void *)a2 + 12)+ 16 * (v133.i32[0] + v133.i32[1] * *((_DWORD *)a2 + 26))), v135)));
        float32x4_t v30 = vaddq_f32(v30, _Q17);
        ++v109;
      }
      while (v109 < v15);
    }
    goto LABEL_3;
  }
  return 0;
}

uint64_t HGLodBlend2::GetDOD(HGLodBlend2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  int v5 = *(const HGTransform **)&a4.var0;
  if (a3 == 1)
  {
    if ((*(int (**)(HGLodBlend2 *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
    {
      uint64_t v14 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      int v5 = (const HGTransform *)HGRectGrow((uint64_t)v5, v4, v14);
      uint64_t v4 = v15;
    }
    HGTransform::HGTransform((HGTransform *)v22);
    HGTransform::LoadMatrixf(v22, (float32x2_t *)(*((void *)this + 51) + 112));
    HGTransform::Invert2D((HGTransform *)v22);
    float v17 = HGTransformUtils::MinW(v16);
    *(void *)&v24.uint64_t var0 = v4;
    uint64_t DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v22, v5, v24, 0.5, v17);
    uint64_t v13 = HGRectUnion(0, 0, DOD, v19);
  }
  else
  {
    if (a3) {
      return 0;
    }
    if ((*(int (**)(HGLodBlend2 *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
    {
      uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      int v5 = (const HGTransform *)HGRectGrow((uint64_t)v5, v4, v7);
      uint64_t v4 = v8;
    }
    HGTransform::HGTransform((HGTransform *)v22);
    HGTransform::LoadMatrixf(v22, (float32x2_t *)(*((void *)this + 51) + 48));
    HGTransform::Invert2D((HGTransform *)v22);
    float v10 = HGTransformUtils::MinW(v9);
    *(void *)&v23.uint64_t var0 = v4;
    uint64_t v11 = HGTransformUtils::GetDOD((HGTransformUtils *)v22, v5, v23, 0.5, v10);
    uint64_t v13 = HGRectUnion(0, 0, v11, v12);
  }
  uint64_t v20 = v13;
  HGTransform::~HGTransform((HGTransform *)v22);
  return v20;
}

void sub_1B76FDF5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76FDF70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76FDF84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76FDF98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGLodBlend2::GetROI(HGLodBlend2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  unint64_t v5 = *(void *)&a4.var0;
  if (a3 == 1)
  {
    HGTransform::HGTransform((HGTransform *)v22);
    HGTransform::LoadMatrixf(v22, (float32x2_t *)(*((void *)this + 51) + 112));
    float v15 = HGTransformUtils::MinW(v14);
    *(void *)&v24.uint64_t var0 = v4;
    uint64_t ROI = HGTransformUtils::GetROI((HGTransformUtils *)v22, v5, v24, 0.5, v15);
    uint64_t v12 = HGRectUnion(0, 0, ROI, v17);
  }
  else
  {
    if (a3) {
      return 0;
    }
    HGTransform::HGTransform((HGTransform *)v22);
    HGTransform::LoadMatrixf(v22, (float32x2_t *)(*((void *)this + 51) + 48));
    float v9 = HGTransformUtils::MinW(v8);
    *(void *)&v23.uint64_t var0 = v4;
    uint64_t v10 = HGTransformUtils::GetROI((HGTransformUtils *)v22, v5, v23, 0.5, v9);
    uint64_t v12 = HGRectUnion(0, 0, v10, v11);
  }
  uint64_t v18 = v12;
  uint64_t v19 = v13;
  HGTransform::~HGTransform((HGTransform *)v22);
  if ((*(int (**)(HGLodBlend2 *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
  {
    uint64_t v20 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    return HGRectGrow(v18, v19, v20);
  }
  return v18;
}

void sub_1B76FE12C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76FE140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76FE154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B76FE168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGLodBlend2::HGLodBlend2(HGLodBlend2 *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10C9F58;
  *(_DWORD *)(v1 + 416) = 1;
  operator new();
}

void sub_1B76FE29C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGLodBlend2::~HGLodBlend2(HGNode *this)
{
  *(void *)this = &unk_1F10C9F58;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40104B78CFLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10C9F58;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40104B78CFLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGLodBlend2::SetParameter(HGLodBlend2 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  void v10[3] = a6;
  *((_DWORD *)this + 10PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HGLodBlend2::GetParameter(HGLodBlend2 *this, unsigned int a2, float *a3)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  unint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

int8x8_t HGLodBlend2::GetOutput(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 416))
  {
    uint64_t v1 = *(void *)(a1 + 408);
    int8x16_t v2 = *(int8x16_t *)v1;
    long long v3 = *(_OWORD *)(v1 + 192);
    float32x2_t v4 = (float32x2_t)vextq_s8(v2, v2, 8uLL).u64[0];
    *(float32x2_t *)&long long v5 = vmul_f32(*(float32x2_t *)v1, *(float32x2_t *)(v1 + 176));
    long long v6 = *(_OWORD *)(v1 + 224);
    *((int8x8_t *)&v5 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v1 + 240), *(int8x16_t *)(v1 + 240), 8uLL), *(int8x8_t *)&v5);
    *(_OWORD *)(v1 + 48) = v5;
    *(float32x2_t *)&long long v5 = vmul_f32(*(float32x2_t *)v2.i8, *(float32x2_t *)&v3);
    uint64_t v7 = *(void *)(a1 + 408);
    *((int8x8_t *)&v5 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v7 + 240), *(int8x16_t *)(v7 + 240), 8uLL), *(int8x8_t *)&v5);
    *(_OWORD *)(v7 + 6PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v5;
    *(float32x2_t *)v2.int i8 = vmul_f32(*(float32x2_t *)v2.i8, *(float32x2_t *)&v6);
    uint64_t v8 = *(void *)(a1 + 408);
    *(float32x2_t *)&long long v3 = vadd_f32(v4, *(float32x2_t *)v2.i8);
    v2.u64[1] = (unint64_t)vbsl_s8(*(int8x8_t *)(v8 + 240), *(int8x8_t *)v2.i8, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v8 + 208), *(int8x16_t *)(v8 + 208), 8uLL));
    *(int8x16_t *)(v8 + 80) = v2;
    uint64_t v9 = *(void *)(a1 + 408);
    *((int8x8_t *)&v3 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = vbsl_s8(*(int8x8_t *)(v9 + 240), *(int8x8_t *)&v3, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v9 + 224), *(int8x16_t *)(v9 + 224), 8uLL));
    *(_OWORD *)(v9 + 96) = v3;
    uint64_t v10 = *(void *)(a1 + 408);
    int8x16_t v11 = *(int8x16_t *)(v10 + 16);
    long long v12 = *(_OWORD *)(v10 + 192);
    *(float32x2_t *)&long long v5 = vmul_f32(*(float32x2_t *)v11.i8, *(float32x2_t *)(v10 + 176));
    long long v13 = *(_OWORD *)(v10 + 224);
    *((int8x8_t *)&v5 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v10 + 240), *(int8x16_t *)(v10 + 240), 8uLL), *(int8x8_t *)&v5);
    *(void *)&long long v6 = vextq_s8(v11, v11, 8uLL).u64[0];
    *(_OWORD *)(v10 + 11PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v5;
    *(float32x2_t *)&long long v5 = vmul_f32(*(float32x2_t *)v11.i8, *(float32x2_t *)&v12);
    uint64_t v14 = *(void *)(a1 + 408);
    *((int8x8_t *)&v5 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v14 + 240), *(int8x16_t *)(v14 + 240), 8uLL), *(int8x8_t *)&v5);
    *(_OWORD *)(v14 + 128) = v5;
    *(float32x2_t *)v11.int i8 = vmul_f32(*(float32x2_t *)v11.i8, *(float32x2_t *)&v13);
    uint64_t v15 = *(void *)(a1 + 408);
    *(float32x2_t *)&long long v12 = vadd_f32(*(float32x2_t *)&v6, *(float32x2_t *)v11.i8);
    v11.u64[1] = (unint64_t)vbsl_s8(*(int8x8_t *)(v15 + 240), *(int8x8_t *)v11.i8, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v15 + 208), *(int8x16_t *)(v15 + 208), 8uLL));
    *(int8x16_t *)(v15 + 14PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v11;
    uint64_t v16 = *(void *)(a1 + 408);
    int8x8_t result = vbsl_s8(*(int8x8_t *)(v16 + 240), *(int8x8_t *)&v12, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v16 + 224), *(int8x16_t *)(v16 + 224), 8uLL));
    *((int8x8_t *)&v12 + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = result;
    *(_OWORD *)(v16 + 160) = v12;
    *(_DWORD *)(a1 + 416) = 0;
  }
  return result;
}

void HGMipmapLevel::HGMipmapLevel(HGMipmapLevel *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10CA1A8;
}

void HGMipmap::HGMipmap(HGMipmap *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v2 = &unk_1F10CA400;
  HGTransform::HGTransform((HGTransform *)(v2 + 56));
  HGTransform::HGTransform((HGMipmap *)((char *)this + 592));
  long long v3 = (HGLodBlend2 *)HGObject::operator new(0x1B0uLL);
  HGLodBlend2::HGLodBlend2(v3);
}

void sub_1B76FE6A8(_Unwind_Exception *a1)
{
  long long v5 = v4;
  HGObject::operator delete(v5);
  HGTransform::~HGTransform(v3);
  HGTransform::~HGTransform(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMipmap::~HGMipmap(HGMipmap *this)
{
  *(void *)this = &unk_1F10CA400;
  if (*((_DWORD *)this + 107))
  {
    unint64_t v2 = 0;
    do
    {
      uint64_t v3 = *(void *)(*((void *)this + 52) + 8 * v2);
      (*(void (**)(uint64_t, void, void))(*(void *)v3 + 120))(v3, 0, 0);
      uint64_t v4 = *(void *)(*((void *)this + 52) + 8 * v2);
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      ++v2;
    }
    while (v2 < *((unsigned int *)this + 107));
    free(*((void **)this + 52));
  }
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));
  HGTransform::~HGTransform((HGMipmap *)((char *)this + 592));
  HGTransform::~HGTransform((HGMipmap *)((char *)this + 448));

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v1;
  uint64_t vars8;

  HGMipmap::~HGMipmap(this);

  HGObject::operator delete(v1);
}

uint64_t HGMipmap::SetTransform(HGMipmap *this, HGTransform *a2, HGTransform *a3, float a4)
{
  uint64_t v8 = (HGMipmap *)((char *)this + 448);
  if (!HGTransform::IsEqual((HGMipmap *)((char *)this + 448), a2))
  {
    HGTransform::LoadTransform(v8, a2);
    uint64_t v9 = 1;
    uint64_t v10 = (HGMipmap *)((char *)this + 592);
    if (a3) {
      goto LABEL_3;
    }
LABEL_5:
    HGTransform::LoadTransform(v10, v8);
    HGTransform::Invert2D(v10);
    goto LABEL_6;
  }
  uint64_t v9 = 0;
  uint64_t v10 = (HGMipmap *)((char *)this + 592);
  if (!a3) {
    goto LABEL_5;
  }
LABEL_3:
  HGTransform::LoadTransform(v10, a3);
LABEL_6:
  *((float *)this + 18PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = a4;
  return v9;
}

uint64_t HGMipmap::SetParameter(HGMipmap *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  if (*((float *)this + 108) == a3) {
    return 0;
  }
  *((float *)this + 108) = a3;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HGMipmap::SetInput(HGNode *this, int a2, HGNode *a3)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = HGNode::SetInput(this, a2, a3);
  if (result == 1) {
    *((_DWORD *)this + 109) = 1;
  }
  return result;
}

uint64_t HGMipmap::SetLodFilter(uint64_t a1, uint64_t a2, char *a3)
{
  if (*(_DWORD *)(a1 + 440) == a2) {
    return 0;
  }
  *(_DWORD *)(a1 + 440) = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  return 1;
}

HGNode *HGMipmap::GetLevelOfDetail(HGMipmap *this, HGRenderer *a2, unsigned int a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t result = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  if (!result) {
    return result;
  }
  Input = result;
  uint64_t DOD = 0;
  uint64_t v9 = 0;
  float32x4_t v30 = 0uLL;
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target > 0x6043F
    || Target - 394016 < 0xF0
    || (uint64_t MatrixPtr = (double *)HGTransform::GetMatrixPtr((HGMipmap *)((char *)this + 592)), *((float *)this + 184) <= 1.0)
    || MatrixPtr[3] == 0.0
    && MatrixPtr[7] == 0.0
    && (MatrixPtr[11] == 0.0
      ? (BOOL v12 = *MatrixPtr * *MatrixPtr + MatrixPtr[1] * MatrixPtr[1] == MatrixPtr[4] * MatrixPtr[4]
                                                                      + MatrixPtr[5] * MatrixPtr[5])
      : (BOOL v12 = 0),
        v12))
  {
    if (*((_DWORD *)Input + 3) == -1814136143)
    {
      int TextureWrapMode = HGTextureWrap::GetTextureWrapMode((HGTextureWrap *)Input);
      HGTextureWrap::GetTextureBorderColor((HGTextureWrap *)Input, v30.f32);
      uint64_t v14 = 0;
      int v15 = 1;
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v30)))) & 1) == 0
        && !TextureWrapMode)
      {
        Input = HGRenderer::GetInput(a2, Input, 0);
        uint64_t v14 = 0;
      }
      if (!*((_DWORD *)this + 109))
      {
LABEL_20:
        if (*((_DWORD *)this + 107) > a3) {
          goto LABEL_22;
        }
      }
    }
    else
    {
      uint64_t v14 = 0;
      int v15 = 1;
      if (!*((_DWORD *)this + 109)) {
        goto LABEL_20;
      }
    }
  }
  else
  {
    long long v13 = (HGNode *)HGObject::operator new(0x1B0uLL);
    HGLodPreFilter::HGLodPreFilter(v13, (uint64_t)this, 0);
    (*(void (**)(HGNode *, void, HGNode *))(*(void *)v13 + 120))(v13, 0, Input);
    uint64_t v14 = (HGNode *)HGObject::operator new(0x1B0uLL);
    HGLodPreFilter::HGLodPreFilter(v14, (uint64_t)this, 1);
    (*(void (**)(HGNode *, void, HGNode *))(*(void *)v14 + 120))(v14, 0, v13);
    (*(void (**)(HGNode *))(*(void *)v13 + 24))(v13);
    int v15 = 0;
    if (!*((_DWORD *)this + 109)) {
      goto LABEL_20;
    }
  }
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  uint64_t v9 = v17;
  *(void *)((char *)this + 740) = DOD;
  *(void *)((char *)this + 748) = v17;
LABEL_22:
  if (!v15) {
    Input = v14;
  }
  if (!*((_DWORD *)this + 106))
  {
    *((_DWORD *)this + 106) = 8;
    *((void *)this + 5PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = malloc_type_malloc(0x40uLL, 0x2004093837F09uLL);
    uint64_t v18 = (HGLodFilter *)HGObject::operator new(0x250uLL);
    HGLodFilter::HGLodFilter(v18);
  }
  if (*((_DWORD *)this + 109))
  {
    (*(void (**)(void, void, HGNode *))(***((void ***)this + 52) + 120))(**((void **)this + 52), 0, Input);
    HGLodFilter::SetLevel(**((void **)this + 52), DOD, v9, DOD, v9, 0, 0);
    if (*((_DWORD *)this + 107) >= 2u)
    {
      uint64_t v19 = 0;
      do
      {
        uint64_t v20 = *((void *)this + 52) + 8 * v19;
        uint64_t v21 = *(void *)(v20 + 8);
        uint64_t v22 = HGRenderer::GetDOD(a2, *(HGNode **)v20);
        HGLodFilter::SetLevel(v21, DOD, v9, v22, v23, v19 + 1, *((_DWORD *)this + 110));
        unint64_t v24 = v19 + 2;
        ++v19;
      }
      while (v24 < *((unsigned int *)this + 107));
    }
    *((_DWORD *)this + 109) = 0;
    if (v15) {
      goto LABEL_34;
    }
  }
  else if (v15)
  {
    goto LABEL_34;
  }
  (*(void (**)(HGNode *))(*(void *)v14 + 24))(v14);
LABEL_34:
  unsigned int v25 = *((_DWORD *)this + 107);
  if (v25 <= a3)
  {
    unsigned int v26 = *((_DWORD *)this + 106);
    if (v26 <= v25)
    {
      float32x4_t v27 = (void *)*((void *)this + 52);
      unsigned int v28 = v26 + 8;
      *((_DWORD *)this + 106) = v28;
      *((void *)this + 5PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = malloc_type_realloc(v27, 8 * v28, 0x2004093837F09uLL);
    }
    int v29 = (HGLodFilter *)HGObject::operator new(0x250uLL);
    HGLodFilter::HGLodFilter(v29);
  }
  return *(HGNode **)(*((void *)this + 52) + 8 * a3);
}

void sub_1B76FEEE8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76FEEFC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76FEF10(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B76FEF24(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGMipmap::GetOutput(HGMipmap *this, HGRenderer *a2)
{
  if (*((float *)this + 108) >= 0.0) {
    float v5 = *((float *)this + 108);
  }
  else {
    float v5 = 0.0;
  }
  LODWORD(vPCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = vcvtms_s32_f32(v5);
  uint64_t v6 = (*(uint64_t (**)(HGMipmap *, HGRenderer *, uint64_t))(*(void *)this + 584))(this, a2, v2);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  HGTransform::HGTransform((HGTransform *)v30);
  (*(void (**)(void *__return_ptr, uint64_t, void))(*(void *)v7 + 576))(v21, v7, 0);
  long long v35 = v26;
  long long v36 = v27;
  long long v37 = v28;
  long long v38 = v29;
  long long v31 = v22;
  long long v32 = v23;
  long long v33 = v24;
  long long v34 = v25;
  HGTransform::~HGTransform((HGTransform *)v21);
  uint64_t MatrixPtr = (double *)HGTransform::GetMatrixPtr((HGTransform *)v30);
  (*(void (**)(void, void, uint64_t))(**((void **)this + 51) + 120))(*((void *)this + 51), 0, v7);
  float v9 = *MatrixPtr;
  float v10 = MatrixPtr[5];
  float v11 = MatrixPtr[12];
  float v12 = MatrixPtr[13];
  (*(void (**)(void, void, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, v9, v10, v11, v12);
  uint64_t v13 = (*(uint64_t (**)(HGMipmap *, HGRenderer *, void))(*(void *)this + 584))(this, a2, (v2 + 1));
  (*(void (**)(void *__return_ptr))(*(void *)v13 + 576))(v21);
  long long v35 = v26;
  long long v36 = v27;
  long long v37 = v28;
  long long v38 = v29;
  long long v31 = v22;
  long long v32 = v23;
  long long v33 = v24;
  long long v34 = v25;
  HGTransform::~HGTransform((HGTransform *)v21);
  uint64_t v14 = (double *)HGTransform::GetMatrixPtr((HGTransform *)v30);
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 51) + 120))(*((void *)this + 51), 1, v13);
  float v15 = *v14;
  float v16 = v14[5];
  float v17 = v14[12];
  float v18 = v14[13];
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, v15, v16, v17, v18);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 2, v5 - (float)(int)v2, v5 - (float)(int)v2, v5 - (float)(int)v2, v5 - (float)(int)v2);
  uint64_t v19 = *((void *)this + 51);
  HGTransform::~HGTransform((HGTransform *)v30);
  return v19;
}

void sub_1B76FF23C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1B76FF250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1B76FF264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1B76FF278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t HGMipmap::GetRect(HGMipmap *this, unsigned int a2, HGRect a3, char a4, int a5)
{
  if (*((_DWORD *)this + 107) <= (signed int)a2) {
    return 0;
  }
  if (a4)
  {
    if ((a2 & 0x80000000) == 0)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 8 * (a2 + 1);
      do
      {
        *(void *)&a3.uint64_t var0 = HGLodFilter::GetRect(*(HGLodFilter **)(*((void *)this + 52) + v7), a3, 1, a5);
        *(void *)&a3.var2 = v9;
        v7 += 8;
      }
      while (v8 != v7);
    }
  }
  else if ((a2 & 0x80000000) == 0)
  {
    uint64_t v11 = 8 * a2;
    do
    {
      *(void *)&a3.uint64_t var0 = HGLodFilter::GetRect(*(HGLodFilter **)(*((void *)this + 52) + v11), a3, 0, a5);
      *(void *)&a3.var2 = v12;
      v11 -= 8;
    }
    while (v11 != -8);
  }
  return *(void *)&a3.var0;
}

void HGMipmap::GetTransform(HGMipmap *this@<X0>, int a2@<W1>, uint64_t a3@<X2>, HGTransform *a4@<X8>)
{
  if (*((_DWORD *)this + 107) <= a2)
  {
    HGTransform::HGTransform(a4);
  }
  else
  {
    uint64_t v4 = *(void *)(*((void *)this + 52) + 8 * a2);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 576))(v4, a3);
  }
}

void soMaxFlow::soMaxFlow(soMaxFlow *this)
{
  *(void *)this = &unk_1F10CA6B8;
  operator new();
}

void sub_1B76FF438(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B0C406F4980B6);
  _Unwind_Resume(a1);
}

void soMaxFlow::~soMaxFlow(soMaxFlow *this, void *a2)
{
  *(void *)this = &unk_1F10CA6B8;
  uint64_t v2 = (HGMemory **)*((void *)this + 1);
  if (v2)
  {
    soMaxFlow::Impl::~Impl(v2, a2);
    MEMORY[0x1BA9BFBA0]();
  }
}

{
  HGMemory **v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10CA6B8;
  uint64_t v2 = (HGMemory **)*((void *)this + 1);
  if (v2)
  {
    soMaxFlow::Impl::~Impl(v2, a2);
    MEMORY[0x1BA9BFBA0]();
  }

  JUMPOUT(0x1BA9BFBA0);
}

double soMaxFlow::Reset(soMaxFlow *this)
{
  uint64_t v1 = *((void *)this + 1);
  size_t v2 = *(int *)(v1 + 68) * (uint64_t)*(int *)(v1 + 64);
  bzero(*(void **)v1, v2 << 6);
  bzero(*(void **)(v1 + 8), 8 * v2);
  memset(*(void **)(v1 + 16), 255, v2);
  bzero(*(void **)(v1 + 24), v2);
  memset(*(void **)(v1 + 32), 255, v2);
  v2 *= 4;
  memset(*(void **)(v1 + 40), 255, v2);
  bzero(*(void **)(v1 + 48), v2);
  *(void *)(v1 + 7PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  double result = NAN;
  *(void *)(v1 + 80) = -1;
  *(void *)(v1 + 10PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = *(void *)(v1 + 96);
  return result;
}

float soMaxFlow::Run(HGProfiler ***this)
{
  return soMaxFlow::Impl::solve(this[1]);
}

float soMaxFlow::Impl::solve(HGProfiler **this)
{
  HGProfiler::start(this[11]);
  this[10] = (HGProfiler *)-1;
  int v2 = *((_DWORD *)this + 16);
  int v3 = *((_DWORD *)this + 17);
  if (v3 * v2 >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      if (*((unsigned char *)this[3] + v4))
      {
        *((unsigned char *)this[2] + vPCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = -2;
        *((void *)this[1] + vPCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = 1;
        uint64_t v5 = *((unsigned int *)this + 21);
        if ((v5 & 0x80000000) != 0) {
          *((_DWORD *)this + 20) = v4;
        }
        else {
          *((_DWORD *)this[5] + v5) = v4;
        }
        *((_DWORD *)this + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v4;
        int v2 = *((_DWORD *)this + 16);
        int v3 = *((_DWORD *)this + 17);
      }
      ++v4;
    }
    while (v4 < v3 * v2);
  }
  while (1)
  {
    uint64_t v20 = -1;
    soMaxFlow::Impl::GrowthStage((uint64_t)this, &v20);
    uint64_t v6 = v20;
    if ((v20 & 0x80000000) != 0) {
      break;
    }
    int v7 = HIDWORD(v20);
    if (v20 < 0) {
      break;
    }
    ++*((_DWORD *)this + 18);
    uint64_t v8 = this[2];
    uint64_t v9 = *this;
    if (*((char *)v8 + v6) < 0)
    {
      float v11 = 3.4028e38;
      uint64_t v12 = v6;
    }
    else
    {
      uint64_t v10 = *((unsigned __int8 *)v8 + v6);
      float v11 = 3.4028e38;
      uint64_t v12 = v6;
      do
      {
        uint64_t v12 = *((int *)v9 + 16 * v12 + v10 + 8);
        float v11 = fminf(v11, *((float *)v9 + 16 * v12 + (((_BYTE)v10 + 4) & 7)));
        uint64_t v10 = *((unsigned __int8 *)v8 + v12);
      }
      while ((*((char *)v8 + v12) & 0x80000000) == 0);
    }
    uint64_t v13 = this[6];
    uint64_t v14 = (uint64_t)v9 + 64 * v6 + 4 * v7;
    float v15 = fminf(fminf(v11, fabsf(*((float *)v13 + v12))), *(float *)v14);
    uint64_t v16 = *(int *)(v14 + 32);
    if ((*((char *)v8 + v16) & 0x80000000) == 0)
    {
      uint64_t v17 = *((unsigned __int8 *)v8 + v16);
      do
      {
        uint64_t v18 = (uint64_t)v9 + 64 * v16 + 4 * v17;
        float v15 = fminf(v15, *(float *)v18);
        uint64_t v16 = *(int *)(v18 + 32);
        uint64_t v17 = *((unsigned __int8 *)v8 + v16);
      }
      while ((*((char *)v8 + v16) & 0x80000000) == 0);
    }
    soMaxFlow::Impl::UpdateFlow((uint64_t)this, (int *)&v20, fminf(v15, fabsf(*((float *)v13 + v16))));
    soMaxFlow::Impl::AdoptionStage((soMaxFlow::Impl *)this);
  }
  HGProfiler::stop(this[11]);
  return *((float *)this + 19);
}

uint64_t soMaxFlow::SetNodeWeights(soMaxFlow *this, int a2, int a3, float a4, float a5)
{
  uint64_t v5 = *((void *)this + 1);
  signed int v6 = (((_BYTE)a2 + (*(int *)(v5 + 56) >> 1)) & 7 | ((a2 + (*(int *)(v5 + 56) >> 1)) >> 3 << 6))
     + ((a3 + (*(int *)(v5 + 60) >> 1)) & 0xFFFFFFF8) * *(_DWORD *)(v5 + 64)
     + 8 * ((a3 + (*(int *)(v5 + 60) >> 1)) & 7);
  *(float *)(*(void *)(v5 + 48) + 4 * v6) = a4 - a5;
  if ((float)(a4 - a5) != 0.0)
  {
    if ((float)(a4 - a5) > 0.0) {
      char v7 = 1;
    }
    else {
      char v7 = 2;
    }
    *(unsigned char *)(*(void *)(v5 + 24) + v6) = v7;
  }
  if (a4 >= a5) {
    a4 = a5;
  }
  *(float *)(v5 + 76) = a4 + *(float *)(v5 + 76);
  return 1;
}

uint64_t soMaxFlow::SetEdgeCapacity(uint64_t a1, int a2, int a3, int a4, float a5)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (int)((((_BYTE)a3 + (*(int *)(v5 + 56) >> 1)) & 7 | ((a3 + (*(int *)(v5 + 56) >> 1)) >> 3 << 6))
           + ((a4 + (*(int *)(v5 + 60) >> 1)) & 0xFFFFFFF8) * *(_DWORD *)(v5 + 64)
           + 8 * ((a4 + (*(int *)(v5 + 60) >> 1)) & 7));
  uint64_t v7 = v6 << 6;
  uint64_t v8 = 4 * a2;
  *(float *)(*(void *)v5 + (v6 << 6) + v8) = a5;
  *(unsigned char *)(*(void *)(v5 + 32) + v6) = *(unsigned char *)(*(void *)(v5 + 32) + v6) & ~(1 << a2) | ((a5 == 0.0) << a2);
  unsigned int v9 = *(_DWORD *)((char *)&Edge::OffsetX + v8) + a3 + (*(int *)(v5 + 56) >> 1);
  LODWORD(v6) = *(_DWORD *)((char *)&Edge::OffsetY + v8) + a4 + (*(int *)(v5 + 60) >> 1);
  *(_DWORD *)(*(void *)v5 + v8 + v7 + 3PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = (v9 & 7 | (v9 >> 3 << 6))
                                            + (v6 & 0xFFFFFFF8) * *(_DWORD *)(v5 + 64)
                                            + 8 * (v6 & 7);
  return 1;
}

uint64_t soMaxFlow::StoreGraphCutToMask(uint64_t this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, unsigned __int8 a8, char a9)
{
  uint64_t v9 = *(void *)(this + 8);
  if (*(int *)(v9 + 64) - (uint64_t)*(int *)(v9 + 56) == a3
    && a4
    && *(int *)(v9 + 68) - (uint64_t)*(int *)(v9 + 60) == a4
    && a3 != 0)
  {
    for (uint64_t i = 0; i != a4; ++i)
    {
      uint64_t v12 = 0;
      do
      {
        unsigned int v13 = a2[v12];
        if (v13 >= a6 && v13 <= a7)
        {
          if (*(unsigned char *)(*(void *)(v9 + 24)
                        + (int)((((_BYTE)v12 + (*(int *)(v9 + 56) >> 1)) & 7 | ((v12 + (*(int *)(v9 + 56) >> 1)) >> 3 << 6))
                              + ((i + (*(int *)(v9 + 60) >> 1)) & 0xFFFFFFF8) * *(_DWORD *)(v9 + 64)
                              + 8 * ((i + (*(int *)(v9 + 60) >> 1)) & 7))) == 1)
            unsigned __int8 v15 = a9;
          else {
            unsigned __int8 v15 = a8;
          }
          a2[v12] = v15;
        }
        ++v12;
      }
      while (a3 != v12);
      a2 += a5;
    }
  }
  return this;
}

void soMaxFlow::Impl::Impl(soMaxFlow::Impl *this, int a2, unint64_t *a3)
{
  *((void *)this + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = 0;
  *((void *)this + 9) = 1;
  *((void *)this + 1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 0;
  *((void *)this + 1PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = 0;
  int v4 = 8 - (a2 & 7);
  int v5 = 8 - (a3 & 7);
  *((_DWORD *)this + 1PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v4;
  *((_DWORD *)this + 15) = v5;
  if ((a2 & 7) == 7)
  {
    int v4 = 9;
    *((_DWORD *)this + 1PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = 9;
  }
  if ((a3 & 7) == 7)
  {
    int v5 = 9;
    *((_DWORD *)this + 15) = 9;
  }
  int v6 = v4 + a2;
  int v7 = v5 + a3;
  *((_DWORD *)this + 16) = v6;
  *((_DWORD *)this + 17) = v7;
  int v8 = v7 * v6;
  *(void *)this = HGMemory::allocate((HGMemory *)((uint64_t)(v7 * v6) << 6), 0, a3);
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = HGMemory::allocate((HGMemory *)(8 * v8), 0, v9);
  *((void *)this + PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = HGMemory::allocate((HGMemory *)v8, 0, v10);
  *((void *)this + PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = HGMemory::allocate((HGMemory *)v8, 0, v11);
  *((void *)this + PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = HGMemory::allocate((HGMemory *)v8, 0, v12);
  unsigned int v13 = (HGMemory *)(4 * v8);
  *((void *)this + 5) = HGMemory::allocate(v13, 0, v14);
  *((void *)this + 6) = HGMemory::allocate(v13, 0, v15);
  size_t v16 = *((int *)this + 17) * (uint64_t)*((int *)this + 16);
  bzero(*(void **)this, v16 << 6);
  bzero(*((void **)this + 1), 8 * v16);
  memset(*((void **)this + 2), 255, v16);
  bzero(*((void **)this + 3), v16);
  memset(*((void **)this + 4), 255, v16);
  v16 *= 4;
  memset(*((void **)this + 5), 255, v16);
  bzero(*((void **)this + 6), v16);
  *((void *)this + 9) = 0;
  *((void *)this + 10) = -1;
  *((void *)this + 1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = *((void *)this + 12);
  operator new();
}

void sub_1B76FFB40(_Unwind_Exception *a1)
{
  uint64_t v4 = v2;
  MEMORY[0x1BA9BFBA0](v4, 0x1000C40451B5BE8);
  int v6 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 10PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

void soMaxFlow::Impl::~Impl(HGMemory **this, void *a2)
{
  int v3 = *this;
  if (v3) {
    HGMemory::release(v3, a2);
  }
  uint64_t v4 = this[1];
  if (v4) {
    HGMemory::release(v4, a2);
  }
  int v5 = this[2];
  if (v5) {
    HGMemory::release(v5, a2);
  }
  int v6 = this[3];
  if (v6) {
    HGMemory::release(v6, a2);
  }
  int v7 = this[4];
  if (v7) {
    HGMemory::release(v7, a2);
  }
  int v8 = this[5];
  if (v8) {
    HGMemory::release(v8, a2);
  }
  uint64_t v9 = this[6];
  if (v9) {
    HGMemory::release(v9, a2);
  }
  uint64_t v10 = this[11];
  if (v10) {
    MEMORY[0x1BA9BFBA0](v10, 0x1000C40451B5BE8);
  }
  float v11 = this[12];
  if (v11)
  {
    this[13] = v11;
    operator delete(v11);
  }
}

uint64_t soMaxFlow::Impl::GrowthStage(uint64_t result, _DWORD *a2)
{
  uint64_t v2 = *(unsigned int *)(result + 80);
  if ((v2 & 0x80000000) != 0)
  {
LABEL_101:
    *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v2;
    return result;
  }
  while (1)
  {
    uint64_t v5 = *(void *)(result + 16);
    if (*(unsigned __int8 *)(v5 + v2) == 255) {
      goto LABEL_4;
    }
    int v6 = (int *)(*(void *)(result + 8) + 8 * v2);
    uint64_t v7 = *(void *)(result + 24);
    uint64_t v8 = *(void *)(result + 32);
    unsigned __int8 v9 = *(unsigned char *)(v7 + v2);
    int v10 = *v6;
    int v11 = v6[1];
    int v12 = v10 + 1;
    int v13 = *(_DWORD *)(*(void *)result + (v2 << 6) + 32);
    if (v9 == 2)
    {
      if ((*(unsigned char *)(v8 + v13) & 0x10) == 0)
      {
        if (*(unsigned __int8 *)(v5 + v13) == 255)
        {
          *(unsigned char *)(v7 + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 2;
          *(unsigned char *)(*(void *)(result + 16) + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 4;
          uint64_t v14 = (_DWORD *)(*(void *)(result + 8) + 8 * v13);
          *uint64_t v14 = v12;
          v14[1] = v11;
          uint64_t v15 = *(void *)(result + 40);
          if ((*(_DWORD *)(v15 + 4 * v13) & 0x80000000) != 0)
          {
            *(_DWORD *)(v15 + 4 * *(int *)(result + 84)) = v13;
            *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v13;
          }
        }
        else if (*(unsigned char *)(v7 + v13) != 2)
        {
          *a2 = v13;
          a2[1] = 4;
          return result;
        }
      }
      int v16 = *(_DWORD *)(*(void *)result + (v2 << 6) + 36);
      if ((*(unsigned char *)(*(void *)(result + 32) + v16) & 0x20) == 0)
      {
        uint64_t v17 = *(void *)(result + 24);
        if (*(unsigned __int8 *)(*(void *)(result + 16) + v16) == 255)
        {
          *(unsigned char *)(v17 + v16) = 2;
          *(unsigned char *)(*(void *)(result + 16) + v16) = 5;
          uint64_t v21 = (_DWORD *)(*(void *)(result + 8) + 8 * v16);
          *uint64_t v21 = v12;
          v21[1] = v11;
          uint64_t v22 = *(void *)(result + 40);
          if ((*(_DWORD *)(v22 + 4 * v16) & 0x80000000) != 0)
          {
            *(_DWORD *)(v22 + 4 * *(int *)(result + 84)) = v16;
            *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v16;
          }
        }
        else if (*(unsigned char *)(v17 + v16) != 2)
        {
          *a2 = v16;
          a2[1] = 5;
          return result;
        }
      }
      int v23 = *(_DWORD *)(*(void *)result + (v2 << 6) + 40);
      if ((*(unsigned char *)(*(void *)(result + 32) + v23) & 0x40) == 0)
      {
        uint64_t v24 = *(void *)(result + 24);
        if (*(unsigned __int8 *)(*(void *)(result + 16) + v23) == 255)
        {
          *(unsigned char *)(v24 + v2PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 2;
          *(unsigned char *)(*(void *)(result + 16) + v2PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 6;
          long long v27 = (_DWORD *)(*(void *)(result + 8) + 8 * v23);
          *long long v27 = v12;
          v27[1] = v11;
          uint64_t v28 = *(void *)(result + 40);
          if ((*(_DWORD *)(v28 + 4 * v23) & 0x80000000) != 0)
          {
            *(_DWORD *)(v28 + 4 * *(int *)(result + 84)) = v23;
            *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v23;
          }
        }
        else if (*(unsigned char *)(v24 + v23) != 2)
        {
          *a2 = v23;
          a2[1] = 6;
          return result;
        }
      }
      int v29 = *(_DWORD *)(*(void *)result + (v2 << 6) + 44);
      if ((*(char *)(*(void *)(result + 32) + v29) & 0x80000000) == 0)
      {
        uint64_t v30 = *(void *)(result + 24);
        if (*(unsigned __int8 *)(*(void *)(result + 16) + v29) == 255)
        {
          *(unsigned char *)(v30 + v29) = 2;
          *(unsigned char *)(*(void *)(result + 16) + v29) = 7;
          long long v31 = (_DWORD *)(*(void *)(result + 8) + 8 * v29);
          *long long v31 = v12;
          v31[1] = v11;
          uint64_t v32 = *(void *)(result + 40);
          if ((*(_DWORD *)(v32 + 4 * v29) & 0x80000000) != 0)
          {
            *(_DWORD *)(v32 + 4 * *(int *)(result + 84)) = v29;
            *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v29;
          }
        }
        else if (*(unsigned char *)(v30 + v29) != 2)
        {
          *a2 = v29;
          a2[1] = 7;
          return result;
        }
      }
      int v33 = *(_DWORD *)(*(void *)result + (v2 << 6) + 48);
      if ((*(unsigned char *)(*(void *)(result + 32) + v33) & 1) == 0)
      {
        uint64_t v34 = *(void *)(result + 24);
        if (*(unsigned __int8 *)(*(void *)(result + 16) + v33) == 255)
        {
          *(unsigned char *)(v34 + v3PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 2;
          *(unsigned char *)(*(void *)(result + 16) + v3PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 0;
          long long v35 = (_DWORD *)(*(void *)(result + 8) + 8 * v33);
          *long long v35 = v12;
          v35[1] = v11;
          uint64_t v36 = *(void *)(result + 40);
          if ((*(_DWORD *)(v36 + 4 * v33) & 0x80000000) != 0)
          {
            *(_DWORD *)(v36 + 4 * *(int *)(result + 84)) = v33;
            *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v33;
          }
        }
        else if (*(unsigned char *)(v34 + v33) != 2)
        {
          *a2 = v33;
          a2[1] = 0;
          return result;
        }
      }
      int v37 = *(_DWORD *)(*(void *)result + (v2 << 6) + 52);
      if ((*(unsigned char *)(*(void *)(result + 32) + v37) & 2) == 0)
      {
        uint64_t v38 = *(void *)(result + 24);
        if (*(unsigned __int8 *)(*(void *)(result + 16) + v37) == 255)
        {
          *(unsigned char *)(v38 + v37) = 2;
          *(unsigned char *)(*(void *)(result + 16) + v37) = 1;
          int32x4_t v39 = (_DWORD *)(*(void *)(result + 8) + 8 * v37);
          *int32x4_t v39 = v12;
          v39[1] = v11;
          uint64_t v40 = *(void *)(result + 40);
          if ((*(_DWORD *)(v40 + 4 * v37) & 0x80000000) != 0)
          {
            *(_DWORD *)(v40 + 4 * *(int *)(result + 84)) = v37;
            *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v37;
          }
        }
        else if (*(unsigned char *)(v38 + v37) != 2)
        {
          *a2 = v37;
          a2[1] = 1;
          return result;
        }
      }
      int v41 = *(_DWORD *)(*(void *)result + (v2 << 6) + 56);
      if ((*(unsigned char *)(*(void *)(result + 32) + v41) & 4) == 0)
      {
        uint64_t v42 = *(void *)(result + 24);
        if (*(unsigned __int8 *)(*(void *)(result + 16) + v41) == 255)
        {
          *(unsigned char *)(v42 + v4PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 2;
          *(unsigned char *)(*(void *)(result + 16) + v4PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = 2;
          float32x4_t v43 = (_DWORD *)(*(void *)(result + 8) + 8 * v41);
          *float32x4_t v43 = v12;
          v43[1] = v11;
          uint64_t v44 = *(void *)(result + 40);
          if ((*(_DWORD *)(v44 + 4 * v41) & 0x80000000) != 0)
          {
            *(_DWORD *)(v44 + 4 * *(int *)(result + 84)) = v41;
            *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v41;
          }
        }
        else if (*(unsigned char *)(v42 + v41) != 2)
        {
          *a2 = v41;
          a2[1] = 2;
          return result;
        }
      }
      int v13 = *(_DWORD *)(*(void *)result + (v2 << 6) + 60);
      if ((*(unsigned char *)(*(void *)(result + 32) + v13) & 8) == 0)
      {
        uint64_t v45 = *(void *)(result + 24);
        if (*(unsigned __int8 *)(*(void *)(result + 16) + v13) == 255)
        {
          *(unsigned char *)(v45 + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 2;
          *(unsigned char *)(*(void *)(result + 16) + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 3;
          float32x4_t v46 = (_DWORD *)(*(void *)(result + 8) + 8 * v13);
          *float32x4_t v46 = v12;
          v46[1] = v11;
          uint64_t v47 = *(void *)(result + 40);
          if ((*(_DWORD *)(v47 + 4 * v13) & 0x80000000) != 0) {
            goto LABEL_100;
          }
        }
        else if (*(unsigned char *)(v45 + v13) != 2)
        {
          *a2 = v13;
          a2[1] = 3;
          return result;
        }
      }
      goto LABEL_4;
    }
    if ((*(unsigned char *)(v8 + v2) & 1) == 0)
    {
      if (*(unsigned __int8 *)(v5 + v13) == 255)
      {
        *(unsigned char *)(v7 + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v9;
        *(unsigned char *)(*(void *)(result + 16) + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 4;
        uint64_t v18 = (_DWORD *)(*(void *)(result + 8) + 8 * v13);
        *uint64_t v18 = v12;
        v18[1] = v11;
        uint64_t v19 = *(void *)(result + 40);
        if ((*(_DWORD *)(v19 + 4 * v13) & 0x80000000) != 0)
        {
          *(_DWORD *)(v19 + 4 * *(int *)(result + 84)) = v13;
          *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v13;
          if ((*(unsigned char *)(*(void *)(result + 32) + v2) & 2) != 0) {
            goto LABEL_67;
          }
          goto LABEL_23;
        }
      }
      else if (*(unsigned __int8 *)(v7 + v13) != v9)
      {
        int v65 = 0;
        if (*(unsigned char *)(v7 + v2) != 1) {
          goto LABEL_115;
        }
        goto LABEL_117;
      }
    }
    if ((*(unsigned char *)(*(void *)(result + 32) + v2) & 2) != 0) {
      goto LABEL_67;
    }
LABEL_23:
    int v13 = *(_DWORD *)(*(void *)result + (v2 << 6) + 36);
    uint64_t v20 = *(void *)(result + 24);
    if (*(unsigned __int8 *)(*(void *)(result + 16) + v13) == 255)
    {
      *(unsigned char *)(v20 + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v9;
      *(unsigned char *)(*(void *)(result + 16) + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 5;
      long long v25 = (_DWORD *)(*(void *)(result + 8) + 8 * v13);
      *long long v25 = v12;
      v25[1] = v11;
      uint64_t v26 = *(void *)(result + 40);
      if ((*(_DWORD *)(v26 + 4 * v13) & 0x80000000) != 0)
      {
        *(_DWORD *)(v26 + 4 * *(int *)(result + 84)) = v13;
        *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v13;
      }
    }
    else if (*(unsigned __int8 *)(v20 + v13) != v9)
    {
      int v65 = 1;
      if (v9 != 1) {
        goto LABEL_115;
      }
      goto LABEL_117;
    }
LABEL_67:
    if ((*(unsigned char *)(*(void *)(result + 32) + v2) & 4) == 0)
    {
      int v13 = *(_DWORD *)(*(void *)result + (v2 << 6) + 40);
      uint64_t v48 = *(void *)(result + 24);
      if (*(unsigned __int8 *)(*(void *)(result + 16) + v13) == 255)
      {
        *(unsigned char *)(v48 + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v9;
        *(unsigned char *)(*(void *)(result + 16) + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 6;
        int32x4_t v49 = (_DWORD *)(*(void *)(result + 8) + 8 * v13);
        *int32x4_t v49 = v12;
        v49[1] = v11;
        uint64_t v50 = *(void *)(result + 40);
        if ((*(_DWORD *)(v50 + 4 * v13) & 0x80000000) != 0)
        {
          *(_DWORD *)(v50 + 4 * *(int *)(result + 84)) = v13;
          *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v13;
          if ((*(unsigned char *)(*(void *)(result + 32) + v2) & 8) != 0) {
            goto LABEL_79;
          }
          goto LABEL_73;
        }
      }
      else if (*(unsigned __int8 *)(v48 + v13) != v9)
      {
        int v65 = 2;
        if (v9 != 1) {
          goto LABEL_115;
        }
        goto LABEL_117;
      }
    }
    if ((*(unsigned char *)(*(void *)(result + 32) + v2) & 8) != 0) {
      goto LABEL_79;
    }
LABEL_73:
    int v13 = *(_DWORD *)(*(void *)result + (v2 << 6) + 44);
    uint64_t v51 = *(void *)(result + 24);
    if (*(unsigned __int8 *)(*(void *)(result + 16) + v13) == 255)
    {
      *(unsigned char *)(v51 + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v9;
      *(unsigned char *)(*(void *)(result + 16) + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 7;
      float32x4_t v52 = (_DWORD *)(*(void *)(result + 8) + 8 * v13);
      *float32x4_t v52 = v12;
      v52[1] = v11;
      uint64_t v53 = *(void *)(result + 40);
      if ((*(_DWORD *)(v53 + 4 * v13) & 0x80000000) != 0)
      {
        *(_DWORD *)(v53 + 4 * *(int *)(result + 84)) = v13;
        *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v13;
      }
    }
    else if (*(unsigned __int8 *)(v51 + v13) != v9)
    {
      int v65 = 3;
      if (v9 != 1) {
        goto LABEL_115;
      }
      goto LABEL_117;
    }
LABEL_79:
    if ((*(unsigned char *)(*(void *)(result + 32) + v2) & 0x10) == 0)
    {
      int v13 = *(_DWORD *)(*(void *)result + (v2 << 6) + 48);
      uint64_t v54 = *(void *)(result + 24);
      if (*(unsigned __int8 *)(*(void *)(result + 16) + v13) == 255)
      {
        *(unsigned char *)(v54 + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v9;
        *(unsigned char *)(*(void *)(result + 16) + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 0;
        float32x4_t v55 = (_DWORD *)(*(void *)(result + 8) + 8 * v13);
        *float32x4_t v55 = v12;
        v55[1] = v11;
        uint64_t v56 = *(void *)(result + 40);
        if ((*(_DWORD *)(v56 + 4 * v13) & 0x80000000) != 0)
        {
          *(_DWORD *)(v56 + 4 * *(int *)(result + 84)) = v13;
          *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v13;
          if ((*(unsigned char *)(*(void *)(result + 32) + v2) & 0x20) != 0) {
            goto LABEL_91;
          }
          goto LABEL_85;
        }
      }
      else if (*(unsigned __int8 *)(v54 + v13) != v9)
      {
        int v65 = 4;
        if (v9 != 1) {
          goto LABEL_115;
        }
        goto LABEL_117;
      }
    }
    if ((*(unsigned char *)(*(void *)(result + 32) + v2) & 0x20) != 0) {
      goto LABEL_91;
    }
LABEL_85:
    int v13 = *(_DWORD *)(*(void *)result + (v2 << 6) + 52);
    uint64_t v57 = *(void *)(result + 24);
    if (*(unsigned __int8 *)(*(void *)(result + 16) + v13) == 255)
    {
      *(unsigned char *)(v57 + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v9;
      *(unsigned char *)(*(void *)(result + 16) + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 1;
      float32x4_t v58 = (_DWORD *)(*(void *)(result + 8) + 8 * v13);
      *float32x4_t v58 = v12;
      v58[1] = v11;
      uint64_t v59 = *(void *)(result + 40);
      if ((*(_DWORD *)(v59 + 4 * v13) & 0x80000000) != 0)
      {
        *(_DWORD *)(v59 + 4 * *(int *)(result + 84)) = v13;
        *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v13;
      }
    }
    else if (*(unsigned __int8 *)(v57 + v13) != v9)
    {
      int v65 = 5;
      if (v9 == 1) {
        goto LABEL_117;
      }
      goto LABEL_115;
    }
LABEL_91:
    if ((*(unsigned char *)(*(void *)(result + 32) + v2) & 0x40) == 0)
    {
      int v13 = *(_DWORD *)(*(void *)result + (v2 << 6) + 56);
      uint64_t v60 = *(void *)(result + 24);
      if (*(unsigned __int8 *)(*(void *)(result + 16) + v13) == 255)
      {
        *(unsigned char *)(v60 + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v9;
        *(unsigned char *)(*(void *)(result + 16) + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 2;
        float32x4_t v61 = (_DWORD *)(*(void *)(result + 8) + 8 * v13);
        *float32x4_t v61 = v12;
        v61[1] = v11;
        uint64_t v62 = *(void *)(result + 40);
        if ((*(_DWORD *)(v62 + 4 * v13) & 0x80000000) != 0)
        {
          *(_DWORD *)(v62 + 4 * *(int *)(result + 84)) = v13;
          *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v13;
        }
      }
      else if (*(unsigned __int8 *)(v60 + v13) != v9)
      {
        int v65 = 6;
        if (v9 == 1) {
          goto LABEL_117;
        }
LABEL_115:
        *a2 = v13;
        a2[1] = ((_BYTE)v65 + 4) & 7;
        return result;
      }
    }
    if (*(char *)(*(void *)(result + 32) + v2) < 0) {
      goto LABEL_4;
    }
    int v13 = *(_DWORD *)(*(void *)result + (v2 << 6) + 60);
    uint64_t v63 = *(void *)(result + 24);
    if (*(unsigned __int8 *)(*(void *)(result + 16) + v13) != 255) {
      break;
    }
    *(unsigned char *)(v63 + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v9;
    *(unsigned char *)(*(void *)(result + 16) + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = 3;
    float32x4_t v64 = (_DWORD *)(*(void *)(result + 8) + 8 * v13);
    *float32x4_t v64 = v12;
    v64[1] = v11;
    uint64_t v47 = *(void *)(result + 40);
    if ((*(_DWORD *)(v47 + 4 * v13) & 0x80000000) != 0)
    {
LABEL_100:
      *(_DWORD *)(v47 + 4 * *(int *)(result + 84)) = v13;
      *(_DWORD *)(result + 8PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v13;
    }
LABEL_4:
    uint64_t v3 = *(void *)(result + 40);
    uint64_t v4 = 4 * v2;
    *(_DWORD *)(result + 80) = *(_DWORD *)(v3 + v4);
    *(_DWORD *)(v3 + vPCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = -1;
    uint64_t v2 = *(unsigned int *)(result + 80);
    if ((v2 & 0x80000000) != 0) {
      goto LABEL_101;
    }
  }
  if (*(unsigned __int8 *)(v63 + v13) == v9) {
    goto LABEL_4;
  }
  int v65 = 7;
  if (v9 != 1) {
    goto LABEL_115;
  }
LABEL_117:
  *a2 = v2;
  a2[1] = v65;
  return result;
}

void soMaxFlow::Impl::AdoptionStage(soMaxFlow::Impl *this)
{
  uint64_t v56 = (void **)((char *)this + 96);
  for (uint64_t i = *((void *)this + 13); *((void *)this + 12) != i; uint64_t i = *((void *)this + 13))
  {
    uint64_t v5 = *(int *)(i - 4);
    *((void *)this + 1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = i - 4;
    uint64_t v6 = *((void *)this + 3);
    int v7 = *(unsigned __int8 *)(v6 + v5);
    uint64_t v8 = *(void *)this;
    int v9 = -1;
    int v10 = 0x7FFFFFFF;
    int v11 = (char *)&Edge::All;
    do
    {
      uint64_t v12 = *(int *)v11;
      LODWORD(v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = *(_DWORD *)(v8 + (v5 << 6) + 4 * v12 + 32);
      uint64_t v14 = (int)v13;
      if (!*(unsigned char *)(v6 + (int)v13)) {
        goto LABEL_7;
      }
      if (*(unsigned char *)(v6 + (int)v13) == 1)
      {
        if ((*(unsigned __int8 *)(*((void *)this + 4) + (int)v13) >> ((v12 + 4) & 7))) {
          goto LABEL_7;
        }
      }
      else if ((*(char *)(*((void *)this + 4) + v5) >> v12))
      {
        goto LABEL_7;
      }
      if (v7 == *(unsigned __int8 *)(v6 + (int)v13))
      {
        uint64_t v15 = *((void *)this + 2);
        int v16 = *(unsigned __int8 *)(v15 + (int)v13);
        if (v16 != 255)
        {
          uint64_t v17 = *((void *)this + 1);
          int v18 = *((_DWORD *)this + 18);
          uint64_t v19 = v17 + 8 * (int)v13;
          int v21 = *(_DWORD *)(v19 + 4);
          uint64_t v20 = (_DWORD *)(v19 + 4);
          if (v21 == v18)
          {
            int v22 = 0;
            uint64_t v13 = (int)v13;
LABEL_21:
            v22 += *(_DWORD *)(v17 + 8 * v13);
            int v23 = 1;
            if (v16 == 254) {
              goto LABEL_22;
            }
          }
          else
          {
            int v22 = 0;
            while (1)
            {
              uint64_t v13 = (int)v13;
              if (*(char *)(v15 + (int)v13) < 0) {
                break;
              }
              LODWORD(v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = *(_DWORD *)(v8 + ((uint64_t)(int)v13 << 6) + 4 * *(unsigned __int8 *)(v15 + (int)v13) + 32);
              ++v22;
              if (*(_DWORD *)(v17 + 8 * (int)v13 + 4) == v18)
              {
                uint64_t v13 = (int)v13;
                int v16 = *(unsigned __int8 *)(v15 + (int)v13);
                goto LABEL_21;
              }
            }
            int v23 = 0;
            int v16 = *(unsigned __int8 *)(v15 + (int)v13);
            if (v16 == 254)
            {
LABEL_22:
              uint64_t v24 = (_DWORD *)(v17 + 8 * v13);
              *uint64_t v24 = 1;
              v24[1] = v18;
              int v16 = *(unsigned __int8 *)(v15 + v13);
            }
          }
          if (((v16 != 254) & ~v23) == 0)
          {
            if (v22 < v10)
            {
              int v9 = v12;
              int v10 = v22;
            }
            if (*v20 != v18)
            {
              do
              {
                *(_DWORD *)(v17 + 8 * v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v22;
                *uint64_t v20 = v18;
                uint64_t v14 = *(int *)(v8 + (v14 << 6) + 4 * *(char *)(v15 + v14) + 32);
                --v22;
                uint64_t v25 = v17 + 8 * v14;
                int v26 = *(_DWORD *)(v25 + 4);
                uint64_t v20 = (_DWORD *)(v25 + 4);
              }
              while (v26 != v18);
            }
          }
        }
      }
LABEL_7:
      v11 += 4;
    }
    while (v11 != "9soMaxFlow");
    *(unsigned char *)(*((void *)this + 2) + v5) = v9;
    if (v9 < 0)
    {
      long long v27 = (char *)&Edge::All;
      int v55 = v7;
      while (1)
      {
        uint64_t v29 = *(int *)v27;
        int v30 = *(_DWORD *)(*(void *)this + (v5 << 6) + 4 * v29 + 32);
        uint64_t v31 = v30;
        if (v7 != *(unsigned __int8 *)(*((void *)this + 3) + v30)) {
          goto LABEL_34;
        }
        uint64_t v32 = *((void *)this + 2);
        if (*(unsigned __int8 *)(v32 + v30) == 255) {
          goto LABEL_34;
        }
        uint64_t v33 = *((void *)this + 5);
        if ((*(_DWORD *)(v33 + 4 * v30) & 0x80000000) != 0)
        {
          if (v7 == 1)
          {
            if ((*(unsigned __int8 *)(*((void *)this + 4) + v30) >> ((v29 + 4) & 7))) {
              goto LABEL_38;
            }
          }
          else if ((*(char *)(*((void *)this + 4) + v5) >> v29))
          {
            goto LABEL_38;
          }
          uint64_t v54 = *((unsigned int *)this + 21);
          if ((v54 & 0x80000000) != 0) {
            *((_DWORD *)this + 20) = v30;
          }
          else {
            *(_DWORD *)(v33 + 4 * v5PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v30;
          }
          *((_DWORD *)this + 2PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = v30;
        }
LABEL_38:
        if ((((_BYTE)v29 + 4) & 7) != *(unsigned char *)(v32 + v30)) {
          goto LABEL_34;
        }
        long long v35 = (char *)*((void *)this + 13);
        unint64_t v34 = *((void *)this + 14);
        if ((unint64_t)v35 >= v34)
        {
          uint64_t v36 = (char *)*v56;
          uint64_t v37 = v35 - (unsigned char *)*v56;
          uint64_t v38 = v37 >> 2;
          unint64_t v39 = (v37 >> 2) + 1;
          if (v39 >> 62) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v40 = v34 - (void)v36;
          if (v40 >> 1 > v39) {
            unint64_t v39 = v40 >> 1;
          }
          if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v39 = 0x3FFFFFFFFFFFFFFFLL;
          }
          unint64_t v57 = v39;
          if (v39)
          {
            if (v39 >> 62) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            uint64_t v41 = v35 - (unsigned char *)*v56;
            uint64_t v42 = operator new(4 * v39);
            uint64_t v37 = v41;
            int v7 = v55;
            float32x4_t v43 = &v42[4 * v38];
            *float32x4_t v43 = v30;
            uint64_t v28 = (uint64_t)(v43 + 1);
            if (v35 != v36) {
              goto LABEL_48;
            }
LABEL_64:
            *((void *)this + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v43;
            *((void *)this + 1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v28;
            *((void *)this + 1PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = &v42[4 * v57];
            if (!v36) {
              goto LABEL_33;
            }
          }
          else
          {
            uint64_t v42 = 0;
            float32x4_t v43 = (_DWORD *)(4 * v38);
            *(_DWORD *)(4 * v38) = v30;
            uint64_t v28 = 4 * v38 + 4;
            if (v35 == v36) {
              goto LABEL_64;
            }
LABEL_48:
            unint64_t v44 = v35 - 4 - v36;
            if (v44 < 0x2C) {
              goto LABEL_73;
            }
            if ((unint64_t)(v35 - &v42[v37]) < 0x20) {
              goto LABEL_73;
            }
            uint64_t v45 = (v44 >> 2) + 1;
            uint64_t v46 = 4 * (v45 & 0x7FFFFFFFFFFFFFF8);
            uint64_t v47 = &v35[-v46];
            float32x4_t v43 = (_DWORD *)((char *)v43 - v46);
            uint64_t v48 = &v42[4 * v38 - 16];
            int32x4_t v49 = v35 - 16;
            uint64_t v50 = v45 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v51 = *(_OWORD *)v49;
              *(v48 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *((_OWORD *)v49 - 1);
              *uint64_t v48 = v51;
              v48 -= 2;
              v49 -= 32;
              v50 -= 8;
            }
            while (v50);
            long long v35 = v47;
            if (v45 != (v45 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_73:
              do
              {
                int v52 = *((_DWORD *)v35 - 1);
                v35 -= 4;
                *--float32x4_t v43 = v52;
              }
              while (v35 != v36);
            }
            *((void *)this + 1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v43;
            *((void *)this + 1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v28;
            *((void *)this + 1PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = &v42[4 * v57];
            if (!v36) {
              goto LABEL_33;
            }
          }
          uint64_t v53 = v28;
          operator delete(v36);
          uint64_t v28 = v53;
          uint64_t v32 = *((void *)this + 2);
          goto LABEL_33;
        }
        *(_DWORD *)long long v35 = v30;
        uint64_t v28 = (uint64_t)(v35 + 4);
LABEL_33:
        *((void *)this + 1PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = v28;
        *(unsigned char *)(v32 + v3PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = -4;
LABEL_34:
        v27 += 4;
        if (v27 == "9soMaxFlow") {
          goto LABEL_5;
        }
      }
    }
    int v3 = *((_DWORD *)this + 18);
    uint64_t v4 = (int *)(*((void *)this + 1) + 8 * v5);
    *uint64_t v4 = v10;
    v4[1] = v3;
LABEL_5:
    ;
  }
}

void soMaxFlow::Impl::UpdateFlow(uint64_t a1, int *a2, float a3)
{
  uint64_t v4 = a2;
  *(float *)(a1 + 76) = *(float *)(a1 + 76) + a3;
  int v6 = *a2;
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = *a2;
  if ((*(char *)(v7 + v8) & 0x80000000) == 0)
  {
    unsigned int v9 = *(unsigned __int8 *)(v7 + v8);
    float32x4_t v127 = (void **)(a1 + 96);
    while (1)
    {
      uint64_t v11 = *(void *)a1 + (v8 << 6);
      uint64_t v12 = 4 * v9;
      float v13 = *(float *)(v11 + v12) + a3;
      *(float *)(v11 + v1PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v13;
      *(unsigned char *)(*(void *)(a1 + 32) + v8) = *(unsigned char *)(*(void *)(a1 + 32) + v8) & ~(1 << v9) | ((v13 == 0.0) << v9);
      int v14 = *(_DWORD *)(*(void *)a1 + (v8 << 6) + v12 + 32);
      unsigned int v15 = ((_BYTE)v9 + 4) & 7;
      uint64_t v16 = *(void *)a1 + ((uint64_t)v14 << 6);
      uint64_t v17 = 4 * v15;
      float v18 = *(float *)(v16 + v17) - a3;
      *(float *)(v16 + v17) = v18;
      LODWORD(v16) = (v18 == 0.0) << v15;
      int v19 = 1 << v15;
      *(unsigned char *)(*(void *)(a1 + 32) + v1PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = *(unsigned char *)(*(void *)(a1 + 32) + v14) & ~(_BYTE)v19 | v16;
      if ((v19 & *(unsigned char *)(*(void *)(a1 + 32) + v14)) == 0) {
        goto LABEL_5;
      }
      *(unsigned char *)(*(void *)(a1 + 16) + v8) = -4;
      int v21 = *(char **)(a1 + 104);
      unint64_t v20 = *(void *)(a1 + 112);
      if ((unint64_t)v21 >= v20) {
        break;
      }
      *(_DWORD *)int v21 = v6;
      uint64_t v10 = (uint64_t)(v21 + 4);
LABEL_4:
      *(void *)(a1 + 10PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v10;
LABEL_5:
      uint64_t v7 = *(void *)(a1 + 16);
      unsigned int v9 = *(unsigned __int8 *)(v7 + v14);
      uint64_t v8 = v14;
      int v6 = v14;
      if (*(char *)(v7 + v14) < 0)
      {
        uint64_t v8 = v14;
        int v6 = v14;
        uint64_t v4 = a2;
        goto LABEL_29;
      }
    }
    int v22 = (char *)*v127;
    uint64_t v23 = v21 - (unsigned char *)*v127;
    uint64_t v24 = v23 >> 2;
    unint64_t v25 = (v23 >> 2) + 1;
    if (v25 >> 62) {
LABEL_104:
    }
      std::vector<double>::__throw_length_error[abi:ne180100]();
    uint64_t v26 = v20 - (void)v22;
    if (v26 >> 1 > v25) {
      unint64_t v25 = v26 >> 1;
    }
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v27 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v25;
    }
    if (v27)
    {
      if (v27 >> 62) {
        goto LABEL_105;
      }
      uint64_t v28 = operator new(4 * v27);
      uint64_t v29 = &v28[4 * v24];
      _DWORD *v29 = v6;
      uint64_t v10 = (uint64_t)(v29 + 1);
      if (v21 == v22) {
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v28 = 0;
      uint64_t v29 = (_DWORD *)(4 * v24);
      *(_DWORD *)(4 * v2PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v6;
      uint64_t v10 = 4 * v24 + 4;
      if (v21 == v22)
      {
LABEL_25:
        *(void *)(a1 + 96) = v29;
        *(void *)(a1 + 10PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v10;
        *(void *)(a1 + 11PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = &v28[4 * v27];
        if (v22) {
          operator delete(v22);
        }
        goto LABEL_4;
      }
    }
    unint64_t v30 = v21 - 4 - v22;
    if (v30 < 0x2C) {
      goto LABEL_109;
    }
    if ((unint64_t)(v21 - &v28[v23]) < 0x20) {
      goto LABEL_109;
    }
    uint64_t v31 = (v30 >> 2) + 1;
    uint64_t v32 = 4 * (v31 & 0x7FFFFFFFFFFFFFF8);
    uint64_t v33 = &v21[-v32];
    uint64_t v29 = (_DWORD *)((char *)v29 - v32);
    unint64_t v34 = &v28[4 * v24 - 16];
    long long v35 = v21 - 16;
    uint64_t v36 = v31 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      long long v37 = *(_OWORD *)v35;
      *(v34 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *((_OWORD *)v35 - 1);
      *unint64_t v34 = v37;
      v34 -= 2;
      v35 -= 32;
      v36 -= 8;
    }
    while (v36);
    int v21 = v33;
    if (v31 != (v31 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_109:
      do
      {
        int v38 = *((_DWORD *)v21 - 1);
        v21 -= 4;
        *--uint64_t v29 = v38;
      }
      while (v21 != v22);
    }
    goto LABEL_25;
  }
LABEL_29:
  uint64_t v39 = *(void *)(a1 + 48);
  float v40 = *(float *)(v39 + 4 * v8) - a3;
  *(float *)(v39 + 4 * v8) = v40;
  if (v40 != 0.0) {
    goto LABEL_52;
  }
  *(unsigned char *)(v7 + v8) = -4;
  uint64_t v42 = *(char **)(a1 + 104);
  unint64_t v41 = *(void *)(a1 + 112);
  if ((unint64_t)v42 >= v41)
  {
    unint64_t v44 = *(char **)(a1 + 96);
    uint64_t v45 = (v42 - v44) >> 2;
    unint64_t v46 = v45 + 1;
    if ((unint64_t)(v45 + 1) >> 62) {
      goto LABEL_106;
    }
    uint64_t v47 = v41 - (void)v44;
    if (v47 >> 1 > v46) {
      unint64_t v46 = v47 >> 1;
    }
    if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v48 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v48 = v46;
    }
    if (v48)
    {
      if (v48 >> 62) {
        goto LABEL_105;
      }
      int32x4_t v49 = operator new(4 * v48);
      uint64_t v50 = &v49[4 * v45];
      long long v51 = &v49[4 * v48];
      *uint64_t v50 = v6;
      uint64_t v43 = (uint64_t)(v50 + 1);
      int64_t v52 = v42 - v44;
      if (v42 == v44) {
        goto LABEL_49;
      }
    }
    else
    {
      int32x4_t v49 = 0;
      uint64_t v50 = (_DWORD *)(4 * v45);
      long long v51 = 0;
      *(_DWORD *)(4 * v45) = v6;
      uint64_t v43 = 4 * v45 + 4;
      int64_t v52 = v42 - v44;
      if (v42 == v44)
      {
LABEL_49:
        *(void *)(a1 + 96) = v50;
        *(void *)(a1 + 10PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v43;
        *(void *)(a1 + 11PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v51;
        if (v44) {
          operator delete(v44);
        }
        goto LABEL_51;
      }
    }
    unint64_t v53 = v52 - 4;
    if (v53 < 0x2C) {
      goto LABEL_110;
    }
    if ((unint64_t)(v44 - v49) < 0x20) {
      goto LABEL_110;
    }
    uint64_t v54 = (v53 >> 2) + 1;
    uint64_t v55 = 4 * (v54 & 0x7FFFFFFFFFFFFFF8);
    uint64_t v56 = &v42[-v55];
    uint64_t v50 = (_DWORD *)((char *)v50 - v55);
    unint64_t v57 = &v49[4 * v45 - 16];
    float32x4_t v58 = v42 - 16;
    uint64_t v59 = v54 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      long long v60 = *(_OWORD *)v58;
      *(v57 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *((_OWORD *)v58 - 1);
      *unint64_t v57 = v60;
      v57 -= 2;
      v58 -= 32;
      v59 -= 8;
    }
    while (v59);
    uint64_t v42 = v56;
    if (v54 != (v54 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_110:
      do
      {
        int v61 = *((_DWORD *)v42 - 1);
        v42 -= 4;
        *--uint64_t v50 = v61;
      }
      while (v42 != v44);
    }
    goto LABEL_49;
  }
  *(_DWORD *)uint64_t v42 = v6;
  uint64_t v43 = (uint64_t)(v42 + 4);
LABEL_51:
  *(void *)(a1 + 10PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v43;
LABEL_52:
  int v62 = v4[1];
  uint64_t v63 = *v4;
  uint64_t v64 = *(void *)a1 + (v63 << 6);
  uint64_t v65 = 4 * v62;
  float v66 = *(float *)(v64 + v65) - a3;
  *(float *)(v64 + v65) = v66;
  *(unsigned char *)(*(void *)(a1 + 32) + v6PCSharedCount::PCSharedCount((PCSharedCount *)this + 3) = *(unsigned char *)(*(void *)(a1 + 32) + v63) & ~(1 << v62) | ((v66 == 0.0) << v62);
  int v67 = *(_DWORD *)(*(void *)a1 + (v63 << 6) + v65 + 32);
  LODWORD(v6PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = ((_BYTE)v62 + 4) & 7;
  uint64_t v68 = v67;
  uint64_t v69 = *(void *)a1 + ((uint64_t)v67 << 6);
  uint64_t v70 = 4 * v64;
  float v71 = *(float *)(v69 + v70) + a3;
  *(float *)(v69 + v70) = v71;
  *(unsigned char *)(*(void *)(a1 + 32) + v67) = *(unsigned char *)(*(void *)(a1 + 32) + v67) & ~(1 << v64) | ((v71 == 0.0) << v64);
  uint64_t v72 = *(void *)(a1 + 16);
  if (*(char *)(v72 + v67) < 0) {
    goto LABEL_80;
  }
  unsigned int v73 = *(unsigned __int8 *)(v72 + v67);
  int v128 = (void **)(a1 + 96);
  do
  {
    uint64_t v75 = *(void *)a1 + (v68 << 6);
    uint64_t v76 = 4 * v73;
    float v77 = *(float *)(v75 + v76) - a3;
    *(float *)(v75 + v76) = v77;
    int v78 = 1 << v73;
    *(unsigned char *)(*(void *)(a1 + 32) + v68) = *(unsigned char *)(*(void *)(a1 + 32) + v68) & ~(1 << v73) | ((v77 == 0.0) << v73);
    int v79 = *(_DWORD *)(*(void *)a1 + (v68 << 6) + v76 + 32);
    unsigned int v80 = ((_BYTE)v73 + 4) & 7;
    uint64_t v81 = *(void *)a1 + ((uint64_t)v79 << 6);
    uint64_t v82 = 4 * v80;
    float v83 = *(float *)(v81 + v82) + a3;
    *(float *)(v81 + v8PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v83;
    *(unsigned char *)(*(void *)(a1 + 32) + v79) = *(unsigned char *)(*(void *)(a1 + 32) + v79) & ~(1 << v80) | ((v83 == 0.0) << v80);
    if ((v78 & *(char *)(*(void *)(a1 + 32) + v68)) != 0)
    {
      *(unsigned char *)(*(void *)(a1 + 16) + v68) = -4;
      float32x4_t v85 = *(char **)(a1 + 104);
      unint64_t v84 = *(void *)(a1 + 112);
      if ((unint64_t)v85 < v84)
      {
        *(_DWORD *)float32x4_t v85 = v67;
        uint64_t v74 = (uint64_t)(v85 + 4);
LABEL_55:
        *(void *)(a1 + 10PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v74;
        goto LABEL_56;
      }
      float32x4_t v86 = (char *)*v128;
      uint64_t v87 = v85 - (unsigned char *)*v128;
      uint64_t v88 = v87 >> 2;
      unint64_t v89 = (v87 >> 2) + 1;
      if (v89 >> 62) {
        goto LABEL_104;
      }
      uint64_t v90 = v84 - (void)v86;
      if (v90 >> 1 > v89) {
        unint64_t v89 = v90 >> 1;
      }
      if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v91 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v91 = v89;
      }
      if (v91)
      {
        if (v91 >> 62) {
          goto LABEL_105;
        }
        int32x4_t v92 = operator new(4 * v91);
        float32x4_t v93 = &v92[4 * v88];
        *float32x4_t v93 = v67;
        uint64_t v74 = (uint64_t)(v93 + 1);
        if (v85 == v86) {
          goto LABEL_76;
        }
      }
      else
      {
        int32x4_t v92 = 0;
        float32x4_t v93 = (_DWORD *)(4 * v88);
        *(_DWORD *)(4 * v88) = v67;
        uint64_t v74 = 4 * v88 + 4;
        if (v85 == v86)
        {
LABEL_76:
          *(void *)(a1 + 96) = v93;
          *(void *)(a1 + 10PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v74;
          *(void *)(a1 + 11PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = &v92[4 * v91];
          if (v86) {
            operator delete(v86);
          }
          goto LABEL_55;
        }
      }
      unint64_t v94 = v85 - 4 - v86;
      if (v94 < 0x2C) {
        goto LABEL_111;
      }
      if ((unint64_t)(v85 - &v92[v87]) < 0x20) {
        goto LABEL_111;
      }
      uint64_t v95 = (v94 >> 2) + 1;
      uint64_t v96 = 4 * (v95 & 0x7FFFFFFFFFFFFFF8);
      float32x4_t v97 = &v85[-v96];
      float32x4_t v93 = (_DWORD *)((char *)v93 - v96);
      int32x4_t v98 = &v92[4 * v88 - 16];
      uint64_t v99 = v85 - 16;
      uint64_t v100 = v95 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v101 = *(_OWORD *)v99;
        *(v98 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *((_OWORD *)v99 - 1);
        *int32x4_t v98 = v101;
        v98 -= 2;
        v99 -= 32;
        v100 -= 8;
      }
      while (v100);
      float32x4_t v85 = v97;
      if (v95 != (v95 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_111:
        do
        {
          int v102 = *((_DWORD *)v85 - 1);
          v85 -= 4;
          *--float32x4_t v93 = v102;
        }
        while (v85 != v86);
      }
      goto LABEL_76;
    }
LABEL_56:
    uint64_t v72 = *(void *)(a1 + 16);
    unsigned int v73 = *(unsigned __int8 *)(v72 + v79);
    uint64_t v68 = v79;
    int v67 = v79;
  }
  while ((*(char *)(v72 + v79) & 0x80000000) == 0);
  uint64_t v68 = v79;
  int v67 = v79;
LABEL_80:
  uint64_t v103 = *(void *)(a1 + 48);
  float v104 = *(float *)(v103 + 4 * v68) + a3;
  *(float *)(v103 + 4 * v68) = v104;
  if (v104 != 0.0) {
    return;
  }
  *(unsigned char *)(v72 + v68) = -4;
  int32x4_t v106 = *(char **)(a1 + 104);
  unint64_t v105 = *(void *)(a1 + 112);
  if ((unint64_t)v106 < v105)
  {
    *(_DWORD *)int32x4_t v106 = v67;
    uint64_t v107 = (uint64_t)(v106 + 4);
    goto LABEL_102;
  }
  int32x4_t v108 = *(char **)(a1 + 96);
  uint64_t v109 = (v106 - v108) >> 2;
  unint64_t v110 = v109 + 1;
  if ((unint64_t)(v109 + 1) >> 62) {
LABEL_106:
  }
    std::vector<double>::__throw_length_error[abi:ne180100]();
  uint64_t v111 = v105 - (void)v108;
  if (v111 >> 1 > v110) {
    unint64_t v110 = v111 >> 1;
  }
  if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v112 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v112 = v110;
  }
  if (!v112)
  {
    float32x4_t v113 = 0;
    uint64_t v114 = (_DWORD *)(4 * v109);
    float32x4_t v115 = 0;
    *(_DWORD *)(4 * v109) = v67;
    uint64_t v107 = 4 * v109 + 4;
    int64_t v116 = v106 - v108;
    if (v106 == v108) {
      goto LABEL_100;
    }
LABEL_94:
    unint64_t v117 = v116 - 4;
    if (v117 < 0x2C) {
      goto LABEL_112;
    }
    if ((unint64_t)(v108 - v113) < 0x20) {
      goto LABEL_112;
    }
    uint64_t v118 = (v117 >> 2) + 1;
    uint64_t v119 = 4 * (v118 & 0x7FFFFFFFFFFFFFF8);
    int32x4_t v120 = &v106[-v119];
    uint64_t v114 = (_DWORD *)((char *)v114 - v119);
    float32x4_t v121 = &v113[4 * v109 - 16];
    float32x4_t v122 = v106 - 16;
    uint64_t v123 = v118 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      long long v124 = *(_OWORD *)v122;
      *(v121 - PCCFRef<CGColorSpace *>::~PCCFRef(this + 1) = *((_OWORD *)v122 - 1);
      *float32x4_t v121 = v124;
      v121 -= 2;
      v122 -= 32;
      v123 -= 8;
    }
    while (v123);
    int32x4_t v106 = v120;
    if (v118 != (v118 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_112:
      do
      {
        int v125 = *((_DWORD *)v106 - 1);
        v106 -= 4;
        *--uint64_t v114 = v125;
      }
      while (v106 != v108);
    }
    goto LABEL_100;
  }
  if (v112 >> 62) {
LABEL_105:
  }
    std::__throw_bad_array_new_length[abi:ne180100]();
  float32x4_t v113 = operator new(4 * v112);
  uint64_t v114 = &v113[4 * v109];
  float32x4_t v115 = &v113[4 * v112];
  *uint64_t v114 = v67;
  uint64_t v107 = (uint64_t)(v114 + 1);
  int64_t v116 = v106 - v108;
  if (v106 != v108) {
    goto LABEL_94;
  }
LABEL_100:
  *(void *)(a1 + 96) = v114;
  *(void *)(a1 + 10PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v107;
  *(void *)(a1 + 11PCCFRef<CGColorSpace *>::~PCCFRef(this + 2) = v115;
  if (v108) {
    operator delete(v108);
  }
LABEL_102:
  *(void *)(a1 + 10PCSharedCount::PCSharedCount((PCSharedCount *)this + 4) = v107;
}