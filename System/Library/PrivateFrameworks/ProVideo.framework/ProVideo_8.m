void HgcYUV422TriPlanar_2020ToRGB::InitProgramDescriptor(HgcYUV422TriPlanar_2020ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422TriPlanar_2020ToRGB_hgc_visible", "//Metal1.0     \n//LEN=0000000311\n[[ visible ]] FragmentOut HgcYUV422TriPlanar_2020ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 color2,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
    "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV422TriPlanar_2020ToRGB");
}

void sub_1B78E34B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78E34F8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78E34F0);
}

char *HgcYUV422TriPlanar_2020ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375E40;
  strcpy(result, "HgcYUV422TriPlanar_2020ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::BindTexture(HgcYUV422TriPlanar_2020ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 != 2)
    {
      if (a3 != 1) {
        return 0xFFFFFFFFLL;
      }
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2); {
      (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 0.5, 1.0, 1.0);
      }
      return 0;
    }
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    int v6 = 2;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    v5 = a2;
    int v6 = 0;
  }
  HGHandler::TexCoord(v5, v6, 0, 0, 0);
  int v7 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v7)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::Bind(HgcYUV422TriPlanar_2020ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::RenderTile(HgcYUV422TriPlanar_2020ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    float32x4_t v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B8375E70);
    int32x2_t v8 = a2[2];
    int32x2_t v9 = a2[14];
    int32x2_t v10 = a2[10];
    uint64_t v11 = 16 * a2[11].i32[0];
    uint64_t v12 = 16 * a2[15].i32[0];
    uint64_t v13 = 16 * a2[3].i32[0];
    __asm { FMOV            V4.4S, #4.0 }
    v19.i64[0] = 0x3F0000003F000000;
    v19.i64[1] = 0x3F0000003F000000;
    while (v6 < 4)
    {
      LODWORD(v66) = 0;
      float32x4_t v21 = 0uLL;
      if (v6 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      ++v4;
      float32x4_t v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B7E736C0);
      *(void *)&v10 += v11;
      *(void *)&v9 += v12;
      *(void *)&v8 += v13;
      if (v4 == v3) {
        return 0;
      }
    }
    int v20 = 0;
    float32x4_t v21 = 0uLL;
    uint64_t v22 = 32;
    do
    {
      float32x4_t v23 = vaddq_f32(v7, vmulq_f32(v21, (float32x4_t)xmmword_1B7E75B20));
      float32x4_t v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B7E75B20);
      int32x2_t v27 = a2[12];
      __int32 v28 = a2[13].i32[0];
      float32x4_t v29 = vaddq_f32(vsubq_f32(v23, v5), v19);
      int32x4_t v30 = vcvtq_s32_f32(v29);
      v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
      __int32 v31 = v29.i32[1];
      __int32 v32 = v29.i32[0];
      float32x4_t v33 = vaddq_f32(vsubq_f32(v24, v5), v19);
      int32x4_t v34 = vcvtq_s32_f32(v33);
      v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      int8x16_t v35 = *(int8x16_t *)(*(void *)&v27 + 16 * (v32 + v31 * v28));
      __int32 v36 = v33.i32[1];
      __int32 v37 = v33.i32[0];
      float32x4_t v38 = vaddq_f32(vsubq_f32(v25, v5), v19);
      int32x4_t v39 = vcvtq_s32_f32(v38);
      v38.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v38)).u64[0];
      int8x16_t v40 = *(int8x16_t *)(*(void *)&v27 + 16 * (v37 + v36 * v28));
      __int32 v41 = v38.i32[1];
      __int32 v42 = v38.i32[0];
      float32x4_t v43 = vaddq_f32(vsubq_f32(v26, v5), v19);
      int32x4_t v44 = vcvtq_s32_f32(v43);
      v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
      int8x16_t v45 = *(int8x16_t *)(*(void *)&v27 + 16 * (v42 + v41 * v28));
      int8x16_t v46 = *(int8x16_t *)(*(void *)&v27 + 16 * (v43.i32[0] + v43.i32[1] * v28));
      uint64_t v47 = *((void *)this + 51);
      int8x16_t v48 = *(int8x16_t *)(v47 + 32);
      float32x4_t v49 = *(float32x4_t *)(v47 + 48);
      float32x4_t v50 = *(float32x4_t *)(v47 + 16);
      float32x4_t v51 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(void *)&v10 + v22 - 32), vextq_s8(v35, v35, 0xCuLL))));
      float32x4_t v52 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(void *)&v10 + v22 - 16), vextq_s8(v40, v40, 0xCuLL))));
      float32x4_t v53 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(void *)&v10 + v22), vextq_s8(v45, v45, 0xCuLL))));
      float32x4_t v54 = vaddq_f32(v50, vmulq_f32(*(float32x4_t *)v47, (float32x4_t)vbslq_s8(v48, *(int8x16_t *)(*(void *)&v10 + v22 + 16), vextq_s8(v46, v46, 0xCuLL))));
      float32x4_t v55 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v51.f32, 1));
      float32x4_t v56 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v52.f32, 1));
      int8x16_t v57 = *(int8x16_t *)(*(void *)&v9 + v22 - 32);
      int8x16_t v58 = *(int8x16_t *)(*(void *)&v9 + v22 - 16);
      v57.i64[1] = v51.i64[1];
      float32x4_t v59 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v53.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v53.f32, 1));
      int8x16_t v61 = *(int8x16_t *)(*(void *)&v9 + v22);
      int8x16_t v60 = *(int8x16_t *)(*(void *)&v9 + v22 + 16);
      v58.i64[1] = v52.i64[1];
      v61.i64[1] = v53.i64[1];
      float32x4_t v62 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v49, *(float32x2_t *)v54.f32, 1));
      v60.i64[1] = v54.i64[1];
      float32x4_t v63 = *(float32x4_t *)(v47 + 64);
      int8x16_t v64 = *(int8x16_t *)(v47 + 80);
      float32x4_t v21 = vaddq_f32(v21, _Q4);
      v65 = (int8x16_t *)(*(void *)&v8 + v22);
      v65[-2] = vbslq_s8(v64, vextq_s8(v57, v57, 4uLL), (int8x16_t)vaddq_f32(v55, vmulq_laneq_f32(v63, v51, 2)));
      v65[-1] = vbslq_s8(v64, vextq_s8(v58, v58, 4uLL), (int8x16_t)vaddq_f32(v56, vmulq_laneq_f32(v63, v52, 2)));
      int8x16_t *v65 = vbslq_s8(v64, vextq_s8(v61, v61, 4uLL), (int8x16_t)vaddq_f32(v59, vmulq_laneq_f32(v63, v53, 2)));
      v65[1] = vbslq_s8(v64, vextq_s8(v60, v60, 4uLL), (int8x16_t)vaddq_f32(v62, vmulq_laneq_f32(v63, v54, 2)));
      v20 -= 4;
      v22 += 64;
    }
    while (v6 + v20 > 3);
    LODWORD(v66) = -v20;
    if ((int)v66 >= v6) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v66 = v66;
    do
    {
      float32x4_t v67 = vaddq_f32(vsubq_f32(vaddq_f32(v7, vmulq_f32(v21, (float32x4_t)xmmword_1B7E75B20)), v5), v19);
      int32x4_t v68 = vcvtq_s32_f32(v67);
      v67.i64[0] = vaddq_s32(v68, vcgtq_f32(vcvtq_f32_s32(v68), v67)).u64[0];
      int8x16_t v69 = *(int8x16_t *)(*(void *)&a2[12] + 16 * (v67.i32[0] + v67.i32[1] * a2[13].i32[0]));
      uint64_t v70 = *((void *)this + 51);
      float32x4_t v71 = vaddq_f32(*(float32x4_t *)(v70 + 16), vmulq_f32(*(float32x4_t *)v70, (float32x4_t)vbslq_s8(*(int8x16_t *)(v70 + 32), *(int8x16_t *)(*(void *)&v10 + 16 * v66), vextq_s8(v69, v69, 0xCuLL))));
      int8x16_t v72 = *(int8x16_t *)(*(void *)&v9 + 16 * v66);
      v72.i64[1] = v71.i64[1];
      *(int8x16_t *)(*(void *)&v8 + 16 * v66) = vbslq_s8(*(int8x16_t *)(v70 + 80), vextq_s8(v72, v72, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v70 + 64), v71, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v70 + 48), *(float32x2_t *)v71.f32, 1))));
      __asm { FMOV            V7.4S, #1.0 }
      float32x4_t v21 = vaddq_f32(v21, _Q7);
      ++v66;
    }
    while (v66 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::GetDOD(HgcYUV422TriPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  if (!a3 || a3 == 2) {
    return v5;
  }
  if (a3 == 1)
  {
    uint64_t v6 = HGRectMake4i(0, 0, 1u, 0);
    int v7 = HGRectGrow(v5, v4, v6);
    float v8 = HGRectFloat(v7);
    float v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    uint64_t v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::GetROI(HgcYUV422TriPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result = *(void *)&a4.var0;
  if (a3 && a3 != 2)
  {
    if (a3 == 1)
    {
      float v5 = HGRectFloat(a4.var0);
      float v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      uint64_t v16 = v15;
      uint64_t v17 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
      uint64_t v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV422TriPlanar_2020ToRGB::HgcYUV422TriPlanar_2020ToRGB(HgcYUV422TriPlanar_2020ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10E8A30;
  operator new();
}

void sub_1B78E3E68(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422TriPlanar_2020ToRGB::~HgcYUV422TriPlanar_2020ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10E8A30;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10E8A30;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E8A30;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::SetParameter(HgcYUV422TriPlanar_2020ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  double v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *double v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV422TriPlanar_2020ToRGB::GetParameter(HgcYUV422TriPlanar_2020ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  float v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV444TriPlanar_601ToRGB::GetProgram(HgcYUV444TriPlanar_601ToRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const half4 c1 = half4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6c0cd9a4:962f63d5:0783359b:49528c86\n"
             "//SIG=00400000:00000007:00000007:00000007:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004b8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=24010ee7:6e1cd76d:c31b9c85:b9fbda97\n"
             "//SIG=00000000:00000007:00000007:00000000:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000473\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    r0.x = texture2D(hg_Texture2, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.x;\n"
           "}\n"
           "//MD5=6448df2f:b4b78b65:3a0dc9a8:4e1d16fb\n"
           "//SIG=00000000:00000007:00000007:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcYUV444TriPlanar_601ToRGB::InitProgramDescriptor(HgcYUV444TriPlanar_601ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444TriPlanar_601ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002a7\n[[ visible ]] FragmentOut HgcYUV444TriPlanar_601ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2)\n{\n    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
    "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = color1.xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV444TriPlanar_601ToRGB");
}

void sub_1B78E44A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78E44DC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78E44D4);
}

char *HgcYUV444TriPlanar_601ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375DB0;
  strcpy(result, "HgcYUV444TriPlanar_601ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV444TriPlanar_601ToRGB::BindTexture(HgcYUV444TriPlanar_601ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 == 2)
    {
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 2;
    }
    else
    {
      if (a3 != 1) {
        return 0xFFFFFFFFLL;
      }
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 1;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444TriPlanar_601ToRGB::Bind(HgcYUV444TriPlanar_601ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV444TriPlanar_601ToRGB::RenderTile(HgcYUV444TriPlanar_601ToRGB *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((int *)a2 + 6);
    uint64_t v6 = *((void *)a2 + 2);
    uint64_t v7 = *((void *)a2 + 14);
    uint64_t v8 = *((void *)a2 + 10);
    uint64_t v9 = 16 * *((int *)a2 + 22);
    uint64_t v10 = 16 * *((int *)a2 + 26);
    uint64_t v11 = *((void *)a2 + 12);
    uint64_t v12 = 16 * *((int *)a2 + 30);
    uint64_t v13 = 16 * v5;
    while (v4 < 4)
    {
      LODWORD(v35) = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      ++v3;
      v8 += v9;
      v11 += v10;
      v7 += v12;
      v6 += v13;
      if (v3 == v2) {
        return 0;
      }
    }
    uint64_t v14 = 0;
    int v15 = 0;
    do
    {
      uint64_t v16 = *((void *)this + 51);
      int8x16_t v17 = *(int8x16_t *)(v16 + 32);
      float32x4_t v18 = *(float32x4_t *)(v16 + 48);
      float32x4_t v19 = *(float32x4_t *)(v16 + 16);
      float32x4_t v20 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14), vextq_s8(*(int8x16_t *)(v11 + v14), *(int8x16_t *)(v11 + v14), 0xCuLL))));
      float32x4_t v21 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 16), vextq_s8(*(int8x16_t *)(v11 + v14 + 16), *(int8x16_t *)(v11 + v14 + 16), 0xCuLL))));
      float32x4_t v22 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 32), vextq_s8(*(int8x16_t *)(v11 + v14 + 32), *(int8x16_t *)(v11 + v14 + 32), 0xCuLL))));
      float32x4_t v23 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 48), vextq_s8(*(int8x16_t *)(v11 + v14 + 48), *(int8x16_t *)(v11 + v14 + 48), 0xCuLL))));
      float32x4_t v24 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v20.f32, 1));
      int8x16_t v25 = *(int8x16_t *)(v7 + v14);
      int8x16_t v26 = *(int8x16_t *)(v7 + v14 + 16);
      v25.i64[1] = v20.i64[1];
      float32x4_t v27 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v21.f32, 1));
      int8x16_t v29 = *(int8x16_t *)(v7 + v14 + 32);
      int8x16_t v28 = *(int8x16_t *)(v7 + v14 + 48);
      v26.i64[1] = v21.i64[1];
      v29.i64[1] = v22.i64[1];
      float32x4_t v30 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v22.f32, 1));
      float32x4_t v31 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v23.f32, 1));
      v28.i64[1] = v23.i64[1];
      float32x4_t v32 = *(float32x4_t *)(v16 + 64);
      int8x16_t v33 = *(int8x16_t *)(v16 + 80);
      int32x4_t v34 = (int8x16_t *)(v6 + v14);
      *int32x4_t v34 = vbslq_s8(v33, vextq_s8(v25, v25, 4uLL), (int8x16_t)vaddq_f32(v24, vmulq_laneq_f32(v32, v20, 2)));
      v34[1] = vbslq_s8(v33, vextq_s8(v26, v26, 4uLL), (int8x16_t)vaddq_f32(v27, vmulq_laneq_f32(v32, v21, 2)));
      v34[2] = vbslq_s8(v33, vextq_s8(v29, v29, 4uLL), (int8x16_t)vaddq_f32(v30, vmulq_laneq_f32(v32, v22, 2)));
      v34[3] = vbslq_s8(v33, vextq_s8(v28, v28, 4uLL), (int8x16_t)vaddq_f32(v31, vmulq_laneq_f32(v32, v23, 2)));
      v15 -= 4;
      v14 += 64;
    }
    while (v4 + v15 > 3);
    LODWORD(v35) = -v15;
    if ((int)v35 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v35 = v35;
    do
    {
      uint64_t v36 = *((void *)this + 51);
      float32x4_t v37 = vaddq_f32(*(float32x4_t *)(v36 + 16), vmulq_f32(*(float32x4_t *)v36, (float32x4_t)vbslq_s8(*(int8x16_t *)(v36 + 32), *(int8x16_t *)(v8 + 16 * v35), vextq_s8(*(int8x16_t *)(v11 + 16 * v35), *(int8x16_t *)(v11 + 16 * v35), 0xCuLL))));
      int8x16_t v38 = *(int8x16_t *)(v7 + 16 * v35);
      v38.i64[1] = v37.i64[1];
      *(int8x16_t *)(v6 + 16 * v35++) = vbslq_s8(*(int8x16_t *)(v36 + 80), vextq_s8(v38, v38, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v36 + 64), v37, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v36 + 48), *(float32x2_t *)v37.f32, 1))));
    }
    while (v35 < v4);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV444TriPlanar_601ToRGB::GetDOD(HgcYUV444TriPlanar_601ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcYUV444TriPlanar_601ToRGB::GetROI(HgcYUV444TriPlanar_601ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcYUV444TriPlanar_601ToRGB::HgcYUV444TriPlanar_601ToRGB(HgcYUV444TriPlanar_601ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10E8C98;
  operator new();
}

void sub_1B78E4B08(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444TriPlanar_601ToRGB::~HgcYUV444TriPlanar_601ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10E8C98;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10E8C98;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E8C98;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV444TriPlanar_601ToRGB::SetParameter(HgcYUV444TriPlanar_601ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV444TriPlanar_601ToRGB::GetParameter(HgcYUV444TriPlanar_601ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV444TriPlanar_709ToRGB::GetProgram(HgcYUV444TriPlanar_709ToRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const half4 c1 = half4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cdf2c357:0e58722b:1e4f6b69:f6729461\n"
             "//SIG=00400000:00000007:00000007:00000007:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004b8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=05c81fc8:e3feb89a:8a806bcd:71aa8c88\n"
             "//SIG=00000000:00000007:00000007:00000000:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000473\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    r0.x = texture2D(hg_Texture2, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.x;\n"
           "}\n"
           "//MD5=d2915400:9b8d3537:638e9298:f328421c\n"
           "//SIG=00000000:00000007:00000007:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcYUV444TriPlanar_709ToRGB::InitProgramDescriptor(HgcYUV444TriPlanar_709ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444TriPlanar_709ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002a7\n[[ visible ]] FragmentOut HgcYUV444TriPlanar_709ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2)\n{\n    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
    "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = color1.xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV444TriPlanar_709ToRGB");
}

void sub_1B78E5144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78E517C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78E5174);
}

char *HgcYUV444TriPlanar_709ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375DB0;
  strcpy(result, "HgcYUV444TriPlanar_709ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV444TriPlanar_709ToRGB::BindTexture(HgcYUV444TriPlanar_709ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 == 2)
    {
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      int v4 = a2;
      int v5 = 2;
    }
    else
    {
      if (a3 != 1) {
        return 0xFFFFFFFFLL;
      }
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      int v4 = a2;
      int v5 = 1;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444TriPlanar_709ToRGB::Bind(HgcYUV444TriPlanar_709ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV444TriPlanar_709ToRGB::RenderTile(HgcYUV444TriPlanar_709ToRGB *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((int *)a2 + 6);
    uint64_t v6 = *((void *)a2 + 2);
    uint64_t v7 = *((void *)a2 + 14);
    uint64_t v8 = *((void *)a2 + 10);
    uint64_t v9 = 16 * *((int *)a2 + 22);
    uint64_t v10 = 16 * *((int *)a2 + 26);
    uint64_t v11 = *((void *)a2 + 12);
    uint64_t v12 = 16 * *((int *)a2 + 30);
    uint64_t v13 = 16 * v5;
    while (v4 < 4)
    {
      LODWORD(v35) = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      ++v3;
      v8 += v9;
      v11 += v10;
      v7 += v12;
      v6 += v13;
      if (v3 == v2) {
        return 0;
      }
    }
    uint64_t v14 = 0;
    int v15 = 0;
    do
    {
      uint64_t v16 = *((void *)this + 51);
      int8x16_t v17 = *(int8x16_t *)(v16 + 32);
      float32x4_t v18 = *(float32x4_t *)(v16 + 48);
      float32x4_t v19 = *(float32x4_t *)(v16 + 16);
      float32x4_t v20 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14), vextq_s8(*(int8x16_t *)(v11 + v14), *(int8x16_t *)(v11 + v14), 0xCuLL))));
      float32x4_t v21 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 16), vextq_s8(*(int8x16_t *)(v11 + v14 + 16), *(int8x16_t *)(v11 + v14 + 16), 0xCuLL))));
      float32x4_t v22 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 32), vextq_s8(*(int8x16_t *)(v11 + v14 + 32), *(int8x16_t *)(v11 + v14 + 32), 0xCuLL))));
      float32x4_t v23 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 48), vextq_s8(*(int8x16_t *)(v11 + v14 + 48), *(int8x16_t *)(v11 + v14 + 48), 0xCuLL))));
      float32x4_t v24 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v20.f32, 1));
      int8x16_t v25 = *(int8x16_t *)(v7 + v14);
      int8x16_t v26 = *(int8x16_t *)(v7 + v14 + 16);
      v25.i64[1] = v20.i64[1];
      float32x4_t v27 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v21.f32, 1));
      int8x16_t v29 = *(int8x16_t *)(v7 + v14 + 32);
      int8x16_t v28 = *(int8x16_t *)(v7 + v14 + 48);
      v26.i64[1] = v21.i64[1];
      v29.i64[1] = v22.i64[1];
      float32x4_t v30 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v22.f32, 1));
      float32x4_t v31 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v23.f32, 1));
      v28.i64[1] = v23.i64[1];
      float32x4_t v32 = *(float32x4_t *)(v16 + 64);
      int8x16_t v33 = *(int8x16_t *)(v16 + 80);
      int32x4_t v34 = (int8x16_t *)(v6 + v14);
      *int32x4_t v34 = vbslq_s8(v33, vextq_s8(v25, v25, 4uLL), (int8x16_t)vaddq_f32(v24, vmulq_laneq_f32(v32, v20, 2)));
      v34[1] = vbslq_s8(v33, vextq_s8(v26, v26, 4uLL), (int8x16_t)vaddq_f32(v27, vmulq_laneq_f32(v32, v21, 2)));
      v34[2] = vbslq_s8(v33, vextq_s8(v29, v29, 4uLL), (int8x16_t)vaddq_f32(v30, vmulq_laneq_f32(v32, v22, 2)));
      v34[3] = vbslq_s8(v33, vextq_s8(v28, v28, 4uLL), (int8x16_t)vaddq_f32(v31, vmulq_laneq_f32(v32, v23, 2)));
      v15 -= 4;
      v14 += 64;
    }
    while (v4 + v15 > 3);
    LODWORD(v35) = -v15;
    if ((int)v35 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v35 = v35;
    do
    {
      uint64_t v36 = *((void *)this + 51);
      float32x4_t v37 = vaddq_f32(*(float32x4_t *)(v36 + 16), vmulq_f32(*(float32x4_t *)v36, (float32x4_t)vbslq_s8(*(int8x16_t *)(v36 + 32), *(int8x16_t *)(v8 + 16 * v35), vextq_s8(*(int8x16_t *)(v11 + 16 * v35), *(int8x16_t *)(v11 + 16 * v35), 0xCuLL))));
      int8x16_t v38 = *(int8x16_t *)(v7 + 16 * v35);
      v38.i64[1] = v37.i64[1];
      *(int8x16_t *)(v6 + 16 * v35++) = vbslq_s8(*(int8x16_t *)(v36 + 80), vextq_s8(v38, v38, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v36 + 64), v37, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v36 + 48), *(float32x2_t *)v37.f32, 1))));
    }
    while (v35 < v4);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV444TriPlanar_709ToRGB::GetDOD(HgcYUV444TriPlanar_709ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcYUV444TriPlanar_709ToRGB::GetROI(HgcYUV444TriPlanar_709ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcYUV444TriPlanar_709ToRGB::HgcYUV444TriPlanar_709ToRGB(HgcYUV444TriPlanar_709ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10E8F00;
  operator new();
}

void sub_1B78E57A8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444TriPlanar_709ToRGB::~HgcYUV444TriPlanar_709ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10E8F00;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10E8F00;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E8F00;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV444TriPlanar_709ToRGB::SetParameter(HgcYUV444TriPlanar_709ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV444TriPlanar_709ToRGB::GetParameter(HgcYUV444TriPlanar_709ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV444TriPlanar_2020ToRGB::GetProgram(HgcYUV444TriPlanar_2020ToRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const half4 c1 = half4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = (half) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f79a664b:38284d73:72f9ca6b:398dd0ca\n"
             "//SIG=00400000:00000007:00000007:00000007:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004b8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    r0.x = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy).x;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7637b7ca:94e18948:9249a20f:2be63cfc\n"
             "//SIG=00000000:00000007:00000007:00000000:0002:0002:0002:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000473\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    r0.x = texture2D(hg_Texture2, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.x;\n"
           "}\n"
           "//MD5=a3e884d8:41b7c32f:d6ccb16b:fb255cb1\n"
           "//SIG=00000000:00000007:00000007:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcYUV444TriPlanar_2020ToRGB::InitProgramDescriptor(HgcYUV444TriPlanar_2020ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444TriPlanar_2020ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002a8\n[[ visible ]] FragmentOut HgcYUV444TriPlanar_2020ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2)\n{\n    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
    "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = color1.xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    r0.x = color2.x;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = r0.x;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV444TriPlanar_2020ToRGB");
}

void sub_1B78E5DE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78E5E1C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78E5E14);
}

char *HgcYUV444TriPlanar_2020ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375E40;
  strcpy(result, "HgcYUV444TriPlanar_2020ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::BindTexture(HgcYUV444TriPlanar_2020ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 == 2)
    {
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      int v4 = a2;
      int v5 = 2;
    }
    else
    {
      if (a3 != 1) {
        return 0xFFFFFFFFLL;
      }
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      int v4 = a2;
      int v5 = 1;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::Bind(HgcYUV444TriPlanar_2020ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::RenderTile(HgcYUV444TriPlanar_2020ToRGB *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((int *)a2 + 6);
    uint64_t v6 = *((void *)a2 + 2);
    uint64_t v7 = *((void *)a2 + 14);
    uint64_t v8 = *((void *)a2 + 10);
    uint64_t v9 = 16 * *((int *)a2 + 22);
    uint64_t v10 = 16 * *((int *)a2 + 26);
    uint64_t v11 = *((void *)a2 + 12);
    uint64_t v12 = 16 * *((int *)a2 + 30);
    uint64_t v13 = 16 * v5;
    while (v4 < 4)
    {
      LODWORD(v35) = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      ++v3;
      v8 += v9;
      v11 += v10;
      v7 += v12;
      v6 += v13;
      if (v3 == v2) {
        return 0;
      }
    }
    uint64_t v14 = 0;
    int v15 = 0;
    do
    {
      uint64_t v16 = *((void *)this + 51);
      int8x16_t v17 = *(int8x16_t *)(v16 + 32);
      float32x4_t v18 = *(float32x4_t *)(v16 + 48);
      float32x4_t v19 = *(float32x4_t *)(v16 + 16);
      float32x4_t v20 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14), vextq_s8(*(int8x16_t *)(v11 + v14), *(int8x16_t *)(v11 + v14), 0xCuLL))));
      float32x4_t v21 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 16), vextq_s8(*(int8x16_t *)(v11 + v14 + 16), *(int8x16_t *)(v11 + v14 + 16), 0xCuLL))));
      float32x4_t v22 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 32), vextq_s8(*(int8x16_t *)(v11 + v14 + 32), *(int8x16_t *)(v11 + v14 + 32), 0xCuLL))));
      float32x4_t v23 = vaddq_f32(v19, vmulq_f32(*(float32x4_t *)v16, (float32x4_t)vbslq_s8(v17, *(int8x16_t *)(v8 + v14 + 48), vextq_s8(*(int8x16_t *)(v11 + v14 + 48), *(int8x16_t *)(v11 + v14 + 48), 0xCuLL))));
      float32x4_t v24 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v20.f32, 1));
      int8x16_t v25 = *(int8x16_t *)(v7 + v14);
      int8x16_t v26 = *(int8x16_t *)(v7 + v14 + 16);
      v25.i64[1] = v20.i64[1];
      float32x4_t v27 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v21.f32, 1));
      int8x16_t v29 = *(int8x16_t *)(v7 + v14 + 32);
      int8x16_t v28 = *(int8x16_t *)(v7 + v14 + 48);
      v26.i64[1] = v21.i64[1];
      v29.i64[1] = v22.i64[1];
      float32x4_t v30 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v22.f32, 1));
      float32x4_t v31 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v23.f32, 1));
      v28.i64[1] = v23.i64[1];
      float32x4_t v32 = *(float32x4_t *)(v16 + 64);
      int8x16_t v33 = *(int8x16_t *)(v16 + 80);
      int32x4_t v34 = (int8x16_t *)(v6 + v14);
      *int32x4_t v34 = vbslq_s8(v33, vextq_s8(v25, v25, 4uLL), (int8x16_t)vaddq_f32(v24, vmulq_laneq_f32(v32, v20, 2)));
      v34[1] = vbslq_s8(v33, vextq_s8(v26, v26, 4uLL), (int8x16_t)vaddq_f32(v27, vmulq_laneq_f32(v32, v21, 2)));
      v34[2] = vbslq_s8(v33, vextq_s8(v29, v29, 4uLL), (int8x16_t)vaddq_f32(v30, vmulq_laneq_f32(v32, v22, 2)));
      v34[3] = vbslq_s8(v33, vextq_s8(v28, v28, 4uLL), (int8x16_t)vaddq_f32(v31, vmulq_laneq_f32(v32, v23, 2)));
      v15 -= 4;
      v14 += 64;
    }
    while (v4 + v15 > 3);
    LODWORD(v35) = -v15;
    if ((int)v35 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v35 = v35;
    do
    {
      uint64_t v36 = *((void *)this + 51);
      float32x4_t v37 = vaddq_f32(*(float32x4_t *)(v36 + 16), vmulq_f32(*(float32x4_t *)v36, (float32x4_t)vbslq_s8(*(int8x16_t *)(v36 + 32), *(int8x16_t *)(v8 + 16 * v35), vextq_s8(*(int8x16_t *)(v11 + 16 * v35), *(int8x16_t *)(v11 + 16 * v35), 0xCuLL))));
      int8x16_t v38 = *(int8x16_t *)(v7 + 16 * v35);
      v38.i64[1] = v37.i64[1];
      *(int8x16_t *)(v6 + 16 * v35++) = vbslq_s8(*(int8x16_t *)(v36 + 80), vextq_s8(v38, v38, 4uLL), (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v36 + 64), v37, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v36 + 48), *(float32x2_t *)v37.f32, 1))));
    }
    while (v35 < v4);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::GetDOD(HgcYUV444TriPlanar_2020ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::GetROI(HgcYUV444TriPlanar_2020ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcYUV444TriPlanar_2020ToRGB::HgcYUV444TriPlanar_2020ToRGB(HgcYUV444TriPlanar_2020ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10E9168;
  operator new();
}

void sub_1B78E644C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444TriPlanar_2020ToRGB::~HgcYUV444TriPlanar_2020ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10E9168;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10E9168;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E9168;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::SetParameter(HgcYUV444TriPlanar_2020ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV444TriPlanar_2020ToRGB::GetParameter(HgcYUV444TriPlanar_2020ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV420BiPlanar_luma::GetProgram(HgcYUV420BiPlanar_luma *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000020a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0.x = (float) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=362a17a2:e54929ff:e041de3e:e21b3210\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000203\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2456f903:b3470d55:359ed246:2c083ec0\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000019e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "\n"
           "    gl_FragColor.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "}\n"
           "//MD5=df35ce51:fa3c22ab:4af7cc35:bf3b1e9a\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_luma::InitProgramDescriptor(HgcYUV420BiPlanar_luma *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_luma_hgc_visible", "//Metal1.0     \n//LEN=00000000e3\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_luma_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    FragmentOut output;\n"
    "\n"
    "    output.color0.x = color0.x;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV420BiPlanar_luma");
}

void sub_1B78E6958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78E6988(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78E6980);
}

double HgcYUV420BiPlanar_luma::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375F40;
  strcpy(v3, "HgcYUV420BiPlanar_luma [hgc1]");
  return *(double *)"anar_luma [hgc1]";
}

uint64_t HgcYUV420BiPlanar_luma::BindTexture(HgcYUV420BiPlanar_luma *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV420BiPlanar_luma::Bind(HgcYUV420BiPlanar_luma *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma::RenderTile(HgcYUV420BiPlanar_luma *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (int8x16_t *)*((void *)a2 + 10);
    int v5 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v27 = 0;
        uint64_t v28 = 16 * v7;
        uint64_t v29 = 16 * v6;
        uint64_t v30 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v31 = 0;
          do
          {
            v5[v31 / 0x10] = vbslq_s8(*(int8x16_t *)(*((void *)this + 51) + 16), v4[v31 / 0x10], *(int8x16_t *)*((void *)this + 51));
            v31 += 16;
          }
          while (v30 != v31);
          ++v27;
          int v4 = (int8x16_t *)((char *)v4 + v28);
          int v5 = (int8x16_t *)((char *)v5 + v29);
        }
        while (v27 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      uint64_t v11 = v4 + 4;
      uint64_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        uint64_t v14 = v12;
        int v15 = v11;
        uint64_t v16 = 2;
        do
        {
          int8x16_t v17 = v15;
          float32x4_t v18 = v14;
          float32x4_t v19 = (int8x16_t *)*((void *)this + 51);
          int8x16_t v20 = v19[1];
          int8x16_t v21 = vbslq_s8(v20, v4[v16 - 2], *v19);
          int8x16_t v22 = vbslq_s8(v20, v4[v16 - 1], *v19);
          int8x16_t v23 = vbslq_s8(v20, v4[v16], *v19);
          int8x16_t v24 = vbslq_s8(v20, v4[v16 + 1], *v19);
          int8x16_t v25 = &v5[v16];
          v25[-2] = v21;
          v25[-1] = v22;
          v13 += 4;
          *int8x16_t v25 = v23;
          v25[1] = v24;
          v16 += 4;
          v15 += 4;
          uint64_t v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            int8x16_t v26 = *v17++;
            *v18++ = vbslq_s8(*(int8x16_t *)(*((void *)this + 51) + 16), v26, *(int8x16_t *)*((void *)this + 51));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (int8x16_t *)((char *)v5 + v9);
        int v4 = (int8x16_t *)((char *)v4 + v10);
        uint64_t v11 = (int8x16_t *)((char *)v11 + v10);
        uint64_t v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma::GetDOD(HgcYUV420BiPlanar_luma *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcYUV420BiPlanar_luma::GetROI(HgcYUV420BiPlanar_luma *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcYUV420BiPlanar_luma::HgcYUV420BiPlanar_luma(HgcYUV420BiPlanar_luma *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10E93D0;
  operator new();
}

void sub_1B78E6D58(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_luma::~HgcYUV420BiPlanar_luma(HGNode *this)
{
  *(void *)this = &unk_1F10E93D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E93D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_luma::SetParameter(HgcYUV420BiPlanar_luma *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV420BiPlanar_luma::GetParameter(HgcYUV420BiPlanar_luma *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV420BiPlanar_luma_pack2::GetProgram(HgcYUV420BiPlanar_luma_pack2 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000284\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    output.color0.x = (float) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    output.color0.y = float(r0.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=4456c075:b6d6ba4d:38e99e92:436ff40d\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0001:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000270\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    output.color0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    output.color0.y = r0.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b0085e2f:e0f56ad7:4e83395a:f54f2528\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000226\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    gl_FragColor.x = texture2D(hg_Texture0, hg_TexCoord1.xy).x;\n"
           "    gl_FragColor.y = r0.x;\n"
           "}\n"
           "//MD5=eaeac9e2:ac28c509:f186b78a:7563dbf5\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_luma_pack2::InitProgramDescriptor(HgcYUV420BiPlanar_luma_pack2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_luma_pack2_hgc_visible", "//Metal1.0     \n//LEN=00000001cf\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_luma_pack2_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).x;\n"
    "    output.color0.x = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).x;\n"
    "    output.color0.y = r0.x;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV420BiPlanar_luma_pack2");
}

void sub_1B78E72F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78E7334(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78E732CLL);
}

char *HgcYUV420BiPlanar_luma_pack2::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375E40;
  strcpy(result, "HgcYUV420BiPlanar_luma_pack2 [hgc1]");
  return result;
}

uint64_t HgcYUV420BiPlanar_luma_pack2::BindTexture(HgcYUV420BiPlanar_luma_pack2 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, 0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, -0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma_pack2::Bind(HgcYUV420BiPlanar_luma_pack2 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma_pack2::RenderTile(HgcYUV420BiPlanar_luma_pack2 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    uint64_t v3 = *(int *)a2;
    unint64_t v4 = (*((_DWORD *)a2 + 2) - v3);
    uint64_t v5 = *((void *)a2 + 10);
    uint64_t v6 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v7 = *((int *)a2 + 6);
    uint64_t v8 = *((int *)a2 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        int v33 = 0;
        uint64_t v34 = v5 + 16 * v3 + 16;
        uint64_t v35 = 16 * v8;
        uint64_t v36 = 16 * v4;
        do
        {
          unint64_t v37 = 0;
          int8x16_t v38 = (int32x4_t *)v34;
          do
          {
            v6[v37 / 0x10] = vbslq_s8(*(int8x16_t *)(*((void *)this + 51) + 32), (int8x16_t)vrev64q_s32(*v38), vbslq_s8(*(int8x16_t *)(*((void *)this + 51) + 16), (int8x16_t)v38[-1], *(int8x16_t *)*((void *)this + 51)));
            v37 += 16;
            v38 += 2;
          }
          while (v36 != v37);
          ++v33;
          v6 += v7;
          v34 += v35;
        }
        while (v33 != v2);
      }
    }
    else
    {
      int v9 = 0;
      uint64_t v10 = v5 + 16 * v3;
      uint64_t v11 = v10 + 64;
      uint64_t v12 = v6 + 2;
      uint64_t v13 = 16 * v7;
      uint64_t v14 = v6 + 4;
      do
      {
        unint64_t v15 = 0;
        int v16 = 8;
        int8x16_t v17 = v14;
        float32x4_t v18 = v12;
        uint64_t v19 = v11;
        do
        {
          unsigned int v20 = v16;
          int8x16_t v21 = v17;
          int8x16_t v22 = (int8x16_t *)*((void *)this + 51);
          int8x16_t v23 = v22[1];
          int8x16_t v24 = vbslq_s8(v23, *(int8x16_t *)(v19 - 64), *v22);
          int8x16_t v25 = vbslq_s8(v23, *(int8x16_t *)(v19 - 32), *v22);
          int8x16_t v26 = vbslq_s8(v23, *(int8x16_t *)v19, *v22);
          int8x16_t v27 = vbslq_s8(v23, *(int8x16_t *)(v19 + 32), *v22);
          int8x16_t v28 = v22[2];
          int8x16_t v29 = vbslq_s8(v28, (int8x16_t)vrev64q_s32(*(int32x4_t *)(v19 - 48)), v24);
          int8x16_t v30 = vbslq_s8(v28, (int8x16_t)vrev64q_s32(*(int32x4_t *)(v19 - 16)), v25);
          int8x16_t v31 = vbslq_s8(v28, (int8x16_t)vrev64q_s32(*(int32x4_t *)(v19 + 16)), v26);
          int8x16_t v32 = vbslq_s8(v28, (int8x16_t)vrev64q_s32(*(int32x4_t *)(v19 + 48)), v27);
          v18[-2] = v29;
          v18[-1] = v30;
          v15 += 4;
          v19 += 128;
          *float32x4_t v18 = v31;
          v18[1] = v32;
          v18 += 4;
          int v16 = v20 + 8;
          v17 += 4;
        }
        while ((uint64_t)v15 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v15)
        {
          do
          {
            *v21++ = vbslq_s8(*(int8x16_t *)(*((void *)this + 51) + 32), (int8x16_t)vrev64q_s32(*(int32x4_t *)(v10 + 16 * (v20 + 1))), vbslq_s8(*(int8x16_t *)(*((void *)this + 51) + 16), *(int8x16_t *)(v10 + 16 * v20), *(int8x16_t *)*((void *)this + 51)));
            ++v15;
            v20 += 2;
          }
          while (v15 < v4);
        }
        v10 += 16 * v8;
        ++v9;
        v11 += 16 * v8;
        uint64_t v12 = (int8x16_t *)((char *)v12 + v13);
        uint64_t v14 = (int8x16_t *)((char *)v14 + v13);
      }
      while (v9 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma_pack2::GetDOD(HgcYUV420BiPlanar_luma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0, 0, 0xFFFFFFFF, 0);
  int v8 = HGRectGrow(v6, v5, v7);
  float v9 = HGRectFloat(v8);
  float v13 = HGRectScale(v9, v10, v11, v12, 0.5);
  uint64_t v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcYUV420BiPlanar_luma_pack2::GetROI(HgcYUV420BiPlanar_luma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 2.0);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  uint64_t v16 = v15;
  uint64_t v17 = HGRectMake4i(0, 0, 1u, 0);
  uint64_t v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcYUV420BiPlanar_luma_pack2::HgcYUV420BiPlanar_luma_pack2(HgcYUV420BiPlanar_luma_pack2 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10E9638;
  operator new();
}

void sub_1B78E79F8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_luma_pack2::~HgcYUV420BiPlanar_luma_pack2(HGNode *this)
{
  *(void *)this = &unk_1F10E9638;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40EED21634);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E9638;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40EED21634);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_luma_pack2::SetParameter(HgcYUV420BiPlanar_luma_pack2 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV420BiPlanar_luma_pack2::GetParameter(HgcYUV420BiPlanar_luma_pack2 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV420BiPlanar_luma_pack4::GetProgram(HgcYUV420BiPlanar_luma_pack4 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000364\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    r2.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy).x;\n"
             "    output.color0.x = (float) hg_Texture0.sample(hg_Sampler0, frag._texCoord3.xy).x;\n"
             "    output.color0.y = float(r0.x);\n"
             "    output.color0.z = float(r1.x);\n"
             "    output.color0.w = float(r2.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8b57dc08:a504f16a:c8e16446:44c11f04\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0003:0000:0000:0000:001e:0000:0004:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000334\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    r2.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy).x;\n"
             "    output.color0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord3.xy).x;\n"
             "    output.color0.y = r0.x;\n"
             "    output.color0.z = r1.x;\n"
             "    output.color0.w = r2.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2e819e4d:f08f0348:7d03619e:883413bd\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0003:0000:0000:0000:001e:0000:0004:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000312\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r1.x = texture2D(hg_Texture0, hg_TexCoord1.xy).x;\n"
           "    r2.x = texture2D(hg_Texture0, hg_TexCoord2.xy).x;\n"
           "    gl_FragColor.x = texture2D(hg_Texture0, hg_TexCoord3.xy).x;\n"
           "    gl_FragColor.y = r0.x;\n"
           "    gl_FragColor.z = r1.x;\n"
           "    gl_FragColor.w = r2.x;\n"
           "}\n"
           "//MD5=c72d106c:41629b4d:88d61728:329143b3\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0003:0000:0000:0000:0000:0000:0004:01:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_luma_pack4::InitProgramDescriptor(HgcYUV420BiPlanar_luma_pack4 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_luma_pack4_hgc_visible", "//Metal1.0     \n//LEN=00000002b3\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_luma_pack4_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1,\n    float4 texCoord2,\n    float4 texCoord3)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).x;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).x;\n"
    "    r2.x = hg_Texture0.sample(hg_Sampler0, texCoord2.xy).x;\n"
    "    output.color0.x = hg_Texture0.sample(hg_Sampler0, texCoord3.xy).x;\n"
    "    output.color0.y = r0.x;\n"
    "    output.color0.z = r1.x;\n"
    "    output.color0.w = r2.x;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV420BiPlanar_luma_pack4");
}

void sub_1B78E80C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78E810C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78E8104);
}

char *HgcYUV420BiPlanar_luma_pack4::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375E40;
  strcpy(result, "HgcYUV420BiPlanar_luma_pack4 [hgc1]");
  return result;
}

uint64_t HgcYUV420BiPlanar_luma_pack4::BindTexture(HgcYUV420BiPlanar_luma_pack4 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, -0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 4.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, 0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 4.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 2, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, 1.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 4.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 3, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, -1.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 4.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma_pack4::Bind(HgcYUV420BiPlanar_luma_pack4 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma_pack4::RenderTile(HgcYUV420BiPlanar_luma_pack4 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = *((void *)a2 + 10);
    int v5 = 3 * *(_DWORD *)a2;
    uint64_t v6 = v5;
    float v7 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v8 = *((int *)a2 + 6);
    uint64_t v9 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v36 = 0;
        uint64_t v37 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        uint64_t v38 = v4 + 16 * v5 + 32;
        uint64_t v39 = 16 * v9;
        do
        {
          unint64_t v40 = 0;
          __int32 v41 = (_OWORD *)v38;
          do
          {
            uint64_t v42 = *((void *)this + 51);
            *(int8x8_t *)v43.i8 = vbsl_s8(*(int8x8_t *)v42, *(int8x8_t *)(v41 - 2), (int8x8_t)*(_OWORD *)&vrev64q_s32(*((int32x4_t *)v41 - 1)));
            int32x4_t v44 = *(int32x4_t *)v41;
            int8x16_t v45 = *((int8x16_t *)v41 + 1);
            v41 += 4;
            v43.i64[1] = v44.i64[0];
            v7[v40 / 0x10] = vbslq_s8(*(int8x16_t *)(v42 + 16), vextq_s8(v45, v45, 4uLL), v43);
            v40 += 16;
          }
          while (v37 != v40);
          ++v36;
          v7 += v8;
          v38 += v39;
        }
        while (v36 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = v4 + 16 * v5;
      uint64_t v12 = v4 + 16 * v6 + 128;
      float v13 = v7 + 2;
      uint64_t v14 = 16 * v8;
      uint64_t v15 = v7 + 4;
      do
      {
        unint64_t v16 = 0;
        int v17 = 16;
        uint64_t v18 = v15;
        uint64_t v19 = v13;
        uint64_t v20 = v12;
        do
        {
          unsigned int v21 = v17;
          int8x16_t v22 = v18;
          int8x16_t v23 = (int8x16_t *)*((void *)this + 51);
          int8x16_t v24 = v23[1];
          int8x8_t v25 = (int8x8_t)vmvnq_s8(*v23).u64[0];
          *(int8x8_t *)v26.i8 = vorr_s8(vand_s8(*(int8x8_t *)v23->i8, *(int8x8_t *)(v20 - 128)), vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v20 - 112)), v25));
          v26.i64[1] = *(void *)(v20 - 96);
          *(int8x8_t *)v27.i8 = vorr_s8(vand_s8(*(int8x8_t *)v23->i8, *(int8x8_t *)(v20 - 64)), vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v20 - 48)), v25));
          v27.i64[1] = *(void *)(v20 - 32);
          *(int8x8_t *)v28.i8 = vorr_s8(vand_s8(*(int8x8_t *)v23->i8, *(int8x8_t *)v20), vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v20 + 16)), v25));
          v28.i64[1] = *(void *)(v20 + 32);
          *(int8x8_t *)v29.i8 = vorr_s8(vand_s8(*(int8x8_t *)v23->i8, *(int8x8_t *)(v20 + 64)), vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v20 + 80)), v25));
          v29.i64[1] = *(void *)(v20 + 96);
          int8x16_t v30 = vbslq_s8(v24, vextq_s8(*(int8x16_t *)(v20 - 16), *(int8x16_t *)(v20 - 16), 4uLL), v27);
          int8x16_t v31 = vbslq_s8(v24, vextq_s8(*(int8x16_t *)(v20 + 48), *(int8x16_t *)(v20 + 48), 4uLL), v28);
          int8x16_t v32 = vbslq_s8(v24, vextq_s8(*(int8x16_t *)(v20 + 112), *(int8x16_t *)(v20 + 112), 4uLL), v29);
          v19[-2] = vbslq_s8(v24, vextq_s8(*(int8x16_t *)(v20 - 80), *(int8x16_t *)(v20 - 80), 4uLL), v26);
          v19[-1] = v30;
          v16 += 4;
          v20 += 256;
          *uint64_t v19 = v31;
          v19[1] = v32;
          v19 += 4;
          int v17 = v21 + 16;
          v18 += 4;
        }
        while ((uint64_t)v16 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v16)
        {
          do
          {
            uint64_t v33 = *((void *)this + 51);
            *(int8x8_t *)v34.i8 = vbsl_s8(*(int8x8_t *)v33, *(int8x8_t *)(v11 + 16 * v21), (int8x8_t)*(_OWORD *)&vrev64q_s32(*(int32x4_t *)(v11 + 16 * (v21 + 1))));
            int8x16_t v35 = *(int8x16_t *)(v11 + 16 * (v21 + 3));
            v34.i64[1] = *(void *)(v11 + 16 * (v21 + 2));
            *v22++ = vbslq_s8(*(int8x16_t *)(v33 + 16), vextq_s8(v35, v35, 4uLL), v34);
            ++v16;
            v21 += 4;
          }
          while (v16 < v3);
        }
        v11 += 16 * v9;
        ++v10;
        v12 += 16 * v9;
        float v13 = (int8x16_t *)((char *)v13 + v14);
        uint64_t v15 = (int8x16_t *)((char *)v15 + v14);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_luma_pack4::GetDOD(HgcYUV420BiPlanar_luma_pack4 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0, 0, 0xFFFFFFFD, 0);
  int v8 = HGRectGrow(v6, v5, v7);
  float v9 = HGRectFloat(v8);
  float v13 = HGRectScale(v9, v10, v11, v12, 0.25);
  uint64_t v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcYUV420BiPlanar_luma_pack4::GetROI(HgcYUV420BiPlanar_luma_pack4 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 4.0);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  uint64_t v16 = v15;
  uint64_t v17 = HGRectMake4i(0, 0, 3u, 0);
  uint64_t v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcYUV420BiPlanar_luma_pack4::HgcYUV420BiPlanar_luma_pack4(HgcYUV420BiPlanar_luma_pack4 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10E98A0;
  operator new();
}

void sub_1B78E89E4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_luma_pack4::~HgcYUV420BiPlanar_luma_pack4(HGNode *this)
{
  *(void *)this = &unk_1F10E98A0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E98A0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_luma_pack4::SetParameter(HgcYUV420BiPlanar_luma_pack4 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV420BiPlanar_luma_pack4::GetParameter(HgcYUV420BiPlanar_luma_pack4 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV420BiPlanar_chroma_pack2::GetProgram(HgcYUV420BiPlanar_chroma_pack2 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002ab\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).yz;\n"
             "    r1.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = float2(r0.yz);\n"
             "    output.color0.zw = float2(r1.yz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=33bdb345:2758fc0c:d30c75e2:ea65b96f\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000028d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).yz;\n"
             "    r1.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = r0.yz;\n"
             "    output.color0.zw = r1.yz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6888e40f:7ebf1f5f:d902b6ad:5e066264\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000243\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.yz = texture2D(hg_Texture0, hg_TexCoord1.xy).yz;\n"
           "    r1.yz = texture2D(hg_Texture0, hg_TexCoord0.xy).yz;\n"
           "    gl_FragColor.xy = r0.yz;\n"
           "    gl_FragColor.zw = r1.yz;\n"
           "}\n"
           "//MD5=0c7412c0:8a79fbe3:17780697:6248caac\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_chroma_pack2::InitProgramDescriptor(HgcYUV420BiPlanar_chroma_pack2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_chroma_pack2_hgc_visible", "//Metal1.0     \n//LEN=00000001ee\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_chroma_pack2_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.yz = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).yz;\n"
    "    r1.yz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).yz;\n"
    "    output.color0.xy = r0.yz;\n"
    "    output.color0.zw = r1.yz;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV420BiPlanar_chroma_pack2");
}

void sub_1B78E8F84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78E8FC0(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78E8FB8);
}

char *HgcYUV420BiPlanar_chroma_pack2::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D30;
  strcpy(result, "HgcYUV420BiPlanar_chroma_pack2 [hgc1]");
  return result;
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::BindTexture(HgcYUV420BiPlanar_chroma_pack2 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, -1.5, -0.5, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 4.0, 2.0, 1.0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, 0.5, -0.5, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 4.0, 2.0, 1.0);
  return 0;
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::Bind(HgcYUV420BiPlanar_chroma_pack2 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::RenderTile(HgcYUV420BiPlanar_chroma_pack2 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 1);
  int v3 = *((_DWORD *)a2 + 3) - v2;
  if (v3 >= 1)
  {
    unint64_t v4 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v5 = *((int *)a2 + 22);
    uint64_t v6 = *((void *)a2 + 10);
    int v7 = v5 * v2;
    uint64_t v8 = (int)v5 * v2;
    int v9 = 3 * *(_DWORD *)a2;
    uint64_t v10 = *((void *)a2 + 2);
    uint64_t v11 = *((int *)a2 + 6);
    uint64_t v12 = 2 * v5;
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        int v36 = 0;
        uint64_t v37 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        uint64_t v38 = 16 * v7 + 16 * v9 + v6 + 32;
        do
        {
          uint64_t v39 = 0;
          unint64_t v40 = (int8x16_t *)v38;
          do
          {
            int8x16_t v41 = v40[-2];
            int8x16_t v42 = *v40;
            v40 += 4;
            int8x16_t v43 = vextq_s8(v41, v42, 0xCuLL);
            *(int8x8_t *)v41.i8 = vext_s8(*(int8x8_t *)v41.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL), 4uLL);
            v41.i64[1] = vextq_s8(v43, v43, 8uLL).u64[0];
            *(int8x16_t *)(v10 + v39) = v41;
            v39 += 16;
          }
          while (v37 != v39);
          ++v36;
          v10 += 16 * v11;
          v38 += 32 * v5;
        }
        while (v36 != v3);
      }
    }
    else
    {
      int v13 = 0;
      uint64_t v14 = v6 + 16 * v7 + 16 * v9;
      uint64_t v15 = 16 * v8 + 16 * v9 + v6 + 128;
      uint64_t v16 = (_OWORD *)(v10 + 32);
      uint64_t v17 = 16 * v11;
      uint64_t v18 = (int8x16_t *)(v10 + 64);
      do
      {
        unint64_t v19 = 0;
        int v20 = 18;
        unsigned int v21 = v18;
        int8x16_t v22 = v16;
        uint64_t v23 = v15;
        do
        {
          int8x16_t v24 = *(int8x16_t *)(v23 - 128);
          int8x16_t v25 = vextq_s8(v24, *(int8x16_t *)(v23 - 96), 0xCuLL);
          *(int8x8_t *)v24.i8 = vext_s8(*(int8x8_t *)v24.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), 4uLL);
          v24.i64[1] = vextq_s8(v25, v25, 8uLL).u64[0];
          int8x16_t v26 = vextq_s8(v24, *(int8x16_t *)(v23 - 32), 0xCuLL);
          *(int8x8_t *)&long long v27 = vext_s8(*(int8x8_t *)(v23 - 64), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v23 - 64), *(int8x16_t *)(v23 - 64), 8uLL), 4uLL);
          *((void *)&v27 + 1) = vextq_s8(v26, v26, 8uLL).u64[0];
          int8x16_t v28 = vextq_s8(v24, *(int8x16_t *)(v23 + 32), 0xCuLL);
          *(int8x8_t *)&long long v29 = vext_s8(*(int8x8_t *)v23, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v23, *(int8x16_t *)v23, 8uLL), 4uLL);
          *((void *)&v29 + 1) = vextq_s8(v28, v28, 8uLL).u64[0];
          int8x16_t v30 = vextq_s8(v24, *(int8x16_t *)(v23 + 96), 0xCuLL);
          *(int8x8_t *)&long long v31 = vext_s8(*(int8x8_t *)(v23 + 64), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v23 + 64), *(int8x16_t *)(v23 + 64), 8uLL), 4uLL);
          *((void *)&v31 + 1) = vextq_s8(v30, v30, 8uLL).u64[0];
          unsigned int v32 = v20;
          uint64_t v33 = v21;
          *(v22 - 2) = v24;
          *(v22 - 1) = v27;
          v19 += 4;
          v23 += 256;
          *int8x16_t v22 = v29;
          v22[1] = v31;
          v22 += 4;
          v20 += 16;
          v21 += 4;
        }
        while ((uint64_t)v19 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v19)
        {
          do
          {
            int8x16_t v34 = *(int8x16_t *)(v14 + 16 * (v32 - 2));
            int8x16_t v35 = vextq_s8(v34, *(int8x16_t *)(v14 + 16 * v32), 0xCuLL);
            *(int8x8_t *)v34.i8 = vext_s8(*(int8x8_t *)v34.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL), 4uLL);
            v34.i64[1] = vextq_s8(v35, v35, 8uLL).u64[0];
            *v33++ = v34;
            ++v19;
            v32 += 4;
          }
          while (v19 < v4);
        }
        v14 += 16 * v12;
        ++v13;
        v15 += 16 * v12;
        uint64_t v16 = (_OWORD *)((char *)v16 + v17);
        uint64_t v18 = (int8x16_t *)((char *)v18 + v17);
      }
      while (v13 != v3);
    }
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::GetDOD(HgcYUV420BiPlanar_chroma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0, 0, 0xFFFFFFFE, 0);
  int v8 = HGRectGrow(v6, v5, v7);
  float v9 = HGRectFloat(v8);
  float v13 = HGRectScale(v9, v10, v11, v12, 0.25);
  uint64_t v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::GetROI(HgcYUV420BiPlanar_chroma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 4.0);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  uint64_t v16 = v15;
  uint64_t v17 = HGRectMake4i(0, 0, 2u, 0);
  uint64_t v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcYUV420BiPlanar_chroma_pack2::HgcYUV420BiPlanar_chroma_pack2(HgcYUV420BiPlanar_chroma_pack2 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10E9B08;
  operator new();
}

void sub_1B78E9698(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_chroma_pack2::~HgcYUV420BiPlanar_chroma_pack2(HGNode *this)
{
  *(void *)this = &unk_1F10E9B08;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0xC400A2AC0F1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E9B08;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0xC400A2AC0F1);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::SetParameter(HgcYUV420BiPlanar_chroma_pack2 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV420BiPlanar_chroma_pack2::GetParameter(HgcYUV420BiPlanar_chroma_pack2 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV420BiPlanar_chroma::GetProgram(HgcYUV420BiPlanar_chroma *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000235\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = float2(r0.yz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b5ceef05:898edb99:9f947171:98dbaa5b\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000227\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = r0.yz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=513314b2:face81c8:9010d868:78fd2bc7\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001c9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.yz = texture2D(hg_Texture0, hg_TexCoord0.xy).yz;\n"
           "    gl_FragColor.xy = r0.yz;\n"
           "}\n"
           "//MD5=6e8f9b59:fe470076:deb0cf55:8a2a4614\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_chroma::InitProgramDescriptor(HgcYUV420BiPlanar_chroma *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_chroma_hgc_visible", "//Metal1.0     \n//LEN=0000000172\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_chroma_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.yz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).yz;\n"
    "    output.color0.xy = r0.yz;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV420BiPlanar_chroma");
}

void sub_1B78E9B98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78E9BD0(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78E9BC8);
}

double HgcYUV420BiPlanar_chroma::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D70;
  strcpy(v3, "HgcYUV420BiPlanar_chroma [hgc1]");
  return *(double *)"ar_chroma [hgc1]";
}

uint64_t HgcYUV420BiPlanar_chroma::BindTexture(HgcYUV420BiPlanar_chroma *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, -0.5, -0.5, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 2.0, 2.0, 1.0);
  return 0;
}

uint64_t HgcYUV420BiPlanar_chroma::Bind(HgcYUV420BiPlanar_chroma *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV420BiPlanar_chroma::RenderTile(HgcYUV420BiPlanar_chroma *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 1);
  int v3 = *((_DWORD *)a2 + 3) - v2;
  if (v3 >= 1)
  {
    uint64_t v4 = *(int *)a2;
    unint64_t v5 = (*((_DWORD *)a2 + 2) - v4);
    uint64_t v6 = *((int *)a2 + 22);
    uint64_t v7 = *((void *)a2 + 10);
    int v8 = v6 * v2;
    uint64_t v9 = v7 + 16 * (int)v6 * v2 + 16 * v4;
    uint64_t v10 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v11 = *((int *)a2 + 6);
    uint64_t v12 = 2 * v6;
    if ((int)v5 < 4)
    {
      if ((int)v5 >= 1)
      {
        int v30 = 0;
        uint64_t v31 = 16 * v12;
        uint64_t v32 = 32 * (*((_DWORD *)a2 + 2) - v4);
        do
        {
          uint64_t v33 = 0;
          int8x16_t v34 = v10;
          do
          {
            *v34++ = vbslq_s8(*(int8x16_t *)(*((void *)this + 51) + 16), vextq_s8(*(int8x16_t *)(v9 + v33), *(int8x16_t *)(v9 + v33), 4uLL), *(int8x16_t *)*((void *)this + 51));
            v33 += 32;
          }
          while (v32 != v33);
          ++v30;
          v10 += v11;
          v9 += v31;
        }
        while (v30 != v3);
      }
    }
    else
    {
      int v13 = 0;
      uint64_t v14 = 16 * v4 + 16 * v8 + v7 + 64;
      uint64_t v15 = v10 + 2;
      uint64_t v16 = 16 * v11;
      uint64_t v17 = v10 + 4;
      do
      {
        unint64_t v18 = 0;
        uint64_t v19 = v17;
        uint64_t v20 = 8;
        unsigned int v21 = v15;
        int8x16_t v22 = (int8x16_t *)v14;
        do
        {
          uint64_t v23 = v20;
          int8x16_t v24 = v19;
          int8x16_t v25 = (int8x16_t *)*((void *)this + 51);
          int8x16_t v26 = v25[1];
          int8x16_t v27 = vbslq_s8(v26, vextq_s8(v22[-2], v22[-2], 4uLL), *v25);
          int8x16_t v28 = vbslq_s8(v26, vextq_s8(*v22, *v22, 4uLL), *v25);
          int8x16_t v29 = vbslq_s8(v26, vextq_s8(v22[2], v22[2], 4uLL), *v25);
          v21[-2] = vbslq_s8(v26, vextq_s8(v22[-4], v22[-4], 4uLL), *v25);
          v21[-1] = v27;
          v18 += 4;
          v22 += 8;
          *unsigned int v21 = v28;
          v21[1] = v29;
          v21 += 4;
          v20 += 8;
          uint64_t v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v5 - 3));
        if ((int)v5 > (int)v18)
        {
          do
          {
            *v24++ = vbslq_s8(*(int8x16_t *)(*((void *)this + 51) + 16), vextq_s8(*(int8x16_t *)(v9 + 16 * (v23 & 0xFFFFFFFE)), *(int8x16_t *)(v9 + 16 * (v23 & 0xFFFFFFFE)), 4uLL), *(int8x16_t *)*((void *)this + 51));
            ++v18;
            v23 += 2;
          }
          while (v18 < v5);
        }
        v9 += 16 * v12;
        ++v13;
        v14 += 16 * v12;
        uint64_t v15 = (int8x16_t *)((char *)v15 + v16);
        uint64_t v17 = (int8x16_t *)((char *)v17 + v16);
      }
      while (v13 != v3);
    }
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_chroma::GetDOD(HgcYUV420BiPlanar_chroma *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 0.5);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  return HGRectUnion(0, 0, v14, v15);
}

uint64_t HgcYUV420BiPlanar_chroma::GetROI(HgcYUV420BiPlanar_chroma *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 2.0);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  return HGRectUnion(0, 0, v14, v15);
}

void HgcYUV420BiPlanar_chroma::HgcYUV420BiPlanar_chroma(HgcYUV420BiPlanar_chroma *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10E9D70;
  operator new();
}

void sub_1B78EA120(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_chroma::~HgcYUV420BiPlanar_chroma(HGNode *this)
{
  *(void *)this = &unk_1F10E9D70;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E9D70;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_chroma::SetParameter(HgcYUV420BiPlanar_chroma *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV420BiPlanar_chroma::GetParameter(HgcYUV420BiPlanar_chroma *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV422BiPlanar_chroma::GetProgram(HgcYUV422BiPlanar_chroma *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000235\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = float2(r0.yz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b5ceef05:898edb99:9f947171:98dbaa5b\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000227\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = r0.yz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=513314b2:face81c8:9010d868:78fd2bc7\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001c9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.yz = texture2D(hg_Texture0, hg_TexCoord0.xy).yz;\n"
           "    gl_FragColor.xy = r0.yz;\n"
           "}\n"
           "//MD5=6e8f9b59:fe470076:deb0cf55:8a2a4614\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcYUV422BiPlanar_chroma::InitProgramDescriptor(HgcYUV422BiPlanar_chroma *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422BiPlanar_chroma_hgc_visible", "//Metal1.0     \n//LEN=0000000172\n[[ visible ]] FragmentOut HgcYUV422BiPlanar_chroma_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.yz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).yz;\n"
    "    output.color0.xy = r0.yz;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV422BiPlanar_chroma");
}

void sub_1B78EA628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78EA660(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78EA658);
}

double HgcYUV422BiPlanar_chroma::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D70;
  strcpy(v3, "HgcYUV422BiPlanar_chroma [hgc1]");
  return *(double *)"ar_chroma [hgc1]";
}

uint64_t HgcYUV422BiPlanar_chroma::BindTexture(HgcYUV422BiPlanar_chroma *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, -0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcYUV422BiPlanar_chroma::Bind(HgcYUV422BiPlanar_chroma *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV422BiPlanar_chroma::RenderTile(HgcYUV422BiPlanar_chroma *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    uint64_t v3 = *(int *)a2;
    unint64_t v4 = (*((_DWORD *)a2 + 2) - v3);
    uint64_t v5 = *((void *)a2 + 10);
    uint64_t v6 = v5 + 16 * v3;
    float v7 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v8 = *((int *)a2 + 6);
    uint64_t v9 = *((int *)a2 + 22);
    if ((int)v4 < 4)
    {
      if ((int)v4 >= 1)
      {
        int v27 = 0;
        uint64_t v28 = 16 * v9;
        uint64_t v29 = 32 * (*((_DWORD *)a2 + 2) - v3);
        do
        {
          uint64_t v30 = 0;
          uint64_t v31 = v7;
          do
          {
            *v31++ = vbslq_s8(*(int8x16_t *)(*((void *)this + 51) + 16), vextq_s8(*(int8x16_t *)(v6 + v30), *(int8x16_t *)(v6 + v30), 4uLL), *(int8x16_t *)*((void *)this + 51));
            v30 += 32;
          }
          while (v29 != v30);
          ++v27;
          v7 += v8;
          v6 += v28;
        }
        while (v27 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = v5 + 16 * v3 + 64;
      float v12 = v7 + 2;
      uint64_t v13 = 16 * v8;
      uint64_t v14 = v7 + 4;
      do
      {
        unint64_t v15 = 0;
        uint64_t v16 = v14;
        uint64_t v17 = 8;
        unint64_t v18 = v12;
        uint64_t v19 = (int8x16_t *)v11;
        do
        {
          uint64_t v20 = v17;
          unsigned int v21 = v16;
          int8x16_t v22 = (int8x16_t *)*((void *)this + 51);
          int8x16_t v23 = v22[1];
          int8x16_t v24 = vbslq_s8(v23, vextq_s8(v19[-2], v19[-2], 4uLL), *v22);
          int8x16_t v25 = vbslq_s8(v23, vextq_s8(*v19, *v19, 4uLL), *v22);
          int8x16_t v26 = vbslq_s8(v23, vextq_s8(v19[2], v19[2], 4uLL), *v22);
          v18[-2] = vbslq_s8(v23, vextq_s8(v19[-4], v19[-4], 4uLL), *v22);
          v18[-1] = v24;
          v15 += 4;
          v19 += 8;
          *unint64_t v18 = v25;
          v18[1] = v26;
          v18 += 4;
          v17 += 8;
          uint64_t v16 = v21 + 4;
        }
        while ((uint64_t)v15 < (uint64_t)(v4 - 3));
        if ((int)v4 > (int)v15)
        {
          do
          {
            *v21++ = vbslq_s8(*(int8x16_t *)(*((void *)this + 51) + 16), vextq_s8(*(int8x16_t *)(v6 + 16 * (v20 & 0xFFFFFFFE)), *(int8x16_t *)(v6 + 16 * (v20 & 0xFFFFFFFE)), 4uLL), *(int8x16_t *)*((void *)this + 51));
            ++v15;
            v20 += 2;
          }
          while (v15 < v4);
        }
        v6 += 16 * v9;
        ++v10;
        v11 += 16 * v9;
        float v12 = (int8x16_t *)((char *)v12 + v13);
        uint64_t v14 = (int8x16_t *)((char *)v14 + v13);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_chroma::GetDOD(HgcYUV422BiPlanar_chroma *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 0.5);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  return HGRectUnion(0, 0, v14, v15);
}

uint64_t HgcYUV422BiPlanar_chroma::GetROI(HgcYUV422BiPlanar_chroma *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 2.0);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  return HGRectUnion(0, 0, v14, v15);
}

void HgcYUV422BiPlanar_chroma::HgcYUV422BiPlanar_chroma(HgcYUV422BiPlanar_chroma *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10E9FD8;
  operator new();
}

void sub_1B78EAB98(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422BiPlanar_chroma::~HgcYUV422BiPlanar_chroma(HGNode *this)
{
  *(void *)this = &unk_1F10E9FD8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E9FD8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV422BiPlanar_chroma::SetParameter(HgcYUV422BiPlanar_chroma *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV422BiPlanar_chroma::GetParameter(HgcYUV422BiPlanar_chroma *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV422BiPlanar_chroma_pack2::GetProgram(HgcYUV422BiPlanar_chroma_pack2 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002ab\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).yz;\n"
             "    r1.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = float2(r0.yz);\n"
             "    output.color0.zw = float2(r1.yz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=33bdb345:2758fc0c:d30c75e2:ea65b96f\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000028d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).yz;\n"
             "    r1.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).yz;\n"
             "    output.color0.xy = r0.yz;\n"
             "    output.color0.zw = r1.yz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6888e40f:7ebf1f5f:d902b6ad:5e066264\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000243\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.yz = texture2D(hg_Texture0, hg_TexCoord1.xy).yz;\n"
           "    r1.yz = texture2D(hg_Texture0, hg_TexCoord0.xy).yz;\n"
           "    gl_FragColor.xy = r0.yz;\n"
           "    gl_FragColor.zw = r1.yz;\n"
           "}\n"
           "//MD5=0c7412c0:8a79fbe3:17780697:6248caac\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcYUV422BiPlanar_chroma_pack2::InitProgramDescriptor(HgcYUV422BiPlanar_chroma_pack2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422BiPlanar_chroma_pack2_hgc_visible", "//Metal1.0     \n//LEN=00000001ee\n[[ visible ]] FragmentOut HgcYUV422BiPlanar_chroma_pack2_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.yz = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).yz;\n"
    "    r1.yz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).yz;\n"
    "    output.color0.xy = r0.yz;\n"
    "    output.color0.zw = r1.yz;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV422BiPlanar_chroma_pack2");
}

void sub_1B78EB138(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78EB174(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78EB16CLL);
}

char *HgcYUV422BiPlanar_chroma_pack2::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D30;
  strcpy(result, "HgcYUV422BiPlanar_chroma_pack2 [hgc1]");
  return result;
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::BindTexture(HgcYUV422BiPlanar_chroma_pack2 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, -1.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 4.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, 0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 4.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::Bind(HgcYUV422BiPlanar_chroma_pack2 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::RenderTile(HgcYUV422BiPlanar_chroma_pack2 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = *((void *)a2 + 10);
    int v5 = 3 * *(_DWORD *)a2;
    uint64_t v6 = v5;
    uint64_t v7 = *((void *)a2 + 2);
    uint64_t v8 = *((int *)a2 + 6);
    uint64_t v9 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v33 = 0;
        uint64_t v34 = v4 + 16 * v5 + 32;
        uint64_t v35 = 16 * v9;
        uint64_t v36 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          uint64_t v37 = 0;
          uint64_t v38 = (int8x16_t *)v34;
          do
          {
            int8x16_t v39 = v38[-2];
            int8x16_t v40 = *v38;
            v38 += 4;
            int8x16_t v41 = vextq_s8(v39, v40, 0xCuLL);
            *(int8x8_t *)v39.i8 = vext_s8(*(int8x8_t *)v39.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL), 4uLL);
            v39.i64[1] = vextq_s8(v41, v41, 8uLL).u64[0];
            *(int8x16_t *)(v7 + v37) = v39;
            v37 += 16;
          }
          while (v36 != v37);
          ++v33;
          v7 += 16 * v8;
          v34 += v35;
        }
        while (v33 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = v4 + 16 * v5;
      uint64_t v12 = v4 + 16 * v6 + 128;
      float v13 = (_OWORD *)(v7 + 32);
      uint64_t v14 = 16 * v8;
      uint64_t v15 = (int8x16_t *)(v7 + 64);
      do
      {
        unint64_t v16 = 0;
        int v17 = 18;
        unint64_t v18 = v15;
        uint64_t v19 = v13;
        uint64_t v20 = v12;
        do
        {
          int8x16_t v21 = *(int8x16_t *)(v20 - 128);
          int8x16_t v22 = vextq_s8(v21, *(int8x16_t *)(v20 - 96), 0xCuLL);
          *(int8x8_t *)v21.i8 = vext_s8(*(int8x8_t *)v21.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL), 4uLL);
          v21.i64[1] = vextq_s8(v22, v22, 8uLL).u64[0];
          int8x16_t v23 = vextq_s8(v21, *(int8x16_t *)(v20 - 32), 0xCuLL);
          *(int8x8_t *)&long long v24 = vext_s8(*(int8x8_t *)(v20 - 64), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v20 - 64), *(int8x16_t *)(v20 - 64), 8uLL), 4uLL);
          *((void *)&v24 + 1) = vextq_s8(v23, v23, 8uLL).u64[0];
          int8x16_t v25 = vextq_s8(v21, *(int8x16_t *)(v20 + 32), 0xCuLL);
          *(int8x8_t *)&long long v26 = vext_s8(*(int8x8_t *)v20, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v20, *(int8x16_t *)v20, 8uLL), 4uLL);
          *((void *)&v26 + 1) = vextq_s8(v25, v25, 8uLL).u64[0];
          int8x16_t v27 = vextq_s8(v21, *(int8x16_t *)(v20 + 96), 0xCuLL);
          *(int8x8_t *)&long long v28 = vext_s8(*(int8x8_t *)(v20 + 64), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v20 + 64), *(int8x16_t *)(v20 + 64), 8uLL), 4uLL);
          *((void *)&v28 + 1) = vextq_s8(v27, v27, 8uLL).u64[0];
          unsigned int v29 = v17;
          uint64_t v30 = v18;
          *(v19 - 2) = v21;
          *(v19 - 1) = v24;
          v16 += 4;
          v20 += 256;
          *uint64_t v19 = v26;
          v19[1] = v28;
          v19 += 4;
          v17 += 16;
          v18 += 4;
        }
        while ((uint64_t)v16 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v16)
        {
          do
          {
            int8x16_t v31 = *(int8x16_t *)(v11 + 16 * (v29 - 2));
            int8x16_t v32 = vextq_s8(v31, *(int8x16_t *)(v11 + 16 * v29), 0xCuLL);
            *(int8x8_t *)v31.i8 = vext_s8(*(int8x8_t *)v31.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL), 4uLL);
            v31.i64[1] = vextq_s8(v32, v32, 8uLL).u64[0];
            *v30++ = v31;
            ++v16;
            v29 += 4;
          }
          while (v16 < v3);
        }
        v11 += 16 * v9;
        ++v10;
        v12 += 16 * v9;
        float v13 = (_OWORD *)((char *)v13 + v14);
        uint64_t v15 = (int8x16_t *)((char *)v15 + v14);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::GetDOD(HgcYUV422BiPlanar_chroma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0, 0, 0xFFFFFFFE, 0);
  int v8 = HGRectGrow(v6, v5, v7);
  float v9 = HGRectFloat(v8);
  float v13 = HGRectScale(v9, v10, v11, v12, 0.25);
  uint64_t v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::GetROI(HgcYUV422BiPlanar_chroma_pack2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 4.0);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  uint64_t v16 = v15;
  uint64_t v17 = HGRectMake4i(0, 0, 2u, 0);
  uint64_t v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcYUV422BiPlanar_chroma_pack2::HgcYUV422BiPlanar_chroma_pack2(HgcYUV422BiPlanar_chroma_pack2 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EA240;
  operator new();
}

void sub_1B78EB82C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422BiPlanar_chroma_pack2::~HgcYUV422BiPlanar_chroma_pack2(HGNode *this)
{
  *(void *)this = &unk_1F10EA240;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0xC400A2AC0F1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EA240;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0xC400A2AC0F1);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::SetParameter(HgcYUV422BiPlanar_chroma_pack2 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcYUV422BiPlanar_chroma_pack2::GetParameter(HgcYUV422BiPlanar_chroma_pack2 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcYUV422BiPlanar_601ToRGB::GetProgram(HgcYUV422BiPlanar_601ToRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const half4 c1 = half4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0e00be48:1d4c1030:c845256d:4f625dda\n"
             "//SIG=00400000:00000001:00000001:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e920bf17:693c75e5:4f148dce:a2580259\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=b28b84a9:65d97aa9:3bf19568:b311251d\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV422BiPlanar_601ToRGB::InitProgramDescriptor(HgcYUV422BiPlanar_601ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422BiPlanar_601ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e7\n[[ visible ]] FragmentOut HgcYUV422BiPlanar_601ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
    "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV422BiPlanar_601ToRGB");
}

void sub_1B78EBDC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78EBE00(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78EBDF8);
}

char *HgcYUV422BiPlanar_601ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376030;
  strcpy(result, "HgcYUV422BiPlanar_601ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV422BiPlanar_601ToRGB::BindTexture(HgcYUV422BiPlanar_601ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2); {
      (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 0.5, 1.0, 1.0);
      }
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v5)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcYUV422BiPlanar_601ToRGB::Bind(HgcYUV422BiPlanar_601ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV422BiPlanar_601ToRGB::RenderTile(HgcYUV422BiPlanar_601ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    float32x4_t v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B8375E70);
    int32x2_t v8 = a2[2];
    int32x2_t v9 = a2[10];
    uint64_t v10 = 16 * a2[11].i32[0];
    uint64_t v11 = 16 * a2[3].i32[0];
    __asm { FMOV            V4.4S, #4.0 }
    v17.i64[0] = 0x3F0000003F000000;
    v17.i64[1] = 0x3F0000003F000000;
    while (v6 < 4)
    {
      LODWORD(v64) = 0;
      float32x4_t v19 = 0uLL;
      if (v6 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      *(void *)&v9 += v10;
      *(void *)&v8 += v11;
      if (v4 == v3) {
        return 0;
      }
    }
    int v18 = 0;
    float32x4_t v19 = 0uLL;
    uint64_t v20 = 32;
    do
    {
      float32x4_t v21 = vaddq_f32(v7, vmulq_f32(v19, (float32x4_t)xmmword_1B7E75B20));
      float32x4_t v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v23 = vaddq_f32(v22, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E75B20);
      int32x2_t v25 = a2[12];
      __int32 v26 = a2[13].i32[0];
      float32x4_t v27 = vaddq_f32(vsubq_f32(v21, v5), v17);
      int32x4_t v28 = vcvtq_s32_f32(v27);
      v27.i64[0] = vaddq_s32(v28, vcgtq_f32(vcvtq_f32_s32(v28), v27)).u64[0];
      __int32 v29 = v27.i32[1];
      __int32 v30 = v27.i32[0];
      float32x4_t v31 = vaddq_f32(vsubq_f32(v22, v5), v17);
      int32x4_t v32 = vcvtq_s32_f32(v31);
      __int32 v33 = v30 + v29 * v26;
      v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
      __int32 v34 = v31.i32[1];
      __int32 v35 = v31.i32[0];
      int8x16_t v36 = *(int8x16_t *)(*(void *)&v25 + 16 * v33);
      float32x4_t v37 = vaddq_f32(vsubq_f32(v23, v5), v17);
      int32x4_t v38 = vcvtq_s32_f32(v37);
      __int32 v39 = v35 + v34 * v26;
      v37.i64[0] = vaddq_s32(v38, vcgtq_f32(vcvtq_f32_s32(v38), v37)).u64[0];
      __int32 v40 = v37.i32[1];
      __int32 v41 = v37.i32[0];
      int8x16_t v42 = *(int8x16_t *)(*(void *)&v25 + 16 * v39);
      float32x4_t v43 = vaddq_f32(vsubq_f32(v24, v5), v17);
      int32x4_t v44 = vcvtq_s32_f32(v43);
      __int32 v45 = v41 + v40 * v26;
      v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
      __int32 v46 = v43.i32[1];
      __int32 v47 = v43.i32[0];
      int8x16_t v48 = *(int8x16_t *)(*(void *)&v25 + 16 * v45);
      int8x16_t v49 = *(int8x16_t *)(*(void *)&v25 + 16 * (v47 + v46 * v26));
      uint64_t v50 = *((void *)this + 51);
      int8x16_t v51 = *(int8x16_t *)(v50 + 32);
      float32x4_t v52 = *(float32x4_t *)(v50 + 48);
      float32x4_t v53 = *(float32x4_t *)(v50 + 16);
      float32x4_t v54 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(void *)&v9 + v20 - 32), vextq_s8(v36, v36, 0xCuLL))));
      float32x4_t v55 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(void *)&v9 + v20 - 16), vextq_s8(v42, v42, 0xCuLL))));
      float32x4_t v56 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(void *)&v9 + v20), vextq_s8(v48, v48, 0xCuLL))));
      float32x4_t v57 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(void *)&v9 + v20 + 16), vextq_s8(v49, v49, 0xCuLL))));
      float32x4_t v19 = vaddq_f32(v19, _Q4);
      float32x4_t v58 = *(float32x4_t *)(v50 + 64);
      float32x4_t v59 = vaddq_f32(vmulq_laneq_f32(v58, v54, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v54.f32, 1)));
      float32x4_t v60 = vaddq_f32(vmulq_laneq_f32(v58, v55, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v55.f32, 1)));
      float32x4_t v61 = vaddq_f32(vmulq_laneq_f32(v58, v56, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v56.f32, 1)));
      v59.i32[3] = 1.0;
      v60.i32[3] = 1.0;
      v61.i32[3] = 1.0;
      float32x4_t v62 = vaddq_f32(vmulq_laneq_f32(v58, v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v57.f32, 1)));
      v62.i32[3] = 1.0;
      float32x4_t v63 = (float32x4_t *)(*(void *)&v8 + v20);
      v63[-2] = v59;
      v63[-1] = v60;
      *float32x4_t v63 = v61;
      v63[1] = v62;
      v18 -= 4;
      v20 += 64;
    }
    while (v6 + v18 > 3);
    LODWORD(v64) = -v18;
    if ((int)v64 >= v6) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v64 = v64;
    do
    {
      float32x4_t v65 = vaddq_f32(vsubq_f32(vaddq_f32(v7, vmulq_f32(v19, (float32x4_t)xmmword_1B7E75B20)), v5), v17);
      int32x4_t v66 = vcvtq_s32_f32(v65);
      v65.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v65)).u64[0];
      uint64_t v67 = *((void *)this + 51);
      float32x4_t v68 = vaddq_f32(*(float32x4_t *)(v67 + 16), vmulq_f32(*(float32x4_t *)v67, (float32x4_t)vbslq_s8(*(int8x16_t *)(v67 + 32), *(int8x16_t *)(*(void *)&v9 + 16 * v64), vextq_s8(*(int8x16_t *)(*(void *)&a2[12] + 16 * (v65.i32[0] + v65.i32[1] * a2[13].i32[0])), *(int8x16_t *)(*(void *)&a2[12] + 16 * (v65.i32[0] + v65.i32[1] * a2[13].i32[0])), 0xCuLL))));
      float32x4_t v69 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v67 + 64), v68, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v67 + 48), *(float32x2_t *)v68.f32, 1)));
      v69.i32[3] = 1.0;
      *(float32x4_t *)(*(void *)&v8 + 16 * v64) = v69;
      __asm { FMOV            V16.4S, #1.0 }
      float32x4_t v19 = vaddq_f32(v19, _Q16);
      ++v64;
    }
    while (v64 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_601ToRGB::GetDOD(HgcYUV422BiPlanar_601ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  if (!a3) {
    return v5;
  }
  if (a3 == 1)
  {
    uint64_t v6 = HGRectMake4i(0, 0, 1u, 0);
    int v7 = HGRectGrow(v5, v4, v6);
    float v8 = HGRectFloat(v7);
    float v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    uint64_t v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_601ToRGB::GetROI(HgcYUV422BiPlanar_601ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result = *(void *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      float v5 = HGRectFloat(a4.var0);
      float v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      uint64_t v16 = v15;
      uint64_t v17 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
      uint64_t v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV422BiPlanar_601ToRGB::HgcYUV422BiPlanar_601ToRGB(HgcYUV422BiPlanar_601ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EA4A8;
  operator new();
}

void sub_1B78EC698(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422BiPlanar_601ToRGB::~HgcYUV422BiPlanar_601ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10EA4A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10EA4A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EA4A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV422BiPlanar_601ToRGB::SetParameter(HgcYUV422BiPlanar_601ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  double v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *double v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV422BiPlanar_601ToRGB::GetParameter(HgcYUV422BiPlanar_601ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  float v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV422BiPlanar_709ToRGB::GetProgram(HgcYUV422BiPlanar_709ToRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const half4 c1 = half4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1048caae:387a44ef:fc83ffd8:52b73979\n"
             "//SIG=00400000:00000001:00000001:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2408e641:b05fbd09:a6279793:e6b41496\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=50acfb20:dc59fe91:195acf38:f03e2245\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV422BiPlanar_709ToRGB::InitProgramDescriptor(HgcYUV422BiPlanar_709ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422BiPlanar_709ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e7\n[[ visible ]] FragmentOut HgcYUV422BiPlanar_709ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
    "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV422BiPlanar_709ToRGB");
}

void sub_1B78ECD6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78ECDA8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78ECDA0);
}

char *HgcYUV422BiPlanar_709ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376030;
  strcpy(result, "HgcYUV422BiPlanar_709ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV422BiPlanar_709ToRGB::BindTexture(HgcYUV422BiPlanar_709ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2); {
      (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 0.5, 1.0, 1.0);
      }
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v5)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcYUV422BiPlanar_709ToRGB::Bind(HgcYUV422BiPlanar_709ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV422BiPlanar_709ToRGB::RenderTile(HgcYUV422BiPlanar_709ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    float32x4_t v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B8375E70);
    int32x2_t v8 = a2[2];
    int32x2_t v9 = a2[10];
    uint64_t v10 = 16 * a2[11].i32[0];
    uint64_t v11 = 16 * a2[3].i32[0];
    __asm { FMOV            V4.4S, #4.0 }
    v17.i64[0] = 0x3F0000003F000000;
    v17.i64[1] = 0x3F0000003F000000;
    while (v6 < 4)
    {
      LODWORD(v64) = 0;
      float32x4_t v19 = 0uLL;
      if (v6 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      *(void *)&v9 += v10;
      *(void *)&v8 += v11;
      if (v4 == v3) {
        return 0;
      }
    }
    int v18 = 0;
    float32x4_t v19 = 0uLL;
    uint64_t v20 = 32;
    do
    {
      float32x4_t v21 = vaddq_f32(v7, vmulq_f32(v19, (float32x4_t)xmmword_1B7E75B20));
      float32x4_t v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v23 = vaddq_f32(v22, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E75B20);
      int32x2_t v25 = a2[12];
      __int32 v26 = a2[13].i32[0];
      float32x4_t v27 = vaddq_f32(vsubq_f32(v21, v5), v17);
      int32x4_t v28 = vcvtq_s32_f32(v27);
      v27.i64[0] = vaddq_s32(v28, vcgtq_f32(vcvtq_f32_s32(v28), v27)).u64[0];
      __int32 v29 = v27.i32[1];
      __int32 v30 = v27.i32[0];
      float32x4_t v31 = vaddq_f32(vsubq_f32(v22, v5), v17);
      int32x4_t v32 = vcvtq_s32_f32(v31);
      __int32 v33 = v30 + v29 * v26;
      v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
      __int32 v34 = v31.i32[1];
      __int32 v35 = v31.i32[0];
      int8x16_t v36 = *(int8x16_t *)(*(void *)&v25 + 16 * v33);
      float32x4_t v37 = vaddq_f32(vsubq_f32(v23, v5), v17);
      int32x4_t v38 = vcvtq_s32_f32(v37);
      __int32 v39 = v35 + v34 * v26;
      v37.i64[0] = vaddq_s32(v38, vcgtq_f32(vcvtq_f32_s32(v38), v37)).u64[0];
      __int32 v40 = v37.i32[1];
      __int32 v41 = v37.i32[0];
      int8x16_t v42 = *(int8x16_t *)(*(void *)&v25 + 16 * v39);
      float32x4_t v43 = vaddq_f32(vsubq_f32(v24, v5), v17);
      int32x4_t v44 = vcvtq_s32_f32(v43);
      __int32 v45 = v41 + v40 * v26;
      v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
      __int32 v46 = v43.i32[1];
      __int32 v47 = v43.i32[0];
      int8x16_t v48 = *(int8x16_t *)(*(void *)&v25 + 16 * v45);
      int8x16_t v49 = *(int8x16_t *)(*(void *)&v25 + 16 * (v47 + v46 * v26));
      uint64_t v50 = *((void *)this + 51);
      int8x16_t v51 = *(int8x16_t *)(v50 + 32);
      float32x4_t v52 = *(float32x4_t *)(v50 + 48);
      float32x4_t v53 = *(float32x4_t *)(v50 + 16);
      float32x4_t v54 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(void *)&v9 + v20 - 32), vextq_s8(v36, v36, 0xCuLL))));
      float32x4_t v55 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(void *)&v9 + v20 - 16), vextq_s8(v42, v42, 0xCuLL))));
      float32x4_t v56 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(void *)&v9 + v20), vextq_s8(v48, v48, 0xCuLL))));
      float32x4_t v57 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(void *)&v9 + v20 + 16), vextq_s8(v49, v49, 0xCuLL))));
      float32x4_t v19 = vaddq_f32(v19, _Q4);
      float32x4_t v58 = *(float32x4_t *)(v50 + 64);
      float32x4_t v59 = vaddq_f32(vmulq_laneq_f32(v58, v54, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v54.f32, 1)));
      float32x4_t v60 = vaddq_f32(vmulq_laneq_f32(v58, v55, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v55.f32, 1)));
      float32x4_t v61 = vaddq_f32(vmulq_laneq_f32(v58, v56, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v56.f32, 1)));
      v59.i32[3] = 1.0;
      v60.i32[3] = 1.0;
      v61.i32[3] = 1.0;
      float32x4_t v62 = vaddq_f32(vmulq_laneq_f32(v58, v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v57.f32, 1)));
      v62.i32[3] = 1.0;
      float32x4_t v63 = (float32x4_t *)(*(void *)&v8 + v20);
      v63[-2] = v59;
      v63[-1] = v60;
      *float32x4_t v63 = v61;
      v63[1] = v62;
      v18 -= 4;
      v20 += 64;
    }
    while (v6 + v18 > 3);
    LODWORD(v64) = -v18;
    if ((int)v64 >= v6) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v64 = v64;
    do
    {
      float32x4_t v65 = vaddq_f32(vsubq_f32(vaddq_f32(v7, vmulq_f32(v19, (float32x4_t)xmmword_1B7E75B20)), v5), v17);
      int32x4_t v66 = vcvtq_s32_f32(v65);
      v65.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v65)).u64[0];
      uint64_t v67 = *((void *)this + 51);
      float32x4_t v68 = vaddq_f32(*(float32x4_t *)(v67 + 16), vmulq_f32(*(float32x4_t *)v67, (float32x4_t)vbslq_s8(*(int8x16_t *)(v67 + 32), *(int8x16_t *)(*(void *)&v9 + 16 * v64), vextq_s8(*(int8x16_t *)(*(void *)&a2[12] + 16 * (v65.i32[0] + v65.i32[1] * a2[13].i32[0])), *(int8x16_t *)(*(void *)&a2[12] + 16 * (v65.i32[0] + v65.i32[1] * a2[13].i32[0])), 0xCuLL))));
      float32x4_t v69 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v67 + 64), v68, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v67 + 48), *(float32x2_t *)v68.f32, 1)));
      v69.i32[3] = 1.0;
      *(float32x4_t *)(*(void *)&v8 + 16 * v64) = v69;
      __asm { FMOV            V16.4S, #1.0 }
      float32x4_t v19 = vaddq_f32(v19, _Q16);
      ++v64;
    }
    while (v64 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_709ToRGB::GetDOD(HgcYUV422BiPlanar_709ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  if (!a3) {
    return v5;
  }
  if (a3 == 1)
  {
    uint64_t v6 = HGRectMake4i(0, 0, 1u, 0);
    int v7 = HGRectGrow(v5, v4, v6);
    float v8 = HGRectFloat(v7);
    float v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    uint64_t v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_709ToRGB::GetROI(HgcYUV422BiPlanar_709ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result = *(void *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      float v5 = HGRectFloat(a4.var0);
      float v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      uint64_t v16 = v15;
      uint64_t v17 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
      uint64_t v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV422BiPlanar_709ToRGB::HgcYUV422BiPlanar_709ToRGB(HgcYUV422BiPlanar_709ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EA710;
  operator new();
}

void sub_1B78ED640(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422BiPlanar_709ToRGB::~HgcYUV422BiPlanar_709ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10EA710;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10EA710;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EA710;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV422BiPlanar_709ToRGB::SetParameter(HgcYUV422BiPlanar_709ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  double v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *double v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV422BiPlanar_709ToRGB::GetParameter(HgcYUV422BiPlanar_709ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  float v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV422BiPlanar_2020ToRGB::GetProgram(HgcYUV422BiPlanar_2020ToRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const half4 c1 = half4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5b2c3b8c:71d74731:f5cd4f36:083b9890\n"
             "//SIG=00400000:00000001:00000001:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=76c81ece:94c5249f:ae40b588:a20d303a\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=39ba3a76:86163c26:2e7e27c5:49379347\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV422BiPlanar_2020ToRGB::InitProgramDescriptor(HgcYUV422BiPlanar_2020ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV422BiPlanar_2020ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e8\n[[ visible ]] FragmentOut HgcYUV422BiPlanar_2020ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
    "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV422BiPlanar_2020ToRGB");
}

void sub_1B78EDD14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78EDD50(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78EDD48);
}

char *HgcYUV422BiPlanar_2020ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375DB0;
  strcpy(result, "HgcYUV422BiPlanar_2020ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::BindTexture(HgcYUV422BiPlanar_2020ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2); {
      (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 0.5, 1.0, 1.0);
      }
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v5)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::Bind(HgcYUV422BiPlanar_2020ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::RenderTile(HgcYUV422BiPlanar_2020ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    float32x4_t v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B8375E70);
    int32x2_t v8 = a2[2];
    int32x2_t v9 = a2[10];
    uint64_t v10 = 16 * a2[11].i32[0];
    uint64_t v11 = 16 * a2[3].i32[0];
    __asm { FMOV            V4.4S, #4.0 }
    v17.i64[0] = 0x3F0000003F000000;
    v17.i64[1] = 0x3F0000003F000000;
    while (v6 < 4)
    {
      LODWORD(v64) = 0;
      float32x4_t v19 = 0uLL;
      if (v6 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      *(void *)&v9 += v10;
      *(void *)&v8 += v11;
      if (v4 == v3) {
        return 0;
      }
    }
    int v18 = 0;
    float32x4_t v19 = 0uLL;
    uint64_t v20 = 32;
    do
    {
      float32x4_t v21 = vaddq_f32(v7, vmulq_f32(v19, (float32x4_t)xmmword_1B7E75B20));
      float32x4_t v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v23 = vaddq_f32(v22, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E75B20);
      int32x2_t v25 = a2[12];
      __int32 v26 = a2[13].i32[0];
      float32x4_t v27 = vaddq_f32(vsubq_f32(v21, v5), v17);
      int32x4_t v28 = vcvtq_s32_f32(v27);
      v27.i64[0] = vaddq_s32(v28, vcgtq_f32(vcvtq_f32_s32(v28), v27)).u64[0];
      __int32 v29 = v27.i32[1];
      __int32 v30 = v27.i32[0];
      float32x4_t v31 = vaddq_f32(vsubq_f32(v22, v5), v17);
      int32x4_t v32 = vcvtq_s32_f32(v31);
      __int32 v33 = v30 + v29 * v26;
      v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
      __int32 v34 = v31.i32[1];
      __int32 v35 = v31.i32[0];
      int8x16_t v36 = *(int8x16_t *)(*(void *)&v25 + 16 * v33);
      float32x4_t v37 = vaddq_f32(vsubq_f32(v23, v5), v17);
      int32x4_t v38 = vcvtq_s32_f32(v37);
      __int32 v39 = v35 + v34 * v26;
      v37.i64[0] = vaddq_s32(v38, vcgtq_f32(vcvtq_f32_s32(v38), v37)).u64[0];
      __int32 v40 = v37.i32[1];
      __int32 v41 = v37.i32[0];
      int8x16_t v42 = *(int8x16_t *)(*(void *)&v25 + 16 * v39);
      float32x4_t v43 = vaddq_f32(vsubq_f32(v24, v5), v17);
      int32x4_t v44 = vcvtq_s32_f32(v43);
      __int32 v45 = v41 + v40 * v26;
      v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
      __int32 v46 = v43.i32[1];
      __int32 v47 = v43.i32[0];
      int8x16_t v48 = *(int8x16_t *)(*(void *)&v25 + 16 * v45);
      int8x16_t v49 = *(int8x16_t *)(*(void *)&v25 + 16 * (v47 + v46 * v26));
      uint64_t v50 = *((void *)this + 51);
      int8x16_t v51 = *(int8x16_t *)(v50 + 32);
      float32x4_t v52 = *(float32x4_t *)(v50 + 48);
      float32x4_t v53 = *(float32x4_t *)(v50 + 16);
      float32x4_t v54 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(void *)&v9 + v20 - 32), vextq_s8(v36, v36, 0xCuLL))));
      float32x4_t v55 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(void *)&v9 + v20 - 16), vextq_s8(v42, v42, 0xCuLL))));
      float32x4_t v56 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(void *)&v9 + v20), vextq_s8(v48, v48, 0xCuLL))));
      float32x4_t v57 = vaddq_f32(v53, vmulq_f32(*(float32x4_t *)v50, (float32x4_t)vbslq_s8(v51, *(int8x16_t *)(*(void *)&v9 + v20 + 16), vextq_s8(v49, v49, 0xCuLL))));
      float32x4_t v19 = vaddq_f32(v19, _Q4);
      float32x4_t v58 = *(float32x4_t *)(v50 + 64);
      float32x4_t v59 = vaddq_f32(vmulq_laneq_f32(v58, v54, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v54.f32, 1)));
      float32x4_t v60 = vaddq_f32(vmulq_laneq_f32(v58, v55, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v55.f32, 1)));
      float32x4_t v61 = vaddq_f32(vmulq_laneq_f32(v58, v56, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v56.f32, 1)));
      v59.i32[3] = 1.0;
      v60.i32[3] = 1.0;
      v61.i32[3] = 1.0;
      float32x4_t v62 = vaddq_f32(vmulq_laneq_f32(v58, v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0), vmulq_lane_f32(v52, *(float32x2_t *)v57.f32, 1)));
      v62.i32[3] = 1.0;
      float32x4_t v63 = (float32x4_t *)(*(void *)&v8 + v20);
      v63[-2] = v59;
      v63[-1] = v60;
      *float32x4_t v63 = v61;
      v63[1] = v62;
      v18 -= 4;
      v20 += 64;
    }
    while (v6 + v18 > 3);
    LODWORD(v64) = -v18;
    if ((int)v64 >= v6) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v64 = v64;
    do
    {
      float32x4_t v65 = vaddq_f32(vsubq_f32(vaddq_f32(v7, vmulq_f32(v19, (float32x4_t)xmmword_1B7E75B20)), v5), v17);
      int32x4_t v66 = vcvtq_s32_f32(v65);
      v65.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v65)).u64[0];
      uint64_t v67 = *((void *)this + 51);
      float32x4_t v68 = vaddq_f32(*(float32x4_t *)(v67 + 16), vmulq_f32(*(float32x4_t *)v67, (float32x4_t)vbslq_s8(*(int8x16_t *)(v67 + 32), *(int8x16_t *)(*(void *)&v9 + 16 * v64), vextq_s8(*(int8x16_t *)(*(void *)&a2[12] + 16 * (v65.i32[0] + v65.i32[1] * a2[13].i32[0])), *(int8x16_t *)(*(void *)&a2[12] + 16 * (v65.i32[0] + v65.i32[1] * a2[13].i32[0])), 0xCuLL))));
      float32x4_t v69 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v67 + 64), v68, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v67 + 48), *(float32x2_t *)v68.f32, 1)));
      v69.i32[3] = 1.0;
      *(float32x4_t *)(*(void *)&v8 + 16 * v64) = v69;
      __asm { FMOV            V16.4S, #1.0 }
      float32x4_t v19 = vaddq_f32(v19, _Q16);
      ++v64;
    }
    while (v64 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::GetDOD(HgcYUV422BiPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  if (!a3) {
    return v5;
  }
  if (a3 == 1)
  {
    uint64_t v6 = HGRectMake4i(0, 0, 1u, 0);
    int v7 = HGRectGrow(v5, v4, v6);
    float v8 = HGRectFloat(v7);
    float v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    uint64_t v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::GetROI(HgcYUV422BiPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result = *(void *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      float v5 = HGRectFloat(a4.var0);
      float v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      uint64_t v16 = v15;
      uint64_t v17 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
      uint64_t v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV422BiPlanar_2020ToRGB::HgcYUV422BiPlanar_2020ToRGB(HgcYUV422BiPlanar_2020ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EA978;
  operator new();
}

void sub_1B78EE5EC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV422BiPlanar_2020ToRGB::~HgcYUV422BiPlanar_2020ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10EA978;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10EA978;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EA978;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::SetParameter(HgcYUV422BiPlanar_2020ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  double v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *double v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV422BiPlanar_2020ToRGB::GetParameter(HgcYUV422BiPlanar_2020ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  float v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV420BiPlanar_2020ToRGB::GetProgram(HgcYUV420BiPlanar_2020ToRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const half4 c1 = half4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5b2c3b8c:71d74731:f5cd4f36:083b9890\n"
             "//SIG=00400000:00000001:00000001:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=76c81ece:94c5249f:ae40b588:a20d303a\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=39ba3a76:86163c26:2e7e27c5:49379347\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_2020ToRGB::InitProgramDescriptor(HgcYUV420BiPlanar_2020ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_2020ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e8\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_2020ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
    "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV420BiPlanar_2020ToRGB");
}

void sub_1B78EECC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78EECFC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78EECF4);
}

char *HgcYUV420BiPlanar_2020ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375DB0;
  strcpy(result, "HgcYUV420BiPlanar_2020ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::BindTexture(HgcYUV420BiPlanar_2020ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2); {
      (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 0.5, 0.5, 1.0);
      }
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v5)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::Bind(HgcYUV420BiPlanar_2020ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::RenderTile(HgcYUV420BiPlanar_2020ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    float32x4_t v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B7E77360);
    int32x2_t v8 = a2[2];
    int32x2_t v9 = a2[10];
    uint64_t v10 = 16 * a2[11].i32[0];
    uint64_t v11 = 16 * a2[3].i32[0];
    float32x4_t v12 = 0uLL;
    __asm { FMOV            V5.4S, #4.0 }
    v18.i64[0] = 0x3F0000003F000000;
    v18.i64[1] = 0x3F0000003F000000;
    while (1)
    {
      float32x4_t v19 = vaddq_f32(v7, vmulq_f32(v12, (float32x4_t)xmmword_1B7E75610));
      if (v6 >= 4) {
        break;
      }
      LODWORD(v66) = 0;
      float32x4_t v21 = 0uLL;
      __asm { FMOV            V18.4S, #1.0 }
      if (v6 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v12 = vaddq_f32(v12, _Q18);
      ++v4;
      *(void *)&v9 += v10;
      *(void *)&v8 += v11;
      if (v4 == v3) {
        return 0;
      }
    }
    int v20 = 0;
    float32x4_t v21 = 0uLL;
    uint64_t v22 = 32;
    do
    {
      float32x4_t v23 = vaddq_f32(v19, vmulq_f32(v21, (float32x4_t)xmmword_1B7E75B20));
      float32x4_t v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B7E75B20);
      int32x2_t v27 = a2[12];
      __int32 v28 = a2[13].i32[0];
      float32x4_t v29 = vaddq_f32(vsubq_f32(v23, v5), v18);
      int32x4_t v30 = vcvtq_s32_f32(v29);
      v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
      __int32 v31 = v29.i32[1];
      __int32 v32 = v29.i32[0];
      float32x4_t v33 = vaddq_f32(vsubq_f32(v24, v5), v18);
      int32x4_t v34 = vcvtq_s32_f32(v33);
      __int32 v35 = v32 + v31 * v28;
      v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      __int32 v36 = v33.i32[1];
      __int32 v37 = v33.i32[0];
      int8x16_t v38 = *(int8x16_t *)(*(void *)&v27 + 16 * v35);
      float32x4_t v39 = vaddq_f32(vsubq_f32(v25, v5), v18);
      int32x4_t v40 = vcvtq_s32_f32(v39);
      __int32 v41 = v37 + v36 * v28;
      v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
      __int32 v42 = v39.i32[1];
      __int32 v43 = v39.i32[0];
      int8x16_t v44 = *(int8x16_t *)(*(void *)&v27 + 16 * v41);
      float32x4_t v45 = vaddq_f32(vsubq_f32(v26, v5), v18);
      int32x4_t v46 = vcvtq_s32_f32(v45);
      __int32 v47 = v43 + v42 * v28;
      v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
      __int32 v48 = v45.i32[1];
      __int32 v49 = v45.i32[0];
      int8x16_t v50 = *(int8x16_t *)(*(void *)&v27 + 16 * v47);
      int8x16_t v51 = *(int8x16_t *)(*(void *)&v27 + 16 * (v49 + v48 * v28));
      uint64_t v52 = *((void *)this + 51);
      int8x16_t v53 = *(int8x16_t *)(v52 + 32);
      float32x4_t v54 = *(float32x4_t *)(v52 + 48);
      float32x4_t v55 = *(float32x4_t *)(v52 + 16);
      float32x4_t v56 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(void *)&v9 + v22 - 32), vextq_s8(v38, v38, 0xCuLL))));
      float32x4_t v57 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(void *)&v9 + v22 - 16), vextq_s8(v44, v44, 0xCuLL))));
      float32x4_t v58 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(void *)&v9 + v22), vextq_s8(v50, v50, 0xCuLL))));
      float32x4_t v59 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(void *)&v9 + v22 + 16), vextq_s8(v51, v51, 0xCuLL))));
      float32x4_t v21 = vaddq_f32(v21, _Q5);
      float32x4_t v60 = *(float32x4_t *)(v52 + 64);
      float32x4_t v61 = vaddq_f32(vmulq_laneq_f32(v60, v56, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v56.f32, 1)));
      float32x4_t v62 = vaddq_f32(vmulq_laneq_f32(v60, v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v57.f32, 1)));
      float32x4_t v63 = vaddq_f32(vmulq_laneq_f32(v60, v58, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v58.f32, 1)));
      v61.i32[3] = 1.0;
      v62.i32[3] = 1.0;
      v63.i32[3] = 1.0;
      float32x4_t v64 = vaddq_f32(vmulq_laneq_f32(v60, v59, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v59.f32, 1)));
      v64.i32[3] = 1.0;
      float32x4_t v65 = (float32x4_t *)(*(void *)&v8 + v22);
      v65[-2] = v61;
      v65[-1] = v62;
      float32x4_t *v65 = v63;
      v65[1] = v64;
      v20 -= 4;
      v22 += 64;
    }
    while (v6 + v20 > 3);
    LODWORD(v66) = -v20;
    __asm { FMOV            V18.4S, #1.0 }
    if ((int)v66 >= v6) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v66 = v66;
    do
    {
      float32x4_t v68 = vaddq_f32(vsubq_f32(vaddq_f32(v19, vmulq_f32(v21, (float32x4_t)xmmword_1B7E75B20)), v5), v18);
      int32x4_t v69 = vcvtq_s32_f32(v68);
      v68.i64[0] = vaddq_s32(v69, vcgtq_f32(vcvtq_f32_s32(v69), v68)).u64[0];
      uint64_t v70 = *((void *)this + 51);
      float32x4_t v71 = vaddq_f32(*(float32x4_t *)(v70 + 16), vmulq_f32(*(float32x4_t *)v70, (float32x4_t)vbslq_s8(*(int8x16_t *)(v70 + 32), *(int8x16_t *)(*(void *)&v9 + 16 * v66), vextq_s8(*(int8x16_t *)(*(void *)&a2[12] + 16 * (v68.i32[0] + v68.i32[1] * a2[13].i32[0])), *(int8x16_t *)(*(void *)&a2[12] + 16 * (v68.i32[0] + v68.i32[1] * a2[13].i32[0])), 0xCuLL))));
      float32x4_t v72 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v70 + 64), v71, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v70 + 48), *(float32x2_t *)v71.f32, 1)));
      v72.i32[3] = 1.0;
      *(float32x4_t *)(*(void *)&v8 + 16 * v66) = v72;
      float32x4_t v21 = vaddq_f32(v21, _Q18);
      ++v66;
    }
    while (v66 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::GetDOD(HgcYUV420BiPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  if (!a3) {
    return v5;
  }
  if (a3 == 1)
  {
    uint64_t v6 = HGRectMake4i(0, 0, 1u, 1u);
    int v7 = HGRectGrow(v5, v4, v6);
    float v8 = HGRectFloat(v7);
    float v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    uint64_t v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::GetROI(HgcYUV420BiPlanar_2020ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result = *(void *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      float v5 = HGRectFloat(a4.var0);
      float v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      uint64_t v16 = v15;
      uint64_t v17 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
      uint64_t v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV420BiPlanar_2020ToRGB::HgcYUV420BiPlanar_2020ToRGB(HgcYUV420BiPlanar_2020ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EABE0;
  operator new();
}

void sub_1B78EF5A8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_2020ToRGB::~HgcYUV420BiPlanar_2020ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10EABE0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10EABE0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EABE0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::SetParameter(HgcYUV420BiPlanar_2020ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  double v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *double v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV420BiPlanar_2020ToRGB::GetParameter(HgcYUV420BiPlanar_2020ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  float v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV444BiPlanar_2020ToRGB::GetProgram(HgcYUV444BiPlanar_2020ToRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const half4 c1 = half4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5b2c3b8c:71d74731:f5cd4f36:083b9890\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
             "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=76c81ece:94c5249f:ae40b588:a20d303a\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=39ba3a76:86163c26:2e7e27c5:49379347\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV444BiPlanar_2020ToRGB::InitProgramDescriptor(HgcYUV444BiPlanar_2020ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444BiPlanar_2020ToRGB_hgc_visible", "//Metal1.0     \n//LEN=000000027f\n[[ visible ]] FragmentOut HgcYUV444BiPlanar_2020ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, -0.1645531207, 1.881399989, 0.000000000);\n"
    "    const float4 c1 = float4(1.474599957, -0.5713531375, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = color1.xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV444BiPlanar_2020ToRGB");
}

void sub_1B78EFB4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78EFB80(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78EFB78);
}

char *HgcYUV444BiPlanar_2020ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375DB0;
  strcpy(result, "HgcYUV444BiPlanar_2020ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::BindTexture(HgcYUV444BiPlanar_2020ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 != 1) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::Bind(HgcYUV444BiPlanar_2020ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::RenderTile(HgcYUV444BiPlanar_2020ToRGB *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = (int8x16_t *)*((void *)a2 + 12);
    int v5 = (int8x16_t *)*((void *)a2 + 10);
    int v6 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v7 = *((int *)a2 + 6);
    uint64_t v8 = *((int *)a2 + 22);
    uint64_t v9 = *((int *)a2 + 26);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v45 = 0;
        uint64_t v46 = 16 * v9;
        uint64_t v47 = 16 * v8;
        uint64_t v48 = 16 * v7;
        uint64_t v49 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v50 = 0;
          do
          {
            uint64_t v51 = *((void *)this + 51);
            float32x4_t v52 = vaddq_f32(*(float32x4_t *)(v51 + 16), vmulq_f32(*(float32x4_t *)v51, (float32x4_t)vbslq_s8(*(int8x16_t *)(v51 + 32), v5[v50 / 0x10], vextq_s8(v4[v50 / 0x10], v4[v50 / 0x10], 0xCuLL))));
            float32x4_t v53 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v51 + 64), v52, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v51 + 48), *(float32x2_t *)v52.f32, 1)));
            v53.i32[3] = 1.0;
            v6[v50 / 0x10] = v53;
            v50 += 16;
          }
          while (v49 != v50);
          ++v45;
          uint64_t v4 = (int8x16_t *)((char *)v4 + v46);
          int v5 = (int8x16_t *)((char *)v5 + v47);
          int v6 = (float32x4_t *)((char *)v6 + v48);
        }
        while (v45 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      uint64_t v14 = v4 + 4;
      uint64_t v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        uint64_t v17 = 0;
        unint64_t v18 = 0;
        uint64_t v19 = v16;
        int v20 = v15;
        float32x4_t v21 = v14;
        do
        {
          uint64_t v22 = *((void *)this + 51);
          int8x16_t v23 = *(int8x16_t *)(v22 + 32);
          float32x4_t v24 = *(float32x4_t *)(v22 + 48);
          float32x4_t v25 = *(float32x4_t *)(v22 + 16);
          float32x4_t v26 = v21;
          float32x4_t v27 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17], vextq_s8(v4[v17], v4[v17], 0xCuLL))));
          float32x4_t v28 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 1], vextq_s8(v4[v17 + 1], v4[v17 + 1], 0xCuLL))));
          float32x4_t v29 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 2], vextq_s8(v4[v17 + 2], v4[v17 + 2], 0xCuLL))));
          float32x4_t v30 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 3], vextq_s8(v4[v17 + 3], v4[v17 + 3], 0xCuLL))));
          float32x4_t v31 = *(float32x4_t *)(v22 + 64);
          float32x4_t v32 = vaddq_f32(vmulq_laneq_f32(v31, v27, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v27.f32, 1)));
          float32x4_t v33 = vaddq_f32(vmulq_laneq_f32(v31, v28, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v28.f32, 1)));
          float32x4_t v34 = vaddq_f32(vmulq_laneq_f32(v31, v29, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v29.f32, 1)));
          v32.i32[3] = 1.0;
          v33.i32[3] = 1.0;
          float32x4_t v35 = vaddq_f32(vmulq_laneq_f32(v31, v30, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v30.f32, 1)));
          v34.i32[3] = 1.0;
          v35.i32[3] = 1.0;
          __int32 v36 = v20;
          __int32 v37 = v19;
          int8x16_t v38 = &v6[v17];
          v18 += 4;
          v17 += 4;
          *int8x16_t v38 = v32;
          v38[1] = v33;
          v38[2] = v34;
          v38[3] = v35;
          v21 += 4;
          int v20 = v36 + 4;
          v19 += 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            int8x16_t v39 = *v26++;
            int8x16_t v40 = vextq_s8(v39, v39, 0xCuLL);
            int8x16_t v41 = *v36++;
            uint64_t v42 = *((void *)this + 51);
            float32x4_t v43 = vaddq_f32(*(float32x4_t *)(v42 + 16), vmulq_f32(*(float32x4_t *)v42, (float32x4_t)vbslq_s8(*(int8x16_t *)(v42 + 32), v41, v40)));
            float32x4_t v44 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v42 + 64), v43, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v42 + 48), *(float32x2_t *)v43.f32, 1)));
            v44.i32[3] = 1.0;
            *v37++ = v44;
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        int v5 = (int8x16_t *)((char *)v5 + v11);
        int v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (int8x16_t *)((char *)v4 + v13);
        uint64_t v14 = (int8x16_t *)((char *)v14 + v13);
        uint64_t v15 = (int8x16_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::GetDOD(HgcYUV444BiPlanar_2020ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::GetROI(HgcYUV444BiPlanar_2020ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcYUV444BiPlanar_2020ToRGB::HgcYUV444BiPlanar_2020ToRGB(HgcYUV444BiPlanar_2020ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EAE48;
  operator new();
}

void sub_1B78F01A4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444BiPlanar_2020ToRGB::~HgcYUV444BiPlanar_2020ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10EAE48;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10EAE48;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EAE48;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::SetParameter(HgcYUV444BiPlanar_2020ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  int v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV444BiPlanar_2020ToRGB::GetParameter(HgcYUV444BiPlanar_2020ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

uint64_t HgcDither_CPU_NoClamp::RenderTile(HgcDither_CPU_NoClamp *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 12);
    int v6 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v7 = *((int *)a2 + 6);
    uint64_t v8 = *((int *)a2 + 26);
    uint64_t v9 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v33 = 0;
        uint64_t v34 = 16 * v9;
        uint64_t v35 = 16 * v8;
        uint64_t v36 = 16 * v7;
        uint64_t v37 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v38 = 0;
          do
          {
            v6[v38 / 0x10] = vaddq_f32(v4[v38 / 0x10], vmulq_f32(v5[v38 / 0x10], *(float32x4_t *)*((void *)this + 51)));
            v38 += 16;
          }
          while (v37 != v38);
          ++v33;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v34);
          int v5 = (float32x4_t *)((char *)v5 + v35);
          int v6 = (float32x4_t *)((char *)v6 + v36);
        }
        while (v33 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      uint64_t v14 = v4 + 4;
      uint64_t v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        unint64_t v17 = 0;
        unint64_t v18 = 0;
        uint64_t v19 = v16;
        int v20 = v15;
        float32x4_t v21 = v14;
        do
        {
          uint64_t v22 = v21;
          int8x16_t v23 = v20;
          float32x4_t v24 = v19;
          float32x4_t v25 = *(float32x4_t *)*((void *)this + 51);
          float32x4_t v26 = vaddq_f32(v4[v17 + 1], vmulq_f32(v5[v17 + 1], v25));
          float32x4_t v27 = vaddq_f32(v4[v17 + 2], vmulq_f32(v5[v17 + 2], v25));
          float32x4_t v28 = vaddq_f32(v4[v17 + 3], vmulq_f32(v5[v17 + 3], v25));
          float32x4_t v29 = &v6[v17];
          *float32x4_t v29 = vaddq_f32(v4[v17], vmulq_f32(v5[v17], v25));
          v29[1] = v26;
          v18 += 4;
          v17 += 4;
          v29[2] = v27;
          v29[3] = v28;
          v21 += 4;
          v20 += 4;
          uint64_t v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            float32x4_t v30 = *v22++;
            float32x4_t v31 = v30;
            float32x4_t v32 = *v23++;
            *v24++ = vaddq_f32(v31, vmulq_f32(v32, *(float32x4_t *)*((void *)this + 51)));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        int v5 = (float32x4_t *)((char *)v5 + v11);
        int v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v13);
        uint64_t v14 = (float32x4_t *)((char *)v14 + v13);
        uint64_t v15 = (float32x4_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcDither_CPU_NoClamp::GetDOD(HgcDither_CPU_NoClamp *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcDither_CPU_NoClamp::GetROI(HgcDither_CPU_NoClamp *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcDither_CPU_NoClamp::HgcDither_CPU_NoClamp(HgcDither_CPU_NoClamp *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EB0B0;
  operator new();
}

void sub_1B78F063C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcDither_CPU_NoClamp::~HgcDither_CPU_NoClamp(HGNode *this)
{
  *(void *)this = &unk_1F10EB0B0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EB0B0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcDither_CPU_NoClamp::SetParameter(HgcDither_CPU_NoClamp *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcDither_CPU_NoClamp::GetParameter(HgcDither_CPU_NoClamp *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcDither_CPU::RenderTile(HgcDither_CPU *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 12);
    int v6 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v7 = *((int *)a2 + 6);
    uint64_t v8 = *((int *)a2 + 26);
    uint64_t v9 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v35 = 0;
        uint64_t v36 = 16 * v9;
        uint64_t v37 = 16 * v8;
        uint64_t v38 = 16 * v7;
        uint64_t v39 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v40 = 0;
          do
          {
            v6[v40 / 0x10] = vminq_f32(vmaxq_f32(vaddq_f32(v4[v40 / 0x10], vmulq_f32(v5[v40 / 0x10], *(float32x4_t *)*((void *)this + 51))), *(float32x4_t *)(*((void *)this + 51) + 16)), *(float32x4_t *)(*((void *)this + 51) + 32));
            v40 += 16;
          }
          while (v39 != v40);
          ++v35;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v36);
          int v5 = (float32x4_t *)((char *)v5 + v37);
          int v6 = (float32x4_t *)((char *)v6 + v38);
        }
        while (v35 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      uint64_t v14 = v4 + 4;
      uint64_t v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        unint64_t v17 = 0;
        unint64_t v18 = 0;
        uint64_t v19 = v16;
        int v20 = v15;
        float32x4_t v21 = v14;
        do
        {
          uint64_t v22 = v21;
          int8x16_t v23 = v20;
          float32x4_t v24 = v19;
          float32x4_t v25 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v26 = v25[1];
          float32x4_t v27 = v25[2];
          float32x4_t v28 = vminq_f32(vmaxq_f32(vaddq_f32(v4[v17 + 1], vmulq_f32(v5[v17 + 1], *v25)), v26), v27);
          float32x4_t v29 = vminq_f32(vmaxq_f32(vaddq_f32(v4[v17 + 2], vmulq_f32(v5[v17 + 2], *v25)), v26), v27);
          float32x4_t v30 = vminq_f32(vmaxq_f32(vaddq_f32(v4[v17 + 3], vmulq_f32(v5[v17 + 3], *v25)), v26), v27);
          float32x4_t v31 = &v6[v17];
          *float32x4_t v31 = vminq_f32(vmaxq_f32(vaddq_f32(v4[v17], vmulq_f32(v5[v17], *v25)), v26), v27);
          v31[1] = v28;
          v18 += 4;
          v17 += 4;
          v31[2] = v29;
          v31[3] = v30;
          v21 += 4;
          int v20 = v23 + 4;
          uint64_t v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            float32x4_t v32 = *v22++;
            float32x4_t v33 = v32;
            float32x4_t v34 = *v23++;
            *v24++ = vminq_f32(vmaxq_f32(vaddq_f32(v33, vmulq_f32(v34, *(float32x4_t *)*((void *)this + 51))), *(float32x4_t *)(*((void *)this + 51) + 16)), *(float32x4_t *)(*((void *)this + 51) + 32));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        int v5 = (float32x4_t *)((char *)v5 + v11);
        int v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v13);
        uint64_t v14 = (float32x4_t *)((char *)v14 + v13);
        uint64_t v15 = (float32x4_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcDither_CPU::GetDOD(HgcDither_CPU *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcDither_CPU::GetROI(HgcDither_CPU *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcDither_CPU::HgcDither_CPU(HgcDither_CPU *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EB318;
  operator new();
}

void sub_1B78F09E8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcDither_CPU::~HgcDither_CPU(HGNode *this)
{
  *(void *)this = &unk_1F10EB318;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40EED21634);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EB318;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40EED21634);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcDither_CPU::SetParameter(HgcDither_CPU *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcDither_CPU::GetParameter(HgcDither_CPU *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcDither_GPU_NoClamp::GetProgram(HgcDither_GPU_NoClamp *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003f2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = hg_Params[1].xy;\n"
             "    s0.xy = frag._texCoord1.xy - s0.xy*floor(frag._texCoord1.xy/s0.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, s0.xy);\n"
             "    output.color0 = float4(r1)*float4(c0.xxxw) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fecfdea2:4af1a003:559b7893:a59f823d\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0002:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003c0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Params[1].xy;\n"
             "    r0.xy = frag._texCoord1.xy - r0.xy*floor(frag._texCoord1.xy/r0.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xy = r0.xy + hg_Params[0].xy;\n"
             "    r0.xy = r0.xy*hg_Params[0].zw;\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, r0.xy);\n"
             "    output.color0 = r0*c0.xxxw + r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6b1be8b7:ff006c96:12e0fa22:9998b3f1\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000377\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = hg_ProgramLocal1.xy;\n"
           "    r0.xy = mod(hg_TexCoord1.xy, r0.xy);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal0.zw;\n"
           "    r0 = texture2D(hg_Texture1, r0.xy);\n"
           "    gl_FragColor = r0*c0.xxxw + r1;\n"
           "}\n"
           "//MD5=93fb8dbc:091fea70:eb857dc2:db227491\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcDither_GPU_NoClamp::InitProgramDescriptor(HgcDither_GPU_NoClamp *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcDither_GPU_NoClamp_hgc_visible", "//Metal1.0     \n//LEN=0000000287\n[[ visible ]] FragmentOut HgcDither_GPU_NoClamp_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Params[1].xy;\n"
    "    r0.xy = texCoord1.xy - r0.xy*floor(texCoord1.xy/r0.xy);\n"
    "    r1 = color0;\n"
    "    r0.xy = r0.xy + hg_Params[0].xy;\n"
    "    r0.xy = r0.xy*hg_Params[0].zw;\n"
    "    r0 = hg_Texture1.sample(hg_Sampler1, r0.xy);\n"
    "    output.color0 = r0*c0.xxxw + r1;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcDither_GPU_NoClamp");
}

void sub_1B78F0F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78F0FC4(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78F0FBCLL);
}

double HgcDither_GPU_NoClamp::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376120;
  strcpy(v3, "HgcDither_GPU_NoClamp [hgc1]");
  return *(double *)"U_NoClamp [hgc1]";
}

uint64_t HgcDither_GPU_NoClamp::BindTexture(HgcDither_GPU_NoClamp *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
      {
        v6.n128_u32[0] = 1.0;
        v7.n128_u32[0] = 1.0;
      }
      else
      {
        v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
        v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
      }
      v4.n128_f32[0] = (float)*((int *)a2 + 60);
      v5.n128_f32[0] = (float)*((int *)a2 + 61);
      (*(void (**)(HGHandler *, void, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 0, v4, v5, v6, v7);
      (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 1, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), (float)*((int *)a2 + 47), (float)*((int *)a2 + 48));
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v8 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v8)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcDither_GPU_NoClamp::Bind(HgcDither_GPU_NoClamp *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcDither_GPU_NoClamp::GetDOD(HgcDither_GPU_NoClamp *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (!a3) {
    return *(void *)&a4.var0;
  }
  if (a3 == 1) {
    return 0x8000000080000000;
  }
  return 0;
}

uint64_t HgcDither_GPU_NoClamp::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
  {
    if (a3 == 1)
    {
      Input = HGRenderer::GetInput(a2, this, 1u);
      *(void *)&a4.var0 = HGRenderer::GetDOD(a2, Input);
    }
    else
    {
      *(void *)&a4.var0 = 0;
    }
  }
  return *(void *)&a4.var0;
}

void HgcDither_GPU_NoClamp::HgcDither_GPU_NoClamp(HgcDither_GPU_NoClamp *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EB580;
  operator new();
}

void sub_1B78F1464(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcDither_GPU_NoClamp::~HgcDither_GPU_NoClamp(HGNode *this)
{
  *(void *)this = &unk_1F10EB580;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0xC400A2AC0F1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EB580;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0xC400A2AC0F1);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcDither_GPU_NoClamp::SetParameter(HgcDither_GPU_NoClamp *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcDither_GPU_NoClamp::GetParameter(HgcDither_GPU_NoClamp *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcDither_GPU::GetProgram(HgcDither_GPU *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000040d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = hg_Params[1].xy;\n"
             "    s0.xy = frag._texCoord1.xy - s0.xy*floor(frag._texCoord1.xy/s0.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, s0.xy);\n"
             "    output.color0 = clamp(float4(r1)*float4(c0.xxxw) + float4(r0), 0.00000f, 1.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=73956a5f:71c66c21:a7e6c42e:944d9b9b\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0002:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003db\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Params[1].xy;\n"
             "    r0.xy = frag._texCoord1.xy - r0.xy*floor(frag._texCoord1.xy/r0.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xy = r0.xy + hg_Params[0].xy;\n"
             "    r0.xy = r0.xy*hg_Params[0].zw;\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, r0.xy);\n"
             "    output.color0 = clamp(r0*c0.xxxw + r1, 0.00000f, 1.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b0267f22:5a359f19:1b29b0a6:fbd2585f\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000039c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = hg_ProgramLocal1.xy;\n"
           "    r0.xy = mod(hg_TexCoord1.xy, r0.xy);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal0.zw;\n"
           "    r0 = texture2D(hg_Texture1, r0.xy);\n"
           "    gl_FragColor = clamp(r0*c0.xxxw + r1, vec4(0.00000), vec4(1.00000));\n"
           "}\n"
           "//MD5=09402855:043f81c6:ab992516:1920d05e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcDither_GPU::InitProgramDescriptor(HgcDither_GPU *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcDither_GPU_hgc_visible", "//Metal1.0     \n//LEN=000000029a\n[[ visible ]] FragmentOut HgcDither_GPU_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.003921568394, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Params[1].xy;\n"
    "    r0.xy = texCoord1.xy - r0.xy*floor(texCoord1.xy/r0.xy);\n"
    "    r1 = color0;\n"
    "    r0.xy = r0.xy + hg_Params[0].xy;\n"
    "    r0.xy = r0.xy*hg_Params[0].zw;\n"
    "    r0 = hg_Texture1.sample(hg_Sampler1, r0.xy);\n"
    "    output.color0 = clamp(r0*c0.xxxw + r1, 0.00000f, 1.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcDither_GPU");
}

void sub_1B78F19FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78F1A38(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78F1A30);
}

void HgcDither_GPU::shaderDescription(char *a1@<X8>)
{
  a1[23] = 20;
  strcpy(a1, "HgcDither_GPU [hgc1]");
}

uint64_t HgcDither_GPU::BindTexture(HgcDither_GPU *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
      {
        v6.n128_u32[0] = 1.0;
        v7.n128_u32[0] = 1.0;
      }
      else
      {
        v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
        v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
      }
      v4.n128_f32[0] = (float)*((int *)a2 + 60);
      v5.n128_f32[0] = (float)*((int *)a2 + 61);
      (*(void (**)(HGHandler *, void, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 0, v4, v5, v6, v7);
      (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 1, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), (float)*((int *)a2 + 47), (float)*((int *)a2 + 48));
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v8 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v8)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcDither_GPU::Bind(HgcDither_GPU *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcDither_GPU::GetDOD(HgcDither_GPU *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (!a3) {
    return *(void *)&a4.var0;
  }
  if (a3 == 1) {
    return 0x8000000080000000;
  }
  return 0;
}

uint64_t HgcDither_GPU::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
  {
    if (a3 == 1)
    {
      Input = HGRenderer::GetInput(a2, this, 1u);
      *(void *)&a4.var0 = HGRenderer::GetDOD(a2, Input);
    }
    else
    {
      *(void *)&a4.var0 = 0;
    }
  }
  return *(void *)&a4.var0;
}

void HgcDither_GPU::HgcDither_GPU(HgcDither_GPU *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EB7E8;
  operator new();
}

void sub_1B78F1EB0(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcDither_GPU::~HgcDither_GPU(HGNode *this)
{
  *(void *)this = &unk_1F10EB7E8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0xC400A2AC0F1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EB7E8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0xC400A2AC0F1);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcDither_GPU::SetParameter(HgcDither_GPU *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcDither_GPU::GetParameter(HgcDither_GPU *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcGradientLinearTranslate::GetProgram(HgcGradientLinearTranslate *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004ae\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(half4(hg_Params[3]), half4(frag._texCoord0));\n"
             "    r0.y = dot(half4(hg_Params[4]), half4(frag._texCoord0));\n"
             "    s0.xyz = float3(r0.xyz) - hg_Params[0].xyz;\n"
             "    s0.x = dot(hg_Params[1].xyz, s0.xyz);\n"
             "    s0.x = s0.x*hg_Params[2].x;\n"
             "    s0.x = clamp(s0.x*hg_Params[5].x + hg_Params[5].y, 0.00000f, 1.00000f);\n"
             "    s0.y = float(c0.x);\n"
             "    s0.xy = s0.xy*hg_Params[6].xy;\n"
             "    s0.xy = fmax(s0.xy, float2(c0.xx));\n"
             "    s1.xy = hg_Params[6].xy - float2(c0.xx);\n"
             "    s0.xy = fmin(s0.xy, s1.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    r1 = r0;\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    output.color0 = float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=46452133:57680ffc:173d5a39:c04c88c5\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0007:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000447\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(hg_Params[3], frag._texCoord0);\n"
             "    r0.y = dot(hg_Params[4], frag._texCoord0);\n"
             "    r0.xyz = r0.xyz - hg_Params[0].xyz;\n"
             "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
             "    r0.x = r0.x*hg_Params[2].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[5].x + hg_Params[5].y, 0.00000f, 1.00000f);\n"
             "    r0.y = c0.x;\n"
             "    r0.xy = r0.xy*hg_Params[6].xy;\n"
             "    r0.xy = fmax(r0.xy, c0.xx);\n"
             "    r1.xy = hg_Params[6].xy - c0.xx;\n"
             "    r0.xy = fmin(r0.xy, r1.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=3e663d75:e0a55e8b:34c412a8:0286977f\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0007:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004a5\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.z = c0.z;\n"
           "    r0.x = dot(hg_ProgramLocal3, hg_TexCoord0);\n"
           "    r0.y = dot(hg_ProgramLocal4, hg_TexCoord0);\n"
           "    r0.xyz = r0.xyz - hg_ProgramLocal0.xyz;\n"
           "    r0.x = dot(hg_ProgramLocal1.xyz, r0.xyz);\n"
           "    r0.x = r0.x*hg_ProgramLocal2.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal5.x + hg_ProgramLocal5.y, 0.00000, 1.00000);\n"
           "    r0.y = c0.x;\n"
           "    r0.xy = hg_ProgramLocal6.xy*c0.zz + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=b8811881:1a7c8d4d:3ce9ee81:ce3624a3\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0007:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientLinearTranslate::InitProgramDescriptor(HgcGradientLinearTranslate *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientLinearTranslate_hgc_visible", "//Metal1.0     \n//LEN=000000038e\n[[ visible ]] FragmentOut HgcGradientLinearTranslate_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = c0.z;\n"
    "    r0.x = dot(hg_Params[3], texCoord0);\n"
    "    r0.y = dot(hg_Params[4], texCoord0);\n"
    "    r0.xyz = r0.xyz - hg_Params[0].xyz;\n"
    "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
    "    r0.x = r0.x*hg_Params[2].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[5].x + hg_Params[5].y, 0.00000f, 1.00000f);\n"
    "    r0.y = c0.x;\n"
    "    r0.xy = r0.xy*hg_Params[6].xy;\n"
    "    r0.xy = fmax(r0.xy, c0.xx);\n"
    "    r1.xy = hg_Params[6].xy - c0.xx;\n"
    "    r0.xy = fmin(r0.xy, r1.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcGradientLinearTranslate");
}

void sub_1B78F23B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78F23E8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78F23E0);
}

char *HgcGradientLinearTranslate::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376030;
  strcpy(result, "HgcGradientLinearTranslate [hgc1]");
  return result;
}

uint64_t HgcGradientLinearTranslate::BindTexture(HgcGradientLinearTranslate *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)a2 + 136))(a2, 6, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientLinearTranslate::Bind(HgcGradientLinearTranslate *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcGradientLinearTranslate::RenderTile(HgcGradientLinearTranslate *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    int v5 = a2[1].i32[0] - v2.i32[0];
    float32x2_t v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    int32x2_t v7 = a2[2];
    *(float32x2_t *)v8.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v8.i64[1] = 0x3F80000000000000;
    __asm { FMOV            V4.2S, #-1.0 }
    float32x2_t v14 = vadd_f32(v6, _D4);
    float32x2_t v15 = vadd_f32(v14, _D4);
    uint64_t v16 = (int8x16_t *)(*(void *)&v7 + 32);
    uint64_t v17 = 16 * a2[3].i32[0];
    while (v5 < 4)
    {
      LODWORD(v82) = 0;
      float32x4_t v20 = v8;
      if (v5 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v8 = vaddq_f32(v8, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      uint64_t v16 = (int8x16_t *)((char *)v16 + v17);
      *(void *)&v7 += v17;
      if (v4 == v3) {
        return 0;
      }
    }
    int v18 = 0;
    uint64_t v19 = v16;
    float32x4_t v20 = v8;
    do
    {
      float32x4_t v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v23 = vaddq_f32(v22, (float32x4_t)xmmword_1B7E736B0);
      uint64_t v24 = *((void *)this + 51);
      float32x4_t v26 = *(float32x4_t *)(v24 + 32);
      float32x4_t v25 = *(float32x4_t *)(v24 + 48);
      float32x4_t v27 = vmulq_f32(v20, v25);
      float32x4_t v28 = vmulq_f32(v21, v25);
      float32x4_t v29 = vmulq_f32(v22, v25);
      float32x4_t v30 = vmulq_f32(v23, v25);
      int8x16_t v31 = (int8x16_t)vaddq_f32(v27, (float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL));
      int8x16_t v32 = (int8x16_t)vaddq_f32(v28, (float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 4uLL));
      int8x16_t v33 = (int8x16_t)vaddq_f32(v29, (float32x4_t)vextq_s8((int8x16_t)v29, (int8x16_t)v29, 4uLL));
      int8x16_t v34 = (int8x16_t)vaddq_f32(v30, (float32x4_t)vextq_s8((int8x16_t)v30, (int8x16_t)v30, 4uLL));
      *(float32x2_t *)v31.i8 = vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
      float32x4_t v35 = *(float32x4_t *)(v24 + 64);
      float32x4_t v36 = *(float32x4_t *)(v24 + 80);
      float32x4_t v37 = vmulq_f32(v20, v35);
      float32x4_t v38 = vmulq_f32(v21, v35);
      *(float32x2_t *)v32.i8 = vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
      float32x4_t v39 = vmulq_f32(v22, v35);
      float32x4_t v40 = vmulq_f32(v23, v35);
      *(float32x2_t *)v33.i8 = vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
      float32x4_t v41 = vaddq_f32(v37, (float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 4uLL));
      float32x4_t v42 = vaddq_f32(v38, (float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 4uLL));
      float32x4_t v43 = vaddq_f32(v39, (float32x4_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 4uLL));
      float32x4_t v44 = vaddq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)v40, (int8x16_t)v40, 4uLL));
      *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
      int8x16_t v45 = *(int8x16_t *)(v24 + 96);
      float32x4_t v46 = *(float32x4_t *)(v24 + 112);
      float32x4_t v47 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v42, (float32x4_t)vextq_s8((int8x16_t)v42, (int8x16_t)v42, 8uLL)), v32);
      float32x4_t v48 = *(float32x4_t *)(v24 + 16);
      float32x4_t v49 = vmulq_f32(v48, vsubq_f32((float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v41, (float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v41, 8uLL)), v31), *(float32x4_t *)v24));
      float32x4_t v50 = vmulq_f32(v48, vsubq_f32(v47, *(float32x4_t *)v24));
      float32x4_t v51 = vmulq_f32(v48, vsubq_f32((float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v43, (float32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v43, 8uLL)), v33), *(float32x4_t *)v24));
      float32x4_t v52 = vmulq_f32(v48, vsubq_f32((float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v44, (float32x4_t)vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL)), v34), *(float32x4_t *)v24));
      float32x4_t v53 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL), vaddq_f32(v49, (float32x4_t)vrev64q_s32((int32x4_t)v49))));
      float32x4_t v54 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v50, (int8x16_t)v50, 8uLL), vaddq_f32(v50, (float32x4_t)vrev64q_s32((int32x4_t)v50))));
      float32x4_t v55 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v51, (int8x16_t)v51, 8uLL), vaddq_f32(v51, (float32x4_t)vrev64q_s32((int32x4_t)v51))));
      float32x4_t v56 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v52, (int8x16_t)v52, 8uLL), vaddq_f32(v52, (float32x4_t)vrev64q_s32((int32x4_t)v52))));
      float32x4_t v57 = (float32x4_t)vrev64q_s32((int32x4_t)v36);
      float32x4_t v58 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v53)), v46);
      float32x4_t v59 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v54)), v46);
      float32x4_t v60 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v55)), v46);
      float32x4_t v61 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v56)), v46);
      float32x4_t v62 = *(float32x4_t *)(v24 + 128);
      int8x16_t v63 = *(int8x16_t *)(v24 + 144);
      v58.i32[0] = vminq_f32(v58, v62).u32[0];
      v59.i32[0] = vminq_f32(v59, v62).u32[0];
      v60.i32[0] = vminq_f32(v60, v62).u32[0];
      v61.i32[0] = vminq_f32(v61, v62).u32[0];
      v58.i32[1] = 0.5;
      v59.i32[1] = 0.5;
      v60.i32[1] = 0.5;
      v61.i32[1] = 0.5;
      int32x2_t v64 = a2[10];
      uint64_t v65 = a2[11].i32[0];
      *(float32x2_t *)v58.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v58.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v62.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v58.f32, v15));
      int v66 = v65 + 1;
      *(float32x2_t *)v59.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v59.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v33.i8 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v59.f32, v15));
      *(float32x2_t *)v58.f32 = vsub_f32(*(float32x2_t *)v58.f32, vcvt_f32_s32(*(int32x2_t *)v62.f32));
      *(float32x2_t *)v59.f32 = vsub_f32(*(float32x2_t *)v59.f32, vcvt_f32_s32(*(int32x2_t *)v33.i8));
      *(int32x2_t *)v44.f32 = vdup_n_s32(v65);
      *(int32x2_t *)v62.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v62.f32, *(int32x2_t *)v33.i8), vzip2_s32(*(int32x2_t *)v62.f32, *(int32x2_t *)v33.i8), *(int32x2_t *)v44.f32);
      uint64_t v67 = (float32x4_t *)(*(void *)&v64 + 16 * v62.i32[0]);
      v65 *= 16;
      uint64_t v68 = v66;
      int32x4_t v69 = (float32x4_t *)(*(void *)&v64 + 16 * v62.i32[1]);
      float32x4_t v70 = vaddq_f32(*v67, vmulq_n_f32(vsubq_f32(v67[1], *v67), v58.f32[0]));
      *(float32x2_t *)v60.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v60.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v71 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v60.f32, v15));
      *(float32x2_t *)v60.f32 = vsub_f32(*(float32x2_t *)v60.f32, vcvt_f32_s32(v71));
      *(float32x2_t *)v61.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v61.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      float32x4_t v72 = vaddq_f32(*v69, vmulq_n_f32(vsubq_f32(v69[1], *v69), v59.f32[0]));
      *(int32x2_t *)v46.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v61.f32, v15));
      *(float32x2_t *)v61.f32 = vsub_f32(*(float32x2_t *)v61.f32, vcvt_f32_s32(*(int32x2_t *)v46.f32));
      *(int32x2_t *)v46.f32 = vmla_s32(vzip1_s32(v71, *(int32x2_t *)v46.f32), vzip2_s32(v71, *(int32x2_t *)v46.f32), *(int32x2_t *)v44.f32);
      float32x4_t v73 = vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v67 + v65), vmulq_n_f32(vsubq_f32(v67[v68], *(float32x4_t *)((char *)v67 + v65)), v58.f32[0])), v70), *(float32x2_t *)v58.f32, 1);
      v74 = (float32x4_t *)(*(void *)&v64 + 16 * v46.i32[0]);
      float32x4_t v75 = vaddq_f32(v70, v73);
      float32x4_t v76 = vaddq_f32(*v74, vmulq_n_f32(vsubq_f32(v74[1], *v74), v60.f32[0]));
      v77 = (float32x4_t *)(*(void *)&v64 + 16 * v46.i32[1]);
      float32x4_t v78 = vaddq_f32(*v77, vmulq_n_f32(vsubq_f32(v77[1], *v77), v61.f32[0]));
      float32x4_t v79 = vaddq_f32(v72, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v69 + v65), vmulq_n_f32(vsubq_f32(v69[v68], *(float32x4_t *)((char *)v69 + v65)), v59.f32[0])), v72), *(float32x2_t *)v59.f32, 1));
      float32x4_t v80 = vaddq_f32(v76, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v74 + v65), vmulq_n_f32(vsubq_f32(v74[v68], *(float32x4_t *)((char *)v74 + v65)), v60.f32[0])), v76), *(float32x2_t *)v60.f32, 1));
      float32x4_t v81 = vaddq_f32(v78, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v77 + v65), vmulq_n_f32(vsubq_f32(v77[v68], *(float32x4_t *)((char *)v77 + v65)), v61.f32[0])), v78), *(float32x2_t *)v61.f32, 1));
      v19[-2] = vbslq_s8(v63, (int8x16_t)v75, (int8x16_t)vmulq_laneq_f32(v75, v75, 3));
      v19[-1] = vbslq_s8(v63, (int8x16_t)v79, (int8x16_t)vmulq_laneq_f32(v79, v79, 3));
      *uint64_t v19 = vbslq_s8(v63, (int8x16_t)v80, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      v19[1] = vbslq_s8(v63, (int8x16_t)v81, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v19 += 4;
      float32x4_t v20 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E736B0);
      v18 -= 4;
    }
    while (v5 + v18 > 3);
    LODWORD(v82) = -v18;
    if ((int)v82 >= v5) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v82 = v82;
    do
    {
      uint64_t v83 = *((void *)this + 51);
      float32x4_t v84 = vmulq_f32(v20, *(float32x4_t *)(v83 + 48));
      int8x16_t v85 = (int8x16_t)vaddq_f32(v84, (float32x4_t)vextq_s8((int8x16_t)v84, (int8x16_t)v84, 4uLL));
      float32x4_t v86 = vmulq_f32(v20, *(float32x4_t *)(v83 + 64));
      float32x4_t v87 = vaddq_f32(v86, (float32x4_t)vextq_s8((int8x16_t)v86, (int8x16_t)v86, 4uLL));
      *(float32x2_t *)v85.i8 = vadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL));
      float32x4_t v88 = vmulq_f32(*(float32x4_t *)(v83 + 16), vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v83 + 96), (int8x16_t)vaddq_f32(v87, (float32x4_t)vextq_s8((int8x16_t)v87, (int8x16_t)v87, 8uLL)), v85), *(float32x4_t *)v83));
      int8x16_t v89 = *(int8x16_t *)(v83 + 144);
      v88.i32[0] = vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(*(int32x4_t *)(v83 + 80)), vmulq_f32(*(float32x4_t *)(v83 + 80), vmulq_f32(*(float32x4_t *)(v83 + 32), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v88, (int8x16_t)v88, 8uLL), vaddq_f32(v88, (float32x4_t)vrev64q_s32((int32x4_t)v88)))))), *(float32x4_t *)(v83 + 112)), *(float32x4_t *)(v83 + 128)).u32[0];
      v88.i32[1] = 0.5;
      *(float32x2_t *)v88.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v88.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v90 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v88.f32, v15));
      uint64_t v91 = a2[11].i32[0];
      *(float32x2_t *)v88.f32 = vsub_f32(*(float32x2_t *)v88.f32, vcvt_f32_s32(v90));
      v92 = (float32x4_t *)(*(void *)&a2[10] + 16 * (v90.i32[0] + v90.i32[1] * (int)v91));
      float32x4_t v93 = vaddq_f32(*v92, vmulq_n_f32(vsubq_f32(v92[1], *v92), v88.f32[0]));
      float32x4_t v94 = vaddq_f32(v93, vmulq_lane_f32(vsubq_f32(vaddq_f32(v92[v91], vmulq_n_f32(vsubq_f32(v92[(int)v91 + 1], v92[v91]), v88.f32[0])), v93), *(float32x2_t *)v88.f32, 1));
      *(int8x16_t *)(*(void *)&v7 + 16 * v82) = vbslq_s8(v89, (int8x16_t)v94, (int8x16_t)vmulq_laneq_f32(v94, v94, 3));
      float32x4_t v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      ++v82;
    }
    while (v82 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientLinearTranslate::GetDOD(HgcGradientLinearTranslate *this, HGRenderer *a2, int a3, HGRect a4)
{
  int v4 = &HGRectInfinite;
  if (a3) {
    int v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcGradientLinearTranslate::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientLinearTranslate::HgcGradientLinearTranslate(HgcGradientLinearTranslate *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EBA50;
  operator new();
}

void sub_1B78F2DCC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientLinearTranslate::~HgcGradientLinearTranslate(HGNode *this)
{
  *(void *)this = &unk_1F10EBA50;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B8406A4ELL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EBA50;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B8406A4ELL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcGradientLinearTranslate::SetParameter(HgcGradientLinearTranslate *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  float32x4_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *float32x4_t v8 = a3;
  int v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientLinearTranslate::GetParameter(HgcGradientLinearTranslate *this, unsigned int a2, float *a3)
{
  if (a2 > 5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientLinearAffine::GetProgram(HgcGradientLinearAffine *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004ae\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(half4(hg_Params[3]), half4(frag._texCoord0));\n"
             "    r0.y = dot(half4(hg_Params[4]), half4(frag._texCoord0));\n"
             "    s0.xyz = float3(r0.xyz) - hg_Params[0].xyz;\n"
             "    s0.x = dot(hg_Params[1].xyz, s0.xyz);\n"
             "    s0.x = s0.x*hg_Params[2].x;\n"
             "    s0.x = clamp(s0.x*hg_Params[5].x + hg_Params[5].y, 0.00000f, 1.00000f);\n"
             "    s0.y = float(c0.x);\n"
             "    s0.xy = s0.xy*hg_Params[6].xy;\n"
             "    s0.xy = fmax(s0.xy, float2(c0.xx));\n"
             "    s1.xy = hg_Params[6].xy - float2(c0.xx);\n"
             "    s0.xy = fmin(s0.xy, s1.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    r1 = r0;\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    output.color0 = float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=46452133:57680ffc:173d5a39:c04c88c5\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0007:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000447\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(hg_Params[3], frag._texCoord0);\n"
             "    r0.y = dot(hg_Params[4], frag._texCoord0);\n"
             "    r0.xyz = r0.xyz - hg_Params[0].xyz;\n"
             "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
             "    r0.x = r0.x*hg_Params[2].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[5].x + hg_Params[5].y, 0.00000f, 1.00000f);\n"
             "    r0.y = c0.x;\n"
             "    r0.xy = r0.xy*hg_Params[6].xy;\n"
             "    r0.xy = fmax(r0.xy, c0.xx);\n"
             "    r1.xy = hg_Params[6].xy - c0.xx;\n"
             "    r0.xy = fmin(r0.xy, r1.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=3e663d75:e0a55e8b:34c412a8:0286977f\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0007:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004a5\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.z = c0.z;\n"
           "    r0.x = dot(hg_ProgramLocal3, hg_TexCoord0);\n"
           "    r0.y = dot(hg_ProgramLocal4, hg_TexCoord0);\n"
           "    r0.xyz = r0.xyz - hg_ProgramLocal0.xyz;\n"
           "    r0.x = dot(hg_ProgramLocal1.xyz, r0.xyz);\n"
           "    r0.x = r0.x*hg_ProgramLocal2.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal5.x + hg_ProgramLocal5.y, 0.00000, 1.00000);\n"
           "    r0.y = c0.x;\n"
           "    r0.xy = hg_ProgramLocal6.xy*c0.zz + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=b8811881:1a7c8d4d:3ce9ee81:ce3624a3\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0007:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientLinearAffine::InitProgramDescriptor(HgcGradientLinearAffine *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientLinearAffine_hgc_visible", "//Metal1.0     \n//LEN=000000038b\n[[ visible ]] FragmentOut HgcGradientLinearAffine_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = c0.z;\n"
    "    r0.x = dot(hg_Params[3], texCoord0);\n"
    "    r0.y = dot(hg_Params[4], texCoord0);\n"
    "    r0.xyz = r0.xyz - hg_Params[0].xyz;\n"
    "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
    "    r0.x = r0.x*hg_Params[2].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[5].x + hg_Params[5].y, 0.00000f, 1.00000f);\n"
    "    r0.y = c0.x;\n"
    "    r0.xy = r0.xy*hg_Params[6].xy;\n"
    "    r0.xy = fmax(r0.xy, c0.xx);\n"
    "    r1.xy = hg_Params[6].xy - c0.xx;\n"
    "    r0.xy = fmin(r0.xy, r1.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcGradientLinearAffine");
}

void sub_1B78F339C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78F33D4(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78F33CCLL);
}

double HgcGradientLinearAffine::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376180;
  strcpy(v3, "HgcGradientLinearAffine [hgc1]");
  return *(double *)"earAffine [hgc1]";
}

uint64_t HgcGradientLinearAffine::BindTexture(HgcGradientLinearAffine *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)a2 + 136))(a2, 6, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientLinearAffine::Bind(HgcGradientLinearAffine *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcGradientLinearAffine::RenderTile(HgcGradientLinearAffine *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    int v5 = a2[1].i32[0] - v2.i32[0];
    float32x2_t v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    int32x2_t v7 = a2[2];
    *(float32x2_t *)v8.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v8.i64[1] = 0x3F80000000000000;
    __asm { FMOV            V4.2S, #-1.0 }
    float32x2_t v14 = vadd_f32(v6, _D4);
    float32x2_t v15 = vadd_f32(v14, _D4);
    uint64_t v16 = (int8x16_t *)(*(void *)&v7 + 32);
    uint64_t v17 = 16 * a2[3].i32[0];
    while (v5 < 4)
    {
      LODWORD(v82) = 0;
      float32x4_t v20 = v8;
      if (v5 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v8 = vaddq_f32(v8, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      uint64_t v16 = (int8x16_t *)((char *)v16 + v17);
      *(void *)&v7 += v17;
      if (v4 == v3) {
        return 0;
      }
    }
    int v18 = 0;
    uint64_t v19 = v16;
    float32x4_t v20 = v8;
    do
    {
      float32x4_t v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v23 = vaddq_f32(v22, (float32x4_t)xmmword_1B7E736B0);
      uint64_t v24 = *((void *)this + 51);
      float32x4_t v26 = *(float32x4_t *)(v24 + 32);
      float32x4_t v25 = *(float32x4_t *)(v24 + 48);
      float32x4_t v27 = vmulq_f32(v20, v25);
      float32x4_t v28 = vmulq_f32(v21, v25);
      float32x4_t v29 = vmulq_f32(v22, v25);
      float32x4_t v30 = vmulq_f32(v23, v25);
      int8x16_t v31 = (int8x16_t)vaddq_f32(v27, (float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL));
      int8x16_t v32 = (int8x16_t)vaddq_f32(v28, (float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 4uLL));
      int8x16_t v33 = (int8x16_t)vaddq_f32(v29, (float32x4_t)vextq_s8((int8x16_t)v29, (int8x16_t)v29, 4uLL));
      int8x16_t v34 = (int8x16_t)vaddq_f32(v30, (float32x4_t)vextq_s8((int8x16_t)v30, (int8x16_t)v30, 4uLL));
      *(float32x2_t *)v31.i8 = vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
      float32x4_t v35 = *(float32x4_t *)(v24 + 64);
      float32x4_t v36 = *(float32x4_t *)(v24 + 80);
      float32x4_t v37 = vmulq_f32(v20, v35);
      float32x4_t v38 = vmulq_f32(v21, v35);
      *(float32x2_t *)v32.i8 = vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
      float32x4_t v39 = vmulq_f32(v22, v35);
      float32x4_t v40 = vmulq_f32(v23, v35);
      *(float32x2_t *)v33.i8 = vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
      float32x4_t v41 = vaddq_f32(v37, (float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 4uLL));
      float32x4_t v42 = vaddq_f32(v38, (float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 4uLL));
      float32x4_t v43 = vaddq_f32(v39, (float32x4_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 4uLL));
      float32x4_t v44 = vaddq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)v40, (int8x16_t)v40, 4uLL));
      *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
      int8x16_t v45 = *(int8x16_t *)(v24 + 96);
      float32x4_t v46 = *(float32x4_t *)(v24 + 112);
      float32x4_t v47 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v42, (float32x4_t)vextq_s8((int8x16_t)v42, (int8x16_t)v42, 8uLL)), v32);
      float32x4_t v48 = *(float32x4_t *)(v24 + 16);
      float32x4_t v49 = vmulq_f32(v48, vsubq_f32((float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v41, (float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v41, 8uLL)), v31), *(float32x4_t *)v24));
      float32x4_t v50 = vmulq_f32(v48, vsubq_f32(v47, *(float32x4_t *)v24));
      float32x4_t v51 = vmulq_f32(v48, vsubq_f32((float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v43, (float32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v43, 8uLL)), v33), *(float32x4_t *)v24));
      float32x4_t v52 = vmulq_f32(v48, vsubq_f32((float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v44, (float32x4_t)vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL)), v34), *(float32x4_t *)v24));
      float32x4_t v53 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL), vaddq_f32(v49, (float32x4_t)vrev64q_s32((int32x4_t)v49))));
      float32x4_t v54 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v50, (int8x16_t)v50, 8uLL), vaddq_f32(v50, (float32x4_t)vrev64q_s32((int32x4_t)v50))));
      float32x4_t v55 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v51, (int8x16_t)v51, 8uLL), vaddq_f32(v51, (float32x4_t)vrev64q_s32((int32x4_t)v51))));
      float32x4_t v56 = vmulq_f32(v26, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v52, (int8x16_t)v52, 8uLL), vaddq_f32(v52, (float32x4_t)vrev64q_s32((int32x4_t)v52))));
      float32x4_t v57 = (float32x4_t)vrev64q_s32((int32x4_t)v36);
      float32x4_t v58 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v53)), v46);
      float32x4_t v59 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v54)), v46);
      float32x4_t v60 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v55)), v46);
      float32x4_t v61 = vmaxq_f32(vaddq_f32(v57, vmulq_f32(v36, v56)), v46);
      float32x4_t v62 = *(float32x4_t *)(v24 + 128);
      int8x16_t v63 = *(int8x16_t *)(v24 + 144);
      v58.i32[0] = vminq_f32(v58, v62).u32[0];
      v59.i32[0] = vminq_f32(v59, v62).u32[0];
      v60.i32[0] = vminq_f32(v60, v62).u32[0];
      v61.i32[0] = vminq_f32(v61, v62).u32[0];
      v58.i32[1] = 0.5;
      v59.i32[1] = 0.5;
      v60.i32[1] = 0.5;
      v61.i32[1] = 0.5;
      int32x2_t v64 = a2[10];
      uint64_t v65 = a2[11].i32[0];
      *(float32x2_t *)v58.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v58.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v62.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v58.f32, v15));
      int v66 = v65 + 1;
      *(float32x2_t *)v59.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v59.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v33.i8 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v59.f32, v15));
      *(float32x2_t *)v58.f32 = vsub_f32(*(float32x2_t *)v58.f32, vcvt_f32_s32(*(int32x2_t *)v62.f32));
      *(float32x2_t *)v59.f32 = vsub_f32(*(float32x2_t *)v59.f32, vcvt_f32_s32(*(int32x2_t *)v33.i8));
      *(int32x2_t *)v44.f32 = vdup_n_s32(v65);
      *(int32x2_t *)v62.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v62.f32, *(int32x2_t *)v33.i8), vzip2_s32(*(int32x2_t *)v62.f32, *(int32x2_t *)v33.i8), *(int32x2_t *)v44.f32);
      uint64_t v67 = (float32x4_t *)(*(void *)&v64 + 16 * v62.i32[0]);
      v65 *= 16;
      uint64_t v68 = v66;
      int32x4_t v69 = (float32x4_t *)(*(void *)&v64 + 16 * v62.i32[1]);
      float32x4_t v70 = vaddq_f32(*v67, vmulq_n_f32(vsubq_f32(v67[1], *v67), v58.f32[0]));
      *(float32x2_t *)v60.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v60.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v71 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v60.f32, v15));
      *(float32x2_t *)v60.f32 = vsub_f32(*(float32x2_t *)v60.f32, vcvt_f32_s32(v71));
      *(float32x2_t *)v61.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v61.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      float32x4_t v72 = vaddq_f32(*v69, vmulq_n_f32(vsubq_f32(v69[1], *v69), v59.f32[0]));
      *(int32x2_t *)v46.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v61.f32, v15));
      *(float32x2_t *)v61.f32 = vsub_f32(*(float32x2_t *)v61.f32, vcvt_f32_s32(*(int32x2_t *)v46.f32));
      *(int32x2_t *)v46.f32 = vmla_s32(vzip1_s32(v71, *(int32x2_t *)v46.f32), vzip2_s32(v71, *(int32x2_t *)v46.f32), *(int32x2_t *)v44.f32);
      float32x4_t v73 = vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v67 + v65), vmulq_n_f32(vsubq_f32(v67[v68], *(float32x4_t *)((char *)v67 + v65)), v58.f32[0])), v70), *(float32x2_t *)v58.f32, 1);
      v74 = (float32x4_t *)(*(void *)&v64 + 16 * v46.i32[0]);
      float32x4_t v75 = vaddq_f32(v70, v73);
      float32x4_t v76 = vaddq_f32(*v74, vmulq_n_f32(vsubq_f32(v74[1], *v74), v60.f32[0]));
      v77 = (float32x4_t *)(*(void *)&v64 + 16 * v46.i32[1]);
      float32x4_t v78 = vaddq_f32(*v77, vmulq_n_f32(vsubq_f32(v77[1], *v77), v61.f32[0]));
      float32x4_t v79 = vaddq_f32(v72, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v69 + v65), vmulq_n_f32(vsubq_f32(v69[v68], *(float32x4_t *)((char *)v69 + v65)), v59.f32[0])), v72), *(float32x2_t *)v59.f32, 1));
      float32x4_t v80 = vaddq_f32(v76, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v74 + v65), vmulq_n_f32(vsubq_f32(v74[v68], *(float32x4_t *)((char *)v74 + v65)), v60.f32[0])), v76), *(float32x2_t *)v60.f32, 1));
      float32x4_t v81 = vaddq_f32(v78, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v77 + v65), vmulq_n_f32(vsubq_f32(v77[v68], *(float32x4_t *)((char *)v77 + v65)), v61.f32[0])), v78), *(float32x2_t *)v61.f32, 1));
      v19[-2] = vbslq_s8(v63, (int8x16_t)v75, (int8x16_t)vmulq_laneq_f32(v75, v75, 3));
      v19[-1] = vbslq_s8(v63, (int8x16_t)v79, (int8x16_t)vmulq_laneq_f32(v79, v79, 3));
      *uint64_t v19 = vbslq_s8(v63, (int8x16_t)v80, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      v19[1] = vbslq_s8(v63, (int8x16_t)v81, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      v19 += 4;
      float32x4_t v20 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E736B0);
      v18 -= 4;
    }
    while (v5 + v18 > 3);
    LODWORD(v82) = -v18;
    if ((int)v82 >= v5) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v82 = v82;
    do
    {
      uint64_t v83 = *((void *)this + 51);
      float32x4_t v84 = vmulq_f32(v20, *(float32x4_t *)(v83 + 48));
      int8x16_t v85 = (int8x16_t)vaddq_f32(v84, (float32x4_t)vextq_s8((int8x16_t)v84, (int8x16_t)v84, 4uLL));
      float32x4_t v86 = vmulq_f32(v20, *(float32x4_t *)(v83 + 64));
      float32x4_t v87 = vaddq_f32(v86, (float32x4_t)vextq_s8((int8x16_t)v86, (int8x16_t)v86, 4uLL));
      *(float32x2_t *)v85.i8 = vadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL));
      float32x4_t v88 = vmulq_f32(*(float32x4_t *)(v83 + 16), vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v83 + 96), (int8x16_t)vaddq_f32(v87, (float32x4_t)vextq_s8((int8x16_t)v87, (int8x16_t)v87, 8uLL)), v85), *(float32x4_t *)v83));
      int8x16_t v89 = *(int8x16_t *)(v83 + 144);
      v88.i32[0] = vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(*(int32x4_t *)(v83 + 80)), vmulq_f32(*(float32x4_t *)(v83 + 80), vmulq_f32(*(float32x4_t *)(v83 + 32), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v88, (int8x16_t)v88, 8uLL), vaddq_f32(v88, (float32x4_t)vrev64q_s32((int32x4_t)v88)))))), *(float32x4_t *)(v83 + 112)), *(float32x4_t *)(v83 + 128)).u32[0];
      v88.i32[1] = 0.5;
      *(float32x2_t *)v88.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v88.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v90 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v88.f32, v15));
      uint64_t v91 = a2[11].i32[0];
      *(float32x2_t *)v88.f32 = vsub_f32(*(float32x2_t *)v88.f32, vcvt_f32_s32(v90));
      v92 = (float32x4_t *)(*(void *)&a2[10] + 16 * (v90.i32[0] + v90.i32[1] * (int)v91));
      float32x4_t v93 = vaddq_f32(*v92, vmulq_n_f32(vsubq_f32(v92[1], *v92), v88.f32[0]));
      float32x4_t v94 = vaddq_f32(v93, vmulq_lane_f32(vsubq_f32(vaddq_f32(v92[v91], vmulq_n_f32(vsubq_f32(v92[(int)v91 + 1], v92[v91]), v88.f32[0])), v93), *(float32x2_t *)v88.f32, 1));
      *(int8x16_t *)(*(void *)&v7 + 16 * v82) = vbslq_s8(v89, (int8x16_t)v94, (int8x16_t)vmulq_laneq_f32(v94, v94, 3));
      float32x4_t v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      ++v82;
    }
    while (v82 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientLinearAffine::GetDOD(HgcGradientLinearAffine *this, HGRenderer *a2, int a3, HGRect a4)
{
  int v4 = &HGRectInfinite;
  if (a3) {
    int v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcGradientLinearAffine::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientLinearAffine::HgcGradientLinearAffine(HgcGradientLinearAffine *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EBCB8;
  operator new();
}

void sub_1B78F3DBC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientLinearAffine::~HgcGradientLinearAffine(HGNode *this)
{
  *(void *)this = &unk_1F10EBCB8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B8406A4ELL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EBCB8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B8406A4ELL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcGradientLinearAffine::SetParameter(HgcGradientLinearAffine *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  float32x4_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *float32x4_t v8 = a3;
  int v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientLinearAffine::GetParameter(HgcGradientLinearAffine *this, unsigned int a2, float *a3)
{
  if (a2 > 5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientLinearPerspective::GetProgram(HgcGradientLinearPerspective *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000504\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(half4(hg_Params[3]), half4(frag._texCoord0));\n"
             "    r0.y = dot(half4(hg_Params[4]), half4(frag._texCoord0));\n"
             "    r0.w = dot(half4(hg_Params[5]), half4(frag._texCoord0));\n"
             "    r0.xy = r0.xy/r0.ww;\n"
             "    s0.xyz = float3(r0.xyz) - hg_Params[0].xyz;\n"
             "    s0.x = dot(hg_Params[1].xyz, s0.xyz);\n"
             "    s0.x = s0.x*hg_Params[2].x;\n"
             "    s0.x = clamp(s0.x*hg_Params[6].x + hg_Params[6].y, 0.00000f, 1.00000f);\n"
             "    s0.y = float(c0.x);\n"
             "    s0.xy = s0.xy*hg_Params[7].xy;\n"
             "    s0.xy = fmax(s0.xy, float2(c0.xx));\n"
             "    s1.xy = hg_Params[7].xy - float2(c0.xx);\n"
             "    s0.xy = fmin(s0.xy, s1.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    r1 = r0;\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    output.color0 = float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2e08a5bb:aa373144:fd65e842:17accea7\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0008:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000048f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(hg_Params[3], frag._texCoord0);\n"
             "    r0.y = dot(hg_Params[4], frag._texCoord0);\n"
             "    r0.w = dot(hg_Params[5], frag._texCoord0);\n"
             "    r0.xy = r0.xy/r0.ww;\n"
             "    r0.xyz = r0.xyz - hg_Params[0].xyz;\n"
             "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
             "    r0.x = r0.x*hg_Params[2].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[6].x + hg_Params[6].y, 0.00000f, 1.00000f);\n"
             "    r0.y = c0.x;\n"
             "    r0.xy = r0.xy*hg_Params[7].xy;\n"
             "    r0.xy = fmax(r0.xy, c0.xx);\n"
             "    r1.xy = hg_Params[7].xy - c0.xx;\n"
             "    r0.xy = fmin(r0.xy, r1.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=55ccf5f9:4165b0cb:ef29e9dd:cc6692a4\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0008:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000513\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.z = c0.z;\n"
           "    r0.x = dot(hg_ProgramLocal3, hg_TexCoord0);\n"
           "    r0.y = dot(hg_ProgramLocal4, hg_TexCoord0);\n"
           "    r0.w = dot(hg_ProgramLocal5, hg_TexCoord0);\n"
           "    r0.xy = r0.xy/r0.ww;\n"
           "    r0.xyz = r0.xyz - hg_ProgramLocal0.xyz;\n"
           "    r0.x = dot(hg_ProgramLocal1.xyz, r0.xyz);\n"
           "    r0.x = r0.x*hg_ProgramLocal2.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal6.x + hg_ProgramLocal6.y, 0.00000, 1.00000);\n"
           "    r0.y = c0.x;\n"
           "    r0.xy = hg_ProgramLocal7.xy*c0.zz + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c492827a:59585925:8987f7c8:7cfbe231\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0008:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientLinearPerspective::InitProgramDescriptor(HgcGradientLinearPerspective *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientLinearPerspective_hgc_visible", "//Metal1.0     \n//LEN=00000003d2\n[[ visible ]] FragmentOut HgcGradientLinearPerspective_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = c0.z;\n"
    "    r0.x = dot(hg_Params[3], texCoord0);\n"
    "    r0.y = dot(hg_Params[4], texCoord0);\n"
    "    r0.w = dot(hg_Params[5], texCoord0);\n"
    "    r0.xy = r0.xy/r0.ww;\n"
    "    r0.xyz = r0.xyz - hg_Params[0].xyz;\n"
    "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
    "    r0.x = r0.x*hg_Params[2].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[6].x + hg_Params[6].y, 0.00000f, 1.00000f);\n"
    "    r0.y = c0.x;\n"
    "    r0.xy = r0.xy*hg_Params[7].xy;\n"
    "    r0.xy = fmax(r0.xy, c0.xx);\n"
    "    r1.xy = hg_Params[7].xy - c0.xx;\n"
    "    r0.xy = fmin(r0.xy, r1.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcGradientLinearPerspective");
}

void sub_1B78F438C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78F43C4(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78F43BCLL);
}

char *HgcGradientLinearPerspective::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375E40;
  strcpy(result, "HgcGradientLinearPerspective [hgc1]");
  return result;
}

uint64_t HgcGradientLinearPerspective::BindTexture(HgcGradientLinearPerspective *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)a2 + 136))(a2, 7, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientLinearPerspective::Bind(HgcGradientLinearPerspective *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcGradientLinearPerspective::RenderTile(HgcGradientLinearPerspective *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    int v5 = a2[1].i32[0] - v2.i32[0];
    float32x2_t v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    *(float32x2_t *)v7.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v7.i64[1] = 0x3F80000000000000;
    int32x2_t v8 = a2[2];
    __asm { FMOV            V4.2S, #-1.0 }
    float32x2_t v14 = vadd_f32(v6, _D4);
    float32x2_t v15 = vadd_f32(v14, _D4);
    uint64_t v16 = 16 * a2[3].i32[0];
    while (v5 < 3)
    {
      uint64_t v17 = 0;
      float32x4_t v19 = v7;
      if (v5 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      *(void *)&v8 += v16;
      if (v4 == v3) {
        return 0;
      }
    }
    uint64_t v17 = 0;
    int v18 = v5;
    float32x4_t v19 = v7;
    do
    {
      float32x4_t v20 = vaddq_f32(v19, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      uint64_t v22 = *((void *)this + 51);
      float32x4_t v24 = *(float32x4_t *)(v22 + 32);
      float32x4_t v23 = *(float32x4_t *)(v22 + 48);
      float32x4_t v25 = vmulq_f32(v19, v23);
      float32x4_t v26 = vmulq_f32(v20, v23);
      float32x4_t v27 = vmulq_f32(v21, v23);
      int8x16_t v28 = (int8x16_t)vaddq_f32(v25, (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 4uLL));
      int8x16_t v29 = (int8x16_t)vaddq_f32(v26, (float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL));
      int8x16_t v30 = (int8x16_t)vaddq_f32(v27, (float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL));
      *(float32x2_t *)v28.i8 = vadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
      float32x4_t v31 = *(float32x4_t *)(v22 + 64);
      float32x4_t v32 = *(float32x4_t *)(v22 + 80);
      float32x4_t v33 = vmulq_f32(v19, v31);
      float32x4_t v34 = vmulq_f32(v20, v31);
      float32x4_t v35 = vmulq_f32(v21, v31);
      *(float32x2_t *)v29.i8 = vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL));
      float32x4_t v36 = vaddq_f32(v33, (float32x4_t)vextq_s8((int8x16_t)v33, (int8x16_t)v33, 4uLL));
      float32x4_t v37 = vaddq_f32(v34, (float32x4_t)vextq_s8((int8x16_t)v34, (int8x16_t)v34, 4uLL));
      *(float32x2_t *)v30.i8 = vadd_f32(*(float32x2_t *)v30.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
      float32x4_t v38 = vaddq_f32(v35, (float32x4_t)vextq_s8((int8x16_t)v35, (int8x16_t)v35, 4uLL));
      int8x16_t v39 = (int8x16_t)vaddq_f32(v37, (float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 8uLL));
      float32x4_t v40 = vmulq_f32(v19, v32);
      float32x4_t v41 = vmulq_f32(v20, v32);
      float32x4_t v43 = *(float32x4_t *)(v22 + 96);
      int8x16_t v42 = *(int8x16_t *)(v22 + 112);
      int8x16_t v44 = vbslq_s8(v42, (int8x16_t)vaddq_f32(v36, (float32x4_t)vextq_s8((int8x16_t)v36, (int8x16_t)v36, 8uLL)), v28);
      float32x4_t v45 = vmulq_f32(v21, v32);
      float32x4_t v46 = vaddq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)v40, (int8x16_t)v40, 4uLL));
      int8x16_t v47 = vbslq_s8(v42, v39, v29);
      float32x4_t v48 = vaddq_f32(v41, (float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v41, 4uLL));
      float32x4_t v49 = vaddq_f32(v45, (float32x4_t)vextq_s8((int8x16_t)v45, (int8x16_t)v45, 4uLL));
      int8x16_t v50 = vbslq_s8(v42, (int8x16_t)vaddq_f32(v38, (float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 8uLL)), v30);
      int8x16_t v51 = (int8x16_t)vaddq_f32(v46, (float32x4_t)vextq_s8((int8x16_t)v46, (int8x16_t)v46, 8uLL));
      int8x16_t v52 = *(int8x16_t *)(v22 + 128);
      float32x4_t v53 = *(float32x4_t *)(v22 + 144);
      float32x4_t v54 = (float32x4_t)vbslq_s8(v52, v51, v44);
      float32x4_t v55 = (float32x4_t)vbslq_s8(v52, (int8x16_t)vaddq_f32(v48, (float32x4_t)vextq_s8((int8x16_t)v48, (int8x16_t)v48, 8uLL)), v47);
      float32x4_t v56 = (float32x4_t)vbslq_s8(v52, (int8x16_t)vaddq_f32(v49, (float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL)), v50);
      float32x4_t v57 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 3);
      float32x4_t v58 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3);
      float32x4_t v59 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3);
      float32x4_t v61 = *(float32x4_t *)(v22 + 160);
      float32x4_t v60 = *(float32x4_t *)(v22 + 176);
      float32x4_t v62 = vminq_f32(vmaxq_f32(vrecpeq_f32(v57), v53), v61);
      float32x4_t v63 = vminq_f32(vmaxq_f32(vrecpeq_f32(v58), v53), v61);
      float32x4_t v64 = vminq_f32(vmaxq_f32(vrecpeq_f32(v59), v53), v61);
      float32x4_t v65 = vminq_f32(vmaxq_f32(vmulq_f32(v62, vrecpsq_f32(v57, v62)), v53), v61);
      float32x4_t v66 = vminq_f32(vmaxq_f32(vmulq_f32(v63, vrecpsq_f32(v58, v63)), v53), v61);
      float32x4_t v67 = vminq_f32(vmaxq_f32(vmulq_f32(v64, vrecpsq_f32(v59, v64)), v53), v61);
      v57.i64[0] = vmulq_f32(vmulq_f32(v65, vrecpsq_f32(v57, v65)), v54).u64[0];
      v58.i64[0] = vmulq_f32(vmulq_f32(v66, vrecpsq_f32(v58, v66)), v55).u64[0];
      v59.i64[0] = vmulq_f32(vmulq_f32(v67, vrecpsq_f32(v59, v67)), v56).u64[0];
      v57.i64[1] = v54.i64[1];
      v58.i64[1] = v55.i64[1];
      v59.i64[1] = v56.i64[1];
      float32x4_t v68 = *(float32x4_t *)(v22 + 16);
      float32x4_t v69 = vmulq_f32(v68, vsubq_f32(v57, *(float32x4_t *)v22));
      float32x4_t v70 = vmulq_f32(v68, vsubq_f32(v58, *(float32x4_t *)v22));
      float32x4_t v71 = vmulq_f32(v68, vsubq_f32(v59, *(float32x4_t *)v22));
      float32x4_t v72 = vmulq_f32(v24, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v69, (int8x16_t)v69, 8uLL), vaddq_f32(v69, (float32x4_t)vrev64q_s32((int32x4_t)v69))));
      float32x4_t v73 = vmulq_f32(v24, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v70, (int8x16_t)v70, 8uLL), vaddq_f32(v70, (float32x4_t)vrev64q_s32((int32x4_t)v70))));
      float32x4_t v74 = vmulq_f32(v24, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v71, (int8x16_t)v71, 8uLL), vaddq_f32(v71, (float32x4_t)vrev64q_s32((int32x4_t)v71))));
      float32x4_t v75 = (float32x4_t)vrev64q_s32((int32x4_t)v43);
      float32x4_t v76 = vaddq_f32(v75, vmulq_f32(v43, v74));
      float32x4_t v77 = vmaxq_f32(vaddq_f32(v75, vmulq_f32(v43, v72)), v60);
      float32x4_t v78 = vmaxq_f32(vaddq_f32(v75, vmulq_f32(v43, v73)), v60);
      float32x4_t v79 = *(float32x4_t *)(v22 + 192);
      v77.i32[0] = vminq_f32(v77, v79).u32[0];
      v78.i32[0] = vminq_f32(v78, v79).u32[0];
      v77.i32[1] = 0.5;
      v76.i32[0] = vminq_f32(vmaxq_f32(v76, v60), v79).u32[0];
      v78.i32[1] = 0.5;
      v76.i32[1] = 0.5;
      int32x2_t v80 = a2[10];
      uint64_t v81 = a2[11].i32[0];
      *(float32x2_t *)v77.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v77.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v79.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v77.f32, v15));
      *(float32x2_t *)v78.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v78.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v58.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v78.f32, v15));
      *(float32x2_t *)v77.f32 = vsub_f32(*(float32x2_t *)v77.f32, vcvt_f32_s32(*(int32x2_t *)v79.f32));
      *(int32x2_t *)v79.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v79.f32, *(int32x2_t *)v58.f32), vzip2_s32(*(int32x2_t *)v79.f32, *(int32x2_t *)v58.f32), vdup_n_s32(v81));
      __int32 v82 = v79.i32[1];
      *(float32x2_t *)v78.f32 = vsub_f32(*(float32x2_t *)v78.f32, vcvt_f32_s32(*(int32x2_t *)v58.f32));
      uint64_t v83 = (float32x4_t *)(*(void *)&v80 + 16 * v79.i32[0]);
      uint64_t v84 = (int)v81 + 1;
      float32x4_t v85 = vaddq_f32(*v83, vmulq_n_f32(vsubq_f32(v83[1], *v83), v77.f32[0]));
      float32x4_t v86 = (float32x4_t *)(*(void *)&v80 + 16 * v82);
      float32x4_t v87 = vaddq_f32(*v86, vmulq_n_f32(vsubq_f32(v86[1], *v86), v78.f32[0]));
      *(float32x2_t *)v76.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v76.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v70.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v76.f32, v15));
      *(float32x2_t *)v76.f32 = vsub_f32(*(float32x2_t *)v76.f32, vcvt_f32_s32(*(int32x2_t *)v70.f32));
      float32x4_t v88 = (float32x4_t *)(*(void *)&v80 + 16 * (v70.i32[0] + v70.i32[1] * (int)v81));
      float32x4_t v89 = vaddq_f32(v85, vmulq_lane_f32(vsubq_f32(vaddq_f32(v83[v81], vmulq_n_f32(vsubq_f32(v83[v84], v83[v81]), v77.f32[0])), v85), *(float32x2_t *)v77.f32, 1));
      float32x4_t v90 = vaddq_f32(*v88, vmulq_n_f32(vsubq_f32(v88[1], *v88), v76.f32[0]));
      float32x4_t v91 = vaddq_f32(v87, vmulq_lane_f32(vsubq_f32(vaddq_f32(v86[v81], vmulq_n_f32(vsubq_f32(v86[v84], v86[v81]), v78.f32[0])), v87), *(float32x2_t *)v78.f32, 1));
      float32x4_t v92 = vaddq_f32(v90, vmulq_lane_f32(vsubq_f32(vaddq_f32(v88[v81], vmulq_n_f32(vsubq_f32(v88[v84], v88[v81]), v76.f32[0])), v90), *(float32x2_t *)v76.f32, 1));
      float32x4_t v93 = (int8x16_t *)(*(void *)&v8 + 16 * v17);
      *float32x4_t v93 = vbslq_s8(v52, (int8x16_t)v89, (int8x16_t)vmulq_laneq_f32(v89, v89, 3));
      v93[1] = vbslq_s8(v52, (int8x16_t)v91, (int8x16_t)vmulq_laneq_f32(v91, v91, 3));
      v93[2] = vbslq_s8(v52, (int8x16_t)v92, (int8x16_t)vmulq_laneq_f32(v92, v92, 3));
      float32x4_t v19 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E736B0);
      v17 += 3;
      v18 -= 3;
    }
    while (v18 > 2);
    uint64_t v17 = v17;
    if ((int)v17 >= v5) {
      goto LABEL_3;
    }
    do
    {
LABEL_10:
      uint64_t v94 = *((void *)this + 51);
      float32x4_t v95 = vmulq_f32(v19, *(float32x4_t *)(v94 + 48));
      int8x16_t v96 = (int8x16_t)vaddq_f32(v95, (float32x4_t)vextq_s8((int8x16_t)v95, (int8x16_t)v95, 4uLL));
      float32x4_t v97 = vmulq_f32(v19, *(float32x4_t *)(v94 + 64));
      float32x4_t v98 = vaddq_f32(v97, (float32x4_t)vextq_s8((int8x16_t)v97, (int8x16_t)v97, 4uLL));
      *(float32x2_t *)v96.i8 = vadd_f32(*(float32x2_t *)v96.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v96, v96, 8uLL));
      int8x16_t v99 = (int8x16_t)vaddq_f32(v98, (float32x4_t)vextq_s8((int8x16_t)v98, (int8x16_t)v98, 8uLL));
      float32x4_t v100 = vmulq_f32(v19, *(float32x4_t *)(v94 + 80));
      int8x16_t v101 = vbslq_s8(*(int8x16_t *)(v94 + 112), v99, v96);
      float32x4_t v102 = vaddq_f32(v100, (float32x4_t)vextq_s8((int8x16_t)v100, (int8x16_t)v100, 4uLL));
      int8x16_t v103 = *(int8x16_t *)(v94 + 128);
      float32x4_t v104 = *(float32x4_t *)(v94 + 144);
      float32x4_t v105 = (float32x4_t)vbslq_s8(v103, (int8x16_t)vaddq_f32(v102, (float32x4_t)vextq_s8((int8x16_t)v102, (int8x16_t)v102, 8uLL)), v101);
      float32x4_t v106 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v105, 3);
      float32x4_t v107 = *(float32x4_t *)(v94 + 160);
      float32x4_t v108 = vminq_f32(vmaxq_f32(vrecpeq_f32(v106), v104), v107);
      float32x4_t v109 = vminq_f32(vmaxq_f32(vmulq_f32(v108, vrecpsq_f32(v106, v108)), v104), v107);
      v106.i64[0] = vmulq_f32(vmulq_f32(v109, vrecpsq_f32(v106, v109)), v105).u64[0];
      v106.i64[1] = v105.i64[1];
      float32x4_t v110 = vmulq_f32(*(float32x4_t *)(v94 + 16), vsubq_f32(v106, *(float32x4_t *)v94));
      v110.i32[0] = vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(*(int32x4_t *)(v94 + 96)), vmulq_f32(*(float32x4_t *)(v94 + 96), vmulq_f32(*(float32x4_t *)(v94 + 32), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v110, (int8x16_t)v110, 8uLL), vaddq_f32(v110, (float32x4_t)vrev64q_s32((int32x4_t)v110)))))), *(float32x4_t *)(v94 + 176)), *(float32x4_t *)(v94 + 192)).u32[0];
      v110.i32[1] = 0.5;
      *(float32x2_t *)v110.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v110.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v111 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v110.f32, v15));
      uint64_t v112 = a2[11].i32[0];
      *(float32x2_t *)v110.f32 = vsub_f32(*(float32x2_t *)v110.f32, vcvt_f32_s32(v111));
      v113 = (float32x4_t *)(*(void *)&a2[10] + 16 * (v111.i32[0] + v111.i32[1] * (int)v112));
      float32x4_t v114 = vaddq_f32(*v113, vmulq_n_f32(vsubq_f32(v113[1], *v113), v110.f32[0]));
      float32x4_t v115 = vaddq_f32(v114, vmulq_lane_f32(vsubq_f32(vaddq_f32(v113[v112], vmulq_n_f32(vsubq_f32(v113[(int)v112 + 1], v113[v112]), v110.f32[0])), v114), *(float32x2_t *)v110.f32, 1));
      *(int8x16_t *)(*(void *)&v8 + 16 * v17) = vbslq_s8(v103, (int8x16_t)v115, (int8x16_t)vmulq_laneq_f32(v115, v115, 3));
      float32x4_t v19 = vaddq_f32(v19, (float32x4_t)xmmword_1B7E736B0);
      ++v17;
    }
    while (v17 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientLinearPerspective::GetDOD(HgcGradientLinearPerspective *this, HGRenderer *a2, int a3, HGRect a4)
{
  int v4 = &HGRectInfinite;
  if (a3) {
    int v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcGradientLinearPerspective::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientLinearPerspective::HgcGradientLinearPerspective(HgcGradientLinearPerspective *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EBF20;
  operator new();
}

void sub_1B78F4E74(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientLinearPerspective::~HgcGradientLinearPerspective(HGNode *this)
{
  *(void *)this = &unk_1F10EBF20;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C400F93440CLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EBF20;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C400F93440CLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcGradientLinearPerspective::SetParameter(HgcGradientLinearPerspective *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int32x2_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int32x2_t v8 = a3;
  int v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientLinearPerspective::GetParameter(HgcGradientLinearPerspective *this, unsigned int a2, float *a3)
{
  if (a2 > 6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientLinearIdentity::GetProgram(HgcGradientLinearIdentity *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000417\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xyz = frag._texCoord0.xyz - hg_Params[0].xyz;\n"
             "    s0.x = dot(hg_Params[1].xyz, s0.xyz);\n"
             "    s0.x = s0.x*hg_Params[2].x;\n"
             "    s0.x = clamp(s0.x*hg_Params[3].x + hg_Params[3].y, 0.00000f, 1.00000f);\n"
             "    s0.y = float(c0.y);\n"
             "    s0.xy = s0.xy*hg_Params[4].xy;\n"
             "    s0.xy = fmax(s0.xy, float2(c0.yy));\n"
             "    s1.xy = hg_Params[4].xy - float2(c0.yy);\n"
             "    s0.xy = fmin(s0.xy, s1.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=90469e23:e8a58590:544d7d30:1a3cbdd3\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = frag._texCoord0.xyz - hg_Params[0].xyz;\n"
             "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
             "    r0.x = r0.x*hg_Params[2].x;\n"
             "    r0.x = clamp(r0.x*hg_Params[3].x + hg_Params[3].y, 0.00000f, 1.00000f);\n"
             "    r0.y = c0.y;\n"
             "    r0.xy = r0.xy*hg_Params[4].xy;\n"
             "    r0.xy = fmax(r0.xy, c0.yy);\n"
             "    r1.xy = hg_Params[4].xy - c0.yy;\n"
             "    r0.xy = fmin(r0.xy, r1.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f0cefc8b:5dc30f52:2b0338bb:b15223e3\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0005:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.xyz = hg_TexCoord0.xyz - hg_ProgramLocal0.xyz;\n"
           "    r0.x = dot(hg_ProgramLocal1.xyz, r0.xyz);\n"
           "    r0.x = r0.x*hg_ProgramLocal2.x;\n"
           "    r0.x = clamp(r0.x*hg_ProgramLocal3.x + hg_ProgramLocal3.y, 0.00000, 1.00000);\n"
           "    r0.y = c0.y;\n"
           "    r0.xy = hg_ProgramLocal4.xy*c0.xx + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=25a463cb:436ff83f:4101e589:fcdc7897\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0005:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientLinearIdentity::InitProgramDescriptor(HgcGradientLinearIdentity *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientLinearIdentity_hgc_visible", "//Metal1.0     \n//LEN=0000000331\n[[ visible ]] FragmentOut HgcGradientLinearIdentity_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = texCoord0.xyz - hg_Params[0].xyz;\n"
    "    r0.x = dot(hg_Params[1].xyz, r0.xyz);\n"
    "    r0.x = r0.x*hg_Params[2].x;\n"
    "    r0.x = clamp(r0.x*hg_Params[3].x + hg_Params[3].y, 0.00000f, 1.00000f);\n"
    "    r0.y = c0.y;\n"
    "    r0.xy = r0.xy*hg_Params[4].xy;\n"
    "    r0.xy = fmax(r0.xy, c0.yy);\n"
    "    r1.xy = hg_Params[4].xy - c0.yy;\n"
    "    r0.xy = fmin(r0.xy, r1.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcGradientLinearIdentity");
}

void sub_1B78F5444(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78F547C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78F5474);
}

char *HgcGradientLinearIdentity::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B83761D0;
  strcpy(result, "HgcGradientLinearIdentity [hgc1]");
  return result;
}

uint64_t HgcGradientLinearIdentity::BindTexture(HgcGradientLinearIdentity *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)a2 + 136))(a2, 4, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientLinearIdentity::Bind(HgcGradientLinearIdentity *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcGradientLinearIdentity::RenderTile(HgcGradientLinearIdentity *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    int v5 = a2[1].i32[0] - v2.i32[0];
    float32x2_t v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    int32x2_t v7 = a2[2];
    *(float32x2_t *)v8.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v8.i64[1] = 0x3F80000000000000;
    __asm { FMOV            V4.2S, #-1.0 }
    float32x2_t v14 = vadd_f32(v6, _D4);
    float32x2_t v15 = vadd_f32(v14, _D4);
    uint64_t v16 = (int8x16_t *)(*(void *)&v7 + 32);
    uint64_t v17 = 16 * a2[3].i32[0];
    while (v5 < 4)
    {
      LODWORD(v70) = 0;
      float32x4_t v20 = v8;
      if (v5 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v8 = vaddq_f32(v8, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      uint64_t v16 = (int8x16_t *)((char *)v16 + v17);
      *(void *)&v7 += v17;
      if (v4 == v3) {
        return 0;
      }
    }
    int v18 = 0;
    float32x4_t v19 = v16;
    float32x4_t v20 = v8;
    do
    {
      float32x4_t v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E736B0);
      uint64_t v23 = *((void *)this + 51);
      float32x4_t v24 = vaddq_f32(v22, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v25 = *(float32x4_t *)(v23 + 16);
      float32x4_t v26 = vmulq_f32(v25, vsubq_f32(v20, *(float32x4_t *)v23));
      float32x4_t v27 = vmulq_f32(v25, vsubq_f32(v21, *(float32x4_t *)v23));
      float32x4_t v28 = vmulq_f32(v25, vsubq_f32(v22, *(float32x4_t *)v23));
      float32x4_t v29 = vmulq_f32(v25, vsubq_f32(v24, *(float32x4_t *)v23));
      float32x4_t v30 = *(float32x4_t *)(v23 + 32);
      float32x4_t v31 = *(float32x4_t *)(v23 + 48);
      float32x4_t v32 = vmulq_f32(v30, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 8uLL), vaddq_f32(v26, (float32x4_t)vrev64q_s32((int32x4_t)v26))));
      float32x4_t v33 = vmulq_f32(v30, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 8uLL), vaddq_f32(v27, (float32x4_t)vrev64q_s32((int32x4_t)v27))));
      float32x4_t v34 = vmulq_f32(v30, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 8uLL), vaddq_f32(v28, (float32x4_t)vrev64q_s32((int32x4_t)v28))));
      float32x4_t v35 = vmulq_f32(v30, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v29, (int8x16_t)v29, 8uLL), vaddq_f32(v29, (float32x4_t)vrev64q_s32((int32x4_t)v29))));
      float32x4_t v36 = (float32x4_t)vrev64q_s32((int32x4_t)v31);
      float32x4_t v37 = vaddq_f32(v36, vmulq_f32(v31, v32));
      float32x4_t v38 = vaddq_f32(v36, vmulq_f32(v31, v33));
      float32x4_t v39 = vaddq_f32(v36, vmulq_f32(v31, v34));
      float32x4_t v40 = vaddq_f32(v36, vmulq_f32(v31, v35));
      float32x4_t v42 = *(float32x4_t *)(v23 + 64);
      float32x4_t v41 = *(float32x4_t *)(v23 + 80);
      float32x4_t v43 = vmaxq_f32(v38, v42);
      float32x4_t v44 = vmaxq_f32(v39, v42);
      float32x4_t v45 = vmaxq_f32(v40, v42);
      v42.i32[0] = vminq_f32(vmaxq_f32(v37, v42), v41).u32[0];
      v43.i32[0] = vminq_f32(v43, v41).u32[0];
      v44.i32[0] = vminq_f32(v44, v41).u32[0];
      v42.i32[1] = 0.5;
      v43.i32[1] = 0.5;
      v37.i32[0] = vminq_f32(v45, v41).u32[0];
      v44.i32[1] = 0.5;
      v37.i32[1] = 0.5;
      int32x2_t v46 = a2[10];
      uint64_t v47 = a2[11].i32[0];
      *(float32x2_t *)v45.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v42.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v41.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v45.f32, v15));
      int v48 = v47 + 1;
      float32x2_t v49 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v43.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v50 = vcvt_s32_f32(vmin_f32(v49, v15));
      *(float32x2_t *)v43.f32 = vsub_f32(*(float32x2_t *)v45.f32, vcvt_f32_s32(*(int32x2_t *)v41.f32));
      *(int32x2_t *)v45.f32 = vdup_n_s32(v47);
      *(int32x2_t *)v41.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v41.f32, v50), vzip2_s32(*(int32x2_t *)v41.f32, v50), *(int32x2_t *)v45.f32);
      *(float32x2_t *)v42.f32 = vsub_f32(v49, vcvt_f32_s32(v50));
      int8x16_t v51 = (float32x4_t *)(*(void *)&v46 + 16 * v41.i32[0]);
      v47 *= 16;
      uint64_t v52 = v48;
      float32x4_t v53 = (float32x4_t *)(*(void *)&v46 + 16 * v41.i32[1]);
      *(float32x2_t *)v44.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v44.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      float32x4_t v54 = vaddq_f32(*v51, vmulq_n_f32(vsubq_f32(v51[1], *v51), v43.f32[0]));
      int32x2_t v55 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v44.f32, v15));
      *(float32x2_t *)v37.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v37.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v56 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v37.f32, v15));
      int32x2_t v57 = vmla_s32(vzip1_s32(v55, v56), vzip2_s32(v55, v56), *(int32x2_t *)v45.f32);
      float32x4_t v58 = vaddq_f32(*v53, vmulq_n_f32(vsubq_f32(v53[1], *v53), v42.f32[0]));
      *(float32x2_t *)v44.f32 = vsub_f32(*(float32x2_t *)v44.f32, vcvt_f32_s32(v55));
      *(float32x2_t *)v37.f32 = vsub_f32(*(float32x2_t *)v37.f32, vcvt_f32_s32(v56));
      float32x4_t v59 = vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v51 + v47), vmulq_n_f32(vsubq_f32(v51[v52], *(float32x4_t *)((char *)v51 + v47)), v43.f32[0])), v54), *(float32x2_t *)v43.f32, 1);
      float32x4_t v60 = (float32x4_t *)(*(void *)&v46 + 16 * v57.i32[0]);
      float32x4_t v61 = vaddq_f32(v54, v59);
      float32x4_t v62 = vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v53 + v47), vmulq_n_f32(vsubq_f32(v53[v52], *(float32x4_t *)((char *)v53 + v47)), v42.f32[0])), v58), *(float32x2_t *)v42.f32, 1);
      float32x4_t v63 = vaddq_f32(*v60, vmulq_n_f32(vsubq_f32(v60[1], *v60), v44.f32[0]));
      float32x4_t v64 = (float32x4_t *)(*(void *)&v46 + 16 * v57.i32[1]);
      float32x4_t v65 = vaddq_f32(v58, v62);
      float32x4_t v66 = vaddq_f32(*v64, vmulq_n_f32(vsubq_f32(v64[1], *v64), v37.f32[0]));
      float32x4_t v67 = vaddq_f32(v63, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v60 + v47), vmulq_n_f32(vsubq_f32(v60[v52], *(float32x4_t *)((char *)v60 + v47)), v44.f32[0])), v63), *(float32x2_t *)v44.f32, 1));
      float32x4_t v68 = vaddq_f32(v66, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v64 + v47), vmulq_n_f32(vsubq_f32(v64[v52], *(float32x4_t *)((char *)v64 + v47)), v37.f32[0])), v66), *(float32x2_t *)v37.f32, 1));
      int8x16_t v69 = *(int8x16_t *)(v23 + 96);
      v19[-2] = vbslq_s8(v69, (int8x16_t)v61, (int8x16_t)vmulq_laneq_f32(v61, v61, 3));
      v19[-1] = vbslq_s8(v69, (int8x16_t)v65, (int8x16_t)vmulq_laneq_f32(v65, v65, 3));
      *float32x4_t v19 = vbslq_s8(v69, (int8x16_t)v67, (int8x16_t)vmulq_laneq_f32(v67, v67, 3));
      v19[1] = vbslq_s8(v69, (int8x16_t)v68, (int8x16_t)vmulq_laneq_f32(v68, v68, 3));
      v19 += 4;
      float32x4_t v20 = vaddq_f32(v24, (float32x4_t)xmmword_1B7E736B0);
      v18 -= 4;
    }
    while (v5 + v18 > 3);
    LODWORD(v70) = -v18;
    if ((int)v70 >= v5) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v70 = v70;
    do
    {
      uint64_t v71 = *((void *)this + 51);
      float32x4_t v72 = vmulq_f32(*(float32x4_t *)(v71 + 16), vsubq_f32(v20, *(float32x4_t *)v71));
      v72.i32[0] = vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(*(int32x4_t *)(v71 + 48)), vmulq_f32(*(float32x4_t *)(v71 + 48), vmulq_f32(*(float32x4_t *)(v71 + 32), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v72, (int8x16_t)v72, 8uLL), vaddq_f32(v72, (float32x4_t)vrev64q_s32((int32x4_t)v72)))))), *(float32x4_t *)(v71 + 64)), *(float32x4_t *)(v71 + 80)).u32[0];
      v72.i32[1] = 0.5;
      uint64_t v73 = a2[11].i32[0];
      *(float32x2_t *)v72.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, *(float32x2_t *)v72.f32), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v74 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v72.f32, v15));
      *(float32x2_t *)v72.f32 = vsub_f32(*(float32x2_t *)v72.f32, vcvt_f32_s32(v74));
      float32x4_t v75 = (float32x4_t *)(*(void *)&a2[10] + 16 * (v74.i32[0] + v74.i32[1] * (int)v73));
      float32x4_t v76 = vaddq_f32(*v75, vmulq_n_f32(vsubq_f32(v75[1], *v75), v72.f32[0]));
      float32x4_t v77 = vaddq_f32(v76, vmulq_lane_f32(vsubq_f32(vaddq_f32(v75[v73], vmulq_n_f32(vsubq_f32(v75[(int)v73 + 1], v75[v73]), v72.f32[0])), v76), *(float32x2_t *)v72.f32, 1));
      *(int8x16_t *)(*(void *)&v7 + 16 * v70) = vbslq_s8(*(int8x16_t *)(v71 + 96), (int8x16_t)v77, (int8x16_t)vmulq_laneq_f32(v77, v77, 3));
      float32x4_t v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      ++v70;
    }
    while (v70 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientLinearIdentity::GetDOD(HgcGradientLinearIdentity *this, HGRenderer *a2, int a3, HGRect a4)
{
  int v4 = &HGRectInfinite;
  if (a3) {
    int v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcGradientLinearIdentity::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientLinearIdentity::HgcGradientLinearIdentity(HgcGradientLinearIdentity *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EC188;
  operator new();
}

void sub_1B78F5CF8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientLinearIdentity::~HgcGradientLinearIdentity(HGNode *this)
{
  *(void *)this = &unk_1F10EC188;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EC188;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcGradientLinearIdentity::SetParameter(HgcGradientLinearIdentity *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  float32x4_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *float32x4_t v8 = a3;
  int v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientLinearIdentity::GetParameter(HgcGradientLinearIdentity *this, unsigned int a2, float *a3)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientRadialAffine::GetProgram(HgcGradientRadialAffine *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000579\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(half4(hg_Params[3]), half4(frag._texCoord0));\n"
             "    r0.y = dot(half4(hg_Params[4]), half4(frag._texCoord0));\n"
             "    s0.xyz = float3(r0.xyz) - hg_Params[1].xyz;\n"
             "    s0.x = s0.x*hg_Params[0].x;\n"
             "    s0.xy = float2(dot(s0.xyz, s0.xyz));\n"
             "    s0.xy = sqrt(s0.xy);\n"
             "    s1.xy = s0.xy*hg_Params[2].ww;\n"
             "    s1.xy = fmin(s1.xy, float2(c0.xx));\n"
             "    s1.xy = s1.xy*hg_Params[5].xy;\n"
             "    s1.xy = fmax(s1.xy, float2(c0.yy));\n"
             "    s2.xy = hg_Params[5].xy - float2(c0.yy);\n"
             "    s1.xy = fmin(s1.xy, s2.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s1.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    r1.x = half(hg_Params[2].x) - c0.y;\n"
             "    r1.x = fmax(r1.x, c0.z);\n"
             "    s0.x = clamp(s0.x - float(r1.x), 0.00000f, 1.00000f);\n"
             "    s0 = float4(r0)*-s0.xxxx + float4(r0);\n"
             "    output.color0 = select(s0, float4(r0), hg_Params[2].yyyy == 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=686d5007:b53467b8:2344a822:939db735\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0006:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000501\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(hg_Params[3], frag._texCoord0);\n"
             "    r0.y = dot(hg_Params[4], frag._texCoord0);\n"
             "    r0.xyz = r0.xyz - hg_Params[1].xyz;\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
             "    r0.xy = sqrt(r0.xy);\n"
             "    r1.xy = r0.xy*hg_Params[2].ww;\n"
             "    r1.xy = fmin(r1.xy, c0.xx);\n"
             "    r1.xy = r1.xy*hg_Params[5].xy;\n"
             "    r1.xy = fmax(r1.xy, c0.yy);\n"
             "    r2.xy = hg_Params[5].xy - c0.yy;\n"
             "    r1.xy = fmin(r1.xy, r2.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    r2.x = hg_Params[2].x - c0.y;\n"
             "    r2.x = fmax(r2.x, c0.z);\n"
             "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
             "    r2 = r1*-r2.xxxx + r1;\n"
             "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d5e6b64b:323bc96d:e3898f43:70f17049\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0006:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000005c1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.z = c0.z;\n"
           "    r0.x = dot(hg_ProgramLocal3, hg_TexCoord0);\n"
           "    r0.y = dot(hg_ProgramLocal4, hg_TexCoord0);\n"
           "    r0.xyz = r0.xyz - hg_ProgramLocal1.xyz;\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r0.xy = vec2(dot(r0.xyz, r0.xyz));\n"
           "    r0.xy = sqrt(r0.xy);\n"
           "    r1.xy = r0.xy*hg_ProgramLocal2.ww;\n"
           "    r1.xy = min(r1.xy, c0.xx);\n"
           "    r1.xy = hg_ProgramLocal5.xy*c0.zz + r1.xy;\n"
           "    r1 = texture2D(hg_Texture0, r1.xy);\n"
           "    r1.xyz = r1.xyz*r1.www;\n"
           "    r2.x = hg_ProgramLocal2.x - c0.y;\n"
           "    r2.x = max(r2.x, c0.z);\n"
           "    r2.x = clamp(r0.x - r2.x, 0.00000, 1.00000);\n"
           "    r2 = r1*-r2.xxxx + r1;\n"
           "    gl_FragColor = vec4(hg_ProgramLocal2.y == 0.00000 ? r1.x : r2.x, hg_ProgramLocal2.y == 0.00000 ? r1.y : r"
           "2.y, hg_ProgramLocal2.y == 0.00000 ? r1.z : r2.z, hg_ProgramLocal2.y == 0.00000 ? r1.w : r2.w);\n"
           "}\n"
           "//MD5=c9df8185:4b2e9f5c:f34b2e0b:0cf74b2f\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0006:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientRadialAffine::InitProgramDescriptor(HgcGradientRadialAffine *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientRadialAffine_hgc_visible", "//Metal1.0     \n//LEN=0000000445\n[[ visible ]] FragmentOut HgcGradientRadialAffine_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = c0.z;\n"
    "    r0.x = dot(hg_Params[3], texCoord0);\n"
    "    r0.y = dot(hg_Params[4], texCoord0);\n"
    "    r0.xyz = r0.xyz - hg_Params[1].xyz;\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
    "    r0.xy = sqrt(r0.xy);\n"
    "    r1.xy = r0.xy*hg_Params[2].ww;\n"
    "    r1.xy = fmin(r1.xy, c0.xx);\n"
    "    r1.xy = r1.xy*hg_Params[5].xy;\n"
    "    r1.xy = fmax(r1.xy, c0.yy);\n"
    "    r2.xy = hg_Params[5].xy - c0.yy;\n"
    "    r1.xy = fmin(r1.xy, r2.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
    "    r1.xyz = r1.xyz*r1.www;\n"
    "    r2.x = hg_Params[2].x - c0.y;\n"
    "    r2.x = fmax(r2.x, c0.z);\n"
    "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
    "    r2 = r1*-r2.xxxx + r1;\n"
    "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcGradientRadialAffine");
}

void sub_1B78F62C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78F6300(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78F62F8);
}

double HgcGradientRadialAffine::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376180;
  strcpy(v3, "HgcGradientRadialAffine [hgc1]");
  return *(double *)"ialAffine [hgc1]";
}

uint64_t HgcGradientRadialAffine::BindTexture(HgcGradientRadialAffine *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)a2 + 136))(a2, 5, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientRadialAffine::Bind(HgcGradientRadialAffine *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcGradientRadialAffine::RenderTile(HgcGradientRadialAffine *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    int v5 = a2[1].i32[0] - v2.i32[0];
    float32x2_t v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    *(float32x2_t *)v7.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v7.i64[1] = 0x3F80000000000000;
    int32x2_t v8 = a2[2];
    __asm { FMOV            V4.2S, #-1.0 }
    float32x2_t v14 = vadd_f32(v6, _D4);
    float32x2_t v15 = vadd_f32(v14, _D4);
    uint64_t v16 = (int8x16_t *)(*(void *)&v8 + 32);
    uint64_t v17 = 16 * a2[3].i32[0];
    while (v5 < 4)
    {
      LODWORD(v114) = 0;
      float32x4_t v20 = v7;
      if (v5 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      uint64_t v16 = (int8x16_t *)((char *)v16 + v17);
      *(void *)&v8 += v17;
      if (v4 == v3) {
        return 0;
      }
    }
    int v18 = 0;
    float32x4_t v19 = v16;
    float32x4_t v20 = v7;
    do
    {
      float32x4_t v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E736B0);
      uint64_t v23 = *((void *)this + 51);
      float32x4_t v24 = *(float32x4_t *)(v23 + 32);
      float32x4_t v25 = *(float32x4_t *)(v23 + 48);
      float32x4_t v26 = vaddq_f32(v22, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v27 = vmulq_f32(v20, v25);
      float32x4_t v28 = vmulq_f32(v21, v25);
      float32x4_t v29 = vmulq_f32(v22, v25);
      float32x4_t v30 = vmulq_f32(v26, v25);
      int8x16_t v31 = (int8x16_t)vaddq_f32(v27, (float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL));
      int8x16_t v32 = (int8x16_t)vaddq_f32(v28, (float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 4uLL));
      int8x16_t v33 = (int8x16_t)vaddq_f32(v29, (float32x4_t)vextq_s8((int8x16_t)v29, (int8x16_t)v29, 4uLL));
      int8x16_t v34 = (int8x16_t)vaddq_f32(v30, (float32x4_t)vextq_s8((int8x16_t)v30, (int8x16_t)v30, 4uLL));
      *(float32x2_t *)v31.i8 = vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
      *(float32x2_t *)v32.i8 = vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
      float32x4_t v36 = *(float32x4_t *)(v23 + 64);
      int8x16_t v35 = *(int8x16_t *)(v23 + 80);
      float32x4_t v37 = vmulq_f32(v20, v36);
      float32x4_t v38 = vmulq_f32(v21, v36);
      float32x4_t v39 = vmulq_f32(v22, v36);
      float32x4_t v40 = vmulq_f32(v26, v36);
      *(float32x2_t *)v33.i8 = vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
      float32x4_t v41 = vaddq_f32(v37, (float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 4uLL));
      float32x4_t v42 = vaddq_f32(v38, (float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 4uLL));
      float32x4_t v43 = vaddq_f32(v39, (float32x4_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 4uLL));
      float32x4_t v44 = vaddq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)v40, (int8x16_t)v40, 4uLL));
      *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
      float32x4_t v45 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v41, (float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v41, 8uLL)), v31);
      float32x4_t v46 = *(float32x4_t *)(v23 + 16);
      float32x4_t v47 = vsubq_f32(v45, v46);
      float32x4_t v48 = vsubq_f32((float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v42, (float32x4_t)vextq_s8((int8x16_t)v42, (int8x16_t)v42, 8uLL)), v32), v46);
      float32x4_t v49 = vsubq_f32((float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v43, (float32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v43, 8uLL)), v33), v46);
      float32x4_t v50 = vsubq_f32((float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v44, (float32x4_t)vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL)), v34), v46);
      int8x16_t v51 = *(int8x16_t *)(v23 + 96);
      float32x4_t v52 = *(float32x4_t *)(v23 + 112);
      float32x4_t v53 = (float32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(*(float32x4_t *)v23, v47), (int8x16_t)v47);
      float32x4_t v54 = (float32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(*(float32x4_t *)v23, v48), (int8x16_t)v48);
      float32x4_t v55 = (float32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(*(float32x4_t *)v23, v49), (int8x16_t)v49);
      float32x4_t v56 = (float32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(*(float32x4_t *)v23, v50), (int8x16_t)v50);
      int32x4_t v57 = (int32x4_t)vmulq_f32(v53, v53);
      int32x4_t v58 = (int32x4_t)vmulq_f32(v54, v54);
      int32x4_t v59 = (int32x4_t)vmulq_f32(v55, v55);
      int32x4_t v60 = (int32x4_t)vmulq_f32(v56, v56);
      float32x4_t v61 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.i8, 1)));
      float32x4_t v62 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v58, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.i8, 1)));
      float32x4_t v63 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v59, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.i8, 1)));
      float32x4_t v64 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v60, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.i8, 1)));
      float32x4_t v65 = vminq_f32(vrsqrteq_f32(v61), v52);
      float32x4_t v66 = vminq_f32(vrsqrteq_f32(v62), v52);
      float32x4_t v67 = vminq_f32(vrsqrteq_f32(v63), v52);
      float32x4_t v68 = vminq_f32(vrsqrteq_f32(v64), v52);
      float32x4_t v69 = vminq_f32(vmulq_f32(v65, vrsqrtsq_f32(vmulq_f32(v65, v61), v65)), v52);
      float32x4_t v70 = vminq_f32(vmulq_f32(v66, vrsqrtsq_f32(vmulq_f32(v66, v62), v66)), v52);
      float32x4_t v71 = vminq_f32(vmulq_f32(v67, vrsqrtsq_f32(vmulq_f32(v67, v63), v67)), v52);
      float32x4_t v72 = vminq_f32(vmulq_f32(v68, vrsqrtsq_f32(vmulq_f32(v68, v64), v68)), v52);
      float32x4_t v73 = vmulq_f32(v61, vminq_f32(vmulq_f32(v69, vrsqrtsq_f32(vmulq_f32(v69, v61), v69)), v52));
      float32x4_t v74 = vmulq_f32(v62, vminq_f32(vmulq_f32(v70, vrsqrtsq_f32(vmulq_f32(v70, v62), v70)), v52));
      float32x4_t v75 = vmulq_f32(v63, vminq_f32(vmulq_f32(v71, vrsqrtsq_f32(vmulq_f32(v71, v63), v71)), v52));
      int32x2_t v76 = a2[10];
      float32x4_t v77 = vmulq_f32(v64, vminq_f32(vmulq_f32(v72, vrsqrtsq_f32(vmulq_f32(v64, v72), v72)), v52));
      uint64_t v78 = a2[11].i32[0];
      float32x4_t v79 = *(float32x4_t *)(v23 + 128);
      int8x16_t v80 = *(int8x16_t *)(v23 + 144);
      *(float32x2_t *)v64.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v73.f32, v24, 3), *(float32x2_t *)v79.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      int v81 = v78 + 1;
      *(int32x2_t *)v72.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v64.f32, v15));
      *(float32x2_t *)v51.i8 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v74.f32, v24, 3), *(float32x2_t *)v79.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v82 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v51.i8, v15));
      *(float32x2_t *)v64.f32 = vsub_f32(*(float32x2_t *)v64.f32, vcvt_f32_s32(*(int32x2_t *)v72.f32));
      *(int32x2_t *)v52.f32 = vdup_n_s32(v78);
      *(int32x2_t *)v72.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v72.f32, v82), vzip2_s32(*(int32x2_t *)v72.f32, v82), *(int32x2_t *)v52.f32);
      *(float32x2_t *)v51.i8 = vsub_f32(*(float32x2_t *)v51.i8, vcvt_f32_s32(v82));
      uint64_t v83 = (float32x4_t *)(*(void *)&v76 + 16 * v72.i32[0]);
      v78 *= 16;
      uint64_t v84 = v81;
      float32x4_t v85 = (float32x4_t *)(*(void *)&v76 + 16 * v72.i32[1]);
      float32x2_t v86 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v75.f32, v24, 3), *(float32x2_t *)v79.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v87 = vcvt_s32_f32(vmin_f32(v86, v15));
      float32x4_t v88 = vaddq_f32(*v83, vmulq_n_f32(vsubq_f32(v83[1], *v83), v64.f32[0]));
      float32x2_t v89 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v77.f32, v24, 3), *(float32x2_t *)v79.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v90 = vcvt_s32_f32(vmin_f32(v89, v15));
      int32x2_t v91 = vmla_s32(vzip1_s32(v87, v90), vzip2_s32(v87, v90), *(int32x2_t *)v52.f32);
      float32x4_t v92 = vaddq_f32(*v85, vmulq_n_f32(vsubq_f32(v85[1], *v85), *(float *)v51.i32));
      float32x2_t v93 = vsub_f32(v86, vcvt_f32_s32(v87));
      float32x4_t v94 = vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v83 + v78), vmulq_n_f32(vsubq_f32(v83[v84], *(float32x4_t *)((char *)v83 + v78)), v64.f32[0])), v88);
      float32x2_t v95 = vsub_f32(v89, vcvt_f32_s32(v90));
      int8x16_t v96 = (float32x4_t *)(*(void *)&v76 + 16 * v91.i32[0]);
      float32x4_t v97 = vaddq_f32(v88, vmulq_lane_f32(v94, *(float32x2_t *)v64.f32, 1));
      float32x4_t v98 = vaddq_f32(*v96, vmulq_n_f32(vsubq_f32(v96[1], *v96), v93.f32[0]));
      int8x16_t v99 = (float32x4_t *)(*(void *)&v76 + 16 * v91.i32[1]);
      float32x4_t v100 = vaddq_f32(v92, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v85 + v78), vmulq_n_f32(vsubq_f32(v85[v84], *(float32x4_t *)((char *)v85 + v78)), *(float *)v51.i32)), v92), *(float32x2_t *)v51.i8, 1));
      float32x4_t v101 = vaddq_f32(*v99, vmulq_n_f32(vsubq_f32(v99[1], *v99), v95.f32[0]));
      float32x4_t v102 = vaddq_f32(v98, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v96 + v78), vmulq_n_f32(vsubq_f32(v96[v84], *(float32x4_t *)((char *)v96 + v78)), v93.f32[0])), v98), v93, 1));
      float32x4_t v103 = vaddq_f32(v101, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v99 + v78), vmulq_n_f32(vsubq_f32(v99[v84], *(float32x4_t *)((char *)v99 + v78)), v95.f32[0])), v101), v95, 1));
      float32x4_t v104 = (float32x4_t)vbslq_s8(v80, (int8x16_t)v97, (int8x16_t)vmulq_laneq_f32(v97, v97, 3));
      float32x4_t v105 = *(float32x4_t *)(v23 + 176);
      float32x4_t v106 = (float32x4_t)vbslq_s8(v80, (int8x16_t)v100, (int8x16_t)vmulq_laneq_f32(v100, v100, 3));
      float32x4_t v107 = vmaxq_f32(vsubq_f32(v24, *(float32x4_t *)(v23 + 160)), v105);
      float32x4_t v108 = (float32x4_t)vbslq_s8(v80, (int8x16_t)v102, (int8x16_t)vmulq_laneq_f32(v102, v102, 3));
      v73.i32[0] = vminq_f32(vmaxq_f32(vsubq_f32(v73, v107), v105), v79).u32[0];
      float32x4_t v109 = (float32x4_t)vbslq_s8(v80, (int8x16_t)v103, (int8x16_t)vmulq_laneq_f32(v103, v103, 3));
      int8x16_t v110 = (int8x16_t)vsubq_f32(v106, vmulq_n_f32(v106, vminq_f32(vmaxq_f32(vsubq_f32(v74, v107), v105), v79).f32[0]));
      int8x16_t v111 = (int8x16_t)vsubq_f32(v108, vmulq_n_f32(v108, vminq_f32(vmaxq_f32(vsubq_f32(v75, v107), v105), v79).f32[0]));
      int8x16_t v112 = (int8x16_t)vsubq_f32(v109, vmulq_n_f32(v109, vminq_f32(vmaxq_f32(vsubq_f32(v77, v107), v105), v79).f32[0]));
      int8x16_t v113 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v79, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1), v105)), v105);
      v19[-2] = vbslq_s8(v113, (int8x16_t)v104, (int8x16_t)vsubq_f32(v104, vmulq_n_f32(v104, v73.f32[0])));
      v19[-1] = vbslq_s8(v113, (int8x16_t)v106, v110);
      *float32x4_t v19 = vbslq_s8(v113, (int8x16_t)v108, v111);
      v19[1] = vbslq_s8(v113, (int8x16_t)v109, v112);
      v19 += 4;
      float32x4_t v20 = vaddq_f32(v26, (float32x4_t)xmmword_1B7E736B0);
      v18 -= 4;
    }
    while (v5 + v18 > 3);
    LODWORD(v114) = -v18;
    if ((int)v114 >= v5) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v114 = v114;
    do
    {
      uint64_t v115 = *((void *)this + 51);
      float32x4_t v116 = *(float32x4_t *)(v115 + 32);
      float32x4_t v117 = vmulq_f32(v20, *(float32x4_t *)(v115 + 48));
      int8x16_t v118 = (int8x16_t)vaddq_f32(v117, (float32x4_t)vextq_s8((int8x16_t)v117, (int8x16_t)v117, 4uLL));
      *(float32x2_t *)v118.i8 = vadd_f32(*(float32x2_t *)v118.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v118, v118, 8uLL));
      float32x4_t v119 = vmulq_f32(v20, *(float32x4_t *)(v115 + 64));
      float32x4_t v120 = vaddq_f32(v119, (float32x4_t)vextq_s8((int8x16_t)v119, (int8x16_t)v119, 4uLL));
      float32x4_t v121 = vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v115 + 80), (int8x16_t)vaddq_f32(v120, (float32x4_t)vextq_s8((int8x16_t)v120, (int8x16_t)v120, 8uLL)), v118), *(float32x4_t *)(v115 + 16));
      float32x4_t v122 = *(float32x4_t *)(v115 + 112);
      float32x4_t v123 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v115 + 96), (int8x16_t)vmulq_f32(*(float32x4_t *)v115, v121), (int8x16_t)v121);
      int32x4_t v124 = (int32x4_t)vmulq_f32(v123, v123);
      float32x4_t v125 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v124, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v124.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v124.i8, 1)));
      float32x4_t v126 = vminq_f32(vrsqrteq_f32(v125), v122);
      float32x4_t v127 = vminq_f32(vmulq_f32(v126, vrsqrtsq_f32(vmulq_f32(v126, v125), v126)), v122);
      float32x4_t v128 = vmulq_f32(vminq_f32(vmulq_f32(v127, vrsqrtsq_f32(vmulq_f32(v127, v125), v127)), v122), v125);
      float32x4_t v129 = *(float32x4_t *)(v115 + 128);
      uint64_t v130 = a2[11].i32[0];
      *(float32x2_t *)v127.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v128.f32, v116, 3), *(float32x2_t *)v129.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v131 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v127.f32, v15));
      *(float32x2_t *)v127.f32 = vsub_f32(*(float32x2_t *)v127.f32, vcvt_f32_s32(v131));
      v132 = (float32x4_t *)(*(void *)&a2[10] + 16 * (v131.i32[0] + v131.i32[1] * (int)v130));
      float32x4_t v133 = vaddq_f32(*v132, vmulq_n_f32(vsubq_f32(v132[1], *v132), v127.f32[0]));
      float32x4_t v134 = vaddq_f32(v133, vmulq_lane_f32(vsubq_f32(vaddq_f32(v132[v130], vmulq_n_f32(vsubq_f32(v132[(int)v130 + 1], v132[v130]), v127.f32[0])), v133), *(float32x2_t *)v127.f32, 1));
      float32x4_t v135 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v115 + 144), (int8x16_t)v134, (int8x16_t)vmulq_laneq_f32(v134, v134, 3));
      *(float32x4_t *)(*(void *)&v8 + 16 * v114) = vsubq_f32(v135, (float32x4_t)vbicq_s8((int8x16_t)vmulq_n_f32(v135, vminq_f32(vmaxq_f32(vsubq_f32(v128, vmaxq_f32(vsubq_f32(v116, *(float32x4_t *)(v115 + 160)), *(float32x4_t *)(v115 + 176))), *(float32x4_t *)(v115 + 176)), v129).f32[0]), (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v129, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v116.f32, 1), *(float32x4_t *)(v115 + 176))),
                                                                                   *(float32x4_t *)(v115 + 176))));
      float32x4_t v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      ++v114;
    }
    while (v114 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientRadialAffine::GetDOD(HgcGradientRadialAffine *this, HGRenderer *a2, int a3, HGRect a4)
{
  int v4 = &HGRectInfinite;
  if (a3) {
    int v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcGradientRadialAffine::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientRadialAffine::HgcGradientRadialAffine(HgcGradientRadialAffine *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EC3F0;
  operator new();
}

void sub_1B78F6E50(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientRadialAffine::~HgcGradientRadialAffine(HGNode *this)
{
  *(void *)this = &unk_1F10EC3F0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EC3F0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcGradientRadialAffine::SetParameter(HgcGradientRadialAffine *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int32x2_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int32x2_t v8 = a3;
  int v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientRadialAffine::GetParameter(HgcGradientRadialAffine *this, unsigned int a2, float *a3)
{
  if (a2 > 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientRadialIdentity::GetProgram(HgcGradientRadialIdentity *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004f3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xyz = frag._texCoord0.xyz - hg_Params[1].xyz;\n"
             "    s0.x = s0.x*hg_Params[0].x;\n"
             "    s0.xy = float2(dot(s0.xyz, s0.xyz));\n"
             "    s0.xy = sqrt(s0.xy);\n"
             "    s1.xy = s0.xy*hg_Params[2].ww;\n"
             "    s1.xy = fmin(s1.xy, float2(c0.xx));\n"
             "    s1.xy = s1.xy*hg_Params[3].xy;\n"
             "    s1.xy = fmax(s1.xy, float2(c0.yy));\n"
             "    s2.xy = hg_Params[3].xy - float2(c0.yy);\n"
             "    s1.xy = fmin(s1.xy, s2.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s1.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    r1.x = half(hg_Params[2].x) - c0.y;\n"
             "    r1.x = fmax(r1.x, c0.z);\n"
             "    s0.x = clamp(s0.x - float(r1.x), 0.00000f, 1.00000f);\n"
             "    s0 = float4(r0)*-s0.xxxx + float4(r0);\n"
             "    output.color0 = select(s0, float4(r0), hg_Params[2].yyyy == 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c95cbf95:9c3091f5:7f2eee20:db8d59e4\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0004:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000049f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = frag._texCoord0.xyz - hg_Params[1].xyz;\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
             "    r0.xy = sqrt(r0.xy);\n"
             "    r1.xy = r0.xy*hg_Params[2].ww;\n"
             "    r1.xy = fmin(r1.xy, c0.xx);\n"
             "    r1.xy = r1.xy*hg_Params[3].xy;\n"
             "    r1.xy = fmax(r1.xy, c0.yy);\n"
             "    r2.xy = hg_Params[3].xy - c0.yy;\n"
             "    r1.xy = fmin(r1.xy, r2.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    r2.x = hg_Params[2].x - c0.y;\n"
             "    r2.x = fmax(r2.x, c0.z);\n"
             "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
             "    r2 = r1*-r2.xxxx + r1;\n"
             "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fbc4a517:d5b8985a:eb4412b3:5f5c023b\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000510\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.xyz = hg_TexCoord0.xyz - hg_ProgramLocal1.xyz;\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r0.xy = vec2(dot(r0.xyz, r0.xyz));\n"
           "    r0.xy = sqrt(r0.xy);\n"
           "    r1.xy = r0.xy*hg_ProgramLocal2.ww;\n"
           "    r1.xy = min(r1.xy, c0.xx);\n"
           "    r1.xy = hg_ProgramLocal3.xy*c0.yy + r1.xy;\n"
           "    r1 = texture2D(hg_Texture0, r1.xy);\n"
           "    r1.xyz = r1.xyz*r1.www;\n"
           "    r2.x = hg_ProgramLocal2.x - c0.z;\n"
           "    r2.x = max(r2.x, c0.y);\n"
           "    r2.x = clamp(r0.x - r2.x, 0.00000, 1.00000);\n"
           "    r2 = r1*-r2.xxxx + r1;\n"
           "    gl_FragColor = vec4(hg_ProgramLocal2.y == 0.00000 ? r1.x : r2.x, hg_ProgramLocal2.y == 0.00000 ? r1.y : r"
           "2.y, hg_ProgramLocal2.y == 0.00000 ? r1.z : r2.z, hg_ProgramLocal2.y == 0.00000 ? r1.w : r2.w);\n"
           "}\n"
           "//MD5=a69acbca:061caa14:e70c4662:94856247\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0004:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientRadialIdentity::InitProgramDescriptor(HgcGradientRadialIdentity *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientRadialIdentity_hgc_visible", "//Metal1.0     \n//LEN=00000003eb\n[[ visible ]] FragmentOut HgcGradientRadialIdentity_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = texCoord0.xyz - hg_Params[1].xyz;\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
    "    r0.xy = sqrt(r0.xy);\n"
    "    r1.xy = r0.xy*hg_Params[2].ww;\n"
    "    r1.xy = fmin(r1.xy, c0.xx);\n"
    "    r1.xy = r1.xy*hg_Params[3].xy;\n"
    "    r1.xy = fmax(r1.xy, c0.yy);\n"
    "    r2.xy = hg_Params[3].xy - c0.yy;\n"
    "    r1.xy = fmin(r1.xy, r2.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
    "    r1.xyz = r1.xyz*r1.www;\n"
    "    r2.x = hg_Params[2].x - c0.y;\n"
    "    r2.x = fmax(r2.x, c0.z);\n"
    "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
    "    r2 = r1*-r2.xxxx + r1;\n"
    "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcGradientRadialIdentity");
}

void sub_1B78F7420(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78F7458(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78F7450);
}

char *HgcGradientRadialIdentity::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B83761D0;
  strcpy(result, "HgcGradientRadialIdentity [hgc1]");
  return result;
}

uint64_t HgcGradientRadialIdentity::BindTexture(HgcGradientRadialIdentity *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)a2 + 136))(a2, 3, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientRadialIdentity::Bind(HgcGradientRadialIdentity *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcGradientRadialIdentity::RenderTile(HgcGradientRadialIdentity *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    int v5 = a2[1].i32[0] - v2.i32[0];
    float32x2_t v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    *(float32x2_t *)v7.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v7.i64[1] = 0x3F80000000000000;
    int32x2_t v8 = a2[2];
    __asm { FMOV            V4.2S, #-1.0 }
    float32x2_t v14 = vadd_f32(v6, _D4);
    float32x2_t v15 = vadd_f32(v14, _D4);
    uint64_t v16 = (int8x16_t *)(*(void *)&v8 + 32);
    uint64_t v17 = 16 * a2[3].i32[0];
    while (v5 < 4)
    {
      LODWORD(v90) = 0;
      float32x4_t v20 = v7;
      if (v5 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      uint64_t v16 = (int8x16_t *)((char *)v16 + v17);
      *(void *)&v8 += v17;
      if (v4 == v3) {
        return 0;
      }
    }
    int v18 = 0;
    float32x4_t v19 = v16;
    float32x4_t v20 = v7;
    do
    {
      float32x4_t v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v22 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v23 = vaddq_f32(v22, (float32x4_t)xmmword_1B7E736B0);
      uint64_t v24 = *((void *)this + 51);
      float32x4_t v25 = *(float32x4_t *)(v24 + 16);
      float32x4_t v26 = vsubq_f32(v20, v25);
      float32x4_t v27 = vsubq_f32(v21, v25);
      float32x4_t v28 = vsubq_f32(v22, v25);
      float32x4_t v29 = vsubq_f32(v23, v25);
      float32x4_t v30 = *(float32x4_t *)(v24 + 32);
      int8x16_t v31 = *(int8x16_t *)(v24 + 48);
      float32x4_t v32 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vmulq_f32(v26, *(float32x4_t *)v24), (int8x16_t)v26);
      float32x4_t v33 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vmulq_f32(v27, *(float32x4_t *)v24), (int8x16_t)v27);
      float32x4_t v34 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vmulq_f32(v28, *(float32x4_t *)v24), (int8x16_t)v28);
      float32x4_t v35 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vmulq_f32(v29, *(float32x4_t *)v24), (int8x16_t)v29);
      int32x4_t v36 = (int32x4_t)vmulq_f32(v32, v32);
      int32x4_t v37 = (int32x4_t)vmulq_f32(v33, v33);
      int32x4_t v38 = (int32x4_t)vmulq_f32(v34, v34);
      int32x4_t v39 = (int32x4_t)vmulq_f32(v35, v35);
      float32x4_t v40 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v36, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.i8, 1)));
      float32x4_t v41 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v37, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.i8, 1)));
      float32x4_t v42 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v38, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.i8, 1)));
      float32x4_t v43 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v39, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.i8, 1)));
      float32x4_t v45 = *(float32x4_t *)(v24 + 64);
      float32x4_t v44 = *(float32x4_t *)(v24 + 80);
      float32x4_t v46 = vminq_f32(vrsqrteq_f32(v40), v45);
      float32x4_t v47 = vminq_f32(vrsqrteq_f32(v41), v45);
      float32x4_t v48 = vminq_f32(vrsqrteq_f32(v42), v45);
      float32x4_t v49 = vminq_f32(vrsqrteq_f32(v43), v45);
      float32x4_t v50 = vminq_f32(vmulq_f32(v46, vrsqrtsq_f32(vmulq_f32(v46, v40), v46)), v45);
      float32x4_t v51 = vminq_f32(vmulq_f32(v47, vrsqrtsq_f32(vmulq_f32(v47, v41), v47)), v45);
      float32x4_t v52 = vminq_f32(vmulq_f32(v48, vrsqrtsq_f32(vmulq_f32(v48, v42), v48)), v45);
      float32x4_t v53 = vminq_f32(vmulq_f32(v49, vrsqrtsq_f32(vmulq_f32(v43, v49), v49)), v45);
      float32x4_t v54 = vminq_f32(vmulq_f32(v51, vrsqrtsq_f32(vmulq_f32(v41, v51), v51)), v45);
      float32x4_t v55 = vmulq_f32(v40, vminq_f32(vmulq_f32(v50, vrsqrtsq_f32(vmulq_f32(v40, v50), v50)), v45));
      float32x4_t v56 = vmulq_f32(v41, v54);
      float32x4_t v57 = vmulq_f32(v42, vminq_f32(vmulq_f32(v52, vrsqrtsq_f32(vmulq_f32(v42, v52), v52)), v45));
      float32x4_t v58 = vmulq_f32(v43, vminq_f32(vmulq_f32(v53, vrsqrtsq_f32(vmulq_f32(v43, v53), v53)), v45));
      int32x2_t v59 = a2[10];
      uint64_t v60 = a2[11].i32[0];
      *(float32x2_t *)v41.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v55.f32, v30, 3), *(float32x2_t *)v44.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v52.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v41.f32, v15));
      int v61 = v60 + 1;
      *(float32x2_t *)v43.f32 = vsub_f32(*(float32x2_t *)v41.f32, vcvt_f32_s32(*(int32x2_t *)v52.f32));
      *(float32x2_t *)v41.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v56.f32, v30, 3), *(float32x2_t *)v44.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v53.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v41.f32, v15));
      *(float32x2_t *)v41.f32 = vsub_f32(*(float32x2_t *)v41.f32, vcvt_f32_s32(*(int32x2_t *)v53.f32));
      *(int32x2_t *)v45.f32 = vdup_n_s32(v60);
      *(int32x2_t *)v52.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v52.f32, *(int32x2_t *)v53.f32), vzip2_s32(*(int32x2_t *)v52.f32, *(int32x2_t *)v53.f32), *(int32x2_t *)v45.f32);
      float32x4_t v62 = (float32x4_t *)(*(void *)&v59 + 16 * v52.i32[0]);
      v60 *= 16;
      uint64_t v63 = v61;
      float32x4_t v64 = (float32x4_t *)(*(void *)&v59 + 16 * v52.i32[1]);
      float32x2_t v65 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v57.f32, v30, 3), *(float32x2_t *)v44.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v66 = vcvt_s32_f32(vmin_f32(v65, v15));
      float32x2_t v67 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v58.f32, v30, 3), *(float32x2_t *)v44.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      float32x4_t v68 = vaddq_f32(*v62, vmulq_n_f32(vsubq_f32(v62[1], *v62), v43.f32[0]));
      *(int32x2_t *)v53.f32 = vcvt_s32_f32(vmin_f32(v67, v15));
      int32x2_t v69 = vmla_s32(vzip1_s32(v66, *(int32x2_t *)v53.f32), vzip2_s32(v66, *(int32x2_t *)v53.f32), *(int32x2_t *)v45.f32);
      float32x4_t v70 = vaddq_f32(*v64, vmulq_n_f32(vsubq_f32(v64[1], *v64), v41.f32[0]));
      float32x2_t v71 = vsub_f32(v65, vcvt_f32_s32(v66));
      float32x4_t v72 = vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v62 + v60), vmulq_n_f32(vsubq_f32(v62[v63], *(float32x4_t *)((char *)v62 + v60)), v43.f32[0])), v68);
      *(float32x2_t *)v53.f32 = vsub_f32(v67, vcvt_f32_s32(*(int32x2_t *)v53.f32));
      float32x4_t v73 = (float32x4_t *)(*(void *)&v59 + 16 * v69.i32[0]);
      float32x4_t v74 = vmulq_lane_f32(v72, *(float32x2_t *)v43.f32, 1);
      float32x4_t v75 = vaddq_f32(*v73, vmulq_n_f32(vsubq_f32(v73[1], *v73), v71.f32[0]));
      float32x4_t v76 = vaddq_f32(v68, v74);
      float32x4_t v77 = (float32x4_t *)(*(void *)&v59 + 16 * v69.i32[1]);
      float32x4_t v78 = vaddq_f32(*v77, vmulq_n_f32(vsubq_f32(v77[1], *v77), v53.f32[0]));
      float32x4_t v79 = vaddq_f32(v70, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v64 + v60), vmulq_n_f32(vsubq_f32(v64[v63], *(float32x4_t *)((char *)v64 + v60)), v41.f32[0])), v70), *(float32x2_t *)v41.f32, 1));
      float32x4_t v80 = vaddq_f32(v75, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v73 + v60), vmulq_n_f32(vsubq_f32(v73[v63], *(float32x4_t *)((char *)v73 + v60)), v71.f32[0])), v75), v71, 1));
      float32x4_t v81 = vaddq_f32(v78, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v77 + v60), vmulq_n_f32(vsubq_f32(v77[v63], *(float32x4_t *)((char *)v77 + v60)), v53.f32[0])), v78), *(float32x2_t *)v53.f32, 1));
      int8x16_t v82 = *(int8x16_t *)(v24 + 96);
      float32x4_t v83 = (float32x4_t)vbslq_s8(v82, (int8x16_t)v76, (int8x16_t)vmulq_laneq_f32(v76, v76, 3));
      float32x4_t v84 = *(float32x4_t *)(v24 + 128);
      float32x4_t v85 = (float32x4_t)vbslq_s8(v82, (int8x16_t)v79, (int8x16_t)vmulq_laneq_f32(v79, v79, 3));
      float32x4_t v86 = vmaxq_f32(vsubq_f32(v30, *(float32x4_t *)(v24 + 112)), v84);
      float32x4_t v87 = (float32x4_t)vbslq_s8(v82, (int8x16_t)v80, (int8x16_t)vmulq_laneq_f32(v80, v80, 3));
      float32x4_t v88 = (float32x4_t)vbslq_s8(v82, (int8x16_t)v81, (int8x16_t)vmulq_laneq_f32(v81, v81, 3));
      int8x16_t v89 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v44, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1), v84)), v84);
      v19[-2] = vbslq_s8(v89, (int8x16_t)v83, (int8x16_t)vsubq_f32(v83, vmulq_n_f32(v83, vminq_f32(vmaxq_f32(vsubq_f32(v55, v86), v84), v44).f32[0])));
      v19[-1] = vbslq_s8(v89, (int8x16_t)v85, (int8x16_t)vsubq_f32(v85, vmulq_n_f32(v85, vminq_f32(vmaxq_f32(vsubq_f32(v56, v86), v84), v44).f32[0])));
      *float32x4_t v19 = vbslq_s8(v89, (int8x16_t)v87, (int8x16_t)vsubq_f32(v87, vmulq_n_f32(v87, vminq_f32(vmaxq_f32(vsubq_f32(v57, v86), v84), v44).f32[0])));
      v19[1] = vbslq_s8(v89, (int8x16_t)v88, (int8x16_t)vsubq_f32(v88, vmulq_n_f32(v88, vminq_f32(vmaxq_f32(vsubq_f32(v58, v86), v84), v44).f32[0])));
      v19 += 4;
      float32x4_t v20 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E736B0);
      v18 -= 4;
    }
    while (v5 + v18 > 3);
    LODWORD(v90) = -v18;
    if ((int)v90 >= v5) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v90 = v90;
    do
    {
      uint64_t v91 = *((void *)this + 51);
      float32x4_t v92 = vsubq_f32(v20, *(float32x4_t *)(v91 + 16));
      float32x4_t v93 = *(float32x4_t *)(v91 + 32);
      float32x4_t v94 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v91 + 48), (int8x16_t)vmulq_f32(v92, *(float32x4_t *)v91), (int8x16_t)v92);
      int32x4_t v95 = (int32x4_t)vmulq_f32(v94, v94);
      float32x4_t v96 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v95, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v95.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v95.i8, 1)));
      float32x4_t v97 = *(float32x4_t *)(v91 + 64);
      float32x4_t v98 = *(float32x4_t *)(v91 + 80);
      float32x4_t v99 = vminq_f32(vrsqrteq_f32(v96), v97);
      float32x4_t v100 = vminq_f32(vmulq_f32(v99, vrsqrtsq_f32(vmulq_f32(v99, v96), v99)), v97);
      float32x4_t v101 = vmulq_f32(vminq_f32(vmulq_f32(v100, vrsqrtsq_f32(vmulq_f32(v100, v96), v100)), v97), v96);
      *(float32x2_t *)v100.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v101.f32, v93, 3), *(float32x2_t *)v98.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      uint64_t v102 = a2[11].i32[0];
      *(int32x2_t *)v97.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v100.f32, v15));
      *(float32x2_t *)v100.f32 = vsub_f32(*(float32x2_t *)v100.f32, vcvt_f32_s32(*(int32x2_t *)v97.f32));
      float32x4_t v103 = (float32x4_t *)(*(void *)&a2[10] + 16 * (v97.i32[0] + v97.i32[1] * (int)v102));
      float32x4_t v104 = vaddq_f32(*v103, vmulq_n_f32(vsubq_f32(v103[1], *v103), v100.f32[0]));
      float32x4_t v105 = vaddq_f32(v104, vmulq_lane_f32(vsubq_f32(vaddq_f32(v103[v102], vmulq_n_f32(vsubq_f32(v103[(int)v102 + 1], v103[v102]), v100.f32[0])), v104), *(float32x2_t *)v100.f32, 1));
      float32x4_t v106 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v91 + 96), (int8x16_t)v105, (int8x16_t)vmulq_laneq_f32(v105, v105, 3));
      *(float32x4_t *)(*(void *)&v8 + 16 * v90) = vsubq_f32(v106, (float32x4_t)vbicq_s8((int8x16_t)vmulq_n_f32(v106, vminq_f32(vmaxq_f32(vsubq_f32(v101, vmaxq_f32(vsubq_f32(v93, *(float32x4_t *)(v91 + 112)), *(float32x4_t *)(v91 + 128))), *(float32x4_t *)(v91 + 128)), v98).f32[0]), (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v98, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v93.f32, 1), *(float32x4_t *)(v91 + 128))),
                                                                                  *(float32x4_t *)(v91 + 128))));
      float32x4_t v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      ++v90;
    }
    while (v90 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientRadialIdentity::GetDOD(HgcGradientRadialIdentity *this, HGRenderer *a2, int a3, HGRect a4)
{
  int v4 = &HGRectInfinite;
  if (a3) {
    int v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcGradientRadialIdentity::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientRadialIdentity::HgcGradientRadialIdentity(HgcGradientRadialIdentity *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EC658;
  operator new();
}

void sub_1B78F7E34(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientRadialIdentity::~HgcGradientRadialIdentity(HGNode *this)
{
  *(void *)this = &unk_1F10EC658;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40265AC83CLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EC658;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40265AC83CLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcGradientRadialIdentity::SetParameter(HgcGradientRadialIdentity *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int32x2_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int32x2_t v8 = a3;
  int v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientRadialIdentity::GetParameter(HgcGradientRadialIdentity *this, unsigned int a2, float *a3)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientRadialPerspective::GetProgram(HgcGradientRadialPerspective *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000005cf\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(half4(hg_Params[3]), half4(frag._texCoord0));\n"
             "    r0.y = dot(half4(hg_Params[4]), half4(frag._texCoord0));\n"
             "    r0.w = dot(half4(hg_Params[5]), half4(frag._texCoord0));\n"
             "    r0.xy = r0.xy/r0.ww;\n"
             "    s0.xyz = float3(r0.xyz) - hg_Params[1].xyz;\n"
             "    s0.x = s0.x*hg_Params[0].x;\n"
             "    s0.xy = float2(dot(s0.xyz, s0.xyz));\n"
             "    s0.xy = sqrt(s0.xy);\n"
             "    s1.xy = s0.xy*hg_Params[2].ww;\n"
             "    s1.xy = fmin(s1.xy, float2(c0.xx));\n"
             "    s1.xy = s1.xy*hg_Params[6].xy;\n"
             "    s1.xy = fmax(s1.xy, float2(c0.yy));\n"
             "    s2.xy = hg_Params[6].xy - float2(c0.yy);\n"
             "    s1.xy = fmin(s1.xy, s2.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s1.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    r1.x = half(hg_Params[2].x) - c0.y;\n"
             "    r1.x = fmax(r1.x, c0.z);\n"
             "    s0.x = clamp(s0.x - float(r1.x), 0.00000f, 1.00000f);\n"
             "    s0 = float4(r0)*-s0.xxxx + float4(r0);\n"
             "    output.color0 = select(s0, float4(r0), hg_Params[2].yyyy == 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=4fc58a1d:f2a56d04:45f3c20f:c91b4cbb\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0007:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000549\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = dot(hg_Params[3], frag._texCoord0);\n"
             "    r0.y = dot(hg_Params[4], frag._texCoord0);\n"
             "    r0.w = dot(hg_Params[5], frag._texCoord0);\n"
             "    r0.xy = r0.xy/r0.ww;\n"
             "    r0.xyz = r0.xyz - hg_Params[1].xyz;\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
             "    r0.xy = sqrt(r0.xy);\n"
             "    r1.xy = r0.xy*hg_Params[2].ww;\n"
             "    r1.xy = fmin(r1.xy, c0.xx);\n"
             "    r1.xy = r1.xy*hg_Params[6].xy;\n"
             "    r1.xy = fmax(r1.xy, c0.yy);\n"
             "    r2.xy = hg_Params[6].xy - c0.yy;\n"
             "    r1.xy = fmin(r1.xy, r2.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    r2.x = hg_Params[2].x - c0.y;\n"
             "    r2.x = fmax(r2.x, c0.z);\n"
             "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
             "    r2 = r1*-r2.xxxx + r1;\n"
             "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5122a7df:2cdb5da5:cb8625a9:cbdcfae0\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0007:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000062f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.z = c0.z;\n"
           "    r0.x = dot(hg_ProgramLocal3, hg_TexCoord0);\n"
           "    r0.y = dot(hg_ProgramLocal4, hg_TexCoord0);\n"
           "    r0.w = dot(hg_ProgramLocal5, hg_TexCoord0);\n"
           "    r0.xy = r0.xy/r0.ww;\n"
           "    r0.xyz = r0.xyz - hg_ProgramLocal1.xyz;\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r0.xy = vec2(dot(r0.xyz, r0.xyz));\n"
           "    r0.xy = sqrt(r0.xy);\n"
           "    r1.xy = r0.xy*hg_ProgramLocal2.ww;\n"
           "    r1.xy = min(r1.xy, c0.xx);\n"
           "    r1.xy = hg_ProgramLocal6.xy*c0.zz + r1.xy;\n"
           "    r1 = texture2D(hg_Texture0, r1.xy);\n"
           "    r1.xyz = r1.xyz*r1.www;\n"
           "    r2.x = hg_ProgramLocal2.x - c0.y;\n"
           "    r2.x = max(r2.x, c0.z);\n"
           "    r2.x = clamp(r0.x - r2.x, 0.00000, 1.00000);\n"
           "    r2 = r1*-r2.xxxx + r1;\n"
           "    gl_FragColor = vec4(hg_ProgramLocal2.y == 0.00000 ? r1.x : r2.x, hg_ProgramLocal2.y == 0.00000 ? r1.y : r"
           "2.y, hg_ProgramLocal2.y == 0.00000 ? r1.z : r2.z, hg_ProgramLocal2.y == 0.00000 ? r1.w : r2.w);\n"
           "}\n"
           "//MD5=7d877a02:a9145601:4fed2dba:0c2241bf\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0007:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientRadialPerspective::InitProgramDescriptor(HgcGradientRadialPerspective *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientRadialPerspective_hgc_visible", "//Metal1.0     \n//LEN=000000048c\n[[ visible ]] FragmentOut HgcGradientRadialPerspective_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = c0.z;\n"
    "    r0.x = dot(hg_Params[3], texCoord0);\n"
    "    r0.y = dot(hg_Params[4], texCoord0);\n"
    "    r0.w = dot(hg_Params[5], texCoord0);\n"
    "    r0.xy = r0.xy/r0.ww;\n"
    "    r0.xyz = r0.xyz - hg_Params[1].xyz;\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
    "    r0.xy = sqrt(r0.xy);\n"
    "    r1.xy = r0.xy*hg_Params[2].ww;\n"
    "    r1.xy = fmin(r1.xy, c0.xx);\n"
    "    r1.xy = r1.xy*hg_Params[6].xy;\n"
    "    r1.xy = fmax(r1.xy, c0.yy);\n"
    "    r2.xy = hg_Params[6].xy - c0.yy;\n"
    "    r1.xy = fmin(r1.xy, r2.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
    "    r1.xyz = r1.xyz*r1.www;\n"
    "    r2.x = hg_Params[2].x - c0.y;\n"
    "    r2.x = fmax(r2.x, c0.z);\n"
    "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
    "    r2 = r1*-r2.xxxx + r1;\n"
    "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcGradientRadialPerspective");
}

void sub_1B78F8404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78F843C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78F8434);
}

char *HgcGradientRadialPerspective::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375E40;
  strcpy(result, "HgcGradientRadialPerspective [hgc1]");
  return result;
}

uint64_t HgcGradientRadialPerspective::BindTexture(HgcGradientRadialPerspective *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)a2 + 136))(a2, 6, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientRadialPerspective::Bind(HgcGradientRadialPerspective *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcGradientRadialPerspective::RenderTile(HgcGradientRadialPerspective *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    int v5 = a2[1].i32[0] - v2.i32[0];
    float32x2_t v6 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    int32x2_t v7 = a2[2];
    *(float32x2_t *)v8.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v8.i64[1] = 0x3F80000000000000;
    __asm { FMOV            V4.2S, #-1.0 }
    float32x2_t v14 = vadd_f32(v6, _D4);
    float32x2_t v15 = vadd_f32(v14, _D4);
    uint64_t v16 = 16 * a2[3].i32[0];
    while (v5 < 3)
    {
      uint64_t v17 = 0;
      float32x4_t v19 = v8;
      if (v5 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v8 = vaddq_f32(v8, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      *(void *)&v7 += v16;
      if (v4 == v3) {
        return 0;
      }
    }
    uint64_t v17 = 0;
    int v18 = v5;
    float32x4_t v19 = v8;
    do
    {
      float32x4_t v20 = vaddq_f32(v19, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      uint64_t v22 = *((void *)this + 51);
      float32x4_t v24 = *(float32x4_t *)(v22 + 32);
      float32x4_t v23 = *(float32x4_t *)(v22 + 48);
      float32x4_t v25 = vmulq_f32(v19, v23);
      float32x4_t v26 = vmulq_f32(v20, v23);
      float32x4_t v27 = vmulq_f32(v21, v23);
      int8x16_t v28 = (int8x16_t)vaddq_f32(v25, (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 4uLL));
      int8x16_t v29 = (int8x16_t)vaddq_f32(v26, (float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL));
      int8x16_t v30 = (int8x16_t)vaddq_f32(v27, (float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL));
      float32x4_t v31 = *(float32x4_t *)(v22 + 64);
      float32x4_t v32 = *(float32x4_t *)(v22 + 80);
      *(float32x2_t *)v28.i8 = vadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
      float32x4_t v33 = vmulq_f32(v19, v31);
      float32x4_t v34 = vmulq_f32(v20, v31);
      float32x4_t v35 = vmulq_f32(v21, v31);
      *(float32x2_t *)v29.i8 = vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL));
      float32x4_t v36 = vaddq_f32(v33, (float32x4_t)vextq_s8((int8x16_t)v33, (int8x16_t)v33, 4uLL));
      float32x4_t v37 = vaddq_f32(v34, (float32x4_t)vextq_s8((int8x16_t)v34, (int8x16_t)v34, 4uLL));
      float32x4_t v38 = vaddq_f32(v35, (float32x4_t)vextq_s8((int8x16_t)v35, (int8x16_t)v35, 4uLL));
      *(float32x2_t *)v30.i8 = vadd_f32(*(float32x2_t *)v30.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
      float32x4_t v39 = vmulq_f32(v19, v32);
      float32x4_t v40 = vmulq_f32(v20, v32);
      float32x4_t v41 = vmulq_f32(v21, v32);
      int8x16_t v43 = *(int8x16_t *)(v22 + 96);
      int8x16_t v42 = *(int8x16_t *)(v22 + 112);
      int8x16_t v44 = vbslq_s8(v43, (int8x16_t)vaddq_f32(v36, (float32x4_t)vextq_s8((int8x16_t)v36, (int8x16_t)v36, 8uLL)), v28);
      float32x4_t v45 = vaddq_f32(v39, (float32x4_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 4uLL));
      float32x4_t v46 = vaddq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)v40, (int8x16_t)v40, 4uLL));
      float32x4_t v47 = vaddq_f32(v41, (float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v41, 4uLL));
      float32x4_t v48 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vaddq_f32(v45, (float32x4_t)vextq_s8((int8x16_t)v45, (int8x16_t)v45, 8uLL)), v44);
      float32x4_t v49 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vaddq_f32(v46, (float32x4_t)vextq_s8((int8x16_t)v46, (int8x16_t)v46, 8uLL)), vbslq_s8(v43, (int8x16_t)vaddq_f32(v37, (float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 8uLL)), v29));
      float32x4_t v50 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vaddq_f32(v47, (float32x4_t)vextq_s8((int8x16_t)v47, (int8x16_t)v47, 8uLL)), vbslq_s8(v43, (int8x16_t)vaddq_f32(v38, (float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 8uLL)), v30));
      float32x4_t v51 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 3);
      float32x4_t v52 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 3);
      float32x4_t v53 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3);
      float32x4_t v54 = *(float32x4_t *)(v22 + 128);
      float32x4_t v55 = *(float32x4_t *)(v22 + 144);
      float32x4_t v56 = vminq_f32(vmaxq_f32(vrecpeq_f32(v51), v54), v55);
      float32x4_t v57 = vminq_f32(vmaxq_f32(vrecpeq_f32(v52), v54), v55);
      float32x4_t v58 = vminq_f32(vmaxq_f32(vrecpeq_f32(v53), v54), v55);
      float32x4_t v59 = vminq_f32(vmaxq_f32(vmulq_f32(v56, vrecpsq_f32(v51, v56)), v54), v55);
      float32x4_t v60 = vminq_f32(vmaxq_f32(vmulq_f32(v57, vrecpsq_f32(v52, v57)), v54), v55);
      float32x4_t v61 = vminq_f32(vmaxq_f32(vmulq_f32(v58, vrecpsq_f32(v53, v58)), v54), v55);
      v51.i64[0] = vmulq_f32(vmulq_f32(v59, vrecpsq_f32(v51, v59)), v48).u64[0];
      v52.i64[0] = vmulq_f32(vmulq_f32(v60, vrecpsq_f32(v52, v60)), v49).u64[0];
      v53.i64[0] = vmulq_f32(vmulq_f32(v61, vrecpsq_f32(v53, v61)), v50).u64[0];
      v51.i64[1] = v48.i64[1];
      v52.i64[1] = v49.i64[1];
      v53.i64[1] = v50.i64[1];
      float32x4_t v62 = *(float32x4_t *)(v22 + 16);
      float32x4_t v63 = vsubq_f32(v51, v62);
      float32x4_t v64 = vsubq_f32(v52, v62);
      float32x4_t v65 = vsubq_f32(v53, v62);
      int8x16_t v67 = *(int8x16_t *)(v22 + 160);
      float32x4_t v66 = *(float32x4_t *)(v22 + 176);
      float32x4_t v68 = (float32x4_t)vbslq_s8(v67, (int8x16_t)vmulq_f32(*(float32x4_t *)v22, v63), (int8x16_t)v63);
      float32x4_t v69 = (float32x4_t)vbslq_s8(v67, (int8x16_t)vmulq_f32(*(float32x4_t *)v22, v64), (int8x16_t)v64);
      float32x4_t v70 = (float32x4_t)vbslq_s8(v67, (int8x16_t)vmulq_f32(*(float32x4_t *)v22, v65), (int8x16_t)v65);
      int32x4_t v71 = (int32x4_t)vmulq_f32(v68, v68);
      int32x4_t v72 = (int32x4_t)vmulq_f32(v69, v69);
      int32x4_t v73 = (int32x4_t)vmulq_f32(v70, v70);
      float32x4_t v74 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v71, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.i8, 1)));
      float32x4_t v75 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v72, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v72.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v72.i8, 1)));
      float32x4_t v76 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v73, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v73.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v73.i8, 1)));
      float32x4_t v77 = vminq_f32(vrsqrteq_f32(v74), v55);
      float32x4_t v78 = vminq_f32(vrsqrteq_f32(v75), v55);
      float32x4_t v79 = vminq_f32(vrsqrteq_f32(v76), v55);
      float32x4_t v80 = vminq_f32(vmulq_f32(v77, vrsqrtsq_f32(vmulq_f32(v77, v74), v77)), v55);
      float32x4_t v81 = vminq_f32(vmulq_f32(v78, vrsqrtsq_f32(vmulq_f32(v78, v75), v78)), v55);
      float32x4_t v82 = vminq_f32(vmulq_f32(v79, vrsqrtsq_f32(vmulq_f32(v79, v76), v79)), v55);
      float32x4_t v83 = vmulq_f32(v74, vminq_f32(vmulq_f32(v80, vrsqrtsq_f32(vmulq_f32(v74, v80), v80)), v55));
      float32x4_t v84 = vmulq_f32(v75, vminq_f32(vmulq_f32(v81, vrsqrtsq_f32(vmulq_f32(v75, v81), v81)), v55));
      float32x4_t v85 = vmulq_f32(v76, vminq_f32(vmulq_f32(v82, vrsqrtsq_f32(vmulq_f32(v76, v82), v82)), v55));
      int32x2_t v86 = a2[10];
      uint64_t v87 = a2[11].i32[0];
      *(float32x2_t *)v80.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v83.f32, v24, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v81.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v80.f32, v15));
      *(float32x2_t *)v82.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v84.f32, v24, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v61.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v82.f32, v15));
      *(float32x2_t *)v80.f32 = vsub_f32(*(float32x2_t *)v80.f32, vcvt_f32_s32(*(int32x2_t *)v81.f32));
      *(float32x2_t *)v82.f32 = vsub_f32(*(float32x2_t *)v82.f32, vcvt_f32_s32(*(int32x2_t *)v61.f32));
      *(int32x2_t *)v81.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v81.f32, *(int32x2_t *)v61.f32), vzip2_s32(*(int32x2_t *)v81.f32, *(int32x2_t *)v61.f32), vdup_n_s32(v87));
      __int32 v88 = v81.i32[1];
      int8x16_t v89 = (float32x4_t *)(*(void *)&v86 + 16 * v81.i32[0]);
      float32x4_t v90 = vaddq_f32(*v89, vmulq_n_f32(vsubq_f32(v89[1], *v89), v80.f32[0]));
      uint64_t v91 = (int)v87 + 1;
      float32x4_t v92 = (float32x4_t *)(*(void *)&v86 + 16 * v88);
      float32x4_t v93 = vaddq_f32(*v92, vmulq_n_f32(vsubq_f32(v92[1], *v92), v82.f32[0]));
      *(float32x2_t *)v55.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v85.f32, v24, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      int32x2_t v94 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v55.f32, v15));
      *(float32x2_t *)v67.i8 = vsub_f32(*(float32x2_t *)v55.f32, vcvt_f32_s32(v94));
      int32x4_t v95 = (float32x4_t *)(*(void *)&v86 + 16 * (v94.i32[0] + v94.i32[1] * (int)v87));
      float32x4_t v96 = vaddq_f32(v90, vmulq_lane_f32(vsubq_f32(vaddq_f32(v89[v87], vmulq_n_f32(vsubq_f32(v89[v91], v89[v87]), v80.f32[0])), v90), *(float32x2_t *)v80.f32, 1));
      float32x4_t v97 = vaddq_f32(*v95, vmulq_n_f32(vsubq_f32(v95[1], *v95), *(float *)v67.i32));
      float32x4_t v98 = vaddq_f32(v93, vmulq_lane_f32(vsubq_f32(vaddq_f32(v92[v87], vmulq_n_f32(vsubq_f32(v92[v91], v92[v87]), v82.f32[0])), v93), *(float32x2_t *)v82.f32, 1));
      float32x4_t v99 = vaddq_f32(v97, vmulq_lane_f32(vsubq_f32(vaddq_f32(v95[v87], vmulq_n_f32(vsubq_f32(v95[v91], v95[v87]), *(float *)v67.i32)), v97), *(float32x2_t *)v67.i8, 1));
      float32x4_t v100 = (float32x4_t)vbslq_s8(v42, (int8x16_t)v96, (int8x16_t)vmulq_laneq_f32(v96, v96, 3));
      float32x4_t v101 = *(float32x4_t *)(v22 + 208);
      float32x4_t v102 = vmaxq_f32(vsubq_f32(v24, *(float32x4_t *)(v22 + 192)), v101);
      float32x4_t v103 = (float32x4_t)vbslq_s8(v42, (int8x16_t)v99, (int8x16_t)vmulq_laneq_f32(v99, v99, 3));
      float32x4_t v104 = (float32x4_t)vbslq_s8(v42, (int8x16_t)v98, (int8x16_t)vmulq_laneq_f32(v98, v98, 3));
      int8x16_t v105 = (int8x16_t)vsubq_f32(v100, vmulq_n_f32(v100, vminq_f32(vmaxq_f32(vsubq_f32(v83, v102), v101), v66).f32[0]));
      float32x4_t v106 = vmulq_n_f32(v104, vminq_f32(vmaxq_f32(vsubq_f32(v84, v102), v101), v66).f32[0]);
      int8x16_t v107 = (int8x16_t)vsubq_f32(v103, vmulq_n_f32(v103, vminq_f32(vmaxq_f32(vsubq_f32(v85, v102), v101), v66).f32[0]));
      int8x16_t v108 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v66, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1), v101)), v101);
      float32x4_t v109 = (int8x16_t *)(*(void *)&v7 + 16 * v17);
      *float32x4_t v109 = vbslq_s8(v108, (int8x16_t)v100, v105);
      v109[1] = vbslq_s8(v108, (int8x16_t)v104, (int8x16_t)vsubq_f32(v104, v106));
      v109[2] = vbslq_s8(v108, (int8x16_t)v103, v107);
      float32x4_t v19 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E736B0);
      v17 += 3;
      v18 -= 3;
    }
    while (v18 > 2);
    uint64_t v17 = v17;
    if ((int)v17 >= v5) {
      goto LABEL_3;
    }
    do
    {
LABEL_10:
      uint64_t v110 = *((void *)this + 51);
      float32x4_t v111 = *(float32x4_t *)(v110 + 32);
      float32x4_t v112 = vmulq_f32(v19, *(float32x4_t *)(v110 + 48));
      int8x16_t v113 = (int8x16_t)vaddq_f32(v112, (float32x4_t)vextq_s8((int8x16_t)v112, (int8x16_t)v112, 4uLL));
      float32x4_t v114 = vmulq_f32(v19, *(float32x4_t *)(v110 + 64));
      float32x4_t v115 = vaddq_f32(v114, (float32x4_t)vextq_s8((int8x16_t)v114, (int8x16_t)v114, 4uLL));
      *(float32x2_t *)v113.i8 = vadd_f32(*(float32x2_t *)v113.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v113, v113, 8uLL));
      float32x4_t v116 = vmulq_f32(v19, *(float32x4_t *)(v110 + 80));
      int8x16_t v117 = *(int8x16_t *)(v110 + 112);
      int8x16_t v118 = vbslq_s8(*(int8x16_t *)(v110 + 96), (int8x16_t)vaddq_f32(v115, (float32x4_t)vextq_s8((int8x16_t)v115, (int8x16_t)v115, 8uLL)), v113);
      float32x4_t v119 = vaddq_f32(v116, (float32x4_t)vextq_s8((int8x16_t)v116, (int8x16_t)v116, 4uLL));
      float32x4_t v120 = (float32x4_t)vbslq_s8(v117, (int8x16_t)vaddq_f32(v119, (float32x4_t)vextq_s8((int8x16_t)v119, (int8x16_t)v119, 8uLL)), v118);
      float32x4_t v121 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v120, 3);
      float32x4_t v122 = *(float32x4_t *)(v110 + 128);
      float32x4_t v123 = *(float32x4_t *)(v110 + 144);
      float32x4_t v124 = vminq_f32(vmaxq_f32(vrecpeq_f32(v121), v122), v123);
      float32x4_t v125 = vminq_f32(vmaxq_f32(vmulq_f32(v124, vrecpsq_f32(v121, v124)), v122), v123);
      v121.i64[0] = vmulq_f32(vmulq_f32(v125, vrecpsq_f32(v121, v125)), v120).u64[0];
      v121.i64[1] = v120.i64[1];
      float32x4_t v126 = vsubq_f32(v121, *(float32x4_t *)(v110 + 16));
      float32x4_t v127 = *(float32x4_t *)(v110 + 176);
      float32x4_t v128 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v110 + 160), (int8x16_t)vmulq_f32(*(float32x4_t *)v110, v126), (int8x16_t)v126);
      int32x4_t v129 = (int32x4_t)vmulq_f32(v128, v128);
      float32x4_t v130 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v129, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v129.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v129.i8, 1)));
      float32x4_t v131 = vminq_f32(vrsqrteq_f32(v130), v123);
      float32x4_t v132 = vminq_f32(vmulq_f32(v131, vrsqrtsq_f32(vmulq_f32(v131, v130), v131)), v123);
      float32x4_t v133 = vmulq_f32(vminq_f32(vmulq_f32(v132, vrsqrtsq_f32(vmulq_f32(v132, v130), v132)), v123), v130);
      uint64_t v134 = a2[11].i32[0];
      *(float32x2_t *)v132.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v6, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v133.f32, v111, 3), *(float32x2_t *)v127.f32)), (float32x2_t)0xBF000000BF000000), 0), v14);
      *(int32x2_t *)v125.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v132.f32, v15));
      *(float32x2_t *)v132.f32 = vsub_f32(*(float32x2_t *)v132.f32, vcvt_f32_s32(*(int32x2_t *)v125.f32));
      float32x4_t v135 = (float32x4_t *)(*(void *)&a2[10] + 16 * (v125.i32[0] + v125.i32[1] * (int)v134));
      float32x4_t v136 = vaddq_f32(*v135, vmulq_n_f32(vsubq_f32(v135[1], *v135), v132.f32[0]));
      float32x4_t v137 = vaddq_f32(v136, vmulq_lane_f32(vsubq_f32(vaddq_f32(v135[v134], vmulq_n_f32(vsubq_f32(v135[(int)v134 + 1], v135[v134]), v132.f32[0])), v136), *(float32x2_t *)v132.f32, 1));
      float32x4_t v138 = (float32x4_t)vbslq_s8(v117, (int8x16_t)v137, (int8x16_t)vmulq_laneq_f32(v137, v137, 3));
      *(float32x4_t *)(*(void *)&v7 + 16 * v17) = vsubq_f32(v138, (float32x4_t)vbicq_s8((int8x16_t)vmulq_n_f32(v138, vminq_f32(vmaxq_f32(vsubq_f32(v133, vmaxq_f32(vsubq_f32(v111, *(float32x4_t *)(v110 + 192)), *(float32x4_t *)(v110 + 208))), *(float32x4_t *)(v110 + 208)), v127).f32[0]), (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v127, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v111.f32, 1), *(float32x4_t *)(v110 + 208))),
                                                                                  *(float32x4_t *)(v110 + 208))));
      float32x4_t v19 = vaddq_f32(v19, (float32x4_t)xmmword_1B7E736B0);
      ++v17;
    }
    while (v17 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientRadialPerspective::GetDOD(HgcGradientRadialPerspective *this, HGRenderer *a2, int a3, HGRect a4)
{
  int v4 = &HGRectInfinite;
  if (a3) {
    int v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcGradientRadialPerspective::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientRadialPerspective::HgcGradientRadialPerspective(HgcGradientRadialPerspective *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EC8C0;
  operator new();
}

void sub_1B78F8FD4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientRadialPerspective::~HgcGradientRadialPerspective(HGNode *this)
{
  *(void *)this = &unk_1F10EC8C0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C405DF52C91);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EC8C0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C405DF52C91);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcGradientRadialPerspective::SetParameter(HgcGradientRadialPerspective *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  float32x4_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *float32x4_t v8 = a3;
  int v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcGradientRadialPerspective::GetParameter(HgcGradientRadialPerspective *this, unsigned int a2, float *a3)
{
  if (a2 > 5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGradientRadialTranslate::GetProgram(HgcGradientRadialTranslate *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000575\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = half(hg_Params[3].x) + half(frag._texCoord0.x);\n"
             "    r0.y = half(hg_Params[4].y) + half(frag._texCoord0.y);\n"
             "    s0.xyz = float3(r0.xyz) - hg_Params[1].xyz;\n"
             "    s0.x = s0.x*hg_Params[0].x;\n"
             "    s0.xy = float2(dot(s0.xyz, s0.xyz));\n"
             "    s0.xy = sqrt(s0.xy);\n"
             "    s1.xy = s0.xy*hg_Params[2].ww;\n"
             "    s1.xy = fmin(s1.xy, float2(c0.xx));\n"
             "    s1.xy = s1.xy*hg_Params[5].xy;\n"
             "    s1.xy = fmax(s1.xy, float2(c0.yy));\n"
             "    s2.xy = hg_Params[5].xy - float2(c0.yy);\n"
             "    s1.xy = fmin(s1.xy, s2.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s1.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    r1.x = half(hg_Params[2].x) - c0.y;\n"
             "    r1.x = fmax(r1.x, c0.z);\n"
             "    s0.x = clamp(s0.x - float(r1.x), 0.00000f, 1.00000f);\n"
             "    s0 = float4(r0)*-s0.xxxx + float4(r0);\n"
             "    output.color0 = select(s0, float4(r0), hg_Params[2].yyyy == 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1ea05cb7:c3dd4787:6609f856:de1f9da5\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0006:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000501\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = c0.z;\n"
             "    r0.x = hg_Params[3].x + frag._texCoord0.x;\n"
             "    r0.y = hg_Params[4].y + frag._texCoord0.y;\n"
             "    r0.xyz = r0.xyz - hg_Params[1].xyz;\n"
             "    r0.x = r0.x*hg_Params[0].x;\n"
             "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
             "    r0.xy = sqrt(r0.xy);\n"
             "    r1.xy = r0.xy*hg_Params[2].ww;\n"
             "    r1.xy = fmin(r1.xy, c0.xx);\n"
             "    r1.xy = r1.xy*hg_Params[5].xy;\n"
             "    r1.xy = fmax(r1.xy, c0.yy);\n"
             "    r2.xy = hg_Params[5].xy - c0.yy;\n"
             "    r1.xy = fmin(r1.xy, r2.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
             "    r1.xyz = r1.xyz*r1.www;\n"
             "    r2.x = hg_Params[2].x - c0.y;\n"
             "    r2.x = fmax(r2.x, c0.z);\n"
             "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
             "    r2 = r1*-r2.xxxx + r1;\n"
             "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c8bbc548:4c65dde8:81c7f077:a13a6c08\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0006:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000005c1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.z = c0.z;\n"
           "    r0.x = hg_ProgramLocal3.x + hg_TexCoord0.x;\n"
           "    r0.y = hg_ProgramLocal4.y + hg_TexCoord0.y;\n"
           "    r0.xyz = r0.xyz - hg_ProgramLocal1.xyz;\n"
           "    r0.x = r0.x*hg_ProgramLocal0.x;\n"
           "    r0.xy = vec2(dot(r0.xyz, r0.xyz));\n"
           "    r0.xy = sqrt(r0.xy);\n"
           "    r1.xy = r0.xy*hg_ProgramLocal2.ww;\n"
           "    r1.xy = min(r1.xy, c0.xx);\n"
           "    r1.xy = hg_ProgramLocal5.xy*c0.zz + r1.xy;\n"
           "    r1 = texture2D(hg_Texture0, r1.xy);\n"
           "    r1.xyz = r1.xyz*r1.www;\n"
           "    r2.x = hg_ProgramLocal2.x - c0.y;\n"
           "    r2.x = max(r2.x, c0.z);\n"
           "    r2.x = clamp(r0.x - r2.x, 0.00000, 1.00000);\n"
           "    r2 = r1*-r2.xxxx + r1;\n"
           "    gl_FragColor = vec4(hg_ProgramLocal2.y == 0.00000 ? r1.x : r2.x, hg_ProgramLocal2.y == 0.00000 ? r1.y : r"
           "2.y, hg_ProgramLocal2.y == 0.00000 ? r1.z : r2.z, hg_ProgramLocal2.y == 0.00000 ? r1.w : r2.w);\n"
           "}\n"
           "//MD5=97dca451:648d32c1:c6253b89:39206e01\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0006:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGradientRadialTranslate::InitProgramDescriptor(HgcGradientRadialTranslate *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientRadialTranslate_hgc_visible", "//Metal1.0     \n//LEN=0000000448\n[[ visible ]] FragmentOut HgcGradientRadialTranslate_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = c0.z;\n"
    "    r0.x = hg_Params[3].x + texCoord0.x;\n"
    "    r0.y = hg_Params[4].y + texCoord0.y;\n"
    "    r0.xyz = r0.xyz - hg_Params[1].xyz;\n"
    "    r0.x = r0.x*hg_Params[0].x;\n"
    "    r0.xy = float2(dot(r0.xyz, r0.xyz));\n"
    "    r0.xy = sqrt(r0.xy);\n"
    "    r1.xy = r0.xy*hg_Params[2].ww;\n"
    "    r1.xy = fmin(r1.xy, c0.xx);\n"
    "    r1.xy = r1.xy*hg_Params[5].xy;\n"
    "    r1.xy = fmax(r1.xy, c0.yy);\n"
    "    r2.xy = hg_Params[5].xy - c0.yy;\n"
    "    r1.xy = fmin(r1.xy, r2.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
    "    r1.xyz = r1.xyz*r1.www;\n"
    "    r2.x = hg_Params[2].x - c0.y;\n"
    "    r2.x = fmax(r2.x, c0.z);\n"
    "    r2.x = clamp(r0.x - r2.x, 0.00000f, 1.00000f);\n"
    "    r2 = r1*-r2.xxxx + r1;\n"
    "    output.color0 = select(r2, r1, hg_Params[2].yyyy == 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcGradientRadialTranslate");
}

void sub_1B78F95A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78F95DC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78F95D4);
}

char *HgcGradientRadialTranslate::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376030;
  strcpy(result, "HgcGradientRadialTranslate [hgc1]");
  return result;
}

uint64_t HgcGradientRadialTranslate::BindTexture(HgcGradientRadialTranslate *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)a2 + 136))(a2, 5, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcGradientRadialTranslate::Bind(HgcGradientRadialTranslate *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcGradientRadialTranslate::RenderTile(HgcGradientRadialTranslate *this, int32x2_t *a2)
{
  int32x2_t v5 = *a2;
  int v6 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v6 >= 1)
  {
    int v7 = 0;
    int v8 = a2[1].i32[0] - v5.i32[0];
    float32x2_t v9 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    *(float32x2_t *)v10.f32 = vadd_f32(vcvt_f32_s32(v5), (float32x2_t)0x3F0000003F000000);
    v10.i64[1] = 0x3F80000000000000;
    int32x2_t v11 = a2[2];
    __asm { FMOV            V4.2S, #-1.0 }
    float32x2_t v17 = vadd_f32(v9, _D4);
    float32x2_t v18 = vadd_f32(v17, _D4);
    float32x4_t v19 = (int8x16_t *)(*(void *)&v11 + 32);
    uint64_t v20 = 16 * a2[3].i32[0];
    while (v8 < 4)
    {
      LODWORD(v98) = 0;
      float32x4_t v23 = v10;
      if (v8 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v10 = vaddq_f32(v10, (float32x4_t)xmmword_1B7E736C0);
      ++v7;
      float32x4_t v19 = (int8x16_t *)((char *)v19 + v20);
      *(void *)&v11 += v20;
      if (v7 == v6) {
        return 0;
      }
    }
    int v21 = 0;
    uint64_t v22 = v19;
    float32x4_t v23 = v10;
    do
    {
      float32x4_t v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B7E736B0);
      uint64_t v26 = *((void *)this + 51);
      float32x4_t v27 = vaddq_f32(v25, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v28 = *(float32x4_t *)(v26 + 32);
      int8x16_t v29 = *(int8x16_t *)(v26 + 48);
      *(float32x2_t *)v2.i8 = vadd_f32(*(float32x2_t *)v23.f32, *(float32x2_t *)v29.i8);
      *(float32x2_t *)v3.f32 = vadd_f32(*(float32x2_t *)v24.f32, *(float32x2_t *)v29.i8);
      *(float32x2_t *)v4.f32 = vadd_f32(*(float32x2_t *)v25.f32, *(float32x2_t *)v29.i8);
      *(float32x2_t *)v29.i8 = vadd_f32(*(float32x2_t *)v27.f32, *(float32x2_t *)v29.i8);
      float32x4_t v30 = *(float32x4_t *)(v26 + 64);
      int8x16_t v31 = *(int8x16_t *)(v26 + 80);
      float32x4_t v32 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vaddq_f32(v23, v30), v2);
      float32x4_t v33 = *(float32x4_t *)(v26 + 16);
      float32x4_t v34 = vsubq_f32(v32, v33);
      float32x4_t v35 = vsubq_f32((float32x4_t)vbslq_s8(v31, (int8x16_t)vaddq_f32(v24, v30), (int8x16_t)v3), v33);
      float32x4_t v36 = vsubq_f32((float32x4_t)vbslq_s8(v31, (int8x16_t)vaddq_f32(v25, v30), (int8x16_t)v4), v33);
      float32x4_t v37 = vsubq_f32((float32x4_t)vbslq_s8(v31, (int8x16_t)vaddq_f32(v27, v30), v29), v33);
      int8x16_t v38 = *(int8x16_t *)(v26 + 96);
      float32x4_t v39 = *(float32x4_t *)(v26 + 112);
      float32x4_t v40 = (float32x4_t)vbslq_s8(v38, (int8x16_t)vmulq_f32(*(float32x4_t *)v26, v34), (int8x16_t)v34);
      float32x4_t v41 = (float32x4_t)vbslq_s8(v38, (int8x16_t)vmulq_f32(*(float32x4_t *)v26, v35), (int8x16_t)v35);
      float32x4_t v42 = (float32x4_t)vbslq_s8(v38, (int8x16_t)vmulq_f32(*(float32x4_t *)v26, v36), (int8x16_t)v36);
      float32x4_t v43 = (float32x4_t)vbslq_s8(v38, (int8x16_t)vmulq_f32(*(float32x4_t *)v26, v37), (int8x16_t)v37);
      int32x4_t v44 = (int32x4_t)vmulq_f32(v40, v40);
      int32x4_t v45 = (int32x4_t)vmulq_f32(v41, v41);
      int32x4_t v46 = (int32x4_t)vmulq_f32(v42, v42);
      int32x4_t v47 = (int32x4_t)vmulq_f32(v43, v43);
      float32x4_t v48 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v44, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.i8, 1)));
      float32x4_t v49 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v45, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.i8, 1)));
      float32x4_t v50 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v46, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v46.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v46.i8, 1)));
      float32x4_t v51 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v47, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.i8, 1)));
      float32x4_t v52 = vminq_f32(vrsqrteq_f32(v48), v39);
      float32x4_t v53 = vminq_f32(vrsqrteq_f32(v49), v39);
      float32x4_t v54 = vminq_f32(vrsqrteq_f32(v50), v39);
      float32x4_t v55 = vminq_f32(vrsqrteq_f32(v51), v39);
      float32x4_t v56 = vminq_f32(vmulq_f32(v52, vrsqrtsq_f32(vmulq_f32(v52, v48), v52)), v39);
      float32x4_t v57 = vminq_f32(vmulq_f32(v53, vrsqrtsq_f32(vmulq_f32(v53, v49), v53)), v39);
      float32x4_t v58 = vminq_f32(vmulq_f32(v54, vrsqrtsq_f32(vmulq_f32(v54, v50), v54)), v39);
      float32x4_t v59 = vminq_f32(vmulq_f32(v55, vrsqrtsq_f32(vmulq_f32(v55, v51), v55)), v39);
      float32x4_t v60 = vmulq_f32(v48, vminq_f32(vmulq_f32(v56, vrsqrtsq_f32(vmulq_f32(v48, v56), v56)), v39));
      float32x4_t v61 = vmulq_f32(v49, vminq_f32(vmulq_f32(v57, vrsqrtsq_f32(vmulq_f32(v49, v57), v57)), v39));
      float32x4_t v62 = vmulq_f32(v50, vminq_f32(vmulq_f32(v58, vrsqrtsq_f32(vmulq_f32(v50, v58), v58)), v39));
      int32x2_t v63 = a2[10];
      float32x4_t v64 = vmulq_f32(v51, vminq_f32(vmulq_f32(v59, vrsqrtsq_f32(vmulq_f32(v51, v59), v59)), v39));
      uint64_t v65 = a2[11].i32[0];
      float32x4_t v66 = *(float32x4_t *)(v26 + 128);
      int8x16_t v67 = *(int8x16_t *)(v26 + 144);
      *(float32x2_t *)v50.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v60.f32, v28, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v17);
      int v68 = v65 + 1;
      *(int32x2_t *)v59.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v50.f32, v18));
      *(float32x2_t *)v38.i8 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v61.f32, v28, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v17);
      int32x2_t v69 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v38.i8, v18));
      *(float32x2_t *)v50.f32 = vsub_f32(*(float32x2_t *)v50.f32, vcvt_f32_s32(*(int32x2_t *)v59.f32));
      *(int32x2_t *)v39.f32 = vdup_n_s32(v65);
      *(int32x2_t *)v59.f32 = vmla_s32(vzip1_s32(*(int32x2_t *)v59.f32, v69), vzip2_s32(*(int32x2_t *)v59.f32, v69), *(int32x2_t *)v39.f32);
      *(float32x2_t *)v38.i8 = vsub_f32(*(float32x2_t *)v38.i8, vcvt_f32_s32(v69));
      float32x4_t v70 = (float32x4_t *)(*(void *)&v63 + 16 * v59.i32[0]);
      v65 *= 16;
      uint64_t v71 = v68;
      int32x4_t v72 = (float32x4_t *)(*(void *)&v63 + 16 * v59.i32[1]);
      float32x2_t v73 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v62.f32, v28, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v17);
      int32x2_t v74 = vcvt_s32_f32(vmin_f32(v73, v18));
      float32x4_t v75 = vaddq_f32(*v70, vmulq_n_f32(vsubq_f32(v70[1], *v70), v50.f32[0]));
      float32x2_t v76 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v64.f32, v28, 3), *(float32x2_t *)v66.f32)), (float32x2_t)0xBF000000BF000000), 0), v17);
      int32x2_t v77 = vcvt_s32_f32(vmin_f32(v76, v18));
      int32x2_t v78 = vmla_s32(vzip1_s32(v74, v77), vzip2_s32(v74, v77), *(int32x2_t *)v39.f32);
      float32x4_t v79 = vaddq_f32(*v72, vmulq_n_f32(vsubq_f32(v72[1], *v72), *(float *)v38.i32));
      float32x2_t v80 = vsub_f32(v73, vcvt_f32_s32(v74));
      float32x4_t v81 = vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v70 + v65), vmulq_n_f32(vsubq_f32(v70[v71], *(float32x4_t *)((char *)v70 + v65)), v50.f32[0])), v75);
      float32x2_t v82 = vsub_f32(v76, vcvt_f32_s32(v77));
      float32x4_t v83 = (float32x4_t *)(*(void *)&v63 + 16 * v78.i32[0]);
      float32x4_t v84 = vaddq_f32(v75, vmulq_lane_f32(v81, *(float32x2_t *)v50.f32, 1));
      float32x4_t v85 = vaddq_f32(*v83, vmulq_n_f32(vsubq_f32(v83[1], *v83), v80.f32[0]));
      int32x2_t v86 = (float32x4_t *)(*(void *)&v63 + 16 * v78.i32[1]);
      float32x4_t v87 = vaddq_f32(v79, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v72 + v65), vmulq_n_f32(vsubq_f32(v72[v71], *(float32x4_t *)((char *)v72 + v65)), *(float *)v38.i32)), v79), *(float32x2_t *)v38.i8, 1));
      float32x4_t v88 = vaddq_f32(*v86, vmulq_n_f32(vsubq_f32(v86[1], *v86), v82.f32[0]));
      float32x4_t v89 = vaddq_f32(v85, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v83 + v65), vmulq_n_f32(vsubq_f32(v83[v71], *(float32x4_t *)((char *)v83 + v65)), v80.f32[0])), v85), v80, 1));
      float32x4_t v90 = vaddq_f32(v88, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)((char *)v86 + v65), vmulq_n_f32(vsubq_f32(v86[v71], *(float32x4_t *)((char *)v86 + v65)), v82.f32[0])), v88), v82, 1));
      float32x4_t v3 = (float32x4_t)vbslq_s8(v67, (int8x16_t)v84, (int8x16_t)vmulq_laneq_f32(v84, v84, 3));
      float32x4_t v91 = *(float32x4_t *)(v26 + 176);
      float32x4_t v92 = (float32x4_t)vbslq_s8(v67, (int8x16_t)v87, (int8x16_t)vmulq_laneq_f32(v87, v87, 3));
      float32x4_t v93 = vmaxq_f32(vsubq_f32(v28, *(float32x4_t *)(v26 + 160)), v91);
      float32x4_t v94 = (float32x4_t)vbslq_s8(v67, (int8x16_t)v89, (int8x16_t)vmulq_laneq_f32(v89, v89, 3));
      v60.i32[0] = vminq_f32(vmaxq_f32(vsubq_f32(v60, v93), v91), v66).u32[0];
      float32x4_t v4 = (float32x4_t)vbslq_s8(v67, (int8x16_t)v90, (int8x16_t)vmulq_laneq_f32(v90, v90, 3));
      int8x16_t v95 = (int8x16_t)vsubq_f32(v92, vmulq_n_f32(v92, vminq_f32(vmaxq_f32(vsubq_f32(v61, v93), v91), v66).f32[0]));
      int8x16_t v96 = (int8x16_t)vsubq_f32(v94, vmulq_n_f32(v94, vminq_f32(vmaxq_f32(vsubq_f32(v62, v93), v91), v66).f32[0]));
      int8x16_t v2 = (int8x16_t)vsubq_f32(v4, vmulq_n_f32(v4, vminq_f32(vmaxq_f32(vsubq_f32(v64, v93), v91), v66).f32[0]));
      int8x16_t v97 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v66, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1), v91)), v91);
      v22[-2] = vbslq_s8(v97, (int8x16_t)v3, (int8x16_t)vsubq_f32(v3, vmulq_n_f32(v3, v60.f32[0])));
      v22[-1] = vbslq_s8(v97, (int8x16_t)v92, v95);
      *uint64_t v22 = vbslq_s8(v97, (int8x16_t)v94, v96);
      v22[1] = vbslq_s8(v97, (int8x16_t)v4, v2);
      v22 += 4;
      float32x4_t v23 = vaddq_f32(v27, (float32x4_t)xmmword_1B7E736B0);
      v21 -= 4;
    }
    while (v8 + v21 > 3);
    LODWORD(v98) = -v21;
    if ((int)v98 >= v8) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v98 = v98;
    do
    {
      uint64_t v99 = *((void *)this + 51);
      float32x4_t v101 = *(float32x4_t *)(v99 + 32);
      int8x16_t v100 = *(int8x16_t *)(v99 + 48);
      *(float32x2_t *)v100.i8 = vadd_f32(*(float32x2_t *)v23.f32, *(float32x2_t *)v100.i8);
      float32x4_t v102 = vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v99 + 80), (int8x16_t)vaddq_f32(v23, *(float32x4_t *)(v99 + 64)), v100), *(float32x4_t *)(v99 + 16));
      float32x4_t v103 = *(float32x4_t *)(v99 + 112);
      float32x4_t v104 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v99 + 96), (int8x16_t)vmulq_f32(*(float32x4_t *)v99, v102), (int8x16_t)v102);
      int32x4_t v105 = (int32x4_t)vmulq_f32(v104, v104);
      float32x4_t v106 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v105, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v105.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v105.i8, 1)));
      float32x4_t v107 = vminq_f32(vrsqrteq_f32(v106), v103);
      float32x4_t v108 = vminq_f32(vmulq_f32(v107, vrsqrtsq_f32(vmulq_f32(v107, v106), v107)), v103);
      float32x4_t v109 = vmulq_f32(vminq_f32(vmulq_f32(v108, vrsqrtsq_f32(vmulq_f32(v108, v106), v108)), v103), v106);
      float32x4_t v110 = *(float32x4_t *)(v99 + 128);
      uint64_t v111 = a2[11].i32[0];
      *(float32x2_t *)v108.f32 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, vmin_f32(vmul_laneq_f32(*(float32x2_t *)v109.f32, v101, 3), *(float32x2_t *)v110.f32)), (float32x2_t)0xBF000000BF000000), 0), v17);
      int32x2_t v112 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v108.f32, v18));
      *(float32x2_t *)v108.f32 = vsub_f32(*(float32x2_t *)v108.f32, vcvt_f32_s32(v112));
      int8x16_t v113 = (float32x4_t *)(*(void *)&a2[10] + 16 * (v112.i32[0] + v112.i32[1] * (int)v111));
      float32x4_t v114 = vaddq_f32(*v113, vmulq_n_f32(vsubq_f32(v113[1], *v113), v108.f32[0]));
      float32x4_t v115 = vaddq_f32(v114, vmulq_lane_f32(vsubq_f32(vaddq_f32(v113[v111], vmulq_n_f32(vsubq_f32(v113[(int)v111 + 1], v113[v111]), v108.f32[0])), v114), *(float32x2_t *)v108.f32, 1));
      int8x16_t v2 = (int8x16_t)vmulq_laneq_f32(v115, v115, 3);
      float32x4_t v3 = *(float32x4_t *)(v99 + 160);
      float32x4_t v4 = *(float32x4_t *)(v99 + 176);
      float32x4_t v116 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v99 + 144), (int8x16_t)v115, v2);
      *(float32x4_t *)(*(void *)&v11 + 16 * v98) = vsubq_f32(v116, (float32x4_t)vbicq_s8((int8x16_t)vmulq_n_f32(v116, vminq_f32(vmaxq_f32(vsubq_f32(v109, vmaxq_f32(vsubq_f32(v101, v3), v4)), v4), v110).f32[0]), (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v110, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v101.f32, 1), v4)), v4)));
      float32x4_t v23 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E736B0);
      ++v98;
    }
    while (v98 < v8);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGradientRadialTranslate::GetDOD(HgcGradientRadialTranslate *this, HGRenderer *a2, int a3, HGRect a4)
{
  float32x4_t v4 = &HGRectInfinite;
  if (a3) {
    float32x4_t v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcGradientRadialTranslate::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcGradientRadialTranslate::HgcGradientRadialTranslate(HgcGradientRadialTranslate *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10ECB28;
  operator new();
}

void sub_1B78FA088(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientRadialTranslate::~HgcGradientRadialTranslate(HGNode *this)
{
  *(void *)this = &unk_1F10ECB28;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C405DF52C91);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10ECB28;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C405DF52C91);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcGradientRadialTranslate::SetParameter(HgcGradientRadialTranslate *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  switch((int)a2)
  {
    case 0:
      int v7 = (float *)*((void *)this + 51);
      if (*v7 == a3.n128_f32[0] && v7[1] == a4 && v7[2] == a5 && v7[3] == a6) {
        goto LABEL_28;
      }
      *int v7 = a3.n128_f32[0];
      v7[1] = a4;
      v7[2] = a5;
      v7[3] = a6;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      uint64_t result = 1;
      break;
    case 1:
      float32x2_t v9 = (float *)*((void *)this + 51);
      if (v9[4] == a3.n128_f32[0] && v9[5] == a4 && v9[6] == a5 && v9[7] == a6) {
        goto LABEL_28;
      }
      v9[4] = a3.n128_f32[0];
      v9[5] = a4;
      v9[6] = a5;
      v9[7] = a6;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      uint64_t result = 1;
      break;
    case 2:
      float32x4_t v10 = (float *)*((void *)this + 51);
      if (v10[8] == a3.n128_f32[0] && v10[9] == a4 && v10[10] == a5 && v10[11] == a6) {
        goto LABEL_28;
      }
      v10[8] = a3.n128_f32[0];
      v10[9] = a4;
      v10[10] = a5;
      v10[11] = a6;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      uint64_t result = 1;
      break;
    case 3:
      int32x2_t v11 = (__n128 *)*((void *)this + 51);
      if (v11[3].n128_f32[0] == a6
        && v11[3].n128_f32[1] == 0.0
        && v11[3].n128_f32[2] == 0.0
        && v11[3].n128_f32[3] == 0.0)
      {
        goto LABEL_28;
      }
      v11[3].n128_f32[0] = a6;
      v11[3].n128_u64[1] = 0;
      v11[3].n128_u32[1] = 0;
      a3.n128_f32[1] = a4;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v11[12] = a3;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      uint64_t result = 1;
      break;
    case 4:
      uint64_t v12 = (__n128 *)*((void *)this + 51);
      if (v12[4].n128_f32[0] == 0.0
        && v12[4].n128_f32[1] == a6
        && v12[4].n128_f32[2] == 0.0
        && v12[4].n128_f32[3] == 0.0)
      {
LABEL_28:
        uint64_t result = 0;
      }
      else
      {
        v12[4].n128_u32[0] = 0;
        v12[4].n128_f32[1] = a6;
        a3.n128_f32[1] = a4;
        v12[4].n128_u64[1] = 0;
        a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
        v12[13] = a3;
        HGNode::ClearBits((HGNode *)this, a2, a7);
        uint64_t result = 1;
      }
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

float HgcGradientRadialTranslate::GetParameter(HgcGradientRadialTranslate *this, int a2, float *a3)
{
  switch(a2)
  {
    case 0:
      float32x4_t v3 = (float *)*((void *)this + 51);
      *a3 = *v3;
      a3[1] = v3[1];
      a3[2] = v3[2];
      float result = v3[3];
      a3[3] = result;
      break;
    case 1:
      int32x2_t v5 = (float *)*((void *)this + 51);
      *a3 = v5[4];
      a3[1] = v5[5];
      a3[2] = v5[6];
      float result = v5[7];
      a3[3] = result;
      break;
    case 2:
      int v6 = (float *)*((void *)this + 51);
      *a3 = v6[8];
      a3[1] = v6[9];
      a3[2] = v6[10];
      float result = v6[11];
      a3[3] = result;
      break;
    case 3:
      int v7 = (float *)*((void *)this + 51);
      *a3 = v7[48];
      a3[1] = v7[49];
      a3[2] = v7[50];
      float result = v7[51];
      a3[3] = result;
      break;
    case 4:
      int v8 = (float *)*((void *)this + 51);
      *a3 = v8[52];
      a3[1] = v8[53];
      a3[2] = v8[54];
      float result = v8[55];
      a3[3] = result;
      break;
    default:
      return result;
  }
  return result;
}

const char *HgcYUV444BiPlanar_601ToRGB::GetProgram(HgcYUV444BiPlanar_601ToRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const half4 c1 = half4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0e00be48:1d4c1030:c845256d:4f625dda\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e920bf17:693c75e5:4f148dce:a2580259\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=b28b84a9:65d97aa9:3bf19568:b311251d\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV444BiPlanar_601ToRGB::InitProgramDescriptor(HgcYUV444BiPlanar_601ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444BiPlanar_601ToRGB_hgc_visible", "//Metal1.0     \n//LEN=000000027e\n[[ visible ]] FragmentOut HgcYUV444BiPlanar_601ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
    "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = color1.xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV444BiPlanar_601ToRGB");
}

void sub_1B78FA828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78FA85C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78FA854);
}

char *HgcYUV444BiPlanar_601ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  float result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376030;
  strcpy(result, "HgcYUV444BiPlanar_601ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV444BiPlanar_601ToRGB::BindTexture(HgcYUV444BiPlanar_601ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 != 1) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    float32x4_t v4 = a2;
    int v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    float32x4_t v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444BiPlanar_601ToRGB::Bind(HgcYUV444BiPlanar_601ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV444BiPlanar_601ToRGB::RenderTile(HgcYUV444BiPlanar_601ToRGB *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    float32x4_t v4 = (int8x16_t *)*((void *)a2 + 12);
    int v5 = (int8x16_t *)*((void *)a2 + 10);
    int v6 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v7 = *((int *)a2 + 6);
    uint64_t v8 = *((int *)a2 + 22);
    uint64_t v9 = *((int *)a2 + 26);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v45 = 0;
        uint64_t v46 = 16 * v9;
        uint64_t v47 = 16 * v8;
        uint64_t v48 = 16 * v7;
        uint64_t v49 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v50 = 0;
          do
          {
            uint64_t v51 = *((void *)this + 51);
            float32x4_t v52 = vaddq_f32(*(float32x4_t *)(v51 + 16), vmulq_f32(*(float32x4_t *)v51, (float32x4_t)vbslq_s8(*(int8x16_t *)(v51 + 32), v5[v50 / 0x10], vextq_s8(v4[v50 / 0x10], v4[v50 / 0x10], 0xCuLL))));
            float32x4_t v53 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v51 + 64), v52, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v51 + 48), *(float32x2_t *)v52.f32, 1)));
            v53.i32[3] = 1.0;
            v6[v50 / 0x10] = v53;
            v50 += 16;
          }
          while (v49 != v50);
          ++v45;
          float32x4_t v4 = (int8x16_t *)((char *)v4 + v46);
          int v5 = (int8x16_t *)((char *)v5 + v47);
          int v6 = (float32x4_t *)((char *)v6 + v48);
        }
        while (v45 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      float32x2_t v14 = v4 + 4;
      float32x2_t v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        uint64_t v17 = 0;
        unint64_t v18 = 0;
        float32x4_t v19 = v16;
        uint64_t v20 = v15;
        int v21 = v14;
        do
        {
          uint64_t v22 = *((void *)this + 51);
          int8x16_t v23 = *(int8x16_t *)(v22 + 32);
          float32x4_t v24 = *(float32x4_t *)(v22 + 48);
          float32x4_t v25 = *(float32x4_t *)(v22 + 16);
          uint64_t v26 = v21;
          float32x4_t v27 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17], vextq_s8(v4[v17], v4[v17], 0xCuLL))));
          float32x4_t v28 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 1], vextq_s8(v4[v17 + 1], v4[v17 + 1], 0xCuLL))));
          float32x4_t v29 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 2], vextq_s8(v4[v17 + 2], v4[v17 + 2], 0xCuLL))));
          float32x4_t v30 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 3], vextq_s8(v4[v17 + 3], v4[v17 + 3], 0xCuLL))));
          float32x4_t v31 = *(float32x4_t *)(v22 + 64);
          float32x4_t v32 = vaddq_f32(vmulq_laneq_f32(v31, v27, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v27.f32, 1)));
          float32x4_t v33 = vaddq_f32(vmulq_laneq_f32(v31, v28, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v28.f32, 1)));
          float32x4_t v34 = vaddq_f32(vmulq_laneq_f32(v31, v29, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v29.f32, 1)));
          v32.i32[3] = 1.0;
          v33.i32[3] = 1.0;
          float32x4_t v35 = vaddq_f32(vmulq_laneq_f32(v31, v30, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v30.f32, 1)));
          v34.i32[3] = 1.0;
          v35.i32[3] = 1.0;
          float32x4_t v36 = v20;
          float32x4_t v37 = v19;
          int8x16_t v38 = &v6[v17];
          v18 += 4;
          v17 += 4;
          *int8x16_t v38 = v32;
          v38[1] = v33;
          v38[2] = v34;
          v38[3] = v35;
          v21 += 4;
          uint64_t v20 = v36 + 4;
          v19 += 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            int8x16_t v39 = *v26++;
            int8x16_t v40 = vextq_s8(v39, v39, 0xCuLL);
            int8x16_t v41 = *v36++;
            uint64_t v42 = *((void *)this + 51);
            float32x4_t v43 = vaddq_f32(*(float32x4_t *)(v42 + 16), vmulq_f32(*(float32x4_t *)v42, (float32x4_t)vbslq_s8(*(int8x16_t *)(v42 + 32), v41, v40)));
            float32x4_t v44 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v42 + 64), v43, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v42 + 48), *(float32x2_t *)v43.f32, 1)));
            v44.i32[3] = 1.0;
            *v37++ = v44;
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        int v5 = (int8x16_t *)((char *)v5 + v11);
        int v6 = (float32x4_t *)((char *)v6 + v12);
        float32x4_t v4 = (int8x16_t *)((char *)v4 + v13);
        float32x2_t v14 = (int8x16_t *)((char *)v14 + v13);
        float32x2_t v15 = (int8x16_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV444BiPlanar_601ToRGB::GetDOD(HgcYUV444BiPlanar_601ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcYUV444BiPlanar_601ToRGB::GetROI(HgcYUV444BiPlanar_601ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcYUV444BiPlanar_601ToRGB::HgcYUV444BiPlanar_601ToRGB(HgcYUV444BiPlanar_601ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10ECD90;
  operator new();
}

void sub_1B78FAE7C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444BiPlanar_601ToRGB::~HgcYUV444BiPlanar_601ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10ECD90;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10ECD90;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10ECD90;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV444BiPlanar_601ToRGB::SetParameter(HgcYUV444BiPlanar_601ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  int v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV444BiPlanar_601ToRGB::GetParameter(HgcYUV444BiPlanar_601ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV420BiPlanar_709ToRGB::GetProgram(HgcYUV420BiPlanar_709ToRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const half4 c1 = half4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1048caae:387a44ef:fc83ffd8:52b73979\n"
             "//SIG=00400000:00000001:00000001:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2408e641:b05fbd09:a6279793:e6b41496\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=50acfb20:dc59fe91:195acf38:f03e2245\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_709ToRGB::InitProgramDescriptor(HgcYUV420BiPlanar_709ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_709ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e7\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_709ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
    "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV420BiPlanar_709ToRGB");
}

void sub_1B78FB550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78FB58C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78FB584);
}

char *HgcYUV420BiPlanar_709ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376030;
  strcpy(result, "HgcYUV420BiPlanar_709ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV420BiPlanar_709ToRGB::BindTexture(HgcYUV420BiPlanar_709ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2); {
      (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 0.5, 0.5, 1.0);
      }
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v5)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcYUV420BiPlanar_709ToRGB::Bind(HgcYUV420BiPlanar_709ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV420BiPlanar_709ToRGB::RenderTile(HgcYUV420BiPlanar_709ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    float32x4_t v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B7E77360);
    int32x2_t v8 = a2[2];
    int32x2_t v9 = a2[10];
    uint64_t v10 = 16 * a2[11].i32[0];
    uint64_t v11 = 16 * a2[3].i32[0];
    float32x4_t v12 = 0uLL;
    __asm { FMOV            V5.4S, #4.0 }
    v18.i64[0] = 0x3F0000003F000000;
    v18.i64[1] = 0x3F0000003F000000;
    while (1)
    {
      float32x4_t v19 = vaddq_f32(v7, vmulq_f32(v12, (float32x4_t)xmmword_1B7E75610));
      if (v6 >= 4) {
        break;
      }
      LODWORD(v66) = 0;
      float32x4_t v21 = 0uLL;
      __asm { FMOV            V18.4S, #1.0 }
      if (v6 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v12 = vaddq_f32(v12, _Q18);
      ++v4;
      *(void *)&v9 += v10;
      *(void *)&v8 += v11;
      if (v4 == v3) {
        return 0;
      }
    }
    int v20 = 0;
    float32x4_t v21 = 0uLL;
    uint64_t v22 = 32;
    do
    {
      float32x4_t v23 = vaddq_f32(v19, vmulq_f32(v21, (float32x4_t)xmmword_1B7E75B20));
      float32x4_t v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B7E75B20);
      int32x2_t v27 = a2[12];
      __int32 v28 = a2[13].i32[0];
      float32x4_t v29 = vaddq_f32(vsubq_f32(v23, v5), v18);
      int32x4_t v30 = vcvtq_s32_f32(v29);
      v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
      __int32 v31 = v29.i32[1];
      __int32 v32 = v29.i32[0];
      float32x4_t v33 = vaddq_f32(vsubq_f32(v24, v5), v18);
      int32x4_t v34 = vcvtq_s32_f32(v33);
      __int32 v35 = v32 + v31 * v28;
      v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      __int32 v36 = v33.i32[1];
      __int32 v37 = v33.i32[0];
      int8x16_t v38 = *(int8x16_t *)(*(void *)&v27 + 16 * v35);
      float32x4_t v39 = vaddq_f32(vsubq_f32(v25, v5), v18);
      int32x4_t v40 = vcvtq_s32_f32(v39);
      __int32 v41 = v37 + v36 * v28;
      v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
      __int32 v42 = v39.i32[1];
      __int32 v43 = v39.i32[0];
      int8x16_t v44 = *(int8x16_t *)(*(void *)&v27 + 16 * v41);
      float32x4_t v45 = vaddq_f32(vsubq_f32(v26, v5), v18);
      int32x4_t v46 = vcvtq_s32_f32(v45);
      __int32 v47 = v43 + v42 * v28;
      v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
      __int32 v48 = v45.i32[1];
      __int32 v49 = v45.i32[0];
      int8x16_t v50 = *(int8x16_t *)(*(void *)&v27 + 16 * v47);
      int8x16_t v51 = *(int8x16_t *)(*(void *)&v27 + 16 * (v49 + v48 * v28));
      uint64_t v52 = *((void *)this + 51);
      int8x16_t v53 = *(int8x16_t *)(v52 + 32);
      float32x4_t v54 = *(float32x4_t *)(v52 + 48);
      float32x4_t v55 = *(float32x4_t *)(v52 + 16);
      float32x4_t v56 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(void *)&v9 + v22 - 32), vextq_s8(v38, v38, 0xCuLL))));
      float32x4_t v57 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(void *)&v9 + v22 - 16), vextq_s8(v44, v44, 0xCuLL))));
      float32x4_t v58 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(void *)&v9 + v22), vextq_s8(v50, v50, 0xCuLL))));
      float32x4_t v59 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(void *)&v9 + v22 + 16), vextq_s8(v51, v51, 0xCuLL))));
      float32x4_t v21 = vaddq_f32(v21, _Q5);
      float32x4_t v60 = *(float32x4_t *)(v52 + 64);
      float32x4_t v61 = vaddq_f32(vmulq_laneq_f32(v60, v56, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v56.f32, 1)));
      float32x4_t v62 = vaddq_f32(vmulq_laneq_f32(v60, v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v57.f32, 1)));
      float32x4_t v63 = vaddq_f32(vmulq_laneq_f32(v60, v58, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v58.f32, 1)));
      v61.i32[3] = 1.0;
      v62.i32[3] = 1.0;
      v63.i32[3] = 1.0;
      float32x4_t v64 = vaddq_f32(vmulq_laneq_f32(v60, v59, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v59.f32, 1)));
      v64.i32[3] = 1.0;
      uint64_t v65 = (float32x4_t *)(*(void *)&v8 + v22);
      v65[-2] = v61;
      v65[-1] = v62;
      float32x4_t *v65 = v63;
      v65[1] = v64;
      v20 -= 4;
      v22 += 64;
    }
    while (v6 + v20 > 3);
    LODWORD(v66) = -v20;
    __asm { FMOV            V18.4S, #1.0 }
    if ((int)v66 >= v6) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v66 = v66;
    do
    {
      float32x4_t v68 = vaddq_f32(vsubq_f32(vaddq_f32(v19, vmulq_f32(v21, (float32x4_t)xmmword_1B7E75B20)), v5), v18);
      int32x4_t v69 = vcvtq_s32_f32(v68);
      v68.i64[0] = vaddq_s32(v69, vcgtq_f32(vcvtq_f32_s32(v69), v68)).u64[0];
      uint64_t v70 = *((void *)this + 51);
      float32x4_t v71 = vaddq_f32(*(float32x4_t *)(v70 + 16), vmulq_f32(*(float32x4_t *)v70, (float32x4_t)vbslq_s8(*(int8x16_t *)(v70 + 32), *(int8x16_t *)(*(void *)&v9 + 16 * v66), vextq_s8(*(int8x16_t *)(*(void *)&a2[12] + 16 * (v68.i32[0] + v68.i32[1] * a2[13].i32[0])), *(int8x16_t *)(*(void *)&a2[12] + 16 * (v68.i32[0] + v68.i32[1] * a2[13].i32[0])), 0xCuLL))));
      float32x4_t v72 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v70 + 64), v71, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v70 + 48), *(float32x2_t *)v71.f32, 1)));
      v72.i32[3] = 1.0;
      *(float32x4_t *)(*(void *)&v8 + 16 * v66) = v72;
      float32x4_t v21 = vaddq_f32(v21, _Q18);
      ++v66;
    }
    while (v66 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_709ToRGB::GetDOD(HgcYUV420BiPlanar_709ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  if (!a3) {
    return v5;
  }
  if (a3 == 1)
  {
    uint64_t v6 = HGRectMake4i(0, 0, 1u, 1u);
    int v7 = HGRectGrow(v5, v4, v6);
    float v8 = HGRectFloat(v7);
    float v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    uint64_t v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_709ToRGB::GetROI(HgcYUV420BiPlanar_709ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result = *(void *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      float v5 = HGRectFloat(a4.var0);
      float v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      uint64_t v16 = v15;
      uint64_t v17 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
      uint64_t v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV420BiPlanar_709ToRGB::HgcYUV420BiPlanar_709ToRGB(HgcYUV420BiPlanar_709ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10ECFF8;
  operator new();
}

void sub_1B78FBE34(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_709ToRGB::~HgcYUV420BiPlanar_709ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10ECFF8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10ECFF8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10ECFF8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_709ToRGB::SetParameter(HgcYUV420BiPlanar_709ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  double v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *double v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV420BiPlanar_709ToRGB::GetParameter(HgcYUV420BiPlanar_709ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  float v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcMultiTexBlend_8::GetProgram(HgcMultiTexBlend_8 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000816\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< half > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]], \n"
             "    texture2d< half > hg_Texture6 [[ texture(6) ]], \n"
             "    sampler hg_Sampler6 [[ sampler(6) ]], \n"
             "    texture2d< half > hg_Texture7 [[ texture(7) ]], \n"
             "    sampler hg_Sampler7 [[ sampler(7) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = (half4) hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r6 = (half4) hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
             "    r7 = (half4) hg_Texture7.sample(hg_Sampler7, frag._texCoord7.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    r0 = half4(hg_Params[0].yyyy)*r1 + r0;\n"
             "    r0 = half4(hg_Params[0].zzzz)*r2 + r0;\n"
             "    r0 = half4(hg_Params[0].wwww)*r3 + r0;\n"
             "    r0 = half4(hg_Params[1].xxxx)*r4 + r0;\n"
             "    r0 = half4(hg_Params[1].yyyy)*r5 + r0;\n"
             "    r0 = half4(hg_Params[1].zzzz)*r6 + r0;\n"
             "    output.color0 = hg_Params[1].wwww*float4(r7) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ba77e172:499d5e50:ba48f7a9:fb1ede91\n"
             "//SIG=00400000:000000ff:000000ff:000000ff:0000:0002:0008:0000:0000:0000:01fe:0000:0008:08:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000079e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< float > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]], \n"
             "    texture2d< float > hg_Texture6 [[ texture(6) ]], \n"
             "    sampler hg_Sampler6 [[ sampler(6) ]], \n"
             "    texture2d< float > hg_Texture7 [[ texture(7) ]], \n"
             "    sampler hg_Sampler7 [[ sampler(7) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r6 = hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
             "    r7 = hg_Texture7.sample(hg_Sampler7, frag._texCoord7.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
             "    r0 = hg_Params[0].wwww*r3 + r0;\n"
             "    r0 = hg_Params[1].xxxx*r4 + r0;\n"
             "    r0 = hg_Params[1].yyyy*r5 + r0;\n"
             "    r0 = hg_Params[1].zzzz*r6 + r0;\n"
             "    output.color0 = hg_Params[1].wwww*r7 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e2d0b895:1047a73b:cf113545:5f20f4cb\n"
             "//SIG=00000000:000000ff:000000ff:00000000:0000:0002:0008:0000:0000:0000:01fe:0000:0008:08:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000006b4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp sampler2D hg_Texture5;\n"
           "uniform defaultp sampler2D hg_Texture6;\n"
           "uniform defaultp sampler2D hg_Texture7;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "varying highp vec4 hg_TexCoord5;\n"
           "varying highp vec4 hg_TexCoord6;\n"
           "varying highp vec4 hg_TexCoord7;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r5 = texture2D(hg_Texture5, hg_TexCoord5.xy);\n"
           "    r6 = texture2D(hg_Texture6, hg_TexCoord6.xy);\n"
           "    r7 = texture2D(hg_Texture7, hg_TexCoord7.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    r0 = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "    r0 = hg_ProgramLocal0.zzzz*r2 + r0;\n"
           "    r0 = hg_ProgramLocal0.wwww*r3 + r0;\n"
           "    r0 = hg_ProgramLocal1.xxxx*r4 + r0;\n"
           "    r0 = hg_ProgramLocal1.yyyy*r5 + r0;\n"
           "    r0 = hg_ProgramLocal1.zzzz*r6 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal1.wwww*r7 + r0;\n"
           "}\n"
           "//MD5=037c2ec9:d4a3ecf1:f512314e:ade30c08\n"
           "//SIG=00000000:000000ff:000000ff:00000000:0000:0002:0008:0000:0000:0000:0000:0000:0008:08:0:1:0\n";
  }
}

void HgcMultiTexBlend_8::InitProgramDescriptor(HgcMultiTexBlend_8 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_8_hgc_visible", "//Metal1.0     \n//LEN=000000031d\n[[ visible ]] FragmentOut HgcMultiTexBlend_8_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4,\n    float4 color5,\n    float4 color6,\n    float4 color7)\n{\n    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r5 = color5;\n"
    "    r6 = color6;\n"
    "    r7 = color7;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
    "    r0 = hg_Params[0].wwww*r3 + r0;\n"
    "    r0 = hg_Params[1].xxxx*r4 + r0;\n"
    "    r0 = hg_Params[1].yyyy*r5 + r0;\n"
    "    r0 = hg_Params[1].zzzz*r6 + r0;\n"
    "    output.color0 = hg_Params[1].wwww*r7 + r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcMultiTexBlend_8");
}

void sub_1B78FC768(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78FC7B4(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78FC7ACLL);
}

double HgcMultiTexBlend_8::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcMultiTexBlend_8 [hgc1]");
  return *(double *)"exBlend_8 [hgc1]";
}

uint64_t HgcMultiTexBlend_8::BindTexture(HgcMultiTexBlend_8 *this, HGHandler *a2, int a3)
{
  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 0;
      goto LABEL_11;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 1;
      goto LABEL_11;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 2;
      goto LABEL_11;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 3;
      goto LABEL_11;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 4;
      goto LABEL_11;
    case 5:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 5, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 5;
      goto LABEL_11;
    case 6:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 6, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 6;
      goto LABEL_11;
    case 7:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 7, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 7;
LABEL_11:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      int v7 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
      uint64_t result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
        uint64_t result = 0;
      }
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcMultiTexBlend_8::Bind(HgcMultiTexBlend_8 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcMultiTexBlend_8::RenderTile(HgcMultiTexBlend_8 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 12);
    double v6 = (float32x4_t *)*((void *)a2 + 14);
    int v7 = (float32x4_t *)*((void *)a2 + 16);
    double v8 = (float32x4_t *)*((void *)a2 + 18);
    uint64_t v9 = (float32x4_t *)*((void *)a2 + 20);
    uint64_t v10 = (float32x4_t *)*((void *)a2 + 22);
    float v11 = (float32x4_t *)*((void *)a2 + 24);
    float v12 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v13 = *((int *)a2 + 6);
    uint64_t v14 = *((int *)a2 + 50);
    uint64_t v15 = *((int *)a2 + 46);
    uint64_t v16 = *((int *)a2 + 42);
    uint64_t v17 = *((int *)a2 + 38);
    uint64_t v18 = *((int *)a2 + 34);
    uint64_t v19 = *((int *)a2 + 30);
    uint64_t v20 = *((int *)a2 + 26);
    uint64_t v21 = *((int *)a2 + 22);
    if (v3 < 2)
    {
      if (v3 == 1)
      {
        uint64_t v40 = 16 * v21;
        uint64_t v41 = 16 * v19;
        uint64_t v42 = 16 * v18;
        uint64_t v43 = 16 * v17;
        uint64_t v44 = 16 * v16;
        uint64_t v45 = 16 * v15;
        uint64_t v46 = 16 * v14;
        uint64_t v47 = 16 * v13;
        do
        {
          __int32 v48 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v49 = v48[1];
          float32x4_t v50 = vaddq_f32(vmulq_laneq_f32(*v10, v49, 2), vaddq_f32(vmulq_lane_f32(*v9, *(float32x2_t *)v49.f32, 1), vaddq_f32(vmulq_n_f32(*v8, v49.f32[0]), vaddq_f32(vmulq_laneq_f32(*v7, *v48, 3), vaddq_f32(vmulq_laneq_f32(*v6, *v48, 2), vaddq_f32(vmulq_n_f32(*v4, COERCE_FLOAT(*v48)), vmulq_lane_f32(*v5, *(float32x2_t *)v48->f32, 1)))))));
          uint64_t v4 = (float32x4_t *)((char *)v4 + v40);
          v5 += v20;
          double v6 = (float32x4_t *)((char *)v6 + v41);
          int v7 = (float32x4_t *)((char *)v7 + v42);
          double v8 = (float32x4_t *)((char *)v8 + v43);
          uint64_t v9 = (float32x4_t *)((char *)v9 + v44);
          *float v12 = vaddq_f32(vmulq_laneq_f32(*v11, v49, 3), v50);
          uint64_t v10 = (float32x4_t *)((char *)v10 + v45);
          float v11 = (float32x4_t *)((char *)v11 + v46);
          float v12 = (float32x4_t *)((char *)v12 + v47);
          --v2;
        }
        while (v2);
      }
    }
    else
    {
      int v22 = 0;
      uint64_t v23 = 16 * v19;
      uint64_t v24 = 16 * v18;
      uint64_t v25 = 16 * v17;
      uint64_t v26 = 16 * v16;
      uint64_t v27 = 16 * v15;
      uint64_t v28 = 16 * v14;
      uint64_t v29 = 16 * v13;
      uint64_t v30 = 16 * v21;
      uint64_t v31 = 16 * v20;
      do
      {
        uint64_t v32 = 0;
        int v33 = 0;
        do
        {
          int32x4_t v34 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v35 = v34[1];
          float32x4_t v36 = vaddq_f32(vmulq_laneq_f32(v11[v32 + 1], v35, 3), vaddq_f32(vmulq_laneq_f32(v10[v32 + 1], v35, 2), vaddq_f32(vmulq_lane_f32(v9[v32 + 1], *(float32x2_t *)v35.f32, 1), vaddq_f32(vmulq_n_f32(v8[v32 + 1], v35.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v32 + 1], *v34, 3), vaddq_f32(vmulq_laneq_f32(v6[v32 + 1], *v34, 2), vaddq_f32(vmulq_n_f32(v4[v32 + 1], COERCE_FLOAT(*v34)), vmulq_lane_f32(v5[v32 + 1], *(float32x2_t *)v34->f32, 1))))))));
          __int32 v37 = &v12[v32];
          *__int32 v37 = vaddq_f32(vmulq_laneq_f32(v11[v32], v35, 3), vaddq_f32(vmulq_laneq_f32(v10[v32], v35, 2), vaddq_f32(vmulq_lane_f32(v9[v32], *(float32x2_t *)v35.f32, 1), vaddq_f32(vmulq_n_f32(v8[v32], v35.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v32], *v34, 3), vaddq_f32(vmulq_laneq_f32(v6[v32], *v34, 2), vaddq_f32(vmulq_n_f32(v4[v32], COERCE_FLOAT(*v34)), vmulq_lane_f32(v5[v32], *(float32x2_t *)v34->f32, 1))))))));
          v37[1] = v36;
          v33 -= 2;
          v32 += 2;
        }
        while (v3 + v33 > 1);
        if (v3 > -v33)
        {
          int8x16_t v38 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v39 = v38[1];
          v12[v32] = vaddq_f32(vmulq_laneq_f32(v11[v32], v39, 3), vaddq_f32(vmulq_laneq_f32(v10[v32], v39, 2), vaddq_f32(vmulq_lane_f32(v9[v32], *(float32x2_t *)v39.f32, 1), vaddq_f32(vmulq_n_f32(v8[v32], v39.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v32], *v38, 3), vaddq_f32(vmulq_laneq_f32(v6[v32], *v38, 2), vaddq_f32(vmulq_n_f32(v4[v32], COERCE_FLOAT(*v38)), vmulq_lane_f32(v5[v32], *(float32x2_t *)v38->f32, 1))))))));
        }
        ++v22;
        double v6 = (float32x4_t *)((char *)v6 + v23);
        int v7 = (float32x4_t *)((char *)v7 + v24);
        double v8 = (float32x4_t *)((char *)v8 + v25);
        uint64_t v9 = (float32x4_t *)((char *)v9 + v26);
        uint64_t v10 = (float32x4_t *)((char *)v10 + v27);
        float v11 = (float32x4_t *)((char *)v11 + v28);
        float v12 = (float32x4_t *)((char *)v12 + v29);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v30);
        int v5 = (float32x4_t *)((char *)v5 + v31);
      }
      while (v22 != v2);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_8::GetDOD(HgcMultiTexBlend_8 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 8) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcMultiTexBlend_8::GetROI(HgcMultiTexBlend_8 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 8) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcMultiTexBlend_8::HgcMultiTexBlend_8(HgcMultiTexBlend_8 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10ED260;
  operator new();
}

void sub_1B78FD0F8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_8::~HgcMultiTexBlend_8(HGNode *this)
{
  *(void *)this = &unk_1F10ED260;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10ED260;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_8::SetParameter(HgcMultiTexBlend_8 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  double v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *double v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcMultiTexBlend_8::GetParameter(HgcMultiTexBlend_8 *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcMultiTexBlend_2::GetProgram(HgcMultiTexBlend_2 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000318\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    output.color0 = hg_Params[0].yyyy*float4(r1) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6a73d4da:17adb56f:e7bd03ff:96b24d50\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002f4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    output.color0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4e913d9e:9986742c:dfcf17ed:4ab82079\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002a2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    gl_FragColor = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "}\n"
           "//MD5=e2a4ad3f:8093be2a:11c9162f:b54ec260\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcMultiTexBlend_2::InitProgramDescriptor(HgcMultiTexBlend_2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_2_hgc_visible", "//Metal1.0     \n//LEN=0000000155\n[[ visible ]] FragmentOut HgcMultiTexBlend_2_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    output.color0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcMultiTexBlend_2");
}

void sub_1B78FD630(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78FD664(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78FD65CLL);
}

double HgcMultiTexBlend_2::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcMultiTexBlend_2 [hgc1]");
  return *(double *)"exBlend_2 [hgc1]";
}

uint64_t HgcMultiTexBlend_2::BindTexture(HgcMultiTexBlend_2 *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 1;
  }
  else
  {
    if (a3) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcMultiTexBlend_2::Bind(HgcMultiTexBlend_2 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcMultiTexBlend_2::RenderTile(HgcMultiTexBlend_2 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 12);
    int v6 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v7 = *((int *)a2 + 6);
    uint64_t v8 = *((int *)a2 + 26);
    uint64_t v9 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v33 = 0;
        uint64_t v34 = 16 * v9;
        uint64_t v35 = 16 * v8;
        uint64_t v36 = 16 * v7;
        uint64_t v37 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v38 = 0;
          do
          {
            v6[v38 / 0x10] = vaddq_f32(vmulq_n_f32(v4[v38 / 0x10], COERCE_FLOAT(*(_OWORD *)*((void *)this + 51))), vmulq_lane_f32(v5[v38 / 0x10], **((float32x2_t **)this + 51), 1));
            v38 += 16;
          }
          while (v37 != v38);
          ++v33;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v34);
          int v5 = (float32x4_t *)((char *)v5 + v35);
          int v6 = (float32x4_t *)((char *)v6 + v36);
        }
        while (v33 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      uint64_t v14 = v4 + 4;
      uint64_t v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        unint64_t v17 = 0;
        unint64_t v18 = 0;
        uint64_t v19 = v16;
        uint64_t v20 = v15;
        uint64_t v21 = v14;
        do
        {
          int v22 = v21;
          uint64_t v23 = v20;
          uint64_t v24 = v19;
          long long v25 = *(_OWORD *)*((void *)this + 51);
          float32x4_t v26 = vaddq_f32(vmulq_n_f32(v4[v17 + 1], *(float *)&v25), vmulq_lane_f32(v5[v17 + 1], *(float32x2_t *)&v25, 1));
          float32x4_t v27 = vaddq_f32(vmulq_n_f32(v4[v17 + 2], *(float *)&v25), vmulq_lane_f32(v5[v17 + 2], *(float32x2_t *)&v25, 1));
          float32x4_t v28 = vaddq_f32(vmulq_n_f32(v4[v17 + 3], *(float *)&v25), vmulq_lane_f32(v5[v17 + 3], *(float32x2_t *)&v25, 1));
          uint64_t v29 = &v6[v17];
          *uint64_t v29 = vaddq_f32(vmulq_n_f32(v4[v17], *(float *)&v25), vmulq_lane_f32(v5[v17], *(float32x2_t *)&v25, 1));
          v29[1] = v26;
          v18 += 4;
          v17 += 4;
          v29[2] = v27;
          v29[3] = v28;
          v21 += 4;
          v20 += 4;
          uint64_t v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            float32x4_t v30 = *v22++;
            float32x4_t v31 = v30;
            float32x4_t v32 = *v23++;
            *v24++ = vaddq_f32(vmulq_n_f32(v31, COERCE_FLOAT(*(_OWORD *)*((void *)this + 51))), vmulq_lane_f32(v32, **((float32x2_t **)this + 51), 1));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        int v5 = (float32x4_t *)((char *)v5 + v11);
        int v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v13);
        uint64_t v14 = (float32x4_t *)((char *)v14 + v13);
        uint64_t v15 = (float32x4_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_2::GetDOD(HgcMultiTexBlend_2 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcMultiTexBlend_2::GetROI(HgcMultiTexBlend_2 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcMultiTexBlend_2::HgcMultiTexBlend_2(HgcMultiTexBlend_2 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10ED4C8;
  operator new();
}

void sub_1B78FDB64(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_2::~HgcMultiTexBlend_2(HGNode *this)
{
  *(void *)this = &unk_1F10ED4C8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10ED4C8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_2::SetParameter(HgcMultiTexBlend_2 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcMultiTexBlend_2::GetParameter(HgcMultiTexBlend_2 *this, int a2, float *a3)
{
  if (!a2)
  {
    unint64_t v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcMultiTexBlend_5::GetProgram(HgcMultiTexBlend_5 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000592\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    r0 = half4(hg_Params[0].yyyy)*r1 + r0;\n"
             "    r0 = half4(hg_Params[0].zzzz)*r2 + r0;\n"
             "    r0 = half4(hg_Params[0].wwww)*r3 + r0;\n"
             "    output.color0 = hg_Params[1]*float4(r4) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2ebe55f7:cd345d72:633071a4:844930c7\n"
             "//SIG=00400000:0000001f:0000001f:0000001f:0000:0002:0005:0000:0000:0000:003e:0000:0005:05:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000544\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
             "    r0 = hg_Params[0].wwww*r3 + r0;\n"
             "    output.color0 = hg_Params[1]*r4 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4d49c78f:1cb5eac2:32689adf:f7a27f9e\n"
             "//SIG=00000000:0000001f:0000001f:00000000:0000:0002:0005:0000:0000:0000:003e:0000:0005:05:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004ba\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    r0 = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "    r0 = hg_ProgramLocal0.zzzz*r2 + r0;\n"
           "    r0 = hg_ProgramLocal0.wwww*r3 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal1*r4 + r0;\n"
           "}\n"
           "//MD5=ae575d71:1ffff228:b9e973a0:e48fa370\n"
           "//SIG=00000000:0000001f:0000001f:00000000:0000:0002:0005:0000:0000:0000:0000:0000:0005:05:0:1:0\n";
  }
}

void HgcMultiTexBlend_5::InitProgramDescriptor(HgcMultiTexBlend_5 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_5_hgc_visible", "//Metal1.0     \n//LEN=0000000234\n[[ visible ]] FragmentOut HgcMultiTexBlend_5_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4)\n{\n    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
    "    r0 = hg_Params[0].wwww*r3 + r0;\n"
    "    output.color0 = hg_Params[1]*r4 + r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcMultiTexBlend_5");
}

void sub_1B78FE240(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78FE280(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78FE278);
}

double HgcMultiTexBlend_5::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcMultiTexBlend_5 [hgc1]");
  return *(double *)"exBlend_5 [hgc1]";
}

uint64_t HgcMultiTexBlend_5::BindTexture(HgcMultiTexBlend_5 *this, HGHandler *a2, int a3)
{
  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 0;
      goto LABEL_8;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 1;
      goto LABEL_8;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 2;
      goto LABEL_8;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 3;
      goto LABEL_8;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 4;
LABEL_8:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      int v7 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
      uint64_t result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
        uint64_t result = 0;
      }
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcMultiTexBlend_5::Bind(HgcMultiTexBlend_5 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcMultiTexBlend_5::RenderTile(HgcMultiTexBlend_5 *this, HGTile *a2)
{
  int v70 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v70 >= 1)
  {
    uint64_t v2 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    unint64_t v3 = (float32x4_t *)*((void *)a2 + 10);
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 12);
    int v5 = (float32x4_t *)*((void *)a2 + 14);
    int v6 = (float32x4_t *)*((void *)a2 + 16);
    int v7 = (float32x4_t *)*((void *)a2 + 18);
    uint64_t v8 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v9 = *((int *)a2 + 6);
    uint64_t v10 = *((int *)a2 + 38);
    uint64_t v11 = *((int *)a2 + 34);
    uint64_t v12 = *((int *)a2 + 30);
    uint64_t v13 = *((int *)a2 + 26);
    uint64_t v14 = *((int *)a2 + 22);
    if ((int)v2 < 3)
    {
      if ((int)v2 >= 1)
      {
        int v53 = 0;
        uint64_t v54 = 16 * v14;
        uint64_t v55 = 16 * v13;
        uint64_t v56 = 16 * v12;
        uint64_t v57 = 16 * v11;
        uint64_t v58 = 16 * v10;
        uint64_t v59 = 16 * v9;
        uint64_t v60 = 16 * v2;
        do
        {
          unint64_t v61 = 0;
          do
          {
            float32x4_t v62 = (float32x4_t *)*((void *)this + 51);
            v8[v61 / 0x10] = vaddq_f32(vmulq_f32(v7[v61 / 0x10], v62[1]), vaddq_f32(vmulq_laneq_f32(v6[v61 / 0x10], *v62, 3), vaddq_f32(vmulq_laneq_f32(v5[v61 / 0x10], *v62, 2), vaddq_f32(vmulq_n_f32(v3[v61 / 0x10], COERCE_FLOAT(*v62)), vmulq_lane_f32(v4[v61 / 0x10], *(float32x2_t *)v62->f32, 1)))));
            v61 += 16;
          }
          while (v60 != v61);
          ++v53;
          unint64_t v3 = (float32x4_t *)((char *)v3 + v54);
          uint64_t v4 = (float32x4_t *)((char *)v4 + v55);
          int v5 = (float32x4_t *)((char *)v5 + v56);
          int v6 = (float32x4_t *)((char *)v6 + v57);
          int v7 = (float32x4_t *)((char *)v7 + v58);
          uint64_t v8 = (float32x4_t *)((char *)v8 + v59);
        }
        while (v53 != v70);
      }
    }
    else
    {
      int v15 = 0;
      uint64_t v69 = v13;
      uint64_t v68 = 16 * v12;
      uint64_t v67 = 16 * v11;
      uint64_t v16 = v3 + 3;
      uint64_t v66 = 16 * v10;
      unint64_t v17 = v4 + 3;
      uint64_t v65 = 16 * v9;
      unint64_t v18 = v5 + 3;
      uint64_t v64 = v14;
      uint64_t v19 = v6 + 3;
      uint64_t v20 = v7 + 3;
      uint64_t v21 = v8 + 3;
      do
      {
        int v73 = v15;
        unint64_t v22 = 0;
        uint64_t v23 = 0;
        int v24 = 3;
        long long v25 = v21;
        float32x4_t v26 = v20;
        float32x4_t v27 = v19;
        float32x4_t v28 = v18;
        float32x4_t v71 = v17;
        float32x4_t v72 = v16;
        do
        {
          uint64_t v29 = v16;
          float32x4_t v30 = v17;
          float32x4_t v31 = v28;
          float32x4_t v32 = v27;
          int v33 = v26;
          uint64_t v34 = v25;
          int v35 = v24;
          uint64_t v36 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v37 = v36[1];
          float32x4_t v38 = vaddq_f32(vmulq_laneq_f32(v6[v22 + 2], *v36, 3), vaddq_f32(vmulq_laneq_f32(v5[v22 + 2], *v36, 2), vaddq_f32(vmulq_n_f32(v3[v22 + 2], COERCE_FLOAT(*v36)), vmulq_lane_f32(v4[v22 + 2], *(float32x2_t *)v36->f32, 1))));
          float32x4_t v39 = vaddq_f32(vmulq_f32(v7[v22], v37), vaddq_f32(vmulq_laneq_f32(v6[v22], *v36, 3), vaddq_f32(vmulq_laneq_f32(v5[v22], *v36, 2), vaddq_f32(vmulq_n_f32(v3[v22], COERCE_FLOAT(*v36)), vmulq_lane_f32(v4[v22], *(float32x2_t *)v36->f32, 1)))));
          float32x4_t v40 = vaddq_f32(vmulq_f32(v7[v22 + 1], v37), vaddq_f32(vmulq_laneq_f32(v6[v22 + 1], *v36, 3), vaddq_f32(vmulq_laneq_f32(v5[v22 + 1], *v36, 2), vaddq_f32(vmulq_n_f32(v3[v22 + 1], COERCE_FLOAT(*v36)), vmulq_lane_f32(v4[v22 + 1], *(float32x2_t *)v36->f32, 1)))));
          float32x4_t v41 = vmulq_f32(v7[v22 + 2], v37);
          uint64_t v42 = &v8[v22];
          v23 += 3;
          v22 += 3;
          uint64_t v16 = v29 + 3;
          v17 += 3;
          v28 += 3;
          v27 += 3;
          *uint64_t v42 = v39;
          v42[1] = v40;
          v42[2] = vaddq_f32(v41, v38);
          v26 += 3;
          v25 += 3;
          int v24 = v35 + 3;
        }
        while (v23 < v2 - 2);
        if ((int)v2 > (int)v23)
        {
          do
          {
            float32x4_t v43 = *v29++;
            float32x4_t v44 = v43;
            float32x4_t v45 = *v30++;
            float32x4_t v46 = v45;
            float32x4_t v47 = *v31++;
            float32x4_t v48 = v47;
            float32x4_t v49 = *v32++;
            float32x4_t v50 = v49;
            int8x16_t v51 = (float32x4_t *)*((void *)this + 51);
            float32x4_t v52 = *v33++;
            *v34++ = vaddq_f32(vmulq_f32(v52, v51[1]), vaddq_f32(vmulq_laneq_f32(v50, *v51, 3), vaddq_f32(vmulq_laneq_f32(v48, *v51, 2), vaddq_f32(vmulq_n_f32(v44, COERCE_FLOAT(*v51)), vmulq_lane_f32(v46, *(float32x2_t *)v51->f32, 1)))));
            ++v35;
          }
          while ((int)v2 > v35);
        }
        int v15 = v73 + 1;
        uint64_t v4 = (float32x4_t *)((char *)v4 + v69 * 16);
        int v5 = (float32x4_t *)((char *)v5 + v68);
        int v6 = (float32x4_t *)((char *)v6 + v67);
        int v7 = (float32x4_t *)((char *)v7 + v66);
        uint64_t v8 = (float32x4_t *)((char *)v8 + v65);
        unint64_t v3 = (float32x4_t *)((char *)v3 + v64 * 16);
        uint64_t v16 = &v72[v64];
        unint64_t v17 = &v71[v69];
        unint64_t v18 = (float32x4_t *)((char *)v18 + v68);
        uint64_t v19 = (float32x4_t *)((char *)v19 + v67);
        uint64_t v20 = (float32x4_t *)((char *)v20 + v66);
        uint64_t v21 = (float32x4_t *)((char *)v21 + v65);
      }
      while (v73 + 1 != v70);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_5::GetDOD(HgcMultiTexBlend_5 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 5) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcMultiTexBlend_5::GetROI(HgcMultiTexBlend_5 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 5) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcMultiTexBlend_5::HgcMultiTexBlend_5(HgcMultiTexBlend_5 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10ED730;
  operator new();
}

void sub_1B78FEAD8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_5::~HgcMultiTexBlend_5(HGNode *this)
{
  *(void *)this = &unk_1F10ED730;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40EED21634);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10ED730;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40EED21634);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_5::SetParameter(HgcMultiTexBlend_5 *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  if (a2 == 1)
  {
    uint64_t v9 = *((void *)this + 51);
    if (*(float *)(v9 + 16) != a3.n128_f32[0]
      || *(float *)(v9 + 20) != a3.n128_f32[0]
      || *(float *)(v9 + 24) != a3.n128_f32[0]
      || *(float *)(v9 + 28) != a3.n128_f32[0])
    {
      int32x4_t v10 = vdupq_lane_s32((int32x2_t)a3.n128_u64[0], 0);
      a3.n128_f32[1] = a4;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      *(int32x4_t *)(v9 + 16) = v10;
      *(__n128 *)(v9 + 32) = a3;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    }
  }
  else
  {
    if (a2) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v7 = *((void *)this + 51);
    if (*(float *)v7 != a3.n128_f32[0]
      || *(float *)(v7 + 4) != a4
      || *(float *)(v7 + 8) != a5
      || *(float *)(v7 + 12) != a6)
    {
      *(_DWORD *)uint64_t v7 = a3.n128_u32[0];
      *(float *)(v7 + 4) = a4;
      *(float *)(v7 + 8) = a5;
      *(float *)(v7 + 12) = a6;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_5::GetParameter(HgcMultiTexBlend_5 *this, int a2, float *a3)
{
  if (a2 == 1)
  {
    int v5 = (float *)*((void *)this + 51);
    *a3 = v5[8];
    a3[1] = v5[9];
    a3[2] = v5[10];
    uint64_t result = 0;
    a3[3] = v5[11];
  }
  else if (a2)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    unint64_t v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    uint64_t result = 0;
    a3[3] = v3[3];
  }
  return result;
}

const char *HgcYUV444BiPlanar_709ToRGB::GetProgram(HgcYUV444BiPlanar_709ToRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const half4 c1 = half4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1048caae:387a44ef:fc83ffd8:52b73979\n"
             "//SIG=00400000:00000003:00000003:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
             "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2408e641:b05fbd09:a6279793:e6b41496\n"
             "//SIG=00000000:00000003:00000003:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=50acfb20:dc59fe91:195acf38:f03e2245\n"
           "//SIG=00000000:00000003:00000003:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV444BiPlanar_709ToRGB::InitProgramDescriptor(HgcYUV444BiPlanar_709ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV444BiPlanar_709ToRGB_hgc_visible", "//Metal1.0     \n//LEN=000000027e\n[[ visible ]] FragmentOut HgcYUV444BiPlanar_709ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(0.000000000, -0.1873242706, 1.855599999, 0.000000000);\n"
    "    const float4 c1 = float4(1.574800014, -0.4681242704, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = color1.xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV444BiPlanar_709ToRGB");
}

void sub_1B78FF078(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78FF0AC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78FF0A4);
}

char *HgcYUV444BiPlanar_709ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376030;
  strcpy(result, "HgcYUV444BiPlanar_709ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV444BiPlanar_709ToRGB::BindTexture(HgcYUV444BiPlanar_709ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 != 1) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcYUV444BiPlanar_709ToRGB::Bind(HgcYUV444BiPlanar_709ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV444BiPlanar_709ToRGB::RenderTile(HgcYUV444BiPlanar_709ToRGB *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = (int8x16_t *)*((void *)a2 + 12);
    int v5 = (int8x16_t *)*((void *)a2 + 10);
    int v6 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v7 = *((int *)a2 + 6);
    uint64_t v8 = *((int *)a2 + 22);
    uint64_t v9 = *((int *)a2 + 26);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v45 = 0;
        uint64_t v46 = 16 * v9;
        uint64_t v47 = 16 * v8;
        uint64_t v48 = 16 * v7;
        uint64_t v49 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v50 = 0;
          do
          {
            uint64_t v51 = *((void *)this + 51);
            float32x4_t v52 = vaddq_f32(*(float32x4_t *)(v51 + 16), vmulq_f32(*(float32x4_t *)v51, (float32x4_t)vbslq_s8(*(int8x16_t *)(v51 + 32), v5[v50 / 0x10], vextq_s8(v4[v50 / 0x10], v4[v50 / 0x10], 0xCuLL))));
            float32x4_t v53 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v51 + 64), v52, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v51 + 48), *(float32x2_t *)v52.f32, 1)));
            v53.i32[3] = 1.0;
            v6[v50 / 0x10] = v53;
            v50 += 16;
          }
          while (v49 != v50);
          ++v45;
          uint64_t v4 = (int8x16_t *)((char *)v4 + v46);
          int v5 = (int8x16_t *)((char *)v5 + v47);
          int v6 = (float32x4_t *)((char *)v6 + v48);
        }
        while (v45 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      uint64_t v14 = v4 + 4;
      int v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        uint64_t v17 = 0;
        unint64_t v18 = 0;
        uint64_t v19 = v16;
        uint64_t v20 = v15;
        uint64_t v21 = v14;
        do
        {
          uint64_t v22 = *((void *)this + 51);
          int8x16_t v23 = *(int8x16_t *)(v22 + 32);
          float32x4_t v24 = *(float32x4_t *)(v22 + 48);
          float32x4_t v25 = *(float32x4_t *)(v22 + 16);
          float32x4_t v26 = v21;
          float32x4_t v27 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17], vextq_s8(v4[v17], v4[v17], 0xCuLL))));
          float32x4_t v28 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 1], vextq_s8(v4[v17 + 1], v4[v17 + 1], 0xCuLL))));
          float32x4_t v29 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 2], vextq_s8(v4[v17 + 2], v4[v17 + 2], 0xCuLL))));
          float32x4_t v30 = vaddq_f32(v25, vmulq_f32(*(float32x4_t *)v22, (float32x4_t)vbslq_s8(v23, v5[v17 + 3], vextq_s8(v4[v17 + 3], v4[v17 + 3], 0xCuLL))));
          float32x4_t v31 = *(float32x4_t *)(v22 + 64);
          float32x4_t v32 = vaddq_f32(vmulq_laneq_f32(v31, v27, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v27.f32, 1)));
          float32x4_t v33 = vaddq_f32(vmulq_laneq_f32(v31, v28, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v28.f32, 1)));
          float32x4_t v34 = vaddq_f32(vmulq_laneq_f32(v31, v29, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v29.f32, 1)));
          v32.i32[3] = 1.0;
          v33.i32[3] = 1.0;
          float32x4_t v35 = vaddq_f32(vmulq_laneq_f32(v31, v30, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 0), vmulq_lane_f32(v24, *(float32x2_t *)v30.f32, 1)));
          v34.i32[3] = 1.0;
          v35.i32[3] = 1.0;
          uint64_t v36 = v20;
          float32x4_t v37 = v19;
          float32x4_t v38 = &v6[v17];
          v18 += 4;
          v17 += 4;
          *float32x4_t v38 = v32;
          v38[1] = v33;
          v38[2] = v34;
          v38[3] = v35;
          v21 += 4;
          uint64_t v20 = v36 + 4;
          v19 += 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            int8x16_t v39 = *v26++;
            int8x16_t v40 = vextq_s8(v39, v39, 0xCuLL);
            int8x16_t v41 = *v36++;
            uint64_t v42 = *((void *)this + 51);
            float32x4_t v43 = vaddq_f32(*(float32x4_t *)(v42 + 16), vmulq_f32(*(float32x4_t *)v42, (float32x4_t)vbslq_s8(*(int8x16_t *)(v42 + 32), v41, v40)));
            float32x4_t v44 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v42 + 64), v43, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v42 + 48), *(float32x2_t *)v43.f32, 1)));
            v44.i32[3] = 1.0;
            *v37++ = v44;
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        int v5 = (int8x16_t *)((char *)v5 + v11);
        int v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (int8x16_t *)((char *)v4 + v13);
        uint64_t v14 = (int8x16_t *)((char *)v14 + v13);
        int v15 = (int8x16_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t HgcYUV444BiPlanar_709ToRGB::GetDOD(HgcYUV444BiPlanar_709ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcYUV444BiPlanar_709ToRGB::GetROI(HgcYUV444BiPlanar_709ToRGB *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcYUV444BiPlanar_709ToRGB::HgcYUV444BiPlanar_709ToRGB(HgcYUV444BiPlanar_709ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10ED998;
  operator new();
}

void sub_1B78FF6CC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV444BiPlanar_709ToRGB::~HgcYUV444BiPlanar_709ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10ED998;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10ED998;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10ED998;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV444BiPlanar_709ToRGB::SetParameter(HgcYUV444BiPlanar_709ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  int v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV444BiPlanar_709ToRGB::GetParameter(HgcYUV444BiPlanar_709ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorClamp::GetProgram(HgcColorClamp *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000265\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmin(r0, half4(hg_Params[0]));\n"
             "    output.color0 = fmax(float4(r0), hg_Params[1]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1fa9eff4:6b098975:051c3a71:ce7e3a5d\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0002:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000250\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmin(r0, hg_Params[0]);\n"
             "    output.color0 = fmax(r0, hg_Params[1]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8bd8f6b7:d61ba1b5:de97aeb6:868bcdb1\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0002:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000248\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = min(r0, hg_ProgramLocal0);\n"
           "    gl_FragColor = max(r0, hg_ProgramLocal1);\n"
           "}\n"
           "//MD5=b29813de:3fb28b2e:1d30ba03:4d6a0c54\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0002:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorClamp::InitProgramDescriptor(HgcColorClamp *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorClamp_hgc_visible", "//Metal1.0     \n//LEN=0000000127\n[[ visible ]] FragmentOut HgcColorClamp_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = fmin(r0, hg_Params[0]);\n"
    "    output.color0 = fmax(r0, hg_Params[1]);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorClamp");
}

void sub_1B78FFBD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B78FFC08(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B78FFC00);
}

void HgcColorClamp::shaderDescription(char *a1@<X8>)
{
  a1[23] = 20;
  strcpy(a1, "HgcColorClamp [hgc1]");
}

uint64_t HgcColorClamp::BindTexture(HgcColorClamp *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcColorClamp::Bind(HgcColorClamp *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorClamp::RenderTile(HgcColorClamp *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v27 = 0;
        uint64_t v28 = 16 * v7;
        uint64_t v29 = 16 * v6;
        uint64_t v30 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v31 = 0;
          do
          {
            v5[v31 / 0x10] = vmaxq_f32(vminq_f32(v4[v31 / 0x10], *(float32x4_t *)*((void *)this + 51)), *(float32x4_t *)(*((void *)this + 51) + 16));
            v31 += 16;
          }
          while (v30 != v31);
          ++v27;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v28);
          int v5 = (float32x4_t *)((char *)v5 + v29);
        }
        while (v27 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      uint64_t v11 = v4 + 4;
      uint64_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        uint64_t v14 = v12;
        int v15 = v11;
        uint64_t v16 = 2;
        do
        {
          uint64_t v17 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v18 = v17[1];
          float32x4_t v19 = vminq_f32(v4[v16 - 2], *v17);
          float32x4_t v20 = vminq_f32(v4[v16 - 1], *v17);
          float32x4_t v21 = vminq_f32(v4[v16], *v17);
          float32x4_t v22 = vminq_f32(v4[v16 + 1], *v17);
          int8x16_t v23 = v15;
          float32x4_t v24 = v14;
          float32x4_t v25 = &v5[v16];
          v25[-2] = vmaxq_f32(v19, v18);
          v25[-1] = vmaxq_f32(v20, v18);
          v13 += 4;
          *float32x4_t v25 = vmaxq_f32(v21, v18);
          v25[1] = vmaxq_f32(v22, v18);
          v16 += 4;
          int v15 = v23 + 4;
          v14 += 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            float32x4_t v26 = *v23++;
            *v24++ = vmaxq_f32(vminq_f32(v26, *(float32x4_t *)*((void *)this + 51)), *(float32x4_t *)(*((void *)this + 51) + 16));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (float32x4_t *)((char *)v5 + v9);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v10);
        uint64_t v11 = (float32x4_t *)((char *)v11 + v10);
        uint64_t v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcColorClamp::GetDOD(HgcColorClamp *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcColorClamp::GetROI(HgcColorClamp *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcColorClamp::HgcColorClamp(HgcColorClamp *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EDC00;
  operator new();
}

void sub_1B7900040(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorClamp::~HgcColorClamp(HGNode *this)
{
  *(void *)this = &unk_1F10EDC00;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EDC00;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorClamp::SetParameter(HgcColorClamp *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcColorClamp::GetParameter(HgcColorClamp *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcMultiTexBlend_4::GetProgram(HgcMultiTexBlend_4 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004c2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    r0 = half4(hg_Params[0].yyyy)*r1 + r0;\n"
             "    r0 = half4(hg_Params[0].zzzz)*r2 + r0;\n"
             "    output.color0 = hg_Params[0].wwww*float4(r3) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1a6c17cb:31f0a26b:ade5145e:0414ab15\n"
             "//SIG=00400000:0000000f:0000000f:0000000f:0000:0001:0004:0000:0000:0000:001e:0000:0004:04:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000482\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
             "    output.color0 = hg_Params[0].wwww*r3 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5298a64d:65565521:895e2114:65f6560f\n"
             "//SIG=00000000:0000000f:0000000f:00000000:0000:0001:0004:0000:0000:0000:001e:0000:0004:04:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    r0 = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "    r0 = hg_ProgramLocal0.zzzz*r2 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal0.wwww*r3 + r0;\n"
           "}\n"
           "//MD5=57e6a43b:2edcb015:005cc30e:7898f273\n"
           "//SIG=00000000:0000000f:0000000f:00000000:0000:0001:0004:0000:0000:0000:0000:0000:0004:04:0:1:0\n";
  }
}

void HgcMultiTexBlend_4::InitProgramDescriptor(HgcMultiTexBlend_4 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_4_hgc_visible", "//Metal1.0     \n//LEN=00000001ed\n[[ visible ]] FragmentOut HgcMultiTexBlend_4_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
    "    output.color0 = hg_Params[0].wwww*r3 + r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcMultiTexBlend_4");
}

void sub_1B79006A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B79006E4(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79006DCLL);
}

double HgcMultiTexBlend_4::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcMultiTexBlend_4 [hgc1]");
  return *(double *)"exBlend_4 [hgc1]";
}

uint64_t HgcMultiTexBlend_4::BindTexture(HgcMultiTexBlend_4 *this, HGHandler *a2, int a3)
{
  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 0;
      goto LABEL_7;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 1;
      goto LABEL_7;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 2;
      goto LABEL_7;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 3;
LABEL_7:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      int v7 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
      uint64_t result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
        uint64_t result = 0;
      }
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcMultiTexBlend_4::Bind(HgcMultiTexBlend_4 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcMultiTexBlend_4::RenderTile(HgcMultiTexBlend_4 *this, HGTile *a2)
{
  int v55 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v55 >= 1)
  {
    unint64_t v2 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    unint64_t v3 = (float32x4_t *)*((void *)a2 + 10);
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 12);
    int v5 = (float32x4_t *)*((void *)a2 + 14);
    uint64_t v6 = (float32x4_t *)*((void *)a2 + 16);
    int v7 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v8 = *((int *)a2 + 6);
    uint64_t v9 = *((int *)a2 + 34);
    uint64_t v10 = *((int *)a2 + 30);
    uint64_t v11 = *((int *)a2 + 26);
    uint64_t v12 = *((int *)a2 + 22);
    if ((int)v2 < 4)
    {
      if ((int)v2 >= 1)
      {
        int v46 = 0;
        uint64_t v47 = 16 * v10;
        uint64_t v48 = 16 * v9;
        uint64_t v49 = 16 * v8;
        uint64_t v50 = 16 * v2;
        do
        {
          unint64_t v51 = 0;
          do
          {
            v7[v51 / 0x10] = vaddq_f32(vmulq_laneq_f32(v6[v51 / 0x10], *(float32x4_t *)*((void *)this + 51), 3), vaddq_f32(vmulq_laneq_f32(v5[v51 / 0x10], *(float32x4_t *)*((void *)this + 51), 2), vaddq_f32(vmulq_n_f32(v3[v51 / 0x10], COERCE_FLOAT(*(_OWORD *)*((void *)this + 51))), vmulq_lane_f32(v4[v51 / 0x10], **((float32x2_t **)this + 51), 1))));
            v51 += 16;
          }
          while (v50 != v51);
          ++v46;
          v3 += v12;
          v4 += v11;
          int v5 = (float32x4_t *)((char *)v5 + v47);
          uint64_t v6 = (float32x4_t *)((char *)v6 + v48);
          int v7 = (float32x4_t *)((char *)v7 + v49);
        }
        while (v46 != v55);
      }
    }
    else
    {
      int v13 = 0;
      uint64_t v53 = 16 * v10;
      uint64_t v54 = 16 * v11;
      uint64_t v14 = 16 * v9;
      int v15 = v3 + 4;
      uint64_t v16 = 16 * v8;
      uint64_t v17 = v4 + 4;
      uint64_t v18 = 16 * v12;
      float32x4_t v19 = v5 + 4;
      float32x4_t v20 = v6 + 4;
      float32x4_t v21 = v7 + 4;
      do
      {
        unint64_t v22 = 0;
        unint64_t v23 = 0;
        float32x4_t v24 = v21;
        float32x4_t v25 = v20;
        float32x4_t v26 = v19;
        int v27 = v17;
        uint64_t v28 = v15;
        do
        {
          uint64_t v29 = v28;
          uint64_t v30 = v27;
          unint64_t v31 = v26;
          float32x4_t v32 = v25;
          float32x4_t v33 = v24;
          float32x4_t v34 = *(float32x4_t *)*((void *)this + 51);
          float32x4_t v35 = vaddq_f32(vmulq_laneq_f32(v6[v22 + 1], v34, 3), vaddq_f32(vmulq_laneq_f32(v5[v22 + 1], v34, 2), vaddq_f32(vmulq_n_f32(v3[v22 + 1], v34.f32[0]), vmulq_lane_f32(v4[v22 + 1], *(float32x2_t *)v34.f32, 1))));
          float32x4_t v36 = vaddq_f32(vmulq_laneq_f32(v6[v22 + 2], v34, 3), vaddq_f32(vmulq_laneq_f32(v5[v22 + 2], v34, 2), vaddq_f32(vmulq_n_f32(v3[v22 + 2], v34.f32[0]), vmulq_lane_f32(v4[v22 + 2], *(float32x2_t *)v34.f32, 1))));
          float32x4_t v37 = vaddq_f32(vmulq_laneq_f32(v6[v22 + 3], v34, 3), vaddq_f32(vmulq_laneq_f32(v5[v22 + 3], v34, 2), vaddq_f32(vmulq_n_f32(v3[v22 + 3], v34.f32[0]), vmulq_lane_f32(v4[v22 + 3], *(float32x2_t *)v34.f32, 1))));
          float32x4_t v38 = &v7[v22];
          *float32x4_t v38 = vaddq_f32(vmulq_laneq_f32(v6[v22], v34, 3), vaddq_f32(vmulq_laneq_f32(v5[v22], v34, 2), vaddq_f32(vmulq_n_f32(v3[v22], v34.f32[0]), vmulq_lane_f32(v4[v22], *(float32x2_t *)v34.f32, 1))));
          v38[1] = v35;
          v23 += 4;
          v22 += 4;
          v28 += 4;
          v27 += 4;
          v38[2] = v36;
          v38[3] = v37;
          float32x4_t v26 = v31 + 4;
          v25 += 4;
          v24 += 4;
        }
        while ((uint64_t)v23 < (uint64_t)(v2 - 3));
        if ((int)v2 > (int)v23)
        {
          do
          {
            float32x4_t v39 = *v29++;
            float32x4_t v40 = v39;
            float32x4_t v41 = *v30++;
            float32x4_t v42 = v41;
            float32x4_t v43 = *v31++;
            float32x4_t v44 = v43;
            float32x4_t v45 = *v32++;
            *v33++ = vaddq_f32(vmulq_laneq_f32(v45, *(float32x4_t *)*((void *)this + 51), 3), vaddq_f32(vmulq_laneq_f32(v44, *(float32x4_t *)*((void *)this + 51), 2), vaddq_f32(vmulq_n_f32(v40, COERCE_FLOAT(*(_OWORD *)*((void *)this + 51))), vmulq_lane_f32(v42, **((float32x2_t **)this + 51), 1))));
            ++v23;
          }
          while (v23 < v2);
        }
        ++v13;
        uint64_t v4 = (float32x4_t *)((char *)v4 + v54);
        int v5 = (float32x4_t *)((char *)v5 + v53);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v14);
        int v7 = (float32x4_t *)((char *)v7 + v16);
        unint64_t v3 = (float32x4_t *)((char *)v3 + v18);
        int v15 = (float32x4_t *)((char *)v15 + v18);
        uint64_t v17 = (float32x4_t *)((char *)v17 + v54);
        float32x4_t v19 = (float32x4_t *)((char *)v19 + v53);
        float32x4_t v20 = (float32x4_t *)((char *)v20 + v14);
        float32x4_t v21 = (float32x4_t *)((char *)v21 + v16);
      }
      while (v13 != v55);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_4::GetDOD(HgcMultiTexBlend_4 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 4) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcMultiTexBlend_4::GetROI(HgcMultiTexBlend_4 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 4) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcMultiTexBlend_4::HgcMultiTexBlend_4(HgcMultiTexBlend_4 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EDE68;
  operator new();
}

void sub_1B7900E10(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_4::~HgcMultiTexBlend_4(HGNode *this)
{
  *(void *)this = &unk_1F10EDE68;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EDE68;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_4::SetParameter(HgcMultiTexBlend_4 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcMultiTexBlend_4::GetParameter(HgcMultiTexBlend_4 *this, int a2, float *a3)
{
  if (!a2)
  {
    unint64_t v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcMultiTexBlend_7::GetProgram(HgcMultiTexBlend_7 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000741\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< half > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]], \n"
             "    texture2d< half > hg_Texture6 [[ texture(6) ]], \n"
             "    sampler hg_Sampler6 [[ sampler(6) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = (half4) hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r6 = (half4) hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    r0 = half4(hg_Params[0].yyyy)*r1 + r0;\n"
             "    r0 = half4(hg_Params[0].zzzz)*r2 + r0;\n"
             "    r0 = half4(hg_Params[0].wwww)*r3 + r0;\n"
             "    r0 = half4(hg_Params[1].xxxx)*r4 + r0;\n"
             "    r0 = half4(hg_Params[1].yyyy)*r5 + r0;\n"
             "    output.color0 = hg_Params[1].zzzz*float4(r6) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0919c6bd:8f8b1602:660b36e3:90776682\n"
             "//SIG=00400000:0000007f:0000007f:0000007f:0000:0002:0007:0000:0000:0000:00fe:0000:0007:07:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000006d7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< float > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]], \n"
             "    texture2d< float > hg_Texture6 [[ texture(6) ]], \n"
             "    sampler hg_Sampler6 [[ sampler(6) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r6 = hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
             "    r0 = hg_Params[0].wwww*r3 + r0;\n"
             "    r0 = hg_Params[1].xxxx*r4 + r0;\n"
             "    r0 = hg_Params[1].yyyy*r5 + r0;\n"
             "    output.color0 = hg_Params[1].zzzz*r6 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=91d90a23:e17307a0:56e74a97:fbca53d8\n"
             "//SIG=00000000:0000007f:0000007f:00000000:0000:0002:0007:0000:0000:0000:00fe:0000:0007:07:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000060d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp sampler2D hg_Texture5;\n"
           "uniform defaultp sampler2D hg_Texture6;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "varying highp vec4 hg_TexCoord5;\n"
           "varying highp vec4 hg_TexCoord6;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r5 = texture2D(hg_Texture5, hg_TexCoord5.xy);\n"
           "    r6 = texture2D(hg_Texture6, hg_TexCoord6.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    r0 = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "    r0 = hg_ProgramLocal0.zzzz*r2 + r0;\n"
           "    r0 = hg_ProgramLocal0.wwww*r3 + r0;\n"
           "    r0 = hg_ProgramLocal1.xxxx*r4 + r0;\n"
           "    r0 = hg_ProgramLocal1.yyyy*r5 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal1.zzzz*r6 + r0;\n"
           "}\n"
           "//MD5=f1f5c9f2:cb3caeb2:b31a6ebb:ceea2000\n"
           "//SIG=00000000:0000007f:0000007f:00000000:0000:0002:0007:0000:0000:0000:0000:0000:0007:07:0:1:0\n";
  }
}

void HgcMultiTexBlend_7::InitProgramDescriptor(HgcMultiTexBlend_7 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_7_hgc_visible", "//Metal1.0     \n//LEN=00000002d1\n[[ visible ]] FragmentOut HgcMultiTexBlend_7_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4,\n    float4 color5,\n    float4 color6)\n{\n    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r5 = color5;\n"
    "    r6 = color6;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
    "    r0 = hg_Params[0].wwww*r3 + r0;\n"
    "    r0 = hg_Params[1].xxxx*r4 + r0;\n"
    "    r0 = hg_Params[1].yyyy*r5 + r0;\n"
    "    output.color0 = hg_Params[1].zzzz*r6 + r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcMultiTexBlend_7");
}

void sub_1B790161C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7901664(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B790165CLL);
}

double HgcMultiTexBlend_7::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcMultiTexBlend_7 [hgc1]");
  return *(double *)"exBlend_7 [hgc1]";
}

uint64_t HgcMultiTexBlend_7::BindTexture(HgcMultiTexBlend_7 *this, HGHandler *a2, int a3)
{
  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 0;
      goto LABEL_10;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 1;
      goto LABEL_10;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 2;
      goto LABEL_10;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 3;
      goto LABEL_10;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 4;
      goto LABEL_10;
    case 5:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 5, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 5;
      goto LABEL_10;
    case 6:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 6, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 6;
LABEL_10:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      int v7 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
      uint64_t result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
        uint64_t result = 0;
      }
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcMultiTexBlend_7::Bind(HgcMultiTexBlend_7 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcMultiTexBlend_7::RenderTile(HgcMultiTexBlend_7 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 12);
    uint64_t v6 = (float32x4_t *)*((void *)a2 + 14);
    int v7 = (float32x4_t *)*((void *)a2 + 16);
    uint64_t v8 = (float32x4_t *)*((void *)a2 + 18);
    uint64_t v9 = (float32x4_t *)*((void *)a2 + 20);
    uint64_t v10 = (float32x4_t *)*((void *)a2 + 22);
    uint64_t v11 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v12 = *((int *)a2 + 6);
    uint64_t v13 = *((int *)a2 + 46);
    uint64_t v14 = *((int *)a2 + 42);
    uint64_t v15 = *((int *)a2 + 38);
    uint64_t v16 = *((int *)a2 + 34);
    uint64_t v17 = *((int *)a2 + 30);
    uint64_t v18 = *((int *)a2 + 26);
    uint64_t v19 = *((int *)a2 + 22);
    if (v3 < 2)
    {
      if (v3 == 1)
      {
        uint64_t v37 = 16 * v19;
        uint64_t v38 = 16 * v17;
        uint64_t v39 = 16 * v16;
        uint64_t v40 = 16 * v15;
        uint64_t v41 = 16 * v14;
        uint64_t v42 = 16 * v13;
        uint64_t v43 = 16 * v12;
        do
        {
          float32x4_t v44 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v45 = v44[1];
          float32x4_t v46 = vaddq_f32(vmulq_lane_f32(*v9, *(float32x2_t *)v45.f32, 1), vaddq_f32(vmulq_n_f32(*v8, v45.f32[0]), vaddq_f32(vmulq_laneq_f32(*v7, *v44, 3), vaddq_f32(vmulq_laneq_f32(*v6, *v44, 2), vaddq_f32(vmulq_n_f32(*v4, COERCE_FLOAT(*v44)), vmulq_lane_f32(*v5, *(float32x2_t *)v44->f32, 1))))));
          uint64_t v4 = (float32x4_t *)((char *)v4 + v37);
          v5 += v18;
          uint64_t v6 = (float32x4_t *)((char *)v6 + v38);
          int v7 = (float32x4_t *)((char *)v7 + v39);
          uint64_t v8 = (float32x4_t *)((char *)v8 + v40);
          *uint64_t v11 = vaddq_f32(vmulq_laneq_f32(*v10, v45, 2), v46);
          uint64_t v9 = (float32x4_t *)((char *)v9 + v41);
          uint64_t v10 = (float32x4_t *)((char *)v10 + v42);
          uint64_t v11 = (float32x4_t *)((char *)v11 + v43);
          --v2;
        }
        while (v2);
      }
    }
    else
    {
      int v20 = 0;
      uint64_t v21 = 16 * v17;
      uint64_t v22 = 16 * v16;
      uint64_t v23 = 16 * v15;
      uint64_t v24 = 16 * v14;
      uint64_t v25 = 16 * v13;
      uint64_t v26 = 16 * v12;
      uint64_t v27 = 16 * v19;
      uint64_t v28 = 16 * v18;
      do
      {
        uint64_t v29 = 0;
        int v30 = 0;
        do
        {
          unint64_t v31 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v32 = v31[1];
          float32x4_t v33 = vaddq_f32(vmulq_laneq_f32(v10[v29], v32, 2), vaddq_f32(vmulq_lane_f32(v9[v29], *(float32x2_t *)v32.f32, 1), vaddq_f32(vmulq_n_f32(v8[v29], v32.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v29], *v31, 3), vaddq_f32(vmulq_laneq_f32(v6[v29], *v31, 2), vaddq_f32(vmulq_n_f32(v4[v29], COERCE_FLOAT(*v31)), vmulq_lane_f32(v5[v29], *(float32x2_t *)v31->f32, 1)))))));
          float32x4_t v34 = vaddq_f32(vmulq_laneq_f32(v10[v29 + 1], v32, 2), vaddq_f32(vmulq_lane_f32(v9[v29 + 1], *(float32x2_t *)v32.f32, 1), vaddq_f32(vmulq_n_f32(v8[v29 + 1], v32.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v29 + 1], *v31, 3), vaddq_f32(vmulq_laneq_f32(v6[v29 + 1], *v31, 2), vaddq_f32(vmulq_n_f32(v4[v29 + 1], COERCE_FLOAT(*v31)), vmulq_lane_f32(v5[v29 + 1], *(float32x2_t *)v31->f32, 1)))))));
          float32x4_t v35 = &v11[v29];
          *float32x4_t v35 = v33;
          v35[1] = v34;
          v30 -= 2;
          v29 += 2;
        }
        while (v3 + v30 > 1);
        if (v3 > -v30)
        {
          float32x4_t v36 = (float32x4_t *)*((void *)this + 51);
          v11[v29] = vaddq_f32(vmulq_laneq_f32(v10[v29], v36[1], 2), vaddq_f32(vmulq_lane_f32(v9[v29], *(float32x2_t *)v36[1].f32, 1), vaddq_f32(vmulq_n_f32(v8[v29], COERCE_FLOAT(*(_OWORD *)&v36[1])), vaddq_f32(vmulq_laneq_f32(v7[v29], *v36, 3), vaddq_f32(vmulq_laneq_f32(v6[v29], *v36, 2), vaddq_f32(vmulq_n_f32(v4[v29], COERCE_FLOAT(*v36)), vmulq_lane_f32(v5[v29], *(float32x2_t *)v36->f32, 1)))))));
        }
        ++v20;
        uint64_t v6 = (float32x4_t *)((char *)v6 + v21);
        int v7 = (float32x4_t *)((char *)v7 + v22);
        uint64_t v8 = (float32x4_t *)((char *)v8 + v23);
        uint64_t v9 = (float32x4_t *)((char *)v9 + v24);
        uint64_t v10 = (float32x4_t *)((char *)v10 + v25);
        uint64_t v11 = (float32x4_t *)((char *)v11 + v26);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v27);
        int v5 = (float32x4_t *)((char *)v5 + v28);
      }
      while (v20 != v2);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_7::GetDOD(HgcMultiTexBlend_7 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 7) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcMultiTexBlend_7::GetROI(HgcMultiTexBlend_7 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 7) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcMultiTexBlend_7::HgcMultiTexBlend_7(HgcMultiTexBlend_7 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EE0D0;
  operator new();
}

void sub_1B7901EE8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_7::~HgcMultiTexBlend_7(HGNode *this)
{
  *(void *)this = &unk_1F10EE0D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EE0D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_7::SetParameter(HgcMultiTexBlend_7 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcMultiTexBlend_7::GetParameter(HgcMultiTexBlend_7 *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcYUV420BiPlanar_601ToRGB::GetProgram(HgcYUV420BiPlanar_601ToRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const half4 c1 = half4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = (half2) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xyz) + half3(hg_Params[1].xyz);\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = float3(r0.zzz)*float3(c1.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(c1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0e00be48:1d4c1030:c845256d:4f625dda\n"
             "//SIG=00400000:00000001:00000001:00000003:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000415\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
             "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xy;\n"
             "    r0.yz = r0.xy;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
             "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
             "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
             "    output.color0.w = c1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e920bf17:693c75e5:4f148dce:a2580259\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
           "    const defaultp vec4 c1 = vec4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xy = texture2D(hg_Texture1, hg_TexCoord1.xy).xy;\n"
           "    r0.yz = r0.xy;\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xyz + hg_ProgramLocal1.xyz;\n"
           "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
           "    gl_FragColor.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
           "    gl_FragColor.w = c1.w;\n"
           "}\n"
           "//MD5=b28b84a9:65d97aa9:3bf19568:b311251d\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcYUV420BiPlanar_601ToRGB::InitProgramDescriptor(HgcYUV420BiPlanar_601ToRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcYUV420BiPlanar_601ToRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e7\n[[ visible ]] FragmentOut HgcYUV420BiPlanar_601ToRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, -0.3441362977, 1.771999955, 0.000000000);\n"
    "    const float4 c1 = float4(1.401999950, -0.7141363025, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Texture1.sample(hg_Sampler1, texCoord1.xy).xy;\n"
    "    r0.yz = r0.xy;\n"
    "    r0.x = color0.x;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xyz + hg_Params[1].xyz;\n"
    "    r1.xyz = r0.yyy*c0.xyz + r0.xxx;\n"
    "    output.color0.xyz = r0.zzz*c1.xyz + r1.xyz;\n"
    "    output.color0.w = c1.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcYUV420BiPlanar_601ToRGB");
}

void sub_1B7902550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B790258C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7902584);
}

char *HgcYUV420BiPlanar_601ToRGB::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376030;
  strcpy(result, "HgcYUV420BiPlanar_601ToRGB [hgc1]");
  return result;
}

uint64_t HgcYUV420BiPlanar_601ToRGB::BindTexture(HgcYUV420BiPlanar_601ToRGB *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 == 1)
    {
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      HGHandler::TexCoord(a2, 1, 0, 0, 0);
      if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))(*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2); {
      (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 0.5, 0.5, 1.0);
      }
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v5)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcYUV420BiPlanar_601ToRGB::Bind(HgcYUV420BiPlanar_601ToRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcYUV420BiPlanar_601ToRGB::RenderTile(HgcYUV420BiPlanar_601ToRGB *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    float32x4_t v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B7E77360);
    int32x2_t v8 = a2[2];
    int32x2_t v9 = a2[10];
    uint64_t v10 = 16 * a2[11].i32[0];
    uint64_t v11 = 16 * a2[3].i32[0];
    float32x4_t v12 = 0uLL;
    __asm { FMOV            V5.4S, #4.0 }
    v18.i64[0] = 0x3F0000003F000000;
    v18.i64[1] = 0x3F0000003F000000;
    while (1)
    {
      float32x4_t v19 = vaddq_f32(v7, vmulq_f32(v12, (float32x4_t)xmmword_1B7E75610));
      if (v6 >= 4) {
        break;
      }
      LODWORD(v66) = 0;
      float32x4_t v21 = 0uLL;
      __asm { FMOV            V18.4S, #1.0 }
      if (v6 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v12 = vaddq_f32(v12, _Q18);
      ++v4;
      *(void *)&v9 += v10;
      *(void *)&v8 += v11;
      if (v4 == v3) {
        return 0;
      }
    }
    int v20 = 0;
    float32x4_t v21 = 0uLL;
    uint64_t v22 = 32;
    do
    {
      float32x4_t v23 = vaddq_f32(v19, vmulq_f32(v21, (float32x4_t)xmmword_1B7E75B20));
      float32x4_t v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B7E75B20);
      int32x2_t v27 = a2[12];
      __int32 v28 = a2[13].i32[0];
      float32x4_t v29 = vaddq_f32(vsubq_f32(v23, v5), v18);
      int32x4_t v30 = vcvtq_s32_f32(v29);
      v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
      __int32 v31 = v29.i32[1];
      __int32 v32 = v29.i32[0];
      float32x4_t v33 = vaddq_f32(vsubq_f32(v24, v5), v18);
      int32x4_t v34 = vcvtq_s32_f32(v33);
      __int32 v35 = v32 + v31 * v28;
      v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      __int32 v36 = v33.i32[1];
      __int32 v37 = v33.i32[0];
      int8x16_t v38 = *(int8x16_t *)(*(void *)&v27 + 16 * v35);
      float32x4_t v39 = vaddq_f32(vsubq_f32(v25, v5), v18);
      int32x4_t v40 = vcvtq_s32_f32(v39);
      __int32 v41 = v37 + v36 * v28;
      v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
      __int32 v42 = v39.i32[1];
      __int32 v43 = v39.i32[0];
      int8x16_t v44 = *(int8x16_t *)(*(void *)&v27 + 16 * v41);
      float32x4_t v45 = vaddq_f32(vsubq_f32(v26, v5), v18);
      int32x4_t v46 = vcvtq_s32_f32(v45);
      __int32 v47 = v43 + v42 * v28;
      v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
      __int32 v48 = v45.i32[1];
      __int32 v49 = v45.i32[0];
      int8x16_t v50 = *(int8x16_t *)(*(void *)&v27 + 16 * v47);
      int8x16_t v51 = *(int8x16_t *)(*(void *)&v27 + 16 * (v49 + v48 * v28));
      uint64_t v52 = *((void *)this + 51);
      int8x16_t v53 = *(int8x16_t *)(v52 + 32);
      float32x4_t v54 = *(float32x4_t *)(v52 + 48);
      float32x4_t v55 = *(float32x4_t *)(v52 + 16);
      float32x4_t v56 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(void *)&v9 + v22 - 32), vextq_s8(v38, v38, 0xCuLL))));
      float32x4_t v57 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(void *)&v9 + v22 - 16), vextq_s8(v44, v44, 0xCuLL))));
      float32x4_t v58 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(void *)&v9 + v22), vextq_s8(v50, v50, 0xCuLL))));
      float32x4_t v59 = vaddq_f32(v55, vmulq_f32(*(float32x4_t *)v52, (float32x4_t)vbslq_s8(v53, *(int8x16_t *)(*(void *)&v9 + v22 + 16), vextq_s8(v51, v51, 0xCuLL))));
      float32x4_t v21 = vaddq_f32(v21, _Q5);
      float32x4_t v60 = *(float32x4_t *)(v52 + 64);
      float32x4_t v61 = vaddq_f32(vmulq_laneq_f32(v60, v56, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v56.f32, 1)));
      float32x4_t v62 = vaddq_f32(vmulq_laneq_f32(v60, v57, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v57.f32, 1)));
      float32x4_t v63 = vaddq_f32(vmulq_laneq_f32(v60, v58, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v58.f32, 1)));
      v61.i32[3] = 1.0;
      v62.i32[3] = 1.0;
      v63.i32[3] = 1.0;
      float32x4_t v64 = vaddq_f32(vmulq_laneq_f32(v60, v59, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.f32, 0), vmulq_lane_f32(v54, *(float32x2_t *)v59.f32, 1)));
      v64.i32[3] = 1.0;
      uint64_t v65 = (float32x4_t *)(*(void *)&v8 + v22);
      v65[-2] = v61;
      v65[-1] = v62;
      float32x4_t *v65 = v63;
      v65[1] = v64;
      v20 -= 4;
      v22 += 64;
    }
    while (v6 + v20 > 3);
    LODWORD(v66) = -v20;
    __asm { FMOV            V18.4S, #1.0 }
    if ((int)v66 >= v6) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v66 = v66;
    do
    {
      float32x4_t v68 = vaddq_f32(vsubq_f32(vaddq_f32(v19, vmulq_f32(v21, (float32x4_t)xmmword_1B7E75B20)), v5), v18);
      int32x4_t v69 = vcvtq_s32_f32(v68);
      v68.i64[0] = vaddq_s32(v69, vcgtq_f32(vcvtq_f32_s32(v69), v68)).u64[0];
      uint64_t v70 = *((void *)this + 51);
      float32x4_t v71 = vaddq_f32(*(float32x4_t *)(v70 + 16), vmulq_f32(*(float32x4_t *)v70, (float32x4_t)vbslq_s8(*(int8x16_t *)(v70 + 32), *(int8x16_t *)(*(void *)&v9 + 16 * v66), vextq_s8(*(int8x16_t *)(*(void *)&a2[12] + 16 * (v68.i32[0] + v68.i32[1] * a2[13].i32[0])), *(int8x16_t *)(*(void *)&a2[12] + 16 * (v68.i32[0] + v68.i32[1] * a2[13].i32[0])), 0xCuLL))));
      float32x4_t v72 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v70 + 64), v71, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 0), vmulq_lane_f32(*(float32x4_t *)(v70 + 48), *(float32x2_t *)v71.f32, 1)));
      v72.i32[3] = 1.0;
      *(float32x4_t *)(*(void *)&v8 + 16 * v66) = v72;
      float32x4_t v21 = vaddq_f32(v21, _Q18);
      ++v66;
    }
    while (v66 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_601ToRGB::GetDOD(HgcYUV420BiPlanar_601ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  if (!a3) {
    return v5;
  }
  if (a3 == 1)
  {
    uint64_t v6 = HGRectMake4i(0, 0, 1u, 1u);
    int v7 = HGRectGrow(v5, v4, v6);
    float v8 = HGRectFloat(v7);
    float v12 = HGRectScale(v8, v9, v10, v11, 2.0);
    uint64_t v17 = HGRectIntegral(v13, v12, v14, v15, v16);
    return HGRectUnion(0, 0, v17, v18);
  }
  return 0;
}

uint64_t HgcYUV420BiPlanar_601ToRGB::GetROI(HgcYUV420BiPlanar_601ToRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t result = *(void *)&a4.var0;
  if (a3)
  {
    if (a3 == 1)
    {
      float v5 = HGRectFloat(a4.var0);
      float v9 = HGRectScale(v5, v6, v7, v8, 0.5);
      uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
      uint64_t v16 = v15;
      uint64_t v17 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 0, 0);
      uint64_t v18 = HGRectGrow(v14, v16, v17);
      return HGRectUnion(0, 0, v18, v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HgcYUV420BiPlanar_601ToRGB::HgcYUV420BiPlanar_601ToRGB(HgcYUV420BiPlanar_601ToRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EE338;
  operator new();
}

void sub_1B7902E34(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcYUV420BiPlanar_601ToRGB::~HgcYUV420BiPlanar_601ToRGB(HGNode *this)
{
  *(void *)this = &unk_1F10EE338;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10EE338;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EE338;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcYUV420BiPlanar_601ToRGB::SetParameter(HgcYUV420BiPlanar_601ToRGB *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  double v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *double v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcYUV420BiPlanar_601ToRGB::GetParameter(HgcYUV420BiPlanar_601ToRGB *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  float v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcMultiTexBlend_3::GetProgram(HgcMultiTexBlend_3 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ed\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    r0 = half4(hg_Params[0].yyyy)*r1 + r0;\n"
             "    output.color0 = hg_Params[0].zzzz*float4(r2) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cc766481:a53c051c:4e34c2a5:82be33cf\n"
             "//SIG=00400000:00000007:00000007:00000007:0000:0001:0003:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003bb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    output.color0 = hg_Params[0].zzzz*r2 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f558b7ce:73db4aed:13eb5976:1ab74be0\n"
             "//SIG=00000000:00000007:00000007:00000000:0000:0001:0003:0000:0000:0000:000e:0000:0003:03:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000349\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    r0 = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal0.zzzz*r2 + r0;\n"
           "}\n"
           "//MD5=08d99f4b:8e68f2aa:db8b3680:60eeb43c\n"
           "//SIG=00000000:00000007:00000007:00000000:0000:0001:0003:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
  }
}

void HgcMultiTexBlend_3::InitProgramDescriptor(HgcMultiTexBlend_3 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_3_hgc_visible", "//Metal1.0     \n//LEN=00000001a1\n[[ visible ]] FragmentOut HgcMultiTexBlend_3_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    output.color0 = hg_Params[0].zzzz*r2 + r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcMultiTexBlend_3");
}

void sub_1B7903470(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B79034A8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79034A0);
}

double HgcMultiTexBlend_3::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcMultiTexBlend_3 [hgc1]");
  return *(double *)"exBlend_3 [hgc1]";
}

uint64_t HgcMultiTexBlend_3::BindTexture(HgcMultiTexBlend_3 *this, HGHandler *a2, int a3)
{
  if (a3 == 2)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 2;
  }
  else if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 1;
  }
  else
  {
    if (a3) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcMultiTexBlend_3::Bind(HgcMultiTexBlend_3 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcMultiTexBlend_3::RenderTile(HgcMultiTexBlend_3 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 12);
    int v6 = (float32x4_t *)*((void *)a2 + 14);
    uint64_t v7 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v8 = *((int *)a2 + 6);
    uint64_t v9 = *((int *)a2 + 30);
    uint64_t v10 = *((int *)a2 + 26);
    uint64_t v11 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v41 = 0;
        uint64_t v42 = 16 * v10;
        uint64_t v43 = 16 * v9;
        uint64_t v44 = 16 * v8;
        uint64_t v45 = 16 * v3;
        do
        {
          unint64_t v46 = 0;
          do
          {
            v7[v46 / 0x10] = vaddq_f32(vmulq_laneq_f32(v6[v46 / 0x10], *(float32x4_t *)*((void *)this + 51), 2), vaddq_f32(vmulq_n_f32(v4[v46 / 0x10], COERCE_FLOAT(*(_OWORD *)*((void *)this + 51))), vmulq_lane_f32(v5[v46 / 0x10], **((float32x2_t **)this + 51), 1)));
            v46 += 16;
          }
          while (v45 != v46);
          ++v41;
          v4 += v11;
          int v5 = (float32x4_t *)((char *)v5 + v42);
          int v6 = (float32x4_t *)((char *)v6 + v43);
          uint64_t v7 = (float32x4_t *)((char *)v7 + v44);
        }
        while (v41 != v2);
      }
    }
    else
    {
      int v12 = 0;
      uint64_t v13 = 16 * v10;
      uint64_t v14 = 16 * v9;
      uint64_t v15 = 16 * v8;
      uint64_t v16 = v4 + 4;
      uint64_t v17 = 16 * v11;
      uint64_t v18 = v5 + 4;
      uint64_t v19 = v6 + 4;
      int v20 = v7 + 4;
      do
      {
        unint64_t v21 = 0;
        unint64_t v22 = 0;
        float32x4_t v23 = v20;
        float32x4_t v24 = v19;
        float32x4_t v25 = v18;
        float32x4_t v26 = v16;
        do
        {
          int32x2_t v27 = v26;
          __int32 v28 = v25;
          float32x4_t v29 = v24;
          int32x4_t v30 = v23;
          float32x4_t v31 = *(float32x4_t *)*((void *)this + 51);
          float32x4_t v32 = vaddq_f32(vmulq_laneq_f32(v6[v21 + 1], v31, 2), vaddq_f32(vmulq_n_f32(v4[v21 + 1], v31.f32[0]), vmulq_lane_f32(v5[v21 + 1], *(float32x2_t *)v31.f32, 1)));
          float32x4_t v33 = vaddq_f32(vmulq_laneq_f32(v6[v21 + 2], v31, 2), vaddq_f32(vmulq_n_f32(v4[v21 + 2], v31.f32[0]), vmulq_lane_f32(v5[v21 + 2], *(float32x2_t *)v31.f32, 1)));
          float32x4_t v34 = vaddq_f32(vmulq_laneq_f32(v6[v21 + 3], v31, 2), vaddq_f32(vmulq_n_f32(v4[v21 + 3], v31.f32[0]), vmulq_lane_f32(v5[v21 + 3], *(float32x2_t *)v31.f32, 1)));
          __int32 v35 = &v7[v21];
          *__int32 v35 = vaddq_f32(vmulq_laneq_f32(v6[v21], v31, 2), vaddq_f32(vmulq_n_f32(v4[v21], v31.f32[0]), vmulq_lane_f32(v5[v21], *(float32x2_t *)v31.f32, 1)));
          v35[1] = v32;
          v22 += 4;
          v21 += 4;
          v26 += 4;
          v35[2] = v33;
          v35[3] = v34;
          v25 += 4;
          v24 += 4;
          float32x4_t v23 = v30 + 4;
        }
        while ((uint64_t)v22 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v22)
        {
          do
          {
            float32x4_t v36 = *v27++;
            float32x4_t v37 = v36;
            float32x4_t v38 = *v28++;
            float32x4_t v39 = v38;
            float32x4_t v40 = *v29++;
            *v30++ = vaddq_f32(vmulq_laneq_f32(v40, *(float32x4_t *)*((void *)this + 51), 2), vaddq_f32(vmulq_n_f32(v37, COERCE_FLOAT(*(_OWORD *)*((void *)this + 51))), vmulq_lane_f32(v39, **((float32x2_t **)this + 51), 1)));
            ++v22;
          }
          while (v22 < v3);
        }
        ++v12;
        int v5 = (float32x4_t *)((char *)v5 + v13);
        int v6 = (float32x4_t *)((char *)v6 + v14);
        uint64_t v7 = (float32x4_t *)((char *)v7 + v15);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v17);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v17);
        uint64_t v18 = (float32x4_t *)((char *)v18 + v13);
        uint64_t v19 = (float32x4_t *)((char *)v19 + v14);
        int v20 = (float32x4_t *)((char *)v20 + v15);
      }
      while (v12 != v2);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_3::GetDOD(HgcMultiTexBlend_3 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcMultiTexBlend_3::GetROI(HgcMultiTexBlend_3 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcMultiTexBlend_3::HgcMultiTexBlend_3(HgcMultiTexBlend_3 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EE5A0;
  operator new();
}

void sub_1B7903AA4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_3::~HgcMultiTexBlend_3(HGNode *this)
{
  *(void *)this = &unk_1F10EE5A0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EE5A0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_3::SetParameter(HgcMultiTexBlend_3 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcMultiTexBlend_3::GetParameter(HgcMultiTexBlend_3 *this, int a2, float *a3)
{
  if (!a2)
  {
    unint64_t v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcMultiTexBlend_6::GetProgram(HgcMultiTexBlend_6 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000066c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< half > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = (half4) hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r0 = half4(hg_Params[0].xxxx)*r0;\n"
             "    r0 = half4(hg_Params[0].yyyy)*r1 + r0;\n"
             "    r0 = half4(hg_Params[0].zzzz)*r2 + r0;\n"
             "    r0 = half4(hg_Params[0].wwww)*r3 + r0;\n"
             "    r0 = half4(hg_Params[1].xxxx)*r4 + r0;\n"
             "    output.color0 = hg_Params[1].yyyy*float4(r5) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=552ccccb:a1de3632:dbe40462:70e09c4d\n"
             "//SIG=00400000:0000003f:0000003f:0000003f:0000:0002:0006:0000:0000:0000:007e:0000:0006:06:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000610\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< float > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    r0 = hg_Params[0].xxxx*r0;\n"
             "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
             "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
             "    r0 = hg_Params[0].wwww*r3 + r0;\n"
             "    r0 = hg_Params[1].xxxx*r4 + r0;\n"
             "    output.color0 = hg_Params[1].yyyy*r5 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=69605aab:03823b9c:4ce0d041:98b9bc19\n"
             "//SIG=00000000:0000003f:0000003f:00000000:0000:0002:0006:0000:0000:0000:007e:0000:0006:06:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000566\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp sampler2D hg_Texture5;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "varying highp vec4 hg_TexCoord5;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r5 = texture2D(hg_Texture5, hg_TexCoord5.xy);\n"
           "    r0 = hg_ProgramLocal0.xxxx*r0;\n"
           "    r0 = hg_ProgramLocal0.yyyy*r1 + r0;\n"
           "    r0 = hg_ProgramLocal0.zzzz*r2 + r0;\n"
           "    r0 = hg_ProgramLocal0.wwww*r3 + r0;\n"
           "    r0 = hg_ProgramLocal1.xxxx*r4 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal1.yyyy*r5 + r0;\n"
           "}\n"
           "//MD5=6976d0bc:7777c38e:336b9450:9480e558\n"
           "//SIG=00000000:0000003f:0000003f:00000000:0000:0002:0006:0000:0000:0000:0000:0000:0006:06:0:1:0\n";
  }
}

void HgcMultiTexBlend_6::InitProgramDescriptor(HgcMultiTexBlend_6 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcMultiTexBlend_6_hgc_visible", "//Metal1.0     \n//LEN=0000000285\n[[ visible ]] FragmentOut HgcMultiTexBlend_6_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4,\n    float4 color5)\n{\n    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r5 = color5;\n"
    "    r0 = hg_Params[0].xxxx*r0;\n"
    "    r0 = hg_Params[0].yyyy*r1 + r0;\n"
    "    r0 = hg_Params[0].zzzz*r2 + r0;\n"
    "    r0 = hg_Params[0].wwww*r3 + r0;\n"
    "    r0 = hg_Params[1].xxxx*r4 + r0;\n"
    "    output.color0 = hg_Params[1].yyyy*r5 + r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcMultiTexBlend_6");
}

void sub_1B7904218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B790425C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7904254);
}

double HgcMultiTexBlend_6::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcMultiTexBlend_6 [hgc1]");
  return *(double *)"exBlend_6 [hgc1]";
}

uint64_t HgcMultiTexBlend_6::BindTexture(HgcMultiTexBlend_6 *this, HGHandler *a2, int a3)
{
  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 0;
      goto LABEL_9;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 1;
      goto LABEL_9;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 2;
      goto LABEL_9;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 3;
      goto LABEL_9;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 4;
      goto LABEL_9;
    case 5:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 5, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      uint64_t v4 = a2;
      int v5 = 5;
LABEL_9:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      int v7 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
      uint64_t result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
        uint64_t result = 0;
      }
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcMultiTexBlend_6::Bind(HgcMultiTexBlend_6 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcMultiTexBlend_6::RenderTile(HgcMultiTexBlend_6 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 12);
    int v6 = (float32x4_t *)*((void *)a2 + 14);
    int v7 = (float32x4_t *)*((void *)a2 + 16);
    uint64_t v8 = (float32x4_t *)*((void *)a2 + 18);
    uint64_t v9 = (float32x4_t *)*((void *)a2 + 20);
    uint64_t v10 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v11 = *((int *)a2 + 6);
    uint64_t v12 = *((int *)a2 + 42);
    uint64_t v13 = *((int *)a2 + 38);
    uint64_t v14 = *((int *)a2 + 34);
    uint64_t v15 = *((int *)a2 + 30);
    uint64_t v16 = *((int *)a2 + 26);
    uint64_t v17 = *((int *)a2 + 22);
    if (v3 < 2)
    {
      if (v3 == 1)
      {
        uint64_t v34 = 16 * v17;
        uint64_t v35 = 16 * v14;
        uint64_t v36 = 16 * v13;
        uint64_t v37 = 16 * v12;
        uint64_t v38 = 16 * v11;
        do
        {
          float32x4_t v39 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v40 = v39[1];
          float32x4_t v41 = vaddq_f32(vmulq_n_f32(*v8, v40.f32[0]), vaddq_f32(vmulq_laneq_f32(*v7, *v39, 3), vaddq_f32(vmulq_laneq_f32(*v6, *v39, 2), vaddq_f32(vmulq_n_f32(*v4, COERCE_FLOAT(*v39)), vmulq_lane_f32(*v5, *(float32x2_t *)v39->f32, 1)))));
          uint64_t v4 = (float32x4_t *)((char *)v4 + v34);
          v5 += v16;
          v6 += v15;
          int v7 = (float32x4_t *)((char *)v7 + v35);
          *uint64_t v10 = vaddq_f32(vmulq_lane_f32(*v9, *(float32x2_t *)v40.f32, 1), v41);
          uint64_t v8 = (float32x4_t *)((char *)v8 + v36);
          uint64_t v9 = (float32x4_t *)((char *)v9 + v37);
          uint64_t v10 = (float32x4_t *)((char *)v10 + v38);
          --v2;
        }
        while (v2);
      }
    }
    else
    {
      int v18 = 0;
      uint64_t v19 = 16 * v15;
      uint64_t v20 = 16 * v14;
      uint64_t v21 = 16 * v13;
      uint64_t v22 = 16 * v12;
      uint64_t v23 = 16 * v11;
      uint64_t v24 = 16 * v17;
      uint64_t v25 = 16 * v16;
      do
      {
        uint64_t v26 = 0;
        int v27 = 0;
        do
        {
          __int32 v28 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v29 = v28[1];
          float32x4_t v30 = vaddq_f32(vmulq_lane_f32(v9[v26], *(float32x2_t *)v29.f32, 1), vaddq_f32(vmulq_n_f32(v8[v26], v29.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v26], *v28, 3), vaddq_f32(vmulq_laneq_f32(v6[v26], *v28, 2), vaddq_f32(vmulq_n_f32(v4[v26], COERCE_FLOAT(*v28)), vmulq_lane_f32(v5[v26], *(float32x2_t *)v28->f32, 1))))));
          float32x4_t v31 = vaddq_f32(vmulq_lane_f32(v9[v26 + 1], *(float32x2_t *)v29.f32, 1), vaddq_f32(vmulq_n_f32(v8[v26 + 1], v29.f32[0]), vaddq_f32(vmulq_laneq_f32(v7[v26 + 1], *v28, 3), vaddq_f32(vmulq_laneq_f32(v6[v26 + 1], *v28, 2), vaddq_f32(vmulq_n_f32(v4[v26 + 1], COERCE_FLOAT(*v28)), vmulq_lane_f32(v5[v26 + 1], *(float32x2_t *)v28->f32, 1))))));
          float32x4_t v32 = &v10[v26];
          *float32x4_t v32 = v30;
          v32[1] = v31;
          v27 -= 2;
          v26 += 2;
        }
        while (v3 + v27 > 1);
        if (v3 > -v27)
        {
          float32x4_t v33 = (float32x4_t *)*((void *)this + 51);
          v10[v26] = vaddq_f32(vmulq_lane_f32(v9[v26], *(float32x2_t *)v33[1].f32, 1), vaddq_f32(vmulq_n_f32(v8[v26], COERCE_FLOAT(*(_OWORD *)&v33[1])), vaddq_f32(vmulq_laneq_f32(v7[v26], *v33, 3), vaddq_f32(vmulq_laneq_f32(v6[v26], *v33, 2), vaddq_f32(vmulq_n_f32(v4[v26], COERCE_FLOAT(*v33)), vmulq_lane_f32(v5[v26], *(float32x2_t *)v33->f32, 1))))));
        }
        ++v18;
        int v6 = (float32x4_t *)((char *)v6 + v19);
        int v7 = (float32x4_t *)((char *)v7 + v20);
        uint64_t v8 = (float32x4_t *)((char *)v8 + v21);
        uint64_t v9 = (float32x4_t *)((char *)v9 + v22);
        uint64_t v10 = (float32x4_t *)((char *)v10 + v23);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v24);
        int v5 = (float32x4_t *)((char *)v5 + v25);
      }
      while (v18 != v2);
    }
  }
  return 0;
}

uint64_t HgcMultiTexBlend_6::GetDOD(HgcMultiTexBlend_6 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 6) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcMultiTexBlend_6::GetROI(HgcMultiTexBlend_6 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 6) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcMultiTexBlend_6::HgcMultiTexBlend_6(HgcMultiTexBlend_6 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EE808;
  operator new();
}

void sub_1B7904A20(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcMultiTexBlend_6::~HgcMultiTexBlend_6(HGNode *this)
{
  *(void *)this = &unk_1F10EE808;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EE808;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcMultiTexBlend_6::SetParameter(HgcMultiTexBlend_6 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcMultiTexBlend_6::GetParameter(HgcMultiTexBlend_6 *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcGamutMap::GetProgram(HgcGamutMap *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000573\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 1.000000000, 0.3330000043, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = fmin(r0.x, c0.x);\n"
             "    r1.z = c0.x - r1.x;\n"
             "    r2.xyz = (half3) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r1.xy = c0.yy;\n"
             "    r1.xyz = -r2.xyz*r1.xyz + r0.xyz;\n"
             "    r2.w = dot(r1.xyz, r1.xyz);\n"
             "    r2.w = sqrt(r2.w);\n"
             "    r1.x = r2.w + c0.y;\n"
             "    r1.y = 1.00000h / r1.x;\n"
             "    r1.x = r2.w*r2.w + c0.y;\n"
             "    r2.w = clamp(dot(r0.xyz, c0.zzz), 0.00000h, 1.00000h);\n"
             "    r0.x = 1.00000h / r1.x;\n"
             "    r0.y = r2.w*r2.w + -r2.w;\n"
             "    r2.w = r2.w*r0.y + r2.w;\n"
             "    r2.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = mix(r0.xxx, r1.yyy, half3(hg_Params[0].xyz));\n"
             "    output.color0.xyz = mix(float3(r2.www), float3(r2.xyz), float3(r0.xyz));\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9fd12417:c540b2a9:193700f8:2013b2a7\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000542\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 1.000000000, 0.3330000043, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = fmin(r0.x, c0.x);\n"
             "    r1.z = c0.x - r1.x;\n"
             "    r2.xyz = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r1.xy = c0.yy;\n"
             "    r1.xyz = -r2.xyz*r1.xyz + r0.xyz;\n"
             "    r2.w = dot(r1.xyz, r1.xyz);\n"
             "    r2.w = sqrt(r2.w);\n"
             "    r1.x = r2.w + c0.y;\n"
             "    r1.y = 1.00000f / r1.x;\n"
             "    r1.x = r2.w*r2.w + c0.y;\n"
             "    r2.w = clamp(dot(r0.xyz, c0.zzz), 0.00000f, 1.00000f);\n"
             "    r0.x = 1.00000f / r1.x;\n"
             "    r0.y = r2.w*r2.w + -r2.w;\n"
             "    r2.w = r2.w*r0.y + r2.w;\n"
             "    r2.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = mix(r0.xxx, r1.yyy, hg_Params[0].xyz);\n"
             "    output.color0.xyz = mix(r2.www, r2.xyz, r0.xyz);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7c8a7355:917bfc5f:f837ebc6:4b23a8cd\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004f2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 1.000000000, 0.3330000043, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = min(r0.x, c0.x);\n"
           "    r1.z = c0.x - r1.x;\n"
           "    r2.xyz = texture2D(hg_Texture1, hg_TexCoord1.xy).xyz;\n"
           "    r1.xy = c0.yy;\n"
           "    r1.xyz = -r2.xyz*r1.xyz + r0.xyz;\n"
           "    r2.w = dot(r1.xyz, r1.xyz);\n"
           "    r2.w = sqrt(r2.w);\n"
           "    r1.x = r2.w + c0.y;\n"
           "    r1.y = 1.00000 / r1.x;\n"
           "    r1.x = r2.w*r2.w + c0.y;\n"
           "    r2.w = clamp(dot(r0.xyz, c0.zzz), 0.00000, 1.00000);\n"
           "    r0.x = 1.00000 / r1.x;\n"
           "    r0.y = r2.w*r2.w + -r2.w;\n"
           "    r2.w = r2.w*r0.y + r2.w;\n"
           "    r2.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = mix(r0.xxx, r1.yyy, hg_ProgramLocal0.xyz);\n"
           "    gl_FragColor.xyz = mix(r2.www, r2.xyz, r0.xyz);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=37364881:eadfc1fa:492b9576:fb1eb981\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcGamutMap::InitProgramDescriptor(HgcGamutMap *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGamutMap_hgc_visible", "//Metal1.0     \n//LEN=000000039c\n[[ visible ]] FragmentOut HgcGamutMap_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(2.000000000, 1.000000000, 0.3330000043, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = fmin(r0.x, c0.x);\n"
    "    r1.z = c0.x - r1.x;\n"
    "    r2.xyz = color1.xyz;\n"
    "    r1.xy = c0.yy;\n"
    "    r1.xyz = -r2.xyz*r1.xyz + r0.xyz;\n"
    "    r2.w = dot(r1.xyz, r1.xyz);\n"
    "    r2.w = sqrt(r2.w);\n"
    "    r1.x = r2.w + c0.y;\n"
    "    r1.y = 1.00000f / r1.x;\n"
    "    r1.x = r2.w*r2.w + c0.y;\n"
    "    r2.w = clamp(dot(r0.xyz, c0.zzz), 0.00000f, 1.00000f);\n"
    "    r0.x = 1.00000f / r1.x;\n"
    "    r0.y = r2.w*r2.w + -r2.w;\n"
    "    r2.w = r2.w*r0.y + r2.w;\n"
    "    r2.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = mix(r0.xxx, r1.yyy, hg_Params[0].xyz);\n"
    "    output.color0.xyz = mix(r2.www, r2.xyz, r0.xyz);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcGamutMap");
}

void sub_1B7904F58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7904F8C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7904F84);
}

void HgcGamutMap::shaderDescription(char *a1@<X8>)
{
  a1[23] = 18;
  strcpy(a1, "HgcGamutMap [hgc1]");
}

uint64_t HgcGamutMap::BindTexture(HgcGamutMap *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 1;
  }
  else
  {
    if (a3) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcGamutMap::Bind(HgcGamutMap *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcGamutMap::RenderTile(HgcGamutMap *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 12);
    uint64_t v7 = 16 * *((int *)a2 + 22);
    uint64_t v8 = *((void *)a2 + 10);
    uint64_t v9 = 16 * *((int *)a2 + 6);
    uint64_t v10 = 16 * *((int *)a2 + 26);
    while (v4 < 2)
    {
      int v76 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v8 += v7;
      v6 += v10;
      v5 += v9;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v11 = 0;
    uint64_t v12 = 16;
    do
    {
      float32x4_t v13 = *(float32x4_t *)(v8 + v12 - 16);
      float32x4_t v14 = *(float32x4_t *)(v8 + v12);
      uint64_t v15 = *((void *)this + 51);
      float32x4_t v16 = *(float32x4_t *)(v15 + 16);
      int8x16_t v17 = (int8x16_t)vminq_f32(v13, v16);
      int8x16_t v18 = (int8x16_t)vminq_f32(v14, v16);
      float32x4_t v19 = *(float32x4_t *)(v6 + v12 - 16);
      float32x4_t v20 = *(float32x4_t *)(v6 + v12);
      float32x4_t v22 = *(float32x4_t *)(v15 + 32);
      int8x16_t v21 = *(int8x16_t *)(v15 + 48);
      float32x4_t v23 = vsubq_f32(v13, vmulq_f32(v19, (float32x4_t)vbslq_s8(v21, (int8x16_t)vsubq_f32(v16, (float32x4_t)vextq_s8(v17, v17, 8uLL)), (int8x16_t)v22)));
      float32x4_t v24 = vsubq_f32(v14, vmulq_f32(v20, (float32x4_t)vbslq_s8(v21, (int8x16_t)vsubq_f32(v16, (float32x4_t)vextq_s8(v18, v18, 8uLL)), (int8x16_t)v22)));
      int32x4_t v25 = (int32x4_t)vmulq_f32(v23, v23);
      int32x4_t v26 = (int32x4_t)vmulq_f32(v24, v24);
      int8x16_t v27 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v25), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL)));
      int8x16_t v28 = *(int8x16_t *)(v15 + 64);
      float32x4_t v29 = *(float32x4_t *)(v15 + 80);
      float32x4_t v30 = (float32x4_t)vbslq_s8(v28, v27, (int8x16_t)v19);
      float32x4_t v31 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v26), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 8uLL))), (int8x16_t)v20);
      float32x4_t v32 = vminq_f32(vmulq_f32(v22, vrsqrteq_f32(v30)), v16);
      float32x4_t v33 = vminq_f32(vmulq_f32(v22, vrsqrteq_f32(v31)), v16);
      float32x4_t v34 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vmulq_f32(vminq_f32(vmulq_f32(v32, vrsqrtsq_f32(vmulq_f32(v32, v30), v32)), v16), v30), (int8x16_t)v19);
      float32x4_t v35 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vmulq_f32(vminq_f32(vmulq_f32(v33, vrsqrtsq_f32(vmulq_f32(v33, v31), v33)), v16), v31), (int8x16_t)v20);
      float32x4_t v36 = (float32x4_t)vextq_s8((int8x16_t)v34, (int8x16_t)v34, 0xCuLL);
      float32x4_t v37 = (float32x4_t)vextq_s8((int8x16_t)v35, (int8x16_t)v35, 0xCuLL);
      float32x4_t v38 = (float32x4_t)vrev64q_s32((int32x4_t)vaddq_f32(v22, v36));
      float32x4_t v39 = (float32x4_t)vrev64q_s32((int32x4_t)vaddq_f32(v22, v37));
      float32x4_t v40 = *(float32x4_t *)(v15 + 96);
      int8x16_t v41 = *(int8x16_t *)(v15 + 112);
      float32x4_t v42 = vminq_f32(vmaxq_f32(vmulq_f32(v16, vrecpeq_f32(v38)), v29), v40);
      float32x4_t v43 = vminq_f32(vmaxq_f32(vmulq_f32(v16, vrecpeq_f32(v39)), v29), v40);
      float32x4_t v44 = (float32x4_t)vbslq_s8(v41, (int8x16_t)vaddq_f32(v29, vmulq_laneq_f32(v36, v34, 3)), (int8x16_t)vmulq_f32(v42, vrecpsq_f32(v38, v42)));
      float32x4_t v45 = (float32x4_t)vbslq_s8(v41, (int8x16_t)vaddq_f32(v29, vmulq_laneq_f32(v37, v35, 3)), (int8x16_t)vmulq_f32(v43, vrecpsq_f32(v39, v43)));
      float32x4_t v47 = *(float32x4_t *)(v15 + 128);
      float32x4_t v46 = *(float32x4_t *)(v15 + 144);
      int32x4_t v48 = (int32x4_t)vmulq_f32(v13, v47);
      int32x4_t v49 = (int32x4_t)vmulq_f32(v14, v47);
      int8x16_t v50 = (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(v48), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v48, (int8x16_t)v48, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v48, (int8x16_t)v48, 8uLL))), v47), v29);
      int8x16_t v51 = (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(v49), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL))), v47), v29);
      float32x4_t v52 = *(float32x4_t *)(v15 + 160);
      int8x16_t v53 = *(int8x16_t *)(v15 + 176);
      float32x4_t v54 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v44), v46), v52), v40);
      float32x4_t v55 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v45), v46), v52), v40);
      float32x4_t v56 = (float32x4_t)vbslq_s8(v28, v50, (int8x16_t)v19);
      v54.i64[0] = vmulq_f32(v54, vrecpsq_f32(v44, v54)).u64[0];
      v55.i64[0] = vmulq_f32(v55, vrecpsq_f32(v45, v55)).u64[0];
      v54.i64[1] = *(void *)(v8 + v12 - 8);
      v55.i64[1] = *(void *)(v8 + v12 + 8);
      float32x4_t v57 = (float32x4_t)vbslq_s8(v28, v51, (int8x16_t)v20);
      int8x16_t v58 = (int8x16_t)vnegq_f32(v56);
      int8x16_t v59 = (int8x16_t)vnegq_f32(v57);
      int8x16_t v60 = vbslq_s8(v53, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v58, v58, 8uLL), vmulq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)v56, (int8x16_t)v56, 8uLL), v56, 3)), (int8x16_t)v54);
      int8x16_t v61 = vbslq_s8(v53, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v59, v59, 8uLL), vmulq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)v57, (int8x16_t)v57, 8uLL), v57, 3)), (int8x16_t)v55);
      float32x4_t v62 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vaddq_f32(vmulq_lane_f32(v57, *(float32x2_t *)v61.i8, 1), v57), (int8x16_t)v20);
      float32x4_t v63 = *(float32x4_t *)(v15 + 192);
      float32x4_t v64 = *(float32x4_t *)(v15 + 208);
      float32x4_t v65 = vmaxq_f32((float32x4_t)vbslq_s8(v28, (int8x16_t)vaddq_f32(vmulq_lane_f32(v56, *(float32x2_t *)v60.i8, 1), v56), (int8x16_t)v19), v63);
      float32x4_t v66 = vmaxq_f32(v62, v63);
      float32x4_t v67 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.i8, 0);
      float32x4_t v68 = vminq_f32(v65, v64);
      float32x4_t v69 = vminq_f32(v66, v64);
      float32x4_t v70 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v61.i8, 0);
      float32x4_t v71 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 3);
      float32x4_t v72 = (float32x4_t)vbslq_s8(v28, v60, (int8x16_t)vaddq_f32(v67, vmulq_f32(*(float32x4_t *)v15, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1), v67))));
      float32x4_t v73 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 3);
      int8x16_t v74 = (int8x16_t)vaddq_f32(v73, vmulq_f32(vsubq_f32(v69, v73), (float32x4_t)vbslq_s8(v28, v61, (int8x16_t)vaddq_f32(v70, vmulq_f32(*(float32x4_t *)v15, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1), v70))))));
      float32x4_t v75 = (int8x16_t *)(v5 + v12);
      v75[-1] = vbslq_s8(v28, v60, (int8x16_t)vaddq_f32(v71, vmulq_f32(vsubq_f32(v68, v71), v72)));
      *float32x4_t v75 = vbslq_s8(v28, v61, v74);
      v11 -= 2;
      v12 += 32;
    }
    while (v4 + v11 > 1);
    int v76 = -v11;
    if (v76 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v77 = 16 * v76;
    float32x4_t v78 = *(float32x4_t *)(v8 + v77);
    uint64_t v79 = *((void *)this + 51);
    float32x4_t v80 = *(float32x4_t *)(v79 + 16);
    int8x16_t v81 = (int8x16_t)vminq_f32(v78, v80);
    float32x4_t v82 = *(float32x4_t *)(v6 + v77);
    float32x4_t v83 = *(float32x4_t *)(v79 + 32);
    float32x4_t v84 = vsubq_f32(v78, vmulq_f32(v82, (float32x4_t)vbslq_s8(*(int8x16_t *)(v79 + 48), (int8x16_t)vsubq_f32(v80, (float32x4_t)vextq_s8(v81, v81, 8uLL)), (int8x16_t)v83)));
    int32x4_t v85 = (int32x4_t)vmulq_f32(v84, v84);
    int8x16_t v86 = *(int8x16_t *)(v79 + 64);
    float32x4_t v87 = *(float32x4_t *)(v79 + 80);
    float32x4_t v88 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v85), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v85, (int8x16_t)v85, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v85, (int8x16_t)v85, 8uLL))), (int8x16_t)v82);
    float32x4_t v89 = vminq_f32(vmulq_f32(v83, vrsqrteq_f32(v88)), v80);
    float32x4_t v90 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vmulq_f32(vminq_f32(vmulq_f32(v89, vrsqrtsq_f32(vmulq_f32(v89, v88), v89)), v80), v88), (int8x16_t)v82);
    float32x4_t v91 = (float32x4_t)vextq_s8((int8x16_t)v90, (int8x16_t)v90, 0xCuLL);
    float32x4_t v92 = (float32x4_t)vrev64q_s32((int32x4_t)vaddq_f32(v83, v91));
    float32x4_t v93 = *(float32x4_t *)(v79 + 96);
    float32x4_t v94 = vminq_f32(vmaxq_f32(vmulq_f32(v80, vrecpeq_f32(v92)), v87), v93);
    float32x4_t v95 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v79 + 112), (int8x16_t)vaddq_f32(v87, vmulq_laneq_f32(v91, v90, 3)), (int8x16_t)vmulq_f32(v94, vrecpsq_f32(v92, v94)));
    float32x4_t v96 = *(float32x4_t *)(v79 + 128);
    int32x4_t v97 = (int32x4_t)vmulq_f32(v78, v96);
    float32x4_t v98 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v95), *(float32x4_t *)(v79 + 144)), *(float32x4_t *)(v79 + 160)), v93);
    v98.i64[0] = vmulq_f32(v98, vrecpsq_f32(v95, v98)).u64[0];
    v98.i64[1] = *(void *)(v8 + v77 + 8);
    float32x4_t v99 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vrev64q_s32(v97), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v97, (int8x16_t)v97, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v97, (int8x16_t)v97, 8uLL))), v96), v87), (int8x16_t)v82);
    int8x16_t v100 = (int8x16_t)vnegq_f32(v99);
    int8x16_t v101 = vbslq_s8(*(int8x16_t *)(v79 + 176), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v100, v100, 8uLL), vmulq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)v99, (int8x16_t)v99, 8uLL), v99, 3)), (int8x16_t)v98);
    float32x4_t v102 = vminq_f32(vmaxq_f32((float32x4_t)vbslq_s8(v86, (int8x16_t)vaddq_f32(vmulq_lane_f32(v99, *(float32x2_t *)v101.i8, 1), v99), (int8x16_t)v82), *(float32x4_t *)(v79 + 192)), *(float32x4_t *)(v79 + 208));
    float32x4_t v103 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v101.i8, 0);
    float32x4_t v104 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v102, 3);
    *(int8x16_t *)(v5 + v77) = vbslq_s8(v86, v101, (int8x16_t)vaddq_f32(v104, vmulq_f32(vsubq_f32(v102, v104), (float32x4_t)vbslq_s8(v86, v101, (int8x16_t)vaddq_f32(v103, vmulq_f32(*(float32x4_t *)v79, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v95.f32, 1), v103)))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcGamutMap::GetDOD(HgcGamutMap *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcGamutMap::GetROI(HgcGamutMap *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcGamutMap::HgcGamutMap(HgcGamutMap *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EEA70;
  operator new();
}

void sub_1B7905790(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGamutMap::~HgcGamutMap(HGNode *this)
{
  *(void *)this = &unk_1F10EEA70;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C405DF52C91);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EEA70;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C405DF52C91);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcGamutMap::SetParameter(HgcGamutMap *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcGamutMap::GetParameter(HgcGamutMap *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcGamutDebug::GetProgram(HgcGamutDebug *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000315\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = half3(r0.xyz < c0.xxx);\n"
             "    r1.x = clamp(dot(r1.xyz, 1.00000h), 0.00000h, 1.00000h);\n"
             "    output.color0 = select(float4(r0), float4(c0.yyyy), -float4(r1.xxxx) < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2d0afb17:dab469cd:798741a4:58cd198f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = float3(r0.xyz < c0.xxx);\n"
             "    r1.x = clamp(dot(r1.xyz, 1.00000f), 0.00000f, 1.00000f);\n"
             "    output.color0 = select(r0, c0.yyyy, -r1.xxxx < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=71fe4496:7156453e:b7d65510:ea5aafa6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000303\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = vec3(lessThan(r0.xyz, c0.xxx));\n"
           "    r1.x = clamp(dot(r1.xyz, vec3(1.00000)), 0.00000, 1.00000);\n"
           "    gl_FragColor = vec4(-r1.x < 0.00000 ? c0.y : r0.x, -r1.x < 0.00000 ? c0.y : r0.y, -r1.x < 0.00000 ? c0.y "
           ": r0.z, -r1.x < 0.00000 ? c0.y : r0.w);\n"
           "}\n"
           "//MD5=a7127b0a:d9e000dc:3c8303cb:b3e5bf56\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGamutDebug::InitProgramDescriptor(HgcGamutDebug *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGamutDebug_hgc_visible", "//Metal1.0     \n//LEN=00000001d1\n[[ visible ]] FragmentOut HgcGamutDebug_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = float3(r0.xyz < c0.xxx);\n"
    "    r1.x = clamp(dot(r1.xyz, 1.00000f), 0.00000f, 1.00000f);\n"
    "    output.color0 = select(r0, c0.yyyy, -r1.xxxx < 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcGamutDebug");
}

void sub_1B7905C0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7905C3C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7905C34);
}

void HgcGamutDebug::shaderDescription(char *a1@<X8>)
{
  a1[23] = 20;
  strcpy(a1, "HgcGamutDebug [hgc1]");
}

uint64_t HgcGamutDebug::BindTexture(HgcGamutDebug *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcGamutDebug::Bind(HgcGamutDebug *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcGamutDebug::RenderTile(HgcGamutDebug *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v39 = 0;
        uint64_t v40 = 16 * v7;
        uint64_t v41 = 16 * v6;
        uint64_t v42 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v43 = 0;
          do
          {
            float32x4_t v44 = v4[v43 / 0x10];
            float32x4_t v45 = (float32x4_t *)*((void *)this + 51);
            float32x4_t v46 = v45[1];
            float32x4_t v47 = (float32x4_t)vandq_s8((int8x16_t)v46, (int8x16_t)vcgtq_f32(*v45, v44));
            v5[v43 / 0x10] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v47, (int8x16_t)v47, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v47), v47)), *v45), v46), 0), *v45), (int8x16_t)v46, (int8x16_t)v44);
            v43 += 16;
          }
          while (v42 != v43);
          ++v39;
          int v4 = (float32x4_t *)((char *)v4 + v40);
          int v5 = (int8x16_t *)((char *)v5 + v41);
        }
        while (v39 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      int v11 = v4 + 4;
      uint64_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        float32x4_t v14 = v12;
        uint64_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = v4[v16 - 2];
          float32x4_t v18 = v4[v16 - 1];
          float32x4_t v19 = v4[v16];
          float32x4_t v20 = v4[v16 + 1];
          int8x16_t v21 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v22 = *v21;
          float32x4_t v23 = v21[1];
          float32x4_t v24 = v15;
          float32x4_t v25 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(*v21, v17));
          float32x4_t v26 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(*v21, v18));
          float32x4_t v27 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(*v21, v19));
          float32x4_t v28 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(*v21, v20));
          float32x4_t v29 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v25), v25)), *v21), v23), 0);
          float32x4_t v30 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v26), v26)), *v21), v23), 0);
          float32x4_t v31 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v27), v27)), *v21), v23), 0);
          float32x4_t v32 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v28), v28)), *v21), v23), 0);
          float32x4_t v33 = v14;
          float32x4_t v34 = &v5[v16];
          v13 += 4;
          v34[-2] = vbslq_s8((int8x16_t)vcgtq_f32(v29, v22), (int8x16_t)v23, (int8x16_t)v17);
          v34[-1] = vbslq_s8((int8x16_t)vcgtq_f32(v30, v22), (int8x16_t)v23, (int8x16_t)v18);
          *float32x4_t v34 = vbslq_s8((int8x16_t)vcgtq_f32(v31, v22), (int8x16_t)v23, (int8x16_t)v19);
          v34[1] = vbslq_s8((int8x16_t)vcgtq_f32(v32, v22), (int8x16_t)v23, (int8x16_t)v20);
          v16 += 4;
          v15 += 4;
          float32x4_t v14 = v33 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            float32x4_t v35 = (float32x4_t *)*((void *)this + 51);
            float32x4_t v36 = *v24++;
            float32x4_t v37 = v35[1];
            float32x4_t v38 = (float32x4_t)vandq_s8((int8x16_t)v37, (int8x16_t)vcgtq_f32(*v35, v36));
            *v33++ = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v38), v38)), *v35), v37), 0), *v35), (int8x16_t)v37, (int8x16_t)v36);
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (int8x16_t *)((char *)v5 + v9);
        int v4 = (float32x4_t *)((char *)v4 + v10);
        int v11 = (float32x4_t *)((char *)v11 + v10);
        uint64_t v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcGamutDebug::GetDOD(HgcGamutDebug *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcGamutDebug::GetROI(HgcGamutDebug *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcGamutDebug::HgcGamutDebug(HgcGamutDebug *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EECD8;
  operator new();
}

void sub_1B79060CC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGamutDebug::~HgcGamutDebug(HGNode *this)
{
  *(void *)this = &unk_1F10EECD8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EECD8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcGamutDebug::SetParameter(HgcGamutDebug *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcGamutDebug::GetParameter(HgcGamutDebug *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcCinematicDepthFX_ColorPop::GetProgram(HgcCinematicDepthFX_ColorPop *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000435\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.6779999733, 0.2626999915, 0.05930000171);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.x - half(hg_Params[0].x);\n"
             "    r1.y = abs(r1.x);\n"
             "    r1.x = (half) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).x;\n"
             "    r1.x = half(r1.x < r1.y);\n"
             "    r1.z = r0.y*c0.y;\n"
             "    r1.y = r0.x*c0.z + r1.z;\n"
             "    r1.y = r0.z*c0.w + r1.y;\n"
             "    output.color0.xyz = select(float3(r0.xyz), float3(r1.yyy), -float3(r1.xxx) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1298defe:3711e2e2:cd1e08c0:d5f1acf3\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000407\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.6779999733, 0.2626999915, 0.05930000171);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.x - hg_Params[0].x;\n"
             "    r1.y = abs(r1.x);\n"
             "    r1.x = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).x;\n"
             "    r1.x = float(r1.x < r1.y);\n"
             "    r1.z = r0.y*c0.y;\n"
             "    r1.y = r0.x*c0.z + r1.z;\n"
             "    r1.y = r0.z*c0.w + r1.y;\n"
             "    output.color0.xyz = select(r0.xyz, r1.yyy, -r1.xxx < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=55869529:89b21dce:60251d5d:c1ca7ed8\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003ec\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.6779999733, 0.2626999915, 0.05930000171);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.x - hg_ProgramLocal0.x;\n"
           "    r1.y = abs(r1.x);\n"
           "    r1.x = texture2D(hg_Texture1, hg_TexCoord1.xy).x;\n"
           "    r1.x = float(r1.x < r1.y);\n"
           "    r1.z = r0.y*c0.y;\n"
           "    r1.y = r0.x*c0.z + r1.z;\n"
           "    r1.y = r0.z*c0.w + r1.y;\n"
           "    gl_FragColor.xyz = vec3(-r1.x < 0.00000 ? r1.y : r0.x, -r1.x < 0.00000 ? r1.y : r0.y, -r1.x < 0.00000 ? r"
           "1.y : r0.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=b5739cb7:e2f53a23:ffaea585:6fd6d74e\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcCinematicDepthFX_ColorPop::InitProgramDescriptor(HgcCinematicDepthFX_ColorPop *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcCinematicDepthFX_ColorPop_hgc_visible", "//Metal1.0     \n//LEN=0000000272\n[[ visible ]] FragmentOut HgcCinematicDepthFX_ColorPop_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.6779999733, 0.2626999915, 0.05930000171);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = c0.x - hg_Params[0].x;\n"
    "    r1.y = abs(r1.x);\n"
    "    r1.x = color1.x;\n"
    "    r1.x = float(r1.x < r1.y);\n"
    "    r1.z = r0.y*c0.y;\n"
    "    r1.y = r0.x*c0.z + r1.z;\n"
    "    r1.y = r0.z*c0.w + r1.y;\n"
    "    output.color0.xyz = select(r0.xyz, r1.yyy, -r1.xxx < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcCinematicDepthFX_ColorPop");
}

void sub_1B790653C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7906570(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7906568);
}

char *HgcCinematicDepthFX_ColorPop::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375E40;
  strcpy(result, "HgcCinematicDepthFX_ColorPop [hgc1]");
  return result;
}

uint64_t HgcCinematicDepthFX_ColorPop::BindTexture(HgcCinematicDepthFX_ColorPop *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 1;
  }
  else
  {
    if (a3) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcCinematicDepthFX_ColorPop::Bind(HgcCinematicDepthFX_ColorPop *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcCinematicDepthFX_ColorPop::RenderTile(HgcCinematicDepthFX_ColorPop *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 12);
    uint64_t v7 = 16 * *((int *)a2 + 22);
    uint64_t v8 = *((void *)a2 + 10);
    uint64_t v9 = 16 * *((int *)a2 + 26);
    uint64_t v10 = 16 * *((int *)a2 + 6);
    while (v4 < 4)
    {
      LODWORD(v43) = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      ++v3;
      v8 += v7;
      v6 += v9;
      v5 += v10;
      if (v3 == v2) {
        return 0;
      }
    }
    int v11 = 0;
    uint64_t v12 = 32;
    do
    {
      uint64_t v13 = *((void *)this + 51);
      float32x4_t v14 = *(float32x4_t *)(v13 + 16);
      float32x4_t v15 = *(float32x4_t *)(v8 + v12 - 32);
      float32x4_t v16 = *(float32x4_t *)(v8 + v12 - 16);
      int8x16_t v17 = (int8x16_t)vabsq_f32((float32x4_t)vrev64q_s32((int32x4_t)vsubq_f32(v14, *(float32x4_t *)v13)));
      int8x16_t v18 = *(int8x16_t *)(v13 + 32);
      float32x4_t v19 = *(float32x4_t *)(v13 + 48);
      float32x4_t v20 = *(float32x4_t *)(v8 + v12);
      float32x4_t v21 = *(float32x4_t *)(v8 + v12 + 16);
      float32x4_t v22 = (float32x4_t)vbslq_s8(v18, *(int8x16_t *)(v6 + v12 - 32), v17);
      float32x4_t v23 = (float32x4_t)vbslq_s8(v18, *(int8x16_t *)(v6 + v12 - 16), v17);
      float32x4_t v24 = (float32x4_t)vbslq_s8(v18, *(int8x16_t *)(v6 + v12), v17);
      float32x4_t v25 = (float32x4_t)vbslq_s8(v18, *(int8x16_t *)(v6 + v12 + 16), v17);
      int8x16_t v26 = vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v22), v22));
      int8x16_t v27 = vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v23), v23));
      int8x16_t v28 = vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v24), v24));
      float32x4_t v29 = vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v15, 0xCuLL), v14);
      float32x4_t v30 = vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v16, 0xCuLL), v14);
      int8x16_t v31 = (int8x16_t)vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v20, 0xCuLL), v14);
      int8x16_t v32 = vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v25), v25));
      *(int8x8_t *)v33.f32 = vext_s8(*(int8x8_t *)v26.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v29, (int8x16_t)v29, 8uLL), 4uLL);
      uint64_t v34 = vextq_s8((int8x16_t)v29, v26, 0xCuLL).u64[0];
      v26.i64[1] = v29.i64[1];
      *(int8x8_t *)v29.f32 = vext_s8(*(int8x8_t *)v27.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL), 4uLL);
      unint64_t v35 = vextq_s8((int8x16_t)v30, v27, 0xCuLL).u64[0];
      v27.i64[1] = v30.i64[1];
      *(int8x8_t *)v30.f32 = vext_s8(*(int8x8_t *)v28.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL), 4uLL);
      unint64_t v36 = vextq_s8(v31, v28, 0xCuLL).u64[0];
      v28.i64[1] = v31.i64[1];
      int8x16_t v37 = (int8x16_t)vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v21, 0xCuLL), v14);
      *(int8x8_t *)v38.f32 = vext_s8(*(int8x8_t *)v32.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL), 4uLL);
      v39.i64[0] = v32.i64[0];
      v39.i64[1] = v37.i64[1];
      v33.i64[1] = v34;
      v29.i64[1] = v35;
      v30.i64[1] = v36;
      v38.i64[1] = vextq_s8(v37, v32, 0xCuLL).u64[0];
      v26.i64[0] = vbslq_s8(v18, v26, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v19, v15, 2), (float32x4_t)vbslq_s8(v18, v26, (int8x16_t)vaddq_f32(vmulq_n_f32(v14, v15.f32[0]), v33)))).u64[0];
      v27.i64[0] = vbslq_s8(v18, v27, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v19, v16, 2), (float32x4_t)vbslq_s8(v18, v27, (int8x16_t)vaddq_f32(vmulq_n_f32(v14, v16.f32[0]), v29)))).u64[0];
      v28.i64[0] = vbslq_s8(v18, v28, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v19, v20, 2), (float32x4_t)vbslq_s8(v18, v28, (int8x16_t)vaddq_f32(vmulq_n_f32(v14, v20.f32[0]), v30)))).u64[0];
      v18.i64[0] = vbslq_s8(v18, v39, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v19, v21, 2), (float32x4_t)vbslq_s8(v18, v39, (int8x16_t)vaddq_f32(vmulq_n_f32(v14, v21.f32[0]), v38)))).u64[0];
      float32x4_t v40 = *(float32x4_t *)(v13 + 64);
      int8x16_t v41 = *(int8x16_t *)(v13 + 80);
      uint64_t v42 = (int8x16_t *)(v5 + v12);
      v42[-2] = vbslq_s8(v41, (int8x16_t)v15, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.i8, 0), v40), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v26.i8, 1), (int8x16_t)v15));
      v42[-1] = vbslq_s8(v41, (int8x16_t)v16, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.i8, 0), v40), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v27.i8, 1), (int8x16_t)v16));
      *uint64_t v42 = vbslq_s8(v41, (int8x16_t)v20, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.i8, 0), v40), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v28.i8, 1), (int8x16_t)v20));
      v42[1] = vbslq_s8(v41, (int8x16_t)v21, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.i8, 0), v40), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v18.i8, 1), (int8x16_t)v21));
      v11 -= 4;
      v12 += 64;
    }
    while (v4 + v11 > 3);
    LODWORD(v43) = -v11;
    if ((int)v43 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v43 = v43;
    do
    {
      float32x4_t v44 = *(float32x4_t *)(v8 + 16 * v43);
      uint64_t v45 = *((void *)this + 51);
      float32x4_t v46 = *(float32x4_t *)(v45 + 16);
      int8x16_t v47 = *(int8x16_t *)(v45 + 32);
      float32x4_t v48 = (float32x4_t)vbslq_s8(v47, *(int8x16_t *)(v6 + 16 * v43), (int8x16_t)vabsq_f32((float32x4_t)vrev64q_s32((int32x4_t)vsubq_f32(v46, *(float32x4_t *)v45))));
      int8x16_t v49 = vandq_s8((int8x16_t)v46, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v48), v48));
      int8x16_t v50 = (int8x16_t)vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v44, (int8x16_t)v44, 0xCuLL), v46);
      *(int8x8_t *)v51.f32 = vext_s8(*(int8x8_t *)v49.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL), 4uLL);
      uint64_t v52 = vextq_s8(v50, v49, 0xCuLL).u64[0];
      v49.i64[1] = v50.i64[1];
      v51.i64[1] = v52;
      v46.i64[0] = vbslq_s8(v47, v49, (int8x16_t)vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v45 + 48), v44, 2), (float32x4_t)vbslq_s8(v47, v49, (int8x16_t)vaddq_f32(vmulq_n_f32(v46, v44.f32[0]), v51)))).u64[0];
      *(int8x16_t *)(v5 + 16 * v43++) = vbslq_s8(*(int8x16_t *)(v45 + 80), (int8x16_t)v44, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v46.f32, 0), *(float32x4_t *)(v45 + 64)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v46.f32, 1), (int8x16_t)v44));
    }
    while (v43 < v4);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcCinematicDepthFX_ColorPop::GetDOD(HgcCinematicDepthFX_ColorPop *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcCinematicDepthFX_ColorPop::GetROI(HgcCinematicDepthFX_ColorPop *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcCinematicDepthFX_ColorPop::HgcCinematicDepthFX_ColorPop(HgcCinematicDepthFX_ColorPop *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EEF40;
  operator new();
}

void sub_1B7906BB8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcCinematicDepthFX_ColorPop::~HgcCinematicDepthFX_ColorPop(HGNode *this)
{
  *(void *)this = &unk_1F10EEF40;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EEF40;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcCinematicDepthFX_ColorPop::SetParameter(HgcCinematicDepthFX_ColorPop *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcCinematicDepthFX_ColorPop::GetParameter(HgcCinematicDepthFX_ColorPop *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcCinematicDepthFX_FadeOut::GetProgram(HgcCinematicDepthFX_FadeOut *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000033c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).x;\n"
             "    r0.x = pow(r0.x, half(hg_Params[0].x));\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0.xyz = float3(r1.xyz)*float3(r0.xxx);\n"
             "    output.color0.w = float(r1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5d72101a:0d1ba2d4:a3186824:d7a1b699\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000313\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).x;\n"
             "    r0.x = pow(r0.x, hg_Params[0].x);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0.xyz = r1.xyz*r0.xxx;\n"
             "    output.color0.w = r1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c08c65b8:bcd4ef5b:1ac91bee:f607030c\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002ba\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture1, hg_TexCoord1.xy).x;\n"
           "    r0.x = pow(r0.x, hg_ProgramLocal0.x);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor.xyz = r1.xyz*r0.xxx;\n"
           "    gl_FragColor.w = r1.w;\n"
           "}\n"
           "//MD5=4fc1596e:38c41ba7:94ce35ad:ee78ae36\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcCinematicDepthFX_FadeOut::InitProgramDescriptor(HgcCinematicDepthFX_FadeOut *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcCinematicDepthFX_FadeOut_hgc_visible", "//Metal1.0     \n//LEN=000000017d\n[[ visible ]] FragmentOut HgcCinematicDepthFX_FadeOut_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = color1.x;\n"
    "    r0.x = pow(r0.x, hg_Params[0].x);\n"
    "    r1 = color0;\n"
    "    output.color0.xyz = r1.xyz*r0.xxx;\n"
    "    output.color0.w = r1.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcCinematicDepthFX_FadeOut");
}

void sub_1B79070CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7907100(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79070F8);
}

char *HgcCinematicDepthFX_FadeOut::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  float result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375DB0;
  strcpy(result, "HgcCinematicDepthFX_FadeOut [hgc1]");
  return result;
}

uint64_t HgcCinematicDepthFX_FadeOut::BindTexture(HgcCinematicDepthFX_FadeOut *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 != 1) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcCinematicDepthFX_FadeOut::Bind(HgcCinematicDepthFX_FadeOut *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcCinematicDepthFX_FadeOut::RenderTile(HgcCinematicDepthFX_FadeOut *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 26);
    uint64_t v8 = *((void *)a2 + 12);
    uint64_t v9 = 16 * *((int *)a2 + 6);
    uint64_t v10 = 16 * *((int *)a2 + 22);
    while (v4 < 3)
    {
      LODWORD(v73) = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      ++v3;
      v8 += v7;
      v5 += v9;
      v6 += v10;
      if (v3 == v2) {
        return 0;
      }
    }
    int v11 = 0;
    uint64_t v12 = 32;
    do
    {
      float32x4_t v13 = *(float32x4_t *)(v8 + v12 - 32);
      float32x4_t v14 = *(float32x4_t *)(v8 + v12 - 16);
      uint64_t v15 = *((void *)this + 51);
      float32x4_t v16 = *(float32x4_t *)(v8 + v12);
      int8x16_t v17 = *(int8x16_t *)(v15 + 16);
      float32x4_t v18 = *(float32x4_t *)(v15 + 32);
      float32x4_t v19 = *(float32x4_t *)(v15 + 48);
      float32x4_t v20 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v13), (int8x16_t)v18);
      float32x4_t v21 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v14), (int8x16_t)v18);
      int8x16_t v22 = (int8x16_t)vcgtq_f32(v19, v14);
      float32x4_t v23 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v16), (int8x16_t)v18);
      int8x16_t v24 = *(int8x16_t *)(v15 + 64);
      float32x4_t v25 = *(float32x4_t *)(v15 + 80);
      float32x4_t v26 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v19, v16)));
      float32x4_t v27 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v13, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v19, v13))), v25);
      float32x4_t v28 = *(float32x4_t *)(v15 + 96);
      float32x4_t v29 = *(float32x4_t *)(v15 + 112);
      float32x4_t v30 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v14, 0x17uLL)), (float32x4_t)vandq_s8(v24, v22)), v25);
      float32x4_t v31 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v20, v28));
      float32x4_t v32 = vsubq_f32(v26, v25);
      float32x4_t v33 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v21, v28));
      float32x4_t v34 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v23, v28));
      float32x4_t v35 = vaddq_f32(v30, v33);
      float32x4_t v36 = vsubq_f32(vsubq_f32(v20, v18), vmulq_f32(vmulq_f32(v29, v31), v20));
      float32x4_t v37 = vsubq_f32(vsubq_f32(v21, v18), vmulq_f32(vmulq_f32(v29, v33), v21));
      float32x4_t v38 = vsubq_f32(vsubq_f32(v23, v18), vmulq_f32(vmulq_f32(v29, v34), v23));
      float32x4_t v39 = *(float32x4_t *)(v15 + 128);
      float32x4_t v40 = *(float32x4_t *)(v15 + 144);
      float32x4_t v41 = vaddq_f32(v39, vmulq_f32(v40, v36));
      float32x4_t v42 = vaddq_f32(v39, vmulq_f32(v40, v37));
      float32x4_t v43 = vaddq_f32(v39, vmulq_f32(v40, v38));
      float32x4_t v44 = *(float32x4_t *)(v15 + 160);
      float32x4_t v45 = *(float32x4_t *)(v15 + 176);
      float32x4_t v46 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(vaddq_f32(v32, v34), vmulq_f32(v38, vaddq_f32(vaddq_f32(v44, vmulq_f32(v38, v45)), vmulq_f32(vmulq_f32(v38, v38), v43)))));
      float32x4_t v47 = *(float32x4_t *)(v15 + 192);
      float32x4_t v48 = *(float32x4_t *)(v15 + 208);
      float32x4_t v49 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v15, vaddq_f32(vaddq_f32(v27, v31), vmulq_f32(v36, vaddq_f32(vaddq_f32(v44, vmulq_f32(v36, v45)), vmulq_f32(vmulq_f32(v36, v36), v41))))), v47);
      float32x4_t v50 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v15, vaddq_f32(v35, vmulq_f32(v37, vaddq_f32(vaddq_f32(v44, vmulq_f32(v37, v45)), vmulq_f32(vmulq_f32(v37, v37), v42))))), v47);
      float32x4_t v51 = vmaxq_f32(v46, v47);
      float32x4_t v52 = vcvtq_f32_s32(vcvtq_s32_f32(v49));
      float32x4_t v53 = vcvtq_f32_s32(vcvtq_s32_f32(v50));
      float32x4_t v54 = vcvtq_f32_s32(vcvtq_s32_f32(v51));
      float32x4_t v55 = vsubq_f32(v52, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v52, v49)));
      float32x4_t v56 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v53, v50)));
      float32x4_t v57 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v54, v51)));
      float32x4_t v58 = vsubq_f32(v49, v55);
      float32x4_t v59 = vsubq_f32(v50, v56);
      float32x4_t v60 = vsubq_f32(v51, v57);
      float32x4_t v61 = *(float32x4_t *)(v15 + 224);
      float32x4_t v62 = *(float32x4_t *)(v15 + 240);
      float32x4_t v63 = vaddq_f32(v48, vmulq_f32(v61, v59));
      float32x4_t v64 = vmulq_f32(v60, vaddq_f32(v62, vmulq_f32(v60, vaddq_f32(v48, vmulq_f32(v61, v60)))));
      float32x4_t v65 = vaddq_f32(v18, vmulq_f32(v58, vaddq_f32(v62, vmulq_f32(v58, vaddq_f32(v48, vmulq_f32(v61, v58))))));
      int32x4_t v66 = vcvtq_s32_f32(v56);
      int32x4_t v67 = vcvtq_s32_f32(v57);
      int32x4_t v68 = *(int32x4_t *)(v15 + 256);
      int8x16_t v69 = *(int8x16_t *)(v15 + 272);
      int8x16_t v70 = vbslq_s8(v69, *(int8x16_t *)(v6 + v12 - 16), (int8x16_t)vmulq_n_f32(*(float32x4_t *)(v6 + v12 - 16), vmulq_f32(vaddq_f32(v18, vmulq_f32(v59, vaddq_f32(v62, vmulq_f32(v59, v63)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v68, v66), 0x17uLL)).f32[0]));
      int8x16_t v71 = vbslq_s8(v69, *(int8x16_t *)(v6 + v12), (int8x16_t)vmulq_n_f32(*(float32x4_t *)(v6 + v12), vmulq_f32(vaddq_f32(v18, v64), (float32x4_t)vshlq_n_s32(vaddq_s32(v68, v67), 0x17uLL)).f32[0]));
      float32x4_t v72 = (int8x16_t *)(v5 + v12);
      v72[-2] = vbslq_s8(v69, *(int8x16_t *)(v6 + v12 - 32), (int8x16_t)vmulq_n_f32(*(float32x4_t *)(v6 + v12 - 32), vmulq_f32(v65, (float32x4_t)vshlq_n_s32(vaddq_s32(v68, vcvtq_s32_f32(v55)), 0x17uLL)).f32[0]));
      v72[-1] = v70;
      *float32x4_t v72 = v71;
      v11 -= 3;
      v12 += 48;
    }
    while (v4 + v11 > 2);
    LODWORD(v73) = -v11;
    if ((int)v73 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v73 = v73;
    do
    {
      float32x4_t v74 = *(float32x4_t *)(v8 + 16 * v73);
      uint64_t v75 = *((void *)this + 51);
      float32x4_t v76 = *(float32x4_t *)(v75 + 32);
      float32x4_t v77 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v75 + 16), (int8x16_t)v74), (int8x16_t)v76);
      float32x4_t v78 = (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v77, *(float32x4_t *)(v75 + 96)));
      float32x4_t v79 = vsubq_f32(vsubq_f32(v77, v76), vmulq_f32(vmulq_f32(*(float32x4_t *)(v75 + 112), v78), v77));
      float32x4_t v80 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v75, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v74, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v75 + 64), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v75 + 48), v74))), *(float32x4_t *)(v75 + 80)), v78), vmulq_f32(v79, vaddq_f32(vaddq_f32(*(float32x4_t *)(v75 + 160), vmulq_f32(v79, *(float32x4_t *)(v75 + 176))), vmulq_f32(vmulq_f32(v79, v79), vaddq_f32(*(float32x4_t *)(v75 + 128), vmulq_f32(*(float32x4_t *)(v75 + 144), v79))))))),
              *(float32x4_t *)(v75 + 192));
      float32x4_t v81 = vcvtq_f32_s32(vcvtq_s32_f32(v80));
      float32x4_t v82 = vsubq_f32(v81, (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v81, v80)));
      float32x4_t v83 = vsubq_f32(v80, v82);
      *(int8x16_t *)(v5 + 16 * v73) = vbslq_s8(*(int8x16_t *)(v75 + 272), *(int8x16_t *)(v6 + 16 * v73), (int8x16_t)vmulq_n_f32(*(float32x4_t *)(v6 + 16 * v73), vmulq_f32(vaddq_f32(v76, vmulq_f32(v83, vaddq_f32(*(float32x4_t *)(v75 + 240), vmulq_f32(v83, vaddq_f32(*(float32x4_t *)(v75 + 208), vmulq_f32(*(float32x4_t *)(v75 + 224), v83)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v75 + 256),
                                                                        vcvtq_s32_f32(v82)),
                                                                      0x17uLL)).f32[0]));
      ++v73;
    }
    while (v73 < v4);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcCinematicDepthFX_FadeOut::GetDOD(HgcCinematicDepthFX_FadeOut *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcCinematicDepthFX_FadeOut::GetROI(HgcCinematicDepthFX_FadeOut *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcCinematicDepthFX_FadeOut::HgcCinematicDepthFX_FadeOut(HgcCinematicDepthFX_FadeOut *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EF1A8;
  operator new();
}

void sub_1B79078E0(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcCinematicDepthFX_FadeOut::~HgcCinematicDepthFX_FadeOut(HGNode *this)
{
  *(void *)this = &unk_1F10EF1A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40A8CFB95ELL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EF1A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40A8CFB95ELL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcCinematicDepthFX_FadeOut::SetParameter(HgcCinematicDepthFX_FadeOut *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcCinematicDepthFX_FadeOut::GetParameter(HgcCinematicDepthFX_FadeOut *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcCinematicDepthFX_Fog::GetProgram(HgcCinematicDepthFX_Fog *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000400\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 2.718281746, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = (half3) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r0.xyz = c0.xxx - r0.xyz;\n"
             "    r0.xyz = fabs(r0.xyz)*half3(hg_Params[0].xyz);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = pow(c0.yyy, r0.xyz);\n"
             "    r1.xyz = r1.xyz*r0.xyz + -r0.xyz;\n"
             "    output.color0.xyz = float3(r1.xyz) + float3(c0.xxx);\n"
             "    output.color0.w = float(r1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=95cd50d6:e7470ad6:0a32471f:84c275c9\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003d7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 2.718281746, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r0.xyz = c0.xxx - r0.xyz;\n"
             "    r0.xyz = fabs(r0.xyz)*hg_Params[0].xyz;\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = pow(c0.yyy, r0.xyz);\n"
             "    r1.xyz = r1.xyz*r0.xyz + -r0.xyz;\n"
             "    output.color0.xyz = r1.xyz + c0.xxx;\n"
             "    output.color0.w = r1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=91a66ef9:927addd3:c7b26079:fd8ccfc6\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000381\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 2.718281746, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0.xyz = texture2D(hg_Texture1, hg_TexCoord1.xy).xyz;\n"
           "    r0.xyz = c0.xxx - r0.xyz;\n"
           "    r0.xyz = abs(r0.xyz)*hg_ProgramLocal0.xyz;\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = pow(c0.yyy, r0.xyz);\n"
           "    r1.xyz = r1.xyz*r0.xyz + -r0.xyz;\n"
           "    gl_FragColor.xyz = r1.xyz + c0.xxx;\n"
           "    gl_FragColor.w = r1.w;\n"
           "}\n"
           "//MD5=4a441193:7bfac871:d695a5d5:1d33ddce\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcCinematicDepthFX_Fog::InitProgramDescriptor(HgcCinematicDepthFX_Fog *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcCinematicDepthFX_Fog_hgc_visible", "//Metal1.0     \n//LEN=000000023d\n[[ visible ]] FragmentOut HgcCinematicDepthFX_Fog_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 2.718281746, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = color1.xyz;\n"
    "    r0.xyz = c0.xxx - r0.xyz;\n"
    "    r0.xyz = fabs(r0.xyz)*hg_Params[0].xyz;\n"
    "    r1 = color0;\n"
    "    r0.xyz = pow(c0.yyy, r0.xyz);\n"
    "    r1.xyz = r1.xyz*r0.xyz + -r0.xyz;\n"
    "    output.color0.xyz = r1.xyz + c0.xxx;\n"
    "    output.color0.w = r1.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcCinematicDepthFX_Fog");
}

void sub_1B7907DF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7907E28(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7907E20);
}

double HgcCinematicDepthFX_Fog::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376180;
  strcpy(v3, "HgcCinematicDepthFX_Fog [hgc1]");
  return *(double *)"pthFX_Fog [hgc1]";
}

uint64_t HgcCinematicDepthFX_Fog::BindTexture(HgcCinematicDepthFX_Fog *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 != 1) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcCinematicDepthFX_Fog::Bind(HgcCinematicDepthFX_Fog *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcCinematicDepthFX_Fog::RenderTile(HgcCinematicDepthFX_Fog *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 26);
    uint64_t v8 = *((void *)a2 + 12);
    uint64_t v9 = 16 * *((int *)a2 + 6);
    uint64_t v10 = 16 * *((int *)a2 + 22);
    while (v4 < 3)
    {
      LODWORD(v46) = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      ++v3;
      v8 += v7;
      v5 += v9;
      v6 += v10;
      if (v3 == v2) {
        return 0;
      }
    }
    int v11 = 0;
    uint64_t v12 = 32;
    do
    {
      uint64_t v13 = *((void *)this + 51);
      float32x4_t v14 = *(float32x4_t *)(v13 + 16);
      float32x4_t v15 = *(float32x4_t *)(v6 + v12 - 32);
      float32x4_t v16 = *(float32x4_t *)(v6 + v12 - 16);
      float32x4_t v18 = *(float32x4_t *)(v13 + 32);
      float32x4_t v17 = *(float32x4_t *)(v13 + 48);
      float32x4_t v19 = vmaxq_f32(vmulq_f32(vmulq_f32(*(float32x4_t *)v13, vabdq_f32(v14, *(float32x4_t *)(v8 + v12 - 32))), v18), v17);
      float32x4_t v20 = vmaxq_f32(vmulq_f32(vmulq_f32(*(float32x4_t *)v13, vabdq_f32(v14, *(float32x4_t *)(v8 + v12 - 16))), v18), v17);
      float32x4_t v21 = vmaxq_f32(vmulq_f32(vmulq_f32(*(float32x4_t *)v13, vabdq_f32(v14, *(float32x4_t *)(v8 + v12))), v18), v17);
      float32x4_t v22 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
      float32x4_t v23 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      float32x4_t v24 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      float32x4_t v25 = vsubq_f32(v22, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v22, v19)));
      float32x4_t v26 = vsubq_f32(v23, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v23, v20)));
      float32x4_t v27 = vsubq_f32(v24, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v24, v21)));
      float32x4_t v28 = vsubq_f32(v19, v25);
      float32x4_t v29 = vsubq_f32(v20, v26);
      float32x4_t v30 = vsubq_f32(v21, v27);
      float32x4_t v31 = *(float32x4_t *)(v13 + 64);
      float32x4_t v32 = *(float32x4_t *)(v13 + 80);
      float32x4_t v33 = vaddq_f32(v31, vmulq_f32(v32, v28));
      float32x4_t v34 = vaddq_f32(v31, vmulq_f32(v32, v29));
      float32x4_t v35 = vaddq_f32(v31, vmulq_f32(v32, v30));
      float32x4_t v36 = *(float32x4_t *)(v13 + 96);
      int32x4_t v37 = *(int32x4_t *)(v13 + 112);
      float32x4_t v38 = vmulq_f32(vaddq_f32(v14, vmulq_f32(v28, vaddq_f32(v36, vmulq_f32(v28, v33)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v37, vcvtq_s32_f32(v25)), 0x17uLL));
      float32x4_t v39 = vmulq_f32(vaddq_f32(v14, vmulq_f32(v29, vaddq_f32(v36, vmulq_f32(v29, v34)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v37, vcvtq_s32_f32(v26)), 0x17uLL));
      float32x4_t v40 = vmulq_f32(vaddq_f32(v14, vmulq_f32(v30, vaddq_f32(v36, vmulq_f32(v30, v35)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v37, vcvtq_s32_f32(v27)), 0x17uLL));
      int8x16_t v41 = *(int8x16_t *)(v13 + 128);
      int8x16_t v42 = (int8x16_t)vaddq_f32(v14, (float32x4_t)vbslq_s8(v41, (int8x16_t)v15, (int8x16_t)vsubq_f32(vmulq_f32(v15, v38), v38)));
      int8x16_t v43 = (int8x16_t)vaddq_f32(v14, (float32x4_t)vbslq_s8(v41, (int8x16_t)v16, (int8x16_t)vsubq_f32(vmulq_f32(v16, v39), v39)));
      int8x16_t v44 = vbslq_s8(v41, *(int8x16_t *)(v6 + v12), (int8x16_t)vaddq_f32(v14, (float32x4_t)vbslq_s8(v41, *(int8x16_t *)(v6 + v12), (int8x16_t)vsubq_f32(vmulq_f32(*(float32x4_t *)(v6 + v12), v40), v40))));
      float32x4_t v45 = (int8x16_t *)(v5 + v12);
      v45[-2] = vbslq_s8(v41, (int8x16_t)v15, v42);
      v45[-1] = vbslq_s8(v41, (int8x16_t)v16, v43);
      *float32x4_t v45 = v44;
      v11 -= 3;
      v12 += 48;
    }
    while (v4 + v11 > 2);
    LODWORD(v46) = -v11;
    if ((int)v46 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v46 = v46;
    do
    {
      uint64_t v47 = *((void *)this + 51);
      float32x4_t v48 = *(float32x4_t *)(v47 + 16);
      float32x4_t v49 = vmaxq_f32(vmulq_f32(vmulq_f32(*(float32x4_t *)v47, vabdq_f32(v48, *(float32x4_t *)(v8 + 16 * v46))), *(float32x4_t *)(v47 + 32)), *(float32x4_t *)(v47 + 48));
      float32x4_t v50 = vcvtq_f32_s32(vcvtq_s32_f32(v49));
      float32x4_t v51 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v48, (int8x16_t)vcgtq_f32(v50, v49)));
      float32x4_t v52 = vsubq_f32(v49, v51);
      float32x4_t v53 = vmulq_f32(vaddq_f32(v48, vmulq_f32(v52, vaddq_f32(*(float32x4_t *)(v47 + 96), vmulq_f32(v52, vaddq_f32(*(float32x4_t *)(v47 + 64), vmulq_f32(*(float32x4_t *)(v47 + 80), v52)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v47 + 112), vcvtq_s32_f32(v51)), 0x17uLL));
      *(int8x16_t *)(v5 + 16 * v46) = vbslq_s8(*(int8x16_t *)(v47 + 128), *(int8x16_t *)(v6 + 16 * v46), (int8x16_t)vaddq_f32(v48, (float32x4_t)vbslq_s8(*(int8x16_t *)(v47 + 128), *(int8x16_t *)(v6 + 16 * v46), (int8x16_t)vsubq_f32(vmulq_f32(*(float32x4_t *)(v6 + 16 * v46), v53), v53))));
      ++v46;
    }
    while (v46 < v4);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcCinematicDepthFX_Fog::GetDOD(HgcCinematicDepthFX_Fog *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcCinematicDepthFX_Fog::GetROI(HgcCinematicDepthFX_Fog *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcCinematicDepthFX_Fog::HgcCinematicDepthFX_Fog(HgcCinematicDepthFX_Fog *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EF410;
  operator new();
}

void sub_1B7908464(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcCinematicDepthFX_Fog::~HgcCinematicDepthFX_Fog(HGNode *this)
{
  *(void *)this = &unk_1F10EF410;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B8406A4ELL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EF410;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B8406A4ELL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcCinematicDepthFX_Fog::SetParameter(HgcCinematicDepthFX_Fog *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  float v8 = -a3.n128_f32[0];
  uint64_t v9 = (__n128 *)*((void *)this + 51);
  if (v9->n128_f32[0] == (float)-a3.n128_f32[0]
    && v9->n128_f32[1] == v8
    && v9->n128_f32[2] == v8
    && v9->n128_f32[3] == 0.0)
  {
    return 0;
  }
  int32x4_t v10 = vzip1q_s32((int32x4_t)LODWORD(v8), (int32x4_t)LODWORD(v8));
  *(float *)&v10.i32[2] = -a3.n128_f32[0];
  a3.n128_f32[1] = a4;
  *uint64_t v9 = (__n128)v10;
  a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
  v9[9] = a3;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcCinematicDepthFX_Fog::GetParameter(HgcCinematicDepthFX_Fog *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = v3[36];
    a3[1] = v3[37];
    a3[2] = v3[38];
    float result = v3[39];
    a3[3] = result;
  }
  return result;
}

const char *HgcGammaNoPremult::GetProgram(HgcGammaNoPremult *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002b3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = abs(r0);\n"
             "    r2.xyz = pow(r1.xyz, half3(hg_Params[0].xyz));\n"
             "    r2.w = r1.w;\n"
             "    output.color0 = select(float4(r2), -float4(r2), float4(r0) < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=07195965:b14d782f:2455a915:5205ce07\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000028e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = abs(r0);\n"
             "    r2.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
             "    r2.w = r1.w;\n"
             "    output.color0 = select(r2, -r2, r0 < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=5bc0a167:957bca21:4fe89d3a:884daf25\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002b5\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = abs(r0);\n"
           "    r2.xyz = pow(r1.xyz, hg_ProgramLocal0.xyz);\n"
           "    r2.w = r1.w;\n"
           "    gl_FragColor = vec4(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z "
           ": r2.z, r0.w < 0.00000 ? -r2.w : r2.w);\n"
           "}\n"
           "//MD5=9548e277:2e546086:10e1df88:2981f6f1\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcGammaNoPremult::InitProgramDescriptor(HgcGammaNoPremult *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGammaNoPremult_hgc_visible", "//Metal1.0     \n//LEN=0000000169\n[[ visible ]] FragmentOut HgcGammaNoPremult_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = abs(r0);\n"
    "    r2.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
    "    r2.w = r1.w;\n"
    "    output.color0 = select(r2, -r2, r0 < 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcGammaNoPremult");
}

void sub_1B7908900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7908930(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7908928);
}

char *HgcGammaNoPremult::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  float result = (char *)operator new(0x20uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8349210;
  strcpy(result, "HgcGammaNoPremult [hgc1]");
  return result;
}

uint64_t HgcGammaNoPremult::BindTexture(HgcGammaNoPremult *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcGammaNoPremult::Bind(HgcGammaNoPremult *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcGammaNoPremult::RenderTile(HgcGammaNoPremult *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    int v3 = 0;
    uint64_t v4 = *((void *)a2 + 10);
    uint64_t v5 = 16 * *((int *)a2 + 22);
    uint64_t v6 = *((void *)a2 + 2);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    do
    {
      uint64_t v9 = 0;
      do
      {
        float32x4_t v10 = *(float32x4_t *)(v4 + v9);
        int8x16_t v11 = (int8x16_t)vabsq_f32(v10);
        uint64_t v12 = *((void *)this + 51);
        float32x4_t v13 = *(float32x4_t *)(v12 + 16);
        float32x4_t v14 = *(float32x4_t *)(v12 + 32);
        float32x4_t v15 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vceqq_f32(*(float32x4_t *)v12, v13)), v13), (int8x16_t)v14, v11);
        int8x16_t v16 = (int8x16_t)vcgtq_f32(*(float32x4_t *)(v12 + 48), v15);
        int8x16_t v17 = (int8x16_t)vmulq_f32(v15, vaddq_f32(v14, (float32x4_t)vandq_s8(*(int8x16_t *)(v12 + 64), v16)));
        float32x4_t v18 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v12 + 80), v17), (int8x16_t)v14);
        int8x16_t v19 = *(int8x16_t *)(v12 + 128);
        float32x4_t v20 = vaddq_f32(vsubq_f32(vaddq_f32((float32x4_t)vandq_s8(*(int8x16_t *)(v12 + 96), (int8x16_t)vceqq_f32(v15, *(float32x4_t *)(v12 + 96))), vsubq_f32(vsubq_f32((float32x4_t)vbicq_s8((int8x16_t)vcgeq_f32(v15, v13), *(int8x16_t *)(v12 + 112)), (float32x4_t)vandq_s8(*(int8x16_t *)(v12 + 96), (int8x16_t)vceqq_f32(v15, v13))), (float32x4_t)vandq_s8(v19, v16))), *(float32x4_t *)(v12 + 144)), vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)));
        float32x4_t v21 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v18, *(float32x4_t *)(v12 + 160)));
        float32x4_t v22 = vaddq_f32(v20, v21);
        float32x4_t v23 = vsubq_f32(vsubq_f32(v18, v14), vmulq_f32(vmulq_f32(*(float32x4_t *)(v12 + 176), v21), v18));
        float32x4_t v24 = vmulq_f32(v23, v23);
        float32x4_t v25 = vmulq_f32(*(float32x4_t *)v12, vaddq_f32(v22, vmulq_f32(v23, vaddq_f32(*(float32x4_t *)(v12 + 320), vmulq_f32(v23, vaddq_f32(vaddq_f32(vaddq_f32(*(float32x4_t *)(v12 + 288), vmulq_f32(*(float32x4_t *)(v12 + 304), v23)), vmulq_f32(v24, vaddq_f32(*(float32x4_t *)(v12 + 256), vmulq_f32(*(float32x4_t *)(v12 + 272), v23)))), vmulq_f32(vmulq_f32(v24, v24), vaddq_f32(vaddq_f32(*(float32x4_t *)(v12 + 224), vmulq_f32(*(float32x4_t *)(v12 + 240), v23)),
                              vmulq_f32(v24, vaddq_f32(*(float32x4_t *)(v12 + 192), vmulq_f32(*(float32x4_t *)(v12 + 208), v23)))))))))));
        float32x4_t v26 = vminq_f32(vmaxq_f32(v25, *(float32x4_t *)(v12 + 336)), *(float32x4_t *)(v12 + 352));
        float32x4_t v27 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
        float32x4_t v28 = vsubq_f32(v27, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v27, v26)));
        float32x4_t v29 = vsubq_f32(v26, v28);
        float32x4_t v30 = vmulq_f32(v29, v29);
        int8x16_t v31 = (int8x16_t)vcgtq_f32(*(float32x4_t *)(v12 + 464), v28);
        *(int8x16_t *)(v6 + v9) = veorq_s8(vbslq_s8(*(int8x16_t *)(v12 + 512), v11, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, vorrq_s8((int8x16_t)vcltzq_f32(v25), (int8x16_t)vcgezq_f32(v25))), v13), (int8x16_t)vmulq_f32(vaddq_f32(v14, (float32x4_t)vandq_s8(*(int8x16_t *)(v12 + 480), v31)), vmulq_f32(vaddq_f32(v14, vmulq_f32(
                                                           v29,
                                                           vaddq_f32(vaddq_f32(*(float32x4_t *)(v12 + 432), vmulq_f32(v29, *(float32x4_t *)(v12 + 448))), vmulq_f32(v30, vaddq_f32(vaddq_f32(*(float32x4_t *)(v12 + 400), vmulq_f32(*(float32x4_t *)(v12 + 416), v29)), vmulq_f32(v30, vaddq_f32(*(float32x4_t *)(v12 + 368), vmulq_f32(*(float32x4_t *)(v12 + 384), v29)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v12 + 496), vcvtq_s32_f32(vaddq_f32(
                                                                            v28,
                                                                            (float32x4_t)vandq_s8(v19, v31)))),
                                                                      0x17uLL))),
                                        (int8x16_t)v25)),
                                    vandq_s8(*(int8x16_t *)(v12 + 528), (int8x16_t)v10));
        v9 += 16;
      }
      while (v8 != v9);
      ++v3;
      v4 += v5;
      v6 += v7;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcGammaNoPremult::GetDOD(HgcGammaNoPremult *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcGammaNoPremult::GetROI(HgcGammaNoPremult *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcGammaNoPremult::HgcGammaNoPremult(HgcGammaNoPremult *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EF678;
  operator new();
}

void sub_1B7908F60(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGammaNoPremult::~HgcGammaNoPremult(HGNode *this)
{
  *(void *)this = &unk_1F10EF678;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4027AB4E27);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10EF678;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4027AB4E27);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EF678;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4027AB4E27);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcGammaNoPremult::SetParameter(HgcGammaNoPremult *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcGammaNoPremult::GetParameter(HgcGammaNoPremult *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcToneParamCurve1AntiSymmetric::GetProgram(HgcToneParamCurve1AntiSymmetric *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000051c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[1].xyz) + half3(hg_Params[2].xyz);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[3].xyz);\n"
             "    r1.w = pow(r2.z, half(hg_Params[0].z));\n"
             "    r1.z = select(r1.w, c0.z, r1.z < 0.00000h);\n"
             "    output.color0.z = select(float(r1.z), -float(r1.z), float(r0.z) < 0.00000h);\n"
             "    r0.z = pow(r2.y, half(hg_Params[0].y));\n"
             "    r1.z = pow(r2.x, half(hg_Params[0].x));\n"
             "    r0.z = select(r0.z, c0.z, r1.y < 0.00000h);\n"
             "    r1.x = select(r1.z, c0.z, r1.x < 0.00000h);\n"
             "    output.color0.y = select(float(r0.z), -float(r0.z), float(r0.y) < 0.00000h);\n"
             "    output.color0.x = select(float(r1.x), -float(r1.x), float(r0.x) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d718f972:caaf58f4:2a79117f:c79f3bd7\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004ab\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
             "    r1.xyz = r1.xyz - hg_Params[3].xyz;\n"
             "    r1.w = pow(r2.z, hg_Params[0].z);\n"
             "    r1.z = select(r1.w, c0.z, r1.z < 0.00000f);\n"
             "    output.color0.z = select(r1.z, -r1.z, r0.z < 0.00000f);\n"
             "    r0.z = pow(r2.y, hg_Params[0].y);\n"
             "    r1.z = pow(r2.x, hg_Params[0].x);\n"
             "    r0.z = select(r0.z, c0.z, r1.y < 0.00000f);\n"
             "    r1.x = select(r1.z, c0.z, r1.x < 0.00000f);\n"
             "    output.color0.y = select(r0.z, -r0.z, r0.y < 0.00000f);\n"
             "    output.color0.x = select(r1.x, -r1.x, r0.x < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=8bd267df:aff60290:d6b8443b:3a9c691b\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004c7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = abs(r0.xyz);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal1.xyz + hg_ProgramLocal2.xyz;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal3.xyz;\n"
           "    r1.w = pow(r2.z, hg_ProgramLocal0.z);\n"
           "    r1.z = r1.z < 0.00000 ? c0.z : r1.w;\n"
           "    gl_FragColor.z = r0.z < 0.00000 ? -r1.z : r1.z;\n"
           "    r0.z = pow(r2.y, hg_ProgramLocal0.y);\n"
           "    r1.z = pow(r2.x, hg_ProgramLocal0.x);\n"
           "    r0.z = r1.y < 0.00000 ? c0.z : r0.z;\n"
           "    r1.x = r1.x < 0.00000 ? c0.z : r1.z;\n"
           "    gl_FragColor.y = r0.y < 0.00000 ? -r0.z : r0.z;\n"
           "    gl_FragColor.x = r0.x < 0.00000 ? -r1.x : r1.x;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=0e82e012:3c12addf:abe4b0a7:1bdc9d8c\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0004:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve1AntiSymmetric::InitProgramDescriptor(HgcToneParamCurve1AntiSymmetric *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve1AntiSymmetric_hgc_visible", "//Metal1.0     \n//LEN=0000000394\n[[ visible ]] FragmentOut HgcToneParamCurve1AntiSymmetric_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fabs(r0.xyz);\n"
    "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
    "    r1.xyz = r1.xyz - hg_Params[3].xyz;\n"
    "    r1.w = pow(r2.z, hg_Params[0].z);\n"
    "    r1.z = select(r1.w, c0.z, r1.z < 0.00000f);\n"
    "    output.color0.z = select(r1.z, -r1.z, r0.z < 0.00000f);\n"
    "    r0.z = pow(r2.y, hg_Params[0].y);\n"
    "    r1.z = pow(r2.x, hg_Params[0].x);\n"
    "    r0.z = select(r0.z, c0.z, r1.y < 0.00000f);\n"
    "    r1.x = select(r1.z, c0.z, r1.x < 0.00000f);\n"
    "    output.color0.y = select(r0.z, -r0.z, r0.y < 0.00000f);\n"
    "    output.color0.x = select(r1.x, -r1.x, r0.x < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcToneParamCurve1AntiSymmetric");
}

void sub_1B7909448(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7909478(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7909470);
}

char *HgcToneParamCurve1AntiSymmetric::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  float result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376490;
  strcpy(result, "HgcToneParamCurve1AntiSymmetric [hgc1]");
  return result;
}

uint64_t HgcToneParamCurve1AntiSymmetric::BindTexture(HgcToneParamCurve1AntiSymmetric *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve1AntiSymmetric::Bind(HgcToneParamCurve1AntiSymmetric *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcToneParamCurve1AntiSymmetric::RenderTile(HgcToneParamCurve1AntiSymmetric *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    int v3 = 0;
    uint64_t v4 = *((void *)a2 + 10);
    uint64_t v5 = 16 * *((int *)a2 + 22);
    uint64_t v6 = *((void *)a2 + 2);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    do
    {
      uint64_t v9 = 0;
      do
      {
        float32x4_t v79 = *(float32x4_t *)(v4 + v9);
        float32x4_t v10 = vabsq_f32(v79);
        int8x16_t v11 = (_OWORD *)*((void *)this + 51);
        int8x16_t v12 = *(int8x16_t *)v11;
        int32x4_t v13 = (int32x4_t)vaddq_f32(*((float32x4_t *)v11 + 2), vmulq_f32(v10, *((float32x4_t *)v11 + 1)));
        float32x4_t v14 = *((float32x4_t *)v11 + 4);
        float32x4_t v15 = *((float32x4_t *)v11 + 5);
        float32x4_t v16 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vrev64q_s32(*(int32x4_t *)v11), v14)), v14), (int8x16_t)v15, (int8x16_t)vrev64q_s32(v13));
        int8x16_t v18 = *((int8x16_t *)v11 + 6);
        float32x4_t v17 = *((float32x4_t *)v11 + 7);
        float32x4_t v19 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v16, v18), (int8x16_t)v15);
        float32x4_t v20 = *((float32x4_t *)v11 + 8);
        float32x4_t v21 = *((float32x4_t *)v11 + 9);
        float32x4_t v22 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v17, v16))), v21);
        float32x4_t v23 = *((float32x4_t *)v11 + 10);
        float32x4_t v24 = *((float32x4_t *)v11 + 11);
        float32x4_t v25 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v19, v23));
        float32x4_t v26 = vaddq_f32(v22, v25);
        float32x4_t v27 = vsubq_f32(vsubq_f32(v19, v15), vmulq_f32(vmulq_f32(v24, v25), v19));
        float32x4_t v28 = *((float32x4_t *)v11 + 12);
        float32x4_t v29 = *((float32x4_t *)v11 + 13);
        float32x4_t v30 = vmulq_f32(v27, v27);
        float32x4_t v31 = *((float32x4_t *)v11 + 14);
        float32x4_t v32 = *((float32x4_t *)v11 + 15);
        float32x4_t v33 = *((float32x4_t *)v11 + 16);
        float32x4_t v34 = *((float32x4_t *)v11 + 17);
        float32x4_t v35 = *((float32x4_t *)v11 + 18);
        float32x4_t v36 = *((float32x4_t *)v11 + 19);
        float32x4_t v38 = *((float32x4_t *)v11 + 20);
        float32x4_t v37 = *((float32x4_t *)v11 + 21);
        float32x4_t v39 = vmaxq_f32(vmulq_laneq_f32(vaddq_f32(v26, vmulq_f32(v27, vaddq_f32(v35, vmulq_f32(v27, vaddq_f32(vaddq_f32(v33, vmulq_f32(v27, v34)), vmulq_f32(v30, vaddq_f32(vaddq_f32(v28, vmulq_f32(v29, v27)), vmulq_f32(v30, vaddq_f32(v31, vmulq_f32(v32, v27)))))))))), *(float32x4_t *)v11, 2), v36);
        float32x4_t v40 = *((float32x4_t *)v11 + 22);
        float32x4_t v41 = *((float32x4_t *)v11 + 23);
        float32x4_t v42 = *((float32x4_t *)v11 + 24);
        int32x4_t v43 = *((int32x4_t *)v11 + 25);
        float32x4_t v44 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v41, (int8x16_t)vceqq_f32((float32x4_t)vextq_s8(v12, v12, 0xCuLL), v42)), v42), (int8x16_t)v41, vextq_s8((int8x16_t)v13, (int8x16_t)v13, 0xCuLL));
        float32x4_t v45 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
        float32x4_t v46 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v44, v18), (int8x16_t)v41);
        float32x4_t v47 = (float32x4_t)vandq_s8((int8x16_t)v41, (int8x16_t)vcgtq_f32(v46, v36));
        float32x4_t v48 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v44, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v37, (int8x16_t)vcgtq_f32(v40, v44))), v38), v47);
        float32x4_t v49 = vsubq_f32(vsubq_f32(v46, v41), vmulq_f32(vmulq_f32(v35, v47), v46));
        float32x4_t v50 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v45, v39)));
        float32x4_t v51 = vmulq_f32(v49, v49);
        float32x4_t v52 = vsubq_f32(v39, v50);
        float32x4_t v53 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v48, vmulq_f32(v49, vaddq_f32(v24, vmulq_f32(v49, vaddq_f32(vaddq_f32(v29, vmulq_f32(v28, v49)), vmulq_f32(v51, vaddq_f32(vaddq_f32(v34, vmulq_f32(v33, v49)), vmulq_f32(v51, vaddq_f32(v32, vmulq_f32(v31, v49)))))))))), *(float32x2_t *)v11, 1), v23);
        float32x4_t v54 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
        float32x4_t v55 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v41, (int8x16_t)vcgtq_f32(v54, v53)));
        float32x4_t v56 = vsubq_f32(v53, v55);
        float32x4_t v57 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v41, (int8x16_t)vceqq_f32((float32x4_t)vextq_s8(v12, v12, 8uLL), v42)), v42), (int8x16_t)v41, vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL));
        float32x4_t v58 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v57, v18), (int8x16_t)v41);
        float32x4_t v59 = (float32x4_t)vandq_s8((int8x16_t)v41, (int8x16_t)vcgtq_f32(v58, v36));
        float32x4_t v60 = vsubq_f32(vsubq_f32(v58, v41), vmulq_f32(vmulq_f32(v35, v59), v58));
        float32x4_t v61 = vaddq_f32(v29, vmulq_f32(v28, v60));
        float32x4_t v62 = vmulq_f32(v60, v60);
        float32x4_t v63 = vmulq_f32(v60, vaddq_f32(v24, vmulq_f32(v60, vaddq_f32(v61, vmulq_f32(v62, vaddq_f32(vaddq_f32(v34, vmulq_f32(v33, v60)), vmulq_f32(v62, vaddq_f32(v32, vmulq_f32(v31, v60)))))))));
        int8x16_t v64 = (int8x16_t)vmulq_f32(vaddq_f32(v15, vmulq_f32(v52, vaddq_f32(v42, vmulq_f32(v52, vaddq_f32(vaddq_f32(v40, vmulq_f32(v41, v52)), vmulq_f32(vmulq_f32(v52, v52), vaddq_f32(v38, vmulq_f32(v37, v52)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v43, vcvtq_s32_f32(v50)), 0x17uLL));
        float32x4_t v65 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v57, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v37, (int8x16_t)vcgtq_f32(v40, v57))), v38), v59), v63), COERCE_FLOAT(*v11)), v23);
        float32x4_t v66 = vcvtq_f32_s32(vcvtq_s32_f32(v65));
        float32x4_t v67 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v41, (int8x16_t)vcgtq_f32(v66, v65)));
        float32x4_t v68 = vsubq_f32(v65, v67);
        float32x4_t v69 = vaddq_f32(v41, vmulq_f32(v56, vaddq_f32(v14, vmulq_f32(v56, vaddq_f32(vaddq_f32(v17, vmulq_f32(v15, v56)), vmulq_f32(vmulq_f32(v56, v56), vaddq_f32(v21, vmulq_f32(v20, v56))))))));
        float32x4_t v70 = vaddq_f32(v14, vmulq_f32(v68, vaddq_f32(vaddq_f32(v17, vmulq_f32(v15, v68)), vmulq_f32(vmulq_f32(v68, v68), vaddq_f32(v21, vmulq_f32(v20, v68))))));
        int32x4_t v71 = *((int32x4_t *)v11 + 27);
        float32x4_t v72 = vmulq_f32(v68, v70);
        int8x16_t v73 = *((int8x16_t *)v11 + 26);
        float32x4_t v74 = (float32x4_t)vbslq_s8(v73, v64, (int8x16_t)vsubq_f32(v10, *((float32x4_t *)v11 + 3)));
        int8x16_t v75 = (int8x16_t)vmulq_f32(vaddq_f32(v41, v72), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v67), v71), 0x17uLL));
        v20.i64[0] = vextq_s8(v75, (int8x16_t)v74, 0xCuLL).u64[0];
        v21.i64[0] = v74.i64[0];
        v21.i64[1] = v75.i64[1];
        *(int8x8_t *)&v20.u32[2] = vext_s8(*(int8x8_t *)v74.f32, (int8x8_t)*(_OWORD *)&vextq_s8(v75, v75, 8uLL), 4uLL);
        int8x16_t v76 = vbslq_s8(*((int8x16_t *)v11 + 28), vbslq_s8((int8x16_t)vcgtq_f32(v42, v20), (int8x16_t)v42, vbslq_s8(*((int8x16_t *)v11 + 28), (int8x16_t)vmulq_f32(v69, (float32x4_t)vshlq_n_s32(vaddq_s32(v71, vcvtq_s32_f32(v55)), 0x17uLL)), (int8x16_t)v79)), (int8x16_t)v79);
        int8x16_t v77 = vandq_s8(v76, (int8x16_t)v71);
        v75.i64[0] = veorq_s8(v77, vextq_s8(v76, v76, 4uLL)).u64[0];
        v75.i64[1] = veorq_s8(vandq_s8(*(int8x16_t *)&v43, *(int8x16_t *)&v79), vbslq_s8((int8x16_t)vcgtq_f32(v42, v74), *(int8x16_t *)&v42, (int8x16_t)vrev64q_s32(*(int32x4_t *)&v74))).i64[1];
        *(int8x16_t *)(v6 + v9) = vbslq_s8(v73, v76, vbslq_s8(*((int8x16_t *)v11 + 29), veorq_s8(v77, vbslq_s8((int8x16_t)vcgtq_f32(v42, v21), (int8x16_t)v42, vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL))), v75));
        v9 += 16;
      }
      while (v8 != v9);
      ++v3;
      v4 += v5;
      v6 += v7;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcToneParamCurve1AntiSymmetric::GetDOD(HgcToneParamCurve1AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcToneParamCurve1AntiSymmetric::GetROI(HgcToneParamCurve1AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcToneParamCurve1AntiSymmetric::HgcToneParamCurve1AntiSymmetric(HgcToneParamCurve1AntiSymmetric *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EF8E0;
  operator new();
}

void sub_1B7909D14(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve1AntiSymmetric::~HgcToneParamCurve1AntiSymmetric(HGNode *this)
{
  *(void *)this = &unk_1F10EF8E0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40048C4DA3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EF8E0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40048C4DA3);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve1AntiSymmetric::SetParameter(HgcToneParamCurve1AntiSymmetric *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  float32x4_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve1AntiSymmetric::GetParameter(HgcToneParamCurve1AntiSymmetric *this, unsigned int a2, float *a3)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcToneParamCurve2AntiSymmetric::GetProgram(HgcToneParamCurve2AntiSymmetric *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000455\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[1].xyz) + half3(hg_Params[2].xyz);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[4].xyz);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xyz));\n"
             "    r2.xyz = r2.xyz + half3(hg_Params[3].xyz);\n"
             "    r2.xz = select(r2.xz, half2(hg_Params[3].xz), r1.xz < 0.00000h);\n"
             "    output.color0.xz = select(float2(r2.xz), -float2(r2.xz), float2(r0.xz) < 0.00000h);\n"
             "    r0.z = select(r2.y, half(hg_Params[3].y), r1.y < 0.00000h);\n"
             "    output.color0.y = select(float(r0.z), -float(r0.z), float(r0.y) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=058b8728:b732aed8:ceabb34a:625557cb\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003eb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
             "    r1.xyz = r1.xyz - hg_Params[4].xyz;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xyz);\n"
             "    r2.xyz = r2.xyz + hg_Params[3].xyz;\n"
             "    r2.xz = select(r2.xz, hg_Params[3].xz, r1.xz < 0.00000f);\n"
             "    output.color0.xz = select(r2.xz, -r2.xz, r0.xz < 0.00000f);\n"
             "    r0.z = select(r2.y, hg_Params[3].y, r1.y < 0.00000f);\n"
             "    output.color0.y = select(r0.z, -r0.z, r0.y < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ce2eeb4b:e2a50521:c7bd3e50:b5953cf0\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000048e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = abs(r0.xyz);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal1.xyz + hg_ProgramLocal2.xyz;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal4.xyz;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xyz);\n"
           "    r2.xyz = r2.xyz + hg_ProgramLocal3.xyz;\n"
           "    r2.xz = vec2(r1.x < 0.00000 ? hg_ProgramLocal3.x : r2.x, r1.z < 0.00000 ? hg_ProgramLocal3.z : r2.z);\n"
           "    gl_FragColor.xz = vec2(r0.x < 0.00000 ? -r2.x : r2.x, r0.z < 0.00000 ? -r2.z : r2.z);\n"
           "    r0.z = r1.y < 0.00000 ? hg_ProgramLocal3.y : r2.y;\n"
           "    gl_FragColor.y = r0.y < 0.00000 ? -r0.z : r0.z;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=56d606f4:e7adcee5:7dc2a713:12142499\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0005:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve2AntiSymmetric::InitProgramDescriptor(HgcToneParamCurve2AntiSymmetric *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve2AntiSymmetric_hgc_visible", "//Metal1.0     \n//LEN=00000002d4\n[[ visible ]] FragmentOut HgcToneParamCurve2AntiSymmetric_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fabs(r0.xyz);\n"
    "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
    "    r1.xyz = r1.xyz - hg_Params[4].xyz;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xyz);\n"
    "    r2.xyz = r2.xyz + hg_Params[3].xyz;\n"
    "    r2.xz = select(r2.xz, hg_Params[3].xz, r1.xz < 0.00000f);\n"
    "    output.color0.xz = select(r2.xz, -r2.xz, r0.xz < 0.00000f);\n"
    "    r0.z = select(r2.y, hg_Params[3].y, r1.y < 0.00000f);\n"
    "    output.color0.y = select(r0.z, -r0.z, r0.y < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcToneParamCurve2AntiSymmetric");
}

void sub_1B790A1B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B790A1E8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B790A1E0);
}

char *HgcToneParamCurve2AntiSymmetric::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376490;
  strcpy(result, "HgcToneParamCurve2AntiSymmetric [hgc1]");
  return result;
}

uint64_t HgcToneParamCurve2AntiSymmetric::BindTexture(HgcToneParamCurve2AntiSymmetric *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve2AntiSymmetric::Bind(HgcToneParamCurve2AntiSymmetric *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcToneParamCurve2AntiSymmetric::RenderTile(HgcToneParamCurve2AntiSymmetric *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v99 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v11 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v12 = *(float32x4_t *)(v6 + v10);
      float32x4_t v13 = vabsq_f32(v11);
      float32x4_t v14 = vabsq_f32(v12);
      uint64_t v15 = *((void *)this + 51);
      float32x4_t v16 = *(float32x4_t *)(v15 + 16);
      float32x4_t v17 = *(float32x4_t *)(v15 + 32);
      float32x4_t v18 = *(float32x4_t *)(v15 + 48);
      int8x16_t v19 = (int8x16_t)vaddq_f32(v17, vmulq_f32(v13, v16));
      int8x16_t v20 = (int8x16_t)vaddq_f32(v17, vmulq_f32(v14, v16));
      float32x4_t v22 = *(float32x4_t *)(v15 + 64);
      float32x4_t v21 = *(float32x4_t *)(v15 + 80);
      float32x4_t v23 = *(float32x4_t *)(v15 + 96);
      int8x16_t v24 = *(int8x16_t *)(v15 + 112);
      int8x16_t v25 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vceqq_f32(*(float32x4_t *)v15, v21)), v21);
      float32x4_t v26 = (float32x4_t)vbslq_s8(v25, (int8x16_t)v23, v19);
      float32x4_t v27 = (float32x4_t)vbslq_s8(v25, (int8x16_t)v23, v20);
      float32x4_t v28 = (float32x4_t)vorrq_s8(vandq_s8(v24, (int8x16_t)v26), (int8x16_t)v23);
      float32x4_t v29 = (float32x4_t)vorrq_s8(vandq_s8(v24, (int8x16_t)v27), (int8x16_t)v23);
      float32x4_t v30 = *(float32x4_t *)(v15 + 128);
      int8x16_t v31 = *(int8x16_t *)(v15 + 144);
      float32x4_t v32 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v30, v26)));
      float32x4_t v33 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v30, v27)));
      float32x4_t v34 = *(float32x4_t *)(v15 + 160);
      float32x4_t v35 = *(float32x4_t *)(v15 + 176);
      float32x4_t v36 = vsubq_f32(v32, v34);
      float32x4_t v37 = vsubq_f32(v33, v34);
      float32x4_t v38 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v28, v35));
      float32x4_t v39 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v29, v35));
      float32x4_t v40 = *(float32x4_t *)(v15 + 192);
      float32x4_t v41 = *(float32x4_t *)(v15 + 208);
      float32x4_t v42 = vaddq_f32(v36, v38);
      float32x4_t v43 = vsubq_f32(vsubq_f32(v28, v23), vmulq_f32(vmulq_f32(v40, v38), v28));
      float32x4_t v44 = vsubq_f32(vsubq_f32(v29, v23), vmulq_f32(vmulq_f32(v40, v39), v29));
      float32x4_t v45 = vmulq_f32(v43, v43);
      float32x4_t v46 = *(float32x4_t *)(v15 + 224);
      float32x4_t v47 = *(float32x4_t *)(v15 + 240);
      float32x4_t v48 = vaddq_f32(v41, vmulq_f32(v46, v43));
      float32x4_t v49 = vaddq_f32(v41, vmulq_f32(v46, v44));
      float32x4_t v50 = *(float32x4_t *)(v15 + 256);
      float32x4_t v51 = *(float32x4_t *)(v15 + 272);
      float32x4_t v52 = vaddq_f32(v47, vmulq_f32(v50, v43));
      float32x4_t v53 = vaddq_f32(v47, vmulq_f32(v50, v44));
      float32x4_t v54 = *(float32x4_t *)(v15 + 288);
      float32x4_t v55 = *(float32x4_t *)(v15 + 304);
      float32x4_t v56 = vaddq_f32(v51, vmulq_f32(v43, v54));
      float32x4_t v57 = vaddq_f32(v51, vmulq_f32(v44, v54));
      float32x4_t v58 = vmulq_f32(v44, v44);
      float32x4_t v59 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(v42, vmulq_f32(v43, vaddq_f32(v55, vmulq_f32(v43, vaddq_f32(v56, vmulq_f32(v45, vaddq_f32(v48, vmulq_f32(v45, v52)))))))));
      float32x4_t v60 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(vaddq_f32(v37, v39), vmulq_f32(v44, vaddq_f32(v55, vmulq_f32(v44, vaddq_f32(v57, vmulq_f32(v58, vaddq_f32(v49, vmulq_f32(v58, v53)))))))));
      float32x4_t v61 = *(float32x4_t *)(v15 + 320);
      float32x4_t v62 = *(float32x4_t *)(v15 + 336);
      float32x4_t v63 = vmaxq_f32(v59, v61);
      float32x4_t v64 = vmaxq_f32(v60, v61);
      float32x4_t v65 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
      float32x4_t v66 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
      float32x4_t v67 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v65, v63)));
      float32x4_t v68 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v66, v64)));
      float32x4_t v69 = vsubq_f32(v63, v67);
      float32x4_t v70 = vsubq_f32(v64, v68);
      float32x4_t v71 = *(float32x4_t *)(v15 + 352);
      float32x4_t v72 = *(float32x4_t *)(v15 + 368);
      float32x4_t v73 = vaddq_f32(v62, vmulq_f32(v71, v69));
      float32x4_t v74 = vaddq_f32(v62, vmulq_f32(v71, v70));
      float32x4_t v76 = *(float32x4_t *)(v15 + 384);
      float32x4_t v75 = *(float32x4_t *)(v15 + 400);
      float32x4_t v77 = vaddq_f32(v23, vmulq_f32(v69, vaddq_f32(v75, vmulq_f32(v69, vaddq_f32(vaddq_f32(v72, vmulq_f32(v69, v76)), vmulq_f32(vmulq_f32(v69, v69), v73))))));
      float32x4_t v78 = vaddq_f32(v23, vmulq_f32(v70, vaddq_f32(v75, vmulq_f32(v70, vaddq_f32(vaddq_f32(v72, vmulq_f32(v76, v70)), vmulq_f32(vmulq_f32(v70, v70), v74))))));
      int32x4_t v79 = vcvtq_s32_f32(v68);
      int32x4_t v80 = *(int32x4_t *)(v15 + 416);
      int8x16_t v81 = *(int8x16_t *)(v15 + 432);
      int8x16_t v82 = (int8x16_t)vaddq_f32(v18, vmulq_f32(v77, (float32x4_t)vshlq_n_s32(vaddq_s32(v80, vcvtq_s32_f32(v67)), 0x17uLL)));
      int8x16_t v83 = (int8x16_t)vaddq_f32(v18, vmulq_f32(v78, (float32x4_t)vshlq_n_s32(vaddq_s32(v80, v79), 0x17uLL)));
      int8x16_t v84 = (int8x16_t)vcgtq_f32(v21, vsubq_f32(v13, v22));
      int8x16_t v85 = (int8x16_t)vcgtq_f32(v21, vsubq_f32(v14, v22));
      int8x16_t v86 = vbslq_s8(v81, v82, vbslq_s8(v84, (int8x16_t)v18, v82));
      int8x16_t v87 = vbslq_s8(v81, v83, vbslq_s8(v85, (int8x16_t)v18, v83));
      int8x16_t v88 = *(int8x16_t *)(v15 + 448);
      int8x16_t v89 = *(int8x16_t *)(v15 + 464);
      int8x16_t v90 = vandq_s8(v88, (int8x16_t)v12);
      int8x16_t v91 = veorq_s8(v86, vandq_s8(v88, (int8x16_t)v11));
      int8x16_t v92 = vbslq_s8(v84, (int8x16_t)v18, v86);
      int8x16_t v93 = vbslq_s8(v85, (int8x16_t)v18, v87);
      int8x16_t v94 = vbslq_s8(v89, vextq_s8(v92, v92, 0xCuLL), (int8x16_t)v11);
      int8x16_t v95 = vbslq_s8(v89, vextq_s8(v93, v93, 0xCuLL), (int8x16_t)v12);
      int8x16_t v96 = vbslq_s8(v81, veorq_s8(vandq_s8(v95, v88), vextq_s8(v95, v95, 4uLL)), veorq_s8(v87, v90));
      int8x16_t v97 = *(int8x16_t *)(v15 + 480);
      float32x4_t v98 = (int8x16_t *)(v5 + v10);
      v98[-1] = vbslq_s8(v97, v94, vbslq_s8(v81, veorq_s8(vandq_s8(v94, v88), vextq_s8(v94, v94, 4uLL)), v91));
      *float32x4_t v98 = vbslq_s8(v97, v95, v96);
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v99 = -v9;
    if (v99 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v100 = 16 * v99;
    float32x4_t v101 = *(float32x4_t *)(v6 + v100);
    float32x4_t v102 = vabsq_f32(v101);
    uint64_t v103 = *((void *)this + 51);
    float32x4_t v104 = *(float32x4_t *)(v103 + 48);
    float32x4_t v105 = *(float32x4_t *)(v103 + 80);
    float32x4_t v106 = *(float32x4_t *)(v103 + 96);
    float32x4_t v107 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v106, (int8x16_t)vceqq_f32(*(float32x4_t *)v103, v105)), v105), (int8x16_t)v106, (int8x16_t)vaddq_f32(*(float32x4_t *)(v103 + 32), vmulq_f32(v102, *(float32x4_t *)(v103 + 16))));
    float32x4_t v108 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v103 + 112), (int8x16_t)v107), (int8x16_t)v106);
    float32x4_t v109 = (float32x4_t)vandq_s8((int8x16_t)v106, (int8x16_t)vcgtq_f32(v108, *(float32x4_t *)(v103 + 176)));
    float32x4_t v110 = vsubq_f32(vsubq_f32(v108, v106), vmulq_f32(vmulq_f32(*(float32x4_t *)(v103 + 192), v109), v108));
    float32x4_t v111 = vmulq_f32(v110, v110);
    float32x4_t v112 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v103, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v107, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v103 + 144), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v103 + 128), v107))), *(float32x4_t *)(v103 + 160)), v109), vmulq_f32(v110, vaddq_f32(*(float32x4_t *)(v103 + 304), vmulq_f32(v110, vaddq_f32(
                         vaddq_f32(*(float32x4_t *)(v103 + 272), vmulq_f32(v110, *(float32x4_t *)(v103 + 288))),
                         vmulq_f32(v111, vaddq_f32(vaddq_f32(*(float32x4_t *)(v103 + 208), vmulq_f32(*(float32x4_t *)(v103 + 224), v110)), vmulq_f32(v111, vaddq_f32(*(float32x4_t *)(v103 + 240), vmulq_f32(*(float32x4_t *)(v103 + 256), v110))))))))))), *(float32x4_t *)(v103 + 320));
    float32x4_t v113 = vcvtq_f32_s32(vcvtq_s32_f32(v112));
    float32x4_t v114 = vsubq_f32(v113, (float32x4_t)vandq_s8((int8x16_t)v106, (int8x16_t)vcgtq_f32(v113, v112)));
    float32x4_t v115 = vsubq_f32(v112, v114);
    float32x4_t v116 = vaddq_f32(v106, vmulq_f32(v115, vaddq_f32(*(float32x4_t *)(v103 + 400), vmulq_f32(v115, vaddq_f32(vaddq_f32(*(float32x4_t *)(v103 + 368), vmulq_f32(*(float32x4_t *)(v103 + 384), v115)), vmulq_f32(vmulq_f32(v115, v115), vaddq_f32(*(float32x4_t *)(v103 + 336), vmulq_f32(*(float32x4_t *)(v103 + 352), v115))))))));
    int8x16_t v117 = *(int8x16_t *)(v103 + 432);
    int8x16_t v118 = (int8x16_t)vaddq_f32(v104, vmulq_f32(v116, (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v103 + 416), vcvtq_s32_f32(v114)), 0x17uLL)));
    int8x16_t v119 = (int8x16_t)vcgtq_f32(v105, vsubq_f32(v102, *(float32x4_t *)(v103 + 64)));
    int8x16_t v120 = vbslq_s8(v117, v118, vbslq_s8(v119, (int8x16_t)v104, v118));
    int8x16_t v121 = *(int8x16_t *)(v103 + 448);
    int8x16_t v122 = veorq_s8(v120, vandq_s8(v121, (int8x16_t)v101));
    int8x16_t v123 = vbslq_s8(v119, (int8x16_t)v104, v120);
    int8x16_t v124 = vbslq_s8(*(int8x16_t *)(v103 + 464), vextq_s8(v123, v123, 0xCuLL), (int8x16_t)v101);
    *(int8x16_t *)(v5 + v100) = vbslq_s8(*(int8x16_t *)(v103 + 480), v124, vbslq_s8(v117, veorq_s8(vandq_s8(v124, v121), vextq_s8(v124, v124, 4uLL)), v122));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve2AntiSymmetric::GetDOD(HgcToneParamCurve2AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcToneParamCurve2AntiSymmetric::GetROI(HgcToneParamCurve2AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(HgcToneParamCurve2AntiSymmetric *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EFB48;
  operator new();
}

void sub_1B790AB50(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve2AntiSymmetric::~HgcToneParamCurve2AntiSymmetric(HGNode *this)
{
  *(void *)this = &unk_1F10EFB48;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4051E21E55);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EFB48;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4051E21E55);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve2AntiSymmetric::SetParameter(HgcToneParamCurve2AntiSymmetric *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve2AntiSymmetric::GetParameter(HgcToneParamCurve2AntiSymmetric *this, unsigned int a2, float *a3)
{
  if (a2 > 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcToneParamCurve3AntiSymmetric::GetProgram(HgcToneParamCurve3AntiSymmetric *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000438\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = abs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[1].xyz) + half3(hg_Params[2].xyz);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xyz));\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[3].xyz) + -r2.xyz;\n"
             "    r1.xyz = half3(r1.xyz < half3(hg_Params[4].xyz));\n"
             "    r2.xyz = r1.xyz*r3.xyz + r2.xyz;\n"
             "    r1.xyz = r2.xyz*c0.xxx;\n"
             "    r0.xyz = half3(r0.xyz < c0.yyy);\n"
             "    output.color0.xyz = float3(r0.xyz)*float3(r1.xyz) + float3(r2.xyz);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c5899dcc:9555caf0:c3bcf81f:37a2c769\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0005:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003f4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = abs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xyz);\n"
             "    r3.xyz = r1.xyz*hg_Params[3].xyz + -r2.xyz;\n"
             "    r1.xyz = float3(r1.xyz < hg_Params[4].xyz);\n"
             "    r2.xyz = r1.xyz*r3.xyz + r2.xyz;\n"
             "    r1.xyz = r2.xyz*c0.xxx;\n"
             "    r0.xyz = float3(r0.xyz < c0.yyy);\n"
             "    output.color0.xyz = r0.xyz*r1.xyz + r2.xyz;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=eef59206:cc43f70e:921111e4:957edf63\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0005:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000046c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = abs(r0.xyz);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal1.xyz + hg_ProgramLocal2.xyz;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xyz);\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal3.xyz + -r2.xyz;\n"
           "    r1.xyz = vec3(lessThan(r1.xyz, hg_ProgramLocal4.xyz));\n"
           "    r2.xyz = r1.xyz*r3.xyz + r2.xyz;\n"
           "    r1.xyz = r2.xyz*c0.xxx;\n"
           "    r0.xyz = vec3(lessThan(r0.xyz, c0.yyy));\n"
           "    gl_FragColor.xyz = r0.xyz*r1.xyz + r2.xyz;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=22cc40e9:55017b8d:7a25fcde:8c47c86f\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0005:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve3AntiSymmetric::InitProgramDescriptor(HgcToneParamCurve3AntiSymmetric *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve3AntiSymmetric_hgc_visible", "//Metal1.0     \n//LEN=00000002dd\n[[ visible ]] FragmentOut HgcToneParamCurve3AntiSymmetric_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = abs(r0.xyz);\n"
    "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xyz);\n"
    "    r3.xyz = r1.xyz*hg_Params[3].xyz + -r2.xyz;\n"
    "    r1.xyz = float3(r1.xyz < hg_Params[4].xyz);\n"
    "    r2.xyz = r1.xyz*r3.xyz + r2.xyz;\n"
    "    r1.xyz = r2.xyz*c0.xxx;\n"
    "    r0.xyz = float3(r0.xyz < c0.yyy);\n"
    "    output.color0.xyz = r0.xyz*r1.xyz + r2.xyz;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcToneParamCurve3AntiSymmetric");
}

void sub_1B790AFF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B790B024(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B790B01CLL);
}

char *HgcToneParamCurve3AntiSymmetric::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376490;
  strcpy(result, "HgcToneParamCurve3AntiSymmetric [hgc1]");
  return result;
}

uint64_t HgcToneParamCurve3AntiSymmetric::BindTexture(HgcToneParamCurve3AntiSymmetric *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve3AntiSymmetric::Bind(HgcToneParamCurve3AntiSymmetric *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcToneParamCurve3AntiSymmetric::RenderTile(HgcToneParamCurve3AntiSymmetric *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v88 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v11 = *(float32x4_t *)(v6 + v10);
      float32x4_t v13 = vabsq_f32(v12);
      float32x4_t v14 = vabsq_f32(v11);
      uint64_t v15 = *((void *)this + 51);
      float32x4_t v16 = *(float32x4_t *)(v15 + 16);
      float32x4_t v17 = *(float32x4_t *)(v15 + 32);
      float32x4_t v18 = *(float32x4_t *)(v15 + 48);
      int8x16_t v19 = (int8x16_t)vaddq_f32(v17, vmulq_f32(v13, v16));
      int8x16_t v20 = (int8x16_t)vaddq_f32(v17, vmulq_f32(v14, v16));
      float32x4_t v22 = *(float32x4_t *)(v15 + 64);
      float32x4_t v21 = *(float32x4_t *)(v15 + 80);
      float32x4_t v23 = *(float32x4_t *)(v15 + 96);
      int8x16_t v24 = *(int8x16_t *)(v15 + 112);
      int8x16_t v25 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vceqq_f32(*(float32x4_t *)v15, v21)), v21);
      float32x4_t v26 = (float32x4_t)vbslq_s8(v25, (int8x16_t)v23, v19);
      float32x4_t v27 = (float32x4_t)vbslq_s8(v25, (int8x16_t)v23, v20);
      float32x4_t v28 = (float32x4_t)vorrq_s8(vandq_s8(v24, (int8x16_t)v26), (int8x16_t)v23);
      float32x4_t v29 = (float32x4_t)vorrq_s8(vandq_s8(v24, (int8x16_t)v27), (int8x16_t)v23);
      float32x4_t v30 = *(float32x4_t *)(v15 + 128);
      int8x16_t v31 = *(int8x16_t *)(v15 + 144);
      float32x4_t v32 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v30, v26)));
      float32x4_t v33 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v30, v27)));
      float32x4_t v34 = *(float32x4_t *)(v15 + 160);
      float32x4_t v35 = *(float32x4_t *)(v15 + 176);
      float32x4_t v36 = vsubq_f32(v32, v34);
      float32x4_t v37 = vsubq_f32(v33, v34);
      float32x4_t v38 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v28, v35));
      float32x4_t v39 = (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v29, v35));
      float32x4_t v40 = *(float32x4_t *)(v15 + 192);
      float32x4_t v41 = *(float32x4_t *)(v15 + 208);
      float32x4_t v42 = vaddq_f32(v36, v38);
      float32x4_t v43 = vsubq_f32(vsubq_f32(v28, v23), vmulq_f32(vmulq_f32(v40, v38), v28));
      float32x4_t v44 = vsubq_f32(vsubq_f32(v29, v23), vmulq_f32(vmulq_f32(v40, v39), v29));
      float32x4_t v45 = vmulq_f32(v43, v43);
      float32x4_t v46 = *(float32x4_t *)(v15 + 224);
      float32x4_t v47 = *(float32x4_t *)(v15 + 240);
      float32x4_t v48 = vaddq_f32(v41, vmulq_f32(v46, v43));
      float32x4_t v49 = vaddq_f32(v41, vmulq_f32(v46, v44));
      float32x4_t v50 = *(float32x4_t *)(v15 + 256);
      float32x4_t v51 = *(float32x4_t *)(v15 + 272);
      float32x4_t v52 = vaddq_f32(v47, vmulq_f32(v50, v43));
      float32x4_t v53 = vaddq_f32(v47, vmulq_f32(v50, v44));
      float32x4_t v54 = *(float32x4_t *)(v15 + 288);
      float32x4_t v55 = *(float32x4_t *)(v15 + 304);
      float32x4_t v56 = vaddq_f32(v51, vmulq_f32(v43, v54));
      float32x4_t v57 = vaddq_f32(v51, vmulq_f32(v44, v54));
      float32x4_t v58 = vmulq_f32(v44, v44);
      float32x4_t v59 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(v42, vmulq_f32(v43, vaddq_f32(v55, vmulq_f32(v43, vaddq_f32(v56, vmulq_f32(v45, vaddq_f32(v48, vmulq_f32(v45, v52)))))))));
      float32x4_t v60 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(vaddq_f32(v37, v39), vmulq_f32(v44, vaddq_f32(v55, vmulq_f32(v44, vaddq_f32(v57, vmulq_f32(v58, vaddq_f32(v49, vmulq_f32(v58, v53)))))))));
      float32x4_t v61 = *(float32x4_t *)(v15 + 320);
      float32x4_t v62 = *(float32x4_t *)(v15 + 336);
      float32x4_t v63 = vmaxq_f32(v59, v61);
      float32x4_t v64 = vmaxq_f32(v60, v61);
      float32x4_t v65 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
      float32x4_t v66 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
      float32x4_t v67 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v65, v63)));
      float32x4_t v68 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v66, v64)));
      float32x4_t v69 = vsubq_f32(v63, v67);
      float32x4_t v70 = vsubq_f32(v64, v68);
      float32x4_t v71 = *(float32x4_t *)(v15 + 352);
      float32x4_t v72 = *(float32x4_t *)(v15 + 368);
      float32x4_t v73 = *(float32x4_t *)(v15 + 384);
      float32x4_t v74 = *(float32x4_t *)(v15 + 400);
      float32x4_t v75 = vmulq_f32(v70, vaddq_f32(v74, vmulq_f32(v70, vaddq_f32(vaddq_f32(v72, vmulq_f32(v73, v70)), vmulq_f32(vmulq_f32(v70, v70), vaddq_f32(v62, vmulq_f32(v71, v70)))))));
      float32x4_t v76 = vaddq_f32(v23, vmulq_f32(v69, vaddq_f32(v74, vmulq_f32(v69, vaddq_f32(vaddq_f32(v72, vmulq_f32(v69, v73)), vmulq_f32(vmulq_f32(v69, v69), vaddq_f32(v62, vmulq_f32(v71, v69))))))));
      int32x4_t v77 = vcvtq_s32_f32(v68);
      int32x4_t v78 = *(int32x4_t *)(v15 + 416);
      float32x4_t v79 = *(float32x4_t *)(v15 + 432);
      float32x4_t v80 = vmulq_f32(v76, (float32x4_t)vshlq_n_s32(vaddq_s32(v78, vcvtq_s32_f32(v67)), 0x17uLL));
      float32x4_t v81 = vmulq_f32(vaddq_f32(v23, v75), (float32x4_t)vshlq_n_s32(vaddq_s32(v78, v77), 0x17uLL));
      float32x4_t v82 = vaddq_f32(v80, vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v22, v13)), vsubq_f32(vmulq_f32(v13, v18), v80)));
      float32x4_t v83 = vaddq_f32(v81, vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v22, v14)), vsubq_f32(vmulq_f32(v14, v18), v81)));
      int8x16_t v84 = vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v21, v12));
      int8x16_t v85 = vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v21, v11));
      int8x16_t v86 = *(int8x16_t *)(v15 + 448);
      int8x16_t v87 = (int8x16_t *)(v5 + v10);
      v87[-1] = vbslq_s8(v86, (int8x16_t)v12, (int8x16_t)vaddq_f32(v82, vmulq_f32(vmulq_f32(v79, v82), (float32x4_t)vbslq_s8(v86, (int8x16_t)v12, v84))));
      *int8x16_t v87 = vbslq_s8(v86, (int8x16_t)v11, (int8x16_t)vaddq_f32(v83, vmulq_f32(vmulq_f32(v79, v83), (float32x4_t)vbslq_s8(v86, (int8x16_t)v11, v85))));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v88 = -v9;
    if (v88 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v89 = 16 * v88;
    float32x4_t v90 = *(float32x4_t *)(v6 + v89);
    float32x4_t v91 = vabsq_f32(v90);
    uint64_t v92 = *((void *)this + 51);
    float32x4_t v93 = *(float32x4_t *)(v92 + 80);
    float32x4_t v94 = *(float32x4_t *)(v92 + 96);
    float32x4_t v95 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vceqq_f32(*(float32x4_t *)v92, v93)), v93), (int8x16_t)v94, (int8x16_t)vaddq_f32(*(float32x4_t *)(v92 + 32), vmulq_f32(v91, *(float32x4_t *)(v92 + 16))));
    float32x4_t v96 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v92 + 112), (int8x16_t)v95), (int8x16_t)v94);
    float32x4_t v97 = (float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(v96, *(float32x4_t *)(v92 + 176)));
    float32x4_t v98 = vsubq_f32(vsubq_f32(v96, v94), vmulq_f32(vmulq_f32(*(float32x4_t *)(v92 + 192), v97), v96));
    float32x4_t v99 = vmulq_f32(v98, v98);
    float32x4_t v100 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v92, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v95, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v92 + 144), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v92 + 128), v95))), *(float32x4_t *)(v92 + 160)), v97), vmulq_f32(v98, vaddq_f32(*(float32x4_t *)(v92 + 304), vmulq_f32(v98, vaddq_f32(
                         vaddq_f32(*(float32x4_t *)(v92 + 272), vmulq_f32(v98, *(float32x4_t *)(v92 + 288))),
                         vmulq_f32(v99, vaddq_f32(vaddq_f32(*(float32x4_t *)(v92 + 208), vmulq_f32(*(float32x4_t *)(v92 + 224), v98)), vmulq_f32(v99, vaddq_f32(*(float32x4_t *)(v92 + 240), vmulq_f32(*(float32x4_t *)(v92 + 256), v98))))))))))), *(float32x4_t *)(v92 + 320));
    float32x4_t v101 = vcvtq_f32_s32(vcvtq_s32_f32(v100));
    float32x4_t v102 = vsubq_f32(v101, (float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(v101, v100)));
    float32x4_t v103 = vsubq_f32(v100, v102);
    float32x4_t v104 = vmulq_f32(vaddq_f32(v94, vmulq_f32(v103, vaddq_f32(*(float32x4_t *)(v92 + 400), vmulq_f32(v103, vaddq_f32(vaddq_f32(*(float32x4_t *)(v92 + 368), vmulq_f32(*(float32x4_t *)(v92 + 384), v103)), vmulq_f32(vmulq_f32(v103, v103), vaddq_f32(*(float32x4_t *)(v92 + 336), vmulq_f32(*(float32x4_t *)(v92 + 352), v103)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v92 + 416), vcvtq_s32_f32(v102)), 0x17uLL));
    float32x4_t v105 = vaddq_f32(v104, vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(*(float32x4_t *)(v92 + 64), v91)), vsubq_f32(vmulq_f32(v91, *(float32x4_t *)(v92 + 48)), v104)));
    *(int8x16_t *)(v5 + v89) = vbslq_s8(*(int8x16_t *)(v92 + 448), (int8x16_t)v90, (int8x16_t)vaddq_f32(v105, vmulq_f32(vmulq_f32(*(float32x4_t *)(v92 + 432), v105), (float32x4_t)vbslq_s8(*(int8x16_t *)(v92 + 448), (int8x16_t)v90, vandq_s8((int8x16_t)v94, (int8x16_t)vcgtq_f32(v93, v90))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve3AntiSymmetric::GetDOD(HgcToneParamCurve3AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcToneParamCurve3AntiSymmetric::GetROI(HgcToneParamCurve3AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(HgcToneParamCurve3AntiSymmetric *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10EFDB0;
  operator new();
}

void sub_1B790B94C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve3AntiSymmetric::~HgcToneParamCurve3AntiSymmetric(HGNode *this)
{
  *(void *)this = &unk_1F10EFDB0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4019C028F0);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10EFDB0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4019C028F0);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve3AntiSymmetric::SetParameter(HgcToneParamCurve3AntiSymmetric *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve3AntiSymmetric::GetParameter(HgcToneParamCurve3AntiSymmetric *this, unsigned int a2, float *a3)
{
  if (a2 > 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcToneParamCurve4AntiSymmetric::GetProgram(HgcToneParamCurve4AntiSymmetric *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000494\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[1].xyz) + half3(hg_Params[2].xyz);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xyz));\n"
             "    r2.xyz = r2.xyz + half3(hg_Params[5].xyz);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[3].xyz);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[4].xyz);\n"
             "    r3.xyz = r3.xyz + half3(hg_Params[6].xyz);\n"
             "    r1.xz = select(r2.xz, r3.xz, r1.xz < 0.00000h);\n"
             "    output.color0.xz = select(float2(r1.xz), -float2(r1.xz), float2(r0.xz) < 0.00000h);\n"
             "    r0.z = select(r2.y, r3.y, r1.y < 0.00000h);\n"
             "    output.color0.y = select(float(r0.z), -float(r0.z), float(r0.y) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6701f725:e5cd2a86:d8f2e6e4:94645d52\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0007:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000429\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz);\n"
             "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xyz);\n"
             "    r2.xyz = r2.xyz + hg_Params[5].xyz;\n"
             "    r3.xyz = r1.xyz*hg_Params[3].xyz;\n"
             "    r1.xyz = r1.xyz - hg_Params[4].xyz;\n"
             "    r3.xyz = r3.xyz + hg_Params[6].xyz;\n"
             "    r1.xz = select(r2.xz, r3.xz, r1.xz < 0.00000f);\n"
             "    output.color0.xz = select(r1.xz, -r1.xz, r0.xz < 0.00000f);\n"
             "    r0.z = select(r2.y, r3.y, r1.y < 0.00000f);\n"
             "    output.color0.y = select(r0.z, -r0.z, r0.y < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e8a9e9fa:346b61d9:9c01e056:7ecca853\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0007:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000508\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = abs(r0.xyz);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal1.xyz + hg_ProgramLocal2.xyz;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xyz);\n"
           "    r2.xyz = r2.xyz + hg_ProgramLocal5.xyz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal3.xyz;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal4.xyz;\n"
           "    r3.xyz = r3.xyz + hg_ProgramLocal6.xyz;\n"
           "    r1.xz = vec2(r1.x < 0.00000 ? r3.x : r2.x, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    gl_FragColor.xz = vec2(r0.x < 0.00000 ? -r1.x : r1.x, r0.z < 0.00000 ? -r1.z : r1.z);\n"
           "    r0.z = r1.y < 0.00000 ? r3.y : r2.y;\n"
           "    gl_FragColor.y = r0.y < 0.00000 ? -r0.z : r0.z;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=e8be88c2:c272e374:876071e8:50ed2741\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0007:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve4AntiSymmetric::InitProgramDescriptor(HgcToneParamCurve4AntiSymmetric *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve4AntiSymmetric_hgc_visible", "//Metal1.0     \n//LEN=0000000312\n[[ visible ]] FragmentOut HgcToneParamCurve4AntiSymmetric_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fabs(r0.xyz);\n"
    "    r2.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[2].xyz;\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].xyz);\n"
    "    r2.xyz = r2.xyz + hg_Params[5].xyz;\n"
    "    r3.xyz = r1.xyz*hg_Params[3].xyz;\n"
    "    r1.xyz = r1.xyz - hg_Params[4].xyz;\n"
    "    r3.xyz = r3.xyz + hg_Params[6].xyz;\n"
    "    r1.xz = select(r2.xz, r3.xz, r1.xz < 0.00000f);\n"
    "    output.color0.xz = select(r1.xz, -r1.xz, r0.xz < 0.00000f);\n"
    "    r0.z = select(r2.y, r3.y, r1.y < 0.00000f);\n"
    "    output.color0.y = select(r0.z, -r0.z, r0.y < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcToneParamCurve4AntiSymmetric");
}

void sub_1B790BDEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B790BE1C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B790BE14);
}

char *HgcToneParamCurve4AntiSymmetric::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376490;
  strcpy(result, "HgcToneParamCurve4AntiSymmetric [hgc1]");
  return result;
}

uint64_t HgcToneParamCurve4AntiSymmetric::BindTexture(HgcToneParamCurve4AntiSymmetric *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve4AntiSymmetric::Bind(HgcToneParamCurve4AntiSymmetric *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcToneParamCurve4AntiSymmetric::RenderTile(HgcToneParamCurve4AntiSymmetric *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v109 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v11 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v12 = *(float32x4_t *)(v6 + v10);
      float32x4_t v13 = vabsq_f32(v11);
      float32x4_t v14 = vabsq_f32(v12);
      uint64_t v15 = *((void *)this + 51);
      float32x4_t v16 = *(float32x4_t *)(v15 + 16);
      float32x4_t v17 = *(float32x4_t *)(v15 + 32);
      float32x4_t v18 = *(float32x4_t *)(v15 + 48);
      int8x16_t v19 = (int8x16_t)vaddq_f32(v17, vmulq_f32(v13, v16));
      float32x4_t v20 = vmulq_f32(v14, v16);
      float32x4_t v22 = *(float32x4_t *)(v15 + 96);
      float32x4_t v21 = *(float32x4_t *)(v15 + 112);
      int8x16_t v23 = (int8x16_t)vaddq_f32(v17, v20);
      float32x4_t v24 = *(float32x4_t *)(v15 + 128);
      int8x16_t v25 = *(int8x16_t *)(v15 + 144);
      int8x16_t v26 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vceqq_f32(*(float32x4_t *)v15, v21)), v21);
      float32x4_t v27 = (float32x4_t)vbslq_s8(v26, (int8x16_t)v24, v19);
      float32x4_t v28 = (float32x4_t)vbslq_s8(v26, (int8x16_t)v24, v23);
      float32x4_t v29 = (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)v27), (int8x16_t)v24);
      float32x4_t v30 = *(float32x4_t *)(v15 + 160);
      int8x16_t v31 = *(int8x16_t *)(v15 + 176);
      float32x4_t v32 = (float32x4_t)vorrq_s8(vandq_s8(v25, (int8x16_t)v28), (int8x16_t)v24);
      int8x16_t v33 = (int8x16_t)vcgtq_f32(v30, v27);
      float32x4_t v34 = (float32x4_t)vandq_s8(v31, (int8x16_t)vcgtq_f32(v30, v28));
      float32x4_t v35 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x17uLL)), (float32x4_t)vandq_s8(v31, v33));
      float32x4_t v36 = *(float32x4_t *)(v15 + 192);
      float32x4_t v37 = *(float32x4_t *)(v15 + 208);
      float32x4_t v38 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x17uLL)), v34);
      float32x4_t v39 = vsubq_f32(v35, v36);
      float32x4_t v40 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v29, v37));
      float32x4_t v41 = (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v32, v37));
      float32x4_t v42 = vsubq_f32(v38, v36);
      float32x4_t v43 = *(float32x4_t *)(v15 + 224);
      float32x4_t v44 = *(float32x4_t *)(v15 + 240);
      float32x4_t v45 = vaddq_f32(v39, v40);
      float32x4_t v46 = vsubq_f32(vsubq_f32(v29, v24), vmulq_f32(vmulq_f32(v43, v40), v29));
      float32x4_t v47 = vsubq_f32(vsubq_f32(v32, v24), vmulq_f32(vmulq_f32(v43, v41), v32));
      float32x4_t v48 = vmulq_f32(v46, v46);
      float32x4_t v49 = *(float32x4_t *)(v15 + 256);
      float32x4_t v50 = *(float32x4_t *)(v15 + 272);
      float32x4_t v51 = *(float32x4_t *)(v15 + 288);
      float32x4_t v52 = *(float32x4_t *)(v15 + 304);
      float32x4_t v53 = vaddq_f32(v44, vmulq_f32(v49, v46));
      float32x4_t v54 = vaddq_f32(v50, vmulq_f32(v51, v46));
      float32x4_t v55 = vaddq_f32(v50, vmulq_f32(v51, v47));
      float32x4_t v56 = vaddq_f32(v44, vmulq_f32(v49, v47));
      float32x4_t v57 = *(float32x4_t *)(v15 + 320);
      float32x4_t v58 = *(float32x4_t *)(v15 + 336);
      float32x4_t v59 = vaddq_f32(v52, vmulq_f32(v46, v57));
      float32x4_t v60 = vaddq_f32(v52, vmulq_f32(v47, v57));
      float32x4_t v61 = vmulq_f32(v47, v47);
      float32x4_t v62 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(v45, vmulq_f32(v46, vaddq_f32(v58, vmulq_f32(v46, vaddq_f32(v59, vmulq_f32(v48, vaddq_f32(v53, vmulq_f32(v48, v54)))))))));
      float32x4_t v63 = vmulq_f32(*(float32x4_t *)v15, vaddq_f32(vaddq_f32(v42, v41), vmulq_f32(v47, vaddq_f32(v58, vmulq_f32(v47, vaddq_f32(v60, vmulq_f32(v61, vaddq_f32(v56, vmulq_f32(v61, v55)))))))));
      float32x4_t v64 = *(float32x4_t *)(v15 + 352);
      float32x4_t v65 = *(float32x4_t *)(v15 + 368);
      float32x4_t v66 = vmaxq_f32(v62, v64);
      float32x4_t v67 = vmaxq_f32(v63, v64);
      float32x4_t v68 = vcvtq_f32_s32(vcvtq_s32_f32(v66));
      float32x4_t v69 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      float32x4_t v70 = vsubq_f32(v68, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v68, v66)));
      float32x4_t v71 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v24, (int8x16_t)vcgtq_f32(v69, v67)));
      float32x4_t v72 = vsubq_f32(v66, v70);
      float32x4_t v73 = vsubq_f32(v67, v71);
      float32x4_t v74 = *(float32x4_t *)(v15 + 384);
      float32x4_t v75 = *(float32x4_t *)(v15 + 400);
      float32x4_t v76 = vaddq_f32(v65, vmulq_f32(v74, v72));
      float32x4_t v77 = vaddq_f32(v65, vmulq_f32(v74, v73));
      float32x4_t v78 = *(float32x4_t *)(v15 + 416);
      float32x4_t v79 = *(float32x4_t *)(v15 + 432);
      float32x4_t v80 = vmulq_f32(v73, vaddq_f32(v79, vmulq_f32(v73, vaddq_f32(vaddq_f32(v75, vmulq_f32(v78, v73)), vmulq_f32(vmulq_f32(v73, v73), v77)))));
      int32x4_t v81 = vcvtq_s32_f32(v71);
      int32x4_t v82 = *(int32x4_t *)(v15 + 448);
      int8x16_t v83 = *(int8x16_t *)(v15 + 464);
      float32x4_t v84 = vaddq_f32(v24, v80);
      float32x4_t v85 = vmulq_f32(vaddq_f32(v24, vmulq_f32(v72, vaddq_f32(v79, vmulq_f32(v72, vaddq_f32(vaddq_f32(v75, vmulq_f32(v72, v78)), vmulq_f32(vmulq_f32(v72, v72), v76)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v82, vcvtq_s32_f32(v70)), 0x17uLL));
      float32x4_t v86 = vmulq_f32(v84, (float32x4_t)vshlq_n_s32(vaddq_s32(v82, v81), 0x17uLL));
      float32x4_t v88 = *(float32x4_t *)(v15 + 64);
      float32x4_t v87 = *(float32x4_t *)(v15 + 80);
      int8x16_t v89 = (int8x16_t)vaddq_f32(v87, v85);
      float32x4_t v90 = vmulq_f32(v13, v18);
      float32x4_t v91 = vmulq_f32(v14, v18);
      int8x16_t v92 = (int8x16_t)vaddq_f32(v87, v86);
      float32x4_t v93 = vsubq_f32(v13, v88);
      float32x4_t v94 = vsubq_f32(v14, v88);
      int8x16_t v95 = (int8x16_t)vaddq_f32(v90, v22);
      int8x16_t v96 = (int8x16_t)vaddq_f32(v91, v22);
      float32x4_t v97 = (float32x4_t)vbslq_s8(v83, (int8x16_t)v93, vbslq_s8((int8x16_t)vcgtq_f32(v21, v93), v95, v89));
      float32x4_t v98 = (float32x4_t)vbslq_s8(v83, (int8x16_t)v94, vbslq_s8((int8x16_t)vcgtq_f32(v21, v94), v96, v92));
      int8x16_t v99 = *(int8x16_t *)(v15 + 480);
      int8x16_t v100 = *(int8x16_t *)(v15 + 496);
      int8x16_t v101 = vandq_s8(v99, (int8x16_t)v12);
      int8x16_t v102 = veorq_s8((int8x16_t)v97, vandq_s8(v99, (int8x16_t)v11));
      int8x16_t v103 = vbslq_s8((int8x16_t)vcgtq_f32(v21, v97), v95, v89);
      int8x16_t v104 = vbslq_s8((int8x16_t)vcgtq_f32(v21, v98), v96, v92);
      int8x16_t v105 = vbslq_s8(v100, vextq_s8(v103, v103, 0xCuLL), (int8x16_t)v11);
      int8x16_t v106 = vbslq_s8(v100, vextq_s8(v104, v104, 0xCuLL), (int8x16_t)v12);
      int8x16_t v107 = *(int8x16_t *)(v15 + 512);
      float32x4_t v108 = (int8x16_t *)(v5 + v10);
      v108[-1] = vbslq_s8(v107, v105, vbslq_s8(v83, veorq_s8(vandq_s8(v105, v99), vextq_s8(v105, v105, 4uLL)), v102));
      *float32x4_t v108 = vbslq_s8(v107, v106, vbslq_s8(v83, veorq_s8(vandq_s8(v106, v99), vextq_s8(v106, v106, 4uLL)), veorq_s8((int8x16_t)v98, v101)));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v109 = -v9;
    if (v109 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v110 = 16 * v109;
    float32x4_t v111 = *(float32x4_t *)(v6 + v110);
    float32x4_t v112 = vabsq_f32(v111);
    uint64_t v113 = *((void *)this + 51);
    float32x4_t v114 = *(float32x4_t *)(v113 + 112);
    float32x4_t v115 = *(float32x4_t *)(v113 + 128);
    float32x4_t v116 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v115, (int8x16_t)vceqq_f32(*(float32x4_t *)v113, v114)), v114), (int8x16_t)v115, (int8x16_t)vaddq_f32(*(float32x4_t *)(v113 + 32), vmulq_f32(v112, *(float32x4_t *)(v113 + 16))));
    float32x4_t v117 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v113 + 144), (int8x16_t)v116), (int8x16_t)v115);
    float32x4_t v118 = (float32x4_t)vandq_s8((int8x16_t)v115, (int8x16_t)vcgtq_f32(v117, *(float32x4_t *)(v113 + 208)));
    float32x4_t v119 = vsubq_f32(vsubq_f32(v117, v115), vmulq_f32(vmulq_f32(*(float32x4_t *)(v113 + 224), v118), v117));
    float32x4_t v120 = vmulq_f32(v119, v119);
    float32x4_t v121 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v113, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v116, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v113 + 176), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v113 + 160), v116))), *(float32x4_t *)(v113 + 192)), v118), vmulq_f32(v119, vaddq_f32(*(float32x4_t *)(v113 + 336), vmulq_f32(v119, vaddq_f32(
                         vaddq_f32(*(float32x4_t *)(v113 + 304), vmulq_f32(v119, *(float32x4_t *)(v113 + 320))),
                         vmulq_f32(v120, vaddq_f32(vaddq_f32(*(float32x4_t *)(v113 + 240), vmulq_f32(*(float32x4_t *)(v113 + 256), v119)), vmulq_f32(v120, vaddq_f32(*(float32x4_t *)(v113 + 272), vmulq_f32(*(float32x4_t *)(v113 + 288), v119))))))))))), *(float32x4_t *)(v113 + 352));
    float32x4_t v122 = vcvtq_f32_s32(vcvtq_s32_f32(v121));
    float32x4_t v123 = vsubq_f32(v122, (float32x4_t)vandq_s8((int8x16_t)v115, (int8x16_t)vcgtq_f32(v122, v121)));
    float32x4_t v124 = vsubq_f32(v121, v123);
    float32x4_t v125 = vaddq_f32(v115, vmulq_f32(v124, vaddq_f32(*(float32x4_t *)(v113 + 432), vmulq_f32(v124, vaddq_f32(vaddq_f32(*(float32x4_t *)(v113 + 400), vmulq_f32(*(float32x4_t *)(v113 + 416), v124)), vmulq_f32(vmulq_f32(v124, v124), vaddq_f32(*(float32x4_t *)(v113 + 368), vmulq_f32(*(float32x4_t *)(v113 + 384), v124))))))));
    int8x16_t v126 = *(int8x16_t *)(v113 + 464);
    int8x16_t v127 = (int8x16_t)vaddq_f32(*(float32x4_t *)(v113 + 80), vmulq_f32(v125, (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v113 + 448), vcvtq_s32_f32(v123)), 0x17uLL)));
    float32x4_t v128 = vmulq_f32(v112, *(float32x4_t *)(v113 + 48));
    float32x4_t v129 = vsubq_f32(v112, *(float32x4_t *)(v113 + 64));
    int8x16_t v130 = (int8x16_t)vaddq_f32(v128, *(float32x4_t *)(v113 + 96));
    float32x4_t v131 = (float32x4_t)vbslq_s8(v126, (int8x16_t)v129, vbslq_s8((int8x16_t)vcgtq_f32(v114, v129), v130, v127));
    int8x16_t v132 = *(int8x16_t *)(v113 + 480);
    int8x16_t v133 = veorq_s8((int8x16_t)v131, vandq_s8(v132, (int8x16_t)v111));
    int8x16_t v134 = vbslq_s8((int8x16_t)vcgtq_f32(v114, v131), v130, v127);
    int8x16_t v135 = vbslq_s8(*(int8x16_t *)(v113 + 496), vextq_s8(v134, v134, 0xCuLL), (int8x16_t)v111);
    *(int8x16_t *)(v5 + v110) = vbslq_s8(*(int8x16_t *)(v113 + 512), v135, vbslq_s8(v126, veorq_s8(vandq_s8(v135, v132), vextq_s8(v135, v135, 4uLL)), v133));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve4AntiSymmetric::GetDOD(HgcToneParamCurve4AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcToneParamCurve4AntiSymmetric::GetROI(HgcToneParamCurve4AntiSymmetric *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(HgcToneParamCurve4AntiSymmetric *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F0018;
  operator new();
}

void sub_1B790C818(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve4AntiSymmetric::~HgcToneParamCurve4AntiSymmetric(HGNode *this)
{
  *(void *)this = &unk_1F10F0018;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409F0D1415);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F0018;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409F0D1415);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve4AntiSymmetric::SetParameter(HgcToneParamCurve4AntiSymmetric *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve4AntiSymmetric::GetParameter(HgcToneParamCurve4AntiSymmetric *this, unsigned int a2, float *a3)
{
  if (a2 > 6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2446_Method_A_TMO::GetProgram(HgcBT2446_Method_A_TMO *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000007d4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.4166666567, 0.6779999733, 0.2626999915, 0.05930000171);\n"
             "    const half4 c1 = half4(12.25979805, 1.000000000, 0.2681693435, 0.9908999801);\n"
             "    const half4 c2 = half4(0.000000000, 0.7398999929, -1.151000023, 1.077000022);\n"
             "    const half4 c3 = half4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
             "    const half4 c4 = half4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
             "    const half4 c5 = half4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xy = pow(r0.xy, c0.xx);\n"
             "    r0.y = r0.y*c0.y;\n"
             "    r1.x = r0.x*c0.z + r0.y;\n"
             "    r0.y = pow(r0.z, c0.x);\n"
             "    r0.z = r0.y*c0.w + r1.x;\n"
             "    r1.x = r0.z*c1.x + c1.y;\n"
             "    r1.x = log2(r1.x);\n"
             "    r1.x = r1.x*c1.z;\n"
             "    r1.z = half(r1.x < c1.w);\n"
             "    r1.y = half(c2.y < r1.x);\n"
             "    r1.w = fmin(r1.y, r1.z);\n"
             "    r1.y = half(c2.y < r1.x);\n"
             "    r1.z = half(-r1.w >= c2.x);\n"
             "    r1.yw = fmin(r1.yy, r1.zw);\n"
             "    r2.xy = r1.xx*c2.zw + c3.xy;\n"
             "    r2.x = r1.x*r2.x + c3.z;\n"
             "    r0.xy = r0.xy - r0.zz;\n"
             "    r1.w = select(r2.y, r2.x, -r1.w < 0.00000h);\n"
             "    r1.x = r1.x*c3.w + c3.w;\n"
             "    r1.x = select(r1.w, r1.x, -r1.y < 0.00000h);\n"
             "    r1.y = r0.z*c4.y;\n"
             "    r1.x = pow(c4.x, r1.x);\n"
             "    r1.y = fmax(r1.y, c4.z);\n"
             "    r1.x = r1.x*c4.w + -c4.w;\n"
             "    r1.y = r1.x/r1.y;\n"
             "    r0.xy = r0.xy*r1.yy;\n"
             "    r0.x = r0.x*c5.x;\n"
             "    r1.z = r0.x*c5.y;\n"
             "    r0.z = fmax(r1.z, c3.y);\n"
             "    output.color0.x = float(r1.x) - float(r0.z);\n"
             "    output.color0.y = float(r0.y)*float(c5.z);\n"
             "    output.color0.zw = float2(r0.xw);\n"
             "    return output;\n"
             "}\n"
             "//MD5=00594ba5:384afdf9:88664fca:8e0e4589\n"
             "//SIG=00400000:00000001:00000001:00000001:0006:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000007ba\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.4166666567, 0.6779999733, 0.2626999915, 0.05930000171);\n"
             "    const float4 c1 = float4(12.25979805, 1.000000000, 0.2681693435, 0.9908999801);\n"
             "    const float4 c2 = float4(0.000000000, 0.7398999929, -1.151000023, 1.077000022);\n"
             "    const float4 c3 = float4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
             "    const float4 c4 = float4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
             "    const float4 c5 = float4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xy = pow(r0.xy, c0.xx);\n"
             "    r0.y = r0.y*c0.y;\n"
             "    r1.x = r0.x*c0.z + r0.y;\n"
             "    r0.y = pow(r0.z, c0.x);\n"
             "    r0.z = r0.y*c0.w + r1.x;\n"
             "    r1.x = r0.z*c1.x + c1.y;\n"
             "    r1.x = log2(r1.x);\n"
             "    r1.x = r1.x*c1.z;\n"
             "    r1.z = float(r1.x < c1.w);\n"
             "    r1.y = float(c2.y < r1.x);\n"
             "    r1.w = fmin(r1.y, r1.z);\n"
             "    r1.y = float(c2.y < r1.x);\n"
             "    r1.z = float(-r1.w >= c2.x);\n"
             "    r1.yw = fmin(r1.yy, r1.zw);\n"
             "    r2.xy = r1.xx*c2.zw + c3.xy;\n"
             "    r2.x = r1.x*r2.x + c3.z;\n"
             "    r0.xy = r0.xy - r0.zz;\n"
             "    r1.w = select(r2.y, r2.x, -r1.w < 0.00000f);\n"
             "    r1.x = r1.x*c3.w + c3.w;\n"
             "    r1.x = select(r1.w, r1.x, -r1.y < 0.00000f);\n"
             "    r1.y = r0.z*c4.y;\n"
             "    r1.x = pow(c4.x, r1.x);\n"
             "    r1.y = fmax(r1.y, c4.z);\n"
             "    r1.x = r1.x*c4.w + -c4.w;\n"
             "    r1.y = r1.x/r1.y;\n"
             "    r0.xy = r0.xy*r1.yy;\n"
             "    r0.x = r0.x*c5.x;\n"
             "    r1.z = r0.x*c5.y;\n"
             "    r0.z = fmax(r1.z, c3.y);\n"
             "    output.color0.x = r1.x - r0.z;\n"
             "    output.color0.y = r0.y*c5.z;\n"
             "    output.color0.zw = r0.xw;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ac33f7a0:aaa13e44:0e17b65d:b527b488\n"
             "//SIG=00000000:00000001:00000001:00000000:0006:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000075f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.4166666567, 0.6779999733, 0.2626999915, 0.05930000171);\n"
           "    const mediump vec4 c1 = vec4(12.25979805, 1.000000000, 0.2681693435, 0.9908999801);\n"
           "    const mediump vec4 c2 = vec4(0.000000000, 0.7398999929, -1.151000023, 1.077000022);\n"
           "    const mediump vec4 c3 = vec4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
           "    const mediump vec4 c4 = vec4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
           "    const mediump vec4 c5 = vec4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xy = pow(r0.xy, c0.xx);\n"
           "    r0.y = r0.y*c0.y;\n"
           "    r1.x = r0.x*c0.z + r0.y;\n"
           "    r0.y = pow(r0.z, c0.x);\n"
           "    r0.z = r0.y*c0.w + r1.x;\n"
           "    r1.x = r0.z*c1.x + c1.y;\n"
           "    r1.x = log2(r1.x);\n"
           "    r1.x = r1.x*c1.z;\n"
           "    r1.z = float(r1.x < c1.w);\n"
           "    r1.y = float(c2.y < r1.x);\n"
           "    r1.w = min(r1.y, r1.z);\n"
           "    r1.y = float(c2.y < r1.x);\n"
           "    r1.z = float(-r1.w >= c2.x);\n"
           "    r1.yw = min(r1.yy, r1.zw);\n"
           "    r2.xy = r1.xx*c2.zw + c3.xy;\n"
           "    r2.x = r1.x*r2.x + c3.z;\n"
           "    r0.xy = r0.xy - r0.zz;\n"
           "    r1.w = -r1.w < 0.00000 ? r2.x : r2.y;\n"
           "    r1.x = r1.x*c3.w + c3.w;\n"
           "    r1.x = -r1.y < 0.00000 ? r1.x : r1.w;\n"
           "    r1.y = r0.z*c4.y;\n"
           "    r1.x = pow(c4.x, r1.x);\n"
           "    r1.y = max(r1.y, c4.z);\n"
           "    r1.x = r1.x*c4.w + -c4.w;\n"
           "    r1.y = r1.x/r1.y;\n"
           "    r0.xy = r0.xy*r1.yy;\n"
           "    r0.x = r0.x*c5.x;\n"
           "    r1.z = r0.x*c5.y;\n"
           "    r0.z = max(r1.z, c3.y);\n"
           "    gl_FragColor.x = r1.x - r0.z;\n"
           "    gl_FragColor.y = r0.y*c5.z;\n"
           "    gl_FragColor.zw = r0.xw;\n"
           "}\n"
           "//MD5=23dc2221:3ec35feb:ba705176:9ebe6741\n"
           "//SIG=00000000:00000001:00000001:00000000:0006:0000:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2446_Method_A_TMO::InitProgramDescriptor(HgcBT2446_Method_A_TMO *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2446_Method_A_TMO_hgc_visible", "//Metal1.0     \n//LEN=000000069a\n[[ visible ]] FragmentOut HgcBT2446_Method_A_TMO_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.4166666567, 0.6779999733, 0.2626999915, 0.05930000171);\n"
    "    const float4 c1 = float4(12.25979805, 1.000000000, 0.2681693435, 0.9908999801);\n"
    "    const float4 c2 = float4(0.000000000, 0.7398999929, -1.151000023, 1.077000022);\n"
    "    const float4 c3 = float4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
    "    const float4 c4 = float4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
    "    const float4 c5 = float4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xy = pow(r0.xy, c0.xx);\n"
    "    r0.y = r0.y*c0.y;\n"
    "    r1.x = r0.x*c0.z + r0.y;\n"
    "    r0.y = pow(r0.z, c0.x);\n"
    "    r0.z = r0.y*c0.w + r1.x;\n"
    "    r1.x = r0.z*c1.x + c1.y;\n"
    "    r1.x = log2(r1.x);\n"
    "    r1.x = r1.x*c1.z;\n"
    "    r1.z = float(r1.x < c1.w);\n"
    "    r1.y = float(c2.y < r1.x);\n"
    "    r1.w = fmin(r1.y, r1.z);\n"
    "    r1.y = float(c2.y < r1.x);\n"
    "    r1.z = float(-r1.w >= c2.x);\n"
    "    r1.yw = fmin(r1.yy, r1.zw);\n"
    "    r2.xy = r1.xx*c2.zw + c3.xy;\n"
    "    r2.x = r1.x*r2.x + c3.z;\n"
    "    r0.xy = r0.xy - r0.zz;\n"
    "    r1.w = select(r2.y, r2.x, -r1.w < 0.00000f);\n"
    "    r1.x = r1.x*c3.w + c3.w;\n"
    "    r1.x = select(r1.w, r1.x, -r1.y < 0.00000f);\n"
    "    r1.y = r0.z*c4.y;\n"
    "    r1.x = pow(c4.x, r1.x);\n"
    "    r1.y = fmax(r1.y, c4.z);\n"
    "    r1.x = r1.x*c4.w + -c4.w;\n"
    "    r1.y = r1.x/r1.y;\n"
    "    r0.xy = r0.xy*r1.yy;\n"
    "    r0.x = r0.x*c5.x;\n"
    "    r1.z = r0.x*c5.y;\n"
    "    r0.z = fmax(r1.z, c3.y);\n"
    "    output.color0.x = r1.x - r0.z;\n"
    "    output.color0.y = r0.y*c5.z;\n"
    "    output.color0.zw = r0.xw;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2446_Method_A_TMO");
}

void sub_1B790CCBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B790CCEC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B790CCE4);
}

double HgcBT2446_Method_A_TMO::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375F40;
  strcpy(v3, "HgcBT2446_Method_A_TMO [hgc1]");
  return *(double *)"hod_A_TMO [hgc1]";
}

uint64_t HgcBT2446_Method_A_TMO::BindTexture(HgcBT2446_Method_A_TMO *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2446_Method_A_TMO::Bind(HgcBT2446_Method_A_TMO *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2446_Method_A_TMO::RenderTile(HgcBT2446_Method_A_TMO *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v167 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v11 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v12 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = *((void *)this + 51);
      float32x4_t v14 = *(float32x4_t *)(v13 + 16);
      float32x4_t v15 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v13, (int8x16_t)v11), (int8x16_t)v14);
      float32x4_t v16 = *(float32x4_t *)(v13 + 32);
      int8x16_t v17 = *(int8x16_t *)(v13 + 48);
      float32x4_t v18 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v13, (int8x16_t)v12), (int8x16_t)v14);
      float32x4_t v19 = *(float32x4_t *)(v13 + 64);
      float32x4_t v20 = *(float32x4_t *)(v13 + 80);
      float32x4_t v21 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v15, v20));
      float32x4_t v22 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v18, v20));
      float32x4_t v23 = *(float32x4_t *)(v13 + 96);
      float32x4_t v24 = *(float32x4_t *)(v13 + 112);
      float32x4_t v25 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v11, 0x17uLL)), (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v16, v11))), v19), v21);
      float32x4_t v26 = vsubq_f32(vsubq_f32(v15, v14), vmulq_f32(vmulq_f32(v23, v21), v15));
      float32x4_t v27 = vsubq_f32(vsubq_f32(v18, v14), vmulq_f32(vmulq_f32(v23, v22), v18));
      float32x4_t v29 = *(float32x4_t *)(v13 + 128);
      float32x4_t v28 = *(float32x4_t *)(v13 + 144);
      float32x4_t v31 = *(float32x4_t *)(v13 + 160);
      float32x4_t v30 = *(float32x4_t *)(v13 + 176);
      float32x4_t v32 = vmulq_f32(v30, vaddq_f32(v25, vmulq_f32(v26, vaddq_f32(vaddq_f32(v28, vmulq_f32(v26, v31)), vmulq_f32(vmulq_f32(v26, v26), vaddq_f32(v24, vmulq_f32(v29, v26)))))));
      float32x4_t v33 = vmulq_f32(v30, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v12, 0x17uLL)), (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v16, v12))), v19), v22), vmulq_f32(v27, vaddq_f32(vaddq_f32(v28, vmulq_f32(v27, v31)), vmulq_f32(vmulq_f32(v27, v27), vaddq_f32(v24, vmulq_f32(v29, v27)))))));
      float32x4_t v34 = *(float32x4_t *)(v13 + 192);
      float32x4_t v35 = *(float32x4_t *)(v13 + 208);
      float32x4_t v36 = vmaxq_f32(v32, v34);
      float32x4_t v37 = vmaxq_f32(v33, v34);
      float32x4_t v38 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      float32x4_t v39 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
      float32x4_t v40 = vsubq_f32(v38, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v38, v36)));
      float32x4_t v41 = vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v39, v37)));
      float32x4_t v42 = vsubq_f32(v36, v40);
      float32x4_t v43 = vsubq_f32(v37, v41);
      float32x4_t v45 = *(float32x4_t *)(v13 + 224);
      float32x4_t v44 = *(float32x4_t *)(v13 + 240);
      int32x4_t v46 = vcvtq_s32_f32(v40);
      float32x4_t v47 = vaddq_f32(v14, vmulq_f32(v42, vaddq_f32(v44, vmulq_f32(v42, vaddq_f32(v35, vmulq_f32(v45, v42))))));
      int32x4_t v48 = vcvtq_s32_f32(v41);
      int32x4_t v50 = *(int32x4_t *)(v13 + 256);
      float32x4_t v49 = *(float32x4_t *)(v13 + 272);
      float32x4_t v51 = vaddq_f32(v14, vmulq_f32(v43, vaddq_f32(v44, vmulq_f32(v43, vaddq_f32(v35, vmulq_f32(v45, v43))))));
      v43.i64[0] = vmulq_f32(v47, (float32x4_t)vshlq_n_s32(vaddq_s32(v50, v46), 0x17uLL)).u64[0];
      v47.i64[0] = vmulq_f32(v51, (float32x4_t)vshlq_n_s32(vaddq_s32(v50, v48), 0x17uLL)).u64[0];
      v43.i64[1] = *(void *)(v6 + v10 - 8);
      v47.i64[1] = *(void *)(v6 + v10 + 8);
      int8x16_t v53 = *(int8x16_t *)(v13 + 288);
      float32x4_t v52 = *(float32x4_t *)(v13 + 304);
      float32x4_t v54 = (float32x4_t)vbslq_s8(v53, (int8x16_t)vmulq_f32(v49, v43), (int8x16_t)v43);
      float32x4_t v55 = (float32x4_t)vbslq_s8(v53, (int8x16_t)vmulq_f32(v49, v47), (int8x16_t)v47);
      float32x4_t v56 = (float32x4_t)vextq_s8((int8x16_t)v54, (int8x16_t)v54, 4uLL);
      int8x16_t v57 = (int8x16_t)vaddq_f32(vmulq_f32(v52, v54), (float32x4_t)vrev64q_s32((int32x4_t)v54));
      float32x4_t v58 = (float32x4_t)vextq_s8((int8x16_t)v55, (int8x16_t)v55, 4uLL);
      float32x4_t v59 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v56, *(int8x16_t *)v13), (int8x16_t)v52);
      float32x4_t v60 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v58, *(int8x16_t *)v13), (int8x16_t)v52);
      float32x4_t v61 = (float32x4_t)vandq_s8((int8x16_t)v52, (int8x16_t)vcgtq_f32(v59, v20));
      float32x4_t v62 = (float32x4_t)vandq_s8((int8x16_t)v52, (int8x16_t)vcgtq_f32(v60, v20));
      float32x4_t v63 = vsubq_f32(vsubq_f32(v59, v52), vmulq_f32(vmulq_f32(v23, v61), v59));
      float32x4_t v64 = vsubq_f32(vsubq_f32(v60, v52), vmulq_f32(vmulq_f32(v23, v62), v60));
      float32x4_t v65 = vmulq_f32(v30, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v56, 0x17uLL)), (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v16, v56))), v19), v61), vmulq_f32(v63, vaddq_f32(vaddq_f32(v28, vmulq_f32(v31, v63)), vmulq_f32(vmulq_f32(v63, v63), vaddq_f32(v24, vmulq_f32(v29, v63)))))));
      float32x4_t v66 = vmulq_f32(v30, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v58, 0x17uLL)), (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v16, v58))), v19), v62), vmulq_f32(v64, vaddq_f32(vaddq_f32(v28, vmulq_f32(v31, v64)), vmulq_f32(vmulq_f32(v64, v64), vaddq_f32(v24, vmulq_f32(v29, v64)))))));
      float32x4_t v67 = vmaxq_f32(v65, v34);
      float32x4_t v68 = vmaxq_f32(v66, v34);
      float32x4_t v69 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      float32x4_t v70 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
      float32x4_t v71 = vsubq_f32(v69, (float32x4_t)vandq_s8((int8x16_t)v52, (int8x16_t)vcgtq_f32(v69, v67)));
      float32x4_t v72 = vsubq_f32(v70, (float32x4_t)vandq_s8((int8x16_t)v52, (int8x16_t)vcgtq_f32(v70, v68)));
      int8x16_t v73 = (int8x16_t)vaddq_f32(vmulq_f32(v52, v55), (float32x4_t)vrev64q_s32((int32x4_t)v55));
      float32x4_t v74 = vsubq_f32(v67, v71);
      float32x4_t v75 = vsubq_f32(v68, v72);
      int8x16_t v76 = (int8x16_t)vmulq_f32(vaddq_f32(v52, vmulq_f32(v75, vaddq_f32(v44, vmulq_f32(v75, vaddq_f32(v35, vmulq_f32(v45, v75)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v72), v50), 0x17uLL));
      int8x16_t v77 = vbslq_s8(v53, (int8x16_t)vmulq_f32(vaddq_f32(v52, vmulq_f32(v74, vaddq_f32(v44, vmulq_f32(v74, vaddq_f32(v35, vmulq_f32(v45, v74)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v71), v50), 0x17uLL)), (int8x16_t)v43);
      int8x16_t v78 = vbslq_s8(v53, v76, (int8x16_t)v47);
      int8x16_t v79 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v57, v57, 8uLL), vmulq_lane_f32(v52, *(float32x2_t *)v77.i8, 1));
      int8x16_t v80 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v73, v73, 8uLL), vmulq_lane_f32(v52, *(float32x2_t *)v78.i8, 1));
      int8x16_t v81 = *(int8x16_t *)(v13 + 320);
      float32x4_t v82 = *(float32x4_t *)(v13 + 336);
      float32x4_t v83 = (float32x4_t)vbslq_s8(v81, v79, v77);
      float32x4_t v84 = (float32x4_t)vbslq_s8(v81, v80, v78);
      float32x4_t v85 = (float32x4_t)vextq_s8((int8x16_t)v83, (int8x16_t)v83, 8uLL);
      float32x4_t v86 = (float32x4_t)vextq_s8((int8x16_t)v84, (int8x16_t)v84, 8uLL);
      float32x4_t v87 = vaddq_f32(v49, vmulq_f32(v82, v85));
      float32x4_t v88 = vaddq_f32(v49, vmulq_f32(v82, v86));
      float32x4_t v89 = (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v16, v87));
      float32x4_t v90 = (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v16, v88));
      float32x4_t v91 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v87, 0x17uLL)), v89);
      float32x4_t v92 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v13, (int8x16_t)v87), (int8x16_t)v49);
      float32x4_t v93 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v13, (int8x16_t)v88), (int8x16_t)v49);
      float32x4_t v94 = vsubq_f32(v91, v19);
      float32x4_t v95 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v88, 0x17uLL)), v90), v19);
      float32x4_t v96 = (float32x4_t)vandq_s8((int8x16_t)v49, (int8x16_t)vcgtq_f32(v92, v20));
      float32x4_t v97 = (float32x4_t)vandq_s8((int8x16_t)v49, (int8x16_t)vcgtq_f32(v93, v20));
      float32x4_t v98 = vaddq_f32(v94, v96);
      float32x4_t v99 = vsubq_f32(vsubq_f32(v92, v49), vmulq_f32(vmulq_f32(v23, v96), v92));
      float32x4_t v100 = vsubq_f32(vsubq_f32(v93, v49), vmulq_f32(vmulq_f32(v23, v97), v93));
      float32x4_t v101 = vaddq_f32(v98, vmulq_f32(v99, vaddq_f32(vaddq_f32(v28, vmulq_f32(v31, v99)), vmulq_f32(vmulq_f32(v99, v99), vaddq_f32(v24, vmulq_f32(v29, v99))))));
      float32x4_t v102 = vaddq_f32(vaddq_f32(v95, v97), vmulq_f32(v100, vaddq_f32(vaddq_f32(v28, vmulq_f32(v31, v100)), vmulq_f32(vmulq_f32(v100, v100), vaddq_f32(v24, vmulq_f32(v29, v100))))));
      float32x4_t v103 = *(float32x4_t *)(v13 + 352);
      int32x4_t v104 = *(int32x4_t *)(v13 + 368);
      int32x4_t v105 = (int32x4_t)vmulq_f32(v103, v101);
      int32x4_t v106 = (int32x4_t)vmulq_f32(v103, v102);
      int64x2_t v107 = (int64x2_t)vandq_s8((int8x16_t)v82, (int8x16_t)vcgtq_f32(v103, (float32x4_t)vextq_s8((int8x16_t)v105, (int8x16_t)v105, 8uLL)));
      int64x2_t v108 = (int64x2_t)vandq_s8((int8x16_t)v82, (int8x16_t)vcgtq_f32(v103, (float32x4_t)vextq_s8((int8x16_t)v106, (int8x16_t)v106, 8uLL)));
      v28.i64[0] = v105.i64[0];
      v29.i64[0] = v106.i64[0];
      v28.i64[1] = v107.i64[1];
      v29.i64[1] = v108.i64[1];
      v105.i64[1] = vdupq_laneq_s64(v107, 1).u64[0];
      v106.i64[1] = vdupq_laneq_s64(v108, 1).u64[0];
      int32x4_t v109 = (int32x4_t)vbslq_s8(v53, vandq_s8((int8x16_t)v82, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v105), v103)), (int8x16_t)v28);
      int32x4_t v110 = (int32x4_t)vbslq_s8(v53, vandq_s8((int8x16_t)v82, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v106), v103)), (int8x16_t)v29);
      int64x2_t v111 = (int64x2_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v109, (int8x16_t)v109, 8uLL), (float32x4_t)vrev64q_s32(v109));
      float32x4_t v112 = vminq_f32((float32x4_t)vextq_s8((int8x16_t)v110, (int8x16_t)v110, 8uLL), (float32x4_t)vrev64q_s32(v110));
      v28.i64[0] = v109.i64[0];
      v28.i64[1] = v111.i64[1];
      v29.i64[0] = v110.i64[0];
      v29.i64[1] = v112.i64[1];
      v109.i64[1] = vdupq_laneq_s64(v111, 1).u64[0];
      v110.i64[1] = vdupq_laneq_s64((int64x2_t)v112, 1).u64[0];
      int32x4_t v113 = (int32x4_t)vbslq_s8(v53, vandq_s8((int8x16_t)v82, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v109), v103)), (int8x16_t)v28);
      int32x4_t v114 = (int32x4_t)vbslq_s8(v53, vandq_s8((int8x16_t)v82, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v110), v103)), (int8x16_t)v29);
      int8x16_t v115 = vbslq_s8(v81, vandq_s8((int8x16_t)v82, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32(v113)), v44)), (int8x16_t)v113);
      int8x16_t v116 = vbslq_s8(v81, vandq_s8((int8x16_t)v82, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32(v114)), v44)), (int8x16_t)v114);
      *(int8x8_t *)v112.f32 = vqtbl1_s8(v115, *(int8x8_t *)v104.i8);
      v114.i64[0] = vextq_s8((int8x16_t)v104, (int8x16_t)v104, 8uLL).u64[0];
      *(int8x8_t *)&v112.u32[2] = vqtbl1_s8(v115, *(int8x8_t *)v114.i8);
      int8x16_t v117 = (int8x16_t)vminq_f32((float32x4_t)vdupq_lane_s64(v115.i64[0], 0), v112);
      int8x16_t v118 = *(int8x16_t *)(v13 + 384);
      float32x4_t v119 = *(float32x4_t *)(v13 + 400);
      float32x4_t v120 = (float32x4_t)vbslq_s8(v118, v115, v117);
      float32x4_t v121 = *(float32x4_t *)(v13 + 416);
      float32x4_t v122 = *(float32x4_t *)(v13 + 432);
      float32x4_t v123 = vaddq_f32(v119, vmulq_n_f32(v121, v120.f32[0]));
      int8x16_t v124 = vbslq_s8(v118, (int8x16_t)vaddq_f32(v122, vmulq_f32(v123, v120)), (int8x16_t)v123);
      *(int8x8_t *)v31.f32 = vqtbl1_s8(v116, *(int8x8_t *)v104.i8);
      *(int8x8_t *)&v31.u32[2] = vqtbl1_s8(v116, *(int8x8_t *)v114.i8);
      float32x4_t v125 = (float32x4_t)vbslq_s8(v118, v116, (int8x16_t)vminq_f32((float32x4_t)vdupq_lane_s64(v116.i64[0], 0), v31));
      float32x4_t v126 = vaddq_f32(v119, vmulq_n_f32(v121, v125.f32[0]));
      int8x16_t v127 = vbslq_s8(v118, (int8x16_t)vaddq_f32(v122, vmulq_f32(v126, v125)), (int8x16_t)v126);
      v120.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v120, v122), vextq_s8(v124, v124, 4uLL), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v124, 0)).i64[1];
      v125.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v125, v122), vextq_s8(v127, v127, 4uLL), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v127, 0)).i64[1];
      int32x4_t v128 = (int32x4_t)vbslq_s8(v118, (int8x16_t)vaddq_f32(v23, vmulq_f32(v23, v120)), (int8x16_t)v120);
      int32x4_t v129 = (int32x4_t)vbslq_s8(v118, (int8x16_t)vaddq_f32(v23, vmulq_f32(v23, v125)), (int8x16_t)v125);
      float32x4_t v131 = *(float32x4_t *)(v13 + 448);
      float32x4_t v130 = *(float32x4_t *)(v13 + 464);
      int8x16_t v132 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v128), v131), (int8x16_t)v128, vextq_s8((int8x16_t)v128, (int8x16_t)v128, 0xCuLL));
      int8x16_t v133 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v129), v131), (int8x16_t)v129, vextq_s8((int8x16_t)v129, (int8x16_t)v129, 0xCuLL));
      float32x4_t v134 = vsubq_f32(v83, (float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 2));
      float32x4_t v135 = vsubq_f32(v84, (float32x4_t)vdupq_laneq_s32((int32x4_t)v84, 2));
      *(int8x8_t *)v31.f32 = vext_s8(*(int8x8_t *)v134.f32, *(int8x8_t *)v85.f32, 4uLL);
      *(int8x8_t *)&v31.u32[2] = vext_s8(*(int8x8_t *)v85.f32, *(int8x8_t *)v134.f32, 4uLL);
      *(int8x8_t *)v119.f32 = vext_s8(*(int8x8_t *)v86.f32, *(int8x8_t *)v135.f32, 4uLL);
      *(int8x8_t *)v86.f32 = vext_s8(*(int8x8_t *)v135.f32, *(int8x8_t *)v86.f32, 4uLL);
      v86.i64[1] = v119.i64[0];
      int8x16_t v136 = (int8x16_t)vmulq_f32(v131, v31);
      int8x16_t v137 = (int8x16_t)vmulq_f32(v131, v86);
      float32x4_t v138 = vmaxq_f32(vmulq_f32(v130, (float32x4_t)vbslq_s8(v118, v132, v136)), v34);
      float32x4_t v139 = vmaxq_f32(vmulq_f32(v130, (float32x4_t)vbslq_s8(v118, v133, v137)), v34);
      float32x4_t v140 = vcvtq_f32_s32(vcvtq_s32_f32(v138));
      float32x4_t v141 = vcvtq_f32_s32(vcvtq_s32_f32(v139));
      float32x4_t v142 = vsubq_f32(v140, (float32x4_t)vandq_s8((int8x16_t)v49, (int8x16_t)vcgtq_f32(v140, v138)));
      float32x4_t v143 = vsubq_f32(v141, (float32x4_t)vandq_s8((int8x16_t)v49, (int8x16_t)vcgtq_f32(v141, v139)));
      float32x4_t v144 = vsubq_f32(v138, v142);
      float32x4_t v145 = vsubq_f32(v139, v143);
      float32x4_t v146 = vmulq_f32(v145, vaddq_f32(v44, vmulq_f32(v145, vaddq_f32(v35, vmulq_f32(v45, v145)))));
      int8x16_t v147 = (int8x16_t)vmulq_f32(vaddq_f32(v49, vmulq_f32(v144, vaddq_f32(v44, vmulq_f32(v144, vaddq_f32(v35, vmulq_f32(v45, v144)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v142), v104), 0x17uLL));
      int8x16_t v148 = (int8x16_t)vmulq_f32(vaddq_f32(v49, v146), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v143), v104), 0x17uLL));
      float32x4_t v149 = *(float32x4_t *)(v13 + 480);
      float32x4_t v150 = *(float32x4_t *)(v13 + 496);
      int8x16_t v151 = (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v118, v147, v136), v149);
      int8x16_t v152 = (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v118, v148, v137), v149);
      float32x4_t v153 = *(float32x4_t *)(v13 + 512);
      float32x4_t v154 = *(float32x4_t *)(v13 + 528);
      int8x16_t v155 = (int8x16_t)vaddq_f32(v150, vmulq_f32(v153, (float32x4_t)vbslq_s8(v118, v147, v151)));
      int8x16_t v156 = (int8x16_t)vaddq_f32(v150, vmulq_f32(v153, (float32x4_t)vbslq_s8(v118, v148, v152)));
      float32x4_t v157 = (float32x4_t)vbslq_s8(v118, v155, v151);
      float32x4_t v158 = (float32x4_t)vbslq_s8(v118, v156, v152);
      float32x4_t v159 = vminq_f32(vmaxq_f32(vmulq_f32(v153, vrecpeq_f32(v157)), v150), v154);
      float32x4_t v160 = vminq_f32(vmaxq_f32(vmulq_f32(v153, vrecpeq_f32(v158)), v150), v154);
      v155.i64[0] = vbslq_s8(v118, v155, (int8x16_t)vmulq_n_f32(vmulq_f32(v159, vrecpsq_f32(v157, v159)), v157.f32[0])).u64[0];
      v156.i64[0] = vbslq_s8(v118, v156, (int8x16_t)vmulq_n_f32(vmulq_f32(v160, vrecpsq_f32(v158, v160)), v158.f32[0])).u64[0];
      v157.i64[0] = vmulq_lane_f32(v134, *(float32x2_t *)v155.i8, 1).u64[0];
      v158.i64[0] = vmulq_lane_f32(v135, *(float32x2_t *)v156.i8, 1).u64[0];
      v157.i64[1] = v83.i64[1];
      v158.i64[1] = v84.i64[1];
      float32x4_t v161 = *(float32x4_t *)(v13 + 544);
      int8x16_t v162 = vbslq_s8(v118, (int8x16_t)vmulq_f32(v161, v157), (int8x16_t)v157);
      int8x16_t v163 = vbslq_s8(v118, (int8x16_t)vmulq_f32(v161, v158), (int8x16_t)v158);
      v160.i64[0] = v155.i64[0];
      v160.i64[1] = vmulq_f32(v161, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v162, 0)).i64[1];
      v83.i64[0] = v156.i64[0];
      v83.i64[1] = vmulq_f32(v161, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v163, 0)).i64[1];
      int8x16_t v164 = vbslq_s8(v81, (int8x16_t)vmaxq_f32(v160, v153), v162);
      int8x16_t v165 = vbslq_s8(v81, (int8x16_t)vmaxq_f32(v83, v153), v163);
      v153.i64[0] = vmvnq_s8(v118).u64[0];
      *(int8x8_t *)v155.i8 = vorr_s8(vand_s8(*(int8x8_t *)v118.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v155.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v164, v164, 8uLL))), vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v130.f32, *(float32x2_t *)v164.i8), *(int8x8_t *)v153.f32));
      v155.u64[1] = (unint64_t)vqtbl1_s8(v164, *(int8x8_t *)v114.i8);
      *(int8x8_t *)v130.f32 = vorr_s8(vand_s8(*(int8x8_t *)v118.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v156.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v165, v165, 8uLL))), vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v130.f32, *(float32x2_t *)v165.i8), *(int8x8_t *)v153.f32));
      *(int8x8_t *)&v130.u32[2] = vqtbl1_s8(v165, *(int8x8_t *)v114.i8);
      v166 = (float32x4_t *)(v5 + v10);
      v166[-1] = (float32x4_t)v155;
      float32x4_t *v166 = v130;
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v167 = -v9;
    if (v167 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v168 = 16 * v167;
    float32x4_t v169 = *(float32x4_t *)(v6 + v168);
    uint64_t v170 = *((void *)this + 51);
    float32x4_t v171 = *(float32x4_t *)(v170 + 16);
    float32x4_t v172 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v170, (int8x16_t)v169), (int8x16_t)v171);
    float32x4_t v173 = *(float32x4_t *)(v170 + 32);
    int8x16_t v174 = *(int8x16_t *)(v170 + 48);
    float32x4_t v175 = *(float32x4_t *)(v170 + 64);
    float32x4_t v176 = *(float32x4_t *)(v170 + 80);
    float32x4_t v177 = (float32x4_t)vandq_s8((int8x16_t)v171, (int8x16_t)vcgtq_f32(v172, v176));
    float32x4_t v178 = *(float32x4_t *)(v170 + 96);
    float32x4_t v179 = *(float32x4_t *)(v170 + 112);
    float32x4_t v180 = vsubq_f32(vsubq_f32(v172, v171), vmulq_f32(vmulq_f32(v178, v177), v172));
    float32x4_t v182 = *(float32x4_t *)(v170 + 128);
    float32x4_t v181 = *(float32x4_t *)(v170 + 144);
    float32x4_t v184 = *(float32x4_t *)(v170 + 160);
    float32x4_t v183 = *(float32x4_t *)(v170 + 176);
    float32x4_t v185 = vmulq_f32(v183, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v169, 0x17uLL)), (float32x4_t)vandq_s8(v174, (int8x16_t)vcgtq_f32(v173, v169))), v175), v177), vmulq_f32(v180, vaddq_f32(vaddq_f32(v181, vmulq_f32(v180, v184)), vmulq_f32(vmulq_f32(v180, v180), vaddq_f32(v179, vmulq_f32(v182, v180)))))));
    float32x4_t v186 = *(float32x4_t *)(v170 + 192);
    float32x4_t v187 = *(float32x4_t *)(v170 + 208);
    float32x4_t v188 = vmaxq_f32(v185, v186);
    float32x4_t v189 = vcvtq_f32_s32(vcvtq_s32_f32(v188));
    float32x4_t v190 = vsubq_f32(v189, (float32x4_t)vandq_s8((int8x16_t)v171, (int8x16_t)vcgtq_f32(v189, v188)));
    float32x4_t v191 = vsubq_f32(v188, v190);
    float32x4_t v193 = *(float32x4_t *)(v170 + 224);
    float32x4_t v192 = *(float32x4_t *)(v170 + 240);
    float32x4_t v194 = vaddq_f32(v171, vmulq_f32(v191, vaddq_f32(v192, vmulq_f32(v191, vaddq_f32(v187, vmulq_f32(v193, v191))))));
    int32x4_t v196 = *(int32x4_t *)(v170 + 256);
    float32x4_t v195 = *(float32x4_t *)(v170 + 272);
    v194.i64[0] = vmulq_f32(v194, (float32x4_t)vshlq_n_s32(vaddq_s32(v196, vcvtq_s32_f32(v190)), 0x17uLL)).u64[0];
    v194.i64[1] = *(void *)(v6 + v168 + 8);
    int8x16_t v197 = *(int8x16_t *)(v170 + 288);
    float32x4_t v198 = *(float32x4_t *)(v170 + 304);
    float32x4_t v199 = (float32x4_t)vbslq_s8(v197, (int8x16_t)vmulq_f32(v195, v194), (int8x16_t)v194);
    int8x16_t v200 = (int8x16_t)vaddq_f32(vmulq_f32(v198, v199), (float32x4_t)vrev64q_s32((int32x4_t)v199));
    float32x4_t v201 = (float32x4_t)vextq_s8((int8x16_t)v199, (int8x16_t)v199, 4uLL);
    float32x4_t v202 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v201, *(int8x16_t *)v170), (int8x16_t)v198);
    float32x4_t v203 = (float32x4_t)vandq_s8((int8x16_t)v198, (int8x16_t)vcgtq_f32(v202, v176));
    float32x4_t v204 = vsubq_f32(vsubq_f32(v202, v198), vmulq_f32(vmulq_f32(v178, v203), v202));
    float32x4_t v205 = vmaxq_f32(vmulq_f32(v183, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v201, 0x17uLL)), (float32x4_t)vandq_s8(v174, (int8x16_t)vcgtq_f32(v173, v201))), v175), v203), vmulq_f32(v204, vaddq_f32(vaddq_f32(v181, vmulq_f32(v184, v204)), vmulq_f32(vmulq_f32(v204, v204), vaddq_f32(v179, vmulq_f32(v182, v204))))))), v186);
    float32x4_t v206 = vcvtq_f32_s32(vcvtq_s32_f32(v205));
    float32x4_t v207 = vsubq_f32(v206, (float32x4_t)vandq_s8((int8x16_t)v198, (int8x16_t)vcgtq_f32(v206, v205)));
    float32x4_t v208 = vsubq_f32(v205, v207);
    int8x16_t v209 = vbslq_s8(v197, (int8x16_t)vmulq_f32(vaddq_f32(v198, vmulq_f32(v208, vaddq_f32(v192, vmulq_f32(v208, vaddq_f32(v187, vmulq_f32(v193, v208)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v207), v196), 0x17uLL)), (int8x16_t)v194);
    int8x16_t v210 = *(int8x16_t *)(v170 + 320);
    float32x4_t v211 = *(float32x4_t *)(v170 + 336);
    float32x4_t v212 = (float32x4_t)vbslq_s8(v210, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v200, v200, 8uLL), vmulq_lane_f32(v198, *(float32x2_t *)v209.i8, 1)), v209);
    float32x4_t v213 = (float32x4_t)vextq_s8((int8x16_t)v212, (int8x16_t)v212, 8uLL);
    float32x4_t v214 = vaddq_f32(v195, vmulq_f32(v211, v213));
    float32x4_t v215 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v170, (int8x16_t)v214), (int8x16_t)v195);
    float32x4_t v216 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v214, 0x17uLL)), (float32x4_t)vandq_s8(v174, (int8x16_t)vcgtq_f32(v173, v214))), v175);
    float32x4_t v217 = (float32x4_t)vandq_s8((int8x16_t)v195, (int8x16_t)vcgtq_f32(v215, v176));
    float32x4_t v218 = vsubq_f32(vsubq_f32(v215, v195), vmulq_f32(vmulq_f32(v178, v217), v215));
    float32x4_t v219 = vaddq_f32(vaddq_f32(v216, v217), vmulq_f32(v218, vaddq_f32(vaddq_f32(v181, vmulq_f32(v184, v218)), vmulq_f32(vmulq_f32(v218, v218), vaddq_f32(v179, vmulq_f32(v182, v218))))));
    float32x4_t v220 = *(float32x4_t *)(v170 + 352);
    int32x4_t v221 = *(int32x4_t *)(v170 + 368);
    int32x4_t v222 = (int32x4_t)vmulq_f32(v220, v219);
    int64x2_t v223 = (int64x2_t)vandq_s8((int8x16_t)v211, (int8x16_t)vcgtq_f32(v220, (float32x4_t)vextq_s8((int8x16_t)v222, (int8x16_t)v222, 8uLL)));
    v176.i64[0] = v222.i64[0];
    v176.i64[1] = v223.i64[1];
    v222.i64[1] = vdupq_laneq_s64(v223, 1).u64[0];
    int32x4_t v224 = (int32x4_t)vbslq_s8(v197, vandq_s8((int8x16_t)v211, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v222), v220)), (int8x16_t)v176);
    float32x4_t v225 = vminq_f32((float32x4_t)vextq_s8((int8x16_t)v224, (int8x16_t)v224, 8uLL), (float32x4_t)vrev64q_s32(v224));
    v176.i64[0] = v224.i64[0];
    v176.i64[1] = v225.i64[1];
    v224.i64[1] = vdupq_laneq_s64((int64x2_t)v225, 1).u64[0];
    int32x4_t v226 = (int32x4_t)vbslq_s8(v197, vandq_s8((int8x16_t)v211, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v224), v220)), (int8x16_t)v176);
    int8x16_t v227 = vbslq_s8(v210, vandq_s8((int8x16_t)v211, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32(v226)), v192)), (int8x16_t)v226);
    *(int8x8_t *)v225.f32 = vqtbl1_s8(v227, *(int8x8_t *)v221.i8);
    v224.i64[0] = vextq_s8((int8x16_t)v221, (int8x16_t)v221, 8uLL).u64[0];
    *(int8x8_t *)&v225.u32[2] = vqtbl1_s8(v227, *(int8x8_t *)v224.i8);
    int8x16_t v228 = *(int8x16_t *)(v170 + 384);
    float32x4_t v229 = (float32x4_t)vbslq_s8(v228, v227, (int8x16_t)vminq_f32((float32x4_t)vdupq_lane_s64(v227.i64[0], 0), v225));
    float32x4_t v230 = *(float32x4_t *)(v170 + 432);
    float32x4_t v231 = vaddq_f32(*(float32x4_t *)(v170 + 400), vmulq_n_f32(*(float32x4_t *)(v170 + 416), v229.f32[0]));
    int8x16_t v232 = vbslq_s8(v228, (int8x16_t)vaddq_f32(v230, vmulq_f32(v231, v229)), (int8x16_t)v231);
    float32x4_t v233 = vsubq_f32(v212, (float32x4_t)vdupq_laneq_s32((int32x4_t)v212, 2));
    v229.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v229, v230), vextq_s8(v232, v232, 4uLL), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v232, 0)).i64[1];
    int32x4_t v234 = (int32x4_t)vbslq_s8(v228, (int8x16_t)vaddq_f32(v178, vmulq_f32(v178, v229)), (int8x16_t)v229);
    float32x4_t v235 = *(float32x4_t *)(v170 + 448);
    float32x4_t v236 = *(float32x4_t *)(v170 + 464);
    *(int8x8_t *)v184.f32 = vext_s8(*(int8x8_t *)v233.f32, *(int8x8_t *)v213.f32, 4uLL);
    *(int8x8_t *)&v184.u32[2] = vext_s8(*(int8x8_t *)v213.f32, *(int8x8_t *)v233.f32, 4uLL);
    int8x16_t v237 = (int8x16_t)vmulq_f32(v235, v184);
    float32x4_t v238 = vmaxq_f32(vmulq_f32(v236, (float32x4_t)vbslq_s8(v228, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v234), v235), (int8x16_t)v234, vextq_s8((int8x16_t)v234, (int8x16_t)v234, 0xCuLL)), v237)), v186);
    float32x4_t v239 = vcvtq_f32_s32(vcvtq_s32_f32(v238));
    float32x4_t v240 = vsubq_f32(v239, (float32x4_t)vandq_s8((int8x16_t)v195, (int8x16_t)vcgtq_f32(v239, v238)));
    float32x4_t v241 = vsubq_f32(v238, v240);
    int8x16_t v242 = (int8x16_t)vmulq_f32(vaddq_f32(v195, vmulq_f32(v241, vaddq_f32(v192, vmulq_f32(v241, vaddq_f32(v187, vmulq_f32(v193, v241)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v240), v221), 0x17uLL));
    float32x4_t v243 = *(float32x4_t *)(v170 + 496);
    int8x16_t v244 = (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v228, v242, v237), *(float32x4_t *)(v170 + 480));
    float32x4_t v245 = *(float32x4_t *)(v170 + 512);
    int8x16_t v246 = (int8x16_t)vaddq_f32(v243, vmulq_f32(v245, (float32x4_t)vbslq_s8(v228, v242, v244)));
    float32x4_t v247 = (float32x4_t)vbslq_s8(v228, v246, v244);
    float32x4_t v248 = vminq_f32(vmaxq_f32(vmulq_f32(v245, vrecpeq_f32(v247)), v243), *(float32x4_t *)(v170 + 528));
    v246.i64[0] = vbslq_s8(v228, v246, (int8x16_t)vmulq_n_f32(vmulq_f32(v248, vrecpsq_f32(v247, v248)), v247.f32[0])).u64[0];
    v247.i64[0] = vmulq_lane_f32(v233, *(float32x2_t *)v246.i8, 1).u64[0];
    v247.i64[1] = v212.i64[1];
    float32x4_t v249 = *(float32x4_t *)(v170 + 544);
    int8x16_t v250 = vbslq_s8(v228, (int8x16_t)vmulq_f32(v249, v247), (int8x16_t)v247);
    v193.i64[0] = v246.i64[0];
    v193.i64[1] = vmulq_f32(v249, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v250, 0)).i64[1];
    int8x16_t v251 = vbslq_s8(v210, (int8x16_t)vmaxq_f32(v193, v245), v250);
    *(int8x8_t *)v246.i8 = vorr_s8(vand_s8(*(int8x8_t *)v228.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v246.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v251, v251, 8uLL))), vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v236.f32, *(float32x2_t *)v251.i8), (int8x8_t)*(_OWORD *)&vmvnq_s8(v228)));
    v246.u64[1] = (unint64_t)vqtbl1_s8(v251, *(int8x8_t *)v224.i8);
    *(int8x16_t *)(v5 + v168) = v246;
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2446_Method_A_TMO::GetDOD(HgcBT2446_Method_A_TMO *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2446_Method_A_TMO::GetROI(HgcBT2446_Method_A_TMO *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2446_Method_A_TMO::HgcBT2446_Method_A_TMO(HgcBT2446_Method_A_TMO *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F0280;
  operator new();
}

void sub_1B790DD24(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2446_Method_A_TMO::~HgcBT2446_Method_A_TMO(HGNode *this)
{
  *(void *)this = &unk_1F10F0280;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40897A1F55);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F0280;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40897A1F55);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2446_Method_A_TMO::SetParameter(HgcBT2446_Method_A_TMO *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcBT2446_Method_A_TMO::GetParameter(HgcBT2446_Method_A_TMO *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcBT2446_Method_A_TMO_Input_Clamped::GetProgram(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000007f0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.4166666567, 0.6779999733, 0.2626999915);\n"
             "    const half4 c1 = half4(12.25979805, 1.000000000, 0.05930000171, 0.2681693435);\n"
             "    const half4 c2 = half4(0.7398999929, -1.151000023, 0.9908999801, 1.077000022);\n"
             "    const half4 c3 = half4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
             "    const half4 c4 = half4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
             "    const half4 c5 = half4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmax(r0, c0.xxxx);\n"
             "    r0.xy = pow(r0.xy, c0.yy);\n"
             "    r0.y = r0.y*c0.z;\n"
             "    r1.x = r0.x*c0.w + r0.y;\n"
             "    r0.y = pow(r0.z, c0.y);\n"
             "    r0.z = r0.y*c1.z + r1.x;\n"
             "    r1.x = r0.z*c1.x + c1.y;\n"
             "    r1.x = log2(r1.x);\n"
             "    r1.x = r1.x*c1.w;\n"
             "    r1.z = half(r1.x < c2.z);\n"
             "    r1.y = half(c2.x < r1.x);\n"
             "    r1.w = fmin(r1.y, r1.z);\n"
             "    r1.y = half(c2.x < r1.x);\n"
             "    r1.z = half(-r1.w >= c0.x);\n"
             "    r1.yw = fmin(r1.yy, r1.zw);\n"
             "    r2.xy = r1.xx*c2.yw + c3.xy;\n"
             "    r2.x = r1.x*r2.x + c3.z;\n"
             "    r0.xy = r0.xy - r0.zz;\n"
             "    r1.w = select(r2.y, r2.x, -r1.w < 0.00000h);\n"
             "    r1.x = r1.x*c3.w + c3.w;\n"
             "    r1.x = select(r1.w, r1.x, -r1.y < 0.00000h);\n"
             "    r1.y = r0.z*c4.y;\n"
             "    r1.x = pow(c4.x, r1.x);\n"
             "    r1.y = fmax(r1.y, c4.z);\n"
             "    r1.x = r1.x*c4.w + -c4.w;\n"
             "    r1.y = r1.x/r1.y;\n"
             "    r0.xy = r0.xy*r1.yy;\n"
             "    r0.x = r0.x*c5.x;\n"
             "    r1.z = r0.x*c5.y;\n"
             "    r0.z = fmax(r1.z, c3.y);\n"
             "    output.color0.x = float(r1.x) - float(r0.z);\n"
             "    output.color0.y = float(r0.y)*float(c5.z);\n"
             "    output.color0.zw = float2(r0.xw);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cc0a64d2:44602f95:51ae6a6f:b8abc699\n"
             "//SIG=00400000:00000001:00000001:00000001:0006:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000007d6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.4166666567, 0.6779999733, 0.2626999915);\n"
             "    const float4 c1 = float4(12.25979805, 1.000000000, 0.05930000171, 0.2681693435);\n"
             "    const float4 c2 = float4(0.7398999929, -1.151000023, 0.9908999801, 1.077000022);\n"
             "    const float4 c3 = float4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
             "    const float4 c4 = float4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
             "    const float4 c5 = float4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmax(r0, c0.xxxx);\n"
             "    r0.xy = pow(r0.xy, c0.yy);\n"
             "    r0.y = r0.y*c0.z;\n"
             "    r1.x = r0.x*c0.w + r0.y;\n"
             "    r0.y = pow(r0.z, c0.y);\n"
             "    r0.z = r0.y*c1.z + r1.x;\n"
             "    r1.x = r0.z*c1.x + c1.y;\n"
             "    r1.x = log2(r1.x);\n"
             "    r1.x = r1.x*c1.w;\n"
             "    r1.z = float(r1.x < c2.z);\n"
             "    r1.y = float(c2.x < r1.x);\n"
             "    r1.w = fmin(r1.y, r1.z);\n"
             "    r1.y = float(c2.x < r1.x);\n"
             "    r1.z = float(-r1.w >= c0.x);\n"
             "    r1.yw = fmin(r1.yy, r1.zw);\n"
             "    r2.xy = r1.xx*c2.yw + c3.xy;\n"
             "    r2.x = r1.x*r2.x + c3.z;\n"
             "    r0.xy = r0.xy - r0.zz;\n"
             "    r1.w = select(r2.y, r2.x, -r1.w < 0.00000f);\n"
             "    r1.x = r1.x*c3.w + c3.w;\n"
             "    r1.x = select(r1.w, r1.x, -r1.y < 0.00000f);\n"
             "    r1.y = r0.z*c4.y;\n"
             "    r1.x = pow(c4.x, r1.x);\n"
             "    r1.y = fmax(r1.y, c4.z);\n"
             "    r1.x = r1.x*c4.w + -c4.w;\n"
             "    r1.y = r1.x/r1.y;\n"
             "    r0.xy = r0.xy*r1.yy;\n"
             "    r0.x = r0.x*c5.x;\n"
             "    r1.z = r0.x*c5.y;\n"
             "    r0.z = fmax(r1.z, c3.y);\n"
             "    output.color0.x = r1.x - r0.z;\n"
             "    output.color0.y = r0.y*c5.z;\n"
             "    output.color0.zw = r0.xw;\n"
             "    return output;\n"
             "}\n"
             "//MD5=cfc8a029:e305a50f:078af61c:309e7d5a\n"
             "//SIG=00000000:00000001:00000001:00000000:0006:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000077a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.4166666567, 0.6779999733, 0.2626999915);\n"
           "    const mediump vec4 c1 = vec4(12.25979805, 1.000000000, 0.05930000171, 0.2681693435);\n"
           "    const mediump vec4 c2 = vec4(0.7398999929, -1.151000023, 0.9908999801, 1.077000022);\n"
           "    const mediump vec4 c3 = vec4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
           "    const mediump vec4 c4 = vec4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
           "    const mediump vec4 c5 = vec4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = max(r0, c0.xxxx);\n"
           "    r0.xy = pow(r0.xy, c0.yy);\n"
           "    r0.y = r0.y*c0.z;\n"
           "    r1.x = r0.x*c0.w + r0.y;\n"
           "    r0.y = pow(r0.z, c0.y);\n"
           "    r0.z = r0.y*c1.z + r1.x;\n"
           "    r1.x = r0.z*c1.x + c1.y;\n"
           "    r1.x = log2(r1.x);\n"
           "    r1.x = r1.x*c1.w;\n"
           "    r1.z = float(r1.x < c2.z);\n"
           "    r1.y = float(c2.x < r1.x);\n"
           "    r1.w = min(r1.y, r1.z);\n"
           "    r1.y = float(c2.x < r1.x);\n"
           "    r1.z = float(-r1.w >= c0.x);\n"
           "    r1.yw = min(r1.yy, r1.zw);\n"
           "    r2.xy = r1.xx*c2.yw + c3.xy;\n"
           "    r2.x = r1.x*r2.x + c3.z;\n"
           "    r0.xy = r0.xy - r0.zz;\n"
           "    r1.w = -r1.w < 0.00000 ? r2.x : r2.y;\n"
           "    r1.x = r1.x*c3.w + c3.w;\n"
           "    r1.x = -r1.y < 0.00000 ? r1.x : r1.w;\n"
           "    r1.y = r0.z*c4.y;\n"
           "    r1.x = pow(c4.x, r1.x);\n"
           "    r1.y = max(r1.y, c4.z);\n"
           "    r1.x = r1.x*c4.w + -c4.w;\n"
           "    r1.y = r1.x/r1.y;\n"
           "    r0.xy = r0.xy*r1.yy;\n"
           "    r0.x = r0.x*c5.x;\n"
           "    r1.z = r0.x*c5.y;\n"
           "    r0.z = max(r1.z, c3.y);\n"
           "    gl_FragColor.x = r1.x - r0.z;\n"
           "    gl_FragColor.y = r0.y*c5.z;\n"
           "    gl_FragColor.zw = r0.xw;\n"
           "}\n"
           "//MD5=714dff85:561e4c87:9a5079b2:1332a3ac\n"
           "//SIG=00000000:00000001:00000001:00000000:0006:0000:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2446_Method_A_TMO_Input_Clamped::InitProgramDescriptor(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2446_Method_A_TMO_Input_Clamped_hgc_visible", "//Metal1.0     \n//LEN=00000006c4\n[[ visible ]] FragmentOut HgcBT2446_Method_A_TMO_Input_Clamped_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.4166666567, 0.6779999733, 0.2626999915);\n"
    "    const float4 c1 = float4(12.25979805, 1.000000000, 0.05930000171, 0.2681693435);\n"
    "    const float4 c2 = float4(0.7398999929, -1.151000023, 0.9908999801, 1.077000022);\n"
    "    const float4 c3 = float4(2.781100035, 0.000000000, -0.6302000284, 0.5000000000);\n"
    "    const float4 c4 = float4(5.696958065, 1.100000024, 5.960464478e-08, 0.2129037529);\n"
    "    const float4 c5 = float4(0.6781499982, 0.1000000015, 0.5315190554, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = fmax(r0, c0.xxxx);\n"
    "    r0.xy = pow(r0.xy, c0.yy);\n"
    "    r0.y = r0.y*c0.z;\n"
    "    r1.x = r0.x*c0.w + r0.y;\n"
    "    r0.y = pow(r0.z, c0.y);\n"
    "    r0.z = r0.y*c1.z + r1.x;\n"
    "    r1.x = r0.z*c1.x + c1.y;\n"
    "    r1.x = log2(r1.x);\n"
    "    r1.x = r1.x*c1.w;\n"
    "    r1.z = float(r1.x < c2.z);\n"
    "    r1.y = float(c2.x < r1.x);\n"
    "    r1.w = fmin(r1.y, r1.z);\n"
    "    r1.y = float(c2.x < r1.x);\n"
    "    r1.z = float(-r1.w >= c0.x);\n"
    "    r1.yw = fmin(r1.yy, r1.zw);\n"
    "    r2.xy = r1.xx*c2.yw + c3.xy;\n"
    "    r2.x = r1.x*r2.x + c3.z;\n"
    "    r0.xy = r0.xy - r0.zz;\n"
    "    r1.w = select(r2.y, r2.x, -r1.w < 0.00000f);\n"
    "    r1.x = r1.x*c3.w + c3.w;\n"
    "    r1.x = select(r1.w, r1.x, -r1.y < 0.00000f);\n"
    "    r1.y = r0.z*c4.y;\n"
    "    r1.x = pow(c4.x, r1.x);\n"
    "    r1.y = fmax(r1.y, c4.z);\n"
    "    r1.x = r1.x*c4.w + -c4.w;\n"
    "    r1.y = r1.x/r1.y;\n"
    "    r0.xy = r0.xy*r1.yy;\n"
    "    r0.x = r0.x*c5.x;\n"
    "    r1.z = r0.x*c5.y;\n"
    "    r0.z = fmax(r1.z, c3.y);\n"
    "    output.color0.x = r1.x - r0.z;\n"
    "    output.color0.y = r0.y*c5.z;\n"
    "    output.color0.zw = r0.xw;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2446_Method_A_TMO_Input_Clamped");
}

void sub_1B790E100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B790E130(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B790E128);
}

double HgcBT2446_Method_A_TMO_Input_Clamped::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x30uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B7EC1860;
  strcpy(v3, "HgcBT2446_Method_A_TMO_Input_Clamped [hgc1]");
  return *(double *)"t_Clamped [hgc1]";
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::BindTexture(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::Bind(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::RenderTile(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v156 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      uint64_t v11 = *((void *)this + 51);
      int8x16_t v12 = *(int8x16_t *)(v11 + 16);
      float32x4_t v13 = vmaxq_f32(*(float32x4_t *)(v6 + v10 - 16), *(float32x4_t *)v11);
      float32x4_t v14 = vmaxq_f32(*(float32x4_t *)(v6 + v10), *(float32x4_t *)v11);
      float32x4_t v16 = *(float32x4_t *)(v11 + 32);
      float32x4_t v15 = *(float32x4_t *)(v11 + 48);
      float32x4_t v17 = (float32x4_t)vorrq_s8(vandq_s8(v12, (int8x16_t)v13), (int8x16_t)v16);
      float32x4_t v18 = (float32x4_t)vorrq_s8(vandq_s8(v12, (int8x16_t)v14), (int8x16_t)v16);
      int8x16_t v19 = *(int8x16_t *)(v11 + 64);
      float32x4_t v20 = *(float32x4_t *)(v11 + 80);
      float32x4_t v22 = *(float32x4_t *)(v11 + 96);
      float32x4_t v21 = *(float32x4_t *)(v11 + 112);
      float32x4_t v23 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v17, v22));
      float32x4_t v24 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v18, v22));
      float32x4_t v25 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v13, 0x17uLL)), (float32x4_t)vandq_s8(v19, (int8x16_t)vcgtq_f32(v15, v13))), v20), v23);
      float32x4_t v26 = vsubq_f32(vsubq_f32(v17, v16), vmulq_f32(vmulq_f32(v21, v23), v17));
      float32x4_t v27 = vsubq_f32(vsubq_f32(v18, v16), vmulq_f32(vmulq_f32(v21, v24), v18));
      float32x4_t v28 = *(float32x4_t *)(v11 + 128);
      float32x4_t v29 = *(float32x4_t *)(v11 + 144);
      float32x4_t v30 = *(float32x4_t *)(v11 + 160);
      float32x4_t v31 = *(float32x4_t *)(v11 + 176);
      float32x4_t v32 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v14, 0x17uLL)), (float32x4_t)vandq_s8(v19, (int8x16_t)vcgtq_f32(v15, v14))), v20), v24), vmulq_f32(v27, vaddq_f32(vaddq_f32(v30, vmulq_f32(v27, v31)), vmulq_f32(vmulq_f32(v27, v27), vaddq_f32(v28, vmulq_f32(v29, v27))))));
      float32x4_t v34 = *(float32x4_t *)(v11 + 192);
      float32x4_t v33 = *(float32x4_t *)(v11 + 208);
      float32x4_t v35 = vmaxq_f32(vmulq_f32(v34, vaddq_f32(v25, vmulq_f32(v26, vaddq_f32(vaddq_f32(v30, vmulq_f32(v26, v31)), vmulq_f32(vmulq_f32(v26, v26), vaddq_f32(v28, vmulq_f32(v29, v26))))))), v33);
      float32x4_t v36 = vmaxq_f32(vmulq_f32(v34, v32), v33);
      float32x4_t v37 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
      float32x4_t v38 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
      float32x4_t v39 = vsubq_f32(v37, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v37, v35)));
      float32x4_t v40 = vsubq_f32(v38, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v38, v36)));
      float32x4_t v41 = vsubq_f32(v35, v39);
      float32x4_t v42 = *(float32x4_t *)(v11 + 224);
      float32x4_t v43 = *(float32x4_t *)(v11 + 240);
      float32x4_t v44 = vsubq_f32(v36, v40);
      float32x4_t v45 = *(float32x4_t *)(v11 + 256);
      int32x4_t v46 = *(int32x4_t *)(v11 + 272);
      v41.i64[0] = vmulq_f32(vaddq_f32(v16, vmulq_f32(v41, vaddq_f32(v45, vmulq_f32(v41, vaddq_f32(v42, vmulq_f32(v43, v41)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v46, vcvtq_s32_f32(v39)), 0x17uLL)).u64[0];
      v39.i64[0] = vmulq_f32(vaddq_f32(v16, vmulq_f32(v44, vaddq_f32(v45, vmulq_f32(v44, vaddq_f32(v42, vmulq_f32(v43, v44)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v46, vcvtq_s32_f32(v40)), 0x17uLL)).u64[0];
      v41.i64[1] = v13.i64[1];
      v39.i64[1] = v14.i64[1];
      float32x4_t v47 = *(float32x4_t *)(v11 + 288);
      float32x4_t v48 = *(float32x4_t *)(v11 + 304);
      float32x4_t v49 = (float32x4_t)vbslq_s8((int8x16_t)v48, (int8x16_t)vmulq_f32(v47, v41), (int8x16_t)v41);
      float32x4_t v50 = (float32x4_t)vbslq_s8((int8x16_t)v48, (int8x16_t)vmulq_f32(v47, v39), (int8x16_t)v39);
      float32x4_t v51 = *(float32x4_t *)(v11 + 320);
      int8x16_t v52 = *(int8x16_t *)(v11 + 336);
      int8x16_t v53 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v49), vmulq_lane_f32(v49, *(float32x2_t *)v51.f32, 1));
      float32x4_t v54 = (float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 4uLL);
      float32x4_t v55 = (float32x4_t)vextq_s8((int8x16_t)v50, (int8x16_t)v50, 4uLL);
      float32x4_t v56 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v54, v12), (int8x16_t)v16);
      float32x4_t v57 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v55, v12), (int8x16_t)v16);
      float32x4_t v58 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v56, v22));
      float32x4_t v59 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v57, v22));
      float32x4_t v60 = vsubq_f32(vsubq_f32(v56, v16), vmulq_f32(vmulq_f32(v21, v58), v56));
      float32x4_t v61 = vsubq_f32(vsubq_f32(v57, v16), vmulq_f32(vmulq_f32(v21, v59), v57));
      float32x4_t v62 = vmaxq_f32(vmulq_f32(v34, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v54, 0x17uLL)), (float32x4_t)vandq_s8(v19, (int8x16_t)vcgtq_f32(v15, v54))), v20), v58), vmulq_f32(v60, vaddq_f32(vaddq_f32(v30, vmulq_f32(v31, v60)), vmulq_f32(vmulq_f32(v60, v60), vaddq_f32(v28, vmulq_f32(v29, v60))))))), v33);
      float32x4_t v63 = vmaxq_f32(vmulq_f32(v34, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v55, 0x17uLL)), (float32x4_t)vandq_s8(v19, (int8x16_t)vcgtq_f32(v15, v55))), v20), v59), vmulq_f32(v61, vaddq_f32(vaddq_f32(v30, vmulq_f32(v31, v61)), vmulq_f32(vmulq_f32(v61, v61), vaddq_f32(v28, vmulq_f32(v29, v61))))))), v33);
      int8x16_t v64 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v50), vmulq_lane_f32(v50, *(float32x2_t *)v51.f32, 1));
      float32x4_t v65 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
      float32x4_t v66 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
      float32x4_t v67 = vsubq_f32(v65, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v65, v62)));
      float32x4_t v68 = vsubq_f32(v66, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v66, v63)));
      float32x4_t v69 = vsubq_f32(v62, v67);
      float32x4_t v70 = vsubq_f32(v63, v68);
      float32x4_t v71 = vaddq_f32(v16, vmulq_f32(v69, vaddq_f32(v45, vmulq_f32(v69, vaddq_f32(v42, vmulq_f32(v43, v69))))));
      float32x4_t v72 = vaddq_f32(v16, vmulq_f32(v70, vaddq_f32(v45, vmulq_f32(v70, vaddq_f32(v42, vmulq_f32(v43, v70))))));
      int8x16_t v73 = vbslq_s8((int8x16_t)v48, (int8x16_t)vmulq_f32(v71, (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v67), v46), 0x17uLL)), (int8x16_t)v41);
      int8x16_t v74 = vbslq_s8((int8x16_t)v48, (int8x16_t)vmulq_f32(v72, (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v68), v46), 0x17uLL)), (int8x16_t)v39);
      float32x4_t v75 = (float32x4_t)vbslq_s8(v52, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v53, v53, 8uLL), vmulq_lane_f32(v51, *(float32x2_t *)v73.i8, 1)), v73);
      float32x4_t v76 = (float32x4_t)vbslq_s8(v52, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v64, v64, 8uLL), vmulq_lane_f32(v51, *(float32x2_t *)v74.i8, 1)), v74);
      float32x4_t v77 = (float32x4_t)vextq_s8((int8x16_t)v75, (int8x16_t)v75, 8uLL);
      float32x4_t v78 = (float32x4_t)vextq_s8((int8x16_t)v76, (int8x16_t)v76, 8uLL);
      float32x4_t v79 = *(float32x4_t *)(v11 + 352);
      float32x4_t v80 = *(float32x4_t *)(v11 + 368);
      float32x4_t v81 = vaddq_f32(v51, vmulq_f32(v79, v77));
      float32x4_t v82 = vaddq_f32(v51, vmulq_f32(v79, v78));
      float32x4_t v83 = (float32x4_t)vandq_s8(v19, (int8x16_t)vcgtq_f32(v15, v81));
      float32x4_t v84 = (float32x4_t)vandq_s8(v19, (int8x16_t)vcgtq_f32(v15, v82));
      float32x4_t v85 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v81, 0x17uLL)), v83);
      float32x4_t v86 = (float32x4_t)vorrq_s8(vandq_s8(v12, (int8x16_t)v81), (int8x16_t)v51);
      float32x4_t v87 = (float32x4_t)vorrq_s8(vandq_s8(v12, (int8x16_t)v82), (int8x16_t)v51);
      float32x4_t v88 = vsubq_f32(v85, v20);
      float32x4_t v89 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v82, 0x17uLL)), v84), v20);
      float32x4_t v90 = (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v86, v22));
      float32x4_t v91 = (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v87, v22));
      float32x4_t v92 = vaddq_f32(v88, v90);
      float32x4_t v93 = vsubq_f32(vsubq_f32(v86, v51), vmulq_f32(vmulq_f32(v21, v90), v86));
      float32x4_t v94 = vsubq_f32(vsubq_f32(v87, v51), vmulq_f32(vmulq_f32(v21, v91), v87));
      float32x4_t v95 = vaddq_f32(vaddq_f32(v89, v91), vmulq_f32(v94, vaddq_f32(vaddq_f32(v30, vmulq_f32(v31, v94)), vmulq_f32(vmulq_f32(v94, v94), vaddq_f32(v28, vmulq_f32(v29, v94))))));
      int32x4_t v96 = (int32x4_t)vmulq_f32(v80, vaddq_f32(v92, vmulq_f32(v93, vaddq_f32(vaddq_f32(v30, vmulq_f32(v31, v93)), vmulq_f32(vmulq_f32(v93, v93), vaddq_f32(v28, vmulq_f32(v29, v93)))))));
      int32x4_t v97 = (int32x4_t)vmulq_f32(v80, v95);
      int64x2_t v98 = (int64x2_t)vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32(v80, (float32x4_t)vextq_s8((int8x16_t)v96, (int8x16_t)v96, 8uLL)));
      int64x2_t v99 = (int64x2_t)vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32(v80, (float32x4_t)vextq_s8((int8x16_t)v97, (int8x16_t)v97, 8uLL)));
      v91.i64[0] = v96.i64[0];
      v28.i64[0] = v97.i64[0];
      v91.i64[1] = v98.i64[1];
      v28.i64[1] = v99.i64[1];
      v96.i64[1] = vdupq_laneq_s64(v98, 1).u64[0];
      v97.i64[1] = vdupq_laneq_s64(v99, 1).u64[0];
      int32x4_t v100 = (int32x4_t)vbslq_s8((int8x16_t)v48, vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v96), v80)), (int8x16_t)v91);
      int32x4_t v101 = (int32x4_t)vbslq_s8((int8x16_t)v48, vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v97), v80)), (int8x16_t)v28);
      int64x2_t v102 = (int64x2_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v100, (int8x16_t)v100, 8uLL), (float32x4_t)vrev64q_s32(v100));
      int64x2_t v103 = (int64x2_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v101, (int8x16_t)v101, 8uLL), (float32x4_t)vrev64q_s32(v101));
      v91.i64[0] = v100.i64[0];
      v91.i64[1] = v102.i64[1];
      v28.i64[0] = v101.i64[0];
      v28.i64[1] = v103.i64[1];
      v100.i64[1] = vdupq_laneq_s64(v102, 1).u64[0];
      v101.i64[1] = vdupq_laneq_s64(v103, 1).u64[0];
      int32x4_t v104 = (int32x4_t)vbslq_s8((int8x16_t)v48, vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v100), v80)), (int8x16_t)v91);
      int32x4_t v105 = (int32x4_t)vbslq_s8((int8x16_t)v48, vandq_s8((int8x16_t)v79, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v101), v80)), (int8x16_t)v28);
      int8x16_t v106 = vbslq_s8(v52, vandq_s8((int8x16_t)v79, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32(v104)), v45)), (int8x16_t)v104);
      int8x16_t v107 = vbslq_s8(v52, vandq_s8((int8x16_t)v79, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32(v105)), v45)), (int8x16_t)v105);
      int32x4_t v109 = *(int32x4_t *)(v11 + 384);
      int8x16_t v108 = *(int8x16_t *)(v11 + 400);
      *(int8x8_t *)v30.f32 = vqtbl1_s8(v106, *(int8x8_t *)v109.i8);
      v104.i64[0] = vextq_s8((int8x16_t)v109, (int8x16_t)v109, 8uLL).u64[0];
      *(int8x8_t *)&v30.u32[2] = vqtbl1_s8(v106, *(int8x8_t *)v104.i8);
      *(int8x8_t *)v31.f32 = vqtbl1_s8(v107, *(int8x8_t *)v109.i8);
      *(int8x8_t *)&v31.u32[2] = vqtbl1_s8(v107, *(int8x8_t *)v104.i8);
      int8x16_t v110 = (int8x16_t)vminq_f32((float32x4_t)vdupq_lane_s64(v107.i64[0], 0), v31);
      float32x4_t v111 = (float32x4_t)vbslq_s8(v108, v106, (int8x16_t)vminq_f32((float32x4_t)vdupq_lane_s64(v106.i64[0], 0), v30));
      float32x4_t v112 = *(float32x4_t *)(v11 + 416);
      float32x4_t v113 = *(float32x4_t *)(v11 + 432);
      float32x4_t v114 = (float32x4_t)vbslq_s8(v108, v107, v110);
      float32x4_t v115 = vaddq_f32(v112, vmulq_n_f32(v113, v111.f32[0]));
      float32x4_t v116 = vaddq_f32(v112, vmulq_n_f32(v113, v114.f32[0]));
      float32x4_t v118 = *(float32x4_t *)(v11 + 448);
      float32x4_t v117 = *(float32x4_t *)(v11 + 464);
      int8x16_t v119 = vbslq_s8(v108, (int8x16_t)vaddq_f32(v118, vmulq_f32(v115, v111)), (int8x16_t)v115);
      float32x4_t v120 = (float32x4_t)vbslq_s8(v108, (int8x16_t)vaddq_f32(v118, vmulq_f32(v116, v114)), (int8x16_t)v116);
      v111.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v111, v118), vextq_s8(v119, v119, 4uLL), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v119, 0)).i64[1];
      int32x4_t v121 = (int32x4_t)vbslq_s8(v108, (int8x16_t)vaddq_f32(v21, vmulq_f32(v21, v111)), (int8x16_t)v111);
      v114.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v114, v118), vextq_s8(*(int8x16_t *)&v120, *(int8x16_t *)&v120, 4uLL), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v120, 0)).i64[1];
      int32x4_t v122 = (int32x4_t)vbslq_s8(v108, (int8x16_t)vaddq_f32(v21, vmulq_f32(v21, v114)), (int8x16_t)v114);
      int8x16_t v123 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v122), *(float32x4_t *)v11), (int8x16_t)v122, vextq_s8((int8x16_t)v122, (int8x16_t)v122, 0xCuLL));
      float32x4_t v124 = vsubq_f32(v75, (float32x4_t)vdupq_laneq_s32((int32x4_t)v75, 2));
      float32x4_t v125 = vsubq_f32(v76, (float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 2));
      *(int8x8_t *)v120.f32 = vext_s8(*(int8x8_t *)v124.f32, *(int8x8_t *)v77.f32, 4uLL);
      *(int8x8_t *)&v120.u32[2] = vext_s8(*(int8x8_t *)v77.f32, *(int8x8_t *)v124.f32, 4uLL);
      *(int8x8_t *)v48.f32 = vext_s8(*(int8x8_t *)v125.f32, *(int8x8_t *)v78.f32, 4uLL);
      *(int8x8_t *)&v48.u32[2] = vext_s8(*(int8x8_t *)v78.f32, *(int8x8_t *)v125.f32, 4uLL);
      int8x16_t v126 = (int8x16_t)vmulq_f32(v118, v120);
      int8x16_t v127 = (int8x16_t)vmulq_f32(v118, v48);
      float32x4_t v128 = vmaxq_f32(vmulq_f32(v117, (float32x4_t)vbslq_s8(v108, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v121), *(float32x4_t *)v11), (int8x16_t)v121, vextq_s8((int8x16_t)v121, (int8x16_t)v121, 0xCuLL)), v126)), v33);
      float32x4_t v129 = vmaxq_f32(vmulq_f32(v117, (float32x4_t)vbslq_s8(v108, v123, v127)), v33);
      float32x4_t v130 = vcvtq_f32_s32(vcvtq_s32_f32(v128));
      float32x4_t v131 = vcvtq_f32_s32(vcvtq_s32_f32(v129));
      float32x4_t v132 = vsubq_f32(v130, (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v130, v128)));
      float32x4_t v133 = vsubq_f32(v131, (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v131, v129)));
      float32x4_t v134 = vsubq_f32(v128, v132);
      float32x4_t v135 = vsubq_f32(v129, v133);
      int8x16_t v136 = (int8x16_t)vmulq_f32(vaddq_f32(v51, vmulq_f32(v134, vaddq_f32(v45, vmulq_f32(v134, vaddq_f32(v42, vmulq_f32(v43, v134)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v132), v109), 0x17uLL));
      int8x16_t v137 = (int8x16_t)vmulq_f32(vaddq_f32(v51, vmulq_f32(v135, vaddq_f32(v45, vmulq_f32(v135, vaddq_f32(v42, vmulq_f32(v43, v135)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v133), v109), 0x17uLL));
      float32x4_t v138 = *(float32x4_t *)(v11 + 480);
      float32x4_t v139 = *(float32x4_t *)(v11 + 496);
      int8x16_t v140 = (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v108, v136, v126), v138);
      int8x16_t v141 = (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v108, v137, v127), v138);
      float32x4_t v142 = *(float32x4_t *)(v11 + 512);
      float32x4_t v143 = *(float32x4_t *)(v11 + 528);
      int8x16_t v144 = (int8x16_t)vaddq_f32(v139, vmulq_f32(v142, (float32x4_t)vbslq_s8(v108, v136, v140)));
      int8x16_t v145 = (int8x16_t)vaddq_f32(v139, vmulq_f32(v142, (float32x4_t)vbslq_s8(v108, v137, v141)));
      float32x4_t v146 = (float32x4_t)vbslq_s8(v108, v144, v140);
      float32x4_t v147 = (float32x4_t)vbslq_s8(v108, v145, v141);
      float32x4_t v148 = vminq_f32(vmaxq_f32(vmulq_f32(v142, vrecpeq_f32(v146)), v139), v143);
      float32x4_t v149 = vminq_f32(vmaxq_f32(vmulq_f32(v142, vrecpeq_f32(v147)), v139), v143);
      v144.i64[0] = vbslq_s8(v108, v144, (int8x16_t)vmulq_n_f32(vmulq_f32(v148, vrecpsq_f32(v146, v148)), v146.f32[0])).u64[0];
      v145.i64[0] = vbslq_s8(v108, v145, (int8x16_t)vmulq_n_f32(vmulq_f32(v149, vrecpsq_f32(v147, v149)), v147.f32[0])).u64[0];
      v146.i64[0] = vmulq_lane_f32(v124, *(float32x2_t *)v144.i8, 1).u64[0];
      v125.i64[0] = vmulq_lane_f32(v125, *(float32x2_t *)v145.i8, 1).u64[0];
      v146.i64[1] = v75.i64[1];
      v125.i64[1] = v76.i64[1];
      float32x4_t v150 = *(float32x4_t *)(v11 + 544);
      int8x16_t v151 = vbslq_s8(v108, (int8x16_t)vmulq_f32(v150, v146), (int8x16_t)v146);
      int8x16_t v152 = vbslq_s8(v108, (int8x16_t)vmulq_f32(v150, v125), (int8x16_t)v125);
      v143.i64[0] = v144.i64[0];
      v143.i64[1] = vmulq_f32(v150, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v151, 0)).i64[1];
      v149.i64[0] = v145.i64[0];
      v149.i64[1] = vmulq_f32(v150, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v152, 0)).i64[1];
      int8x16_t v153 = vbslq_s8(v52, (int8x16_t)vmaxq_f32(v143, v142), v151);
      int8x16_t v154 = vbslq_s8(v52, (int8x16_t)vmaxq_f32(v149, v142), v152);
      v150.i64[0] = vmvnq_s8(v108).u64[0];
      *(int8x8_t *)v144.i8 = vorr_s8(vand_s8(*(int8x8_t *)v108.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v144.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v153, v153, 8uLL))), vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v117.f32, *(float32x2_t *)v153.i8), *(int8x8_t *)v150.f32));
      v144.u64[1] = (unint64_t)vqtbl1_s8(v153, *(int8x8_t *)v104.i8);
      *(int8x8_t *)v145.i8 = vorr_s8(vand_s8(*(int8x8_t *)v108.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v145.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v154, v154, 8uLL))), vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v117.f32, *(float32x2_t *)v154.i8), *(int8x8_t *)v150.f32));
      v145.u64[1] = (unint64_t)vqtbl1_s8(v154, *(int8x8_t *)v104.i8);
      int8x16_t v155 = (int8x16_t *)(v5 + v10);
      v155[-1] = v144;
      *int8x16_t v155 = v145;
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v156 = -v9;
    if (v156 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v157 = 16 * v156;
    uint64_t v158 = *((void *)this + 51);
    int8x16_t v159 = *(int8x16_t *)(v158 + 16);
    float32x4_t v160 = vmaxq_f32(*(float32x4_t *)(v6 + v157), *(float32x4_t *)v158);
    float32x4_t v162 = *(float32x4_t *)(v158 + 32);
    float32x4_t v161 = *(float32x4_t *)(v158 + 48);
    float32x4_t v163 = (float32x4_t)vorrq_s8(vandq_s8(v159, (int8x16_t)v160), (int8x16_t)v162);
    int8x16_t v164 = *(int8x16_t *)(v158 + 64);
    float32x4_t v165 = *(float32x4_t *)(v158 + 80);
    float32x4_t v167 = *(float32x4_t *)(v158 + 96);
    float32x4_t v166 = *(float32x4_t *)(v158 + 112);
    float32x4_t v168 = (float32x4_t)vandq_s8((int8x16_t)v162, (int8x16_t)vcgtq_f32(v163, v167));
    float32x4_t v169 = vsubq_f32(vsubq_f32(v163, v162), vmulq_f32(vmulq_f32(v166, v168), v163));
    float32x4_t v170 = *(float32x4_t *)(v158 + 128);
    float32x4_t v171 = *(float32x4_t *)(v158 + 144);
    float32x4_t v172 = *(float32x4_t *)(v158 + 160);
    float32x4_t v173 = *(float32x4_t *)(v158 + 176);
    float32x4_t v174 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v160, 0x17uLL)), (float32x4_t)vandq_s8(v164, (int8x16_t)vcgtq_f32(v161, v160))), v165), v168), vmulq_f32(v169, vaddq_f32(vaddq_f32(v172, vmulq_f32(v169, v173)), vmulq_f32(vmulq_f32(v169, v169), vaddq_f32(v170, vmulq_f32(v171, v169))))));
    float32x4_t v176 = *(float32x4_t *)(v158 + 192);
    float32x4_t v175 = *(float32x4_t *)(v158 + 208);
    float32x4_t v177 = vmaxq_f32(vmulq_f32(v176, v174), v175);
    float32x4_t v178 = vcvtq_f32_s32(vcvtq_s32_f32(v177));
    float32x4_t v179 = vsubq_f32(v178, (float32x4_t)vandq_s8((int8x16_t)v162, (int8x16_t)vcgtq_f32(v178, v177)));
    float32x4_t v180 = vsubq_f32(v177, v179);
    float32x4_t v181 = *(float32x4_t *)(v158 + 224);
    float32x4_t v182 = *(float32x4_t *)(v158 + 240);
    float32x4_t v183 = *(float32x4_t *)(v158 + 256);
    int32x4_t v184 = *(int32x4_t *)(v158 + 272);
    v185.i64[0] = vmulq_f32(vaddq_f32(v162, vmulq_f32(v180, vaddq_f32(v183, vmulq_f32(v180, vaddq_f32(v181, vmulq_f32(v182, v180)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v184, vcvtq_s32_f32(v179)), 0x17uLL)).u64[0];
    v185.i64[1] = v160.i64[1];
    int8x16_t v186 = *(int8x16_t *)(v158 + 304);
    float32x4_t v187 = (float32x4_t)vbslq_s8(v186, (int8x16_t)vmulq_f32(*(float32x4_t *)(v158 + 288), v185), (int8x16_t)v185);
    float32x4_t v188 = *(float32x4_t *)(v158 + 320);
    int8x16_t v189 = *(int8x16_t *)(v158 + 336);
    int8x16_t v190 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v187), vmulq_lane_f32(v187, *(float32x2_t *)v188.f32, 1));
    float32x4_t v191 = (float32x4_t)vextq_s8((int8x16_t)v187, (int8x16_t)v187, 4uLL);
    float32x4_t v192 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v191, v159), (int8x16_t)v162);
    float32x4_t v193 = (float32x4_t)vandq_s8((int8x16_t)v162, (int8x16_t)vcgtq_f32(v192, v167));
    float32x4_t v194 = vsubq_f32(vsubq_f32(v192, v162), vmulq_f32(vmulq_f32(v166, v193), v192));
    float32x4_t v195 = vmaxq_f32(vmulq_f32(v176, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v191, 0x17uLL)), (float32x4_t)vandq_s8(v164, (int8x16_t)vcgtq_f32(v161, v191))), v165), v193), vmulq_f32(v194, vaddq_f32(vaddq_f32(v172, vmulq_f32(v173, v194)), vmulq_f32(vmulq_f32(v194, v194), vaddq_f32(v170, vmulq_f32(v171, v194))))))), v175);
    float32x4_t v196 = vcvtq_f32_s32(vcvtq_s32_f32(v195));
    float32x4_t v197 = vsubq_f32(v196, (float32x4_t)vandq_s8((int8x16_t)v162, (int8x16_t)vcgtq_f32(v196, v195)));
    float32x4_t v198 = vsubq_f32(v195, v197);
    int8x16_t v199 = vbslq_s8(v186, (int8x16_t)vmulq_f32(vaddq_f32(v162, vmulq_f32(v198, vaddq_f32(v183, vmulq_f32(v198, vaddq_f32(v181, vmulq_f32(v182, v198)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v197), v184), 0x17uLL)), (int8x16_t)v185);
    float32x4_t v200 = (float32x4_t)vbslq_s8(v189, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v190, v190, 8uLL), vmulq_lane_f32(v188, *(float32x2_t *)v199.i8, 1)), v199);
    float32x4_t v201 = (float32x4_t)vextq_s8((int8x16_t)v200, (int8x16_t)v200, 8uLL);
    float32x4_t v202 = *(float32x4_t *)(v158 + 352);
    float32x4_t v203 = *(float32x4_t *)(v158 + 368);
    float32x4_t v204 = vaddq_f32(v188, vmulq_f32(v202, v201));
    float32x4_t v205 = (float32x4_t)vorrq_s8(vandq_s8(v159, (int8x16_t)v204), (int8x16_t)v188);
    float32x4_t v206 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v204, 0x17uLL)), (float32x4_t)vandq_s8(v164, (int8x16_t)vcgtq_f32(v161, v204))), v165);
    float32x4_t v207 = (float32x4_t)vandq_s8((int8x16_t)v188, (int8x16_t)vcgtq_f32(v205, v167));
    float32x4_t v208 = vsubq_f32(vsubq_f32(v205, v188), vmulq_f32(vmulq_f32(v166, v207), v205));
    int32x4_t v209 = (int32x4_t)vmulq_f32(v203, vaddq_f32(vaddq_f32(v206, v207), vmulq_f32(v208, vaddq_f32(vaddq_f32(v172, vmulq_f32(v173, v208)), vmulq_f32(vmulq_f32(v208, v208), vaddq_f32(v170, vmulq_f32(v171, v208)))))));
    int64x2_t v210 = (int64x2_t)vandq_s8((int8x16_t)v202, (int8x16_t)vcgtq_f32(v203, (float32x4_t)vextq_s8((int8x16_t)v209, (int8x16_t)v209, 8uLL)));
    v207.i64[0] = v209.i64[0];
    v207.i64[1] = v210.i64[1];
    v209.i64[1] = vdupq_laneq_s64(v210, 1).u64[0];
    int32x4_t v211 = (int32x4_t)vbslq_s8(v186, vandq_s8((int8x16_t)v202, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v209), v203)), (int8x16_t)v207);
    int64x2_t v212 = (int64x2_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v211, (int8x16_t)v211, 8uLL), (float32x4_t)vrev64q_s32(v211));
    v207.i64[0] = v211.i64[0];
    v207.i64[1] = v212.i64[1];
    v211.i64[1] = vdupq_laneq_s64(v212, 1).u64[0];
    int32x4_t v213 = (int32x4_t)vbslq_s8(v186, vandq_s8((int8x16_t)v202, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v211), v203)), (int8x16_t)v207);
    int8x16_t v214 = vbslq_s8(v189, vandq_s8((int8x16_t)v202, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32(v213)), v183)), (int8x16_t)v213);
    int32x4_t v216 = *(int32x4_t *)(v158 + 384);
    int8x16_t v215 = *(int8x16_t *)(v158 + 400);
    *(int8x8_t *)v170.f32 = vqtbl1_s8(v214, *(int8x8_t *)v216.i8);
    v212.i64[0] = vextq_s8((int8x16_t)v216, (int8x16_t)v216, 8uLL).u64[0];
    *(int8x8_t *)&v170.u32[2] = vqtbl1_s8(v214, *(int8x8_t *)v212.i8);
    float32x4_t v217 = (float32x4_t)vbslq_s8(v215, v214, (int8x16_t)vminq_f32((float32x4_t)vdupq_lane_s64(v214.i64[0], 0), v170));
    float32x4_t v218 = vaddq_f32(*(float32x4_t *)(v158 + 416), vmulq_n_f32(*(float32x4_t *)(v158 + 432), v217.f32[0]));
    float32x4_t v219 = *(float32x4_t *)(v158 + 448);
    float32x4_t v220 = *(float32x4_t *)(v158 + 464);
    int8x16_t v221 = vbslq_s8(v215, (int8x16_t)vaddq_f32(v219, vmulq_f32(v218, v217)), (int8x16_t)v218);
    float32x4_t v222 = vsubq_f32(v200, (float32x4_t)vdupq_laneq_s32((int32x4_t)v200, 2));
    v217.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v217, v219), vextq_s8(v221, v221, 4uLL), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v221, 0)).i64[1];
    int32x4_t v223 = (int32x4_t)vbslq_s8(v215, (int8x16_t)vaddq_f32(v166, vmulq_f32(v166, v217)), (int8x16_t)v217);
    *(int8x8_t *)v173.f32 = vext_s8(*(int8x8_t *)v222.f32, *(int8x8_t *)v201.f32, 4uLL);
    *(int8x8_t *)&v173.u32[2] = vext_s8(*(int8x8_t *)v201.f32, *(int8x8_t *)v222.f32, 4uLL);
    int8x16_t v224 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v223), *(float32x4_t *)v158), (int8x16_t)v223, vextq_s8((int8x16_t)v223, (int8x16_t)v223, 0xCuLL));
    int8x16_t v225 = (int8x16_t)vmulq_f32(v219, v173);
    float32x4_t v226 = vmaxq_f32(vmulq_f32(v220, (float32x4_t)vbslq_s8(v215, v224, v225)), v175);
    float32x4_t v227 = vcvtq_f32_s32(vcvtq_s32_f32(v226));
    float32x4_t v228 = vsubq_f32(v227, (float32x4_t)vandq_s8((int8x16_t)v188, (int8x16_t)vcgtq_f32(v227, v226)));
    float32x4_t v229 = vsubq_f32(v226, v228);
    int8x16_t v230 = (int8x16_t)vmulq_f32(vaddq_f32(v188, vmulq_f32(v229, vaddq_f32(v183, vmulq_f32(v229, vaddq_f32(v181, vmulq_f32(v182, v229)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v228), v216), 0x17uLL));
    float32x4_t v231 = *(float32x4_t *)(v158 + 496);
    int8x16_t v232 = (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v215, v230, v225), *(float32x4_t *)(v158 + 480));
    float32x4_t v233 = *(float32x4_t *)(v158 + 512);
    int8x16_t v234 = (int8x16_t)vaddq_f32(v231, vmulq_f32(v233, (float32x4_t)vbslq_s8(v215, v230, v232)));
    float32x4_t v235 = (float32x4_t)vbslq_s8(v215, v234, v232);
    float32x4_t v236 = vminq_f32(vmaxq_f32(vmulq_f32(v233, vrecpeq_f32(v235)), v231), *(float32x4_t *)(v158 + 528));
    v234.i64[0] = vbslq_s8(v215, v234, (int8x16_t)vmulq_n_f32(vmulq_f32(v236, vrecpsq_f32(v235, v236)), v235.f32[0])).u64[0];
    v235.i64[0] = vmulq_lane_f32(v222, *(float32x2_t *)v234.i8, 1).u64[0];
    v235.i64[1] = v200.i64[1];
    float32x4_t v237 = *(float32x4_t *)(v158 + 544);
    int8x16_t v238 = vbslq_s8(v215, (int8x16_t)vmulq_f32(v237, v235), (int8x16_t)v235);
    v182.i64[0] = v234.i64[0];
    v182.i64[1] = vmulq_f32(v237, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v238, 0)).i64[1];
    int8x16_t v239 = vbslq_s8(v189, (int8x16_t)vmaxq_f32(v182, v233), v238);
    *(int8x8_t *)v234.i8 = vorr_s8(vand_s8(*(int8x8_t *)v215.i8, (int8x8_t)vsub_f32(*(float32x2_t *)v234.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v239, v239, 8uLL))), vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v220.f32, *(float32x2_t *)v239.i8), (int8x8_t)*(_OWORD *)&vmvnq_s8(v215)));
    v234.u64[1] = (unint64_t)vqtbl1_s8(v239, *(int8x8_t *)v212.i8);
    *(int8x16_t *)(v5 + v157) = v234;
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::GetDOD(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::GetROI(HgcBT2446_Method_A_TMO_Input_Clamped *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2446_Method_A_TMO_Input_Clamped::HgcBT2446_Method_A_TMO_Input_Clamped(HgcBT2446_Method_A_TMO_Input_Clamped *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F04E8;
  operator new();
}

void sub_1B790F178(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2446_Method_A_TMO_Input_Clamped::~HgcBT2446_Method_A_TMO_Input_Clamped(HGNode *this)
{
  *(void *)this = &unk_1F10F04E8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40897A1F55);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F04E8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40897A1F55);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::SetParameter(HgcBT2446_Method_A_TMO_Input_Clamped *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcBT2446_Method_A_TMO_Input_Clamped::GetParameter(HgcBT2446_Method_A_TMO_Input_Clamped *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcBT2446_Method_A_ITMO::GetProgram(HgcBT2446_Method_A_ITMO *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000069a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(255.0000000, 1.871200038e-05, 2.830500080e-06, 70.00000000);\n"
             "    const half4 c1 = half4(1.252799988, -0.002733400092, -0.0007462200010, 1.314100027);\n"
             "    const half4 c2 = half4(0.000000000, 1.075000048, 1.000000000, 1.474599957);\n"
             "    const half4 c3 = half4(0.001000000047, 1000.000000, -0.1645500064, 2.400000095);\n"
             "    const half4 c4 = half4(1.881399989, -0.5713499784, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = r0.x*c0.x;\n"
             "    r1.yz = r1.xx*c0.yz + c1.yz;\n"
             "    r1.zw = r1.xx*r1.zy + c1.xw;\n"
             "    r1.y = c0.w - r1.x;\n"
             "    r1.y = select(r1.w, r1.z, r1.y < 0.00000h);\n"
             "    r1.x = fmax(r1.x, c2.x);\n"
             "    r1.x = pow(r1.x, r1.y);\n"
             "    r1.y = r1.x/r0.x;\n"
             "    r1.y = r1.y*c2.y;\n"
             "    r0.x = select(c2.z, r1.y, -r0.x < 0.00000h);\n"
             "    r0.xz = r0.yz*r0.xx;\n"
             "    r1.y = r0.z*c2.w + r1.x;\n"
             "    r1.y = fmin(r1.y, c3.y);\n"
             "    r1.y = fmax(r1.y, c2.x);\n"
             "    r0.y = r1.y*c3.x;\n"
             "    r1.y = r0.x*c3.z + r1.x;\n"
             "    output.color0.x = pow(float(r0.y), float(c3.w));\n"
             "    r0.xy = r0.xz*c4.xy + r1.xy;\n"
             "    r0.xy = fmin(r0.xy, c3.yy);\n"
             "    r0.xy = fmax(r0.xy, c2.xx);\n"
             "    r0.xy = r0.xy*c3.xx;\n"
             "    output.color0.yz = pow(float2(r0.yx), float2(c3.ww));\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=52cfe100:87057625:53164afc:07fec1d0\n"
             "//SIG=00400000:00000001:00000001:00000001:0005:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000679\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(255.0000000, 1.871200038e-05, 2.830500080e-06, 70.00000000);\n"
             "    const float4 c1 = float4(1.252799988, -0.002733400092, -0.0007462200010, 1.314100027);\n"
             "    const float4 c2 = float4(0.000000000, 1.075000048, 1.000000000, 1.474599957);\n"
             "    const float4 c3 = float4(0.001000000047, 1000.000000, -0.1645500064, 2.400000095);\n"
             "    const float4 c4 = float4(1.881399989, -0.5713499784, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = r0.x*c0.x;\n"
             "    r1.yz = r1.xx*c0.yz + c1.yz;\n"
             "    r1.zw = r1.xx*r1.zy + c1.xw;\n"
             "    r1.y = c0.w - r1.x;\n"
             "    r1.y = select(r1.w, r1.z, r1.y < 0.00000f);\n"
             "    r1.x = fmax(r1.x, c2.x);\n"
             "    r1.x = pow(r1.x, r1.y);\n"
             "    r1.y = r1.x/r0.x;\n"
             "    r1.y = r1.y*c2.y;\n"
             "    r0.x = select(c2.z, r1.y, -r0.x < 0.00000f);\n"
             "    r0.xz = r0.yz*r0.xx;\n"
             "    r1.y = r0.z*c2.w + r1.x;\n"
             "    r1.y = fmin(r1.y, c3.y);\n"
             "    r1.y = fmax(r1.y, c2.x);\n"
             "    r0.y = r1.y*c3.x;\n"
             "    r1.y = r0.x*c3.z + r1.x;\n"
             "    output.color0.x = pow(r0.y, c3.w);\n"
             "    r0.xy = r0.xz*c4.xy + r1.xy;\n"
             "    r0.xy = fmin(r0.xy, c3.yy);\n"
             "    r0.xy = fmax(r0.xy, c2.xx);\n"
             "    r0.xy = r0.xy*c3.xx;\n"
             "    output.color0.yz = pow(r0.yx, c3.ww);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5fd96646:90622500:0191c3b0:ef8ed030\n"
             "//SIG=00000000:00000001:00000001:00000000:0005:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000619\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(255.0000000, 1.871200038e-05, 2.830500080e-06, 70.00000000);\n"
           "    const mediump vec4 c1 = vec4(1.252799988, -0.002733400092, -0.0007462200010, 1.314100027);\n"
           "    const mediump vec4 c2 = vec4(0.000000000, 1.075000048, 1.000000000, 1.474599957);\n"
           "    const mediump vec4 c3 = vec4(0.001000000047, 1000.000000, -0.1645500064, 2.400000095);\n"
           "    const mediump vec4 c4 = vec4(1.881399989, -0.5713499784, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = r0.x*c0.x;\n"
           "    r1.yz = r1.xx*c0.yz + c1.yz;\n"
           "    r1.zw = r1.xx*r1.zy + c1.xw;\n"
           "    r1.y = c0.w - r1.x;\n"
           "    r1.y = r1.y < 0.00000 ? r1.z : r1.w;\n"
           "    r1.x = max(r1.x, c2.x);\n"
           "    r1.x = pow(r1.x, r1.y);\n"
           "    r1.y = r1.x/r0.x;\n"
           "    r1.y = r1.y*c2.y;\n"
           "    r0.x = -r0.x < 0.00000 ? r1.y : c2.z;\n"
           "    r0.xz = r0.yz*r0.xx;\n"
           "    r1.y = r0.z*c2.w + r1.x;\n"
           "    r1.y = min(r1.y, c3.y);\n"
           "    r1.y = max(r1.y, c2.x);\n"
           "    r0.y = r1.y*c3.x;\n"
           "    r1.y = r0.x*c3.z + r1.x;\n"
           "    gl_FragColor.x = pow(r0.y, c3.w);\n"
           "    r0.xy = r0.xz*c4.xy + r1.xy;\n"
           "    r0.xy = min(r0.xy, c3.yy);\n"
           "    r0.xy = max(r0.xy, c2.xx);\n"
           "    r0.xy = r0.xy*c3.xx;\n"
           "    gl_FragColor.yz = pow(r0.yx, c3.ww);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=4c3db6c5:8c56c001:502585ba:cb00e598\n"
           "//SIG=00000000:00000001:00000001:00000000:0005:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2446_Method_A_ITMO::InitProgramDescriptor(HgcBT2446_Method_A_ITMO *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2446_Method_A_ITMO_hgc_visible", "//Metal1.0     \n//LEN=000000055a\n[[ visible ]] FragmentOut HgcBT2446_Method_A_ITMO_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(255.0000000, 1.871200038e-05, 2.830500080e-06, 70.00000000);\n"
    "    const float4 c1 = float4(1.252799988, -0.002733400092, -0.0007462200010, 1.314100027);\n"
    "    const float4 c2 = float4(0.000000000, 1.075000048, 1.000000000, 1.474599957);\n"
    "    const float4 c3 = float4(0.001000000047, 1000.000000, -0.1645500064, 2.400000095);\n"
    "    const float4 c4 = float4(1.881399989, -0.5713499784, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = r0.x*c0.x;\n"
    "    r1.yz = r1.xx*c0.yz + c1.yz;\n"
    "    r1.zw = r1.xx*r1.zy + c1.xw;\n"
    "    r1.y = c0.w - r1.x;\n"
    "    r1.y = select(r1.w, r1.z, r1.y < 0.00000f);\n"
    "    r1.x = fmax(r1.x, c2.x);\n"
    "    r1.x = pow(r1.x, r1.y);\n"
    "    r1.y = r1.x/r0.x;\n"
    "    r1.y = r1.y*c2.y;\n"
    "    r0.x = select(c2.z, r1.y, -r0.x < 0.00000f);\n"
    "    r0.xz = r0.yz*r0.xx;\n"
    "    r1.y = r0.z*c2.w + r1.x;\n"
    "    r1.y = fmin(r1.y, c3.y);\n"
    "    r1.y = fmax(r1.y, c2.x);\n"
    "    r0.y = r1.y*c3.x;\n"
    "    r1.y = r0.x*c3.z + r1.x;\n"
    "    output.color0.x = pow(r0.y, c3.w);\n"
    "    r0.xy = r0.xz*c4.xy + r1.xy;\n"
    "    r0.xy = fmin(r0.xy, c3.yy);\n"
    "    r0.xy = fmax(r0.xy, c2.xx);\n"
    "    r0.xy = r0.xy*c3.xx;\n"
    "    output.color0.yz = pow(r0.yx, c3.ww);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2446_Method_A_ITMO");
}

void sub_1B790F554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B790F584(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B790F57CLL);
}

double HgcBT2446_Method_A_ITMO::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376180;
  strcpy(v3, "HgcBT2446_Method_A_ITMO [hgc1]");
  return *(double *)"od_A_ITMO [hgc1]";
}

uint64_t HgcBT2446_Method_A_ITMO::BindTexture(HgcBT2446_Method_A_ITMO *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2446_Method_A_ITMO::Bind(HgcBT2446_Method_A_ITMO *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2446_Method_A_ITMO::RenderTile(HgcBT2446_Method_A_ITMO *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v179 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v11 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v12 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = *((void *)this + 51);
      float32x4_t v14 = *(float32x4_t *)(v13 + 16);
      int8x16_t v15 = (int8x16_t)vmulq_f32(v11, *(float32x4_t *)v13);
      int8x16_t v16 = (int8x16_t)vmulq_f32(v12, *(float32x4_t *)v13);
      int8x16_t v17 = *(int8x16_t *)(v13 + 32);
      int8x16_t v18 = *(int8x16_t *)(v13 + 48);
      float32x4_t v19 = (float32x4_t)vbslq_s8(v17, v15, (int8x16_t)vaddq_f32(*(float32x4_t *)v13, vmulq_n_f32(v14, *(float *)v15.i32)));
      int8x8_t v20 = (int8x8_t)vextq_s8(v18, v18, 8uLL).u64[0];
      float32x4_t v21 = (float32x4_t)vbslq_s8(v17, v16, (int8x16_t)vaddq_f32(*(float32x4_t *)v13, vmulq_n_f32(v14, *(float *)v16.i32)));
      *(int8x8_t *)v22.f32 = vqtbl1_s8((int8x16_t)v19, v20);
      v22.i64[1] = v22.i64[0];
      *(int8x8_t *)v23.f32 = vqtbl1_s8((int8x16_t)v21, v20);
      v23.i64[1] = v23.i64[0];
      float32x4_t v24 = *(float32x4_t *)(v13 + 64);
      int8x16_t v25 = *(int8x16_t *)(v13 + 80);
      v19.i64[1] = vaddq_f32(v24, vmulq_n_f32(v22, *(float *)&v19)).i64[1];
      v21.i64[1] = vaddq_f32(v24, vmulq_n_f32(v23, *(float *)&v21)).i64[1];
      float32x4_t v26 = (float32x4_t)vbslq_s8(v25, (int8x16_t)vrev64q_s32((int32x4_t)vsubq_f32(v24, v19)), (int8x16_t)v19);
      float32x4_t v27 = (float32x4_t)vbslq_s8(v25, (int8x16_t)vrev64q_s32((int32x4_t)vsubq_f32(v24, v21)), (int8x16_t)v21);
      int8x16_t v28 = vbslq_s8((int8x16_t)vcgtq_f32(v24, v26), vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL), vextq_s8((int8x16_t)v26, (int8x16_t)v26, 8uLL));
      int8x16_t v29 = vbslq_s8((int8x16_t)vcgtq_f32(v24, v27), vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL), vextq_s8((int8x16_t)v27, (int8x16_t)v27, 8uLL));
      float32x4_t v30 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v26, v28);
      float32x4_t v32 = *(float32x4_t *)(v13 + 96);
      float32x4_t v31 = *(float32x4_t *)(v13 + 112);
      float32x4_t v33 = (float32x4_t)vbslq_s8(v17, (int8x16_t)vmaxq_f32(v30, v32), v28);
      float32x4_t v34 = (float32x4_t)vbslq_s8(v17, (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v27, v29), v32), v29);
      float32x4_t v35 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v33, v18), (int8x16_t)v14);
      float32x4_t v36 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v34, v18), (int8x16_t)v14);
      float32x4_t v38 = *(float32x4_t *)(v13 + 128);
      float32x4_t v37 = *(float32x4_t *)(v13 + 144);
      float32x4_t v39 = *(float32x4_t *)(v13 + 160);
      float32x4_t v40 = *(float32x4_t *)(v13 + 176);
      float32x4_t v41 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v35, v39));
      float32x4_t v42 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v36, v39));
      float32x4_t v43 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v31, v33))), v37), v41);
      float32x4_t v44 = vsubq_f32(vsubq_f32(v35, v14), vmulq_f32(vmulq_f32(v40, v41), v35));
      float32x4_t v45 = vsubq_f32(vsubq_f32(v36, v14), vmulq_f32(vmulq_f32(v40, v42), v36));
      float32x4_t v46 = *(float32x4_t *)(v13 + 192);
      float32x4_t v47 = *(float32x4_t *)(v13 + 208);
      float32x4_t v48 = *(float32x4_t *)(v13 + 224);
      float32x4_t v49 = *(float32x4_t *)(v13 + 240);
      float32x4_t v50 = vmulq_lane_f32(vaddq_f32(v43, vmulq_f32(v44, vaddq_f32(vaddq_f32(v48, vmulq_f32(v49, v44)), vmulq_f32(vmulq_f32(v44, v44), vaddq_f32(v46, vmulq_f32(v47, v44)))))), *(float32x2_t *)v33.f32, 1);
      float32x4_t v51 = vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v34, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v31, v34))), v37), v42), vmulq_f32(v45, vaddq_f32(vaddq_f32(v48, vmulq_f32(v49, v45)), vmulq_f32(vmulq_f32(v45, v45), vaddq_f32(v46, vmulq_f32(v47, v45)))))), *(float32x2_t *)v34.f32, 1);
      float32x4_t v53 = *(float32x4_t *)(v13 + 256);
      float32x4_t v52 = *(float32x4_t *)(v13 + 272);
      float32x4_t v54 = vmaxq_f32(v50, v53);
      float32x4_t v55 = vmaxq_f32(v51, v53);
      float32x4_t v56 = vcvtq_f32_s32(vcvtq_s32_f32(v54));
      float32x4_t v57 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
      float32x4_t v58 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v56, v54)));
      float32x4_t v59 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v57, v55)));
      float32x4_t v60 = vsubq_f32(v54, v58);
      float32x4_t v62 = *(float32x4_t *)(v13 + 288);
      float32x4_t v61 = *(float32x4_t *)(v13 + 304);
      float32x4_t v63 = vsubq_f32(v55, v59);
      float32x4_t v64 = vmulq_f32(v63, vaddq_f32(v61, vmulq_f32(v63, vaddq_f32(v52, vmulq_f32(v62, v63)))));
      int32x4_t v66 = *(int32x4_t *)(v13 + 320);
      float32x4_t v65 = *(float32x4_t *)(v13 + 336);
      float32x4_t v67 = vaddq_f32(v14, vmulq_f32(v60, vaddq_f32(v61, vmulq_f32(v60, vaddq_f32(v52, vmulq_f32(v62, v60))))));
      float32x4_t v68 = (float32x4_t)vrev64q_s32((int32x4_t)v11);
      float32x4_t v69 = (float32x4_t)vrev64q_s32((int32x4_t)v12);
      float32x4_t v70 = vaddq_f32(v14, v64);
      float32x4_t v71 = vminq_f32(vmaxq_f32(vmulq_f32(v61, vrecpeq_f32(v68)), v62), v65);
      int8x16_t v72 = (int8x16_t)vmulq_f32(v67, (float32x4_t)vshlq_n_s32(vaddq_s32(v66, vcvtq_s32_f32(v58)), 0x17uLL));
      float32x4_t v73 = vminq_f32(vmaxq_f32(vmulq_f32(v61, vrecpeq_f32(v69)), v62), v65);
      int8x16_t v74 = (int8x16_t)vmulq_f32(v70, (float32x4_t)vshlq_n_s32(vaddq_s32(v66, vcvtq_s32_f32(v59)), 0x17uLL));
      float32x4_t v76 = *(float32x4_t *)(v13 + 352);
      float32x4_t v75 = *(float32x4_t *)(v13 + 368);
      float32x4_t v77 = (float32x4_t)vrev64q_s32((int32x4_t)vbslq_s8(v17, v72, (int8x16_t)vmulq_f32(v76, (float32x4_t)vbslq_s8(v17, v72, (int8x16_t)vmulq_n_f32(vmulq_f32(v71, vrecpsq_f32(v68, v71)), *(float *)v72.i32)))));
      float32x4_t v78 = (float32x4_t)vrev64q_s32((int32x4_t)vbslq_s8(v17, v74, (int8x16_t)vmulq_f32(v76, (float32x4_t)vbslq_s8(v17, v74, (int8x16_t)vmulq_n_f32(vmulq_f32(v73, vrecpsq_f32(v69, v73)), *(float *)v74.i32)))));
      int8x16_t v79 = vbslq_s8(v17, vbslq_s8((int8x16_t)vcgtq_f32(v11, v32), (int8x16_t)v77, (int8x16_t)v76), (int8x16_t)v11);
      int8x16_t v80 = vbslq_s8(v17, vbslq_s8((int8x16_t)vcgtq_f32(v12, v32), (int8x16_t)v78, (int8x16_t)v76), (int8x16_t)v12);
      *(int8x8_t *)v11.f32 = vqtbl1_s8(v79, *(int8x8_t *)v75.f32);
      v32.i64[0] = vextq_s8((int8x16_t)v75, (int8x16_t)v75, 8uLL).u64[0];
      *(int8x8_t *)v75.f32 = vqtbl1_s8(v80, *(int8x8_t *)v75.f32);
      *(int8x8_t *)&v11.u32[2] = vqtbl1_s8(v79, *(int8x8_t *)v32.f32);
      *(int8x8_t *)&v75.u32[2] = vqtbl1_s8(v80, *(int8x8_t *)v32.f32);
      int8x16_t v81 = (int8x16_t)vmulq_n_f32(v11, *(float *)v79.i32);
      int8x16_t v83 = *(int8x16_t *)(v13 + 384);
      float32x4_t v82 = *(float32x4_t *)(v13 + 400);
      float32x4_t v84 = (float32x4_t)vbslq_s8(v83, v79, v81);
      float32x4_t v85 = (float32x4_t)vbslq_s8(v83, v80, (int8x16_t)vmulq_n_f32(v75, *(float *)v80.i32));
      float32x4_t v86 = (float32x4_t)vbslq_s8(v17, v72, (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v17, v72, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v17, v72, (int8x16_t)vaddq_f32(v77, vmulq_laneq_f32(v52, v84, 2))), v38)), v82));
      float32x4_t v87 = (float32x4_t)vbslq_s8(v17, v74, (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v17, v74, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v17, v74, (int8x16_t)vaddq_f32(v78, vmulq_laneq_f32(v52, v85, 2))), v38)), v82));
      int32x4_t v88 = (int32x4_t)vbslq_s8(v25, (int8x16_t)vmulq_f32(v53, v86), (int8x16_t)v84);
      int32x4_t v89 = (int32x4_t)vbslq_s8(v25, (int8x16_t)vmulq_f32(v53, v87), (int8x16_t)v85);
      int8x16_t v90 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v86), vmulq_n_f32(v49, *(float *)v88.i32));
      float32x4_t v91 = (float32x4_t)vrev64q_s32(v88);
      float32x4_t v92 = (float32x4_t)vrev64q_s32(v89);
      float32x4_t v93 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v91, v18), (int8x16_t)v76);
      float32x4_t v94 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v92, v18), (int8x16_t)v76);
      float32x4_t v95 = (float32x4_t)vbslq_s8(v17, v72, v90);
      float32x4_t v96 = (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v31, v91));
      float32x4_t v97 = (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v31, v92));
      int32x4_t v98 = (int32x4_t)vshrq_n_u32((uint32x4_t)v91, 0x17uLL);
      int32x4_t v99 = (int32x4_t)vshrq_n_u32((uint32x4_t)v92, 0x17uLL);
      float32x4_t v100 = vcvtq_f32_s32(v98);
      float32x4_t v101 = (float32x4_t)vbslq_s8(v17, v74, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v87), vmulq_n_f32(v49, *(float *)v89.i32)));
      float32x4_t v102 = vsubq_f32(vsubq_f32(vcvtq_f32_s32(v99), v97), v37);
      float32x4_t v103 = (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v93, v39));
      float32x4_t v104 = (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v94, v39));
      float32x4_t v105 = vaddq_f32(vsubq_f32(vsubq_f32(v100, v96), v37), v103);
      float32x4_t v106 = vsubq_f32(vsubq_f32(v93, v76), vmulq_f32(vmulq_f32(v40, v103), v93));
      float32x4_t v107 = vsubq_f32(vsubq_f32(v94, v76), vmulq_f32(vmulq_f32(v40, v104), v94));
      float32x4_t v108 = vmulq_f32(v107, vaddq_f32(vaddq_f32(v48, vmulq_f32(v49, v107)), vmulq_f32(vmulq_f32(v107, v107), vaddq_f32(v46, vmulq_f32(v47, v107)))));
      float32x4_t v109 = vaddq_f32(v105, vmulq_f32(v106, vaddq_f32(vaddq_f32(v48, vmulq_f32(v49, v106)), vmulq_f32(vmulq_f32(v106, v106), vaddq_f32(v46, vmulq_f32(v47, v106))))));
      float32x4_t v110 = vaddq_f32(vaddq_f32(v102, v104), v108);
      float32x4_t v111 = *(float32x4_t *)(v13 + 416);
      float32x4_t v112 = *(float32x4_t *)(v13 + 432);
      float32x4_t v113 = vmaxq_f32(vmulq_f32(v111, v109), v53);
      float32x4_t v114 = vmaxq_f32(vmulq_f32(v111, v110), v53);
      float32x4_t v115 = vcvtq_f32_s32(vcvtq_s32_f32(v113));
      float32x4_t v116 = vcvtq_f32_s32(vcvtq_s32_f32(v114));
      float32x4_t v117 = vsubq_f32(v115, (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v115, v113)));
      float32x4_t v118 = vsubq_f32(v116, (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v116, v114)));
      float32x4_t v119 = vsubq_f32(v113, v117);
      float32x4_t v120 = vsubq_f32(v114, v118);
      int32x4_t v121 = vcvtq_s32_f32(v117);
      *(int8x8_t *)v117.f32 = vqtbl1_s8((int8x16_t)v88, *(int8x8_t *)v112.f32);
      *(int8x8_t *)v112.f32 = vqtbl1_s8((int8x16_t)v89, *(int8x8_t *)v112.f32);
      float32x4_t v122 = *(float32x4_t *)(v13 + 448);
      float32x4_t v123 = *(float32x4_t *)(v13 + 464);
      v95.i64[0] = vaddq_f32(vmulq_f32(v117, v122), v95).u64[0];
      v101.i64[0] = vaddq_f32(vmulq_f32(v122, v112), v101).u64[0];
      v95.i64[1] = v88.i64[1];
      v101.i64[1] = v89.i64[1];
      v95.i64[0] = vminq_f32(v95, v123).u64[0];
      float32x4_t v124 = vmulq_f32(v62, v119);
      v101.i64[0] = vminq_f32(v101, v123).u64[0];
      v95.i64[1] = v88.i64[1];
      v101.i64[1] = v89.i64[1];
      float32x4_t v125 = vmulq_f32(v62, v120);
      float32x4_t v127 = *(float32x4_t *)(v13 + 480);
      float32x4_t v126 = *(float32x4_t *)(v13 + 496);
      float32x4_t v128 = vmaxq_f32(v95, v127);
      float32x4_t v129 = vmaxq_f32(v101, v127);
      float32x4_t v130 = (float32x4_t)vshlq_n_s32(vaddq_s32(v121, v66), 0x17uLL);
      v121.i64[0] = vmulq_f32(v128, v126).u64[0];
      float32x4_t v131 = (float32x4_t)vdupq_lane_s64(v121.i64[0], 0);
      v121.i64[1] = v88.i64[1];
      float32x4_t v132 = vaddq_f32(v52, v124);
      v129.i64[0] = vmulq_f32(v129, v126).u64[0];
      float32x4_t v133 = (float32x4_t)vdupq_lane_s64(v129.i64[0], 0);
      v129.i64[1] = v89.i64[1];
      float32x4_t v134 = vaddq_f32(v52, v125);
      float32x4_t v135 = (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v118), v66), 0x17uLL);
      float32x4_t v136 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v66, (int8x16_t)v131), (int8x16_t)v111);
      float32x4_t v137 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v66, (int8x16_t)v133), (int8x16_t)v111);
      float32x4_t v138 = (float32x4_t)vandq_s8((int8x16_t)v47, (int8x16_t)vcgtq_f32(v48, v131));
      float32x4_t v139 = (float32x4_t)vandq_s8((int8x16_t)v47, (int8x16_t)vcgtq_f32(v48, v133));
      float32x4_t v140 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v131, 0x17uLL)), v138), v46);
      float32x4_t v141 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v133, 0x17uLL)), v139), v46);
      float32x4_t v142 = (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v136, v40));
      float32x4_t v143 = (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v137, v40));
      float32x4_t v144 = vaddq_f32(v140, v142);
      float32x4_t v145 = vaddq_f32(v141, v143);
      float32x4_t v146 = vmulq_f32(v39, v142);
      float32x4_t v147 = vmulq_f32(v39, v143);
      float32x4_t v148 = vmulq_f32(v119, vaddq_f32(v61, vmulq_f32(v119, v132)));
      float32x4_t v149 = vsubq_f32(vsubq_f32(v136, v111), vmulq_f32(v146, v136));
      float32x4_t v150 = vsubq_f32(vsubq_f32(v137, v111), vmulq_f32(v147, v137));
      float32x4_t v151 = vaddq_f32(v37, vmulq_f32(v31, v149));
      float32x4_t v152 = vaddq_f32(v76, v148);
      float32x4_t v153 = vaddq_f32(v37, vmulq_f32(v31, v150));
      float32x4_t v154 = *(float32x4_t *)(v13 + 512);
      float32x4_t v155 = *(float32x4_t *)(v13 + 528);
      float32x4_t v156 = vaddq_f32(vaddq_f32(v154, vmulq_f32(v155, v150)), vmulq_f32(vmulq_f32(v150, v150), v153));
      float32x4_t v157 = vaddq_f32(v144, vmulq_f32(v149, vaddq_f32(vaddq_f32(v154, vmulq_f32(v155, v149)), vmulq_f32(vmulq_f32(v149, v149), v151))));
      float32x4_t v158 = vmulq_f32(v150, v156);
      int8x16_t v159 = (int8x16_t)vmulq_f32(vaddq_f32(v76, vmulq_f32(v120, vaddq_f32(v61, vmulq_f32(v120, v134)))), v135);
      float32x4_t v160 = vaddq_f32(v145, v158);
      float32x4_t v161 = *(float32x4_t *)(v13 + 544);
      float32x4_t v162 = *(float32x4_t *)(v13 + 560);
      float32x4_t v163 = vmaxq_f32(vmulq_f32(v161, v157), v162);
      float32x4_t v164 = vmaxq_f32(vmulq_f32(v161, v160), v162);
      float32x4_t v165 = vcvtq_f32_s32(vcvtq_s32_f32(v163));
      float32x4_t v166 = vcvtq_f32_s32(vcvtq_s32_f32(v164));
      float32x4_t v167 = vsubq_f32(v165, (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v165, v163)));
      float32x4_t v168 = vsubq_f32(v166, (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v166, v164)));
      float32x4_t v169 = vsubq_f32(v163, v167);
      float32x4_t v170 = vsubq_f32(v164, v168);
      float32x4_t v171 = *(float32x4_t *)(v13 + 576);
      float32x4_t v172 = *(float32x4_t *)(v13 + 592);
      float32x4_t v173 = vaddq_f32(v171, vmulq_f32(v172, v169));
      float32x4_t v174 = vaddq_f32(v171, vmulq_f32(v172, v170));
      float32x4_t v175 = vmulq_f32(v169, v173);
      float32x4_t v176 = *(float32x4_t *)(v13 + 608);
      int32x4_t v177 = *(int32x4_t *)(v13 + 624);
      float32x4_t v178 = (int8x16_t *)(v5 + v10);
      v178[-1] = vbslq_s8(v83, (int8x16_t)v121, vbslq_s8(v17, (int8x16_t)vmulq_f32(v152, v130), (int8x16_t)vmulq_f32(vaddq_f32(v111, vmulq_f32(v169, vaddq_f32(v176, v175))), (float32x4_t)vshlq_n_s32(vaddq_s32(v177, vcvtq_s32_f32(v167)), 0x17uLL))));
      *float32x4_t v178 = vbslq_s8(v83, (int8x16_t)v129, vbslq_s8(v17, v159, (int8x16_t)vmulq_f32(vaddq_f32(v111, vmulq_f32(v170, vaddq_f32(v176, vmulq_f32(v170, v174)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v177, vcvtq_s32_f32(v168)), 0x17uLL))));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v179 = -v9;
    if (v179 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v180 = 16 * v179;
    float32x4_t v181 = *(float32x4_t *)(v6 + v180);
    uint64_t v182 = *((void *)this + 51);
    float32x4_t v183 = *(float32x4_t *)(v182 + 16);
    int8x16_t v184 = (int8x16_t)vmulq_f32(v181, *(float32x4_t *)v182);
    int8x16_t v185 = *(int8x16_t *)(v182 + 32);
    int8x16_t v186 = *(int8x16_t *)(v182 + 48);
    float32x4_t v187 = (float32x4_t)vbslq_s8(v185, v184, (int8x16_t)vaddq_f32(*(float32x4_t *)v182, vmulq_n_f32(v183, *(float *)v184.i32)));
    *(int8x8_t *)v188.f32 = vqtbl1_s8((int8x16_t)v187, (int8x8_t)*(_OWORD *)&vextq_s8(v186, v186, 8uLL));
    v188.i64[1] = v188.i64[0];
    float32x4_t v189 = *(float32x4_t *)(v182 + 64);
    int8x16_t v190 = *(int8x16_t *)(v182 + 80);
    v187.i64[1] = vaddq_f32(v189, vmulq_n_f32(v188, *(float *)&v187)).i64[1];
    float32x4_t v191 = (float32x4_t)vbslq_s8(v190, (int8x16_t)vrev64q_s32((int32x4_t)vsubq_f32(v189, v187)), (int8x16_t)v187);
    int8x16_t v192 = vbslq_s8((int8x16_t)vcgtq_f32(v189, v191), vextq_s8((int8x16_t)v191, (int8x16_t)v191, 4uLL), vextq_s8((int8x16_t)v191, (int8x16_t)v191, 8uLL));
    float32x4_t v193 = (float32x4_t)vbslq_s8(v185, (int8x16_t)v191, v192);
    float32x4_t v195 = *(float32x4_t *)(v182 + 96);
    float32x4_t v194 = *(float32x4_t *)(v182 + 112);
    float32x4_t v196 = (float32x4_t)vbslq_s8(v185, (int8x16_t)vmaxq_f32(v193, v195), v192);
    float32x4_t v197 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v196, v186), (int8x16_t)v183);
    float32x4_t v199 = *(float32x4_t *)(v182 + 128);
    float32x4_t v198 = *(float32x4_t *)(v182 + 144);
    float32x4_t v200 = *(float32x4_t *)(v182 + 160);
    float32x4_t v201 = *(float32x4_t *)(v182 + 176);
    float32x4_t v202 = (float32x4_t)vandq_s8((int8x16_t)v183, (int8x16_t)vcgtq_f32(v197, v200));
    float32x4_t v203 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v196, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v199, (int8x16_t)vcgtq_f32(v194, v196))), v198), v202);
    float32x4_t v204 = vsubq_f32(vsubq_f32(v197, v183), vmulq_f32(vmulq_f32(v201, v202), v197));
    float32x4_t v205 = *(float32x4_t *)(v182 + 192);
    float32x4_t v206 = *(float32x4_t *)(v182 + 208);
    float32x4_t v207 = *(float32x4_t *)(v182 + 224);
    float32x4_t v208 = *(float32x4_t *)(v182 + 240);
    float32x4_t v209 = vmulq_lane_f32(vaddq_f32(v203, vmulq_f32(v204, vaddq_f32(vaddq_f32(v207, vmulq_f32(v208, v204)), vmulq_f32(vmulq_f32(v204, v204), vaddq_f32(v205, vmulq_f32(v206, v204)))))), *(float32x2_t *)v196.f32, 1);
    float32x4_t v210 = *(float32x4_t *)(v182 + 256);
    float32x4_t v211 = *(float32x4_t *)(v182 + 272);
    float32x4_t v212 = vmaxq_f32(v209, v210);
    float32x4_t v213 = vcvtq_f32_s32(vcvtq_s32_f32(v212));
    float32x4_t v214 = vsubq_f32(v213, (float32x4_t)vandq_s8((int8x16_t)v183, (int8x16_t)vcgtq_f32(v213, v212)));
    float32x4_t v215 = vsubq_f32(v212, v214);
    float32x4_t v216 = *(float32x4_t *)(v182 + 288);
    float32x4_t v217 = *(float32x4_t *)(v182 + 304);
    float32x4_t v218 = vaddq_f32(v183, vmulq_f32(v215, vaddq_f32(v217, vmulq_f32(v215, vaddq_f32(v211, vmulq_f32(v216, v215))))));
    int32x4_t v219 = *(int32x4_t *)(v182 + 320);
    int8x16_t v220 = (int8x16_t)vmulq_f32(v218, (float32x4_t)vshlq_n_s32(vaddq_s32(v219, vcvtq_s32_f32(v214)), 0x17uLL));
    float32x4_t v221 = (float32x4_t)vrev64q_s32((int32x4_t)v181);
    float32x4_t v222 = vminq_f32(vmaxq_f32(vmulq_f32(v217, vrecpeq_f32(v221)), v216), *(float32x4_t *)(v182 + 336));
    float32x4_t v223 = (float32x4_t)vbslq_s8(v185, v220, (int8x16_t)vmulq_n_f32(vmulq_f32(v222, vrecpsq_f32(v221, v222)), *(float *)v220.i32));
    float32x4_t v224 = *(float32x4_t *)(v182 + 352);
    int8x16_t v225 = *(int8x16_t *)(v182 + 368);
    float32x4_t v226 = (float32x4_t)vrev64q_s32((int32x4_t)vbslq_s8(v185, v220, (int8x16_t)vmulq_f32(v224, v223)));
    int8x16_t v227 = vbslq_s8(v185, vbslq_s8((int8x16_t)vcgtq_f32(v181, v195), (int8x16_t)v226, (int8x16_t)v224), (int8x16_t)v181);
    *(int8x8_t *)v181.f32 = vqtbl1_s8(v227, *(int8x8_t *)v225.i8);
    *(int8x8_t *)&v181.u32[2] = vqtbl1_s8(v227, (int8x8_t)*(_OWORD *)&vextq_s8(v225, v225, 8uLL));
    int8x16_t v228 = (int8x16_t)vmulq_n_f32(v181, *(float *)v227.i32);
    int8x16_t v229 = *(int8x16_t *)(v182 + 384);
    float32x4_t v230 = (float32x4_t)vbslq_s8(v229, v227, v228);
    float32x4_t v231 = (float32x4_t)vbslq_s8(v185, v220, (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v185, v220, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v185, v220, (int8x16_t)vaddq_f32(v226, vmulq_laneq_f32(v211, v230, 2))), v199)), *(float32x4_t *)(v182 + 400)));
    int32x4_t v232 = (int32x4_t)vbslq_s8(v190, (int8x16_t)vmulq_f32(v210, v231), (int8x16_t)v230);
    float32x4_t v233 = (float32x4_t)vbslq_s8(v185, v220, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v231), vmulq_n_f32(v208, *(float *)v232.i32)));
    float32x4_t v234 = (float32x4_t)vrev64q_s32(v232);
    float32x4_t v235 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v234, v186), (int8x16_t)v224);
    float32x4_t v236 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v234, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v199, (int8x16_t)vcgtq_f32(v194, v234))), v198);
    float32x4_t v237 = (float32x4_t)vandq_s8((int8x16_t)v224, (int8x16_t)vcgtq_f32(v235, v200));
    float32x4_t v238 = vsubq_f32(vsubq_f32(v235, v224), vmulq_f32(vmulq_f32(v201, v237), v235));
    float32x4_t v239 = vaddq_f32(vaddq_f32(v236, v237), vmulq_f32(v238, vaddq_f32(vaddq_f32(v207, vmulq_f32(v208, v238)), vmulq_f32(vmulq_f32(v238, v238), vaddq_f32(v205, vmulq_f32(v206, v238))))));
    float32x4_t v240 = *(float32x4_t *)(v182 + 416);
    float32x4_t v241 = vmaxq_f32(vmulq_f32(v240, v239), v210);
    float32x4_t v242 = vcvtq_f32_s32(vcvtq_s32_f32(v241));
    float32x4_t v243 = vsubq_f32(v242, (float32x4_t)vandq_s8((int8x16_t)v224, (int8x16_t)vcgtq_f32(v242, v241)));
    float32x4_t v244 = vsubq_f32(v241, v243);
    float32x4_t v245 = vmulq_f32(v216, v244);
    float32x4_t v246 = vaddq_f32(v224, vmulq_f32(v244, vaddq_f32(v217, vmulq_f32(v244, vaddq_f32(v211, v245)))));
    *(int8x8_t *)v245.f32 = vqtbl1_s8((int8x16_t)v232, *(int8x8_t *)(v182 + 432));
    v245.i64[0] = vaddq_f32(vmulq_f32(*(float32x4_t *)(v182 + 448), v245), v233).u64[0];
    v245.i64[1] = v232.i64[1];
    int8x16_t v247 = (int8x16_t)vmulq_f32(v246, (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v243), v219), 0x17uLL));
    v211.i64[0] = vminq_f32(v245, *(float32x4_t *)(v182 + 464)).u64[0];
    v211.i64[1] = v232.i64[1];
    v211.i64[0] = vmulq_f32(vmaxq_f32(v211, *(float32x4_t *)(v182 + 480)), *(float32x4_t *)(v182 + 496)).u64[0];
    float32x4_t v248 = (float32x4_t)vdupq_lane_s64(v211.i64[0], 0);
    v211.i64[1] = v232.i64[1];
    float32x4_t v249 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v219, (int8x16_t)v248), (int8x16_t)v240);
    float32x4_t v250 = (float32x4_t)vandq_s8((int8x16_t)v240, (int8x16_t)vcgtq_f32(v249, v201));
    float32x4_t v251 = vsubq_f32(vsubq_f32(v249, v240), vmulq_f32(vmulq_f32(v200, v250), v249));
    float32x4_t v252 = vmaxq_f32(vmulq_f32(*(float32x4_t *)(v182 + 544), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v248, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v206, (int8x16_t)vcgtq_f32(v207, v248))), v205), v250), vmulq_f32(v251, vaddq_f32(vaddq_f32(*(float32x4_t *)(v182 + 512), vmulq_f32(*(float32x4_t *)(v182 + 528), v251)), vmulq_f32(vmulq_f32(v251, v251), vaddq_f32(v198, vmulq_f32(v194, v251))))))), *(float32x4_t *)(v182 + 560));
    float32x4_t v253 = vcvtq_f32_s32(vcvtq_s32_f32(v252));
    float32x4_t v254 = vsubq_f32(v253, (float32x4_t)vandq_s8((int8x16_t)v240, (int8x16_t)vcgtq_f32(v253, v252)));
    float32x4_t v255 = vsubq_f32(v252, v254);
    *(int8x16_t *)(v5 + v180) = vbslq_s8(v229, (int8x16_t)v211, vbslq_s8(v185, v247, (int8x16_t)vmulq_f32(vaddq_f32(v240, vmulq_f32(v255, vaddq_f32(*(float32x4_t *)(v182 + 608), vmulq_f32(v255, vaddq_f32(*(float32x4_t *)(v182 + 576), vmulq_f32(*(float32x4_t *)(v182 + 592), v255)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(
                                                                  *(int32x4_t *)(v182 + 624),
                                                                  vcvtq_s32_f32(v254)),
                                                                0x17uLL))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2446_Method_A_ITMO::GetDOD(HgcBT2446_Method_A_ITMO *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2446_Method_A_ITMO::GetROI(HgcBT2446_Method_A_ITMO *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2446_Method_A_ITMO::HgcBT2446_Method_A_ITMO(HgcBT2446_Method_A_ITMO *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F0750;
  operator new();
}

void sub_1B7910424(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2446_Method_A_ITMO::~HgcBT2446_Method_A_ITMO(HGNode *this)
{
  *(void *)this = &unk_1F10F0750;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B6D25C9CLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F0750;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B6D25C9CLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2446_Method_A_ITMO::SetParameter(HgcBT2446_Method_A_ITMO *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcBT2446_Method_A_ITMO::GetParameter(HgcBT2446_Method_A_ITMO *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcBT2390_Gain_Sat_ToneAdj::GetProgram(HgcBT2390_Gain_Sat_ToneAdj *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000482\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.2649999857, 1.100000024, 0.6779980063);\n"
             "    const half4 c1 = half4(0.05930199847, 1.000000000, 12.00000000, 0.2626999915);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmax(r0, c0.xxxx);\n"
             "    r1.xyz = r0.xyz*c0.yyy;\n"
             "    r0.xy = pow(r1.xy, c0.zz);\n"
             "    r0.z = r0.y*c0.w;\n"
             "    r1.w = r0.x*c1.w + r0.z;\n"
             "    r1.y = r1.y*c0.w;\n"
             "    r1.x = r1.x*c1.w + r1.y;\n"
             "    r0.z = pow(r1.z, c0.z);\n"
             "    r1.w = r0.z*c1.x + r1.w;\n"
             "    r1.x = r1.z*c1.x + r1.x;\n"
             "    r1.x = r1.x/r1.w;\n"
             "    r1.x = select(c1.y, r1.x, -r1.w < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r1.xxx;\n"
             "    output.color0.xyz = float3(r0.xyz)*float3(c1.zzz);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c4ba51af:835a3309:a06f8f2a:0fe182e4\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000469\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.2649999857, 1.100000024, 0.6779980063);\n"
             "    const float4 c1 = float4(0.05930199847, 1.000000000, 12.00000000, 0.2626999915);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmax(r0, c0.xxxx);\n"
             "    r1.xyz = r0.xyz*c0.yyy;\n"
             "    r0.xy = pow(r1.xy, c0.zz);\n"
             "    r0.z = r0.y*c0.w;\n"
             "    r1.w = r0.x*c1.w + r0.z;\n"
             "    r1.y = r1.y*c0.w;\n"
             "    r1.x = r1.x*c1.w + r1.y;\n"
             "    r0.z = pow(r1.z, c0.z);\n"
             "    r1.w = r0.z*c1.x + r1.w;\n"
             "    r1.x = r1.z*c1.x + r1.x;\n"
             "    r1.x = r1.x/r1.w;\n"
             "    r1.x = select(c1.y, r1.x, -r1.w < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r1.xxx;\n"
             "    output.color0.xyz = r0.xyz*c1.zzz;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2c714e19:97ce859d:2d1a1eb0:61cf40b1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000409\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.2649999857, 1.100000024, 0.6779980063);\n"
           "    const mediump vec4 c1 = vec4(0.05930199847, 1.000000000, 12.00000000, 0.2626999915);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = max(r0, c0.xxxx);\n"
           "    r1.xyz = r0.xyz*c0.yyy;\n"
           "    r0.xy = pow(r1.xy, c0.zz);\n"
           "    r0.z = r0.y*c0.w;\n"
           "    r1.w = r0.x*c1.w + r0.z;\n"
           "    r1.y = r1.y*c0.w;\n"
           "    r1.x = r1.x*c1.w + r1.y;\n"
           "    r0.z = pow(r1.z, c0.z);\n"
           "    r1.w = r0.z*c1.x + r1.w;\n"
           "    r1.x = r1.z*c1.x + r1.x;\n"
           "    r1.x = r1.x/r1.w;\n"
           "    r1.x = -r1.w < 0.00000 ? r1.x : c1.y;\n"
           "    r0.xyz = r0.xyz*r1.xxx;\n"
           "    gl_FragColor.xyz = r0.xyz*c1.zzz;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=2b807689:01e4ee76:eadbe047:2c27b0e4\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2390_Gain_Sat_ToneAdj::InitProgramDescriptor(HgcBT2390_Gain_Sat_ToneAdj *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2390_Gain_Sat_ToneAdj_hgc_visible", "//Metal1.0     \n//LEN=000000034d\n[[ visible ]] FragmentOut HgcBT2390_Gain_Sat_ToneAdj_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.2649999857, 1.100000024, 0.6779980063);\n"
    "    const float4 c1 = float4(0.05930199847, 1.000000000, 12.00000000, 0.2626999915);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = fmax(r0, c0.xxxx);\n"
    "    r1.xyz = r0.xyz*c0.yyy;\n"
    "    r0.xy = pow(r1.xy, c0.zz);\n"
    "    r0.z = r0.y*c0.w;\n"
    "    r1.w = r0.x*c1.w + r0.z;\n"
    "    r1.y = r1.y*c0.w;\n"
    "    r1.x = r1.x*c1.w + r1.y;\n"
    "    r0.z = pow(r1.z, c0.z);\n"
    "    r1.w = r0.z*c1.x + r1.w;\n"
    "    r1.x = r1.z*c1.x + r1.x;\n"
    "    r1.x = r1.x/r1.w;\n"
    "    r1.x = select(c1.y, r1.x, -r1.w < 0.00000f);\n"
    "    r0.xyz = r0.xyz*r1.xxx;\n"
    "    output.color0.xyz = r0.xyz*c1.zzz;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2390_Gain_Sat_ToneAdj");
}

void sub_1B7910800(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7910830(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7910828);
}

char *HgcBT2390_Gain_Sat_ToneAdj::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376030;
  strcpy(result, "HgcBT2390_Gain_Sat_ToneAdj [hgc1]");
  return result;
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::BindTexture(HgcBT2390_Gain_Sat_ToneAdj *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::Bind(HgcBT2390_Gain_Sat_ToneAdj *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::RenderTile(HgcBT2390_Gain_Sat_ToneAdj *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v117 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      uint64_t v11 = *((void *)this + 51);
      float32x4_t v12 = *(float32x4_t *)(v11 + 16);
      float32x4_t v13 = vmaxq_f32(*(float32x4_t *)(v6 + v10 - 16), *(float32x4_t *)v11);
      float32x4_t v14 = vmaxq_f32(*(float32x4_t *)(v6 + v10), *(float32x4_t *)v11);
      float32x4_t v15 = vmulq_f32(v13, v12);
      float32x4_t v16 = vmulq_f32(v14, v12);
      int32x4_t v17 = *(int32x4_t *)(v11 + 32);
      float32x4_t v18 = *(float32x4_t *)(v11 + 48);
      float32x4_t v19 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v17, (int8x16_t)v15), (int8x16_t)v18);
      float32x4_t v20 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v17, (int8x16_t)v16), (int8x16_t)v18);
      float32x4_t v21 = *(float32x4_t *)(v11 + 64);
      float32x4_t v22 = *(float32x4_t *)(v11 + 80);
      float32x4_t v23 = *(float32x4_t *)(v11 + 96);
      float32x4_t v24 = *(float32x4_t *)(v11 + 112);
      float32x4_t v25 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v19, v24));
      float32x4_t v26 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v20, v24));
      float32x4_t v27 = *(float32x4_t *)(v11 + 128);
      float32x4_t v28 = *(float32x4_t *)(v11 + 144);
      float32x4_t v29 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v21, v16))), v23), v26);
      float32x4_t v30 = vsubq_f32(vsubq_f32(v19, v18), vmulq_f32(vmulq_f32(v27, v25), v19));
      float32x4_t v31 = vsubq_f32(vsubq_f32(v20, v18), vmulq_f32(vmulq_f32(v27, v26), v20));
      float32x4_t v32 = *(float32x4_t *)(v11 + 160);
      float32x4_t v33 = *(float32x4_t *)(v11 + 176);
      float32x4_t v34 = *(float32x4_t *)(v11 + 192);
      float32x4_t v35 = *(float32x4_t *)(v11 + 208);
      float32x4_t v36 = vmulq_f32(v35, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v15, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v21, v15))), v23), v25), vmulq_f32(v30, vaddq_f32(vaddq_f32(v33, vmulq_f32(v30, v34)), vmulq_f32(vmulq_f32(v30, v30), vaddq_f32(v28, vmulq_f32(v32, v30)))))));
      float32x4_t v37 = *(float32x4_t *)(v11 + 224);
      float32x4_t v38 = *(float32x4_t *)(v11 + 240);
      float32x4_t v39 = vmaxq_f32(v36, v37);
      float32x4_t v40 = vmaxq_f32(vmulq_f32(v35, vaddq_f32(v29, vmulq_f32(v31, vaddq_f32(vaddq_f32(v33, vmulq_f32(v31, v34)), vmulq_f32(vmulq_f32(v31, v31), vaddq_f32(v28, vmulq_f32(v32, v31))))))), v37);
      float32x4_t v41 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      float32x4_t v42 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      float32x4_t v43 = vsubq_f32(v41, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v41, v39)));
      float32x4_t v44 = vsubq_f32(v42, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v42, v40)));
      float32x4_t v45 = vsubq_f32(v39, v43);
      float32x4_t v46 = vsubq_f32(v40, v44);
      float32x4_t v48 = *(float32x4_t *)(v11 + 256);
      float32x4_t v47 = *(float32x4_t *)(v11 + 272);
      float32x4_t v49 = vmulq_f32(v46, vaddq_f32(v47, vmulq_f32(v46, vaddq_f32(v38, vmulq_f32(v48, v46)))));
      int32x4_t v50 = *(int32x4_t *)(v11 + 288);
      int8x16_t v51 = *(int8x16_t *)(v11 + 304);
      int8x16_t v52 = (int8x16_t)vmulq_f32(vaddq_f32(v18, vmulq_f32(v45, vaddq_f32(v47, vmulq_f32(v45, vaddq_f32(v38, vmulq_f32(v48, v45)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v50, vcvtq_s32_f32(v43)), 0x17uLL));
      int8x16_t v53 = (int8x16_t)vmulq_f32(vaddq_f32(v18, v49), (float32x4_t)vshlq_n_s32(vaddq_s32(v50, vcvtq_s32_f32(v44)), 0x17uLL));
      v49.i64[0] = vextq_s8((int8x16_t)v13, v52, 0xCuLL).u64[0];
      v52.i64[1] = v13.i64[1];
      v54.i64[0] = vextq_s8((int8x16_t)v14, v53, 0xCuLL).u64[0];
      v53.i64[1] = v14.i64[1];
      *(int8x8_t *)&v49.u32[2] = vext_s8(*(int8x8_t *)v52.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL), 4uLL);
      *(int8x8_t *)&v54.u32[2] = vext_s8(*(int8x8_t *)v53.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL), 4uLL);
      int32x4_t v55 = (int32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(v47, v49), v52);
      int32x4_t v56 = (int32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(v47, v54), v53);
      int8x16_t v57 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v55), vmulq_n_f32(v47, *(float *)v55.i32));
      int8x16_t v58 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v56), vmulq_n_f32(v47, *(float *)v56.i32));
      int8x16_t v59 = *(int8x16_t *)(v11 + 320);
      float32x4_t v60 = *(float32x4_t *)(v11 + 336);
      float32x4_t v61 = (float32x4_t)vbslq_s8(v59, v57, (int8x16_t)v15);
      float32x4_t v62 = (float32x4_t)vbslq_s8(v59, v58, (int8x16_t)v16);
      int8x16_t v63 = *(int8x16_t *)(v11 + 352);
      float32x4_t v64 = *(float32x4_t *)(v11 + 368);
      float32x4_t v65 = (float32x4_t)vbslq_s8(v63, (int8x16_t)vmulq_f32(v60, v61), (int8x16_t)v61);
      float32x4_t v66 = (float32x4_t)vbslq_s8(v63, (int8x16_t)vmulq_f32(v60, v62), (int8x16_t)v62);
      v62.i64[0] = vaddq_f32(vmulq_f32(v64, v65), (float32x4_t)vrev64q_s32((int32x4_t)v65)).u64[0];
      v61.i64[0] = vaddq_f32(vmulq_f32(v64, v66), (float32x4_t)vrev64q_s32((int32x4_t)v66)).u64[0];
      v62.i64[1] = v65.i64[1];
      v61.i64[1] = v66.i64[1];
      float32x4_t v67 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v50, (int8x16_t)v62), (int8x16_t)v64);
      float32x4_t v68 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v50, (int8x16_t)v61), (int8x16_t)v64);
      float32x4_t v69 = (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v48, v62));
      float32x4_t v70 = (float32x4_t)vandq_s8((int8x16_t)v38, (int8x16_t)vcgtq_f32(v48, v61));
      float32x4_t v71 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v62, 0x17uLL)), v69), v37);
      float32x4_t v72 = (float32x4_t)vandq_s8((int8x16_t)v64, (int8x16_t)vcgtq_f32(v67, v35));
      float32x4_t v73 = (float32x4_t)vandq_s8((int8x16_t)v64, (int8x16_t)vcgtq_f32(v68, v35));
      float32x4_t v74 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v61, 0x17uLL)), v70), v37);
      float32x4_t v75 = vaddq_f32(v71, v72);
      float32x4_t v76 = vsubq_f32(vsubq_f32(v67, v64), vmulq_f32(vmulq_f32(v34, v72), v67));
      float32x4_t v77 = vsubq_f32(vsubq_f32(v68, v64), vmulq_f32(vmulq_f32(v34, v73), v68));
      float32x4_t v78 = vaddq_f32(v33, vmulq_f32(v32, v76));
      float32x4_t v79 = vaddq_f32(v33, vmulq_f32(v32, v77));
      float32x4_t v80 = vmulq_f32(v27, v76);
      float32x4_t v81 = vaddq_f32(v28, vmulq_f32(v27, v77));
      float32x4_t v82 = vmulq_f32(v24, vaddq_f32(v75, vmulq_f32(v76, vaddq_f32(vaddq_f32(v28, v80), vmulq_f32(vmulq_f32(v76, v76), v78)))));
      float32x4_t v83 = vmulq_f32(v24, vaddq_f32(vaddq_f32(v74, v73), vmulq_f32(v77, vaddq_f32(v81, vmulq_f32(vmulq_f32(v77, v77), v79)))));
      float32x4_t v84 = vmaxq_f32(v82, v23);
      float32x4_t v85 = vmaxq_f32(v83, v23);
      float32x4_t v86 = vcvtq_f32_s32(vcvtq_s32_f32(v84));
      float32x4_t v87 = vcvtq_f32_s32(vcvtq_s32_f32(v85));
      float32x4_t v88 = vsubq_f32(v86, (float32x4_t)vandq_s8((int8x16_t)v64, (int8x16_t)vcgtq_f32(v86, v84)));
      float32x4_t v89 = vsubq_f32(v87, (float32x4_t)vandq_s8((int8x16_t)v64, (int8x16_t)vcgtq_f32(v87, v85)));
      float32x4_t v90 = vsubq_f32(v84, v88);
      float32x4_t v91 = vsubq_f32(v85, v89);
      float32x4_t v92 = vaddq_f32(v22, vmulq_f32(v21, v90));
      float32x4_t v93 = vaddq_f32(v22, vmulq_f32(v21, v91));
      float32x4_t v94 = vaddq_f32(v18, vmulq_f32(v90, v92));
      float32x4_t v95 = vaddq_f32(v18, vmulq_f32(v91, v93));
      float32x4_t v96 = vaddq_f32(v64, vmulq_f32(v90, v94));
      int32x4_t v97 = vaddq_s32(vcvtq_s32_f32(v88), v17);
      int8x16_t v98 = (int8x16_t)vmulq_f32(vaddq_f32(v64, vmulq_f32(v91, v95)), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v89), v17), 0x17uLL));
      float32x4_t v99 = (float32x4_t)vbslq_s8(v51, (int8x16_t)vmulq_f32(v96, (float32x4_t)vshlq_n_s32(v97, 0x17uLL)), v52);
      float32x4_t v100 = (float32x4_t)vbslq_s8(v51, v98, v53);
      float32x4_t v101 = (float32x4_t)vbslq_s8(v59, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v64, v99, 2), v62), (int8x16_t)v62);
      float32x4_t v102 = (float32x4_t)vbslq_s8(v59, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v64, v100, 2), v61), (int8x16_t)v61);
      v91.i64[0] = vextq_s8((int8x16_t)v101, (int8x16_t)v101, 8uLL).u64[0];
      float32x4_t v103 = *(float32x4_t *)(v11 + 384);
      float32x4_t v104 = *(float32x4_t *)(v11 + 400);
      v64.i64[0] = vextq_s8((int8x16_t)v102, (int8x16_t)v102, 8uLL).u64[0];
      float32x4_t v105 = vaddq_f32(vmulq_laneq_f32(v103, v101, 2), v101);
      float32x4_t v106 = vaddq_f32(vmulq_laneq_f32(v103, v102, 2), v102);
      *(int8x8_t *)v89.f32 = vext_s8(*(int8x8_t *)v91.f32, *(int8x8_t *)v105.f32, 4uLL);
      *(int8x8_t *)&v89.u32[2] = vext_s8(*(int8x8_t *)v105.f32, *(int8x8_t *)v91.f32, 4uLL);
      *(int8x8_t *)v62.f32 = vext_s8(*(int8x8_t *)v64.f32, *(int8x8_t *)v106.f32, 4uLL);
      *(int8x8_t *)&v62.u32[2] = vext_s8(*(int8x8_t *)v106.f32, *(int8x8_t *)v64.f32, 4uLL);
      float32x4_t v107 = *(float32x4_t *)(v11 + 416);
      float32x4_t v108 = *(float32x4_t *)(v11 + 432);
      float32x4_t v109 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v89), v104), v107), v108);
      float32x4_t v110 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v62), v104), v107), v108);
      int8x16_t v111 = (int8x16_t)vmulq_f32(vmulq_f32(v109, vrecpsq_f32(v89, v109)), v105);
      int8x16_t v112 = (int8x16_t)vmulq_f32(vmulq_f32(v110, vrecpsq_f32(v62, v110)), v106);
      *(int8x8_t *)v109.f32 = vext_s8(*(int8x8_t *)v111.i8, *(int8x8_t *)v91.f32, 4uLL);
      *(int8x8_t *)v91.f32 = vext_s8(*(int8x8_t *)v91.f32, *(int8x8_t *)v111.i8, 4uLL);
      v91.i64[1] = v109.i64[0];
      *(int8x8_t *)v110.f32 = vext_s8(*(int8x8_t *)v64.f32, *(int8x8_t *)v112.i8, 4uLL);
      *(int8x8_t *)&v110.u32[2] = vext_s8(*(int8x8_t *)v112.i8, *(int8x8_t *)v64.f32, 4uLL);
      float32x4_t v113 = (float32x4_t)vbslq_s8(v59, (int8x16_t)v100, (int8x16_t)vmulq_n_f32(v100, *(float *)vbslq_s8((int8x16_t)vcgtq_f32(v110, *(float32x4_t *)v11), v112, (int8x16_t)v60).i32));
      float32x4_t v114 = *(float32x4_t *)(v11 + 448);
      int8x16_t v115 = vbslq_s8(v59, (int8x16_t)v99, (int8x16_t)vmulq_f32(v114, (float32x4_t)vbslq_s8(v59, (int8x16_t)v99, (int8x16_t)vmulq_n_f32(v99, *(float *)vbslq_s8((int8x16_t)vcgtq_f32(v91, *(float32x4_t *)v11), v111, (int8x16_t)v60).i32))));
      float32x4_t v116 = (int8x16_t *)(v5 + v10);
      v116[-1] = v115;
      *float32x4_t v116 = vbslq_s8(v59, (int8x16_t)v100, (int8x16_t)vmulq_f32(v114, v113));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v117 = -v9;
    if (v117 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v118 = 16 * v117;
    uint64_t v119 = *((void *)this + 51);
    float32x4_t v120 = vmaxq_f32(*(float32x4_t *)(v6 + v118), *(float32x4_t *)v119);
    float32x4_t v121 = vmulq_f32(v120, *(float32x4_t *)(v119 + 16));
    int32x4_t v122 = *(int32x4_t *)(v119 + 32);
    float32x4_t v123 = *(float32x4_t *)(v119 + 48);
    float32x4_t v124 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v122, (int8x16_t)v121), (int8x16_t)v123);
    float32x4_t v125 = *(float32x4_t *)(v119 + 64);
    float32x4_t v126 = *(float32x4_t *)(v119 + 80);
    float32x4_t v127 = *(float32x4_t *)(v119 + 96);
    float32x4_t v128 = *(float32x4_t *)(v119 + 112);
    float32x4_t v129 = (float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgtq_f32(v124, v128));
    float32x4_t v130 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v121, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v126, (int8x16_t)vcgtq_f32(v125, v121))), v127), v129);
    float32x4_t v131 = *(float32x4_t *)(v119 + 128);
    float32x4_t v132 = *(float32x4_t *)(v119 + 144);
    float32x4_t v133 = vsubq_f32(vsubq_f32(v124, v123), vmulq_f32(vmulq_f32(v131, v129), v124));
    float32x4_t v134 = *(float32x4_t *)(v119 + 160);
    float32x4_t v135 = *(float32x4_t *)(v119 + 176);
    float32x4_t v136 = *(float32x4_t *)(v119 + 192);
    float32x4_t v137 = *(float32x4_t *)(v119 + 208);
    float32x4_t v138 = vmulq_f32(v137, vaddq_f32(v130, vmulq_f32(v133, vaddq_f32(vaddq_f32(v135, vmulq_f32(v133, v136)), vmulq_f32(vmulq_f32(v133, v133), vaddq_f32(v132, vmulq_f32(v134, v133)))))));
    float32x4_t v139 = *(float32x4_t *)(v119 + 224);
    float32x4_t v140 = *(float32x4_t *)(v119 + 240);
    float32x4_t v141 = vmaxq_f32(v138, v139);
    float32x4_t v142 = vcvtq_f32_s32(vcvtq_s32_f32(v141));
    float32x4_t v143 = vsubq_f32(v142, (float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgtq_f32(v142, v141)));
    float32x4_t v144 = vsubq_f32(v141, v143);
    float32x4_t v145 = *(float32x4_t *)(v119 + 256);
    float32x4_t v146 = *(float32x4_t *)(v119 + 272);
    int32x4_t v147 = *(int32x4_t *)(v119 + 288);
    int8x16_t v148 = *(int8x16_t *)(v119 + 304);
    int8x16_t v149 = (int8x16_t)vmulq_f32(vaddq_f32(v123, vmulq_f32(v144, vaddq_f32(v146, vmulq_f32(v144, vaddq_f32(v140, vmulq_f32(v145, v144)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v147, vcvtq_s32_f32(v143)), 0x17uLL));
    v150.i64[0] = vextq_s8((int8x16_t)v120, v149, 0xCuLL).u64[0];
    v151.i64[0] = v149.i64[0];
    v151.i64[1] = v120.i64[1];
    *(int8x8_t *)&v150.u32[2] = vext_s8(*(int8x8_t *)v149.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v120, (int8x16_t)v120, 8uLL), 4uLL);
    int32x4_t v152 = (int32x4_t)vbslq_s8(v148, (int8x16_t)vmulq_f32(v146, v150), v151);
    float32x4_t v153 = vaddq_f32((float32x4_t)vrev64q_s32(v152), vmulq_n_f32(v146, *(float *)v152.i32));
    int8x16_t v154 = *(int8x16_t *)(v119 + 320);
    float32x4_t v155 = *(float32x4_t *)(v119 + 336);
    float32x4_t v156 = (float32x4_t)vbslq_s8(v154, (int8x16_t)v153, (int8x16_t)v121);
    float32x4_t v157 = *(float32x4_t *)(v119 + 368);
    float32x4_t v158 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v119 + 352), (int8x16_t)vmulq_f32(v155, v156), (int8x16_t)v156);
    v153.i64[0] = vaddq_f32(vmulq_f32(v157, v158), (float32x4_t)vrev64q_s32((int32x4_t)v158)).u64[0];
    v153.i64[1] = v158.i64[1];
    float32x4_t v159 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v147, (int8x16_t)v153), (int8x16_t)v157);
    float32x4_t v160 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v153, 0x17uLL)), (float32x4_t)vandq_s8((int8x16_t)v140, (int8x16_t)vcgtq_f32(v145, v153))), v139);
    float32x4_t v161 = (float32x4_t)vandq_s8((int8x16_t)v157, (int8x16_t)vcgtq_f32(v159, v137));
    float32x4_t v162 = vsubq_f32(vsubq_f32(v159, v157), vmulq_f32(vmulq_f32(v136, v161), v159));
    float32x4_t v163 = vmaxq_f32(vmulq_f32(v128, vaddq_f32(vaddq_f32(v160, v161), vmulq_f32(v162, vaddq_f32(vaddq_f32(v132, vmulq_f32(v131, v162)), vmulq_f32(vmulq_f32(v162, v162), vaddq_f32(v135, vmulq_f32(v134, v162))))))), v127);
    float32x4_t v164 = vcvtq_f32_s32(vcvtq_s32_f32(v163));
    float32x4_t v165 = vsubq_f32(v164, (float32x4_t)vandq_s8((int8x16_t)v157, (int8x16_t)vcgtq_f32(v164, v163)));
    float32x4_t v166 = vsubq_f32(v163, v165);
    float32x4_t v167 = (float32x4_t)vbslq_s8(v148, (int8x16_t)vmulq_f32(vaddq_f32(v157, vmulq_f32(v166, vaddq_f32(v123, vmulq_f32(v166, vaddq_f32(v126, vmulq_f32(v125, v166)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v165), v122), 0x17uLL)), v151);
    float32x4_t v168 = (float32x4_t)vbslq_s8(v154, (int8x16_t)vaddq_f32(vmulq_laneq_f32(v157, v167, 2), v153), (int8x16_t)v153);
    v125.i64[0] = vextq_s8((int8x16_t)v168, (int8x16_t)v168, 8uLL).u64[0];
    float32x4_t v169 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v119 + 384), v168, 2), v168);
    *(int8x8_t *)v165.f32 = vext_s8(*(int8x8_t *)v125.f32, *(int8x8_t *)v169.f32, 4uLL);
    *(int8x8_t *)&v165.u32[2] = vext_s8(*(int8x8_t *)v169.f32, *(int8x8_t *)v125.f32, 4uLL);
    float32x4_t v170 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v165), *(float32x4_t *)(v119 + 400)), *(float32x4_t *)(v119 + 416)), *(float32x4_t *)(v119 + 432));
    int8x16_t v171 = (int8x16_t)vmulq_f32(vmulq_f32(v170, vrecpsq_f32(v165, v170)), v169);
    *(int8x8_t *)v170.f32 = vext_s8(*(int8x8_t *)v171.i8, *(int8x8_t *)v125.f32, 4uLL);
    *(int8x8_t *)v125.f32 = vext_s8(*(int8x8_t *)v125.f32, *(int8x8_t *)v171.i8, 4uLL);
    v125.i64[1] = v170.i64[0];
    *(int8x16_t *)(v5 + v118) = vbslq_s8(v154, (int8x16_t)v167, (int8x16_t)vmulq_f32(*(float32x4_t *)(v119 + 448), (float32x4_t)vbslq_s8(v154, (int8x16_t)v167, (int8x16_t)vmulq_n_f32(v167, *(float *)vbslq_s8((int8x16_t)vcgtq_f32(v125, *(float32x4_t *)v119), v171, (int8x16_t)v155).i32))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::GetDOD(HgcBT2390_Gain_Sat_ToneAdj *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::GetROI(HgcBT2390_Gain_Sat_ToneAdj *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2390_Gain_Sat_ToneAdj::HgcBT2390_Gain_Sat_ToneAdj(HgcBT2390_Gain_Sat_ToneAdj *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F09B8;
  operator new();
}

void sub_1B7911310(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2390_Gain_Sat_ToneAdj::~HgcBT2390_Gain_Sat_ToneAdj(HGNode *this)
{
  *(void *)this = &unk_1F10F09B8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4019C028F0);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F09B8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4019C028F0);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::SetParameter(HgcBT2390_Gain_Sat_ToneAdj *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcBT2390_Gain_Sat_ToneAdj::GetParameter(HgcBT2390_Gain_Sat_ToneAdj *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcRasterizerTextureNoColor::GetProgram(HgcRasterizerTextureNoColor *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002c8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = half2(frag._texCoord0.xy)/half2(frag._texCoord0.ww);\n"
             "    r0.xy = r0.xy + half2(hg_Params[5].xy);\n"
             "    r0.xy = r0.xy*half2(hg_Params[5].zw);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, float2(r0.xy));\n"
             "    output.color0 = float4(r0)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=4aaae76a:5a25eb2d:36af91f0:a92036c5\n"
             "//SIG=02400000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000296\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy/frag._texCoord0.ww;\n"
             "    r0.xy = r0.xy + hg_Params[5].xy;\n"
             "    r0.xy = r0.xy*hg_Params[5].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    output.color0 = r0*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=b070b0e3:02ff281f:fd62ccc2:049b1c99\n"
             "//SIG=02000000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000031c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy/hg_TexCoord0.ww;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal5.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal5.zw;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=8b328c37:2cd8c50a:51b32aa3:3f5d6ce5\n"
           "//SIG=02000000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcRasterizerTextureNoColor::InitProgramDescriptor(HgcRasterizerTextureNoColor *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcRasterizerTextureNoColor_hgc_visible", "//Metal1.0     \n//LEN=00000001de\n[[ visible ]] FragmentOut HgcRasterizerTextureNoColor_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy/texCoord0.ww;\n"
    "    r0.xy = r0.xy + hg_Params[5].xy;\n"
    "    r0.xy = r0.xy*hg_Params[5].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    output.color0 = r0*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcRasterizerTextureNoColor");
}

void sub_1B791181C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7911854(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B791184CLL);
}

char *HgcRasterizerTextureNoColor::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375DB0;
  strcpy(result, "HgcRasterizerTextureNoColor [hgc1]");
  return result;
}

uint64_t HgcRasterizerTextureNoColor::BindTexture(HgcRasterizerTextureNoColor *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 5, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcRasterizerTextureNoColor::Bind(HgcRasterizerTextureNoColor *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcRasterizerTextureNoColor::RenderFragment(uint64_t a1, float32x4_t *a2, int32x2_t *a3)
{
  *(float32x2_t *)v3.f32 = vadd_f32(vcvt_f32_s32(*a3), (float32x2_t)0x3F0000003F000000);
  v3.i64[1] = 0x3F80000000000000;
  float32x4_t v4 = a2[1];
  float32x4_t v5 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 3);
  __n128 v6 = *(float32x4_t **)(a1 + 408);
  float32x4_t v7 = v6[9];
  float32x4_t v8 = v6[10];
  float32x4_t v9 = vminq_f32(vmaxq_f32(vrecpeq_f32(v5), v7), v8);
  float32x4_t v10 = vminq_f32(vmaxq_f32(vmulq_f32(v9, vrecpsq_f32(v5, v9)), v7), v8);
  int32x2_t v11 = a3[10];
  uint64_t v12 = a3[11].i32[0];
  float32x4_t v13 = vsubq_f32(vmulq_f32(v4, vmulq_f32(v10, vrecpsq_f32(v5, v10))), v3);
  if (a2[14].i32[0])
  {
    int32x4_t v14 = vaddq_s32(vcvtq_s32_f32(v13), vcltzq_f32(v13));
    float32x2_t v15 = (float32x2_t)vsubq_f32(v13, vcvtq_f32_s32(v14)).u64[0];
    float32x4_t v16 = (float32x4_t *)(*(void *)&v11 + 16 * (v14.i32[0] + v14.i32[1] * (int)v12));
    float32x4_t v17 = vaddq_f32(*v16, vmulq_n_f32(vsubq_f32(v16[1], *v16), v15.f32[0]));
    float32x4_t v18 = vmulq_f32(vaddq_f32(v17, vmulq_lane_f32(vsubq_f32(vaddq_f32(v16[v12], vmulq_n_f32(vsubq_f32(v16[(int)v12 + 1], v16[v12]), v15.f32[0])), v17), v15, 1)), *v6);
  }
  else
  {
    v20.i64[0] = 0x3F0000003F000000;
    v20.i64[1] = 0x3F0000003F000000;
    float32x4_t v21 = vaddq_f32(v13, v20);
    int32x4_t v22 = vcvtq_s32_f32(v21);
    v21.i64[0] = vaddq_s32(v22, vcgtq_f32(vcvtq_f32_s32(v22), v21)).u64[0];
    float32x4_t v18 = vmulq_f32(*(float32x4_t *)(*(void *)&v11 + 16 * (v21.i32[0] + v21.i32[1] * (int)v12)), *v6);
  }
  *(float32x4_t *)*(void *)&a3[2] = v18;
  return 0;
}

uint64_t HgcRasterizerTextureNoColor::RenderTile(float32x4_t **this, HGTile *a2)
{
  uint64_t v4 = HGTile::Renderer(a2);
  int v5 = ((uint64_t (*)(float32x4_t **, uint64_t))(*this)[19].i64[1])(this, v4);
  int32x2_t v6 = *(int32x2_t *)a2;
  int v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v7 >= 1)
  {
    uint64_t v8 = (*((_DWORD *)a2 + 2) - v6.i32[0]);
    if ((int)v8 >= 1)
    {
      *(float32x2_t *)v9.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v9.i64[1] = 0x3F80000000000000;
      uint64_t v10 = *((void *)a2 + 2);
      int v11 = 0;
      uint64_t v12 = 16 * *((int *)a2 + 6);
      uint64_t v13 = 16 * v8;
      if (v5)
      {
        float32x4_t v14 = v9;
        do
        {
          uint64_t v15 = 0;
          float32x4_t v16 = v14;
          do
          {
            float32x4_t v17 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3);
            float32x4_t v18 = this[51];
            float32x4_t v19 = v18[9];
            float32x4_t v20 = v18[10];
            float32x4_t v21 = vminq_f32(vmaxq_f32(vrecpeq_f32(v17), v19), v20);
            float32x4_t v22 = vminq_f32(vmaxq_f32(vmulq_f32(v21, vrecpsq_f32(v17, v21)), v19), v20);
            uint64_t v23 = *((int *)a2 + 22);
            float32x4_t v24 = vsubq_f32(vmulq_f32(v16, vmulq_f32(v22, vrecpsq_f32(v17, v22))), v9);
            int32x4_t v25 = vaddq_s32(vcvtq_s32_f32(v24), vcltzq_f32(v24));
            v24.i64[0] = vsubq_f32(v24, vcvtq_f32_s32(v25)).u64[0];
            float32x4_t v26 = (float32x4_t *)(*((void *)a2 + 10) + 16 * (v25.i32[0] + v25.i32[1] * (int)v23));
            float32x4_t v27 = vaddq_f32(*v26, vmulq_n_f32(vsubq_f32(v26[1], *v26), v24.f32[0]));
            *(float32x4_t *)(v10 + v15) = vmulq_f32(vaddq_f32(v27, vmulq_lane_f32(vsubq_f32(vaddq_f32(v26[v23], vmulq_n_f32(vsubq_f32(v26[(int)v23 + 1], v26[v23]), v24.f32[0])), v27), *(float32x2_t *)v24.f32, 1)), *v18);
            float32x4_t v16 = vaddq_f32(v16, (float32x4_t)xmmword_1B7E736B0);
            v15 += 16;
          }
          while (v13 != v15);
          float32x4_t v14 = vaddq_f32(v14, (float32x4_t)xmmword_1B7E736C0);
          ++v11;
          v10 += v12;
        }
        while (v11 != v7);
      }
      else
      {
        v28.i64[0] = 0x3F0000003F000000;
        v28.i64[1] = 0x3F0000003F000000;
        float32x4_t v29 = v9;
        do
        {
          uint64_t v30 = 0;
          float32x4_t v31 = v29;
          do
          {
            float32x4_t v32 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 3);
            float32x4_t v33 = this[51];
            float32x4_t v34 = v33[9];
            float32x4_t v35 = v33[10];
            float32x4_t v36 = vminq_f32(vmaxq_f32(vrecpeq_f32(v32), v34), v35);
            float32x4_t v37 = vminq_f32(vmaxq_f32(vmulq_f32(v36, vrecpsq_f32(v32, v36)), v34), v35);
            float32x4_t v38 = vaddq_f32(vsubq_f32(vmulq_f32(v31, vmulq_f32(v37, vrecpsq_f32(v32, v37))), v9), v28);
            int32x4_t v39 = vcvtq_s32_f32(v38);
            v38.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v38)).u64[0];
            *(float32x4_t *)(v10 + v30) = vmulq_f32(*(float32x4_t *)(*((void *)a2 + 10)+ 16 * (v38.i32[0] + v38.i32[1] * *((_DWORD *)a2 + 22))), *v33);
            float32x4_t v31 = vaddq_f32(v31, (float32x4_t)xmmword_1B7E736B0);
            v30 += 16;
          }
          while (v13 != v30);
          float32x4_t v29 = vaddq_f32(v29, (float32x4_t)xmmword_1B7E736C0);
          ++v11;
          v10 += v12;
        }
        while (v11 != v7);
      }
    }
  }
  return 0;
}

uint64_t HgcRasterizerTextureNoColor::GetDOD(HgcRasterizerTextureNoColor *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  int32x2_t v6 = *(const HGTransform **)&a4.var0;
  if ((*(int (**)(HgcRasterizerTextureNoColor *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
  {
    uint64_t v8 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    int32x2_t v6 = (const HGTransform *)HGRectGrow((uint64_t)v6, v5, v8);
    uint64_t v5 = v9;
  }
  HGTransform::HGTransform((HGTransform *)v15);
  HGTransform::LoadMatrixf(v15, (float32x2_t *)(*((void *)this + 51) + 16));
  HGTransform::Invert2D((HGTransform *)v15);
  float v11 = HGTransformUtils::MinW(v10);
  *(void *)&v16.var0 = v5;
  uint64_t DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v15, v6, v16, 0.5, v11);
  uint64_t v4 = HGRectUnion(0, 0, DOD, v13);
  HGTransform::~HGTransform((HGTransform *)v15);
  return v4;
}

void sub_1B7911FF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7912008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HgcRasterizerTextureNoColor::GetROI(HgcRasterizerTextureNoColor *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = 0;
  if (!a3)
  {
    uint64_t v5 = *(void *)&a4.var2;
    unint64_t v6 = *(void *)&a4.var0;
    HGTransform::HGTransform((HGTransform *)v17);
    HGTransform::LoadMatrixf(v17, (float32x2_t *)(*((void *)this + 51) + 16));
    float v10 = HGTransformUtils::MinW(v9);
    *(void *)&v18.var0 = v5;
    uint64_t ROI = HGTransformUtils::GetROI((HGTransformUtils *)v17, v6, v18, 0.5, v10);
    uint64_t v4 = HGRectUnion(0, 0, ROI, v12);
    uint64_t v14 = v13;
    HGTransform::~HGTransform((HGTransform *)v17);
    if ((*(int (**)(HgcRasterizerTextureNoColor *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
    {
      uint64_t v15 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      return HGRectGrow(v4, v14, v15);
    }
  }
  return v4;
}

void sub_1B791213C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7912150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HgcRasterizerTextureNoColor::HgcRasterizerTextureNoColor(HgcRasterizerTextureNoColor *this)
{
  HGNode3D::HGNode3D(this);
  *(void *)uint64_t v1 = &unk_1F10F0C20;
  *(_DWORD *)(v1 + 416) = 1;
  operator new();
}

void sub_1B7912254(_Unwind_Exception *a1)
{
  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HgcRasterizerTextureNoColor::~HgcRasterizerTextureNoColor(HgcRasterizerTextureNoColor *this)
{
  *(void *)this = &unk_1F10F0C20;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40C3A7E6FCLL);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F0C20;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40C3A7E6FCLL);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F0C20;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40C3A7E6FCLL);
  }
  HGMipmapLevel::~HGMipmapLevel(this);

  HGObject::operator delete(v3);
}

uint64_t HgcRasterizerTextureNoColor::SetParameter(HgcRasterizerTextureNoColor *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  *((_DWORD *)this + 104) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcRasterizerTextureNoColor::GetParameter(HgcRasterizerTextureNoColor *this, int a2, float *a3)
{
  if (!a2)
  {
    float32x4_t v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

double HgcRasterizerTextureNoColor::GetOutput(HgcRasterizerTextureNoColor *this, HGRenderer *a2)
{
  if (*((_DWORD *)this + 104))
  {
    uint64_t v2 = *((void *)this + 51);
    long long v3 = *(_OWORD *)(v2 + 96);
    *(_OWORD *)(v2 + 16) = *(unint64_t *)(v2 + 80);
    *(_OWORD *)(*((void *)this + 51) + 32) = (unint64_t)v3;
    *(_OWORD *)(*((void *)this + 51) + 48) = xmmword_1B7E736D0;
    double result = 0.0;
    *(_OWORD *)(*((void *)this + 51) + 64) = xmmword_1B7E734D0;
    *((_DWORD *)this + 104) = 0;
  }
  return result;
}

const char *HgcDemosaic_1::GetProgram(HgcDemosaic_1 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return aMetal10Len0000_1118;
    }
    else {
      return aMetal10Len0000_1119;
    }
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_421;
  }
}

void HgcDemosaic_1::InitProgramDescriptor(HgcDemosaic_1 *this, HGProgramDescriptor *a2)
{
}

void sub_1B79128D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B791290C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7912904);
}

void HgcDemosaic_1::shaderDescription(char *a1@<X8>)
{
  a1[23] = 20;
  strcpy(a1, "HgcDemosaic_1 [hgc1]");
}

uint64_t HgcDemosaic_1::BindTexture(HgcDemosaic_1 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 3, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcDemosaic_1::Bind(HgcDemosaic_1 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcDemosaic_1::RenderTile(HgcDemosaic_1 *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    uint64_t v4 = (a2[1].i32[0] - v2.i32[0]);
    if ((int)v4 >= 1)
    {
      int v5 = 0;
      uint64_t v6 = a2[11].i32[0];
      *(float32x2_t *)v7.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v7.i64[1] = 0x3F80000000000000;
      __n128 v8 = (int8x16_t *)a2[10];
      int32x2_t v9 = a2[2];
      float v10 = &v8[2 * (int)v6];
      uint64_t v11 = 16 * v6;
      uint64_t v12 = &v8[v6];
      int v13 = -2 * v6;
      int v14 = -(int)v6;
      uint64_t v15 = 16 * a2[3].i32[0];
      int8x16_t v16 = 0uLL;
      do
      {
        uint64_t v17 = 0;
        HGRect v18 = v8;
        float32x4_t v225 = v7;
        float32x4_t v19 = v8;
        do
        {
          float32x4_t v227 = v7;
          float32x4_t v20 = vcvtq_f32_s32(vcvtq_s32_f32(v7));
          uint64_t v21 = *((void *)this + 51);
          float32x4_t v23 = *(float32x4_t *)(v21 + 32);
          float32x4_t v22 = *(float32x4_t *)(v21 + 48);
          float32x4_t v24 = vsubq_f32(v20, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v20, v7)));
          v25.i64[0] = v24.i64[0];
          v25.i64[1] = vmulq_f32(v22, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v24, 0)).i64[1];
          float32x4_t v26 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
          float32x4_t v28 = *(float32x4_t *)(v21 + 64);
          float32x4_t v27 = *(float32x4_t *)(v21 + 80);
          int8x16_t v29 = (int8x16_t)vsubq_f32(v26, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v26, v25), (int8x16_t)v28, v16));
          float32x4_t v30 = (float32x4_t)vextq_s8(v29, (int8x16_t)v24, 8uLL);
          v24.i64[1] = v29.i64[1];
          int8x16_t v31 = (int8x16_t)vsubq_f32(v24, vmulq_lane_f32(v30, *(float32x2_t *)v28.f32, 1));
          float32x4_t v32 = vaddq_f32((float32x4_t)vextq_s8(v31, v31, 8uLL), vmulq_lane_f32(v27, *(float32x2_t *)v31.i8, 1));
          float32x4_t v33 = *(float32x4_t *)(v21 + 16);
          float32x4_t v34 = (float32x4_t)vrev64q_s32(*(int32x4_t *)v21);
          int8x16_t v35 = v19[1];
          ++v19;
          int8x16_t v37 = *(int8x16_t *)(v21 + 96);
          float32x4_t v36 = *(float32x4_t *)(v21 + 112);
          int8x16_t v38 = (int8x16_t)vsubq_f32(v34, (float32x4_t)vextq_s8((int8x16_t)v32, (int8x16_t)v32, 4uLL));
          float32x4_t v39 = (float32x4_t)vextq_s8(*(int8x16_t *)v21, *(int8x16_t *)v21, 8uLL);
          float32x4_t v40 = (float32x4_t)vrev64q_s32((int32x4_t)vsubq_f32(vaddq_f32(v39, v32), v36));
          float32x4_t v41 = (float32x4_t)vbslq_s8(v37, v8[(v17 + 2)], v38);
          v40.i64[0] = v41.i64[0];
          int8x16_t v42 = (int8x16_t)vabsq_f32(v40);
          int32x4_t v43 = (int32x4_t)vbslq_s8(v37, v18[-2], v42);
          *(int8x8_t *)v38.i8 = vorr_s8(vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32((int32x4_t)vbslq_s8(v37, v35, v38)), (int8x8_t)*(_OWORD *)&vmvnq_s8(v37)), vand_s8(*(int8x8_t *)v18[-1].i8, *(int8x8_t *)v37.i8));
          float32x4_t v44 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v21, 3);
          v38.i64[1] = v43.i64[0];
          int8x16_t v45 = *(int8x16_t *)(v21 + 128);
          int8x16_t v46 = *(int8x16_t *)(v21 + 144);
          float32x4_t v47 = (float32x4_t)vbslq_s8(v45, vextq_s8((int8x16_t)v41, (int8x16_t)v41, 4uLL), v38);
          float32x4_t v48 = (float32x4_t)vbslq_s8(v37, vbslq_s8((int8x16_t)vcgtq_f32(v28, (float32x4_t)vbslq_s8(v37, (int8x16_t)vsubq_f32((float32x4_t)vrev64q_s32(v43), v27), v42)), (int8x16_t)v23, (int8x16_t)vrev64q_s32((int32x4_t)v23)), v42);
          *(int8x8_t *)v49.f32 = vqtbl1_s8((int8x16_t)v48, *(int8x8_t *)v46.i8);
          int8x8_t v50 = (int8x8_t)vextq_s8(v46, v46, 8uLL).u64[0];
          *(int8x8_t *)&v49.u32[2] = vqtbl1_s8((int8x16_t)v48, v50);
          int8x16_t v51 = vandq_s8((int8x16_t)v28, (int8x16_t)vcgtq_f32(v22, v49));
          v49.i64[0] = vextq_s8(v51, v51, 8uLL).u64[0];
          *(int8x8_t *)v41.f32 = vext_s8(*(int8x8_t *)v49.f32, *(int8x8_t *)v48.f32, 4uLL);
          *(int8x8_t *)v49.f32 = vext_s8(*(int8x8_t *)v48.f32, *(int8x8_t *)v49.f32, 4uLL);
          float32x4_t v52 = (float32x4_t)vextq_s8(v51, (int8x16_t)v48, 8uLL);
          v48.i64[1] = v51.i64[1];
          v49.i64[1] = v41.i64[0];
          float32x4_t v53 = vmaxq_f32(v49, v52);
          float32x4_t v54 = (float32x4_t)vbslq_s8(v37, (int8x16_t)v48, (int8x16_t)vrev64q_s32((int32x4_t)vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32(v36, v7))));
          float32x4_t v55 = vmulq_laneq_f32(vsubq_f32(v47, v44), v23, 2);
          v48.i64[0] = *(void *)(v21 + 112);
          int8x16_t v56 = (int8x16_t)vminq_f32(v53, v54);
          int8x16_t v57 = vextq_s8((int8x16_t)v55, v56, 0xCuLL);
          int8x8_t v58 = (int8x8_t)vextq_s8(v57, v57, 8uLL).u64[0];
          *(int32x2_t *)&v48.u32[2] = vdup_lane_s32(*(int32x2_t *)v54.f32, 0);
          v41.i64[0] = vextq_s8(v57, (int8x16_t)v54, 0xCuLL).u64[0];
          v57.i64[0] = v54.i64[0];
          int32x4_t v59 = *(int32x4_t *)(v21 + 160);
          float32x4_t v60 = *(float32x4_t *)(v21 + 176);
          int8x16_t v61 = (int8x16_t)vminq_f32(v55, v48);
          *(int8x8_t *)v62.i8 = vqtbl1_s8(v61, *(int8x8_t *)v59.i8);
          v27.i64[0] = vextq_s8((int8x16_t)v59, (int8x16_t)v59, 8uLL).u64[0];
          *(int8x8_t *)v63.i8 = vqtbl1_s8(v61, *(int8x8_t *)v46.i8);
          *(int8x8_t *)&v41.u32[2] = vext_s8(*(int8x8_t *)v54.f32, v58, 4uLL);
          v62.u64[1] = (unint64_t)vqtbl1_s8(v61, *(int8x8_t *)v27.f32);
          int8x8_t v64 = vqtbl1_s8(v61, v50);
          int8x16_t v65 = *(int8x16_t *)(v21 + 192);
          float32x4_t v66 = *(float32x4_t *)(v21 + 208);
          int8x16_t v67 = vbslq_s8(v65, vandq_s8((int8x16_t)v28, (int8x16_t)vcgeq_f32(vnegq_f32(v41), v60)), v61);
          v63.u64[1] = (unint64_t)v64;
          int8x16_t v68 = vbslq_s8(v37, v57, (int8x16_t)vsubq_f32((float32x4_t)vrev64q_s32((int32x4_t)vbslq_s8(v37, *v18, v67)), v39));
          int64x2_t v69 = (int64x2_t)vmulq_lane_f32(v23, *(float32x2_t *)v68.i8, 1);
          v57.i64[0] = v53.i64[0];
          v57.i64[1] = v69.i64[1];
          int8x16_t v70 = (int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.i8, 1), v60);
          v53.i64[1] = vdupq_laneq_s64(v69, 1).u64[0];
          int8x16_t v71 = (int8x16_t)vcgtq_f32(v60, v7);
          float32x4_t v72 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vminq_f32((float32x4_t)vextq_s8(v68, v68, 4uLL), (float32x4_t)vrev64q_s32((int32x4_t)v53)), v57);
          float32x4_t v73 = (float32x4_t)vorrq_s8(vbicq_s8(v67, v37), vandq_s8(vandq_s8(v37, (int8x16_t)v36), v71));
          float32x4_t v74 = (float32x4_t)vextq_s8((int8x16_t)v72, (int8x16_t)v72, 0xCuLL);
          float32x4_t v75 = (float32x4_t)vbslq_s8(v65, (int8x16_t)vminq_f32(v74, v73), (int8x16_t)v73);
          int64x2_t v76 = (int64x2_t)vbslq_s8(v70, v63, v62);
          int8x16_t v77 = vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)vextq_s8((int8x16_t)v75, (int8x16_t)v75, 4uLL)), v75), v28), (int8x16_t)v74, vextq_s8((int8x16_t)v76, (int8x16_t)v76, 0xCuLL));
          int8x16_t v78 = (int8x16_t)vcgeq_f32(vnegq_f32(v75), v28);
          float32x4_t v79 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vsubq_f32(v34, v36), (int8x16_t)v75);
          int8x16_t v80 = (int8x16_t)vdupq_lane_s64(v77.i64[0], 0);
          int8x16_t v81 = vandq_s8((int8x16_t)v36, v78);
          float32x4_t v82 = (float32x4_t)vbslq_s8(v65, (int8x16_t)vminq_f32(v79, (float32x4_t)vextq_s8(v81, v81, 8uLL)), (int8x16_t)v79);
          int32x4_t v83 = (int32x4_t)vbslq_s8(v37, vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32(v7, v82)), (int8x16_t)v82);
          v82.i64[0] = vextq_s8((int8x16_t)v76, (int8x16_t)v76, 8uLL).u64[0];
          int8x16_t v84 = vextq_s8(v80, v80, 8uLL);
          v80.i64[0] = v76.i64[1];
          *(int8x8_t *)v59.i8 = vqtbl1_s8((int8x16_t)v83, *(int8x8_t *)v59.i8);
          v82.i64[1] = v84.i64[0];
          *(int8x8_t *)v84.i8 = vqtbl1_s8((int8x16_t)v82, *(int8x8_t *)v46.i8);
          float32x4_t v85 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v83, 2), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v83.i8, 0)), v66), v84, (int8x16_t)v59);
          int8x16_t v86 = *(int8x16_t *)(v21 + 224);
          float32x4_t v87 = *(float32x4_t *)(v21 + 240);
          float32x4_t v88 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vsubq_f32(*(float32x4_t *)v21, v60), (int8x16_t)v83);
          v59.i64[0] = v85.i64[0];
          float32x4_t v89 = (float32x4_t)vextq_s8((int8x16_t)v76, (int8x16_t)v85, 8uLL);
          v60.i64[0] = vdupq_laneq_s64(v76, 1).u64[0];
          v85.i64[1] = v76.i64[1];
          float32x4_t v90 = (float32x4_t)vbslq_s8(v37, vandq_s8((int8x16_t)v36, (int8x16_t)vcgeq_f32(vnegq_f32(v88), v66)), (int8x16_t)v88);
          v59.i64[1] = v60.i64[0];
          float32x4_t v91 = (float32x4_t)vbslq_s8(v86, vandq_s8((int8x16_t)v36, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v7), v90)), (int8x16_t)v90);
          float32x4_t v92 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v91, (int8x16_t)v91, 8uLL), v91), (int8x16_t)v91);
          float32x4_t v93 = (float32x4_t)vextq_s8((int8x16_t)v72, (int8x16_t)v72, 8uLL);
          float32x4_t v94 = (float32x4_t)vbslq_s8(v37, v77, vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v92), v92), v66), (int8x16_t)v93, (int8x16_t)v85));
          float32x4_t v95 = (float32x4_t)vbslq_s8(v45, vextq_s8((int8x16_t)v94, (int8x16_t)v94, 8uLL), vbslq_s8(v86, (int8x16_t)vrev64q_s32(v59), v80));
          float32x4_t v96 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 0);
          float32x4_t v97 = vaddq_f32(v96, v95);
          float32x4_t v226 = v95;
          float32x4_t v98 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2);
          float32x4_t v99 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 3);
          float32x4_t v100 = vaddq_f32(vmaxq_f32(vmulq_lane_f32(vmulq_f32(v97, v97), *(float32x2_t *)v33.f32, 1), v98), v99);
          float32x4_t v101 = vminq_f32(vrsqrteq_f32(v100), v87);
          float32x4_t v102 = vminq_f32(vmulq_f32(v101, vrsqrtsq_f32(vmulq_f32(v100, v101), v101)), v87);
          float32x4_t v103 = vmulq_f32(v100, vminq_f32(vmulq_f32(v102, vrsqrtsq_f32(vmulq_f32(v100, v102), v102)), v87));
          v90.i64[0] = v27.i64[0];
          float32x4_t v104 = (float32x4_t)vrev64q_s32((int32x4_t)v94);
          v105.i64[0] = vsubq_f32(v104, v94).u64[0];
          float32x4_t v106 = vsubq_f32(v89, v85);
          v105.u64[1] = (unint64_t)vadd_f32((float32x2_t)vqtbl1_s8((int8x16_t)v103, *(int8x8_t *)v27.f32), (float32x2_t)vqtbl1_s8((int8x16_t)v103, v50));
          int8x16_t v107 = vbslq_s8(v37, (int8x16_t)vmulq_lane_f32(v106, *(float32x2_t *)v105.i8, 1), v105);
          int8x16_t v108 = vmvnq_s8(v65);
          int8x16_t v109 = (int8x16_t)vabsq_f32((float32x4_t)vextq_s8((int8x16_t)v106, (int8x16_t)v106, 8uLL));
          int8x16_t v110 = (int8x16_t)vabsq_f32((float32x4_t)vextq_s8(v107, v107, 8uLL));
          int8x8_t v111 = (int8x8_t)vsubq_f32(v104, v74).u64[0];
          float32x4_t v112 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v86, (int8x16_t)vsubq_f32(v104, v93), v107), *(float *)v111.i32), v107);
          *(int8x8_t *)v109.i8 = vorr_s8(vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(v110, v110, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v108, v108, 8uLL)), vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(v65, v65, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v109, v109, 8uLL)));
          float32x4_t v113 = *(float32x4_t *)(v21 + 256);
          long long v114 = *(_OWORD *)(v21 + 272);
          *(int8x8_t *)v115.f32 = vbic_s8(v111, *(int8x8_t *)&v114);
          v115.i64[1] = v109.i64[0];
          float32x4_t v116 = (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v95, v103));
          float32x4_t v117 = (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v112, v115));
          v109.i64[0] = vmaxq_f32(v117, (float32x4_t)vrev64q_s32((int32x4_t)v117)).u64[0];
          v109.i64[1] = v117.i64[1];
          float32x4_t v118 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vminq_f32(vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v116), v116), (float32x4_t)vextq_s8((int8x16_t)v116, (int8x16_t)v116, 4uLL)), v109);
          float32x4_t v119 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vmaxq_f32(v118, (float32x4_t)vextq_s8((int8x16_t)v118, (int8x16_t)v118, 8uLL)), (int8x16_t)v118);
          float32x4_t v120 = (float32x4_t)vextq_s8((int8x16_t)v119, (int8x16_t)v119, 8uLL);
          float32x4_t v121 = (float32x4_t)vrev64q_s32((int32x4_t)v119);
          v119.i64[0] = vminq_f32(v119, (float32x4_t)vextq_s8((int8x16_t)v116, (int8x16_t)v116, 8uLL)).u64[0];
          v119.i64[1] = vmaxq_f32(v120, v121).i64[1];
          int8x16_t v122 = vbslq_s8(v37, v8[v13 + (int)v17], (int8x16_t)v119);
          int8x16_t v123 = vextq_s8(v122, v122, 8uLL);
          v119.i64[0] = vbslq_s8(v37, v123, (int8x16_t)v119).u64[0];
          v123.i64[0] = vbslq_s8(v37, v8[v14 + (int)v17], (int8x16_t)vrev64q_s32((int32x4_t)v12[v17])).u64[0];
          float32x4_t v124 = (float32x4_t)vextq_s8((int8x16_t)v227, (int8x16_t)v227, 0xCuLL);
          int64x2_t v125 = (int64x2_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v113, v124));
          v95.i64[0] = v119.i64[0];
          v95.i64[1] = vdupq_laneq_s64(v125, 1).u64[0];
          v119.i64[1] = v125.i64[1];
          float32x4_t v126 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vminq_f32(v93, (float32x4_t)vrev64q_s32((int32x4_t)v95)), (int8x16_t)v119);
          int32x4_t v127 = (int32x4_t)vminq_f32(v48, vmulq_laneq_f32(vsubq_f32((float32x4_t)vbslq_s8(v45, vextq_s8(v10[v17], v10[v17], 4uLL), v123), v44), v23, 2));
          int8x16_t v128 = vandq_s8((int8x16_t)v113, v71);
          int8x16_t v129 = vbslq_s8(v65, vextq_s8(v128, v128, 0xCuLL), (int8x16_t)v127);
          float32x4_t v130 = (float32x4_t)vrev64q_s32((int32x4_t)v72);
          float32x4_t v131 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vsubq_f32(v130, vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v126, (int8x16_t)v126, 8uLL), *(float32x2_t *)v72.f32, 1)), v129);
          int8x16_t v132 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v126, 1), v66), (int8x16_t)v127, (int8x16_t)vrev64q_s32(v127));
          float32x4_t v133 = (float32x4_t)vextq_s8((int8x16_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v131, (int8x16_t)v131, 8uLL), v131), (int8x16_t)v126, 8uLL);
          v126.i64[1] = v131.i64[1];
          int32x4_t v134 = (int32x4_t)vbslq_s8(v86, (int8x16_t)v126, vandq_s8((int8x16_t)v113, (int8x16_t)vcgeq_f32(vnegq_f32(v126), v66)));
          float32x4_t v135 = (float32x4_t)vbslq_s8(v65, vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v124, (float32x4_t)vbslq_s8(v65, (int8x16_t)vsubq_f32(*(float32x4_t *)v21, v113), (int8x16_t)v131))), (int8x16_t)v131);
          float32x4_t v136 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vminq_f32(v135, (float32x4_t)vextq_s8((int8x16_t)v134, (int8x16_t)v134, 8uLL)), (int8x16_t)v135);
          int8x16_t v137 = *(int8x16_t *)(v21 + 304);
          int8x16_t v138 = vbslq_s8(*(int8x16_t *)(v21 + 288), (int8x16_t)v85, v132);
          *(int8x8_t *)v123.i8 = vqtbl1_s8((int8x16_t)v136, v50);
          int8x16_t v139 = vandq_s8((int8x16_t)v113, (int8x16_t)vcgeq_f32(vnegq_f32(v136), v66));
          v140.i64[0] = v136.i64[0];
          v140.i64[1] = v139.i64[1];
          v139.i64[0] = vminq_f32(v140, (float32x4_t)vextq_s8(v139, (int8x16_t)v136, 8uLL)).u64[0];
          float32x4_t v141 = *(float32x4_t *)(v21 + 80);
          v139.i64[1] = vsubq_f32(*(float32x4_t *)v21, v141).i64[1];
          int8x16_t v142 = vbslq_s8((int8x16_t)vcgtq_f32(v133, v66), (int8x16_t)v74, vextq_s8(v138, v138, 0xCuLL));
          *(int32x2_t *)v85.f32 = vrev64_s32(*(int32x2_t *)v138.i8);
          v85.i64[1] = v142.i64[0];
          v123.i64[1] = v123.i64[0];
          *(int8x8_t *)v71.i8 = vqtbl1_s8((int8x16_t)v85, *(int8x8_t *)v90.f32);
          v71.i64[1] = v71.i64[0];
          int8x16_t v143 = vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v136.f32, 0), (float32x4_t)vdupq_laneq_s32((int32x4_t)v136, 2)), v66), v71, v123);
          float32x4_t v144 = (float32x4_t)vrev64q_s32((int32x4_t)v33);
          float32x4_t v145 = (float32x4_t)vbslq_s8(v86, (int8x16_t)vaddq_f32(v144, v93), v139);
          v145.i64[1] = vandq_s8(*(int8x16_t *)&v113, (int8x16_t)vcgtq_f32(v124, v145)).i64[1];
          float32x4_t v146 = vmulq_f32((float32x4_t)vdupq_lane_s64(v145.i64[0], 0), v145);
          v100.i64[1] = v143.i64[1];
          int8x16_t v147 = (int8x16_t)vmulq_lane_f32(v144, *(float32x2_t *)v146.f32, 1);
          float32x4_t v148 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v33, (int8x16_t)v33, 4uLL), vmaxq_f32((float32x4_t)vextq_s8(v147, v147, 8uLL), v33));
          float32x4_t v149 = vminq_f32(vrsqrteq_f32(v148), v87);
          float32x4_t v150 = vminq_f32(vmulq_f32(v149, vrsqrtsq_f32(vmulq_f32(v149, v148), v149)), v87);
          float32x4_t v151 = vmulq_f32(v148, vminq_f32(vmulq_f32(v150, vrsqrtsq_f32(vmulq_f32(v148, v150), v150)), v87));
          v150.i64[0] = v134.i64[0];
          v150.i64[1] = v151.i64[1];
          int8x16_t v152 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v146, (int8x16_t)v146, 4uLL), v66), (int8x16_t)v93, vextq_s8((int8x16_t)v100, (int8x16_t)v100, 8uLL));
          int64x2_t v153 = (int64x2_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v130, v150));
          v146.i64[0] = v134.i64[0];
          v144.i64[0] = vdupq_laneq_s64(v153, 1).u64[0];
          v146.i64[1] = v153.i64[1];
          float32x4_t v154 = (float32x4_t)vbslq_s8(v37, v142, v152);
          v134.i64[1] = v144.i64[0];
          float32x4_t v155 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vminq_f32(v93, (float32x4_t)vrev64q_s32(v134)), (int8x16_t)v100);
          float32x4_t v156 = (float32x4_t)vextq_s8((int8x16_t)v155, (int8x16_t)v155, 0xCuLL);
          float32x4_t v157 = (float32x4_t)vbslq_s8(v86, vextq_s8((int8x16_t)v155, (int8x16_t)v155, 4uLL), vbslq_s8(v45, vextq_s8((int8x16_t)v154, (int8x16_t)v154, 8uLL), (int8x16_t)v85));
          float32x4_t v158 = vaddq_f32(v96, v157);
          float32x4_t v159 = vaddq_f32(v99, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v158, v158), *(float32x2_t *)v33.f32, 1), v98));
          float32x4_t v160 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vminq_f32(v156, v146), (int8x16_t)v146);
          *(int8x8_t *)v144.f32 = vqtbl1_s8((int8x16_t)v159, *(int8x8_t *)v137.i8);
          v158.i64[0] = vextq_s8(v137, v137, 8uLL).u64[0];
          *(int8x8_t *)&v144.u32[2] = vqtbl1_s8((int8x16_t)v159, *(int8x8_t *)v158.f32);
          float32x4_t v161 = vminq_f32(vrsqrteq_f32(v144), v87);
          int8x16_t v162 = vbslq_s8((int8x16_t)vcgtq_f32(v160, v66), (int8x16_t)v66, (int8x16_t)vrev64q_s32((int32x4_t)v160));
          float32x4_t v163 = vminq_f32(vmulq_f32(v161, vrsqrtsq_f32(vmulq_f32(v161, v144), v161)), v87);
          int8x16_t v164 = *(int8x16_t *)(v21 + 320);
          float32x4_t v165 = *(float32x4_t *)(v21 + 336);
          int8x16_t v166 = (int8x16_t)vmulq_f32(v163, vrsqrtsq_f32(vmulq_f32(v144, v163), v163));
          *(int8x8_t *)v144.f32 = vqtbl1_s8(v166, *(int8x8_t *)v164.i8);
          v96.i64[0] = vextq_s8(v164, v164, 8uLL).u64[0];
          *(int8x8_t *)&v144.u32[2] = vqtbl1_s8(v166, *(int8x8_t *)v96.f32);
          float32x4_t v167 = vminq_f32(vmaxq_f32(vrecpeq_f32(v144), v165), v87);
          int8x16_t v168 = (int8x16_t)vaddq_f32(v104, v94);
          float32x4_t v169 = (float32x4_t)vrev64q_s32((int32x4_t)vbslq_s8(v37, v168, v166));
          float32x4_t v170 = vminq_f32(vmaxq_f32(vrecpeq_f32(v169), v165), v87);
          float32x4_t v171 = vminq_f32(vmaxq_f32(vmulq_f32(v170, vrecpsq_f32(v169, v170)), v165), v87);
          float32x4_t v172 = vminq_f32(vmaxq_f32(vmulq_f32(v167, vrecpsq_f32(v144, v167)), v165), v87);
          float32x4_t v173 = (float32x4_t)vrev64q_s32((int32x4_t)v154);
          float32x4_t v174 = vaddq_f32((float32x4_t)vdupq_lane_s64(vbslq_s8(v37, v168, (int8x16_t)vaddq_f32(v173, v154)).i64[0], 0), vmulq_laneq_f32(*(float32x4_t *)(v21 + 352), v72, 3));
          int8x16_t v175 = (int8x16_t)vmulq_f32(v171, vrecpsq_f32(v169, v171));
          float32x4_t v176 = vminq_f32(vrsqrteq_f32(v159), v165);
          float32x4_t v177 = vminq_f32(vmulq_f32(v176, vrsqrtsq_f32(vmulq_f32(v159, v176), v176)), v165);
          float32x4_t v178 = vmulq_f32(v172, vrecpsq_f32(v144, v172));
          float32x4_t v179 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vmulq_f32(v159, vminq_f32(vmulq_f32(v177, vrsqrtsq_f32(vmulq_f32(v159, v177), v177)), v165)), vbslq_s8(v37, v175, (int8x16_t)v178));
          float32x4_t v180 = vaddq_f32(v174, v174);
          float32x4_t v181 = vminq_f32(vmaxq_f32(vrecpeq_f32(v180), v165), v87);
          float32x4_t v182 = vminq_f32(vmaxq_f32(vmulq_f32(v181, vrecpsq_f32(v180, v181)), v165), v87);
          int8x16_t v183 = vbslq_s8(v37, v162, (int8x16_t)v178);
          v178.i64[0] = vbslq_s8(v37, (int8x16_t)vmulq_f32(v182, vrecpsq_f32(v180, v182)), (int8x16_t)vsubq_f32(v173, v154)).u64[0];
          float32x4_t v184 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vminq_f32(v155, (float32x4_t)vextq_s8(v183, v183, 4uLL)), v138);
          v180.i64[0] = v178.i64[0];
          float32x4_t v185 = (float32x4_t)vextq_s8((int8x16_t)v184, (int8x16_t)v184, 0xCuLL);
          *(float32x2_t *)&v180.u32[2] = vadd_f32((float32x2_t)vqtbl1_s8((int8x16_t)v179, *(int8x8_t *)v96.f32), (float32x2_t)vqtbl1_s8((int8x16_t)v179, *(int8x8_t *)v158.f32));
          v178.i64[1] = v180.i64[1];
          float32x4_t v186 = vsubq_f32(v185, v155);
          v154.i64[1] = v186.i64[1];
          int8x16_t v187 = vbslq_s8(v37, (int8x16_t)vmulq_laneq_f32((float32x4_t)vrev64q_s32((int32x4_t)v178), v186, 2), (int8x16_t)v180);
          float32x4_t v188 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vabsq_f32((float32x4_t)vextq_s8(v187, v187, 8uLL)), (int8x16_t)v154);
          v74.i64[0] = vsubq_f32(v188, v74).u64[0];
          *(int8x8_t *)v178.f32 = vbic_s8(*(int8x8_t *)v74.f32, *(int8x8_t *)&v114);
          *(int8x8_t *)&v178.u32[2] = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v188, (int8x16_t)v188, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v21 + 368), *(int8x16_t *)(v21 + 368), 8uLL));
          float32x4_t v189 = (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v86, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v86, (int8x16_t)vsubq_f32(v188, v93), v187), v74.f32[0]), v187), v178));
          float32x4_t v190 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v189, (int8x16_t)v189, 4uLL), v189);
          float32x4_t v191 = (float32x4_t)vandq_s8((int8x16_t)v113, (int8x16_t)vcgtq_f32(v157, v179));
          int8x16_t v192 = (int8x16_t)vminq_f32(vmaxq_f32(vaddq_f32(v190, (float32x4_t)vextq_s8((int8x16_t)v190, (int8x16_t)v190, 8uLL)), v66), v113);
          int8x16_t v193 = (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v37, v192, (int8x16_t)vminq_f32((float32x4_t)vbslq_s8(v37, v192, (int8x16_t)vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v191), v191)), (float32x4_t)vextq_s8((int8x16_t)v191, (int8x16_t)v191, 4uLL))), (float32x4_t)vextq_s8((int8x16_t)v191, (int8x16_t)v191, 8uLL));
          float32x4_t v194 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vmulq_laneq_f32(v180, v174, 2), (int8x16_t)v174);
          int8x16_t v195 = vbslq_s8(v37, vandq_s8((int8x16_t)v113, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vbslq_s8(v37, v192, v193)), v66)), v193);
          float32x4_t v196 = (float32x4_t)vextq_s8(v195, (int8x16_t)vaddq_f32(v194, v194), 0xCuLL);
          v196.i64[0] = v195.i64[0];
          float32x4_t v197 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vminq_f32(v156, v196), (int8x16_t)v196);
          v196.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32(v197, v66), (int8x16_t)v66, (int8x16_t)vrev64q_s32((int32x4_t)v197)).u64[0];
          v178.i64[0] = vextq_s8((int8x16_t)v197, (int8x16_t)v197, 8uLL).u64[0];
          *(int8x8_t *)v180.f32 = vext_s8(*(int8x8_t *)v178.f32, *(int8x8_t *)v196.f32, 4uLL);
          *(int8x8_t *)v178.f32 = vext_s8(*(int8x8_t *)v196.f32, *(int8x8_t *)v178.f32, 4uLL);
          v178.i64[1] = v180.i64[0];
          v196.i64[1] = v197.i64[1];
          float32x4_t v198 = vminq_f32(vmaxq_f32(vrecpeq_f32(v178), v165), v87);
          float32x4_t v199 = vminq_f32(vmaxq_f32(vmulq_f32(v198, vrecpsq_f32(v178, v198)), v165), v87);
          int8x16_t v200 = (int8x16_t)vmulq_laneq_f32(vmulq_f32(v199, vrecpsq_f32(v178, v199)), v194, 3);
          v200.i64[0] = vbslq_s8(v37, (int8x16_t)vminq_f32(v156, (float32x4_t)vbslq_s8(v37, (int8x16_t)v196, v200)), v200).u64[0];
          float32x4_t v201 = (float32x4_t)vextq_s8((int8x16_t)v184, (int8x16_t)v184, 8uLL);
          v200.i64[1] = vaddq_f32(v201, v184).i64[1];
          float32x4_t v202 = (float32x4_t)vrev64q_s32((int32x4_t)v155);
          int32x4_t v203 = (int32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32(v202, v201), v200);
          float32x4_t v204 = (float32x4_t)vbslq_s8(v37, vbslq_s8((int8x16_t)vcgtq_f32(v185, v66), (int8x16_t)v194, (int8x16_t)v66), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v203), v66), (int8x16_t)v203, (int8x16_t)v66));
          float32x4_t v205 = (float32x4_t)vextq_s8((int8x16_t)v203, (int8x16_t)v203, 8uLL);
          int8x16_t v206 = (int8x16_t)vmulq_f32(v141, vsubq_f32(v205, vmulq_f32(v205, v204)));
          int8x16_t v207 = (int8x16_t)vdupq_laneq_s32((int32x4_t)v72, 3);
          *(int32x2_t *)v178.f32 = vdup_lane_s32(*(int32x2_t *)v206.i8, 0);
          v178.i64[1] = v207.i64[0];
          float32x4_t v208 = vsubq_f32(v226, v178);
          float32x4_t v209 = vmulq_f32(v208, v208);
          v206.i64[1] = vsubq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v206, 0), (float32x4_t)vextq_s8(v207, v206, 0xCuLL)).i64[1];
          float32x4_t v210 = vaddq_f32(v209, (float32x4_t)vextq_s8((int8x16_t)v209, (int8x16_t)v209, 4uLL));
          int8x16_t v211 = vbslq_s8(v37, (int8x16_t)vaddq_f32(vaddq_f32(v210, (float32x4_t)vextq_s8((int8x16_t)v210, (int8x16_t)v210, 8uLL)), (float32x4_t)vbslq_s8(v37, (int8x16_t)vaddq_f32(v202, v155), v206)), v206);
          *(int32x2_t *)v210.f32 = vdup_lane_s32(*(int32x2_t *)v211.i8, 1);
          v210.i64[1] = v207.i64[0];
          float32x4_t v212 = vsubq_f32(v157, v210);
          float32x4_t v213 = vmulq_f32(v212, v212);
          float32x4_t v214 = vaddq_f32(v213, (float32x4_t)vextq_s8((int8x16_t)v213, (int8x16_t)v213, 4uLL));
          float32x4_t v215 = (float32x4_t)vbslq_s8(v45, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v159, (int8x16_t)v159, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v159, (int8x16_t)v159, 8uLL)), v211);
          float32x4_t v216 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v215, (int8x16_t)v215, 0xCuLL), vaddq_f32(v214, (float32x4_t)vextq_s8((int8x16_t)v214, (int8x16_t)v214, 8uLL)));
          float32x4_t v217 = (float32x4_t)vbslq_s8(v37, (int8x16_t)v216, (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v216, v215)));
          float32x4_t v218 = vminq_f32(vmaxq_f32(vrecpeq_f32(v217), v165), v87);
          float32x4_t v219 = vminq_f32(vmaxq_f32(vmulq_f32(v218, vrecpsq_f32(v217, v218)), v165), v87);
          int8x16_t v220 = (int8x16_t)vmulq_f32(v219, vrecpsq_f32(v217, v219));
          float32x4_t v221 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v37, (int8x16_t)v216, v220), v215, 2), v220);
          float32x4_t v222 = (float32x4_t)vbslq_s8(v37, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v215), vmulq_lane_f32(v221, *(float32x2_t *)v221.f32, 1)), vandq_s8((int8x16_t)v113, (int8x16_t)vcgeq_f32(vnegq_f32(v72), v66)));
          int8x16_t v16 = 0uLL;
          int8x16_t v223 = vbslq_s8(v86, vbslq_s8((int8x16_t)vcgtq_f32(v222, v66), vextq_s8((int8x16_t)v72, v207, 4uLL), (int8x16_t)vrev64q_s32((int32x4_t)v222)), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v222.f32, 1), v66), (int8x16_t)v66, v207));
          v223.i32[3] = 1.0;
          *(int8x16_t *)(*(void *)&v9 + 16 * v17) = v223;
          float32x4_t v7 = vaddq_f32(v227, (float32x4_t)xmmword_1B7E736B0);
          HGRect v18 = v19;
          ++v17;
        }
        while (v4 != v17);
        __n128 v8 = (int8x16_t *)((char *)v8 + v11);
        ++v5;
        float32x4_t v7 = vaddq_f32(v225, (float32x4_t)xmmword_1B7E736C0);
        float v10 = (int8x16_t *)((char *)v10 + v11);
        uint64_t v12 = (int8x16_t *)((char *)v12 + v11);
        *(void *)&v9 += v15;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcDemosaic_1::GetDOD(HgcDemosaic_1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0xFFFFFFFE, 0xFFFFFFFE, 2u, 2u);
  return HGRectGrow(v6, v5, v7);
}

uint64_t HgcDemosaic_1::GetROI(HgcDemosaic_1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0xFFFFFFFE, 0xFFFFFFFE, 2u, 2u);
  return HGRectGrow(v6, v5, v7);
}

void HgcDemosaic_1::HgcDemosaic_1(HgcDemosaic_1 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F0E98;
  operator new();
}

void sub_1B7913914(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcDemosaic_1::~HgcDemosaic_1(HGNode *this)
{
  *(void *)this = &unk_1F10F0E98;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C400F47AF14);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F0E98;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C400F47AF14);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F0E98;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C400F47AF14);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcDemosaic_1::SetParameter(HgcDemosaic_1 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  __n128 v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *__n128 v8 = a3;
  float v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcDemosaic_1::GetParameter(HgcDemosaic_1 *this, unsigned int a2, float *a3)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcDemosaic_2::GetProgram(HgcDemosaic_2 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return aMetal10Len0000_1121;
    }
    else {
      return aMetal10Len0000_1122;
    }
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_422;
  }
}

void HgcDemosaic_2::InitProgramDescriptor(HgcDemosaic_2 *this, HGProgramDescriptor *a2)
{
}

void sub_1B7913F50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7913F88(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7913F80);
}

void HgcDemosaic_2::shaderDescription(char *a1@<X8>)
{
  a1[23] = 20;
  strcpy(a1, "HgcDemosaic_2 [hgc1]");
}

uint64_t HgcDemosaic_2::BindTexture(HgcDemosaic_2 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 3, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcDemosaic_2::Bind(HgcDemosaic_2 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcDemosaic_2::RenderTile(HgcDemosaic_2 *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  uint64_t v3 = (a2[1].i32[1] - HIDWORD(*(unint64_t *)a2));
  if ((int)v3 >= 1 && a2[1].i32[0] - v2.i32[0] >= 1)
  {
    uint64_t v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int32x2_t v6 = a2[10];
    int32x2_t v7 = a2[2];
    uint64_t v8 = 16 * a2[3].i32[0];
    uint64_t v9 = 16 * a2[11].i32[0];
    uint64_t v10 = 16 * (a2[1].i32[0] - v2.i32[0]);
    int8x16_t v11 = 0uLL;
    float32x4_t v12 = v5;
    float32x4_t v360 = v5;
    do
    {
      uint64_t v13 = 0;
      float32x4_t v359 = v12;
      do
      {
        float32x4_t v383 = v12;
        float32x4_t v14 = vcvtq_f32_s32(vcvtq_s32_f32(v12));
        uint64_t v15 = *((void *)this + 51);
        float32x4_t v16 = *(float32x4_t *)(v15 + 48);
        float32x4_t v17 = vsubq_f32(v14, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v14, v12)));
        v18.i64[0] = v17.i64[0];
        v18.i64[1] = vmulq_f32(v16, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v17, 0)).i64[1];
        float32x4_t v19 = vcvtq_f32_s32(vcvtq_s32_f32(v18));
        float32x4_t v20 = *(float32x4_t *)(v15 + 80);
        float32x4_t v375 = *(float32x4_t *)(v15 + 64);
        long long v376 = *(_OWORD *)(v15 + 32);
        int8x16_t v21 = (int8x16_t)vsubq_f32(v19, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v19, v18), (int8x16_t)v375, v11));
        float32x4_t v22 = (float32x4_t)vextq_s8(v21, (int8x16_t)v17, 8uLL);
        v17.i64[1] = v21.i64[1];
        float32x4_t v23 = vsubq_f32(v17, vmulq_laneq_f32(v22, v20, 2));
        int32x4_t v24 = (int32x4_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v23), vmulq_laneq_f32(v23, v20, 2));
        float32x4_t v25 = *(float32x4_t *)(v15 + 16);
        int8x16_t v27 = *(int8x16_t *)(v15 + 96);
        int8x16_t v26 = *(int8x16_t *)(v15 + 112);
        int8x16_t v28 = (int8x16_t)vsubq_f32((float32x4_t)vbslq_s8(v27, (int8x16_t)vaddq_f32(*(float32x4_t *)v15, (float32x4_t)vrev64q_s32(v24)), (int8x16_t)v24), v20);
        float32x4_t v29 = (float32x4_t)vbslq_s8(v27, v28, (int8x16_t)v24);
        float32x4_t v30 = (float32x4_t)vrev64q_s32(*(int32x4_t *)v15);
        int8x16_t v31 = (int8x16_t)vcgtq_f32(v375, vabsq_f32((float32x4_t)vbslq_s8(v27, v28, (int8x16_t)vsubq_f32(v30, v29))));
        float32x4_t v32 = (float32x4_t)vextq_s8((int8x16_t)v383, (int8x16_t)v383, 8uLL);
        int8x16_t v33 = vandq_s8((int8x16_t)v16, v31);
        int64x2_t v34 = (int64x2_t)vextq_s8((int8x16_t)v23, v33, 0xCuLL);
        unint64_t v35 = vdupq_laneq_s64(v34, 1).u64[0];
        v34.i64[0] = v23.i64[0];
        v23.i64[1] = v35;
        float32x4_t v36 = (float32x4_t)vbslq_s8(v26, (int8x16_t)vmaxq_f32((float32x4_t)vrev64q_s32((int32x4_t)v23), (float32x4_t)vextq_s8(v33, v33, 4uLL)), (int8x16_t)v34);
        float32x4_t v37 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v16, v383));
        float32x4_t v371 = (float32x4_t)vrev64q_s32((int32x4_t)v36);
        float32x4_t v374 = vnegq_f32(v36);
        int8x16_t v38 = (int8x16_t)v36;
        float32x4_t v373 = v36;
        int8x16_t v40 = *(int8x16_t *)(v15 + 128);
        float32x4_t v39 = *(float32x4_t *)(v15 + 144);
        float32x4_t v41 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v374, (int8x16_t)v374, 0xCuLL), v39));
        float32x4_t v42 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 0);
        int8x16_t v44 = *(int8x16_t *)(v15 + 160);
        float32x4_t v43 = *(float32x4_t *)(v15 + 176);
        int64x2_t v45 = (int64x2_t)vbslq_s8(v40, (int8x16_t)vminq_f32(v371, (float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 8uLL)), vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v20, v32)));
        float32x4_t v46 = (float32x4_t)vcgtq_f32(v42, v43);
        int32x2_t v47 = a2[10];
        v48.i64[0] = 0x3F0000003F000000;
        v48.i64[1] = 0x3F0000003F000000;
        float32x4_t v49 = vaddq_f32(vsubq_f32(vaddq_f32(v383, (float32x4_t)vbslq_s8((int8x16_t)v46, (int8x16_t)v39, v44)), v5), v48);
        int32x4_t v50 = vcvtq_s32_f32(v49);
        v49.i64[0] = vaddq_s32(v50, vcgtq_f32(vcvtq_f32_s32(v50), v49)).u64[0];
        __int32 v51 = v49.i32[1];
        __int32 v52 = a2[11].i32[0];
        int8x16_t v53 = (int8x16_t)vcgtq_f32(v42, v39);
        int8x16_t v54 = (int8x16_t)vaddq_f32(v32, (float32x4_t)vbslq_s8(v53, v44, (int8x16_t)v43));
        __int32 v55 = v49.i32[0];
        float32x4_t v56 = vaddq_f32(vsubq_f32((float32x4_t)vextq_s8(v54, v54, 8uLL), v5), v48);
        float32x4_t v57 = (float32x4_t)vcvtq_s32_f32(v56);
        v56.i64[0] = vaddq_s32((int32x4_t)v57, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v57), v56)).u64[0];
        v57.i64[0] = vextq_s8((int8x16_t)v45, (int8x16_t)v45, 8uLL).u64[0];
        int32x4_t v58 = *(int32x4_t *)(v15 + 192);
        float32x4_t v59 = *(float32x4_t *)(v15 + 208);
        v46.i64[0] = vaddq_f32(v383, (float32x4_t)vbslq_s8((int8x16_t)v46, (int8x16_t)v58, (int8x16_t)v16)).u64[0];
        float32x4_t v60 = (float32x4_t)vbslq_s8(v53, (int8x16_t)v59, (int8x16_t)v58);
        v58.i64[0] = *(void *)(*(void *)&v47 + 16 * (v56.i32[0] + v56.i32[1] * v52));
        int8x8_t v61 = vext_s8(*(int8x8_t *)v58.i8, *(int8x8_t *)v57.f32, 4uLL);
        v62.i64[0] = v58.i64[0];
        v46.i64[1] = v60.i64[1];
        v62.i64[1] = v45.i64[1];
        *(int8x8_t *)v57.f32 = vext_s8(*(int8x8_t *)v57.f32, *(int8x8_t *)v58.i8, 4uLL);
        float32x4_t v63 = vaddq_f32(vsubq_f32(v46, v5), v48);
        int32x4_t v64 = vcvtq_s32_f32(v63);
        v58.i64[1] = vdupq_laneq_s64(v45, 1).u64[0];
        v63.i64[0] = vaddq_s32(v64, vcgtq_f32(vcvtq_f32_s32(v64), v63)).u64[0];
        float32x4_t v65 = (float32x4_t)vrev64q_s32(v58);
        int8x16_t v66 = *(int8x16_t *)(*(void *)&v47 + 16 * (v63.i32[0] + v63.i32[1] * v52));
        int8x16_t v67 = (int8x16_t)vdupq_lane_s64(v62.i64[0], 0);
        int32x4_t v68 = (int32x4_t)vminq_f32(v65, v62);
        float32x4_t v69 = (float32x4_t)vdupq_laneq_s32(v68, 2);
        *(int8x8_t *)&v57.u32[2] = v61;
        int8x16_t v70 = vandq_s8((int8x16_t)v16, (int8x16_t)vcgeq_f32(vnegq_f32(v57), v59));
        *(int8x8_t *)v71.f32 = vext_s8(*(int8x8_t *)v70.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v68, (int8x16_t)v68, 8uLL), 4uLL);
        uint64_t v72 = vextq_s8((int8x16_t)v68, v70, 0xCuLL).u64[0];
        v70.i64[1] = v68.i64[1];
        float32x4_t v73 = (float32x4_t)vextq_s8((int8x16_t)vaddq_f32(v32, v60), v66, 8uLL);
        float32x4_t v74 = vaddq_f32(vsubq_f32(v73, v5), v48);
        int32x4_t v75 = vcvtq_s32_f32(v74);
        v71.i64[1] = v72;
        v74.i64[0] = vaddq_s32(v75, vcgtq_f32(vcvtq_f32_s32(v75), v74)).u64[0];
        int64x2_t v76 = (int64x2_t)vbslq_s8(v40, vandq_s8((int8x16_t)v43, (int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v383, (int8x16_t)v383, 0xCuLL), (float32x4_t)vextq_s8((int8x16_t)v45, (int8x16_t)vsubq_f32((float32x4_t)vdupq_laneq_s64(*(int64x2_t *)v15, 1), v16), 8uLL))), (int8x16_t)v45);
        float32x4_t v77 = *(float32x4_t *)(*(void *)&v47 + 16 * (v74.i32[0] + v74.i32[1] * v52));
        int8x16_t v78 = vbslq_s8(v26, (int8x16_t)vminq_f32(v71, v65), v70);
        v65.i64[0] = vextq_s8((int8x16_t)v76, (int8x16_t)v76, 8uLL).u64[0];
        *(int8x8_t *)v71.f32 = vext_s8(*(int8x8_t *)v65.f32, *(int8x8_t *)v77.f32, 4uLL);
        *(int8x8_t *)v65.f32 = vext_s8(*(int8x8_t *)v77.f32, *(int8x8_t *)v65.f32, 4uLL);
        v77.i64[1] = v76.i64[1];
        v65.i64[1] = v71.i64[0];
        int8x16_t v80 = *(int8x16_t *)(v15 + 224);
        float32x4_t v79 = *(float32x4_t *)(v15 + 240);
        int8x16_t v81 = (int8x16_t)vcgtq_f32(v69, v39);
        int32x4_t v82 = (int32x4_t)vbslq_s8(v80, (int8x16_t)vminq_f32(v65, (float32x4_t)vextq_s8(v78, v78, 8uLL)), v78);
        float32x4_t v83 = (float32x4_t)vdupq_laneq_s32(v82, 2);
        v56.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32(v83, v59), v66, *(int8x16_t *)(*(void *)&v47 + 16 * (v55 + v51 * v52))).u64[0];
        v66.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32(v83, v39), *(int8x16_t *)&v73, (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v77, 0)).i64[1];
        int64x2_t v84 = (int64x2_t)vbslq_s8(v81, (int8x16_t)vdupq_lane_s64(v66.i64[0], 0), v67);
        v56.i64[1] = v84.i64[1];
        float32x4_t v85 = (float32x4_t)vbslq_s8(v40, vandq_s8((int8x16_t)v43, (int8x16_t)vcgeq_f32(vnegq_f32(v77), v39)), (int8x16_t)v82);
        float32x4_t v86 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v85.f32, 1);
        int8x16_t v87 = (int8x16_t)vcgtq_f32(v86, v59);
        int8x16_t v88 = vbslq_s8((int8x16_t)vcgtq_f32(v86, v79), (int8x16_t)vdupq_laneq_s64(v84, 1), v66);
        int32x4_t v89 = (int32x4_t)vbslq_s8(v26, (int8x16_t)vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v85), v85), (int8x16_t)v85);
        int8x16_t v378 = v26;
        v30.i64[0] = vsubq_f32(v30, v16).u64[0];
        v30.i64[1] = v84.i64[1];
        int8x16_t v90 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32(v89, 3), v79), v88, vbslq_s8(v87, (int8x16_t)vdupq_laneq_s64((int64x2_t)v56, 1), (int8x16_t)v56));
        *(int8x8_t *)&v37.u32[2] = vand_s8(*(int8x8_t *)v16.f32, (int8x8_t)*(_OWORD *)&vcgeq_f32(vnegq_f32(v37), v79));
        v56.i64[0] = v90.i64[0];
        float32x4_t v91 = (float32x4_t)vbslq_s8(v80, (int8x16_t)vrev64q_s32((int32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v383, v30))), (int8x16_t)v37);
        float32x4_t v372 = (float32x4_t)vextq_s8(v38, v38, 8uLL);
        v56.i64[1] = v76.i64[1];
        float32x4_t v92 = (float32x4_t)vbslq_s8(v80, (int8x16_t)vminq_f32(v372, (float32x4_t)vextq_s8((int8x16_t)v91, (int8x16_t)v91, 4uLL)), (int8x16_t)v89);
        float32x4_t v93 = (float32x4_t)vrev64q_s32((int32x4_t)vminq_f32(v92, v91));
        float32x4_t v94 = (float32x4_t)vrev64q_s32((int32x4_t)vminq_f32(v92, v93));
        int32x4_t v95 = (int32x4_t)vbslq_s8(v27, (int8x16_t)v93, (int8x16_t)v94);
        int8x16_t v96 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 3), v79), (int8x16_t)v84, v88);
        float32x4_t v97 = (float32x4_t)vbslq_s8(v26, (int8x16_t)vminq_f32(v56, (float32x4_t)vextq_s8((int8x16_t)v95, (int8x16_t)v95, 4uLL)), (int8x16_t)v92);
        int8x16_t v98 = vextq_s8(v96, v88, 8uLL);
        int8x16_t v99 = (int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v97, 3), v79);
        float32x4_t v100 = (float32x4_t)vextq_s8((int8x16_t)v56, (int8x16_t)v56, 8uLL);
        int8x16_t v101 = vbslq_s8(v27, (int8x16_t)vminq_f32(v100, (float32x4_t)vrev64q_s32(v95)), (int8x16_t)v94);
        v90.i64[0] = vbslq_s8(v99, v90, v98).u64[0];
        float32x4_t v102 = (float32x4_t)vbslq_s8(v40, (int8x16_t)vminq_f32((float32x4_t)vextq_s8(v101, v101, 0xCuLL), v97), (int8x16_t)v97);
        int8x16_t v103 = vbslq_s8(v99, (int8x16_t)v100, v98);
        float32x4_t v104 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v101.i8, 0);
        v90.i64[1] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)&v102, 3), v79), *(int8x16_t *)&v100, *(int8x16_t *)&v84).i64[1];
        int8x16_t v105 = (int8x16_t)vcgtq_f32(v104, v79);
        int8x16_t v106 = vbslq_s8(v105, v90, (int8x16_t)v56);
        int8x16_t v107 = vextq_s8(v90, v90, 8uLL);
        v94.i64[0] = vandq_s8((int8x16_t)v16, (int8x16_t)vcgeq_f32(vnegq_f32((float32x4_t)vrev64q_s32((int32x4_t)v91)), v79)).u64[0];
        v94.i64[1] = v76.i64[1];
        float32x4_t v108 = vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v102), v94);
        int8x16_t v109 = vbslq_s8(v105, v107, v103);
        v103.i64[0] = v108.i64[0];
        float32x4_t v110 = (float32x4_t)vextq_s8((int8x16_t)v76, (int8x16_t)v108, 8uLL);
        v108.i64[1] = vdupq_laneq_s64(v76, 1).u64[0];
        v103.i64[1] = v76.i64[1];
        float32x4_t v111 = (float32x4_t)vbslq_s8(v80, (int8x16_t)vminq_f32(v110, (float32x4_t)vrev64q_s32((int32x4_t)v108)), v103);
        int8x16_t v364 = v80;
        v103.i64[0] = v106.i64[0];
        v103.i64[1] = v109.i64[1];
        float32x4_t v112 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v102, 2);
        float32x4_t v113 = (float32x4_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v111.f32, 1), v79);
        v48.i64[0] = vbslq_s8((int8x16_t)v113, v103, v90).u64[0];
        int8x16_t v114 = vbslq_s8((int8x16_t)vcgtq_f32(v79, vminq_f32(vnegq_f32(v112), vnegq_f32(v104))), v107, v90);
        float32x4_t v115 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v112, v79), (int8x16_t)vdupq_lane_s64(v106.i64[0], 0), v103);
        int8x16_t v116 = vextq_s8((int8x16_t)v115, v106, 8uLL);
        int8x16_t v117 = (int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(v111, v102), 0), (float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 2)), v79);
        v102.i64[0] = vminq_f32(v41, v102).u64[0];
        v102.i64[1] = v115.i64[1];
        v110.i64[0] = vbslq_s8((int8x16_t)v113, v116, vextq_s8(v114, v114, 8uLL)).u64[0];
        uint64_t v369 = v48.i64[0];
        int8x16_t v370 = vbslq_s8(v117, (int8x16_t)vdupq_lane_s64(v48.i64[0], 0), v116);
        float32x4_t v118 = (float32x4_t)vextq_s8((int8x16_t)v111, (int8x16_t)v111, 8uLL);
        int32x4_t v368 = (int32x4_t)vbslq_s8(v117, (int8x16_t)vdupq_lane_s64(v110.i64[0], 0), (int8x16_t)v102);
        float32x4_t v119 = (float32x4_t)vbslq_s8(v27, (int8x16_t)v102, (int8x16_t)vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v41), v118));
        v48.i64[1] = v370.i64[1];
        int8x16_t v120 = vextq_s8((int8x16_t)v48, (int8x16_t)v48, 8uLL);
        v110.i64[1] = v368.i64[1];
        int8x16_t v366 = (int8x16_t)v110;
        int8x16_t v121 = vextq_s8((int8x16_t)v110, (int8x16_t)v110, 8uLL);
        v67.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v119.f32, 1), v79), v121, v120).u64[0];
        int8x16_t v122 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(v118, v119), 0), v79), (int8x16_t)v48, (int8x16_t)v110);
        float32x4_t v123 = *(float32x4_t *)(*(void *)&v6 + v13);
        float32x4_t v124 = vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v123), v25);
        int8x16_t v125 = (int8x16_t)vmulq_lane_f32(vmulq_f32(v124, v124), *(float32x2_t *)v25.f32, 1);
        float32x4_t v126 = vaddq_f32(vmaxq_f32((float32x4_t)vextq_s8(v125, v125, 8uLL), v25), (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 4uLL));
        float32x4_t v127 = *(float32x4_t *)(v15 + 256);
        float32x4_t v128 = *(float32x4_t *)(v15 + 272);
        float32x4_t v129 = vminq_f32(vmulq_f32(vrsqrteq_f32(v126), v127), v128);
        int8x16_t v130 = (int8x16_t)vmulq_f32(v126, vminq_f32(vmulq_f32(v129, vrsqrtsq_f32(vmulq_f32(v126, v129), v129)), v128));
        float32x4_t v131 = (float32x4_t)vextq_s8(v130, v130, 4uLL);
        int8x16_t v132 = vbslq_s8(v27, (int8x16_t)v41, vandq_s8((int8x16_t)v128, (int8x16_t)vcgtq_f32(v123, v131)));
        v129.i64[0] = v67.i64[0];
        v129.i64[1] = vextq_s8(v122, v122, 8uLL).u64[0];
        int8x16_t v382 = *(int8x16_t *)(v15 + 288);
        *(int8x8_t *)v115.f32 = vqtbl1_s8((int8x16_t)v129, *(int8x8_t *)v382.i8);
        int8x8_t v365 = (int8x8_t)vextq_s8(v382, v382, 8uLL).u64[0];
        *(int8x8_t *)&v115.u32[2] = vqtbl1_s8((int8x16_t)v129, v365);
        int32x4_t v133 = (int32x4_t)vminq_f32((float32x4_t)vextq_s8(v132, v132, 8uLL), (float32x4_t)vextq_s8(v132, v132, 0xCuLL));
        float32x4_t v134 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 0);
        float32x4_t v135 = vaddq_f32(v134, v115);
        float32x4_t v136 = v134;
        float32x4_t v381 = v134;
        float32x4_t v379 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 3);
        float32x4_t v380 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2);
        float32x4_t v137 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32(v133, 2), v79), (int8x16_t)vaddq_f32(v379, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v135, v135), *(float32x2_t *)v25.f32, 1), v380)), (int8x16_t)v79);
        int8x16_t v377 = *(int8x16_t *)(v15 + 304);
        *(int8x8_t *)v108.f32 = vqtbl1_s8((int8x16_t)v129, *(int8x8_t *)v377.i8);
        int8x8_t v361 = (int8x8_t)vextq_s8(v377, v377, 8uLL).u64[0];
        *(int8x8_t *)&v108.u32[2] = vqtbl1_s8((int8x16_t)v129, v361);
        float32x4_t v138 = vrsqrteq_f32(v137);
        float32x4_t v139 = vminq_f32(v138, v127);
        float32x4_t v140 = vminq_f32(vmulq_f32(v139, vrsqrtsq_f32(vmulq_f32(v137, v139), v139)), v127);
        float32x4_t v141 = vminq_f32(v138, v128);
        float32x4_t v142 = vminq_f32(vmulq_f32(v141, vrsqrtsq_f32(vmulq_f32(v137, v141), v141)), v128);
        float32x4_t v143 = vminq_f32(vmulq_f32(v142, vrsqrtsq_f32(vmulq_f32(v137, v142), v142)), v128);
        v142.i64[0] = vmulq_f32(v137, vminq_f32(vmulq_f32(v140, vrsqrtsq_f32(vmulq_f32(v137, v140), v140)), v127)).u64[0];
        v142.i64[1] = vmulq_f32(v137, v143).i64[1];
        v140.i64[0] = v132.i64[0];
        v140.i64[1] = v133.i64[1];
        float32x4_t v144 = (float32x4_t)vextq_s8((int8x16_t)v133, v132, 8uLL);
        float32x4_t v145 = *(float32x4_t *)(v15 + 320);
        float32x4_t v146 = *(float32x4_t *)(v15 + 336);
        float32x4_t v147 = (float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgtq_f32(v115, v142));
        float32x4_t v148 = vminq_f32(v147, (float32x4_t)vrev64q_s32((int32x4_t)v147));
        v149.i64[0] = v148.i64[0];
        v149.i64[1] = v147.i64[1];
        v113.i64[0] = vminq_f32(v149, (float32x4_t)vextq_s8((int8x16_t)v147, (int8x16_t)v148, 8uLL)).u64[0];
        v149.i64[0] = vextq_s8((int8x16_t)v147, (int8x16_t)v147, 8uLL).u64[0];
        *(float32x2_t *)v148.f32 = vmin_f32(*(float32x2_t *)v148.f32, *(float32x2_t *)v149.f32);
        *(int8x8_t *)v134.f32 = vext_s8(*(int8x8_t *)v148.f32, *(int8x8_t *)v149.f32, 4uLL);
        *(int8x8_t *)v148.f32 = vext_s8(*(int8x8_t *)v149.f32, *(int8x8_t *)v148.f32, 4uLL);
        v113.i64[1] = v147.i64[1];
        v148.i64[1] = v134.i64[0];
        float32x4_t v150 = vminq_f32(v113, v148);
        float32x4_t v151 = vaddq_f32(v136, v108);
        float32x4_t v152 = vaddq_f32(v379, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v151, v151), *(float32x2_t *)v25.f32, 1), v380));
        float32x4_t v153 = vminq_f32(vrsqrteq_f32(v152), v127);
        float32x4_t v154 = vminq_f32(vmulq_f32(v153, vrsqrtsq_f32(vmulq_f32(v152, v153), v153)), v127);
        v154.i64[0] = vmulq_f32(v152, vminq_f32(vmulq_f32(v154, vrsqrtsq_f32(vmulq_f32(v152, v154), v154)), v127)).u64[0];
        v113.i64[0] = v154.i64[0];
        v113.i64[1] = v152.i64[1];
        float32x4_t v155 = vminq_f32(vrsqrteq_f32(v113), v128);
        float32x4_t v156 = vminq_f32(vmulq_f32(v155, vrsqrtsq_f32(vmulq_f32(v155, v113), v155)), v128);
        v154.i64[1] = vmulq_f32(v152, vminq_f32(vmulq_f32(v156, vrsqrtsq_f32(vmulq_f32(v113, v156), v156)), v128)).i64[1];
        float32x4_t v157 = (float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgtq_f32(v108, v154));
        v113.i64[0] = vminq_f32(v157, (float32x4_t)vrev64q_s32((int32x4_t)v157)).u64[0];
        v113.i64[1] = v157.i64[1];
        float32x4_t v158 = (float32x4_t)vbslq_s8(v80, (int8x16_t)vrev64q_s32((int32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(vnegq_f32(v150), v128))), (int8x16_t)v113);
        int32x4_t v159 = (int32x4_t)vbslq_s8(v27, (int8x16_t)vminq_f32(v158, (float32x4_t)vextq_s8((int8x16_t)v158, (int8x16_t)v158, 8uLL)), (int8x16_t)v158);
        v67.i64[1] = v122.i64[1];
        float32x4_t v160 = (float32x4_t)vextq_s8((int8x16_t)v159, (int8x16_t)v159, 8uLL);
        float32x4_t v161 = (float32x4_t)vrev64q_s32(v159);
        int32x4_t v162 = (int32x4_t)vbslq_s8(v27, (int8x16_t)vminq_f32(v144, v161), vbslq_s8(v40, (int8x16_t)vminq_f32(v160, v161), v67));
        float32x4_t v163 = (float32x4_t)vbslq_s8(v378, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v162, (int8x16_t)v162, 4uLL), v127), (int8x16_t)v127, (int8x16_t)vrev64q_s32(v162)), (int8x16_t)v140);
        float32x4_t v164 = *(float32x4_t *)(v15 + 384);
        float32x4_t v362 = *(float32x4_t *)(v15 + 400);
        int8x16_t v363 = (int8x16_t)v123;
        int8x16_t v165 = vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v91.f32, 1), vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v163.f32, 0), (float32x4_t)vdupq_laneq_s32((int32x4_t)v91, 2))), v164), v120, v121);
        v160.i64[0] = vsubq_f32(v123, v131).u64[0];
        v160.i64[1] = v130.i64[1];
        *(int8x8_t *)v110.f32 = vqtbl1_s8((int8x16_t)v162, *(int8x8_t *)v377.i8);
        *(int8x8_t *)&v110.u32[2] = vqtbl1_s8((int8x16_t)v162, v361);
        float32x4_t v166 = *(float32x4_t *)(v15 + 352);
        float32x4_t v167 = *(float32x4_t *)(v15 + 368);
        float32x4_t v168 = vminq_f32(vmaxq_f32(vrecpeq_f32(v110), v146), v166);
        float32x4_t v169 = vminq_f32(vmaxq_f32(vmulq_f32(v168, vrecpsq_f32(v110, v168)), v146), v166);
        float32x4_t v170 = vmulq_f32(vmulq_lane_f32(v115, *(float32x2_t *)v123.f32, 1), vmulq_f32(v169, vrecpsq_f32(v110, v169)));
        float32x4_t v171 = vmulq_f32(v167, v170);
        float32x4_t v172 = vaddq_f32(v171, (float32x4_t)vextq_s8((int8x16_t)v171, (int8x16_t)v171, 4uLL));
        float32x4_t v367 = (float32x4_t)vrev64q_s32((int32x4_t)v163);
        int8x16_t v173 = vbslq_s8(v378, (int8x16_t)vminq_f32(v367, v163), (int8x16_t)v160);
        float32x4_t v174 = (float32x4_t)vbslq_s8(v27, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8(v173, v173, 0xCuLL), v128), (int8x16_t)vaddq_f32(v172, (float32x4_t)vextq_s8((int8x16_t)v172, (int8x16_t)v172, 8uLL)), (int8x16_t)v128), v173);
        float32x4_t v175 = vaddq_f32(v108, v154);
        float32x4_t v176 = vsubq_f32(v108, v154);
        float32x4_t v177 = (float32x4_t)vbslq_s8(v40, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v123, (int8x16_t)v123, 0xCuLL), v174), (int8x16_t)v174);
        float32x4_t v178 = vminq_f32(vmaxq_f32(vrecpeq_f32(v175), v146), v166);
        float32x4_t v179 = vminq_f32(vmaxq_f32(vmulq_f32(v178, vrecpsq_f32(v175, v178)), v146), v166);
        float32x4_t v180 = vmulq_f32(vmulq_f32(v179, vrecpsq_f32(v175, v179)), vmulq_lane_f32(vsubq_f32(v142, v115), *(float32x2_t *)v177.f32, 1));
        float32x4_t v181 = vminq_f32(vmaxq_f32(vrecpeq_f32(v176), v146), v166);
        float32x4_t v182 = vminq_f32(vmaxq_f32(vmulq_f32(v181, vrecpsq_f32(v176, v181)), v146), v166);
        float32x4_t v183 = vmulq_f32(vmulq_f32(v182, vrecpsq_f32(v176, v182)), vmulq_laneq_f32(vaddq_f32(v115, v142), v177, 2));
        float32x4_t v184 = vaddq_f32(v170, v180);
        float32x4_t v185 = vsubq_f32(v170, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v177.f32, 0));
        float32x4_t v186 = vsubq_f32(v183, v170);
        float32x4_t v187 = vmulq_f32(v185, v185);
        float32x4_t v188 = vaddq_f32(v187, (float32x4_t)vextq_s8((int8x16_t)v187, (int8x16_t)v187, 4uLL));
        float32x4_t v189 = vmulq_f32(v184, v186);
        float32x4_t v190 = vaddq_f32(v189, (float32x4_t)vextq_s8((int8x16_t)v189, (int8x16_t)v189, 4uLL));
        float32x4_t v191 = vaddq_f32(v190, (float32x4_t)vextq_s8((int8x16_t)v190, (int8x16_t)v190, 8uLL));
        float32x4_t v192 = vmulq_f32(v115, v167);
        float32x4_t v193 = vaddq_f32(v192, (float32x4_t)vextq_s8((int8x16_t)v192, (int8x16_t)v192, 4uLL));
        v91.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(v163, v91), 0), v79), v366, (int8x16_t)v48).u64[0];
        v113.i64[0] = v91.i64[0];
        v113.i64[1] = vextq_s8(v165, v165, 8uLL).u64[0];
        float32x4_t v194 = (float32x4_t)vbslq_s8(v378, (int8x16_t)vaddq_f32(v193, (float32x4_t)vextq_s8((int8x16_t)v193, (int8x16_t)v193, 8uLL)), (int8x16_t)v177);
        float32x4_t v195 = vsubq_f32(v115, (float32x4_t)vdupq_laneq_s32((int32x4_t)v194, 3));
        *(int8x8_t *)v123.f32 = vqtbl1_s8((int8x16_t)v113, *(int8x8_t *)v382.i8);
        *(int8x8_t *)&v123.u32[2] = vqtbl1_s8((int8x16_t)v113, v365);
        float32x4_t v196 = vmulq_f32(v195, v195);
        float32x4_t v197 = vaddq_f32(v196, (float32x4_t)vextq_s8((int8x16_t)v196, (int8x16_t)v196, 4uLL));
        int8x16_t v198 = (int8x16_t)vaddq_f32(vaddq_f32(v188, (float32x4_t)vextq_s8((int8x16_t)v188, (int8x16_t)v188, 8uLL)), vmulq_f32(v164, v191));
        float32x4_t v199 = vmulq_f32(v137, v362);
        float32x4_t v200 = vaddq_f32(v199, (float32x4_t)vextq_s8((int8x16_t)v199, (int8x16_t)v199, 4uLL));
        int8x16_t v201 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v177, (int8x16_t)v177, 0xCuLL), v128), v198, (int8x16_t)v128);
        float32x4_t v202 = vaddq_f32(v381, v123);
        float32x4_t v203 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v163, 2), v79), (int8x16_t)vaddq_f32(v379, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v202, v202), *(float32x2_t *)v25.f32, 1), v380)), (int8x16_t)v79);
        float32x4_t v204 = (float32x4_t)vbslq_s8(v27, v201, (int8x16_t)vaddq_f32(v197, (float32x4_t)vextq_s8((int8x16_t)v197, (int8x16_t)v197, 8uLL)));
        float32x4_t v205 = vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)vaddq_f32(v200, (float32x4_t)vextq_s8((int8x16_t)v200, (int8x16_t)v200, 8uLL))), v204);
        *(int8x8_t *)v137.f32 = vqtbl1_s8((int8x16_t)v113, *(int8x8_t *)v377.i8);
        *(int8x8_t *)&v137.u32[2] = vqtbl1_s8((int8x16_t)v113, v361);
        float32x4_t v206 = vminq_f32(vrsqrteq_f32(v203), v166);
        float32x4_t v207 = vminq_f32(vmulq_f32(v206, vrsqrtsq_f32(vmulq_f32(v203, v206), v206)), v166);
        float32x4_t v208 = vmulq_f32(v203, vminq_f32(vmulq_f32(v207, vrsqrtsq_f32(vmulq_f32(v203, v207), v207)), v166));
        float32x4_t v209 = (float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgtq_f32(v123, v208));
        float32x4_t v210 = vminq_f32(v209, (float32x4_t)vrev64q_s32((int32x4_t)v209));
        v156.i64[0] = v210.i64[0];
        v156.i64[1] = v209.i64[1];
        v156.i64[0] = vminq_f32(v156, (float32x4_t)vextq_s8((int8x16_t)v209, (int8x16_t)v210, 8uLL)).u64[0];
        v48.i64[0] = vextq_s8((int8x16_t)v209, (int8x16_t)v209, 8uLL).u64[0];
        *(float32x2_t *)v210.f32 = vmin_f32(*(float32x2_t *)v210.f32, *(float32x2_t *)v48.f32);
        *(int8x8_t *)v38.i8 = vext_s8(*(int8x8_t *)v210.f32, *(int8x8_t *)v48.f32, 4uLL);
        *(int8x8_t *)v210.f32 = vext_s8(*(int8x8_t *)v48.f32, *(int8x8_t *)v210.f32, 4uLL);
        v156.i64[1] = v209.i64[1];
        v210.i64[1] = v38.i64[0];
        float32x4_t v211 = vminq_f32(v156, v210);
        float32x4_t v212 = vaddq_f32(v381, v137);
        float32x4_t v213 = vaddq_f32(v379, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v212, v212), *(float32x2_t *)v25.f32, 1), v380));
        float32x4_t v214 = vminq_f32(vrsqrteq_f32(v213), v166);
        float32x4_t v215 = vminq_f32(vmulq_f32(v214, vrsqrtsq_f32(vmulq_f32(v213, v214), v214)), v166);
        v215.i64[0] = vmulq_f32(v213, vminq_f32(vmulq_f32(v215, vrsqrtsq_f32(vmulq_f32(v213, v215), v215)), v166)).u64[0];
        v48.i64[0] = v215.i64[0];
        v48.i64[1] = v213.i64[1];
        float32x4_t v216 = vminq_f32(vrsqrteq_f32(v48), v166);
        float32x4_t v217 = vminq_f32(vmulq_f32(v216, vrsqrtsq_f32(vmulq_f32(v216, v48), v216)), v166);
        v215.i64[1] = vmulq_f32(v213, vminq_f32(vmulq_f32(v217, vrsqrtsq_f32(vmulq_f32(v48, v217), v217)), v166)).i64[1];
        float32x4_t v218 = (float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgtq_f32(v137, v215));
        v48.i64[0] = vminq_f32(v218, (float32x4_t)vrev64q_s32((int32x4_t)v218)).u64[0];
        v48.i64[1] = v218.i64[1];
        float32x4_t v219 = (float32x4_t)vbslq_s8(v364, (int8x16_t)vrev64q_s32((int32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(vnegq_f32(v211), v128))), (int8x16_t)v48);
        int32x4_t v220 = (int32x4_t)vbslq_s8(v27, (int8x16_t)vminq_f32(v219, (float32x4_t)vextq_s8((int8x16_t)v219, (int8x16_t)v219, 8uLL)), (int8x16_t)v219);
        v91.i64[1] = v165.i64[1];
        float32x4_t v221 = (float32x4_t)vrev64q_s32(v220);
        int8x16_t v222 = vbslq_s8(v40, (int8x16_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v220, (int8x16_t)v220, 8uLL), v221), (int8x16_t)v91);
        float32x4_t v223 = (float32x4_t)vextq_s8((int8x16_t)v163, (int8x16_t)v163, 8uLL);
        float32x4_t v224 = (float32x4_t)vbslq_s8(v27, (int8x16_t)vminq_f32(v223, v221), v222);
        v205.i64[1] = vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v204, 0), (float32x4_t)vextq_s8(*(int8x16_t *)&v381, *(int8x16_t *)&v205, 0xCuLL)).i64[1];
        float32x4_t v225 = (float32x4_t)vbslq_s8(v27, vbslq_s8((int8x16_t)vcgtq_f32(v224, v128), (int8x16_t)v128, vextq_s8((int8x16_t)v224, (int8x16_t)v224, 8uLL)), (int8x16_t)v205);
        *(int8x8_t *)v205.f32 = vqtbl1_s8((int8x16_t)v224, *(int8x8_t *)v377.i8);
        *(int8x8_t *)&v205.u32[2] = vqtbl1_s8((int8x16_t)v224, v361);
        float32x4_t v226 = vminq_f32(vmaxq_f32(vrecpeq_f32(v205), v146), v166);
        float32x4_t v227 = vminq_f32(vmaxq_f32(vmulq_f32(v226, vrecpsq_f32(v205, v226)), v146), v166);
        float32x4_t v228 = vmulq_f32(vmulq_lane_f32(v123, *(float32x2_t *)v363.i8, 1), vmulq_f32(v227, vrecpsq_f32(v205, v227)));
        float32x4_t v229 = vmulq_f32(v167, v228);
        float32x4_t v230 = vaddq_f32(v229, (float32x4_t)vextq_s8((int8x16_t)v229, (int8x16_t)v229, 4uLL));
        float32x4_t v231 = vminq_f32(v223, v225);
        int8x16_t v232 = vbslq_s8((int8x16_t)vcgtq_f32(v231, v128), (int8x16_t)vaddq_f32(v230, (float32x4_t)vextq_s8((int8x16_t)v230, (int8x16_t)v230, 8uLL)), (int8x16_t)v128);
        float32x4_t v233 = vaddq_f32(v137, v215);
        float32x4_t v234 = vsubq_f32(v137, v215);
        float32x4_t v235 = vminq_f32(vmaxq_f32(vrecpeq_f32(v233), v146), v166);
        float32x4_t v236 = vminq_f32(vmaxq_f32(vmulq_f32(v235, vrecpsq_f32(v233, v235)), v146), v166);
        float32x4_t v237 = vmulq_f32(vmulq_lane_f32(vsubq_f32(v208, v123), *(float32x2_t *)v194.f32, 1), vmulq_f32(v236, vrecpsq_f32(v233, v236)));
        float32x4_t v238 = vminq_f32(vmaxq_f32(vrecpeq_f32(v234), v146), v166);
        int32x4_t v239 = (int32x4_t)vbslq_s8(v378, vextq_s8(v232, v232, 4uLL), (int8x16_t)v225);
        float32x4_t v240 = vminq_f32(vmaxq_f32(vmulq_f32(v238, vrecpsq_f32(v234, v238)), v146), v166);
        float32x4_t v241 = vmulq_f32(vmulq_laneq_f32(vaddq_f32(v123, v208), v194, 2), vmulq_f32(v240, vrecpsq_f32(v234, v240)));
        float32x4_t v242 = vaddq_f32(v228, v237);
        float32x4_t v243 = vsubq_f32(v241, v228);
        float32x4_t v244 = vsubq_f32(v228, (float32x4_t)vdupq_laneq_s32(v239, 3));
        float32x4_t v245 = vmulq_f32(v242, v243);
        float32x4_t v246 = vaddq_f32(v245, (float32x4_t)vextq_s8((int8x16_t)v245, (int8x16_t)v245, 4uLL));
        float32x4_t v247 = vmulq_f32(v244, v244);
        float32x4_t v248 = vaddq_f32(v247, (float32x4_t)vextq_s8((int8x16_t)v247, (int8x16_t)v247, 4uLL));
        float32x4_t v249 = vmulq_f32(v167, v123);
        float32x4_t v250 = vaddq_f32(v249, (float32x4_t)vextq_s8((int8x16_t)v249, (int8x16_t)v249, 4uLL));
        v248.i64[0] = vbslq_s8(v27, (int8x16_t)vaddq_f32(v250, (float32x4_t)vdupq_laneq_s64((int64x2_t)v250, 1)), (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)vaddq_f32(v248, (float32x4_t)vdupq_laneq_s64((int64x2_t)v248, 1))), vmulq_n_f32(v362, vaddq_f32(v246, (float32x4_t)vdupq_laneq_s32((int32x4_t)v246, 2)).f32[0]))).u64[0];
        float32x4_t v251 = vsubq_f32(v123, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v248.f32, 0));
        float32x4_t v252 = vmulq_f32(v251, v251);
        float32x4_t v253 = vaddq_f32(v252, (float32x4_t)vextq_s8((int8x16_t)v252, (int8x16_t)v252, 4uLL));
        int8x16_t v254 = (int8x16_t)vrev64q_s32(v368);
        v254.i64[0] = vaddq_f32(v253, (float32x4_t)vdupq_laneq_s64((int64x2_t)v253, 1)).u64[0];
        float32x4_t v255 = vmulq_f32(v362, v203);
        float32x4_t v256 = vaddq_f32(v255, (float32x4_t)vextq_s8((int8x16_t)v255, (int8x16_t)v255, 4uLL));
        int32x4_t v257 = (int32x4_t)vaddq_f32(v256, (float32x4_t)vdupq_lane_s64(v256.i64[0], 0));
        float32x4_t v258 = (float32x4_t)vbslq_s8(v40, vbslq_s8((int8x16_t)vcgtq_f32(v163, v164), vextq_s8((int8x16_t)v239, (int8x16_t)v239, 8uLL), (int8x16_t)v164), v254);
        v248.i64[1] = v257.i64[1];
        v257.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v257, 1), v258).u64[0];
        v254.i64[0] = v257.i64[0];
        v254.i64[1] = v258.i64[1];
        v257.i64[1] = vdupq_laneq_s64((int64x2_t)v258, 1).u64[0];
        float32x4_t v259 = (float32x4_t)vbslq_s8(v27, (int8x16_t)v248, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v231), v164), (int8x16_t)v248, (int8x16_t)v164));
        float32x4_t v260 = (float32x4_t)vbslq_s8(v364, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v257), v259), v254);
        float32x4_t v261 = (float32x4_t)vrev64q_s32((int32x4_t)v260);
        float32x4_t v262 = vminq_f32(vmaxq_f32(vrecpeq_f32(v261), v146), v166);
        float32x4_t v263 = vminq_f32(vmaxq_f32(vmulq_f32(v262, vrecpsq_f32(v261, v262)), v146), v166);
        v261.i64[0] = vmulq_f32(vmulq_f32(v263, vrecpsq_f32(v261, v263)), v260).u64[0];
        v263.i64[0] = vextq_s8((int8x16_t)v260, (int8x16_t)v260, 8uLL).u64[0];
        *(int8x8_t *)v250.f32 = vext_s8(*(int8x8_t *)v263.f32, *(int8x8_t *)v261.f32, 4uLL);
        *(int8x8_t *)v263.f32 = vext_s8(*(int8x8_t *)v261.f32, *(int8x8_t *)v263.f32, 4uLL);
        v261.i64[1] = v260.i64[1];
        v263.i64[1] = v250.i64[0];
        float32x4_t v264 = (float32x4_t)vbslq_s8(v364, vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(vnegq_f32(v263), v164)), (int8x16_t)v261);
        float32x4_t v265 = (float32x4_t)vbslq_s8(v27, (int8x16_t)vaddq_f32(vmulq_f32(vsubq_f32((float32x4_t)vextq_s8((int8x16_t)v239, (int8x16_t)v239, 0xCuLL), v259), v264), v259), (int8x16_t)v264);
        int32x4_t v266 = (int32x4_t)vbslq_s8(v364, (int8x16_t)vminq_f32(v367, v265), (int8x16_t)v265);
        int8x16_t v267 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v266), v128), (int8x16_t)v259, (int8x16_t)v266);
        float32x4_t v268 = (float32x4_t)vbslq_s8(v27, v267, (int8x16_t)v239);
        float32x4_t v269 = vminq_f32(vmaxq_f32(vrecpeq_f32(v268), v146), v166);
        float32x4_t v270 = vminq_f32(vmaxq_f32(vmulq_f32(v269, vrecpsq_f32(v268, v269)), v146), v166);
        float32x4_t v271 = (float32x4_t)vbslq_s8(v40, (int8x16_t)vmulq_lane_f32(vmulq_f32(v270, vrecpsq_f32(v268, v270)), *(float32x2_t *)v268.f32, 1), (int8x16_t)v266);
        float32x4_t v272 = (float32x4_t)vextq_s8((int8x16_t)v163, (int8x16_t)v163, 0xCuLL);
        v270.i64[0] = vbslq_s8((int8x16_t)vcgtq_f32(v223, v128), (int8x16_t)v272, (int8x16_t)v128).u64[0];
        v270.i64[1] = v271.i64[1];
        float32x4_t v273 = (float32x4_t)vextq_s8((int8x16_t)v194, (int8x16_t)v194, 0xCuLL);
        int8x16_t v274 = (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v194, v273), v271, 2), v273);
        int32x4_t v275 = (int32x4_t)vbslq_s8(v27, v274, (int8x16_t)vminq_f32(v367, (float32x4_t)vbslq_s8(v27, v274, (int8x16_t)vrev64q_s32((int32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(vnegq_f32(v270), v128))))));
        int8x16_t v276 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v275), v128), (int8x16_t)v273, (int8x16_t)v275);
        v274.i64[0] = v369;
        v274.i64[1] = vextq_s8(v370, v370, 8uLL).u64[0];
        int8x16_t v277 = vbslq_s8(v40, (int8x16_t)vminq_f32(v371, v272), v366);
        int8x16_t v278 = vmvnq_s8(v40);
        int32x4_t v279 = (int32x4_t)vbslq_s8(v27, v276, v277);
        *(int8x8_t *)v277.i8 = vorr_s8(vand_s8((int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v271, (int8x16_t)v271, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v278, v278, 8uLL)), vand_s8(*(int8x8_t *)v277.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL)));
        *(int8x8_t *)v271.f32 = vqtbl1_s8(v274, *(int8x8_t *)v382.i8);
        v271.i64[1] = v277.i64[0];
        float32x4_t v280 = vaddq_f32(v381, v271);
        float32x4_t v281 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_laneq_s32(v279, 2), v79), (int8x16_t)vaddq_f32(v379, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v280, v280), *(float32x2_t *)v25.f32, 1), v380)), (int8x16_t)v79);
        float32x4_t v282 = vminq_f32(vrsqrteq_f32(v281), v166);
        float32x4_t v283 = vminq_f32(vmulq_f32(v282, vrsqrtsq_f32(vmulq_f32(v282, v281), v282)), v166);
        *(int8x8_t *)v250.f32 = vqtbl1_s8(v274, v361);
        *(int8x8_t *)v208.f32 = vqtbl1_s8(v274, *(int8x8_t *)v377.i8);
        v231.i64[0] = v208.i64[0];
        *(int8x8_t *)&v231.u32[2] = vqtbl1_s8((int8x16_t)v279, v361);
        float32x4_t v284 = vaddq_f32(v381, v231);
        float32x4_t v285 = vmulq_f32(vminq_f32(vmulq_f32(v283, vrsqrtsq_f32(vmulq_f32(v283, v281), v283)), v166), v281);
        float32x4_t v286 = (float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgtq_f32(v271, v285));
        int8x16_t v287 = (int8x16_t)vminq_f32(v286, (float32x4_t)vrev64q_s32((int32x4_t)v286));
        v238.i64[0] = v287.i64[0];
        v238.i64[1] = v286.i64[1];
        float32x4_t v288 = vaddq_f32(v379, vmaxq_f32(vmulq_lane_f32(vmulq_f32(v284, v284), *(float32x2_t *)v25.f32, 1), v380));
        v238.i64[0] = vminq_f32(v238, (float32x4_t)vextq_s8((int8x16_t)v286, v287, 8uLL)).u64[0];
        v238.i64[1] = v286.i64[1];
        v286.i64[0] = vextq_s8((int8x16_t)v286, (int8x16_t)v286, 8uLL).u64[0];
        *(float32x2_t *)v287.i8 = vmin_f32(*(float32x2_t *)v287.i8, *(float32x2_t *)v286.f32);
        *(int8x8_t *)v25.f32 = vext_s8(*(int8x8_t *)v287.i8, *(int8x8_t *)v286.f32, 4uLL);
        *(int8x8_t *)v286.f32 = vext_s8(*(int8x8_t *)v286.f32, *(int8x8_t *)v287.i8, 4uLL);
        v286.i64[1] = v25.i64[0];
        float32x4_t v289 = vminq_f32(v238, v286);
        float32x4_t v290 = vminq_f32(vrsqrteq_f32(v288), v166);
        float32x4_t v291 = vminq_f32(vmulq_f32(v290, vrsqrtsq_f32(vmulq_f32(v288, v290), v290)), v166);
        float32x4_t v292 = vmulq_f32(v288, vminq_f32(vmulq_f32(v291, vrsqrtsq_f32(vmulq_f32(v288, v291), v291)), v166));
        float32x4_t v293 = (float32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgtq_f32(v231, v292));
        v238.i64[0] = vminq_f32(v293, (float32x4_t)vrev64q_s32((int32x4_t)v293)).u64[0];
        v238.i64[1] = v293.i64[1];
        float32x4_t v294 = (float32x4_t)vbslq_s8(v364, (int8x16_t)vrev64q_s32((int32x4_t)vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(vnegq_f32(v289), v128))), (int8x16_t)v238);
        int32x4_t v295 = (int32x4_t)vbslq_s8(v27, (int8x16_t)vminq_f32(v294, (float32x4_t)vextq_s8((int8x16_t)v294, (int8x16_t)v294, 8uLL)), (int8x16_t)v294);
        float32x4_t v296 = (float32x4_t)vrev64q_s32(v295);
        int32x4_t v297 = (int32x4_t)vbslq_s8(v27, (int8x16_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v279, (int8x16_t)v279, 8uLL), v296), (int8x16_t)vminq_f32(v296, (float32x4_t)vextq_s8((int8x16_t)v295, (int8x16_t)v295, 8uLL)));
        *(int8x8_t *)v293.f32 = vqtbl1_s8((int8x16_t)v279, *(int8x8_t *)v377.i8);
        v293.i64[1] = v231.i64[1];
        float32x4_t v298 = vminq_f32(vmaxq_f32(vrecpeq_f32(v293), v146), v166);
        float32x4_t v299 = vminq_f32(vmaxq_f32(vmulq_f32(v298, vrecpsq_f32(v293, v298)), v146), v166);
        int32x4_t v300 = (int32x4_t)vbslq_s8(v364, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v297), v164), (int8x16_t)v164, (int8x16_t)v297), (int8x16_t)v279);
        v208.i64[1] = v250.i64[0];
        float32x4_t v301 = vminq_f32(vmaxq_f32(vrecpeq_f32(v208), v146), v166);
        float32x4_t v302 = vminq_f32(vmaxq_f32(vmulq_f32(v301, vrecpsq_f32(v208, v301)), v146), v166);
        v302.i64[0] = vmulq_f32(v302, vrecpsq_f32(v208, v302)).u64[0];
        v302.i64[1] = vmulq_f32(v299, vrecpsq_f32(v293, v299)).i64[1];
        float32x4_t v303 = vmulq_f32(v302, vmulq_lane_f32(v271, *(float32x2_t *)v363.i8, 1));
        float32x4_t v304 = (float32x4_t)vbslq_s8(v378, (int8x16_t)vminq_f32((float32x4_t)vrev64q_s32(v300), (float32x4_t)vextq_s8((int8x16_t)v300, (int8x16_t)v300, 8uLL)), (int8x16_t)v300);
        float32x4_t v305 = vmulq_f32(v167, v303);
        float32x4_t v306 = vaddq_f32(v305, (float32x4_t)vextq_s8((int8x16_t)v305, (int8x16_t)v305, 4uLL));
        float32x4_t v307 = vaddq_f32(v231, v292);
        float32x4_t v308 = vsubq_f32(v231, v292);
        float32x4_t v309 = vminq_f32(vmaxq_f32(vrecpeq_f32(v307), v146), v166);
        float32x4_t v310 = vminq_f32(vmaxq_f32(vmulq_f32(v309, vrecpsq_f32(v307, v309)), v146), v166);
        float32x4_t v311 = vmulq_f32(v310, vrecpsq_f32(v307, v310));
        float32x4_t v312 = (float32x4_t)vextq_s8((int8x16_t)v304, (int8x16_t)v304, 0xCuLL);
        float32x4_t v313 = vmulq_f32(v311, vmulq_lane_f32(vsubq_f32(v285, v271), *(float32x2_t *)v194.f32, 1));
        float32x4_t v314 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v312, v128), (int8x16_t)vaddq_f32(v306, (float32x4_t)vextq_s8((int8x16_t)v306, (int8x16_t)v306, 8uLL)), (int8x16_t)v128);
        float32x4_t v315 = vminq_f32(vmaxq_f32(vrecpeq_f32(v308), v146), v166);
        float32x4_t v316 = vminq_f32(vmaxq_f32(vmulq_f32(v315, vrecpsq_f32(v308, v315)), v146), v166);
        float32x4_t v317 = vmulq_f32(vmulq_f32(v316, vrecpsq_f32(v308, v316)), vmulq_laneq_f32(vaddq_f32(v271, v285), v194, 2));
        float32x4_t v318 = vsubq_f32(v303, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v314.f32, 0));
        float32x4_t v319 = vmulq_f32(vaddq_f32(v303, v313), vsubq_f32(v317, v303));
        float32x4_t v320 = vaddq_f32(v319, (float32x4_t)vextq_s8((int8x16_t)v319, (int8x16_t)v319, 4uLL));
        float32x4_t v321 = vmulq_f32(v318, v318);
        float32x4_t v322 = vaddq_f32(v321, (float32x4_t)vextq_s8((int8x16_t)v321, (int8x16_t)v321, 4uLL));
        float32x4_t v323 = vmulq_f32(v167, v271);
        float32x4_t v324 = vaddq_f32(v323, (float32x4_t)vextq_s8((int8x16_t)v323, (int8x16_t)v323, 4uLL));
        v320.i64[0] = vbslq_s8(v27, (int8x16_t)vaddq_f32(v324, (float32x4_t)vdupq_laneq_s64((int64x2_t)v324, 1)), (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)vaddq_f32(v322, (float32x4_t)vdupq_laneq_s64((int64x2_t)v322, 1))), vmulq_n_f32(v362, vaddq_f32(v320, (float32x4_t)vdupq_laneq_s32((int32x4_t)v320, 2)).f32[0]))).u64[0];
        int64x2_t v325 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_f32(v304, v164), (int8x16_t)v312, (int8x16_t)v164);
        int8x16_t v11 = 0uLL;
        float32x4_t v326 = vsubq_f32(v271, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v320.f32, 0));
        float32x4_t v327 = vmulq_f32(v326, v326);
        float32x4_t v328 = vmulq_f32(v362, v281);
        float32x4_t v329 = vaddq_f32(v328, (float32x4_t)vextq_s8((int8x16_t)v328, (int8x16_t)v328, 4uLL));
        float32x4_t v330 = vaddq_f32(v327, (float32x4_t)vextq_s8((int8x16_t)v327, (int8x16_t)v327, 4uLL));
        int64x2_t v331 = (int64x2_t)vaddq_f32(v329, (float32x4_t)vdupq_lane_s64(v329.i64[0], 0));
        v320.i64[1] = v331.i64[1];
        v330.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s64(v331, 1), vaddq_f32(v330, (float32x4_t)vdupq_laneq_s64((int64x2_t)v330, 1))).u64[0];
        v331.i64[0] = v330.i64[0];
        float32x4_t v332 = (float32x4_t)vbslq_s8(v27, (int8x16_t)v320, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v304, (int8x16_t)v304, 8uLL), v164), (int8x16_t)v320, (int8x16_t)v164));
        v331.i64[1] = v325.i64[1];
        v330.i64[1] = vdupq_laneq_s64(v325, 1).u64[0];
        float32x4_t v333 = (float32x4_t)vbslq_s8(v364, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v330), v332), (int8x16_t)v331);
        float32x4_t v334 = (float32x4_t)vrev64q_s32((int32x4_t)v333);
        float32x4_t v335 = vminq_f32(vmaxq_f32(vrecpeq_f32(v334), v146), v166);
        float32x4_t v336 = vminq_f32(vmaxq_f32(vmulq_f32(v335, vrecpsq_f32(v334, v335)), v146), v166);
        v334.i64[0] = vmulq_f32(vmulq_f32(v336, vrecpsq_f32(v334, v336)), v333).u64[0];
        v336.i64[0] = vextq_s8((int8x16_t)v333, (int8x16_t)v333, 8uLL).u64[0];
        *(int8x8_t *)v324.f32 = vext_s8(*(int8x8_t *)v336.f32, *(int8x8_t *)v334.f32, 4uLL);
        *(int8x8_t *)v336.f32 = vext_s8(*(int8x8_t *)v334.f32, *(int8x8_t *)v336.f32, 4uLL);
        v334.i64[1] = v333.i64[1];
        v336.i64[1] = v324.i64[0];
        int8x16_t v337 = vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(vnegq_f32(v336), v164));
        int8x16_t v338 = (int8x16_t)vaddq_f32(vmulq_f32(vsubq_f32(v314, v332), (float32x4_t)vbslq_s8(v27, (int8x16_t)v334, v337)), v332);
        float32x4_t v339 = (float32x4_t)vbslq_s8(v27, v338, (int8x16_t)vminq_f32(v372, (float32x4_t)vbslq_s8(v27, v338, v337)));
        int8x16_t v340 = vbslq_s8((int8x16_t)vcgtq_f32(v339, v164), (int8x16_t)vrev64q_s32((int32x4_t)v332), (int8x16_t)vrev64q_s32((int32x4_t)v339));
        float32x4_t v341 = (float32x4_t)vbslq_s8(v27, (int8x16_t)vmulq_f32(v375, *(float32x4_t *)v15), v340);
        float32x4_t v342 = vcvtq_f32_s32(vcvtq_s32_f32(v341));
        v340.i64[0] = vbslq_s8(v27, (int8x16_t)vsubq_f32(v342, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v342, v341), (int8x16_t)v145, (int8x16_t)0)), v340).u64[0];
        int8x16_t v343 = vandq_s8((int8x16_t)v145, (int8x16_t)vcgeq_f32(v374, v164));
        v342.i64[0] = vextq_s8(v343, v343, 8uLL).u64[0];
        *(int8x8_t *)v336.f32 = vext_s8(*(int8x8_t *)v342.f32, *(int8x8_t *)v340.i8, 4uLL);
        *(int8x8_t *)v342.f32 = vext_s8(*(int8x8_t *)v340.i8, *(int8x8_t *)v342.f32, 4uLL);
        v340.i64[1] = v343.i64[1];
        v342.i64[1] = v336.i64[0];
        float32x4_t v344 = (float32x4_t)vbslq_s8(v378, (int8x16_t)vsubq_f32(v372, v342), v340);
        int32x4_t v345 = (int32x4_t)vbslq_s8(v40, (int8x16_t)vminq_f32(v371, v344), (int8x16_t)v344);
        int8x16_t v346 = vbslq_s8(v40, (int8x16_t)vminq_f32(v371, v373), vbslq_s8(v27, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v345, (int8x16_t)v345, 8uLL), v128), (int8x16_t)vrev64q_s32(v345), v363), (int8x16_t)v345));
        int8x16_t v347 = (int8x16_t)vcgtq_f32((float32x4_t)vextq_s8(v346, v346, 4uLL), v164);
        float32x4_t v5 = v360;
        int8x16_t v348 = vbslq_s8(v364, vbslq_s8(v347, v346, vextq_s8(v363, v363, 4uLL)), v346);
        float32x4_t v349 = (float32x4_t)vbslq_s8(v27, vandq_s8((int8x16_t)vcagtq_f32(v375, (float32x4_t)vextq_s8(v348, v348, 0xCuLL)), (int8x16_t)v145), v363);
        int8x16_t v350 = (int8x16_t)vminq_f32(v163, v349);
        float32x4_t v351 = (float32x4_t)vbslq_s8(v40, vextq_s8(v350, v350, 8uLL), (int8x16_t)v349);
        v350.i64[0] = vmvnq_s8(v27).u64[0];
        float32x4_t v352 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v351, 2);
        int8x16_t v353 = vbslq_s8(v27, (int8x16_t)vsubq_f32(vmulq_f32(v163, v351), v163), (int8x16_t)v351);
        *(int8x8_t *)v267.i8 = vorr_s8(vand_s8((int8x8_t)vrev64_s32(*(int32x2_t *)v304.f32), *(int8x8_t *)v350.i8), (int8x8_t)*(_OWORD *)&vandq_s8(v267, v27));
        *(int8x8_t *)v348.i8 = vbsl_s8((int8x8_t)*(_OWORD *)&vcgtq_f32(v352, v79), *(int8x8_t *)v267.i8, *(int8x8_t *)v348.i8);
        *(int8x8_t *)v267.i8 = vorr_s8(vand_s8((int8x8_t)vrev64_s32(*(int32x2_t *)v267.i8), *(int8x8_t *)v350.i8), vand_s8(*(int8x8_t *)v304.f32, *(int8x8_t *)v27.i8));
        v354.i64[0] = v267.u32[0];
        v354.i64[1] = v267.u32[1];
        int8x16_t v355 = v354;
        v354.i64[0] = v348.u32[0];
        v354.i64[1] = v348.u32[1];
        int8x16_t v356 = *(int8x16_t *)(v15 + 416);
        float32x4_t v357 = (float32x4_t)vbslq_s8(v356, vbslq_s8((int8x16_t)vcgtq_f32(v79, (float32x4_t)vdupq_lane_s64(v353.i64[0], 0)), v355, v354), v353);
        v354.i64[0] = v376;
        v354.i64[1] = DWORD1(v376);
        *(float32x4_t *)(*(void *)&v7 + v13) = vminq_f32(vmulq_f32((float32x4_t)vbslq_s8(v356, v354, (int8x16_t)v145), v357), v145);
        float32x4_t v12 = vaddq_f32(v383, (float32x4_t)xmmword_1B7E736B0);
        v13 += 16;
      }
      while (v10 != v13);
      float32x4_t v12 = vaddq_f32(v359, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      *(void *)&v7 += v8;
      *(void *)&v6 += v9;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t HgcDemosaic_2::GetDOD(HgcDemosaic_2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = &HGRectInfinite;
  if (a3) {
    uint64_t v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcDemosaic_2::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcDemosaic_2::HgcDemosaic_2(HgcDemosaic_2 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F1100;
  operator new();
}

void sub_1B79157C8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcDemosaic_2::~HgcDemosaic_2(HGNode *this)
{
  *(void *)this = &unk_1F10F1100;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4003455651);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F1100;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4003455651);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F1100;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4003455651);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcDemosaic_2::SetParameter(HgcDemosaic_2 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcDemosaic_2::GetParameter(HgcDemosaic_2 *this, unsigned int a2, float *a3)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  float32x4_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcWhiteBalanceRAW::GetProgram(HgcWhiteBalanceRAW *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000634\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = half2(hg_Params[2].zw) - c0.xx;\n"
             "    r0.zw = half2(frag._texCoord0.xy) - half2(hg_Params[1].xy);\n"
             "    r0.zw = fmin(r0.zw, r0.xy);\n"
             "    r0.zw = fmax(r0.zw, c0.xx);\n"
             "    s0.xy = float2(r0.zw) + hg_Params[3].xy;\n"
             "    s0.xy = s0.xy*hg_Params[3].zw;\n"
             "    r1.x = (half) hg_Texture0.sample(hg_Sampler0, s0.xy).x;\n"
             "    r0.zw = half2(frag._texCoord0.xy) - half2(hg_Params[2].xy);\n"
             "    r1.zw = half2(frag._texCoord0.xy) - half2(hg_Params[1].zw);\n"
             "    r0.zw = fmin(r0.xy, r0.zw);\n"
             "    r1.zw = fmin(r0.xy, r1.zw);\n"
             "    r0.xy = fmax(r0.zw, c0.xx);\n"
             "    r0.zw = fmax(r1.zw, c0.xx);\n"
             "    s0.xy = float2(r0.xy) + hg_Params[3].xy;\n"
             "    s0.xy = s0.xy*hg_Params[3].zw;\n"
             "    r1.z = (half) hg_Texture0.sample(hg_Sampler0, s0.xy).z;\n"
             "    s0.xy = float2(r0.zw) + hg_Params[3].xy;\n"
             "    s0.xy = s0.xy*hg_Params[3].zw;\n"
             "    r1.y = (half) hg_Texture0.sample(hg_Sampler0, s0.xy).y;\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].yzw);\n"
             "    output.color0.xyz = fmin(float3(r1.xyz), float3(c0.yyy));\n"
             "    output.color0.w = float(c0.y);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a6698d57:f4cd57fc:1ac6cad7:05401ec0\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000005aa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = hg_Params[2].zw - c0.xx;\n"
             "    r0.zw = frag._texCoord0.xy - hg_Params[1].xy;\n"
             "    r0.zw = fmin(r0.zw, r0.xy);\n"
             "    r0.zw = fmax(r0.zw, c0.xx);\n"
             "    r1.xy = r0.zw + hg_Params[3].xy;\n"
             "    r1.xy = r1.xy*hg_Params[3].zw;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, r1.xy).x;\n"
             "    r0.zw = frag._texCoord0.xy - hg_Params[2].xy;\n"
             "    r1.zw = frag._texCoord0.xy - hg_Params[1].zw;\n"
             "    r0.zw = fmin(r0.xy, r0.zw);\n"
             "    r1.zw = fmin(r0.xy, r1.zw);\n"
             "    r0.xy = fmax(r0.zw, c0.xx);\n"
             "    r0.zw = fmax(r1.zw, c0.xx);\n"
             "    r2.xy = r0.xy + hg_Params[3].xy;\n"
             "    r2.xy = r2.xy*hg_Params[3].zw;\n"
             "    r1.z = hg_Texture0.sample(hg_Sampler0, r2.xy).z;\n"
             "    r0.xy = r0.zw + hg_Params[3].xy;\n"
             "    r0.xy = r0.xy*hg_Params[3].zw;\n"
             "    r1.y = hg_Texture0.sample(hg_Sampler0, r0.xy).y;\n"
             "    r1.xyz = r1.xyz - hg_Params[0].xxx;\n"
             "    r1.xyz = r1.xyz*hg_Params[0].yzw;\n"
             "    output.color0.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    output.color0.w = c0.y;\n"
             "    return output;\n"
             "}\n"
             "//MD5=23ff346a:c4a2d73b:0b76461a:7c8c8ac4\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000005ef\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.xy = hg_ProgramLocal2.zw - c0.xx;\n"
           "    r0.zw = hg_TexCoord0.xy - hg_ProgramLocal1.xy;\n"
           "    r0.zw = min(r0.zw, r0.xy);\n"
           "    r0.zw = max(r0.zw, c0.xx);\n"
           "    r1.xy = r0.zw + hg_ProgramLocal3.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal3.zw;\n"
           "    r1.x = texture2D(hg_Texture0, r1.xy).x;\n"
           "    r0.zw = hg_TexCoord0.xy - hg_ProgramLocal2.xy;\n"
           "    r1.zw = hg_TexCoord0.xy - hg_ProgramLocal1.zw;\n"
           "    r0.zw = min(r0.xy, r0.zw);\n"
           "    r1.zw = min(r0.xy, r1.zw);\n"
           "    r0.xy = max(r0.zw, c0.xx);\n"
           "    r0.zw = max(r1.zw, c0.xx);\n"
           "    r2.xy = r0.xy + hg_ProgramLocal3.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal3.zw;\n"
           "    r1.z = texture2D(hg_Texture0, r2.xy).z;\n"
           "    r0.xy = r0.zw + hg_ProgramLocal3.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal3.zw;\n"
           "    r1.y = texture2D(hg_Texture0, r0.xy).y;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal0.xxx;\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.yzw;\n"
           "    gl_FragColor.xyz = min(r1.xyz, c0.yyy);\n"
           "    gl_FragColor.w = c0.y;\n"
           "}\n"
           "//MD5=b7fe7f36:69cec0c5:5dc0df38:8bfb24de\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0004:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcWhiteBalanceRAW::InitProgramDescriptor(HgcWhiteBalanceRAW *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcWhiteBalanceRAW_hgc_visible", "//Metal1.0     \n//LEN=00000004e3\n[[ visible ]] FragmentOut HgcWhiteBalanceRAW_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = hg_Params[2].zw - c0.xx;\n"
    "    r0.zw = texCoord0.xy - hg_Params[1].xy;\n"
    "    r0.zw = fmin(r0.zw, r0.xy);\n"
    "    r0.zw = fmax(r0.zw, c0.xx);\n"
    "    r1.xy = r0.zw + hg_Params[3].xy;\n"
    "    r1.xy = r1.xy*hg_Params[3].zw;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, r1.xy).x;\n"
    "    r0.zw = texCoord0.xy - hg_Params[2].xy;\n"
    "    r1.zw = texCoord0.xy - hg_Params[1].zw;\n"
    "    r0.zw = fmin(r0.xy, r0.zw);\n"
    "    r1.zw = fmin(r0.xy, r1.zw);\n"
    "    r0.xy = fmax(r0.zw, c0.xx);\n"
    "    r0.zw = fmax(r1.zw, c0.xx);\n"
    "    r2.xy = r0.xy + hg_Params[3].xy;\n"
    "    r2.xy = r2.xy*hg_Params[3].zw;\n"
    "    r1.z = hg_Texture0.sample(hg_Sampler0, r2.xy).z;\n"
    "    r0.xy = r0.zw + hg_Params[3].xy;\n"
    "    r0.xy = r0.xy*hg_Params[3].zw;\n"
    "    r1.y = hg_Texture0.sample(hg_Sampler0, r0.xy).y;\n"
    "    r1.xyz = r1.xyz - hg_Params[0].xxx;\n"
    "    r1.xyz = r1.xyz*hg_Params[0].yzw;\n"
    "    output.color0.xyz = fmin(r1.xyz, c0.yyy);\n"
    "    output.color0.w = c0.y;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcWhiteBalanceRAW");
}

void sub_1B7915E04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7915E3C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7915E34);
}

double HgcWhiteBalanceRAW::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  uint64_t v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcWhiteBalanceRAW [hgc1]");
  return *(double *)"alanceRAW [hgc1]";
}

uint64_t HgcWhiteBalanceRAW::BindTexture(HgcWhiteBalanceRAW *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 3, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcWhiteBalanceRAW::Bind(HgcWhiteBalanceRAW *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcWhiteBalanceRAW::RenderTile(HgcWhiteBalanceRAW *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    int32x2_t v7 = a2[2];
    float32x4_t v8 = (float32x4_t)xmmword_1B7E736C0;
    uint64_t v9 = (float32x4_t *)(*(void *)&v7 + 32);
    uint64_t v10 = 16 * a2[3].i32[0];
    float32x4_t v11 = v5;
    while (v6 < 4)
    {
      LODWORD(v161) = 0;
      float32x4_t v14 = v11;
      if (v6 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v11 = vaddq_f32(v11, v8);
      ++v4;
      uint64_t v9 = (float32x4_t *)((char *)v9 + v10);
      *(void *)&v7 += v10;
      if (v4 == v3) {
        return 0;
      }
    }
    int v12 = 0;
    uint64_t v13 = v9;
    float32x4_t v193 = v11;
    float32x4_t v14 = v11;
    do
    {
      float32x4_t v15 = vaddq_f32(v14, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v16 = vaddq_f32(v15, (float32x4_t)xmmword_1B7E736B0);
      uint64_t v17 = *((void *)this + 51);
      int64x2_t v19 = *(int64x2_t *)(v17 + 32);
      float32x4_t v18 = *(float32x4_t *)(v17 + 48);
      float32x4_t v20 = vaddq_f32(v16, (float32x4_t)xmmword_1B7E736B0);
      int8x16_t v21 = (int8x16_t)vsubq_f32((float32x4_t)vdupq_laneq_s64(v19, 1), v18);
      float32x4_t v22 = *(float32x4_t *)(v17 + 16);
      *(float32x2_t *)v23.f32 = vsub_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v22.f32);
      v24.i64[0] = v21.i64[0];
      *(float32x2_t *)v25.f32 = vsub_f32(*(float32x2_t *)v15.f32, *(float32x2_t *)v22.f32);
      v26.i64[0] = v21.i64[0];
      v24.i64[1] = v23.i64[0];
      v26.i64[1] = v25.i64[0];
      *(float32x2_t *)v27.f32 = vsub_f32(*(float32x2_t *)v16.f32, *(float32x2_t *)v22.f32);
      v28.i64[0] = v21.i64[0];
      v28.i64[1] = v27.i64[0];
      *(float32x2_t *)v29.f32 = vsub_f32(*(float32x2_t *)v20.f32, *(float32x2_t *)v22.f32);
      v30.i64[0] = v21.i64[0];
      v30.i64[1] = v29.i64[0];
      v23.i64[1] = v21.i64[0];
      v25.i64[1] = v21.i64[0];
      v27.i64[1] = v21.i64[0];
      v29.i64[1] = v21.i64[0];
      float32x4_t v31 = vminq_f32(v24, v23);
      float32x4_t v32 = vminq_f32(v26, v25);
      float32x4_t v33 = vminq_f32(v28, v27);
      float32x4_t v34 = vminq_f32(v30, v29);
      v27.i64[0] = v21.i64[0];
      v27.i64[1] = v31.i64[1];
      v28.i64[0] = v21.i64[0];
      v29.i64[0] = v21.i64[0];
      v28.i64[1] = v32.i64[1];
      v29.i64[1] = v33.i64[1];
      v33.i64[0] = v21.i64[0];
      v33.i64[1] = v34.i64[1];
      float32x4_t v36 = *(float32x4_t *)(v17 + 64);
      int8x16_t v35 = *(int8x16_t *)(v17 + 80);
      int8x16_t v37 = (int8x16_t)vmaxq_f32(v27, v36);
      int8x16_t v38 = (int8x16_t)vmaxq_f32(v28, v36);
      float32x4_t v39 = (float32x4_t)vextq_s8((int8x16_t)vmaxq_f32(v29, v36), v21, 8uLL);
      int32x2_t v40 = a2[10];
      uint64_t v41 = a2[11].i32[0];
      float32x4_t v42 = vsubq_f32((float32x4_t)vextq_s8(v37, v21, 8uLL), v5);
      int32x4_t v43 = vaddq_s32(vcvtq_s32_f32(v42), vcltzq_f32(v42));
      v42.i64[0] = vsubq_f32(v42, vcvtq_f32_s32(v43)).u64[0];
      int8x16_t v44 = (float32x4_t *)(*(void *)&v40 + 16 * (v43.i32[0] + v43.i32[1] * (int)v41));
      float32x4_t v45 = *v44;
      float32x4_t v46 = v44[v41];
      uint64_t v47 = (int)v41 + 1;
      float32x4_t v48 = vsubq_f32((float32x4_t)vextq_s8(v38, v21, 8uLL), v5);
      float32x4_t v49 = vsubq_f32(v44[v47], v46);
      int32x4_t v50 = vaddq_s32(vcvtq_s32_f32(v48), vcltzq_f32(v48));
      v48.i64[0] = vsubq_f32(v48, vcvtq_f32_s32(v50)).u64[0];
      float32x4_t v51 = vmulq_n_f32(vsubq_f32(v44[1], *v44), v42.f32[0]);
      __int32 v52 = (float32x4_t *)(*(void *)&v40 + 16 * (v50.i32[0] + v50.i32[1] * (int)v41));
      float32x4_t v53 = v52[v41];
      float32x4_t v54 = vaddq_f32(v45, v51);
      float32x4_t v55 = vmulq_n_f32(vsubq_f32(v52[v47], v53), v48.f32[0]);
      float32x4_t v56 = vsubq_f32(v39, v5);
      float32x4_t v57 = vaddq_f32(v46, vmulq_n_f32(v49, v42.f32[0]));
      int32x4_t v58 = vaddq_s32(vcvtq_s32_f32(v56), vcltzq_f32(v56));
      float32x4_t v59 = vaddq_f32(*v52, vmulq_n_f32(vsubq_f32(v52[1], *v52), v48.f32[0]));
      v56.i64[0] = vsubq_f32(v56, vcvtq_f32_s32(v58)).u64[0];
      float32x4_t v60 = (float32x4_t *)(*(void *)&v40 + 16 * (v58.i32[0] + v58.i32[1] * (int)v41));
      float32x4_t v61 = vaddq_f32(v53, v55);
      float32x4_t v62 = vaddq_f32(*v60, vmulq_n_f32(vsubq_f32(v60[1], *v60), v56.f32[0]));
      float32x4_t v63 = vsubq_f32((float32x4_t)vextq_s8((int8x16_t)vmaxq_f32(v33, v36), v21, 8uLL), v5);
      float32x4_t v64 = vaddq_f32(v60[v41], vmulq_n_f32(vsubq_f32(v60[v47], v60[v41]), v56.f32[0]));
      int32x4_t v65 = vaddq_s32(vcvtq_s32_f32(v63), vcltzq_f32(v63));
      v63.i64[0] = vsubq_f32(v63, vcvtq_f32_s32(v65)).u64[0];
      int8x16_t v66 = (float32x4_t *)(*(void *)&v40 + 16 * (v65.i32[0] + v65.i32[1] * (int)v41));
      float32x4_t v67 = vaddq_f32(*v66, vmulq_n_f32(vsubq_f32(v66[1], *v66), v63.f32[0]));
      *(float32x2_t *)v68.f32 = vsub_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v19.i8);
      v69.i64[0] = v21.i64[0];
      v69.i64[1] = v68.i64[0];
      float32x4_t v70 = vmulq_lane_f32(vsubq_f32(v61, v59), *(float32x2_t *)v48.f32, 1);
      *(float32x2_t *)v61.f32 = vsub_f32(*(float32x2_t *)v15.f32, *(float32x2_t *)v19.i8);
      v71.i64[0] = v21.i64[0];
      v71.i64[1] = v61.i64[0];
      float32x4_t v72 = vmulq_lane_f32(vsubq_f32(v64, v62), *(float32x2_t *)v56.f32, 1);
      *(float32x2_t *)v64.f32 = vsub_f32(*(float32x2_t *)v16.f32, *(float32x2_t *)v19.i8);
      v73.i64[0] = v21.i64[0];
      v73.i64[1] = v64.i64[0];
      *(float32x2_t *)v74.f32 = vsub_f32(*(float32x2_t *)v20.f32, *(float32x2_t *)v19.i8);
      v19.i64[0] = vaddq_f32(v54, vmulq_lane_f32(vsubq_f32(v57, v54), *(float32x2_t *)v42.f32, 1)).u64[0];
      v42.i64[0] = v21.i64[0];
      v42.i64[1] = v74.i64[0];
      float32x4_t v75 = (float32x4_t)vdupq_lane_s64(v14.i64[0], 0);
      v76.i64[0] = vaddq_f32(v59, v70).u64[0];
      float32x4_t v77 = (float32x4_t)vdupq_lane_s64(v15.i64[0], 0);
      float32x4_t v78 = (float32x4_t)vdupq_lane_s64(v16.i64[0], 0);
      v15.i64[0] = vaddq_f32(v62, v72).u64[0];
      float32x4_t v79 = vsubq_f32(v77, v22);
      v16.i64[0] = vaddq_f32(v67, vmulq_lane_f32(vsubq_f32(vaddq_f32(v66[v41], vmulq_n_f32(vsubq_f32(v66[v47], v66[v41]), v63.f32[0])), v67), *(float32x2_t *)v63.f32, 1)).u64[0];
      v63.i64[0] = v19.i64[0];
      v77.i64[0] = v76.i64[0];
      v63.i64[1] = vsubq_f32(v75, v22).i64[1];
      v77.i64[1] = v79.i64[1];
      v70.i64[0] = v15.i64[0];
      v79.i64[0] = v16.i64[0];
      v70.i64[1] = vsubq_f32(v78, v22).i64[1];
      v68.i64[1] = v21.i64[0];
      v61.i64[1] = v21.i64[0];
      v79.i64[1] = vsubq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v20, 0), v22).i64[1];
      v64.i64[1] = v21.i64[0];
      v74.i64[1] = v21.i64[0];
      float32x4_t v80 = (float32x4_t)vextq_s8((int8x16_t)vminq_f32(v68, v69), v21, 8uLL);
      float32x4_t v81 = (float32x4_t)vextq_s8((int8x16_t)vminq_f32(v61, v71), v21, 8uLL);
      float32x4_t v82 = (float32x4_t)vextq_s8((int8x16_t)vminq_f32(v64, v73), v21, 8uLL);
      float32x4_t v83 = (float32x4_t)vextq_s8((int8x16_t)vminq_f32(v74, v42), v21, 8uLL);
      float32x4_t v84 = vminq_f32(v81, v77);
      v77.i64[0] = v19.i64[0];
      v77.i64[1] = vminq_f32(v80, v63).i64[1];
      v63.i64[0] = v76.i64[0];
      v62.i64[0] = v15.i64[0];
      v63.i64[1] = v84.i64[1];
      v62.i64[1] = vminq_f32(v82, v70).i64[1];
      v84.i64[0] = v16.i64[0];
      v84.i64[1] = vminq_f32(v83, v79).i64[1];
      float32x4_t v85 = vmaxq_f32(v80, v18);
      float32x4_t v86 = vmaxq_f32(v81, v18);
      float32x4_t v87 = vmaxq_f32(v82, v18);
      float32x4_t v88 = vmaxq_f32(v83, v18);
      int8x16_t v89 = (int8x16_t)vmaxq_f32(v77, v36);
      int8x16_t v90 = (int8x16_t)vmaxq_f32(v63, v36);
      int8x16_t v91 = (int8x16_t)vmaxq_f32(v62, v36);
      float32x4_t v92 = (float32x4_t)vextq_s8(v89, (int8x16_t)v85, 8uLL);
      float32x4_t v93 = (float32x4_t)vextq_s8(v90, (int8x16_t)v86, 8uLL);
      v85.i64[1] = v89.i64[1];
      v86.i64[1] = v90.i64[1];
      float32x4_t v94 = (float32x4_t)vextq_s8(v91, (int8x16_t)v87, 8uLL);
      v87.i64[1] = v91.i64[1];
      int8x16_t v95 = (int8x16_t)vmaxq_f32(v84, v36);
      float32x4_t v96 = (float32x4_t)vextq_s8(v95, (int8x16_t)v88, 8uLL);
      v88.i64[1] = v95.i64[1];
      float32x4_t v97 = vsubq_f32(v85, v5);
      int32x4_t v98 = vaddq_s32(vcvtq_s32_f32(v97), vcltzq_f32(v97));
      v97.i64[0] = vsubq_f32(v97, vcvtq_f32_s32(v98)).u64[0];
      LODWORD(v66) = v98.i32[0] + v98.i32[1] * v41;
      float32x4_t v99 = vsubq_f32(v86, v5);
      float32x4_t v100 = (float32x4_t *)(*(void *)&v40 + 16 * (int)v66);
      int32x4_t v101 = vaddq_s32(vcvtq_s32_f32(v99), vcltzq_f32(v99));
      v99.i64[0] = vsubq_f32(v99, vcvtq_f32_s32(v101)).u64[0];
      float32x4_t v102 = v100[v41];
      int8x16_t v103 = (float32x4_t *)(*(void *)&v40 + 16 * (v101.i32[0] + v101.i32[1] * (int)v41));
      float32x4_t v104 = vsubq_f32(v87, v5);
      float32x4_t v105 = v103[v41];
      int32x4_t v106 = vaddq_s32(vcvtq_s32_f32(v104), vcltzq_f32(v104));
      v104.i64[0] = vsubq_f32(v104, vcvtq_f32_s32(v106)).u64[0];
      int8x16_t v107 = (float32x4_t *)(*(void *)&v40 + 16 * (v106.i32[0] + v106.i32[1] * (int)v41));
      float32x4_t v108 = vsubq_f32(v88, v5);
      int32x4_t v109 = vaddq_s32(vcvtq_s32_f32(v108), vcltzq_f32(v108));
      float32x4_t v110 = vsubq_f32(v92, v5);
      int32x4_t v111 = vaddq_s32(vcvtq_s32_f32(v110), vcltzq_f32(v110));
      float32x4_t v112 = *v103;
      float32x4_t v113 = vmulq_n_f32(vsubq_f32(v100[v47], v102), v97.f32[0]);
      float32x4_t v114 = vmulq_n_f32(vsubq_f32(v103[1], *v103), v99.f32[0]);
      float32x4_t v115 = vmulq_n_f32(vsubq_f32(v103[v47], v105), v99.f32[0]);
      v108.i64[0] = vsubq_f32(v108, vcvtq_f32_s32(v109)).u64[0];
      int8x16_t v116 = (float32x4_t *)(*(void *)&v40 + 16 * (v109.i32[0] + v109.i32[1] * (int)v41));
      float32x4_t v117 = vaddq_f32(*v100, vmulq_n_f32(vsubq_f32(v100[1], *v100), v97.f32[0]));
      float32x2_t v118 = (float32x2_t)vsubq_f32(v110, vcvtq_f32_s32(v111)).u64[0];
      float32x4_t v119 = (float32x4_t *)(*(void *)&v40 + 16 * (v111.i32[0] + v111.i32[1] * (int)v41));
      float32x4_t v120 = vaddq_f32(v102, v113);
      float32x4_t v121 = vaddq_f32(*v119, vmulq_n_f32(vsubq_f32(v119[1], *v119), v118.f32[0]));
      float32x4_t v122 = vaddq_f32(v112, v114);
      float32x4_t v123 = vaddq_f32(v105, v115);
      float32x4_t v124 = vsubq_f32(v93, v5);
      float32x4_t v125 = vaddq_f32(*v107, vmulq_n_f32(vsubq_f32(v107[1], *v107), v104.f32[0]));
      int32x4_t v126 = vaddq_s32(vcvtq_s32_f32(v124), vcltzq_f32(v124));
      v124.i64[0] = vsubq_f32(v124, vcvtq_f32_s32(v126)).u64[0];
      float32x4_t v127 = vsubq_f32(vaddq_f32(v119[v41], vmulq_n_f32(vsubq_f32(v119[v47], v119[v41]), v118.f32[0])), v121);
      float32x4_t v128 = vaddq_f32(*v116, vmulq_n_f32(vsubq_f32(v116[1], *v116), v108.f32[0]));
      float32x4_t v129 = (float32x4_t *)(*(void *)&v40 + 16 * (v126.i32[0] + v126.i32[1] * (int)v41));
      float32x4_t v130 = vaddq_f32(*v129, vmulq_n_f32(vsubq_f32(v129[1], *v129), v124.f32[0]));
      float32x4_t v131 = vmulq_lane_f32(v127, v118, 1);
      float32x4_t v132 = v129[v41];
      float32x4_t v133 = vsubq_f32(v129[v47], v132);
      int8x16_t v134 = (int8x16_t)vaddq_f32(v121, v131);
      float32x4_t v135 = vsubq_f32(v94, v5);
      int32x4_t v136 = vaddq_s32(vcvtq_s32_f32(v135), vcltzq_f32(v135));
      v135.i64[0] = vsubq_f32(v135, vcvtq_f32_s32(v136)).u64[0];
      float32x4_t v137 = (float32x4_t *)(*(void *)&v40 + 16 * (v136.i32[0] + v136.i32[1] * (int)v41));
      float32x4_t v138 = vaddq_f32(*v137, vmulq_n_f32(vsubq_f32(v137[1], *v137), v135.f32[0]));
      float32x4_t v139 = vaddq_f32(v125, vmulq_lane_f32(vsubq_f32(vaddq_f32(v107[v41], vmulq_n_f32(vsubq_f32(v107[v47], v107[v41]), v104.f32[0])), v125), *(float32x2_t *)v104.f32, 1));
      float32x4_t v140 = vsubq_f32(v96, v5);
      int32x4_t v141 = vaddq_s32(vcvtq_s32_f32(v140), vcltzq_f32(v140));
      v140.i64[0] = vsubq_f32(v140, vcvtq_f32_s32(v141)).u64[0];
      v19.i64[1] = vaddq_f32(v117, vmulq_lane_f32(vsubq_f32(v120, v117), *(float32x2_t *)&v97, 1)).i64[1];
      float32x4_t v142 = (float32x4_t *)(*(void *)&v40 + 16 * (v141.i32[0] + v141.i32[1] * (int)v41));
      v76.i64[1] = vaddq_f32(v122, vmulq_lane_f32(vsubq_f32(v123, v122), *(float32x2_t *)&v99, 1)).i64[1];
      v15.i64[1] = v139.i64[1];
      float32x4_t v143 = vaddq_f32(*v142, vmulq_n_f32(vsubq_f32(v142[1], *v142), v140.f32[0]));
      v16.i64[1] = vaddq_f32(v128, vmulq_lane_f32(vsubq_f32(vaddq_f32(v116[16 * v41], vmulq_n_f32(vsubq_f32(v116[v47 * 16], v116[16 * v41]), *(float *)&v108)), v128), *(float32x2_t *)&v108, 1)).i64[1];
      int8x16_t v144 = (int8x16_t)vaddq_f32(v143, vmulq_lane_f32(vsubq_f32(vaddq_f32(v142[v41], vmulq_n_f32(vsubq_f32(v142[v47], v142[v41]), v140.f32[0])), v143), *(float32x2_t *)v140.f32, 1));
      float32x4_t v145 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v138, vmulq_lane_f32(vsubq_f32(vaddq_f32(v137[v41], vmulq_n_f32(vsubq_f32(v137[v47], v137[v41]), v135.f32[0])), v138), *(float32x2_t *)v135.f32, 1)), (int8x16_t)v15);
      float32x4_t v146 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17, 0);
      float32x4_t v147 = vsubq_f32((float32x4_t)vbslq_s8(v35, v134, (int8x16_t)v19), v146);
      float32x4_t v148 = vsubq_f32((float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v130, vmulq_lane_f32(vsubq_f32(vaddq_f32(v132, vmulq_n_f32(v133, v124.f32[0])), v130), *(float32x2_t *)v124.f32, 1)), v76), v146);
      float32x4_t v149 = vsubq_f32(v145, v146);
      float32x4_t v150 = vsubq_f32((float32x4_t)vbslq_s8(v35, v144, (int8x16_t)v16), v146);
      float32x4_t v151 = (float32x4_t)vextq_s8(*(int8x16_t *)v17, *(int8x16_t *)v17, 4uLL);
      float32x4_t v152 = vmulq_f32(v151, v147);
      float32x4_t v153 = vmulq_f32(v151, v148);
      float32x4_t v154 = vmulq_f32(v151, v149);
      float32x4_t v155 = vmulq_f32(v151, v150);
      float32x4_t v156 = *(float32x4_t *)(v17 + 96);
      float32x4_t v157 = vminq_f32(v152, v156);
      float32x4_t v158 = vminq_f32(v153, v156);
      float32x4_t v159 = vminq_f32(v154, v156);
      v157.i32[3] = 1.0;
      v158.i32[3] = 1.0;
      v159.i32[3] = 1.0;
      float32x4_t v160 = vminq_f32(v155, v156);
      v160.i32[3] = 1.0;
      v13[-2] = v157;
      v13[-1] = v158;
      *uint64_t v13 = v159;
      v13[1] = v160;
      v13 += 4;
      float32x4_t v14 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      v12 -= 4;
    }
    while (v6 + v12 > 3);
    LODWORD(v161) = -v12;
    float32x4_t v8 = (float32x4_t)xmmword_1B7E736C0;
    float32x4_t v11 = v193;
    if ((int)v161 >= v6) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v161 = v161;
    do
    {
      uint64_t v162 = *((void *)this + 51);
      float32x4_t v164 = *(float32x4_t *)(v162 + 32);
      float32x4_t v163 = *(float32x4_t *)(v162 + 48);
      int8x16_t v165 = (int8x16_t)vsubq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v164, 1), v163);
      float32x4_t v166 = *(float32x4_t *)(v162 + 16);
      *(float32x2_t *)v167.f32 = vsub_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v166.f32);
      v168.i64[0] = v165.i64[0];
      v168.i64[1] = v167.i64[0];
      v167.i64[1] = v165.i64[0];
      float32x4_t v169 = vminq_f32(v168, v167);
      v168.i64[0] = v165.i64[0];
      v168.i64[1] = v169.i64[1];
      float32x4_t v170 = *(float32x4_t *)(v162 + 64);
      int32x2_t v171 = a2[10];
      float32x4_t v172 = vsubq_f32((float32x4_t)vextq_s8((int8x16_t)vmaxq_f32(v168, v170), v165, 8uLL), v5);
      uint64_t v173 = a2[11].i32[0];
      int32x4_t v174 = vaddq_s32(vcvtq_s32_f32(v172), vcltzq_f32(v172));
      v172.i64[0] = vsubq_f32(v172, vcvtq_f32_s32(v174)).u64[0];
      float32x4_t v175 = (float32x4_t *)(*(void *)&v171 + 16 * (v174.i32[0] + v174.i32[1] * (int)v173));
      uint64_t v176 = (int)v173 + 1;
      float32x4_t v177 = vaddq_f32(*v175, vmulq_n_f32(vsubq_f32(v175[1], *v175), v172.f32[0]));
      *(float32x2_t *)v164.f32 = vsub_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v164.f32);
      v178.i64[0] = v165.i64[0];
      v178.i64[1] = v164.i64[0];
      v172.i64[0] = vaddq_f32(v177, vmulq_lane_f32(vsubq_f32(vaddq_f32(v175[v173], vmulq_n_f32(vsubq_f32(v175[v176], v175[v173]), v172.f32[0])), v177), *(float32x2_t *)v172.f32, 1)).u64[0];
      v177.i64[0] = v172.i64[0];
      v177.i64[1] = vsubq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v14, 0), v166).i64[1];
      v164.i64[1] = v165.i64[0];
      float32x4_t v179 = (float32x4_t)vextq_s8((int8x16_t)vminq_f32(v164, v178), v165, 8uLL);
      v164.i64[0] = v172.i64[0];
      v164.i64[1] = vminq_f32(v179, v177).i64[1];
      float32x4_t v180 = vmaxq_f32(v179, v163);
      int8x16_t v181 = (int8x16_t)vmaxq_f32(v164, v170);
      float32x4_t v182 = (float32x4_t)vextq_s8(v181, (int8x16_t)v180, 8uLL);
      v180.i64[1] = v181.i64[1];
      float32x4_t v183 = vsubq_f32(v180, v5);
      int32x4_t v184 = vaddq_s32(vcvtq_s32_f32(v183), vcltzq_f32(v183));
      v183.i64[0] = vsubq_f32(v183, vcvtq_f32_s32(v184)).u64[0];
      float32x4_t v185 = (float32x4_t *)(*(void *)&v171 + 16 * (v184.i32[0] + v184.i32[1] * (int)v173));
      float32x4_t v186 = vaddq_f32(*v185, vmulq_n_f32(vsubq_f32(v185[1], *v185), v183.f32[0]));
      float32x4_t v187 = vsubq_f32(v182, v5);
      int32x4_t v188 = vaddq_s32(vcvtq_s32_f32(v187), vcltzq_f32(v187));
      v187.i64[0] = vsubq_f32(v187, vcvtq_f32_s32(v188)).u64[0];
      float32x4_t v189 = (float32x4_t *)(*(void *)&v171 + 16 * (v188.i32[0] + v188.i32[1] * (int)v173));
      float32x4_t v190 = vaddq_f32(*v189, vmulq_n_f32(vsubq_f32(v189[1], *v189), v187.f32[0]));
      v172.i64[1] = vaddq_f32(v186, vmulq_lane_f32(vsubq_f32(vaddq_f32(v185[16 * v173], vmulq_n_f32(vsubq_f32(v185[v176 * 16], v185[16 * v173]), *(float *)&v183)), v186), *(float32x2_t *)&v183, 1)).i64[1];
      float32x4_t v191 = vminq_f32(vmulq_f32((float32x4_t)vextq_s8(*(int8x16_t *)v162, *(int8x16_t *)v162, 4uLL), vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v162 + 80), (int8x16_t)vaddq_f32(v190, vmulq_lane_f32(vsubq_f32(vaddq_f32(v189[v173], vmulq_n_f32(vsubq_f32(v189[v176], v189[v173]), v187.f32[0])), v190), *(float32x2_t *)v187.f32, 1)), (int8x16_t)v172), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v162, 0))), *(float32x4_t *)(v162 + 96));
      v191.i32[3] = 1.0;
      *(float32x4_t *)(*(void *)&v7 + 16 * v161) = v191;
      float32x4_t v14 = vaddq_f32(v14, (float32x4_t)xmmword_1B7E736B0);
      ++v161;
    }
    while (v161 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcWhiteBalanceRAW::GetDOD(HgcWhiteBalanceRAW *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  HGRectGrow(v6, v5, v7);
  return 0x8000000080000000;
}

uint64_t HgcWhiteBalanceRAW::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  uint64_t v9 = v8;
  uint64_t v10 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  return HGRectGrow(DOD, v9, v10);
}

void HgcWhiteBalanceRAW::HgcWhiteBalanceRAW(HgcWhiteBalanceRAW *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F1368;
  operator new();
}

void sub_1B7916BD4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcWhiteBalanceRAW::~HgcWhiteBalanceRAW(HGNode *this)
{
  *(void *)this = &unk_1F10F1368;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F1368;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F1368;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcWhiteBalanceRAW::SetParameter(HgcWhiteBalanceRAW *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcWhiteBalanceRAW::GetParameter(HgcWhiteBalanceRAW *this, unsigned int a2, float *a3)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcRasterizerGenerator::GetProgram(HgcRasterizerGenerator *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000183\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]])\n"
             "{\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0 = frag._color*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=f0fb2d12:8a63952b:8c3e7840:9534b621\n"
             "//SIG=02400000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0200:0000:0000:00:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000183\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]])\n"
             "{\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0 = frag._color*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=f0fb2d12:8a63952b:8c3e7840:9534b621\n"
             "//SIG=02000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0200:0000:0000:00:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000017b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "void main()\n"
           "{\n"
           "\n"
           "    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0)*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=5ce95289:5b0ceedb:528a5b25:059f4e88\n"
           "//SIG=02000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
  }
}

void HgcRasterizerGenerator::InitProgramDescriptor(HgcRasterizerGenerator *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcRasterizerGenerator_hgc_visible", "//Metal1.0     \n//LEN=00000000ea\n[[ visible ]] FragmentOut HgcRasterizerGenerator_hgc_visible(const constant float4* hg_Params,\n    float4 color)\n{\n    FragmentOut output;\n"
    "\n"
    "    output.color0 = color*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcRasterizerGenerator");
}

void sub_1B79170E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7917110(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7917108);
}

double HgcRasterizerGenerator::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375F40;
  strcpy(v3, "HgcRasterizerGenerator [hgc1]");
  return *(double *)"Generator [hgc1]";
}

uint64_t HgcRasterizerGenerator::BindTexture(HgcRasterizerGenerator *this, HGHandler *a2)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcRasterizerGenerator::Bind(HgcRasterizerGenerator *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcRasterizerGenerator::UnBind(HgcRasterizerGenerator *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcRasterizerGenerator::RenderFragment(uint64_t a1, float32x4_t *a2, uint64_t a3)
{
  *(float32x4_t *)*(void *)(a3 + 16) = vmulq_f32(a2[9], *(float32x4_t *)*(void *)(a1 + 408));
  return 0;
}

uint64_t HgcRasterizerGenerator::RenderTile(HgcRasterizerGenerator *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    int v3 = 0;
    float32x4_t v4 = *(float32x4_t *)(*((void *)this + 51) + 16);
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = 16 * *((int *)a2 + 6);
    uint64_t v7 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    do
    {
      uint64_t v8 = 0;
      do
      {
        *(float32x4_t *)(v5 + v8) = vmulq_f32(v4, *(float32x4_t *)*((void *)this + 51));
        v8 += 16;
      }
      while (v7 != v8);
      ++v3;
      v5 += v6;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcRasterizerGenerator::GetDOD(HgcRasterizerGenerator *this, HGRenderer *a2, int a3, HGRect a4)
{
  float32x4_t v4 = &HGRectInfinite;
  if (a3) {
    float32x4_t v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcRasterizerGenerator::GetROI(HgcRasterizerGenerator *this, HGRenderer *a2, int a3, HGRect a4)
{
  return 0;
}

uint64_t HgcRasterizerGenerator::GetProperty(HGNode *this, int a2, uint64_t a3)
{
  if (a2 == 20) {
    return 1;
  }
  else {
    return HGNode::GetProperty(this, a2, a3);
  }
}

void HgcRasterizerGenerator::HgcRasterizerGenerator(HgcRasterizerGenerator *this)
{
  HGNode3D::HGNode3D(this);
  *uint64_t v1 = &unk_1F10F15D0;
  operator new();
}

void sub_1B7917380(_Unwind_Exception *a1)
{
  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HgcRasterizerGenerator::~HgcRasterizerGenerator(HgcRasterizerGenerator *this)
{
  *(void *)this = &unk_1F10F15D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F15D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F15D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGMipmapLevel::~HGMipmapLevel(this);

  HGObject::operator delete(v3);
}

uint64_t HgcRasterizerGenerator::SetParameter(HgcRasterizerGenerator *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcRasterizerGenerator::GetParameter(HgcRasterizerGenerator *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcRasterizerTexture::GetProgram(HgcRasterizerTexture *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002e8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = half2(frag._texCoord0.xy)/half2(frag._texCoord0.ww);\n"
             "    r0.xy = r0.xy + half2(hg_Params[5].xy);\n"
             "    r0.xy = r0.xy*half2(hg_Params[5].zw);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, float2(r0.xy));\n"
             "    r0 = r0*half4(frag._color);\n"
             "    output.color0 = float4(r0)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=e403a67b:687ef7e8:b76ee859:1a4e898a\n"
             "//SIG=02400000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0202:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002af\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy/frag._texCoord0.ww;\n"
             "    r0.xy = r0.xy + hg_Params[5].xy;\n"
             "    r0.xy = r0.xy*hg_Params[5].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r0 = r0*frag._color;\n"
             "    output.color0 = r0*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=ed919563:adff3d10:d856f429:fd9e4277\n"
             "//SIG=02000000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0202:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000342\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy/hg_TexCoord0.ww;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal5.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal5.zw;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r0 = r0*vec4(1.0, 1.0, 1.0, 1.0);\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=18ef6ee5:2f79df4d:2199991e:ce4393d9\n"
           "//SIG=02000000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcRasterizerTexture::InitProgramDescriptor(HgcRasterizerTexture *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcRasterizerTexture_hgc_visible", "//Metal1.0     \n//LEN=00000001fc\n[[ visible ]] FragmentOut HgcRasterizerTexture_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 color,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy/texCoord0.ww;\n"
    "    r0.xy = r0.xy + hg_Params[5].xy;\n"
    "    r0.xy = r0.xy*hg_Params[5].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r0 = r0*color;\n"
    "    output.color0 = r0*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcRasterizerTexture");
}

void sub_1B7917A54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7917A90(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7917A88);
}

double HgcRasterizerTexture::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8349220;
  strcpy(v3, "HgcRasterizerTexture [hgc1]");
  return *(double *)"erTexture [hgc1]";
}

uint64_t HgcRasterizerTexture::BindTexture(HgcRasterizerTexture *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 5, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcRasterizerTexture::Bind(HgcRasterizerTexture *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcRasterizerTexture::UnBind(HgcRasterizerTexture *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcRasterizerTexture::RenderFragment(uint64_t a1, float32x4_t *a2, int32x2_t *a3)
{
  *(float32x2_t *)v3.f32 = vadd_f32(vcvt_f32_s32(*a3), (float32x2_t)0x3F0000003F000000);
  v3.i64[1] = 0x3F80000000000000;
  float32x4_t v4 = a2[9];
  float32x4_t v5 = a2[1];
  float32x4_t v6 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 3);
  __n128 v7 = *(float32x4_t **)(a1 + 408);
  float32x4_t v8 = v7[10];
  float32x4_t v9 = v7[11];
  float32x4_t v10 = vminq_f32(vmaxq_f32(vrecpeq_f32(v6), v8), v9);
  float32x4_t v11 = vminq_f32(vmaxq_f32(vmulq_f32(v10, vrecpsq_f32(v6, v10)), v8), v9);
  int32x2_t v12 = a3[10];
  uint64_t v13 = a3[11].i32[0];
  float32x4_t v14 = vsubq_f32(vmulq_f32(v5, vmulq_f32(v11, vrecpsq_f32(v6, v11))), v3);
  if (a2[14].i32[0])
  {
    int32x4_t v15 = vaddq_s32(vcvtq_s32_f32(v14), vcltzq_f32(v14));
    float32x2_t v16 = (float32x2_t)vsubq_f32(v14, vcvtq_f32_s32(v15)).u64[0];
    uint64_t v17 = (float32x4_t *)(*(void *)&v12 + 16 * (v15.i32[0] + v15.i32[1] * (int)v13));
    float32x4_t v18 = vaddq_f32(*v17, vmulq_n_f32(vsubq_f32(v17[1], *v17), v16.f32[0]));
    float32x4_t v19 = vmulq_f32(v4, vaddq_f32(v18, vmulq_lane_f32(vsubq_f32(vaddq_f32(v17[v13], vmulq_n_f32(vsubq_f32(v17[(int)v13 + 1], v17[v13]), v16.f32[0])), v18), v16, 1)));
  }
  else
  {
    v21.i64[0] = 0x3F0000003F000000;
    v21.i64[1] = 0x3F0000003F000000;
    float32x4_t v22 = vaddq_f32(v14, v21);
    int32x4_t v23 = vcvtq_s32_f32(v22);
    v22.i64[0] = vaddq_s32(v23, vcgtq_f32(vcvtq_f32_s32(v23), v22)).u64[0];
    float32x4_t v19 = vmulq_f32(v4, *(float32x4_t *)(*(void *)&v12 + 16 * (v22.i32[0] + v22.i32[1] * (int)v13)));
  }
  *(float32x4_t *)*(void *)&a3[2] = vmulq_f32(v19, *v7);
  return 0;
}

uint64_t HgcRasterizerTexture::RenderTile(HgcRasterizerTexture *this, HGTile *a2)
{
  uint64_t v4 = HGTile::Renderer(a2);
  int v5 = (*(uint64_t (**)(HgcRasterizerTexture *, uint64_t))(*(void *)this + 312))(this, v4);
  int32x2_t v6 = *(int32x2_t *)a2;
  int v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v7 >= 1)
  {
    uint64_t v8 = (*((_DWORD *)a2 + 2) - v6.i32[0]);
    if ((int)v8 >= 1)
    {
      *(float32x2_t *)v9.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v9.i64[1] = 0x3F80000000000000;
      uint64_t v10 = *((void *)a2 + 2);
      float32x4_t v11 = *(float32x4_t *)(*((void *)this + 51) + 16);
      int v12 = 0;
      uint64_t v13 = 16 * *((int *)a2 + 6);
      uint64_t v14 = 16 * v8;
      if (v5)
      {
        float32x4_t v15 = v9;
        do
        {
          uint64_t v16 = 0;
          float32x4_t v17 = v15;
          do
          {
            float32x4_t v18 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 3);
            float32x4_t v19 = (float32x4_t *)*((void *)this + 51);
            float32x4_t v20 = v19[10];
            float32x4_t v21 = v19[11];
            float32x4_t v22 = vminq_f32(vmaxq_f32(vrecpeq_f32(v18), v20), v21);
            float32x4_t v23 = vminq_f32(vmaxq_f32(vmulq_f32(v22, vrecpsq_f32(v18, v22)), v20), v21);
            uint64_t v24 = *((int *)a2 + 22);
            float32x4_t v25 = vsubq_f32(vmulq_f32(v17, vmulq_f32(v23, vrecpsq_f32(v18, v23))), v9);
            int32x4_t v26 = vaddq_s32(vcvtq_s32_f32(v25), vcltzq_f32(v25));
            v25.i64[0] = vsubq_f32(v25, vcvtq_f32_s32(v26)).u64[0];
            float32x4_t v27 = (float32x4_t *)(*((void *)a2 + 10) + 16 * (v26.i32[0] + v26.i32[1] * (int)v24));
            float32x4_t v28 = vaddq_f32(*v27, vmulq_n_f32(vsubq_f32(v27[1], *v27), v25.f32[0]));
            *(float32x4_t *)(v10 + v16) = vmulq_f32(vmulq_f32(v11, vaddq_f32(v28, vmulq_lane_f32(vsubq_f32(vaddq_f32(v27[v24], vmulq_n_f32(vsubq_f32(v27[(int)v24 + 1], v27[v24]), v25.f32[0])), v28), *(float32x2_t *)v25.f32, 1))), *v19);
            float32x4_t v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B7E736B0);
            v16 += 16;
          }
          while (v14 != v16);
          float32x4_t v15 = vaddq_f32(v15, (float32x4_t)xmmword_1B7E736C0);
          ++v12;
          v10 += v13;
        }
        while (v12 != v7);
      }
      else
      {
        v29.i64[0] = 0x3F0000003F000000;
        v29.i64[1] = 0x3F0000003F000000;
        float32x4_t v30 = v9;
        do
        {
          uint64_t v31 = 0;
          float32x4_t v32 = v30;
          do
          {
            float32x4_t v33 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 3);
            float32x4_t v34 = (float32x4_t *)*((void *)this + 51);
            float32x4_t v35 = v34[10];
            float32x4_t v36 = v34[11];
            float32x4_t v37 = vminq_f32(vmaxq_f32(vrecpeq_f32(v33), v35), v36);
            float32x4_t v38 = vminq_f32(vmaxq_f32(vmulq_f32(v37, vrecpsq_f32(v33, v37)), v35), v36);
            float32x4_t v39 = vaddq_f32(vsubq_f32(vmulq_f32(v32, vmulq_f32(v38, vrecpsq_f32(v33, v38))), v9), v29);
            int32x4_t v40 = vcvtq_s32_f32(v39);
            v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
            *(float32x4_t *)(v10 + v31) = vmulq_f32(vmulq_f32(v11, *(float32x4_t *)(*((void *)a2 + 10)+ 16 * (v39.i32[0] + v39.i32[1] * *((_DWORD *)a2 + 22)))), *v34);
            float32x4_t v32 = vaddq_f32(v32, (float32x4_t)xmmword_1B7E736B0);
            v31 += 16;
          }
          while (v14 != v31);
          float32x4_t v30 = vaddq_f32(v30, (float32x4_t)xmmword_1B7E736C0);
          ++v12;
          v10 += v13;
        }
        while (v12 != v7);
      }
    }
  }
  return 0;
}

uint64_t HgcRasterizerTexture::GetDOD(HgcRasterizerTexture *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  int32x2_t v6 = *(const HGTransform **)&a4.var0;
  if ((*(int (**)(HgcRasterizerTexture *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
  {
    uint64_t v8 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    int32x2_t v6 = (const HGTransform *)HGRectGrow((uint64_t)v6, v5, v8);
    uint64_t v5 = v9;
  }
  HGTransform::HGTransform((HGTransform *)v15);
  HGTransform::LoadMatrixf(v15, (float32x2_t *)(*((void *)this + 51) + 32));
  HGTransform::Invert2D((HGTransform *)v15);
  float v11 = HGTransformUtils::MinW(v10);
  *(void *)&v16.var0 = v5;
  uint64_t DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v15, v6, v16, 0.5, v11);
  uint64_t v4 = HGRectUnion(0, 0, DOD, v13);
  HGTransform::~HGTransform((HGTransform *)v15);
  return v4;
}

void sub_1B7918254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7918268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HgcRasterizerTexture::GetROI(HgcRasterizerTexture *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = 0;
  if (!a3)
  {
    uint64_t v5 = *(void *)&a4.var2;
    unint64_t v6 = *(void *)&a4.var0;
    HGTransform::HGTransform((HGTransform *)v17);
    HGTransform::LoadMatrixf(v17, (float32x2_t *)(*((void *)this + 51) + 32));
    float v10 = HGTransformUtils::MinW(v9);
    *(void *)&v18.var0 = v5;
    uint64_t ROI = HGTransformUtils::GetROI((HGTransformUtils *)v17, v6, v18, 0.5, v10);
    uint64_t v4 = HGRectUnion(0, 0, ROI, v12);
    uint64_t v14 = v13;
    HGTransform::~HGTransform((HGTransform *)v17);
    if ((*(int (**)(HgcRasterizerTexture *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
    {
      uint64_t v15 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      return HGRectGrow(v4, v14, v15);
    }
  }
  return v4;
}

void sub_1B791839C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B79183B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HgcRasterizerTexture::GetProperty(HGNode *this, int a2, uint64_t a3)
{
  if (a2 == 20) {
    return 1;
  }
  else {
    return HGNode::GetProperty(this, a2, a3);
  }
}

void HgcRasterizerTexture::HgcRasterizerTexture(HgcRasterizerTexture *this)
{
  HGNode3D::HGNode3D(this);
  *(void *)uint64_t v1 = &unk_1F10F1848;
  *(_DWORD *)(v1 + 416) = 1;
  operator new();
}

void sub_1B79184D0(_Unwind_Exception *a1)
{
  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HgcRasterizerTexture::~HgcRasterizerTexture(HgcRasterizerTexture *this)
{
  *(void *)this = &unk_1F10F1848;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F1848;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F1848;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }
  HGMipmapLevel::~HGMipmapLevel(this);

  HGObject::operator delete(v3);
}

uint64_t HgcRasterizerTexture::SetParameter(HgcRasterizerTexture *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  float v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  *((_DWORD *)this + 104) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcRasterizerTexture::GetParameter(HgcRasterizerTexture *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

double HgcRasterizerTexture::GetOutput(HgcRasterizerTexture *this, HGRenderer *a2)
{
  if (*((_DWORD *)this + 104))
  {
    uint64_t v2 = *((void *)this + 51);
    long long v3 = *(_OWORD *)(v2 + 112);
    *(_OWORD *)(v2 + 32) = *(unint64_t *)(v2 + 96);
    *(_OWORD *)(*((void *)this + 51) + 48) = (unint64_t)v3;
    *(_OWORD *)(*((void *)this + 51) + 64) = xmmword_1B7E736D0;
    double result = 0.0;
    *(_OWORD *)(*((void *)this + 51) + 80) = xmmword_1B7E734D0;
    *((_DWORD *)this + 104) = 0;
  }
  return result;
}

const char *HgcBlur_cs9s::GetProgram(HgcBlur_cs9s *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000ef3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    float4 s0, s1, s2, s3, s4, s5, s6, s7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord1.xy*hg_Params[5].xy;\n"
             "    s0.xy = s0.xy + frag._texCoord0.xy;\n"
             "    s0.xy = s0.xy + hg_Params[6].xy;\n"
             "    s0.zw = s0.xy + hg_Params[7].xy;\n"
             "    s1.xy = s0.zw + hg_Params[7].xy;\n"
             "    s2.zw = s1.xy + hg_Params[7].xy;\n"
             "    s3.xy = s2.zw + hg_Params[7].xy;\n"
             "    s4.xy = s3.xy + hg_Params[7].xy;\n"
             "    s2.xy = s4.xy + hg_Params[7].xy;\n"
             "    s1.zw = s3.xy + hg_Params[8].xy;\n"
             "    s1.zw = s1.zw*hg_Params[8].zw;\n"
             "    s6.xy = s1.zw*hg_Params[9].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s7.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s7.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    s1.zw = s2.xy + hg_Params[8].xy;\n"
             "    s1.xy = s1.xy + hg_Params[8].xy;\n"
             "    s4.zw = s1.xy*hg_Params[8].zw;\n"
             "    s1.zw = s1.zw*hg_Params[8].zw;\n"
             "    s4.xy = s4.xy + hg_Params[8].xy;\n"
             "    s2.zw = s2.zw + hg_Params[8].xy;\n"
             "    s0.zw = s0.zw + hg_Params[8].xy;\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    s7.xy = s4.zw*hg_Params[9].xy;\n"
             "    s7.xy = fmax(s7.xy, float2(c0.xy));\n"
             "    s6.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s7.xy = fmin(s7.xy, s6.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s7.xy);\n"
             "    s6.xy = s1.zw*hg_Params[9].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s7.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s7.xy);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    s4.xy = s4.xy*hg_Params[8].zw;\n"
             "    r2 = r0 + r2;\n"
             "    s2.zw = s2.zw*hg_Params[8].zw;\n"
             "    s7.xy = s2.zw*hg_Params[9].xy;\n"
             "    s7.xy = fmax(s7.xy, float2(c0.xy));\n"
             "    s6.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s7.xy = fmin(s7.xy, s6.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s7.xy);\n"
             "    s6.xy = s4.xy*hg_Params[9].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s7.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s7.xy);\n"
             "    r3 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    r3 = r0 + r3;\n"
             "    r3 = r3*half4(hg_Params[1]) + r1;\n"
             "    s5.xy = s2.xy + hg_Params[7].xy;\n"
             "    s5.zw = s5.xy + hg_Params[8].xy;\n"
             "    s5.zw = s5.zw*hg_Params[8].zw;\n"
             "    r2 = r2*half4(hg_Params[2]) + r3;\n"
             "    s0.zw = s0.zw*hg_Params[8].zw;\n"
             "    s7.xy = s0.zw*hg_Params[9].xy;\n"
             "    s7.xy = fmax(s7.xy, float2(c0.xy));\n"
             "    s6.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s7.xy = fmin(s7.xy, s6.xy);\n"
             "    r3 = (half4) hg_Texture0.sample(hg_Sampler0, s7.xy);\n"
             "    s0.zw = s5.xy + hg_Params[7].xy;\n"
             "    s5.xy = s0.zw + hg_Params[8].xy;\n"
             "    s0.zw = s0.xy + hg_Params[8].xy;\n"
             "    s6.xy = s5.zw*hg_Params[9].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s7.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s7.xy);\n"
             "    r4 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    s0.xy = s5.xy*hg_Params[8].zw;\n"
             "    s5.xy = s0.zw*hg_Params[8].zw;\n"
             "    r4 = r3 + r4;\n"
             "    r2 = r4*half4(hg_Params[3]) + r2;\n"
             "    s7.xy = s0.xy*hg_Params[9].xy;\n"
             "    s7.xy = fmax(s7.xy, float2(c0.xy));\n"
             "    s6.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s7.xy = fmin(s7.xy, s6.xy);\n"
             "    r5 = (half4) hg_Texture0.sample(hg_Sampler0, s7.xy);\n"
             "    s6.xy = s5.xy*hg_Params[9].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s7.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s7.xy);\n"
             "    r6 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    r5 = r6 + r5;\n"
             "    output.color0 = float4(r5)*hg_Params[4] + float4(r2);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8af31599:eb0d3a9d:b19e4849:d2105752\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:000a:000f:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000dcc\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord1.xy*hg_Params[5].xy;\n"
             "    r0.xy = r0.xy + frag._texCoord0.xy;\n"
             "    r0.xy = r0.xy + hg_Params[6].xy;\n"
             "    r0.zw = r0.xy + hg_Params[7].xy;\n"
             "    r1.xy = r0.zw + hg_Params[7].xy;\n"
             "    r3.zw = r1.xy + hg_Params[7].xy;\n"
             "    r2.xy = r3.zw + hg_Params[7].xy;\n"
             "    r4.xy = r2.xy + hg_Params[7].xy;\n"
             "    r3.xy = r4.xy + hg_Params[7].xy;\n"
             "    r1.zw = r2.xy + hg_Params[8].xy;\n"
             "    r1.zw = r1.zw*hg_Params[8].zw;\n"
             "    r6.xy = r1.zw*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r7.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r7.xy);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r1.zw = r3.xy + hg_Params[8].xy;\n"
             "    r1.xy = r1.xy + hg_Params[8].xy;\n"
             "    r4.zw = r1.xy*hg_Params[8].zw;\n"
             "    r1.zw = r1.zw*hg_Params[8].zw;\n"
             "    r4.xy = r4.xy + hg_Params[8].xy;\n"
             "    r3.zw = r3.zw + hg_Params[8].xy;\n"
             "    r0.zw = r0.zw + hg_Params[8].xy;\n"
             "    r2 = r2*hg_Params[0];\n"
             "    r7.xy = r4.zw*hg_Params[9].xy;\n"
             "    r7.xy = fmax(r7.xy, c0.xy);\n"
             "    r6.xy = hg_Params[9].xy - c0.xy;\n"
             "    r7.xy = fmin(r7.xy, r6.xy);\n"
             "    r5 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
             "    r6.xy = r1.zw*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r7.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r7.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r4.xy = r4.xy*hg_Params[8].zw;\n"
             "    r1 = r5 + r1;\n"
             "    r3.zw = r3.zw*hg_Params[8].zw;\n"
             "    r7.xy = r3.zw*hg_Params[9].xy;\n"
             "    r7.xy = fmax(r7.xy, c0.xy);\n"
             "    r6.xy = hg_Params[9].xy - c0.xy;\n"
             "    r7.xy = fmin(r7.xy, r6.xy);\n"
             "    r5 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
             "    r6.xy = r4.xy*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r7.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r7.xy);\n"
             "    r4 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r4 = r5 + r4;\n"
             "    r4 = r4*hg_Params[1] + r2;\n"
             "    r2.xy = r3.xy + hg_Params[7].xy;\n"
             "    r2.zw = r2.xy + hg_Params[8].xy;\n"
             "    r2.zw = r2.zw*hg_Params[8].zw;\n"
             "    r1 = r1*hg_Params[2] + r4;\n"
             "    r0.zw = r0.zw*hg_Params[8].zw;\n"
             "    r7.xy = r0.zw*hg_Params[9].xy;\n"
             "    r7.xy = fmax(r7.xy, c0.xy);\n"
             "    r6.xy = hg_Params[9].xy - c0.xy;\n"
             "    r7.xy = fmin(r7.xy, r6.xy);\n"
             "    r4 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
             "    r0.zw = r2.xy + hg_Params[7].xy;\n"
             "    r2.xy = r0.zw + hg_Params[8].xy;\n"
             "    r0.zw = r0.xy + hg_Params[8].xy;\n"
             "    r6.xy = r2.zw*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r7.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r7.xy);\n"
             "    r3 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r0.xy = r2.xy*hg_Params[8].zw;\n"
             "    r2.xy = r0.zw*hg_Params[8].zw;\n"
             "    r3 = r4 + r3;\n"
             "    r1 = r3*hg_Params[3] + r1;\n"
             "    r7.xy = r0.xy*hg_Params[9].xy;\n"
             "    r7.xy = fmax(r7.xy, c0.xy);\n"
             "    r6.xy = hg_Params[9].xy - c0.xy;\n"
             "    r7.xy = fmin(r7.xy, r6.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
             "    r6.xy = r2.xy*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r7.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r7.xy);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r0 = r2 + r0;\n"
             "    output.color0 = r0*hg_Params[4] + r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2a372906:61260339:48778105:68017d9d\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:000a:0008:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000c12\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "uniform highp vec4 hg_ProgramLocal8;\n"
           "uniform highp vec4 hg_ProgramLocal9;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5, r6;\n"
           "\n"
           "    r0.xy = hg_TexCoord1.xy*hg_ProgramLocal5.xy;\n"
           "    r0.xy = r0.xy + hg_TexCoord0.xy;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal6.xy;\n"
           "    r0.zw = r0.xy + hg_ProgramLocal7.xy;\n"
           "    r1.xy = r0.zw + hg_ProgramLocal7.xy;\n"
           "    r3.zw = r1.xy + hg_ProgramLocal7.xy;\n"
           "    r2.xy = r3.zw + hg_ProgramLocal7.xy;\n"
           "    r4.xy = r2.xy + hg_ProgramLocal7.xy;\n"
           "    r3.xy = r4.xy + hg_ProgramLocal7.xy;\n"
           "    r1.zw = r2.xy + hg_ProgramLocal8.xy;\n"
           "    r1.zw = r1.zw*hg_ProgramLocal8.zw;\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r1.zw;\n"
           "    r2 = texture2D(hg_Texture0, r6.xy);\n"
           "    r1.zw = r3.xy + hg_ProgramLocal8.xy;\n"
           "    r1.xy = r1.xy + hg_ProgramLocal8.xy;\n"
           "    r4.zw = r1.xy*hg_ProgramLocal8.zw;\n"
           "    r1.zw = r1.zw*hg_ProgramLocal8.zw;\n"
           "    r4.xy = r4.xy + hg_ProgramLocal8.xy;\n"
           "    r3.zw = r3.zw + hg_ProgramLocal8.xy;\n"
           "    r0.zw = r0.zw + hg_ProgramLocal8.xy;\n"
           "    r2 = r2*hg_ProgramLocal0;\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r4.zw;\n"
           "    r5 = texture2D(hg_Texture0, r6.xy);\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r1.zw;\n"
           "    r1 = texture2D(hg_Texture0, r6.xy);\n"
           "    r4.xy = r4.xy*hg_ProgramLocal8.zw;\n"
           "    r1 = r5 + r1;\n"
           "    r3.zw = r3.zw*hg_ProgramLocal8.zw;\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r3.zw;\n"
           "    r5 = texture2D(hg_Texture0, r6.xy);\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r4.xy;\n"
           "    r4 = texture2D(hg_Texture0, r6.xy);\n"
           "    r4 = r5 + r4;\n"
           "    r4 = r4*hg_ProgramLocal1 + r2;\n"
           "    r2.xy = r3.xy + hg_ProgramLocal7.xy;\n"
           "    r2.zw = r2.xy + hg_ProgramLocal8.xy;\n"
           "    r2.zw = r2.zw*hg_ProgramLocal8.zw;\n"
           "    r1 = r1*hg_ProgramLocal2 + r4;\n"
           "    r0.zw = r0.zw*hg_ProgramLocal8.zw;\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r0.zw;\n"
           "    r4 = texture2D(hg_Texture0, r6.xy);\n"
           "    r0.zw = r2.xy + hg_ProgramLocal7.xy;\n"
           "    r2.xy = r0.zw + hg_ProgramLocal8.xy;\n"
           "    r0.zw = r0.xy + hg_ProgramLocal8.xy;\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r2.zw;\n"
           "    r3 = texture2D(hg_Texture0, r6.xy);\n"
           "    r0.xy = r2.xy*hg_ProgramLocal8.zw;\n"
           "    r2.xy = r0.zw*hg_ProgramLocal8.zw;\n"
           "    r3 = r4 + r3;\n"
           "    r1 = r3*hg_ProgramLocal3 + r1;\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r6.xy);\n"
           "    r6.xy = hg_ProgramLocal9.xy*c0.xy + r2.xy;\n"
           "    r2 = texture2D(hg_Texture0, r6.xy);\n"
           "    r0 = r2 + r0;\n"
           "    gl_FragColor = r0*hg_ProgramLocal4 + r1;\n"
           "}\n"
           "//MD5=55e7fd50:9f7d4509:b6988dd8:48d03ab1\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:000a:0007:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcBlur_cs9s::InitProgramDescriptor(HgcBlur_cs9s *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlur_cs9s_hgc_visible", "//Metal1.0     \n//LEN=0000000d1b\n[[ visible ]] FragmentOut HgcBlur_cs9s_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord1.xy*hg_Params[5].xy;\n"
    "    r0.xy = r0.xy + texCoord0.xy;\n"
    "    r0.xy = r0.xy + hg_Params[6].xy;\n"
    "    r0.zw = r0.xy + hg_Params[7].xy;\n"
    "    r1.xy = r0.zw + hg_Params[7].xy;\n"
    "    r3.zw = r1.xy + hg_Params[7].xy;\n"
    "    r2.xy = r3.zw + hg_Params[7].xy;\n"
    "    r4.xy = r2.xy + hg_Params[7].xy;\n"
    "    r3.xy = r4.xy + hg_Params[7].xy;\n"
    "    r1.zw = r2.xy + hg_Params[8].xy;\n"
    "    r1.zw = r1.zw*hg_Params[8].zw;\n"
    "    r6.xy = r1.zw*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r7.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r7.xy);\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r1.zw = r3.xy + hg_Params[8].xy;\n"
    "    r1.xy = r1.xy + hg_Params[8].xy;\n"
    "    r4.zw = r1.xy*hg_Params[8].zw;\n"
    "    r1.zw = r1.zw*hg_Params[8].zw;\n"
    "    r4.xy = r4.xy + hg_Params[8].xy;\n"
    "    r3.zw = r3.zw + hg_Params[8].xy;\n"
    "    r0.zw = r0.zw + hg_Params[8].xy;\n"
    "    r2 = r2*hg_Params[0];\n"
    "    r7.xy = r4.zw*hg_Params[9].xy;\n"
    "    r7.xy = fmax(r7.xy, c0.xy);\n"
    "    r6.xy = hg_Params[9].xy - c0.xy;\n"
    "    r7.xy = fmin(r7.xy, r6.xy);\n"
    "    r5 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
    "    r6.xy = r1.zw*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r7.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r7.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r4.xy = r4.xy*hg_Params[8].zw;\n"
    "    r1 = r5 + r1;\n"
    "    r3.zw = r3.zw*hg_Params[8].zw;\n"
    "    r7.xy = r3.zw*hg_Params[9].xy;\n"
    "    r7.xy = fmax(r7.xy, c0.xy);\n"
    "    r6.xy = hg_Params[9].xy - c0.xy;\n"
    "    r7.xy = fmin(r7.xy, r6.xy);\n"
    "    r5 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
    "    r6.xy = r4.xy*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r7.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r7.xy);\n"
    "    r4 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r4 = r5 + r4;\n"
    "    r4 = r4*hg_Params[1] + r2;\n"
    "    r2.xy = r3.xy + hg_Params[7].xy;\n"
    "    r2.zw = r2.xy + hg_Params[8].xy;\n"
    "    r2.zw = r2.zw*hg_Params[8].zw;\n"
    "    r1 = r1*hg_Params[2] + r4;\n"
    "    r0.zw = r0.zw*hg_Params[8].zw;\n"
    "    r7.xy = r0.zw*hg_Params[9].xy;\n"
    "    r7.xy = fmax(r7.xy, c0.xy);\n"
    "    r6.xy = hg_Params[9].xy - c0.xy;\n"
    "    r7.xy = fmin(r7.xy, r6.xy);\n"
    "    r4 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
    "    r0.zw = r2.xy + hg_Params[7].xy;\n"
    "    r2.xy = r0.zw + hg_Params[8].xy;\n"
    "    r0.zw = r0.xy + hg_Params[8].xy;\n"
    "    r6.xy = r2.zw*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r7.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r7.xy);\n"
    "    r3 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r0.xy = r2.xy*hg_Params[8].zw;\n"
    "    r2.xy = r0.zw*hg_Params[8].zw;\n"
    "    r3 = r4 + r3;\n"
    "    r1 = r3*hg_Params[3] + r1;\n"
    "    r7.xy = r0.xy*hg_Params[9].xy;\n"
    "    r7.xy = fmax(r7.xy, c0.xy);\n"
    "    r6.xy = hg_Params[9].xy - c0.xy;\n"
    "    r7.xy = fmin(r7.xy, r6.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r7.xy);\n"
    "    r6.xy = r2.xy*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r7.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r7.xy);\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r0 = r2 + r0;\n"
    "    output.color0 = r0*hg_Params[4] + r1;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBlur_cs9s");
}

void sub_1B7918C0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7918C48(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7918C40);
}

void HgcBlur_cs9s::shaderDescription(char *a1@<X8>)
{
  a1[23] = 19;
  strcpy(a1, "HgcBlur_cs9s [hgc1]");
}

uint64_t HgcBlur_cs9s::BindTexture(HgcBlur_cs9s *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)a2 + 136))(a2, 9, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcBlur_cs9s::Bind(HgcBlur_cs9s *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBlur_cs9s::RenderTile(HgcBlur_cs9s *this, int32x2_t *a2)
{
  uint64_t v4 = HGTile::Renderer((HGTile *)a2);
  int v5 = (*(uint64_t (**)(HgcBlur_cs9s *, uint64_t))(*(void *)this + 312))(this, v4);
  int32x2_t v6 = *a2;
  int v7 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v7 >= 1)
  {
    int v8 = a2[1].i32[0] - v6.i32[0];
    if (v8 >= 1)
    {
      int v9 = 0;
      float32x2_t v10 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
      __asm { FMOV            V2.2S, #-1.0 }
      float32x2_t v16 = vadd_f32(v10, _D2);
      float32x2_t v17 = vadd_f32(v16, _D2);
      *(float32x2_t *)v18.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v18.i64[1] = 0x3F80000000000000;
      int32x2_t v19 = a2[2];
      uint64_t v20 = 16 * a2[3].i32[0];
      uint64_t v21 = 16 * v8;
      float32x4_t v22 = v18;
      do
      {
        uint64_t v23 = 0;
        float32x4_t v24 = v18;
        float32x4_t v25 = v22;
        do
        {
          uint64_t v32 = *((void *)this + 51);
          int8x16_t v33 = (int8x16_t)vaddq_f32(*(float32x4_t *)(v32 + 96), vaddq_f32(v24, vmulq_f32(v25, *(float32x4_t *)(v32 + 80))));
          float32x4_t v34 = *(float32x4_t *)(v32 + 112);
          int8x16_t v35 = *(int8x16_t *)(v32 + 128);
          int8x16_t v36 = (int8x16_t)vdupq_lane_s64(vaddq_f32(v34, (float32x4_t)v33).i64[0], 0);
          float32x4_t v37 = vaddq_f32(v34, (float32x4_t)vextq_s8(v36, v33, 8uLL));
          float32x4_t v38 = vaddq_f32(v34, v37);
          float32x4_t v39 = vaddq_f32(v34, v38);
          float32x4_t v40 = (float32x4_t)vextq_s8(v35, v35, 8uLL);
          int32x2_t v41 = a2[10];
          uint64_t v42 = a2[11].i32[0];
          float32x2_t v43 = vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, vadd_f32(*(float32x2_t *)v35.i8, *(float32x2_t *)v39.f32)));
          if (v5)
          {
            float32x2_t v44 = vmin_f32(vmax_f32(vadd_f32(v43, (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v45 = vcvt_s32_f32(vmin_f32(v44, v17));
            float32x2_t v46 = vsub_f32(v44, vcvt_f32_s32(v45));
            uint64_t v47 = (float32x4_t *)(*(void *)&v41 + 16 * (v45.i32[0] + v45.i32[1] * (int)v42));
            float32x4_t v48 = vaddq_f32(*v47, vmulq_n_f32(vsubq_f32(v47[1], *v47), v46.f32[0]));
            float32x4_t v49 = vaddq_f32(v48, vmulq_lane_f32(vsubq_f32(vaddq_f32(v47[v42], vmulq_n_f32(vsubq_f32(v47[(int)v42 + 1], v47[v42]), v46.f32[0])), v48), v46, 1));
          }
          else
          {
            int32x2_t v50 = vcvt_s32_f32(vmin_f32(vmax_f32(v43, 0), v16));
            float32x4_t v49 = *(float32x4_t *)(*(void *)&v41 + 16 * (v50.i32[0] + v50.i32[1] * (int)v42));
          }
          float32x4_t v51 = (float32x4_t)vdupq_lane_s64(v38.i64[0], 0);
          float32x4_t v52 = vaddq_f32(v34, v39);
          v39.i64[0] = vaddq_f32(v34, v52).u64[0];
          v53.i64[0] = vaddq_f32((float32x4_t)v35, v37).u64[0];
          v53.i64[1] = vaddq_f32(v40, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v39, 0)).i64[1];
          int8x16_t v54 = (int8x16_t)vmulq_f32((float32x4_t)v35, (float32x4_t)vdupq_lane_s64(v53.i64[0], 0));
          int8x16_t v55 = (int8x16_t)vmulq_f32((float32x4_t)v35, v53);
          float32x2_t v56 = (float32x2_t)vaddq_f32((float32x4_t)v35, v52).u64[0];
          int8x16_t v57 = (int8x16_t)vaddq_f32(v40, v51);
          float32x2_t v58 = vmul_f32(v10, (float32x2_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL));
          if (v5)
          {
            float32x2_t v59 = vmin_f32(vmax_f32(vadd_f32(v58, (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v60 = vcvt_s32_f32(vmin_f32(v59, v17));
            float32x2_t v61 = vsub_f32(v59, vcvt_f32_s32(v60));
            float32x2_t v62 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, (float32x2_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL)), (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v63 = vcvt_s32_f32(vmin_f32(v62, v17));
            float32x2_t v64 = vsub_f32(v62, vcvt_f32_s32(v63));
            int32x2_t v65 = vdup_n_s32(v42);
            int32x2_t v66 = vmla_s32(vzip1_s32(v60, v63), vzip2_s32(v60, v63), v65);
            __int32 v67 = v66.i32[1];
            float32x4_t v68 = (float32x4_t *)(*(void *)&v41 + 16 * v66.i32[0]);
            float32x4_t v69 = vaddq_f32(*v68, vmulq_n_f32(vsubq_f32(v68[1], *v68), v61.f32[0]));
            uint64_t v70 = (int)v42 + 1;
            float32x4_t v71 = vaddq_f32(v69, vmulq_lane_f32(vsubq_f32(vaddq_f32(v68[v42], vmulq_n_f32(vsubq_f32(v68[v70], v68[v42]), v61.f32[0])), v69), v61, 1));
            float32x4_t v72 = (float32x4_t *)(*(void *)&v41 + 16 * v67);
            float32x4_t v73 = vaddq_f32(*v72, vmulq_n_f32(vsubq_f32(v72[1], *v72), v64.f32[0]));
            float32x4_t v74 = vaddq_f32(v71, vaddq_f32(v73, vmulq_lane_f32(vsubq_f32(vaddq_f32(v72[v42], vmulq_n_f32(vsubq_f32(v72[v70], v72[v42]), v64.f32[0])), v73), v64, 1)));
            *(float32x2_t *)&v39.u32[2] = vmul_f32(*(float32x2_t *)v40.f32, (float32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL));
            float32x2_t v75 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, *(float32x2_t *)&v39.u32[2]), (float32x2_t)0xBF000000BF000000), 0), v16);
            *(int32x2_t *)v71.f32 = vcvt_s32_f32(vmin_f32(v75, v17));
            float32x2_t v76 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, v56)), (float32x2_t)0xBF000000BF000000), 0), v16);
            *(int32x2_t *)v73.f32 = vcvt_s32_f32(vmin_f32(v76, v17));
            int32x2_t v77 = vmla_s32(vzip1_s32(*(int32x2_t *)v71.f32, *(int32x2_t *)v73.f32), vzip2_s32(*(int32x2_t *)v71.f32, *(int32x2_t *)v73.f32), v65);
            float32x4_t v78 = (float32x4_t *)(*(void *)&v41 + 16 * v77.i32[0]);
            float32x2_t v79 = vsub_f32(v75, vcvt_f32_s32(*(int32x2_t *)v71.f32));
            *(float32x2_t *)v71.f32 = vsub_f32(v76, vcvt_f32_s32(*(int32x2_t *)v73.f32));
            float32x4_t v80 = vaddq_f32(*v78, vmulq_n_f32(vsubq_f32(v78[1], *v78), v79.f32[0]));
            float32x4_t v81 = vaddq_f32(v80, vmulq_lane_f32(vsubq_f32(vaddq_f32(v78[v42], vmulq_n_f32(vsubq_f32(v78[v70], v78[v42]), v79.f32[0])), v80), v79, 1));
            float32x4_t v82 = (float32x4_t *)(*(void *)&v41 + 16 * v77.i32[1]);
            float32x4_t v83 = vaddq_f32(*v82, vmulq_n_f32(vsubq_f32(v82[1], *v82), v71.f32[0]));
            float32x4_t v84 = vaddq_f32(v83, vmulq_lane_f32(vsubq_f32(vaddq_f32(v82[v42], vmulq_n_f32(vsubq_f32(v82[v70], v82[v42]), v71.f32[0])), v83), *(float32x2_t *)v71.f32, 1));
            int8x16_t v85 = (int8x16_t)vaddq_f32(v40, (float32x4_t)v36);
            *(float32x2_t *)v85.i8 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, (float32x2_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL))), (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v86 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v85.i8, v17));
            *(float32x2_t *)v85.i8 = vsub_f32(*(float32x2_t *)v85.i8, vcvt_f32_s32(v86));
            float32x4_t v87 = (float32x4_t *)(*(void *)&v41 + 16 * (v86.i32[0] + v86.i32[1] * (int)v42));
            float32x4_t v88 = vaddq_f32(*v87, vmulq_n_f32(vsubq_f32(v87[1], *v87), *(float *)v85.i32));
            float32x4_t v89 = vaddq_f32(v88, vmulq_lane_f32(vsubq_f32(vaddq_f32(v87[v42], vmulq_n_f32(vsubq_f32(v87[(int)v42 + 1], v87[v42]), *(float *)v85.i32)), v88), *(float32x2_t *)v85.i8, 1));
            float32x2_t v90 = (float32x2_t)vaddq_f32(v34, v39).u64[0];
            float32x2_t v91 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, vadd_f32(*(float32x2_t *)v35.i8, v90))), (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v92 = vcvt_s32_f32(vmin_f32(v91, v17));
            float32x2_t v93 = vsub_f32(v91, vcvt_f32_s32(v92));
            float32x4_t v94 = (float32x4_t *)(*(void *)&v41 + 16 * (v92.i32[0] + v92.i32[1] * (int)v42));
            float32x4_t v95 = vaddq_f32(*v94, vmulq_n_f32(vsubq_f32(v94[1], *v94), v93.f32[0]));
            float32x4_t v96 = vaddq_f32(v95, vmulq_lane_f32(vsubq_f32(vaddq_f32(v94[v42], vmulq_n_f32(vsubq_f32(v94[(int)v42 + 1], v94[v42]), v93.f32[0])), v95), v93, 1));
          }
          else
          {
            int32x2_t v97 = vcvt_s32_f32(vmin_f32(vmax_f32(v58, 0), v16));
            int32x2_t v98 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, (float32x2_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL)), 0), v16));
            int32x2_t v99 = vdup_n_s32(v42);
            int32x2_t v100 = vmla_s32(vzip1_s32(v97, v98), vzip2_s32(v97, v98), v99);
            float32x2_t v101 = vmul_f32(*(float32x2_t *)v40.f32, (float32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL));
            int32x2_t v102 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, v101), 0), v16));
            int32x2_t v103 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, v56)), 0), v16));
            int32x2_t v104 = vmla_s32(vzip1_s32(v102, v103), vzip2_s32(v102, v103), v99);
            __int32 v105 = v104.i32[1];
            float32x4_t v81 = *(float32x4_t *)(*(void *)&v41 + 16 * v104.i32[0]);
            float32x4_t v74 = vaddq_f32(*(float32x4_t *)(*(void *)&v41 + 16 * v100.i32[0]), *(float32x4_t *)(*(void *)&v41 + 16 * v100.i32[1]));
            *(float32x2_t *)&v39.u32[2] = v101;
            float32x4_t v84 = *(float32x4_t *)(*(void *)&v41 + 16 * v105);
            int8x16_t v106 = (int8x16_t)vaddq_f32(v40, (float32x4_t)v36);
            *(int32x2_t *)v106.i8 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, (float32x2_t)*(_OWORD *)&vextq_s8(v106, v106, 8uLL))), 0), v16));
            float32x4_t v89 = *(float32x4_t *)(*(void *)&v41 + 16 * (v106.i32[0] + v106.i32[1] * (int)v42));
            float32x2_t v90 = (float32x2_t)vaddq_f32(v34, v39).u64[0];
            int32x2_t v107 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, vadd_f32(*(float32x2_t *)v35.i8, v90))), 0), v16));
            float32x4_t v96 = *(float32x4_t *)(*(void *)&v41 + 16 * (v107.i32[0] + v107.i32[1] * (int)v42));
          }
          *(float32x2_t *)v108.f32 = vadd_f32(*(float32x2_t *)v34.f32, v90);
          v108.i64[1] = v33.i64[0];
          int8x16_t v109 = (int8x16_t)vmulq_f32(v40, vaddq_f32((float32x4_t)v35, v108));
          float32x2_t v110 = (float32x2_t)vmulq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)vaddq_f32(v40, v108), v109, 8uLL)).u64[0];
          float32x2_t v111 = vmul_f32(v10, *(float32x2_t *)v109.i8);
          if (v5)
          {
            float32x2_t v112 = vmin_f32(vmax_f32(vadd_f32(v111, (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v113 = vcvt_s32_f32(vmin_f32(v112, v17));
            float32x2_t v114 = vsub_f32(v112, vcvt_f32_s32(v113));
            float32x2_t v115 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, v110), (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v116 = vcvt_s32_f32(vmin_f32(v115, v17));
            float32x2_t v117 = vsub_f32(v115, vcvt_f32_s32(v116));
            int32x2_t v118 = vmla_s32(vzip1_s32(v113, v116), vzip2_s32(v113, v116), vdup_n_s32(v42));
            float32x4_t v119 = (float32x4_t *)(*(void *)&v41 + 16 * v118.i32[0]);
            uint64_t v120 = (int)v42 + 1;
            float32x4_t v121 = vaddq_f32(*v119, vmulq_n_f32(vsubq_f32(v119[1], *v119), v114.f32[0]));
            float32x4_t v30 = vaddq_f32(v121, vmulq_lane_f32(vsubq_f32(vaddq_f32(v119[v42], vmulq_n_f32(vsubq_f32(v119[v120], v119[v42]), v114.f32[0])), v121), v114, 1));
            float32x4_t v122 = (float32x4_t *)(*(void *)&v41 + 16 * v118.i32[1]);
            float32x4_t v123 = vaddq_f32(*v122, vmulq_n_f32(vsubq_f32(v122[1], *v122), v117.f32[0]));
            float32x4_t v31 = vaddq_f32(v123, vmulq_lane_f32(vsubq_f32(vaddq_f32(v122[v42], vmulq_n_f32(vsubq_f32(v122[v120], v122[v42]), v117.f32[0])), v123), v117, 1));
          }
          else
          {
            int32x2_t v26 = vcvt_s32_f32(vmin_f32(vmax_f32(v111, 0), v16));
            int32x2_t v27 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, v110), 0), v16));
            int32x2_t v28 = vmla_s32(vzip1_s32(v26, v27), vzip2_s32(v26, v27), vdup_n_s32(v42));
            __int32 v29 = v28.i32[1];
            float32x4_t v30 = *(float32x4_t *)(*(void *)&v41 + 16 * v28.i32[0]);
            float32x4_t v31 = *(float32x4_t *)(*(void *)&v41 + 16 * v29);
          }
          *(float32x4_t *)(*(void *)&v19 + v23) = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v74, *(float32x4_t *)(v32 + 32)), vaddq_f32(vmulq_f32(v49, *(float32x4_t *)v32), vmulq_f32(vaddq_f32(v81, v84), *(float32x4_t *)(v32 + 16)))), vmulq_f32(vaddq_f32(v89, v96), *(float32x4_t *)(v32 + 48))), vmulq_f32(vaddq_f32(v30, v31), *(float32x4_t *)(v32 + 64)));
          float32x4_t v24 = vaddq_f32(v24, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v25 = vaddq_f32(v25, (float32x4_t)xmmword_1B7E736B0);
          v23 += 16;
        }
        while (v21 != v23);
        float32x4_t v18 = vaddq_f32(v18, (float32x4_t)xmmword_1B7E736C0);
        float32x4_t v22 = vaddq_f32(v22, (float32x4_t)xmmword_1B7E736C0);
        ++v9;
        *(void *)&v19 += v20;
      }
      while (v9 != v7);
    }
  }
  return 0;
}

uint64_t HgcBlur_cs9s::GetDOD(HgcBlur_cs9s *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = &HGRectInfinite;
  if (a3) {
    uint64_t v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcBlur_cs9s::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcBlur_cs9s::HgcBlur_cs9s(HgcBlur_cs9s *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F1AC0;
  operator new();
}

void sub_1B791988C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBlur_cs9s::~HgcBlur_cs9s(HGNode *this)
{
  *(void *)this = &unk_1F10F1AC0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40265AC83CLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F1AC0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40265AC83CLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F1AC0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40265AC83CLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBlur_cs9s::SetParameter(HgcBlur_cs9s *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 8) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int v8 = a3;
  float32x2_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlur_cs9s::GetParameter(HgcBlur_cs9s *this, unsigned int a2, float *a3)
{
  if (a2 > 8) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBlur_cs9s_rect::GetProgram(HgcBlur_cs9s_rect *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000952\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7, r8;\n"
             "    float4 s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord1.xy*hg_Params[5].xy + frag._texCoord0.xy;\n"
             "    s0.xy = s0.xy + hg_Params[6].xy;\n"
             "    s1.xy = s0.xy + hg_Params[7].xy;\n"
             "    s2.xy = s1.xy + hg_Params[7].xy;\n"
             "    s3.xy = s2.xy + hg_Params[7].xy;\n"
             "    s4.xy = s3.xy + hg_Params[7].xy;\n"
             "    s5.xy = s4.xy + hg_Params[7].xy;\n"
             "    s6.xy = s5.xy + hg_Params[7].xy;\n"
             "    s7.xy = s6.xy + hg_Params[7].xy;\n"
             "    s8.xy = s7.xy + hg_Params[7].xy;\n"
             "    s9.xy = s0.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s9.xy = s8.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r0 = r0 + r1;\n"
             "    s9.xy = s1.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s9.xy = s7.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r3 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r2 = r2 + r3;\n"
             "    s9.xy = s2.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r4 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s9.xy = s6.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r5 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r4 = r4 + r5;\n"
             "    s9.xy = s3.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r6 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s9.xy = s5.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r7 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r6 = r6 + r7;\n"
             "    s9.xy = s4.xy + hg_Params[8].xy;\n"
             "    s9.xy = s9.xy*hg_Params[8].zw;\n"
             "    r8 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r8 = r8*half4(hg_Params[0]);\n"
             "    r8 = r6*half4(hg_Params[1]) + r8;\n"
             "    r8 = r4*half4(hg_Params[2]) + r8;\n"
             "    r8 = r2*half4(hg_Params[3]) + r8;\n"
             "    r8 = r0*half4(hg_Params[4]) + r8;\n"
             "    output.color0 = float4(r8);\n"
             "    return output;\n"
             "}\n"
             "//MD5=20231576:38422c71:410e9f91:50cad1c9\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0009:0013:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000008b2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord1.xy*hg_Params[5].xy + frag._texCoord0.xy;\n"
             "    r0.xy = r0.xy + hg_Params[6].xy;\n"
             "    r1.xy = r0.xy + hg_Params[7].xy;\n"
             "    r2.xy = r1.xy + hg_Params[7].xy;\n"
             "    r3.xy = r2.xy + hg_Params[7].xy;\n"
             "    r4.xy = r3.xy + hg_Params[7].xy;\n"
             "    r5.xy = r4.xy + hg_Params[7].xy;\n"
             "    r6.xy = r5.xy + hg_Params[7].xy;\n"
             "    r7.xy = r6.xy + hg_Params[7].xy;\n"
             "    r8.xy = r7.xy + hg_Params[7].xy;\n"
             "    r9.xy = r0.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r9.xy = r8.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r8 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r0 = r0 + r8;\n"
             "    r9.xy = r1.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r9.xy = r7.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r7 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r1 = r1 + r7;\n"
             "    r9.xy = r2.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r9.xy = r6.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r6 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r2 = r2 + r6;\n"
             "    r9.xy = r3.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r3 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r9.xy = r5.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r5 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r3 = r3 + r5;\n"
             "    r9.xy = r4.xy + hg_Params[8].xy;\n"
             "    r9.xy = r9.xy*hg_Params[8].zw;\n"
             "    r4 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
             "    r4 = r4*hg_Params[0];\n"
             "    r4 = r3*hg_Params[1] + r4;\n"
             "    r4 = r2*hg_Params[2] + r4;\n"
             "    r4 = r1*hg_Params[3] + r4;\n"
             "    r4 = r0*hg_Params[4] + r4;\n"
             "    output.color0 = r4;\n"
             "    return output;\n"
             "}\n"
             "//MD5=32296e5f:5026098e:617aecba:68002612\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0009:000a:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000009f8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "uniform highp vec4 hg_ProgramLocal8;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;\n"
           "\n"
           "    r0.xy = hg_TexCoord1.xy*hg_ProgramLocal5.xy + hg_TexCoord0.xy;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal6.xy;\n"
           "    r1.xy = r0.xy + hg_ProgramLocal7.xy;\n"
           "    r2.xy = r1.xy + hg_ProgramLocal7.xy;\n"
           "    r3.xy = r2.xy + hg_ProgramLocal7.xy;\n"
           "    r4.xy = r3.xy + hg_ProgramLocal7.xy;\n"
           "    r5.xy = r4.xy + hg_ProgramLocal7.xy;\n"
           "    r6.xy = r5.xy + hg_ProgramLocal7.xy;\n"
           "    r7.xy = r6.xy + hg_ProgramLocal7.xy;\n"
           "    r8.xy = r7.xy + hg_ProgramLocal7.xy;\n"
           "    r9.xy = r0.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r0 = texture2D(hg_Texture0, r9.xy);\n"
           "    r9.xy = r8.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r8 = texture2D(hg_Texture0, r9.xy);\n"
           "    r0 = r0 + r8;\n"
           "    r9.xy = r1.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r1 = texture2D(hg_Texture0, r9.xy);\n"
           "    r9.xy = r7.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r7 = texture2D(hg_Texture0, r9.xy);\n"
           "    r1 = r1 + r7;\n"
           "    r9.xy = r2.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r2 = texture2D(hg_Texture0, r9.xy);\n"
           "    r9.xy = r6.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r6 = texture2D(hg_Texture0, r9.xy);\n"
           "    r2 = r2 + r6;\n"
           "    r9.xy = r3.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r3 = texture2D(hg_Texture0, r9.xy);\n"
           "    r9.xy = r5.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r5 = texture2D(hg_Texture0, r9.xy);\n"
           "    r3 = r3 + r5;\n"
           "    r9.xy = r4.xy + hg_ProgramLocal8.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal8.zw;\n"
           "    r4 = texture2D(hg_Texture0, r9.xy);\n"
           "    r4 = r4*hg_ProgramLocal0;\n"
           "    r4 = r3*hg_ProgramLocal1 + r4;\n"
           "    r4 = r2*hg_ProgramLocal2 + r4;\n"
           "    r4 = r1*hg_ProgramLocal3 + r4;\n"
           "    r4 = r0*hg_ProgramLocal4 + r4;\n"
           "    gl_FragColor = r4;\n"
           "}\n"
           "//MD5=7ad25e9b:38f9f67b:041a5da1:774d8277\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0009:000a:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcBlur_cs9s_rect::InitProgramDescriptor(HgcBlur_cs9s_rect *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlur_cs9s_rect_hgc_visible", "//Metal1.0     \n//LEN=0000000806\n[[ visible ]] FragmentOut HgcBlur_cs9s_rect_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord1.xy*hg_Params[5].xy + texCoord0.xy;\n"
    "    r0.xy = r0.xy + hg_Params[6].xy;\n"
    "    r1.xy = r0.xy + hg_Params[7].xy;\n"
    "    r2.xy = r1.xy + hg_Params[7].xy;\n"
    "    r3.xy = r2.xy + hg_Params[7].xy;\n"
    "    r4.xy = r3.xy + hg_Params[7].xy;\n"
    "    r5.xy = r4.xy + hg_Params[7].xy;\n"
    "    r6.xy = r5.xy + hg_Params[7].xy;\n"
    "    r7.xy = r6.xy + hg_Params[7].xy;\n"
    "    r8.xy = r7.xy + hg_Params[7].xy;\n"
    "    r9.xy = r0.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r9.xy = r8.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r8 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r0 = r0 + r8;\n"
    "    r9.xy = r1.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r9.xy = r7.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r7 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r1 = r1 + r7;\n"
    "    r9.xy = r2.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r9.xy = r6.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r6 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r2 = r2 + r6;\n"
    "    r9.xy = r3.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r3 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r9.xy = r5.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r5 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r3 = r3 + r5;\n"
    "    r9.xy = r4.xy + hg_Params[8].xy;\n"
    "    r9.xy = r9.xy*hg_Params[8].zw;\n"
    "    r4 = hg_Texture0.sample(hg_Sampler0, r9.xy);\n"
    "    r4 = r4*hg_Params[0];\n"
    "    r4 = r3*hg_Params[1] + r4;\n"
    "    r4 = r2*hg_Params[2] + r4;\n"
    "    r4 = r1*hg_Params[3] + r4;\n"
    "    r4 = r0*hg_Params[4] + r4;\n"
    "    output.color0 = r4;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBlur_cs9s_rect");
}

void sub_1B7919F60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7919F9C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7919F94);
}

char *HgcBlur_cs9s_rect::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8349210;
  strcpy(result, "HgcBlur_cs9s_rect [hgc1]");
  return result;
}

uint64_t HgcBlur_cs9s_rect::BindTexture(HgcBlur_cs9s_rect *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 8, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcBlur_cs9s_rect::Bind(HgcBlur_cs9s_rect *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBlur_cs9s_rect::RenderTile(float32x4_t **this, HGTile *a2)
{
  uint64_t v4 = HGTile::Renderer(a2);
  int v5 = ((uint64_t (*)(float32x4_t **, uint64_t))(*this)[19].i64[1])(this, v4);
  int32x2_t v6 = *(int32x2_t *)a2;
  int v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v7 >= 1)
  {
    uint64_t v8 = (*((_DWORD *)a2 + 2) - v6.i32[0]);
    if ((int)v8 >= 1)
    {
      *(float32x2_t *)v9.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v9.i64[1] = 0x3F80000000000000;
      uint64_t v10 = *((void *)a2 + 2);
      int v11 = 0;
      uint64_t v12 = 16 * *((int *)a2 + 6);
      uint64_t v13 = 16 * v8;
      if (v5)
      {
        float32x4_t v14 = v9;
        float32x4_t v15 = v9;
        do
        {
          uint64_t v16 = 0;
          float32x4_t v17 = v14;
          float32x4_t v18 = v15;
          do
          {
            int32x2_t v19 = this[51];
            float32x4_t v20 = v19[7];
            float32x4_t v21 = vaddq_f32(v19[6], vaddq_f32(v17, vmulq_f32(v18, v19[5])));
            float32x4_t v22 = vaddq_f32(v20, v21);
            float32x4_t v23 = vaddq_f32(v20, v22);
            float32x4_t v24 = vaddq_f32(v20, v23);
            float32x4_t v25 = vaddq_f32(v20, v24);
            float32x4_t v26 = vaddq_f32(v20, v25);
            uint64_t v27 = *((void *)a2 + 10);
            uint64_t v28 = *((int *)a2 + 22);
            float32x4_t v29 = vsubq_f32(v21, v9);
            int32x4_t v30 = vaddq_s32(vcvtq_s32_f32(v29), vcltzq_f32(v29));
            float32x4_t v31 = vaddq_f32(v20, v26);
            v29.i64[0] = vsubq_f32(v29, vcvtq_f32_s32(v30)).u64[0];
            __int32 v32 = v30.i32[1];
            __int32 v33 = v30.i32[0];
            float32x4_t v34 = vaddq_f32(v20, v31);
            int8x16_t v35 = (float32x4_t *)(v27 + 16 * (v33 + v32 * (int)v28));
            float32x4_t v36 = vaddq_f32(*v35, vmulq_n_f32(vsubq_f32(v35[1], *v35), v29.f32[0]));
            uint64_t v37 = (int)v28 + 1;
            float32x4_t v38 = vsubq_f32(v22, v9);
            int32x4_t v39 = vaddq_s32(vcvtq_s32_f32(v38), vcltzq_f32(v38));
            float32x4_t v40 = vsubq_f32(vaddq_f32(v20, v34), v9);
            v38.i64[0] = vsubq_f32(v38, vcvtq_f32_s32(v39)).u64[0];
            float32x4_t v41 = vsubq_f32(vaddq_f32(v35[v28], vmulq_n_f32(vsubq_f32(v35[v37], v35[v28]), v29.f32[0])), v36);
            uint64_t v42 = (float32x4_t *)(v27 + 16 * (v39.i32[0] + v39.i32[1] * (int)v28));
            float32x4_t v43 = vaddq_f32(*v42, vmulq_n_f32(vsubq_f32(v42[1], *v42), v38.f32[0]));
            float32x4_t v44 = vaddq_f32(v42[v28], vmulq_n_f32(vsubq_f32(v42[v37], v42[v28]), v38.f32[0]));
            float32x4_t v45 = vsubq_f32(v34, v9);
            int32x4_t v46 = vaddq_s32(vcvtq_s32_f32(v45), vcltzq_f32(v45));
            float32x4_t v47 = vsubq_f32(v23, v9);
            float32x4_t v48 = vmulq_lane_f32(v41, *(float32x2_t *)v29.f32, 1);
            int32x4_t v49 = vaddq_s32(vcvtq_s32_f32(v47), vcltzq_f32(v47));
            float32x4_t v50 = vcvtq_f32_s32(v49);
            LODWORD(v42) = v49.i32[1];
            __int32 v51 = v49.i32[0];
            float32x4_t v52 = vsubq_f32(v44, v43);
            float32x4_t v53 = (float32x4_t *)(v27 + 16 * (v51 + (int)v42 * (int)v28));
            float32x4_t v54 = v53[v28];
            int32x4_t v55 = vaddq_s32(vcvtq_s32_f32(v40), vcltzq_f32(v40));
            float32x4_t v57 = *v53;
            float32x4_t v56 = v53[1];
            float32x4_t v58 = vsubq_f32(v31, v9);
            int32x4_t v59 = vaddq_s32(vcvtq_s32_f32(v58), vcltzq_f32(v58));
            float32x4_t v60 = vaddq_f32(v36, v48);
            float32x4_t v61 = vcvtq_f32_s32(v59);
            float32x4_t v62 = vsubq_f32(v24, v9);
            int32x4_t v63 = vaddq_s32(vcvtq_s32_f32(v62), vcltzq_f32(v62));
            float32x4_t v64 = vcvtq_f32_s32(v63);
            __int32 v65 = v55.i32[1];
            __int32 v66 = v63.i32[1];
            __int32 v67 = v63.i32[0];
            float32x4_t v68 = v53[v37];
            LODWORD(v53) = v55.i32[0];
            int v69 = v46.i32[0] + v46.i32[1] * v28;
            float32x4_t v70 = vmulq_lane_f32(v52, *(float32x2_t *)v38.f32, 1);
            v38.i64[0] = vsubq_f32(v45, vcvtq_f32_s32(v46)).u64[0];
            v47.i64[0] = vsubq_f32(v47, v50).u64[0];
            float32x4_t v71 = vsubq_f32(v56, v57);
            float32x4_t v72 = (float32x4_t *)(v27 + 16 * (v59.i32[0] + v59.i32[1] * (int)v28));
            v46.i64[0] = vsubq_f32(v40, vcvtq_f32_s32(v55)).u64[0];
            float32x4_t v73 = v72[v28];
            float32x4_t v74 = v72[v37];
            float32x4_t v76 = *v72;
            float32x4_t v75 = v72[1];
            float32x4_t v77 = vaddq_f32(v57, vmulq_n_f32(v71, v47.f32[0]));
            float32x4_t v78 = vaddq_f32(v43, v70);
            float32x2_t v79 = (float32x4_t *)(v27 + 16 * (v67 + v66 * (int)v28));
            float32x4_t v81 = *v79;
            float32x4_t v80 = v79[1];
            float32x4_t v82 = v79[v28];
            float32x4_t v83 = v79[v37];
            float32x4_t v84 = (float32x4_t *)(v27 + 16 * v69);
            int8x16_t v85 = (float32x4_t *)(v27 + 16 * ((int)v53 + v65 * (int)v28));
            float32x4_t v86 = vaddq_f32(v77, vmulq_lane_f32(vsubq_f32(vaddq_f32(v54, vmulq_n_f32(vsubq_f32(v68, v54), v47.f32[0])), v77), *(float32x2_t *)v47.f32, 1));
            v58.i64[0] = vsubq_f32(v58, v61).u64[0];
            float32x4_t v87 = v85[v28];
            v62.i64[0] = vsubq_f32(v62, v64).u64[0];
            float32x4_t v88 = vaddq_f32(v81, vmulq_n_f32(vsubq_f32(v80, v81), v62.f32[0]));
            float32x4_t v89 = vaddq_f32(v76, vmulq_n_f32(vsubq_f32(v75, v76), v58.f32[0]));
            float32x4_t v90 = vaddq_f32(v73, vmulq_n_f32(vsubq_f32(v74, v73), v58.f32[0]));
            float32x4_t v91 = vaddq_f32(*v84, vmulq_n_f32(vsubq_f32(v84[1], *v84), v38.f32[0]));
            float32x4_t v92 = vsubq_f32(v26, v9);
            int32x4_t v93 = vaddq_s32(vcvtq_s32_f32(v92), vcltzq_f32(v92));
            v92.i64[0] = vsubq_f32(v92, vcvtq_f32_s32(v93)).u64[0];
            float32x4_t v94 = vmulq_n_f32(vsubq_f32(v85[v37], v87), *(float *)v46.i32);
            float32x4_t v95 = vaddq_f32(*v85, vmulq_n_f32(vsubq_f32(v85[1], *v85), *(float *)v46.i32));
            float32x4_t v96 = (float32x4_t *)(v27 + 16 * (v93.i32[0] + v93.i32[1] * (int)v28));
            float32x4_t v97 = vaddq_f32(*v96, vmulq_n_f32(vsubq_f32(v96[1], *v96), v92.f32[0]));
            float32x4_t v98 = vaddq_f32(vaddq_f32(v88, vmulq_lane_f32(vsubq_f32(vaddq_f32(v82, vmulq_n_f32(vsubq_f32(v83, v82), v62.f32[0])), v88), *(float32x2_t *)v62.f32, 1)), vaddq_f32(v97, vmulq_lane_f32(vsubq_f32(vaddq_f32(v96[v28], vmulq_n_f32(vsubq_f32(v96[v37], v96[v28]), v92.f32[0])), v97), *(float32x2_t *)v92.f32, 1)));
            float32x4_t v99 = vsubq_f32(v25, v9);
            int32x4_t v100 = vaddq_s32(vcvtq_s32_f32(v99), vcltzq_f32(v99));
            v99.i64[0] = vsubq_f32(v99, vcvtq_f32_s32(v100)).u64[0];
            float32x2_t v101 = (float32x4_t *)(v27 + 16 * (v100.i32[0] + v100.i32[1] * (int)v28));
            float32x4_t v102 = vaddq_f32(*v101, vmulq_n_f32(vsubq_f32(v101[1], *v101), v99.f32[0]));
            *(float32x4_t *)(v10 + v16) = vaddq_f32(vmulq_f32(vaddq_f32(v60, vaddq_f32(v95, vmulq_lane_f32(vsubq_f32(vaddq_f32(v87, v94), v95), *(float32x2_t *)v46.i8, 1))), v19[4]), vaddq_f32(vmulq_f32(vaddq_f32(v78, vaddq_f32(v91, vmulq_lane_f32(vsubq_f32(vaddq_f32(
                                                          v84[v28],
                                                          vmulq_n_f32(vsubq_f32(v84[v37], v84[v28]), v38.f32[0])),
                                                        v91),
                                                      *(float32x2_t *)v38.f32,
                                                      1))),
                                                v19[3]),
                                              vaddq_f32(vmulq_f32(vaddq_f32(v86, vaddq_f32(v89, vmulq_lane_f32(vsubq_f32(v90, v89), *(float32x2_t *)v58.f32, 1))), v19[2]), vaddq_f32(vmulq_f32(vaddq_f32(v102, vmulq_lane_f32(vsubq_f32(vaddq_f32(v101[v28], vmulq_n_f32(vsubq_f32(v101[v37], v101[v28]), v99.f32[0])), v102), *(float32x2_t *)v99.f32, 1)),
                                                    *v19),
                                                  vmulq_f32(v98, v19[1])))));
            float32x4_t v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B7E736B0);
            float32x4_t v18 = vaddq_f32(v18, (float32x4_t)xmmword_1B7E736B0);
            v16 += 16;
          }
          while (v13 != v16);
          float32x4_t v14 = vaddq_f32(v14, (float32x4_t)xmmword_1B7E736C0);
          float32x4_t v15 = vaddq_f32(v15, (float32x4_t)xmmword_1B7E736C0);
          ++v11;
          v10 += v12;
        }
        while (v11 != v7);
      }
      else
      {
        v103.i64[0] = 0x3F0000003F000000;
        v103.i64[1] = 0x3F0000003F000000;
        float32x4_t v104 = v9;
        float32x4_t v105 = v9;
        do
        {
          uint64_t v106 = 0;
          float32x4_t v107 = v104;
          float32x4_t v108 = v105;
          do
          {
            int8x16_t v109 = this[51];
            float32x4_t v110 = v109[7];
            float32x4_t v111 = vaddq_f32(v109[6], vaddq_f32(v107, vmulq_f32(v108, v109[5])));
            float32x4_t v112 = vaddq_f32(v110, v111);
            float32x4_t v113 = vaddq_f32(v110, v112);
            float32x4_t v114 = vaddq_f32(v110, v113);
            float32x4_t v115 = vaddq_f32(v110, v114);
            float32x4_t v116 = vaddq_f32(v110, v115);
            uint64_t v117 = *((void *)a2 + 10);
            int v118 = *((_DWORD *)a2 + 22);
            float32x4_t v119 = vaddq_f32(v110, v116);
            float32x4_t v120 = vaddq_f32(vsubq_f32(v111, v9), v103);
            int32x4_t v121 = vcvtq_s32_f32(v120);
            v120.i64[0] = vaddq_s32(v121, vcgtq_f32(vcvtq_f32_s32(v121), v120)).u64[0];
            float32x4_t v122 = vaddq_f32(v110, v119);
            float32x4_t v123 = vaddq_f32(vsubq_f32(v112, v9), v103);
            int32x4_t v124 = vcvtq_s32_f32(v123);
            v123.i64[0] = vaddq_s32(v124, vcgtq_f32(vcvtq_f32_s32(v124), v123)).u64[0];
            __int32 v125 = v123.i32[1];
            __int32 v126 = v123.i32[0];
            float32x4_t v127 = vaddq_f32(vsubq_f32(vaddq_f32(v110, v122), v9), v103);
            __int32 v128 = v126 + v125 * v118;
            float32x4_t v129 = vaddq_f32(vsubq_f32(v122, v9), v103);
            float32x4_t v130 = vaddq_f32(vsubq_f32(v113, v9), v103);
            int32x4_t v131 = vcvtq_s32_f32(v129);
            int32x4_t v132 = vcvtq_s32_f32(v130);
            v130.i64[0] = vaddq_s32(v132, vcgtq_f32(vcvtq_f32_s32(v132), v130)).u64[0];
            int32x4_t v133 = vcvtq_s32_f32(v127);
            __int32 v134 = v130.i32[1];
            __int32 v135 = v130.i32[0];
            float32x4_t v136 = vaddq_f32(vsubq_f32(v119, v9), v103);
            int32x4_t v137 = vcvtq_s32_f32(v136);
            float32x4_t v138 = *(float32x4_t *)(v117 + 16 * v128);
            v129.i64[0] = vaddq_s32(v131, vcgtq_f32(vcvtq_f32_s32(v131), v129)).u64[0];
            v136.i64[0] = vaddq_s32(v137, vcgtq_f32(vcvtq_f32_s32(v137), v136)).u64[0];
            float32x4_t v139 = *(float32x4_t *)(v117 + 16 * (v135 + v134 * v118));
            __int32 v140 = v136.i32[0] + v136.i32[1] * v118;
            v127.i64[0] = vaddq_s32(v133, vcgtq_f32(vcvtq_f32_s32(v133), v127)).u64[0];
            float32x4_t v141 = vaddq_f32(vsubq_f32(v114, v9), v103);
            int32x4_t v142 = vcvtq_s32_f32(v141);
            __int32 v143 = v127.i32[1];
            v141.i64[0] = vaddq_s32(v142, vcgtq_f32(vcvtq_f32_s32(v142), v141)).u64[0];
            __int32 v144 = v127.i32[0];
            float32x4_t v145 = *(float32x4_t *)(v117 + 16 * (v141.i32[0] + v141.i32[1] * v118));
            __int32 v146 = v129.i32[0] + v129.i32[1] * v118;
            float32x4_t v147 = vaddq_f32(vsubq_f32(v116, v9), v103);
            int32x4_t v148 = vcvtq_s32_f32(v147);
            v147.i64[0] = vaddq_s32(v148, vcgtq_f32(vcvtq_f32_s32(v148), v147)).u64[0];
            float32x4_t v149 = vaddq_f32(vsubq_f32(v115, v9), v103);
            int32x4_t v150 = vcvtq_s32_f32(v149);
            v149.i64[0] = vaddq_s32(v150, vcgtq_f32(vcvtq_f32_s32(v150), v149)).u64[0];
            *(float32x4_t *)(v10 + v106) = vaddq_f32(vmulq_f32(vaddq_f32(*(float32x4_t *)(v117 + 16 * (v120.i32[0] + v120.i32[1] * v118)), *(float32x4_t *)(v117 + 16 * (v144 + v143 * v118))), v109[4]), vaddq_f32(vmulq_f32(vaddq_f32(v138, *(float32x4_t *)(v117 + 16 * v146)), v109[3]), vaddq_f32(vmulq_f32(vaddq_f32(v139, *(float32x4_t *)(v117 + 16 * v140)), v109[2]), vaddq_f32(vmulq_f32(*(float32x4_t *)(v117 + 16 * (v149.i32[0] + v149.i32[1] * v118)), *v109), vmulq_f32(vaddq_f32(v145, *(float32x4_t *)(v117 + 16 * (v147.i32[0] + v147.i32[1] * v118))),
                                                     v109[1])))));
            float32x4_t v107 = vaddq_f32(v107, (float32x4_t)xmmword_1B7E736B0);
            float32x4_t v108 = vaddq_f32(v108, (float32x4_t)xmmword_1B7E736B0);
            v106 += 16;
          }
          while (v13 != v106);
          float32x4_t v104 = vaddq_f32(v104, (float32x4_t)xmmword_1B7E736C0);
          float32x4_t v105 = vaddq_f32(v105, (float32x4_t)xmmword_1B7E736C0);
          ++v11;
          v10 += v12;
        }
        while (v11 != v7);
      }
    }
  }
  return 0;
}

uint64_t HgcBlur_cs9s_rect::GetDOD(HgcBlur_cs9s_rect *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  if ((*(int (**)(HgcBlur_cs9s_rect *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
  {
    uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    HGRectGrow(v6, v5, v7);
  }
  return 0x8000000080000000;
}

uint64_t HgcBlur_cs9s_rect::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  uint64_t v10 = v9;
  if ((*(int (**)(HGNode *, HGRenderer *))(*(void *)this + 312))(this, a2) < 1) {
    return DOD;
  }
  uint64_t v11 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  return HGRectGrow(DOD, v10, v11);
}

void HgcBlur_cs9s_rect::HgcBlur_cs9s_rect(HgcBlur_cs9s_rect *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F1D28;
  operator new();
}

void sub_1B791AC7C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(HGNode *this)
{
  *(void *)this = &unk_1F10F1D28;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F1D28;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F1D28;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBlur_cs9s_rect::SetParameter(HgcBlur_cs9s_rect *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlur_cs9s_rect::GetParameter(HgcBlur_cs9s_rect *this, unsigned int a2, float *a3)
{
  if (a2 > 7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorGamma_chroma_upsample_f1::GetProgram(HgcColorGamma_chroma_upsample_f1 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000532\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.x = floor(frag._texCoord1.x);\n"
             "    s1.xz = hg_Params[1].xz;\n"
             "    s1.x = dot(s1.xz, 1.00000f);\n"
             "    s1.x = s1.x - float(c0.x);\n"
             "    s1.x = s1.x - s0.x;\n"
             "    s1.xy = select(-float2(c0.xy), float2(c0.xy), s1.xx > 0.00000h);\n"
             "    s1.xy = frag._texCoord1.xy + s1.xy;\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s1.xy = s1.xy + hg_Params[0].xy;\n"
             "    s1.xy = s1.xy*hg_Params[0].zw;\n"
             "    r1.yz = (half2) hg_Texture0.sample(hg_Sampler0, s1.xy).yz;\n"
             "    r2.yz = (half2) hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy).yz;\n"
             "    r1.yz = mix(r2.yz, r1.yz, c0.zz);\n"
             "    s0.yz = float2(fract(0.500000f*frag._texCoord1.xx) >= 0.500000f);\n"
             "    s1.xw = float2(r0.xw);\n"
             "    s1.yz = select(float2(r0.yz), float2(r1.yz), s0.yz > 0.00000h);\n"
             "    output.color0 = s1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d15e8235:1bcea85f:801bb56b:2741a3f6\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0002:0005:0000:0000:0000:000e:0000:0003:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004c9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = floor(frag._texCoord1.x);\n"
             "    r1.xz = hg_Params[1].xz;\n"
             "    r1.x = dot(r1.xz, 1.00000f);\n"
             "    r1.x = r1.x - c0.x;\n"
             "    r1.x = r1.x - r0.x;\n"
             "    r1.xy = select(-c0.xy, c0.xy, r1.xx > 0.00000f);\n"
             "    r1.xy = frag._texCoord1.xy + r1.xy;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = r1.xy + hg_Params[0].xy;\n"
             "    r1.xy = r1.xy*hg_Params[0].zw;\n"
             "    r1.yz = hg_Texture0.sample(hg_Sampler0, r1.xy).yz;\n"
             "    r2.yz = hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy).yz;\n"
             "    r1.yz = mix(r2.yz, r1.yz, c0.zz);\n"
             "    r2.yz = float2(fract(0.500000f*frag._texCoord1.xx) >= 0.500000f);\n"
             "    r0.yz = select(r0.yz, r1.yz, r2.yz > 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f819144d:7b0341ff:b247e70a:9881758d\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0002:0003:0000:0000:0000:000e:0000:0003:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000054a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.x = floor(hg_TexCoord1.x);\n"
           "    r1.xz = hg_ProgramLocal1.xz;\n"
           "    r1.x = dot(r1.xz, vec2(1.00000));\n"
           "    r1.x = r1.x - c0.x;\n"
           "    r1.x = r1.x - r0.x;\n"
           "    r1.xy = vec2(r1.x > 0.00000 ? c0.x : -c0.x, r1.x > 0.00000 ? c0.y : -c0.y);\n"
           "    r1.xy = hg_TexCoord1.xy + r1.xy;\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xy = r1.xy + hg_ProgramLocal0.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal0.zw;\n"
           "    r1.yz = texture2D(hg_Texture0, r1.xy).yz;\n"
           "    r2.yz = texture2D(hg_Texture0, hg_TexCoord2.xy).yz;\n"
           "    r1.yz = mix(r2.yz, r1.yz, c0.zz);\n"
           "    r2.yz = c0.zz*hg_TexCoord1.xx;\n"
           "    r2.yz = fract(r2.yz);\n"
           "    r2.yz = vec2(greaterThanEqual(r2.yz, c0.zz));\n"
           "    r0.yz = vec2(r2.y > 0.00000 ? r1.y : r0.y, r2.z > 0.00000 ? r1.z : r0.z);\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=2635f3eb:1d6c7af1:cbb290bc:c440b6c0\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
  }
}

void HgcColorGamma_chroma_upsample_f1::InitProgramDescriptor(HgcColorGamma_chroma_upsample_f1 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_chroma_upsample_f1_hgc_visible", "//Metal1.0     \n//LEN=0000000430\n[[ visible ]] FragmentOut HgcColorGamma_chroma_upsample_f1_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1,\n    float4 texCoord2)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = floor(texCoord1.x);\n"
    "    r1.xz = hg_Params[1].xz;\n"
    "    r1.x = dot(r1.xz, 1.00000f);\n"
    "    r1.x = r1.x - c0.x;\n"
    "    r1.x = r1.x - r0.x;\n"
    "    r1.xy = select(-c0.xy, c0.xy, r1.xx > 0.00000f);\n"
    "    r1.xy = texCoord1.xy + r1.xy;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, texCoord0.xy);\n"
    "    r1.xy = r1.xy + hg_Params[0].xy;\n"
    "    r1.xy = r1.xy*hg_Params[0].zw;\n"
    "    r1.yz = hg_Texture0.sample(hg_Sampler0, r1.xy).yz;\n"
    "    r2.yz = hg_Texture0.sample(hg_Sampler0, texCoord2.xy).yz;\n"
    "    r1.yz = mix(r2.yz, r1.yz, c0.zz);\n"
    "    r2.yz = float2(fract(0.500000f*texCoord1.xx) >= 0.500000f);\n"
    "    r0.yz = select(r0.yz, r1.yz, r2.yz > 0.00000f);\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorGamma_chroma_upsample_f1");
}

void sub_1B791B3E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B791B428(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B791B420);
}

char *HgcColorGamma_chroma_upsample_f1::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376020;
  strcpy(result, "HgcColorGamma_chroma_upsample_f1 [hgc1]");
  return result;
}

uint64_t HgcColorGamma_chroma_upsample_f1::BindTexture(HgcColorGamma_chroma_upsample_f1 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, void, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 0, v5, v6, v7, v8);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  HGHandler::TexCoord(a2, 2, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, -1.0, 0.0, 0.0);
  return 0;
}

uint64_t HgcColorGamma_chroma_upsample_f1::Bind(HgcColorGamma_chroma_upsample_f1 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorGamma_chroma_upsample_f1::RenderTile(HGNode *this, int8x8_t *a2)
{
  __int32 v4 = a2[1].i32[0];
  int32x2_t v70 = (int32x2_t)*a2;
  uint64_t v5 = (a2[1].i32[1] - HIDWORD(*(unint64_t *)a2));
  uint64_t v6 = a2[11].i32[0];
  int8x8_t v7 = a2[10];
  __n128 v8 = (HGRenderer *)HGTile::Renderer((HGTile *)a2);
  int32x2_t DOD = (int32x2_t)HGRenderer::GetDOD(v8, this);
  if ((int)v5 >= 1)
  {
    uint64_t v11 = 0;
    *(float32x2_t *)v12.f32 = vadd_f32(vcvt_f32_s32(v70), (float32x2_t)0x3F0000003F000000);
    v12.i64[1] = 0x3F80000000000000;
    int v13 = v4 - v70.i32[0];
    int8x8_t v14 = a2[2];
    *(float32x2_t *)v15.i8 = vcvt_f32_s32((int32x2_t)vand_s8(*a2, (int8x8_t)0x100000001));
    v15.i64[1] = 0x3F80000000000000;
    *(float *)v16.i32 = (float)((v4 - v70.i32[0]) & 1);
    v16.i32[1] = 1.0;
    v16.i64[1] = 0;
    *(int32x2_t *)v17.i8 = vsub_s32(v10, DOD);
    v17.u64[1] = (unint64_t)DOD;
    int8x16_t v18 = (int8x16_t)vcvtq_f32_s32(v17);
    float32x4_t v19 = vaddq_f32((float32x4_t)vextq_s8(v18, v18, 8uLL), (float32x4_t)v18);
    float32x4_t v20 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), (float32x4_t)v18);
    uint64_t v21 = 16 * a2[3].i32[0];
    unint64_t v22 = 0xFFFFFFFF00000000;
    v23.i64[0] = 0x3F0000003F000000;
    v23.i64[1] = 0x3F0000003F000000;
    int8x8_t v24 = v7;
    float32x4_t v25 = v12;
    while (1)
    {
      int8x16_t v26 = veorq_s8(v15, (int8x16_t)xmmword_1B7E736B0);
      if (v13 >= 2) {
        break;
      }
      int v61 = 0;
      float32x4_t v32 = v25;
      if (v13 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v25 = vaddq_f32(v25, (float32x4_t)xmmword_1B7E736C0);
      int8x16_t v15 = veorq_s8(v15, v16);
      *(void *)&v14 += v21;
      ++v11;
      v22 += v6 << 32;
      *(void *)&v24 += 16 * v6;
      if (v11 == v5) {
        return 0;
      }
    }
    int v27 = 0;
    uint64_t v28 = 0;
    float32x4_t v29 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 0);
    float32x4_t v30 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.i8, 0);
    uint64_t v31 = v22;
    float32x4_t v32 = v25;
    do
    {
      float32x4_t v33 = vaddq_f32(v32, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v34 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
      float32x4_t v35 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
      uint64_t v36 = *((void *)this + 51);
      int8x16_t v37 = *(int8x16_t *)(v36 + 16);
      float32x4_t v38 = vsubq_f32(v19, *(float32x4_t *)v36);
      float32x4_t v39 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32(v38, vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v34, v32), *(int8x16_t *)v36, (int8x16_t)0), v34)), 0);
      float32x4_t v40 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32(v38, vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v35, v33), *(int8x16_t *)v36, (int8x16_t)0), v35)), 0);
      float32x4_t v41 = *(float32x4_t *)(v36 + 32);
      float32x4_t v42 = *(float32x4_t *)(v36 + 48);
      float32x4_t v43 = vaddq_f32(v32, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v39, v41), *(int8x16_t *)v36, v37));
      float32x4_t v44 = vaddq_f32(v33, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v40, v41), *(int8x16_t *)v36, v37));
      int8x8_t v45 = a2[10];
      __int32 v46 = a2[11].i32[0];
      float32x4_t v47 = vaddq_f32(vsubq_f32(v43, v12), v23);
      int32x4_t v48 = vcvtq_s32_f32(v47);
      v47.i64[0] = vaddq_s32(v48, vcgtq_f32(vcvtq_f32_s32(v48), v47)).u64[0];
      __int32 v49 = v47.i32[1];
      __int32 v50 = v47.i32[0];
      float32x4_t v51 = vaddq_f32(vsubq_f32(v44, v12), v23);
      int32x4_t v52 = vcvtq_s32_f32(v51);
      v51.i64[0] = vaddq_s32(v52, vcgtq_f32(vcvtq_f32_s32(v52), v51)).u64[0];
      int8x16_t v53 = *(int8x16_t *)(*(void *)&v24 + v28);
      int8x16_t v54 = *(int8x16_t *)(*(void *)&v24 + v28 + 16);
      int8x16_t v55 = (int8x16_t)vaddq_f32(*(float32x4_t *)(*(void *)&v7 + (v31 >> 28)), vmulq_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v45 + 16 * (v50 + v49 * v46)), *(float32x4_t *)(*(void *)&v7 + (v31 >> 28))), v42));
      int8x16_t v56 = (int8x16_t)vaddq_f32((float32x4_t)v53, vmulq_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v45 + 16 * (v51.i32[0] + v51.i32[1] * v46)), (float32x4_t)v53), v42));
      int8x16_t v57 = (int8x16_t)vcgtq_f32(v29, v41);
      int8x16_t v58 = vbslq_s8((int8x16_t)vcgtq_f32(v30, v41), v56, v54);
      int8x16_t v59 = *(int8x16_t *)(v36 + 64);
      float32x4_t v60 = (int8x16_t *)(*(void *)&v14 + v28);
      *float32x4_t v60 = vbslq_s8(v59, vbslq_s8(v57, v55, v53), v53);
      v60[1] = vbslq_s8(v59, v58, v54);
      float32x4_t v32 = vaddq_f32(v33, (float32x4_t)xmmword_1B7E736B0);
      v31 += 0x200000000;
      v28 += 32;
      v27 -= 2;
    }
    while (v13 + v27 > 1);
    int v61 = -v27;
    if (v61 >= v13) {
      goto LABEL_3;
    }
LABEL_10:
    float32x4_t v62 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
    uint64_t v63 = *((void *)this + 51);
    float32x4_t v64 = *(float32x4_t *)(v63 + 32);
    float32x4_t v65 = vaddq_f32(vsubq_f32(vaddq_f32(v32, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32(vsubq_f32(v20, *(float32x4_t *)v63), vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v62, v32), *(int8x16_t *)v63, (int8x16_t)0), v62)), 0), v64), *(int8x16_t *)v63, *(int8x16_t *)(v63 + 16))), v12),
            v23);
    int32x4_t v66 = vcvtq_s32_f32(v65);
    int8x16_t v67 = *(int8x16_t *)(*(void *)&v7 + 16 * (v11 * v6 + v61));
    v65.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v65)).u64[0];
    float32x4_t v68 = *(float32x4_t *)(*(void *)&v7 + 16 * ((int)v11 * (int)v6 + v61 - 1));
    *(int8x16_t *)(*(void *)&v14 + 16 * v61) = vbslq_s8(*(int8x16_t *)(v63 + 64), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 0), v64), (int8x16_t)vaddq_f32(v68, vmulq_f32(vsubq_f32(*(float32x4_t *)(*(void *)&a2[10] + 16 * (v65.i32[0] + v65.i32[1] * a2[11].i32[0])), v68), *(float32x4_t *)(v63 + 48))), v67), v67);
    int8x16_t v15 = v26;
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_chroma_upsample_f1::GetDOD(HgcColorGamma_chroma_upsample_f1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int32 v4 = &HGRectInfinite;
  if (a3) {
    __int32 v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcColorGamma_chroma_upsample_f1::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcColorGamma_chroma_upsample_f1::HgcColorGamma_chroma_upsample_f1(HgcColorGamma_chroma_upsample_f1 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F1F90;
  operator new();
}

void sub_1B791BC54(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_chroma_upsample_f1::~HgcColorGamma_chroma_upsample_f1(HGNode *this)
{
  *(void *)this = &unk_1F10F1F90;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F1F90;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F1F90;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_chroma_upsample_f1::SetParameter(HgcColorGamma_chroma_upsample_f1 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_chroma_upsample_f1::GetParameter(HgcColorGamma_chroma_upsample_f1 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcTextureWrapClampToEdge::GetProgram(HgcTextureWrapClampToEdge *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000036f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0 = hg_Params[1];\n"
             "    s1.xy = frag._texCoord0.xy - s0.zw;\n"
             "    s2.xy = s0.xy - float2(c0.xx);\n"
             "    s1.xy = fmin(s1.xy, s2.xy);\n"
             "    s1.xy = fmax(s1.xy, float2(c0.xx));\n"
             "    s1.xy = s1.xy + s0.zw;\n"
             "    s1.xy = s1.xy + hg_Params[0].xy;\n"
             "    s1.xy = s1.xy*hg_Params[0].zw;\n"
             "    output.color0 = (float4) hg_Texture0.sample(hg_Sampler0, s1.xy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=221ff63d:13dd7d75:60c547a0:c3470b13\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000359\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Params[1];\n"
             "    r1.xy = frag._texCoord0.xy - r0.zw;\n"
             "    r2.xy = r0.xy - c0.xx;\n"
             "    r1.xy = fmin(r1.xy, r2.xy);\n"
             "    r1.xy = fmax(r1.xy, c0.xx);\n"
             "    r1.xy = r1.xy + r0.zw;\n"
             "    r1.xy = r1.xy + hg_Params[0].xy;\n"
             "    r1.xy = r1.xy*hg_Params[0].zw;\n"
             "    output.color0 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8f249fac:b1c9a8e2:b56a003b:e01656c1\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000034e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = hg_ProgramLocal1;\n"
           "    r1.xy = hg_TexCoord0.xy - r0.zw;\n"
           "    r2.xy = r0.xy - c0.xx;\n"
           "    r1.xy = min(r1.xy, r2.xy);\n"
           "    r1.xy = max(r1.xy, c0.xx);\n"
           "    r1.xy = r1.xy + r0.zw;\n"
           "    r1.xy = r1.xy + hg_ProgramLocal0.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal0.zw;\n"
           "    gl_FragColor = texture2D(hg_Texture0, r1.xy);\n"
           "}\n"
           "//MD5=334048ff:96ec5d13:4628fd48:15f149a4\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcTextureWrapClampToEdge::InitProgramDescriptor(HgcTextureWrapClampToEdge *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcTextureWrapClampToEdge_hgc_visible", "//Metal1.0     \n//LEN=00000002a5\n[[ visible ]] FragmentOut HgcTextureWrapClampToEdge_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = hg_Params[1];\n"
    "    r1.xy = texCoord0.xy - r0.zw;\n"
    "    r2.xy = r0.xy - c0.xx;\n"
    "    r1.xy = fmin(r1.xy, r2.xy);\n"
    "    r1.xy = fmax(r1.xy, c0.xx);\n"
    "    r1.xy = r1.xy + r0.zw;\n"
    "    r1.xy = r1.xy + hg_Params[0].xy;\n"
    "    r1.xy = r1.xy*hg_Params[0].zw;\n"
    "    output.color0 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcTextureWrapClampToEdge");
}

void sub_1B791C1C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B791C200(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B791C1F8);
}

char *HgcTextureWrapClampToEdge::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B83761D0;
  strcpy(result, "HgcTextureWrapClampToEdge [hgc1]");
  return result;
}

uint64_t HgcTextureWrapClampToEdge::BindTexture(HgcTextureWrapClampToEdge *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, void, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 0, v5, v6, v7, v8);
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 1, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), (float)*((int *)a2 + 47), (float)*((int *)a2 + 48));
  return 0;
}

uint64_t HgcTextureWrapClampToEdge::Bind(HgcTextureWrapClampToEdge *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcTextureWrapClampToEdge::RenderTile(HgcTextureWrapClampToEdge *this, int32x2_t *a2)
{
  __int32 v4 = a2[1].i32[0];
  int32x2_t v67 = *a2;
  int v5 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  __n128 v6 = (HGRenderer *)HGTile::Renderer((HGTile *)a2);
  __n128 v7 = (HGRenderer *)HGTile::Renderer((HGTile *)a2);
  Input = HGRenderer::GetInput(v7, (HGNode *)this, 0);
  int32x2_t DOD = (int32x2_t)HGRenderer::GetDOD(v6, Input);
  if (v5 >= 1)
  {
    *(float32x2_t *)v11.f32 = vadd_f32(vcvt_f32_s32(v67), (float32x2_t)0x3F0000003F000000);
    v11.i64[1] = 0x3F80000000000000;
    *(int32x2_t *)v12.i8 = vsub_s32(v10, DOD);
    v12.u64[1] = (unint64_t)DOD;
    unint64_t v13 = (v4 - v67.i32[0]);
    int8x16_t v14 = (int8x16_t)vcvtq_f32_s32(v12);
    int32x2_t v15 = a2[2];
    uint64_t v16 = a2[3].i32[0];
    float32x4_t v17 = (float32x4_t)vextq_s8(v14, v14, 8uLL);
    if ((int)v13 < 4)
    {
      if ((int)v13 >= 1)
      {
        int v59 = 0;
        v60.i64[0] = 0x3F0000003F000000;
        v60.i64[1] = 0x3F0000003F000000;
        float32x4_t v61 = v11;
        do
        {
          uint64_t v62 = 0;
          float32x4_t v63 = v61;
          do
          {
            float32x4_t v64 = vaddq_f32(vsubq_f32(vaddq_f32(v17, vmaxq_f32(vminq_f32(vsubq_f32(v63, v17), vsubq_f32((float32x4_t)v14, *(float32x4_t *)*((void *)this + 51))), *(float32x4_t *)*((void *)this + 51))), v11), v60);
            int32x4_t v65 = vcvtq_s32_f32(v64);
            v64.i64[0] = vaddq_s32(v65, vcgtq_f32(vcvtq_f32_s32(v65), v64)).u64[0];
            *(_OWORD *)(*(void *)&v15 + v62) = *(_OWORD *)(*(void *)&a2[10]
                                                           + 16 * (v64.i32[0] + v64.i32[1] * a2[11].i32[0]));
            float32x4_t v63 = vaddq_f32(v63, (float32x4_t)xmmword_1B7E736B0);
            v62 += 16;
          }
          while (16 * (v4 - v67.i32[0]) != v62);
          float32x4_t v61 = vaddq_f32(v61, (float32x4_t)xmmword_1B7E736C0);
          ++v59;
          *(void *)&v15 += 16 * v16;
        }
        while (v59 != v5);
      }
    }
    else
    {
      int v18 = 0;
      float32x4_t v19 = (_OWORD *)(*(void *)&v15 + 32);
      uint64_t v20 = 16 * v16;
      uint64_t v21 = (_OWORD *)(*(void *)&v15 + 64);
      v22.i64[0] = 0x3F0000003F000000;
      v22.i64[1] = 0x3F0000003F000000;
      float32x4_t v23 = v11;
      do
      {
        unint64_t v24 = 0;
        float32x4_t v25 = v21;
        int8x16_t v26 = v19;
        float32x4_t v27 = v23;
        do
        {
          uint64_t v28 = v25;
          float32x4_t v29 = vaddq_f32(v27, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v30 = vaddq_f32(v29, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v31 = vaddq_f32(v30, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v32 = *(float32x4_t *)*((void *)this + 51);
          float32x4_t v33 = vsubq_f32((float32x4_t)v14, v32);
          __int32 v34 = a2[11].i32[0];
          float32x4_t v35 = vaddq_f32(vsubq_f32(vaddq_f32(v17, vmaxq_f32(vminq_f32(vsubq_f32(v27, v17), v33), v32)), v11), v22);
          int32x4_t v36 = vcvtq_s32_f32(v35);
          v35.i64[0] = vaddq_s32(v36, vcgtq_f32(vcvtq_f32_s32(v36), v35)).u64[0];
          float32x4_t v37 = vaddq_f32(vsubq_f32(vaddq_f32(v17, vmaxq_f32(vminq_f32(vsubq_f32(v29, v17), v33), v32)), v11), v22);
          __int32 v38 = v35.i32[1];
          int32x4_t v39 = vcvtq_s32_f32(v37);
          v37.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v37)).u64[0];
          __int32 v40 = v37.i32[1];
          __int32 v41 = v35.i32[0];
          __int32 v42 = v37.i32[0];
          float32x4_t v43 = vaddq_f32(vsubq_f32(vaddq_f32(v17, vmaxq_f32(vminq_f32(vsubq_f32(v30, v17), v33), v32)), v11), v22);
          int32x4_t v44 = vcvtq_s32_f32(v43);
          __int32 v45 = v41 + v38 * v34;
          v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
          __int32 v46 = v42 + v40 * v34;
          __int32 v47 = v43.i32[0] + v43.i32[1] * v34;
          int32x2_t v48 = a2[10];
          long long v49 = *(_OWORD *)(*(void *)&v48 + 16 * v45);
          float32x4_t v50 = vaddq_f32(vsubq_f32(vaddq_f32(v17, vmaxq_f32(vminq_f32(vsubq_f32(v31, v17), v33), v32)), v11), v22);
          int32x4_t v51 = vcvtq_s32_f32(v50);
          long long v52 = *(_OWORD *)(*(void *)&v48 + 16 * v46);
          v50.i64[0] = vaddq_s32(v51, vcgtq_f32(vcvtq_f32_s32(v51), v50)).u64[0];
          __int32 v53 = v50.i32[1];
          __int32 v54 = v50.i32[0];
          long long v55 = *(_OWORD *)(*(void *)&v48 + 16 * v47);
          long long v56 = *(_OWORD *)(*(void *)&v48 + 16 * (v54 + v53 * v34));
          *(v26 - 2) = v49;
          *(v26 - 1) = v52;
          *int8x16_t v26 = v55;
          v26[1] = v56;
          v26 += 4;
          float32x4_t v27 = vaddq_f32(v31, (float32x4_t)xmmword_1B7E736B0);
          v24 += 4;
          float32x4_t v25 = v28 + 4;
        }
        while ((uint64_t)v24 < (uint64_t)(v13 - 3));
        if ((int)v13 > (int)v24)
        {
          do
          {
            float32x4_t v57 = vaddq_f32(vsubq_f32(vaddq_f32(v17, vmaxq_f32(vminq_f32(vsubq_f32(v27, v17), vsubq_f32((float32x4_t)v14, *(float32x4_t *)*((void *)this + 51))), *(float32x4_t *)*((void *)this + 51))), v11), v22);
            int32x4_t v58 = vcvtq_s32_f32(v57);
            v57.i64[0] = vaddq_s32(v58, vcgtq_f32(vcvtq_f32_s32(v58), v57)).u64[0];
            *v28++ = *(_OWORD *)(*(void *)&a2[10] + 16 * (v57.i32[0] + v57.i32[1] * a2[11].i32[0]));
            float32x4_t v27 = vaddq_f32(v27, (float32x4_t)xmmword_1B7E736B0);
            ++v24;
          }
          while (v24 < v13);
        }
        float32x4_t v23 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E736C0);
        ++v18;
        float32x4_t v19 = (_OWORD *)((char *)v19 + v20);
        uint64_t v21 = (_OWORD *)((char *)v21 + v20);
      }
      while (v18 != v5);
    }
  }
  return 0;
}

uint64_t HgcTextureWrapClampToEdge::GetDOD(HgcTextureWrapClampToEdge *this, HGRenderer *a2, int a3, HGRect a4)
{
  __int32 v4 = &HGRectInfinite;
  if (a3) {
    __int32 v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcTextureWrapClampToEdge::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcTextureWrapClampToEdge::HgcTextureWrapClampToEdge(HgcTextureWrapClampToEdge *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F21F8;
  operator new();
}

void sub_1B791C8F0(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcTextureWrapClampToEdge::~HgcTextureWrapClampToEdge(HGNode *this)
{
  *(void *)this = &unk_1F10F21F8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F21F8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F21F8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcTextureWrapClampToEdge::SetParameter(HgcTextureWrapClampToEdge *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcTextureWrapClampToEdge::GetParameter(HgcTextureWrapClampToEdge *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcToneParamCurve2::GetProgram(HgcToneParamCurve2 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000369\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = half3(hg_Params[1].xyz)*r0.xyz + half3(hg_Params[2].xyz);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xyz));\n"
             "    r1.xyz = r1.xyz + half3(hg_Params[3].xyz);\n"
             "    r2.xyz = r0.xyz - half3(hg_Params[4].xyz);\n"
             "    output.color0.xyz = select(float3(r1.xyz), hg_Params[3].xyz, float3(r2.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=11f96f30:b2be53b4:29dcc524:84f02f26\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000329\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
             "    r1.xyz = r1.xyz + hg_Params[3].xyz;\n"
             "    r2.xyz = r0.xyz - hg_Params[4].xyz;\n"
             "    output.color0.xyz = select(r1.xyz, hg_Params[3].xyz, r2.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=882be748:9bb58854:7a0b6941:5bec227a\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f5\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "uniform mediump vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = hg_ProgramLocal1.xyz*r0.xyz + hg_ProgramLocal2.xyz;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xyz);\n"
           "    r1.xyz = r1.xyz + hg_ProgramLocal3.xyz;\n"
           "    r2.xyz = r0.xyz - hg_ProgramLocal4.xyz;\n"
           "    gl_FragColor.xyz = vec3(r2.x < 0.00000 ? hg_ProgramLocal3.x : r1.x, r2.y < 0.00000 ? hg_ProgramLocal3.y :"
           " r1.y, r2.z < 0.00000 ? hg_ProgramLocal3.z : r1.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=6881b252:4d76b384:24ec1fbe:a73e8ed3\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0005:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve2::InitProgramDescriptor(HgcToneParamCurve2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve2_hgc_visible", "//Metal1.0     \n//LEN=0000000205\n[[ visible ]] FragmentOut HgcToneParamCurve2_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
    "    r1.xyz = r1.xyz + hg_Params[3].xyz;\n"
    "    r2.xyz = r0.xyz - hg_Params[4].xyz;\n"
    "    output.color0.xyz = select(r1.xyz, hg_Params[3].xyz, r2.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcToneParamCurve2");
}

void sub_1B791CD34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B791CD64(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B791CD5CLL);
}

double HgcToneParamCurve2::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  long long v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcToneParamCurve2 [hgc1]");
  return *(double *)"ramCurve2 [hgc1]";
}

uint64_t HgcToneParamCurve2::BindTexture(HgcToneParamCurve2 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve2::Bind(HgcToneParamCurve2 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcToneParamCurve2::RenderTile(HgcToneParamCurve2 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    v9.i64[0] = 0x8000000080000000;
    v9.i64[1] = 0x8000000080000000;
    while (v4 < 2)
    {
      int v65 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v10 = 0;
    uint64_t v11 = 16;
    do
    {
      float32x4_t v13 = *(float32x4_t *)(v6 + v11 - 16);
      float32x4_t v12 = *(float32x4_t *)(v6 + v11);
      uint64_t v14 = *((void *)this + 51);
      float32x4_t v15 = *(float32x4_t *)(v14 + 16);
      float32x4_t v16 = *(float32x4_t *)(v14 + 32);
      float32x4_t v17 = *(float32x4_t *)(v14 + 48);
      float32x4_t v18 = vaddq_f32(v16, vmulq_f32(v13, v15));
      float32x4_t v19 = vaddq_f32(v16, vmulq_f32(v12, v15));
      float32x4_t v21 = *(float32x4_t *)(v14 + 64);
      int8x16_t v20 = *(int8x16_t *)(v14 + 80);
      float32x4_t v22 = *(float32x4_t *)(v14 + 96);
      float32x4_t v23 = *(float32x4_t *)(v14 + 112);
      float32x4_t v24 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v18), (int8x16_t)v22);
      int8x16_t v25 = *(int8x16_t *)(v14 + 128);
      float32x4_t v26 = *(float32x4_t *)(v14 + 144);
      float32x4_t v27 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v19), (int8x16_t)v22);
      float32x4_t v28 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v23, v19)));
      float32x4_t v29 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v25, (int8x16_t)vcgtq_f32(v23, v18))), v26);
      float32x4_t v30 = *(float32x4_t *)(v14 + 160);
      float32x4_t v31 = *(float32x4_t *)(v14 + 176);
      float32x4_t v32 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v24, v30));
      float32x4_t v33 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v27, v30));
      float32x4_t v34 = vaddq_f32(v29, v32);
      float32x4_t v35 = vaddq_f32(vsubq_f32(v28, v26), v33);
      float32x4_t v36 = vsubq_f32(vsubq_f32(v24, v22), vmulq_f32(vmulq_f32(v31, v32), v24));
      float32x4_t v37 = vsubq_f32(vsubq_f32(v27, v22), vmulq_f32(vmulq_f32(v31, v33), v27));
      float32x4_t v38 = *(float32x4_t *)(v14 + 192);
      float32x4_t v39 = *(float32x4_t *)(v14 + 208);
      float32x4_t v40 = vaddq_f32(v38, vmulq_f32(v39, v36));
      float32x4_t v41 = vaddq_f32(v38, vmulq_f32(v39, v37));
      float32x4_t v42 = *(float32x4_t *)(v14 + 224);
      float32x4_t v43 = *(float32x4_t *)(v14 + 240);
      float32x4_t v44 = vmulq_f32(*(float32x4_t *)v14, vaddq_f32(v35, vmulq_f32(v37, vaddq_f32(vaddq_f32(v42, vmulq_f32(v37, v43)), vmulq_f32(vmulq_f32(v37, v37), v41)))));
      float32x4_t v45 = *(float32x4_t *)(v14 + 256);
      float32x4_t v46 = *(float32x4_t *)(v14 + 272);
      float32x4_t v47 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v14, vaddq_f32(v34, vmulq_f32(v36, vaddq_f32(vaddq_f32(v42, vmulq_f32(v36, v43)), vmulq_f32(vmulq_f32(v36, v36), v40))))), v45);
      float32x4_t v48 = vmaxq_f32(v44, v45);
      float32x4_t v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      float32x4_t v50 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
      float32x4_t v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v49, v47)));
      float32x4_t v52 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v50, v48)));
      float32x4_t v53 = vsubq_f32(v47, v51);
      float32x4_t v54 = vsubq_f32(v48, v52);
      float32x4_t v55 = *(float32x4_t *)(v14 + 288);
      float32x4_t v56 = *(float32x4_t *)(v14 + 304);
      float32x4_t v57 = vmulq_f32(v54, vaddq_f32(v56, vmulq_f32(v54, vaddq_f32(v46, vmulq_f32(v55, v54)))));
      float32x4_t v58 = vaddq_f32(v22, vmulq_f32(v53, vaddq_f32(v56, vmulq_f32(v53, vaddq_f32(v46, vmulq_f32(v55, v53))))));
      int32x4_t v59 = vcvtq_s32_f32(v52);
      int32x4_t v60 = *(int32x4_t *)(v14 + 320);
      float32x4_t v61 = *(float32x4_t *)(v14 + 336);
      int8x16_t v62 = (int8x16_t)vaddq_f32(v17, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v61, vsubq_f32(v13, v21)), v9, (int8x16_t)vmulq_f32(v58, (float32x4_t)vshlq_n_s32(vaddq_s32(v60, vcvtq_s32_f32(v51)), 0x17uLL))));
      int8x16_t v63 = *(int8x16_t *)(v14 + 352);
      float32x4_t v64 = (int8x16_t *)(v5 + v11);
      v64[-1] = vbslq_s8(v63, (int8x16_t)v13, v62);
      *float32x4_t v64 = vbslq_s8(v63, (int8x16_t)v12, (int8x16_t)vaddq_f32(v17, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v61, vsubq_f32(v12, v21)), v9, (int8x16_t)vmulq_f32(vaddq_f32(v22, v57), (float32x4_t)vshlq_n_s32(vaddq_s32(v60, v59), 0x17uLL)))));
      v10 -= 2;
      v11 += 32;
    }
    while (v4 + v10 > 1);
    int v65 = -v10;
    if (v65 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v66 = 16 * v65;
    float32x4_t v67 = *(float32x4_t *)(v6 + v66);
    uint64_t v68 = *((void *)this + 51);
    float32x4_t v69 = vaddq_f32(*(float32x4_t *)(v68 + 32), vmulq_f32(v67, *(float32x4_t *)(v68 + 16)));
    float32x4_t v70 = *(float32x4_t *)(v68 + 96);
    float32x4_t v71 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v68 + 80), (int8x16_t)v69), (int8x16_t)v70);
    float32x4_t v72 = (float32x4_t)vandq_s8((int8x16_t)v70, (int8x16_t)vcgtq_f32(v71, *(float32x4_t *)(v68 + 160)));
    float32x4_t v73 = vsubq_f32(vsubq_f32(v71, v70), vmulq_f32(vmulq_f32(*(float32x4_t *)(v68 + 176), v72), v71));
    float32x4_t v74 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v68, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v69, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v68 + 128), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v68 + 112), v69))), *(float32x4_t *)(v68 + 144)), v72), vmulq_f32(v73, vaddq_f32(vaddq_f32(*(float32x4_t *)(v68 + 224), vmulq_f32(v73, *(float32x4_t *)(v68 + 240))), vmulq_f32(vmulq_f32(v73, v73), vaddq_f32(*(float32x4_t *)(v68 + 192), vmulq_f32(*(float32x4_t *)(v68 + 208), v73))))))),
            *(float32x4_t *)(v68 + 256));
    float32x4_t v75 = vcvtq_f32_s32(vcvtq_s32_f32(v74));
    float32x4_t v76 = vsubq_f32(v75, (float32x4_t)vandq_s8((int8x16_t)v70, (int8x16_t)vcgtq_f32(v75, v74)));
    float32x4_t v77 = vsubq_f32(v74, v76);
    *(int8x16_t *)(v5 + v66) = vbslq_s8(*(int8x16_t *)(v68 + 352), (int8x16_t)v67, (int8x16_t)vaddq_f32(*(float32x4_t *)(v68 + 48), (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(v68 + 336), vsubq_f32(v67, *(float32x4_t *)(v68 + 64))), v9, (int8x16_t)vmulq_f32(vaddq_f32(v70, vmulq_f32(v77, vaddq_f32(*(float32x4_t *)(v68 + 304), vmulq_f32(v77, vaddq_f32(
                                                                                    *(float32x4_t *)(v68 + 272),
                                                                                    vmulq_f32(*(float32x4_t *)(v68 + 288), v77)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v68 + 320), vcvtq_s32_f32(v76)), 0x17uLL)))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve2::GetDOD(HgcToneParamCurve2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcToneParamCurve2::GetROI(HgcToneParamCurve2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcToneParamCurve2::HgcToneParamCurve2(HgcToneParamCurve2 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F2460;
  operator new();
}

void sub_1B791D52C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve2::~HgcToneParamCurve2(HGNode *this)
{
  *(void *)this = &unk_1F10F2460;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409BD2D9E4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F2460;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409BD2D9E4);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve2::SetParameter(HgcToneParamCurve2 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  int v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve2::GetParameter(HgcToneParamCurve2 *this, unsigned int a2, float *a3)
{
  if (a2 > 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcToneParamCurve1::GetProgram(HgcToneParamCurve1 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000388\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = half3(hg_Params[1].xyz)*r0.xyz + half3(hg_Params[2].xyz);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xyz));\n"
             "    r2.xyz = r0.xyz - half3(hg_Params[3].xyz);\n"
             "    output.color0.xyz = select(float3(r1.xyz), float3(c0.xxx), float3(r2.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=bbf4a9d3:8ac3c576:5d1632bf:935fc9e2\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000349\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
             "    r2.xyz = r0.xyz - hg_Params[3].xyz;\n"
             "    output.color0.xyz = select(r1.xyz, c0.xxx, r2.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6f388f1a:83ba6503:f0c59378:67222bba\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003ce\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = hg_ProgramLocal1.xyz*r0.xyz + hg_ProgramLocal2.xyz;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xyz);\n"
           "    r2.xyz = r0.xyz - hg_ProgramLocal3.xyz;\n"
           "    gl_FragColor.xyz = vec3(r2.x < 0.00000 ? c0.x : r1.x, r2.y < 0.00000 ? c0.x : r1.y, r2.z < 0.00000 ? c0.x"
           " : r1.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=073b1929:ac9c9606:88f5e5f8:42afc5ab\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0004:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve1::InitProgramDescriptor(HgcToneParamCurve1 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve1_hgc_visible", "//Metal1.0     \n//LEN=0000000225\n[[ visible ]] FragmentOut HgcToneParamCurve1_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
    "    r2.xyz = r0.xyz - hg_Params[3].xyz;\n"
    "    output.color0.xyz = select(r1.xyz, c0.xxx, r2.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcToneParamCurve1");
}

void sub_1B791D9CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B791D9FC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B791D9F4);
}

double HgcToneParamCurve1::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcToneParamCurve1 [hgc1]");
  return *(double *)"ramCurve1 [hgc1]";
}

uint64_t HgcToneParamCurve1::BindTexture(HgcToneParamCurve1 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve1::Bind(HgcToneParamCurve1 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcToneParamCurve1::RenderTile(HgcToneParamCurve1 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v64 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v11 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = *((void *)this + 51);
      float32x4_t v14 = *(float32x4_t *)(v13 + 16);
      float32x4_t v15 = *(float32x4_t *)(v13 + 32);
      float32x4_t v16 = *(float32x4_t *)(v13 + 48);
      float32x4_t v17 = vaddq_f32(v15, vmulq_f32(v12, v14));
      float32x4_t v18 = vaddq_f32(v15, vmulq_f32(v11, v14));
      int8x16_t v19 = *(int8x16_t *)(v13 + 64);
      float32x4_t v20 = *(float32x4_t *)(v13 + 80);
      float32x4_t v21 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v17), (int8x16_t)v20);
      float32x4_t v22 = *(float32x4_t *)(v13 + 96);
      int8x16_t v23 = *(int8x16_t *)(v13 + 112);
      float32x4_t v24 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v18), (int8x16_t)v20);
      float32x4_t v25 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v23, (int8x16_t)vcgtq_f32(v22, v17)));
      float32x4_t v26 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v23, (int8x16_t)vcgtq_f32(v22, v18)));
      float32x4_t v27 = *(float32x4_t *)(v13 + 128);
      float32x4_t v28 = *(float32x4_t *)(v13 + 144);
      float32x4_t v29 = vsubq_f32(v25, v27);
      float32x4_t v30 = vsubq_f32(v26, v27);
      float32x4_t v31 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v21, v28));
      float32x4_t v32 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v24, v28));
      float32x4_t v33 = *(float32x4_t *)(v13 + 160);
      float32x4_t v34 = *(float32x4_t *)(v13 + 176);
      float32x4_t v35 = vaddq_f32(v30, v32);
      float32x4_t v36 = vsubq_f32(vsubq_f32(v21, v20), vmulq_f32(vmulq_f32(v33, v31), v21));
      float32x4_t v37 = vsubq_f32(vsubq_f32(v24, v20), vmulq_f32(vmulq_f32(v33, v32), v24));
      float32x4_t v38 = *(float32x4_t *)(v13 + 192);
      float32x4_t v39 = *(float32x4_t *)(v13 + 208);
      float32x4_t v40 = vaddq_f32(v34, vmulq_f32(v38, v36));
      float32x4_t v41 = vaddq_f32(v34, vmulq_f32(v38, v37));
      float32x4_t v42 = *(float32x4_t *)(v13 + 224);
      float32x4_t v43 = *(float32x4_t *)(v13 + 240);
      float32x4_t v44 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v13, vaddq_f32(vaddq_f32(v29, v31), vmulq_f32(v36, vaddq_f32(vaddq_f32(v39, vmulq_f32(v36, v42)), vmulq_f32(vmulq_f32(v36, v36), v40))))), v43);
      float32x4_t v45 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v13, vaddq_f32(v35, vmulq_f32(v37, vaddq_f32(vaddq_f32(v39, vmulq_f32(v37, v42)), vmulq_f32(vmulq_f32(v37, v37), v41))))), v43);
      float32x4_t v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      float32x4_t v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      float32x4_t v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v46, v44)));
      float32x4_t v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v47, v45)));
      float32x4_t v50 = vsubq_f32(v44, v48);
      float32x4_t v51 = vsubq_f32(v45, v49);
      float32x4_t v52 = *(float32x4_t *)(v13 + 256);
      float32x4_t v53 = *(float32x4_t *)(v13 + 272);
      float32x4_t v54 = vaddq_f32(v52, vmulq_f32(v53, v50));
      float32x4_t v55 = vaddq_f32(v52, vmulq_f32(v53, v51));
      float32x4_t v56 = vmulq_f32(v50, v54);
      float32x4_t v57 = *(float32x4_t *)(v13 + 288);
      int32x4_t v58 = *(int32x4_t *)(v13 + 304);
      float32x4_t v59 = vaddq_f32(v20, vmulq_f32(v51, vaddq_f32(v57, vmulq_f32(v51, v55))));
      int8x16_t v60 = (int8x16_t)vmulq_f32(vaddq_f32(v20, vmulq_f32(v50, vaddq_f32(v57, v56))), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v48)), 0x17uLL));
      float32x4_t v61 = *(float32x4_t *)(v13 + 320);
      int8x16_t v62 = *(int8x16_t *)(v13 + 336);
      int8x16_t v63 = (int8x16_t *)(v5 + v10);
      v63[-1] = vbslq_s8(v62, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32(v61, vsubq_f32(v12, v16)), (int8x16_t)v61, v60));
      *int8x16_t v63 = vbslq_s8(v62, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32(v61, vsubq_f32(v11, v16)), (int8x16_t)v61, (int8x16_t)vmulq_f32(v59, (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v49)), 0x17uLL))));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v64 = -v9;
    if (v64 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v65 = 16 * v64;
    float32x4_t v66 = *(float32x4_t *)(v6 + v65);
    uint64_t v67 = *((void *)this + 51);
    float32x4_t v68 = vaddq_f32(*(float32x4_t *)(v67 + 32), vmulq_f32(v66, *(float32x4_t *)(v67 + 16)));
    float32x4_t v69 = *(float32x4_t *)(v67 + 80);
    float32x4_t v70 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v67 + 64), (int8x16_t)v68), (int8x16_t)v69);
    float32x4_t v71 = (float32x4_t)vandq_s8((int8x16_t)v69, (int8x16_t)vcgtq_f32(v70, *(float32x4_t *)(v67 + 144)));
    float32x4_t v72 = vsubq_f32(vsubq_f32(v70, v69), vmulq_f32(vmulq_f32(*(float32x4_t *)(v67 + 160), v71), v70));
    float32x4_t v73 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v67, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v67 + 112), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v67 + 96), v68))), *(float32x4_t *)(v67 + 128)), v71), vmulq_f32(v72, vaddq_f32(vaddq_f32(*(float32x4_t *)(v67 + 208), vmulq_f32(v72, *(float32x4_t *)(v67 + 224))), vmulq_f32(vmulq_f32(v72, v72), vaddq_f32(*(float32x4_t *)(v67 + 176), vmulq_f32(*(float32x4_t *)(v67 + 192), v72))))))),
            *(float32x4_t *)(v67 + 240));
    float32x4_t v74 = vcvtq_f32_s32(vcvtq_s32_f32(v73));
    float32x4_t v75 = vsubq_f32(v74, (float32x4_t)vandq_s8((int8x16_t)v69, (int8x16_t)vcgtq_f32(v74, v73)));
    float32x4_t v76 = vsubq_f32(v73, v75);
    *(int8x16_t *)(v5 + v65) = vbslq_s8(*(int8x16_t *)(v67 + 336), (int8x16_t)v66, vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(v67 + 320), vsubq_f32(v66, *(float32x4_t *)(v67 + 48))), *(int8x16_t *)(v67 + 320), (int8x16_t)vmulq_f32(vaddq_f32(v69, vmulq_f32(v76, vaddq_f32(*(float32x4_t *)(v67 + 288), vmulq_f32(v76, vaddq_f32(*(float32x4_t *)(v67 + 256), vmulq_f32(*(float32x4_t *)(v67 + 272), v76)))))),
                                                (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v67 + 304), vcvtq_s32_f32(v75)), 0x17uLL))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve1::GetDOD(HgcToneParamCurve1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcToneParamCurve1::GetROI(HgcToneParamCurve1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcToneParamCurve1::HgcToneParamCurve1(HgcToneParamCurve1 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F26C8;
  operator new();
}

void sub_1B791E170(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve1::~HgcToneParamCurve1(HGNode *this)
{
  *(void *)this = &unk_1F10F26C8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AF73A19ALL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F26C8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AF73A19ALL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve1::SetParameter(HgcToneParamCurve1 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve1::GetParameter(HgcToneParamCurve1 *this, unsigned int a2, float *a3)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcPixelFormatConversion_kV4B10Bit_BE_output::GetProgram(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003db\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(255.7500000, 63.93750000, 15.98437500, 0.000000000);\n"
             "    const half4 c1 = half4(4.000000000, 16.00000000, 64.00000000, 0.000000000);\n"
             "    const half4 c2 = half4(1.000000000, 0.003921568859, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = clamp((half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy), 0.00000h, 1.00000h);\n"
             "    r0 = r0*c0;\n"
             "    r1 = fract(r0);\n"
             "    r1 = r1*c1;\n"
             "    r1 = floor(r1.wxyz);\n"
             "    r1 = r1*c1.wzyx;\n"
             "    r0 = floor(r0);\n"
             "    r0 = r0*c2.xxxw + r1;\n"
             "    output.color0 = float4(r0)*float4(c2.yyyy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=bb27e3be:38664bb7:ce3c51bf:a917b29d\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003cb\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(255.7500000, 63.93750000, 15.98437500, 0.000000000);\n"
             "    const float4 c1 = float4(4.000000000, 16.00000000, 64.00000000, 0.000000000);\n"
             "    const float4 c2 = float4(1.000000000, 0.003921568859, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = clamp(hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy), 0.00000f, 1.00000f);\n"
             "    r0 = r0*c0;\n"
             "    r1 = fract(r0);\n"
             "    r1 = r1*c1;\n"
             "    r1 = floor(r1.wxyz);\n"
             "    r1 = r1*c1.wzyx;\n"
             "    r0 = floor(r0);\n"
             "    r0 = r0*c2.xxxw + r1;\n"
             "    output.color0 = r0*c2.yyyy;\n"
             "    return output;\n"
             "}\n"
             "//MD5=61aa77c2:f5fae104:c9ee071c:f4d1cc49\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000382\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(255.7500000, 63.93750000, 15.98437500, 0.000000000);\n"
           "    const mediump vec4 c1 = vec4(4.000000000, 16.00000000, 64.00000000, 0.000000000);\n"
           "    const mediump vec4 c2 = vec4(1.000000000, 0.003921568859, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = clamp(texture2D(hg_Texture0, hg_TexCoord0.xy), vec4(0.00000), vec4(1.00000));\n"
           "    r0 = r0*c0;\n"
           "    r1 = fract(r0);\n"
           "    r1 = r1*c1;\n"
           "    r1 = floor(r1.wxyz);\n"
           "    r1 = r1*c1.wzyx;\n"
           "    r0 = floor(r0);\n"
           "    r0 = r0*c2.xxxw + r1;\n"
           "    gl_FragColor = r0*c2.yyyy;\n"
           "}\n"
           "//MD5=ca498554:4fd18e60:1c6325ca:76efb0c5\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4B10Bit_BE_output::InitProgramDescriptor(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4B10Bit_BE_output_hgc_visible", "//Metal1.0     \n//LEN=00000002c1\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4B10Bit_BE_output_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(255.7500000, 63.93750000, 15.98437500, 0.000000000);\n"
    "    const float4 c1 = float4(4.000000000, 16.00000000, 64.00000000, 0.000000000);\n"
    "    const float4 c2 = float4(1.000000000, 0.003921568859, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = clamp(color0, 0.00000f, 1.00000f);\n"
    "    r0 = r0*c0;\n"
    "    r1 = fract(r0);\n"
    "    r1 = r1*c1;\n"
    "    r1 = floor(r1.wxyz);\n"
    "    r1 = r1*c1.wzyx;\n"
    "    r0 = floor(r0);\n"
    "    r0 = r0*c2.xxxw + r1;\n"
    "    output.color0 = r0*c2.yyyy;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcPixelFormatConversion_kV4B10Bit_BE_output");
}

void sub_1B791E610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B791E640(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B791E638);
}

double HgcPixelFormatConversion_kV4B10Bit_BE_output::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x38uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B7EC1840;
  strcpy(v3, "HgcPixelFormatConversion_kV4B10Bit_BE_output [hgc1]");
  return *(double *)"it_BE_output [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::BindTexture(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::Bind(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::RenderTile(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v65 = 0;
        uint64_t v66 = 16 * v7;
        uint64_t v67 = 16 * v6;
        uint64_t v68 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v69 = 0;
          do
          {
            float32x4_t v70 = (float32x4_t *)*((void *)this + 51);
            float32x4_t v71 = v70[1];
            float32x4_t v72 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v69 / 0x10], *v70), v71), v70[2]);
            float32x4_t v73 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
            float32x4_t v74 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v71, (int8x16_t)vcgtq_f32(v73, v72)));
            int8x16_t v75 = (int8x16_t)vmulq_f32(v70[3], vsubq_f32(v72, v74));
            float32x4_t v76 = (float32x4_t)vextq_s8(v75, v75, 0xCuLL);
            float32x4_t v77 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
            v5[v69 / 0x10] = vmulq_f32(v70[6], vaddq_f32(vmulq_f32(v74, v70[5]), vmulq_f32(v70[4], vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v71, (int8x16_t)vcgtq_f32(v77, v76))))));
            v69 += 16;
          }
          while (v68 != v69);
          ++v65;
          int v4 = (float32x4_t *)((char *)v4 + v66);
          int v5 = (float32x4_t *)((char *)v5 + v67);
        }
        while (v65 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float32x4_t v11 = v4 + 4;
      float32x4_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        float32x4_t v14 = v12;
        float32x4_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = v15;
          float32x4_t v18 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v19 = v18[1];
          float32x4_t v20 = v14;
          float32x4_t v21 = v18[2];
          float32x4_t v22 = v18[3];
          float32x4_t v23 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16 - 2], *v18), v19), v21);
          float32x4_t v24 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16 - 1], *v18), v19), v21);
          float32x4_t v25 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16], *v18), v19), v21);
          float32x4_t v26 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16 + 1], *v18), v19), v21);
          float32x4_t v27 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
          float32x4_t v28 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
          float32x4_t v29 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
          float32x4_t v30 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
          float32x4_t v31 = vsubq_f32(v27, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v27, v23)));
          float32x4_t v32 = vsubq_f32(v28, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v28, v24)));
          float32x4_t v33 = vsubq_f32(v29, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v29, v25)));
          float32x4_t v34 = vsubq_f32(v30, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v30, v26)));
          int8x16_t v35 = (int8x16_t)vmulq_f32(v22, vsubq_f32(v23, v31));
          int8x16_t v36 = (int8x16_t)vmulq_f32(v22, vsubq_f32(v24, v32));
          int8x16_t v37 = (int8x16_t)vmulq_f32(v22, vsubq_f32(v25, v33));
          int8x16_t v38 = (int8x16_t)vmulq_f32(v22, vsubq_f32(v26, v34));
          float32x4_t v39 = (float32x4_t)vextq_s8(v35, v35, 0xCuLL);
          float32x4_t v40 = (float32x4_t)vextq_s8(v36, v36, 0xCuLL);
          float32x4_t v41 = (float32x4_t)vextq_s8(v37, v37, 0xCuLL);
          float32x4_t v42 = (float32x4_t)vextq_s8(v38, v38, 0xCuLL);
          float32x4_t v43 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
          float32x4_t v44 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
          float32x4_t v45 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
          float32x4_t v46 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
          float32x4_t v47 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v43, v39)));
          float32x4_t v48 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v44, v40)));
          float32x4_t v49 = vsubq_f32(v45, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v45, v41)));
          float32x4_t v50 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v46, v42)));
          float32x4_t v51 = v18[4];
          float32x4_t v52 = v18[5];
          float32x4_t v53 = vaddq_f32(vmulq_f32(v31, v52), vmulq_f32(v51, v47));
          float32x4_t v54 = v18[6];
          float32x4_t v55 = &v5[v16];
          v13 += 4;
          v55[-2] = vmulq_f32(v54, v53);
          v55[-1] = vmulq_f32(v54, vaddq_f32(vmulq_f32(v32, v52), vmulq_f32(v51, v48)));
          *float32x4_t v55 = vmulq_f32(v54, vaddq_f32(vmulq_f32(v33, v52), vmulq_f32(v51, v49)));
          v55[1] = vmulq_f32(v54, vaddq_f32(vmulq_f32(v34, v52), vmulq_f32(v51, v50)));
          v16 += 4;
          float32x4_t v15 = v17 + 4;
          v14 += 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            float32x4_t v56 = *v17++;
            float32x4_t v57 = (float32x4_t *)*((void *)this + 51);
            float32x4_t v58 = v57[1];
            float32x4_t v59 = vmulq_f32(vminq_f32(vmaxq_f32(v56, *v57), v58), v57[2]);
            float32x4_t v60 = vcvtq_f32_s32(vcvtq_s32_f32(v59));
            float32x4_t v61 = vsubq_f32(v60, (float32x4_t)vandq_s8((int8x16_t)v58, (int8x16_t)vcgtq_f32(v60, v59)));
            int8x16_t v62 = (int8x16_t)vmulq_f32(v57[3], vsubq_f32(v59, v61));
            float32x4_t v63 = (float32x4_t)vextq_s8(v62, v62, 0xCuLL);
            float32x4_t v64 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
            *v20++ = vmulq_f32(v57[6], vaddq_f32(vmulq_f32(v61, v57[5]), vmulq_f32(v57[4], vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v58, (int8x16_t)vcgtq_f32(v64, v63))))));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (float32x4_t *)((char *)v5 + v9);
        int v4 = (float32x4_t *)((char *)v4 + v10);
        float32x4_t v11 = (float32x4_t *)((char *)v11 + v10);
        float32x4_t v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::GetDOD(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::GetROI(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcPixelFormatConversion_kV4B10Bit_BE_output::HgcPixelFormatConversion_kV4B10Bit_BE_output(HgcPixelFormatConversion_kV4B10Bit_BE_output *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F2930;
  operator new();
}

void sub_1B791EC34(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4B10Bit_BE_output::~HgcPixelFormatConversion_kV4B10Bit_BE_output(HGNode *this)
{
  *(void *)this = &unk_1F10F2930;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F2930;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F2930;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::SetParameter(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_output::GetParameter(HgcPixelFormatConversion_kV4B10Bit_BE_output *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcPixelFormatConversion_kV4B_WXYZ_input::GetProgram(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000023d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.yxwz) - hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=1dbd242c:497308d0:b7cfb140:ddbffa01\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000022f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.yxwz - hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=2f76817a:3863da94:44205a76:e1835bc2\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001fd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.yxwz - hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=0342e6cd:919b4f83:c06c49fe:3495a499\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4B_WXYZ_input::InitProgramDescriptor(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4B_WXYZ_input_hgc_visible", "//Metal1.0     \n//LEN=0000000121\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4B_WXYZ_input_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0.yxwz - hg_Params[0];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcPixelFormatConversion_kV4B_WXYZ_input");
}

void sub_1B791F078(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B791F0A8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B791F0A0);
}

double HgcPixelFormatConversion_kV4B_WXYZ_input::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x30uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376F10;
  strcpy(v3, "HgcPixelFormatConversion_kV4B_WXYZ_input [hgc1]");
  return *(double *)"XYZ_input [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_input::BindTexture(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_input::Bind(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_input::RenderTile(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (int32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v25 = 0;
        uint64_t v26 = 16 * v7;
        uint64_t v27 = 16 * v6;
        uint64_t v28 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v29 = 0;
          do
          {
            v5[v29 / 0x10] = vsubq_f32((float32x4_t)vrev64q_s32(v4[v29 / 0x10]), *(float32x4_t *)*((void *)this + 51));
            v29 += 16;
          }
          while (v28 != v29);
          ++v25;
          int v4 = (int32x4_t *)((char *)v4 + v26);
          int v5 = (float32x4_t *)((char *)v5 + v27);
        }
        while (v25 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float32x4_t v11 = v4 + 4;
      float32x4_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        float32x4_t v14 = v12;
        float32x4_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = v15;
          float32x4_t v18 = v14;
          float32x4_t v19 = *(float32x4_t *)*((void *)this + 51);
          float32x4_t v20 = vsubq_f32((float32x4_t)vrev64q_s32(v4[v16 - 1]), v19);
          float32x4_t v21 = vsubq_f32((float32x4_t)vrev64q_s32(v4[v16]), v19);
          float32x4_t v22 = vsubq_f32((float32x4_t)vrev64q_s32(v4[v16 + 1]), v19);
          float32x4_t v23 = &v5[v16];
          v23[-2] = vsubq_f32((float32x4_t)vrev64q_s32(v4[v16 - 2]), v19);
          v23[-1] = v20;
          v13 += 4;
          *float32x4_t v23 = v21;
          v23[1] = v22;
          v16 += 4;
          v15 += 4;
          float32x4_t v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            int32x4_t v24 = *v17++;
            *v18++ = vsubq_f32((float32x4_t)vrev64q_s32(v24), *(float32x4_t *)*((void *)this + 51));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (float32x4_t *)((char *)v5 + v9);
        int v4 = (int32x4_t *)((char *)v4 + v10);
        float32x4_t v11 = (int32x4_t *)((char *)v11 + v10);
        float32x4_t v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_input::GetDOD(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_input::GetROI(HgcPixelFormatConversion_kV4B_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcPixelFormatConversion_kV4B_WXYZ_input::HgcPixelFormatConversion_kV4B_WXYZ_input(HgcPixelFormatConversion_kV4B_WXYZ_input *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F2B98;
  operator new();
}

void sub_1B791F4CC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4B_WXYZ_input::~HgcPixelFormatConversion_kV4B_WXYZ_input(HGNode *this)
{
  *(void *)this = &unk_1F10F2B98;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F2B98;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F2B98;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_input::SetParameter(HgcPixelFormatConversion_kV4B_WXYZ_input *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  int v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *int v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcPixelFormatConversion_kV4B_WXYZ_input::GetParameter(HgcPixelFormatConversion_kV4B_WXYZ_input *this, int a2, float *a3)
{
  if (!a2)
  {
    unint64_t v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcPixelFormatConversion_kV4B_WXYZ_output::GetProgram(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000022e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.yxwz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1444beee:fe229edf:8efe5f39:cebbac56\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000220\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.yxwz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=55de5a34:399890da:0381eeee:8693b352\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.yxwz;\n"
           "}\n"
           "//MD5=db620396:7a9f1d56:e8273dfb:0aa51d5a\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4B_WXYZ_output::InitProgramDescriptor(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4B_WXYZ_output_hgc_visible", "//Metal1.0     \n//LEN=0000000113\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4B_WXYZ_output_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0.yxwz;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcPixelFormatConversion_kV4B_WXYZ_output");
}

void sub_1B791F9B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B791F9E4(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B791F9DCLL);
}

double HgcPixelFormatConversion_kV4B_WXYZ_output::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x38uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376F50;
  strcpy(v3, "HgcPixelFormatConversion_kV4B_WXYZ_output [hgc1]");
  return *(double *)"YZ_output [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::BindTexture(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::Bind(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::RenderTile(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (int32x4_t *)*((void *)a2 + 10);
    int v5 = (int32x4_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v24 = 0;
        uint64_t v25 = 16 * v7;
        uint64_t v26 = 16 * v6;
        uint64_t v27 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v28 = 0;
          do
          {
            v5[v28 / 0x10] = vrev64q_s32(v4[v28 / 0x10]);
            v28 += 16;
          }
          while (v27 != v28);
          ++v24;
          int v4 = (int32x4_t *)((char *)v4 + v25);
          int v5 = (int32x4_t *)((char *)v5 + v26);
        }
        while (v24 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float32x4_t v11 = v4 + 4;
      float32x4_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        float32x4_t v14 = v12;
        float32x4_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = v15;
          float32x4_t v18 = v14;
          int32x4_t v19 = vrev64q_s32(v4[v16 - 1]);
          int32x4_t v20 = vrev64q_s32(v4[v16]);
          int32x4_t v21 = vrev64q_s32(v4[v16 + 1]);
          float32x4_t v22 = &v5[v16];
          v22[-2] = vrev64q_s32(v4[v16 - 2]);
          v22[-1] = v19;
          v13 += 4;
          *float32x4_t v22 = v20;
          v22[1] = v21;
          v16 += 4;
          v15 += 4;
          float32x4_t v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            int32x4_t v23 = *v17++;
            *v18++ = vrev64q_s32(v23);
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (int32x4_t *)((char *)v5 + v9);
        int v4 = (int32x4_t *)((char *)v4 + v10);
        float32x4_t v11 = (int32x4_t *)((char *)v11 + v10);
        float32x4_t v12 = (int32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::GetDOD(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::GetROI(HgcPixelFormatConversion_kV4B_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcPixelFormatConversion_kV4B_WXYZ_output::HgcPixelFormatConversion_kV4B_WXYZ_output(HgcPixelFormatConversion_kV4B_WXYZ_output *this)
{
}

void sub_1B791FDC0(_Unwind_Exception *a1)
{
  HGColorMatrix::~HGColorMatrix(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4B_WXYZ_output::~HgcPixelFormatConversion_kV4B_WXYZ_output(HgcPixelFormatConversion_kV4B_WXYZ_output *this)
{
  *(void *)this = &unk_1F10F2E00;
  uint64_t v2 = *((void *)this + 62);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F2E00;
  uint64_t v2 = *((void *)this + 62);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F2E00;
  uint64_t v2 = *((void *)this + 62);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }
  HGColorMatrix::~HGColorMatrix(this);

  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::SetParameter(HgcPixelFormatConversion_kV4B_WXYZ_output *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4B_WXYZ_output::GetParameter(HgcPixelFormatConversion_kV4B_WXYZ_output *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

HGNode *HgcPixelFormatConversion_kV4B_WXYZ_output::GetOutput(__n128 *this, HGRenderer *a2, __n128 a3, __n128 a4, __n128 a5)
{
  if (this[31].n128_u32[2])
  {
    int v5 = (int32x4_t *)this[31].n128_u64[0];
    a4 = (__n128)vrev64q_s32(v5[5]);
    a5 = (__n128)vrev64q_s32(v5[6]);
    int32x4_t v6 = vrev64q_s32(v5[7]);
    int32x4_t *v5 = vrev64q_s32(v5[4]);
    *(__n128 *)(this[31].n128_u64[0] + 16) = a4;
    *(__n128 *)(this[31].n128_u64[0] + 32) = a5;
    *(int32x4_t *)(this[31].n128_u64[0] + 48) = v6;
    uint64_t v7 = (__n128 *)this[31].n128_u64[0];
    this[27] = *v7;
    this[28] = v7[1];
    this[29] = v7[2];
    a3 = v7[3];
    this[30] = a3;
    this[31].n128_u32[2] = 0;
  }
  return HGColorMatrix::GetOutput((HGColorMatrix *)this, a2, a3.n128_f64[0], a4.n128_f64[0], (int32x2_t)a5.n128_u64[0]);
}

const char *HgcColorGamma_v216_yxzx_expand::GetProgram(HgcColorGamma_v216_yxzx_expand *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000303\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s0.x = float(fract(0.500000f*frag._texCoord1.x) >= 0.500000f);\n"
             "    r1 = half4(r0.y, r0.x, r0.z, 1.00000h);\n"
             "    s1.yzw = float3(r1.yzw);\n"
             "    s1.x = select(float(r1.x), float(r0.w), -s0.x < 0.00000h);\n"
             "    output.color0 = s1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e21a45a6:09902464:305afcf0:4fad99f2\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0004:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002c4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = float(fract(0.500000f*frag._texCoord1.x) >= 0.500000f);\n"
             "    r2 = float4(r0.y, r0.x, r0.z, 1.00000f);\n"
             "    r2.x = select(r2.x, r0.w, -r1.x < 0.00000f);\n"
             "    output.color0 = r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=255181fe:8739b9fa:717e3924:0c6abb8c\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0003:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002e4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.x*hg_TexCoord1.x;\n"
           "    r1.x = fract(r1.x);\n"
           "    r1.x = float(r1.x >= c0.x);\n"
           "    r2 = vec4(r0.y, r0.x, r0.z, 1.00000);\n"
           "    r2.x = -r1.x < 0.00000 ? r0.w : r2.x;\n"
           "    gl_FragColor = r2;\n"
           "}\n"
           "//MD5=d30aa489:0cf70260:00ac23f3:bdc5057d\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0000:0003:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcColorGamma_v216_yxzx_expand::InitProgramDescriptor(HgcColorGamma_v216_yxzx_expand *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_v216_yxzx_expand_hgc_visible", "//Metal1.0     \n//LEN=0000000225\n[[ visible ]] FragmentOut HgcColorGamma_v216_yxzx_expand_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, texCoord0.xy);\n"
    "    r1.x = float(fract(0.500000f*texCoord1.x) >= 0.500000f);\n"
    "    r2 = float4(r0.y, r0.x, r0.z, 1.00000f);\n"
    "    r2.x = select(r2.x, r0.w, -r1.x < 0.00000f);\n"
    "    output.color0 = r2;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorGamma_v216_yxzx_expand");
}

void sub_1B7920434(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7920470(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7920468);
}

char *HgcColorGamma_v216_yxzx_expand::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D30;
  strcpy(result, "HgcColorGamma_v216_yxzx_expand [hgc1]");
  return result;
}

uint64_t HgcColorGamma_v216_yxzx_expand::BindTexture(HgcColorGamma_v216_yxzx_expand *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 0.5, 1.0, 1.0);
  return 0;
}

uint64_t HgcColorGamma_v216_yxzx_expand::Bind(HgcColorGamma_v216_yxzx_expand *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorGamma_v216_yxzx_expand::RenderTile(HgcColorGamma_v216_yxzx_expand *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    float32x4_t v7 = vmulq_f32(v5, (float32x4_t)xmmword_1B8375E70);
    *(float32x2_t *)v8.f32 = vcvt_f32_s32((int32x2_t)vand_s8((int8x8_t)v2, (int8x8_t)0x100000001));
    v8.i64[1] = 0x3F80000000000000;
    *(float *)v9.i32 = (float)(v6 & 1);
    v9.i32[1] = 1.0;
    v9.i64[1] = 0;
    uint64_t v10 = (int8x16_t *)a2[2];
    float32x4_t v11 = v10 + 2;
    uint64_t v12 = 16 * a2[3].i32[0];
    __asm { FMOV            V16.4S, #4.0 }
    v18.i64[0] = 0x3F0000003F000000;
    v18.i64[1] = 0x3F0000003F000000;
    while (v6 < 4)
    {
      LODWORD(v53) = 0;
      float32x4_t v21 = 0uLL;
      if (v6 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v7 = vaddq_f32(v7, (float32x4_t)xmmword_1B7E736C0);
      float32x4_t v8 = (float32x4_t)veorq_s8((int8x16_t)v8, v9);
      ++v4;
      float32x4_t v11 = (int8x16_t *)((char *)v11 + v12);
      uint64_t v10 = (int8x16_t *)((char *)v10 + v12);
      if (v4 == v3) {
        return 0;
      }
    }
    int v19 = 0;
    float32x4_t v20 = (float32x4_t)veorq_s8((int8x16_t)v8, (int8x16_t)xmmword_1B7E736B0);
    float32x4_t v21 = 0uLL;
    float32x4_t v22 = v11;
    do
    {
      float32x4_t v23 = vaddq_f32(v7, vmulq_f32(v21, (float32x4_t)xmmword_1B7E75B20));
      float32x4_t v24 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v25 = vaddq_f32(v24, (float32x4_t)xmmword_1B7E75B20);
      float32x4_t v26 = vaddq_f32(v25, (float32x4_t)xmmword_1B7E75B20);
      int32x2_t v27 = a2[10];
      __int32 v28 = a2[11].i32[0];
      float32x4_t v29 = vaddq_f32(vsubq_f32(v23, v5), v18);
      int32x4_t v30 = vcvtq_s32_f32(v29);
      v29.i64[0] = vaddq_s32(v30, vcgtq_f32(vcvtq_f32_s32(v30), v29)).u64[0];
      float32x4_t v31 = vaddq_f32(vsubq_f32(v24, v5), v18);
      int32x4_t v32 = vcvtq_s32_f32(v31);
      int8x16_t v33 = *(int8x16_t *)(*(void *)&v27 + 16 * (v29.i32[0] + v29.i32[1] * v28));
      v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
      float32x4_t v34 = vaddq_f32(vsubq_f32(v25, v5), v18);
      int32x4_t v35 = vcvtq_s32_f32(v34);
      int8x16_t v36 = *(int8x16_t *)(*(void *)&v27 + 16 * (v31.i32[0] + v31.i32[1] * v28));
      v34.i64[0] = vaddq_s32(v35, vcgtq_f32(vcvtq_f32_s32(v35), v34)).u64[0];
      __int32 v37 = v34.i32[0] + v34.i32[1] * v28;
      float32x4_t v38 = vaddq_f32(vsubq_f32(v26, v5), v18);
      int32x4_t v39 = vcvtq_s32_f32(v38);
      int8x16_t v40 = *(int8x16_t *)(*(void *)&v27 + 16 * v37);
      v38.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v38)).u64[0];
      int8x16_t v41 = *(int8x16_t *)(*(void *)&v27 + 16 * (v38.i32[0] + v38.i32[1] * v28));
      uint64_t v42 = *((void *)this + 51);
      float32x4_t v43 = *(float32x4_t *)(v42 + 16);
      *(int8x8_t *)v44.i8 = vqtbl1_s8(v33, *(int8x8_t *)v42);
      int8x8_t v45 = (int8x8_t)vextq_s8(*(int8x16_t *)v42, *(int8x16_t *)v42, 8uLL).u64[0];
      v44.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v33, v45).u32[0]);
      *(int8x8_t *)v46.i8 = vqtbl1_s8(v36, *(int8x8_t *)v42);
      v46.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v36, v45).u32[0]);
      *(int8x8_t *)v47.i8 = vqtbl1_s8(v40, *(int8x8_t *)v42);
      v47.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v40, v45).u32[0]);
      *(int8x8_t *)v39.i8 = vqtbl1_s8(v41, *(int8x8_t *)v42);
      v39.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v41, v45).u32[0]);
      int8x16_t v48 = (int8x16_t)vcgtq_f32(v8, v43);
      int8x16_t v49 = (int8x16_t)vcgtq_f32(v20, v43);
      int8x16_t v50 = vbslq_s8(v49, vextq_s8(v36, v36, 0xCuLL), v46);
      int8x16_t v51 = vbslq_s8(v49, vextq_s8(v41, v41, 0xCuLL), (int8x16_t)v39);
      int8x16_t v52 = *(int8x16_t *)(v42 + 32);
      float32x4_t v21 = vaddq_f32(v21, _Q16);
      v22[-2] = vbslq_s8(v52, vbslq_s8(v48, vextq_s8(v33, v33, 0xCuLL), v44), v44);
      v22[-1] = vbslq_s8(v52, v50, v46);
      *float32x4_t v22 = vbslq_s8(v52, vbslq_s8(v48, vextq_s8(v40, v40, 0xCuLL), v47), v47);
      v22[1] = vbslq_s8(v52, v51, (int8x16_t)v39);
      v22 += 4;
      v19 -= 4;
    }
    while (v6 + v19 > 3);
    LODWORD(v53) = -v19;
    if ((int)v53 >= v6) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v53 = v53;
    do
    {
      float32x4_t v54 = vaddq_f32(vsubq_f32(vaddq_f32(v7, vmulq_f32(v21, (float32x4_t)xmmword_1B7E75B20)), v5), v18);
      int32x4_t v55 = vcvtq_s32_f32(v54);
      v54.i64[0] = vaddq_s32(v55, vcgtq_f32(vcvtq_f32_s32(v55), v54)).u64[0];
      int8x16_t v56 = *(int8x16_t *)(*(void *)&a2[10] + 16 * (v54.i32[0] + v54.i32[1] * a2[11].i32[0]));
      uint64_t v57 = *((void *)this + 51);
      *(int8x8_t *)v55.i8 = vqtbl1_s8(v56, *(int8x8_t *)v57);
      v55.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v56, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v57, *(int8x16_t *)v57, 8uLL)).u32[0]);
      v10[v53] = vbslq_s8(*(int8x16_t *)(v57 + 32), vbslq_s8((int8x16_t)vcgtq_f32(v8, *(float32x4_t *)(v57 + 16)), vextq_s8(v56, v56, 0xCuLL), (int8x16_t)v55), (int8x16_t)v55);
      float32x4_t v8 = (float32x4_t)veorq_s8((int8x16_t)v8, (int8x16_t)xmmword_1B7E736B0);
      __asm { FMOV            V19.4S, #1.0 }
      float32x4_t v21 = vaddq_f32(v21, _Q19);
      ++v53;
    }
    while (v53 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_v216_yxzx_expand::GetDOD(HgcColorGamma_v216_yxzx_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0, 0, 1u, 0);
  int v8 = HGRectGrow(v6, v5, v7);
  float v9 = HGRectFloat(v8);
  float v13 = HGRectScale(v9, v10, v11, v12, 2.0);
  uint64_t v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcColorGamma_v216_yxzx_expand::GetROI(HgcColorGamma_v216_yxzx_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 0.5);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  uint64_t v16 = v15;
  uint64_t v17 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
  uint64_t v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcColorGamma_v216_yxzx_expand::HgcColorGamma_v216_yxzx_expand(HgcColorGamma_v216_yxzx_expand *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F3078;
  operator new();
}

void sub_1B7920B84(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_v216_yxzx_expand::~HgcColorGamma_v216_yxzx_expand(HGNode *this)
{
  *(void *)this = &unk_1F10F3078;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40EED21634);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F3078;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40EED21634);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F3078;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40EED21634);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_v216_yxzx_expand::SetParameter(HgcColorGamma_v216_yxzx_expand *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_v216_yxzx_expand::GetParameter(HgcColorGamma_v216_yxzx_expand *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcBlur_g4u2::GetProgram(HgcBlur_g4u2 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000918\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    float4 s0, s1, s2, s3, s4, s5, s6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord1.xy*hg_Params[4].xy;\n"
             "    s0.xy = s0.xy + frag._texCoord0.xy;\n"
             "    s0.zw = s0.xy + hg_Params[5].xy;\n"
             "    s1.zw = s0.zw + hg_Params[6].xy;\n"
             "    s1.xy = s0.xy + -hg_Params[6].xy;\n"
             "    s2.zw = floor(s0.xy);\n"
             "    s2.xy = floor(s0.zw);\n"
             "    s2.xy = s2.xy + -s2.zw;\n"
             "    s1.zw = s1.zw + hg_Params[7].xy;\n"
             "    s1.zw = s1.zw*hg_Params[7].zw;\n"
             "    s1.xy = s1.xy + hg_Params[7].xy;\n"
             "    s0.zw = s0.zw + hg_Params[7].xy;\n"
             "    s0.xy = s0.xy + hg_Params[7].xy;\n"
             "    s3.x = s2.x + s2.y;\n"
             "    s5.xy = s1.zw*hg_Params[8].xy;\n"
             "    s5.xy = fmax(s5.xy, float2(c0.xy));\n"
             "    s6.xy = hg_Params[8].xy - float2(c0.xy);\n"
             "    s5.xy = fmin(s5.xy, s6.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s5.xy);\n"
             "    s1.xy = s1.xy*hg_Params[7].zw;\n"
             "    s6.xy = s1.xy*hg_Params[8].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s5.xy = hg_Params[8].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s5.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    r0 = r1 + r0;\n"
             "    r1 = half4(hg_Params[1]);\n"
             "    r1 = -r1 + half4(hg_Params[3]);\n"
             "    s2 = s3.xxxx*float4(r1) + hg_Params[1];\n"
             "    r1 = half4(hg_Params[0]);\n"
             "    s2 = float4(r0)*s2;\n"
             "    r0 = -r1 + half4(hg_Params[2]);\n"
             "    s0.zw = s0.zw*hg_Params[7].zw;\n"
             "    s5.xy = s0.zw*hg_Params[8].xy;\n"
             "    s5.xy = fmax(s5.xy, float2(c0.xy));\n"
             "    s6.xy = hg_Params[8].xy - float2(c0.xy);\n"
             "    s5.xy = fmin(s5.xy, s6.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, s5.xy);\n"
             "    s0.xy = s0.xy*hg_Params[7].zw;\n"
             "    s6.xy = s0.xy*hg_Params[8].xy;\n"
             "    s6.xy = fmax(s6.xy, float2(c0.xy));\n"
             "    s5.xy = hg_Params[8].xy - float2(c0.xy);\n"
             "    s6.xy = fmin(s6.xy, s5.xy);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, s6.xy);\n"
             "    r2 = r2 + r1;\n"
             "    s4 = s3.xxxx*float4(r0) + hg_Params[0];\n"
             "    output.color0 = float4(r2)*s4 + s2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=82cbc070:1e8f1392:17c94f80:ede0e467\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0009:000a:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000869\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord1.xy*hg_Params[4].xy;\n"
             "    r0.xy = r0.xy + frag._texCoord0.xy;\n"
             "    r0.zw = r0.xy + hg_Params[5].xy;\n"
             "    r1.zw = r0.zw + hg_Params[6].xy;\n"
             "    r1.xy = r0.xy + -hg_Params[6].xy;\n"
             "    r3.zw = floor(r0.xy);\n"
             "    r3.xy = floor(r0.zw);\n"
             "    r3.xy = r3.xy + -r3.zw;\n"
             "    r1.zw = r1.zw + hg_Params[7].xy;\n"
             "    r1.zw = r1.zw*hg_Params[7].zw;\n"
             "    r1.xy = r1.xy + hg_Params[7].xy;\n"
             "    r0.zw = r0.zw + hg_Params[7].xy;\n"
             "    r0.xy = r0.xy + hg_Params[7].xy;\n"
             "    r4.x = r3.x + r3.y;\n"
             "    r5.xy = r1.zw*hg_Params[8].xy;\n"
             "    r5.xy = fmax(r5.xy, c0.xy);\n"
             "    r6.xy = hg_Params[8].xy - c0.xy;\n"
             "    r5.xy = fmin(r5.xy, r6.xy);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
             "    r1.xy = r1.xy*hg_Params[7].zw;\n"
             "    r6.xy = r1.xy*hg_Params[8].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r5.xy = hg_Params[8].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r5.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r2 = r1 + r2;\n"
             "    r1 = hg_Params[1];\n"
             "    r1 = -r1 + hg_Params[3];\n"
             "    r3 = r4.xxxx*r1 + hg_Params[1];\n"
             "    r1 = hg_Params[0];\n"
             "    r3 = r2*r3;\n"
             "    r2 = -r1 + hg_Params[2];\n"
             "    r0.zw = r0.zw*hg_Params[7].zw;\n"
             "    r5.xy = r0.zw*hg_Params[8].xy;\n"
             "    r5.xy = fmax(r5.xy, c0.xy);\n"
             "    r6.xy = hg_Params[8].xy - c0.xy;\n"
             "    r5.xy = fmin(r5.xy, r6.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
             "    r0.xy = r0.xy*hg_Params[7].zw;\n"
             "    r6.xy = r0.xy*hg_Params[8].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r5.xy = hg_Params[8].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r5.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r0 = r0 + r1;\n"
             "    r1 = r4.xxxx*r2 + hg_Params[0];\n"
             "    output.color0 = r0*r1 + r3;\n"
             "    return output;\n"
             "}\n"
             "//MD5=27c82f99:05d3f9c9:9a09a632:03ef48aa\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0009:0007:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000838\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "uniform highp vec4 hg_ProgramLocal8;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0.xy = hg_TexCoord1.xy*hg_ProgramLocal4.xy;\n"
           "    r0.xy = r0.xy + hg_TexCoord0.xy;\n"
           "    r0.zw = r0.xy + hg_ProgramLocal5.xy;\n"
           "    r1.zw = r0.zw + hg_ProgramLocal6.xy;\n"
           "    r1.xy = r0.xy + -hg_ProgramLocal6.xy;\n"
           "    r3.zw = floor(r0.xy);\n"
           "    r3.xy = floor(r0.zw);\n"
           "    r3.xy = r3.xy + -r3.zw;\n"
           "    r1.zw = r1.zw + hg_ProgramLocal7.xy;\n"
           "    r1.zw = r1.zw*hg_ProgramLocal7.zw;\n"
           "    r1.xy = r1.xy + hg_ProgramLocal7.xy;\n"
           "    r0.zw = r0.zw + hg_ProgramLocal7.xy;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal7.xy;\n"
           "    r4.x = r3.x + r3.y;\n"
           "    r5.xy = hg_ProgramLocal8.xy*c0.xy + r1.zw;\n"
           "    r2 = texture2D(hg_Texture0, r5.xy);\n"
           "    r1.xy = r1.xy*hg_ProgramLocal7.zw;\n"
           "    r5.xy = hg_ProgramLocal8.xy*c0.xy + r1.xy;\n"
           "    r1 = texture2D(hg_Texture0, r5.xy);\n"
           "    r2 = r1 + r2;\n"
           "    r1 = hg_ProgramLocal1;\n"
           "    r1 = -r1 + hg_ProgramLocal3;\n"
           "    r3 = r4.xxxx*r1 + hg_ProgramLocal1;\n"
           "    r1 = hg_ProgramLocal0;\n"
           "    r3 = r2*r3;\n"
           "    r2 = -r1 + hg_ProgramLocal2;\n"
           "    r0.zw = r0.zw*hg_ProgramLocal7.zw;\n"
           "    r5.xy = hg_ProgramLocal8.xy*c0.xy + r0.zw;\n"
           "    r1 = texture2D(hg_Texture0, r5.xy);\n"
           "    r0.xy = r0.xy*hg_ProgramLocal7.zw;\n"
           "    r5.xy = hg_ProgramLocal8.xy*c0.xy + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r5.xy);\n"
           "    r0 = r0 + r1;\n"
           "    r1 = r4.xxxx*r2 + hg_ProgramLocal0;\n"
           "    gl_FragColor = r0*r1 + r3;\n"
           "}\n"
           "//MD5=b7d40998:4cb87aed:89098058:1dba952d\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0009:0006:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcBlur_g4u2::InitProgramDescriptor(HgcBlur_g4u2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlur_g4u2_hgc_visible", "//Metal1.0     \n//LEN=00000007b8\n[[ visible ]] FragmentOut HgcBlur_g4u2_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord1.xy*hg_Params[4].xy;\n"
    "    r0.xy = r0.xy + texCoord0.xy;\n"
    "    r0.zw = r0.xy + hg_Params[5].xy;\n"
    "    r1.zw = r0.zw + hg_Params[6].xy;\n"
    "    r1.xy = r0.xy + -hg_Params[6].xy;\n"
    "    r3.zw = floor(r0.xy);\n"
    "    r3.xy = floor(r0.zw);\n"
    "    r3.xy = r3.xy + -r3.zw;\n"
    "    r1.zw = r1.zw + hg_Params[7].xy;\n"
    "    r1.zw = r1.zw*hg_Params[7].zw;\n"
    "    r1.xy = r1.xy + hg_Params[7].xy;\n"
    "    r0.zw = r0.zw + hg_Params[7].xy;\n"
    "    r0.xy = r0.xy + hg_Params[7].xy;\n"
    "    r4.x = r3.x + r3.y;\n"
    "    r5.xy = r1.zw*hg_Params[8].xy;\n"
    "    r5.xy = fmax(r5.xy, c0.xy);\n"
    "    r6.xy = hg_Params[8].xy - c0.xy;\n"
    "    r5.xy = fmin(r5.xy, r6.xy);\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
    "    r1.xy = r1.xy*hg_Params[7].zw;\n"
    "    r6.xy = r1.xy*hg_Params[8].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r5.xy = hg_Params[8].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r5.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r2 = r1 + r2;\n"
    "    r1 = hg_Params[1];\n"
    "    r1 = -r1 + hg_Params[3];\n"
    "    r3 = r4.xxxx*r1 + hg_Params[1];\n"
    "    r1 = hg_Params[0];\n"
    "    r3 = r2*r3;\n"
    "    r2 = -r1 + hg_Params[2];\n"
    "    r0.zw = r0.zw*hg_Params[7].zw;\n"
    "    r5.xy = r0.zw*hg_Params[8].xy;\n"
    "    r5.xy = fmax(r5.xy, c0.xy);\n"
    "    r6.xy = hg_Params[8].xy - c0.xy;\n"
    "    r5.xy = fmin(r5.xy, r6.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
    "    r0.xy = r0.xy*hg_Params[7].zw;\n"
    "    r6.xy = r0.xy*hg_Params[8].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r5.xy = hg_Params[8].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r5.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r0 = r0 + r1;\n"
    "    r1 = r4.xxxx*r2 + hg_Params[0];\n"
    "    output.color0 = r0*r1 + r3;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBlur_g4u2");
}

void sub_1B7921190(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B79211CC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79211C4);
}

void HgcBlur_g4u2::shaderDescription(char *a1@<X8>)
{
  a1[23] = 19;
  strcpy(a1, "HgcBlur_g4u2 [hgc1]");
}

uint64_t HgcBlur_g4u2::BindTexture(HgcBlur_g4u2 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)a2 + 136))(a2, 8, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcBlur_g4u2::Bind(HgcBlur_g4u2 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBlur_g4u2::RenderTile(HgcBlur_g4u2 *this, int32x2_t *a2)
{
  uint64_t v4 = HGTile::Renderer((HGTile *)a2);
  int v5 = (*(uint64_t (**)(HgcBlur_g4u2 *, uint64_t))(*(void *)this + 312))(this, v4);
  int32x2_t v6 = *a2;
  int v7 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v7 >= 1)
  {
    int v8 = a2[1].i32[0] - v6.i32[0];
    if (v8 >= 1)
    {
      int v9 = 0;
      float32x2_t v10 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
      __asm { FMOV            V2.2S, #-1.0 }
      float32x2_t v16 = vadd_f32(v10, _D2);
      float32x2_t v17 = vadd_f32(v16, _D2);
      *(float32x2_t *)v18.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v18.i64[1] = 0x3F80000000000000;
      int32x2_t v19 = a2[2];
      uint64_t v20 = 16 * a2[3].i32[0];
      uint64_t v21 = 16 * v8;
      float32x4_t v22 = v18;
      do
      {
        uint64_t v23 = 0;
        float32x4_t v24 = v18;
        float32x4_t v25 = v22;
        do
        {
          uint64_t v32 = *((void *)this + 51);
          int8x16_t v33 = (int8x16_t)vaddq_f32(v24, vmulq_f32(v25, *(float32x4_t *)(v32 + 64)));
          int8x16_t v34 = (int8x16_t)vdupq_lane_s64(vaddq_f32(*(float32x4_t *)(v32 + 80), (float32x4_t)v33).i64[0], 0);
          v35.i64[1] = v34.i64[1];
          v35.i64[0] = v33.i64[0];
          float32x4_t v36 = *(float32x4_t *)(v32 + 96);
          int8x16_t v37 = *(int8x16_t *)(v32 + 112);
          float32x4_t v38 = vaddq_f32((float32x4_t)vdupq_lane_s64(v36.i64[0], 0), v35);
          float32x4_t v39 = vsubq_f32((float32x4_t)v33, v36);
          float32x4_t v40 = (float32x4_t)vextq_s8(v37, v37, 8uLL);
          int8x16_t v41 = (int8x16_t)vmulq_f32((float32x4_t)v37, vaddq_f32(v40, v38));
          float32x2_t v42 = (float32x2_t)vaddq_f32((float32x4_t)v37, v39).u64[0];
          int32x2_t v43 = a2[10];
          uint64_t v44 = a2[11].i32[0];
          float32x2_t v45 = vmul_f32(v10, (float32x2_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL));
          if (v5)
          {
            float32x2_t v46 = vmin_f32(vmax_f32(vadd_f32(v45, (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v47 = vcvt_s32_f32(vmin_f32(v46, v17));
            float32x2_t v48 = vsub_f32(v46, vcvt_f32_s32(v47));
            float32x2_t v49 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, v42)), (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v50 = vcvt_s32_f32(vmin_f32(v49, v17));
            float32x2_t v51 = vsub_f32(v49, vcvt_f32_s32(v50));
            int32x2_t v52 = vmla_s32(vzip1_s32(v47, v50), vzip2_s32(v47, v50), vdup_n_s32(v44));
            uint64_t v53 = (float32x4_t *)(*(void *)&v43 + 16 * v52.i32[0]);
            uint64_t v54 = (int)v44 + 1;
            float32x4_t v55 = vaddq_f32(*v53, vmulq_n_f32(vsubq_f32(v53[1], *v53), v48.f32[0]));
            float32x4_t v56 = vaddq_f32(v55, vmulq_lane_f32(vsubq_f32(vaddq_f32(v53[v44], vmulq_n_f32(vsubq_f32(v53[v54], v53[v44]), v48.f32[0])), v55), v48, 1));
            uint64_t v57 = (float32x4_t *)(*(void *)&v43 + 16 * v52.i32[1]);
            float32x4_t v58 = vaddq_f32(*v57, vmulq_n_f32(vsubq_f32(v57[1], *v57), v51.f32[0]));
            float32x4_t v59 = vaddq_f32(v58, vmulq_lane_f32(vsubq_f32(vaddq_f32(v57[v44], vmulq_n_f32(vsubq_f32(v57[v54], v57[v44]), v51.f32[0])), v58), v51, 1));
          }
          else
          {
            int32x2_t v60 = vcvt_s32_f32(vmin_f32(vmax_f32(v45, 0), v16));
            int32x2_t v61 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, v42)), 0), v16));
            int32x2_t v62 = vmla_s32(vzip1_s32(v60, v61), vzip2_s32(v60, v61), vdup_n_s32(v44));
            __int32 v63 = v62.i32[1];
            float32x4_t v56 = *(float32x4_t *)(*(void *)&v43 + 16 * v62.i32[0]);
            float32x4_t v59 = *(float32x4_t *)(*(void *)&v43 + 16 * v63);
          }
          float32x4_t v64 = (float32x4_t)vextq_s8(v34, v33, 8uLL);
          float32x4_t v65 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
          float32x4_t v66 = vsubq_f32(v65, (float32x4_t)vandq_s8(*(int8x16_t *)(v32 + 128), (int8x16_t)vcgtq_f32(v65, v64)));
          int8x16_t v67 = (int8x16_t)vnegq_f32(v66);
          float32x4_t v68 = vaddq_f32(v66, (float32x4_t)vextq_s8(v67, v67, 8uLL));
          int8x16_t v69 = (int8x16_t)vaddq_f32(v35, v40);
          float32x2_t v70 = vadd_f32(*(float32x2_t *)v33.i8, *(float32x2_t *)v37.i8);
          LODWORD(v71) = vaddq_f32(v68, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 1)).u32[0];
          float32x2_t v72 = vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, (float32x2_t)*(_OWORD *)&vextq_s8(v69, v69, 8uLL)));
          if (v5)
          {
            float32x2_t v73 = vmin_f32(vmax_f32(vadd_f32(v72, (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v74 = vcvt_s32_f32(vmin_f32(v73, v17));
            float32x2_t v75 = vsub_f32(v73, vcvt_f32_s32(v74));
            float32x2_t v76 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, v70)), (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v77 = vcvt_s32_f32(vmin_f32(v76, v17));
            float32x2_t v78 = vsub_f32(v76, vcvt_f32_s32(v77));
            int32x2_t v79 = vmla_s32(vzip1_s32(v74, v77), vzip2_s32(v74, v77), vdup_n_s32(v44));
            float32x4_t v80 = (float32x4_t *)(*(void *)&v43 + 16 * v79.i32[0]);
            uint64_t v81 = (int)v44 + 1;
            float32x4_t v82 = vaddq_f32(*v80, vmulq_n_f32(vsubq_f32(v80[1], *v80), v75.f32[0]));
            float32x4_t v30 = vaddq_f32(v82, vmulq_lane_f32(vsubq_f32(vaddq_f32(v80[v44], vmulq_n_f32(vsubq_f32(v80[v81], v80[v44]), v75.f32[0])), v82), v75, 1));
            float32x4_t v83 = (float32x4_t *)(*(void *)&v43 + 16 * v79.i32[1]);
            float32x4_t v84 = vaddq_f32(*v83, vmulq_n_f32(vsubq_f32(v83[1], *v83), v78.f32[0]));
            float32x4_t v31 = vaddq_f32(v84, vmulq_lane_f32(vsubq_f32(vaddq_f32(v83[v44], vmulq_n_f32(vsubq_f32(v83[v81], v83[v44]), v78.f32[0])), v84), v78, 1));
          }
          else
          {
            int32x2_t v26 = vcvt_s32_f32(vmin_f32(vmax_f32(v72, 0), v16));
            int32x2_t v27 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, vmul_f32(*(float32x2_t *)v40.f32, v70)), 0), v16));
            int32x2_t v28 = vmla_s32(vzip1_s32(v26, v27), vzip2_s32(v26, v27), vdup_n_s32(v44));
            __int32 v29 = v28.i32[1];
            float32x4_t v30 = *(float32x4_t *)(*(void *)&v43 + 16 * v28.i32[0]);
            float32x4_t v31 = *(float32x4_t *)(*(void *)&v43 + 16 * v29);
          }
          *(float32x4_t *)(*(void *)&v19 + v23) = vaddq_f32(vmulq_f32(vaddq_f32(v56, v59), vaddq_f32(*(float32x4_t *)(v32 + 16), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v32 + 48), *(float32x4_t *)(v32 + 16)), v71))), vmulq_f32(vaddq_f32(*(float32x4_t *)v32, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v32 + 32), *(float32x4_t *)v32), v71)), vaddq_f32(v30, v31)));
          float32x4_t v24 = vaddq_f32(v24, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v25 = vaddq_f32(v25, (float32x4_t)xmmword_1B7E736B0);
          v23 += 16;
        }
        while (v21 != v23);
        float32x4_t v18 = vaddq_f32(v18, (float32x4_t)xmmword_1B7E736C0);
        float32x4_t v22 = vaddq_f32(v22, (float32x4_t)xmmword_1B7E736C0);
        ++v9;
        *(void *)&v19 += v20;
      }
      while (v9 != v7);
    }
  }
  return 0;
}

uint64_t HgcBlur_g4u2::GetDOD(HgcBlur_g4u2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = &HGRectInfinite;
  if (a3) {
    uint64_t v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcBlur_g4u2::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcBlur_g4u2::HgcBlur_g4u2(HgcBlur_g4u2 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F32E0;
  operator new();
}

void sub_1B7921AD8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBlur_g4u2::~HgcBlur_g4u2(HGNode *this)
{
  *(void *)this = &unk_1F10F32E0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40265AC83CLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F32E0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40265AC83CLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F32E0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40265AC83CLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBlur_g4u2::SetParameter(HgcBlur_g4u2 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int v8 = a3;
  float32x2_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlur_g4u2::GetParameter(HgcBlur_g4u2 *this, unsigned int a2, float *a3)
{
  if (a2 > 7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBlur_g4u2_rect::GetProgram(HgcBlur_g4u2_rect *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000005f2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    float4 s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord1.xy*hg_Params[4].xy + frag._texCoord0.xy;\n"
             "    s1.xy = s0.xy - hg_Params[6].xy;\n"
             "    s2.xy = s0.xy + hg_Params[5].xy;\n"
             "    s3.xy = s2.xy + hg_Params[6].xy;\n"
             "    s4.xy = floor(s0.xy);\n"
             "    s5.xy = floor(s2.xy);\n"
             "    s4.xy = s5.xy - s4.xy;\n"
             "    s4 = s4.xxxx + s4.yyyy;\n"
             "    s6 = mix(hg_Params[0], hg_Params[2], s4);\n"
             "    s7 = mix(hg_Params[1], hg_Params[3], s4);\n"
             "    s9.xy = s1.xy + hg_Params[7].xy;\n"
             "    s9.xy = s9.xy*hg_Params[7].zw;\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s9.xy = s3.xy + hg_Params[7].xy;\n"
             "    s9.xy = s9.xy*hg_Params[7].zw;\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r0 = r0 + r1;\n"
             "    s9.xy = s0.xy + hg_Params[7].xy;\n"
             "    s9.xy = s9.xy*hg_Params[7].zw;\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s9.xy = s2.xy + hg_Params[7].xy;\n"
             "    s9.xy = s9.xy*hg_Params[7].zw;\n"
             "    r3 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    r2 = r2 + r3;\n"
             "    s8 = float4(r0)*s7;\n"
             "    s8 = float4(r2)*s6 + s8;\n"
             "    output.color0 = s8;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6880a678:737fce71:a2b9662a:27e9fc5b\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0008:000e:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000005a5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r1.xy = frag._texCoord1.xy*hg_Params[4].xy + frag._texCoord0.xy;\n"
             "    r0.xy = r1.xy - hg_Params[6].xy;\n"
             "    r2.xy = r1.xy + hg_Params[5].xy;\n"
             "    r3.xy = r2.xy + hg_Params[6].xy;\n"
             "    r4.xy = floor(r1.xy);\n"
             "    r5.xy = floor(r2.xy);\n"
             "    r4.xy = r5.xy - r4.xy;\n"
             "    r4 = r4.xxxx + r4.yyyy;\n"
             "    r6 = mix(hg_Params[0], hg_Params[2], r4);\n"
             "    r7 = mix(hg_Params[1], hg_Params[3], r4);\n"
             "    r8.xy = r0.xy + hg_Params[7].xy;\n"
             "    r8.xy = r8.xy*hg_Params[7].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
             "    r8.xy = r3.xy + hg_Params[7].xy;\n"
             "    r8.xy = r8.xy*hg_Params[7].zw;\n"
             "    r3 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
             "    r0 = r0 + r3;\n"
             "    r8.xy = r1.xy + hg_Params[7].xy;\n"
             "    r8.xy = r8.xy*hg_Params[7].zw;\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
             "    r8.xy = r2.xy + hg_Params[7].xy;\n"
             "    r8.xy = r8.xy*hg_Params[7].zw;\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
             "    r1 = r1 + r2;\n"
             "    r0 = r0*r7;\n"
             "    r0 = r1*r6 + r0;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=325c15d5:053de68f:ddd38fee:92ec3141\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0008:0009:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000006af\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5, r6, r7, r8;\n"
           "\n"
           "    r1.xy = hg_TexCoord1.xy*hg_ProgramLocal4.xy + hg_TexCoord0.xy;\n"
           "    r0.xy = r1.xy - hg_ProgramLocal6.xy;\n"
           "    r2.xy = r1.xy + hg_ProgramLocal5.xy;\n"
           "    r3.xy = r2.xy + hg_ProgramLocal6.xy;\n"
           "    r4.xy = floor(r1.xy);\n"
           "    r5.xy = floor(r2.xy);\n"
           "    r4.xy = r5.xy - r4.xy;\n"
           "    r4 = r4.xxxx + r4.yyyy;\n"
           "    r6 = mix(hg_ProgramLocal0, hg_ProgramLocal2, r4);\n"
           "    r7 = mix(hg_ProgramLocal1, hg_ProgramLocal3, r4);\n"
           "    r8.xy = r0.xy + hg_ProgramLocal7.xy;\n"
           "    r8.xy = r8.xy*hg_ProgramLocal7.zw;\n"
           "    r0 = texture2D(hg_Texture0, r8.xy);\n"
           "    r8.xy = r3.xy + hg_ProgramLocal7.xy;\n"
           "    r8.xy = r8.xy*hg_ProgramLocal7.zw;\n"
           "    r3 = texture2D(hg_Texture0, r8.xy);\n"
           "    r0 = r0 + r3;\n"
           "    r8.xy = r1.xy + hg_ProgramLocal7.xy;\n"
           "    r8.xy = r8.xy*hg_ProgramLocal7.zw;\n"
           "    r1 = texture2D(hg_Texture0, r8.xy);\n"
           "    r8.xy = r2.xy + hg_ProgramLocal7.xy;\n"
           "    r8.xy = r8.xy*hg_ProgramLocal7.zw;\n"
           "    r2 = texture2D(hg_Texture0, r8.xy);\n"
           "    r1 = r1 + r2;\n"
           "    r0 = r0*r7;\n"
           "    r0 = r1*r6 + r0;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=497577be:b0d0ecde:f4ebf00e:861916a5\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0008:0009:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcBlur_g4u2_rect::InitProgramDescriptor(HgcBlur_g4u2_rect *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlur_g4u2_rect_hgc_visible", "//Metal1.0     \n//LEN=00000004f9\n[[ visible ]] FragmentOut HgcBlur_g4u2_rect_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r1.xy = texCoord1.xy*hg_Params[4].xy + texCoord0.xy;\n"
    "    r0.xy = r1.xy - hg_Params[6].xy;\n"
    "    r2.xy = r1.xy + hg_Params[5].xy;\n"
    "    r3.xy = r2.xy + hg_Params[6].xy;\n"
    "    r4.xy = floor(r1.xy);\n"
    "    r5.xy = floor(r2.xy);\n"
    "    r4.xy = r5.xy - r4.xy;\n"
    "    r4 = r4.xxxx + r4.yyyy;\n"
    "    r6 = mix(hg_Params[0], hg_Params[2], r4);\n"
    "    r7 = mix(hg_Params[1], hg_Params[3], r4);\n"
    "    r8.xy = r0.xy + hg_Params[7].xy;\n"
    "    r8.xy = r8.xy*hg_Params[7].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
    "    r8.xy = r3.xy + hg_Params[7].xy;\n"
    "    r8.xy = r8.xy*hg_Params[7].zw;\n"
    "    r3 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
    "    r0 = r0 + r3;\n"
    "    r8.xy = r1.xy + hg_Params[7].xy;\n"
    "    r8.xy = r8.xy*hg_Params[7].zw;\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
    "    r8.xy = r2.xy + hg_Params[7].xy;\n"
    "    r8.xy = r8.xy*hg_Params[7].zw;\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, r8.xy);\n"
    "    r1 = r1 + r2;\n"
    "    r0 = r0*r7;\n"
    "    r0 = r1*r6 + r0;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBlur_g4u2_rect");
}

void sub_1B79221AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B79221E8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79221E0);
}

char *HgcBlur_g4u2_rect::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8349210;
  strcpy(result, "HgcBlur_g4u2_rect [hgc1]");
  return result;
}

uint64_t HgcBlur_g4u2_rect::BindTexture(HgcBlur_g4u2_rect *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 7, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcBlur_g4u2_rect::Bind(HgcBlur_g4u2_rect *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBlur_g4u2_rect::RenderTile(HgcBlur_g4u2_rect *this, HGTile *a2)
{
  uint64_t v4 = HGTile::Renderer(a2);
  int v5 = (*(uint64_t (**)(HgcBlur_g4u2_rect *, uint64_t))(*(void *)this + 312))(this, v4);
  int32x2_t v6 = *(int32x2_t *)a2;
  int v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v7 >= 1)
  {
    uint64_t v8 = (*((_DWORD *)a2 + 2) - v6.i32[0]);
    if ((int)v8 >= 1)
    {
      *(float32x2_t *)v9.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v9.i64[1] = 0x3F80000000000000;
      uint64_t v10 = *((void *)a2 + 2);
      int v11 = 0;
      uint64_t v12 = 16 * *((int *)a2 + 6);
      uint64_t v13 = 16 * v8;
      if (v5)
      {
        float32x4_t v14 = v9;
        float32x4_t v15 = v9;
        do
        {
          uint64_t v16 = 0;
          float32x4_t v17 = v14;
          float32x4_t v18 = v15;
          do
          {
            uint64_t v19 = *((void *)this + 51);
            float32x4_t v20 = vaddq_f32(v17, vmulq_f32(v18, *(float32x4_t *)(v19 + 64)));
            float32x4_t v21 = *(float32x4_t *)(v19 + 96);
            float32x4_t v22 = vsubq_f32(v20, v21);
            float32x4_t v23 = vaddq_f32(v20, *(float32x4_t *)(v19 + 80));
            float32x4_t v24 = vaddq_f32(v21, v23);
            float32x4_t v25 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
            float32x4_t v26 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
            v25.i64[0] = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v25, v20), *(int8x16_t *)(v19 + 112), (int8x16_t)0), v25), vsubq_f32(v26, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v26, v23), *(int8x16_t *)(v19 + 112), (int8x16_t)0))).u64[0];
            float32x4_t v27 = *(float32x4_t *)v19;
            float32x4_t v28 = *(float32x4_t *)(v19 + 16);
            float32x4_t v29 = vsubq_f32(*(float32x4_t *)(v19 + 32), *(float32x4_t *)v19);
            float32x4_t v30 = vsubq_f32(*(float32x4_t *)(v19 + 48), v28);
            uint64_t v31 = *((void *)a2 + 10);
            uint64_t v32 = *((int *)a2 + 22);
            float32x4_t v33 = vsubq_f32(v22, v9);
            float32x4_t v34 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1));
            int32x4_t v35 = vaddq_s32(vcvtq_s32_f32(v33), vcltzq_f32(v33));
            float32x4_t v36 = vmulq_f32(v29, v34);
            v33.i64[0] = vsubq_f32(v33, vcvtq_f32_s32(v35)).u64[0];
            int8x16_t v37 = (float32x4_t *)(v31 + 16 * (v35.i32[0] + v35.i32[1] * (int)v32));
            float32x4_t v38 = vmulq_f32(v30, v34);
            float32x4_t v39 = *v37;
            float32x4_t v40 = v37[v32];
            float32x4_t v41 = vmulq_n_f32(vsubq_f32(v37[1], *v37), v33.f32[0]);
            uint64_t v42 = (int)v32 + 1;
            float32x4_t v43 = vmulq_n_f32(vsubq_f32(v37[v42], v40), v33.f32[0]);
            float32x4_t v44 = vsubq_f32(v24, v9);
            int32x4_t v45 = vaddq_s32(vcvtq_s32_f32(v44), vcltzq_f32(v44));
            float32x4_t v46 = vaddq_f32(v27, v36);
            v36.i64[0] = vsubq_f32(v44, vcvtq_f32_s32(v45)).u64[0];
            float32x4_t v47 = vaddq_f32(v28, v38);
            float32x2_t v48 = (float32x4_t *)(v31 + 16 * (v45.i32[0] + v45.i32[1] * (int)v32));
            float32x4_t v49 = *v48;
            float32x4_t v50 = v48[v32];
            float32x4_t v51 = vaddq_f32(v39, v41);
            float32x4_t v52 = vsubq_f32(v48[v42], v50);
            float32x4_t v53 = vsubq_f32(v20, v9);
            float32x4_t v54 = vaddq_f32(v40, v43);
            int32x4_t v55 = vaddq_s32(vcvtq_s32_f32(v53), vcltzq_f32(v53));
            v53.i64[0] = vsubq_f32(v53, vcvtq_f32_s32(v55)).u64[0];
            float32x4_t v56 = vmulq_n_f32(vsubq_f32(v48[1], *v48), v36.f32[0]);
            uint64_t v57 = (float32x4_t *)(v31 + 16 * (v55.i32[0] + v55.i32[1] * (int)v32));
            float32x4_t v58 = vaddq_f32(*v57, vmulq_n_f32(vsubq_f32(v57[1], *v57), v53.f32[0]));
            float32x4_t v59 = vaddq_f32(v49, v56);
            float32x4_t v60 = vsubq_f32(v23, v9);
            int32x4_t v61 = vaddq_s32(vcvtq_s32_f32(v60), vcltzq_f32(v60));
            v60.i64[0] = vsubq_f32(v60, vcvtq_f32_s32(v61)).u64[0];
            float32x4_t v62 = vaddq_f32(v51, vmulq_lane_f32(vsubq_f32(v54, v51), *(float32x2_t *)v33.f32, 1));
            __int32 v63 = (float32x4_t *)(v31 + 16 * (v61.i32[0] + v61.i32[1] * (int)v32));
            float32x4_t v64 = vaddq_f32(*v63, vmulq_n_f32(vsubq_f32(v63[1], *v63), v60.f32[0]));
            *(float32x4_t *)(v10 + v16) = vaddq_f32(vmulq_f32(v47, vaddq_f32(v62, vaddq_f32(v59, vmulq_lane_f32(vsubq_f32(vaddq_f32(v50, vmulq_n_f32(v52, v36.f32[0])), v59), *(float32x2_t *)v36.f32, 1)))), vmulq_f32(v46, vaddq_f32(vaddq_f32(v58, vmulq_lane_f32(vsubq_f32(vaddq_f32(v57[v32],
                                                        vmulq_n_f32(vsubq_f32(v57[v42], v57[v32]), v53.f32[0])),
                                                      v58),
                                                    *(float32x2_t *)v53.f32,
                                                    1)),
                                                vaddq_f32(v64, vmulq_lane_f32(vsubq_f32(vaddq_f32(v63[v32], vmulq_n_f32(vsubq_f32(v63[v42], v63[v32]), v60.f32[0])), v64), *(float32x2_t *)v60.f32, 1)))));
            float32x4_t v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B7E736B0);
            float32x4_t v18 = vaddq_f32(v18, (float32x4_t)xmmword_1B7E736B0);
            v16 += 16;
          }
          while (v13 != v16);
          float32x4_t v14 = vaddq_f32(v14, (float32x4_t)xmmword_1B7E736C0);
          float32x4_t v15 = vaddq_f32(v15, (float32x4_t)xmmword_1B7E736C0);
          ++v11;
          v10 += v12;
        }
        while (v11 != v7);
      }
      else
      {
        v65.i64[0] = 0x3F0000003F000000;
        v65.i64[1] = 0x3F0000003F000000;
        float32x4_t v66 = v9;
        float32x4_t v67 = v9;
        do
        {
          uint64_t v68 = 0;
          float32x4_t v69 = v66;
          float32x4_t v70 = v67;
          do
          {
            uint64_t v71 = *((void *)this + 51);
            float32x4_t v72 = vaddq_f32(v69, vmulq_f32(v70, *(float32x4_t *)(v71 + 64)));
            float32x4_t v73 = *(float32x4_t *)(v71 + 96);
            int8x16_t v74 = *(int8x16_t *)(v71 + 112);
            float32x4_t v75 = vaddq_f32(v72, *(float32x4_t *)(v71 + 80));
            float32x4_t v76 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
            float32x4_t v77 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v76, v72), v74, (int8x16_t)0);
            float32x4_t v78 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
            float32x4_t v79 = vsubq_f32(v78, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v78, v75), v74, (int8x16_t)0));
            float32x4_t v80 = vsubq_f32(v77, v76);
            float32x4_t v81 = *(float32x4_t *)(v71 + 32);
            float32x4_t v82 = *(float32x4_t *)(v71 + 48);
            uint64_t v83 = *((void *)a2 + 10);
            v79.i64[0] = vaddq_f32(v80, v79).u64[0];
            float32x4_t v84 = vaddq_f32(vsubq_f32(vsubq_f32(v72, v73), v9), v65);
            int32x4_t v85 = vcvtq_s32_f32(v84);
            int v86 = *((_DWORD *)a2 + 22);
            v84.i64[0] = vaddq_s32(v85, vcgtq_f32(vcvtq_f32_s32(v85), v84)).u64[0];
            __int32 v87 = v84.i32[1];
            __int32 v88 = v84.i32[0];
            float32x4_t v89 = vaddq_f32(vsubq_f32(vaddq_f32(v73, v75), v9), v65);
            int32x4_t v90 = vcvtq_s32_f32(v89);
            v89.i64[0] = vaddq_s32(v90, vcgtq_f32(vcvtq_f32_s32(v90), v89)).u64[0];
            float32x4_t v91 = vaddq_f32(vsubq_f32(v72, v9), v65);
            int32x4_t v92 = vcvtq_s32_f32(v91);
            v91.i64[0] = vaddq_s32(v92, vcgtq_f32(vcvtq_f32_s32(v92), v91)).u64[0];
            __int32 v93 = v88 + v87 * v86;
            __int32 v94 = v91.i32[1];
            __int32 v95 = v91.i32[0];
            float32x4_t v96 = *(float32x4_t *)v71;
            float32x4_t v97 = *(float32x4_t *)(v71 + 16);
            LODWORD(v71) = v89.i32[0] + v89.i32[1] * v86;
            float32x4_t v98 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v79.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v79.f32, 1));
            float32x4_t v99 = vaddq_f32(v96, vmulq_f32(vsubq_f32(v81, v96), v98));
            float32x4_t v100 = vaddq_f32(v97, vmulq_f32(vsubq_f32(v82, v97), v98));
            float32x4_t v101 = vaddq_f32(vsubq_f32(v75, v9), v65);
            int32x4_t v102 = vcvtq_s32_f32(v101);
            v101.i64[0] = vaddq_s32(v102, vcgtq_f32(vcvtq_f32_s32(v102), v101)).u64[0];
            *(float32x4_t *)(v10 + v68) = vaddq_f32(vmulq_f32(v100, vaddq_f32(*(float32x4_t *)(v83 + 16 * v93), *(float32x4_t *)(v83 + 16 * (int)v71))), vmulq_f32(v99, vaddq_f32(*(float32x4_t *)(v83 + 16 * (v95 + v94 * v86)), *(float32x4_t *)(v83 + 16 * (v101.i32[0] + v101.i32[1] * v86)))));
            float32x4_t v69 = vaddq_f32(v69, (float32x4_t)xmmword_1B7E736B0);
            float32x4_t v70 = vaddq_f32(v70, (float32x4_t)xmmword_1B7E736B0);
            v68 += 16;
          }
          while (v13 != v68);
          float32x4_t v66 = vaddq_f32(v66, (float32x4_t)xmmword_1B7E736C0);
          float32x4_t v67 = vaddq_f32(v67, (float32x4_t)xmmword_1B7E736C0);
          ++v11;
          v10 += v12;
        }
        while (v11 != v7);
      }
    }
  }
  return 0;
}

uint64_t HgcBlur_g4u2_rect::GetDOD(HgcBlur_g4u2_rect *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  if ((*(int (**)(HgcBlur_g4u2_rect *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
  {
    uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    HGRectGrow(v6, v5, v7);
  }
  return 0x8000000080000000;
}

uint64_t HgcBlur_g4u2_rect::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  uint64_t v10 = v9;
  if ((*(int (**)(HGNode *, HGRenderer *))(*(void *)this + 312))(this, a2) < 1) {
    return DOD;
  }
  uint64_t v11 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  return HGRectGrow(DOD, v10, v11);
}

void HgcBlur_g4u2_rect::HgcBlur_g4u2_rect(HgcBlur_g4u2_rect *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F3548;
  operator new();
}

void sub_1B7922C34(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBlur_g4u2_rect::~HgcBlur_g4u2_rect(HGNode *this)
{
  *(void *)this = &unk_1F10F3548;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F3548;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F3548;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBlur_g4u2_rect::SetParameter(HgcBlur_g4u2_rect *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlur_g4u2_rect::GetParameter(HgcBlur_g4u2_rect *this, unsigned int a2, float *a3)
{
  if (a2 > 6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcApply3DLUTTetrahedral_basekernel::GetProgram(HgcApply3DLUTTetrahedral_basekernel *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return aMetal10Len0000_1169;
    }
    else {
      return aMetal10Len0000_1170;
    }
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_438;
  }
}

void HgcApply3DLUTTetrahedral_basekernel::InitProgramDescriptor(HgcApply3DLUTTetrahedral_basekernel *this, HGProgramDescriptor *a2)
{
}

void sub_1B792339C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a23);
  _Unwind_Resume(a1);
}

void sub_1B79233DC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79233D4);
}

double HgcApply3DLUTTetrahedral_basekernel::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x30uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376FF0;
  strcpy(v3, "HgcApply3DLUTTetrahedral_basekernel [hgc1]");
  return *(double *)"asekernel [hgc1]";
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::BindTexture(HgcApply3DLUTTetrahedral_basekernel *this, HGHandler *a2, int a3)
{
  if (a3 == 2)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 5, v6, v7, v8, v9);
    return 0;
  }
  else if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
    {
      v12.n128_u32[0] = 1.0;
      v13.n128_u32[0] = 1.0;
    }
    else
    {
      v12.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v13.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v10.n128_f32[0] = (float)*((int *)a2 + 60);
    v11.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 4, v10, v11, v12, v13);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v4 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::Bind(HgcApply3DLUTTetrahedral_basekernel *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::RenderTile(HgcApply3DLUTTetrahedral_basekernel *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      int v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      int32x2_t v7 = a2[10];
      int32x2_t v8 = a2[2];
      uint64_t v9 = 16 * a2[11].i32[0];
      uint64_t v10 = 16 * a2[3].i32[0];
      uint64_t v11 = 16 * v4;
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      do
      {
        uint64_t v13 = 0;
        do
        {
          float32x4_t v14 = *(float32x4_t *)(*(void *)&v7 + v13);
          float32x4_t v15 = (_OWORD *)*((void *)this + 51);
          float32x4_t v16 = *(float32x4_t *)v15;
          float32x4_t v17 = *((float32x4_t *)v15 + 1);
          float32x4_t v18 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15, 1), vmulq_n_f32(v14, COERCE_FLOAT(*v15)));
          float32x4_t v19 = *((float32x4_t *)v15 + 2);
          float32x4_t v20 = vmulq_f32(v18, v18);
          float32x4_t v21 = *((float32x4_t *)v15 + 4);
          float32x4_t v22 = *((float32x4_t *)v15 + 5);
          float32x4_t v23 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1), v22);
          float32x4_t v24 = vminq_f32(vmaxq_f32(vaddq_f32(vaddq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v15[3], 0), vmulq_lane_f32(v18, (float32x2_t)v15[3], 1)), vmulq_laneq_f32(v20, *((float32x4_t *)v15 + 3), 2)), vmulq_laneq_f32(vmulq_f32(v18, v20), *((float32x4_t *)v15 + 3), 3)), v21), v23);
          float32x4_t v25 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
          float32x4_t v26 = vsubq_f32(v25, (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v25, v24)));
          float32x4_t v27 = vminq_f32(vaddq_f32(v22, v26), v23);
          float32x4_t v28 = vmulq_f32(v17, v26);
          float32x4_t v29 = *((float32x4_t *)v15 + 6);
          float32x4_t v30 = *((float32x4_t *)v15 + 7);
          float32x4_t v31 = vmulq_f32(v17, vsubq_f32(v27, v26));
          float32x4_t v32 = vaddq_f32(v30, (float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)vaddq_f32(v28, (float32x4_t)vrev64q_s32((int32x4_t)v28)), vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL)));
          int32x2_t v33 = a2[12];
          __int32 v34 = a2[13].i32[0];
          float32x4_t v35 = vaddq_f32(vsubq_f32(v32, v6), v12);
          int32x4_t v36 = vcvtq_s32_f32(v35);
          v35.i64[0] = vaddq_s32(v36, vcgtq_f32(vcvtq_f32_s32(v36), v35)).u64[0];
          __int32 v37 = v35.i32[1];
          __int32 v38 = v35.i32[0];
          float32x4_t v39 = (float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)vaddq_f32(v31, v32), (int8x16_t)v32);
          float32x4_t v40 = vaddq_f32(vsubq_f32(v39, v6), v12);
          __int32 v41 = v38 + v37 * v34;
          int32x4_t v42 = vcvtq_s32_f32(v40);
          v40.i64[0] = vaddq_s32(v42, vcgtq_f32(vcvtq_f32_s32(v42), v40)).u64[0];
          __int32 v43 = v40.i32[1];
          __int32 v44 = v40.i32[0];
          float32x4_t v45 = (float32x4_t)vrev64q_s32((int32x4_t)v31);
          float32x4_t v46 = (float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)vaddq_f32(v45, v39), (int8x16_t)v32);
          float32x4_t v47 = *(float32x4_t *)(*(void *)&v33 + 16 * v41);
          float32x4_t v48 = vaddq_f32(vsubq_f32(v46, v6), v12);
          int32x4_t v49 = vcvtq_s32_f32(v48);
          __int32 v50 = v44 + v43 * v34;
          v48.i64[0] = vaddq_s32(v49, vcgtq_f32(vcvtq_f32_s32(v49), v48)).u64[0];
          __int32 v51 = v48.i32[1];
          int8x16_t v52 = (int8x16_t)vsubq_f32(v46, v31);
          float32x4_t v53 = (float32x4_t)vbslq_s8((int8x16_t)v29, v52, (int8x16_t)v32);
          __int32 v54 = v48.i32[0];
          float32x4_t v55 = vaddq_f32(vsubq_f32(v53, v6), v12);
          int32x4_t v56 = vcvtq_s32_f32(v55);
          float32x4_t v57 = *(float32x4_t *)(*(void *)&v33 + 16 * v50);
          int8x16_t v58 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v31, (int8x16_t)v31, 4uLL), v53);
          float32x4_t v59 = (float32x4_t)vbslq_s8((int8x16_t)v29, v52, v58);
          v55.i64[0] = vaddq_s32(v56, vcgtq_f32(vcvtq_f32_s32(v56), v55)).u64[0];
          float32x4_t v60 = vaddq_f32(vsubq_f32(v59, v6), v12);
          int32x4_t v61 = vcvtq_s32_f32(v60);
          int32x4_t v62 = (int32x4_t)vaddq_f32(v30, v26);
          int32x2_t v63 = a2[14];
          __int32 v64 = v54 + v51 * v34;
          __int32 v65 = a2[15].i32[0];
          float32x4_t v66 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)v62, (int8x16_t)v30), v6), v12);
          int32x4_t v67 = vcvtq_s32_f32(v66);
          v66.i64[0] = vaddq_s32(v67, vcgtq_f32(vcvtq_f32_s32(v67), v66)).u64[0];
          __int32 v68 = v55.i32[1];
          int32x4_t v69 = *(int32x4_t *)(*(void *)&v63 + 16 * (v66.i32[0] + v66.i32[1] * v65));
          __int32 v70 = v55.i32[0];
          float32x4_t v71 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)vrev64q_s32(v62), (int8x16_t)v30), v6), v12);
          int32x4_t v72 = vcvtq_s32_f32(v71);
          int32x4_t v73 = vcgtq_f32(vcvtq_f32_s32(v61), v60);
          v71.i64[0] = vaddq_s32(v72, vcgtq_f32(vcvtq_f32_s32(v72), v71)).u64[0];
          float32x4_t v74 = *(float32x4_t *)(*(void *)&v33 + 16 * v64);
          __int32 v75 = v71.i32[0] + v71.i32[1] * v65;
          float32x4_t v76 = vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)v29, vextq_s8((int8x16_t)v62, (int8x16_t)v62, 8uLL), (int8x16_t)v30), v6);
          v30.i64[0] = vaddq_s32(v61, v73).u64[0];
          float32x4_t v77 = vaddq_f32(v76, v12);
          int32x4_t v78 = vcvtq_s32_f32(v77);
          v77.i64[0] = vaddq_s32(v78, vcgtq_f32(vcvtq_f32_s32(v78), v77)).u64[0];
          __int32 v79 = v70 + v68 * v34;
          __int32 v80 = v77.i32[0] + v77.i32[1] * v65;
          __int32 v81 = v30.i32[1];
          __int32 v82 = v30.i32[0];
          float32x4_t v83 = (float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)vsubq_f32(v59, v45), v58);
          float32x4_t v84 = *(float32x4_t *)(*(void *)&v33 + 16 * v79);
          float32x4_t v85 = vaddq_f32(vsubq_f32(v83, v6), v12);
          int32x4_t v86 = vcvtq_s32_f32(v85);
          v85.i64[0] = vaddq_s32(v86, vcgtq_f32(vcvtq_f32_s32(v86), v85)).u64[0];
          __int32 v87 = v82 + v81 * v34;
          __int32 v88 = v85.i32[1];
          int8x16_t v89 = (int8x16_t)vaddq_f32(v31, v83);
          int32x4_t v90 = *(int32x4_t *)(*(void *)&v63 + 16 * v75);
          __int32 v91 = v85.i32[0];
          float32x4_t v92 = (float32x4_t)vbslq_s8((int8x16_t)v29, v89, v58);
          float32x4_t v93 = vaddq_f32(vsubq_f32(v92, v6), v12);
          int32x4_t v94 = vcvtq_s32_f32(v93);
          float32x4_t v95 = *(float32x4_t *)(*(void *)&v33 + 16 * v87);
          v93.i64[0] = vaddq_s32(v94, vcgtq_f32(vcvtq_f32_s32(v94), v93)).u64[0];
          float32x4_t v96 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)v29, (int8x16_t)vaddq_f32(v45, v92), v58), v6), v12);
          float32x4_t v97 = *(float32x4_t *)(*(void *)&v63 + 16 * v80);
          v63.i32[0] = v93.i32[1];
          float32x4_t v98 = (float32x4_t)vcvtq_s32_f32(v96);
          v72.i64[0] = vrev64q_s32(v90).u64[0];
          v90.i64[0] = vbslq_s8((int8x16_t)v29, (int8x16_t)vrev64q_s32(v69), (int8x16_t)v90).u64[0];
          __int32 v99 = v93.i32[0];
          *(int8x8_t *)v29.f32 = vorr_s8(vand_s8(*(int8x8_t *)v72.i8, (int8x8_t)*(_OWORD *)&vmvnq_s8((int8x16_t)v29)), vand_s8(*(int8x8_t *)v29.f32, *(int8x8_t *)v69.i8));
          v29.i64[1] = v97.i64[0];
          int32x4_t v100 = vcgtq_f32(vcvtq_f32_s32((int32x4_t)v98), v96);
          float32x4_t v101 = (float32x4_t)vextq_s8((int8x16_t)v6, (int8x16_t)v97, 0xCuLL);
          v101.i64[0] = v90.i64[0];
          float32x4_t v102 = *(float32x4_t *)(*(void *)&v33 + 16 * (v91 + v88 * v34));
          float32x4_t v103 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v21, vsubq_f32(v18, v22)), (int8x16_t)vmulq_f32(v101, vsubq_f32(vmaxq_f32(v18, v21), v29)), (int8x16_t)v21);
          v29.i64[0] = vaddq_s32((int32x4_t)v98, v100).u64[0];
          float32x4_t v104 = *((float32x4_t *)v15 + 8);
          int8x16_t v105 = *((int8x16_t *)v15 + 9);
          *(int8x8_t *)v97.f32 = vqtbl1_s8((int8x16_t)v103, *(int8x8_t *)v104.f32);
          *(int8x8_t *)&v97.u32[2] = vqtbl1_s8((int8x16_t)v103, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v104, (int8x16_t)v104, 8uLL));
          *(int8x8_t *)v104.f32 = vqtbl1_s8((int8x16_t)v103, *(int8x8_t *)v105.i8);
          __int32 v106 = v29.i32[1];
          *(int8x8_t *)&v104.u32[2] = vqtbl1_s8((int8x16_t)v103, (int8x8_t)*(_OWORD *)&vextq_s8(v105, v105, 8uLL));
          float32x4_t v107 = *((float32x4_t *)v15 + 10);
          int8x16_t v108 = *((int8x16_t *)v15 + 11);
          LODWORD(v15) = v29.i32[0];
          int32x4_t v109 = (int32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v104, v97));
          float32x4_t v110 = *(float32x4_t *)(*(void *)&v33 + 16 * (v99 + v63.i32[0] * v34));
          *(int8x8_t *)v98.f32 = vqtbl1_s8((int8x16_t)v103, *(int8x8_t *)v107.f32);
          *(int8x8_t *)&v98.u32[2] = vqtbl1_s8((int8x16_t)v103, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v107, (int8x16_t)v107, 8uLL));
          v104.i64[0] = vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v103), v103)).u64[0];
          *(int8x8_t *)v107.f32 = vqtbl1_s8((int8x16_t)v103, *(int8x8_t *)v108.i8);
          float32x4_t v111 = *(float32x4_t *)(*(void *)&v33 + 16 * ((int)v15 + v106 * v34));
          *(int8x8_t *)&v107.u32[2] = vqtbl1_s8((int8x16_t)v103, (int8x8_t)*(_OWORD *)&vextq_s8(v108, v108, 8uLL));
          int32x4_t v112 = (int32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgeq_f32(v107, v98));
          float32x4_t v113 = vmulq_lane_f32(vsubq_f32(v84, v47), *(float32x2_t *)v103.f32, 1);
          float32x4_t v114 = vmulq_n_f32(vsubq_f32(v111, v95), v103.f32[0]);
          float32x4_t v115 = vmulq_n_f32(vsubq_f32(v110, v102), v103.f32[0]);
          float32x4_t v116 = vmulq_laneq_f32(vsubq_f32(v102, v47), v103, 2);
          float32x4_t v117 = vmulq_lane_f32(vsubq_f32(v111, v110), *(float32x2_t *)v103.f32, 1);
          float32x4_t v118 = vmulq_lane_f32(vsubq_f32(v95, v102), *(float32x2_t *)v103.f32, 1);
          int8x16_t v119 = (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v95, v84), v103, 2), vaddq_f32(v114, v113));
          float32x4_t v120 = vmulq_n_f32(vsubq_f32(v57, v47), v103.f32[0]);
          float32x4_t v121 = vaddq_f32(v120, vmulq_lane_f32(vsubq_f32(v74, v57), *(float32x2_t *)v103.f32, 1));
          float32x4_t v122 = vmulq_laneq_f32(vsubq_f32(v111, v74), v103, 2);
          float32x4_t v123 = vaddq_f32(vmulq_n_f32(vsubq_f32(v74, v84), v103.f32[0]), v113);
          float32x4_t v124 = (float32x4_t)vdupq_laneq_s32(v112, 2);
          *(int8x16_t *)(*(void *)&v8 + v13) = vbslq_s8((int8x16_t)vcgtq_f32(v21, v19), (int8x16_t)v14, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), vmulq_laneq_f32(vaddq_f32(v47, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v112, 3), v124), v21), (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v110, v57), v103, 2), vaddq_f32(v120, v117)),
                                                                                   vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32(v124, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v104.f32, 0)), v21), (int8x16_t)vaddq_f32(v122, v123), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v109, 3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v112.i8, 1)), v21), (int8x16_t)vaddq_f32(v122, v121), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v112.i8, 0), (float32x4_t)vdupq_laneq_s32(v109, 2)), v21), (int8x16_t)vaddq_f32(v116, vaddq_f32(v114, v118)), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v109.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v109.i8, 1)), v21), (int8x16_t)vaddq_f32(v116, vaddq_f32(v115, v117)), v119)))))), v16,
                                                                  2)));
          v13 += 16;
        }
        while (v11 != v13);
        ++v5;
        *(void *)&v7 += v9;
        *(void *)&v8 += v10;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::GetDOD(HgcApply3DLUTTetrahedral_basekernel *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 2 || a3 == 1) {
    return 0x8000000080000000;
  }
  if (a3) {
    return 0;
  }
  return *(void *)&a4.var0;
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::GetROI(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 == 2 || a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, a3);
    return HGRenderer::GetDOD(a2, Input);
  }
  else
  {
    if (a3) {
      *(void *)&a4.var0 = 0;
    }
    return *(void *)&a4.var0;
  }
}

void HgcApply3DLUTTetrahedral_basekernel::HgcApply3DLUTTetrahedral_basekernel(HgcApply3DLUTTetrahedral_basekernel *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F37B0;
  operator new();
}

void sub_1B7923FD4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTetrahedral_basekernel::~HgcApply3DLUTTetrahedral_basekernel(HGNode *this)
{
  *(void *)this = &unk_1F10F37B0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F37B0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F37B0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::SetParameter(HgcApply3DLUTTetrahedral_basekernel *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int32x2_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int32x2_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcApply3DLUTTetrahedral_basekernel::GetParameter(HgcApply3DLUTTetrahedral_basekernel *this, unsigned int a2, float *a3)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcApply3DLUTTrilinear_basekernel::GetProgram(HgcApply3DLUTTrilinear_basekernel *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return aMetal10Len0000_1172;
    }
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000ea9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = r1.xyz*r1.xyz;\n"
             "    r3.xyz = r2.xyz*r1.xyz;\n"
             "    r4.xyz = r1.xyz*hg_Params[3].yyy + hg_Params[3].xxx;\n"
             "    r4.xyz = r2.xyz*hg_Params[3].zzz + r4.xyz;\n"
             "    r4.xyz = r3.xyz*hg_Params[3].www + r4.xyz;\n"
             "    r4.xyz = fmax(r4.xyz, c0.xxx);\n"
             "    r2.xyz = hg_Params[1].yyy - c0.yyy;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = floor(r4.xyz);\n"
             "    r3.xyz = r4.xyz + c0.yyy;\n"
             "    r3.xyz = fmin(r3.xyz, r2.xyz);\n"
             "    r3.xyz = r3.xyz - r4.xyz;\n"
             "    r3.xyz = r3.xyz*hg_Params[1].xyz;\n"
             "    r2.x = dot(r4.xy, hg_Params[1].xy);\n"
             "    r2.y = r4.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r5.xy = r2.xy + hg_Params[4].xy;\n"
             "    r5.xy = r5.xy*hg_Params[4].zw;\n"
             "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
             "    r2.x = r2.x + r3.x;\n"
             "    r6.xy = r2.xy + hg_Params[4].xy;\n"
             "    r6.xy = r6.xy*hg_Params[4].zw;\n"
             "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
             "    r2.x = r2.x + r3.y;\n"
             "    r7.xy = r2.xy + hg_Params[4].xy;\n"
             "    r7.xy = r7.xy*hg_Params[4].zw;\n"
             "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
             "    r2.x = r2.x - r3.x;\n"
             "    r8.xy = r2.xy + hg_Params[4].xy;\n"
             "    r8.xy = r8.xy*hg_Params[4].zw;\n"
             "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
             "    r2.y = r2.y + r3.z;\n"
             "    r9.xy = r2.xy + hg_Params[4].xy;\n"
             "    r9.xy = r9.xy*hg_Params[4].zw;\n"
             "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
             "    r2.x = r2.x - r3.y;\n"
             "    r10.xy = r2.xy + hg_Params[4].xy;\n"
             "    r10.xy = r10.xy*hg_Params[4].zw;\n"
             "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
             "    r2.x = r2.x + r3.x;\n"
             "    r11.xy = r2.xy + hg_Params[4].xy;\n"
             "    r11.xy = r11.xy*hg_Params[4].zw;\n"
             "    r11 = hg_Texture1.sample(hg_Sampler1, r11.xy);\n"
             "    r2.x = r2.x + r3.y;\n"
             "    r2.xy = r2.xy + hg_Params[4].xy;\n"
             "    r2.xy = r2.xy*hg_Params[4].zw;\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
             "    r4.xyz = r4.xyz + c0.zzz;\n"
             "    r3.y = c0.z;\n"
             "    r3.x = r4.x;\n"
             "    r12.xy = r3.xy + hg_Params[5].xy;\n"
             "    r12.xy = r12.xy*hg_Params[5].zw;\n"
             "    r12.xy = hg_Texture2.sample(hg_Sampler2, r12.xy).xy;\n"
             "    r13.x = r12.x;\n"
             "    r12.x = r12.y;\n"
             "    r3.x = r4.y;\n"
             "    r14.xy = r3.xy + hg_Params[5].xy;\n"
             "    r14.xy = r14.xy*hg_Params[5].zw;\n"
             "    r14.xy = hg_Texture2.sample(hg_Sampler2, r14.xy).xy;\n"
             "    r13.y = r14.x;\n"
             "    r12.y = r14.y;\n"
             "    r3.x = r4.z;\n"
             "    r3.xy = r3.xy + hg_Params[5].xy;\n"
             "    r3.xy = r3.xy*hg_Params[5].zw;\n"
             "    r3.xy = hg_Texture2.sample(hg_Sampler2, r3.xy).xy;\n"
             "    r13.z = r3.x;\n"
             "    r12.z = r3.y;\n"
             "    r14.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r14.xyz = r14.xyz - r13.xyz;\n"
             "    r14.xyz = r14.xyz*r12.xyz;\n"
             "    r1.xyz = r1.xyz - c0.yyy;\n"
             "    r14.xyz = select(c0.xxx, r14.xyz, r1.xyz < 0.00000f);\n"
             "    r5 = mix(r5, r6, r14.xxxx);\n"
             "    r8 = mix(r8, r7, r14.xxxx);\n"
             "    r10 = mix(r10, r11, r14.xxxx);\n"
             "    r9 = mix(r9, r2, r14.xxxx);\n"
             "    r5 = mix(r5, r8, r14.yyyy);\n"
             "    r10 = mix(r10, r9, r14.yyyy);\n"
             "    r14 = mix(r5, r10, r14.zzzz);\n"
             "    r14 = r14*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
             "    output.color0 = select(r14, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d69a83c9:92974476:ebb55401:991c55ef\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0006:000f:0000:0000:0000:0002:0000:0001:03:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_439;
  }
}

void HgcApply3DLUTTrilinear_basekernel::InitProgramDescriptor(HgcApply3DLUTTrilinear_basekernel *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcApply3DLUTTrilinear_basekernel_hgc_visible", "//Metal1.0     \n//LEN=0000000d50\n[[ visible ]] FragmentOut HgcApply3DLUTTrilinear_basekernel_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1, \n    texture2d< float > hg_Texture2, \n    sampler hg_Sampler2)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = r1.xyz*r1.xyz;\n"
    "    r3.xyz = r2.xyz*r1.xyz;\n"
    "    r4.xyz = r1.xyz*hg_Params[3].yyy + hg_Params[3].xxx;\n"
    "    r4.xyz = r2.xyz*hg_Params[3].zzz + r4.xyz;\n"
    "    r4.xyz = r3.xyz*hg_Params[3].www + r4.xyz;\n"
    "    r4.xyz = fmax(r4.xyz, c0.xxx);\n"
    "    r2.xyz = hg_Params[1].yyy - c0.yyy;\n"
    "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
    "    r4.xyz = floor(r4.xyz);\n"
    "    r3.xyz = r4.xyz + c0.yyy;\n"
    "    r3.xyz = fmin(r3.xyz, r2.xyz);\n"
    "    r3.xyz = r3.xyz - r4.xyz;\n"
    "    r3.xyz = r3.xyz*hg_Params[1].xyz;\n"
    "    r2.x = dot(r4.xy, hg_Params[1].xy);\n"
    "    r2.y = r4.z;\n"
    "    r2.xy = r2.xy + c0.zz;\n"
    "    r5.xy = r2.xy + hg_Params[4].xy;\n"
    "    r5.xy = r5.xy*hg_Params[4].zw;\n"
    "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
    "    r2.x = r2.x + r3.x;\n"
    "    r6.xy = r2.xy + hg_Params[4].xy;\n"
    "    r6.xy = r6.xy*hg_Params[4].zw;\n"
    "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
    "    r2.x = r2.x + r3.y;\n"
    "    r7.xy = r2.xy + hg_Params[4].xy;\n"
    "    r7.xy = r7.xy*hg_Params[4].zw;\n"
    "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
    "    r2.x = r2.x - r3.x;\n"
    "    r8.xy = r2.xy + hg_Params[4].xy;\n"
    "    r8.xy = r8.xy*hg_Params[4].zw;\n"
    "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
    "    r2.y = r2.y + r3.z;\n"
    "    r9.xy = r2.xy + hg_Params[4].xy;\n"
    "    r9.xy = r9.xy*hg_Params[4].zw;\n"
    "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
    "    r2.x = r2.x - r3.y;\n"
    "    r10.xy = r2.xy + hg_Params[4].xy;\n"
    "    r10.xy = r10.xy*hg_Params[4].zw;\n"
    "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
    "    r2.x = r2.x + r3.x;\n"
    "    r11.xy = r2.xy + hg_Params[4].xy;\n"
    "    r11.xy = r11.xy*hg_Params[4].zw;\n"
    "    r11 = hg_Texture1.sample(hg_Sampler1, r11.xy);\n"
    "    r2.x = r2.x + r3.y;\n"
    "    r2.xy = r2.xy + hg_Params[4].xy;\n"
    "    r2.xy = r2.xy*hg_Params[4].zw;\n"
    "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
    "    r4.xyz = r4.xyz + c0.zzz;\n"
    "    r3.y = c0.z;\n"
    "    r3.x = r4.x;\n"
    "    r12.xy = r3.xy + hg_Params[5].xy;\n"
    "    r12.xy = r12.xy*hg_Params[5].zw;\n"
    "    r12.xy = hg_Texture2.sample(hg_Sampler2, r12.xy).xy;\n"
    "    r13.x = r12.x;\n"
    "    r12.x = r12.y;\n"
    "    r3.x = r4.y;\n"
    "    r14.xy = r3.xy + hg_Params[5].xy;\n"
    "    r14.xy = r14.xy*hg_Params[5].zw;\n"
    "    r14.xy = hg_Texture2.sample(hg_Sampler2, r14.xy).xy;\n"
    "    r13.y = r14.x;\n"
    "    r12.y = r14.y;\n"
    "    r3.x = r4.z;\n"
    "    r3.xy = r3.xy + hg_Params[5].xy;\n"
    "    r3.xy = r3.xy*hg_Params[5].zw;\n"
    "    r3.xy = hg_Texture2.sample(hg_Sampler2, r3.xy).xy;\n"
    "    r13.z = r3.x;\n"
    "    r12.z = r3.y;\n"
    "    r14.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r14.xyz = r14.xyz - r13.xyz;\n"
    "    r14.xyz = r14.xyz*r12.xyz;\n"
    "    r1.xyz = r1.xyz - c0.yyy;\n"
    "    r14.xyz = select(c0.xxx, r14.xyz, r1.xyz < 0.00000f);\n"
    "    r5 = mix(r5, r6, r14.xxxx);\n"
    "    r8 = mix(r8, r7, r14.xxxx);\n"
    "    r10 = mix(r10, r11, r14.xxxx);\n"
    "    r9 = mix(r9, r2, r14.xxxx);\n"
    "    r5 = mix(r5, r8, r14.yyyy);\n"
    "    r10 = mix(r10, r9, r14.yyyy);\n"
    "    r14 = mix(r5, r10, r14.zzzz);\n"
    "    r14 = r14*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
    "    output.color0 = select(r14, r0, hg_Params[2] < 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcApply3DLUTTrilinear_basekernel");
}

void sub_1B792473C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a23);
  _Unwind_Resume(a1);
}

void sub_1B792477C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7924774);
}

char *HgcApply3DLUTTrilinear_basekernel::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x30uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375DA0;
  strcpy(result, "HgcApply3DLUTTrilinear_basekernel [hgc1]");
  return result;
}

uint64_t HgcApply3DLUTTrilinear_basekernel::BindTexture(HgcApply3DLUTTrilinear_basekernel *this, HGHandler *a2, int a3)
{
  if (a3 == 2)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 5, v6, v7, v8, v9);
    return 0;
  }
  else if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
    {
      v12.n128_u32[0] = 1.0;
      v13.n128_u32[0] = 1.0;
    }
    else
    {
      v12.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v13.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v10.n128_f32[0] = (float)*((int *)a2 + 60);
    v11.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 4, v10, v11, v12, v13);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v4 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcApply3DLUTTrilinear_basekernel::Bind(HgcApply3DLUTTrilinear_basekernel *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcApply3DLUTTrilinear_basekernel::RenderTile(HgcApply3DLUTTrilinear_basekernel *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      int v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      int32x2_t v7 = a2[10];
      int32x2_t v8 = a2[2];
      uint64_t v9 = 16 * a2[11].i32[0];
      uint64_t v10 = 16 * a2[3].i32[0];
      uint64_t v11 = 16 * v4;
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      do
      {
        uint64_t v13 = 0;
        do
        {
          float32x4_t v14 = *(float32x4_t *)(*(void *)&v7 + v13);
          float32x4_t v15 = (_OWORD *)*((void *)this + 51);
          float32x4_t v16 = *(float32x4_t *)v15;
          float32x4_t v17 = *((float32x4_t *)v15 + 1);
          float32x4_t v18 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15, 1), vmulq_n_f32(v14, COERCE_FLOAT(*v15)));
          float32x4_t v19 = *((float32x4_t *)v15 + 2);
          float32x4_t v20 = vmulq_f32(v18, v18);
          float32x4_t v21 = vaddq_f32(vaddq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v15[3], 0), vmulq_lane_f32(v18, (float32x2_t)v15[3], 1)), vmulq_laneq_f32(v20, *((float32x4_t *)v15 + 3), 2)), vmulq_laneq_f32(vmulq_f32(v18, v20), *((float32x4_t *)v15 + 3), 3));
          float32x4_t v22 = *((float32x4_t *)v15 + 4);
          float32x4_t v23 = *((float32x4_t *)v15 + 5);
          float32x4_t v24 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1), v23);
          float32x4_t v25 = vminq_f32(vmaxq_f32(v21, v22), v24);
          float32x4_t v26 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
          float32x4_t v27 = vsubq_f32(v26, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v26, v25)));
          float32x4_t v28 = vmulq_f32(v17, v27);
          int8x16_t v29 = (int8x16_t)vaddq_f32(v28, (float32x4_t)vrev64q_s32((int32x4_t)v28));
          int8x16_t v30 = *((int8x16_t *)v15 + 6);
          float32x4_t v31 = *((float32x4_t *)v15 + 7);
          float32x4_t v32 = vmulq_f32(v17, vsubq_f32(vminq_f32(vaddq_f32(v23, v27), v24), v27));
          float32x4_t v33 = vaddq_f32(v31, (float32x4_t)vbslq_s8(v30, v29, vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL)));
          int32x2_t v34 = a2[12];
          __int32 v35 = a2[13].i32[0];
          float32x4_t v36 = vaddq_f32(vsubq_f32(v33, v6), v12);
          int32x4_t v37 = vcvtq_s32_f32(v36);
          v36.i64[0] = vaddq_s32(v37, vcgtq_f32(vcvtq_f32_s32(v37), v36)).u64[0];
          __int32 v38 = v36.i32[1];
          float32x4_t v39 = (float32x4_t)vbslq_s8(v30, (int8x16_t)vaddq_f32(v32, v33), (int8x16_t)v33);
          __int32 v40 = v36.i32[0];
          float32x4_t v41 = vaddq_f32(vsubq_f32(v39, v6), v12);
          int32x4_t v42 = vcvtq_s32_f32(v41);
          v41.i64[0] = vaddq_s32(v42, vcgtq_f32(vcvtq_f32_s32(v42), v41)).u64[0];
          __int32 v43 = v40 + v38 * v35;
          __int32 v44 = v41.i32[1];
          __int32 v45 = v41.i32[0];
          float32x4_t v46 = (float32x4_t)vrev64q_s32((int32x4_t)v32);
          float32x4_t v47 = *(float32x4_t *)(*(void *)&v34 + 16 * v43);
          float32x4_t v48 = (float32x4_t)vbslq_s8(v30, (int8x16_t)vaddq_f32(v46, v39), (int8x16_t)v33);
          float32x4_t v49 = vaddq_f32(vsubq_f32(v48, v6), v12);
          int32x4_t v50 = vcvtq_s32_f32(v49);
          __int32 v51 = v45 + v44 * v35;
          v49.i64[0] = vaddq_s32(v50, vcgtq_f32(vcvtq_f32_s32(v50), v49)).u64[0];
          int8x16_t v52 = (int8x16_t)vsubq_f32(v48, v32);
          __int32 v53 = v49.i32[1];
          float32x4_t v54 = (float32x4_t)vbslq_s8(v30, v52, (int8x16_t)v33);
          float32x4_t v55 = vaddq_f32(vsubq_f32(v54, v6), v12);
          int32x4_t v56 = vcvtq_s32_f32(v55);
          __int32 v57 = v49.i32[0];
          int32x4_t v58 = vcgtq_f32(vcvtq_f32_s32(v56), v55);
          int8x16_t v59 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v32, (int8x16_t)v32, 4uLL), v54);
          float32x4_t v60 = (float32x4_t)vbslq_s8(v30, v52, v59);
          float32x4_t v61 = *(float32x4_t *)(*(void *)&v34 + 16 * v51);
          float32x4_t v62 = vaddq_f32(vsubq_f32(v60, v6), v12);
          int32x4_t v63 = (int32x4_t)vaddq_f32(v31, v27);
          v58.i64[0] = vaddq_s32(v56, v58).u64[0];
          float32x4_t v64 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v30, (int8x16_t)v63, (int8x16_t)v31), v6), v12);
          int32x4_t v65 = vcvtq_s32_f32(v64);
          int32x4_t v66 = vcvtq_s32_f32(v62);
          __int32 v67 = v57 + v53 * v35;
          v64.i64[0] = vaddq_s32(v65, vcgtq_f32(vcvtq_f32_s32(v65), v64)).u64[0];
          __int32 v68 = v64.i32[1];
          __int32 v69 = v64.i32[0];
          __int32 v70 = v58.i32[1];
          float32x4_t v71 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v30, (int8x16_t)vrev64q_s32(v63), (int8x16_t)v31), v6), v12);
          int32x4_t v72 = vcvtq_s32_f32(v71);
          __int32 v73 = v58.i32[0];
          __int32 v74 = a2[15].i32[0];
          __int32 v75 = v69 + v68 * v74;
          v58.i64[0] = vaddq_s32(v72, vcgtq_f32(vcvtq_f32_s32(v72), v71)).u64[0];
          __int32 v76 = v58.i32[1];
          __int32 v77 = v58.i32[0];
          float32x4_t v78 = *(float32x4_t *)(*(void *)&v34 + 16 * v67);
          float32x4_t v79 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v30, vextq_s8((int8x16_t)v63, (int8x16_t)v63, 8uLL), (int8x16_t)v31), v6), v12);
          int32x4_t v80 = vcvtq_s32_f32(v79);
          v71.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v62)).u64[0];
          v79.i64[0] = vaddq_s32(v80, vcgtq_f32(vcvtq_f32_s32(v80), v79)).u64[0];
          __int32 v81 = v73 + v70 * v35;
          __int32 v82 = v77 + v76 * v74;
          __int32 v83 = v79.i32[0] + v79.i32[1] * v74;
          __int32 v84 = v71.i32[1];
          __int32 v85 = v71.i32[0];
          float32x4_t v86 = (float32x4_t)vbslq_s8(v30, (int8x16_t)vsubq_f32(v60, v46), v59);
          float32x4_t v87 = vaddq_f32(vsubq_f32(v86, v6), v12);
          float32x4_t v88 = *(float32x4_t *)(*(void *)&v34 + 16 * v81);
          int32x4_t v89 = vcvtq_s32_f32(v87);
          v87.i64[0] = vaddq_s32(v89, vcgtq_f32(vcvtq_f32_s32(v89), v87)).u64[0];
          __int32 v90 = v87.i32[1];
          __int32 v91 = v85 + v84 * v35;
          __int32 v92 = v87.i32[0];
          float32x4_t v93 = (float32x4_t)vbslq_s8(v30, (int8x16_t)vaddq_f32(v32, v86), v59);
          float32x4_t v94 = *(float32x4_t *)(*(void *)&v34 + 16 * v91);
          float32x4_t v95 = vaddq_f32(vsubq_f32(v93, v6), v12);
          int32x4_t v96 = vcvtq_s32_f32(v95);
          v95.i64[0] = vaddq_s32(v96, vcgtq_f32(vcvtq_f32_s32(v96), v95)).u64[0];
          int32x2_t v97 = a2[14];
          int32x4_t v98 = *(int32x4_t *)(*(void *)&v97 + 16 * v75);
          __int32 v99 = v95.i32[1];
          int32x4_t v100 = *(int32x4_t *)(*(void *)&v97 + 16 * v82);
          __int32 v101 = v95.i32[0];
          float32x4_t v102 = *(float32x4_t *)(*(void *)&v34 + 16 * (v92 + v90 * v35));
          float32x4_t v103 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v30, (int8x16_t)vaddq_f32(v46, v93), v59), v6), v12);
          int32x4_t v104 = vcvtq_s32_f32(v103);
          v103.i64[0] = vaddq_s32(v104, vcgtq_f32(vcvtq_f32_s32(v104), v103)).u64[0];
          v46.i64[0] = vbslq_s8(v30, (int8x16_t)vrev64q_s32(v98), (int8x16_t)v100).u64[0];
          *(int8x8_t *)v17.f32 = vorr_s8(vand_s8((int8x8_t)*(_OWORD *)&vrev64q_s32(v100), (int8x8_t)*(_OWORD *)&vmvnq_s8(v30)), vand_s8(*(int8x8_t *)v30.i8, *(int8x8_t *)v98.i8));
          v17.i64[1] = *(void *)(*(void *)&v97 + 16 * v83);
          float32x4_t v105 = (float32x4_t)vextq_s8((int8x16_t)v6, *(int8x16_t *)(*(void *)&v97 + 16 * v83), 0xCuLL);
          v105.i64[0] = v46.i64[0];
          float32x4_t v106 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v22, vsubq_f32(v18, v23)), (int8x16_t)vmulq_f32(v105, vsubq_f32(vmaxq_f32(v18, v22), v17)), (int8x16_t)v22);
          float32x4_t v107 = vaddq_f32(v47, vmulq_n_f32(vsubq_f32(v61, v47), v106.f32[0]));
          float32x4_t v108 = vaddq_f32(v102, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v34 + 16 * (v101 + v99 * v35)), v102), v106.f32[0]));
          float32x4_t v109 = vaddq_f32(v107, vmulq_lane_f32(vsubq_f32(vaddq_f32(v88, vmulq_n_f32(vsubq_f32(v78, v88), v106.f32[0])), v107), *(float32x2_t *)v106.f32, 1));
          *(int8x16_t *)(*(void *)&v8 + v13) = vbslq_s8((int8x16_t)vcgtq_f32(v22, v19), (int8x16_t)v14, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), vmulq_laneq_f32(vaddq_f32(v109, vmulq_laneq_f32(vsubq_f32(vaddq_f32(v108, vmulq_lane_f32(vsubq_f32(vaddq_f32(v94, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v34 + 16 * (v103.i32[0] + v103.i32[1] * v35)), v94),
                                                                                  v106.f32[0])),
                                                                              v108),
                                                                            *(float32x2_t *)v106.f32,
                                                                            1)),
                                                                        v109),
                                                                      v106,
                                                                      2)),
                                                                  v16,
                                                                  2)));
          v13 += 16;
        }
        while (v11 != v13);
        ++v5;
        *(void *)&v7 += v9;
        *(void *)&v8 += v10;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcApply3DLUTTrilinear_basekernel::GetDOD(HgcApply3DLUTTrilinear_basekernel *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 2 || a3 == 1) {
    return 0x8000000080000000;
  }
  if (a3) {
    return 0;
  }
  return *(void *)&a4.var0;
}

uint64_t HgcApply3DLUTTrilinear_basekernel::GetROI(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 == 2 || a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, a3);
    return HGRenderer::GetDOD(a2, Input);
  }
  else
  {
    if (a3) {
      *(void *)&a4.var0 = 0;
    }
    return *(void *)&a4.var0;
  }
}

void HgcApply3DLUTTrilinear_basekernel::HgcApply3DLUTTrilinear_basekernel(HgcApply3DLUTTrilinear_basekernel *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F3A18;
  operator new();
}

void sub_1B792522C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTrilinear_basekernel::~HgcApply3DLUTTrilinear_basekernel(HGNode *this)
{
  *(void *)this = &unk_1F10F3A18;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F3A18;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F3A18;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcApply3DLUTTrilinear_basekernel::SetParameter(HgcApply3DLUTTrilinear_basekernel *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int32x2_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int32x2_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcApply3DLUTTrilinear_basekernel::GetParameter(HgcApply3DLUTTrilinear_basekernel *this, unsigned int a2, float *a3)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcApply3DLUTTrilinearUniform_basekernel::GetProgram(HgcApply3DLUTTrilinearUniform_basekernel *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000ba7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = half3(hg_Params[1].yyy) - c0.xxx;\n"
             "    r1.xyz = r1.xyz*r2.xyz;\n"
             "    r1.xyz = fmax(r1.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
             "    r3.xyz = fract(r1.xyz);\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r4.xyz = r1.xyz + c0.xxx;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = r4.xyz - r1.xyz;\n"
             "    r4.xyz = r4.xyz*half3(hg_Params[1].xyz);\n"
             "    r2.x = dot(r1.xy, half2(hg_Params[1].xy));\n"
             "    r2.y = r1.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r1.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r1.xy = r1.xy*half2(hg_Params[3].zw);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r1.xy));\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r5.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r5.xy = r5.xy*half2(hg_Params[3].zw);\n"
             "    r5 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r5.xy));\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r6.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r6.xy = r6.xy*half2(hg_Params[3].zw);\n"
             "    r6 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r6.xy));\n"
             "    r2.x = r2.x - r4.x;\n"
             "    r7.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r7.xy = r7.xy*half2(hg_Params[3].zw);\n"
             "    r7 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r7.xy));\n"
             "    r2.y = r2.y + r4.z;\n"
             "    r8.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r8.xy = r8.xy*half2(hg_Params[3].zw);\n"
             "    r8 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r8.xy));\n"
             "    r2.x = r2.x - r4.y;\n"
             "    r9.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r9.xy = r9.xy*half2(hg_Params[3].zw);\n"
             "    r9 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r9.xy));\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r10.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r10.xy = r10.xy*half2(hg_Params[3].zw);\n"
             "    r10 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r10.xy));\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r2.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r2.xy = r2.xy*half2(hg_Params[3].zw);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r2.xy));\n"
             "    r1 = mix(r1, r5, r3.xxxx);\n"
             "    r7 = mix(r7, r6, r3.xxxx);\n"
             "    r9 = mix(r9, r10, r3.xxxx);\n"
             "    r8 = mix(r8, r2, r3.xxxx);\n"
             "    r1 = mix(r1, r7, r3.yyyy);\n"
             "    r9 = mix(r9, r8, r3.yyyy);\n"
             "    r3 = mix(r1, r9, r3.zzzz);\n"
             "    r3 = r3*half4(hg_Params[0].zzzz) + half4(hg_Params[0].wwww);\n"
             "    output.color0 = select(float4(r3), float4(r0), hg_Params[2] < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=4a246928:7d77d0f6:04f061a8:55d417f5\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0004:000b:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000a73\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = hg_Params[1].yyy - c0.xxx;\n"
             "    r1.xyz = r1.xyz*r2.xyz;\n"
             "    r1.xyz = fmax(r1.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
             "    r3.xyz = fract(r1.xyz);\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r4.xyz = r1.xyz + c0.xxx;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = r4.xyz - r1.xyz;\n"
             "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
             "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
             "    r2.y = r1.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r1.xy = r2.xy + hg_Params[3].xy;\n"
             "    r1.xy = r1.xy*hg_Params[3].zw;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r5.xy = r2.xy + hg_Params[3].xy;\n"
             "    r5.xy = r5.xy*hg_Params[3].zw;\n"
             "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r6.xy = r2.xy + hg_Params[3].xy;\n"
             "    r6.xy = r6.xy*hg_Params[3].zw;\n"
             "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
             "    r2.x = r2.x - r4.x;\n"
             "    r7.xy = r2.xy + hg_Params[3].xy;\n"
             "    r7.xy = r7.xy*hg_Params[3].zw;\n"
             "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
             "    r2.y = r2.y + r4.z;\n"
             "    r8.xy = r2.xy + hg_Params[3].xy;\n"
             "    r8.xy = r8.xy*hg_Params[3].zw;\n"
             "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
             "    r2.x = r2.x - r4.y;\n"
             "    r9.xy = r2.xy + hg_Params[3].xy;\n"
             "    r9.xy = r9.xy*hg_Params[3].zw;\n"
             "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r10.xy = r2.xy + hg_Params[3].xy;\n"
             "    r10.xy = r10.xy*hg_Params[3].zw;\n"
             "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r2.xy = r2.xy + hg_Params[3].xy;\n"
             "    r2.xy = r2.xy*hg_Params[3].zw;\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
             "    r1 = mix(r1, r5, r3.xxxx);\n"
             "    r7 = mix(r7, r6, r3.xxxx);\n"
             "    r9 = mix(r9, r10, r3.xxxx);\n"
             "    r8 = mix(r8, r2, r3.xxxx);\n"
             "    r1 = mix(r1, r7, r3.yyyy);\n"
             "    r9 = mix(r9, r8, r3.yyyy);\n"
             "    r3 = mix(r1, r9, r3.zzzz);\n"
             "    r3 = r3*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
             "    output.color0 = select(r3, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f2a8ef5a:d246eef6:2592a446:679ba2ae\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:000b:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000b19\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = hg_ProgramLocal1.yyy - c0.xxx;\n"
           "    r1.xyz = r1.xyz*r2.xyz;\n"
           "    r1.xyz = max(r1.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, r2.xyz);\n"
           "    r3.xyz = fract(r1.xyz);\n"
           "    r1.xyz = floor(r1.xyz);\n"
           "    r4.xyz = r1.xyz + c0.xxx;\n"
           "    r4.xyz = min(r4.xyz, r2.xyz);\n"
           "    r4.xyz = r4.xyz - r1.xyz;\n"
           "    r4.xyz = r4.xyz*hg_ProgramLocal1.xyz;\n"
           "    r2.x = dot(r1.xy, hg_ProgramLocal1.xy);\n"
           "    r2.y = r1.z;\n"
           "    r2.xy = r2.xy + c0.zz;\n"
           "    r1.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal3.zw;\n"
           "    r1 = texture2D(hg_Texture1, r1.xy);\n"
           "    r2.x = r2.x + r4.x;\n"
           "    r5.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r5.xy = r5.xy*hg_ProgramLocal3.zw;\n"
           "    r5 = texture2D(hg_Texture1, r5.xy);\n"
           "    r2.x = r2.x + r4.y;\n"
           "    r6.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r6.xy = r6.xy*hg_ProgramLocal3.zw;\n"
           "    r6 = texture2D(hg_Texture1, r6.xy);\n"
           "    r2.x = r2.x - r4.x;\n"
           "    r7.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r7.xy = r7.xy*hg_ProgramLocal3.zw;\n"
           "    r7 = texture2D(hg_Texture1, r7.xy);\n"
           "    r2.y = r2.y + r4.z;\n"
           "    r8.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r8.xy = r8.xy*hg_ProgramLocal3.zw;\n"
           "    r8 = texture2D(hg_Texture1, r8.xy);\n"
           "    r2.x = r2.x - r4.y;\n"
           "    r9.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal3.zw;\n"
           "    r9 = texture2D(hg_Texture1, r9.xy);\n"
           "    r2.x = r2.x + r4.x;\n"
           "    r10.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r10.xy = r10.xy*hg_ProgramLocal3.zw;\n"
           "    r10 = texture2D(hg_Texture1, r10.xy);\n"
           "    r2.x = r2.x + r4.y;\n"
           "    r2.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal3.zw;\n"
           "    r2 = texture2D(hg_Texture1, r2.xy);\n"
           "    r1 = mix(r1, r5, r3.xxxx);\n"
           "    r7 = mix(r7, r6, r3.xxxx);\n"
           "    r9 = mix(r9, r10, r3.xxxx);\n"
           "    r8 = mix(r8, r2, r3.xxxx);\n"
           "    r1 = mix(r1, r7, r3.yyyy);\n"
           "    r9 = mix(r9, r8, r3.yyyy);\n"
           "    r3 = mix(r1, r9, r3.zzzz);\n"
           "    r3 = r3*hg_ProgramLocal0.zzzz + hg_ProgramLocal0.wwww;\n"
           "    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r3.x, hg_ProgramLocal2.y < 0.00000 ? r0.y : r3."
           "y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r3.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r3.w);\n"
           "}\n"
           "//MD5=66dd5ce0:835ac03a:cf594cc7:10f7ddbe\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0004:000b:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
  }
}

void HgcApply3DLUTTrilinearUniform_basekernel::InitProgramDescriptor(HgcApply3DLUTTrilinearUniform_basekernel *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcApply3DLUTTrilinearUniform_basekernel_hgc_visible", "//Metal1.0     \n//LEN=0000000943\n[[ visible ]] FragmentOut HgcApply3DLUTTrilinearUniform_basekernel_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = hg_Params[1].yyy - c0.xxx;\n"
    "    r1.xyz = r1.xyz*r2.xyz;\n"
    "    r1.xyz = fmax(r1.xyz, c0.yyy);\n"
    "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
    "    r3.xyz = fract(r1.xyz);\n"
    "    r1.xyz = floor(r1.xyz);\n"
    "    r4.xyz = r1.xyz + c0.xxx;\n"
    "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
    "    r4.xyz = r4.xyz - r1.xyz;\n"
    "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
    "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
    "    r2.y = r1.z;\n"
    "    r2.xy = r2.xy + c0.zz;\n"
    "    r1.xy = r2.xy + hg_Params[3].xy;\n"
    "    r1.xy = r1.xy*hg_Params[3].zw;\n"
    "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r5.xy = r2.xy + hg_Params[3].xy;\n"
    "    r5.xy = r5.xy*hg_Params[3].zw;\n"
    "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r6.xy = r2.xy + hg_Params[3].xy;\n"
    "    r6.xy = r6.xy*hg_Params[3].zw;\n"
    "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
    "    r2.x = r2.x - r4.x;\n"
    "    r7.xy = r2.xy + hg_Params[3].xy;\n"
    "    r7.xy = r7.xy*hg_Params[3].zw;\n"
    "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
    "    r2.y = r2.y + r4.z;\n"
    "    r8.xy = r2.xy + hg_Params[3].xy;\n"
    "    r8.xy = r8.xy*hg_Params[3].zw;\n"
    "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
    "    r2.x = r2.x - r4.y;\n"
    "    r9.xy = r2.xy + hg_Params[3].xy;\n"
    "    r9.xy = r9.xy*hg_Params[3].zw;\n"
    "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r10.xy = r2.xy + hg_Params[3].xy;\n"
    "    r10.xy = r10.xy*hg_Params[3].zw;\n"
    "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r2.xy = r2.xy + hg_Params[3].xy;\n"
    "    r2.xy = r2.xy*hg_Params[3].zw;\n"
    "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
    "    r1 = mix(r1, r5, r3.xxxx);\n"
    "    r7 = mix(r7, r6, r3.xxxx);\n"
    "    r9 = mix(r9, r10, r3.xxxx);\n"
    "    r8 = mix(r8, r2, r3.xxxx);\n"
    "    r1 = mix(r1, r7, r3.yyyy);\n"
    "    r9 = mix(r9, r8, r3.yyyy);\n"
    "    r3 = mix(r1, r9, r3.zzzz);\n"
    "    r3 = r3*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
    "    output.color0 = select(r3, r0, hg_Params[2] < 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcApply3DLUTTrilinearUniform_basekernel");
}

void sub_1B7925868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B79258A0(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7925898);
}

double HgcApply3DLUTTrilinearUniform_basekernel::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x30uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376F10;
  strcpy(v3, "HgcApply3DLUTTrilinearUniform_basekernel [hgc1]");
  return *(double *)"asekernel [hgc1]";
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::BindTexture(HgcApply3DLUTTrilinearUniform_basekernel *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 3, v6, v7, v8, v9);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v4 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::Bind(HgcApply3DLUTTrilinearUniform_basekernel *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::RenderTile(HgcApply3DLUTTrilinearUniform_basekernel *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      int v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      int32x2_t v7 = a2[10];
      int32x2_t v8 = a2[2];
      uint64_t v9 = 16 * a2[11].i32[0];
      uint64_t v10 = 16 * a2[3].i32[0];
      uint64_t v11 = 16 * v4;
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      do
      {
        uint64_t v13 = 0;
        do
        {
          float32x4_t v14 = *(float32x4_t *)(*(void *)&v7 + v13);
          float32x4_t v15 = (_OWORD *)*((void *)this + 51);
          float32x4_t v16 = *(float32x4_t *)v15;
          float32x4_t v17 = *((float32x4_t *)v15 + 1);
          float32x4_t v19 = *((float32x4_t *)v15 + 2);
          float32x4_t v18 = *((float32x4_t *)v15 + 3);
          float32x4_t v20 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1), v18);
          float32x4_t v21 = *((float32x4_t *)v15 + 4);
          int8x16_t v22 = *((int8x16_t *)v15 + 5);
          float32x4_t v23 = vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15, 1), vmulq_n_f32(v14, COERCE_FLOAT(*v15))), v20), v21), v20);
          float32x4_t v24 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
          float32x4_t v25 = vsubq_f32(v24, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v24, v23)));
          float32x4_t v26 = vmulq_f32(v17, vsubq_f32(vminq_f32(vaddq_f32(v18, v25), v20), v25));
          float32x4_t v27 = vmulq_f32(v17, v25);
          float32x4_t v28 = vaddq_f32(*((float32x4_t *)v15 + 6), (float32x4_t)vbslq_s8(v22, (int8x16_t)vaddq_f32(v27, (float32x4_t)vrev64q_s32((int32x4_t)v27)), vextq_s8((int8x16_t)v25, (int8x16_t)v25, 4uLL)));
          int32x2_t v29 = a2[12];
          __int32 v30 = a2[13].i32[0];
          float32x4_t v31 = vaddq_f32(vsubq_f32(v28, v6), v12);
          int32x4_t v32 = vcvtq_s32_f32(v31);
          v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
          float32x4_t v33 = *(float32x4_t *)(*(void *)&v29 + 16 * (v31.i32[0] + v31.i32[1] * v30));
          float32x4_t v34 = (float32x4_t)vbslq_s8(v22, (int8x16_t)vaddq_f32(v26, v28), (int8x16_t)v28);
          float32x4_t v35 = vaddq_f32(vsubq_f32(v34, v6), v12);
          int32x4_t v36 = vcvtq_s32_f32(v35);
          v35.i64[0] = vaddq_s32(v36, vcgtq_f32(vcvtq_f32_s32(v36), v35)).u64[0];
          float32x4_t v37 = (float32x4_t)vrev64q_s32((int32x4_t)v26);
          float32x4_t v38 = (float32x4_t)vbslq_s8(v22, (int8x16_t)vaddq_f32(v37, v34), (int8x16_t)v28);
          float32x4_t v39 = vaddq_f32(vsubq_f32(v38, v6), v12);
          int32x4_t v40 = vcvtq_s32_f32(v39);
          v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
          int8x16_t v41 = (int8x16_t)vsubq_f32(v38, v26);
          float32x4_t v42 = (float32x4_t)vbslq_s8(v22, v41, (int8x16_t)v28);
          float32x4_t v43 = vaddq_f32(vsubq_f32(v42, v6), v12);
          int32x4_t v44 = vcvtq_s32_f32(v43);
          v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
          __int32 v45 = v43.i32[0] + v43.i32[1] * v30;
          int8x16_t v46 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL), v42);
          float32x4_t v47 = (float32x4_t)vbslq_s8(v22, v41, v46);
          float32x4_t v48 = vaddq_f32(vsubq_f32(v47, v6), v12);
          int32x4_t v49 = vcvtq_s32_f32(v48);
          v48.i64[0] = vaddq_s32(v49, vcgtq_f32(vcvtq_f32_s32(v49), v48)).u64[0];
          __int32 v50 = v48.i32[1];
          __int32 v51 = v48.i32[0];
          float32x4_t v52 = (float32x4_t)vbslq_s8(v22, (int8x16_t)vsubq_f32(v47, v37), v46);
          float32x4_t v53 = vaddq_f32(vsubq_f32(v52, v6), v12);
          int32x4_t v54 = vcvtq_s32_f32(v53);
          float32x4_t v55 = *(float32x4_t *)(*(void *)&v29 + 16 * v45);
          __int32 v56 = v51 + v50 * v30;
          v53.i64[0] = vaddq_s32(v54, vcgtq_f32(vcvtq_f32_s32(v54), v53)).u64[0];
          __int32 v57 = v53.i32[1];
          __int32 v58 = v53.i32[0];
          float32x4_t v59 = (float32x4_t)vbslq_s8(v22, (int8x16_t)vaddq_f32(v26, v52), v46);
          float32x4_t v60 = vaddq_f32(vsubq_f32(v59, v6), v12);
          int32x4_t v61 = vcvtq_s32_f32(v60);
          v60.i64[0] = vaddq_s32(v61, vcgtq_f32(vcvtq_f32_s32(v61), v60)).u64[0];
          float32x4_t v62 = *(float32x4_t *)(*(void *)&v29 + 16 * (v58 + v57 * v30));
          float32x4_t v63 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v22, (int8x16_t)vaddq_f32(v37, v59), v46), v6), v12);
          int32x4_t v64 = vcvtq_s32_f32(v63);
          v63.i64[0] = vaddq_s32(v64, vcgtq_f32(vcvtq_f32_s32(v64), v63)).u64[0];
          float32x4_t v65 = vsubq_f32(v23, v25);
          float32x4_t v66 = vaddq_f32(v33, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v29 + 16 * (v35.i32[0] + v35.i32[1] * v30)), v33), v65.f32[0]));
          float32x4_t v67 = vaddq_f32(v62, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v29 + 16 * (v60.i32[0] + v60.i32[1] * v30)), v62), v65.f32[0]));
          float32x4_t v68 = vaddq_f32(v66, vmulq_lane_f32(vsubq_f32(vaddq_f32(v55, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v29 + 16 * (v39.i32[0] + v39.i32[1] * v30)), v55), v65.f32[0])), v66), *(float32x2_t *)v65.f32, 1));
          *(int8x16_t *)(*(void *)&v8 + v13) = vbslq_s8((int8x16_t)vcgtq_f32(v21, v19), (int8x16_t)v14, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), vmulq_laneq_f32(vaddq_f32(v68, vmulq_laneq_f32(vsubq_f32(vaddq_f32(v67, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)(*(void *)&v29+ 16 * v56), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v29 + 16 * (v63.i32[0] + v63.i32[1] * v30)),
                                                                                    *(float32x4_t *)(*(void *)&v29 + 16 * v56)),
                                                                                  v65.f32[0])),
                                                                              v67),
                                                                            *(float32x2_t *)v65.f32,
                                                                            1)),
                                                                        v68),
                                                                      v65,
                                                                      2)),
                                                                  v16,
                                                                  2)));
          v13 += 16;
        }
        while (v11 != v13);
        ++v5;
        *(void *)&v7 += v9;
        *(void *)&v8 += v10;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::GetDOD(HgcApply3DLUTTrilinearUniform_basekernel *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1) {
    return 0x8000000080000000;
  }
  if (a3) {
    return 0;
  }
  return *(void *)&a4.var0;
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, 1u);
    return HGRenderer::GetDOD(a2, Input);
  }
  else if (a3)
  {
    return 0;
  }
  else
  {
    return *(void *)&a4.var0;
  }
}

void HgcApply3DLUTTrilinearUniform_basekernel::HgcApply3DLUTTrilinearUniform_basekernel(HgcApply3DLUTTrilinearUniform_basekernel *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F3C80;
  operator new();
}

void sub_1B79260C0(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTrilinearUniform_basekernel::~HgcApply3DLUTTrilinearUniform_basekernel(HGNode *this)
{
  *(void *)this = &unk_1F10F3C80;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F3C80;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F3C80;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::SetParameter(HgcApply3DLUTTrilinearUniform_basekernel *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int32x2_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int32x2_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcApply3DLUTTrilinearUniform_basekernel::GetParameter(HgcApply3DLUTTrilinearUniform_basekernel *this, unsigned int a2, float *a3)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcApply3DLUTTrilinearFast_basekernel::GetProgram(HgcApply3DLUTTrilinearFast_basekernel *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000c76\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = r1.xyz*r1.xyz;\n"
             "    r3.xyz = r2.xyz*r1.xyz;\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[3].yyy) + half3(hg_Params[3].xxx);\n"
             "    r1.xyz = r2.xyz*half3(hg_Params[3].zzz) + r1.xyz;\n"
             "    r1.xyz = r3.xyz*half3(hg_Params[3].www) + r1.xyz;\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r2.xyz = half3(hg_Params[1].yyy) - c0.yyy;\n"
             "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
             "    r3.xyz = fract(r1.xyz);\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r4.xyz = r1.xyz + c0.yyy;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = r4.xyz - r1.xyz;\n"
             "    r4.xyz = r4.xyz*half3(hg_Params[1].xyz);\n"
             "    r2.x = dot(r1.xy, half2(hg_Params[1].xy));\n"
             "    r2.y = r1.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r1.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r1.xy = r1.xy*half2(hg_Params[4].zw);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r1.xy));\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r5.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r5.xy = r5.xy*half2(hg_Params[4].zw);\n"
             "    r5 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r5.xy));\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r6.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r6.xy = r6.xy*half2(hg_Params[4].zw);\n"
             "    r6 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r6.xy));\n"
             "    r2.x = r2.x - r4.x;\n"
             "    r7.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r7.xy = r7.xy*half2(hg_Params[4].zw);\n"
             "    r7 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r7.xy));\n"
             "    r2.y = r2.y + r4.z;\n"
             "    r8.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r8.xy = r8.xy*half2(hg_Params[4].zw);\n"
             "    r8 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r8.xy));\n"
             "    r2.x = r2.x - r4.y;\n"
             "    r9.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r9.xy = r9.xy*half2(hg_Params[4].zw);\n"
             "    r9 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r9.xy));\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r10.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r10.xy = r10.xy*half2(hg_Params[4].zw);\n"
             "    r10 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r10.xy));\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r2.xy = r2.xy + half2(hg_Params[4].xy);\n"
             "    r2.xy = r2.xy*half2(hg_Params[4].zw);\n"
             "    r2 = (half4) hg_Texture1.sample(hg_Sampler1, float2(r2.xy));\n"
             "    r1 = mix(r1, r5, r3.xxxx);\n"
             "    r7 = mix(r7, r6, r3.xxxx);\n"
             "    r9 = mix(r9, r10, r3.xxxx);\n"
             "    r8 = mix(r8, r2, r3.xxxx);\n"
             "    r1 = mix(r1, r7, r3.yyyy);\n"
             "    r9 = mix(r9, r8, r3.yyyy);\n"
             "    r3 = mix(r1, r9, r3.zzzz);\n"
             "    r3 = r3*half4(hg_Params[0].zzzz) + half4(hg_Params[0].wwww);\n"
             "    output.color0 = select(float4(r3), float4(r0), hg_Params[2] < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e070033f:1d621a63:785fa6c2:a792b420\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0005:000b:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000b26\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = r1.xyz*r1.xyz;\n"
             "    r3.xyz = r2.xyz*r1.xyz;\n"
             "    r1.xyz = r1.xyz*hg_Params[3].yyy + hg_Params[3].xxx;\n"
             "    r1.xyz = r2.xyz*hg_Params[3].zzz + r1.xyz;\n"
             "    r1.xyz = r3.xyz*hg_Params[3].www + r1.xyz;\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r2.xyz = hg_Params[1].yyy - c0.yyy;\n"
             "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
             "    r3.xyz = fract(r1.xyz);\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r4.xyz = r1.xyz + c0.yyy;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = r4.xyz - r1.xyz;\n"
             "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
             "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
             "    r2.y = r1.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r1.xy = r2.xy + hg_Params[4].xy;\n"
             "    r1.xy = r1.xy*hg_Params[4].zw;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r5.xy = r2.xy + hg_Params[4].xy;\n"
             "    r5.xy = r5.xy*hg_Params[4].zw;\n"
             "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r6.xy = r2.xy + hg_Params[4].xy;\n"
             "    r6.xy = r6.xy*hg_Params[4].zw;\n"
             "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
             "    r2.x = r2.x - r4.x;\n"
             "    r7.xy = r2.xy + hg_Params[4].xy;\n"
             "    r7.xy = r7.xy*hg_Params[4].zw;\n"
             "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
             "    r2.y = r2.y + r4.z;\n"
             "    r8.xy = r2.xy + hg_Params[4].xy;\n"
             "    r8.xy = r8.xy*hg_Params[4].zw;\n"
             "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
             "    r2.x = r2.x - r4.y;\n"
             "    r9.xy = r2.xy + hg_Params[4].xy;\n"
             "    r9.xy = r9.xy*hg_Params[4].zw;\n"
             "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r10.xy = r2.xy + hg_Params[4].xy;\n"
             "    r10.xy = r10.xy*hg_Params[4].zw;\n"
             "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r2.xy = r2.xy + hg_Params[4].xy;\n"
             "    r2.xy = r2.xy*hg_Params[4].zw;\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
             "    r1 = mix(r1, r5, r3.xxxx);\n"
             "    r7 = mix(r7, r6, r3.xxxx);\n"
             "    r9 = mix(r9, r10, r3.xxxx);\n"
             "    r8 = mix(r8, r2, r3.xxxx);\n"
             "    r1 = mix(r1, r7, r3.yyyy);\n"
             "    r9 = mix(r9, r8, r3.yyyy);\n"
             "    r3 = mix(r1, r9, r3.zzzz);\n"
             "    r3 = r3*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
             "    output.color0 = select(r3, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c61a1f18:8e6819ed:8e5b4072:dd86156d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0005:000b:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000c03\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "uniform mediump vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = r1.xyz*r1.xyz;\n"
           "    r3.xyz = r2.xyz*r1.xyz;\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal3.yyy + hg_ProgramLocal3.xxx;\n"
           "    r1.xyz = r2.xyz*hg_ProgramLocal3.zzz + r1.xyz;\n"
           "    r1.xyz = r3.xyz*hg_ProgramLocal3.www + r1.xyz;\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r2.xyz = hg_ProgramLocal1.yyy - c0.yyy;\n"
           "    r1.xyz = min(r1.xyz, r2.xyz);\n"
           "    r3.xyz = fract(r1.xyz);\n"
           "    r1.xyz = floor(r1.xyz);\n"
           "    r4.xyz = r1.xyz + c0.yyy;\n"
           "    r4.xyz = min(r4.xyz, r2.xyz);\n"
           "    r4.xyz = r4.xyz - r1.xyz;\n"
           "    r4.xyz = r4.xyz*hg_ProgramLocal1.xyz;\n"
           "    r2.x = dot(r1.xy, hg_ProgramLocal1.xy);\n"
           "    r2.y = r1.z;\n"
           "    r2.xy = r2.xy + c0.zz;\n"
           "    r1.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal4.zw;\n"
           "    r1 = texture2D(hg_Texture1, r1.xy);\n"
           "    r2.x = r2.x + r4.x;\n"
           "    r5.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r5.xy = r5.xy*hg_ProgramLocal4.zw;\n"
           "    r5 = texture2D(hg_Texture1, r5.xy);\n"
           "    r2.x = r2.x + r4.y;\n"
           "    r6.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r6.xy = r6.xy*hg_ProgramLocal4.zw;\n"
           "    r6 = texture2D(hg_Texture1, r6.xy);\n"
           "    r2.x = r2.x - r4.x;\n"
           "    r7.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r7.xy = r7.xy*hg_ProgramLocal4.zw;\n"
           "    r7 = texture2D(hg_Texture1, r7.xy);\n"
           "    r2.y = r2.y + r4.z;\n"
           "    r8.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r8.xy = r8.xy*hg_ProgramLocal4.zw;\n"
           "    r8 = texture2D(hg_Texture1, r8.xy);\n"
           "    r2.x = r2.x - r4.y;\n"
           "    r9.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r9.xy = r9.xy*hg_ProgramLocal4.zw;\n"
           "    r9 = texture2D(hg_Texture1, r9.xy);\n"
           "    r2.x = r2.x + r4.x;\n"
           "    r10.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r10.xy = r10.xy*hg_ProgramLocal4.zw;\n"
           "    r10 = texture2D(hg_Texture1, r10.xy);\n"
           "    r2.x = r2.x + r4.y;\n"
           "    r2.xy = r2.xy + hg_ProgramLocal4.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal4.zw;\n"
           "    r2 = texture2D(hg_Texture1, r2.xy);\n"
           "    r1 = mix(r1, r5, r3.xxxx);\n"
           "    r7 = mix(r7, r6, r3.xxxx);\n"
           "    r9 = mix(r9, r10, r3.xxxx);\n"
           "    r8 = mix(r8, r2, r3.xxxx);\n"
           "    r1 = mix(r1, r7, r3.yyyy);\n"
           "    r9 = mix(r9, r8, r3.yyyy);\n"
           "    r3 = mix(r1, r9, r3.zzzz);\n"
           "    r3 = r3*hg_ProgramLocal0.zzzz + hg_ProgramLocal0.wwww;\n"
           "    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r3.x, hg_ProgramLocal2.y < 0.00000 ? r0.y : r3."
           "y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r3.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r3.w);\n"
           "}\n"
           "//MD5=73a1f61c:d101d00f:5112a8c9:baad1c77\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0005:000b:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
  }
}

void HgcApply3DLUTTrilinearFast_basekernel::InitProgramDescriptor(HgcApply3DLUTTrilinearFast_basekernel *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcApply3DLUTTrilinearFast_basekernel_hgc_visible", "//Metal1.0     \n//LEN=00000009f3\n[[ visible ]] FragmentOut HgcApply3DLUTTrilinearFast_basekernel_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = r1.xyz*r1.xyz;\n"
    "    r3.xyz = r2.xyz*r1.xyz;\n"
    "    r1.xyz = r1.xyz*hg_Params[3].yyy + hg_Params[3].xxx;\n"
    "    r1.xyz = r2.xyz*hg_Params[3].zzz + r1.xyz;\n"
    "    r1.xyz = r3.xyz*hg_Params[3].www + r1.xyz;\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r2.xyz = hg_Params[1].yyy - c0.yyy;\n"
    "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
    "    r3.xyz = fract(r1.xyz);\n"
    "    r1.xyz = floor(r1.xyz);\n"
    "    r4.xyz = r1.xyz + c0.yyy;\n"
    "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
    "    r4.xyz = r4.xyz - r1.xyz;\n"
    "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
    "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
    "    r2.y = r1.z;\n"
    "    r2.xy = r2.xy + c0.zz;\n"
    "    r1.xy = r2.xy + hg_Params[4].xy;\n"
    "    r1.xy = r1.xy*hg_Params[4].zw;\n"
    "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r5.xy = r2.xy + hg_Params[4].xy;\n"
    "    r5.xy = r5.xy*hg_Params[4].zw;\n"
    "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r6.xy = r2.xy + hg_Params[4].xy;\n"
    "    r6.xy = r6.xy*hg_Params[4].zw;\n"
    "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
    "    r2.x = r2.x - r4.x;\n"
    "    r7.xy = r2.xy + hg_Params[4].xy;\n"
    "    r7.xy = r7.xy*hg_Params[4].zw;\n"
    "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
    "    r2.y = r2.y + r4.z;\n"
    "    r8.xy = r2.xy + hg_Params[4].xy;\n"
    "    r8.xy = r8.xy*hg_Params[4].zw;\n"
    "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
    "    r2.x = r2.x - r4.y;\n"
    "    r9.xy = r2.xy + hg_Params[4].xy;\n"
    "    r9.xy = r9.xy*hg_Params[4].zw;\n"
    "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r10.xy = r2.xy + hg_Params[4].xy;\n"
    "    r10.xy = r10.xy*hg_Params[4].zw;\n"
    "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r2.xy = r2.xy + hg_Params[4].xy;\n"
    "    r2.xy = r2.xy*hg_Params[4].zw;\n"
    "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
    "    r1 = mix(r1, r5, r3.xxxx);\n"
    "    r7 = mix(r7, r6, r3.xxxx);\n"
    "    r9 = mix(r9, r10, r3.xxxx);\n"
    "    r8 = mix(r8, r2, r3.xxxx);\n"
    "    r1 = mix(r1, r7, r3.yyyy);\n"
    "    r9 = mix(r9, r8, r3.yyyy);\n"
    "    r3 = mix(r1, r9, r3.zzzz);\n"
    "    r3 = r3*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
    "    output.color0 = select(r3, r0, hg_Params[2] < 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcApply3DLUTTrilinearFast_basekernel");
}

void sub_1B79266FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7926734(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B792672CLL);
}

double HgcApply3DLUTTrilinearFast_basekernel::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x30uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B83770C0;
  strcpy(v3, "HgcApply3DLUTTrilinearFast_basekernel [hgc1]");
  return *(double *)"asekernel [hgc1]";
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::BindTexture(HgcApply3DLUTTrilinearFast_basekernel *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 4, v6, v7, v8, v9);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v4 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::Bind(HgcApply3DLUTTrilinearFast_basekernel *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::RenderTile(HgcApply3DLUTTrilinearFast_basekernel *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      int v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      int32x2_t v7 = a2[10];
      int32x2_t v8 = a2[2];
      uint64_t v9 = 16 * a2[11].i32[0];
      uint64_t v10 = 16 * a2[3].i32[0];
      uint64_t v11 = 16 * v4;
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      do
      {
        uint64_t v13 = 0;
        do
        {
          float32x4_t v14 = *(float32x4_t *)(*(void *)&v7 + v13);
          float32x4_t v15 = (_OWORD *)*((void *)this + 51);
          float32x4_t v16 = *(float32x4_t *)v15;
          float32x4_t v17 = *((float32x4_t *)v15 + 1);
          float32x4_t v18 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15, 1), vmulq_n_f32(v14, COERCE_FLOAT(*v15)));
          float32x4_t v20 = *((float32x4_t *)v15 + 2);
          float32x4_t v19 = *((float32x4_t *)v15 + 3);
          float32x4_t v21 = vmulq_f32(v18, v18);
          float32x4_t v22 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v19.f32, 1));
          float32x4_t v23 = vmulq_f32(v18, v21);
          float32x4_t v24 = vaddq_f32(v22, vmulq_laneq_f32(v21, v19, 2));
          float32x4_t v25 = vmulq_laneq_f32(v23, v19, 3);
          float32x4_t v26 = *((float32x4_t *)v15 + 4);
          float32x4_t v27 = *((float32x4_t *)v15 + 5);
          float32x4_t v28 = vmaxq_f32(vaddq_f32(v24, v25), v26);
          float32x4_t v29 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1), v27);
          float32x4_t v30 = vminq_f32(v28, v29);
          float32x4_t v31 = vcvtq_f32_s32(vcvtq_s32_f32(v30));
          float32x4_t v32 = vsubq_f32(v31, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v31, v30)));
          float32x4_t v33 = vsubq_f32(vminq_f32(vaddq_f32(v27, v32), v29), v32);
          float32x4_t v34 = vmulq_f32(v17, v32);
          float32x4_t v35 = vmulq_f32(v17, v33);
          int8x16_t v36 = *((int8x16_t *)v15 + 6);
          float32x4_t v37 = vaddq_f32(*((float32x4_t *)v15 + 7), (float32x4_t)vbslq_s8(v36, (int8x16_t)vaddq_f32(v34, (float32x4_t)vrev64q_s32((int32x4_t)v34)), vextq_s8((int8x16_t)v32, (int8x16_t)v32, 4uLL)));
          int32x2_t v38 = a2[12];
          __int32 v39 = a2[13].i32[0];
          float32x4_t v40 = vaddq_f32(vsubq_f32(v37, v6), v12);
          int32x4_t v41 = vcvtq_s32_f32(v40);
          v40.i64[0] = vaddq_s32(v41, vcgtq_f32(vcvtq_f32_s32(v41), v40)).u64[0];
          __int32 v42 = v40.i32[1];
          float32x4_t v43 = (float32x4_t)vbslq_s8(v36, (int8x16_t)vaddq_f32(v35, v37), (int8x16_t)v37);
          __int32 v44 = v40.i32[0];
          float32x4_t v45 = vaddq_f32(vsubq_f32(v43, v6), v12);
          int32x4_t v46 = vcvtq_s32_f32(v45);
          v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
          __int32 v47 = v44 + v42 * v39;
          __int32 v48 = v45.i32[1];
          __int32 v49 = v45.i32[0];
          float32x4_t v50 = (float32x4_t)vrev64q_s32((int32x4_t)v35);
          float32x4_t v51 = *(float32x4_t *)(*(void *)&v38 + 16 * v47);
          float32x4_t v52 = (float32x4_t)vbslq_s8(v36, (int8x16_t)vaddq_f32(v50, v43), (int8x16_t)v37);
          float32x4_t v53 = vaddq_f32(vsubq_f32(v52, v6), v12);
          int32x4_t v54 = vcvtq_s32_f32(v53);
          __int32 v55 = v49 + v48 * v39;
          v53.i64[0] = vaddq_s32(v54, vcgtq_f32(vcvtq_f32_s32(v54), v53)).u64[0];
          __int32 v56 = v53.i32[1];
          __int32 v57 = v53.i32[0];
          int8x16_t v58 = (int8x16_t)vsubq_f32(v52, v35);
          float32x4_t v59 = (float32x4_t)vbslq_s8(v36, v58, (int8x16_t)v37);
          float32x4_t v60 = vaddq_f32(vsubq_f32(v59, v6), v12);
          float32x4_t v61 = *(float32x4_t *)(*(void *)&v38 + 16 * v55);
          int32x4_t v62 = vcvtq_s32_f32(v60);
          v60.i64[0] = vaddq_s32(v62, vcgtq_f32(vcvtq_f32_s32(v62), v60)).u64[0];
          __int32 v63 = v60.i32[1];
          __int32 v64 = v57 + v56 * v39;
          __int32 v65 = v60.i32[0];
          int8x16_t v66 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v35, (int8x16_t)v35, 4uLL), v59);
          float32x4_t v67 = *(float32x4_t *)(*(void *)&v38 + 16 * v64);
          float32x4_t v68 = (float32x4_t)vbslq_s8(v36, v58, v66);
          float32x4_t v69 = vaddq_f32(vsubq_f32(v68, v6), v12);
          int32x4_t v70 = vcvtq_s32_f32(v69);
          __int32 v71 = v65 + v63 * v39;
          v69.i64[0] = vaddq_s32(v70, vcgtq_f32(vcvtq_f32_s32(v70), v69)).u64[0];
          __int32 v72 = v69.i32[1];
          __int32 v73 = v69.i32[0];
          float32x4_t v74 = (float32x4_t)vbslq_s8(v36, (int8x16_t)vsubq_f32(v68, v50), v66);
          float32x4_t v75 = vaddq_f32(vsubq_f32(v74, v6), v12);
          int32x4_t v76 = vcvtq_s32_f32(v75);
          v75.i64[0] = vaddq_s32(v76, vcgtq_f32(vcvtq_f32_s32(v76), v75)).u64[0];
          float32x4_t v77 = (float32x4_t)vbslq_s8(v36, (int8x16_t)vaddq_f32(v35, v74), v66);
          float32x4_t v78 = vaddq_f32(vsubq_f32(v77, v6), v12);
          int32x4_t v79 = vcvtq_s32_f32(v78);
          v78.i64[0] = vaddq_s32(v79, vcgtq_f32(vcvtq_f32_s32(v79), v78)).u64[0];
          int8x16_t v80 = (int8x16_t)vaddq_f32(v50, v77);
          float32x4_t v81 = *(float32x4_t *)(*(void *)&v38 + 16 * (v75.i32[0] + v75.i32[1] * v39));
          float32x4_t v82 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v36, v80, v66), v6), v12);
          int32x4_t v83 = vcvtq_s32_f32(v82);
          v82.i64[0] = vaddq_s32(v83, vcgtq_f32(vcvtq_f32_s32(v83), v82)).u64[0];
          float32x4_t v84 = vsubq_f32(v30, v32);
          float32x4_t v85 = vaddq_f32(v51, vmulq_n_f32(vsubq_f32(v61, v51), v84.f32[0]));
          float32x4_t v86 = vaddq_f32(v81, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v38 + 16 * (v78.i32[0] + v78.i32[1] * v39)), v81), v84.f32[0]));
          float32x4_t v87 = vaddq_f32(v85, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)(*(void *)&v38 + 16 * v71), vmulq_n_f32(vsubq_f32(v67, *(float32x4_t *)(*(void *)&v38 + 16 * v71)), v84.f32[0])), v85), *(float32x2_t *)v84.f32, 1));
          *(int8x16_t *)(*(void *)&v8 + v13) = vbslq_s8((int8x16_t)vcgtq_f32(v26, v20), (int8x16_t)v14, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), vmulq_laneq_f32(vaddq_f32(v87, vmulq_laneq_f32(vsubq_f32(vaddq_f32(v86, vmulq_lane_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)(*(void *)&v38+ 16* (v73 + v72 * v39)), vmulq_n_f32(vsubq_f32(
                                                                                    *(float32x4_t *)(*(void *)&v38 + 16 * (v82.i32[0] + v82.i32[1] * v39)),
                                                                                    *(float32x4_t *)(*(void *)&v38 + 16 * (v73 + v72 * v39))),
                                                                                  v84.f32[0])),
                                                                              v86),
                                                                            *(float32x2_t *)v84.f32,
                                                                            1)),
                                                                        v87),
                                                                      v84,
                                                                      2)),
                                                                  v16,
                                                                  2)));
          v13 += 16;
        }
        while (v11 != v13);
        ++v5;
        *(void *)&v7 += v9;
        *(void *)&v8 += v10;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::GetDOD(HgcApply3DLUTTrilinearFast_basekernel *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1) {
    return 0x8000000080000000;
  }
  if (a3) {
    return 0;
  }
  return *(void *)&a4.var0;
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, 1u);
    return HGRenderer::GetDOD(a2, Input);
  }
  else if (a3)
  {
    return 0;
  }
  else
  {
    return *(void *)&a4.var0;
  }
}

void HgcApply3DLUTTrilinearFast_basekernel::HgcApply3DLUTTrilinearFast_basekernel(HgcApply3DLUTTrilinearFast_basekernel *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F3EE8;
  operator new();
}

void sub_1B7926FAC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTrilinearFast_basekernel::~HgcApply3DLUTTrilinearFast_basekernel(HGNode *this)
{
  *(void *)this = &unk_1F10F3EE8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F3EE8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F3EE8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::SetParameter(HgcApply3DLUTTrilinearFast_basekernel *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int32x2_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int32x2_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcApply3DLUTTrilinearFast_basekernel::GetParameter(HgcApply3DLUTTrilinearFast_basekernel *this, unsigned int a2, float *a3)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorGamma_2vuy_yxzx_expand::GetProgram(HgcColorGamma_2vuy_yxzx_expand *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord0.xy*float2(c0.xy);\n"
             "    s0.xy = floor(s0.xy);\n"
             "    s0.xy = s0.xy + float2(c0.xx);\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    s0.x = float(fract(0.500000f*frag._texCoord0.x) >= 0.500000f);\n"
             "    r1 = half4(r0.y, r0.z, r0.x, 1.00000h);\n"
             "    s1.yzw = float3(r1.yzw);\n"
             "    s1.x = select(float(r1.x), float(r0.w), -s0.x < 0.00000h);\n"
             "    output.color0 = s1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=3f268be6:187954fb:6e0dcb63:6ce755ba\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0001:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ad\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy*c0.xy;\n"
             "    r0.xy = floor(r0.xy);\n"
             "    r0.xy = r0.xy + c0.xx;\n"
             "    r0.xy = r0.xy + hg_Params[0].xy;\n"
             "    r0.xy = r0.xy*hg_Params[0].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r1.x = float(fract(0.500000f*frag._texCoord0.x) >= 0.500000f);\n"
             "    r2 = float4(r0.y, r0.z, r0.x, 1.00000f);\n"
             "    r2.x = select(r2.x, r0.w, -r1.x < 0.00000f);\n"
             "    output.color0 = r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9aad681a:95105c3e:57454f67:c4097cd0\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000386\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy*c0.xy;\n"
           "    r0.xy = floor(r0.xy);\n"
           "    r0.xy = r0.xy + c0.xx;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal0.zw;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r1.x = c0.x*hg_TexCoord0.x;\n"
           "    r1.x = fract(r1.x);\n"
           "    r1.x = float(r1.x >= c0.x);\n"
           "    r2 = vec4(r0.y, r0.z, r0.x, 1.00000);\n"
           "    r2.x = -r1.x < 0.00000 ? r0.w : r2.x;\n"
           "    gl_FragColor = r2;\n"
           "}\n"
           "//MD5=1b446ee9:f22ade39:784a51a7:e86f3a81\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorGamma_2vuy_yxzx_expand::InitProgramDescriptor(HgcColorGamma_2vuy_yxzx_expand *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_2vuy_yxzx_expand_hgc_visible", "//Metal1.0     \n//LEN=00000002f8\n[[ visible ]] FragmentOut HgcColorGamma_2vuy_yxzx_expand_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy*c0.xy;\n"
    "    r0.xy = floor(r0.xy);\n"
    "    r0.xy = r0.xy + c0.xx;\n"
    "    r0.xy = r0.xy + hg_Params[0].xy;\n"
    "    r0.xy = r0.xy*hg_Params[0].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r1.x = float(fract(0.500000f*texCoord0.x) >= 0.500000f);\n"
    "    r2 = float4(r0.y, r0.z, r0.x, 1.00000f);\n"
    "    r2.x = select(r2.x, r0.w, -r1.x < 0.00000f);\n"
    "    output.color0 = r2;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorGamma_2vuy_yxzx_expand");
}

void sub_1B79275E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7927620(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7927618);
}

char *HgcColorGamma_2vuy_yxzx_expand::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D30;
  strcpy(result, "HgcColorGamma_2vuy_yxzx_expand [hgc1]");
  return result;
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::BindTexture(HgcColorGamma_2vuy_yxzx_expand *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, void, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 0, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::Bind(HgcColorGamma_2vuy_yxzx_expand *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::RenderTile(HgcColorGamma_2vuy_yxzx_expand *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    int32x2_t v7 = a2[2];
    uint64_t v8 = 16 * a2[3].i32[0];
    v9.i64[0] = 0x3F0000003F000000;
    v9.i64[1] = 0x3F0000003F000000;
    float32x4_t v10 = v5;
    while (v6 < 3)
    {
      uint64_t v11 = 0;
      float32x4_t v13 = v10;
      if (v6 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v10 = vaddq_f32(v10, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      *(void *)&v7 += v8;
      if (v4 == v3) {
        return 0;
      }
    }
    uint64_t v11 = 0;
    int v12 = v6;
    float32x4_t v13 = v10;
    do
    {
      float32x4_t v14 = vaddq_f32(v13, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v15 = vaddq_f32(v14, (float32x4_t)xmmword_1B7E736B0);
      uint64_t v16 = *((void *)this + 51);
      int8x16_t v17 = *(int8x16_t *)(v16 + 16);
      float32x4_t v18 = vmulq_f32(v13, *(float32x4_t *)v16);
      float32x4_t v19 = vmulq_f32(v14, *(float32x4_t *)v16);
      float32x4_t v20 = vmulq_f32(v15, *(float32x4_t *)v16);
      float32x4_t v21 = vcvtq_f32_s32(vcvtq_s32_f32(v18));
      float32x4_t v22 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
      float32x4_t v23 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      float32x4_t v24 = vsubq_f32(v21, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v21, v18)));
      float32x4_t v25 = vsubq_f32(v22, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v22, v19)));
      float32x4_t v26 = vsubq_f32(v23, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v23, v20)));
      float32x4_t v27 = *(float32x4_t *)(v16 + 32);
      int8x16_t v28 = *(int8x16_t *)(v16 + 48);
      __int32 v29 = a2[11].i32[0];
      float32x4_t v30 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v24), v5), v9);
      int32x4_t v31 = vcvtq_s32_f32(v30);
      v30.i64[0] = vaddq_s32(v31, vcgtq_f32(vcvtq_f32_s32(v31), v30)).u64[0];
      __int32 v32 = v30.i32[1];
      float32x4_t v33 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v25), v5), v9);
      int32x4_t v34 = vcvtq_s32_f32(v33);
      v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      __int32 v35 = v30.i32[0];
      float32x4_t v36 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v26), v5), v9);
      int32x4_t v37 = vcvtq_s32_f32(v36);
      v36.i64[0] = vaddq_s32(v37, vcgtq_f32(vcvtq_f32_s32(v37), v36)).u64[0];
      __int32 v38 = v35 + v32 * v29;
      __int32 v39 = v33.i32[0] + v33.i32[1] * v29;
      __int32 v40 = v36.i32[0] + v36.i32[1] * v29;
      int32x2_t v41 = a2[10];
      int8x16_t v42 = *(int8x16_t *)(*(void *)&v41 + 16 * v38);
      float32x4_t v43 = vmulq_f32(v13, v27);
      float32x4_t v44 = vmulq_f32(v14, v27);
      float32x4_t v45 = vmulq_f32(v15, v27);
      int8x16_t v46 = *(int8x16_t *)(*(void *)&v41 + 16 * v39);
      float32x4_t v47 = vcvtq_f32_s32(vcvtq_s32_f32(v43));
      float32x4_t v48 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      int8x16_t v49 = *(int8x16_t *)(*(void *)&v41 + 16 * v40);
      float32x4_t v50 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      float32x4_t v51 = (float32x4_t)vandq_s8(v17, (int8x16_t)vcgeq_f32(vsubq_f32(v43, vsubq_f32(v47, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v47, v43)))), v27));
      float32x4_t v52 = (float32x4_t)vandq_s8(v17, (int8x16_t)vcgeq_f32(vsubq_f32(v44, vsubq_f32(v48, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v48, v44)))), v27));
      float32x4_t v53 = (float32x4_t)vandq_s8(v17, (int8x16_t)vcgeq_f32(vsubq_f32(v45, vsubq_f32(v50, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v50, v45)))), v27));
      *(int8x8_t *)v27.f32 = vqtbl1_s8(v42, *(int8x8_t *)v28.i8);
      v45.i64[0] = vextq_s8(v28, v28, 8uLL).u64[0];
      v27.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v42, *(int8x8_t *)v45.f32).u32[0]);
      *(int8x8_t *)v47.f32 = vqtbl1_s8(v46, *(int8x8_t *)v28.i8);
      *(int8x8_t *)v28.i8 = vqtbl1_s8(v49, *(int8x8_t *)v28.i8);
      v47.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v46, *(int8x8_t *)v45.f32).u32[0]);
      v28.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v49, *(int8x8_t *)v45.f32).u32[0]);
      int8x16_t v54 = vextq_s8(v46, v46, 0xCuLL);
      float32x4_t v55 = *(float32x4_t *)(v16 + 64);
      int8x16_t v56 = *(int8x16_t *)(v16 + 80);
      __int32 v57 = (int8x16_t *)(*(void *)&v7 + 16 * v11);
      *__int32 v57 = vbslq_s8(v56, vbslq_s8((int8x16_t)vcgtq_f32(v51, v55), vextq_s8(v42, v42, 0xCuLL), (int8x16_t)v27), (int8x16_t)v27);
      v57[1] = vbslq_s8(v56, vbslq_s8((int8x16_t)vcgtq_f32(v52, v55), v54, (int8x16_t)v47), (int8x16_t)v47);
      v57[2] = vbslq_s8(v56, vbslq_s8((int8x16_t)vcgtq_f32(v53, v55), vextq_s8(v49, v49, 0xCuLL), v28), v28);
      float32x4_t v13 = vaddq_f32(v15, (float32x4_t)xmmword_1B7E736B0);
      v11 += 3;
      v12 -= 3;
    }
    while (v12 > 2);
    uint64_t v11 = v11;
    if ((int)v11 >= v6) {
      goto LABEL_3;
    }
    do
    {
LABEL_10:
      uint64_t v58 = *((void *)this + 51);
      int8x16_t v59 = *(int8x16_t *)(v58 + 16);
      float32x4_t v60 = vmulq_f32(v13, *(float32x4_t *)v58);
      float32x4_t v61 = vcvtq_f32_s32(vcvtq_s32_f32(v60));
      float32x4_t v62 = vsubq_f32(v61, (float32x4_t)vandq_s8(v59, (int8x16_t)vcgtq_f32(v61, v60)));
      float32x4_t v63 = *(float32x4_t *)(v58 + 32);
      int8x16_t v64 = *(int8x16_t *)(v58 + 48);
      float32x4_t v65 = vaddq_f32(vsubq_f32(vaddq_f32(v63, v62), v5), v9);
      int32x4_t v66 = vcvtq_s32_f32(v65);
      v65.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v65)).u64[0];
      __int32 v67 = v65.i32[0] + v65.i32[1] * a2[11].i32[0];
      float32x4_t v68 = vmulq_f32(v13, v63);
      float32x4_t v69 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
      int8x16_t v70 = *(int8x16_t *)(*(void *)&a2[10] + 16 * v67);
      int8x16_t v71 = (int8x16_t)vcgeq_f32(vsubq_f32(v68, vsubq_f32(v69, (float32x4_t)vandq_s8(v59, (int8x16_t)vcgtq_f32(v69, v68)))), v63);
      *(int8x8_t *)v63.f32 = vqtbl1_s8(v70, *(int8x8_t *)v64.i8);
      v63.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v70, (int8x8_t)*(_OWORD *)&vextq_s8(v64, v64, 8uLL)).u32[0]);
      *(int8x16_t *)(*(void *)&v7 + 16 * v11) = vbslq_s8(*(int8x16_t *)(v58 + 80), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8(v59, v71), *(float32x4_t *)(v58 + 64)), vextq_s8(v70, v70, 0xCuLL), (int8x16_t)v63), (int8x16_t)v63);
      float32x4_t v13 = vaddq_f32(v13, (float32x4_t)xmmword_1B7E736B0);
      ++v11;
    }
    while (v11 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::GetDOD(HgcColorGamma_2vuy_yxzx_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
  int v8 = HGRectGrow(v6, v5, v7);
  float v9 = HGRectFloat(v8);
  float v13 = HGRectScale(v9, v10, v11, v12, 2.0);
  uint64_t v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::GetROI(HgcColorGamma_2vuy_yxzx_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 0.5);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  uint64_t v16 = v15;
  uint64_t v17 = HGRectMake4i(0, 0, 1u, 0);
  uint64_t v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcColorGamma_2vuy_yxzx_expand::HgcColorGamma_2vuy_yxzx_expand(HgcColorGamma_2vuy_yxzx_expand *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F4150;
  operator new();
}

void sub_1B7927DB8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_2vuy_yxzx_expand::~HgcColorGamma_2vuy_yxzx_expand(HGNode *this)
{
  *(void *)this = &unk_1F10F4150;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F4150;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F4150;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::SetParameter(HgcColorGamma_2vuy_yxzx_expand *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_2vuy_yxzx_expand::GetParameter(HgcColorGamma_2vuy_yxzx_expand *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcPremultiply::GetProgram(HgcPremultiply *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000245\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d94e4443:daab1afb:2b68adf7:815e6ba9\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000237\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=a13a6a2f:33512419:9d3fb3a8:463fe70f\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001d9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=ebd2844b:d31991ae:bbb76419:aca54bd2\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPremultiply::InitProgramDescriptor(HgcPremultiply *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPremultiply_hgc_visible", "//Metal1.0     \n//LEN=000000010f\n[[ visible ]] FragmentOut HgcPremultiply_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcPremultiply");
}

void sub_1B79281FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B792822C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7928224);
}

void HgcPremultiply::shaderDescription(char *a1@<X8>)
{
  a1[23] = 21;
  strcpy(a1, "HgcPremultiply [hgc1]");
}

uint64_t HgcPremultiply::BindTexture(HgcPremultiply *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPremultiply::Bind(HgcPremultiply *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcPremultiply::RenderTile(HgcPremultiply *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v25 = 0;
        uint64_t v26 = 16 * v7;
        uint64_t v27 = 16 * v6;
        uint64_t v28 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v29 = 0;
          do
          {
            v5[v29 / 0x10] = vbslq_s8(*(int8x16_t *)*((void *)this + 51), (int8x16_t)v4[v29 / 0x10], (int8x16_t)vmulq_laneq_f32(v4[v29 / 0x10], v4[v29 / 0x10], 3));
            v29 += 16;
          }
          while (v28 != v29);
          ++v25;
          int v4 = (float32x4_t *)((char *)v4 + v26);
          int v5 = (int8x16_t *)((char *)v5 + v27);
        }
        while (v25 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float v11 = v4 + 4;
      float v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        uint64_t v14 = v12;
        uint64_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          uint64_t v17 = v15;
          uint64_t v18 = v14;
          int8x16_t v19 = *(int8x16_t *)*((void *)this + 51);
          int8x16_t v20 = vbslq_s8(v19, (int8x16_t)v4[v16 - 1], (int8x16_t)vmulq_laneq_f32(v4[v16 - 1], v4[v16 - 1], 3));
          int8x16_t v21 = vbslq_s8(v19, (int8x16_t)v4[v16], (int8x16_t)vmulq_laneq_f32(v4[v16], v4[v16], 3));
          int8x16_t v22 = vbslq_s8(v19, (int8x16_t)v4[v16 + 1], (int8x16_t)vmulq_laneq_f32(v4[v16 + 1], v4[v16 + 1], 3));
          float32x4_t v23 = &v5[v16];
          v23[-2] = vbslq_s8(v19, (int8x16_t)v4[v16 - 2], (int8x16_t)vmulq_laneq_f32(v4[v16 - 2], v4[v16 - 2], 3));
          v23[-1] = v20;
          v13 += 4;
          *float32x4_t v23 = v21;
          v23[1] = v22;
          v16 += 4;
          v15 += 4;
          uint64_t v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            float32x4_t v24 = *v17++;
            *v18++ = vbslq_s8(*(int8x16_t *)*((void *)this + 51), (int8x16_t)v24, (int8x16_t)vmulq_laneq_f32(v24, v24, 3));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (int8x16_t *)((char *)v5 + v9);
        int v4 = (float32x4_t *)((char *)v4 + v10);
        float v11 = (float32x4_t *)((char *)v11 + v10);
        float v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPremultiply::GetDOD(HgcPremultiply *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcPremultiply::GetROI(HgcPremultiply *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcPremultiply::HgcPremultiply(HgcPremultiply *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F43B8;
  operator new();
}

void sub_1B79285E0(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPremultiply::~HgcPremultiply(HGNode *this)
{
  *(void *)this = &unk_1F10F43B8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F43B8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcPremultiply::SetParameter(HgcPremultiply *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPremultiply::GetParameter(HgcPremultiply *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcToneParamCurve4::GetProgram(HgcToneParamCurve4 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003b2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = half3(hg_Params[1].xyz)*r0.xyz + half3(hg_Params[2].xyz);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xyz));\n"
             "    r1.xyz = r1.xyz + half3(hg_Params[5].xyz);\n"
             "    r2.xyz = r0.xyz - half3(hg_Params[4].xyz);\n"
             "    r3.xyz = r0.xyz*half3(hg_Params[3].xyz) + half3(hg_Params[6].xyz);\n"
             "    output.color0.xyz = select(float3(r1.xyz), float3(r3.xyz), float3(r2.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1d41385c:778e5a27:1d60d889:a8729d7e\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0007:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000035c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
             "    r1.xyz = r1.xyz + hg_Params[5].xyz;\n"
             "    r2.xyz = r0.xyz - hg_Params[4].xyz;\n"
             "    r3.xyz = r0.xyz*hg_Params[3].xyz + hg_Params[6].xyz;\n"
             "    output.color0.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=13f252c1:8bebdb6c:281a8258:9f05e0c5\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0007:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000045e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "uniform mediump vec4 hg_ProgramLocal4;\n"
           "uniform mediump vec4 hg_ProgramLocal5;\n"
           "uniform mediump vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = hg_ProgramLocal1.xyz*r0.xyz + hg_ProgramLocal2.xyz;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xyz);\n"
           "    r1.xyz = r1.xyz + hg_ProgramLocal5.xyz;\n"
           "    r2.xyz = r0.xyz - hg_ProgramLocal4.xyz;\n"
           "    r3.xyz = r0.xyz*hg_ProgramLocal3.xyz + hg_ProgramLocal6.xyz;\n"
           "    gl_FragColor.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z"
           " : r1.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=2ab6ce4c:9d775dbf:c9e5cc75:c3634fc7\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0007:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve4::InitProgramDescriptor(HgcToneParamCurve4 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve4_hgc_visible", "//Metal1.0     \n//LEN=0000000238\n[[ visible ]] FragmentOut HgcToneParamCurve4_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
    "    r1.xyz = r1.xyz + hg_Params[5].xyz;\n"
    "    r2.xyz = r0.xyz - hg_Params[4].xyz;\n"
    "    r3.xyz = r0.xyz*hg_Params[3].xyz + hg_Params[6].xyz;\n"
    "    output.color0.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcToneParamCurve4");
}

void sub_1B79289B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B79289E8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79289E0);
}

double HgcToneParamCurve4::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcToneParamCurve4 [hgc1]");
  return *(double *)"ramCurve4 [hgc1]";
}

uint64_t HgcToneParamCurve4::BindTexture(HgcToneParamCurve4 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve4::Bind(HgcToneParamCurve4 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcToneParamCurve4::RenderTile(HgcToneParamCurve4 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v69 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v11 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = *((void *)this + 51);
      float32x4_t v14 = *(float32x4_t *)(v13 + 16);
      float32x4_t v15 = *(float32x4_t *)(v13 + 32);
      float32x4_t v16 = *(float32x4_t *)(v13 + 48);
      float32x4_t v17 = vaddq_f32(v15, vmulq_f32(v12, v14));
      float32x4_t v18 = vaddq_f32(v15, vmulq_f32(v11, v14));
      float32x4_t v20 = *(float32x4_t *)(v13 + 96);
      int8x16_t v19 = *(int8x16_t *)(v13 + 112);
      float32x4_t v21 = *(float32x4_t *)(v13 + 128);
      float32x4_t v22 = *(float32x4_t *)(v13 + 144);
      float32x4_t v23 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v17), (int8x16_t)v21);
      int8x16_t v24 = *(int8x16_t *)(v13 + 160);
      float32x4_t v25 = *(float32x4_t *)(v13 + 176);
      float32x4_t v26 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v18), (int8x16_t)v21);
      float32x4_t v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v18)));
      float32x4_t v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v17))), v25);
      float32x4_t v29 = *(float32x4_t *)(v13 + 192);
      float32x4_t v30 = *(float32x4_t *)(v13 + 208);
      float32x4_t v31 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v23, v29));
      float32x4_t v32 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v26, v29));
      float32x4_t v33 = vaddq_f32(v28, v31);
      float32x4_t v34 = vaddq_f32(vsubq_f32(v27, v25), v32);
      float32x4_t v35 = vsubq_f32(vsubq_f32(v23, v21), vmulq_f32(vmulq_f32(v30, v31), v23));
      float32x4_t v36 = vsubq_f32(vsubq_f32(v26, v21), vmulq_f32(vmulq_f32(v30, v32), v26));
      float32x4_t v37 = *(float32x4_t *)(v13 + 224);
      float32x4_t v38 = *(float32x4_t *)(v13 + 240);
      float32x4_t v39 = vaddq_f32(v37, vmulq_f32(v38, v35));
      float32x4_t v40 = vaddq_f32(v37, vmulq_f32(v38, v36));
      float32x4_t v41 = *(float32x4_t *)(v13 + 256);
      float32x4_t v42 = *(float32x4_t *)(v13 + 272);
      float32x4_t v43 = vmulq_f32(*(float32x4_t *)v13, vaddq_f32(v34, vmulq_f32(v36, vaddq_f32(vaddq_f32(v41, vmulq_f32(v36, v42)), vmulq_f32(vmulq_f32(v36, v36), v40)))));
      float32x4_t v44 = *(float32x4_t *)(v13 + 288);
      float32x4_t v45 = *(float32x4_t *)(v13 + 304);
      float32x4_t v46 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v13, vaddq_f32(v33, vmulq_f32(v35, vaddq_f32(vaddq_f32(v41, vmulq_f32(v35, v42)), vmulq_f32(vmulq_f32(v35, v35), v39))))), v44);
      float32x4_t v47 = vmaxq_f32(v43, v44);
      float32x4_t v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      float32x4_t v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      float32x4_t v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v48, v46)));
      float32x4_t v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v49, v47)));
      float32x4_t v52 = vsubq_f32(v46, v50);
      float32x4_t v53 = vsubq_f32(v47, v51);
      float32x4_t v54 = *(float32x4_t *)(v13 + 320);
      float32x4_t v55 = *(float32x4_t *)(v13 + 336);
      float32x4_t v56 = vmulq_f32(v53, vaddq_f32(v55, vmulq_f32(v53, vaddq_f32(v45, vmulq_f32(v54, v53)))));
      float32x4_t v57 = vaddq_f32(v21, vmulq_f32(v52, vaddq_f32(v55, vmulq_f32(v52, vaddq_f32(v45, vmulq_f32(v54, v52))))));
      int32x4_t v58 = vcvtq_s32_f32(v51);
      int32x4_t v59 = *(int32x4_t *)(v13 + 352);
      float32x4_t v60 = *(float32x4_t *)(v13 + 368);
      float32x4_t v61 = vmulq_f32(v57, (float32x4_t)vshlq_n_s32(vaddq_s32(v59, vcvtq_s32_f32(v50)), 0x17uLL));
      float32x4_t v62 = vmulq_f32(vaddq_f32(v21, v56), (float32x4_t)vshlq_n_s32(vaddq_s32(v59, v58), 0x17uLL));
      float32x4_t v64 = *(float32x4_t *)(v13 + 64);
      float32x4_t v63 = *(float32x4_t *)(v13 + 80);
      int8x16_t v65 = (int8x16_t)vaddq_f32(v63, v62);
      int8x16_t v66 = vbslq_s8((int8x16_t)vcgtq_f32(v60, vsubq_f32(v12, v64)), (int8x16_t)vaddq_f32(v20, vmulq_f32(v12, v16)), (int8x16_t)vaddq_f32(v63, v61));
      int8x16_t v67 = *(int8x16_t *)(v13 + 384);
      float32x4_t v68 = (int8x16_t *)(v5 + v10);
      v68[-1] = vbslq_s8(v67, (int8x16_t)v12, v66);
      *float32x4_t v68 = vbslq_s8(v67, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32(v60, vsubq_f32(v11, v64)), (int8x16_t)vaddq_f32(v20, vmulq_f32(v11, v16)), v65));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v69 = -v9;
    if (v69 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v70 = 16 * v69;
    float32x4_t v71 = *(float32x4_t *)(v6 + v70);
    uint64_t v72 = *((void *)this + 51);
    float32x4_t v73 = vaddq_f32(*(float32x4_t *)(v72 + 32), vmulq_f32(v71, *(float32x4_t *)(v72 + 16)));
    float32x4_t v74 = *(float32x4_t *)(v72 + 128);
    float32x4_t v75 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v72 + 112), (int8x16_t)v73), (int8x16_t)v74);
    float32x4_t v76 = (float32x4_t)vandq_s8((int8x16_t)v74, (int8x16_t)vcgtq_f32(v75, *(float32x4_t *)(v72 + 192)));
    float32x4_t v77 = vsubq_f32(vsubq_f32(v75, v74), vmulq_f32(vmulq_f32(*(float32x4_t *)(v72 + 208), v76), v75));
    float32x4_t v78 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v72, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v73, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v72 + 160), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v72 + 144), v73))), *(float32x4_t *)(v72 + 176)), v76), vmulq_f32(v77, vaddq_f32(vaddq_f32(*(float32x4_t *)(v72 + 256), vmulq_f32(v77, *(float32x4_t *)(v72 + 272))), vmulq_f32(vmulq_f32(v77, v77), vaddq_f32(*(float32x4_t *)(v72 + 224), vmulq_f32(*(float32x4_t *)(v72 + 240), v77))))))),
            *(float32x4_t *)(v72 + 288));
    float32x4_t v79 = vcvtq_f32_s32(vcvtq_s32_f32(v78));
    float32x4_t v80 = vsubq_f32(v79, (float32x4_t)vandq_s8((int8x16_t)v74, (int8x16_t)vcgtq_f32(v79, v78)));
    float32x4_t v81 = vsubq_f32(v78, v80);
    *(int8x16_t *)(v5 + v70) = vbslq_s8(*(int8x16_t *)(v72 + 384), (int8x16_t)v71, vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(v72 + 368), vsubq_f32(v71, *(float32x4_t *)(v72 + 64))), (int8x16_t)vaddq_f32(*(float32x4_t *)(v72 + 96), vmulq_f32(v71, *(float32x4_t *)(v72 + 48))), (int8x16_t)vaddq_f32(*(float32x4_t *)(v72 + 80), vmulq_f32(vaddq_f32(v74, vmulq_f32(v81, vaddq_f32(*(float32x4_t *)(v72 + 336), vmulq_f32(
                                                          v81,
                                                          vaddq_f32(*(float32x4_t *)(v72 + 304), vmulq_f32(*(float32x4_t *)(v72 + 320), v81)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v72 + 352), vcvtq_s32_f32(v80)), 0x17uLL)))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve4::GetDOD(HgcToneParamCurve4 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcToneParamCurve4::GetROI(HgcToneParamCurve4 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcToneParamCurve4::HgcToneParamCurve4(HgcToneParamCurve4 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F4620;
  operator new();
}

void sub_1B7929240(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve4::~HgcToneParamCurve4(HGNode *this)
{
  *(void *)this = &unk_1F10F4620;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C402BC884A0);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F4620;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C402BC884A0);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve4::SetParameter(HgcToneParamCurve4 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve4::GetParameter(HgcToneParamCurve4 *this, unsigned int a2, float *a3)
{
  if (a2 > 6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorGamma_v210_yxzx_rgba_expand::GetProgram(HgcColorGamma_v210_yxzx_rgba_expand *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000955\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.1666669995, 1.000000000, 4.000000000, 0.5000000000);\n"
             "    const half4 c1 = half4(6.000000000, 1.000000000, 0.000000000, 5.000000000);\n"
             "    const half4 c2 = half4(3.000000000, 2.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord0.xy*float2(c0.xy);\n"
             "    s0.xy = floor(s0.xy);\n"
             "    s0.xy = s0.xy*float2(c0.zy) + float2(c0.ww);\n"
             "    s1.xyz = floor(frag._texCoord0.xxx);\n"
             "    s1.xyz = s1.xyz - float3(c1.xxx)*floor(s1.xyz/float3(c1.xxx));\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r0.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s2.xy).xyz;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r1.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s2.xy).xyz;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r2.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s2.xy).xyz;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    r3.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s0.xy).xyz;\n"
             "    r0.xyz = r0.yxz;\n"
             "    r4.yz = r0.yz;\n"
             "    r4.x = r1.x;\n"
             "    r1.xy = r1.zy;\n"
             "    r1.z = r2.x;\n"
             "    r5.yz = r1.yz;\n"
             "    r5.x = r2.y;\n"
             "    r6.xz = r3.xy;\n"
             "    r6.y = r2.z;\n"
             "    r2.yz = r6.yz;\n"
             "    r2.x = r3.z;\n"
             "    s2.xyz = s1.xyz - float3(c1.www);\n"
             "    s2.xyz = select(float3(r2.xyz), float3(r6.xyz), s2.xyz < 0.00000h);\n"
             "    s0.xyz = s1.xyz - float3(c0.zzz);\n"
             "    s2.xyz = select(s2.xyz, float3(r5.xyz), s0.xyz < 0.00000h);\n"
             "    s0.xyz = s1.xyz - float3(c2.xxx);\n"
             "    s2.xyz = select(s2.xyz, float3(r1.xyz), s0.xyz < 0.00000h);\n"
             "    s0.xyz = s1.xyz - float3(c2.yyy);\n"
             "    s2.xyz = select(s2.xyz, float3(r4.xyz), s0.xyz < 0.00000h);\n"
             "    s1.xyz = s1.xyz - float3(c1.yyy);\n"
             "    s2.xyz = select(s2.xyz, float3(r0.xyz), s1.xyz < 0.00000h);\n"
             "    s2.w = float(c1.y);\n"
             "    output.color0 = s2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9faef4db:63ae184b:410e2309:949438a2\n"
             "//SIG=00400000:00000000:00000000:00000001:0003:0001:000a:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000088b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.1666669995, 1.000000000, 4.000000000, 0.5000000000);\n"
             "    const float4 c1 = float4(6.000000000, 1.000000000, 0.000000000, 5.000000000);\n"
             "    const float4 c2 = float4(3.000000000, 2.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy*c0.xy;\n"
             "    r0.xy = floor(r0.xy);\n"
             "    r0.xy = r0.xy*c0.zy + c0.ww;\n"
             "    r1.xyz = floor(frag._texCoord0.xxx);\n"
             "    r1.xyz = r1.xyz - c1.xxx*floor(r1.xyz/c1.xxx);\n"
             "    r2.xy = r0.xy + hg_Params[0].xy;\n"
             "    r2.xy = r2.xy*hg_Params[0].zw;\n"
             "    r2.xyz = hg_Texture0.sample(hg_Sampler0, r2.xy).xyz;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r3.xy = r0.xy + hg_Params[0].xy;\n"
             "    r3.xy = r3.xy*hg_Params[0].zw;\n"
             "    r3.xyz = hg_Texture0.sample(hg_Sampler0, r3.xy).xyz;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r4.xy = r0.xy + hg_Params[0].xy;\n"
             "    r4.xy = r4.xy*hg_Params[0].zw;\n"
             "    r4.xyz = hg_Texture0.sample(hg_Sampler0, r4.xy).xyz;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r0.xy = r0.xy + hg_Params[0].xy;\n"
             "    r0.xy = r0.xy*hg_Params[0].zw;\n"
             "    r0.xyz = hg_Texture0.sample(hg_Sampler0, r0.xy).xyz;\n"
             "    r2.xyz = r2.yxz;\n"
             "    r5.yz = r2.yz;\n"
             "    r5.x = r3.x;\n"
             "    r3.xy = r3.zy;\n"
             "    r3.z = r4.x;\n"
             "    r6.yz = r3.yz;\n"
             "    r6.x = r4.y;\n"
             "    r7.xz = r0.xy;\n"
             "    r7.y = r4.z;\n"
             "    r4.yz = r7.yz;\n"
             "    r4.x = r0.z;\n"
             "    r0.xyz = r1.xyz - c1.www;\n"
             "    r4.xyz = select(r4.xyz, r7.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz - c0.zzz;\n"
             "    r4.xyz = select(r4.xyz, r6.xyz, r0.xyz < 0.00000f);\n"
             "    r7.xyz = r1.xyz - c2.xxx;\n"
             "    r4.xyz = select(r4.xyz, r3.xyz, r7.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz - c2.yyy;\n"
             "    r4.xyz = select(r4.xyz, r5.xyz, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz - c1.yyy;\n"
             "    r4.xyz = select(r4.xyz, r2.xyz, r1.xyz < 0.00000f);\n"
             "    r4.w = c1.y;\n"
             "    output.color0 = r4;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d483035d:436789a8:f3f21232:16bff0a5\n"
             "//SIG=00000000:00000000:00000000:00000000:0003:0001:0008:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000094f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.1666669995, 1.000000000, 4.000000000, 0.5000000000);\n"
           "    const highp vec4 c1 = vec4(6.000000000, 1.000000000, 0.000000000, 5.000000000);\n"
           "    const highp vec4 c2 = vec4(3.000000000, 2.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy*c0.xy;\n"
           "    r0.xy = floor(r0.xy);\n"
           "    r0.xy = r0.xy*c0.zy + c0.ww;\n"
           "    r1.xyz = floor(hg_TexCoord0.xxx);\n"
           "    r1.xyz = mod(r1.xyz, c1.xxx);\n"
           "    r2.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal0.zw;\n"
           "    r2.xyz = texture2D(hg_Texture0, r2.xy).xyz;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r3.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r3.xy = r3.xy*hg_ProgramLocal0.zw;\n"
           "    r3.xyz = texture2D(hg_Texture0, r3.xy).xyz;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r4.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r4.xy = r4.xy*hg_ProgramLocal0.zw;\n"
           "    r4.xyz = texture2D(hg_Texture0, r4.xy).xyz;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal0.zw;\n"
           "    r0.xyz = texture2D(hg_Texture0, r0.xy).xyz;\n"
           "    r2.xyz = r2.yxz;\n"
           "    r5.yz = r2.yz;\n"
           "    r5.x = r3.x;\n"
           "    r3.xy = r3.zy;\n"
           "    r3.z = r4.x;\n"
           "    r6.yz = r3.yz;\n"
           "    r6.x = r4.y;\n"
           "    r7.xz = r0.xy;\n"
           "    r7.y = r4.z;\n"
           "    r4.yz = r7.yz;\n"
           "    r4.x = r0.z;\n"
           "    r0.xyz = r1.xyz - c1.www;\n"
           "    r4.xyz = vec3(r0.x < 0.00000 ? r7.x : r4.x, r0.y < 0.00000 ? r7.y : r4.y, r0.z < 0.00000 ? r7.z : r4.z);\n"
           "    r0.xyz = r1.xyz - c0.zzz;\n"
           "    r4.xyz = vec3(r0.x < 0.00000 ? r6.x : r4.x, r0.y < 0.00000 ? r6.y : r4.y, r0.z < 0.00000 ? r6.z : r4.z);\n"
           "    r7.xyz = r1.xyz - c2.xxx;\n"
           "    r4.xyz = vec3(r7.x < 0.00000 ? r3.x : r4.x, r7.y < 0.00000 ? r3.y : r4.y, r7.z < 0.00000 ? r3.z : r4.z);\n"
           "    r0.xyz = r1.xyz - c2.yyy;\n"
           "    r4.xyz = vec3(r0.x < 0.00000 ? r5.x : r4.x, r0.y < 0.00000 ? r5.y : r4.y, r0.z < 0.00000 ? r5.z : r4.z);\n"
           "    r1.xyz = r1.xyz - c1.yyy;\n"
           "    r4.xyz = vec3(r1.x < 0.00000 ? r2.x : r4.x, r1.y < 0.00000 ? r2.y : r4.y, r1.z < 0.00000 ? r2.z : r4.z);\n"
           "    r4.w = c1.y;\n"
           "    gl_FragColor = r4;\n"
           "}\n"
           "//MD5=81b6259d:b55db391:9900b607:19b19d79\n"
           "//SIG=00000000:00000000:00000000:00000000:0003:0001:0008:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorGamma_v210_yxzx_rgba_expand::InitProgramDescriptor(HgcColorGamma_v210_yxzx_rgba_expand *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_v210_yxzx_rgba_expand_hgc_visible", "//Metal1.0     \n//LEN=00000007db\n[[ visible ]] FragmentOut HgcColorGamma_v210_yxzx_rgba_expand_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.1666669995, 1.000000000, 4.000000000, 0.5000000000);\n"
    "    const float4 c1 = float4(6.000000000, 1.000000000, 0.000000000, 5.000000000);\n"
    "    const float4 c2 = float4(3.000000000, 2.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy*c0.xy;\n"
    "    r0.xy = floor(r0.xy);\n"
    "    r0.xy = r0.xy*c0.zy + c0.ww;\n"
    "    r1.xyz = floor(texCoord0.xxx);\n"
    "    r1.xyz = r1.xyz - c1.xxx*floor(r1.xyz/c1.xxx);\n"
    "    r2.xy = r0.xy + hg_Params[0].xy;\n"
    "    r2.xy = r2.xy*hg_Params[0].zw;\n"
    "    r2.xyz = hg_Texture0.sample(hg_Sampler0, r2.xy).xyz;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r3.xy = r0.xy + hg_Params[0].xy;\n"
    "    r3.xy = r3.xy*hg_Params[0].zw;\n"
    "    r3.xyz = hg_Texture0.sample(hg_Sampler0, r3.xy).xyz;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r4.xy = r0.xy + hg_Params[0].xy;\n"
    "    r4.xy = r4.xy*hg_Params[0].zw;\n"
    "    r4.xyz = hg_Texture0.sample(hg_Sampler0, r4.xy).xyz;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r0.xy = r0.xy + hg_Params[0].xy;\n"
    "    r0.xy = r0.xy*hg_Params[0].zw;\n"
    "    r0.xyz = hg_Texture0.sample(hg_Sampler0, r0.xy).xyz;\n"
    "    r2.xyz = r2.yxz;\n"
    "    r5.yz = r2.yz;\n"
    "    r5.x = r3.x;\n"
    "    r3.xy = r3.zy;\n"
    "    r3.z = r4.x;\n"
    "    r6.yz = r3.yz;\n"
    "    r6.x = r4.y;\n"
    "    r7.xz = r0.xy;\n"
    "    r7.y = r4.z;\n"
    "    r4.yz = r7.yz;\n"
    "    r4.x = r0.z;\n"
    "    r0.xyz = r1.xyz - c1.www;\n"
    "    r4.xyz = select(r4.xyz, r7.xyz, r0.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz - c0.zzz;\n"
    "    r4.xyz = select(r4.xyz, r6.xyz, r0.xyz < 0.00000f);\n"
    "    r7.xyz = r1.xyz - c2.xxx;\n"
    "    r4.xyz = select(r4.xyz, r3.xyz, r7.xyz < 0.00000f);\n"
    "    r0.xyz = r1.xyz - c2.yyy;\n"
    "    r4.xyz = select(r4.xyz, r5.xyz, r0.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz - c1.yyy;\n"
    "    r4.xyz = select(r4.xyz, r2.xyz, r1.xyz < 0.00000f);\n"
    "    r4.w = c1.y;\n"
    "    output.color0 = r4;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorGamma_v210_yxzx_rgba_expand");
}

void sub_1B7929810(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7929848(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7929840);
}

double HgcColorGamma_v210_yxzx_rgba_expand::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x30uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376FF0;
  strcpy(v3, "HgcColorGamma_v210_yxzx_rgba_expand [hgc1]");
  return *(double *)"ba_expand [hgc1]";
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::BindTexture(HgcColorGamma_v210_yxzx_rgba_expand *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, void, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 0, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::Bind(HgcColorGamma_v210_yxzx_rgba_expand *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::RenderTile(HgcColorGamma_v210_yxzx_rgba_expand *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      int v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      int32x2_t v7 = a2[2];
      uint64_t v8 = 16 * a2[3].i32[0];
      uint64_t v9 = 16 * v4;
      v10.i64[0] = 0x3F0000003F000000;
      v10.i64[1] = 0x3F0000003F000000;
      float32x4_t v11 = v6;
      do
      {
        uint64_t v12 = 0;
        float32x4_t v13 = v11;
        do
        {
          uint64_t v14 = *((void *)this + 51);
          float32x4_t v15 = *(float32x4_t *)(v14 + 16);
          float32x4_t v16 = vmulq_f32(v13, *(float32x4_t *)v14);
          float32x4_t v17 = vcvtq_f32_s32(vcvtq_s32_f32(v16));
          float32x4_t v18 = vmulq_f32(*(float32x4_t *)(v14 + 48), vsubq_f32(v17, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v17, v16))));
          float32x4_t v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0);
          float32x4_t v20 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
          float32x4_t v21 = vmulq_f32(*(float32x4_t *)(v14 + 64), vsubq_f32(v20, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v20, v19))));
          float32x4_t v22 = vaddq_f32(*(float32x4_t *)(v14 + 32), v18);
          float32x4_t v23 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
          __int32 v24 = a2[11].i32[0];
          float32x4_t v25 = vaddq_f32(vsubq_f32(v22, v6), v10);
          int32x4_t v26 = vcvtq_s32_f32(v25);
          v25.i64[0] = vaddq_s32(v26, vcgtq_f32(vcvtq_f32_s32(v26), v25)).u64[0];
          float32x4_t v27 = *(float32x4_t *)(v14 + 96);
          int8x16_t v28 = *(int8x16_t *)(v14 + 112);
          __int32 v29 = v25.i32[1];
          float32x4_t v30 = vaddq_f32(v22, v27);
          float32x4_t v31 = vaddq_f32(vsubq_f32(v30, v6), v10);
          int32x4_t v32 = vcvtq_s32_f32(v31);
          __int32 v33 = v25.i32[0];
          v25.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
          __int32 v34 = v25.i32[1];
          __int32 v35 = v25.i32[0];
          float32x4_t v36 = vaddq_f32(v27, v30);
          float32x4_t v37 = vaddq_f32(vsubq_f32(v36, v6), v10);
          int32x4_t v38 = vcvtq_s32_f32(v37);
          __int32 v39 = v33 + v29 * v24;
          v37.i64[0] = vaddq_s32(v38, vcgtq_f32(vcvtq_f32_s32(v38), v37)).u64[0];
          __int32 v40 = v37.i32[1];
          __int32 v41 = v37.i32[0];
          __int32 v42 = v35 + v34 * v24;
          float32x4_t v43 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v36), v6), v10);
          int32x4_t v44 = vcvtq_s32_f32(v43);
          __int32 v45 = v41 + v40 * v24;
          v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
          __int32 v46 = v43.i32[0] + v43.i32[1] * v24;
          int32x2_t v47 = a2[10];
          int8x16_t v48 = *(int8x16_t *)(*(void *)&v47 + 16 * v39);
          float32x4_t v49 = vmulq_f32(*(float32x4_t *)(v14 + 80), vsubq_f32(v21, vsubq_f32(v23, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v23, v21)))));
          int8x16_t v50 = *(int8x16_t *)(*(void *)&v47 + 16 * v42);
          *(int8x8_t *)v23.f32 = vqtbl1_s8(v48, *(int8x8_t *)v28.i8);
          int32x4_t v51 = *(int32x4_t *)(*(void *)&v47 + 16 * v45);
          *(int8x8_t *)&v23.u32[2] = vqtbl1_s8(v48, (int8x8_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
          int8x16_t v52 = *(int8x16_t *)(*(void *)&v47 + 16 * v46);
          *(int8x8_t *)v27.f32 = vqtbl1_s8(v50, *(int8x8_t *)(v14 + 144));
          v27.i64[1] = *(void *)(*(void *)&v47 + 16 * v45);
          int8x16_t v53 = (int8x16_t)vrev64q_s32(v51);
          v54.i64[0] = v52.u32[0];
          v54.i64[1] = v52.u32[1];
          int8x16_t v55 = vbslq_s8(*(int8x16_t *)(v14 + 160), vextq_s8((int8x16_t)v51, (int8x16_t)v51, 4uLL), v54);
          float32x4_t v56 = *(float32x4_t *)(v14 + 192);
          int8x16_t v57 = vbslq_s8((int8x16_t)vcgtq_f32(v56, vsubq_f32(v49, v15)), (int8x16_t)v23, vbslq_s8((int8x16_t)vcgtq_f32(v56, vsubq_f32(v49, *(float32x4_t *)(v14 + 240))), vbslq_s8(*(int8x16_t *)(v14 + 128), v50, (int8x16_t)v23), vbslq_s8((int8x16_t)vcgtq_f32(v56, vsubq_f32(v49, *(float32x4_t *)(v14 + 224))), (int8x16_t)v27, vbslq_s8((int8x16_t)vcgtq_f32(v56, vsubq_f32(v49, *(float32x4_t *)(v14 + 208))), vbslq_s8(*(int8x16_t *)(v14 + 128), v53, (int8x16_t)v27), vbslq_s8((int8x16_t)vcgtq_f32(v56, vsubq_f32(v49, *(float32x4_t *)(v14 + 176))), v55, vbslq_s8(*(int8x16_t *)(v14 + 128), vextq_s8(v52, v52, 8uLL), v55))))));
          v57.i32[3] = 1.0;
          *(int8x16_t *)(*(void *)&v7 + v12) = v57;
          float32x4_t v13 = vaddq_f32(v13, (float32x4_t)xmmword_1B7E736B0);
          v12 += 16;
        }
        while (v9 != v12);
        float32x4_t v11 = vaddq_f32(v11, (float32x4_t)xmmword_1B7E736C0);
        ++v5;
        *(void *)&v7 += v8;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::GetDOD(HgcColorGamma_v210_yxzx_rgba_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  int v4 = &HGRectInfinite;
  if (a3) {
    int v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcColorGamma_v210_yxzx_rgba_expand::HgcColorGamma_v210_yxzx_rgba_expand(HgcColorGamma_v210_yxzx_rgba_expand *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F4888;
  operator new();
}

void sub_1B7929E78(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_v210_yxzx_rgba_expand::~HgcColorGamma_v210_yxzx_rgba_expand(HGNode *this)
{
  *(void *)this = &unk_1F10F4888;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40104B78CFLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F4888;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40104B78CFLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F4888;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40104B78CFLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::SetParameter(HgcColorGamma_v210_yxzx_rgba_expand *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_expand::GetParameter(HgcColorGamma_v210_yxzx_rgba_expand *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcBlur_g4u2_noborder::GetProgram(HgcBlur_g4u2_noborder *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000c4a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    float4 s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord1.xy*hg_Params[4].xy;\n"
             "    s1.xy = s0.xy + frag._texCoord0.xy;\n"
             "    s1.zw = s1.xy + hg_Params[5].xy;\n"
             "    s0.xy = s1.zw + hg_Params[7].xy;\n"
             "    s0.zw = s0.xy*hg_Params[7].zw;\n"
             "    s0.xy = s0.zw + -float2(c0.xx);\n"
             "    s0.xy = s0.xy*hg_Params[8].zw;\n"
             "    s0.xy = abs(s0.xy);\n"
             "    s8.xy = s0.zw*hg_Params[9].xy;\n"
             "    s8.xy = fmax(s8.xy, float2(c0.xy));\n"
             "    s9.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s8.xy = fmin(s8.xy, s9.xy);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s8.xy);\n"
             "    s0.zw = clamp(-s0.xy + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    s0.xy = s1.xy + hg_Params[7].xy;\n"
             "    s0.z = s0.z*s0.w;\n"
             "    s0.xy = s0.xy*hg_Params[7].zw;\n"
             "    s2.xy = s0.xy + -float2(c0.xx);\n"
             "    s2.zw = s2.xy*hg_Params[8].zw;\n"
             "    s2.xy = s1.zw + hg_Params[6].xy;\n"
             "    s3 = float4(r0)*s0.zzzz;\n"
             "    s2.zw = abs(s2.zw);\n"
             "    s2.zw = clamp(-s2.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    s2.xy = s2.xy + hg_Params[7].xy;\n"
             "    s2.xy = s2.xy*hg_Params[7].zw;\n"
             "    s2.z = s2.z*s2.w;\n"
             "    s9.xy = s0.xy*hg_Params[9].xy;\n"
             "    s9.xy = fmax(s9.xy, float2(c0.xy));\n"
             "    s8.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s9.xy = fmin(s9.xy, s8.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s4 = float4(r1)*s2.zzzz + s3;\n"
             "    s2.zw = s1.xy + -hg_Params[6].xy;\n"
             "    s8.xy = s2.xy*hg_Params[9].xy;\n"
             "    s8.xy = fmax(s8.xy, float2(c0.xy));\n"
             "    s9.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s8.xy = fmin(s8.xy, s9.xy);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, s8.xy);\n"
             "    s2.zw = s2.zw + hg_Params[7].xy;\n"
             "    s2.xy = s2.xy + -float2(c0.xx);\n"
             "    s5.xy = s2.zw*hg_Params[7].zw;\n"
             "    s2.xy = s2.xy*hg_Params[8].zw;\n"
             "    s2.zw = abs(s2.xy);\n"
             "    s2.xy = s5.xy + -float2(c0.xx);\n"
             "    s2.zw = clamp(-s2.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    s2.xy = s2.xy*hg_Params[8].zw;\n"
             "    s5.zw = abs(s2.xy);\n"
             "    s2.z = s2.z*s2.w;\n"
             "    s2 = float4(r2)*s2.zzzz;\n"
             "    s9.xy = s5.xy*hg_Params[9].xy;\n"
             "    s9.xy = fmax(s9.xy, float2(c0.xy));\n"
             "    s8.xy = hg_Params[9].xy - float2(c0.xy);\n"
             "    s9.xy = fmin(s9.xy, s8.xy);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, s9.xy);\n"
             "    s5.zw = clamp(-s5.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    s5.x = s5.z*s5.w;\n"
             "    s2 = float4(r2)*s5.xxxx + s2;\n"
             "    r2 = half4(hg_Params[0]);\n"
             "    r3 = half4(hg_Params[1]);\n"
             "    s1.xy = floor(s1.xy);\n"
             "    s1.zw = floor(s1.zw);\n"
             "    s1.xy = s1.zw + -s1.xy;\n"
             "    s1.x = s1.x + s1.y;\n"
             "    r3 = -r3 + half4(hg_Params[3]);\n"
             "    s6 = s1.xxxx*float4(r3) + hg_Params[1];\n"
             "    r2 = -r2 + half4(hg_Params[2]);\n"
             "    s2 = s2*s6;\n"
             "    s7 = s1.xxxx*float4(r2) + hg_Params[0];\n"
             "    output.color0 = s4*s7 + s2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5c82e3c7:07ba83f7:2ad9cba3:69e3d725\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:000a:000e:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000b5b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord1.xy*hg_Params[4].xy;\n"
             "    r4.xy = r0.xy + frag._texCoord0.xy;\n"
             "    r4.zw = r4.xy + hg_Params[5].xy;\n"
             "    r0.xy = r4.zw + hg_Params[7].xy;\n"
             "    r0.zw = r0.xy*hg_Params[7].zw;\n"
             "    r0.xy = r0.zw + -c0.xx;\n"
             "    r0.xy = r0.xy*hg_Params[8].zw;\n"
             "    r0.xy = abs(r0.xy);\n"
             "    r5.xy = r0.zw*hg_Params[9].xy;\n"
             "    r5.xy = fmax(r5.xy, c0.xy);\n"
             "    r6.xy = hg_Params[9].xy - c0.xy;\n"
             "    r5.xy = fmin(r5.xy, r6.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
             "    r0.zw = clamp(-r0.xy + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    r0.xy = r4.xy + hg_Params[7].xy;\n"
             "    r0.z = r0.z*r0.w;\n"
             "    r0.xy = r0.xy*hg_Params[7].zw;\n"
             "    r2.xy = r0.xy + -c0.xx;\n"
             "    r2.zw = r2.xy*hg_Params[8].zw;\n"
             "    r2.xy = r4.zw + hg_Params[6].xy;\n"
             "    r1 = r1*r0.zzzz;\n"
             "    r2.zw = abs(r2.zw);\n"
             "    r2.zw = clamp(-r2.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    r2.xy = r2.xy + hg_Params[7].xy;\n"
             "    r2.xy = r2.xy*hg_Params[7].zw;\n"
             "    r2.z = r2.z*r2.w;\n"
             "    r6.xy = r0.xy*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r5.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r5.xy);\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r0 = r0*r2.zzzz + r1;\n"
             "    r2.zw = r4.xy + -hg_Params[6].xy;\n"
             "    r5.xy = r2.xy*hg_Params[9].xy;\n"
             "    r5.xy = fmax(r5.xy, c0.xy);\n"
             "    r6.xy = hg_Params[9].xy - c0.xy;\n"
             "    r5.xy = fmin(r5.xy, r6.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
             "    r2.zw = r2.zw + hg_Params[7].xy;\n"
             "    r2.xy = r2.xy + -c0.xx;\n"
             "    r3.xy = r2.zw*hg_Params[7].zw;\n"
             "    r2.xy = r2.xy*hg_Params[8].zw;\n"
             "    r2.zw = abs(r2.xy);\n"
             "    r2.xy = r3.xy + -c0.xx;\n"
             "    r2.zw = clamp(-r2.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    r2.xy = r2.xy*hg_Params[8].zw;\n"
             "    r3.zw = abs(r2.xy);\n"
             "    r2.z = r2.z*r2.w;\n"
             "    r2 = r1*r2.zzzz;\n"
             "    r6.xy = r3.xy*hg_Params[9].xy;\n"
             "    r6.xy = fmax(r6.xy, c0.xy);\n"
             "    r5.xy = hg_Params[9].xy - c0.xy;\n"
             "    r6.xy = fmin(r6.xy, r5.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
             "    r3.zw = clamp(-r3.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
             "    r3.x = r3.z*r3.w;\n"
             "    r2 = r1*r3.xxxx + r2;\n"
             "    r1 = hg_Params[0];\n"
             "    r3 = hg_Params[1];\n"
             "    r4.xy = floor(r4.xy);\n"
             "    r4.zw = floor(r4.zw);\n"
             "    r4.xy = r4.zw + -r4.xy;\n"
             "    r4.x = r4.x + r4.y;\n"
             "    r3 = -r3 + hg_Params[3];\n"
             "    r3 = r4.xxxx*r3 + hg_Params[1];\n"
             "    r1 = -r1 + hg_Params[2];\n"
             "    r2 = r2*r3;\n"
             "    r1 = r4.xxxx*r1 + hg_Params[0];\n"
             "    output.color0 = r0*r1 + r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bc2fcd6f:3857ab61:c84a8e17:e752aad0\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:000a:0007:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000bec\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "uniform highp vec4 hg_ProgramLocal8;\n"
           "uniform highp vec4 hg_ProgramLocal9;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    const highp vec4 c1 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0.xy = hg_TexCoord1.xy*hg_ProgramLocal4.xy;\n"
           "    r4.xy = r0.xy + hg_TexCoord0.xy;\n"
           "    r4.zw = r4.xy + hg_ProgramLocal5.xy;\n"
           "    r0.xy = r4.zw + hg_ProgramLocal7.xy;\n"
           "    r0.zw = r0.xy*hg_ProgramLocal7.zw;\n"
           "    r0.xy = r0.zw + -c0.xx;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal8.zw;\n"
           "    r0.xy = abs(r0.xy);\n"
           "    r5.xy = hg_ProgramLocal9.xy*c1.xy + r0.zw;\n"
           "    r1 = texture2D(hg_Texture0, r5.xy);\n"
           "    r0.zw = clamp(-r0.xy + hg_ProgramLocal8.xy, vec2(0.00000), vec2(1.00000));\n"
           "    r0.xy = r4.xy + hg_ProgramLocal7.xy;\n"
           "    r0.z = r0.z*r0.w;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal7.zw;\n"
           "    r2.xy = r0.xy + -c0.xx;\n"
           "    r2.zw = r2.xy*hg_ProgramLocal8.zw;\n"
           "    r2.xy = r4.zw + hg_ProgramLocal6.xy;\n"
           "    r1 = r1*r0.zzzz;\n"
           "    r2.zw = abs(r2.zw);\n"
           "    r2.zw = clamp(-r2.zw + hg_ProgramLocal8.xy, vec2(0.00000), vec2(1.00000));\n"
           "    r2.xy = r2.xy + hg_ProgramLocal7.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal7.zw;\n"
           "    r2.z = r2.z*r2.w;\n"
           "    r5.xy = hg_ProgramLocal9.xy*c1.xy + r0.xy;\n"
           "    r0 = texture2D(hg_Texture0, r5.xy);\n"
           "    r0 = r0*r2.zzzz + r1;\n"
           "    r2.zw = r4.xy + -hg_ProgramLocal6.xy;\n"
           "    r5.xy = hg_ProgramLocal9.xy*c1.xy + r2.xy;\n"
           "    r1 = texture2D(hg_Texture0, r5.xy);\n"
           "    r2.zw = r2.zw + hg_ProgramLocal7.xy;\n"
           "    r2.xy = r2.xy + -c0.xx;\n"
           "    r3.xy = r2.zw*hg_ProgramLocal7.zw;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal8.zw;\n"
           "    r2.zw = abs(r2.xy);\n"
           "    r2.xy = r3.xy + -c0.xx;\n"
           "    r2.zw = clamp(-r2.zw + hg_ProgramLocal8.xy, vec2(0.00000), vec2(1.00000));\n"
           "    r2.xy = r2.xy*hg_ProgramLocal8.zw;\n"
           "    r3.zw = abs(r2.xy);\n"
           "    r2.z = r2.z*r2.w;\n"
           "    r2 = r1*r2.zzzz;\n"
           "    r5.xy = hg_ProgramLocal9.xy*c1.xy + r3.xy;\n"
           "    r1 = texture2D(hg_Texture0, r5.xy);\n"
           "    r3.zw = clamp(-r3.zw + hg_ProgramLocal8.xy, vec2(0.00000), vec2(1.00000));\n"
           "    r3.x = r3.z*r3.w;\n"
           "    r2 = r1*r3.xxxx + r2;\n"
           "    r1 = hg_ProgramLocal0;\n"
           "    r3 = hg_ProgramLocal1;\n"
           "    r4.xy = floor(r4.xy);\n"
           "    r4.zw = floor(r4.zw);\n"
           "    r4.xy = r4.zw + -r4.xy;\n"
           "    r4.x = r4.x + r4.y;\n"
           "    r3 = -r3 + hg_ProgramLocal3;\n"
           "    r3 = r4.xxxx*r3 + hg_ProgramLocal1;\n"
           "    r1 = -r1 + hg_ProgramLocal2;\n"
           "    r2 = r2*r3;\n"
           "    r1 = r4.xxxx*r1 + hg_ProgramLocal0;\n"
           "    gl_FragColor = r0*r1 + r2;\n"
           "}\n"
           "//MD5=a34df5a0:4fe9daf3:c474f320:d4b51f6c\n"
           "//SIG=00000000:00000000:00000000:00000000:0002:000a:0006:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcBlur_g4u2_noborder::InitProgramDescriptor(HgcBlur_g4u2_noborder *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBlur_g4u2_noborder_hgc_visible", "//Metal1.0     \n//LEN=0000000ab3\n[[ visible ]] FragmentOut HgcBlur_g4u2_noborder_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord1.xy*hg_Params[4].xy;\n"
    "    r4.xy = r0.xy + texCoord0.xy;\n"
    "    r4.zw = r4.xy + hg_Params[5].xy;\n"
    "    r0.xy = r4.zw + hg_Params[7].xy;\n"
    "    r0.zw = r0.xy*hg_Params[7].zw;\n"
    "    r0.xy = r0.zw + -c0.xx;\n"
    "    r0.xy = r0.xy*hg_Params[8].zw;\n"
    "    r0.xy = abs(r0.xy);\n"
    "    r5.xy = r0.zw*hg_Params[9].xy;\n"
    "    r5.xy = fmax(r5.xy, c0.xy);\n"
    "    r6.xy = hg_Params[9].xy - c0.xy;\n"
    "    r5.xy = fmin(r5.xy, r6.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
    "    r0.zw = clamp(-r0.xy + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
    "    r0.xy = r4.xy + hg_Params[7].xy;\n"
    "    r0.z = r0.z*r0.w;\n"
    "    r0.xy = r0.xy*hg_Params[7].zw;\n"
    "    r2.xy = r0.xy + -c0.xx;\n"
    "    r2.zw = r2.xy*hg_Params[8].zw;\n"
    "    r2.xy = r4.zw + hg_Params[6].xy;\n"
    "    r1 = r1*r0.zzzz;\n"
    "    r2.zw = abs(r2.zw);\n"
    "    r2.zw = clamp(-r2.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
    "    r2.xy = r2.xy + hg_Params[7].xy;\n"
    "    r2.xy = r2.xy*hg_Params[7].zw;\n"
    "    r2.z = r2.z*r2.w;\n"
    "    r6.xy = r0.xy*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r5.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r5.xy);\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r0 = r0*r2.zzzz + r1;\n"
    "    r2.zw = r4.xy + -hg_Params[6].xy;\n"
    "    r5.xy = r2.xy*hg_Params[9].xy;\n"
    "    r5.xy = fmax(r5.xy, c0.xy);\n"
    "    r6.xy = hg_Params[9].xy - c0.xy;\n"
    "    r5.xy = fmin(r5.xy, r6.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r5.xy);\n"
    "    r2.zw = r2.zw + hg_Params[7].xy;\n"
    "    r2.xy = r2.xy + -c0.xx;\n"
    "    r3.xy = r2.zw*hg_Params[7].zw;\n"
    "    r2.xy = r2.xy*hg_Params[8].zw;\n"
    "    r2.zw = abs(r2.xy);\n"
    "    r2.xy = r3.xy + -c0.xx;\n"
    "    r2.zw = clamp(-r2.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
    "    r2.xy = r2.xy*hg_Params[8].zw;\n"
    "    r3.zw = abs(r2.xy);\n"
    "    r2.z = r2.z*r2.w;\n"
    "    r2 = r1*r2.zzzz;\n"
    "    r6.xy = r3.xy*hg_Params[9].xy;\n"
    "    r6.xy = fmax(r6.xy, c0.xy);\n"
    "    r5.xy = hg_Params[9].xy - c0.xy;\n"
    "    r6.xy = fmin(r6.xy, r5.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r6.xy);\n"
    "    r3.zw = clamp(-r3.zw + hg_Params[8].xy, 0.00000f, 1.00000f);\n"
    "    r3.x = r3.z*r3.w;\n"
    "    r2 = r1*r3.xxxx + r2;\n"
    "    r1 = hg_Params[0];\n"
    "    r3 = hg_Params[1];\n"
    "    r4.xy = floor(r4.xy);\n"
    "    r4.zw = floor(r4.zw);\n"
    "    r4.xy = r4.zw + -r4.xy;\n"
    "    r4.x = r4.x + r4.y;\n"
    "    r3 = -r3 + hg_Params[3];\n"
    "    r3 = r4.xxxx*r3 + hg_Params[1];\n"
    "    r1 = -r1 + hg_Params[2];\n"
    "    r2 = r2*r3;\n"
    "    r1 = r4.xxxx*r1 + hg_Params[0];\n"
    "    output.color0 = r0*r1 + r2;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBlur_g4u2_noborder");
}

void sub_1B792A484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B792A4C0(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B792A4B8);
}

double HgcBlur_g4u2_noborder::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376120;
  strcpy(v3, "HgcBlur_g4u2_noborder [hgc1]");
  return *(double *)"_noborder [hgc1]";
}

uint64_t HgcBlur_g4u2_noborder::BindTexture(HgcBlur_g4u2_noborder *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)a2 + 136))(a2, 9, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcBlur_g4u2_noborder::Bind(HgcBlur_g4u2_noborder *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBlur_g4u2_noborder::RenderTile(HgcBlur_g4u2_noborder *this, int32x2_t *a2)
{
  uint64_t v4 = HGTile::Renderer((HGTile *)a2);
  int v5 = (*(uint64_t (**)(HgcBlur_g4u2_noborder *, uint64_t))(*(void *)this + 312))(this, v4);
  int32x2_t v6 = *a2;
  int v7 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v7 >= 1)
  {
    int v8 = a2[1].i32[0] - v6.i32[0];
    if (v8 >= 1)
    {
      int v9 = 0;
      float32x2_t v10 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
      __asm { FMOV            V3.2S, #-1.0 }
      float32x2_t v16 = vadd_f32(v10, _D3);
      *(float32x2_t *)v17.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
      v17.i64[1] = 0x3F80000000000000;
      float32x2_t v18 = vadd_f32(v16, _D3);
      int32x2_t v19 = a2[2];
      uint64_t v20 = 16 * a2[3].i32[0];
      uint64_t v21 = 16 * v8;
      float32x4_t v22 = v17;
      do
      {
        uint64_t v23 = 0;
        float32x4_t v24 = v17;
        float32x4_t v25 = v22;
        do
        {
          uint64_t v46 = *((void *)this + 51);
          int8x16_t v47 = (int8x16_t)vaddq_f32(v24, vmulq_f32(v25, *(float32x4_t *)(v46 + 64)));
          int8x16_t v48 = (int8x16_t)vdupq_lane_s64(vaddq_f32(*(float32x4_t *)(v46 + 80), (float32x4_t)v47).i64[0], 0);
          float32x2_t v49 = (float32x2_t)vextq_s8(v48, v48, 8uLL).u64[0];
          int8x16_t v50 = *(int8x16_t *)(v46 + 112);
          float32x4_t v51 = (float32x4_t)vextq_s8(v50, v50, 8uLL);
          float32x2_t v52 = vmul_f32(*(float32x2_t *)v51.f32, vadd_f32(*(float32x2_t *)v50.i8, v49));
          int32x2_t v53 = a2[10];
          uint64_t v54 = a2[11].i32[0];
          float32x2_t v55 = vmul_f32(v10, v52);
          if (v5)
          {
            float32x2_t v56 = vmin_f32(vmax_f32(vadd_f32(v55, (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v57 = vcvt_s32_f32(vmin_f32(v56, v18));
            float32x2_t v58 = vsub_f32(v56, vcvt_f32_s32(v57));
            int32x4_t v59 = (float32x4_t *)(*(void *)&v53 + 16 * (v57.i32[0] + v57.i32[1] * (int)v54));
            float32x4_t v60 = vaddq_f32(*v59, vmulq_n_f32(vsubq_f32(v59[1], *v59), v58.f32[0]));
            float32x4_t v61 = vaddq_f32(v60, vmulq_lane_f32(vsubq_f32(vaddq_f32(v59[v54], vmulq_n_f32(vsubq_f32(v59[(int)v54 + 1], v59[v54]), v58.f32[0])), v60), v58, 1));
            v62.i64[1] = v48.i64[1];
            v62.i64[0] = v47.i64[0];
            float32x2_t v63 = vmul_f32(*(float32x2_t *)v51.f32, vadd_f32(*(float32x2_t *)v50.i8, *(float32x2_t *)v47.i8));
            float32x2_t v64 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v10, v63), (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v65 = vcvt_s32_f32(vmin_f32(v64, v18));
            float32x2_t v66 = vsub_f32(v64, vcvt_f32_s32(v65));
            int8x16_t v67 = (float32x4_t *)(*(void *)&v53 + 16 * (v65.i32[0] + v65.i32[1] * (int)v54));
            float32x4_t v68 = vaddq_f32(*v67, vmulq_n_f32(vsubq_f32(v67[1], *v67), v66.f32[0]));
            float32x4_t v69 = vaddq_f32(v68, vmulq_lane_f32(vsubq_f32(vaddq_f32(v67[v54], vmulq_n_f32(vsubq_f32(v67[(int)v54 + 1], v67[v54]), v66.f32[0])), v68), v66, 1));
          }
          else
          {
            int32x2_t v70 = vcvt_s32_f32(vmin_f32(vmax_f32(v55, 0), v16));
            float32x4_t v61 = *(float32x4_t *)(*(void *)&v53 + 16 * (v70.i32[0] + v70.i32[1] * (int)v54));
            v62.i64[1] = v48.i64[1];
            v62.i64[0] = v47.i64[0];
            float32x2_t v63 = vmul_f32(*(float32x2_t *)v51.f32, vadd_f32(*(float32x2_t *)v50.i8, *(float32x2_t *)v47.i8));
            int32x2_t v71 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v10, v63), 0), v16));
            float32x4_t v69 = *(float32x4_t *)(*(void *)&v53 + 16 * (v71.i32[0] + v71.i32[1] * (int)v54));
          }
          int8x16_t v72 = vextq_s8(v48, v47, 8uLL);
          float32x4_t v73 = *(float32x4_t *)(v46 + 96);
          float32x4_t v74 = vaddq_f32((float32x4_t)v72, v73);
          float32x4_t v75 = vmulq_f32(v51, vaddq_f32((float32x4_t)v50, v74));
          float32x2_t v76 = vmul_f32(v10, *(float32x2_t *)v75.f32);
          if (v5)
          {
            float32x2_t v77 = vmin_f32(vmax_f32(vadd_f32(v76, (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v78 = vcvt_s32_f32(vmin_f32(v77, v18));
            float32x2_t v79 = vsub_f32(v77, vcvt_f32_s32(v78));
            float32x4_t v80 = (float32x4_t *)(*(void *)&v53 + 16 * (v78.i32[0] + v78.i32[1] * (int)v54));
            float32x4_t v81 = vaddq_f32(*v80, vmulq_n_f32(vsubq_f32(v80[1], *v80), v79.f32[0]));
            float32x4_t v82 = vaddq_f32(v81, vmulq_lane_f32(vsubq_f32(vaddq_f32(v80[v54], vmulq_n_f32(vsubq_f32(v80[(int)v54 + 1], v80[v54]), v79.f32[0])), v81), v79, 1));
          }
          else
          {
            int32x2_t v83 = vcvt_s32_f32(vmin_f32(vmax_f32(v76, 0), v16));
            float32x4_t v82 = *(float32x4_t *)(*(void *)&v53 + 16 * (v83.i32[0] + v83.i32[1] * (int)v54));
          }
          float32x2_t v84 = vsub_f32((float32x2_t)*(_OWORD *)&vextq_s8(v72, v72, 8uLL), *(float32x2_t *)v73.f32);
          v85.i64[0] = v75.i64[0];
          *(float32x2_t *)&v85.u32[2] = v84;
          float32x4_t v86 = *(float32x4_t *)(v46 + 176);
          int8x16_t v87 = (int8x16_t)vaddq_f32(v86, v75);
          *(float32x2_t *)v51.f32 = vmul_f32(*(float32x2_t *)v51.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)vaddq_f32(v51, v85), v87, 8uLL));
          float32x2_t v88 = vmul_f32(v10, *(float32x2_t *)v51.f32);
          if (v5)
          {
            float32x2_t v89 = vmin_f32(vmax_f32(vadd_f32(v88, (float32x2_t)0xBF000000BF000000), 0), v16);
            int32x2_t v90 = vcvt_s32_f32(vmin_f32(v89, v18));
            float32x2_t v91 = vsub_f32(v89, vcvt_f32_s32(v90));
            __int32 v92 = (float32x4_t *)(*(void *)&v53 + 16 * (v90.i32[0] + v90.i32[1] * (int)v54));
            float32x4_t v93 = vaddq_f32(*v92, vmulq_n_f32(vsubq_f32(v92[1], *v92), v91.f32[0]));
            float32x4_t v27 = vaddq_f32(v93, vmulq_lane_f32(vsubq_f32(vaddq_f32(v92[v54], vmulq_n_f32(vsubq_f32(v92[(int)v54 + 1], v92[v54]), v91.f32[0])), v93), v91, 1));
          }
          else
          {
            int32x2_t v26 = vcvt_s32_f32(vmin_f32(vmax_f32(v88, 0), v16));
            float32x4_t v27 = *(float32x4_t *)(*(void *)&v53 + 16 * (v26.i32[0] + v26.i32[1] * (int)v54));
          }
          float32x4_t v28 = *(float32x4_t *)(v46 + 144);
          float32x4_t v29 = (float32x4_t)vextq_s8(*(int8x16_t *)(v46 + 128), *(int8x16_t *)(v46 + 128), 8uLL);
          *(int8x8_t *)v30.f32 = vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v29.f32, vadd_f32(*(float32x2_t *)v28.f32, v52)), *(int8x8_t *)(v46 + 160));
          *(float32x2_t *)&v30.u32[2] = v52;
          int8x16_t v31 = (int8x16_t)vnegq_f32(v30);
          float32x4_t v32 = vminq_f32(vmaxq_f32(vaddq_f32(v29, (float32x4_t)vextq_s8(v31, v31, 8uLL)), v28), v86);
          float32x4_t v33 = vmulq_laneq_f32(v61, vmulq_laneq_f32(v32, v32, 3), 2);
          *(int8x8_t *)&v74.u32[2] = vand_s8((int8x8_t)vmul_f32(*(float32x2_t *)v29.f32, vadd_f32(*(float32x2_t *)v86.f32, v63)), *(int8x8_t *)(v46 + 200));
          float32x4_t v34 = vminq_f32(vmaxq_f32(vsubq_f32(v29, v74), v28), v86);
          float32x4_t v35 = vaddq_f32(v33, vmulq_laneq_f32(v69, vmulq_laneq_f32(v34, v34, 3), 2));
          *(float32x2_t *)v34.f32 = vadd_f32(*(float32x2_t *)v86.f32, *(float32x2_t *)v51.f32);
          float32x2_t v36 = vmul_f32(*(float32x2_t *)v29.f32, *(float32x2_t *)v34.f32);
          *(float32x2_t *)&v34.u32[2] = vabs_f32(vmul_f32(*(float32x2_t *)v29.f32, *(float32x2_t *)v87.i8));
          float32x4_t v37 = vminq_f32(vmaxq_f32(vsubq_f32(v29, v34), v28), v86);
          *(float32x2_t *)&v51.u32[2] = vabs_f32(v36);
          float32x4_t v38 = vminq_f32(vmaxq_f32(vsubq_f32(v29, v51), v28), v86);
          float32x4_t v39 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
          int8x16_t v40 = *(int8x16_t *)(v46 + 208);
          int8x16_t v41 = (int8x16_t)vsubq_f32(v39, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v39, v62), v40, (int8x16_t)0));
          v39.i64[0] = v41.i64[0];
          *(float32x2_t *)&v39.u32[2] = v49;
          float32x4_t v42 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
          int8x16_t v43 = (int8x16_t)vsubq_f32(v42, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v42, v39), v40, (int8x16_t)0));
          float32x4_t v44 = (float32x4_t)vextq_s8(v43, v41, 8uLL);
          v41.i64[1] = v43.i64[1];
          float32x4_t v45 = vsubq_f32(v44, (float32x4_t)v41);
          v45.i32[0] = vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1)).u32[0];
          *(float32x4_t *)(*(void *)&v19 + v23) = vaddq_f32(vmulq_f32(v35, vaddq_f32(*(float32x4_t *)v46, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v46 + 32), *(float32x4_t *)v46), v45.f32[0]))), vmulq_f32(vaddq_f32(vmulq_laneq_f32(v82, vmulq_laneq_f32(v37, v37, 3), 2), vmulq_n_f32(v27, vmulq_laneq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 3), v38, 2).f32[0])), vaddq_f32(*(float32x4_t *)(v46 + 16), vmulq_n_f32(
                                                            vsubq_f32(*(float32x4_t *)(v46 + 48), *(float32x4_t *)(v46 + 16)), v45.f32[0]))));
          float32x4_t v24 = vaddq_f32(v24, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v25 = vaddq_f32(v25, (float32x4_t)xmmword_1B7E736B0);
          v23 += 16;
        }
        while (v21 != v23);
        float32x4_t v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B7E736C0);
        float32x4_t v22 = vaddq_f32(v22, (float32x4_t)xmmword_1B7E736C0);
        ++v9;
        *(void *)&v19 += v20;
      }
      while (v9 != v7);
    }
  }
  return 0;
}

uint64_t HgcBlur_g4u2_noborder::GetDOD(HgcBlur_g4u2_noborder *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = &HGRectInfinite;
  if (a3) {
    uint64_t v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcBlur_g4u2_noborder::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcBlur_g4u2_noborder::HgcBlur_g4u2_noborder(HgcBlur_g4u2_noborder *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F4AF0;
  operator new();
}

void sub_1B792AF48(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBlur_g4u2_noborder::~HgcBlur_g4u2_noborder(HGNode *this)
{
  *(void *)this = &unk_1F10F4AF0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C405DF52C91);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F4AF0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C405DF52C91);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F4AF0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C405DF52C91);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBlur_g4u2_noborder::SetParameter(HgcBlur_g4u2_noborder *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 8) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int v8 = a3;
  float32x2_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlur_g4u2_noborder::GetParameter(HgcBlur_g4u2_noborder *this, unsigned int a2, float *a3)
{
  if (a2 > 8) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorGamma_2vuy_xyxz_expand::GetProgram(HgcColorGamma_2vuy_xyxz_expand *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord0.xy*float2(c0.xy);\n"
             "    s0.xy = floor(s0.xy);\n"
             "    s0.xy = s0.xy + float2(c0.xx);\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    s0.x = float(fract(0.500000f*frag._texCoord0.x) >= 0.500000f);\n"
             "    r1 = half4(r0.z, r0.y, r0.w, 1.00000h);\n"
             "    s1.yzw = float3(r1.yzw);\n"
             "    s1.x = select(float(r1.x), float(r0.x), -s0.x < 0.00000h);\n"
             "    output.color0 = s1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e2f1359f:d962dc38:6d45378e:c9de3178\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0001:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ad\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy*c0.xy;\n"
             "    r0.xy = floor(r0.xy);\n"
             "    r0.xy = r0.xy + c0.xx;\n"
             "    r0.xy = r0.xy + hg_Params[0].xy;\n"
             "    r0.xy = r0.xy*hg_Params[0].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r1.x = float(fract(0.500000f*frag._texCoord0.x) >= 0.500000f);\n"
             "    r2 = float4(r0.z, r0.y, r0.w, 1.00000f);\n"
             "    r2.x = select(r2.x, r0.x, -r1.x < 0.00000f);\n"
             "    output.color0 = r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9c2db72b:e94c7326:0f4dea4f:07e48d03\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000386\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy*c0.xy;\n"
           "    r0.xy = floor(r0.xy);\n"
           "    r0.xy = r0.xy + c0.xx;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal0.zw;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r1.x = c0.x*hg_TexCoord0.x;\n"
           "    r1.x = fract(r1.x);\n"
           "    r1.x = float(r1.x >= c0.x);\n"
           "    r2 = vec4(r0.z, r0.y, r0.w, 1.00000);\n"
           "    r2.x = -r1.x < 0.00000 ? r0.x : r2.x;\n"
           "    gl_FragColor = r2;\n"
           "}\n"
           "//MD5=10673228:1a421a4c:e2f1387f:08423341\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorGamma_2vuy_xyxz_expand::InitProgramDescriptor(HgcColorGamma_2vuy_xyxz_expand *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_2vuy_xyxz_expand_hgc_visible", "//Metal1.0     \n//LEN=00000002f8\n[[ visible ]] FragmentOut HgcColorGamma_2vuy_xyxz_expand_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.5000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy*c0.xy;\n"
    "    r0.xy = floor(r0.xy);\n"
    "    r0.xy = r0.xy + c0.xx;\n"
    "    r0.xy = r0.xy + hg_Params[0].xy;\n"
    "    r0.xy = r0.xy*hg_Params[0].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r1.x = float(fract(0.500000f*texCoord0.x) >= 0.500000f);\n"
    "    r2 = float4(r0.z, r0.y, r0.w, 1.00000f);\n"
    "    r2.x = select(r2.x, r0.x, -r1.x < 0.00000f);\n"
    "    output.color0 = r2;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorGamma_2vuy_xyxz_expand");
}

void sub_1B792B584(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B792B5BC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B792B5B4);
}

char *HgcColorGamma_2vuy_xyxz_expand::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D30;
  strcpy(result, "HgcColorGamma_2vuy_xyxz_expand [hgc1]");
  return result;
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::BindTexture(HgcColorGamma_2vuy_xyxz_expand *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, void, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 0, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::Bind(HgcColorGamma_2vuy_xyxz_expand *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::RenderTile(HgcColorGamma_2vuy_xyxz_expand *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    int32x2_t v7 = a2[2];
    uint64_t v8 = 16 * a2[3].i32[0];
    v9.i64[0] = 0x3F0000003F000000;
    v9.i64[1] = 0x3F0000003F000000;
    float32x4_t v10 = v5;
    while (v6 < 3)
    {
      uint64_t v11 = 0;
      float32x4_t v13 = v10;
      if (v6 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v10 = vaddq_f32(v10, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      *(void *)&v7 += v8;
      if (v4 == v3) {
        return 0;
      }
    }
    uint64_t v11 = 0;
    int v12 = v6;
    float32x4_t v13 = v10;
    do
    {
      float32x4_t v14 = vaddq_f32(v13, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v15 = vaddq_f32(v14, (float32x4_t)xmmword_1B7E736B0);
      uint64_t v16 = *((void *)this + 51);
      int8x16_t v17 = *(int8x16_t *)(v16 + 16);
      float32x4_t v18 = vmulq_f32(v13, *(float32x4_t *)v16);
      float32x4_t v19 = vmulq_f32(v14, *(float32x4_t *)v16);
      float32x4_t v20 = vmulq_f32(v15, *(float32x4_t *)v16);
      float32x4_t v21 = vcvtq_f32_s32(vcvtq_s32_f32(v18));
      float32x4_t v22 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
      float32x4_t v23 = vcvtq_f32_s32(vcvtq_s32_f32(v20));
      float32x4_t v24 = vsubq_f32(v21, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v21, v18)));
      float32x4_t v25 = vsubq_f32(v22, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v22, v19)));
      float32x4_t v26 = vsubq_f32(v23, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v23, v20)));
      float32x4_t v27 = *(float32x4_t *)(v16 + 32);
      int8x16_t v28 = *(int8x16_t *)(v16 + 48);
      __int32 v29 = a2[11].i32[0];
      float32x4_t v30 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v24), v5), v9);
      int32x4_t v31 = vcvtq_s32_f32(v30);
      v30.i64[0] = vaddq_s32(v31, vcgtq_f32(vcvtq_f32_s32(v31), v30)).u64[0];
      __int32 v32 = v30.i32[1];
      float32x4_t v33 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v25), v5), v9);
      int32x4_t v34 = vcvtq_s32_f32(v33);
      __int32 v35 = v30.i32[0];
      v30.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
      __int32 v36 = v30.i32[1];
      __int32 v37 = v35 + v32 * v29;
      __int32 v38 = v30.i32[0];
      float32x4_t v39 = vaddq_f32(vsubq_f32(vaddq_f32(v27, v26), v5), v9);
      int32x4_t v40 = vcvtq_s32_f32(v39);
      __int32 v41 = v38 + v36 * v29;
      v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
      __int32 v42 = v39.i32[0] + v39.i32[1] * v29;
      int32x2_t v43 = a2[10];
      int8x16_t v44 = *(int8x16_t *)(*(void *)&v43 + 16 * v37);
      float32x4_t v45 = vmulq_f32(v13, v27);
      int8x16_t v46 = *(int8x16_t *)(*(void *)&v43 + 16 * v41);
      float32x4_t v47 = vmulq_f32(v14, v27);
      float32x4_t v48 = vmulq_f32(v15, v27);
      int8x16_t v49 = *(int8x16_t *)(*(void *)&v43 + 16 * v42);
      float32x4_t v50 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      float32x4_t v51 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      float32x4_t v52 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
      int8x16_t v53 = (int8x16_t)vcgeq_f32(vsubq_f32(v45, vsubq_f32(v50, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v50, v45)))), v27);
      int8x16_t v54 = (int8x16_t)vcgeq_f32(vsubq_f32(v47, vsubq_f32(v51, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v51, v47)))), v27);
      int8x16_t v55 = (int8x16_t)vcgeq_f32(vsubq_f32(v48, vsubq_f32(v52, (float32x4_t)vandq_s8(v17, (int8x16_t)vcgtq_f32(v52, v48)))), v27);
      float32x4_t v56 = (float32x4_t)vandq_s8(v17, v53);
      float32x4_t v57 = (float32x4_t)vandq_s8(v17, v54);
      *(int8x8_t *)v48.f32 = vqtbl1_s8(v44, *(int8x8_t *)v28.i8);
      v50.i64[0] = vextq_s8(v28, v28, 8uLL).u64[0];
      v48.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v44, *(int8x8_t *)v50.f32).u32[0]);
      *(int8x8_t *)v51.f32 = vqtbl1_s8(v46, *(int8x8_t *)v28.i8);
      v51.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v46, *(int8x8_t *)v50.f32).u32[0]);
      *(int8x8_t *)v28.i8 = vqtbl1_s8(v49, *(int8x8_t *)v28.i8);
      v28.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v49, *(int8x8_t *)v50.f32).u32[0]);
      float32x4_t v58 = (float32x4_t)vandq_s8(v17, v55);
      float32x4_t v60 = *(float32x4_t *)(v16 + 64);
      int8x16_t v59 = *(int8x16_t *)(v16 + 80);
      float32x4_t v61 = (int8x16_t *)(*(void *)&v7 + 16 * v11);
      *float32x4_t v61 = vbslq_s8(v59, vbslq_s8((int8x16_t)vcgtq_f32(v56, v60), v44, (int8x16_t)v48), (int8x16_t)v48);
      v61[1] = vbslq_s8(v59, vbslq_s8((int8x16_t)vcgtq_f32(v57, v60), v46, (int8x16_t)v51), (int8x16_t)v51);
      v61[2] = vbslq_s8(v59, vbslq_s8((int8x16_t)vcgtq_f32(v58, v60), v49, v28), v28);
      float32x4_t v13 = vaddq_f32(v15, (float32x4_t)xmmword_1B7E736B0);
      v11 += 3;
      v12 -= 3;
    }
    while (v12 > 2);
    uint64_t v11 = v11;
    if ((int)v11 >= v6) {
      goto LABEL_3;
    }
    do
    {
LABEL_10:
      uint64_t v62 = *((void *)this + 51);
      int8x16_t v63 = *(int8x16_t *)(v62 + 16);
      float32x4_t v64 = vmulq_f32(v13, *(float32x4_t *)v62);
      float32x4_t v65 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
      float32x4_t v66 = vsubq_f32(v65, (float32x4_t)vandq_s8(v63, (int8x16_t)vcgtq_f32(v65, v64)));
      float32x4_t v68 = *(float32x4_t *)(v62 + 32);
      int8x16_t v67 = *(int8x16_t *)(v62 + 48);
      float32x4_t v69 = vaddq_f32(vsubq_f32(vaddq_f32(v68, v66), v5), v9);
      int32x4_t v70 = vcvtq_s32_f32(v69);
      v69.i64[0] = vaddq_s32(v70, vcgtq_f32(vcvtq_f32_s32(v70), v69)).u64[0];
      __int32 v71 = v69.i32[0] + v69.i32[1] * a2[11].i32[0];
      float32x4_t v72 = vmulq_f32(v13, v68);
      float32x4_t v73 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
      int8x16_t v74 = *(int8x16_t *)(*(void *)&a2[10] + 16 * v71);
      int8x16_t v75 = (int8x16_t)vcgeq_f32(vsubq_f32(v72, vsubq_f32(v73, (float32x4_t)vandq_s8(v63, (int8x16_t)vcgtq_f32(v73, v72)))), v68);
      *(int8x8_t *)v68.f32 = vqtbl1_s8(v74, *(int8x8_t *)v67.i8);
      v68.i64[1] = __PAIR64__(1.0, vqtbl1_s8(v74, (int8x8_t)*(_OWORD *)&vextq_s8(v67, v67, 8uLL)).u32[0]);
      *(int8x16_t *)(*(void *)&v7 + 16 * v11) = vbslq_s8(*(int8x16_t *)(v62 + 80), vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8(v63, v75), *(float32x4_t *)(v62 + 64)), v74, (int8x16_t)v68), (int8x16_t)v68);
      float32x4_t v13 = vaddq_f32(v13, (float32x4_t)xmmword_1B7E736B0);
      ++v11;
    }
    while (v11 < v6);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::GetDOD(HgcColorGamma_2vuy_xyxz_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0, 0, 0);
  int v8 = HGRectGrow(v6, v5, v7);
  float v9 = HGRectFloat(v8);
  float v13 = HGRectScale(v9, v10, v11, v12, 2.0);
  uint64_t v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::GetROI(HgcColorGamma_2vuy_xyxz_expand *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 0.5);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  uint64_t v16 = v15;
  uint64_t v17 = HGRectMake4i(0, 0, 1u, 0);
  uint64_t v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcColorGamma_2vuy_xyxz_expand::HgcColorGamma_2vuy_xyxz_expand(HgcColorGamma_2vuy_xyxz_expand *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F4D58;
  operator new();
}

void sub_1B792BD44(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_2vuy_xyxz_expand::~HgcColorGamma_2vuy_xyxz_expand(HGNode *this)
{
  *(void *)this = &unk_1F10F4D58;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F4D58;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F4D58;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::SetParameter(HgcColorGamma_2vuy_xyxz_expand *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_2vuy_xyxz_expand::GetParameter(HgcColorGamma_2vuy_xyxz_expand *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcBlur_cs9s_es_noborder::GetProgram(HgcBlur_cs9s_es_noborder *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return aMetal10Len0000_1199;
    }
    else {
      return aMetal10Len0000_1200;
    }
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_448;
  }
}

void HgcBlur_cs9s_es_noborder::InitProgramDescriptor(HgcBlur_cs9s_es_noborder *this, HGProgramDescriptor *a2)
{
}

void sub_1B792C350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B792C38C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B792C384);
}

double HgcBlur_cs9s_es_noborder::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D70;
  strcpy(v3, "HgcBlur_cs9s_es_noborder [hgc1]");
  return *(double *)"_noborder [hgc1]";
}

uint64_t HgcBlur_cs9s_es_noborder::BindTexture(HgcBlur_cs9s_es_noborder *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1)
  {
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)a2 + 136))(a2, 10, (float)(*((_DWORD *)a2 + 49) - *((_DWORD *)a2 + 47)), (float)(*((_DWORD *)a2 + 50) - *((_DWORD *)a2 + 48)), 0.0, 0.0);
  return 0;
}

uint64_t HgcBlur_cs9s_es_noborder::Bind(HgcBlur_cs9s_es_noborder *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBlur_cs9s_es_noborder::RenderTile(HgcBlur_cs9s_es_noborder *this, int32x2_t *a2)
{
  uint64_t v4 = HGTile::Renderer((HGTile *)a2);
  int v5 = (*(uint64_t (**)(HgcBlur_cs9s_es_noborder *, uint64_t))(*(void *)this + 312))(this, v4);
  int32x2_t v6 = *a2;
  int v7 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v7 >= 1 && a2[1].i32[0] - v6.i32[0] >= 1)
  {
    int v8 = 0;
    float32x2_t v9 = vcvt_f32_s32(vsub_s32(a2[27], a2[26]));
    __asm { FMOV            V2.2S, #-1.0 }
    float32x2_t v15 = vadd_f32(v9, _D2);
    float32x2_t v16 = vadd_f32(v15, _D2);
    *(float32x2_t *)v17.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
    v17.i64[1] = 0x3F80000000000000;
    int32x2_t v18 = a2[2];
    uint64_t v19 = 16 * a2[3].i32[0];
    uint64_t v20 = 16 * (a2[1].i32[0] - v6.i32[0]);
    float32x4_t v21 = v17;
    float32x2_t v155 = v16;
    do
    {
      uint64_t v22 = 0;
      float32x4_t v153 = v21;
      float32x4_t v154 = v17;
      do
      {
        uint64_t v40 = *((void *)this + 51);
        int8x16_t v41 = (int8x16_t)vaddq_f32(*(float32x4_t *)(v40 + 96), vaddq_f32(v17, vmulq_f32(v21, *(float32x4_t *)(v40 + 80))));
        int8x16_t v42 = *(int8x16_t *)(v40 + 112);
        int8x16_t v43 = *(int8x16_t *)(v40 + 128);
        int8x16_t v44 = vextq_s8(v42, v42, 8uLL);
        int8x16_t v45 = (int8x16_t)vdupq_lane_s64(vaddq_f32((float32x4_t)v42, (float32x4_t)v41).i64[0], 0);
        float32x4_t v46 = vaddq_f32((float32x4_t)v42, (float32x4_t)vextq_s8(v45, v41, 8uLL));
        float32x4_t v47 = vaddq_f32((float32x4_t)v42, v46);
        int8x16_t v48 = (int8x16_t)vaddq_f32((float32x4_t)v42, v47);
        int8x16_t v49 = vextq_s8(v48, v48, 8uLL);
        int8x16_t v50 = (int8x16_t)vaddq_f32((float32x4_t)v44, (float32x4_t)v49);
        float32x4_t v51 = vaddq_f32((float32x4_t)v42, (float32x4_t)vdupq_laneq_s64((int64x2_t)v50, 1));
        int8x16_t v52 = vextq_s8(v43, v43, 8uLL);
        int8x16_t v54 = *(int8x16_t *)(v40 + 144);
        int8x16_t v53 = *(int8x16_t *)(v40 + 160);
        float32x2_t v55 = (float32x2_t)vextq_s8(v53, v53, 8uLL).u64[0];
        float32x2_t v56 = vmul_f32(*(float32x2_t *)v52.i8, vadd_f32(*(float32x2_t *)v43.i8, *(float32x2_t *)v51.f32));
        float32x4_t v57 = (float32x4_t)vextq_s8(v54, v54, 8uLL);
        v58.i64[0] = v46.i64[0];
        *(float32x2_t *)&v58.u32[2] = vabs_f32(vmul_f32(*(float32x2_t *)v57.f32, vadd_f32(v55, v56)));
        v63.i64[0] = vaddq_f32((float32x4_t)v43, v46).u64[0];
        float32x4_t v59 = vsubq_f32(v57, v58);
        float32x4_t v61 = *(float32x4_t *)(v40 + 176);
        float32x4_t v60 = *(float32x4_t *)(v40 + 192);
        float32x4_t v62 = vminq_f32(vmaxq_f32(v59, v61), v60);
        v63.i64[1] = v62.i64[1];
        float32x4_t v64 = vmulq_f32((float32x4_t)v52, v63);
        int32x2_t v65 = a2[10];
        uint64_t v66 = a2[11].i32[0];
        float32x2_t v67 = vmul_f32(v9, v56);
        float32x2_t v161 = v55;
        if (v5)
        {
          float32x2_t v68 = vmin_f32(vmax_f32(vadd_f32(v67, (float32x2_t)0xBF000000BF000000), 0), v15);
          int32x2_t v69 = vcvt_s32_f32(vmin_f32(v68, v16));
          float32x2_t v70 = vsub_f32(v68, vcvt_f32_s32(v69));
          float32x4_t v71 = vmulq_laneq_f32(v63, v62, 3);
          float32x2_t v72 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, *(float32x2_t *)v64.f32), (float32x2_t)0xBF000000BF000000), 0), v15);
          int32x2_t v73 = vcvt_s32_f32(vmin_f32(v72, v16));
          float32x2_t v74 = vsub_f32(v72, vcvt_f32_s32(v73));
          int32x2_t v75 = vmla_s32(vzip1_s32(v69, v73), vzip2_s32(v69, v73), vdup_n_s32(v66));
          float32x2_t v76 = (float32x4_t *)(*(void *)&v65 + 16 * v75.i32[0]);
          uint64_t v77 = (int)v66 + 1;
          float32x4_t v78 = vaddq_f32(*v76, vmulq_n_f32(vsubq_f32(v76[1], *v76), v70.f32[0]));
          float32x4_t v157 = vmulq_laneq_f32(vaddq_f32(v78, vmulq_lane_f32(vsubq_f32(vaddq_f32(v76[v66], vmulq_n_f32(vsubq_f32(v76[v77], v76[v66]), v70.f32[0])), v78), v70, 1)), v71, 2);
          float32x2_t v79 = (float32x4_t *)(*(void *)&v65 + 16 * v75.i32[1]);
          float32x4_t v80 = vaddq_f32(*v79, vmulq_n_f32(vsubq_f32(v79[1], *v79), v74.f32[0]));
          float32x4_t v81 = vaddq_f32(v80, vmulq_lane_f32(vsubq_f32(vaddq_f32(v79[v66], vmulq_n_f32(vsubq_f32(v79[v77], v79[v66]), v74.f32[0])), v80), v74, 1));
        }
        else
        {
          int32x2_t v82 = vcvt_s32_f32(vmin_f32(vmax_f32(v67, 0), v15));
          int32x2_t v83 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v9, *(float32x2_t *)v64.f32), 0), v15));
          int32x2_t v84 = vmla_s32(vzip1_s32(v82, v83), vzip2_s32(v82, v83), vdup_n_s32(v66));
          float32x4_t v157 = vmulq_laneq_f32(*(float32x4_t *)(*(void *)&v65 + 16 * v84.i32[0]), vmulq_laneq_f32(v63, v62, 3), 2);
          float32x4_t v81 = *(float32x4_t *)(*(void *)&v65 + 16 * v84.i32[1]);
        }
        float32x4_t v156 = v81;
        float32x4_t v86 = (float32x4_t)vextq_s8(v50, v50, 8uLL);
        float32x2_t v85 = (float32x2_t)vextq_s8(v52, v52, 8uLL).u64[0];
        *(float32x2_t *)v86.f32 = vmul_f32(*(float32x2_t *)v52.i8, vadd_f32(v85, *(float32x2_t *)v86.f32));
        float32x2_t v87 = vmul_f32(v9, *(float32x2_t *)v86.f32);
        if (v5)
        {
          float32x2_t v88 = vmin_f32(vmax_f32(vadd_f32(v87, (float32x2_t)0xBF000000BF000000), 0), v15);
          int32x2_t v89 = vcvt_s32_f32(vmin_f32(v88, v16));
          float32x2_t v90 = vsub_f32(v88, vcvt_f32_s32(v89));
          float32x2_t v91 = (float32x4_t *)(*(void *)&v65 + 16 * (v89.i32[0] + v89.i32[1] * (int)v66));
          float32x4_t v92 = vaddq_f32(*v91, vmulq_n_f32(vsubq_f32(v91[1], *v91), v90.f32[0]));
          float32x4_t v93 = vaddq_f32(v92, vmulq_lane_f32(vsubq_f32(vaddq_f32(v91[v66], vmulq_n_f32(vsubq_f32(v91[(int)v66 + 1], v91[v66]), v90.f32[0])), v92), v90, 1));
        }
        else
        {
          int32x2_t v94 = vcvt_s32_f32(vmin_f32(vmax_f32(v87, 0), v15));
          float32x4_t v93 = *(float32x4_t *)(*(void *)&v65 + 16 * (v94.i32[0] + v94.i32[1] * (int)v66));
        }
        float32x4_t v160 = v93;
        int8x16_t v95 = (int8x16_t)vmulq_f32(v57, vaddq_f32(v60, v64));
        float32x4_t v96 = vminq_f32(vmaxq_f32(vsubq_f32(v57, vabsq_f32((float32x4_t)vextq_s8(v95, v95, 8uLL))), v61), v60);
        v97.i64[0] = vaddq_f32(v60, v86).u64[0];
        float32x4_t v98 = vmulq_laneq_f32(v96, v96, 3);
        v97.i64[1] = v98.i64[1];
        int8x16_t v99 = (int8x16_t)vnegq_f32(vabsq_f32(vmulq_f32(v57, v97)));
        float32x4_t v100 = vminq_f32(vmaxq_f32(vaddq_f32(v57, (float32x4_t)vextq_s8(v99, v99, 8uLL)), v61), v60);
        v101.i64[0] = vaddq_f32((float32x4_t)v43, v47).u64[0];
        float32x4_t v102 = vmulq_laneq_f32(v100, v100, 3);
        v101.i64[1] = v102.i64[1];
        float32x2_t v103 = (float32x2_t)vmulq_f32((float32x4_t)v52, v101).u64[0];
        float32x2_t v104 = vmul_f32(v9, v103);
        if (v5)
        {
          float32x2_t v105 = vmin_f32(vmax_f32(vadd_f32(v104, (float32x2_t)0xBF000000BF000000), 0), v15);
          int32x2_t v106 = vcvt_s32_f32(vmin_f32(v105, v16));
          float32x2_t v107 = vsub_f32(v105, vcvt_f32_s32(v106));
          float32x4_t v108 = (float32x4_t *)(*(void *)&v65 + 16 * (v106.i32[0] + v106.i32[1] * (int)v66));
          float32x4_t v109 = vaddq_f32(*v108, vmulq_n_f32(vsubq_f32(v108[1], *v108), v107.f32[0]));
          float32x4_t v159 = vaddq_f32(v109, vmulq_lane_f32(vsubq_f32(vaddq_f32(v108[v66], vmulq_n_f32(vsubq_f32(v108[(int)v66 + 1], v108[v66]), v107.f32[0])), v109), v107, 1));
          float32x2_t v110 = vmul_f32(*(float32x2_t *)v52.i8, vadd_f32(v85, (float32x2_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL)));
          float32x2_t v111 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, v110), (float32x2_t)0xBF000000BF000000), 0), v15);
          int32x2_t v112 = vcvt_s32_f32(vmin_f32(v111, v16));
          float32x2_t v113 = vsub_f32(v111, vcvt_f32_s32(v112));
          float32x4_t v114 = (float32x4_t *)(*(void *)&v65 + 16 * (v112.i32[0] + v112.i32[1] * (int)v66));
          float32x4_t v115 = vaddq_f32(*v114, vmulq_n_f32(vsubq_f32(v114[1], *v114), v113.f32[0]));
          float32x4_t v116 = vaddq_f32(v115, vmulq_lane_f32(vsubq_f32(vaddq_f32(v114[v66], vmulq_n_f32(vsubq_f32(v114[(int)v66 + 1], v114[v66]), v113.f32[0])), v115), v113, 1));
        }
        else
        {
          int32x2_t v117 = vcvt_s32_f32(vmin_f32(vmax_f32(v104, 0), v15));
          float32x4_t v159 = *(float32x4_t *)(*(void *)&v65 + 16 * (v117.i32[0] + v117.i32[1] * (int)v66));
          float32x2_t v110 = vmul_f32(*(float32x2_t *)v52.i8, vadd_f32(v85, (float32x2_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL)));
          int32x2_t v118 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v9, v110), 0), v15));
          float32x4_t v116 = *(float32x4_t *)(*(void *)&v65 + 16 * (v118.i32[0] + v118.i32[1] * (int)v66));
        }
        float32x4_t v158 = v116;
        v42.i64[0] = vaddq_f32((float32x4_t)v42, v51).u64[0];
        int8x16_t v119 = (int8x16_t)vdupq_lane_s64(v42.i64[0], 0);
        float32x2_t v120 = (float32x2_t)vextq_s8(v119, v119, 8uLL).u64[0];
        *(float32x2_t *)v51.f32 = vmul_f32(*(float32x2_t *)v52.i8, vadd_f32(v85, v120));
        float32x2_t v121 = vmul_f32(v9, *(float32x2_t *)v51.f32);
        if (v5)
        {
          float32x2_t v122 = vmin_f32(vmax_f32(vadd_f32(v121, (float32x2_t)0xBF000000BF000000), 0), v15);
          int32x2_t v123 = vcvt_s32_f32(vmin_f32(v122, v16));
          float32x2_t v124 = vsub_f32(v122, vcvt_f32_s32(v123));
          __int32 v125 = (float32x4_t *)(*(void *)&v65 + 16 * (v123.i32[0] + v123.i32[1] * (int)v66));
          float32x4_t v126 = vaddq_f32(*v125, vmulq_n_f32(vsubq_f32(v125[1], *v125), v124.f32[0]));
          float32x4_t v127 = vaddq_f32(v126, vmulq_lane_f32(vsubq_f32(vaddq_f32(v125[v66], vmulq_n_f32(vsubq_f32(v125[(int)v66 + 1], v125[v66]), v124.f32[0])), v126), v124, 1));
          int8x16_t v128 = (int8x16_t)vmulq_f32((float32x4_t)v43, vaddq_f32((float32x4_t)v52, (float32x4_t)v45));
          float32x2_t v129 = (float32x2_t)vextq_s8(v128, v128, 8uLL).u64[0];
          *(float32x2_t *)v128.i8 = vmin_f32(vmax_f32(vadd_f32(vmul_f32(v9, v129), (float32x2_t)0xBF000000BF000000), 0), v15);
          *(int32x2_t *)v126.f32 = vcvt_s32_f32(vmin_f32(*(float32x2_t *)v128.i8, v16));
          *(float32x2_t *)v128.i8 = vsub_f32(*(float32x2_t *)v128.i8, vcvt_f32_s32(*(int32x2_t *)v126.f32));
          float32x4_t v130 = (float32x4_t *)(*(void *)&v65 + 16 * (v126.i32[0] + v126.i32[1] * (int)v66));
          float32x4_t v131 = vaddq_f32(*v130, vmulq_n_f32(vsubq_f32(v130[1], *v130), *(float *)v128.i32));
          float32x4_t v132 = vaddq_f32(v131, vmulq_lane_f32(vsubq_f32(vaddq_f32(v130[v66], vmulq_n_f32(vsubq_f32(v130[(int)v66 + 1], v130[v66]), *(float *)v128.i32)), v131), *(float32x2_t *)v128.i8, 1));
        }
        else
        {
          int32x2_t v133 = vcvt_s32_f32(vmin_f32(vmax_f32(v121, 0), v15));
          float32x4_t v127 = *(float32x4_t *)(*(void *)&v65 + 16 * (v133.i32[0] + v133.i32[1] * (int)v66));
          int8x16_t v134 = (int8x16_t)vmulq_f32((float32x4_t)v43, vaddq_f32((float32x4_t)v52, (float32x4_t)v45));
          float32x2_t v129 = (float32x2_t)vextq_s8(v134, v134, 8uLL).u64[0];
          *(int32x2_t *)v134.i8 = vcvt_s32_f32(vmin_f32(vmax_f32(vmul_f32(v9, v129), 0), v15));
          float32x4_t v132 = *(float32x4_t *)(*(void *)&v65 + 16 * (v134.i32[0] + v134.i32[1] * (int)v66));
        }
        *(float32x2_t *)v135.f32 = vmul_f32(*(float32x2_t *)v52.i8, vadd_f32(v85, vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL), v120)));
        float32x2_t v136 = vmul_f32(v9, *(float32x2_t *)v135.f32);
        if (v5)
        {
          float32x2_t v137 = vmin_f32(vmax_f32(vadd_f32(v136, (float32x2_t)0xBF000000BF000000), 0), v15);
          int32x2_t v138 = vcvt_s32_f32(vmin_f32(v137, v16));
          float32x2_t v139 = vsub_f32(v137, vcvt_f32_s32(v138));
          __int32 v140 = (float32x4_t *)(*(void *)&v65 + 16 * (v138.i32[0] + v138.i32[1] * (int)v66));
          float32x4_t v141 = vaddq_f32(*v140, vmulq_n_f32(vsubq_f32(v140[1], *v140), v139.f32[0]));
          float32x4_t v142 = vaddq_f32(v141, vmulq_lane_f32(vsubq_f32(vaddq_f32(v140[v66], vmulq_n_f32(vsubq_f32(v140[(int)v66 + 1], v140[v66]), v139.f32[0])), v141), v139, 1));
        }
        else
        {
          int32x2_t v143 = vcvt_s32_f32(vmin_f32(vmax_f32(v136, 0), v15));
          float32x4_t v142 = *(float32x4_t *)(*(void *)&v65 + 16 * (v143.i32[0] + v143.i32[1] * (int)v66));
        }
        v135.i64[1] = v41.i64[0];
        int8x16_t v144 = (int8x16_t)vaddq_f32((float32x4_t)v52, v135);
        int8x16_t v145 = (int8x16_t)vmulq_f32(v57, vaddq_f32(v60, v135));
        v41.i64[0] = vmulq_f32((float32x4_t)v52, (float32x4_t)vextq_s8(v144, v145, 8uLL)).u64[0];
        float32x2_t v146 = vmul_f32(v9, *(float32x2_t *)v41.i8);
        if (v5)
        {
          float32x2_t v147 = vmin_f32(vmax_f32(vadd_f32(v146, (float32x2_t)0xBF000000BF000000), 0), v15);
          float32x2_t v16 = v155;
          int32x2_t v148 = vcvt_s32_f32(vmin_f32(v147, v155));
          float32x2_t v149 = vsub_f32(v147, vcvt_f32_s32(v148));
          int32x4_t v150 = (float32x4_t *)(*(void *)&v65 + 16 * (v148.i32[0] + v148.i32[1] * (int)v66));
          float32x4_t v151 = vaddq_f32(*v150, vmulq_n_f32(vsubq_f32(v150[1], *v150), v149.f32[0]));
          float32x4_t v24 = vaddq_f32(v151, vmulq_lane_f32(vsubq_f32(vaddq_f32(v150[v66], vmulq_n_f32(vsubq_f32(v150[(int)v66 + 1], v150[v66]), v149.f32[0])), v151), v149, 1));
        }
        else
        {
          int32x2_t v23 = vcvt_s32_f32(vmin_f32(vmax_f32(v146, 0), v15));
          float32x4_t v24 = *(float32x4_t *)(*(void *)&v65 + 16 * (v23.i32[0] + v23.i32[1] * (int)v66));
          float32x2_t v16 = v155;
        }
        *(float32x2_t *)v25.f32 = vmul_f32(*(float32x2_t *)v57.f32, vadd_f32(*(float32x2_t *)v60.f32, v110));
        *(int8x8_t *)v26.f32 = vand_s8(*(int8x8_t *)(v40 + 224), *(int8x8_t *)v25.f32);
        *(int8x8_t *)&v25.u32[2] = vand_s8(*(int8x8_t *)(v40 + 216), (int8x8_t)vmul_f32(*(float32x2_t *)v57.f32, vadd_f32(*(float32x2_t *)v60.f32, v103)));
        float32x4_t v27 = vminq_f32(vmaxq_f32(vsubq_f32(v57, v25), v61), v60);
        int8x16_t v28 = (int8x16_t)vmulq_laneq_f32(v27, v27, 3);
        v26.i64[1] = vextq_s8(v28, v28, 8uLL).u64[0];
        int32x2_t v29 = (int32x2_t)vminq_f32(vmaxq_f32(vsubq_f32((float32x4_t)v54, v26), v61), (float32x4_t)v53).u64[0];
        float32x4_t v30 = vaddq_f32(vmulq_f32(vaddq_f32(vmulq_laneq_f32(v160, v102, 2), vmulq_laneq_f32(v159, (float32x4_t)v28, 2)), *(float32x4_t *)(v40 + 16)), vmulq_f32(*(float32x4_t *)v40, vmulq_laneq_f32(v158, vmulq_n_f32((float32x4_t)vdupq_lane_s32(v29, 1), *(float *)v29.i32), 2)));
        v51.i64[1] = v42.i64[0];
        v31.i64[0] = v42.i64[0];
        *(float32x2_t *)&v31.u32[2] = vabs_f32((float32x2_t)*(_OWORD *)&vmulq_f32(v57, vaddq_f32(v60, v51)));
        float32x4_t v32 = vaddq_f32(vmulq_f32(vaddq_f32(v157, vmulq_laneq_f32(v156, v98, 2)), *(float32x4_t *)(v40 + 32)), v30);
        float32x4_t v33 = vminq_f32(vmaxq_f32(vsubq_f32(v57, v31), v61), v60);
        v42.u64[1] = (unint64_t)vadd_f32(v161, v129);
        int8x16_t v34 = (int8x16_t)vnegq_f32(vabsq_f32(vmulq_f32((float32x4_t)v54, (float32x4_t)v42)));
        float32x4_t v35 = vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)v54, (float32x4_t)vextq_s8(v34, v34, 8uLL)), v61), (float32x4_t)v53);
        float32x4_t v36 = vaddq_f32(v32, vmulq_f32(*(float32x4_t *)(v40 + 48), vaddq_f32(vmulq_n_f32(v127, vmulq_laneq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 3), v33, 2).f32[0]), vmulq_n_f32(v132, vmulq_lane_f32(v35, *(float32x2_t *)v35.f32, 1).f32[0]))));
        v145.i64[1] = vmulq_f32(*(float32x4_t *)&v54, vaddq_f32(*(float32x4_t *)&v53, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v41, 0))).i64[1];
        float32x4_t v37 = vabsq_f32((float32x4_t)v145);
        v41.i64[1] = v37.i64[1];
        float32x4_t v38 = vminq_f32(vmaxq_f32(vsubq_f32((float32x4_t)v54, v37), v61), (float32x4_t)v53);
        float32x4_t v39 = vminq_f32(vmaxq_f32(vsubq_f32(v57, (float32x4_t)v41), v61), v60);
        *(float32x4_t *)(*(void *)&v18 + v22) = vaddq_f32(v36, vmulq_f32(*(float32x4_t *)(v40 + 64), vaddq_f32(vmulq_n_f32(v142, vmulq_lane_f32(v38, *(float32x2_t *)v38.f32, 1).f32[0]), vmulq_n_f32(v24, vmulq_laneq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 3), v39, 2).f32[0]))));
        float32x4_t v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B7E736B0);
        float32x4_t v21 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E736B0);
        v22 += 16;
      }
      while (v20 != v22);
      float32x4_t v17 = vaddq_f32(v154, (float32x4_t)xmmword_1B7E736C0);
      float32x4_t v21 = vaddq_f32(v153, (float32x4_t)xmmword_1B7E736C0);
      ++v8;
      *(void *)&v18 += v19;
    }
    while (v8 != v7);
  }
  return 0;
}

uint64_t HgcBlur_cs9s_es_noborder::GetDOD(HgcBlur_cs9s_es_noborder *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = &HGRectInfinite;
  if (a3) {
    uint64_t v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcBlur_cs9s_es_noborder::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcBlur_cs9s_es_noborder::HgcBlur_cs9s_es_noborder(HgcBlur_cs9s_es_noborder *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F4FC0;
  operator new();
}

void sub_1B792D284(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(HGNode *this)
{
  *(void *)this = &unk_1F10F4FC0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4019FCA701);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F4FC0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4019FCA701);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F4FC0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4019FCA701);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBlur_cs9s_es_noborder::SetParameter(HgcBlur_cs9s_es_noborder *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 9) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBlur_cs9s_es_noborder::GetParameter(HgcBlur_cs9s_es_noborder *this, unsigned int a2, float *a3)
{
  if (a2 > 9) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcPixelFormatConversion_kV4S_BE_WXYZ_output::GetProgram(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048) {
    return "//Metal1.0     \n"
  }
           "//LEN=000000031d\n"
           "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
           "    const constant float4* hg_Params [[ buffer(0) ]], \n"
           "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
           "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    const float4 c0 = float4(255.9960938, 256.0000000, 1.525902189e-05, 0.000000000);\n"
           "    float4 r0, r1;\n"
           "    FragmentOut output;\n"
           "\n"
           "    r0 = clamp(hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy), 0.00000f, 1.00000f);\n"
           "    r0 = r0*c0.xxxx;\n"
           "    r1 = fract(r0);\n"
           "    r1 = r1*c0.yyyy;\n"
           "    r1 = floor(r1);\n"
           "    r0 = floor(r0);\n"
           "    r1 = r1*c0.yyyy + r0;\n"
           "    output.color0 = r1.wxyz*c0.zzzz;\n"
           "    return output;\n"
           "}\n"
           "//MD5=13ee12da:76615530:14d039ae:fe550c56\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  if (Target <= 0x6060F || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)) {
    return 0;
  }
  return "//GLfs2.0      \n"
         "//LEN=00000002cc\n"
         "#ifndef GL_ES\n"
         "#define lowp\n"
         "#define mediump\n"
         "#define highp\n"
         "#endif\n"
         "#define defaultp mediump\n"
         "uniform defaultp sampler2D hg_Texture0;\n"
         "varying highp vec4 hg_TexCoord0;\n"
         "void main()\n"
         "{\n"
         "    const mediump vec4 c0 = vec4(255.9960938, 256.0000000, 1.525902189e-05, 0.000000000);\n"
         "    mediump vec4 r0, r1;\n"
         "\n"
         "    r0 = clamp(texture2D(hg_Texture0, hg_TexCoord0.xy), vec4(0.00000), vec4(1.00000));\n"
         "    r0 = r0*c0.xxxx;\n"
         "    r1 = fract(r0);\n"
         "    r1 = r1*c0.yyyy;\n"
         "    r1 = floor(r1);\n"
         "    r0 = floor(r0);\n"
         "    r1 = r1*c0.yyyy + r0;\n"
         "    gl_FragColor = r1.wxyz*c0.zzzz;\n"
         "}\n"
         "//MD5=6e72eee3:66e0366d:476be069:a678dd79\n"
         "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
}

void HgcPixelFormatConversion_kV4S_BE_WXYZ_output::InitProgramDescriptor(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4S_BE_WXYZ_output_hgc_visible", "//Metal1.0     \n//LEN=0000000213\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4S_BE_WXYZ_output_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(255.9960938, 256.0000000, 1.525902189e-05, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = clamp(color0, 0.00000f, 1.00000f);\n"
    "    r0 = r0*c0.xxxx;\n"
    "    r1 = fract(r0);\n"
    "    r1 = r1*c0.yyyy;\n"
    "    r1 = floor(r1);\n"
    "    r0 = floor(r0);\n"
    "    r1 = r1*c0.yyyy + r0;\n"
    "    output.color0 = r1.wxyz*c0.zzzz;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcPixelFormatConversion_kV4S_BE_WXYZ_output");
}

void sub_1B792D754(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B792D784(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B792D77CLL);
}

double HgcPixelFormatConversion_kV4S_BE_WXYZ_output::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x38uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B7EC1840;
  strcpy(v3, "HgcPixelFormatConversion_kV4S_BE_WXYZ_output [hgc1]");
  return *(double *)"_WXYZ_output [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::BindTexture(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::Bind(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::RenderTile(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v59 = 0;
        uint64_t v60 = 16 * v7;
        uint64_t v61 = 16 * v6;
        uint64_t v62 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v63 = 0;
          do
          {
            float32x4_t v64 = (float32x4_t *)*((void *)this + 51);
            float32x4_t v65 = v64[1];
            float32x4_t v66 = v64[3];
            float32x4_t v67 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v63 / 0x10], *v64), v65), v64[2]);
            float32x4_t v68 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
            float32x4_t v69 = vsubq_f32(v68, (float32x4_t)vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_f32(v68, v67)));
            float32x4_t v70 = vmulq_f32(v66, vsubq_f32(v67, v69));
            float32x4_t v71 = vcvtq_f32_s32(vcvtq_s32_f32(v70));
            int8x16_t v72 = (int8x16_t)vaddq_f32(v69, vmulq_f32(v66, vsubq_f32(v71, (float32x4_t)vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_f32(v71, v70)))));
            v5[v63 / 0x10] = vmulq_f32(v64[4], (float32x4_t)vextq_s8(v72, v72, 0xCuLL));
            v63 += 16;
          }
          while (v62 != v63);
          ++v59;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v60);
          int v5 = (float32x4_t *)((char *)v5 + v61);
        }
        while (v59 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float v11 = v4 + 4;
      float v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        uint64_t v14 = v12;
        float32x2_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = v15;
          int32x2_t v18 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v19 = v18[1];
          uint64_t v20 = v14;
          float32x4_t v21 = v18[2];
          float32x4_t v22 = v18[3];
          float32x4_t v23 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16 - 2], *v18), v19), v21);
          float32x4_t v24 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16 - 1], *v18), v19), v21);
          float32x4_t v25 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16], *v18), v19), v21);
          float32x4_t v26 = vmulq_f32(vminq_f32(vmaxq_f32(v4[v16 + 1], *v18), v19), v21);
          float32x4_t v27 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
          float32x4_t v28 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
          float32x4_t v29 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
          float32x4_t v30 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
          float32x4_t v31 = vsubq_f32(v27, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v27, v23)));
          float32x4_t v32 = vsubq_f32(v28, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v28, v24)));
          float32x4_t v33 = vsubq_f32(v29, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v29, v25)));
          float32x4_t v34 = vsubq_f32(v30, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v30, v26)));
          float32x4_t v35 = vmulq_f32(v22, vsubq_f32(v23, v31));
          float32x4_t v36 = vmulq_f32(v22, vsubq_f32(v24, v32));
          float32x4_t v37 = vmulq_f32(v22, vsubq_f32(v25, v33));
          float32x4_t v38 = vmulq_f32(v22, vsubq_f32(v26, v34));
          float32x4_t v39 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
          float32x4_t v40 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
          float32x4_t v41 = vcvtq_f32_s32(vcvtq_s32_f32(v37));
          float32x4_t v42 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
          int8x16_t v43 = (int8x16_t)vaddq_f32(v31, vmulq_f32(v22, vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v39, v35)))));
          int8x16_t v44 = (int8x16_t)vaddq_f32(v32, vmulq_f32(v22, vsubq_f32(v40, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v40, v36)))));
          int8x16_t v45 = (int8x16_t)vaddq_f32(v33, vmulq_f32(v22, vsubq_f32(v41, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v41, v37)))));
          int8x16_t v46 = (int8x16_t)vaddq_f32(v34, vmulq_f32(v22, vsubq_f32(v42, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v42, v38)))));
          float32x4_t v47 = v18[4];
          int8x16_t v48 = &v5[v16];
          v13 += 4;
          v48[-2] = vmulq_f32(v47, (float32x4_t)vextq_s8(v43, v43, 0xCuLL));
          v48[-1] = vmulq_f32(v47, (float32x4_t)vextq_s8(v44, v44, 0xCuLL));
          *int8x16_t v48 = vmulq_f32(v47, (float32x4_t)vextq_s8(v45, v45, 0xCuLL));
          v48[1] = vmulq_f32(v47, (float32x4_t)vextq_s8(v46, v46, 0xCuLL));
          v16 += 4;
          float32x2_t v15 = v17 + 4;
          v14 += 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            float32x4_t v49 = *v17++;
            int8x16_t v50 = (float32x4_t *)*((void *)this + 51);
            float32x4_t v51 = v50[1];
            float32x4_t v52 = v50[3];
            float32x4_t v53 = vmulq_f32(vminq_f32(vmaxq_f32(v49, *v50), v51), v50[2]);
            float32x4_t v54 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
            float32x4_t v55 = vsubq_f32(v54, (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v54, v53)));
            float32x4_t v56 = vmulq_f32(v52, vsubq_f32(v53, v55));
            float32x4_t v57 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
            int8x16_t v58 = (int8x16_t)vaddq_f32(v55, vmulq_f32(v52, vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v57, v56)))));
            *v20++ = vmulq_f32(v50[4], (float32x4_t)vextq_s8(v58, v58, 0xCuLL));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (float32x4_t *)((char *)v5 + v9);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v10);
        float v11 = (float32x4_t *)((char *)v11 + v10);
        float v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::GetDOD(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::GetROI(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcPixelFormatConversion_kV4S_BE_WXYZ_output::HgcPixelFormatConversion_kV4S_BE_WXYZ_output(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F5228;
  operator new();
}

void sub_1B792DD44(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4S_BE_WXYZ_output::~HgcPixelFormatConversion_kV4S_BE_WXYZ_output(HGNode *this)
{
  *(void *)this = &unk_1F10F5228;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F5228;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F5228;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::SetParameter(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_output::GetParameter(HgcPixelFormatConversion_kV4S_BE_WXYZ_output *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcUnpremultiply::GetProgram(HgcUnpremultiply *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000025a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0) / float4(fmax((float3)r0.www, 1.00000e-06f), 1.);\n"
             "    return output;\n"
             "}\n"
             "//MD5=164cdd96:703f1726:5bc85274:a1b49ed0\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000244\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c6ed00a3:77233d55:f54fcc5b:9f5ee2d3\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001e1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "}\n"
           "//MD5=4fca7993:d83f0755:ff909c75:c8074a19\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcUnpremultiply::InitProgramDescriptor(HgcUnpremultiply *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcUnpremultiply_hgc_visible", "//Metal1.0     \n//LEN=000000011e\n[[ visible ]] FragmentOut HgcUnpremultiply_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcUnpremultiply");
}

void sub_1B792E188(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B792E1B8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B792E1B0);
}

char *HgcUnpremultiply::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x19uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D20;
  strcpy(result, "HgcUnpremultiply [hgc1]");
  return result;
}

uint64_t HgcUnpremultiply::BindTexture(HgcUnpremultiply *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcUnpremultiply::Bind(HgcUnpremultiply *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcUnpremultiply::RenderTile(HgcUnpremultiply *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v42 = 0;
        uint64_t v43 = 16 * v7;
        uint64_t v44 = 16 * v6;
        uint64_t v45 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v46 = 0;
          do
          {
            float32x4_t v47 = v4[v46 / 0x10];
            uint64_t v48 = *((void *)this + 51);
            float32x4_t v49 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 3), *(float32x4_t *)v48);
            float32x4_t v50 = vmulq_f32(vrecpeq_f32(v49), *(float32x4_t *)(v48 + 16));
            v5[v46 / 0x10] = vmulq_f32(v47, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v48 + 32), (int8x16_t)vmulq_f32(v50, vrecpsq_f32(v50, v49))), *(int8x16_t *)(v48 + 48)));
            v46 += 16;
          }
          while (v45 != v46);
          ++v42;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v43);
          int v5 = (float32x4_t *)((char *)v5 + v44);
        }
        while (v42 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float v11 = v4 + 4;
      float v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        uint64_t v14 = v12;
        float32x2_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = v15;
          float32x4_t v18 = v4[v16 - 2];
          float32x4_t v19 = v4[v16 - 1];
          float32x4_t v20 = v4[v16];
          float32x4_t v21 = v4[v16 + 1];
          uint64_t v22 = *((void *)this + 51);
          float32x4_t v23 = *(float32x4_t *)(v22 + 16);
          float32x4_t v24 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), *(float32x4_t *)v22);
          float32x4_t v25 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), *(float32x4_t *)v22);
          float32x4_t v26 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), *(float32x4_t *)v22);
          float32x4_t v27 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 3), *(float32x4_t *)v22);
          float32x4_t v28 = vmulq_f32(vrecpeq_f32(v24), v23);
          float32x4_t v29 = vmulq_f32(vrecpeq_f32(v25), v23);
          float32x4_t v30 = vmulq_f32(vrecpeq_f32(v26), v23);
          float32x4_t v31 = vmulq_f32(vrecpeq_f32(v27), v23);
          int8x16_t v32 = (int8x16_t)vmulq_f32(v28, vrecpsq_f32(v28, v24));
          int8x16_t v33 = (int8x16_t)vmulq_f32(v31, vrecpsq_f32(v31, v27));
          int8x16_t v34 = *(int8x16_t *)(v22 + 32);
          int8x16_t v35 = *(int8x16_t *)(v22 + 48);
          float32x4_t v36 = v14;
          float32x4_t v37 = &v5[v16];
          v13 += 4;
          v37[-2] = vmulq_f32(v18, (float32x4_t)vorrq_s8(vandq_s8(v34, v32), v35));
          v37[-1] = vmulq_f32(v19, (float32x4_t)vorrq_s8(vandq_s8(v34, (int8x16_t)vmulq_f32(v29, vrecpsq_f32(v29, v25))), v35));
          *float32x4_t v37 = vmulq_f32(v20, (float32x4_t)vorrq_s8(vandq_s8(v34, (int8x16_t)vmulq_f32(v30, vrecpsq_f32(v30, v26))), v35));
          v37[1] = vmulq_f32(v21, (float32x4_t)vorrq_s8(vandq_s8(v34, v33), v35));
          v16 += 4;
          v15 += 4;
          uint64_t v14 = v36 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            float32x4_t v38 = *v17++;
            uint64_t v39 = *((void *)this + 51);
            float32x4_t v40 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 3), *(float32x4_t *)v39);
            float32x4_t v41 = vmulq_f32(vrecpeq_f32(v40), *(float32x4_t *)(v39 + 16));
            *v36++ = vmulq_f32(v38, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v39 + 32), (int8x16_t)vmulq_f32(v41, vrecpsq_f32(v41, v40))), *(int8x16_t *)(v39 + 48)));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (float32x4_t *)((char *)v5 + v9);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v10);
        float v11 = (float32x4_t *)((char *)v11 + v10);
        float v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcUnpremultiply::GetDOD(HgcUnpremultiply *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcUnpremultiply::GetROI(HgcUnpremultiply *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcUnpremultiply::HgcUnpremultiply(HgcUnpremultiply *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F5490;
  operator new();
}

void sub_1B792E670(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcUnpremultiply::~HgcUnpremultiply(HGNode *this)
{
  *(void *)this = &unk_1F10F5490;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40FA0F61DDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F5490;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40FA0F61DDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcUnpremultiply::SetParameter(HgcUnpremultiply *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcUnpremultiply::GetParameter(HgcUnpremultiply *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcUnpremultiplySanitized::GetProgram(HgcUnpremultiplySanitized *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000334\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 9.999999975e-07, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.y = half(r0.w >= c0.y);\n"
             "    r0.xyz = r1.yyy*r0.xyz;\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    output.color0.xyz = fmin(float3(r0.xyz), hg_Params[0].xyz);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8c43997a:1a09e3c5:feddaaaa:95fee0f9\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000323\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 9.999999975e-07, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.y = float(r0.w >= c0.y);\n"
             "    r0.xyz = r1.yyy*r0.xyz;\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    output.color0.xyz = fmin(r0.xyz, hg_Params[0].xyz);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9aa70715:fed71175:863959e2:0a892a0e\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002ed\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 9.999999975e-07, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.y = float(r0.w >= c0.y);\n"
           "    r0.xyz = r1.yyy*r0.xyz;\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    gl_FragColor.xyz = min(r0.xyz, hg_ProgramLocal0.xyz);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=1eda26ab:681475ba:00ce9047:1b229bc3\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcUnpremultiplySanitized::InitProgramDescriptor(HgcUnpremultiplySanitized *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcUnpremultiplySanitized_hgc_visible", "//Metal1.0     \n//LEN=0000000206\n[[ visible ]] FragmentOut HgcUnpremultiplySanitized_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 9.999999975e-07, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.y = float(r0.w >= c0.y);\n"
    "    r0.xyz = r1.yyy*r0.xyz;\n"
    "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
    "    output.color0.xyz = fmin(r0.xyz, hg_Params[0].xyz);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcUnpremultiplySanitized");
}

void sub_1B792EA48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B792EA78(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B792EA70);
}

char *HgcUnpremultiplySanitized::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B83761D0;
  strcpy(result, "HgcUnpremultiplySanitized [hgc1]");
  return result;
}

uint64_t HgcUnpremultiplySanitized::BindTexture(HgcUnpremultiplySanitized *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcUnpremultiplySanitized::Bind(HgcUnpremultiplySanitized *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcUnpremultiplySanitized::RenderTile(HgcUnpremultiplySanitized *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v53 = 0;
        uint64_t v54 = 16 * v7;
        uint64_t v55 = 16 * v6;
        uint64_t v56 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v57 = 0;
          do
          {
            uint64_t v58 = *((void *)this + 51);
            float32x4_t v59 = *(float32x4_t *)(v58 + 16);
            int8x16_t v60 = *(int8x16_t *)(v58 + 48);
            float32x4_t v61 = (float32x4_t)vbslq_s8(v60, (int8x16_t)v4[v57 / 0x10], (int8x16_t)vmulq_lane_f32(v4[v57 / 0x10], (float32x2_t)*(_OWORD *)&vandq_s8(*(int8x16_t *)(v58 + 32), (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v4[v57 / 0x10], (int8x16_t)v4[v57 / 0x10], 8uLL), v59)), 1));
            float32x4_t v62 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v61, 3), v59);
            float32x4_t v63 = vmulq_f32(vrecpeq_f32(v62), *(float32x4_t *)(v58 + 64));
            float32x4_t v64 = vmulq_f32(v61, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v58 + 80), (int8x16_t)vmulq_f32(v63, vrecpsq_f32(v63, v62))), *(int8x16_t *)(v58 + 96)));
            v5[v57 / 0x10] = vbslq_s8(v60, (int8x16_t)v64, (int8x16_t)vminq_f32(v64, *(float32x4_t *)v58));
            v57 += 16;
          }
          while (v56 != v57);
          ++v53;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v54);
          int v5 = (int8x16_t *)((char *)v5 + v55);
        }
        while (v53 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float v11 = v4 + 4;
      float v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        uint64_t v14 = v12;
        float32x2_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = (_OWORD *)*((void *)this + 51);
          float32x4_t v19 = *(float32x4_t *)v17;
          float32x4_t v18 = *((float32x4_t *)v17 + 1);
          int8x16_t v20 = *((int8x16_t *)v17 + 2);
          int8x16_t v21 = *((int8x16_t *)v17 + 3);
          float32x4_t v22 = (float32x4_t)vbslq_s8(v21, (int8x16_t)v4[v16 - 2], (int8x16_t)vmulq_lane_f32(v4[v16 - 2], (float32x2_t)*(_OWORD *)&vandq_s8(v20, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v4[v16 - 2], (int8x16_t)v4[v16 - 2], 8uLL), v18)), 1));
          float32x4_t v23 = (float32x4_t)vbslq_s8(v21, (int8x16_t)v4[v16 - 1], (int8x16_t)vmulq_lane_f32(v4[v16 - 1], (float32x2_t)*(_OWORD *)&vandq_s8(v20, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v4[v16 - 1], (int8x16_t)v4[v16 - 1], 8uLL), v18)), 1));
          float32x4_t v24 = (float32x4_t)vbslq_s8(v21, (int8x16_t)v4[v16], (int8x16_t)vmulq_lane_f32(v4[v16], (float32x2_t)*(_OWORD *)&vandq_s8(v20, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v4[v16], (int8x16_t)v4[v16], 8uLL), v18)), 1));
          float32x4_t v25 = (float32x4_t)vbslq_s8(v21, (int8x16_t)v4[v16 + 1], (int8x16_t)vmulq_lane_f32(v4[v16 + 1], (float32x2_t)*(_OWORD *)&vandq_s8(v20, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v4[v16 + 1], (int8x16_t)v4[v16 + 1], 8uLL), v18)), 1));
          float32x4_t v26 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 3), v18);
          float32x4_t v27 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 3), v18);
          float32x4_t v28 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 3), v18);
          float32x4_t v29 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 3), v18);
          float32x4_t v30 = *((float32x4_t *)v17 + 4);
          int8x16_t v31 = *((int8x16_t *)v17 + 5);
          float32x4_t v32 = vmulq_f32(vrecpeq_f32(v26), v30);
          float32x4_t v33 = vmulq_f32(vrecpeq_f32(v27), v30);
          float32x4_t v34 = vmulq_f32(vrecpeq_f32(v28), v30);
          float32x4_t v35 = vmulq_f32(vrecpeq_f32(v29), v30);
          float32x4_t v36 = v15;
          int8x16_t v37 = vandq_s8(v31, (int8x16_t)vmulq_f32(v32, vrecpsq_f32(v32, v26)));
          int8x16_t v38 = *((int8x16_t *)v17 + 6);
          float32x4_t v39 = vmulq_f32(v22, (float32x4_t)vorrq_s8(v37, v38));
          float32x4_t v40 = vmulq_f32(v23, (float32x4_t)vorrq_s8(vandq_s8(v31, (int8x16_t)vmulq_f32(v33, vrecpsq_f32(v33, v27))), v38));
          float32x4_t v41 = vmulq_f32(v24, (float32x4_t)vorrq_s8(vandq_s8(v31, (int8x16_t)vmulq_f32(v34, vrecpsq_f32(v34, v28))), v38));
          float32x4_t v42 = vmulq_f32(v25, (float32x4_t)vorrq_s8(vandq_s8(v31, (int8x16_t)vmulq_f32(v35, vrecpsq_f32(v35, v29))), v38));
          uint64_t v43 = v14;
          uint64_t v44 = &v5[v16];
          v13 += 4;
          v44[-2] = vbslq_s8(v21, (int8x16_t)v39, (int8x16_t)vminq_f32(v39, v19));
          v44[-1] = vbslq_s8(v21, (int8x16_t)v40, (int8x16_t)vminq_f32(v40, v19));
          *uint64_t v44 = vbslq_s8(v21, (int8x16_t)v41, (int8x16_t)vminq_f32(v41, v19));
          v44[1] = vbslq_s8(v21, (int8x16_t)v42, (int8x16_t)vminq_f32(v42, v19));
          v16 += 4;
          v15 += 4;
          uint64_t v14 = v43 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            float32x4_t v45 = *v36++;
            uint64_t v46 = *((void *)this + 51);
            float32x4_t v47 = *(float32x4_t *)(v46 + 16);
            int8x16_t v48 = *(int8x16_t *)(v46 + 48);
            float32x4_t v49 = (float32x4_t)vbslq_s8(v48, (int8x16_t)v45, (int8x16_t)vmulq_lane_f32(v45, (float32x2_t)*(_OWORD *)&vandq_s8(*(int8x16_t *)(v46 + 32), (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8((int8x16_t)v45, (int8x16_t)v45, 8uLL), v47)), 1));
            float32x4_t v50 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 3), v47);
            float32x4_t v51 = vmulq_f32(vrecpeq_f32(v50), *(float32x4_t *)(v46 + 64));
            float32x4_t v52 = vmulq_f32(v49, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v46 + 80), (int8x16_t)vmulq_f32(v51, vrecpsq_f32(v51, v50))), *(int8x16_t *)(v46 + 96)));
            *v43++ = vbslq_s8(v48, (int8x16_t)v52, (int8x16_t)vminq_f32(v52, *(float32x4_t *)v46));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (int8x16_t *)((char *)v5 + v9);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v10);
        float v11 = (float32x4_t *)((char *)v11 + v10);
        float v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcUnpremultiplySanitized::GetDOD(HgcUnpremultiplySanitized *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcUnpremultiplySanitized::GetROI(HgcUnpremultiplySanitized *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcUnpremultiplySanitized::HgcUnpremultiplySanitized(HgcUnpremultiplySanitized *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F56F8;
  operator new();
}

void sub_1B792F050(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcUnpremultiplySanitized::~HgcUnpremultiplySanitized(HGNode *this)
{
  *(void *)this = &unk_1F10F56F8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F56F8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcUnpremultiplySanitized::SetParameter(HgcUnpremultiplySanitized *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  int v8 = (__n128 *)*((void *)this + 51);
  if (v8->n128_f32[0] == a3.n128_f32[0]
    && v8->n128_f32[1] == a3.n128_f32[0]
    && v8->n128_f32[2] == a3.n128_f32[0]
    && v8->n128_f32[3] == 0.0)
  {
    return 0;
  }
  int32x4_t v9 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
  v9.i32[2] = a3.n128_u32[0];
  a3.n128_f32[1] = a4;
  *int v8 = (__n128)v9;
  a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
  v8[7] = a3;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcUnpremultiplySanitized::GetParameter(HgcUnpremultiplySanitized *this, int a2, float *a3)
{
  if (!a2)
  {
    unint64_t v3 = (float *)*((void *)this + 51);
    *a3 = v3[28];
    a3[1] = v3[29];
    a3[2] = v3[30];
    float result = v3[31];
    a3[3] = result;
  }
  return result;
}

const char *HgcApply3DLUTTetrahedralFast_basekernel::GetProgram(HgcApply3DLUTTetrahedralFast_basekernel *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return aMetal10Len0000_1210;
    }
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000f3c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = r1.xyz*r1.xyz;\n"
             "    r3.xyz = r2.xyz*r1.xyz;\n"
             "    r1.xyz = r1.xyz*hg_Params[3].yyy + hg_Params[3].xxx;\n"
             "    r1.xyz = r2.xyz*hg_Params[3].zzz + r1.xyz;\n"
             "    r1.xyz = r3.xyz*hg_Params[3].www + r1.xyz;\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r2.xyz = hg_Params[1].yyy - c0.yyy;\n"
             "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
             "    r3.xyz = fract(r1.xyz);\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r4.xyz = r1.xyz + c0.yyy;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = r4.xyz - r1.xyz;\n"
             "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
             "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
             "    r2.y = r1.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r1.xy = r2.xy + hg_Params[4].xy;\n"
             "    r1.xy = r1.xy*hg_Params[4].zw;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r5.xy = r2.xy + hg_Params[4].xy;\n"
             "    r5.xy = r5.xy*hg_Params[4].zw;\n"
             "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r6.xy = r2.xy + hg_Params[4].xy;\n"
             "    r6.xy = r6.xy*hg_Params[4].zw;\n"
             "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
             "    r2.x = r2.x - r4.x;\n"
             "    r7.xy = r2.xy + hg_Params[4].xy;\n"
             "    r7.xy = r7.xy*hg_Params[4].zw;\n"
             "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
             "    r2.y = r2.y + r4.z;\n"
             "    r8.xy = r2.xy + hg_Params[4].xy;\n"
             "    r8.xy = r8.xy*hg_Params[4].zw;\n"
             "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
             "    r2.x = r2.x - r4.y;\n"
             "    r9.xy = r2.xy + hg_Params[4].xy;\n"
             "    r9.xy = r9.xy*hg_Params[4].zw;\n"
             "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r10.xy = r2.xy + hg_Params[4].xy;\n"
             "    r10.xy = r10.xy*hg_Params[4].zw;\n"
             "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r2.xy = r2.xy + hg_Params[4].xy;\n"
             "    r2.xy = r2.xy*hg_Params[4].zw;\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
             "    r4 = float4(r3.xzzy > r3.yxyz);\n"
             "    r11.x = float(r3.y > r3.x);\n"
             "    r12 = float4(r3.yxxz >= r3.xyzy);\n"
             "    r13 = r2 - r8;\n"
             "    r14 = r7 - r1;\n"
             "    r15 = r8 - r7;\n"
             "    r16 = r13*r3.xxxx;\n"
             "    r16 = r14*r3.yyyy + r16;\n"
             "    r15 = r15*r3.zzzz + r16;\n"
             "    r16 = r10 - r9;\n"
             "    r17 = r2 - r10;\n"
             "    r18 = r9 - r1;\n"
             "    r16 = r16*r3.xxxx;\n"
             "    r16 = r17*r3.yyyy + r16;\n"
             "    r16 = r18*r3.zzzz + r16;\n"
             "    r19 = fmin(r4.xxxx, r4.yyyy);\n"
             "    r15 = select(r15, r16, r19 > 0.00000f);\n"
             "    r8 = r8 - r9;\n"
             "    r13 = r13*r3.xxxx;\n"
             "    r13 = r8*r3.yyyy + r13;\n"
             "    r13 = r18*r3.zzzz + r13;\n"
             "    r19 = fmin(r12.xxxx, r4.zzzz);\n"
             "    r15 = select(r15, r13, r19 > 0.00000f);\n"
             "    r16 = r5 - r1;\n"
             "    r9 = r6 - r5;\n"
             "    r2 = r2 - r6;\n"
             "    r8 = r16*r3.xxxx;\n"
             "    r8 = r9*r3.yyyy + r8;\n"
             "    r8 = r2*r3.zzzz + r8;\n"
             "    r4 = fmin(r4.wwww, r12.yyyy);\n"
             "    r15 = select(r15, r8, r4 > 0.00000f);\n"
             "    r6 = r6 - r7;\n"
             "    r6 = r6*r3.xxxx;\n"
             "    r6 = r14*r3.yyyy + r6;\n"
             "    r6 = r2*r3.zzzz + r6;\n"
             "    r11 = fmin(r12.zzzz, r11.xxxx);\n"
             "    r15 = select(r15, r6, r11 > 0.00000f);\n"
             "    r10 = r10 - r5;\n"
             "    r16 = r16*r3.xxxx;\n"
             "    r16 = r17*r3.yyyy + r16;\n"
             "    r16 = r10*r3.zzzz + r16;\n"
             "    r12 = fmin(r12.wwww, r12.zzzz);\n"
             "    r12 = select(r15, r16, r12 > 0.00000f);\n"
             "    r12 = r12 + r1;\n"
             "    r12 = r12*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
             "    output.color0 = select(r12, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d988d904:dace4484:6b5f78dc:2808f41f\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0005:0014:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_452;
  }
}

void HgcApply3DLUTTetrahedralFast_basekernel::InitProgramDescriptor(HgcApply3DLUTTetrahedralFast_basekernel *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcApply3DLUTTetrahedralFast_basekernel_hgc_visible", "//Metal1.0     \n//LEN=0000000e0b\n[[ visible ]] FragmentOut HgcApply3DLUTTetrahedralFast_basekernel_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = r1.xyz*r1.xyz;\n"
    "    r3.xyz = r2.xyz*r1.xyz;\n"
    "    r1.xyz = r1.xyz*hg_Params[3].yyy + hg_Params[3].xxx;\n"
    "    r1.xyz = r2.xyz*hg_Params[3].zzz + r1.xyz;\n"
    "    r1.xyz = r3.xyz*hg_Params[3].www + r1.xyz;\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r2.xyz = hg_Params[1].yyy - c0.yyy;\n"
    "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
    "    r3.xyz = fract(r1.xyz);\n"
    "    r1.xyz = floor(r1.xyz);\n"
    "    r4.xyz = r1.xyz + c0.yyy;\n"
    "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
    "    r4.xyz = r4.xyz - r1.xyz;\n"
    "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
    "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
    "    r2.y = r1.z;\n"
    "    r2.xy = r2.xy + c0.zz;\n"
    "    r1.xy = r2.xy + hg_Params[4].xy;\n"
    "    r1.xy = r1.xy*hg_Params[4].zw;\n"
    "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r5.xy = r2.xy + hg_Params[4].xy;\n"
    "    r5.xy = r5.xy*hg_Params[4].zw;\n"
    "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r6.xy = r2.xy + hg_Params[4].xy;\n"
    "    r6.xy = r6.xy*hg_Params[4].zw;\n"
    "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
    "    r2.x = r2.x - r4.x;\n"
    "    r7.xy = r2.xy + hg_Params[4].xy;\n"
    "    r7.xy = r7.xy*hg_Params[4].zw;\n"
    "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
    "    r2.y = r2.y + r4.z;\n"
    "    r8.xy = r2.xy + hg_Params[4].xy;\n"
    "    r8.xy = r8.xy*hg_Params[4].zw;\n"
    "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
    "    r2.x = r2.x - r4.y;\n"
    "    r9.xy = r2.xy + hg_Params[4].xy;\n"
    "    r9.xy = r9.xy*hg_Params[4].zw;\n"
    "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r10.xy = r2.xy + hg_Params[4].xy;\n"
    "    r10.xy = r10.xy*hg_Params[4].zw;\n"
    "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r2.xy = r2.xy + hg_Params[4].xy;\n"
    "    r2.xy = r2.xy*hg_Params[4].zw;\n"
    "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
    "    r4 = float4(r3.xzzy > r3.yxyz);\n"
    "    r11.x = float(r3.y > r3.x);\n"
    "    r12 = float4(r3.yxxz >= r3.xyzy);\n"
    "    r13 = r2 - r8;\n"
    "    r14 = r7 - r1;\n"
    "    r15 = r8 - r7;\n"
    "    r16 = r13*r3.xxxx;\n"
    "    r16 = r14*r3.yyyy + r16;\n"
    "    r15 = r15*r3.zzzz + r16;\n"
    "    r16 = r10 - r9;\n"
    "    r17 = r2 - r10;\n"
    "    r18 = r9 - r1;\n"
    "    r16 = r16*r3.xxxx;\n"
    "    r16 = r17*r3.yyyy + r16;\n"
    "    r16 = r18*r3.zzzz + r16;\n"
    "    r19 = fmin(r4.xxxx, r4.yyyy);\n"
    "    r15 = select(r15, r16, r19 > 0.00000f);\n"
    "    r8 = r8 - r9;\n"
    "    r13 = r13*r3.xxxx;\n"
    "    r13 = r8*r3.yyyy + r13;\n"
    "    r13 = r18*r3.zzzz + r13;\n"
    "    r19 = fmin(r12.xxxx, r4.zzzz);\n"
    "    r15 = select(r15, r13, r19 > 0.00000f);\n"
    "    r16 = r5 - r1;\n"
    "    r9 = r6 - r5;\n"
    "    r2 = r2 - r6;\n"
    "    r8 = r16*r3.xxxx;\n"
    "    r8 = r9*r3.yyyy + r8;\n"
    "    r8 = r2*r3.zzzz + r8;\n"
    "    r4 = fmin(r4.wwww, r12.yyyy);\n"
    "    r15 = select(r15, r8, r4 > 0.00000f);\n"
    "    r6 = r6 - r7;\n"
    "    r6 = r6*r3.xxxx;\n"
    "    r6 = r14*r3.yyyy + r6;\n"
    "    r6 = r2*r3.zzzz + r6;\n"
    "    r11 = fmin(r12.zzzz, r11.xxxx);\n"
    "    r15 = select(r15, r6, r11 > 0.00000f);\n"
    "    r10 = r10 - r5;\n"
    "    r16 = r16*r3.xxxx;\n"
    "    r16 = r17*r3.yyyy + r16;\n"
    "    r16 = r10*r3.zzzz + r16;\n"
    "    r12 = fmin(r12.wwww, r12.zzzz);\n"
    "    r12 = select(r15, r16, r12 > 0.00000f);\n"
    "    r12 = r12 + r1;\n"
    "    r12 = r12*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
    "    output.color0 = select(r12, r0, hg_Params[2] < 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcApply3DLUTTetrahedralFast_basekernel");
}

void sub_1B792F618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B792F650(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B792F648);
}

double HgcApply3DLUTTetrahedralFast_basekernel::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x30uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8377310;
  strcpy(v3, "HgcApply3DLUTTetrahedralFast_basekernel [hgc1]");
  return *(double *)"asekernel [hgc1]";
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::BindTexture(HgcApply3DLUTTetrahedralFast_basekernel *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 4, v6, v7, v8, v9);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v4 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::Bind(HgcApply3DLUTTetrahedralFast_basekernel *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::RenderTile(HgcApply3DLUTTetrahedralFast_basekernel *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      int v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      int32x2_t v7 = a2[10];
      int32x2_t v8 = a2[2];
      uint64_t v9 = 16 * a2[11].i32[0];
      uint64_t v10 = 16 * a2[3].i32[0];
      uint64_t v11 = 16 * v4;
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      do
      {
        uint64_t v13 = 0;
        do
        {
          float32x4_t v14 = *(float32x4_t *)(*(void *)&v7 + v13);
          float32x2_t v15 = (_OWORD *)*((void *)this + 51);
          float32x4_t v16 = *(float32x4_t *)v15;
          float32x4_t v17 = *((float32x4_t *)v15 + 1);
          float32x4_t v18 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15, 1), vmulq_n_f32(v14, COERCE_FLOAT(*v15)));
          float32x4_t v19 = vmulq_f32(v18, v18);
          float32x4_t v21 = *((float32x4_t *)v15 + 2);
          float32x4_t v20 = *((float32x4_t *)v15 + 3);
          float32x4_t v22 = vmulq_f32(v18, v19);
          float32x4_t v23 = vaddq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 0), vmulq_lane_f32(v18, *(float32x2_t *)v20.f32, 1)), vmulq_laneq_f32(v19, v20, 2));
          float32x4_t v24 = vmulq_laneq_f32(v22, v20, 3);
          float32x4_t v25 = *((float32x4_t *)v15 + 4);
          float32x4_t v26 = *((float32x4_t *)v15 + 5);
          float32x4_t v27 = vmaxq_f32(vaddq_f32(v23, v24), v25);
          float32x4_t v28 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1), v26);
          float32x4_t v29 = vminq_f32(v27, v28);
          float32x4_t v30 = vcvtq_f32_s32(vcvtq_s32_f32(v29));
          float32x4_t v31 = vsubq_f32(v30, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v30, v29)));
          float32x4_t v32 = vsubq_f32(v29, v31);
          float32x4_t v33 = vmulq_f32(v17, v31);
          float32x4_t v34 = vmulq_f32(v17, vsubq_f32(vminq_f32(vaddq_f32(v26, v31), v28), v31));
          int8x16_t v35 = *((int8x16_t *)v15 + 6);
          float32x4_t v36 = vaddq_f32(*((float32x4_t *)v15 + 7), (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v33, (float32x4_t)vrev64q_s32((int32x4_t)v33)), vextq_s8((int8x16_t)v31, (int8x16_t)v31, 4uLL)));
          int32x2_t v37 = a2[12];
          float32x4_t v38 = vaddq_f32(vsubq_f32(v36, v6), v12);
          int32x4_t v39 = vcvtq_s32_f32(v38);
          v38.i64[0] = vaddq_s32(v39, vcgtq_f32(vcvtq_f32_s32(v39), v38)).u64[0];
          __int32 v40 = v38.i32[1];
          __int32 v41 = a2[13].i32[0];
          float32x4_t v42 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v34, v36), (int8x16_t)v36);
          float32x4_t v43 = vaddq_f32(vsubq_f32(v42, v6), v12);
          __int32 v44 = v38.i32[0];
          int32x4_t v45 = vcvtq_s32_f32(v43);
          v45.i64[0] = vaddq_s32(v45, vcgtq_f32(vcvtq_f32_s32(v45), v43)).u64[0];
          __int32 v46 = v45.i32[1];
          __int32 v47 = v44 + v40 * v41;
          __int32 v48 = v45.i32[0];
          float32x4_t v49 = (float32x4_t)vrev64q_s32((int32x4_t)v34);
          float32x4_t v50 = *(float32x4_t *)(*(void *)&v37 + 16 * v47);
          float32x4_t v51 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v49, v42), (int8x16_t)v36);
          float32x4_t v52 = vaddq_f32(vsubq_f32(v51, v6), v12);
          int32x4_t v53 = vcvtq_s32_f32(v52);
          __int32 v54 = v48 + v46 * v41;
          v53.i64[0] = vaddq_s32(v53, vcgtq_f32(vcvtq_f32_s32(v53), v52)).u64[0];
          __int32 v55 = v53.i32[1];
          float32x4_t v56 = *(float32x4_t *)(*(void *)&v37 + 16 * v54);
          __int32 v57 = v53.i32[0];
          int8x16_t v58 = (int8x16_t)vsubq_f32(v51, v34);
          float32x4_t v59 = (float32x4_t)vbslq_s8(v35, v58, (int8x16_t)v36);
          float32x4_t v60 = vaddq_f32(vsubq_f32(v59, v6), v12);
          __int32 v61 = v57 + v55 * v41;
          int32x4_t v62 = vcvtq_s32_f32(v60);
          v60.i64[0] = vaddq_s32(v62, vcgtq_f32(vcvtq_f32_s32(v62), v60)).u64[0];
          __int32 v63 = v60.i32[1];
          __int32 v64 = v60.i32[0];
          int8x16_t v65 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v34, (int8x16_t)v34, 4uLL), v59);
          float32x4_t v66 = (float32x4_t)vbslq_s8(v35, v58, v65);
          float32x4_t v67 = *(float32x4_t *)(*(void *)&v37 + 16 * v61);
          float32x4_t v68 = vaddq_f32(vsubq_f32(v66, v6), v12);
          int32x4_t v69 = vcvtq_s32_f32(v68);
          __int32 v70 = v64 + v63 * v41;
          v68.i64[0] = vaddq_s32(v69, vcgtq_f32(vcvtq_f32_s32(v69), v68)).u64[0];
          __int32 v71 = v68.i32[1];
          __int32 v72 = v68.i32[0];
          float32x4_t v73 = *(float32x4_t *)(*(void *)&v37 + 16 * v70);
          float32x4_t v74 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vsubq_f32(v66, v49), v65);
          float32x4_t v75 = vaddq_f32(vsubq_f32(v74, v6), v12);
          int32x4_t v76 = vcvtq_s32_f32(v75);
          __int32 v77 = v72 + v71 * v41;
          v75.i64[0] = vaddq_s32(v76, vcgtq_f32(vcvtq_f32_s32(v76), v75)).u64[0];
          __int32 v78 = v75.i32[1];
          __int32 v79 = v75.i32[0];
          float32x4_t v80 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v34, v74), v65);
          float32x4_t v81 = vaddq_f32(vsubq_f32(v80, v6), v12);
          float32x4_t v82 = *(float32x4_t *)(*(void *)&v37 + 16 * v77);
          int32x4_t v83 = vcvtq_s32_f32(v81);
          v81.i64[0] = vaddq_s32(v83, vcgtq_f32(vcvtq_f32_s32(v83), v81)).u64[0];
          __int32 v84 = v81.i32[1];
          __int32 v85 = v79 + v78 * v41;
          __int32 v86 = v81.i32[0];
          float32x4_t v87 = (float32x4_t)vbslq_s8(v35, (int8x16_t)vaddq_f32(v49, v80), v65);
          float32x4_t v88 = *(float32x4_t *)(*(void *)&v37 + 16 * v85);
          float32x4_t v89 = vaddq_f32(vsubq_f32(v87, v6), v12);
          int32x4_t v90 = vcvtq_s32_f32(v89);
          v89.i64[0] = vaddq_s32(v90, vcgtq_f32(vcvtq_f32_s32(v90), v89)).u64[0];
          float32x4_t v91 = *((float32x4_t *)v15 + 8);
          int8x16_t v92 = *((int8x16_t *)v15 + 9);
          *(int8x8_t *)v81.f32 = vqtbl1_s8((int8x16_t)v32, *(int8x8_t *)v91.f32);
          *(int8x8_t *)&v81.u32[2] = vqtbl1_s8((int8x16_t)v32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v91, (int8x16_t)v91, 8uLL));
          *(int8x8_t *)v91.f32 = vqtbl1_s8((int8x16_t)v32, *(int8x8_t *)v92.i8);
          __int32 v93 = v89.i32[1];
          *(int8x8_t *)&v91.u32[2] = vqtbl1_s8((int8x16_t)v32, (int8x8_t)*(_OWORD *)&vextq_s8(v92, v92, 8uLL));
          float32x4_t v94 = *((float32x4_t *)v15 + 10);
          int8x16_t v95 = *((int8x16_t *)v15 + 11);
          LODWORD(v15) = v89.i32[0];
          int32x4_t v96 = (int32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v91, v81));
          float32x4_t v97 = *(float32x4_t *)(*(void *)&v37 + 16 * (v86 + v84 * v41));
          *(int8x8_t *)v98.f32 = vqtbl1_s8((int8x16_t)v32, *(int8x8_t *)v94.f32);
          *(int8x8_t *)&v98.u32[2] = vqtbl1_s8((int8x16_t)v32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v94, (int8x16_t)v94, 8uLL));
          v91.i64[0] = vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v32), v32)).u64[0];
          *(int8x8_t *)v94.f32 = vqtbl1_s8((int8x16_t)v32, *(int8x8_t *)v95.i8);
          float32x4_t v99 = *(float32x4_t *)(*(void *)&v37 + 16 * ((int)v15 + v93 * v41));
          *(int8x8_t *)&v94.u32[2] = vqtbl1_s8((int8x16_t)v32, (int8x8_t)*(_OWORD *)&vextq_s8(v95, v95, 8uLL));
          int32x4_t v100 = (int32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgeq_f32(v94, v98));
          float32x4_t v101 = vmulq_lane_f32(vsubq_f32(v73, v50), *(float32x2_t *)v32.f32, 1);
          float32x4_t v102 = vmulq_n_f32(vsubq_f32(v99, v82), v32.f32[0]);
          float32x4_t v103 = vmulq_n_f32(vsubq_f32(v97, v88), v32.f32[0]);
          float32x4_t v104 = vmulq_laneq_f32(vsubq_f32(v88, v50), v32, 2);
          float32x4_t v105 = vmulq_lane_f32(vsubq_f32(v99, v97), *(float32x2_t *)v32.f32, 1);
          float32x4_t v106 = vmulq_lane_f32(vsubq_f32(v82, v88), *(float32x2_t *)v32.f32, 1);
          int8x16_t v107 = (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v82, v73), v32, 2), vaddq_f32(v101, v102));
          float32x4_t v108 = vmulq_n_f32(vsubq_f32(v56, v50), v32.f32[0]);
          float32x4_t v109 = vmulq_laneq_f32(vsubq_f32(v99, v67), v32, 2);
          float32x4_t v110 = vaddq_f32(vmulq_n_f32(vsubq_f32(v67, v73), v32.f32[0]), v101);
          float32x4_t v111 = (float32x4_t)vdupq_laneq_s32(v100, 2);
          *(int8x16_t *)(*(void *)&v8 + v13) = vbslq_s8((int8x16_t)vcgtq_f32(v25, v21), (int8x16_t)v14, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), vmulq_laneq_f32(vaddq_f32(v50, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v100, 3), v111), v25), (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v97, v56), v32, 2), vaddq_f32(v108, v105)),
                                                                                   vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32(v111, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v91.f32, 0)), v25), (int8x16_t)vaddq_f32(v110, v109), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v96, 3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v100.i8, 1)), v25), (int8x16_t)vaddq_f32(vaddq_f32(v108, vmulq_lane_f32(vsubq_f32(v67, v56), *(float32x2_t *)v32.f32, 1)), v109), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v100.i8, 0), (float32x4_t)vdupq_laneq_s32(v96, 2)), v25), (int8x16_t)vaddq_f32(v104, vaddq_f32(v106, v102)), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v96.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v96.i8, 1)), v25), (int8x16_t)vaddq_f32(v104, vaddq_f32(v103, v105)),
                                                                                           v107)))))),
                                                                  v16,
                                                                  2)));
          v13 += 16;
        }
        while (v11 != v13);
        ++v5;
        *(void *)&v7 += v9;
        *(void *)&v8 += v10;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::GetDOD(HgcApply3DLUTTetrahedralFast_basekernel *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1) {
    return 0x8000000080000000;
  }
  if (a3) {
    return 0;
  }
  return *(void *)&a4.var0;
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, 1u);
    return HGRenderer::GetDOD(a2, Input);
  }
  else if (a3)
  {
    return 0;
  }
  else
  {
    return *(void *)&a4.var0;
  }
}

void HgcApply3DLUTTetrahedralFast_basekernel::HgcApply3DLUTTetrahedralFast_basekernel(HgcApply3DLUTTetrahedralFast_basekernel *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F5960;
  operator new();
}

void sub_1B7930008(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTetrahedralFast_basekernel::~HgcApply3DLUTTetrahedralFast_basekernel(HGNode *this)
{
  *(void *)this = &unk_1F10F5960;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F5960;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F5960;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::SetParameter(HgcApply3DLUTTetrahedralFast_basekernel *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int32x2_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int32x2_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcApply3DLUTTetrahedralFast_basekernel::GetParameter(HgcApply3DLUTTetrahedralFast_basekernel *this, unsigned int a2, float *a3)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcPixelFormatConversion_kV4F_WXYZ_input::GetProgram(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000023d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.yzwx) - hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=7f28c0de:80e0121d:8aa6daeb:92eb6aac\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000022f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.yzwx - hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=3c877c69:34cadceb:acdc9199:d64abffa\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001fd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.yzwx - hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=2fa037b7:8cefdd5b:5f08de08:8c22b023\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4F_WXYZ_input::InitProgramDescriptor(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4F_WXYZ_input_hgc_visible", "//Metal1.0     \n//LEN=0000000121\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4F_WXYZ_input_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0.yzwx - hg_Params[0];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcPixelFormatConversion_kV4F_WXYZ_input");
}

void sub_1B7930514(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7930544(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B793053CLL);
}

double HgcPixelFormatConversion_kV4F_WXYZ_input::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x30uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376F10;
  strcpy(v3, "HgcPixelFormatConversion_kV4F_WXYZ_input [hgc1]");
  return *(double *)"XYZ_input [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_input::BindTexture(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_input::Bind(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_input::RenderTile(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (int8x16_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v25 = 0;
        uint64_t v26 = 16 * v7;
        uint64_t v27 = 16 * v6;
        uint64_t v28 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v29 = 0;
          do
          {
            v5[v29 / 0x10] = vsubq_f32((float32x4_t)vextq_s8(v4[v29 / 0x10], v4[v29 / 0x10], 4uLL), *(float32x4_t *)*((void *)this + 51));
            v29 += 16;
          }
          while (v28 != v29);
          ++v25;
          int v4 = (int8x16_t *)((char *)v4 + v26);
          int v5 = (float32x4_t *)((char *)v5 + v27);
        }
        while (v25 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      uint64_t v11 = v4 + 4;
      float32x4_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        float32x4_t v14 = v12;
        float32x2_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = v15;
          float32x4_t v18 = v14;
          float32x4_t v19 = *(float32x4_t *)*((void *)this + 51);
          float32x4_t v20 = vsubq_f32((float32x4_t)vextq_s8(v4[v16 - 1], v4[v16 - 1], 4uLL), v19);
          float32x4_t v21 = vsubq_f32((float32x4_t)vextq_s8(v4[v16], v4[v16], 4uLL), v19);
          float32x4_t v22 = vsubq_f32((float32x4_t)vextq_s8(v4[v16 + 1], v4[v16 + 1], 4uLL), v19);
          float32x4_t v23 = &v5[v16];
          v23[-2] = vsubq_f32((float32x4_t)vextq_s8(v4[v16 - 2], v4[v16 - 2], 4uLL), v19);
          v23[-1] = v20;
          v13 += 4;
          *float32x4_t v23 = v21;
          v23[1] = v22;
          v16 += 4;
          v15 += 4;
          float32x4_t v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            int8x16_t v24 = *v17++;
            *v18++ = vsubq_f32((float32x4_t)vextq_s8(v24, v24, 4uLL), *(float32x4_t *)*((void *)this + 51));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (float32x4_t *)((char *)v5 + v9);
        int v4 = (int8x16_t *)((char *)v4 + v10);
        uint64_t v11 = (int8x16_t *)((char *)v11 + v10);
        float32x4_t v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_input::GetDOD(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_input::GetROI(HgcPixelFormatConversion_kV4F_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcPixelFormatConversion_kV4F_WXYZ_input::HgcPixelFormatConversion_kV4F_WXYZ_input(HgcPixelFormatConversion_kV4F_WXYZ_input *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F5BC8;
  operator new();
}

void sub_1B7930968(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4F_WXYZ_input::~HgcPixelFormatConversion_kV4F_WXYZ_input(HGNode *this)
{
  *(void *)this = &unk_1F10F5BC8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F5BC8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F5BC8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_input::SetParameter(HgcPixelFormatConversion_kV4F_WXYZ_input *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  int v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *int v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcPixelFormatConversion_kV4F_WXYZ_input::GetParameter(HgcPixelFormatConversion_kV4F_WXYZ_input *this, int a2, float *a3)
{
  if (!a2)
  {
    unint64_t v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcPixelFormatConversion_kV4S_WXYZ_input::GetProgram(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000023d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.yzwx) - hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=7f28c0de:80e0121d:8aa6daeb:92eb6aac\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000022f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.yzwx - hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=3c877c69:34cadceb:acdc9199:d64abffa\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001fd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.yzwx - hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=2fa037b7:8cefdd5b:5f08de08:8c22b023\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4S_WXYZ_input::InitProgramDescriptor(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4S_WXYZ_input_hgc_visible", "//Metal1.0     \n//LEN=0000000121\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4S_WXYZ_input_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0.yzwx - hg_Params[0];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcPixelFormatConversion_kV4S_WXYZ_input");
}

void sub_1B7930E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7930E80(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7930E78);
}

double HgcPixelFormatConversion_kV4S_WXYZ_input::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x30uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376F10;
  strcpy(v3, "HgcPixelFormatConversion_kV4S_WXYZ_input [hgc1]");
  return *(double *)"XYZ_input [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_input::BindTexture(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_input::Bind(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_input::RenderTile(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (int8x16_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v25 = 0;
        uint64_t v26 = 16 * v7;
        uint64_t v27 = 16 * v6;
        uint64_t v28 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v29 = 0;
          do
          {
            v5[v29 / 0x10] = vsubq_f32((float32x4_t)vextq_s8(v4[v29 / 0x10], v4[v29 / 0x10], 4uLL), *(float32x4_t *)*((void *)this + 51));
            v29 += 16;
          }
          while (v28 != v29);
          ++v25;
          int v4 = (int8x16_t *)((char *)v4 + v26);
          int v5 = (float32x4_t *)((char *)v5 + v27);
        }
        while (v25 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      uint64_t v11 = v4 + 4;
      float32x4_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        float32x4_t v14 = v12;
        float32x2_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = v15;
          float32x4_t v18 = v14;
          float32x4_t v19 = *(float32x4_t *)*((void *)this + 51);
          float32x4_t v20 = vsubq_f32((float32x4_t)vextq_s8(v4[v16 - 1], v4[v16 - 1], 4uLL), v19);
          float32x4_t v21 = vsubq_f32((float32x4_t)vextq_s8(v4[v16], v4[v16], 4uLL), v19);
          float32x4_t v22 = vsubq_f32((float32x4_t)vextq_s8(v4[v16 + 1], v4[v16 + 1], 4uLL), v19);
          float32x4_t v23 = &v5[v16];
          v23[-2] = vsubq_f32((float32x4_t)vextq_s8(v4[v16 - 2], v4[v16 - 2], 4uLL), v19);
          v23[-1] = v20;
          v13 += 4;
          *float32x4_t v23 = v21;
          v23[1] = v22;
          v16 += 4;
          v15 += 4;
          float32x4_t v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            int8x16_t v24 = *v17++;
            *v18++ = vsubq_f32((float32x4_t)vextq_s8(v24, v24, 4uLL), *(float32x4_t *)*((void *)this + 51));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (float32x4_t *)((char *)v5 + v9);
        int v4 = (int8x16_t *)((char *)v4 + v10);
        uint64_t v11 = (int8x16_t *)((char *)v11 + v10);
        float32x4_t v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_input::GetDOD(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_input::GetROI(HgcPixelFormatConversion_kV4S_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcPixelFormatConversion_kV4S_WXYZ_input::HgcPixelFormatConversion_kV4S_WXYZ_input(HgcPixelFormatConversion_kV4S_WXYZ_input *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F5E30;
  operator new();
}

void sub_1B79312A4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4S_WXYZ_input::~HgcPixelFormatConversion_kV4S_WXYZ_input(HGNode *this)
{
  *(void *)this = &unk_1F10F5E30;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F5E30;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F5E30;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_input::SetParameter(HgcPixelFormatConversion_kV4S_WXYZ_input *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  int v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *int v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcPixelFormatConversion_kV4S_WXYZ_input::GetParameter(HgcPixelFormatConversion_kV4S_WXYZ_input *this, int a2, float *a3)
{
  if (!a2)
  {
    unint64_t v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcColorGamma_v216_yxzx_collapse::GetProgram(HgcColorGamma_v216_yxzx_collapse *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002a9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = (half3) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    r1.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    output.color0.xyz = float3(r0.yxz);\n"
             "    output.color0.w = float(r1.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8e7771c2:a06a6c11:9daa802a:96046119\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000028d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    output.color0.xyz = r0.yxz;\n"
             "    output.color0.w = r1.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=1f020ce8:91e1b790:66920186:95589d9d\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000243\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xyz = texture2D(hg_Texture0, hg_TexCoord0.xy).xyz;\n"
           "    r1.x = texture2D(hg_Texture0, hg_TexCoord1.xy).x;\n"
           "    gl_FragColor.xyz = r0.yxz;\n"
           "    gl_FragColor.w = r1.x;\n"
           "}\n"
           "//MD5=36e2a11e:fad481c4:33936514:6896479c\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcColorGamma_v216_yxzx_collapse::InitProgramDescriptor(HgcColorGamma_v216_yxzx_collapse *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_v216_yxzx_collapse_hgc_visible", "//Metal1.0     \n//LEN=00000001f0\n[[ visible ]] FragmentOut HgcColorGamma_v216_yxzx_collapse_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).xyz;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).x;\n"
    "    output.color0.xyz = r0.yxz;\n"
    "    output.color0.w = r1.x;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorGamma_v216_yxzx_collapse");
}

void sub_1B7931954(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7931990(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7931988);
}

char *HgcColorGamma_v216_yxzx_collapse::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  float result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376020;
  strcpy(result, "HgcColorGamma_v216_yxzx_collapse [hgc1]");
  return result;
}

uint64_t HgcColorGamma_v216_yxzx_collapse::BindTexture(HgcColorGamma_v216_yxzx_collapse *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, -0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, 0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcColorGamma_v216_yxzx_collapse::Bind(HgcColorGamma_v216_yxzx_collapse *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorGamma_v216_yxzx_collapse::RenderTile(HgcColorGamma_v216_yxzx_collapse *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    uint64_t v4 = *(int *)a2;
    int v5 = *((_DWORD *)a2 + 2) - v4;
    uint64_t v6 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v7 = *((void *)a2 + 10) + 16 * v4;
    uint64_t v8 = *((int *)a2 + 22);
    uint64_t v9 = v7 + 64;
    uint64_t v10 = v6 + 2;
    uint64_t v11 = 16 * *((int *)a2 + 6);
    while (v5 < 4)
    {
      LODWORD(v26) = 0;
      if (v5 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v7 += 16 * v8;
      ++v3;
      v9 += 16 * v8;
      uint64_t v10 = (int8x16_t *)((char *)v10 + v11);
      uint64_t v6 = (int8x16_t *)((char *)v6 + v11);
      if (v3 == v2) {
        return 0;
      }
    }
    int v12 = 0;
    unint64_t v13 = v10;
    float32x4_t v14 = (int8x16_t *)v9;
    do
    {
      int8x16_t v15 = v14[-4];
      int8x16_t v16 = v14[-2];
      uint64_t v17 = *((void *)this + 51);
      int8x16_t v18 = *(int8x16_t *)(v17 + 16);
      *(int8x8_t *)v19.i8 = vqtbl1_s8(v15, *(int8x8_t *)v17);
      int8x8_t v20 = (int8x8_t)vextq_s8(*(int8x16_t *)v17, *(int8x16_t *)v17, 8uLL).u64[0];
      v19.u64[1] = (unint64_t)vqtbl1_s8(v15, v20);
      *(int8x8_t *)v15.i8 = vqtbl1_s8(v16, *(int8x8_t *)v17);
      v15.u64[1] = (unint64_t)vqtbl1_s8(v16, v20);
      *(int8x8_t *)v16.i8 = vqtbl1_s8(*v14, *(int8x8_t *)v17);
      v16.u64[1] = (unint64_t)vqtbl1_s8(*v14, v20);
      int8x16_t v21 = v14[2];
      *(int8x8_t *)v22.i8 = vqtbl1_s8(v21, *(int8x8_t *)v17);
      v22.u64[1] = (unint64_t)vqtbl1_s8(v21, v20);
      int8x16_t v23 = vbslq_s8(v18, vextq_s8(v14[-1], v14[-1], 4uLL), v15);
      int8x16_t v24 = vbslq_s8(v18, vextq_s8(v14[1], v14[1], 4uLL), v16);
      int8x16_t v25 = vbslq_s8(v18, vextq_s8(v14[3], v14[3], 4uLL), v22);
      v13[-2] = vbslq_s8(v18, vextq_s8(v14[-3], v14[-3], 4uLL), v19);
      v13[-1] = v23;
      *unint64_t v13 = v24;
      v13[1] = v25;
      v13 += 4;
      v14 += 8;
      v12 -= 4;
    }
    while (v5 + v12 > 3);
    LODWORD(v26) = -v12;
    if (-v12 >= v5) {
      goto LABEL_3;
    }
LABEL_10:
    unsigned int v27 = 2 * v26;
    uint64_t v26 = v26;
    do
    {
      int8x16_t v28 = *(int8x16_t *)(v7 + 16 * v27);
      uint64_t v29 = *((void *)this + 51);
      *(int8x8_t *)v30.i8 = vqtbl1_s8(v28, *(int8x8_t *)v29);
      int8x16_t v31 = *(int8x16_t *)(v7 + 16 * (v27 + 1));
      v30.u64[1] = (unint64_t)vqtbl1_s8(v28, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v29, *(int8x16_t *)v29, 8uLL));
      v6[v26++] = vbslq_s8(*(int8x16_t *)(v29 + 16), vextq_s8(v31, v31, 4uLL), v30);
      v27 += 2;
    }
    while (v26 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_v216_yxzx_collapse::GetDOD(HgcColorGamma_v216_yxzx_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0, 0, 0xFFFFFFFF, 0);
  int v8 = HGRectGrow(v6, v5, v7);
  float v9 = HGRectFloat(v8);
  float v13 = HGRectScale(v9, v10, v11, v12, 0.5);
  uint64_t v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcColorGamma_v216_yxzx_collapse::GetROI(HgcColorGamma_v216_yxzx_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 2.0);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  uint64_t v16 = v15;
  uint64_t v17 = HGRectMake4i(0, 0, 1u, 0);
  uint64_t v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcColorGamma_v216_yxzx_collapse::HgcColorGamma_v216_yxzx_collapse(HgcColorGamma_v216_yxzx_collapse *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F6098;
  operator new();
}

void sub_1B7931FFC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_v216_yxzx_collapse::~HgcColorGamma_v216_yxzx_collapse(HGNode *this)
{
  *(void *)this = &unk_1F10F6098;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F6098;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F6098;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_v216_yxzx_collapse::SetParameter(HgcColorGamma_v216_yxzx_collapse *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_v216_yxzx_collapse::GetParameter(HgcColorGamma_v216_yxzx_collapse *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcPixelFormatConversion_kV4B10Bit_BE_input::GetProgram(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003c4\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(255.0000000, 0.0009775171056, 1024.000000, 1.000000000);\n"
             "    const half4 c1 = half4(4.000000000, 0.01562500000, 0.06250000000, 0.2500000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0.zyxw*c0.xxxx + c0.yyyy;\n"
             "    r0 = floor(r0);\n"
             "    r0 = r0.zyxw*c1;\n"
             "    r1.yz = fract(r0.yz);\n"
             "    r0 = floor(r0);\n"
             "    r2.x = dot(r0.xy, 1.00000h);\n"
             "    r2.yz = r1.yz*c0.zz + r0.zw;\n"
             "    r2.xyz = r2.xyz*c0.yyy;\n"
             "    r2.w = c0.w;\n"
             "    output.color0 = float4(r2);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6362bdc0:22917061:826e61ed:9e40a59e\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ba\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(255.0000000, 0.0009775171056, 1024.000000, 1.000000000);\n"
             "    const float4 c1 = float4(4.000000000, 0.01562500000, 0.06250000000, 0.2500000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0.zyxw*c0.xxxx + c0.yyyy;\n"
             "    r0 = floor(r0);\n"
             "    r0 = r0.zyxw*c1;\n"
             "    r1.yz = fract(r0.yz);\n"
             "    r0 = floor(r0);\n"
             "    r2.x = dot(r0.xy, 1.00000f);\n"
             "    r2.yz = r1.yz*c0.zz + r0.zw;\n"
             "    r2.xyz = r2.xyz*c0.yyy;\n"
             "    r2.w = c0.w;\n"
             "    output.color0 = r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=0e872e95:a0ea5bda:b3df1f87:fc314c5e\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000368\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(255.0000000, 0.0009775171056, 1024.000000, 1.000000000);\n"
           "    const mediump vec4 c1 = vec4(4.000000000, 0.01562500000, 0.06250000000, 0.2500000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0.zyxw*c0.xxxx + c0.yyyy;\n"
           "    r0 = floor(r0);\n"
           "    r0 = r0.zyxw*c1;\n"
           "    r1.yz = fract(r0.yz);\n"
           "    r0 = floor(r0);\n"
           "    r2.x = dot(r0.xy, vec2(1.00000));\n"
           "    r2.yz = r1.yz*c0.zz + r0.zw;\n"
           "    r2.xyz = r2.xyz*c0.yyy;\n"
           "    r2.w = c0.w;\n"
           "    gl_FragColor = r2;\n"
           "}\n"
           "//MD5=3ba21b75:19572493:8b20e9c9:500e949a\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4B10Bit_BE_input::InitProgramDescriptor(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4B10Bit_BE_input_hgc_visible", "//Metal1.0     \n//LEN=00000002af\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4B10Bit_BE_input_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(255.0000000, 0.0009775171056, 1024.000000, 1.000000000);\n"
    "    const float4 c1 = float4(4.000000000, 0.01562500000, 0.06250000000, 0.2500000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0.zyxw*c0.xxxx + c0.yyyy;\n"
    "    r0 = floor(r0);\n"
    "    r0 = r0.zyxw*c1;\n"
    "    r1.yz = fract(r0.yz);\n"
    "    r0 = floor(r0);\n"
    "    r2.x = dot(r0.xy, 1.00000f);\n"
    "    r2.yz = r1.yz*c0.zz + r0.zw;\n"
    "    r2.xyz = r2.xyz*c0.yyy;\n"
    "    r2.w = c0.w;\n"
    "    output.color0 = r2;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcPixelFormatConversion_kV4B10Bit_BE_input");
}

void sub_1B7932440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7932470(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7932468);
}

double HgcPixelFormatConversion_kV4B10Bit_BE_input::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x38uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B7EC1850;
  strcpy(v3, "HgcPixelFormatConversion_kV4B10Bit_BE_input [hgc1]");
  return *(double *)"it_BE_input [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::BindTexture(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::Bind(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::RenderTile(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGTile *a2, int8x16_t a3)
{
  int v3 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v3 >= 1)
  {
    int v4 = 0;
    int v5 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v6 = *((void *)a2 + 2);
    uint64_t v7 = *((void *)a2 + 10);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    uint64_t v9 = 16 * *((int *)a2 + 6);
    a3.i32[0] = 1.0;
    while (v5 < 4)
    {
      LODWORD(v59) = 0;
      if (v5 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      ++v4;
      v7 += v8;
      v6 += v9;
      if (v4 == v3) {
        return 0;
      }
    }
    int v10 = 0;
    uint64_t v11 = 32;
    do
    {
      int8x16_t v12 = *(int8x16_t *)(v7 + v11 - 32);
      float32x4_t v13 = *(float32x4_t *)(v7 + v11 - 16);
      float32x4_t v14 = *(float32x4_t *)(v7 + v11);
      int8x16_t v15 = *(int8x16_t *)(v7 + v11 + 16);
      uint64_t v16 = *((void *)this + 51);
      float32x4_t v17 = *(float32x4_t *)(v16 + 16);
      *(int8x8_t *)v18.f32 = vqtbl1_s8(v12, *(int8x8_t *)v16);
      int8x8_t v19 = (int8x8_t)vextq_s8(*(int8x16_t *)v16, *(int8x16_t *)v16, 8uLL).u64[0];
      *(int8x8_t *)v20.f32 = vqtbl1_s8((int8x16_t)v13, *(int8x8_t *)v16);
      *(int8x8_t *)&v18.u32[2] = vqtbl1_s8(v12, v19);
      *(int8x8_t *)&v20.u32[2] = vqtbl1_s8((int8x16_t)v13, v19);
      *(int8x8_t *)v13.f32 = vqtbl1_s8((int8x16_t)v14, *(int8x8_t *)v16);
      *(int8x8_t *)&v13.u32[2] = vqtbl1_s8((int8x16_t)v14, v19);
      *(int8x8_t *)v14.f32 = vqtbl1_s8(v15, *(int8x8_t *)v16);
      *(int8x8_t *)&v14.u32[2] = vqtbl1_s8(v15, v19);
      float32x4_t v22 = *(float32x4_t *)(v16 + 32);
      int8x16_t v21 = *(int8x16_t *)(v16 + 48);
      float32x4_t v23 = vaddq_f32(v17, vmulq_f32(v18, v22));
      float32x4_t v24 = vaddq_f32(v17, vmulq_f32(v20, v22));
      float32x4_t v25 = vaddq_f32(v17, vmulq_f32(v13, v22));
      float32x4_t v26 = vaddq_f32(v17, vmulq_f32(v14, v22));
      float32x4_t v27 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
      float32x4_t v28 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
      float32x4_t v29 = vcvtq_f32_s32(vcvtq_s32_f32(v25));
      float32x4_t v30 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
      float32x4_t v31 = vsubq_f32(v27, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v27, v23)));
      float32x4_t v32 = vsubq_f32(v28, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v28, v24)));
      int8x16_t v33 = (int8x16_t)vsubq_f32(v29, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v29, v25)));
      int8x16_t v34 = (int8x16_t)vsubq_f32(v30, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v30, v26)));
      *(int8x8_t *)v24.f32 = vqtbl1_s8((int8x16_t)v31, *(int8x8_t *)v16);
      *(int8x8_t *)&v24.u32[2] = vqtbl1_s8((int8x16_t)v31, v19);
      *(int8x8_t *)v31.f32 = vqtbl1_s8((int8x16_t)v32, *(int8x8_t *)v16);
      *(int8x8_t *)&v31.u32[2] = vqtbl1_s8((int8x16_t)v32, v19);
      *(int8x8_t *)v32.f32 = vqtbl1_s8(v33, *(int8x8_t *)v16);
      *(int8x8_t *)v35.f32 = vqtbl1_s8(v34, *(int8x8_t *)v16);
      *(int8x8_t *)&v32.u32[2] = vqtbl1_s8(v33, v19);
      *(int8x8_t *)&v35.u32[2] = vqtbl1_s8(v34, v19);
      float32x4_t v36 = *(float32x4_t *)(v16 + 64);
      long long v37 = *(_OWORD *)(v16 + 80);
      float32x4_t v38 = vmulq_f32(v24, v36);
      float32x4_t v39 = vmulq_f32(v31, v36);
      float32x4_t v40 = vmulq_f32(v32, v36);
      float32x4_t v41 = vmulq_f32(v36, v35);
      float32x4_t v42 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
      float32x4_t v43 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      float32x4_t v44 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
      float32x4_t v45 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      float32x4_t v46 = vsubq_f32(v42, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v42, v38)));
      float32x4_t v47 = vsubq_f32(v43, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v43, v39)));
      float32x4_t v48 = vsubq_f32(v44, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v44, v40)));
      float32x4_t v49 = vsubq_f32(v45, (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v45, v41)));
      int8x16_t v50 = (int8x16_t)vaddq_f32(v49, (float32x4_t)vrev64q_s32((int32x4_t)v49));
      int8x16_t v51 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v49, a3, 4uLL), vmulq_lane_f32(vsubq_f32(v41, v49), *(float32x2_t *)&v37, 1));
      int8x16_t v52 = *(int8x16_t *)(v16 + 96);
      float32x4_t v53 = (float32x4_t)vbslq_s8(v52, v50, v51);
      float32x4_t v54 = vmulq_f32(v17, (float32x4_t)vbslq_s8(v52, (int8x16_t)vaddq_f32(v46, (float32x4_t)vrev64q_s32((int32x4_t)v46)), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v46, a3, 4uLL), vmulq_lane_f32(vsubq_f32(v38, v46), *(float32x2_t *)&v37, 1))));
      float32x4_t v55 = vmulq_f32(v17, (float32x4_t)vbslq_s8(*(int8x16_t *)(v16 + 96), (int8x16_t)vaddq_f32(v47, (float32x4_t)vrev64q_s32((int32x4_t)v47)), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v47, a3, 4uLL), vmulq_lane_f32(vsubq_f32(v39, v47), *(float32x2_t *)&v37, 1))));
      float32x4_t v56 = vmulq_f32(v17, (float32x4_t)vbslq_s8(*(int8x16_t *)(v16 + 96), (int8x16_t)vaddq_f32(v48, (float32x4_t)vrev64q_s32((int32x4_t)v48)), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v48, a3, 4uLL), vmulq_lane_f32(vsubq_f32(v40, v48), *(float32x2_t *)&v37, 1))));
      v54.i32[3] = 1.0;
      v55.i32[3] = 1.0;
      v56.i32[3] = 1.0;
      float32x4_t v57 = vmulq_f32(v17, v53);
      v57.i32[3] = 1.0;
      int8x16_t v58 = (float32x4_t *)(v6 + v11);
      v58[-2] = v54;
      v58[-1] = v55;
      *int8x16_t v58 = v56;
      v58[1] = v57;
      v10 -= 4;
      v11 += 64;
    }
    while (v5 + v10 > 3);
    LODWORD(v59) = -v10;
    if ((int)v59 >= v5) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v59 = v59;
    do
    {
      int8x16_t v60 = *(int8x16_t *)(v7 + 16 * v59);
      uint64_t v61 = *((void *)this + 51);
      float32x4_t v62 = *(float32x4_t *)(v61 + 16);
      *(int8x8_t *)v63.f32 = vqtbl1_s8(v60, *(int8x8_t *)v61);
      int8x8_t v64 = (int8x8_t)vextq_s8(*(int8x16_t *)v61, *(int8x16_t *)v61, 8uLL).u64[0];
      *(int8x8_t *)&v63.u32[2] = vqtbl1_s8(v60, v64);
      int8x16_t v65 = *(int8x16_t *)(v61 + 48);
      float32x4_t v66 = vaddq_f32(v62, vmulq_f32(v63, *(float32x4_t *)(v61 + 32)));
      float32x4_t v67 = vcvtq_f32_s32(vcvtq_s32_f32(v66));
      int8x16_t v68 = (int8x16_t)vsubq_f32(v67, (float32x4_t)vandq_s8(v65, (int8x16_t)vcgtq_f32(v67, v66)));
      *(int8x8_t *)v69.f32 = vqtbl1_s8(v68, *(int8x8_t *)v61);
      *(int8x8_t *)&v69.u32[2] = vqtbl1_s8(v68, v64);
      float32x4_t v70 = vmulq_f32(*(float32x4_t *)(v61 + 64), v69);
      float32x4_t v71 = vcvtq_f32_s32(vcvtq_s32_f32(v70));
      float32x4_t v72 = vsubq_f32(v71, (float32x4_t)vandq_s8(v65, (int8x16_t)vcgtq_f32(v71, v70)));
      float32x4_t v73 = vmulq_f32(v62, (float32x4_t)vbslq_s8(*(int8x16_t *)(v61 + 96), (int8x16_t)vaddq_f32(v72, (float32x4_t)vrev64q_s32((int32x4_t)v72)), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v72, a3, 4uLL), vmulq_lane_f32(vsubq_f32(v70, v72), *(float32x2_t *)(v61 + 80), 1))));
      v73.i32[3] = 1.0;
      *(float32x4_t *)(v6 + 16 * v59++) = v73;
    }
    while (v59 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::GetDOD(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::GetROI(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcPixelFormatConversion_kV4B10Bit_BE_input::HgcPixelFormatConversion_kV4B10Bit_BE_input(HgcPixelFormatConversion_kV4B10Bit_BE_input *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F6300;
  operator new();
}

void sub_1B7932A6C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4B10Bit_BE_input::~HgcPixelFormatConversion_kV4B10Bit_BE_input(HGNode *this)
{
  *(void *)this = &unk_1F10F6300;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F6300;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F6300;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AC4F46D1);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::SetParameter(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4B10Bit_BE_input::GetParameter(HgcPixelFormatConversion_kV4B10Bit_BE_input *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcColorGamma_chroma_downsample_f1::GetProgram(HgcColorGamma_chroma_downsample_f1 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000035b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.5000000000, 0.000000000, 0.2500000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy);\n"
             "    r0 = r0*c0.xyyx;\n"
             "    r0 = r1*c0.zwwz + r0;\n"
             "    output.color0 = float4(r2)*float4(c0.zwwz) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2f81be37:9af8fe44:59c646aa:51f8c5ae\n"
             "//SIG=00400000:00000000:00000000:00000001:0001:0000:0003:0000:0000:0000:000e:0000:0003:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000032f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.2500000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy);\n"
             "    r0 = r0*c0.xyyx;\n"
             "    r0 = r1*c0.zwwz + r0;\n"
             "    output.color0 = r2*c0.zwwz + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=a66832cf:ae494a89:e4eb13a9:8c28c8fe\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0000:0003:0000:0000:0000:000e:0000:0003:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000300\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.5000000000, 0.000000000, 0.2500000000);\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture0, hg_TexCoord2.xy);\n"
           "    r0 = r0*c0.xyyx;\n"
           "    r0 = r1*c0.zwwz + r0;\n"
           "    gl_FragColor = r2*c0.zwwz + r0;\n"
           "}\n"
           "//MD5=9c3b26ca:5bc9702c:64a3fe16:6dcbafa3\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0000:0003:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
  }
}

void HgcColorGamma_chroma_downsample_f1::InitProgramDescriptor(HgcColorGamma_chroma_downsample_f1 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_chroma_downsample_f1_hgc_visible", "//Metal1.0     \n//LEN=00000002a4\n[[ visible ]] FragmentOut HgcColorGamma_chroma_downsample_f1_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1,\n    float4 texCoord2)\n{\n    const float4 c0 = float4(1.000000000, 0.5000000000, 0.000000000, 0.2500000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, texCoord0.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, texCoord1.xy);\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, texCoord2.xy);\n"
    "    r0 = r0*c0.xyyx;\n"
    "    r0 = r1*c0.zwwz + r0;\n"
    "    output.color0 = r2*c0.zwwz + r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorGamma_chroma_downsample_f1");
}

void sub_1B7933110(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7933150(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7933148);
}

double HgcColorGamma_chroma_downsample_f1::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x30uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8377430;
  strcpy(v3, "HgcColorGamma_chroma_downsample_f1 [hgc1]");
  return *(double *)"sample_f1 [hgc1]";
}

uint64_t HgcColorGamma_chroma_downsample_f1::BindTexture(HgcColorGamma_chroma_downsample_f1 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, 1.0, 0.0, 0.0);
  HGHandler::TexCoord(a2, 2, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, -1.0, 0.0, 0.0);
  return 0;
}

uint64_t HgcColorGamma_chroma_downsample_f1::Bind(HgcColorGamma_chroma_downsample_f1 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorGamma_chroma_downsample_f1::RenderTile(HgcColorGamma_chroma_downsample_f1 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v37 = 0;
        uint64_t v38 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        uint64_t v39 = 16 * v7;
        uint64_t v40 = 16 * v6;
        do
        {
          unint64_t v41 = 0;
          do
          {
            v5[v41 / 0x10] = vaddq_f32(vmulq_f32(v4[v41 / 0x10 - 1], *(float32x4_t *)(*((void *)this + 51) + 16)), vaddq_f32(vmulq_f32(v4[v41 / 0x10], *(float32x4_t *)*((void *)this + 51)), vmulq_f32(v4[v41 / 0x10 + 1], *(float32x4_t *)(*((void *)this + 51) + 16))));
            v41 += 16;
          }
          while (v38 != v41);
          ++v37;
          int v4 = (float32x4_t *)((char *)v4 + v39);
          int v5 = (float32x4_t *)((char *)v5 + v40);
        }
        while (v37 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v7;
      uint64_t v10 = 16 * v6;
      uint64_t v11 = v4 + 4;
      int8x16_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        unint64_t v14 = 0;
        int8x16_t v15 = v12;
        uint64_t v16 = v11;
        do
        {
          float32x4_t v17 = v16;
          float32x4_t v18 = v15;
          float32x4_t v19 = v4[v13];
          float32x4_t v20 = v4[v13 + 1];
          float32x4_t v21 = v4[v13 + 2];
          float32x4_t v22 = v4[v13 + 3];
          v14 += 4;
          float32x4_t v23 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v24 = v23[1];
          float32x4_t v25 = vmulq_f32(v20, *v23);
          float32x4_t v26 = vmulq_f32(v21, *v23);
          float32x4_t v27 = vmulq_f32(v20, v24);
          float32x4_t v28 = vmulq_f32(v21, v24);
          float32x4_t v29 = vaddq_f32(vmulq_f32(v4[v13 - 1], v24), vaddq_f32(vmulq_f32(v19, *v23), v27));
          float32x4_t v30 = vaddq_f32(vmulq_f32(v19, v24), vaddq_f32(v25, v28));
          float32x4_t v31 = vaddq_f32(v28, vaddq_f32(vmulq_f32(v22, *v23), vmulq_f32(v4[v13 + 4], v24)));
          float32x4_t v32 = &v5[v13];
          *float32x4_t v32 = v29;
          v32[1] = v30;
          v32[2] = vaddq_f32(v27, vaddq_f32(v26, vmulq_f32(v22, v24)));
          v32[3] = v31;
          v13 += 4;
          v16 += 4;
          int8x16_t v15 = v18 + 4;
        }
        while ((uint64_t)v14 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v14)
        {
          do
          {
            float32x4_t v33 = v17[-1];
            ++v14;
            int8x16_t v34 = (float32x4_t *)*((void *)this + 51);
            float32x4_t v35 = vmulq_f32(*v17, *v34);
            float32x4_t v36 = v17[1];
            ++v17;
            *v18++ = vaddq_f32(vmulq_f32(v33, v34[1]), vaddq_f32(v35, vmulq_f32(v36, v34[1])));
          }
          while (v14 < v3);
        }
        ++v8;
        int v4 = (float32x4_t *)((char *)v4 + v9);
        int v5 = (float32x4_t *)((char *)v5 + v10);
        uint64_t v11 = (float32x4_t *)((char *)v11 + v9);
        int8x16_t v12 = (float32x4_t *)((char *)v12 + v10);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcColorGamma_chroma_downsample_f1::GetDOD(HgcColorGamma_chroma_downsample_f1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0, 1u, 0);
  return HGRectGrow(v6, v5, v7);
}

uint64_t HgcColorGamma_chroma_downsample_f1::GetROI(HgcColorGamma_chroma_downsample_f1 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0, 1u, 0);
  return HGRectGrow(v6, v5, v7);
}

void HgcColorGamma_chroma_downsample_f1::HgcColorGamma_chroma_downsample_f1(HgcColorGamma_chroma_downsample_f1 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F6568;
  operator new();
}

void sub_1B7933788(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_chroma_downsample_f1::~HgcColorGamma_chroma_downsample_f1(HGNode *this)
{
  *(void *)this = &unk_1F10F6568;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F6568;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F6568;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_chroma_downsample_f1::SetParameter(HgcColorGamma_chroma_downsample_f1 *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_chroma_downsample_f1::GetParameter(HgcColorGamma_chroma_downsample_f1 *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcColorGamma_v210_yxzx_rgba_collapse::GetProgram(HgcColorGamma_v210_yxzx_rgba_collapse *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000009de\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.2500000000, 1.000000000, 6.000000000, 0.5000000000);\n"
             "    const half4 c1 = half4(4.000000000, 1.000000000, 0.000000000, 3.000000000);\n"
             "    const half4 c2 = half4(2.000000000, 0.003910068423, 0.9960899353, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = frag._texCoord0.xy*float2(c0.xy);\n"
             "    s0.xy = floor(s0.xy);\n"
             "    s0.xy = s0.xy*float2(c0.zy) + float2(c0.ww);\n"
             "    s1.xyz = floor(frag._texCoord0.xxx);\n"
             "    s1.xyz = s1.xyz - float3(c1.xxx)*floor(s1.xyz/float3(c1.xxx));\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r0.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s2.xy).xyz;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r1.x = (half) hg_Texture0.sample(hg_Sampler0, s2.xy).x;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r2.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s2.xy).xyz;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r3.x = (half) hg_Texture0.sample(hg_Sampler0, s2.xy).x;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s2.xy = s0.xy + hg_Params[0].xy;\n"
             "    s2.xy = s2.xy*hg_Params[0].zw;\n"
             "    r4.xyz = (half3) hg_Texture0.sample(hg_Sampler0, s2.xy).xyz;\n"
             "    s0.xy = s0.xy + float2(c1.yz);\n"
             "    s0.xy = s0.xy + hg_Params[0].xy;\n"
             "    s0.xy = s0.xy*hg_Params[0].zw;\n"
             "    r5.x = (half) hg_Texture0.sample(hg_Sampler0, s0.xy).x;\n"
             "    r6.yz = r2.yx;\n"
             "    r6.x = r1.x;\n"
             "    r2.x = r2.z;\n"
             "    r2.y = r3.x;\n"
             "    r2.z = r4.y;\n"
             "    r4.xy = r4.xz;\n"
             "    r4.z = r5.x;\n"
             "    s2.xyz = s1.xyz - float3(c1.www);\n"
             "    s2.xyz = select(float3(r4.xyz), float3(r2.xyz), s2.xyz < 0.00000h);\n"
             "    s0.xyz = s1.xyz - float3(c2.xxx);\n"
             "    s2.xyz = select(s2.xyz, float3(r6.xyz), s0.xyz < 0.00000h);\n"
             "    s1.xyz = s1.xyz - float3(c1.yyy);\n"
             "    s2.xyz = select(s2.xyz, float3(r0.yxz), s1.xyz < 0.00000h);\n"
             "    s2.xyz = fmax(s2.xyz, float3(c2.yyy));\n"
             "    s2.xyz = fmin(s2.xyz, float3(c2.zzz));\n"
             "    s2.w = float(c1.y);\n"
             "    output.color0 = s2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=1c0e69ec:53ecdd8e:097f183e:5cdfa298\n"
             "//SIG=00400000:00000000:00000000:00000001:0003:0001:000a:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000907\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.2500000000, 1.000000000, 6.000000000, 0.5000000000);\n"
             "    const float4 c1 = float4(4.000000000, 1.000000000, 0.000000000, 3.000000000);\n"
             "    const float4 c2 = float4(2.000000000, 0.003910068423, 0.9960899353, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy*c0.xy;\n"
             "    r0.xy = floor(r0.xy);\n"
             "    r0.xy = r0.xy*c0.zy + c0.ww;\n"
             "    r1.xyz = floor(frag._texCoord0.xxx);\n"
             "    r1.xyz = r1.xyz - c1.xxx*floor(r1.xyz/c1.xxx);\n"
             "    r2.xy = r0.xy + hg_Params[0].xy;\n"
             "    r2.xy = r2.xy*hg_Params[0].zw;\n"
             "    r2.xyz = hg_Texture0.sample(hg_Sampler0, r2.xy).xyz;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r3.xy = r0.xy + hg_Params[0].xy;\n"
             "    r3.xy = r3.xy*hg_Params[0].zw;\n"
             "    r3.x = hg_Texture0.sample(hg_Sampler0, r3.xy).x;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r4.xy = r0.xy + hg_Params[0].xy;\n"
             "    r4.xy = r4.xy*hg_Params[0].zw;\n"
             "    r4.xyz = hg_Texture0.sample(hg_Sampler0, r4.xy).xyz;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r5.xy = r0.xy + hg_Params[0].xy;\n"
             "    r5.xy = r5.xy*hg_Params[0].zw;\n"
             "    r5.x = hg_Texture0.sample(hg_Sampler0, r5.xy).x;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r6.xy = r0.xy + hg_Params[0].xy;\n"
             "    r6.xy = r6.xy*hg_Params[0].zw;\n"
             "    r6.xyz = hg_Texture0.sample(hg_Sampler0, r6.xy).xyz;\n"
             "    r0.xy = r0.xy + c1.yz;\n"
             "    r0.xy = r0.xy + hg_Params[0].xy;\n"
             "    r0.xy = r0.xy*hg_Params[0].zw;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, r0.xy).x;\n"
             "    r7.yz = r4.yx;\n"
             "    r7.x = r3.x;\n"
             "    r4.x = r4.z;\n"
             "    r4.y = r5.x;\n"
             "    r4.z = r6.y;\n"
             "    r6.xy = r6.xz;\n"
             "    r6.z = r0.x;\n"
             "    r3.xyz = r1.xyz - c1.www;\n"
             "    r6.xyz = select(r6.xyz, r4.xyz, r3.xyz < 0.00000f);\n"
             "    r5.xyz = r1.xyz - c2.xxx;\n"
             "    r6.xyz = select(r6.xyz, r7.xyz, r5.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz - c1.yyy;\n"
             "    r6.xyz = select(r6.xyz, r2.yxz, r1.xyz < 0.00000f);\n"
             "    r6.xyz = fmax(r6.xyz, c2.yyy);\n"
             "    r6.xyz = fmin(r6.xyz, c2.zzz);\n"
             "    r6.w = c1.y;\n"
             "    output.color0 = r6;\n"
             "    return output;\n"
             "}\n"
             "//MD5=955a98b9:d83ed1c3:5b5e15df:a3665098\n"
             "//SIG=00000000:00000000:00000000:00000000:0003:0001:0008:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000095d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.2500000000, 1.000000000, 6.000000000, 0.5000000000);\n"
           "    const highp vec4 c1 = vec4(4.000000000, 1.000000000, 0.000000000, 3.000000000);\n"
           "    const highp vec4 c2 = vec4(2.000000000, 0.003910068423, 0.9960899353, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy*c0.xy;\n"
           "    r0.xy = floor(r0.xy);\n"
           "    r0.xy = r0.xy*c0.zy + c0.ww;\n"
           "    r1.xyz = floor(hg_TexCoord0.xxx);\n"
           "    r1.xyz = mod(r1.xyz, c1.xxx);\n"
           "    r2.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal0.zw;\n"
           "    r2.xyz = texture2D(hg_Texture0, r2.xy).xyz;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r3.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r3.xy = r3.xy*hg_ProgramLocal0.zw;\n"
           "    r3.x = texture2D(hg_Texture0, r3.xy).x;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r4.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r4.xy = r4.xy*hg_ProgramLocal0.zw;\n"
           "    r4.xyz = texture2D(hg_Texture0, r4.xy).xyz;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r5.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r5.xy = r5.xy*hg_ProgramLocal0.zw;\n"
           "    r5.x = texture2D(hg_Texture0, r5.xy).x;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r6.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r6.xy = r6.xy*hg_ProgramLocal0.zw;\n"
           "    r6.xyz = texture2D(hg_Texture0, r6.xy).xyz;\n"
           "    r0.xy = r0.xy + c1.yz;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal0.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal0.zw;\n"
           "    r0.x = texture2D(hg_Texture0, r0.xy).x;\n"
           "    r7.yz = r4.yx;\n"
           "    r7.x = r3.x;\n"
           "    r4.x = r4.z;\n"
           "    r4.y = r5.x;\n"
           "    r4.z = r6.y;\n"
           "    r6.xy = r6.xz;\n"
           "    r6.z = r0.x;\n"
           "    r3.xyz = r1.xyz - c1.www;\n"
           "    r6.xyz = vec3(r3.x < 0.00000 ? r4.x : r6.x, r3.y < 0.00000 ? r4.y : r6.y, r3.z < 0.00000 ? r4.z : r6.z);\n"
           "    r5.xyz = r1.xyz - c2.xxx;\n"
           "    r6.xyz = vec3(r5.x < 0.00000 ? r7.x : r6.x, r5.y < 0.00000 ? r7.y : r6.y, r5.z < 0.00000 ? r7.z : r6.z);\n"
           "    r1.xyz = r1.xyz - c1.yyy;\n"
           "    r6.xyz = vec3(r1.x < 0.00000 ? r2.y : r6.x, r1.y < 0.00000 ? r2.x : r6.y, r1.z < 0.00000 ? r2.z : r6.z);\n"
           "    r6.xyz = max(r6.xyz, c2.yyy);\n"
           "    r6.xyz = min(r6.xyz, c2.zzz);\n"
           "    r6.w = c1.y;\n"
           "    gl_FragColor = r6;\n"
           "}\n"
           "//MD5=48f15dc5:4d975e15:d41b2040:0394471d\n"
           "//SIG=00000000:00000000:00000000:00000000:0003:0001:0008:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorGamma_v210_yxzx_rgba_collapse::InitProgramDescriptor(HgcColorGamma_v210_yxzx_rgba_collapse *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_v210_yxzx_rgba_collapse_hgc_visible", "//Metal1.0     \n//LEN=0000000859\n[[ visible ]] FragmentOut HgcColorGamma_v210_yxzx_rgba_collapse_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(0.2500000000, 1.000000000, 6.000000000, 0.5000000000);\n"
    "    const float4 c1 = float4(4.000000000, 1.000000000, 0.000000000, 3.000000000);\n"
    "    const float4 c2 = float4(2.000000000, 0.003910068423, 0.9960899353, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy*c0.xy;\n"
    "    r0.xy = floor(r0.xy);\n"
    "    r0.xy = r0.xy*c0.zy + c0.ww;\n"
    "    r1.xyz = floor(texCoord0.xxx);\n"
    "    r1.xyz = r1.xyz - c1.xxx*floor(r1.xyz/c1.xxx);\n"
    "    r2.xy = r0.xy + hg_Params[0].xy;\n"
    "    r2.xy = r2.xy*hg_Params[0].zw;\n"
    "    r2.xyz = hg_Texture0.sample(hg_Sampler0, r2.xy).xyz;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r3.xy = r0.xy + hg_Params[0].xy;\n"
    "    r3.xy = r3.xy*hg_Params[0].zw;\n"
    "    r3.x = hg_Texture0.sample(hg_Sampler0, r3.xy).x;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r4.xy = r0.xy + hg_Params[0].xy;\n"
    "    r4.xy = r4.xy*hg_Params[0].zw;\n"
    "    r4.xyz = hg_Texture0.sample(hg_Sampler0, r4.xy).xyz;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r5.xy = r0.xy + hg_Params[0].xy;\n"
    "    r5.xy = r5.xy*hg_Params[0].zw;\n"
    "    r5.x = hg_Texture0.sample(hg_Sampler0, r5.xy).x;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r6.xy = r0.xy + hg_Params[0].xy;\n"
    "    r6.xy = r6.xy*hg_Params[0].zw;\n"
    "    r6.xyz = hg_Texture0.sample(hg_Sampler0, r6.xy).xyz;\n"
    "    r0.xy = r0.xy + c1.yz;\n"
    "    r0.xy = r0.xy + hg_Params[0].xy;\n"
    "    r0.xy = r0.xy*hg_Params[0].zw;\n"
    "    r0.x = hg_Texture0.sample(hg_Sampler0, r0.xy).x;\n"
    "    r7.yz = r4.yx;\n"
    "    r7.x = r3.x;\n"
    "    r4.x = r4.z;\n"
    "    r4.y = r5.x;\n"
    "    r4.z = r6.y;\n"
    "    r6.xy = r6.xz;\n"
    "    r6.z = r0.x;\n"
    "    r3.xyz = r1.xyz - c1.www;\n"
    "    r6.xyz = select(r6.xyz, r4.xyz, r3.xyz < 0.00000f);\n"
    "    r5.xyz = r1.xyz - c2.xxx;\n"
    "    r6.xyz = select(r6.xyz, r7.xyz, r5.xyz < 0.00000f);\n"
    "    r1.xyz = r1.xyz - c1.yyy;\n"
    "    r6.xyz = select(r6.xyz, r2.yxz, r1.xyz < 0.00000f);\n"
    "    r6.xyz = fmax(r6.xyz, c2.yyy);\n"
    "    r6.xyz = fmin(r6.xyz, c2.zzz);\n"
    "    r6.w = c1.y;\n"
    "    output.color0 = r6;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorGamma_v210_yxzx_rgba_collapse");
}

void sub_1B7933CFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7933D34(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7933D2CLL);
}

double HgcColorGamma_v210_yxzx_rgba_collapse::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x30uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B83770C0;
  strcpy(v3, "HgcColorGamma_v210_yxzx_rgba_collapse [hgc1]");
  return *(double *)"_collapse [hgc1]";
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::BindTexture(HgcColorGamma_v210_yxzx_rgba_collapse *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, void, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 0, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::Bind(HgcColorGamma_v210_yxzx_rgba_collapse *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::RenderTile(HgcColorGamma_v210_yxzx_rgba_collapse *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      int v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      int32x2_t v7 = a2[2];
      uint64_t v8 = 16 * a2[3].i32[0];
      uint64_t v9 = 16 * v4;
      v10.i64[0] = 0x3F0000003F000000;
      v10.i64[1] = 0x3F0000003F000000;
      float32x4_t v11 = v6;
      do
      {
        uint64_t v12 = 0;
        float32x4_t v13 = v11;
        do
        {
          uint64_t v14 = *((void *)this + 51);
          float32x4_t v15 = *(float32x4_t *)(v14 + 16);
          float32x4_t v16 = vmulq_f32(v13, *(float32x4_t *)v14);
          float32x4_t v17 = vcvtq_f32_s32(vcvtq_s32_f32(v16));
          float32x4_t v18 = vmulq_f32(*(float32x4_t *)(v14 + 48), vsubq_f32(v17, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v17, v16))));
          float32x4_t v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0);
          float32x4_t v20 = vcvtq_f32_s32(vcvtq_s32_f32(v19));
          float32x4_t v21 = vmulq_f32(*(float32x4_t *)(v14 + 64), vsubq_f32(v20, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v20, v19))));
          float32x4_t v22 = vaddq_f32(*(float32x4_t *)(v14 + 32), v18);
          float32x4_t v23 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
          float32x4_t v24 = vsubq_f32(v21, vsubq_f32(v23, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v23, v21))));
          int32x2_t v25 = a2[10];
          __int32 v26 = a2[11].i32[0];
          float32x4_t v27 = vaddq_f32(vsubq_f32(v22, v6), v10);
          int32x4_t v28 = vcvtq_s32_f32(v27);
          float32x4_t v29 = vmulq_f32(*(float32x4_t *)(v14 + 80), v24);
          v28.i64[0] = vaddq_s32(v28, vcgtq_f32(vcvtq_f32_s32(v28), v27)).u64[0];
          float32x4_t v30 = *(float32x4_t *)(v14 + 96);
          int8x16_t v31 = *(int8x16_t *)(v14 + 112);
          __int32 v32 = v28.i32[1];
          float32x4_t v33 = vaddq_f32(v22, v30);
          float32x4_t v34 = vaddq_f32(vsubq_f32(v33, v6), v10);
          int32x4_t v35 = vcvtq_s32_f32(v34);
          __int32 v36 = v28.i32[0];
          v28.i64[0] = vaddq_s32(v35, vcgtq_f32(vcvtq_f32_s32(v35), v34)).u64[0];
          __int32 v37 = v28.i32[1];
          __int32 v38 = v28.i32[0];
          float32x4_t v39 = vaddq_f32(v30, v33);
          float32x4_t v40 = vaddq_f32(vsubq_f32(v39, v6), v10);
          int32x4_t v41 = vcvtq_s32_f32(v40);
          __int32 v42 = v36 + v32 * v26;
          v40.i64[0] = vaddq_s32(v41, vcgtq_f32(vcvtq_f32_s32(v41), v40)).u64[0];
          __int32 v43 = v40.i32[1];
          int8x16_t v44 = *(int8x16_t *)(*(void *)&v25 + 16 * v42);
          __int32 v45 = v38 + v37 * v26;
          __int32 v46 = v40.i32[0];
          float32x4_t v47 = vaddq_f32(v30, v39);
          int8x16_t v48 = *(int8x16_t *)(*(void *)&v25 + 16 * v45);
          float32x4_t v49 = vaddq_f32(vsubq_f32(v47, v6), v10);
          int32x4_t v50 = vcvtq_s32_f32(v49);
          v49.i64[0] = vaddq_s32(v50, vcgtq_f32(vcvtq_f32_s32(v50), v49)).u64[0];
          __int32 v51 = v46 + v43 * v26;
          __int32 v52 = v49.i32[1];
          __int32 v53 = v49.i32[0];
          float32x4_t v54 = vaddq_f32(v30, v47);
          int64x2_t v55 = *(int64x2_t *)(*(void *)&v25 + 16 * v51);
          float32x4_t v56 = vaddq_f32(vsubq_f32(v54, v6), v10);
          int32x4_t v57 = vcvtq_s32_f32(v56);
          __int32 v58 = v53 + v52 * v26;
          v56.i64[0] = vaddq_s32(v57, vcgtq_f32(vcvtq_f32_s32(v57), v56)).u64[0];
          float32x4_t v59 = vaddq_f32(vsubq_f32(vaddq_f32(v30, v54), v6), v10);
          int32x4_t v60 = vcvtq_s32_f32(v59);
          v59.i64[0] = vaddq_s32(v60, vcgtq_f32(vcvtq_f32_s32(v60), v59)).u64[0];
          int8x16_t v61 = *(int8x16_t *)(*(void *)&v25 + 16 * (v56.i32[0] + v56.i32[1] * v26));
          __int32 v62 = v59.i32[0] + v59.i32[1] * v26;
          int8x16_t v63 = vbslq_s8(v31, v48, (int8x16_t)vdupq_lane_s64(v55.i64[0], 0));
          v55.i64[0] = vbslq_s8(v31, (int8x16_t)vdupq_laneq_s64(v55, 1), (int8x16_t)vrev64q_s32(*(int32x4_t *)(*(void *)&v25 + 16 * v58))).u64[0];
          int8x16_t v64 = vextq_s8((int8x16_t)v6, v61, 0xCuLL);
          *(int8x8_t *)v61.i8 = vqtbl1_s8(v61, *(int8x8_t *)(v14 + 128));
          v64.i64[0] = v55.i64[0];
          float32x4_t v65 = *(float32x4_t *)(v14 + 160);
          int8x16_t v66 = (int8x16_t)vcgtq_f32(v65, vsubq_f32(v29, *(float32x4_t *)(v14 + 144)));
          v61.i64[1] = *(void *)(*(void *)&v25 + 16 * v62);
          int8x16_t v67 = (int8x16_t)vcgtq_f32(v65, vsubq_f32(v29, *(float32x4_t *)(v14 + 176)));
          float32x4_t v68 = vsubq_f32(v29, v15);
          int8x16_t v69 = *(int8x16_t *)(v14 + 192);
          *(int8x8_t *)v70.i8 = vqtbl1_s8(v44, *(int8x8_t *)v69.i8);
          v70.u64[1] = (unint64_t)vqtbl1_s8(v44, (int8x8_t)*(_OWORD *)&vextq_s8(v69, v69, 8uLL));
          float32x4_t v71 = vminq_f32(vmaxq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v65, v68), v70, vbslq_s8(v67, v63, vbslq_s8(v66, v64, v61))), *(float32x4_t *)(v14 + 208)), *(float32x4_t *)(v14 + 224));
          v71.i32[3] = 1.0;
          *(float32x4_t *)(*(void *)&v7 + v12) = v71;
          float32x4_t v13 = vaddq_f32(v13, (float32x4_t)xmmword_1B7E736B0);
          v12 += 16;
        }
        while (v9 != v12);
        float32x4_t v11 = vaddq_f32(v11, (float32x4_t)xmmword_1B7E736C0);
        ++v5;
        *(void *)&v7 += v8;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::GetDOD(HgcColorGamma_v210_yxzx_rgba_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  int v4 = &HGRectInfinite;
  if (a3) {
    int v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcColorGamma_v210_yxzx_rgba_collapse::HgcColorGamma_v210_yxzx_rgba_collapse(HgcColorGamma_v210_yxzx_rgba_collapse *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F67D0;
  operator new();
}

void sub_1B79343A0(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_v210_yxzx_rgba_collapse::~HgcColorGamma_v210_yxzx_rgba_collapse(HGNode *this)
{
  *(void *)this = &unk_1F10F67D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4019FCA701);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F67D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4019FCA701);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F67D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4019FCA701);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::SetParameter(HgcColorGamma_v210_yxzx_rgba_collapse *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_v210_yxzx_rgba_collapse::GetParameter(HgcColorGamma_v210_yxzx_rgba_collapse *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcColorGamma_2vuy_xyxz_collapse::GetProgram(HgcColorGamma_2vuy_xyxz_collapse *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000028e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = (half3) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    output.color0.yzw = float3(r0.yxz);\n"
             "    output.color0.x = (float) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=03a1507a:010149b6:76881db1:e797c2f0\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0001:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000278\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    output.color0.yzw = r0.yxz;\n"
             "    output.color0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b3a548da:cd778fbd:9d5ae4a9:fb81f639\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000022e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.xyz = texture2D(hg_Texture0, hg_TexCoord0.xy).xyz;\n"
           "    gl_FragColor.yzw = r0.yxz;\n"
           "    gl_FragColor.x = texture2D(hg_Texture0, hg_TexCoord1.xy).x;\n"
           "}\n"
           "//MD5=6dabeac5:cfd7b220:9dd1d489:c803d0b5\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcColorGamma_2vuy_xyxz_collapse::InitProgramDescriptor(HgcColorGamma_2vuy_xyxz_collapse *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_2vuy_xyxz_collapse_hgc_visible", "//Metal1.0     \n//LEN=00000001db\n[[ visible ]] FragmentOut HgcColorGamma_2vuy_xyxz_collapse_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).xyz;\n"
    "    output.color0.yzw = r0.yxz;\n"
    "    output.color0.x = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).x;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorGamma_2vuy_xyxz_collapse");
}

void sub_1B79349AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B79349E8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79349E0);
}

char *HgcColorGamma_2vuy_xyxz_collapse::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376020;
  strcpy(result, "HgcColorGamma_2vuy_xyxz_collapse [hgc1]");
  return result;
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::BindTexture(HgcColorGamma_2vuy_xyxz_collapse *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, -0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, 0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::Bind(HgcColorGamma_2vuy_xyxz_collapse *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::RenderTile(HgcColorGamma_2vuy_xyxz_collapse *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    uint64_t v4 = *(int *)a2;
    int v5 = *((_DWORD *)a2 + 2) - v4;
    float32x4_t v6 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v7 = *((void *)a2 + 10) + 16 * v4;
    uint64_t v8 = *((int *)a2 + 22);
    uint64_t v9 = v7 + 64;
    float32x4_t v10 = v6 + 2;
    uint64_t v11 = 16 * *((int *)a2 + 6);
    while (v5 < 4)
    {
      LODWORD(v28) = 0;
      if (v5 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v7 += 16 * v8;
      ++v3;
      v9 += 16 * v8;
      float32x4_t v10 = (int8x16_t *)((char *)v10 + v11);
      float32x4_t v6 = (int8x16_t *)((char *)v6 + v11);
      if (v3 == v2) {
        return 0;
      }
    }
    int v12 = 0;
    float32x4_t v13 = v10;
    uint64_t v14 = (int8x16_t *)v9;
    do
    {
      uint64_t v15 = *((void *)this + 51);
      int8x16_t v16 = v14[-4];
      *(int8x8_t *)v17.i8 = vqtbl1_s8(v16, *(int8x8_t *)v15);
      int8x8_t v18 = (int8x8_t)vextq_s8(*(int8x16_t *)v15, *(int8x16_t *)v15, 8uLL).u64[0];
      v17.u64[1] = (unint64_t)vqtbl1_s8(v16, v18);
      int8x16_t v19 = v14[-2];
      *(int8x8_t *)v20.i8 = vqtbl1_s8(v19, *(int8x8_t *)v15);
      v20.u64[1] = (unint64_t)vqtbl1_s8(v19, v18);
      *(int8x8_t *)v21.i8 = vqtbl1_s8(*v14, *(int8x8_t *)v15);
      v21.u64[1] = (unint64_t)vqtbl1_s8(*v14, v18);
      int8x16_t v22 = v14[2];
      *(int8x8_t *)v23.i8 = vqtbl1_s8(v22, *(int8x8_t *)v15);
      v23.u64[1] = (unint64_t)vqtbl1_s8(v22, v18);
      int8x16_t v24 = vbslq_s8(*(int8x16_t *)(v15 + 16), v14[-3], v17);
      int8x16_t v25 = vbslq_s8(*(int8x16_t *)(v15 + 16), v14[-1], v20);
      int8x16_t v26 = vbslq_s8(*(int8x16_t *)(v15 + 16), v14[1], v21);
      int8x16_t v27 = vbslq_s8(*(int8x16_t *)(v15 + 16), v14[3], v23);
      v13[-2] = v24;
      v13[-1] = v25;
      *float32x4_t v13 = v26;
      v13[1] = v27;
      v13 += 4;
      v14 += 8;
      v12 -= 4;
    }
    while (v5 + v12 > 3);
    LODWORD(v28) = -v12;
    if (-v12 >= v5) {
      goto LABEL_3;
    }
LABEL_10:
    unsigned int v29 = 2 * v28;
    uint64_t v28 = v28;
    do
    {
      int8x16_t v30 = *(int8x16_t *)(v7 + 16 * v29);
      uint64_t v31 = *((void *)this + 51);
      *(int8x8_t *)v32.i8 = vqtbl1_s8(v30, *(int8x8_t *)v31);
      v32.u64[1] = (unint64_t)vqtbl1_s8(v30, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v31, *(int8x16_t *)v31, 8uLL));
      v6[v28++] = vbslq_s8(*(int8x16_t *)(v31 + 16), *(int8x16_t *)(v7 + 16 * (v29 + 1)), v32);
      v29 += 2;
    }
    while (v28 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::GetDOD(HgcColorGamma_2vuy_xyxz_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0, 0, 0xFFFFFFFF, 0);
  int v8 = HGRectGrow(v6, v5, v7);
  float v9 = HGRectFloat(v8);
  float v13 = HGRectScale(v9, v10, v11, v12, 0.5);
  uint64_t v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::GetROI(HgcColorGamma_2vuy_xyxz_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 2.0);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  uint64_t v16 = v15;
  uint64_t v17 = HGRectMake4i(0, 0, 1u, 0);
  uint64_t v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcColorGamma_2vuy_xyxz_collapse::HgcColorGamma_2vuy_xyxz_collapse(HgcColorGamma_2vuy_xyxz_collapse *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F6A38;
  operator new();
}

void sub_1B7935048(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_2vuy_xyxz_collapse::~HgcColorGamma_2vuy_xyxz_collapse(HGNode *this)
{
  *(void *)this = &unk_1F10F6A38;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F6A38;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F6A38;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::SetParameter(HgcColorGamma_2vuy_xyxz_collapse *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_2vuy_xyxz_collapse::GetParameter(HgcColorGamma_2vuy_xyxz_collapse *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcPixelFormatConversion_kV4S_WXYZ_output::GetProgram(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000022e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.wxyz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cf796c8f:0088fb48:fbecfffa:bebd058b\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000220\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.wxyz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6820d1f2:902f3939:8ad944e0:7499e717\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.wxyz;\n"
           "}\n"
           "//MD5=3629bbaf:437df260:e6e61391:b5896e9d\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4S_WXYZ_output::InitProgramDescriptor(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4S_WXYZ_output_hgc_visible", "//Metal1.0     \n//LEN=0000000113\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4S_WXYZ_output_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0.wxyz;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcPixelFormatConversion_kV4S_WXYZ_output");
}

void sub_1B793548C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B79354BC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79354B4);
}

double HgcPixelFormatConversion_kV4S_WXYZ_output::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x38uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376F50;
  strcpy(v3, "HgcPixelFormatConversion_kV4S_WXYZ_output [hgc1]");
  return *(double *)"YZ_output [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::BindTexture(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::Bind(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::RenderTile(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = (int8x16_t *)*((void *)a2 + 10);
    int v5 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v24 = 0;
        uint64_t v25 = 16 * v7;
        uint64_t v26 = 16 * v6;
        uint64_t v27 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v28 = 0;
          do
          {
            v5[v28 / 0x10] = vextq_s8(v4[v28 / 0x10], v4[v28 / 0x10], 0xCuLL);
            v28 += 16;
          }
          while (v27 != v28);
          ++v24;
          uint64_t v4 = (int8x16_t *)((char *)v4 + v25);
          int v5 = (int8x16_t *)((char *)v5 + v26);
        }
        while (v24 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float v11 = v4 + 4;
      float v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        uint64_t v14 = v12;
        uint64_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          uint64_t v17 = v15;
          uint64_t v18 = v14;
          int8x16_t v19 = vextq_s8(v4[v16 - 1], v4[v16 - 1], 0xCuLL);
          int8x16_t v20 = vextq_s8(v4[v16], v4[v16], 0xCuLL);
          int8x16_t v21 = vextq_s8(v4[v16 + 1], v4[v16 + 1], 0xCuLL);
          int8x16_t v22 = &v5[v16];
          v22[-2] = vextq_s8(v4[v16 - 2], v4[v16 - 2], 0xCuLL);
          v22[-1] = v19;
          v13 += 4;
          *int8x16_t v22 = v20;
          v22[1] = v21;
          v16 += 4;
          v15 += 4;
          uint64_t v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            int8x16_t v23 = *v17++;
            *v18++ = vextq_s8(v23, v23, 0xCuLL);
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (int8x16_t *)((char *)v5 + v9);
        uint64_t v4 = (int8x16_t *)((char *)v4 + v10);
        float v11 = (int8x16_t *)((char *)v11 + v10);
        float v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::GetDOD(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::GetROI(HgcPixelFormatConversion_kV4S_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcPixelFormatConversion_kV4S_WXYZ_output::HgcPixelFormatConversion_kV4S_WXYZ_output(HgcPixelFormatConversion_kV4S_WXYZ_output *this)
{
}

void sub_1B7935898(_Unwind_Exception *a1)
{
  HGColorMatrix::~HGColorMatrix(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4S_WXYZ_output::~HgcPixelFormatConversion_kV4S_WXYZ_output(HgcPixelFormatConversion_kV4S_WXYZ_output *this)
{
  *(void *)this = &unk_1F10F6CA0;
  uint64_t v2 = *((void *)this + 62);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F6CA0;
  uint64_t v2 = *((void *)this + 62);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F6CA0;
  uint64_t v2 = *((void *)this + 62);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }
  HGColorMatrix::~HGColorMatrix(this);

  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::SetParameter(HgcPixelFormatConversion_kV4S_WXYZ_output *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4S_WXYZ_output::GetParameter(HgcPixelFormatConversion_kV4S_WXYZ_output *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

HGNode *HgcPixelFormatConversion_kV4S_WXYZ_output::GetOutput(__n128 *this, HGRenderer *a2, __n128 a3, __n128 a4, __n128 a5)
{
  if (this[31].n128_u32[2])
  {
    int v5 = (int8x16_t *)this[31].n128_u64[0];
    a4 = (__n128)vextq_s8(v5[5], v5[5], 0xCuLL);
    a5 = (__n128)vextq_s8(v5[6], v5[6], 0xCuLL);
    int8x16_t v6 = vextq_s8(v5[7], v5[7], 0xCuLL);
    int8x16_t *v5 = vextq_s8(v5[4], v5[4], 0xCuLL);
    *(__n128 *)(this[31].n128_u64[0] + 16) = a4;
    *(__n128 *)(this[31].n128_u64[0] + 32) = a5;
    *(int8x16_t *)(this[31].n128_u64[0] + 48) = v6;
    uint64_t v7 = (__n128 *)this[31].n128_u64[0];
    this[27] = *v7;
    this[28] = v7[1];
    this[29] = v7[2];
    a3 = v7[3];
    this[30] = a3;
    this[31].n128_u32[2] = 0;
  }
  return HGColorMatrix::GetOutput((HGColorMatrix *)this, a2, a3.n128_f64[0], a4.n128_f64[0], (int32x2_t)a5.n128_u64[0]);
}

const char *HgcColorGamma_2vuy_yxzx_collapse::GetProgram(HgcColorGamma_2vuy_yxzx_collapse *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002a9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = (half3) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    r1.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    output.color0.xyz = float3(r0.zxy);\n"
             "    output.color0.w = float(r1.x);\n"
             "    return output;\n"
             "}\n"
             "//MD5=137f9951:1ecff4bd:440988b0:a7a24e84\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000028d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy).x;\n"
             "    output.color0.xyz = r0.zxy;\n"
             "    output.color0.w = r1.x;\n"
             "    return output;\n"
             "}\n"
             "//MD5=26871f8e:7dbd704e:68fccc01:ba0d779a\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000243\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xyz = texture2D(hg_Texture0, hg_TexCoord0.xy).xyz;\n"
           "    r1.x = texture2D(hg_Texture0, hg_TexCoord1.xy).x;\n"
           "    gl_FragColor.xyz = r0.zxy;\n"
           "    gl_FragColor.w = r1.x;\n"
           "}\n"
           "//MD5=690e075e:9a04c53e:3eba47dc:e08b8ec4\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcColorGamma_2vuy_yxzx_collapse::InitProgramDescriptor(HgcColorGamma_2vuy_yxzx_collapse *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_2vuy_yxzx_collapse_hgc_visible", "//Metal1.0     \n//LEN=00000001f0\n[[ visible ]] FragmentOut HgcColorGamma_2vuy_yxzx_collapse_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = hg_Texture0.sample(hg_Sampler0, texCoord0.xy).xyz;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, texCoord1.xy).x;\n"
    "    output.color0.xyz = r0.zxy;\n"
    "    output.color0.w = r1.x;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorGamma_2vuy_yxzx_collapse");
}

void sub_1B7935F0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7935F48(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7935F40);
}

char *HgcColorGamma_2vuy_yxzx_collapse::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376020;
  strcpy(result, "HgcColorGamma_2vuy_yxzx_collapse [hgc1]");
  return result;
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::BindTexture(HgcColorGamma_2vuy_yxzx_collapse *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, -0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, 0.5, 0.0, 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, 2.0, 1.0, 1.0);
  return 0;
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::Bind(HgcColorGamma_2vuy_yxzx_collapse *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::RenderTile(HgcColorGamma_2vuy_yxzx_collapse *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    uint64_t v4 = *(int *)a2;
    int v5 = *((_DWORD *)a2 + 2) - v4;
    int8x16_t v6 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v7 = *((void *)a2 + 10) + 16 * v4;
    uint64_t v8 = *((int *)a2 + 22);
    uint64_t v9 = v7 + 64;
    uint64_t v10 = v6 + 2;
    uint64_t v11 = 16 * *((int *)a2 + 6);
    while (v5 < 4)
    {
      LODWORD(v26) = 0;
      if (v5 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v7 += 16 * v8;
      ++v3;
      v9 += 16 * v8;
      uint64_t v10 = (int8x16_t *)((char *)v10 + v11);
      int8x16_t v6 = (int8x16_t *)((char *)v6 + v11);
      if (v3 == v2) {
        return 0;
      }
    }
    int v12 = 0;
    unint64_t v13 = v10;
    uint64_t v14 = (int8x16_t *)v9;
    do
    {
      int8x16_t v15 = v14[-4];
      int8x16_t v16 = v14[-2];
      uint64_t v17 = *((void *)this + 51);
      int8x16_t v18 = *(int8x16_t *)(v17 + 16);
      *(int8x8_t *)v19.i8 = vqtbl1_s8(v15, *(int8x8_t *)v17);
      int8x8_t v20 = (int8x8_t)vextq_s8(*(int8x16_t *)v17, *(int8x16_t *)v17, 8uLL).u64[0];
      v19.u64[1] = (unint64_t)vqtbl1_s8(v15, v20);
      *(int8x8_t *)v15.i8 = vqtbl1_s8(v16, *(int8x8_t *)v17);
      v15.u64[1] = (unint64_t)vqtbl1_s8(v16, v20);
      *(int8x8_t *)v16.i8 = vqtbl1_s8(*v14, *(int8x8_t *)v17);
      v16.u64[1] = (unint64_t)vqtbl1_s8(*v14, v20);
      int8x16_t v21 = v14[2];
      *(int8x8_t *)v22.i8 = vqtbl1_s8(v21, *(int8x8_t *)v17);
      v22.u64[1] = (unint64_t)vqtbl1_s8(v21, v20);
      int8x16_t v23 = vbslq_s8(v18, vextq_s8(v14[-1], v14[-1], 4uLL), v15);
      int8x16_t v24 = vbslq_s8(v18, vextq_s8(v14[1], v14[1], 4uLL), v16);
      int8x16_t v25 = vbslq_s8(v18, vextq_s8(v14[3], v14[3], 4uLL), v22);
      v13[-2] = vbslq_s8(v18, vextq_s8(v14[-3], v14[-3], 4uLL), v19);
      v13[-1] = v23;
      *unint64_t v13 = v24;
      v13[1] = v25;
      v13 += 4;
      v14 += 8;
      v12 -= 4;
    }
    while (v5 + v12 > 3);
    LODWORD(v26) = -v12;
    if (-v12 >= v5) {
      goto LABEL_3;
    }
LABEL_10:
    unsigned int v27 = 2 * v26;
    uint64_t v26 = v26;
    do
    {
      int8x16_t v28 = *(int8x16_t *)(v7 + 16 * v27);
      uint64_t v29 = *((void *)this + 51);
      *(int8x8_t *)v30.i8 = vqtbl1_s8(v28, *(int8x8_t *)v29);
      int8x16_t v31 = *(int8x16_t *)(v7 + 16 * (v27 + 1));
      v30.u64[1] = (unint64_t)vqtbl1_s8(v28, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v29, *(int8x16_t *)v29, 8uLL));
      v6[v26++] = vbslq_s8(*(int8x16_t *)(v29 + 16), vextq_s8(v31, v31, 4uLL), v30);
      v27 += 2;
    }
    while (v26 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::GetDOD(HgcColorGamma_2vuy_yxzx_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0, 0, 0xFFFFFFFF, 0);
  int v8 = HGRectGrow(v6, v5, v7);
  float v9 = HGRectFloat(v8);
  float v13 = HGRectScale(v9, v10, v11, v12, 0.5);
  uint64_t v18 = HGRectIntegral(v14, v13, v15, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::GetROI(HgcColorGamma_2vuy_yxzx_collapse *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v5 = HGRectFloat(a4.var0);
  float v9 = HGRectScale(v5, v6, v7, v8, 2.0);
  uint64_t v14 = HGRectIntegral(v10, v9, v11, v12, v13);
  uint64_t v16 = v15;
  uint64_t v17 = HGRectMake4i(0, 0, 1u, 0);
  uint64_t v18 = HGRectGrow(v14, v16, v17);
  return HGRectUnion(0, 0, v18, v19);
}

void HgcColorGamma_2vuy_yxzx_collapse::HgcColorGamma_2vuy_yxzx_collapse(HgcColorGamma_2vuy_yxzx_collapse *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F6F18;
  operator new();
}

void sub_1B79365B4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_2vuy_yxzx_collapse::~HgcColorGamma_2vuy_yxzx_collapse(HGNode *this)
{
  *(void *)this = &unk_1F10F6F18;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F6F18;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F6F18;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::SetParameter(HgcColorGamma_2vuy_yxzx_collapse *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcColorGamma_2vuy_yxzx_collapse::GetParameter(HgcColorGamma_2vuy_yxzx_collapse *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcPremultiplyWhiteToBlack::GetProgram(HgcPremultiplyWhiteToBlack *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002fa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.www - c0.xxx;\n"
             "    r0.xyz = r0.xyz + r1.xyz;\n"
             "    r1.xyz = half3(r0.xyz > c0.yyy);\n"
             "    r0.xyz = r0.xyz*r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6dd76864:48849d5a:13d5e8a8:54ff4049\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.www - c0.xxx;\n"
             "    r0.xyz = r0.xyz + r1.xyz;\n"
             "    r1.xyz = float3(r0.xyz > c0.yyy);\n"
             "    r0.xyz = r0.xyz*r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f31f1670:3fae15ce:30947a54:39732594\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002a0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.www - c0.xxx;\n"
           "    r0.xyz = r0.xyz + r1.xyz;\n"
           "    r1.xyz = vec3(greaterThan(r0.xyz, c0.yyy));\n"
           "    r0.xyz = r0.xyz*r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f5fa399d:5bc239fe:c2d365db:a86b532a\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPremultiplyWhiteToBlack::InitProgramDescriptor(HgcPremultiplyWhiteToBlack *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPremultiplyWhiteToBlack_hgc_visible", "//Metal1.0     \n//LEN=00000001d3\n[[ visible ]] FragmentOut HgcPremultiplyWhiteToBlack_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.www - c0.xxx;\n"
    "    r0.xyz = r0.xyz + r1.xyz;\n"
    "    r1.xyz = float3(r0.xyz > c0.yyy);\n"
    "    r0.xyz = r0.xyz*r1.xyz;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcPremultiplyWhiteToBlack");
}

void sub_1B79369F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7936A28(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7936A20);
}

char *HgcPremultiplyWhiteToBlack::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376030;
  strcpy(result, "HgcPremultiplyWhiteToBlack [hgc1]");
  return result;
}

uint64_t HgcPremultiplyWhiteToBlack::BindTexture(HgcPremultiplyWhiteToBlack *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPremultiplyWhiteToBlack::Bind(HgcPremultiplyWhiteToBlack *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcPremultiplyWhiteToBlack::RenderTile(HgcPremultiplyWhiteToBlack *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    uint64_t v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v39 = 0;
        uint64_t v40 = 16 * v7;
        uint64_t v41 = 16 * v6;
        uint64_t v42 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v43 = 0;
          do
          {
            float32x4_t v44 = v4[v43 / 0x10];
            uint64_t v45 = *((void *)this + 51);
            int8x16_t v46 = *(int8x16_t *)(v45 + 16);
            float32x4_t v47 = (float32x4_t)vbslq_s8(v46, (int8x16_t)v44, (int8x16_t)vaddq_f32(v44, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 3), *(float32x4_t *)v45)));
            v5[v43 / 0x10] = vbslq_s8(v46, (int8x16_t)v44, (int8x16_t)vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)v45, (int8x16_t)vcgtq_f32(v47, *(float32x4_t *)(v45 + 32))), v47));
            v43 += 16;
          }
          while (v42 != v43);
          ++v39;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v40);
          int v5 = (int8x16_t *)((char *)v5 + v41);
        }
        while (v39 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float v11 = v4 + 4;
      float v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        uint64_t v14 = v12;
        uint64_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          uint64_t v17 = v15;
          uint64_t v18 = v14;
          float32x4_t v19 = v4[v16 - 2];
          float32x4_t v20 = v4[v16 - 1];
          float32x4_t v21 = v4[v16];
          float32x4_t v22 = v4[v16 + 1];
          uint64_t v23 = *((void *)this + 51);
          int8x16_t v24 = *(int8x16_t *)(v23 + 16);
          float32x4_t v25 = (float32x4_t)vbslq_s8(v24, (int8x16_t)v19, (int8x16_t)vaddq_f32(v19, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), *(float32x4_t *)v23)));
          float32x4_t v26 = (float32x4_t)vbslq_s8(v24, (int8x16_t)v20, (int8x16_t)vaddq_f32(v20, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), *(float32x4_t *)v23)));
          float32x4_t v27 = (float32x4_t)vbslq_s8(v24, (int8x16_t)v21, (int8x16_t)vaddq_f32(v21, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 3), *(float32x4_t *)v23)));
          float32x4_t v28 = (float32x4_t)vbslq_s8(v24, (int8x16_t)v22, (int8x16_t)vaddq_f32(v22, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 3), *(float32x4_t *)v23)));
          float32x4_t v29 = *(float32x4_t *)(v23 + 32);
          int8x16_t v30 = vbslq_s8(v24, (int8x16_t)v19, (int8x16_t)vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)v23, (int8x16_t)vcgtq_f32(v25, v29)), v25));
          int8x16_t v31 = vbslq_s8(v24, (int8x16_t)v20, (int8x16_t)vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)v23, (int8x16_t)vcgtq_f32(v26, v29)), v26));
          int8x16_t v32 = vbslq_s8(v24, (int8x16_t)v21, (int8x16_t)vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)v23, (int8x16_t)vcgtq_f32(v27, v29)), v27));
          int8x16_t v33 = vbslq_s8(v24, (int8x16_t)v22, (int8x16_t)vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)v23, (int8x16_t)vcgtq_f32(v28, v29)), v28));
          float32x4_t v34 = &v5[v16];
          v34[-2] = v30;
          v34[-1] = v31;
          v13 += 4;
          *float32x4_t v34 = v32;
          v34[1] = v33;
          v16 += 4;
          v15 += 4;
          uint64_t v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            float32x4_t v35 = *v17++;
            uint64_t v36 = *((void *)this + 51);
            int8x16_t v37 = *(int8x16_t *)(v36 + 16);
            float32x4_t v38 = (float32x4_t)vbslq_s8(v37, (int8x16_t)v35, (int8x16_t)vaddq_f32(v35, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 3), *(float32x4_t *)v36)));
            *v18++ = vbslq_s8(v37, (int8x16_t)v35, (int8x16_t)vmulq_f32((float32x4_t)vandq_s8(*(int8x16_t *)v36, (int8x16_t)vcgtq_f32(v38, *(float32x4_t *)(v36 + 32))), v38));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (int8x16_t *)((char *)v5 + v9);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v10);
        float v11 = (float32x4_t *)((char *)v11 + v10);
        float v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPremultiplyWhiteToBlack::GetDOD(HgcPremultiplyWhiteToBlack *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcPremultiplyWhiteToBlack::GetROI(HgcPremultiplyWhiteToBlack *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcPremultiplyWhiteToBlack::HgcPremultiplyWhiteToBlack(HgcPremultiplyWhiteToBlack *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F7180;
  operator new();
}

void sub_1B7936EAC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPremultiplyWhiteToBlack::~HgcPremultiplyWhiteToBlack(HGNode *this)
{
  *(void *)this = &unk_1F10F7180;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40EED21634);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F7180;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40EED21634);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcPremultiplyWhiteToBlack::SetParameter(HgcPremultiplyWhiteToBlack *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPremultiplyWhiteToBlack::GetParameter(HgcPremultiplyWhiteToBlack *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcApply3DLUTTetrahedralUniform_basekernel::GetProgram(HgcApply3DLUTTetrahedralUniform_basekernel *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return aMetal10Len0000_1241;
    }
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000e89\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = hg_Params[1].yyy - c0.xxx;\n"
             "    r1.xyz = r1.xyz*r2.xyz;\n"
             "    r1.xyz = fmax(r1.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
             "    r3.xyz = fract(r1.xyz);\n"
             "    r1.xyz = floor(r1.xyz);\n"
             "    r4.xyz = r1.xyz + c0.xxx;\n"
             "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
             "    r4.xyz = r4.xyz - r1.xyz;\n"
             "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
             "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
             "    r2.y = r1.z;\n"
             "    r2.xy = r2.xy + c0.zz;\n"
             "    r1.xy = r2.xy + hg_Params[3].xy;\n"
             "    r1.xy = r1.xy*hg_Params[3].zw;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r5.xy = r2.xy + hg_Params[3].xy;\n"
             "    r5.xy = r5.xy*hg_Params[3].zw;\n"
             "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r6.xy = r2.xy + hg_Params[3].xy;\n"
             "    r6.xy = r6.xy*hg_Params[3].zw;\n"
             "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
             "    r2.x = r2.x - r4.x;\n"
             "    r7.xy = r2.xy + hg_Params[3].xy;\n"
             "    r7.xy = r7.xy*hg_Params[3].zw;\n"
             "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
             "    r2.y = r2.y + r4.z;\n"
             "    r8.xy = r2.xy + hg_Params[3].xy;\n"
             "    r8.xy = r8.xy*hg_Params[3].zw;\n"
             "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
             "    r2.x = r2.x - r4.y;\n"
             "    r9.xy = r2.xy + hg_Params[3].xy;\n"
             "    r9.xy = r9.xy*hg_Params[3].zw;\n"
             "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
             "    r2.x = r2.x + r4.x;\n"
             "    r10.xy = r2.xy + hg_Params[3].xy;\n"
             "    r10.xy = r10.xy*hg_Params[3].zw;\n"
             "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
             "    r2.x = r2.x + r4.y;\n"
             "    r2.xy = r2.xy + hg_Params[3].xy;\n"
             "    r2.xy = r2.xy*hg_Params[3].zw;\n"
             "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
             "    r4 = float4(r3.xzzy > r3.yxyz);\n"
             "    r11.x = float(r3.y > r3.x);\n"
             "    r12 = float4(r3.yxxz >= r3.xyzy);\n"
             "    r13 = r2 - r8;\n"
             "    r14 = r7 - r1;\n"
             "    r15 = r8 - r7;\n"
             "    r16 = r13*r3.xxxx;\n"
             "    r16 = r14*r3.yyyy + r16;\n"
             "    r15 = r15*r3.zzzz + r16;\n"
             "    r16 = r10 - r9;\n"
             "    r17 = r2 - r10;\n"
             "    r18 = r9 - r1;\n"
             "    r16 = r16*r3.xxxx;\n"
             "    r16 = r17*r3.yyyy + r16;\n"
             "    r16 = r18*r3.zzzz + r16;\n"
             "    r19 = fmin(r4.xxxx, r4.yyyy);\n"
             "    r15 = select(r15, r16, r19 > 0.00000f);\n"
             "    r8 = r8 - r9;\n"
             "    r13 = r13*r3.xxxx;\n"
             "    r13 = r8*r3.yyyy + r13;\n"
             "    r13 = r18*r3.zzzz + r13;\n"
             "    r19 = fmin(r12.xxxx, r4.zzzz);\n"
             "    r15 = select(r15, r13, r19 > 0.00000f);\n"
             "    r16 = r5 - r1;\n"
             "    r9 = r6 - r5;\n"
             "    r2 = r2 - r6;\n"
             "    r8 = r16*r3.xxxx;\n"
             "    r8 = r9*r3.yyyy + r8;\n"
             "    r8 = r2*r3.zzzz + r8;\n"
             "    r4 = fmin(r4.wwww, r12.yyyy);\n"
             "    r15 = select(r15, r8, r4 > 0.00000f);\n"
             "    r6 = r6 - r7;\n"
             "    r6 = r6*r3.xxxx;\n"
             "    r6 = r14*r3.yyyy + r6;\n"
             "    r6 = r2*r3.zzzz + r6;\n"
             "    r11 = fmin(r12.zzzz, r11.xxxx);\n"
             "    r15 = select(r15, r6, r11 > 0.00000f);\n"
             "    r10 = r10 - r5;\n"
             "    r16 = r16*r3.xxxx;\n"
             "    r16 = r17*r3.yyyy + r16;\n"
             "    r16 = r10*r3.zzzz + r16;\n"
             "    r12 = fmin(r12.wwww, r12.zzzz);\n"
             "    r12 = select(r15, r16, r12 > 0.00000f);\n"
             "    r12 = r12 + r1;\n"
             "    r12 = r12*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
             "    output.color0 = select(r12, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a220cc55:c2718b3d:efb1f626:1df26c2c\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0014:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_462;
  }
}

void HgcApply3DLUTTetrahedralUniform_basekernel::InitProgramDescriptor(HgcApply3DLUTTetrahedralUniform_basekernel *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcApply3DLUTTetrahedralUniform_basekernel_hgc_visible", "//Metal1.0     \n//LEN=0000000d5b\n[[ visible ]] FragmentOut HgcApply3DLUTTetrahedralUniform_basekernel_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.5000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = hg_Params[1].yyy - c0.xxx;\n"
    "    r1.xyz = r1.xyz*r2.xyz;\n"
    "    r1.xyz = fmax(r1.xyz, c0.yyy);\n"
    "    r1.xyz = fmin(r1.xyz, r2.xyz);\n"
    "    r3.xyz = fract(r1.xyz);\n"
    "    r1.xyz = floor(r1.xyz);\n"
    "    r4.xyz = r1.xyz + c0.xxx;\n"
    "    r4.xyz = fmin(r4.xyz, r2.xyz);\n"
    "    r4.xyz = r4.xyz - r1.xyz;\n"
    "    r4.xyz = r4.xyz*hg_Params[1].xyz;\n"
    "    r2.x = dot(r1.xy, hg_Params[1].xy);\n"
    "    r2.y = r1.z;\n"
    "    r2.xy = r2.xy + c0.zz;\n"
    "    r1.xy = r2.xy + hg_Params[3].xy;\n"
    "    r1.xy = r1.xy*hg_Params[3].zw;\n"
    "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r5.xy = r2.xy + hg_Params[3].xy;\n"
    "    r5.xy = r5.xy*hg_Params[3].zw;\n"
    "    r5 = hg_Texture1.sample(hg_Sampler1, r5.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r6.xy = r2.xy + hg_Params[3].xy;\n"
    "    r6.xy = r6.xy*hg_Params[3].zw;\n"
    "    r6 = hg_Texture1.sample(hg_Sampler1, r6.xy);\n"
    "    r2.x = r2.x - r4.x;\n"
    "    r7.xy = r2.xy + hg_Params[3].xy;\n"
    "    r7.xy = r7.xy*hg_Params[3].zw;\n"
    "    r7 = hg_Texture1.sample(hg_Sampler1, r7.xy);\n"
    "    r2.y = r2.y + r4.z;\n"
    "    r8.xy = r2.xy + hg_Params[3].xy;\n"
    "    r8.xy = r8.xy*hg_Params[3].zw;\n"
    "    r8 = hg_Texture1.sample(hg_Sampler1, r8.xy);\n"
    "    r2.x = r2.x - r4.y;\n"
    "    r9.xy = r2.xy + hg_Params[3].xy;\n"
    "    r9.xy = r9.xy*hg_Params[3].zw;\n"
    "    r9 = hg_Texture1.sample(hg_Sampler1, r9.xy);\n"
    "    r2.x = r2.x + r4.x;\n"
    "    r10.xy = r2.xy + hg_Params[3].xy;\n"
    "    r10.xy = r10.xy*hg_Params[3].zw;\n"
    "    r10 = hg_Texture1.sample(hg_Sampler1, r10.xy);\n"
    "    r2.x = r2.x + r4.y;\n"
    "    r2.xy = r2.xy + hg_Params[3].xy;\n"
    "    r2.xy = r2.xy*hg_Params[3].zw;\n"
    "    r2 = hg_Texture1.sample(hg_Sampler1, r2.xy);\n"
    "    r4 = float4(r3.xzzy > r3.yxyz);\n"
    "    r11.x = float(r3.y > r3.x);\n"
    "    r12 = float4(r3.yxxz >= r3.xyzy);\n"
    "    r13 = r2 - r8;\n"
    "    r14 = r7 - r1;\n"
    "    r15 = r8 - r7;\n"
    "    r16 = r13*r3.xxxx;\n"
    "    r16 = r14*r3.yyyy + r16;\n"
    "    r15 = r15*r3.zzzz + r16;\n"
    "    r16 = r10 - r9;\n"
    "    r17 = r2 - r10;\n"
    "    r18 = r9 - r1;\n"
    "    r16 = r16*r3.xxxx;\n"
    "    r16 = r17*r3.yyyy + r16;\n"
    "    r16 = r18*r3.zzzz + r16;\n"
    "    r19 = fmin(r4.xxxx, r4.yyyy);\n"
    "    r15 = select(r15, r16, r19 > 0.00000f);\n"
    "    r8 = r8 - r9;\n"
    "    r13 = r13*r3.xxxx;\n"
    "    r13 = r8*r3.yyyy + r13;\n"
    "    r13 = r18*r3.zzzz + r13;\n"
    "    r19 = fmin(r12.xxxx, r4.zzzz);\n"
    "    r15 = select(r15, r13, r19 > 0.00000f);\n"
    "    r16 = r5 - r1;\n"
    "    r9 = r6 - r5;\n"
    "    r2 = r2 - r6;\n"
    "    r8 = r16*r3.xxxx;\n"
    "    r8 = r9*r3.yyyy + r8;\n"
    "    r8 = r2*r3.zzzz + r8;\n"
    "    r4 = fmin(r4.wwww, r12.yyyy);\n"
    "    r15 = select(r15, r8, r4 > 0.00000f);\n"
    "    r6 = r6 - r7;\n"
    "    r6 = r6*r3.xxxx;\n"
    "    r6 = r14*r3.yyyy + r6;\n"
    "    r6 = r2*r3.zzzz + r6;\n"
    "    r11 = fmin(r12.zzzz, r11.xxxx);\n"
    "    r15 = select(r15, r6, r11 > 0.00000f);\n"
    "    r10 = r10 - r5;\n"
    "    r16 = r16*r3.xxxx;\n"
    "    r16 = r17*r3.yyyy + r16;\n"
    "    r16 = r10*r3.zzzz + r16;\n"
    "    r12 = fmin(r12.wwww, r12.zzzz);\n"
    "    r12 = select(r15, r16, r12 > 0.00000f);\n"
    "    r12 = r12 + r1;\n"
    "    r12 = r12*hg_Params[0].zzzz + hg_Params[0].wwww;\n"
    "    output.color0 = select(r12, r0, hg_Params[2] < 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcApply3DLUTTetrahedralUniform_basekernel");
}

void sub_1B79373B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B79373EC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79373E4);
}

double HgcApply3DLUTTetrahedralUniform_basekernel::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x38uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B83775A0;
  strcpy(v3, "HgcApply3DLUTTetrahedralUniform_basekernel [hgc1]");
  return *(double *)"basekernel [hgc1]";
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::BindTexture(HgcApply3DLUTTetrahedralUniform_basekernel *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 3, v6, v7, v8, v9);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v4 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::Bind(HgcApply3DLUTTetrahedralUniform_basekernel *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::RenderTile(HgcApply3DLUTTetrahedralUniform_basekernel *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = a2[1].i32[0] - v2.i32[0];
    if (v4 >= 1)
    {
      int v5 = 0;
      *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
      v6.i64[1] = 0x3F80000000000000;
      int32x2_t v7 = a2[10];
      int32x2_t v8 = a2[2];
      uint64_t v9 = 16 * a2[11].i32[0];
      uint64_t v10 = 16 * a2[3].i32[0];
      uint64_t v11 = 16 * v4;
      v12.i64[0] = 0x3F0000003F000000;
      v12.i64[1] = 0x3F0000003F000000;
      do
      {
        uint64_t v13 = 0;
        do
        {
          uint64_t v14 = (_OWORD *)*((void *)this + 51);
          float32x4_t v15 = *(float32x4_t *)(*(void *)&v7 + v13);
          float32x4_t v16 = *((float32x4_t *)v14 + 1);
          float32x4_t v17 = *((float32x4_t *)v14 + 3);
          float32x4_t v18 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1), v17);
          float32x4_t v19 = *((float32x4_t *)v14 + 4);
          int8x16_t v20 = *((int8x16_t *)v14 + 5);
          float32x4_t v21 = vminq_f32(vmaxq_f32(vmulq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14, 1), vmulq_n_f32(v15, COERCE_FLOAT(*v14))), v18), v19), v18);
          float32x4_t v22 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
          float32x4_t v23 = vsubq_f32(v22, (float32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v22, v21)));
          float32x4_t v24 = vmulq_f32(v16, v23);
          float32x4_t v25 = vmulq_f32(v16, vsubq_f32(vminq_f32(vaddq_f32(v17, v23), v18), v23));
          int8x16_t v26 = *((int8x16_t *)v14 + 7);
          float32x4_t v27 = vaddq_f32(*((float32x4_t *)v14 + 6), (float32x4_t)vbslq_s8(v20, (int8x16_t)vaddq_f32(v24, (float32x4_t)vrev64q_s32((int32x4_t)v24)), vextq_s8((int8x16_t)v23, (int8x16_t)v23, 4uLL)));
          int32x2_t v28 = a2[12];
          __int32 v29 = a2[13].i32[0];
          float32x4_t v30 = vsubq_f32(v21, v23);
          float32x4_t v31 = vaddq_f32(vsubq_f32(v27, v6), v12);
          int32x4_t v32 = vcvtq_s32_f32(v31);
          v31.i64[0] = vaddq_s32(v32, vcgtq_f32(vcvtq_f32_s32(v32), v31)).u64[0];
          __int32 v33 = v31.i32[1];
          float32x4_t v34 = (float32x4_t)vbslq_s8(v20, (int8x16_t)vaddq_f32(v25, v27), (int8x16_t)v27);
          __int32 v35 = v31.i32[0];
          float32x4_t v36 = vaddq_f32(vsubq_f32(v34, v6), v12);
          int32x4_t v37 = vcvtq_s32_f32(v36);
          v36.i64[0] = vaddq_s32(v37, vcgtq_f32(vcvtq_f32_s32(v37), v36)).u64[0];
          __int32 v38 = v35 + v33 * v29;
          __int32 v39 = v36.i32[1];
          __int32 v40 = v36.i32[0];
          float32x4_t v41 = (float32x4_t)vrev64q_s32((int32x4_t)v25);
          float32x4_t v42 = *(float32x4_t *)(*(void *)&v28 + 16 * v38);
          float32x4_t v43 = (float32x4_t)vbslq_s8(v20, (int8x16_t)vaddq_f32(v41, v34), (int8x16_t)v27);
          float32x4_t v44 = vaddq_f32(vsubq_f32(v43, v6), v12);
          int32x4_t v45 = vcvtq_s32_f32(v44);
          __int32 v46 = v40 + v39 * v29;
          v44.i64[0] = vaddq_s32(v45, vcgtq_f32(vcvtq_f32_s32(v45), v44)).u64[0];
          __int32 v47 = v44.i32[1];
          __int32 v48 = v44.i32[0];
          int8x16_t v49 = (int8x16_t)vsubq_f32(v43, v25);
          float32x4_t v50 = (float32x4_t)vbslq_s8(v20, v49, (int8x16_t)v27);
          float32x4_t v51 = vaddq_f32(vsubq_f32(v50, v6), v12);
          float32x4_t v52 = *(float32x4_t *)(*(void *)&v28 + 16 * v46);
          int32x4_t v53 = vcvtq_s32_f32(v51);
          v51.i64[0] = vaddq_s32(v53, vcgtq_f32(vcvtq_f32_s32(v53), v51)).u64[0];
          __int32 v54 = v51.i32[1];
          __int32 v55 = v48 + v47 * v29;
          __int32 v56 = v51.i32[0];
          int8x16_t v57 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 4uLL), v50);
          float32x4_t v58 = *(float32x4_t *)(*(void *)&v28 + 16 * v55);
          float32x4_t v59 = (float32x4_t)vbslq_s8(v20, v49, v57);
          float32x4_t v60 = vaddq_f32(vsubq_f32(v59, v6), v12);
          int32x4_t v61 = vcvtq_s32_f32(v60);
          v60.i64[0] = vaddq_s32(v61, vcgtq_f32(vcvtq_f32_s32(v61), v60)).u64[0];
          __int32 v62 = v60.i32[1];
          float32x4_t v63 = *(float32x4_t *)(*(void *)&v28 + 16 * (v56 + v54 * v29));
          __int32 v64 = v60.i32[0];
          float32x4_t v65 = (float32x4_t)vbslq_s8(v20, (int8x16_t)vsubq_f32(v59, v41), v57);
          float32x4_t v66 = vaddq_f32(vsubq_f32(v65, v6), v12);
          __int32 v67 = v64 + v62 * v29;
          int32x4_t v68 = vcvtq_s32_f32(v66);
          v66.i64[0] = vaddq_s32(v68, vcgtq_f32(vcvtq_f32_s32(v68), v66)).u64[0];
          __int32 v69 = v66.i32[1];
          __int32 v70 = v66.i32[0];
          float32x4_t v71 = (float32x4_t)vbslq_s8(v20, (int8x16_t)vaddq_f32(v25, v65), v57);
          float32x4_t v72 = *(float32x4_t *)(*(void *)&v28 + 16 * v67);
          float32x4_t v73 = vaddq_f32(vsubq_f32(v71, v6), v12);
          float32x4_t v74 = (float32x4_t)vcvtq_s32_f32(v73);
          v73.i64[0] = vaddq_s32((int32x4_t)v74, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v74), v73)).u64[0];
          float32x4_t v75 = vaddq_f32(vsubq_f32((float32x4_t)vbslq_s8(v20, (int8x16_t)vaddq_f32(v41, v71), v57), v6), v12);
          int32x4_t v76 = vcvtq_s32_f32(v75);
          float32x4_t v77 = *(float32x4_t *)(*(void *)&v28 + 16 * (v70 + v69 * v29));
          *(int8x8_t *)v71.f32 = vqtbl1_s8((int8x16_t)v30, *(int8x8_t *)v26.i8);
          *(int8x8_t *)&v71.u32[2] = vqtbl1_s8((int8x16_t)v30, (int8x8_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
          __int32 v78 = v73.i32[0] + v73.i32[1] * v29;
          v75.i64[0] = vaddq_s32(v76, vcgtq_f32(vcvtq_f32_s32(v76), v75)).u64[0];
          int8x16_t v79 = *((int8x16_t *)v14 + 8);
          int8x16_t v80 = *((int8x16_t *)v14 + 9);
          *(int8x8_t *)v73.f32 = vqtbl1_s8((int8x16_t)v30, *(int8x8_t *)v79.i8);
          __int32 v81 = v75.i32[1];
          *(int8x8_t *)&v73.u32[2] = vqtbl1_s8((int8x16_t)v30, (int8x8_t)*(_OWORD *)&vextq_s8(v79, v79, 8uLL));
          __int32 v82 = v75.i32[0];
          int32x4_t v83 = (int32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32(v73, v71));
          v79.i64[0] = vandq_s8((int8x16_t)v17, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32((int32x4_t)v30), v30)).u64[0];
          float32x4_t v84 = *(float32x4_t *)(*(void *)&v28 + 16 * v78);
          *(int8x8_t *)v73.f32 = vqtbl1_s8((int8x16_t)v30, *(int8x8_t *)v80.i8);
          *(int8x8_t *)&v73.u32[2] = vqtbl1_s8((int8x16_t)v30, (int8x8_t)*(_OWORD *)&vextq_s8(v80, v80, 8uLL));
          int8x16_t v85 = *((int8x16_t *)v14 + 10);
          *(int8x8_t *)v74.f32 = vqtbl1_s8((int8x16_t)v30, *(int8x8_t *)v85.i8);
          float32x4_t v86 = *(float32x4_t *)(*(void *)&v28 + 16 * (v82 + v81 * v29));
          *(int8x8_t *)&v74.u32[2] = vqtbl1_s8((int8x16_t)v30, (int8x8_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL));
          int32x4_t v87 = (int32x4_t)vandq_s8((int8x16_t)v17, (int8x16_t)vcgeq_f32(v74, v73));
          float32x4_t v88 = vmulq_lane_f32(vsubq_f32(v63, v42), *(float32x2_t *)v30.f32, 1);
          float32x4_t v89 = vmulq_n_f32(vsubq_f32(v86, v72), v30.f32[0]);
          float32x4_t v90 = vmulq_n_f32(vsubq_f32(v84, v77), v30.f32[0]);
          float32x4_t v91 = vmulq_laneq_f32(vsubq_f32(v77, v42), v30, 2);
          float32x4_t v92 = vmulq_lane_f32(vsubq_f32(v86, v84), *(float32x2_t *)v30.f32, 1);
          float32x4_t v93 = vmulq_lane_f32(vsubq_f32(v72, v77), *(float32x2_t *)v30.f32, 1);
          int8x16_t v94 = (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v72, v63), v30, 2), vaddq_f32(v88, v89));
          float32x4_t v95 = vmulq_n_f32(vsubq_f32(v52, v42), v30.f32[0]);
          float32x4_t v96 = vaddq_f32(v95, vmulq_lane_f32(vsubq_f32(v58, v52), *(float32x2_t *)v30.f32, 1));
          float32x4_t v97 = vmulq_laneq_f32(vsubq_f32(v86, v58), v30, 2);
          float32x4_t v98 = vaddq_f32(vmulq_n_f32(vsubq_f32(v58, v63), v30.f32[0]), v88);
          int8x16_t v99 = vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v83.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v83.i8, 1)), v19), (int8x16_t)vaddq_f32(v91, vaddq_f32(v90, v92)), v94);
          float32x4_t v100 = (float32x4_t)vdupq_laneq_s32(v87, 2);
          *(int8x16_t *)(*(void *)&v8 + v13) = vbslq_s8((int8x16_t)vcgtq_f32(v19, *((float32x4_t *)v14 + 2)), (int8x16_t)v15, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v14, 3), vmulq_laneq_f32(vaddq_f32(v42, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v87, 3), v100), v19), (int8x16_t)vaddq_f32(vmulq_laneq_f32(vsubq_f32(v84, v52), v30, 2), vaddq_f32(v95, v92)),
                                                                                   vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32(v100, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v79.i8, 0)), v19), (int8x16_t)vaddq_f32(v98, v97), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_laneq_s32(v83, 3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v87.i8, 1)), v19), (int8x16_t)vaddq_f32(v96, v97), vbslq_s8((int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v87.i8, 0), (float32x4_t)vdupq_laneq_s32(v83, 2)), v19), (int8x16_t)vaddq_f32(v91, vaddq_f32(v93, v89)), v99))))), *(float32x4_t *)v14, 2)));
          v13 += 16;
        }
        while (v11 != v13);
        ++v5;
        *(void *)&v7 += v9;
        *(void *)&v8 += v10;
      }
      while (v5 != v3);
    }
  }
  return 0;
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::GetDOD(HgcApply3DLUTTetrahedralUniform_basekernel *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1) {
    return 0x8000000080000000;
  }
  if (a3) {
    return 0;
  }
  return *(void *)&a4.var0;
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, 1u);
    return HGRenderer::GetDOD(a2, Input);
  }
  else if (a3)
  {
    return 0;
  }
  else
  {
    return *(void *)&a4.var0;
  }
}

void HgcApply3DLUTTetrahedralUniform_basekernel::HgcApply3DLUTTetrahedralUniform_basekernel(HgcApply3DLUTTetrahedralUniform_basekernel *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F73E8;
  operator new();
}

void sub_1B7937D48(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTetrahedralUniform_basekernel::~HgcApply3DLUTTetrahedralUniform_basekernel(HGNode *this)
{
  *(void *)this = &unk_1F10F73E8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40C3A7E6FCLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F73E8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40C3A7E6FCLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F73E8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40C3A7E6FCLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::SetParameter(HgcApply3DLUTTetrahedralUniform_basekernel *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int32x2_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int32x2_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcApply3DLUTTetrahedralUniform_basekernel::GetParameter(HgcApply3DLUTTetrahedralUniform_basekernel *this, unsigned int a2, float *a3)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcToneParamCurve3::GetProgram(HgcToneParamCurve3 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000369\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = half3(hg_Params[1].xyz)*r0.xyz + half3(hg_Params[2].xyz);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xyz));\n"
             "    r2.xyz = r0.xyz - half3(hg_Params[4].xyz);\n"
             "    r3.xyz = r0.xyz*half3(hg_Params[3].xyz);\n"
             "    output.color0.xyz = select(float3(r1.xyz), float3(r3.xyz), float3(r2.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a08c8d94:38f96d5c:26c0e933:55620f24\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0005:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000321\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
             "    r2.xyz = r0.xyz - hg_Params[4].xyz;\n"
             "    r3.xyz = r0.xyz*hg_Params[3].xyz;\n"
             "    output.color0.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=41552887:797b0b83:44ffd324:adfe9f8c\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0005:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003cd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "uniform mediump vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = hg_ProgramLocal1.xyz*r0.xyz + hg_ProgramLocal2.xyz;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xyz);\n"
           "    r2.xyz = r0.xyz - hg_ProgramLocal4.xyz;\n"
           "    r3.xyz = r0.xyz*hg_ProgramLocal3.xyz;\n"
           "    gl_FragColor.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z"
           " : r1.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=1974bb9c:fd223adc:1fc4ae62:4edb9b94\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0005:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcToneParamCurve3::InitProgramDescriptor(HgcToneParamCurve3 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcToneParamCurve3_hgc_visible", "//Metal1.0     \n//LEN=00000001fd\n[[ visible ]] FragmentOut HgcToneParamCurve3_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = hg_Params[1].xyz*r0.xyz + hg_Params[2].xyz;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[0].xyz);\n"
    "    r2.xyz = r0.xyz - hg_Params[4].xyz;\n"
    "    r3.xyz = r0.xyz*hg_Params[3].xyz;\n"
    "    output.color0.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcToneParamCurve3");
}

void sub_1B7938254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7938284(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B793827CLL);
}

double HgcToneParamCurve3::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcToneParamCurve3 [hgc1]");
  return *(double *)"ramCurve3 [hgc1]";
}

uint64_t HgcToneParamCurve3::BindTexture(HgcToneParamCurve3 *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcToneParamCurve3::Bind(HgcToneParamCurve3 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcToneParamCurve3::RenderTile(HgcToneParamCurve3 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v64 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v11 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = *((void *)this + 51);
      float32x4_t v14 = *(float32x4_t *)(v13 + 16);
      float32x4_t v15 = *(float32x4_t *)(v13 + 32);
      float32x4_t v16 = *(float32x4_t *)(v13 + 48);
      float32x4_t v17 = vaddq_f32(v15, vmulq_f32(v12, v14));
      float32x4_t v18 = vaddq_f32(v15, vmulq_f32(v11, v14));
      float32x4_t v20 = *(float32x4_t *)(v13 + 64);
      int8x16_t v19 = *(int8x16_t *)(v13 + 80);
      float32x4_t v21 = *(float32x4_t *)(v13 + 96);
      float32x4_t v22 = *(float32x4_t *)(v13 + 112);
      float32x4_t v23 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v17), (int8x16_t)v21);
      int8x16_t v24 = *(int8x16_t *)(v13 + 128);
      float32x4_t v25 = *(float32x4_t *)(v13 + 144);
      float32x4_t v26 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v18), (int8x16_t)v21);
      float32x4_t v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v18)));
      float32x4_t v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v17))), v25);
      float32x4_t v29 = *(float32x4_t *)(v13 + 160);
      float32x4_t v30 = *(float32x4_t *)(v13 + 176);
      float32x4_t v31 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v23, v29));
      float32x4_t v32 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v26, v29));
      float32x4_t v33 = vaddq_f32(v28, v31);
      float32x4_t v34 = vaddq_f32(vsubq_f32(v27, v25), v32);
      float32x4_t v35 = vsubq_f32(vsubq_f32(v23, v21), vmulq_f32(vmulq_f32(v30, v31), v23));
      float32x4_t v36 = vsubq_f32(vsubq_f32(v26, v21), vmulq_f32(vmulq_f32(v30, v32), v26));
      float32x4_t v37 = *(float32x4_t *)(v13 + 192);
      float32x4_t v38 = *(float32x4_t *)(v13 + 208);
      float32x4_t v39 = vaddq_f32(v37, vmulq_f32(v38, v35));
      float32x4_t v40 = vaddq_f32(v37, vmulq_f32(v38, v36));
      float32x4_t v41 = *(float32x4_t *)(v13 + 224);
      float32x4_t v42 = *(float32x4_t *)(v13 + 240);
      float32x4_t v43 = vmulq_f32(*(float32x4_t *)v13, vaddq_f32(v34, vmulq_f32(v36, vaddq_f32(vaddq_f32(v41, vmulq_f32(v36, v42)), vmulq_f32(vmulq_f32(v36, v36), v40)))));
      float32x4_t v44 = *(float32x4_t *)(v13 + 256);
      float32x4_t v45 = *(float32x4_t *)(v13 + 272);
      float32x4_t v46 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v13, vaddq_f32(v33, vmulq_f32(v35, vaddq_f32(vaddq_f32(v41, vmulq_f32(v35, v42)), vmulq_f32(vmulq_f32(v35, v35), v39))))), v44);
      float32x4_t v47 = vmaxq_f32(v43, v44);
      float32x4_t v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      float32x4_t v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      float32x4_t v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v48, v46)));
      float32x4_t v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v49, v47)));
      float32x4_t v52 = vsubq_f32(v46, v50);
      float32x4_t v53 = vsubq_f32(v47, v51);
      float32x4_t v54 = *(float32x4_t *)(v13 + 288);
      float32x4_t v55 = *(float32x4_t *)(v13 + 304);
      float32x4_t v56 = vmulq_f32(v53, vaddq_f32(v55, vmulq_f32(v53, vaddq_f32(v45, vmulq_f32(v54, v53)))));
      float32x4_t v57 = vaddq_f32(v21, vmulq_f32(v52, vaddq_f32(v55, vmulq_f32(v52, vaddq_f32(v45, vmulq_f32(v54, v52))))));
      int32x4_t v58 = vcvtq_s32_f32(v51);
      int32x4_t v59 = *(int32x4_t *)(v13 + 320);
      float32x4_t v60 = *(float32x4_t *)(v13 + 336);
      int8x16_t v61 = (int8x16_t)vmulq_f32(v57, (float32x4_t)vshlq_n_s32(vaddq_s32(v59, vcvtq_s32_f32(v50)), 0x17uLL));
      int8x16_t v62 = *(int8x16_t *)(v13 + 352);
      float32x4_t v63 = (int8x16_t *)(v5 + v10);
      v63[-1] = vbslq_s8(v62, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32(v60, vsubq_f32(v12, v20)), (int8x16_t)vmulq_f32(v12, v16), v61));
      *float32x4_t v63 = vbslq_s8(v62, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32(v60, vsubq_f32(v11, v20)), (int8x16_t)vmulq_f32(v11, v16), (int8x16_t)vmulq_f32(vaddq_f32(v21, v56), (float32x4_t)vshlq_n_s32(vaddq_s32(v59, v58), 0x17uLL))));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v64 = -v9;
    if (v64 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v65 = 16 * v64;
    float32x4_t v66 = *(float32x4_t *)(v6 + v65);
    uint64_t v67 = *((void *)this + 51);
    float32x4_t v68 = vaddq_f32(*(float32x4_t *)(v67 + 32), vmulq_f32(v66, *(float32x4_t *)(v67 + 16)));
    float32x4_t v69 = *(float32x4_t *)(v67 + 96);
    float32x4_t v70 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v67 + 80), (int8x16_t)v68), (int8x16_t)v69);
    float32x4_t v71 = (float32x4_t)vandq_s8((int8x16_t)v69, (int8x16_t)vcgtq_f32(v70, *(float32x4_t *)(v67 + 160)));
    float32x4_t v72 = vsubq_f32(vsubq_f32(v70, v69), vmulq_f32(vmulq_f32(*(float32x4_t *)(v67 + 176), v71), v70));
    float32x4_t v73 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v67, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v67 + 128), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v67 + 112), v68))), *(float32x4_t *)(v67 + 144)), v71), vmulq_f32(v72, vaddq_f32(vaddq_f32(*(float32x4_t *)(v67 + 224), vmulq_f32(v72, *(float32x4_t *)(v67 + 240))), vmulq_f32(vmulq_f32(v72, v72), vaddq_f32(*(float32x4_t *)(v67 + 192), vmulq_f32(*(float32x4_t *)(v67 + 208), v72))))))),
            *(float32x4_t *)(v67 + 256));
    float32x4_t v74 = vcvtq_f32_s32(vcvtq_s32_f32(v73));
    float32x4_t v75 = vsubq_f32(v74, (float32x4_t)vandq_s8((int8x16_t)v69, (int8x16_t)vcgtq_f32(v74, v73)));
    float32x4_t v76 = vsubq_f32(v73, v75);
    *(int8x16_t *)(v5 + v65) = vbslq_s8(*(int8x16_t *)(v67 + 352), (int8x16_t)v66, vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(v67 + 336), vsubq_f32(v66, *(float32x4_t *)(v67 + 64))), (int8x16_t)vmulq_f32(v66, *(float32x4_t *)(v67 + 48)), (int8x16_t)vmulq_f32(vaddq_f32(v69, vmulq_f32(v76, vaddq_f32(*(float32x4_t *)(v67 + 304), vmulq_f32(v76, vaddq_f32(*(float32x4_t *)(v67 + 272), vmulq_f32(*(float32x4_t *)(v67 + 288), v76)))))),
                                                (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v67 + 320), vcvtq_s32_f32(v75)), 0x17uLL))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcToneParamCurve3::GetDOD(HgcToneParamCurve3 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcToneParamCurve3::GetROI(HgcToneParamCurve3 *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcToneParamCurve3::HgcToneParamCurve3(HgcToneParamCurve3 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F7650;
  operator new();
}

void sub_1B7938A48(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcToneParamCurve3::~HgcToneParamCurve3(HGNode *this)
{
  *(void *)this = &unk_1F10F7650;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409BD2D9E4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F7650;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409BD2D9E4);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcToneParamCurve3::SetParameter(HgcToneParamCurve3 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcToneParamCurve3::GetParameter(HgcToneParamCurve3 *this, unsigned int a2, float *a3)
{
  if (a2 > 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcPixelFormatConversion_kV4S_BE_WXYZ_input::GetProgram(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048) {
    return "//Metal1.0     \n"
  }
           "//LEN=000000032e\n"
           "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
           "    const constant float4* hg_Params [[ buffer(0) ]], \n"
           "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
           "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    const float4 c0 = float4(65535.00000, 0.003906250000, 256.0000000, 1.525902189e-05);\n"
           "    float4 r0, r1;\n"
           "    FragmentOut output;\n"
           "\n"
           "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "    r0 = r0*c0.xxxx;\n"
           "    r0 = floor(r0);\n"
           "    r0 = r0*c0.yyyy;\n"
           "    r1 = fract(r0);\n"
           "    r1 = r1*c0.zzzz;\n"
           "    r1 = floor(r1);\n"
           "    r0 = floor(r0);\n"
           "    r1 = c0.zzzz*r1 + r0;\n"
           "    output.color0 = r1.yzwx*c0.wwww;\n"
           "    return output;\n"
           "}\n"
           "//MD5=0b7535b4:5e0e2440:c1eacd8a:64887f82\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  if (Target <= 0x6060F || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)) {
    return 0;
  }
  return "//GLfs2.0      \n"
         "//LEN=00000002d3\n"
         "#ifndef GL_ES\n"
         "#define lowp\n"
         "#define mediump\n"
         "#define highp\n"
         "#endif\n"
         "#define defaultp mediump\n"
         "uniform defaultp sampler2D hg_Texture0;\n"
         "varying highp vec4 hg_TexCoord0;\n"
         "void main()\n"
         "{\n"
         "    const mediump vec4 c0 = vec4(65535.00000, 0.003906250000, 256.0000000, 1.525902189e-05);\n"
         "    mediump vec4 r0, r1;\n"
         "\n"
         "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
         "    r0 = r0*c0.xxxx;\n"
         "    r0 = floor(r0);\n"
         "    r0 = r0*c0.yyyy;\n"
         "    r1 = fract(r0);\n"
         "    r1 = r1*c0.zzzz;\n"
         "    r1 = floor(r1);\n"
         "    r0 = floor(r0);\n"
         "    r1 = c0.zzzz*r1 + r0;\n"
         "    gl_FragColor = r1.yzwx*c0.wwww;\n"
         "}\n"
         "//MD5=f4968c87:51150e17:f7500ea5:7d3e7928\n"
         "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
}

void HgcPixelFormatConversion_kV4S_BE_WXYZ_input::InitProgramDescriptor(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4S_BE_WXYZ_input_hgc_visible", "//Metal1.0     \n//LEN=0000000223\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4S_BE_WXYZ_input_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(65535.00000, 0.003906250000, 256.0000000, 1.525902189e-05);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0*c0.xxxx;\n"
    "    r0 = floor(r0);\n"
    "    r0 = r0*c0.yyyy;\n"
    "    r1 = fract(r0);\n"
    "    r1 = r1*c0.zzzz;\n"
    "    r1 = floor(r1);\n"
    "    r0 = floor(r0);\n"
    "    r1 = c0.zzzz*r1 + r0;\n"
    "    output.color0 = r1.yzwx*c0.wwww;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcPixelFormatConversion_kV4S_BE_WXYZ_input");
}

void sub_1B7938EAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7938EDC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7938ED4);
}

double HgcPixelFormatConversion_kV4S_BE_WXYZ_input::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x38uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B7EC1850;
  strcpy(v3, "HgcPixelFormatConversion_kV4S_BE_WXYZ_input [hgc1]");
  return *(double *)"_WXYZ_input [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::BindTexture(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::Bind(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::RenderTile(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v71 = 0;
        uint64_t v72 = 16 * v7;
        uint64_t v73 = 16 * v6;
        uint64_t v74 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v75 = 0;
          do
          {
            uint64_t v76 = *((void *)this + 51);
            int8x16_t v77 = *(int8x16_t *)(v76 + 16);
            float32x4_t v78 = vmulq_f32(v4[v75 / 0x10], *(float32x4_t *)v76);
            float32x4_t v79 = vcvtq_f32_s32(vcvtq_s32_f32(v78));
            float32x4_t v80 = *(float32x4_t *)(v76 + 48);
            float32x4_t v81 = vmulq_f32(*(float32x4_t *)(v76 + 32), vsubq_f32(v79, (float32x4_t)vandq_s8(v77, (int8x16_t)vcgtq_f32(v79, v78))));
            float32x4_t v82 = vcvtq_f32_s32(vcvtq_s32_f32(v81));
            float32x4_t v83 = vsubq_f32(v82, (float32x4_t)vandq_s8(v77, (int8x16_t)vcgtq_f32(v82, v81)));
            float32x4_t v84 = vmulq_f32(v80, vsubq_f32(v81, v83));
            float32x4_t v85 = vcvtq_f32_s32(vcvtq_s32_f32(v84));
            int8x16_t v86 = (int8x16_t)vaddq_f32(v83, vmulq_f32(v80, vsubq_f32(v85, (float32x4_t)vandq_s8(v77, (int8x16_t)vcgtq_f32(v85, v84)))));
            v5[v75 / 0x10] = vmulq_f32(*(float32x4_t *)(v76 + 64), (float32x4_t)vextq_s8(v86, v86, 4uLL));
            v75 += 16;
          }
          while (v74 != v75);
          ++v71;
          int v4 = (float32x4_t *)((char *)v4 + v72);
          int v5 = (float32x4_t *)((char *)v5 + v73);
        }
        while (v71 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float32x4_t v11 = v4 + 4;
      float32x4_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        float32x4_t v14 = v12;
        float32x4_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = v15;
          float32x4_t v18 = v14;
          uint64_t v19 = *((void *)this + 51);
          int8x16_t v20 = *(int8x16_t *)(v19 + 16);
          float32x4_t v21 = vmulq_f32(v4[v16 - 2], *(float32x4_t *)v19);
          float32x4_t v22 = vmulq_f32(v4[v16 - 1], *(float32x4_t *)v19);
          float32x4_t v23 = vmulq_f32(v4[v16], *(float32x4_t *)v19);
          float32x4_t v24 = vmulq_f32(v4[v16 + 1], *(float32x4_t *)v19);
          float32x4_t v25 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
          float32x4_t v26 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
          float32x4_t v27 = vcvtq_f32_s32(vcvtq_s32_f32(v23));
          float32x4_t v28 = vcvtq_f32_s32(vcvtq_s32_f32(v24));
          float32x4_t v29 = vsubq_f32(v25, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v25, v21)));
          float32x4_t v30 = vsubq_f32(v26, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v26, v22)));
          float32x4_t v31 = *(float32x4_t *)(v19 + 32);
          float32x4_t v32 = *(float32x4_t *)(v19 + 48);
          float32x4_t v33 = vmulq_f32(v31, v29);
          float32x4_t v34 = vmulq_f32(v31, v30);
          float32x4_t v35 = vmulq_f32(v31, vsubq_f32(v27, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v27, v23))));
          float32x4_t v36 = vmulq_f32(v31, vsubq_f32(v28, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v28, v24))));
          float32x4_t v37 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
          float32x4_t v38 = vcvtq_f32_s32(vcvtq_s32_f32(v34));
          float32x4_t v39 = vcvtq_f32_s32(vcvtq_s32_f32(v35));
          float32x4_t v40 = vcvtq_f32_s32(vcvtq_s32_f32(v36));
          float32x4_t v41 = vsubq_f32(v37, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v37, v33)));
          float32x4_t v42 = vsubq_f32(v38, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v38, v34)));
          float32x4_t v43 = vsubq_f32(v39, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v39, v35)));
          float32x4_t v44 = vsubq_f32(v40, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v40, v36)));
          float32x4_t v45 = vmulq_f32(v32, vsubq_f32(v33, v41));
          float32x4_t v46 = vmulq_f32(v32, vsubq_f32(v34, v42));
          float32x4_t v47 = vmulq_f32(v32, vsubq_f32(v35, v43));
          float32x4_t v48 = vmulq_f32(v32, vsubq_f32(v36, v44));
          float32x4_t v49 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
          float32x4_t v50 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
          float32x4_t v51 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
          float32x4_t v52 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
          int8x16_t v53 = (int8x16_t)vaddq_f32(v41, vmulq_f32(v32, vsubq_f32(v49, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v49, v45)))));
          int8x16_t v54 = (int8x16_t)vaddq_f32(v42, vmulq_f32(v32, vsubq_f32(v50, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v50, v46)))));
          int8x16_t v55 = (int8x16_t)vaddq_f32(v43, vmulq_f32(v32, vsubq_f32(v51, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v51, v47)))));
          int8x16_t v56 = (int8x16_t)vaddq_f32(v44, vmulq_f32(v32, vsubq_f32(v52, (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v52, v48)))));
          float32x4_t v57 = *(float32x4_t *)(v19 + 64);
          int32x4_t v58 = &v5[v16];
          v13 += 4;
          v58[-2] = vmulq_f32(v57, (float32x4_t)vextq_s8(v53, v53, 4uLL));
          v58[-1] = vmulq_f32(v57, (float32x4_t)vextq_s8(v54, v54, 4uLL));
          *int32x4_t v58 = vmulq_f32(v57, (float32x4_t)vextq_s8(v55, v55, 4uLL));
          v58[1] = vmulq_f32(v57, (float32x4_t)vextq_s8(v56, v56, 4uLL));
          v16 += 4;
          v15 += 4;
          float32x4_t v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            float32x4_t v59 = *v17++;
            uint64_t v60 = *((void *)this + 51);
            int8x16_t v61 = *(int8x16_t *)(v60 + 16);
            float32x4_t v62 = vmulq_f32(v59, *(float32x4_t *)v60);
            float32x4_t v63 = vcvtq_f32_s32(vcvtq_s32_f32(v62));
            float32x4_t v64 = *(float32x4_t *)(v60 + 48);
            float32x4_t v65 = vmulq_f32(*(float32x4_t *)(v60 + 32), vsubq_f32(v63, (float32x4_t)vandq_s8(v61, (int8x16_t)vcgtq_f32(v63, v62))));
            float32x4_t v66 = vcvtq_f32_s32(vcvtq_s32_f32(v65));
            float32x4_t v67 = vsubq_f32(v66, (float32x4_t)vandq_s8(v61, (int8x16_t)vcgtq_f32(v66, v65)));
            float32x4_t v68 = vmulq_f32(v64, vsubq_f32(v65, v67));
            float32x4_t v69 = vcvtq_f32_s32(vcvtq_s32_f32(v68));
            int8x16_t v70 = (int8x16_t)vaddq_f32(v67, vmulq_f32(v64, vsubq_f32(v69, (float32x4_t)vandq_s8(v61, (int8x16_t)vcgtq_f32(v69, v68)))));
            *v18++ = vmulq_f32(*(float32x4_t *)(v60 + 64), (float32x4_t)vextq_s8(v70, v70, 4uLL));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (float32x4_t *)((char *)v5 + v9);
        int v4 = (float32x4_t *)((char *)v4 + v10);
        float32x4_t v11 = (float32x4_t *)((char *)v11 + v10);
        float32x4_t v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::GetDOD(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::GetROI(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcPixelFormatConversion_kV4S_BE_WXYZ_input::HgcPixelFormatConversion_kV4S_BE_WXYZ_input(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F78B8;
  operator new();
}

void sub_1B7939500(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4S_BE_WXYZ_input::~HgcPixelFormatConversion_kV4S_BE_WXYZ_input(HGNode *this)
{
  *(void *)this = &unk_1F10F78B8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F78B8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F78B8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::SetParameter(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4S_BE_WXYZ_input::GetParameter(HgcPixelFormatConversion_kV4S_BE_WXYZ_input *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcPixelFormatConversion_kV4F_WXYZ_output::GetProgram(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000022e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0.wxyz);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cf796c8f:0088fb48:fbecfffa:bebd058b\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000220\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0.wxyz;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6820d1f2:902f3939:8ad944e0:7499e717\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0.wxyz;\n"
           "}\n"
           "//MD5=3629bbaf:437df260:e6e61391:b5896e9d\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcPixelFormatConversion_kV4F_WXYZ_output::InitProgramDescriptor(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcPixelFormatConversion_kV4F_WXYZ_output_hgc_visible", "//Metal1.0     \n//LEN=0000000113\n[[ visible ]] FragmentOut HgcPixelFormatConversion_kV4F_WXYZ_output_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0.wxyz;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcPixelFormatConversion_kV4F_WXYZ_output");
}

void sub_1B7939944(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7939974(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B793996CLL);
}

double HgcPixelFormatConversion_kV4F_WXYZ_output::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x38uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376F50;
  strcpy(v3, "HgcPixelFormatConversion_kV4F_WXYZ_output [hgc1]");
  return *(double *)"YZ_output [hgc1]";
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::BindTexture(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::Bind(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::RenderTile(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (int8x16_t *)*((void *)a2 + 10);
    int v5 = (int8x16_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v24 = 0;
        uint64_t v25 = 16 * v7;
        uint64_t v26 = 16 * v6;
        uint64_t v27 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v28 = 0;
          do
          {
            v5[v28 / 0x10] = vextq_s8(v4[v28 / 0x10], v4[v28 / 0x10], 0xCuLL);
            v28 += 16;
          }
          while (v27 != v28);
          ++v24;
          int v4 = (int8x16_t *)((char *)v4 + v25);
          int v5 = (int8x16_t *)((char *)v5 + v26);
        }
        while (v24 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float32x4_t v11 = v4 + 4;
      float32x4_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        float32x4_t v14 = v12;
        float32x4_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = v15;
          float32x4_t v18 = v14;
          int8x16_t v19 = vextq_s8(v4[v16 - 1], v4[v16 - 1], 0xCuLL);
          int8x16_t v20 = vextq_s8(v4[v16], v4[v16], 0xCuLL);
          int8x16_t v21 = vextq_s8(v4[v16 + 1], v4[v16 + 1], 0xCuLL);
          float32x4_t v22 = &v5[v16];
          v22[-2] = vextq_s8(v4[v16 - 2], v4[v16 - 2], 0xCuLL);
          v22[-1] = v19;
          v13 += 4;
          *float32x4_t v22 = v20;
          v22[1] = v21;
          v16 += 4;
          v15 += 4;
          float32x4_t v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            int8x16_t v23 = *v17++;
            *v18++ = vextq_s8(v23, v23, 0xCuLL);
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (int8x16_t *)((char *)v5 + v9);
        int v4 = (int8x16_t *)((char *)v4 + v10);
        float32x4_t v11 = (int8x16_t *)((char *)v11 + v10);
        float32x4_t v12 = (int8x16_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::GetDOD(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::GetROI(HgcPixelFormatConversion_kV4F_WXYZ_output *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcPixelFormatConversion_kV4F_WXYZ_output::HgcPixelFormatConversion_kV4F_WXYZ_output(HgcPixelFormatConversion_kV4F_WXYZ_output *this)
{
}

void sub_1B7939D50(_Unwind_Exception *a1)
{
  HGColorMatrix::~HGColorMatrix(v1);
  _Unwind_Resume(a1);
}

void HgcPixelFormatConversion_kV4F_WXYZ_output::~HgcPixelFormatConversion_kV4F_WXYZ_output(HgcPixelFormatConversion_kV4F_WXYZ_output *this)
{
  *(void *)this = &unk_1F10F7B20;
  uint64_t v2 = *((void *)this + 62);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F7B20;
  uint64_t v2 = *((void *)this + 62);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }

  HGColorMatrix::~HGColorMatrix(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F7B20;
  uint64_t v2 = *((void *)this + 62);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }
  HGColorMatrix::~HGColorMatrix(this);

  HGObject::operator delete(v3);
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::SetParameter(HgcPixelFormatConversion_kV4F_WXYZ_output *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcPixelFormatConversion_kV4F_WXYZ_output::GetParameter(HgcPixelFormatConversion_kV4F_WXYZ_output *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

HGNode *HgcPixelFormatConversion_kV4F_WXYZ_output::GetOutput(__n128 *this, HGRenderer *a2, __n128 a3, __n128 a4, __n128 a5)
{
  if (this[31].n128_u32[2])
  {
    int v5 = (int8x16_t *)this[31].n128_u64[0];
    a4 = (__n128)vextq_s8(v5[5], v5[5], 0xCuLL);
    a5 = (__n128)vextq_s8(v5[6], v5[6], 0xCuLL);
    int8x16_t v6 = vextq_s8(v5[7], v5[7], 0xCuLL);
    int8x16_t *v5 = vextq_s8(v5[4], v5[4], 0xCuLL);
    *(__n128 *)(this[31].n128_u64[0] + 16) = a4;
    *(__n128 *)(this[31].n128_u64[0] + 32) = a5;
    *(int8x16_t *)(this[31].n128_u64[0] + 48) = v6;
    uint64_t v7 = (__n128 *)this[31].n128_u64[0];
    this[27] = *v7;
    this[28] = v7[1];
    this[29] = v7[2];
    a3 = v7[3];
    this[30] = a3;
    this[31].n128_u32[2] = 0;
  }
  return HGColorMatrix::GetOutput((HGColorMatrix *)this, a2, a3.n128_f64[0], a4.n128_f64[0], (int32x2_t)a5.n128_u64[0]);
}

const char *HgcColorGamma_bias::GetProgram(HgcColorGamma_bias *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000245\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0)*hg_Params[1] + hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=fa49cb7d:1e053eea:12e2489c:1692af72\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0002:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000237\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0*hg_Params[1] + hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=ad9db7bc:ac24aee5:0faf9a1f:d9021699\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0002:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000231\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0*hg_ProgramLocal1 + hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=bfef74a1:370b9177:d2ba98d4:b569923b\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0002:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorGamma_bias::InitProgramDescriptor(HgcColorGamma_bias *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_bias_hgc_visible", "//Metal1.0     \n//LEN=0000000113\n[[ visible ]] FragmentOut HgcColorGamma_bias_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0*hg_Params[1] + hg_Params[0];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorGamma_bias");
}

void sub_1B793A1FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B793A22C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B793A224);
}

double HgcColorGamma_bias::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcColorGamma_bias [hgc1]");
  return *(double *)"amma_bias [hgc1]";
}

uint64_t HgcColorGamma_bias::BindTexture(HgcColorGamma_bias *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcColorGamma_bias::Bind(HgcColorGamma_bias *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorGamma_bias::RenderTile(HgcColorGamma_bias *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v27 = 0;
        uint64_t v28 = 16 * v7;
        uint64_t v29 = 16 * v6;
        uint64_t v30 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v31 = 0;
          do
          {
            v5[v31 / 0x10] = vaddq_f32(*(float32x4_t *)*((void *)this + 51), vmulq_f32(v4[v31 / 0x10], *(float32x4_t *)(*((void *)this + 51) + 16)));
            v31 += 16;
          }
          while (v30 != v31);
          ++v27;
          int v4 = (float32x4_t *)((char *)v4 + v28);
          int v5 = (float32x4_t *)((char *)v5 + v29);
        }
        while (v27 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float32x4_t v11 = v4 + 4;
      float32x4_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        float32x4_t v14 = v12;
        float32x4_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = v15;
          float32x4_t v18 = v14;
          int8x16_t v19 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v20 = v19[1];
          float32x4_t v21 = vaddq_f32(*v19, vmulq_f32(v4[v16 - 2], v20));
          float32x4_t v22 = vaddq_f32(*v19, vmulq_f32(v4[v16 - 1], v20));
          float32x4_t v23 = vaddq_f32(*v19, vmulq_f32(v4[v16], v20));
          float32x4_t v24 = vaddq_f32(*v19, vmulq_f32(v4[v16 + 1], v20));
          uint64_t v25 = &v5[v16];
          v25[-2] = v21;
          v25[-1] = v22;
          v13 += 4;
          *uint64_t v25 = v23;
          v25[1] = v24;
          v16 += 4;
          v15 += 4;
          float32x4_t v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            float32x4_t v26 = *v17++;
            *v18++ = vaddq_f32(*(float32x4_t *)*((void *)this + 51), vmulq_f32(v26, *(float32x4_t *)(*((void *)this + 51) + 16)));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (float32x4_t *)((char *)v5 + v9);
        int v4 = (float32x4_t *)((char *)v4 + v10);
        float32x4_t v11 = (float32x4_t *)((char *)v11 + v10);
        float32x4_t v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcColorGamma_bias::GetDOD(HgcColorGamma_bias *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcColorGamma_bias::GetROI(HgcColorGamma_bias *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcColorGamma_bias::HgcColorGamma_bias(HgcColorGamma_bias *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F7D98;
  operator new();
}

void sub_1B793A68C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_bias::~HgcColorGamma_bias(HGNode *this)
{
  *(void *)this = &unk_1F10F7D98;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10F7D98;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F7D98;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_bias::SetParameter(HgcColorGamma_bias *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  int v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *int v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcColorGamma_bias::GetParameter(HgcColorGamma_bias *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorGamma_bias_clamp::GetProgram(HgcColorGamma_bias_clamp *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000274\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0*half4(hg_Params[1]) + half4(hg_Params[0]);\n"
             "    output.color0 = fmax(float4(r0), hg_Params[2]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=948bba88:2cd0d942:4e7bd5c2:de20170e\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0003:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000258\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0*hg_Params[1] + hg_Params[0];\n"
             "    output.color0 = fmax(r0, hg_Params[2]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=61fc2441:8cd63a5e:fe3bbe94:65cb2e74\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0003:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000027d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0*hg_ProgramLocal1 + hg_ProgramLocal0;\n"
           "    gl_FragColor = max(r0, hg_ProgramLocal2);\n"
           "}\n"
           "//MD5=18efcb7d:7d440686:c0833abc:66ba06e3\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0003:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorGamma_bias_clamp::InitProgramDescriptor(HgcColorGamma_bias_clamp *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorGamma_bias_clamp_hgc_visible", "//Metal1.0     \n//LEN=000000013a\n[[ visible ]] FragmentOut HgcColorGamma_bias_clamp_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0*hg_Params[1] + hg_Params[0];\n"
    "    output.color0 = fmax(r0, hg_Params[2]);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorGamma_bias_clamp");
}

void sub_1B793AB98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B793ABC8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B793ABC0);
}

double HgcColorGamma_bias_clamp::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D70;
  strcpy(v3, "HgcColorGamma_bias_clamp [hgc1]");
  return *(double *)"ias_clamp [hgc1]";
}

uint64_t HgcColorGamma_bias_clamp::BindTexture(HgcColorGamma_bias_clamp *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcColorGamma_bias_clamp::Bind(HgcColorGamma_bias_clamp *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorGamma_bias_clamp::RenderTile(HgcColorGamma_bias_clamp *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    unint64_t v3 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    int v4 = (float32x4_t *)*((void *)a2 + 10);
    int v5 = (float32x4_t *)*((void *)a2 + 2);
    uint64_t v6 = *((int *)a2 + 6);
    uint64_t v7 = *((int *)a2 + 22);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v28 = 0;
        uint64_t v29 = 16 * v7;
        uint64_t v30 = 16 * v6;
        uint64_t v31 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          unint64_t v32 = 0;
          do
          {
            v5[v32 / 0x10] = vmaxq_f32(vaddq_f32(*(float32x4_t *)*((void *)this + 51), vmulq_f32(v4[v32 / 0x10], *(float32x4_t *)(*((void *)this + 51) + 16))), *(float32x4_t *)(*((void *)this + 51) + 32));
            v32 += 16;
          }
          while (v31 != v32);
          ++v28;
          int v4 = (float32x4_t *)((char *)v4 + v29);
          int v5 = (float32x4_t *)((char *)v5 + v30);
        }
        while (v28 != v2);
      }
    }
    else
    {
      int v8 = 0;
      uint64_t v9 = 16 * v6;
      uint64_t v10 = 16 * v7;
      float32x4_t v11 = v4 + 4;
      float32x4_t v12 = v5 + 4;
      do
      {
        unint64_t v13 = 0;
        float32x4_t v14 = v12;
        float32x4_t v15 = v11;
        uint64_t v16 = 2;
        do
        {
          float32x4_t v17 = v15;
          float32x4_t v18 = v14;
          int8x16_t v19 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v20 = v19[1];
          float32x4_t v21 = v19[2];
          float32x4_t v22 = vmaxq_f32(vaddq_f32(*v19, vmulq_f32(v4[v16 - 2], v20)), v21);
          float32x4_t v23 = vmaxq_f32(vaddq_f32(*v19, vmulq_f32(v4[v16 - 1], v20)), v21);
          float32x4_t v24 = vmaxq_f32(vaddq_f32(*v19, vmulq_f32(v4[v16], v20)), v21);
          float32x4_t v25 = vmaxq_f32(vaddq_f32(*v19, vmulq_f32(v4[v16 + 1], v20)), v21);
          float32x4_t v26 = &v5[v16];
          v26[-2] = v22;
          v26[-1] = v23;
          v13 += 4;
          *float32x4_t v26 = v24;
          v26[1] = v25;
          v16 += 4;
          v15 += 4;
          float32x4_t v14 = v18 + 4;
        }
        while ((uint64_t)v13 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v13)
        {
          do
          {
            float32x4_t v27 = *v17++;
            *v18++ = vmaxq_f32(vaddq_f32(*(float32x4_t *)*((void *)this + 51), vmulq_f32(v27, *(float32x4_t *)(*((void *)this + 51) + 16))), *(float32x4_t *)(*((void *)this + 51) + 32));
            ++v13;
          }
          while (v13 < v3);
        }
        ++v8;
        int v5 = (float32x4_t *)((char *)v5 + v9);
        int v4 = (float32x4_t *)((char *)v4 + v10);
        float32x4_t v11 = (float32x4_t *)((char *)v11 + v10);
        float32x4_t v12 = (float32x4_t *)((char *)v12 + v9);
      }
      while (v8 != v2);
    }
  }
  return 0;
}

uint64_t HgcColorGamma_bias_clamp::GetDOD(HgcColorGamma_bias_clamp *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcColorGamma_bias_clamp::GetROI(HgcColorGamma_bias_clamp *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcColorGamma_bias_clamp::HgcColorGamma_bias_clamp(HgcColorGamma_bias_clamp *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F8000;
  operator new();
}

void sub_1B793B088(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorGamma_bias_clamp::~HgcColorGamma_bias_clamp(HGNode *this)
{
  *(void *)this = &unk_1F10F8000;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40FA0F61DDLL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F8000;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40FA0F61DDLL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcColorGamma_bias_clamp::SetParameter(HgcColorGamma_bias_clamp *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  switch((int)a2)
  {
    case 0:
      uint64_t v7 = (float *)*((void *)this + 51);
      if (*v7 == a3.n128_f32[0] && v7[1] == a4 && v7[2] == a5 && v7[3] == a6) {
        goto LABEL_19;
      }
      *uint64_t v7 = a3.n128_f32[0];
      v7[1] = a4;
      v7[2] = a5;
      v7[3] = a6;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      uint64_t result = 1;
      break;
    case 1:
      uint64_t v9 = (float *)*((void *)this + 51);
      if (v9[4] == a3.n128_f32[0] && v9[5] == a4 && v9[6] == a5 && v9[7] == a6) {
        goto LABEL_19;
      }
      v9[4] = a3.n128_f32[0];
      v9[5] = a4;
      v9[6] = a5;
      v9[7] = a6;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      uint64_t result = 1;
      break;
    case 2:
      uint64_t v10 = *((void *)this + 51);
      if (*(float *)(v10 + 32) == a3.n128_f32[0]
        && *(float *)(v10 + 36) == a4
        && *(float *)(v10 + 40) == a5
        && *(float *)(v10 + 44) == a6)
      {
LABEL_19:
        uint64_t result = 0;
      }
      else
      {
        *(_DWORD *)(v10 + 32) = a3.n128_u32[0];
        *(float *)(v10 + 36) = a4;
        *(float *)(v10 + 40) = a5;
        *(float *)(v10 + 44) = a6;
        HGNode::ClearBits((HGNode *)this, a2, a7);
        uint64_t result = 1;
      }
      break;
    case 3:
      a3.n128_f32[1] = a4;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      *(__n128 *)(*((void *)this + 51) + 48) = a3;
      uint64_t result = 0;
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

float HgcColorGamma_bias_clamp::GetParameter(HgcColorGamma_bias_clamp *this, int a2, float *a3)
{
  switch(a2)
  {
    case 0:
      unint64_t v3 = (float *)*((void *)this + 51);
      *a3 = *v3;
      a3[1] = v3[1];
      a3[2] = v3[2];
      float result = v3[3];
      a3[3] = result;
      break;
    case 1:
      int v5 = (float *)*((void *)this + 51);
      *a3 = v5[4];
      a3[1] = v5[5];
      a3[2] = v5[6];
      float result = v5[7];
      a3[3] = result;
      break;
    case 2:
      uint64_t v6 = (float *)*((void *)this + 51);
      *a3 = v6[8];
      a3[1] = v6[9];
      a3[2] = v6[10];
      float result = v6[11];
      a3[3] = result;
      break;
    case 3:
      uint64_t v7 = (float *)*((void *)this + 51);
      *a3 = v7[12];
      a3[1] = v7[13];
      a3[2] = v7[14];
      float result = v7[15];
      a3[3] = result;
      break;
    default:
      return result;
  }
  return result;
}

const char *HgcST2084_EOTF::GetProgram(HgcST2084_EOTF *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000404\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = clamp(r0.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[0].yyy));\n"
             "    r1.xyz = r0.xyz - half3(hg_Params[1].xxx);\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[1].zzz) + half3(hg_Params[1].yyy);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[0].xxx));\n"
             "    output.color0.xyz = float3(r0.xyz)*hg_Params[1].www;\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c1c59994:6a4309cd:322adf23:26162d23\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ce\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = clamp(r0.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
             "    r1.xyz = r0.xyz - hg_Params[1].xxx;\n"
             "    r0.xyz = r0.xyz*hg_Params[1].zzz + hg_Params[1].yyy;\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[0].xxx);\n"
             "    output.color0.xyz = r0.xyz*hg_Params[1].www;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dfda7509:99458374:6e062eb7:63abe617\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003e1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = clamp(r0.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal0.yyy);\n"
           "    r1.xyz = r0.xyz - hg_ProgramLocal1.xxx;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal1.zzz + hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r0.xyz = r1.xyz/r0.xyz;\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal0.xxx);\n"
           "    gl_FragColor.xyz = r0.xyz*hg_ProgramLocal1.www;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=6997d0cc:8e8a000b:d380b926:8b993188\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcST2084_EOTF::InitProgramDescriptor(HgcST2084_EOTF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcST2084_EOTF_hgc_visible", "//Metal1.0     \n//LEN=00000002a6\n[[ visible ]] FragmentOut HgcST2084_EOTF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = clamp(r0.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
    "    r1.xyz = r0.xyz - hg_Params[1].xxx;\n"
    "    r0.xyz = r0.xyz*hg_Params[1].zzz + hg_Params[1].yyy;\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r0.xyz = r1.xyz/r0.xyz;\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[0].xxx);\n"
    "    output.color0.xyz = r0.xyz*hg_Params[1].www;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcST2084_EOTF");
}

void sub_1B793B6CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B793B6FC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B793B6F4);
}

void HgcST2084_EOTF::shaderDescription(char *a1@<X8>)
{
  a1[23] = 21;
  strcpy(a1, "HgcST2084_EOTF [hgc1]");
}

uint64_t HgcST2084_EOTF::BindTexture(HgcST2084_EOTF *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcST2084_EOTF::Bind(HgcST2084_EOTF *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcST2084_EOTF::RenderTile(HgcST2084_EOTF *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v94 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v11 = (_OWORD *)*((void *)this + 51);
      float32x4_t v13 = *((float32x4_t *)v11 + 2);
      float32x4_t v12 = *((float32x4_t *)v11 + 3);
      float32x4_t v14 = vminq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v10 - 16), v13), v12);
      float32x4_t v15 = vminq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v10), v13), v12);
      int8x16_t v16 = *((int8x16_t *)v11 + 4);
      float32x4_t v17 = *((float32x4_t *)v11 + 5);
      float32x4_t v18 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v14), (int8x16_t)v12);
      float32x4_t v19 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v15), (int8x16_t)v12);
      int8x16_t v20 = *((int8x16_t *)v11 + 6);
      float32x4_t v21 = *((float32x4_t *)v11 + 7);
      float32x4_t v23 = *((float32x4_t *)v11 + 8);
      float32x4_t v22 = *((float32x4_t *)v11 + 9);
      float32x4_t v24 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v18, v23));
      float32x4_t v25 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v19, v23));
      float32x4_t v26 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v14, 0x17uLL)), (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v17, v14))), v21), v24);
      float32x4_t v27 = vsubq_f32(vsubq_f32(v18, v12), vmulq_f32(vmulq_f32(v22, v24), v18));
      float32x4_t v28 = vsubq_f32(vsubq_f32(v19, v12), vmulq_f32(vmulq_f32(v22, v25), v19));
      float32x4_t v29 = *((float32x4_t *)v11 + 10);
      float32x4_t v30 = *((float32x4_t *)v11 + 11);
      float32x4_t v31 = *((float32x4_t *)v11 + 12);
      float32x4_t v32 = *((float32x4_t *)v11 + 13);
      float32x4_t v33 = vaddq_f32(v26, vmulq_f32(v27, vaddq_f32(vaddq_f32(v31, vmulq_f32(v27, v32)), vmulq_f32(vmulq_f32(v27, v27), vaddq_f32(v29, vmulq_f32(v30, v27))))));
      float32x4_t v34 = *((float32x4_t *)v11 + 1);
      float32x4_t v35 = vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v15, 0x17uLL)), (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v17, v15))), v21), v25), vmulq_f32(v28, vaddq_f32(vaddq_f32(v31, vmulq_f32(v28, v32)), vmulq_f32(vmulq_f32(v28, v28), vaddq_f32(v29, vmulq_f32(v30, v28)))))), *(float32x2_t *)v11, 1);
      float32x4_t v37 = *((float32x4_t *)v11 + 14);
      float32x4_t v36 = *((float32x4_t *)v11 + 15);
      float32x4_t v38 = vmaxq_f32(vmulq_lane_f32(v33, *(float32x2_t *)v11, 1), v37);
      float32x4_t v39 = vmaxq_f32(v35, v37);
      float32x4_t v40 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
      float32x4_t v41 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      float32x4_t v42 = vsubq_f32(v40, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v40, v38)));
      float32x4_t v43 = vsubq_f32(v41, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v41, v39)));
      float32x4_t v44 = vsubq_f32(v38, v42);
      float32x4_t v45 = vsubq_f32(v39, v43);
      float32x4_t v47 = *((float32x4_t *)v11 + 16);
      float32x4_t v46 = *((float32x4_t *)v11 + 17);
      float32x4_t v48 = vmulq_f32(v45, vaddq_f32(v46, vmulq_f32(v45, vaddq_f32(v36, vmulq_f32(v47, v45)))));
      float32x4_t v49 = vaddq_f32(v12, vmulq_f32(v44, vaddq_f32(v46, vmulq_f32(v44, vaddq_f32(v36, vmulq_f32(v47, v44))))));
      int32x4_t v51 = *((int32x4_t *)v11 + 18);
      int8x16_t v50 = *((int8x16_t *)v11 + 19);
      float32x4_t v52 = (float32x4_t)vbslq_s8(v50, (int8x16_t)v14, (int8x16_t)vmulq_f32(v49, (float32x4_t)vshlq_n_s32(vaddq_s32(v51, vcvtq_s32_f32(v42)), 0x17uLL)));
      float32x4_t v53 = (float32x4_t)vbslq_s8(v50, (int8x16_t)v15, (int8x16_t)vmulq_f32(vaddq_f32(v12, v48), (float32x4_t)vshlq_n_s32(vaddq_s32(v51, vcvtq_s32_f32(v43)), 0x17uLL)));
      float32x4_t v54 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1);
      float32x4_t v55 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 0);
      float32x4_t v56 = vsubq_f32(v52, v55);
      int8x16_t v57 = (int8x16_t)vaddq_f32(v54, vmulq_laneq_f32(v52, v34, 2));
      int8x16_t v58 = (int8x16_t)vaddq_f32(v54, vmulq_laneq_f32(v53, v34, 2));
      float32x4_t v59 = vsubq_f32(v53, v55);
      float32x4_t v60 = (float32x4_t)vbslq_s8(v50, (int8x16_t)v14, v57);
      float32x4_t v61 = (float32x4_t)vbslq_s8(v50, (int8x16_t)v15, v58);
      float32x4_t v62 = vmaxq_f32(v56, v13);
      float32x4_t v63 = vmaxq_f32(v59, v13);
      float32x4_t v64 = *((float32x4_t *)v11 + 20);
      float32x4_t v65 = *((float32x4_t *)v11 + 21);
      float32x4_t v66 = vmaxq_f32(vmulq_f32(vrecpeq_f32(v60), v64), v65);
      float32x4_t v67 = vmaxq_f32(vmulq_f32(vrecpeq_f32(v61), v64), v65);
      float32x4_t v68 = *((float32x4_t *)v11 + 22);
      float32x4_t v69 = vminq_f32(v66, v68);
      float32x4_t v70 = vminq_f32(v67, v68);
      float32x4_t v71 = (float32x4_t)vbslq_s8(v50, (int8x16_t)v14, (int8x16_t)vmulq_f32(v62, vmulq_f32(v69, vrecpsq_f32(v60, v69))));
      float32x4_t v72 = (float32x4_t)vbslq_s8(v50, (int8x16_t)v15, (int8x16_t)vmulq_f32(v63, vmulq_f32(v70, vrecpsq_f32(v61, v70))));
      float32x4_t v73 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v71, v16), (int8x16_t)v12);
      float32x4_t v74 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v72, v16), (int8x16_t)v12);
      float32x4_t v75 = (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v17, v71));
      float32x4_t v76 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v72, 0x17uLL)), (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v17, v72)));
      float32x4_t v77 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v71, 0x17uLL)), v75), v21);
      float32x4_t v78 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v73, v23));
      float32x4_t v79 = vsubq_f32(v76, v21);
      float32x4_t v80 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v74, v23));
      float32x4_t v81 = vaddq_f32(v77, v78);
      float32x4_t v82 = vsubq_f32(vsubq_f32(v73, v12), vmulq_f32(vmulq_f32(v22, v78), v73));
      float32x4_t v83 = vsubq_f32(vsubq_f32(v74, v12), vmulq_f32(vmulq_f32(v22, v80), v74));
      float32x4_t v84 = vaddq_f32(vaddq_f32(v79, v80), vmulq_f32(v83, vaddq_f32(vaddq_f32(v31, vmulq_f32(v32, v83)), vmulq_f32(vmulq_f32(v83, v83), vaddq_f32(v29, vmulq_f32(v30, v83))))));
      float32x4_t v85 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v81, vmulq_f32(v82, vaddq_f32(vaddq_f32(v31, vmulq_f32(v32, v82)), vmulq_f32(vmulq_f32(v82, v82), vaddq_f32(v29, vmulq_f32(v30, v82)))))), COERCE_FLOAT(*v11)), v37);
      float32x4_t v86 = vmaxq_f32(vmulq_n_f32(v84, COERCE_FLOAT(*v11)), v37);
      float32x4_t v87 = vcvtq_f32_s32(vcvtq_s32_f32(v85));
      float32x4_t v88 = vcvtq_f32_s32(vcvtq_s32_f32(v86));
      float32x4_t v89 = vsubq_f32(v87, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v87, v85)));
      float32x4_t v90 = vsubq_f32(v88, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v88, v86)));
      float32x4_t v91 = vsubq_f32(v85, v89);
      float32x4_t v92 = vsubq_f32(v86, v90);
      float32x4_t v93 = (int8x16_t *)(v5 + v10);
      v93[-1] = vbslq_s8(v50, (int8x16_t)v14, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v50, (int8x16_t)v14, (int8x16_t)vmulq_f32(vaddq_f32(v12, vmulq_f32(v91, vaddq_f32(v46, vmulq_f32(v91, vaddq_f32(v36, vmulq_f32(v47, v91)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v89), v51), 0x17uLL))), v34, 3));
      *float32x4_t v93 = vbslq_s8(v50, (int8x16_t)v15, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v50, (int8x16_t)v15, (int8x16_t)vmulq_f32(vaddq_f32(v12, vmulq_f32(v92, vaddq_f32(v46, vmulq_f32(v92, vaddq_f32(v36, vmulq_f32(v47, v92)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v90), v51), 0x17uLL))), v34, 3));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v94 = -v9;
    if (v94 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v95 = 16 * v94;
    float32x4_t v96 = (_OWORD *)*((void *)this + 51);
    float32x4_t v98 = *((float32x4_t *)v96 + 2);
    float32x4_t v97 = *((float32x4_t *)v96 + 3);
    float32x4_t v99 = vminq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v95), v98), v97);
    int8x16_t v100 = *((int8x16_t *)v96 + 4);
    float32x4_t v101 = *((float32x4_t *)v96 + 5);
    float32x4_t v102 = (float32x4_t)vorrq_s8(vandq_s8(v100, (int8x16_t)v99), (int8x16_t)v97);
    int8x16_t v103 = *((int8x16_t *)v96 + 6);
    float32x4_t v104 = *((float32x4_t *)v96 + 7);
    float32x4_t v105 = *((float32x4_t *)v96 + 8);
    float32x4_t v106 = *((float32x4_t *)v96 + 9);
    float32x4_t v107 = (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v102, v105));
    float32x4_t v108 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v99, 0x17uLL)), (float32x4_t)vandq_s8(v103, (int8x16_t)vcgtq_f32(v101, v99))), v104), v107);
    float32x4_t v109 = vsubq_f32(vsubq_f32(v102, v97), vmulq_f32(vmulq_f32(v106, v107), v102));
    float32x4_t v110 = *((float32x4_t *)v96 + 10);
    float32x4_t v111 = *((float32x4_t *)v96 + 11);
    float32x4_t v112 = *((float32x4_t *)v96 + 12);
    float32x4_t v113 = *((float32x4_t *)v96 + 13);
    float32x4_t v114 = *((float32x4_t *)v96 + 1);
    float32x4_t v115 = *((float32x4_t *)v96 + 14);
    float32x4_t v116 = *((float32x4_t *)v96 + 15);
    float32x4_t v117 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v108, vmulq_f32(v109, vaddq_f32(vaddq_f32(v112, vmulq_f32(v109, v113)), vmulq_f32(vmulq_f32(v109, v109), vaddq_f32(v110, vmulq_f32(v111, v109)))))), *(float32x2_t *)v96, 1), v115);
    float32x4_t v118 = vcvtq_f32_s32(vcvtq_s32_f32(v117));
    float32x4_t v119 = vsubq_f32(v118, (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v118, v117)));
    float32x4_t v120 = vsubq_f32(v117, v119);
    float32x4_t v121 = *((float32x4_t *)v96 + 16);
    float32x4_t v122 = *((float32x4_t *)v96 + 17);
    int32x4_t v123 = *((int32x4_t *)v96 + 18);
    int8x16_t v124 = *((int8x16_t *)v96 + 19);
    float32x4_t v125 = (float32x4_t)vbslq_s8(v124, (int8x16_t)v99, (int8x16_t)vmulq_f32(vaddq_f32(v97, vmulq_f32(v120, vaddq_f32(v122, vmulq_f32(v120, vaddq_f32(v116, vmulq_f32(v121, v120)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v123, vcvtq_s32_f32(v119)), 0x17uLL)));
    float32x4_t v126 = vsubq_f32(v125, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 0));
    float32x4_t v127 = (float32x4_t)vbslq_s8(v124, (int8x16_t)v99, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 1), vmulq_laneq_f32(v125, v114, 2)));
    float32x4_t v128 = vmaxq_f32(v126, v98);
    float32x4_t v129 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v127), *((float32x4_t *)v96 + 20)), *((float32x4_t *)v96 + 21)), *((float32x4_t *)v96 + 22));
    float32x4_t v130 = (float32x4_t)vbslq_s8(v124, (int8x16_t)v99, (int8x16_t)vmulq_f32(v128, vmulq_f32(v129, vrecpsq_f32(v127, v129))));
    float32x4_t v131 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v130, v100), (int8x16_t)v97);
    float32x4_t v132 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v130, 0x17uLL)), (float32x4_t)vandq_s8(v103, (int8x16_t)vcgtq_f32(v101, v130))), v104);
    float32x4_t v133 = (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v131, v105));
    float32x4_t v134 = vsubq_f32(vsubq_f32(v131, v97), vmulq_f32(vmulq_f32(v106, v133), v131));
    float32x4_t v135 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(v132, v133), vmulq_f32(v134, vaddq_f32(vaddq_f32(v112, vmulq_f32(v113, v134)), vmulq_f32(vmulq_f32(v134, v134), vaddq_f32(v110, vmulq_f32(v111, v134)))))), COERCE_FLOAT(*v96)), v115);
    float32x4_t v136 = vcvtq_f32_s32(vcvtq_s32_f32(v135));
    float32x4_t v137 = vsubq_f32(v136, (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v136, v135)));
    float32x4_t v138 = vsubq_f32(v135, v137);
    *(int8x16_t *)(v5 + v95) = vbslq_s8(v124, (int8x16_t)v99, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v124, (int8x16_t)v99, (int8x16_t)vmulq_f32(vaddq_f32(v97, vmulq_f32(v138, vaddq_f32(v122, vmulq_f32(v138, vaddq_f32(v116, vmulq_f32(v121, v138)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v137),
                                                                                           v123),
                                                                                         0x17uLL))),
                                              v114,
                                              3));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcST2084_EOTF::GetDOD(HgcST2084_EOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcST2084_EOTF::GetROI(HgcST2084_EOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcST2084_EOTF::HgcST2084_EOTF(HgcST2084_EOTF *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F8268;
  operator new();
}

void sub_1B793C0BC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcST2084_EOTF::~HgcST2084_EOTF(HGNode *this)
{
  *(void *)this = &unk_1F10F8268;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409BD2D9E4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F8268;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409BD2D9E4);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcST2084_EOTF::SetParameter(HgcST2084_EOTF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcST2084_EOTF::GetParameter(HgcST2084_EOTF *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcST2084_InverseEOTF::GetProgram(HgcST2084_InverseEOTF *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ae\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r0.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz*half3(hg_Params[1].zzz) + c0.yyy;\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[1].yyy) + half3(hg_Params[1].xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    output.color0.xyz = pow(float3(r0.xyz), hg_Params[0].yyy);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2444afad:3db4a253:10709704:a6232534\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000037f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r0.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz*hg_Params[1].zzz + c0.yyy;\n"
             "    r1.xyz = r1.xyz*hg_Params[1].yyy + hg_Params[1].xxx;\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    output.color0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=81f92e6d:ccf1bbeb:6804da4c:060ade07\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000384\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r0.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz*hg_ProgramLocal1.zzz + c0.yyy;\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal1.yyy + hg_ProgramLocal1.xxx;\n"
           "    r0.xyz = r1.xyz/r0.xyz;\n"
           "    gl_FragColor.xyz = pow(r0.xyz, hg_ProgramLocal0.yyy);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=1cee2dfd:bd24937f:dc7ace33:9840809d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcST2084_InverseEOTF::InitProgramDescriptor(HgcST2084_InverseEOTF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcST2084_InverseEOTF_hgc_visible", "//Metal1.0     \n//LEN=000000025e\n[[ visible ]] FragmentOut HgcST2084_InverseEOTF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r0.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = r1.xyz*hg_Params[1].zzz + c0.yyy;\n"
    "    r1.xyz = r1.xyz*hg_Params[1].yyy + hg_Params[1].xxx;\n"
    "    r0.xyz = r1.xyz/r0.xyz;\n"
    "    output.color0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcST2084_InverseEOTF");
}

void sub_1B793C55C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B793C58C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B793C584);
}

double HgcST2084_InverseEOTF::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376120;
  strcpy(v3, "HgcST2084_InverseEOTF [hgc1]");
  return *(double *)"verseEOTF [hgc1]";
}

uint64_t HgcST2084_InverseEOTF::BindTexture(HgcST2084_InverseEOTF *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcST2084_InverseEOTF::Bind(HgcST2084_InverseEOTF *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcST2084_InverseEOTF::RenderTile(HgcST2084_InverseEOTF *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v91 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v11 = *(float32x4_t *)(v6 + v10);
      float32x4_t v13 = (float32x2_t *)*((void *)this + 51);
      float32x4_t v15 = *(float32x4_t *)v13[4].f32;
      int8x16_t v14 = *(int8x16_t *)v13[6].f32;
      float32x4_t v16 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v12, (int8x16_t)vmaxq_f32(v12, v15));
      float32x4_t v17 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v11, (int8x16_t)vmaxq_f32(v11, v15));
      int8x16_t v19 = *(int8x16_t *)v13[8].f32;
      float32x4_t v18 = *(float32x4_t *)v13[10].f32;
      float32x4_t v20 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v16, v19), (int8x16_t)v18);
      float32x4_t v21 = *(float32x4_t *)v13[12].f32;
      int8x16_t v22 = *(int8x16_t *)v13[14].f32;
      float32x4_t v23 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v17, v19), (int8x16_t)v18);
      float32x4_t v24 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v21, v16)));
      float32x4_t v25 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v21, v17)));
      float32x4_t v26 = *(float32x4_t *)v13[16].f32;
      float32x4_t v27 = *(float32x4_t *)v13[18].f32;
      float32x4_t v28 = vsubq_f32(v24, v26);
      float32x4_t v29 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v20, v27));
      float32x4_t v30 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v23, v27));
      float32x4_t v32 = *(float32x4_t *)v13[20].f32;
      float32x4_t v31 = *(float32x4_t *)v13[22].f32;
      float32x4_t v33 = vsubq_f32(v25, v26);
      float32x4_t v34 = vmulq_f32(vmulq_f32(v32, v29), v20);
      float32x4_t v35 = vaddq_f32(v28, v29);
      float32x4_t v36 = vsubq_f32(vsubq_f32(v20, v18), v34);
      float32x4_t v37 = vsubq_f32(vsubq_f32(v23, v18), vmulq_f32(vmulq_f32(v32, v30), v23));
      float32x4_t v39 = *(float32x4_t *)v13[24].f32;
      float32x4_t v38 = *(float32x4_t *)v13[26].f32;
      float32x4_t v41 = *(float32x4_t *)v13[28].f32;
      float32x4_t v40 = *(float32x4_t *)v13[30].f32;
      float32x4_t v42 = vaddq_f32(v33, v30);
      float32x4_t v43 = *(float32x4_t *)v13[2].f32;
      float32x4_t v44 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v35, vmulq_f32(v36, vaddq_f32(vaddq_f32(v38, vmulq_f32(v36, v41)), vmulq_f32(vmulq_f32(v36, v36), vaddq_f32(v31, vmulq_f32(v39, v36)))))), COERCE_FLOAT(*(_OWORD *)v13->f32)), v40);
      float32x4_t v45 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v42, vmulq_f32(v37, vaddq_f32(vaddq_f32(v38, vmulq_f32(v37, v41)), vmulq_f32(vmulq_f32(v37, v37), vaddq_f32(v31, vmulq_f32(v39, v37)))))), COERCE_FLOAT(*(_OWORD *)v13->f32)), v40);
      float32x4_t v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      float32x4_t v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      float32x4_t v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v46, v44)));
      float32x4_t v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v47, v45)));
      float32x4_t v50 = vsubq_f32(v44, v48);
      float32x4_t v51 = vsubq_f32(v45, v49);
      float32x4_t v52 = *(float32x4_t *)v13[32].f32;
      float32x4_t v53 = *(float32x4_t *)v13[34].f32;
      float32x4_t v55 = *(float32x4_t *)v13[36].f32;
      int32x4_t v54 = *(int32x4_t *)v13[38].f32;
      float32x4_t v56 = vmulq_f32(vaddq_f32(v18, vmulq_f32(v50, vaddq_f32(v55, vmulq_f32(v50, vaddq_f32(v52, vmulq_f32(v53, v50)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v54, vcvtq_s32_f32(v48)), 0x17uLL));
      float32x4_t v57 = vmulq_f32(vaddq_f32(v18, vmulq_f32(v51, vaddq_f32(v55, vmulq_f32(v51, vaddq_f32(v52, vmulq_f32(v53, v51)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v54, vcvtq_s32_f32(v49)), 0x17uLL));
      float32x4_t v58 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v12, (int8x16_t)vaddq_f32(v18, vmulq_laneq_f32(v56, v43, 2)));
      float32x4_t v59 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v11, (int8x16_t)vaddq_f32(v18, vmulq_laneq_f32(v57, v43, 2)));
      float32x4_t v60 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 0);
      float32x4_t v61 = vaddq_f32(v60, vmulq_lane_f32(v56, *(float32x2_t *)v43.f32, 1));
      float32x4_t v62 = *(float32x4_t *)v13[40].f32;
      float32x4_t v63 = *(float32x4_t *)v13[42].f32;
      float32x4_t v64 = vaddq_f32(v60, vmulq_lane_f32(v57, *(float32x2_t *)v43.f32, 1));
      float32x4_t v65 = *(float32x4_t *)v13[44].f32;
      float32x4_t v66 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v58), v62), v63), v65);
      float32x4_t v67 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v59), v62), v63), v65);
      float32x4_t v68 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v12, (int8x16_t)vmulq_f32(v61, vmulq_f32(v66, vrecpsq_f32(v58, v66))));
      float32x4_t v69 = (float32x4_t)vbslq_s8(v14, (int8x16_t)v11, (int8x16_t)vmulq_f32(v64, vmulq_f32(v67, vrecpsq_f32(v59, v67))));
      float32x4_t v70 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v68, v19), (int8x16_t)v18);
      float32x4_t v71 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v69, v19), (int8x16_t)v18);
      float32x4_t v72 = (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v21, v68));
      float32x4_t v73 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v69, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v21, v69)));
      float32x4_t v74 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), v72), v26);
      float32x4_t v75 = vsubq_f32(v73, v26);
      float32x4_t v76 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v70, v27));
      float32x4_t v77 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v71, v27));
      float32x4_t v78 = vaddq_f32(v74, v76);
      float32x4_t v79 = vsubq_f32(vsubq_f32(v70, v18), vmulq_f32(vmulq_f32(v32, v76), v70));
      float32x4_t v80 = vsubq_f32(vsubq_f32(v71, v18), vmulq_f32(vmulq_f32(v32, v77), v71));
      float32x4_t v81 = vaddq_f32(vaddq_f32(v75, v77), vmulq_f32(v80, vaddq_f32(vaddq_f32(v38, vmulq_f32(v41, v80)), vmulq_f32(vmulq_f32(v80, v80), vaddq_f32(v31, vmulq_f32(v39, v80))))));
      float32x4_t v82 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v78, vmulq_f32(v79, vaddq_f32(vaddq_f32(v38, vmulq_f32(v41, v79)), vmulq_f32(vmulq_f32(v79, v79), vaddq_f32(v31, vmulq_f32(v39, v79)))))), *v13, 1), v40);
      float32x4_t v83 = vmaxq_f32(vmulq_lane_f32(v81, *v13, 1), v40);
      float32x4_t v84 = vcvtq_f32_s32(vcvtq_s32_f32(v82));
      float32x4_t v85 = vcvtq_f32_s32(vcvtq_s32_f32(v83));
      float32x4_t v86 = vsubq_f32(v84, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v84, v82)));
      float32x4_t v87 = vsubq_f32(v85, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v85, v83)));
      float32x4_t v88 = vsubq_f32(v82, v86);
      float32x4_t v89 = vsubq_f32(v83, v87);
      float32x4_t v90 = (int8x16_t *)(v5 + v10);
      v90[-1] = vbslq_s8(v14, (int8x16_t)v12, (int8x16_t)vmulq_f32(vaddq_f32(v18, vmulq_f32(v88, vaddq_f32(v55, vmulq_f32(v88, vaddq_f32(v52, vmulq_f32(v53, v88)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v86), v54), 0x17uLL)));
      *float32x4_t v90 = vbslq_s8(v14, (int8x16_t)v11, (int8x16_t)vmulq_f32(vaddq_f32(v18, vmulq_f32(v89, vaddq_f32(v55, vmulq_f32(v89, vaddq_f32(v52, vmulq_f32(v53, v89)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v87), v54), 0x17uLL)));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v91 = -v9;
    if (v91 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v92 = 16 * v91;
    float32x4_t v93 = *(float32x4_t *)(v6 + v92);
    int v94 = (float32x2_t *)*((void *)this + 51);
    int8x16_t v95 = *(int8x16_t *)v94[6].f32;
    float32x4_t v96 = (float32x4_t)vbslq_s8(v95, (int8x16_t)v93, (int8x16_t)vmaxq_f32(v93, *(float32x4_t *)v94[4].f32));
    int8x16_t v98 = *(int8x16_t *)v94[8].f32;
    float32x4_t v97 = *(float32x4_t *)v94[10].f32;
    float32x4_t v99 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v96, v98), (int8x16_t)v97);
    float32x4_t v100 = *(float32x4_t *)v94[12].f32;
    int8x16_t v101 = *(int8x16_t *)v94[14].f32;
    float32x4_t v102 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v96, 0x17uLL)), (float32x4_t)vandq_s8(v101, (int8x16_t)vcgtq_f32(v100, v96)));
    float32x4_t v103 = *(float32x4_t *)v94[16].f32;
    float32x4_t v104 = *(float32x4_t *)v94[18].f32;
    float32x4_t v105 = (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v99, v104));
    float32x4_t v106 = vaddq_f32(vsubq_f32(v102, v103), v105);
    float32x4_t v107 = *(float32x4_t *)v94[20].f32;
    float32x4_t v108 = *(float32x4_t *)v94[22].f32;
    float32x4_t v109 = vsubq_f32(vsubq_f32(v99, v97), vmulq_f32(vmulq_f32(v107, v105), v99));
    float32x4_t v111 = *(float32x4_t *)v94[24].f32;
    float32x4_t v110 = *(float32x4_t *)v94[26].f32;
    float32x4_t v112 = *(float32x4_t *)v94[28].f32;
    float32x4_t v113 = *(float32x4_t *)v94[30].f32;
    float32x4_t v114 = *(float32x4_t *)v94[2].f32;
    float32x4_t v115 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v106, vmulq_f32(v109, vaddq_f32(vaddq_f32(v110, vmulq_f32(v109, v112)), vmulq_f32(vmulq_f32(v109, v109), vaddq_f32(v108, vmulq_f32(v111, v109)))))), COERCE_FLOAT(*(_OWORD *)v94->f32)), v113);
    float32x4_t v116 = vcvtq_f32_s32(vcvtq_s32_f32(v115));
    float32x4_t v117 = vsubq_f32(v116, (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v116, v115)));
    float32x4_t v118 = vsubq_f32(v115, v117);
    float32x4_t v119 = *(float32x4_t *)v94[32].f32;
    float32x4_t v120 = *(float32x4_t *)v94[34].f32;
    float32x4_t v121 = *(float32x4_t *)v94[36].f32;
    int32x4_t v122 = *(int32x4_t *)v94[38].f32;
    float32x4_t v123 = vmulq_f32(vaddq_f32(v97, vmulq_f32(v118, vaddq_f32(v121, vmulq_f32(v118, vaddq_f32(v119, vmulq_f32(v120, v118)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v122, vcvtq_s32_f32(v117)), 0x17uLL));
    float32x4_t v124 = (float32x4_t)vbslq_s8(v95, (int8x16_t)v93, (int8x16_t)vaddq_f32(v97, vmulq_laneq_f32(v123, v114, 2)));
    float32x4_t v125 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 0), vmulq_lane_f32(v123, *(float32x2_t *)v114.f32, 1));
    float32x4_t v126 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v124), *(float32x4_t *)v94[40].f32), *(float32x4_t *)v94[42].f32), *(float32x4_t *)v94[44].f32);
    float32x4_t v127 = (float32x4_t)vbslq_s8(v95, (int8x16_t)v93, (int8x16_t)vmulq_f32(vmulq_f32(v126, vrecpsq_f32(v124, v126)), v125));
    float32x4_t v128 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v127, v98), (int8x16_t)v97);
    float32x4_t v129 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v127, 0x17uLL)), (float32x4_t)vandq_s8(v101, (int8x16_t)vcgtq_f32(v100, v127))), v103);
    float32x4_t v130 = (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v128, v104));
    float32x4_t v131 = vsubq_f32(vsubq_f32(v128, v97), vmulq_f32(vmulq_f32(v107, v130), v128));
    float32x4_t v132 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(vaddq_f32(v129, v130), vmulq_f32(v131, vaddq_f32(vaddq_f32(v110, vmulq_f32(v112, v131)), vmulq_f32(vmulq_f32(v131, v131), vaddq_f32(v108, vmulq_f32(v111, v131)))))), *v94, 1), v113);
    float32x4_t v133 = vcvtq_f32_s32(vcvtq_s32_f32(v132));
    float32x4_t v134 = vsubq_f32(v133, (float32x4_t)vandq_s8((int8x16_t)v97, (int8x16_t)vcgtq_f32(v133, v132)));
    float32x4_t v135 = vsubq_f32(v132, v134);
    *(int8x16_t *)(v5 + v92) = vbslq_s8(v95, (int8x16_t)v93, (int8x16_t)vmulq_f32(vaddq_f32(v97, vmulq_f32(v135, vaddq_f32(v121, vmulq_f32(v135, vaddq_f32(v119, vmulq_f32(v120, v135)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v134), v122), 0x17uLL)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcST2084_InverseEOTF::GetDOD(HgcST2084_InverseEOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcST2084_InverseEOTF::GetROI(HgcST2084_InverseEOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcST2084_InverseEOTF::HgcST2084_InverseEOTF(HgcST2084_InverseEOTF *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F84D0;
  operator new();
}

void sub_1B793CF54(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcST2084_InverseEOTF::~HgcST2084_InverseEOTF(HGNode *this)
{
  *(void *)this = &unk_1F10F84D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409BD2D9E4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F84D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409BD2D9E4);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcST2084_InverseEOTF::SetParameter(HgcST2084_InverseEOTF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcST2084_InverseEOTF::GetParameter(HgcST2084_InverseEOTF *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_PQ_OOTF::GetProgram(HgcBT2100_PQ_OOTF *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003fc\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[0].zzz);\n"
             "    r0.xyz = pow(r1.xyz, half3(hg_Params[1].xxx));\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = half3(half3(hg_Params[0].www) < r1.xyz);\n"
             "    r0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000h);\n"
             "    output.color0.xyz = pow(float3(r0.xyz), hg_Params[1].yyy);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=497acd98:5770f8f6:3d0f2d43:8aa16af4\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003c7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz*hg_Params[0].zzz;\n"
             "    r0.xyz = pow(r1.xyz, hg_Params[1].xxx);\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r1.xyz = float3(hg_Params[0].www < r1.xyz);\n"
             "    r0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
             "    output.color0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ba549f37:722664fb:6e7f959f:a25bfb26\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal0.zzz;\n"
           "    r0.xyz = pow(r1.xyz, hg_ProgramLocal1.xxx);\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = vec3(lessThan(hg_ProgramLocal0.www, r1.xyz));\n"
           "    r0.xyz = vec3(-r1.x < 0.00000 ? r0.x : r2.x, -r1.y < 0.00000 ? r0.y : r2.y, -r1.z < 0.00000 ? r0.z : r2.z"
           ");\n"
           "    gl_FragColor.xyz = pow(r0.xyz, hg_ProgramLocal1.yyy);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=16c6aa6a:26df20c3:449175b2:08fdb222\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_OOTF::InitProgramDescriptor(HgcBT2100_PQ_OOTF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_OOTF_hgc_visible", "//Metal1.0     \n//LEN=00000002a2\n[[ visible ]] FragmentOut HgcBT2100_PQ_OOTF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz*hg_Params[0].zzz;\n"
    "    r0.xyz = pow(r1.xyz, hg_Params[1].xxx);\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r1.xyz = float3(hg_Params[0].www < r1.xyz);\n"
    "    r0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
    "    output.color0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2100_PQ_OOTF");
}

void sub_1B793D3F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B793D424(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B793D41CLL);
}

char *HgcBT2100_PQ_OOTF::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8349210;
  strcpy(result, "HgcBT2100_PQ_OOTF [hgc1]");
  return result;
}

uint64_t HgcBT2100_PQ_OOTF::BindTexture(HgcBT2100_PQ_OOTF *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_OOTF::Bind(HgcBT2100_PQ_OOTF *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2100_PQ_OOTF::RenderTile(HgcBT2100_PQ_OOTF *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v84 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v11 = *(float32x4_t *)(v6 + v10);
      float32x4_t v13 = (_OWORD *)*((void *)this + 51);
      float32x4_t v14 = *((float32x4_t *)v13 + 2);
      int8x16_t v15 = *((int8x16_t *)v13 + 3);
      float32x4_t v16 = vmaxq_f32(v12, v14);
      float32x4_t v17 = vmaxq_f32(v11, v14);
      float32x4_t v18 = *((float32x4_t *)v13 + 4);
      float32x4_t v19 = *((float32x4_t *)v13 + 5);
      float32x4_t v20 = (float32x4_t)vorrq_s8(vandq_s8(v15, (int8x16_t)v16), (int8x16_t)v18);
      float32x4_t v21 = (float32x4_t)vorrq_s8(vandq_s8(v15, (int8x16_t)v17), (int8x16_t)v18);
      int8x16_t v22 = *((int8x16_t *)v13 + 6);
      float32x4_t v23 = *((float32x4_t *)v13 + 7);
      float32x4_t v25 = *((float32x4_t *)v13 + 8);
      float32x4_t v24 = *((float32x4_t *)v13 + 9);
      float32x4_t v26 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v20, v25));
      float32x4_t v27 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v21, v25));
      float32x4_t v28 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v19, v16))), v23), v26);
      float32x4_t v29 = vsubq_f32(vsubq_f32(v20, v18), vmulq_f32(vmulq_f32(v24, v26), v20));
      float32x4_t v30 = vsubq_f32(vsubq_f32(v21, v18), vmulq_f32(vmulq_f32(v24, v27), v21));
      float32x4_t v31 = *((float32x4_t *)v13 + 10);
      float32x4_t v32 = *((float32x4_t *)v13 + 11);
      float32x4_t v33 = *((float32x4_t *)v13 + 12);
      float32x4_t v34 = *((float32x4_t *)v13 + 13);
      float32x4_t v35 = vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v19, v17))), v23), v27), vmulq_f32(v30, vaddq_f32(vaddq_f32(v33, vmulq_f32(v30, v34)), vmulq_f32(vmulq_f32(v30, v30), vaddq_f32(v31, vmulq_f32(v32, v30))))));
      long long v36 = v13[1];
      float32x4_t v37 = vmulq_n_f32(vaddq_f32(v28, vmulq_f32(v29, vaddq_f32(vaddq_f32(v33, vmulq_f32(v29, v34)), vmulq_f32(vmulq_f32(v29, v29), vaddq_f32(v31, vmulq_f32(v32, v29)))))), *(float *)&v36);
      float32x4_t v38 = vmulq_n_f32(v35, *(float *)&v36);
      float32x4_t v40 = *((float32x4_t *)v13 + 14);
      float32x4_t v39 = *((float32x4_t *)v13 + 15);
      float32x4_t v41 = vmaxq_f32(v37, v40);
      float32x4_t v42 = vmaxq_f32(v38, v40);
      float32x4_t v43 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
      float32x4_t v44 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
      int8x16_t v45 = (int8x16_t)vmulq_laneq_f32(v16, *(float32x4_t *)v13, 2);
      float32x4_t v46 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v43, v41)));
      float32x4_t v47 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v44, v42)));
      float32x4_t v48 = vsubq_f32(v41, v46);
      float32x4_t v49 = vsubq_f32(v42, v47);
      float32x4_t v51 = *((float32x4_t *)v13 + 16);
      float32x4_t v50 = *((float32x4_t *)v13 + 17);
      int8x16_t v52 = (int8x16_t)vmulq_laneq_f32(v17, *(float32x4_t *)v13, 2);
      float32x4_t v53 = vmulq_f32(v49, vaddq_f32(v50, vmulq_f32(v49, vaddq_f32(v39, vmulq_f32(v51, v49)))));
      float32x4_t v54 = vaddq_f32(v18, vmulq_f32(v48, vaddq_f32(v50, vmulq_f32(v48, vaddq_f32(v39, vmulq_f32(v51, v48))))));
      int32x4_t v56 = *((int32x4_t *)v13 + 18);
      int8x16_t v55 = *((int8x16_t *)v13 + 19);
      float32x4_t v57 = (float32x4_t)vbslq_s8(v55, (int8x16_t)v11, (int8x16_t)vmulq_f32(vaddq_f32(v18, v53), (float32x4_t)vshlq_n_s32(vaddq_s32(v56, vcvtq_s32_f32(v47)), 0x17uLL)));
      float32x4_t v58 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 1);
      float32x4_t v59 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v13, 3);
      int8x16_t v60 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v16, v59)), v14);
      int8x16_t v61 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v17, v59)), v14);
      float32x4_t v62 = (float32x4_t)vbslq_s8(v55, (int8x16_t)v12, vbslq_s8(v60, vbslq_s8(v55, (int8x16_t)v12, (int8x16_t)vaddq_f32(v58, vmulq_n_f32((float32x4_t)vbslq_s8(v55, (int8x16_t)v12, (int8x16_t)vmulq_f32(v54, (float32x4_t)vshlq_n_s32(vaddq_s32(v56, vcvtq_s32_f32(v46)),
                                                                                         0x17uLL))),
                                              COERCE_FLOAT(*v13)))),
                             v45));
      float32x4_t v63 = (float32x4_t)vbslq_s8(v55, (int8x16_t)v11, vbslq_s8(v61, vbslq_s8(v55, (int8x16_t)v11, (int8x16_t)vaddq_f32(v58, vmulq_n_f32(v57, COERCE_FLOAT(*v13)))), v52));
      float32x4_t v64 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v62, v15), (int8x16_t)v18);
      float32x4_t v65 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v63, v15), (int8x16_t)v18);
      float32x4_t v66 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v63, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v19, v63)));
      float32x4_t v67 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v62, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v19, v62))), v23);
      float32x4_t v68 = vsubq_f32(v66, v23);
      float32x4_t v69 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v64, v25));
      float32x4_t v70 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v65, v25));
      float32x4_t v71 = vaddq_f32(v67, v69);
      float32x4_t v72 = vsubq_f32(vsubq_f32(v64, v18), vmulq_f32(vmulq_f32(v24, v69), v64));
      float32x4_t v73 = vsubq_f32(vsubq_f32(v65, v18), vmulq_f32(vmulq_f32(v24, v70), v65));
      float32x4_t v74 = vaddq_f32(vaddq_f32(v68, v70), vmulq_f32(v73, vaddq_f32(vaddq_f32(v33, vmulq_f32(v34, v73)), vmulq_f32(vmulq_f32(v73, v73), vaddq_f32(v31, vmulq_f32(v32, v73))))));
      float32x4_t v75 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v71, vmulq_f32(v72, vaddq_f32(vaddq_f32(v33, vmulq_f32(v34, v72)), vmulq_f32(vmulq_f32(v72, v72), vaddq_f32(v31, vmulq_f32(v32, v72)))))), *(float32x2_t *)&v36, 1), v40);
      float32x4_t v76 = vmaxq_f32(vmulq_lane_f32(v74, *(float32x2_t *)&v36, 1), v40);
      float32x4_t v77 = vcvtq_f32_s32(vcvtq_s32_f32(v75));
      float32x4_t v78 = vcvtq_f32_s32(vcvtq_s32_f32(v76));
      float32x4_t v79 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v77, v75)));
      float32x4_t v80 = vsubq_f32(v78, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v78, v76)));
      float32x4_t v81 = vsubq_f32(v75, v79);
      float32x4_t v82 = vsubq_f32(v76, v80);
      float32x4_t v83 = (int8x16_t *)(v5 + v10);
      v83[-1] = vbslq_s8(v55, (int8x16_t)v12, (int8x16_t)vmulq_f32(vaddq_f32(v18, vmulq_f32(v81, vaddq_f32(v50, vmulq_f32(v81, vaddq_f32(v39, vmulq_f32(v51, v81)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v79), v56), 0x17uLL)));
      *float32x4_t v83 = vbslq_s8(v55, (int8x16_t)v11, (int8x16_t)vmulq_f32(vaddq_f32(v18, vmulq_f32(v82, vaddq_f32(v50, vmulq_f32(v82, vaddq_f32(v39, vmulq_f32(v51, v82)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v80), v56), 0x17uLL)));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v84 = -v9;
    if (v84 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v85 = 16 * v84;
    float32x4_t v86 = *(float32x4_t *)(v6 + v85);
    float32x4_t v87 = (_OWORD *)*((void *)this + 51);
    float32x4_t v88 = *((float32x4_t *)v87 + 2);
    int8x16_t v89 = *((int8x16_t *)v87 + 3);
    float32x4_t v90 = vmaxq_f32(v86, v88);
    long long v91 = v87[1];
    float32x4_t v92 = *((float32x4_t *)v87 + 4);
    float32x4_t v93 = *((float32x4_t *)v87 + 5);
    float32x4_t v94 = (float32x4_t)vorrq_s8(vandq_s8(v89, (int8x16_t)v90), (int8x16_t)v92);
    int8x16_t v95 = *((int8x16_t *)v87 + 6);
    float32x4_t v96 = *((float32x4_t *)v87 + 7);
    float32x4_t v97 = *((float32x4_t *)v87 + 8);
    float32x4_t v98 = *((float32x4_t *)v87 + 9);
    float32x4_t v99 = (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v94, v97));
    float32x4_t v100 = vsubq_f32(vsubq_f32(v94, v92), vmulq_f32(vmulq_f32(v98, v99), v94));
    float32x4_t v101 = *((float32x4_t *)v87 + 10);
    float32x4_t v102 = *((float32x4_t *)v87 + 11);
    float32x4_t v103 = *((float32x4_t *)v87 + 12);
    float32x4_t v104 = *((float32x4_t *)v87 + 13);
    float32x4_t v105 = vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v90, 0x17uLL)), (float32x4_t)vandq_s8(v95, (int8x16_t)vcgtq_f32(v93, v90))), v96), v99), vmulq_f32(v100, vaddq_f32(vaddq_f32(v103, vmulq_f32(v100, v104)), vmulq_f32(vmulq_f32(v100, v100), vaddq_f32(v101, vmulq_f32(v102, v100)))))), *(float *)&v91);
    float32x4_t v106 = *((float32x4_t *)v87 + 14);
    float32x4_t v107 = *((float32x4_t *)v87 + 15);
    float32x4_t v108 = vmaxq_f32(v105, v106);
    float32x4_t v109 = vcvtq_f32_s32(vcvtq_s32_f32(v108));
    float32x4_t v110 = vsubq_f32(v109, (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v109, v108)));
    float32x4_t v111 = vsubq_f32(v108, v110);
    float32x4_t v112 = *((float32x4_t *)v87 + 16);
    float32x4_t v113 = *((float32x4_t *)v87 + 17);
    int32x4_t v115 = *((int32x4_t *)v87 + 18);
    int8x16_t v114 = *((int8x16_t *)v87 + 19);
    float32x4_t v116 = (float32x4_t)vbslq_s8(v114, (int8x16_t)v86, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v90, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v87, 3))), v88), vbslq_s8(v114, (int8x16_t)v86, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v87, 1), vmulq_n_f32((float32x4_t)vbslq_s8(v114, (int8x16_t)v86,
                                                            (int8x16_t)vmulq_f32(vaddq_f32(v92, vmulq_f32(v111, vaddq_f32(v113, vmulq_f32(v111, vaddq_f32(v107, vmulq_f32(v112, v111)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v115, vcvtq_s32_f32(v110)), 0x17uLL))), COERCE_FLOAT(*v87)))), (int8x16_t)vmulq_laneq_f32(v90, *(float32x4_t *)v87, 2)));
    float32x4_t v117 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v116, v89), (int8x16_t)v92);
    float32x4_t v118 = (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v117, v97));
    float32x4_t v119 = vsubq_f32(vsubq_f32(v117, v92), vmulq_f32(vmulq_f32(v98, v118), v117));
    float32x4_t v120 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v116, 0x17uLL)), (float32x4_t)vandq_s8(v95, (int8x16_t)vcgtq_f32(v93, v116))), v96), v118), vmulq_f32(v119, vaddq_f32(vaddq_f32(v103, vmulq_f32(v104, v119)), vmulq_f32(vmulq_f32(v119, v119), vaddq_f32(v101, vmulq_f32(v102, v119)))))), *(float32x2_t *)&v91, 1), v106);
    float32x4_t v121 = vcvtq_f32_s32(vcvtq_s32_f32(v120));
    float32x4_t v122 = vsubq_f32(v121, (float32x4_t)vandq_s8((int8x16_t)v92, (int8x16_t)vcgtq_f32(v121, v120)));
    float32x4_t v123 = vsubq_f32(v120, v122);
    *(int8x16_t *)(v5 + v85) = vbslq_s8(v114, (int8x16_t)v86, (int8x16_t)vmulq_f32(vaddq_f32(v92, vmulq_f32(v123, vaddq_f32(v113, vmulq_f32(v123, vaddq_f32(v107, vmulq_f32(v112, v123)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v122), v115), 0x17uLL)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_PQ_OOTF::GetDOD(HgcBT2100_PQ_OOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2100_PQ_OOTF::GetROI(HgcBT2100_PQ_OOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2100_PQ_OOTF::HgcBT2100_PQ_OOTF(HgcBT2100_PQ_OOTF *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F8738;
  operator new();
}

void sub_1B793DD84(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_OOTF::~HgcBT2100_PQ_OOTF(HGNode *this)
{
  *(void *)this = &unk_1F10F8738;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B2834900);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F8738;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B2834900);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_OOTF::SetParameter(HgcBT2100_PQ_OOTF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_PQ_OOTF::GetParameter(HgcBT2100_PQ_OOTF *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_PQ_OOTF_qtApprox::GetProgram(HgcBT2100_PQ_OOTF_qtApprox *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000338\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xxx);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[0].yyy));\n"
             "    output.color0.xyz = float3(r0.xyz)*hg_Params[0].zzz;\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=56795360:c329840e:57b872f7:276b1e06\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000317\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xxx;\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
             "    output.color0.xyz = r0.xyz*hg_Params[0].zzz;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=cd043c2b:d3f1596d:4cb96176:dc8cdb49\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002ed\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xxx;\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal0.yyy);\n"
           "    gl_FragColor.xyz = r0.xyz*hg_ProgramLocal0.zzz;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=37349320:63679db7:9c06dc59:4d215346\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_OOTF_qtApprox::InitProgramDescriptor(HgcBT2100_PQ_OOTF_qtApprox *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_OOTF_qtApprox_hgc_visible", "//Metal1.0     \n//LEN=00000001fb\n[[ visible ]] FragmentOut HgcBT2100_PQ_OOTF_qtApprox_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xxx;\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
    "    output.color0.xyz = r0.xyz*hg_Params[0].zzz;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2100_PQ_OOTF_qtApprox");
}

void sub_1B793E224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B793E254(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B793E24CLL);
}

char *HgcBT2100_PQ_OOTF_qtApprox::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376030;
  strcpy(result, "HgcBT2100_PQ_OOTF_qtApprox [hgc1]");
  return result;
}

uint64_t HgcBT2100_PQ_OOTF_qtApprox::BindTexture(HgcBT2100_PQ_OOTF_qtApprox *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_OOTF_qtApprox::Bind(HgcBT2100_PQ_OOTF_qtApprox *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2100_PQ_OOTF_qtApprox::RenderTile(HgcBT2100_PQ_OOTF_qtApprox *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v61 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v11 = *(float32x4_t *)(v6 + v10);
      float32x4_t v13 = (_OWORD *)*((void *)this + 51);
      float32x4_t v14 = *((float32x4_t *)v13 + 1);
      int8x16_t v15 = (int8x16_t)vmaxq_f32(v12, v14);
      int8x16_t v16 = (int8x16_t)vmaxq_f32(v11, v14);
      int8x16_t v17 = *((int8x16_t *)v13 + 2);
      int8x16_t v18 = *((int8x16_t *)v13 + 3);
      float32x4_t v19 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v12, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v12, v15), COERCE_FLOAT(*v13)));
      float32x4_t v20 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v11, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v11, v16), COERCE_FLOAT(*v13)));
      float32x4_t v21 = *((float32x4_t *)v13 + 4);
      float32x4_t v22 = *((float32x4_t *)v13 + 5);
      float32x4_t v23 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v19, v18), (int8x16_t)v21);
      int8x16_t v24 = *((int8x16_t *)v13 + 6);
      float32x4_t v25 = *((float32x4_t *)v13 + 7);
      float32x4_t v26 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v20, v18), (int8x16_t)v21);
      float32x4_t v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v20)));
      float32x4_t v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v19))), v25);
      float32x4_t v29 = *((float32x4_t *)v13 + 8);
      float32x4_t v30 = *((float32x4_t *)v13 + 9);
      float32x4_t v31 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v23, v29));
      float32x4_t v32 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v26, v29));
      float32x4_t v33 = vaddq_f32(v28, v31);
      float32x4_t v34 = vsubq_f32(vsubq_f32(v23, v21), vmulq_f32(vmulq_f32(v30, v31), v23));
      float32x4_t v35 = vsubq_f32(vsubq_f32(v26, v21), vmulq_f32(vmulq_f32(v30, v32), v26));
      float32x4_t v36 = *((float32x4_t *)v13 + 10);
      float32x4_t v37 = *((float32x4_t *)v13 + 11);
      float32x4_t v38 = *((float32x4_t *)v13 + 12);
      float32x4_t v39 = *((float32x4_t *)v13 + 13);
      float32x4_t v40 = vaddq_f32(vaddq_f32(vsubq_f32(v27, v25), v32), vmulq_f32(v35, vaddq_f32(vaddq_f32(v38, vmulq_f32(v39, v35)), vmulq_f32(vmulq_f32(v35, v35), vaddq_f32(v36, vmulq_f32(v37, v35))))));
      float32x4_t v41 = vmulq_lane_f32(vaddq_f32(v33, vmulq_f32(v34, vaddq_f32(vaddq_f32(v38, vmulq_f32(v39, v34)), vmulq_f32(vmulq_f32(v34, v34), vaddq_f32(v36, vmulq_f32(v37, v34)))))), *(float32x2_t *)v13, 1);
      float32x4_t v42 = *((float32x4_t *)v13 + 14);
      float32x4_t v43 = *((float32x4_t *)v13 + 15);
      float32x4_t v44 = vmaxq_f32(v41, v42);
      float32x4_t v45 = vmaxq_f32(vmulq_lane_f32(v40, *(float32x2_t *)v13, 1), v42);
      float32x4_t v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      float32x4_t v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      float32x4_t v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v46, v44)));
      float32x4_t v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v47, v45)));
      float32x4_t v50 = vsubq_f32(v44, v48);
      float32x4_t v51 = vsubq_f32(v45, v49);
      float32x4_t v52 = *((float32x4_t *)v13 + 16);
      float32x4_t v53 = *((float32x4_t *)v13 + 17);
      float32x4_t v54 = vmulq_f32(v51, vaddq_f32(v53, vmulq_f32(v51, vaddq_f32(v43, vmulq_f32(v52, v51)))));
      float32x4_t v55 = vaddq_f32(v21, vmulq_f32(v50, vaddq_f32(v53, vmulq_f32(v50, vaddq_f32(v43, vmulq_f32(v52, v50))))));
      int32x4_t v56 = vcvtq_s32_f32(v49);
      int32x4_t v57 = *((int32x4_t *)v13 + 18);
      int8x16_t v58 = (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v11, (int8x16_t)vmulq_f32(vaddq_f32(v21, v54), (float32x4_t)vshlq_n_s32(vaddq_s32(v57, v56), 0x17uLL))), *(float32x4_t *)v13, 2);
      int8x16_t v59 = vbslq_s8(v17, (int8x16_t)v12, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v17, (int8x16_t)v12, (int8x16_t)vmulq_f32(v55, (float32x4_t)vshlq_n_s32(vaddq_s32(v57, vcvtq_s32_f32(v48)), 0x17uLL))), *(float32x4_t *)v13, 2));
      int8x16_t v60 = (int8x16_t *)(v5 + v10);
      v60[-1] = v59;
      *int8x16_t v60 = vbslq_s8(v17, (int8x16_t)v11, v58);
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v61 = -v9;
    if (v61 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v62 = 16 * v61;
    float32x4_t v63 = *(float32x4_t *)(v6 + v62);
    uint64_t v64 = *((void *)this + 51);
    int8x16_t v65 = *(int8x16_t *)(v64 + 32);
    float32x4_t v66 = (float32x4_t)vbslq_s8(v65, (int8x16_t)v63, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v65, (int8x16_t)v63, (int8x16_t)vmaxq_f32(v63, *(float32x4_t *)(v64 + 16))), COERCE_FLOAT(*(_OWORD *)v64)));
    float32x4_t v67 = *(float32x4_t *)(v64 + 64);
    float32x4_t v68 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v66, *(int8x16_t *)(v64 + 48)), (int8x16_t)v67);
    float32x4_t v69 = (float32x4_t)vandq_s8((int8x16_t)v67, (int8x16_t)vcgtq_f32(v68, *(float32x4_t *)(v64 + 128)));
    float32x4_t v70 = vsubq_f32(vsubq_f32(v68, v67), vmulq_f32(vmulq_f32(*(float32x4_t *)(v64 + 144), v69), v68));
    float32x4_t v71 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v66, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v64 + 96), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v64 + 80), v66))), *(float32x4_t *)(v64 + 112)), v69), vmulq_f32(v70, vaddq_f32(vaddq_f32(*(float32x4_t *)(v64 + 192), vmulq_f32(*(float32x4_t *)(v64 + 208), v70)), vmulq_f32(vmulq_f32(v70, v70), vaddq_f32(*(float32x4_t *)(v64 + 160), vmulq_f32(*(float32x4_t *)(v64 + 176), v70)))))), *(float32x2_t *)v64,
              1),
            *(float32x4_t *)(v64 + 224));
    float32x4_t v72 = vcvtq_f32_s32(vcvtq_s32_f32(v71));
    float32x4_t v73 = vsubq_f32(v72, (float32x4_t)vandq_s8((int8x16_t)v67, (int8x16_t)vcgtq_f32(v72, v71)));
    float32x4_t v74 = vsubq_f32(v71, v73);
    *(int8x16_t *)(v5 + v62) = vbslq_s8(v65, (int8x16_t)v63, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v65, (int8x16_t)v63, (int8x16_t)vmulq_f32(vaddq_f32(v67, vmulq_f32(v74, vaddq_f32(*(float32x4_t *)(v64 + 272), vmulq_f32(v74, vaddq_f32(*(float32x4_t *)(v64 + 240), vmulq_f32(*(float32x4_t *)(v64 + 256),
                                                                                      v74)))))),
                                                                          (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v64 + 288), vcvtq_s32_f32(v73)), 0x17uLL))), *(float32x4_t *)v64, 2));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_PQ_OOTF_qtApprox::GetDOD(HgcBT2100_PQ_OOTF_qtApprox *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2100_PQ_OOTF_qtApprox::GetROI(HgcBT2100_PQ_OOTF_qtApprox *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2100_PQ_OOTF_qtApprox::HgcBT2100_PQ_OOTF_qtApprox(HgcBT2100_PQ_OOTF_qtApprox *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F89A0;
  operator new();
}

void sub_1B793E924(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_OOTF_qtApprox::~HgcBT2100_PQ_OOTF_qtApprox(HGNode *this)
{
  *(void *)this = &unk_1F10F89A0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40FDACBBE0);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F89A0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40FDACBBE0);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_OOTF_qtApprox::SetParameter(HgcBT2100_PQ_OOTF_qtApprox *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcBT2100_PQ_OOTF_qtApprox::GetParameter(HgcBT2100_PQ_OOTF_qtApprox *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcBT2100_PQ_InverseOOTF::GetProgram(HgcBT2100_PQ_InverseOOTF *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000413\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r0.xyz, half3(hg_Params[1].xxx));\n"
             "    r0.xyz = r1.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[0].zzz);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[1].yyy));\n"
             "    r1.xyz = half3(half3(hg_Params[0].www) < r1.xyz);\n"
             "    output.color0.xyz = select(float3(r2.xyz), float3(r0.xyz), -float3(r1.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a5d8e794:3395fdf7:d7923219:174ddda5\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003c7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r0.xyz, hg_Params[1].xxx);\n"
             "    r0.xyz = r1.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = r1.xyz*hg_Params[0].zzz;\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
             "    r1.xyz = float3(hg_Params[0].www < r1.xyz);\n"
             "    output.color0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2f1f52de:ad2f008b:df44194e:84e296bb\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000403\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r0.xyz, hg_ProgramLocal1.xxx);\n"
           "    r0.xyz = r1.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal0.zzz;\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal1.yyy);\n"
           "    r1.xyz = vec3(lessThan(hg_ProgramLocal0.www, r1.xyz));\n"
           "    gl_FragColor.xyz = vec3(-r1.x < 0.00000 ? r0.x : r2.x, -r1.y < 0.00000 ? r0.y : r2.y, -r1.z < 0.00000 ? r"
           "0.z : r2.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=b9a478a9:481ead68:896d40e0:012e2e2e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_InverseOOTF::InitProgramDescriptor(HgcBT2100_PQ_InverseOOTF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_InverseOOTF_hgc_visible", "//Metal1.0     \n//LEN=00000002a9\n[[ visible ]] FragmentOut HgcBT2100_PQ_InverseOOTF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r0.xyz, hg_Params[1].xxx);\n"
    "    r0.xyz = r1.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = r1.xyz*hg_Params[0].zzz;\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
    "    r1.xyz = float3(hg_Params[0].www < r1.xyz);\n"
    "    output.color0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2100_PQ_InverseOOTF");
}

void sub_1B793EDA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B793EDD0(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B793EDC8);
}

double HgcBT2100_PQ_InverseOOTF::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D70;
  strcpy(v3, "HgcBT2100_PQ_InverseOOTF [hgc1]");
  return *(double *)"verseOOTF [hgc1]";
}

uint64_t HgcBT2100_PQ_InverseOOTF::BindTexture(HgcBT2100_PQ_InverseOOTF *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_InverseOOTF::Bind(HgcBT2100_PQ_InverseOOTF *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2100_PQ_InverseOOTF::RenderTile(HgcBT2100_PQ_InverseOOTF *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    int v3 = 0;
    uint64_t v4 = *((void *)a2 + 10);
    uint64_t v5 = 16 * *((int *)a2 + 22);
    uint64_t v6 = *((void *)a2 + 2);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    do
    {
      uint64_t v9 = 0;
      do
      {
        float32x4_t v10 = *(float32x4_t *)(v4 + v9);
        float32x4_t v11 = (_OWORD *)*((void *)this + 51);
        float32x4_t v12 = *((float32x4_t *)v11 + 2);
        int8x16_t v13 = *((int8x16_t *)v11 + 3);
        long long v14 = v11[1];
        float32x4_t v15 = *((float32x4_t *)v11 + 4);
        int8x16_t v16 = *((int8x16_t *)v11 + 5);
        float32x4_t v17 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v14, 0), v12)), v12), (int8x16_t)v15, vbslq_s8(v13, (int8x16_t)v10, (int8x16_t)vmaxq_f32(v10, v12)));
        float32x4_t v18 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v17, v16), (int8x16_t)v15);
        float32x4_t v19 = *((float32x4_t *)v11 + 6);
        int8x16_t v20 = *((int8x16_t *)v11 + 7);
        float32x4_t v21 = *((float32x4_t *)v11 + 8);
        float32x4_t v22 = *((float32x4_t *)v11 + 9);
        float32x4_t v23 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v18, v22));
        float32x4_t v24 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v19, v17))), v21), v23);
        float32x4_t v25 = *((float32x4_t *)v11 + 10);
        float32x4_t v26 = *((float32x4_t *)v11 + 11);
        float32x4_t v27 = vsubq_f32(vsubq_f32(v18, v15), vmulq_f32(vmulq_f32(v25, v23), v18));
        float32x4_t v28 = vmulq_f32(v27, v27);
        float32x4_t v29 = *((float32x4_t *)v11 + 12);
        float32x4_t v30 = *((float32x4_t *)v11 + 13);
        float32x4_t v31 = *((float32x4_t *)v11 + 14);
        float32x4_t v32 = *((float32x4_t *)v11 + 15);
        float32x4_t v33 = *((float32x4_t *)v11 + 16);
        float32x4_t v34 = *((float32x4_t *)v11 + 17);
        float32x4_t v35 = vmulq_n_f32(vaddq_f32(v24, vmulq_f32(v27, vaddq_f32(v34, vmulq_f32(v27, vaddq_f32(vaddq_f32(v32, vmulq_f32(v27, v33)), vmulq_f32(v28, vaddq_f32(vaddq_f32(v26, vmulq_f32(v29, v27)), vmulq_f32(v28, vaddq_f32(v30, vmulq_f32(v31, v27)))))))))), *(float *)&v14);
        float32x4_t v36 = *((float32x4_t *)v11 + 18);
        float32x4_t v37 = *((float32x4_t *)v11 + 19);
        float32x4_t v38 = vmaxq_f32(v35, v36);
        float32x4_t v39 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
        float32x4_t v40 = vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v39, v38)));
        float32x4_t v41 = vsubq_f32(v38, v40);
        float32x4_t v42 = *((float32x4_t *)v11 + 20);
        float32x4_t v43 = *((float32x4_t *)v11 + 21);
        float32x4_t v44 = *((float32x4_t *)v11 + 22);
        float32x4_t v45 = *((float32x4_t *)v11 + 23);
        int32x4_t v46 = *((int32x4_t *)v11 + 24);
        float32x4_t v47 = vmulq_f32(vaddq_f32(v15, vmulq_f32(v41, vaddq_f32(v45, vmulq_f32(v41, vaddq_f32(vaddq_f32(v43, vmulq_f32(v44, v41)), vmulq_f32(vmulq_f32(v41, v41), vaddq_f32(v37, vmulq_f32(v42, v41)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v46, vcvtq_s32_f32(v40)), 0x17uLL));
        float32x4_t v48 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v14, 1), v12)), v12), (int8x16_t)v15, vbslq_s8(v13, (int8x16_t)v10, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11, 1), vmulq_n_f32(v47, COERCE_FLOAT(*v11)))));
        float32x4_t v49 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v48, v16), (int8x16_t)v15);
        float32x4_t v50 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v48, 0x17uLL)), (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v19, v48))), v21);
        float32x4_t v51 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v49, v22));
        float32x4_t v52 = vaddq_f32(v50, v51);
        float32x4_t v53 = vsubq_f32(vsubq_f32(v49, v15), vmulq_f32(vmulq_f32(v25, v51), v49));
        float32x4_t v54 = vmulq_f32(v53, v53);
        float32x4_t v55 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v52, vmulq_f32(v53, vaddq_f32(v34, vmulq_f32(v53, vaddq_f32(vaddq_f32(v32, vmulq_f32(v33, v53)), vmulq_f32(v54, vaddq_f32(vaddq_f32(v26, vmulq_f32(v29, v53)), vmulq_f32(v54, vaddq_f32(v30, vmulq_f32(v31, v53)))))))))), *(float32x2_t *)&v14, 1), v36);
        float32x4_t v56 = vcvtq_f32_s32(vcvtq_s32_f32(v55));
        float32x4_t v57 = vsubq_f32(v56, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v56, v55)));
        float32x4_t v58 = vsubq_f32(v55, v57);
        *(int8x16_t *)(v6 + v9) = vbslq_s8(v13, (int8x16_t)v10, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v47, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v11, 3))), v12), vbslq_s8(v13, (int8x16_t)v10, (int8x16_t)vmulq_f32(vaddq_f32(v15, vmulq_f32(
                                                         v58,
                                                         vaddq_f32(v45, vmulq_f32(v58, vaddq_f32(vaddq_f32(v43, vmulq_f32(v44, v58)), vmulq_f32(vmulq_f32(v58, v58), vaddq_f32(v37, vmulq_f32(v42, v58)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v57), v46), 0x17uLL))), (int8x16_t)vmulq_laneq_f32(v47, *(float32x4_t *)v11, 2)));
        v9 += 16;
      }
      while (v8 != v9);
      ++v3;
      v4 += v5;
      v6 += v7;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcBT2100_PQ_InverseOOTF::GetDOD(HgcBT2100_PQ_InverseOOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2100_PQ_InverseOOTF::GetROI(HgcBT2100_PQ_InverseOOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2100_PQ_InverseOOTF::HgcBT2100_PQ_InverseOOTF(HgcBT2100_PQ_InverseOOTF *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F8C08;
  operator new();
}

void sub_1B793F484(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_InverseOOTF::~HgcBT2100_PQ_InverseOOTF(HGNode *this)
{
  *(void *)this = &unk_1F10F8C08;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C402BC884A0);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F8C08;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C402BC884A0);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_InverseOOTF::SetParameter(HgcBT2100_PQ_InverseOOTF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  float32x4_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_PQ_InverseOOTF::GetParameter(HgcBT2100_PQ_InverseOOTF *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_PQ_OETF::GetProgram(HgcBT2100_PQ_OETF *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004c8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[0].zzz);\n"
             "    r0.xyz = pow(r1.xyz, half3(hg_Params[1].xxx));\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = half3(half3(hg_Params[0].www) < r1.xyz);\n"
             "    r0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000h);\n"
             "    r1.xyz = pow(r0.xyz, half3(hg_Params[1].yyy));\n"
             "    r0.xyz = r1.xyz*half3(hg_Params[2].zzz) + c0.yyy;\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[2].yyy) + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    output.color0.xyz = pow(float3(r0.xyz), hg_Params[1].zzz);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d5425b59:33d8338b:91a6001c:97c5c49c\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000477\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz*hg_Params[0].zzz;\n"
             "    r0.xyz = pow(r1.xyz, hg_Params[1].xxx);\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r1.xyz = float3(hg_Params[0].www < r1.xyz);\n"
             "    r0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
             "    r1.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
             "    r0.xyz = r1.xyz*hg_Params[2].zzz + c0.yyy;\n"
             "    r1.xyz = r1.xyz*hg_Params[2].yyy + hg_Params[2].xxx;\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    output.color0.xyz = pow(r0.xyz, hg_Params[1].zzz);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=67636bc1:21de775e:88d8bf75:0b21046f\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004e8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal0.zzz;\n"
           "    r0.xyz = pow(r1.xyz, hg_ProgramLocal1.xxx);\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = vec3(lessThan(hg_ProgramLocal0.www, r1.xyz));\n"
           "    r0.xyz = vec3(-r1.x < 0.00000 ? r0.x : r2.x, -r1.y < 0.00000 ? r0.y : r2.y, -r1.z < 0.00000 ? r0.z : r2.z"
           ");\n"
           "    r1.xyz = pow(r0.xyz, hg_ProgramLocal1.yyy);\n"
           "    r0.xyz = r1.xyz*hg_ProgramLocal2.zzz + c0.yyy;\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal2.yyy + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r1.xyz/r0.xyz;\n"
           "    gl_FragColor.xyz = pow(r0.xyz, hg_ProgramLocal1.zzz);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=95633a79:b3a4b859:c6f0cae4:5db01d33\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_OETF::InitProgramDescriptor(HgcBT2100_PQ_OETF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_OETF_hgc_visible", "//Metal1.0     \n//LEN=0000000352\n[[ visible ]] FragmentOut HgcBT2100_PQ_OETF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz*hg_Params[0].zzz;\n"
    "    r0.xyz = pow(r1.xyz, hg_Params[1].xxx);\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r1.xyz = float3(hg_Params[0].www < r1.xyz);\n"
    "    r0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
    "    r1.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
    "    r0.xyz = r1.xyz*hg_Params[2].zzz + c0.yyy;\n"
    "    r1.xyz = r1.xyz*hg_Params[2].yyy + hg_Params[2].xxx;\n"
    "    r0.xyz = r1.xyz/r0.xyz;\n"
    "    output.color0.xyz = pow(r0.xyz, hg_Params[1].zzz);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2100_PQ_OETF");
}

void sub_1B793F924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B793F954(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B793F94CLL);
}

char *HgcBT2100_PQ_OETF::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8349210;
  strcpy(result, "HgcBT2100_PQ_OETF [hgc1]");
  return result;
}

uint64_t HgcBT2100_PQ_OETF::BindTexture(HgcBT2100_PQ_OETF *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_OETF::Bind(HgcBT2100_PQ_OETF *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2100_PQ_OETF::RenderTile(HgcBT2100_PQ_OETF *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    int v3 = 0;
    uint64_t v4 = *((void *)a2 + 10);
    uint64_t v5 = 16 * *((int *)a2 + 22);
    uint64_t v6 = *((void *)a2 + 2);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    do
    {
      uint64_t v9 = 0;
      do
      {
        float32x4_t v10 = *(float32x4_t *)(v4 + v9);
        float32x4_t v11 = (_OWORD *)*((void *)this + 51);
        float32x4_t v12 = *((float32x4_t *)v11 + 1);
        float32x4_t v14 = *((float32x4_t *)v11 + 2);
        float32x4_t v13 = *((float32x4_t *)v11 + 3);
        float32x4_t v15 = *((float32x4_t *)v11 + 4);
        int8x16_t v16 = *((int8x16_t *)v11 + 5);
        float32x4_t v17 = vmaxq_f32(v10, v13);
        float32x4_t v18 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 0), v13)), v13), (int8x16_t)v15, (int8x16_t)v17);
        float32x4_t v19 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v18), (int8x16_t)v15);
        float32x4_t v20 = *((float32x4_t *)v11 + 6);
        int8x16_t v21 = *((int8x16_t *)v11 + 7);
        float32x4_t v22 = *((float32x4_t *)v11 + 8);
        float32x4_t v23 = *((float32x4_t *)v11 + 9);
        float32x4_t v24 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v19, v23));
        float32x4_t v25 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v20, v18))), v22);
        float32x4_t v27 = *((float32x4_t *)v11 + 10);
        float32x4_t v26 = *((float32x4_t *)v11 + 11);
        float32x4_t v28 = vsubq_f32(vsubq_f32(v19, v15), vmulq_f32(vmulq_f32(v27, v24), v19));
        float32x4_t v29 = vmulq_f32(v28, v28);
        float32x4_t v31 = *((float32x4_t *)v11 + 12);
        float32x4_t v30 = *((float32x4_t *)v11 + 13);
        float32x4_t v33 = *((float32x4_t *)v11 + 14);
        float32x4_t v32 = *((float32x4_t *)v11 + 15);
        float32x4_t v35 = *((float32x4_t *)v11 + 16);
        float32x4_t v34 = *((float32x4_t *)v11 + 17);
        float32x4_t v36 = vmulq_n_f32(vaddq_f32(vaddq_f32(v25, v24), vmulq_f32(v28, vaddq_f32(v34, vmulq_f32(v28, vaddq_f32(vaddq_f32(v32, vmulq_f32(v35, v28)), vmulq_f32(v29, vaddq_f32(vaddq_f32(v26, vmulq_f32(v31, v28)), vmulq_f32(v29, vaddq_f32(v30, vmulq_f32(v33, v28)))))))))), v12.f32[0]);
        float32x4_t v38 = *((float32x4_t *)v11 + 18);
        float32x4_t v37 = *((float32x4_t *)v11 + 19);
        float32x4_t v39 = vmaxq_f32(v36, v38);
        float32x4_t v40 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
        float32x4_t v41 = vsubq_f32(v40, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v40, v39)));
        float32x4_t v42 = vsubq_f32(v39, v41);
        float32x4_t v44 = *((float32x4_t *)v11 + 20);
        float32x4_t v43 = *((float32x4_t *)v11 + 21);
        float32x4_t v46 = *((float32x4_t *)v11 + 22);
        float32x4_t v45 = *((float32x4_t *)v11 + 23);
        float32x4_t v47 = vaddq_f32(v15, vmulq_f32(v42, vaddq_f32(v45, vmulq_f32(v42, vaddq_f32(vaddq_f32(v43, vmulq_f32(v46, v42)), vmulq_f32(vmulq_f32(v42, v42), vaddq_f32(v37, vmulq_f32(v44, v42))))))));
        int32x4_t v48 = vcvtq_s32_f32(v41);
        int32x4_t v50 = *((int32x4_t *)v11 + 24);
        int8x16_t v49 = *((int8x16_t *)v11 + 25);
        float32x4_t v51 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1), v13)), v13), (int8x16_t)v15, vbslq_s8(v49, (int8x16_t)v10, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v17,
                                                                          (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v11, 3))), v13), vbslq_s8(v49, (int8x16_t)v10, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11, 1), vmulq_n_f32((float32x4_t)vbslq_s8(v49, (int8x16_t)v10, (int8x16_t)vmulq_f32(v47, (float32x4_t)vshlq_n_s32(vaddq_s32(v50, v48), 0x17uLL))), COERCE_FLOAT(*v11)))), (int8x16_t)vmulq_laneq_f32(v17, *(float32x4_t *)v11, 2))));
        float32x4_t v52 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v51, v16), (int8x16_t)v15);
        float32x4_t v53 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v52, v23));
        float32x4_t v54 = vsubq_f32(vsubq_f32(v52, v15), vmulq_f32(vmulq_f32(v27, v53), v52));
        float32x4_t v55 = vmulq_f32(v54, v54);
        float32x4_t v56 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v51, 0x17uLL)), (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v20, v51))), v22), v53), vmulq_f32(v54, vaddq_f32(v34, vmulq_f32(v54, vaddq_f32(vaddq_f32(v32, vmulq_f32(v35, v54)), vmulq_f32(v55,
                              vaddq_f32(vaddq_f32(v26, vmulq_f32(v31, v54)), vmulq_f32(v55, vaddq_f32(v30, vmulq_f32(v33, v54)))))))))), *(float32x2_t *)v12.f32, 1), v38);
        float32x4_t v57 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
        float32x4_t v58 = vsubq_f32(v57, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v57, v56)));
        float32x4_t v59 = vsubq_f32(v56, v58);
        float32x4_t v60 = vmulq_f32(vaddq_f32(v15, vmulq_f32(v59, vaddq_f32(v45, vmulq_f32(v59, vaddq_f32(vaddq_f32(v43, vmulq_f32(v46, v59)), vmulq_f32(vmulq_f32(v59, v59), vaddq_f32(v37, vmulq_f32(v44, v59)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v58), v50), 0x17uLL));
        float32x4_t v61 = (float32x4_t)vbslq_s8(v49, (int8x16_t)v10, (int8x16_t)vaddq_f32(v15, vmulq_laneq_f32(v60, v14, 2)));
        float32x4_t v62 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 0);
        float32x4_t v63 = vmulq_lane_f32(v60, *(float32x2_t *)v14.f32, 1);
        float32x4_t v64 = *((float32x4_t *)v11 + 26);
        float32x4_t v65 = *((float32x4_t *)v11 + 27);
        float32x4_t v66 = vminq_f32(vmaxq_f32(vrecpeq_f32(v61), v64), v65);
        float32x4_t v67 = vminq_f32(vmaxq_f32(vmulq_f32(v66, vrecpsq_f32(v61, v66)), v64), v65);
        float32x4_t v68 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vceqq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), v13)), v13), (int8x16_t)v15, vbslq_s8(v49, (int8x16_t)v10, (int8x16_t)vmulq_f32(vmulq_f32(v67, vrecpsq_f32(v61, v67)), vaddq_f32(v62, v63))));
        float32x4_t v69 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v68, v16), (int8x16_t)v15);
        float32x4_t v70 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v69, v23));
        float32x4_t v71 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v20, v68))), v22);
        float32x4_t v72 = vsubq_f32(vsubq_f32(v69, v15), vmulq_f32(vmulq_f32(v27, v70), v69));
        float32x4_t v73 = vmulq_f32(v72, v72);
        float32x4_t v74 = vmaxq_f32(vmulq_laneq_f32(vaddq_f32(vaddq_f32(v71, v70), vmulq_f32(v72, vaddq_f32(v34, vmulq_f32(v72, vaddq_f32(vaddq_f32(v32, vmulq_f32(v35, v72)), vmulq_f32(v73, vaddq_f32(vaddq_f32(v26, vmulq_f32(v31, v72)), vmulq_f32(v73, vaddq_f32(v30, vmulq_f32(v33, v72)))))))))), v12, 2), v38);
        float32x4_t v75 = vcvtq_f32_s32(vcvtq_s32_f32(v74));
        float32x4_t v76 = vsubq_f32(v75, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v75, v74)));
        float32x4_t v77 = vsubq_f32(v74, v76);
        *(int8x16_t *)(v6 + v9) = vbslq_s8(v49, (int8x16_t)v10, (int8x16_t)vmulq_f32(vaddq_f32(v15, vmulq_f32(v77, vaddq_f32(v45, vmulq_f32(v77, vaddq_f32(vaddq_f32(v43, vmulq_f32(v46, v77)), vmulq_f32(vmulq_f32(v77, v77), vaddq_f32(v37, vmulq_f32(v44, v77)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v76), v50), 0x17uLL)));
        v9 += 16;
      }
      while (v8 != v9);
      ++v3;
      v4 += v5;
      v6 += v7;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcBT2100_PQ_OETF::GetDOD(HgcBT2100_PQ_OETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2100_PQ_OETF::GetROI(HgcBT2100_PQ_OETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2100_PQ_OETF::HgcBT2100_PQ_OETF(HgcBT2100_PQ_OETF *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F8E70;
  operator new();
}

void sub_1B7940180(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_OETF::~HgcBT2100_PQ_OETF(HGNode *this)
{
  *(void *)this = &unk_1F10F8E70;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40502CBA4ALL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F8E70;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40502CBA4ALL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_OETF::SetParameter(HgcBT2100_PQ_OETF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  float32x4_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_PQ_OETF::GetParameter(HgcBT2100_PQ_OETF *this, unsigned int a2, float *a3)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_PQ_OETF_qtApprox::GetProgram(HgcBT2100_PQ_OETF_qtApprox *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ae\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r0.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz*half3(hg_Params[1].zzz) + c0.yyy;\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[1].yyy) + half3(hg_Params[1].xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    output.color0.xyz = pow(float3(r0.xyz), hg_Params[0].yyy);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2444afad:3db4a253:10709704:a6232534\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000037f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r0.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz*hg_Params[1].zzz + c0.yyy;\n"
             "    r1.xyz = r1.xyz*hg_Params[1].yyy + hg_Params[1].xxx;\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    output.color0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=81f92e6d:ccf1bbeb:6804da4c:060ade07\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000379\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r0.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz*hg_ProgramLocal1.zzz + c0.yyy;\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal1.yyy + hg_ProgramLocal1.xxx;\n"
           "    r0.xyz = r1.xyz/r0.xyz;\n"
           "    gl_FragColor.xyz = pow(r0.xyz, hg_ProgramLocal0.yyy);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=5ec190f3:0ef06f06:f7c965f7:c1522525\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_OETF_qtApprox::InitProgramDescriptor(HgcBT2100_PQ_OETF_qtApprox *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_OETF_qtApprox_hgc_visible", "//Metal1.0     \n//LEN=0000000263\n[[ visible ]] FragmentOut HgcBT2100_PQ_OETF_qtApprox_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r1.xyz = pow(r0.xyz, hg_Params[0].xxx);\n"
    "    r0.xyz = r1.xyz*hg_Params[1].zzz + c0.yyy;\n"
    "    r1.xyz = r1.xyz*hg_Params[1].yyy + hg_Params[1].xxx;\n"
    "    r0.xyz = r1.xyz/r0.xyz;\n"
    "    output.color0.xyz = pow(r0.xyz, hg_Params[0].yyy);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2100_PQ_OETF_qtApprox");
}

void sub_1B7940620(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7940650(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7940648);
}

char *HgcBT2100_PQ_OETF_qtApprox::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8376030;
  strcpy(result, "HgcBT2100_PQ_OETF_qtApprox [hgc1]");
  return result;
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::BindTexture(HgcBT2100_PQ_OETF_qtApprox *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::Bind(HgcBT2100_PQ_OETF_qtApprox *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::RenderTile(HgcBT2100_PQ_OETF_qtApprox *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v101 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v11 = (_OWORD *)*((void *)this + 51);
      float32x4_t v12 = *((float32x4_t *)v11 + 2);
      int8x16_t v13 = *((int8x16_t *)v11 + 3);
      float32x4_t v14 = *(float32x4_t *)(v6 + v10);
      float32x4_t v15 = *((float32x4_t *)v11 + 1);
      float32x4_t v158 = v12;
      float32x4_t v16 = *((float32x4_t *)v11 + 4);
      int8x16_t v17 = *((int8x16_t *)v11 + 5);
      int8x16_t v18 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11, 0), v158)), v158);
      float32x4_t v19 = (float32x4_t)vbslq_s8(v18, (int8x16_t)v16, vbslq_s8(v13, *(int8x16_t *)(v6 + v10 - 16), (int8x16_t)vmaxq_f32(*(float32x4_t *)(v6 + v10 - 16), v12)));
      float32x4_t v20 = (float32x4_t)vbslq_s8(v18, (int8x16_t)v16, vbslq_s8(v13, (int8x16_t)v14, (int8x16_t)vmaxq_f32(v14, v12)));
      float32x4_t v21 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v19, v17), (int8x16_t)v16);
      float32x4_t v23 = *((float32x4_t *)v11 + 6);
      int8x16_t v22 = *((int8x16_t *)v11 + 7);
      float32x4_t v24 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v20, v17), (int8x16_t)v16);
      float32x4_t v26 = *((float32x4_t *)v11 + 8);
      float32x4_t v25 = *((float32x4_t *)v11 + 9);
      float32x4_t v27 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v21, v25));
      float32x4_t v28 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v24, v25));
      float32x4_t v29 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v23, v19))), v26), v27);
      float32x4_t v30 = *((float32x4_t *)v11 + 10);
      float32x4_t v160 = *((float32x4_t *)v11 + 11);
      float32x4_t v31 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v20, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v23, v20))), v26), v28);
      float32x4_t v32 = vsubq_f32(vsubq_f32(v21, v16), vmulq_f32(vmulq_f32(v30, v27), v21));
      float32x4_t v33 = vsubq_f32(vsubq_f32(v24, v16), vmulq_f32(vmulq_f32(v30, v28), v24));
      float32x4_t v34 = vmulq_f32(v32, v32);
      float32x4_t v35 = vmulq_f32(v33, v33);
      float32x4_t v37 = *((float32x4_t *)v11 + 12);
      float32x4_t v36 = *((float32x4_t *)v11 + 13);
      float32x4_t v39 = *((float32x4_t *)v11 + 14);
      float32x4_t v38 = *((float32x4_t *)v11 + 15);
      float32x4_t v41 = *((float32x4_t *)v11 + 16);
      float32x4_t v40 = *((float32x4_t *)v11 + 17);
      float32x4_t v42 = vaddq_f32(v31, vmulq_f32(v33, vaddq_f32(v40, vmulq_f32(v33, vaddq_f32(vaddq_f32(v38, vmulq_f32(v33, v41)), vmulq_f32(v35, vaddq_f32(vaddq_f32(v160, vmulq_f32(v37, v33)), vmulq_f32(v35, vaddq_f32(v36, vmulq_f32(v39, v33))))))))));
      float32x4_t v43 = *((float32x4_t *)v11 + 18);
      float32x4_t v159 = *((float32x4_t *)v11 + 19);
      float32x4_t v44 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v29, vmulq_f32(v32, vaddq_f32(v40, vmulq_f32(v32, vaddq_f32(vaddq_f32(v38, vmulq_f32(v32, v41)), vmulq_f32(v34, vaddq_f32(vaddq_f32(v160, vmulq_f32(v37, v32)), vmulq_f32(v34, vaddq_f32(v36, vmulq_f32(v39, v32)))))))))), COERCE_FLOAT(*v11)), v43);
      float32x4_t v45 = vmaxq_f32(vmulq_n_f32(v42, COERCE_FLOAT(*v11)), v43);
      float32x4_t v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
      float32x4_t v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      float32x4_t v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v46, v44)));
      float32x4_t v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v47, v45)));
      float32x4_t v50 = vsubq_f32(v44, v48);
      float32x4_t v51 = vsubq_f32(v45, v49);
      float32x4_t v53 = *((float32x4_t *)v11 + 20);
      float32x4_t v52 = *((float32x4_t *)v11 + 21);
      float32x4_t v55 = *((float32x4_t *)v11 + 22);
      float32x4_t v54 = *((float32x4_t *)v11 + 23);
      float32x4_t v56 = vmulq_f32(v51, vaddq_f32(v54, vmulq_f32(v51, vaddq_f32(vaddq_f32(v52, vmulq_f32(v55, v51)), vmulq_f32(vmulq_f32(v51, v51), vaddq_f32(v159, vmulq_f32(v53, v51)))))));
      int32x4_t v57 = vcvtq_s32_f32(v48);
      int32x4_t v58 = *((int32x4_t *)v11 + 24);
      float32x4_t v59 = *((float32x4_t *)v11 + 25);
      float32x4_t v60 = vmulq_f32(vaddq_f32(v16, vmulq_f32(v50, vaddq_f32(v54, vmulq_f32(v50, vaddq_f32(vaddq_f32(v52, vmulq_f32(v50, v55)), vmulq_f32(vmulq_f32(v50, v50), vaddq_f32(v159, vmulq_f32(v53, v50)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, v57), 0x17uLL));
      float32x4_t v61 = vmulq_f32(vaddq_f32(v16, v56), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v49)), 0x17uLL));
      int8x16_t v62 = *(int8x16_t *)(v6 + v10 - 16);
      int8x16_t v63 = v13;
      float32x4_t v64 = (float32x4_t)vbslq_s8(v13, v62, (int8x16_t)vaddq_f32(v16, vmulq_laneq_f32(v60, v15, 2)));
      float32x4_t v65 = *((float32x4_t *)v11 + 26);
      float32x4_t v66 = vminq_f32(vmaxq_f32(vrecpeq_f32(v64), v59), v65);
      float32x4_t v67 = vmulq_f32(v66, vrecpsq_f32(v64, v66));
      float32x4_t v68 = (float32x4_t)vbslq_s8(v13, (int8x16_t)v14, (int8x16_t)vaddq_f32(v16, vmulq_laneq_f32(v61, v15, 2)));
      float32x4_t v69 = vminq_f32(vmaxq_f32(vrecpeq_f32(v68), v59), v65);
      float32x4_t v70 = vmulq_lane_f32(v60, *(float32x2_t *)v15.f32, 1);
      float32x4_t v71 = vmulq_lane_f32(v61, *(float32x2_t *)v15.f32, 1);
      float32x4_t v72 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 0);
      float32x4_t v73 = vminq_f32(vmaxq_f32(v67, v59), v65);
      float32x4_t v74 = vminq_f32(vmaxq_f32(vmulq_f32(v69, vrecpsq_f32(v68, v69)), v59), v65);
      int8x16_t v75 = (int8x16_t)vmulq_f32(vaddq_f32(v72, v71), vmulq_f32(v74, vrecpsq_f32(v68, v74)));
      int8x16_t v76 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11, 1), v158)), v158);
      int8x16_t v77 = vbslq_s8(v63, v62, (int8x16_t)vmulq_f32(vaddq_f32(v72, v70), vmulq_f32(v73, vrecpsq_f32(v64, v73))));
      int8x16_t v78 = *((int8x16_t *)v11 + 3);
      float32x4_t v79 = (float32x4_t)vbslq_s8(v76, (int8x16_t)v16, v77);
      float32x4_t v80 = (float32x4_t)vbslq_s8(v76, (int8x16_t)v16, vbslq_s8(v63, *(int8x16_t *)(v6 + v10), v75));
      float32x4_t v81 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v79, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v23, v79)));
      float32x4_t v82 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v79, v17), (int8x16_t)v16);
      float32x4_t v83 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v80, v17), (int8x16_t)v16);
      float32x4_t v84 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v82, v25));
      float32x4_t v85 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v83, v25));
      float32x4_t v86 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v80, 0x17uLL)), (float32x4_t)vandq_s8(v22, (int8x16_t)vcgtq_f32(v23, v80))), v26), v85);
      float32x4_t v87 = vsubq_f32(vsubq_f32(v82, v16), vmulq_f32(vmulq_f32(v30, v84), v82));
      float32x4_t v88 = vsubq_f32(vsubq_f32(v83, v16), vmulq_f32(vmulq_f32(v30, v85), v83));
      float32x4_t v89 = vmulq_f32(v87, v87);
      float32x4_t v90 = vmulq_f32(v88, v88);
      float32x4_t v91 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(v81, v26), v84), vmulq_f32(v87, vaddq_f32(v40, vmulq_f32(v87, vaddq_f32(vaddq_f32(v38, vmulq_f32(v41, v87)), vmulq_f32(v89, vaddq_f32(vaddq_f32(v160, vmulq_f32(v37, v87)), vmulq_f32(v89, vaddq_f32(v36, vmulq_f32(v39, v87)))))))))), *(float32x2_t *)v11, 1), v43);
      float32x4_t v92 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v86, vmulq_f32(v88, vaddq_f32(v40, vmulq_f32(v88, vaddq_f32(vaddq_f32(v38, vmulq_f32(v41, v88)), vmulq_f32(v90, vaddq_f32(vaddq_f32(v160, vmulq_f32(v37, v88)), vmulq_f32(v90, vaddq_f32(v36, vmulq_f32(v39, v88)))))))))), *(float32x2_t *)v11, 1), v43);
      float32x4_t v93 = vcvtq_f32_s32(vcvtq_s32_f32(v91));
      float32x4_t v94 = vcvtq_f32_s32(vcvtq_s32_f32(v92));
      float32x4_t v95 = vsubq_f32(v93, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v93, v91)));
      float32x4_t v96 = vsubq_f32(v94, (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v94, v92)));
      float32x4_t v97 = vsubq_f32(v91, v95);
      float32x4_t v98 = vsubq_f32(v92, v96);
      int8x16_t v99 = vbslq_s8(v78, *(int8x16_t *)(v6 + v10), (int8x16_t)vmulq_f32(vaddq_f32(v16, vmulq_f32(v98, vaddq_f32(v54, vmulq_f32(v98, vaddq_f32(vaddq_f32(v52, vmulq_f32(v55, v98)), vmulq_f32(vmulq_f32(v98, v98), vaddq_f32(v159, vmulq_f32(v53, v98)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v96), v58), 0x17uLL)));
      float32x4_t v100 = (int8x16_t *)(v5 + v10);
      v100[-1] = vbslq_s8(v78, v62, (int8x16_t)vmulq_f32(vaddq_f32(v16, vmulq_f32(v97, vaddq_f32(v54, vmulq_f32(v97, vaddq_f32(vaddq_f32(v52, vmulq_f32(v55, v97)), vmulq_f32(vmulq_f32(v97, v97), vaddq_f32(v159, vmulq_f32(v53, v97)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v95), v58), 0x17uLL)));
      *float32x4_t v100 = v99;
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v101 = -v9;
    if (v101 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v102 = 16 * v101;
    float32x4_t v103 = *(float32x4_t *)(v6 + v102);
    float32x4_t v104 = (_OWORD *)*((void *)this + 51);
    float32x4_t v106 = *((float32x4_t *)v104 + 2);
    int8x16_t v105 = *((int8x16_t *)v104 + 3);
    float32x4_t v107 = *((float32x4_t *)v104 + 1);
    float32x4_t v108 = *((float32x4_t *)v104 + 4);
    int8x16_t v109 = *((int8x16_t *)v104 + 5);
    float32x4_t v110 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v108, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v104, 0), v106)), v106), (int8x16_t)v108, vbslq_s8(v105, (int8x16_t)v103, (int8x16_t)vmaxq_f32(v103, v106)));
    float32x4_t v111 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v110, v109), (int8x16_t)v108);
    float32x4_t v112 = *((float32x4_t *)v104 + 6);
    int8x16_t v113 = *((int8x16_t *)v104 + 7);
    float32x4_t v114 = *((float32x4_t *)v104 + 8);
    float32x4_t v115 = *((float32x4_t *)v104 + 9);
    float32x4_t v116 = (float32x4_t)vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(v111, v115));
    float32x4_t v117 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v110, 0x17uLL)), (float32x4_t)vandq_s8(v113, (int8x16_t)vcgtq_f32(v112, v110))), v114), v116);
    float32x4_t v118 = *((float32x4_t *)v104 + 10);
    float32x4_t v119 = *((float32x4_t *)v104 + 11);
    float32x4_t v120 = vsubq_f32(vsubq_f32(v111, v108), vmulq_f32(vmulq_f32(v118, v116), v111));
    float32x4_t v121 = vmulq_f32(v120, v120);
    float32x4_t v122 = *((float32x4_t *)v104 + 12);
    float32x4_t v123 = *((float32x4_t *)v104 + 13);
    float32x4_t v124 = *((float32x4_t *)v104 + 14);
    float32x4_t v125 = *((float32x4_t *)v104 + 15);
    float32x4_t v126 = *((float32x4_t *)v104 + 16);
    float32x4_t v127 = *((float32x4_t *)v104 + 17);
    float32x4_t v128 = vmulq_n_f32(vaddq_f32(v117, vmulq_f32(v120, vaddq_f32(v127, vmulq_f32(v120, vaddq_f32(vaddq_f32(v125, vmulq_f32(v120, v126)), vmulq_f32(v121, vaddq_f32(vaddq_f32(v119, vmulq_f32(v122, v120)), vmulq_f32(v121, vaddq_f32(v123, vmulq_f32(v124, v120)))))))))), COERCE_FLOAT(*v104));
    float32x4_t v129 = *((float32x4_t *)v104 + 18);
    float32x4_t v130 = *((float32x4_t *)v104 + 19);
    float32x4_t v131 = vmaxq_f32(v128, v129);
    float32x4_t v132 = vcvtq_f32_s32(vcvtq_s32_f32(v131));
    float32x4_t v133 = vsubq_f32(v132, (float32x4_t)vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(v132, v131)));
    float32x4_t v134 = vsubq_f32(v131, v133);
    float32x4_t v135 = *((float32x4_t *)v104 + 20);
    float32x4_t v136 = *((float32x4_t *)v104 + 21);
    float32x4_t v137 = *((float32x4_t *)v104 + 22);
    float32x4_t v138 = *((float32x4_t *)v104 + 23);
    int32x4_t v140 = *((int32x4_t *)v104 + 24);
    float32x4_t v139 = *((float32x4_t *)v104 + 25);
    float32x4_t v141 = vmulq_f32(vaddq_f32(v108, vmulq_f32(v134, vaddq_f32(v138, vmulq_f32(v134, vaddq_f32(vaddq_f32(v136, vmulq_f32(v137, v134)), vmulq_f32(vmulq_f32(v134, v134), vaddq_f32(v130, vmulq_f32(v135, v134)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v140, vcvtq_s32_f32(v133)), 0x17uLL));
    float32x4_t v142 = (float32x4_t)vbslq_s8(v105, (int8x16_t)v103, (int8x16_t)vaddq_f32(v108, vmulq_laneq_f32(v141, v107, 2)));
    float32x4_t v143 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v107.f32, 0), vmulq_lane_f32(v141, *(float32x2_t *)v107.f32, 1));
    float32x4_t v144 = *((float32x4_t *)v104 + 26);
    float32x4_t v145 = vminq_f32(vmaxq_f32(vrecpeq_f32(v142), v139), v144);
    float32x4_t v146 = vminq_f32(vmaxq_f32(vmulq_f32(v145, vrecpsq_f32(v142, v145)), v139), v144);
    float32x4_t v147 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v108, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v104, 1), v106)), v106), (int8x16_t)v108, vbslq_s8(v105, (int8x16_t)v103, (int8x16_t)vmulq_f32(v143, vmulq_f32(v146, vrecpsq_f32(v142, v146)))));
    float32x4_t v148 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v147, v109), (int8x16_t)v108);
    float32x4_t v149 = (float32x4_t)vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(v148, v115));
    float32x4_t v150 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v147, 0x17uLL)), (float32x4_t)vandq_s8(v113, (int8x16_t)vcgtq_f32(v112, v147))), v114), v149);
    float32x4_t v151 = vsubq_f32(vsubq_f32(v148, v108), vmulq_f32(vmulq_f32(v118, v149), v148));
    float32x4_t v152 = vmulq_f32(v151, v151);
    float32x4_t v153 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v150, vmulq_f32(v151, vaddq_f32(v127, vmulq_f32(v151, vaddq_f32(vaddq_f32(v125, vmulq_f32(v126, v151)), vmulq_f32(v152, vaddq_f32(vaddq_f32(v119, vmulq_f32(v122, v151)), vmulq_f32(v152, vaddq_f32(v123, vmulq_f32(v124, v151)))))))))), *(float32x2_t *)v104, 1), v129);
    float32x4_t v154 = vcvtq_f32_s32(vcvtq_s32_f32(v153));
    float32x4_t v155 = vsubq_f32(v154, (float32x4_t)vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(v154, v153)));
    float32x4_t v156 = vsubq_f32(v153, v155);
    *(int8x16_t *)(v5 + v102) = vbslq_s8(v105, (int8x16_t)v103, (int8x16_t)vmulq_f32(vaddq_f32(v108, vmulq_f32(v156, vaddq_f32(v138, vmulq_f32(v156, vaddq_f32(vaddq_f32(v136, vmulq_f32(v137, v156)), vmulq_f32(vmulq_f32(v156, v156), vaddq_f32(v130, vmulq_f32(v135, v156)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v155), v140), 0x17uLL)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::GetDOD(HgcBT2100_PQ_OETF_qtApprox *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::GetROI(HgcBT2100_PQ_OETF_qtApprox *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2100_PQ_OETF_qtApprox::HgcBT2100_PQ_OETF_qtApprox(HgcBT2100_PQ_OETF_qtApprox *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F90D8;
  operator new();
}

void sub_1B794122C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_OETF_qtApprox::~HgcBT2100_PQ_OETF_qtApprox(HGNode *this)
{
  *(void *)this = &unk_1F10F90D8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4003455651);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F90D8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4003455651);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::SetParameter(HgcBT2100_PQ_OETF_qtApprox *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_PQ_OETF_qtApprox::GetParameter(HgcBT2100_PQ_OETF_qtApprox *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_PQ_InverseOETF::GetProgram(HgcBT2100_PQ_InverseOETF *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000508\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = clamp(r0.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[1].yyy));\n"
             "    r1.xyz = r0.xyz - half3(hg_Params[0].xxx);\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].zzz) + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    r1.xyz = pow(r0.xyz, half3(hg_Params[1].xxx));\n"
             "    r0.xyz = r1.xyz*half3(hg_Params[2].xxx) + half3(hg_Params[2].yyy);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[2].zzz);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[1].zzz));\n"
             "    r1.xyz = half3(half3(hg_Params[2].www) < r1.xyz);\n"
             "    output.color0.xyz = select(float3(r2.xyz), float3(r0.xyz), -float3(r1.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1b378797:123e3885:5939c817:bd9b6770\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004a0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = clamp(r0.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
             "    r1.xyz = r0.xyz - hg_Params[0].xxx;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].zzz + hg_Params[0].yyy;\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    r1.xyz = pow(r0.xyz, hg_Params[1].xxx);\n"
             "    r0.xyz = r1.xyz*hg_Params[2].xxx + hg_Params[2].yyy;\n"
             "    r2.xyz = r1.xyz*hg_Params[2].zzz;\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[1].zzz);\n"
             "    r1.xyz = float3(hg_Params[2].www < r1.xyz);\n"
             "    output.color0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=a07f4f72:4373c56a:f9551245:ece12833\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000051b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = clamp(r0.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal1.yyy);\n"
           "    r1.xyz = r0.xyz - hg_ProgramLocal0.xxx;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.zzz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r0.xyz = r1.xyz/r0.xyz;\n"
           "    r1.xyz = pow(r0.xyz, hg_ProgramLocal1.xxx);\n"
           "    r0.xyz = r1.xyz*hg_ProgramLocal2.xxx + hg_ProgramLocal2.yyy;\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal2.zzz;\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal1.zzz);\n"
           "    r1.xyz = vec3(lessThan(hg_ProgramLocal2.www, r1.xyz));\n"
           "    gl_FragColor.xyz = vec3(-r1.x < 0.00000 ? r0.x : r2.x, -r1.y < 0.00000 ? r0.y : r2.y, -r1.z < 0.00000 ? r"
           "0.z : r2.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=4c6efd1c:68a5dad6:d015ee40:c1eec704\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_InverseOETF::InitProgramDescriptor(HgcBT2100_PQ_InverseOETF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_InverseOETF_hgc_visible", "//Metal1.0     \n//LEN=0000000382\n[[ visible ]] FragmentOut HgcBT2100_PQ_InverseOETF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = clamp(r0.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
    "    r1.xyz = r0.xyz - hg_Params[0].xxx;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].zzz + hg_Params[0].yyy;\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r0.xyz = r1.xyz/r0.xyz;\n"
    "    r1.xyz = pow(r0.xyz, hg_Params[1].xxx);\n"
    "    r0.xyz = r1.xyz*hg_Params[2].xxx + hg_Params[2].yyy;\n"
    "    r2.xyz = r1.xyz*hg_Params[2].zzz;\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[1].zzz);\n"
    "    r1.xyz = float3(hg_Params[2].www < r1.xyz);\n"
    "    output.color0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2100_PQ_InverseOETF");
}

void sub_1B79416D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7941700(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79416F8);
}

double HgcBT2100_PQ_InverseOETF::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D70;
  strcpy(v3, "HgcBT2100_PQ_InverseOETF [hgc1]");
  return *(double *)"verseOETF [hgc1]";
}

uint64_t HgcBT2100_PQ_InverseOETF::BindTexture(HgcBT2100_PQ_InverseOETF *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_InverseOETF::Bind(HgcBT2100_PQ_InverseOETF *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2100_PQ_InverseOETF::RenderTile(HgcBT2100_PQ_InverseOETF *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
  {
    int v3 = 0;
    uint64_t v4 = *((void *)a2 + 10);
    uint64_t v5 = 16 * *((int *)a2 + 22);
    uint64_t v6 = *((void *)a2 + 2);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    do
    {
      uint64_t v9 = 0;
      do
      {
        uint64_t v10 = *((void *)this + 51);
        float32x4_t v11 = *(float32x4_t *)(v10 + 16);
        float32x4_t v13 = *(float32x4_t *)(v10 + 32);
        float32x4_t v12 = *(float32x4_t *)(v10 + 48);
        float32x4_t v14 = *(float32x4_t *)(v10 + 64);
        int8x16_t v15 = *(int8x16_t *)(v10 + 80);
        int8x16_t v16 = (int8x16_t)vminq_f32(vmaxq_f32(*(float32x4_t *)(v4 + v9), v12), v14);
        float32x4_t v17 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1), v12)), v12), (int8x16_t)v14, v16);
        float32x4_t v19 = *(float32x4_t *)(v10 + 96);
        int8x16_t v18 = *(int8x16_t *)(v10 + 112);
        float32x4_t v20 = (float32x4_t)vorrq_s8(vandq_s8(v15, (int8x16_t)v17), (int8x16_t)v14);
        float32x4_t v21 = *(float32x4_t *)(v10 + 128);
        float32x4_t v22 = *(float32x4_t *)(v10 + 144);
        float32x4_t v23 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v18, (int8x16_t)vcgtq_f32(v19, v17)));
        float32x4_t v24 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v20, v22));
        float32x4_t v26 = *(float32x4_t *)(v10 + 160);
        float32x4_t v25 = *(float32x4_t *)(v10 + 176);
        float32x4_t v27 = vsubq_f32(vsubq_f32(v20, v14), vmulq_f32(vmulq_f32(v26, v24), v20));
        float32x4_t v29 = *(float32x4_t *)(v10 + 192);
        float32x4_t v28 = *(float32x4_t *)(v10 + 208);
        float32x4_t v30 = vmulq_f32(v27, v27);
        float32x4_t v32 = *(float32x4_t *)(v10 + 224);
        float32x4_t v31 = *(float32x4_t *)(v10 + 240);
        float32x4_t v34 = *(float32x4_t *)(v10 + 256);
        float32x4_t v33 = *(float32x4_t *)(v10 + 272);
        float32x4_t v35 = vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(v23, v21), v24), vmulq_f32(v27, vaddq_f32(v33, vmulq_f32(v27, vaddq_f32(vaddq_f32(v31, vmulq_f32(v34, v27)), vmulq_f32(v30, vaddq_f32(vaddq_f32(v25, vmulq_f32(v29, v27)), vmulq_f32(v30, vaddq_f32(v28, vmulq_f32(v32, v27)))))))))), *(float32x2_t *)v11.f32, 1);
        float32x4_t v37 = *(float32x4_t *)(v10 + 288);
        float32x4_t v36 = *(float32x4_t *)(v10 + 304);
        float32x4_t v38 = vmaxq_f32(v35, v37);
        float32x4_t v39 = vcvtq_f32_s32(vcvtq_s32_f32(v38));
        float32x4_t v40 = vsubq_f32(v39, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v39, v38)));
        float32x4_t v41 = vsubq_f32(v38, v40);
        float32x4_t v42 = *(float32x4_t *)(v10 + 320);
        float32x4_t v43 = *(float32x4_t *)(v10 + 336);
        float32x4_t v44 = *(float32x4_t *)(v10 + 352);
        float32x4_t v45 = *(float32x4_t *)(v10 + 368);
        float32x4_t v46 = vmulq_f32(v41, vaddq_f32(v45, vmulq_f32(v41, vaddq_f32(vaddq_f32(v43, vmulq_f32(v44, v41)), vmulq_f32(vmulq_f32(v41, v41), vaddq_f32(v36, vmulq_f32(v42, v41)))))));
        int32x4_t v47 = vcvtq_s32_f32(v40);
        int32x4_t v48 = *(int32x4_t *)(v10 + 384);
        int8x16_t v49 = *(int8x16_t *)(v10 + 400);
        float32x4_t v50 = (float32x4_t)vbslq_s8(v49, v16, (int8x16_t)vmulq_f32(vaddq_f32(v14, v46), (float32x4_t)vshlq_n_s32(vaddq_s32(v48, v47), 0x17uLL)));
        float32x4_t v51 = (float32x4_t)vbslq_s8(v49, v16, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10, 1), vmulq_laneq_f32(v50, *(float32x4_t *)v10, 2)));
        float32x4_t v52 = *(float32x4_t *)(v10 + 416);
        float32x4_t v53 = *(float32x4_t *)(v10 + 432);
        float32x4_t v54 = vminq_f32(vmaxq_f32(vrecpeq_f32(v51), v52), v53);
        float32x4_t v55 = vminq_f32(vmaxq_f32(vmulq_f32(v54, vrecpsq_f32(v51, v54)), v52), v53);
        float32x4_t v56 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 0), v12)), v12), (int8x16_t)v14, vbslq_s8(v49, v16, (int8x16_t)vmulq_f32(vmaxq_f32(vsubq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10, 0)), v12), vmulq_f32(v55, vrecpsq_f32(v51, v55)))));
        float32x4_t v57 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v56, v15), (int8x16_t)v14);
        float32x4_t v58 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v57, v22));
        float32x4_t v59 = vsubq_f32(vsubq_f32(v57, v14), vmulq_f32(vmulq_f32(v26, v58), v57));
        float32x4_t v60 = vmulq_f32(v59, v59);
        float32x4_t v61 = vmaxq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v56, 0x17uLL)), (float32x4_t)vandq_s8(v18, (int8x16_t)vcgtq_f32(v19, v56))), v21), v58), vmulq_f32(v59, vaddq_f32(v33, vmulq_f32(v59, vaddq_f32(vaddq_f32(v31, vmulq_f32(v34, v59)), vmulq_f32(v60,
                              vaddq_f32(vaddq_f32(v25, vmulq_f32(v29, v59)), vmulq_f32(v60, vaddq_f32(v28, vmulq_f32(v32, v59)))))))))), v11.f32[0]), v37);
        float32x4_t v62 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
        float32x4_t v63 = vsubq_f32(v62, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v62, v61)));
        float32x4_t v64 = vsubq_f32(v61, v63);
        float32x4_t v65 = vmulq_f32(vaddq_f32(v14, vmulq_f32(v64, vaddq_f32(v45, vmulq_f32(v64, vaddq_f32(vaddq_f32(v43, vmulq_f32(v44, v64)), vmulq_f32(vmulq_f32(v64, v64), vaddq_f32(v36, vmulq_f32(v42, v64)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v63), v48), 0x17uLL));
        float32x4_t v66 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vceqq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), v12)), v12), (int8x16_t)v14, vbslq_s8(v49, v16, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1), vmulq_n_f32(v65, v13.f32[0]))));
        float32x4_t v67 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v66, v15), (int8x16_t)v14);
        float32x4_t v68 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v66, 0x17uLL)), (float32x4_t)vandq_s8(v18, (int8x16_t)vcgtq_f32(v19, v66))), v21);
        float32x4_t v69 = (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v67, v22));
        float32x4_t v70 = vsubq_f32(vsubq_f32(v67, v14), vmulq_f32(vmulq_f32(v26, v69), v67));
        float32x4_t v71 = vmulq_f32(v70, v70);
        float32x4_t v72 = vmaxq_f32(vmulq_laneq_f32(vaddq_f32(vaddq_f32(v68, v69), vmulq_f32(v70, vaddq_f32(v33, vmulq_f32(v70, vaddq_f32(vaddq_f32(v31, vmulq_f32(v34, v70)), vmulq_f32(v71, vaddq_f32(vaddq_f32(v25, vmulq_f32(v29, v70)), vmulq_f32(v71, vaddq_f32(v28, vmulq_f32(v32, v70)))))))))), v11, 2), v37);
        float32x4_t v73 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
        float32x4_t v74 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v73, v72)));
        float32x4_t v75 = vsubq_f32(v72, v74);
        *(int8x16_t *)(v6 + v9) = vbslq_s8(v49, v16, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v14, (int8x16_t)vcgtq_f32(v65, (float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3))), v12), vbslq_s8(v49, v16, (int8x16_t)vmulq_f32(vaddq_f32(v14, vmulq_f32(
                                                         v75,
                                                         vaddq_f32(v45, vmulq_f32(v75, vaddq_f32(vaddq_f32(v43, vmulq_f32(v44, v75)), vmulq_f32(vmulq_f32(v75, v75), vaddq_f32(v36, vmulq_f32(v42, v75)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v74), v48), 0x17uLL))), (int8x16_t)vmulq_laneq_f32(v65, v13, 2)));
        v9 += 16;
      }
      while (v8 != v9);
      ++v3;
      v4 += v5;
      v6 += v7;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcBT2100_PQ_InverseOETF::GetDOD(HgcBT2100_PQ_InverseOETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2100_PQ_InverseOETF::GetROI(HgcBT2100_PQ_InverseOETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2100_PQ_InverseOETF::HgcBT2100_PQ_InverseOETF(HgcBT2100_PQ_InverseOETF *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F9340;
  operator new();
}

void sub_1B7941F3C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_InverseOETF::~HgcBT2100_PQ_InverseOETF(HGNode *this)
{
  *(void *)this = &unk_1F10F9340;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40502CBA4ALL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F9340;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40502CBA4ALL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_InverseOETF::SetParameter(HgcBT2100_PQ_InverseOETF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_PQ_InverseOETF::GetParameter(HgcBT2100_PQ_InverseOETF *this, unsigned int a2, float *a3)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_PQ_InverseOETF_qtApprox::GetProgram(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000404\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = clamp(r0.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[1].yyy));\n"
             "    r1.xyz = r0.xyz - half3(hg_Params[0].xxx);\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].zzz) + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    r0.xyz = pow(r0.xyz, half3(hg_Params[1].xxx));\n"
             "    output.color0.xyz = float3(r0.xyz)*hg_Params[1].zzz;\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c51a250f:d66e2ef0:88aa222a:e56ce852\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ce\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = clamp(r0.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
             "    r1.xyz = r0.xyz - hg_Params[0].xxx;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].zzz + hg_Params[0].yyy;\n"
             "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz/r0.xyz;\n"
             "    r0.xyz = pow(r0.xyz, hg_Params[1].xxx);\n"
             "    output.color0.xyz = r0.xyz*hg_Params[1].zzz;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f22f319c:ea07886b:9fc4354b:118627e0\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = clamp(r0.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal1.yyy);\n"
           "    r1.xyz = r0.xyz - hg_ProgramLocal0.xxx;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.zzz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = max(r1.xyz, c0.xxx);\n"
           "    r0.xyz = r1.xyz/r0.xyz;\n"
           "    r0.xyz = pow(r0.xyz, hg_ProgramLocal1.xxx);\n"
           "    gl_FragColor.xyz = r0.xyz*hg_ProgramLocal1.zzz;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=5e7cd0eb:313d5ea6:0c763ff4:65122675\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_PQ_InverseOETF_qtApprox::InitProgramDescriptor(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_PQ_InverseOETF_qtApprox_hgc_visible", "//Metal1.0     \n//LEN=00000002b9\n[[ visible ]] FragmentOut HgcBT2100_PQ_InverseOETF_qtApprox_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = clamp(r0.xyz, 0.00000f, 1.00000f);\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[1].yyy);\n"
    "    r1.xyz = r0.xyz - hg_Params[0].xxx;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].zzz + hg_Params[0].yyy;\n"
    "    r1.xyz = fmax(r1.xyz, c0.xxx);\n"
    "    r0.xyz = r1.xyz/r0.xyz;\n"
    "    r0.xyz = pow(r0.xyz, hg_Params[1].xxx);\n"
    "    output.color0.xyz = r0.xyz*hg_Params[1].zzz;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2100_PQ_InverseOETF_qtApprox");
}

void sub_1B79423E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7942410(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7942408);
}

char *HgcBT2100_PQ_InverseOETF_qtApprox::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x30uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375DA0;
  strcpy(result, "HgcBT2100_PQ_InverseOETF_qtApprox [hgc1]");
  return result;
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::BindTexture(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::Bind(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::RenderTile(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v108 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      uint64_t v11 = *((void *)this + 51);
      float32x4_t v13 = *(float32x4_t *)(v11 + 32);
      float32x4_t v12 = *(float32x4_t *)(v11 + 48);
      int8x16_t v14 = (int8x16_t)vminq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v10 - 16), v13), v12);
      float32x4_t v15 = *(float32x4_t *)(v11 + 16);
      int8x16_t v16 = (int8x16_t)vminq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v10), v13), v12);
      float32x4_t v165 = v13;
      int8x16_t v17 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1), v13)), v13);
      float32x4_t v18 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v12, v14);
      float32x4_t v19 = (float32x4_t)vbslq_s8(v17, (int8x16_t)v12, v16);
      int8x16_t v20 = *(int8x16_t *)(v11 + 64);
      float32x4_t v21 = *(float32x4_t *)(v11 + 80);
      float32x4_t v22 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v18), (int8x16_t)v12);
      float32x4_t v23 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v19), (int8x16_t)v12);
      int8x16_t v24 = *(int8x16_t *)(v11 + 96);
      float32x4_t v163 = *(float32x4_t *)(v11 + 112);
      int8x16_t v164 = v20;
      float32x4_t v25 = *(float32x4_t *)(v11 + 128);
      float32x4_t v166 = *(float32x4_t *)(v11 + 144);
      float32x4_t v26 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v22, v25));
      float32x4_t v27 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v23, v25));
      float32x4_t v28 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v18))), v163), v26);
      float32x4_t v29 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v19))), v163), v27);
      float32x4_t v30 = vmulq_f32(vmulq_f32(v166, v27), v23);
      float32x4_t v31 = vsubq_f32(vsubq_f32(v22, v12), vmulq_f32(vmulq_f32(v166, v26), v22));
      float32x4_t v32 = vsubq_f32(vsubq_f32(v23, v12), v30);
      float32x4_t v33 = vmulq_f32(v31, v31);
      float32x4_t v34 = vmulq_f32(v32, v32);
      float32x4_t v36 = *(float32x4_t *)(v11 + 160);
      float32x4_t v35 = *(float32x4_t *)(v11 + 176);
      float32x4_t v37 = *(float32x4_t *)(v11 + 192);
      float32x4_t v38 = *(float32x4_t *)(v11 + 208);
      float32x4_t v39 = *(float32x4_t *)(v11 + 224);
      float32x4_t v40 = *(float32x4_t *)(v11 + 240);
      float32x4_t v41 = vaddq_f32(vaddq_f32(v39, vmulq_f32(v40, v32)), vmulq_f32(v34, vaddq_f32(vaddq_f32(v36, vmulq_f32(v35, v32)), vmulq_f32(v34, vaddq_f32(v37, vmulq_f32(v38, v32))))));
      float32x4_t v42 = vmulq_f32(v31, vaddq_f32(vaddq_f32(v39, vmulq_f32(v40, v31)), vmulq_f32(v33, vaddq_f32(vaddq_f32(v36, vmulq_f32(v35, v31)), vmulq_f32(v33, vaddq_f32(v37, vmulq_f32(v38, v31)))))));
      float32x4_t v44 = *(float32x4_t *)(v11 + 256);
      float32x4_t v43 = *(float32x4_t *)(v11 + 272);
      float32x4_t v45 = v15;
      float32x4_t v46 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v28, vmulq_f32(v31, vaddq_f32(v44, v42))), *(float32x2_t *)v15.f32, 1), v43);
      float32x4_t v47 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v29, vmulq_f32(v32, vaddq_f32(v44, vmulq_f32(v32, v41)))), *(float32x2_t *)v15.f32, 1), v43);
      float32x4_t v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      float32x4_t v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      float32x4_t v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v48, v46)));
      float32x4_t v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v49, v47)));
      float32x4_t v52 = vsubq_f32(v46, v50);
      float32x4_t v53 = vsubq_f32(v47, v51);
      float32x4_t v54 = *(float32x4_t *)(v11 + 288);
      float32x4_t v55 = *(float32x4_t *)(v11 + 304);
      float32x4_t v57 = *(float32x4_t *)(v11 + 320);
      float32x4_t v56 = *(float32x4_t *)(v11 + 336);
      float32x4_t v59 = *(float32x4_t *)(v11 + 352);
      int32x4_t v58 = *(int32x4_t *)(v11 + 368);
      int8x16_t v60 = (int8x16_t)vmulq_f32(vaddq_f32(v12, vmulq_f32(v52, vaddq_f32(v59, vmulq_f32(v52, vaddq_f32(vaddq_f32(v57, vmulq_f32(v52, v56)), vmulq_f32(vmulq_f32(v52, v52), vaddq_f32(v54, vmulq_f32(v55, v52)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v50)), 0x17uLL));
      int8x16_t v61 = (int8x16_t)vmulq_f32(vaddq_f32(v12, vmulq_f32(v53, vaddq_f32(v59, vmulq_f32(v53, vaddq_f32(vaddq_f32(v57, vmulq_f32(v56, v53)), vmulq_f32(vmulq_f32(v53, v53), vaddq_f32(v54, vmulq_f32(v55, v53)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v58, vcvtq_s32_f32(v51)), 0x17uLL));
      float32x4_t v62 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11, 1);
      int8x16_t v64 = *(int8x16_t *)(v11 + 384);
      float32x4_t v63 = *(float32x4_t *)(v11 + 400);
      int8x16_t v65 = v14;
      float32x4_t v66 = (float32x4_t)vbslq_s8(v64, v14, v60);
      float32x4_t v67 = (float32x4_t)vbslq_s8(v64, v16, v61);
      int8x16_t v68 = (int8x16_t)vaddq_f32(v62, vmulq_laneq_f32(v67, *(float32x4_t *)v11, 2));
      float32x4_t v69 = (float32x4_t)vbslq_s8(v64, v14, (int8x16_t)vaddq_f32(v62, vmulq_laneq_f32(v66, *(float32x4_t *)v11, 2)));
      float32x4_t v70 = *(float32x4_t *)(v11 + 416);
      float32x4_t v71 = vminq_f32(vmaxq_f32(vrecpeq_f32(v69), v63), v70);
      float32x4_t v72 = vmulq_f32(v71, vrecpsq_f32(v69, v71));
      float32x4_t v73 = (float32x4_t)vbslq_s8(v64, v16, v68);
      float32x4_t v74 = vminq_f32(vmaxq_f32(vrecpeq_f32(v73), v63), v70);
      float32x4_t v75 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11, 0);
      float32x4_t v76 = vminq_f32(vmaxq_f32(v72, v63), v70);
      float32x4_t v77 = vminq_f32(vmaxq_f32(vmulq_f32(v74, vrecpsq_f32(v73, v74)), v63), v70);
      float32x4_t v78 = vmulq_f32(v77, vrecpsq_f32(v73, v77));
      int8x16_t v79 = (int8x16_t)vmulq_f32(vmaxq_f32(vsubq_f32(v66, v75), v165), vmulq_f32(v76, vrecpsq_f32(v69, v76)));
      int8x16_t v80 = (int8x16_t)vmulq_f32(vmaxq_f32(vsubq_f32(v67, v75), v165), v78);
      int8x16_t v81 = (int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 0), v165)), v165);
      int8x16_t v82 = v65;
      int8x16_t v83 = v16;
      float32x4_t v84 = (float32x4_t)vbslq_s8(v81, (int8x16_t)v12, vbslq_s8(v64, v65, v79));
      float32x4_t v85 = (float32x4_t)vbslq_s8(v81, (int8x16_t)v12, vbslq_s8(v64, v16, v80));
      float32x4_t v86 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v84, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v84)));
      float32x4_t v87 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v84, v164), (int8x16_t)v12);
      float32x4_t v88 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v85, v164), (int8x16_t)v12);
      float32x4_t v89 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v87, v25));
      float32x4_t v90 = (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v88, v25));
      float32x4_t v91 = vaddq_f32(vsubq_f32(v86, v163), v89);
      float32x4_t v92 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v85, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v85))), v163), v90);
      float32x4_t v93 = vsubq_f32(vsubq_f32(v87, v12), vmulq_f32(vmulq_f32(v166, v89), v87));
      float32x4_t v94 = vsubq_f32(vsubq_f32(v88, v12), vmulq_f32(vmulq_f32(v166, v90), v88));
      float32x4_t v95 = vaddq_f32(v36, vmulq_f32(v35, v94));
      float32x4_t v96 = vmulq_f32(v93, v93);
      float32x4_t v97 = vaddq_f32(vaddq_f32(v36, vmulq_f32(v35, v93)), vmulq_f32(v96, vaddq_f32(v37, vmulq_f32(v38, v93))));
      float32x4_t v98 = vmulq_f32(v94, v94);
      float32x4_t v99 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v91, vmulq_f32(v93, vaddq_f32(v44, vmulq_f32(v93, vaddq_f32(vaddq_f32(v39, vmulq_f32(v40, v93)), vmulq_f32(v96, v97)))))), v45.f32[0]), v43);
      float32x4_t v100 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v92, vmulq_f32(v94, vaddq_f32(v44, vmulq_f32(v94, vaddq_f32(vaddq_f32(v39, vmulq_f32(v40, v94)), vmulq_f32(v98, vaddq_f32(v95, vmulq_f32(v98, vaddq_f32(v37, vmulq_f32(v38, v94)))))))))), v45.f32[0]), v43);
      float32x4_t v101 = vcvtq_f32_s32(vcvtq_s32_f32(v99));
      float32x4_t v102 = vcvtq_f32_s32(vcvtq_s32_f32(v100));
      float32x4_t v103 = vsubq_f32(v101, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v101, v99)));
      float32x4_t v104 = vsubq_f32(v102, (float32x4_t)vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_f32(v102, v100)));
      float32x4_t v105 = vsubq_f32(v99, v103);
      float32x4_t v106 = vsubq_f32(v100, v104);
      float32x4_t v107 = (int8x16_t *)(v5 + v10);
      v107[-1] = vbslq_s8(v64, v82, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v64, v82, (int8x16_t)vmulq_f32(vaddq_f32(v12, vmulq_f32(v105, vaddq_f32(v59, vmulq_f32(v105, vaddq_f32(vaddq_f32(v57, vmulq_f32(v56, v105)), vmulq_f32(vmulq_f32(v105, v105),
                                                                        vaddq_f32(v54, vmulq_f32(v55, v105)))))))),
                                                            (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v103), v58), 0x17uLL))), v45, 2));
      *float32x4_t v107 = vbslq_s8(v64, v83, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v64, v83, (int8x16_t)vmulq_f32(vaddq_f32(v12, vmulq_f32(v106, vaddq_f32(v59, vmulq_f32(v106, vaddq_f32(vaddq_f32(v57, vmulq_f32(v56, v106)), vmulq_f32(vmulq_f32(v106, v106),
                                                                     vaddq_f32(v54, vmulq_f32(v55, v106)))))))),
                                                         (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v104), v58), 0x17uLL))), v45, 2));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v108 = -v9;
    if (v108 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v109 = 16 * v108;
    uint64_t v110 = *((void *)this + 51);
    float32x4_t v112 = *(float32x4_t *)(v110 + 32);
    float32x4_t v111 = *(float32x4_t *)(v110 + 48);
    int8x16_t v113 = (int8x16_t)vminq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v109), v112), v111);
    float32x4_t v114 = *(float32x4_t *)(v110 + 16);
    float32x4_t v115 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 1), v112)), v112), (int8x16_t)v111, v113);
    int8x16_t v116 = *(int8x16_t *)(v110 + 64);
    float32x4_t v117 = *(float32x4_t *)(v110 + 80);
    float32x4_t v118 = (float32x4_t)vorrq_s8(vandq_s8(v116, (int8x16_t)v115), (int8x16_t)v111);
    int8x16_t v119 = *(int8x16_t *)(v110 + 96);
    float32x4_t v120 = *(float32x4_t *)(v110 + 112);
    float32x4_t v121 = *(float32x4_t *)(v110 + 128);
    float32x4_t v122 = *(float32x4_t *)(v110 + 144);
    float32x4_t v123 = (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v118, v121));
    float32x4_t v124 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v115, 0x17uLL)), (float32x4_t)vandq_s8(v119, (int8x16_t)vcgtq_f32(v117, v115))), v120), v123);
    float32x4_t v125 = vsubq_f32(vsubq_f32(v118, v111), vmulq_f32(vmulq_f32(v122, v123), v118));
    float32x4_t v126 = vmulq_f32(v125, v125);
    float32x4_t v127 = *(float32x4_t *)(v110 + 160);
    float32x4_t v128 = *(float32x4_t *)(v110 + 176);
    float32x4_t v129 = *(float32x4_t *)(v110 + 192);
    float32x4_t v130 = *(float32x4_t *)(v110 + 208);
    float32x4_t v131 = *(float32x4_t *)(v110 + 224);
    float32x4_t v132 = *(float32x4_t *)(v110 + 240);
    float32x4_t v133 = *(float32x4_t *)(v110 + 256);
    float32x4_t v134 = *(float32x4_t *)(v110 + 272);
    float32x4_t v135 = vmaxq_f32(vmulq_lane_f32(vaddq_f32(v124, vmulq_f32(v125, vaddq_f32(v133, vmulq_f32(v125, vaddq_f32(vaddq_f32(v131, vmulq_f32(v132, v125)), vmulq_f32(v126, vaddq_f32(vaddq_f32(v127, vmulq_f32(v128, v125)), vmulq_f32(v126, vaddq_f32(v129, vmulq_f32(v130, v125)))))))))), *(float32x2_t *)v114.f32, 1), v134);
    float32x4_t v136 = vcvtq_f32_s32(vcvtq_s32_f32(v135));
    float32x4_t v137 = vsubq_f32(v136, (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v136, v135)));
    float32x4_t v138 = vsubq_f32(v135, v137);
    float32x4_t v139 = *(float32x4_t *)(v110 + 288);
    float32x4_t v140 = *(float32x4_t *)(v110 + 304);
    float32x4_t v141 = *(float32x4_t *)(v110 + 320);
    float32x4_t v142 = *(float32x4_t *)(v110 + 336);
    float32x4_t v143 = *(float32x4_t *)(v110 + 352);
    int32x4_t v144 = *(int32x4_t *)(v110 + 368);
    int8x16_t v146 = *(int8x16_t *)(v110 + 384);
    float32x4_t v145 = *(float32x4_t *)(v110 + 400);
    float32x4_t v147 = (float32x4_t)vbslq_s8(v146, v113, (int8x16_t)vmulq_f32(vaddq_f32(v111, vmulq_f32(v138, vaddq_f32(v143, vmulq_f32(v138, vaddq_f32(vaddq_f32(v141, vmulq_f32(v142, v138)), vmulq_f32(vmulq_f32(v138, v138), vaddq_f32(v139, vmulq_f32(v140, v138)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v144, vcvtq_s32_f32(v137)), 0x17uLL)));
    float32x4_t v148 = (float32x4_t)vbslq_s8(v146, v113, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v110, 1), vmulq_laneq_f32(v147, *(float32x4_t *)v110, 2)));
    float32x4_t v149 = *(float32x4_t *)(v110 + 416);
    float32x4_t v150 = vminq_f32(vmaxq_f32(vrecpeq_f32(v148), v145), v149);
    float32x4_t v151 = vminq_f32(vmaxq_f32(vmulq_f32(v150, vrecpsq_f32(v148, v150)), v145), v149);
    float32x4_t v152 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 0), v112)), v112), (int8x16_t)v111, vbslq_s8(v146, v113, (int8x16_t)vmulq_f32(vmaxq_f32(vsubq_f32(v147, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v110, 0)), v112), vmulq_f32(v151, vrecpsq_f32(v148, v151)))));
    float32x4_t v153 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v152, v116), (int8x16_t)v111);
    float32x4_t v154 = (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v153, v121));
    float32x4_t v155 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v152, 0x17uLL)), (float32x4_t)vandq_s8(v119, (int8x16_t)vcgtq_f32(v117, v152))), v120), v154);
    float32x4_t v156 = vsubq_f32(vsubq_f32(v153, v111), vmulq_f32(vmulq_f32(v122, v154), v153));
    float32x4_t v157 = vmulq_f32(v156, v156);
    float32x4_t v158 = vmaxq_f32(vmulq_n_f32(vaddq_f32(v155, vmulq_f32(v156, vaddq_f32(v133, vmulq_f32(v156, vaddq_f32(vaddq_f32(v131, vmulq_f32(v132, v156)), vmulq_f32(v157, vaddq_f32(vaddq_f32(v127, vmulq_f32(v128, v156)), vmulq_f32(v157, vaddq_f32(v129, vmulq_f32(v130, v156)))))))))), v114.f32[0]), v134);
    float32x4_t v159 = vcvtq_f32_s32(vcvtq_s32_f32(v158));
    float32x4_t v160 = vsubq_f32(v159, (float32x4_t)vandq_s8((int8x16_t)v111, (int8x16_t)vcgtq_f32(v159, v158)));
    float32x4_t v161 = vsubq_f32(v158, v160);
    *(int8x16_t *)(v5 + v109) = vbslq_s8(v146, v113, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v146, v113, (int8x16_t)vmulq_f32(vaddq_f32(v111, vmulq_f32(v161, vaddq_f32(v143, vmulq_f32(v161, vaddq_f32(vaddq_f32(v141, vmulq_f32(v142, v161)),
                                                                                     vmulq_f32(vmulq_f32(v161, v161), vaddq_f32(v139, vmulq_f32(v140, v161)))))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v160), v144), 0x17uLL))), v114, 2));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::GetDOD(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::GetROI(HgcBT2100_PQ_InverseOETF_qtApprox *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2100_PQ_InverseOETF_qtApprox::HgcBT2100_PQ_InverseOETF_qtApprox(HgcBT2100_PQ_InverseOETF_qtApprox *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F95A8;
  operator new();
}

void sub_1B7943008(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_PQ_InverseOETF_qtApprox::~HgcBT2100_PQ_InverseOETF_qtApprox(HGNode *this)
{
  *(void *)this = &unk_1F10F95A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4003455651);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F95A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4003455651);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::SetParameter(HgcBT2100_PQ_InverseOETF_qtApprox *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_PQ_InverseOETF_qtApprox::GetParameter(HgcBT2100_PQ_InverseOETF_qtApprox *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_HLG_OETF::GetProgram(HgcBT2100_HLG_OETF *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000470\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = fmax(r0.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].zzz);\n"
             "    r1.x = sqrt(r1.x);\n"
             "    r1.z = sqrt(r1.z);\n"
             "    r1.y = sqrt(r1.y);\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = log2(r2.xyz);\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[1].yyy) + half3(hg_Params[1].www);\n"
             "    r0.xyz = half3(half3(hg_Params[0].xxx) < r0.xyz);\n"
             "    output.color0.xyz = select(float3(r1.xyz), float3(r2.xyz), -float3(r0.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a246f9f9:66d6029c:84c9338d:ea089985\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000424\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = fmax(r0.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz - hg_Params[1].zzz;\n"
             "    r1.x = sqrt(r1.x);\n"
             "    r1.z = sqrt(r1.z);\n"
             "    r1.y = sqrt(r1.y);\n"
             "    r1.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = log2(r2.xyz);\n"
             "    r2.xyz = r2.xyz*hg_Params[1].yyy + hg_Params[1].www;\n"
             "    r0.xyz = float3(hg_Params[0].xxx < r0.xyz);\n"
             "    output.color0.xyz = select(r1.xyz, r2.xyz, -r0.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5c824207:76fd8e2e:0a00acd2:9472bca2\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000046a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r2.xyz = max(r0.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.zzz;\n"
           "    r1.x = sqrt(r1.x);\n"
           "    r1.z = sqrt(r1.z);\n"
           "    r1.y = sqrt(r1.y);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = log2(r2.xyz);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal1.yyy + hg_ProgramLocal1.www;\n"
           "    r0.xyz = vec3(lessThan(hg_ProgramLocal0.xxx, r0.xyz));\n"
           "    gl_FragColor.xyz = vec3(-r0.x < 0.00000 ? r2.x : r1.x, -r0.y < 0.00000 ? r2.y : r1.y, -r0.z < 0.00000 ? r"
           "2.z : r1.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=56011197:b8fa2ca6:c303b796:50fed9e5\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_HLG_OETF::InitProgramDescriptor(HgcBT2100_HLG_OETF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_HLG_OETF_hgc_visible", "//Metal1.0     \n//LEN=0000000300\n[[ visible ]] FragmentOut HgcBT2100_HLG_OETF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r2.xyz = fmax(r0.xyz, hg_Params[0].xxx);\n"
    "    r2.xyz = r2.xyz - hg_Params[1].zzz;\n"
    "    r1.x = sqrt(r1.x);\n"
    "    r1.z = sqrt(r1.z);\n"
    "    r1.y = sqrt(r1.y);\n"
    "    r1.xyz = r1.xyz*hg_Params[1].xxx;\n"
    "    r2.xyz = log2(r2.xyz);\n"
    "    r2.xyz = r2.xyz*hg_Params[1].yyy + hg_Params[1].www;\n"
    "    r0.xyz = float3(hg_Params[0].xxx < r0.xyz);\n"
    "    output.color0.xyz = select(r1.xyz, r2.xyz, -r0.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2100_HLG_OETF");
}

void sub_1B79434AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B79434DC(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79434D4);
}

double HgcBT2100_HLG_OETF::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcBT2100_HLG_OETF [hgc1]");
  return *(double *)"_HLG_OETF [hgc1]";
}

uint64_t HgcBT2100_HLG_OETF::BindTexture(HgcBT2100_HLG_OETF *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_HLG_OETF::Bind(HgcBT2100_HLG_OETF *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2100_HLG_OETF::RenderTile(HgcBT2100_HLG_OETF *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v62 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v11 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = *((void *)this + 51);
      float32x4_t v14 = *(float32x4_t *)(v13 + 32);
      float32x4_t v15 = *(float32x4_t *)(v13 + 48);
      float32x4_t v16 = vmaxq_f32(v12, v14);
      float32x4_t v17 = vmaxq_f32(v11, v14);
      int32x4_t v18 = *(int32x4_t *)(v13 + 16);
      float32x4_t v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 0);
      float32x4_t v20 = (float32x4_t)vdupq_laneq_s32(v18, 2);
      float32x4_t v21 = vsubq_f32(vmaxq_f32(v12, v19), v20);
      float32x4_t v22 = *(float32x4_t *)(v13 + 64);
      float32x4_t v23 = vminq_f32(vmulq_f32(vrsqrteq_f32(v16), v15), v22);
      float32x4_t v24 = vminq_f32(vmulq_f32(vrsqrteq_f32(v17), v15), v22);
      int8x16_t v25 = (int8x16_t)vmulq_f32(v17, vminq_f32(vmulq_f32(v24, vrsqrtsq_f32(vmulq_f32(v17, v24), v24)), v22));
      float32x4_t v26 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v13 + 80), (int8x16_t)vmulq_f32(v16, vminq_f32(vmulq_f32(v23, vrsqrtsq_f32(vmulq_f32(v16, v23), v23)), v22)), (int8x16_t)v16);
      float32x4_t v27 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v13 + 80), v25, (int8x16_t)v17);
      float32x4_t v28 = vminq_f32(vmulq_f32(v22, vrsqrteq_f32(v26)), v15);
      float32x4_t v29 = vminq_f32(vmulq_f32(v22, vrsqrteq_f32(v27)), v15);
      float32x4_t v30 = vsubq_f32(vmaxq_f32(v11, v19), v20);
      v26.i64[1] = vmulq_f32(vminq_f32(vmulq_f32(v28, vrsqrtsq_f32(vmulq_f32(v28, v26), v28)), v15), v26).i64[1];
      v27.i64[1] = vmulq_f32(vminq_f32(vmulq_f32(v29, vrsqrtsq_f32(vmulq_f32(v29, v27), v29)), v15), v27).i64[1];
      int8x16_t v31 = *(int8x16_t *)(v13 + 96);
      int8x16_t v32 = *(int8x16_t *)(v13 + 112);
      float32x4_t v33 = *(float32x4_t *)(v13 + 128);
      float32x4_t v34 = *(float32x4_t *)(v13 + 144);
      float32x4_t v35 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v21), (int8x16_t)v33);
      float32x4_t v36 = (float32x4_t)vorrq_s8(vandq_s8(v32, (int8x16_t)v30), (int8x16_t)v33);
      int8x16_t v37 = *(int8x16_t *)(v13 + 160);
      float32x4_t v38 = *(float32x4_t *)(v13 + 176);
      float32x4_t v39 = vminq_f32(vmulq_f32(v22, vrsqrteq_f32(v26)), v15);
      float32x4_t v40 = vminq_f32(vmulq_f32(v22, vrsqrteq_f32(v27)), v15);
      float32x4_t v41 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x17uLL)), (float32x4_t)vandq_s8(v37, (int8x16_t)vcgtq_f32(v34, v21))), v38);
      float32x4_t v42 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x17uLL)), (float32x4_t)vandq_s8(v37, (int8x16_t)vcgtq_f32(v34, v30))), v38);
      float32x4_t v43 = *(float32x4_t *)(v13 + 192);
      float32x4_t v44 = *(float32x4_t *)(v13 + 208);
      float32x4_t v45 = (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v35, v43));
      float32x4_t v46 = (float32x4_t)vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v36, v43));
      float32x4_t v47 = vaddq_f32(v42, v46);
      float32x4_t v48 = vsubq_f32(vsubq_f32(v35, v33), vmulq_f32(vmulq_f32(v44, v45), v35));
      float32x4_t v49 = vsubq_f32(vsubq_f32(v36, v33), vmulq_f32(vmulq_f32(v44, v46), v36));
      float32x4_t v50 = *(float32x4_t *)(v13 + 224);
      float32x4_t v51 = *(float32x4_t *)(v13 + 240);
      float32x4_t v52 = vaddq_f32(v50, vmulq_f32(v51, v48));
      float32x4_t v53 = vaddq_f32(v50, vmulq_f32(v51, v49));
      float32x4_t v54 = *(float32x4_t *)(v13 + 256);
      float32x4_t v55 = *(float32x4_t *)(v13 + 272);
      float32x4_t v56 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vmulq_f32(v26, vminq_f32(vmulq_f32(v39, vrsqrtsq_f32(vmulq_f32(v26, v39), v39)), v15)), (int8x16_t)v26);
      float32x4_t v57 = (float32x4_t)vdupq_laneq_s32(v18, 3);
      float32x4_t v58 = (float32x4_t)vbslq_s8(v31, (int8x16_t)vmulq_f32(v27, vminq_f32(vmulq_f32(v40, vrsqrtsq_f32(vmulq_f32(v27, v40), v40)), v15)), (int8x16_t)v27);
      int8x16_t v59 = (int8x16_t)vaddq_f32(v57, vmulq_lane_f32(vaddq_f32(v47, vmulq_f32(v49, vaddq_f32(vaddq_f32(v54, vmulq_f32(v49, v55)), vmulq_f32(vmulq_f32(v49, v49), v53)))), *(float32x2_t *)v18.i8, 1));
      int8x16_t v60 = *(int8x16_t *)(v13 + 288);
      int8x16_t v61 = (int8x16_t *)(v5 + v10);
      v61[-1] = vbslq_s8(v60, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v60, (int8x16_t)v12, vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v12, v19))), v14), (int8x16_t)vaddq_f32(v57, vmulq_lane_f32(vaddq_f32(vaddq_f32(v41, v45), vmulq_f32(v48, vaddq_f32(vaddq_f32(v54, vmulq_f32(v48, v55)), vmulq_f32(vmulq_f32(v48, v48), v52)))),
                                   *(float32x2_t *)v18.i8,
                                   1)),
                    (int8x16_t)vmulq_n_f32(v56, *(float *)v18.i32)));
      *int8x16_t v61 = vbslq_s8(v60, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v60, (int8x16_t)v11, vandq_s8((int8x16_t)v33, (int8x16_t)vcgtq_f32(v11, v19))), v14), v59, (int8x16_t)vmulq_n_f32(v58, *(float *)v18.i32)));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v62 = -v9;
    if (v62 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v63 = 16 * v62;
    float32x4_t v64 = *(float32x4_t *)(v6 + v63);
    uint64_t v65 = *((void *)this + 51);
    float32x4_t v66 = *(float32x4_t *)(v65 + 32);
    float32x4_t v67 = *(float32x4_t *)(v65 + 48);
    float32x4_t v68 = vmaxq_f32(v64, v66);
    int32x4_t v69 = *(int32x4_t *)(v65 + 16);
    float32x4_t v70 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v65, 0);
    float32x4_t v71 = *(float32x4_t *)(v65 + 64);
    float32x4_t v72 = vminq_f32(vmulq_f32(vrsqrteq_f32(v68), v67), v71);
    float32x4_t v73 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v65 + 80), (int8x16_t)vmulq_f32(v68, vminq_f32(vmulq_f32(v72, vrsqrtsq_f32(vmulq_f32(v68, v72), v72)), v71)), (int8x16_t)v68);
    float32x4_t v74 = vminq_f32(vmulq_f32(v71, vrsqrteq_f32(v73)), v67);
    v73.i64[1] = vmulq_f32(vminq_f32(vmulq_f32(v74, vrsqrtsq_f32(vmulq_f32(v74, v73), v74)), v67), v73).i64[1];
    float32x4_t v75 = vsubq_f32(vmaxq_f32(v64, v70), (float32x4_t)vdupq_laneq_s32(v69, 2));
    float32x4_t v76 = vminq_f32(vmulq_f32(v71, vrsqrteq_f32(v73)), v67);
    int8x16_t v77 = (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v65 + 96), (int8x16_t)vmulq_f32(v73, vminq_f32(vmulq_f32(v76, vrsqrtsq_f32(vmulq_f32(v76, v73), v76)), v67)), (int8x16_t)v73), *(float *)v69.i32);
    float32x4_t v78 = *(float32x4_t *)(v65 + 128);
    float32x4_t v79 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v65 + 112), (int8x16_t)v75), (int8x16_t)v78);
    float32x4_t v80 = (float32x4_t)vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v79, *(float32x4_t *)(v65 + 192)));
    float32x4_t v81 = vsubq_f32(vsubq_f32(v79, v78), vmulq_f32(vmulq_f32(*(float32x4_t *)(v65 + 208), v80), v79));
    *(int8x16_t *)(v5 + v63) = vbslq_s8(*(int8x16_t *)(v65 + 288), (int8x16_t)v64, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v65 + 288), (int8x16_t)v64, vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v64, v70))), v66), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(v69, 3), vmulq_lane_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v75, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v65 + 160),
                                                                         (int8x16_t)vcgtq_f32(*(float32x4_t *)(v65 + 144), v75))), *(float32x4_t *)(v65 + 176)), v80), vmulq_f32(v81, vaddq_f32(vaddq_f32(*(float32x4_t *)(v65 + 256), vmulq_f32(v81, *(float32x4_t *)(v65 + 272))), vmulq_f32(vmulq_f32(v81, v81), vaddq_f32(*(float32x4_t *)(v65 + 224), vmulq_f32(*(float32x4_t *)(v65 + 240), v81)))))), *(float32x2_t *)v69.i8, 1)), v77));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_HLG_OETF::GetDOD(HgcBT2100_HLG_OETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2100_HLG_OETF::GetROI(HgcBT2100_HLG_OETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2100_HLG_OETF::HgcBT2100_HLG_OETF(HgcBT2100_HLG_OETF *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F9810;
  operator new();
}

void sub_1B7943CA0(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_HLG_OETF::~HgcBT2100_HLG_OETF(HGNode *this)
{
  *(void *)this = &unk_1F10F9810;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40FDACBBE0);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F9810;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40FDACBBE0);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_HLG_OETF::SetParameter(HgcBT2100_HLG_OETF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_HLG_OETF::GetParameter(HgcBT2100_HLG_OETF *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_HLG_InverseOETF::GetProgram(HgcBT2100_HLG_InverseOETF *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000459\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.004999999888, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz*half3(hg_Params[1].xxx) + half3(hg_Params[1].yyy);\n"
             "    r2.xyz = r1.xyz*r1.xyz;\n"
             "    r1.w = half(r0.w >= c0.y);\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].yyy);\n"
             "    r0.xyz = exp2(r0.xyz);\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[1].zzz) + half3(hg_Params[1].www);\n"
             "    r1.xyz = half3(half3(hg_Params[0].xxx) < r1.xyz);\n"
             "    output.color0.xyz = select(float3(r2.xyz), float3(r0.xyz), -float3(r1.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r1.w)*float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0e64def9:549efc1e:2c24ba50:d3e12153\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000407\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.004999999888, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r0.xyz = r1.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
             "    r2.xyz = r1.xyz*r1.xyz;\n"
             "    r1.w = float(r0.w >= c0.y);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].yyy;\n"
             "    r0.xyz = exp2(r0.xyz);\n"
             "    r0.xyz = r0.xyz*hg_Params[1].zzz + hg_Params[1].www;\n"
             "    r1.xyz = float3(hg_Params[0].xxx < r1.xyz);\n"
             "    output.color0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
             "    output.color0.w = r1.w*r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9d3926b3:95147086:aed26591:6ed500f8\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000044e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.004999999888, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r0.xyz = r1.xyz*hg_ProgramLocal1.xxx + hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = r1.xyz*r1.xyz;\n"
           "    r1.w = float(r0.w >= c0.y);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.yyy;\n"
           "    r0.xyz = exp2(r0.xyz);\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal1.zzz + hg_ProgramLocal1.www;\n"
           "    r1.xyz = vec3(lessThan(hg_ProgramLocal0.xxx, r1.xyz));\n"
           "    gl_FragColor.xyz = vec3(-r1.x < 0.00000 ? r0.x : r2.x, -r1.y < 0.00000 ? r0.y : r2.y, -r1.z < 0.00000 ? r"
           "0.z : r2.z);\n"
           "    gl_FragColor.w = r1.w*r0.w;\n"
           "}\n"
           "//MD5=b0b6d9ae:948ec756:c093cb52:9ea2171d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_HLG_InverseOETF::InitProgramDescriptor(HgcBT2100_HLG_InverseOETF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_HLG_InverseOETF_hgc_visible", "//Metal1.0     \n//LEN=00000002ea\n[[ visible ]] FragmentOut HgcBT2100_HLG_InverseOETF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.004999999888, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r0.xyz = r1.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
    "    r2.xyz = r1.xyz*r1.xyz;\n"
    "    r1.w = float(r0.w >= c0.y);\n"
    "    r2.xyz = r2.xyz*hg_Params[0].yyy;\n"
    "    r0.xyz = exp2(r0.xyz);\n"
    "    r0.xyz = r0.xyz*hg_Params[1].zzz + hg_Params[1].www;\n"
    "    r1.xyz = float3(hg_Params[0].xxx < r1.xyz);\n"
    "    output.color0.xyz = select(r2.xyz, r0.xyz, -r1.xyz < 0.00000f);\n"
    "    output.color0.w = r1.w*r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2100_HLG_InverseOETF");
}

void sub_1B7944140(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7944170(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7944168);
}

char *HgcBT2100_HLG_InverseOETF::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B83761D0;
  strcpy(result, "HgcBT2100_HLG_InverseOETF [hgc1]");
  return result;
}

uint64_t HgcBT2100_HLG_InverseOETF::BindTexture(HgcBT2100_HLG_InverseOETF *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_HLG_InverseOETF::Bind(HgcBT2100_HLG_InverseOETF *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2100_HLG_InverseOETF::RenderTile(HgcBT2100_HLG_InverseOETF *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v51 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v11 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v12 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = *((void *)this + 51);
      float32x4_t v14 = *(float32x4_t *)(v13 + 16);
      float32x4_t v15 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1);
      float32x4_t v17 = *(float32x4_t *)(v13 + 32);
      int8x16_t v16 = *(int8x16_t *)(v13 + 48);
      float32x4_t v18 = vmaxq_f32(v11, v17);
      float32x4_t v19 = vmaxq_f32(v12, v17);
      float32x4_t v20 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v11, (int8x16_t)vaddq_f32(v15, vmulq_n_f32(v18, v14.f32[0])));
      float32x4_t v21 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)vaddq_f32(v15, vmulq_n_f32(v19, v14.f32[0])));
      float32x4_t v22 = *(float32x4_t *)(v13 + 64);
      float32x4_t v23 = *(float32x4_t *)(v13 + 80);
      int8x16_t v24 = (int8x16_t)vcgeq_f32(v21, v17);
      int8x16_t v25 = vandq_s8((int8x16_t)v22, (int8x16_t)vcgeq_f32(v20, v17));
      float32x4_t v26 = vmaxq_f32(v20, v22);
      float32x4_t v27 = vmaxq_f32(v21, v22);
      float32x4_t v28 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
      float32x4_t v29 = vcvtq_f32_s32(vcvtq_s32_f32(v27));
      float32x4_t v30 = vsubq_f32(v28, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v28, v26)));
      float32x4_t v31 = vsubq_f32(v29, (float32x4_t)vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32(v29, v27)));
      float32x4_t v32 = vsubq_f32(v26, v30);
      float32x4_t v33 = vsubq_f32(v27, v31);
      float32x4_t v34 = *(float32x4_t *)(v13 + 96);
      float32x4_t v35 = *(float32x4_t *)(v13 + 112);
      int8x16_t v36 = vandq_s8((int8x16_t)v22, v24);
      float32x4_t v37 = vaddq_f32(v34, vmulq_f32(v35, v32));
      float32x4_t v38 = vaddq_f32(v34, vmulq_f32(v35, v33));
      float32x4_t v39 = *(float32x4_t *)(v13 + 128);
      int32x4_t v40 = *(int32x4_t *)(v13 + 144);
      int8x16_t v41 = (int8x16_t)vmulq_f32(vaddq_f32(v23, vmulq_f32(v32, vaddq_f32(v39, vmulq_f32(v32, v37)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v40, vcvtq_s32_f32(v30)), 0x17uLL));
      float32x4_t v42 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3);
      float32x4_t v43 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v11, (int8x16_t)vaddq_f32(v42, vmulq_laneq_f32((float32x4_t)vbslq_s8(v16, (int8x16_t)v11, v41), v14, 2)));
      float32x4_t v44 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 0);
      float32x4_t v45 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)vaddq_f32(v42, vmulq_laneq_f32((float32x4_t)vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)vmulq_f32(vaddq_f32(v23, vmulq_f32(v33, vaddq_f32(v39, vmulq_f32(v33, v38)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v40, vcvtq_s32_f32(v31)), 0x17uLL))), v14, 2)));
      int8x16_t v46 = vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v16, v36, (int8x16_t)v19), v44));
      float32x4_t v47 = (float32x4_t)vbslq_s8(v16, v25, vandq_s8((int8x16_t)v23, (int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v16, v25, (int8x16_t)v18), v44)));
      float32x4_t v48 = (float32x4_t)vbslq_s8(v16, v36, v46);
      float32x4_t v49 = (int8x16_t *)(v5 + v10);
      int8x16_t v50 = vbslq_s8(v16, (int8x16_t)vmulq_f32(v48, v45), vbslq_s8((int8x16_t)vcgtq_f32(v48, v17), (int8x16_t)v45, (int8x16_t)vmulq_lane_f32(vmulq_f32(v19, v19), *(float32x2_t *)v13, 1)));
      v49[-1] = vbslq_s8(v16, (int8x16_t)vmulq_f32(v47, v43), vbslq_s8((int8x16_t)vcgtq_f32(v47, v17), (int8x16_t)v43, (int8x16_t)vmulq_lane_f32(vmulq_f32(v18, v18), *(float32x2_t *)v13, 1)));
      *float32x4_t v49 = v50;
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v51 = -v9;
    if (v51 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v52 = 16 * v51;
    float32x4_t v53 = *(float32x4_t *)(v6 + v52);
    uint64_t v54 = *((void *)this + 51);
    float32x4_t v55 = *(float32x4_t *)(v54 + 32);
    int8x16_t v56 = *(int8x16_t *)(v54 + 48);
    float32x4_t v57 = vmaxq_f32(v53, v55);
    float32x4_t v58 = *(float32x4_t *)(v54 + 16);
    float32x4_t v59 = (float32x4_t)vbslq_s8(v56, (int8x16_t)v53, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 1), vmulq_n_f32(v57, v58.f32[0])));
    float32x4_t v60 = *(float32x4_t *)(v54 + 64);
    float32x4_t v61 = *(float32x4_t *)(v54 + 80);
    int8x16_t v62 = vandq_s8((int8x16_t)v60, (int8x16_t)vcgeq_f32(v59, v55));
    float32x4_t v63 = vmaxq_f32(v59, v60);
    float32x4_t v64 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
    float32x4_t v65 = vsubq_f32(v64, (float32x4_t)vandq_s8((int8x16_t)v61, (int8x16_t)vcgtq_f32(v64, v63)));
    float32x4_t v66 = vsubq_f32(v63, v65);
    float32x4_t v67 = vmulq_f32(v57, v57);
    float32x4_t v68 = (float32x4_t)vbslq_s8(v56, (int8x16_t)v53, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 3), vmulq_laneq_f32((float32x4_t)vbslq_s8(v56, (int8x16_t)v53, (int8x16_t)vmulq_f32(vaddq_f32(v61, vmulq_f32(v66, vaddq_f32(*(float32x4_t *)(v54 + 128), vmulq_f32(v66, vaddq_f32(*(float32x4_t *)(v54 + 96),
                                                                              vmulq_f32(*(float32x4_t *)(v54 + 112), v66)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v54 + 144), vcvtq_s32_f32(v65)), 0x17uLL))), v58, 2)));
    float32x4_t v69 = (float32x4_t)vbslq_s8(v56, v62, vandq_s8((int8x16_t)v61, (int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v56, v62, (int8x16_t)v57), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54, 0))));
    *(int8x16_t *)(v5 + v52) = vbslq_s8(v56, (int8x16_t)vmulq_f32(v69, v68), vbslq_s8((int8x16_t)vcgtq_f32(v69, v55), (int8x16_t)v68, (int8x16_t)vmulq_lane_f32(v67, *(float32x2_t *)v54, 1)));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_HLG_InverseOETF::GetDOD(HgcBT2100_HLG_InverseOETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2100_HLG_InverseOETF::GetROI(HgcBT2100_HLG_InverseOETF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2100_HLG_InverseOETF::HgcBT2100_HLG_InverseOETF(HgcBT2100_HLG_InverseOETF *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F9A78;
  operator new();
}

void sub_1B7944770(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_HLG_InverseOETF::~HgcBT2100_HLG_InverseOETF(HGNode *this)
{
  *(void *)this = &unk_1F10F9A78;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B8406A4ELL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F9A78;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B8406A4ELL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_HLG_InverseOETF::SetParameter(HgcBT2100_HLG_InverseOETF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_HLG_InverseOETF::GetParameter(HgcBT2100_HLG_InverseOETF *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcBT2100_HLG_OOTF_InverseOOTF::GetProgram(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000389\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = dot(r0.xyz, half3(hg_Params[0].xyz));\n"
             "    r1.y = half(c0.y < r1.x);\n"
             "    r1.x = pow(r1.x, half(hg_Params[1].x));\n"
             "    r1.x = select(c0.y, r1.x, -r1.y < 0.00000h);\n"
             "    r1.x = r1.x*half(hg_Params[1].y);\n"
             "    output.color0.xyz = float3(r0.xyz)*float3(r1.xxx);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=518f3182:06a5d829:280589ce:1e93e94a\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000035c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = dot(r0.xyz, hg_Params[0].xyz);\n"
             "    r1.y = float(c0.y < r1.x);\n"
             "    r1.x = pow(r1.x, hg_Params[1].x);\n"
             "    r1.x = select(c0.y, r1.x, -r1.y < 0.00000f);\n"
             "    r1.x = r1.x*hg_Params[1].y;\n"
             "    output.color0.xyz = r0.xyz*r1.xxx;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c18f2b64:8869268a:5dc9c39b:c72920aa\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000353\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = dot(r0.xyz, hg_ProgramLocal0.xyz);\n"
           "    r1.y = float(c0.y < r1.x);\n"
           "    r1.x = pow(r1.x, hg_ProgramLocal1.x);\n"
           "    r1.x = -r1.y < 0.00000 ? r1.x : c0.y;\n"
           "    r1.x = r1.x*hg_ProgramLocal1.y;\n"
           "    gl_FragColor.xyz = r0.xyz*r1.xxx;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=e6fecf5f:0e29aa5b:51d59bfe:b6c20fae\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcBT2100_HLG_OOTF_InverseOOTF::InitProgramDescriptor(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcBT2100_HLG_OOTF_InverseOOTF_hgc_visible", "//Metal1.0     \n//LEN=0000000244\n[[ visible ]] FragmentOut HgcBT2100_HLG_OOTF_InverseOOTF_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = dot(r0.xyz, hg_Params[0].xyz);\n"
    "    r1.y = float(c0.y < r1.x);\n"
    "    r1.x = pow(r1.x, hg_Params[1].x);\n"
    "    r1.x = select(c0.y, r1.x, -r1.y < 0.00000f);\n"
    "    r1.x = r1.x*hg_Params[1].y;\n"
    "    output.color0.xyz = r0.xyz*r1.xxx;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcBT2100_HLG_OOTF_InverseOOTF");
}

void sub_1B7944C10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7944C40(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7944C38);
}

char *HgcBT2100_HLG_OOTF_InverseOOTF::shaderDescription@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8375D30;
  strcpy(result, "HgcBT2100_HLG_OOTF_InverseOOTF [hgc1]");
  return result;
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::BindTexture(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::Bind(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::RenderTile(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v68 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v11 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v12 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = *((void *)this + 51);
      float32x4_t v14 = *(float32x4_t *)(v13 + 16);
      float32x4_t v15 = vmulq_f32(v11, *(float32x4_t *)v13);
      float32x4_t v16 = vmulq_f32(v12, *(float32x4_t *)v13);
      int32x4_t v17 = (int32x4_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL), vaddq_f32(v15, (float32x4_t)vrev64q_s32((int32x4_t)v15)));
      int32x4_t v18 = (int32x4_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v16, (int8x16_t)v16, 8uLL), vaddq_f32(v16, (float32x4_t)vrev64q_s32((int32x4_t)v16)));
      float32x4_t v19 = *(float32x4_t *)(v13 + 32);
      float32x4_t v20 = *(float32x4_t *)(v13 + 48);
      int8x16_t v21 = vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v17), v19));
      int8x16_t v22 = vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v18), v19));
      int8x16_t v23 = *(int8x16_t *)(v13 + 64);
      int8x16_t v24 = *(int8x16_t *)(v13 + 80);
      float32x4_t v25 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v17, v21);
      float32x4_t v26 = (float32x4_t)vbslq_s8(v23, (int8x16_t)v18, v22);
      float32x4_t v27 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v25, v24), (int8x16_t)v20);
      float32x4_t v28 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v26, v24), (int8x16_t)v20);
      int8x16_t v29 = *(int8x16_t *)(v13 + 96);
      float32x4_t v30 = *(float32x4_t *)(v13 + 112);
      float32x4_t v31 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v25, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v19, v25)));
      float32x4_t v32 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v19, v26)));
      float32x4_t v33 = *(float32x4_t *)(v13 + 128);
      float32x4_t v34 = *(float32x4_t *)(v13 + 144);
      float32x4_t v35 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v27, v33));
      float32x4_t v36 = (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v28, v33));
      float32x4_t v37 = vaddq_f32(vsubq_f32(v31, v30), v35);
      float32x4_t v38 = vsubq_f32(vsubq_f32(v27, v20), vmulq_f32(vmulq_f32(v34, v35), v27));
      float32x4_t v39 = vsubq_f32(vsubq_f32(v28, v20), vmulq_f32(vmulq_f32(v34, v36), v28));
      float32x4_t v40 = *(float32x4_t *)(v13 + 160);
      float32x4_t v41 = *(float32x4_t *)(v13 + 176);
      float32x4_t v42 = *(float32x4_t *)(v13 + 192);
      float32x4_t v43 = *(float32x4_t *)(v13 + 208);
      float32x4_t v44 = vmulq_f32(v14, vaddq_f32(vaddq_f32(vsubq_f32(v32, v30), v36), vmulq_f32(v39, vaddq_f32(vaddq_f32(v42, vmulq_f32(v43, v39)), vmulq_f32(vmulq_f32(v39, v39), vaddq_f32(v40, vmulq_f32(v41, v39)))))));
      float32x4_t v45 = *(float32x4_t *)(v13 + 224);
      float32x4_t v46 = *(float32x4_t *)(v13 + 240);
      float32x4_t v47 = vmaxq_f32(vmulq_f32(v14, vaddq_f32(v37, vmulq_f32(v38, vaddq_f32(vaddq_f32(v42, vmulq_f32(v43, v38)), vmulq_f32(vmulq_f32(v38, v38), vaddq_f32(v40, vmulq_f32(v41, v38))))))), v45);
      float32x4_t v48 = vmaxq_f32(v44, v45);
      float32x4_t v49 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      float32x4_t v50 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
      float32x4_t v51 = vsubq_f32(v49, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v49, v47)));
      float32x4_t v52 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v50, v48)));
      float32x4_t v53 = vsubq_f32(v47, v51);
      float32x4_t v54 = vsubq_f32(v48, v52);
      float32x4_t v55 = *(float32x4_t *)(v13 + 256);
      float32x4_t v56 = *(float32x4_t *)(v13 + 272);
      float32x4_t v57 = vmulq_f32(v54, vaddq_f32(v56, vmulq_f32(v54, vaddq_f32(v46, vmulq_f32(v55, v54)))));
      float32x4_t v58 = vaddq_f32(v20, vmulq_f32(v53, vaddq_f32(v56, vmulq_f32(v53, vaddq_f32(v46, vmulq_f32(v55, v53))))));
      int32x4_t v59 = vcvtq_s32_f32(v52);
      float32x4_t v60 = vaddq_f32(v20, v57);
      int32x4_t v61 = *(int32x4_t *)(v13 + 288);
      float32x4_t v62 = *(float32x4_t *)(v13 + 304);
      int32x4_t v63 = (int32x4_t)vbslq_s8(v23, (int8x16_t)vmulq_f32(v58, (float32x4_t)vshlq_n_s32(vaddq_s32(v61, vcvtq_s32_f32(v51)), 0x17uLL)), v21);
      int32x4_t v64 = (int32x4_t)vbslq_s8(v23, (int8x16_t)vmulq_f32(v60, (float32x4_t)vshlq_n_s32(vaddq_s32(v61, v59), 0x17uLL)), v22);
      v63.i32[0] = vmulq_lane_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v63), v62), (int8x16_t)v63, (int8x16_t)v62), *(float32x2_t *)v14.f32, 1).u32[0];
      int8x16_t v65 = (int8x16_t)vmulq_n_f32(v12, vmulq_lane_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v64), v62), (int8x16_t)v64, (int8x16_t)v62), *(float32x2_t *)v14.f32, 1).f32[0]);
      int8x16_t v66 = *(int8x16_t *)(v13 + 320);
      float32x4_t v67 = (int8x16_t *)(v5 + v10);
      v67[-1] = vbslq_s8(v66, (int8x16_t)v11, (int8x16_t)vmulq_n_f32(v11, *(float *)v63.i32));
      *float32x4_t v67 = vbslq_s8(v66, (int8x16_t)v12, v65);
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v68 = -v9;
    if (v68 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v69 = 16 * v68;
    float32x4_t v70 = *(float32x4_t *)(v6 + v69);
    uint64_t v71 = *((void *)this + 51);
    float32x4_t v72 = *(float32x4_t *)(v71 + 16);
    float32x4_t v73 = vmulq_f32(v70, *(float32x4_t *)v71);
    int32x4_t v74 = (int32x4_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v73, (int8x16_t)v73, 8uLL), vaddq_f32(v73, (float32x4_t)vrev64q_s32((int32x4_t)v73)));
    float32x4_t v75 = *(float32x4_t *)(v71 + 32);
    float32x4_t v76 = *(float32x4_t *)(v71 + 48);
    int8x16_t v77 = vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v74), v75));
    int8x16_t v78 = *(int8x16_t *)(v71 + 64);
    float32x4_t v79 = (float32x4_t)vbslq_s8(v78, (int8x16_t)v74, v77);
    float32x4_t v80 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v79, *(int8x16_t *)(v71 + 80)), (int8x16_t)v76);
    float32x4_t v81 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v79, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v71 + 96), (int8x16_t)vcgtq_f32(v75, v79))), *(float32x4_t *)(v71 + 112));
    float32x4_t v82 = (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v80, *(float32x4_t *)(v71 + 128)));
    float32x4_t v83 = vaddq_f32(v81, v82);
    float32x4_t v84 = vsubq_f32(vsubq_f32(v80, v76), vmulq_f32(vmulq_f32(*(float32x4_t *)(v71 + 144), v82), v80));
    float32x4_t v85 = vmaxq_f32(vmulq_f32(v72, vaddq_f32(v83, vmulq_f32(v84, vaddq_f32(vaddq_f32(*(float32x4_t *)(v71 + 192), vmulq_f32(*(float32x4_t *)(v71 + 208), v84)), vmulq_f32(vmulq_f32(v84, v84), vaddq_f32(*(float32x4_t *)(v71 + 160), vmulq_f32(*(float32x4_t *)(v71 + 176), v84))))))), *(float32x4_t *)(v71 + 224));
    float32x4_t v86 = vcvtq_f32_s32(vcvtq_s32_f32(v85));
    float32x4_t v87 = vsubq_f32(v86, (float32x4_t)vandq_s8((int8x16_t)v76, (int8x16_t)vcgtq_f32(v86, v85)));
    float32x4_t v88 = vsubq_f32(v85, v87);
    int32x4_t v89 = (int32x4_t)vbslq_s8(v78, (int8x16_t)vmulq_f32(vaddq_f32(v76, vmulq_f32(v88, vaddq_f32(*(float32x4_t *)(v71 + 272), vmulq_f32(v88, vaddq_f32(*(float32x4_t *)(v71 + 240), vmulq_f32(*(float32x4_t *)(v71 + 256), v88)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v71 + 288), vcvtq_s32_f32(v87)), 0x17uLL)), v77);
    *(int8x16_t *)(v5 + v69) = vbslq_s8(*(int8x16_t *)(v71 + 320), (int8x16_t)v70, (int8x16_t)vmulq_n_f32(v70, vmulq_lane_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vrev64q_s32(v89), *(float32x4_t *)(v71 + 304)), (int8x16_t)v89, *(int8x16_t *)(v71 + 304)), *(float32x2_t *)v72.f32, 1).f32[0]));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::GetDOD(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::GetROI(HgcBT2100_HLG_OOTF_InverseOOTF *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(HgcBT2100_HLG_OOTF_InverseOOTF *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F9CE0;
  operator new();
}

void sub_1B79453C4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcBT2100_HLG_OOTF_InverseOOTF::~HgcBT2100_HLG_OOTF_InverseOOTF(HGNode *this)
{
  *(void *)this = &unk_1F10F9CE0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4055B0EC01);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F9CE0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4055B0EC01);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::SetParameter(HgcBT2100_HLG_OOTF_InverseOOTF *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcBT2100_HLG_OOTF_InverseOOTF::GetParameter(HgcBT2100_HLG_OOTF_InverseOOTF *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcLogVideo_encode::GetProgram(HgcLogVideo_encode *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ea\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, half3(hg_Params[1].zzz));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = r0.xyz*half3(hg_Params[1].xxx) + half3(hg_Params[1].yyy);\n"
             "    r1.xyz = log2(r1.xyz);\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].zzz) + half3(hg_Params[0].www);\n"
             "    r0.xyz = half3(half3(hg_Params[1].zzz) < r0.xyz);\n"
             "    output.color0.xyz = select(float3(r2.xyz), float3(r1.xyz), -float3(r0.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=673f7309:ded9e39a:b9dc90f8:646914fe\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000038e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, hg_Params[1].zzz);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = r0.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
             "    r1.xyz = log2(r1.xyz);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].zzz + hg_Params[0].www;\n"
             "    r0.xyz = float3(hg_Params[1].zzz < r0.xyz);\n"
             "    output.color0.xyz = select(r2.xyz, r1.xyz, -r0.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=946613bc:8b4d9cc6:754ac3fe:09391315\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, hg_ProgramLocal1.zzz);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = r0.xyz*hg_ProgramLocal1.xxx + hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = log2(r1.xyz);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.zzz + hg_ProgramLocal0.www;\n"
           "    r0.xyz = vec3(lessThan(hg_ProgramLocal1.zzz, r0.xyz));\n"
           "    gl_FragColor.xyz = vec3(-r0.x < 0.00000 ? r1.x : r2.x, -r0.y < 0.00000 ? r1.y : r2.y, -r0.z < 0.00000 ? r"
           "1.z : r2.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=c36f7dfa:e07ee2fc:60dd5881:8caa6da6\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcLogVideo_encode::InitProgramDescriptor(HgcLogVideo_encode *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcLogVideo_encode_hgc_visible", "//Metal1.0     \n//LEN=000000026a\n[[ visible ]] FragmentOut HgcLogVideo_encode_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, hg_Params[1].zzz);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = r0.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
    "    r1.xyz = log2(r1.xyz);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].zzz + hg_Params[0].www;\n"
    "    r0.xyz = float3(hg_Params[1].zzz < r0.xyz);\n"
    "    output.color0.xyz = select(r2.xyz, r1.xyz, -r0.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcLogVideo_encode");
}

void sub_1B7945864(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7945894(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B794588CLL);
}

double HgcLogVideo_encode::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcLogVideo_encode [hgc1]");
  return *(double *)"eo_encode [hgc1]";
}

uint64_t HgcLogVideo_encode::BindTexture(HgcLogVideo_encode *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcLogVideo_encode::Bind(HgcLogVideo_encode *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcLogVideo_encode::RenderTile(HgcLogVideo_encode *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v58 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v11 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = (_OWORD *)*((void *)this + 51);
      int32x4_t v14 = *((int32x4_t *)v13 + 1);
      float32x4_t v15 = (float32x4_t)vdupq_laneq_s32(v14, 2);
      float32x4_t v16 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 1);
      float32x4_t v17 = vaddq_f32(v16, vmulq_n_f32(vmaxq_f32(v12, v15), COERCE_FLOAT(*v13)));
      float32x4_t v18 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.i8, 1);
      float32x4_t v19 = vaddq_f32(v16, vmulq_n_f32(vmaxq_f32(v11, v15), COERCE_FLOAT(*v13)));
      int8x16_t v20 = (int8x16_t)vaddq_f32(v18, vmulq_n_f32(v12, *(float *)v14.i32));
      float32x4_t v21 = vmulq_n_f32(v11, *(float *)v14.i32);
      int8x16_t v23 = *((int8x16_t *)v13 + 2);
      float32x4_t v22 = *((float32x4_t *)v13 + 3);
      float32x4_t v24 = (float32x4_t)vorrq_s8(vandq_s8(v23, (int8x16_t)v17), (int8x16_t)v22);
      float32x4_t v25 = *((float32x4_t *)v13 + 4);
      int8x16_t v26 = *((int8x16_t *)v13 + 5);
      float32x4_t v27 = (float32x4_t)vorrq_s8(vandq_s8(v23, (int8x16_t)v19), (int8x16_t)v22);
      float32x4_t v28 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v25, v17)));
      float32x4_t v29 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v19, 0x17uLL)), (float32x4_t)vandq_s8(v26, (int8x16_t)vcgtq_f32(v25, v19)));
      float32x4_t v30 = *((float32x4_t *)v13 + 6);
      float32x4_t v31 = *((float32x4_t *)v13 + 7);
      float32x4_t v32 = vsubq_f32(v28, v30);
      float32x4_t v33 = vsubq_f32(v29, v30);
      float32x4_t v34 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v24, v31));
      float32x4_t v35 = (float32x4_t)vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v27, v31));
      float32x4_t v36 = *((float32x4_t *)v13 + 8);
      float32x4_t v37 = *((float32x4_t *)v13 + 9);
      float32x4_t v38 = vaddq_f32(v33, v35);
      float32x4_t v39 = vsubq_f32(vsubq_f32(v24, v22), vmulq_f32(vmulq_f32(v36, v34), v24));
      float32x4_t v40 = vsubq_f32(vsubq_f32(v27, v22), vmulq_f32(vmulq_f32(v36, v35), v27));
      float32x4_t v41 = *((float32x4_t *)v13 + 10);
      float32x4_t v42 = *((float32x4_t *)v13 + 11);
      float32x4_t v43 = vaddq_f32(v37, vmulq_f32(v41, v39));
      float32x4_t v44 = vaddq_f32(v37, vmulq_f32(v41, v40));
      float32x4_t v45 = *((float32x4_t *)v13 + 12);
      int8x16_t v46 = *((int8x16_t *)v13 + 13);
      int8x16_t v47 = (int8x16_t)vaddq_f32(v18, v21);
      float32x4_t v48 = vaddq_f32(vaddq_f32(v32, v34), vmulq_f32(v39, vaddq_f32(vaddq_f32(v42, vmulq_f32(v45, v39)), vmulq_f32(vmulq_f32(v39, v39), v43))));
      float32x4_t v49 = vmulq_f32(v40, vaddq_f32(vaddq_f32(v42, vmulq_f32(v45, v40)), vmulq_f32(vmulq_f32(v40, v40), v44)));
      float32x4_t v50 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v13, 3);
      float32x4_t v51 = vmulq_laneq_f32(vaddq_f32(v38, v49), *(float32x4_t *)v13, 2);
      int8x16_t v52 = (int8x16_t)vcgtq_f32(v12, v15);
      int8x16_t v53 = vandq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(v11, v15));
      float32x4_t v54 = (float32x4_t)vbslq_s8(v46, (int8x16_t)v12, vandq_s8((int8x16_t)v22, v52));
      float32x4_t v55 = *((float32x4_t *)v13 + 14);
      int8x16_t v56 = vbslq_s8(v46, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32(v54, v55), (int8x16_t)vaddq_f32(v50, vmulq_laneq_f32(v48, *(float32x4_t *)v13, 2)), v20));
      float32x4_t v57 = (int8x16_t *)(v5 + v10);
      v57[-1] = v56;
      *float32x4_t v57 = vbslq_s8(v46, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v46, (int8x16_t)v11, v53), v55), (int8x16_t)vaddq_f32(v50, v51), v47));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v58 = -v9;
    if (v58 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v59 = 16 * v58;
    float32x4_t v60 = *(float32x4_t *)(v6 + v59);
    int32x4_t v61 = (_OWORD *)*((void *)this + 51);
    int32x4_t v62 = *((int32x4_t *)v61 + 1);
    float32x4_t v63 = (float32x4_t)vdupq_laneq_s32(v62, 2);
    float32x4_t v64 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v61, 1), vmulq_n_f32(vmaxq_f32(v60, v63), COERCE_FLOAT(*v61)));
    float32x4_t v65 = *((float32x4_t *)v61 + 3);
    float32x4_t v66 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)v61 + 2), (int8x16_t)v64), (int8x16_t)v65);
    float32x4_t v67 = (float32x4_t)vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_f32(v66, *((float32x4_t *)v61 + 7)));
    float32x4_t v68 = vsubq_f32(vsubq_f32(v66, v65), vmulq_f32(vmulq_f32(*((float32x4_t *)v61 + 8), v67), v66));
    *(int8x16_t *)(v5 + v59) = vbslq_s8(*((int8x16_t *)v61 + 13), (int8x16_t)v60, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)v61 + 13), (int8x16_t)v60, vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_f32(v60, v63))), *((float32x4_t *)v61 + 14)), (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v61, 3), vmulq_laneq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v64, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)v61 + 5),
                                                                         (int8x16_t)vcgtq_f32(*((float32x4_t *)v61 + 4), v64))), *((float32x4_t *)v61 + 6)), v67), vmulq_f32(v68, vaddq_f32(vaddq_f32(*((float32x4_t *)v61 + 11), vmulq_f32(*((float32x4_t *)v61 + 12), v68)), vmulq_f32(vmulq_f32(v68, v68), vaddq_f32(*((float32x4_t *)v61 + 9), vmulq_f32(*((float32x4_t *)v61 + 10), v68)))))), *(float32x4_t *)v61, 2)), (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v62.i8, 1),
                                                vmulq_n_f32(v60, *(float *)v62.i32))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcLogVideo_encode::GetDOD(HgcLogVideo_encode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcLogVideo_encode::GetROI(HgcLogVideo_encode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcLogVideo_encode::HgcLogVideo_encode(HgcLogVideo_encode *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10F9F48;
  operator new();
}

void sub_1B7945EE8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcLogVideo_encode::~HgcLogVideo_encode(HGNode *this)
{
  *(void *)this = &unk_1F10F9F48;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4019FCA701);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10F9F48;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4019FCA701);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcLogVideo_encode::SetParameter(HgcLogVideo_encode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcLogVideo_encode::GetParameter(HgcLogVideo_encode *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcLogVideo_decode::GetProgram(HgcLogVideo_decode *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003b6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*half3(hg_Params[0].zzz) + half3(hg_Params[0].www);\n"
             "    r2.xyz = r0.xyz*half3(hg_Params[1].xxx) + half3(hg_Params[1].yyy);\n"
             "    r1.xyz = exp2(r1.xyz);\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r0.xyz = half3(half3(hg_Params[1].zzz) < r0.xyz);\n"
             "    output.color0.xyz = select(float3(r2.xyz), float3(r1.xyz), -float3(r0.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=89281f2e:27643c8f:eb416052:f572fac4\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000361\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz*hg_Params[0].zzz + hg_Params[0].www;\n"
             "    r2.xyz = r0.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
             "    r1.xyz = exp2(r1.xyz);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r0.xyz = float3(hg_Params[1].zzz < r0.xyz);\n"
             "    output.color0.xyz = select(r2.xyz, r1.xyz, -r0.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6fc31554:61839044:78b681d8:1e3d981b\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003a9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz*hg_ProgramLocal0.zzz + hg_ProgramLocal0.www;\n"
           "    r2.xyz = r0.xyz*hg_ProgramLocal1.xxx + hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = exp2(r1.xyz);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r0.xyz = vec3(lessThan(hg_ProgramLocal1.zzz, r0.xyz));\n"
           "    gl_FragColor.xyz = vec3(-r0.x < 0.00000 ? r1.x : r2.x, -r0.y < 0.00000 ? r1.y : r2.y, -r0.z < 0.00000 ? r"
           "1.z : r2.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=0d96987c:05a426f8:85bbe0c4:660414d1\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcLogVideo_decode::InitProgramDescriptor(HgcLogVideo_decode *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcLogVideo_decode_hgc_visible", "//Metal1.0     \n//LEN=000000023d\n[[ visible ]] FragmentOut HgcLogVideo_decode_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz*hg_Params[0].zzz + hg_Params[0].www;\n"
    "    r2.xyz = r0.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
    "    r1.xyz = exp2(r1.xyz);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r0.xyz = float3(hg_Params[1].zzz < r0.xyz);\n"
    "    output.color0.xyz = select(r2.xyz, r1.xyz, -r0.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcLogVideo_decode");
}

void sub_1B7946388(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B79463B8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B79463B0);
}

double HgcLogVideo_decode::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcLogVideo_decode [hgc1]");
  return *(double *)"eo_decode [hgc1]";
}

uint64_t HgcLogVideo_decode::BindTexture(HgcLogVideo_decode *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcLogVideo_decode::Bind(HgcLogVideo_decode *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcLogVideo_decode::RenderTile(HgcLogVideo_decode *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v47 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v11 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = (_OWORD *)*((void *)this + 51);
      int32x4_t v14 = *((int32x4_t *)v13 + 1);
      float32x4_t v15 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v13, 3);
      float32x4_t v16 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.i8, 1);
      int8x16_t v17 = (int8x16_t)vaddq_f32(v16, vmulq_n_f32(v12, *(float *)v14.i32));
      int8x16_t v18 = (int8x16_t)vaddq_f32(v16, vmulq_n_f32(v11, *(float *)v14.i32));
      float32x4_t v19 = *((float32x4_t *)v13 + 2);
      float32x4_t v20 = *((float32x4_t *)v13 + 3);
      float32x4_t v21 = vmaxq_f32(vaddq_f32(v15, vmulq_laneq_f32(v12, *(float32x4_t *)v13, 2)), v19);
      float32x4_t v22 = vmaxq_f32(vaddq_f32(v15, vmulq_laneq_f32(v11, *(float32x4_t *)v13, 2)), v19);
      float32x4_t v23 = vcvtq_f32_s32(vcvtq_s32_f32(v21));
      float32x4_t v24 = vcvtq_f32_s32(vcvtq_s32_f32(v22));
      float32x4_t v25 = vsubq_f32(v23, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v23, v21)));
      float32x4_t v26 = vsubq_f32(v24, (float32x4_t)vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v24, v22)));
      float32x4_t v27 = vsubq_f32(v21, v25);
      float32x4_t v28 = vsubq_f32(v22, v26);
      float32x4_t v29 = *((float32x4_t *)v13 + 4);
      float32x4_t v30 = *((float32x4_t *)v13 + 5);
      float32x4_t v31 = vaddq_f32(v29, vmulq_f32(v30, v27));
      float32x4_t v32 = vaddq_f32(v29, vmulq_f32(v30, v28));
      float32x4_t v33 = vmulq_f32(v27, v31);
      float32x4_t v34 = *((float32x4_t *)v13 + 6);
      int32x4_t v35 = *((int32x4_t *)v13 + 7);
      float32x4_t v36 = vmulq_f32(vaddq_f32(v20, vmulq_f32(v27, vaddq_f32(v34, v33))), (float32x4_t)vshlq_n_s32(vaddq_s32(v35, vcvtq_s32_f32(v25)), 0x17uLL));
      float32x4_t v37 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 1);
      float32x4_t v38 = vmulq_n_f32(vmulq_f32(vaddq_f32(v20, vmulq_f32(v28, vaddq_f32(v34, vmulq_f32(v28, v32)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v35, vcvtq_s32_f32(v26)), 0x17uLL)), COERCE_FLOAT(*v13));
      int8x16_t v39 = (int8x16_t)vaddq_f32(v37, vmulq_n_f32(v36, COERCE_FLOAT(*v13)));
      float32x4_t v40 = (float32x4_t)vdupq_laneq_s32(v14, 2);
      int8x16_t v41 = vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v12, v40));
      int8x16_t v42 = (int8x16_t)vaddq_f32(v37, v38);
      int8x16_t v43 = vandq_s8((int8x16_t)v20, (int8x16_t)vcgtq_f32(v11, v40));
      int8x16_t v44 = *((int8x16_t *)v13 + 8);
      float32x4_t v45 = *((float32x4_t *)v13 + 9);
      int8x16_t v46 = (int8x16_t *)(v5 + v10);
      v46[-1] = vbslq_s8(v44, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v44, (int8x16_t)v12, v41), v45), v39, v17));
      *int8x16_t v46 = vbslq_s8(v44, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v44, (int8x16_t)v11, v43), v45), v42, v18));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v47 = -v9;
    if (v47 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v48 = 16 * v47;
    float32x4_t v49 = *(float32x4_t *)(v6 + v48);
    float32x4_t v50 = (_OWORD *)*((void *)this + 51);
    float32x4_t v51 = *((float32x4_t *)v50 + 3);
    float32x4_t v52 = vmaxq_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v50, 3), vmulq_laneq_f32(v49, *(float32x4_t *)v50, 2)), *((float32x4_t *)v50 + 2));
    float32x4_t v53 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
    float32x4_t v54 = vsubq_f32(v53, (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v53, v52)));
    float32x4_t v55 = vsubq_f32(v52, v54);
    *(int8x16_t *)(v5 + v48) = vbslq_s8(*((int8x16_t *)v50 + 8), (int8x16_t)v49, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)v50 + 8), (int8x16_t)v49, vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v49, (float32x4_t)vdupq_laneq_s32(*((int32x4_t *)v50 + 1), 2)))), *((float32x4_t *)v50 + 9)), (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50, 1), vmulq_n_f32(vmulq_f32(
                                                    vaddq_f32(v51, vmulq_f32(v55, vaddq_f32(*((float32x4_t *)v50 + 6), vmulq_f32(v55, vaddq_f32(*((float32x4_t *)v50 + 4), vmulq_f32(*((float32x4_t *)v50 + 5), v55)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)v50 + 7), vcvtq_s32_f32(v54)), 0x17uLL)), COERCE_FLOAT(*v50))), (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v50[1], 1), vmulq_n_f32(v49, COERCE_FLOAT(v50[1])))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcLogVideo_decode::GetDOD(HgcLogVideo_decode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcLogVideo_decode::GetROI(HgcLogVideo_decode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcLogVideo_decode::HgcLogVideo_decode(HgcLogVideo_decode *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10FA1B0;
  operator new();
}

void sub_1B7946960(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcLogVideo_decode::~HgcLogVideo_decode(HGNode *this)
{
  *(void *)this = &unk_1F10FA1B0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B8406A4ELL);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10FA1B0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B8406A4ELL);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcLogVideo_decode::SetParameter(HgcLogVideo_decode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcLogVideo_decode::GetParameter(HgcLogVideo_decode *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcSony709_800_MLUT::GetProgram(HgcSony709_800_MLUT *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000056b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[0].xxx);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[2].xxx);\n"
             "    r3.xyz = r0.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].www));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[1].yyy) + half3(hg_Params[1].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[2].zzz) + c0.yyy;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    r5.xyz = half3(r0.xyz >= half3(hg_Params[0].yyy));\n"
             "    r5.xyz = r5.xyz*r1.xyz + r3.xyz;\n"
             "    r4.xyz = half3(hg_Params[1].www)/r4.xyz;\n"
             "    r2.xyz = pow(r2.xyz, r4.xyz);\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[2].yyy) + -r5.xyz;\n"
             "    r0.xyz = half3(r0.xyz >= half3(hg_Params[0].zzz));\n"
             "    output.color0.xyz = float3(r0.xyz)*float3(r2.xyz) + float3(r5.xyz);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=7b171a2a:157267ef:87e4d2e2:1035cfc2\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0006:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004fd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xyz = r0.xyz + hg_Params[0].xxx;\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz*hg_Params[2].xxx;\n"
             "    r3.xyz = r0.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].www);\n"
             "    r1.xyz = r1.xyz*hg_Params[1].yyy + hg_Params[1].zzz;\n"
             "    r4.xyz = r2.xyz*hg_Params[2].zzz + c0.yyy;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    r5.xyz = float3(r0.xyz >= hg_Params[0].yyy);\n"
             "    r5.xyz = r5.xyz*r1.xyz + r3.xyz;\n"
             "    r4.xyz = hg_Params[1].www/r4.xyz;\n"
             "    r2.xyz = pow(r2.xyz, r4.xyz);\n"
             "    r2.xyz = r2.xyz*hg_Params[2].yyy + -r5.xyz;\n"
             "    r0.xyz = float3(r0.xyz >= hg_Params[0].zzz);\n"
             "    output.color0.xyz = r0.xyz*r2.xyz + r5.xyz;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=33f92460:9b78ada8:8b346e0c:2f6489c6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0006:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000055d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal0.xxx;\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz*hg_ProgramLocal2.xxx;\n"
           "    r3.xyz = r0.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.www);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal1.yyy + hg_ProgramLocal1.zzz;\n"
           "    r4.xyz = r2.xyz*hg_ProgramLocal2.zzz + c0.yyy;\n"
           "    r1.xyz = r1.xyz - r3.xyz;\n"
           "    r5.xyz = vec3(greaterThanEqual(r0.xyz, hg_ProgramLocal0.yyy));\n"
           "    r5.xyz = r5.xyz*r1.xyz + r3.xyz;\n"
           "    r4.xyz = hg_ProgramLocal1.www/r4.xyz;\n"
           "    r2.xyz = pow(r2.xyz, r4.xyz);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal2.yyy + -r5.xyz;\n"
           "    r0.xyz = vec3(greaterThanEqual(r0.xyz, hg_ProgramLocal0.zzz));\n"
           "    gl_FragColor.xyz = r0.xyz*r2.xyz + r5.xyz;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=c888713c:7accba57:13c6ff48:9a1ff1c4\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0006:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcSony709_800_MLUT::InitProgramDescriptor(HgcSony709_800_MLUT *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcSony709_800_MLUT_hgc_visible", "//Metal1.0     \n//LEN=00000003da\n[[ visible ]] FragmentOut HgcSony709_800_MLUT_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0.xyz = r0.xyz + hg_Params[0].xxx;\n"
    "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    r2.xyz = r1.xyz*hg_Params[2].xxx;\n"
    "    r3.xyz = r0.xyz*hg_Params[1].xxx;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].www);\n"
    "    r1.xyz = r1.xyz*hg_Params[1].yyy + hg_Params[1].zzz;\n"
    "    r4.xyz = r2.xyz*hg_Params[2].zzz + c0.yyy;\n"
    "    r1.xyz = r1.xyz - r3.xyz;\n"
    "    r5.xyz = float3(r0.xyz >= hg_Params[0].yyy);\n"
    "    r5.xyz = r5.xyz*r1.xyz + r3.xyz;\n"
    "    r4.xyz = hg_Params[1].www/r4.xyz;\n"
    "    r2.xyz = pow(r2.xyz, r4.xyz);\n"
    "    r2.xyz = r2.xyz*hg_Params[2].yyy + -r5.xyz;\n"
    "    r0.xyz = float3(r0.xyz >= hg_Params[0].zzz);\n"
    "    output.color0.xyz = r0.xyz*r2.xyz + r5.xyz;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcSony709_800_MLUT");
}

void sub_1B7946E00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7946E30(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7946E28);
}

double HgcSony709_800_MLUT::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8377840;
  strcpy(v3, "HgcSony709_800_MLUT [hgc1]");
  return *(double *)"_800_MLUT [hgc1]";
}

uint64_t HgcSony709_800_MLUT::BindTexture(HgcSony709_800_MLUT *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcSony709_800_MLUT::Bind(HgcSony709_800_MLUT *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcSony709_800_MLUT::RenderTile(HgcSony709_800_MLUT *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v111 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v11 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v12 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = *((void *)this + 51);
      float32x4_t v14 = *(float32x4_t *)(v13 + 16);
      float32x4_t v15 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 0);
      float32x4_t v17 = *(float32x4_t *)(v13 + 32);
      int8x16_t v16 = *(int8x16_t *)(v13 + 48);
      float32x4_t v18 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v11, (int8x16_t)vaddq_f32(v11, v15));
      float32x4_t v19 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)vaddq_f32(v12, v15));
      float32x4_t v20 = *(float32x4_t *)(v13 + 64);
      int8x16_t v21 = *(int8x16_t *)(v13 + 80);
      float32x4_t v22 = vmaxq_f32(v18, v20);
      float32x4_t v23 = vmaxq_f32(v19, v20);
      float32x4_t v24 = vmulq_n_f32(v22, v17.f32[0]);
      float32x4_t v25 = vmulq_n_f32(v23, v17.f32[0]);
      float32x4_t v26 = *(float32x4_t *)(v13 + 96);
      float32x4_t v27 = *(float32x4_t *)(v13 + 112);
      float32x4_t v28 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v22), (int8x16_t)v26);
      int8x16_t v30 = *(int8x16_t *)(v13 + 128);
      float32x4_t v29 = *(float32x4_t *)(v13 + 144);
      float32x4_t v31 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v23), (int8x16_t)v26);
      float32x4_t v32 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v27, v23))), v29);
      float32x4_t v34 = *(float32x4_t *)(v13 + 160);
      float32x4_t v33 = *(float32x4_t *)(v13 + 176);
      float32x4_t v35 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v28, v34));
      float32x4_t v36 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v31, v34));
      float32x4_t v37 = vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x17uLL)), (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v27, v22))), v29), v35);
      float32x4_t v38 = vmulq_f32(v33, v35);
      float32x4_t v39 = vmulq_f32(vmulq_f32(v33, v36), v31);
      float32x4_t v40 = vaddq_f32(v32, v36);
      float32x4_t v41 = vsubq_f32(v31, v26);
      float32x4_t v42 = vsubq_f32(vsubq_f32(v28, v26), vmulq_f32(v38, v28));
      float32x4_t v43 = vsubq_f32(v41, v39);
      float32x4_t v44 = *(float32x4_t *)(v13 + 192);
      float32x4_t v45 = *(float32x4_t *)(v13 + 208);
      float32x4_t v46 = *(float32x4_t *)(v13 + 224);
      float32x4_t v47 = *(float32x4_t *)(v13 + 240);
      float32x4_t v48 = vaddq_f32(v37, vmulq_f32(v42, vaddq_f32(vaddq_f32(v46, vmulq_f32(v42, v47)), vmulq_f32(vmulq_f32(v42, v42), vaddq_f32(v44, vmulq_f32(v45, v42))))));
      float32x4_t v49 = vaddq_f32(v26, vmulq_laneq_f32(v24, v17, 2));
      float32x4_t v50 = vaddq_f32(v26, vmulq_laneq_f32(v25, v17, 2));
      float32x4_t v51 = vaddq_f32(v40, vmulq_f32(v43, vaddq_f32(vaddq_f32(v46, vmulq_f32(v43, v47)), vmulq_f32(vmulq_f32(v43, v43), vaddq_f32(v44, vmulq_f32(v45, v43))))));
      float32x4_t v52 = *(float32x4_t *)(v13 + 336);
      float32x4_t v53 = vmulq_f32(vrecpeq_f32(v49), v52);
      float32x4_t v54 = vmulq_f32(vrecpeq_f32(v50), v52);
      float32x4_t v55 = *(float32x4_t *)(v13 + 352);
      float32x4_t v56 = *(float32x4_t *)(v13 + 368);
      float32x4_t v57 = vminq_f32(vmaxq_f32(v53, v55), v56);
      float32x4_t v58 = vminq_f32(vmaxq_f32(v54, v55), v56);
      float32x4_t v59 = vmulq_laneq_f32(v51, v14, 3);
      float32x4_t v60 = vmulq_f32(v57, vrecpsq_f32(v49, v57));
      float32x4_t v61 = *(float32x4_t *)(v13 + 256);
      float32x4_t v62 = *(float32x4_t *)(v13 + 272);
      float32x4_t v63 = vmaxq_f32(vmulq_laneq_f32(v48, v14, 3), v61);
      float32x4_t v64 = vmulq_f32(v58, vrecpsq_f32(v50, v58));
      float32x4_t v65 = (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v27, v24));
      float32x4_t v66 = (float32x4_t)vandq_s8(v30, (int8x16_t)vcgtq_f32(v27, v25));
      float32x4_t v67 = vmaxq_f32(v59, v61);
      float32x4_t v68 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v24), (int8x16_t)v26);
      float32x4_t v69 = (float32x4_t)vorrq_s8(vandq_s8(v21, (int8x16_t)v25), (int8x16_t)v26);
      float32x4_t v70 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x17uLL)), v65), v29);
      float32x4_t v71 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v25, 0x17uLL)), v66), v29);
      float32x4_t v72 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v68, v34));
      float32x4_t v73 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
      float32x4_t v74 = (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v69, v34));
      float32x4_t v75 = vaddq_f32(v70, v72);
      float32x4_t v76 = vaddq_f32(v71, v74);
      float32x4_t v77 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
      float32x4_t v78 = vsubq_f32(vsubq_f32(v68, v26), vmulq_f32(vmulq_f32(v33, v72), v68));
      float32x4_t v79 = vsubq_f32(vsubq_f32(v69, v26), vmulq_f32(vmulq_f32(v33, v74), v69));
      float32x4_t v80 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v73, v63)));
      float32x4_t v81 = vaddq_f32(v44, vmulq_f32(v45, v78));
      float32x4_t v82 = vaddq_f32(v44, vmulq_f32(v45, v79));
      float32x4_t v84 = *(float32x4_t *)(v13 + 288);
      float32x4_t v83 = *(float32x4_t *)(v13 + 304);
      float32x4_t v85 = vsubq_f32(v77, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v77, v67)));
      float32x4_t v86 = vsubq_f32(v63, v80);
      float32x4_t v87 = vsubq_f32(v67, v85);
      float32x4_t v88 = vaddq_f32(v75, vmulq_f32(v78, vaddq_f32(vaddq_f32(v46, vmulq_f32(v78, v47)), vmulq_f32(vmulq_f32(v78, v78), v81))));
      float32x4_t v89 = vmulq_f32(v87, vaddq_f32(v83, vmulq_f32(v87, vaddq_f32(v62, vmulq_f32(v84, v87)))));
      int32x4_t v90 = *(int32x4_t *)(v13 + 320);
      float32x4_t v91 = vmulq_f32(vaddq_f32(v26, v89), (float32x4_t)vshlq_n_s32(vaddq_s32(v90, vcvtq_s32_f32(v85)), 0x17uLL));
      float32x4_t v92 = vmulq_n_f32(v18, v14.f32[0]);
      float32x4_t v93 = vaddq_f32(v76, vmulq_f32(v79, vaddq_f32(vaddq_f32(v46, vmulq_f32(v79, v47)), vmulq_f32(vmulq_f32(v79, v79), v82))));
      float32x4_t v94 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2);
      float32x4_t v95 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 1);
      float32x4_t v96 = vaddq_f32(v94, vmulq_lane_f32(vmulq_f32(vaddq_f32(v26, vmulq_f32(v86, vaddq_f32(v83, vmulq_f32(v86, vaddq_f32(v62, vmulq_f32(v84, v86)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v90, vcvtq_s32_f32(v80)), 0x17uLL)), *(float32x2_t *)v14.f32, 1));
      float32x4_t v97 = vmaxq_f32(vmulq_f32(v88, vmulq_laneq_f32(v60, v14, 3)), v61);
      float32x4_t v98 = vmaxq_f32(vmulq_f32(v93, vmulq_laneq_f32(v64, v14, 3)), v61);
      float32x4_t v99 = vaddq_f32(v94, vmulq_lane_f32(v91, *(float32x2_t *)v14.f32, 1));
      float32x4_t v100 = vcvtq_f32_s32(vcvtq_s32_f32(v97));
      float32x4_t v101 = vcvtq_f32_s32(vcvtq_s32_f32(v98));
      float32x4_t v102 = vsubq_f32(v100, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v100, v97)));
      float32x4_t v103 = vsubq_f32(v101, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v101, v98)));
      float32x4_t v104 = vmulq_n_f32(v19, v14.f32[0]);
      float32x4_t v105 = vsubq_f32(v97, v102);
      float32x4_t v106 = vsubq_f32(v98, v103);
      float32x4_t v107 = vaddq_f32(v92, vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgeq_f32(v18, v95)), vsubq_f32(v96, v92)));
      float32x4_t v108 = vaddq_f32(v104, vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgeq_f32(v19, v95)), vsubq_f32(v99, v104)));
      float32x4_t v109 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v13, 2);
      uint64_t v110 = (int8x16_t *)(v5 + v10);
      v110[-1] = vbslq_s8(v16, (int8x16_t)v11, (int8x16_t)vaddq_f32(v107, vmulq_f32(vsubq_f32(vmulq_lane_f32(vmulq_f32(vaddq_f32(v26, vmulq_f32(v105, vaddq_f32(v83, vmulq_f32(v105, vaddq_f32(v62, vmulq_f32(v84, v105)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v102), v90), 0x17uLL)), *(float32x2_t *)v17.f32, 1), v107), (float32x4_t)vbslq_s8(v16,
                                                 (int8x16_t)v11,
                                                 vandq_s8((int8x16_t)v26, (int8x16_t)vcgeq_f32(v18, v109))))));
      *uint64_t v110 = vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)vaddq_f32(v108, vmulq_f32(vsubq_f32(vmulq_lane_f32(vmulq_f32(vaddq_f32(v26, vmulq_f32(v106, vaddq_f32(v83, vmulq_f32(v106, vaddq_f32(v62, vmulq_f32(v84, v106)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v103), v90), 0x17uLL)), *(float32x2_t *)v17.f32, 1), v108), (float32x4_t)vbslq_s8(v16,
                                              (int8x16_t)v12,
                                              vandq_s8((int8x16_t)v26, (int8x16_t)vcgeq_f32(v19, v109))))));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v111 = -v9;
    if (v111 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v112 = 16 * v111;
    float32x4_t v113 = *(float32x4_t *)(v6 + v112);
    uint64_t v114 = *((void *)this + 51);
    float32x4_t v115 = *(float32x4_t *)(v114 + 16);
    float32x4_t v117 = *(float32x4_t *)(v114 + 32);
    int8x16_t v116 = *(int8x16_t *)(v114 + 48);
    float32x4_t v118 = (float32x4_t)vbslq_s8(v116, (int8x16_t)v113, (int8x16_t)vaddq_f32(v113, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114, 0)));
    int8x16_t v119 = *(int8x16_t *)(v114 + 80);
    float32x4_t v120 = vmaxq_f32(v118, *(float32x4_t *)(v114 + 64));
    float32x4_t v121 = vmulq_n_f32(v120, v117.f32[0]);
    float32x4_t v122 = vmulq_n_f32(v118, v115.f32[0]);
    float32x4_t v123 = *(float32x4_t *)(v114 + 96);
    float32x4_t v124 = *(float32x4_t *)(v114 + 112);
    float32x4_t v125 = (float32x4_t)vorrq_s8(vandq_s8(v119, (int8x16_t)v120), (int8x16_t)v123);
    int8x16_t v126 = *(int8x16_t *)(v114 + 128);
    float32x4_t v127 = *(float32x4_t *)(v114 + 144);
    float32x4_t v128 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v120, 0x17uLL)), (float32x4_t)vandq_s8(v126, (int8x16_t)vcgtq_f32(v124, v120))), v127);
    float32x4_t v129 = *(float32x4_t *)(v114 + 160);
    float32x4_t v130 = *(float32x4_t *)(v114 + 176);
    float32x4_t v131 = (float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgtq_f32(v125, v129));
    float32x4_t v132 = vaddq_f32(v128, v131);
    float32x4_t v133 = vsubq_f32(vsubq_f32(v125, v123), vmulq_f32(vmulq_f32(v130, v131), v125));
    float32x4_t v134 = *(float32x4_t *)(v114 + 192);
    float32x4_t v135 = *(float32x4_t *)(v114 + 208);
    float32x4_t v136 = *(float32x4_t *)(v114 + 224);
    float32x4_t v137 = *(float32x4_t *)(v114 + 240);
    float32x4_t v138 = vmulq_laneq_f32(vaddq_f32(v132, vmulq_f32(v133, vaddq_f32(vaddq_f32(v136, vmulq_f32(v133, v137)), vmulq_f32(vmulq_f32(v133, v133), vaddq_f32(v134, vmulq_f32(v135, v133)))))), v115, 3);
    float32x4_t v139 = *(float32x4_t *)(v114 + 256);
    float32x4_t v140 = *(float32x4_t *)(v114 + 272);
    float32x4_t v141 = vmaxq_f32(v138, v139);
    float32x4_t v142 = vcvtq_f32_s32(vcvtq_s32_f32(v141));
    float32x4_t v143 = vsubq_f32(v142, (float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgtq_f32(v142, v141)));
    float32x4_t v144 = vsubq_f32(v141, v143);
    float32x4_t v146 = *(float32x4_t *)(v114 + 288);
    float32x4_t v145 = *(float32x4_t *)(v114 + 304);
    int32x4_t v147 = *(int32x4_t *)(v114 + 320);
    float32x4_t v148 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v115, 2), vmulq_lane_f32(vmulq_f32(vaddq_f32(v123, vmulq_f32(v144, vaddq_f32(v145, vmulq_f32(v144, vaddq_f32(v140, vmulq_f32(v146, v144)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v147, vcvtq_s32_f32(v143)), 0x17uLL)), *(float32x2_t *)v115.f32, 1));
    float32x4_t v149 = vaddq_f32(v123, vmulq_laneq_f32(v121, v117, 2));
    float32x4_t v150 = vaddq_f32(v122, vmulq_f32((float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgeq_f32(v118, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114, 1))), vsubq_f32(v148, v122)));
    float32x4_t v151 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v149), *(float32x4_t *)(v114 + 336)), *(float32x4_t *)(v114 + 352)), *(float32x4_t *)(v114 + 368));
    float32x4_t v152 = (float32x4_t)vorrq_s8(vandq_s8(v119, (int8x16_t)v121), (int8x16_t)v123);
    float32x4_t v153 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v121, 0x17uLL)), (float32x4_t)vandq_s8(v126, (int8x16_t)vcgtq_f32(v124, v121))), v127);
    float32x4_t v154 = (float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgtq_f32(v152, v129));
    float32x4_t v155 = vsubq_f32(vsubq_f32(v152, v123), vmulq_f32(vmulq_f32(v130, v154), v152));
    float32x4_t v156 = vmaxq_f32(vmulq_f32(vaddq_f32(vaddq_f32(v153, v154), vmulq_f32(v155, vaddq_f32(vaddq_f32(v136, vmulq_f32(v155, v137)), vmulq_f32(vmulq_f32(v155, v155), vaddq_f32(v134, vmulq_f32(v135, v155)))))), vmulq_laneq_f32(vmulq_f32(v151, vrecpsq_f32(v149, v151)), v115, 3)), v139);
    float32x4_t v157 = vcvtq_f32_s32(vcvtq_s32_f32(v156));
    float32x4_t v158 = vsubq_f32(v157, (float32x4_t)vandq_s8((int8x16_t)v123, (int8x16_t)vcgtq_f32(v157, v156)));
    float32x4_t v159 = vsubq_f32(v156, v158);
    *(int8x16_t *)(v5 + v112) = vbslq_s8(v116, (int8x16_t)v113, (int8x16_t)vaddq_f32(v150, vmulq_f32(vsubq_f32(vmulq_lane_f32(vmulq_f32(vaddq_f32(v123, vmulq_f32(v159, vaddq_f32(v145, vmulq_f32(v159, vaddq_f32(v140, vmulq_f32(v146, v159)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(vcvtq_s32_f32(v158), v147), 0x17uLL)), *(float32x2_t *)v117.f32,
                                                     1),
                                                   v150),
                                                 (float32x4_t)vbslq_s8(v116, (int8x16_t)v113, vandq_s8((int8x16_t)v123, (int8x16_t)vcgeq_f32(v118, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v114, 2)))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcSony709_800_MLUT::GetDOD(HgcSony709_800_MLUT *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcSony709_800_MLUT::GetROI(HgcSony709_800_MLUT *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcSony709_800_MLUT::HgcSony709_800_MLUT(HgcSony709_800_MLUT *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10FA418;
  operator new();
}

void sub_1B79478D8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcSony709_800_MLUT::~HgcSony709_800_MLUT(HGNode *this)
{
  *(void *)this = &unk_1F10FA418;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C400F47AF14);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10FA418;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C400F47AF14);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcSony709_800_MLUT::SetParameter(HgcSony709_800_MLUT *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcSony709_800_MLUT::GetParameter(HgcSony709_800_MLUT *this, unsigned int a2, float *a3)
{
  if (a2 > 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcCanonLog_encode::GetProgram(HgcCanonLog_encode *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003cf\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz)*half3(hg_Params[0].zzz);\n"
             "    r2.xyz = half3(r0.xyz < c0.xxx);\n"
             "    r0.xyz = half3(c0.xxx < r0.xyz);\n"
             "    r0.xyz = r0.xyz - r2.xyz;\n"
             "    r1.xyz = r1.xyz + c0.yyy;\n"
             "    r0.xyz = r0.xyz*half3(hg_Params[0].xxx);\n"
             "    r1.xyz = log2(r1.xyz);\n"
             "    output.color0.xyz = float3(r0.xyz)*float3(r1.xyz) + hg_Params[0].yyy;\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=3cb30ea7:184d1a1c:e362e55b:bc915a63\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003a8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz)*hg_Params[0].zzz;\n"
             "    r2.xyz = float3(r0.xyz < c0.xxx);\n"
             "    r0.xyz = float3(c0.xxx < r0.xyz);\n"
             "    r0.xyz = r0.xyz - r2.xyz;\n"
             "    r1.xyz = r1.xyz + c0.yyy;\n"
             "    r0.xyz = r0.xyz*hg_Params[0].xxx;\n"
             "    r1.xyz = log2(r1.xyz);\n"
             "    output.color0.xyz = r0.xyz*r1.xyz + hg_Params[0].yyy;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=24f0a63e:b72cd12f:57b86ae8:8b63bce0\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000038c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = abs(r0.xyz)*hg_ProgramLocal0.zzz;\n"
           "    r2.xyz = vec3(lessThan(r0.xyz, c0.xxx));\n"
           "    r0.xyz = vec3(lessThan(c0.xxx, r0.xyz));\n"
           "    r0.xyz = r0.xyz - r2.xyz;\n"
           "    r1.xyz = r1.xyz + c0.yyy;\n"
           "    r0.xyz = r0.xyz*hg_ProgramLocal0.xxx;\n"
           "    r1.xyz = log2(r1.xyz);\n"
           "    gl_FragColor.xyz = r0.xyz*r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=7914ca2c:7a3f0945:4a5f2d4f:23b380ff\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcCanonLog_encode::InitProgramDescriptor(HgcCanonLog_encode *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcCanonLog_encode_hgc_visible", "//Metal1.0     \n//LEN=0000000284\n[[ visible ]] FragmentOut HgcCanonLog_encode_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fabs(r0.xyz)*hg_Params[0].zzz;\n"
    "    r2.xyz = float3(r0.xyz < c0.xxx);\n"
    "    r0.xyz = float3(c0.xxx < r0.xyz);\n"
    "    r0.xyz = r0.xyz - r2.xyz;\n"
    "    r1.xyz = r1.xyz + c0.yyy;\n"
    "    r0.xyz = r0.xyz*hg_Params[0].xxx;\n"
    "    r1.xyz = log2(r1.xyz);\n"
    "    output.color0.xyz = r0.xyz*r1.xyz + hg_Params[0].yyy;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcCanonLog_encode");
}

void sub_1B7947D78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7947DA8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7947DA0);
}

double HgcCanonLog_encode::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcCanonLog_encode [hgc1]");
  return *(double *)"og_encode [hgc1]";
}

uint64_t HgcCanonLog_encode::BindTexture(HgcCanonLog_encode *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcCanonLog_encode::Bind(HgcCanonLog_encode *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcCanonLog_encode::RenderTile(HgcCanonLog_encode *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v47 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v11 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = (_OWORD *)*((void *)this + 51);
      float32x4_t v14 = *((float32x4_t *)v13 + 1);
      float32x4_t v16 = *((float32x4_t *)v13 + 2);
      int8x16_t v15 = *((int8x16_t *)v13 + 3);
      float32x4_t v17 = vaddq_f32(vmulq_laneq_f32(vabsq_f32(v12), *(float32x4_t *)v13, 2), v16);
      float32x4_t v18 = vaddq_f32(vmulq_laneq_f32(vabsq_f32(v11), *(float32x4_t *)v13, 2), v16);
      int8x16_t v19 = (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vsubq_f32((float32x4_t)vbslq_s8(v15, (int8x16_t)v12, vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v12, v14))), (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v14, v12)))), COERCE_FLOAT(*v13));
      int8x16_t v20 = *((int8x16_t *)v13 + 4);
      float32x4_t v21 = *((float32x4_t *)v13 + 5);
      float32x4_t v22 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v17), (int8x16_t)v16);
      float32x4_t v23 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v18), (int8x16_t)v16);
      int8x16_t v24 = *((int8x16_t *)v13 + 6);
      float32x4_t v25 = *((float32x4_t *)v13 + 7);
      float32x4_t v26 = (float32x4_t)vbslq_s8(v15, (int8x16_t)v11, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v15, (int8x16_t)v11, (int8x16_t)vsubq_f32((float32x4_t)vbslq_s8(v15, (int8x16_t)v11, vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v11, v14))), (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v14, v11)))), COERCE_FLOAT(*v13)));
      float32x4_t v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v18)));
      float32x4_t v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v21, v17))), v25);
      float32x4_t v29 = *((float32x4_t *)v13 + 8);
      float32x4_t v30 = *((float32x4_t *)v13 + 9);
      float32x4_t v31 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v22, v29));
      float32x4_t v32 = (float32x4_t)vandq_s8((int8x16_t)v16, (int8x16_t)vcgtq_f32(v23, v29));
      float32x4_t v33 = vaddq_f32(v28, v31);
      float32x4_t v34 = vaddq_f32(vsubq_f32(v27, v25), v32);
      float32x4_t v35 = vmulq_f32(vmulq_f32(v30, v32), v23);
      float32x4_t v36 = vsubq_f32(v23, v16);
      float32x4_t v37 = vsubq_f32(vsubq_f32(v22, v16), vmulq_f32(vmulq_f32(v30, v31), v22));
      float32x4_t v38 = vsubq_f32(v36, v35);
      float32x4_t v39 = *((float32x4_t *)v13 + 10);
      float32x4_t v40 = *((float32x4_t *)v13 + 11);
      float32x4_t v41 = vaddq_f32(v39, vmulq_f32(v40, v37));
      float32x4_t v42 = vaddq_f32(v39, vmulq_f32(v40, v38));
      float32x4_t v43 = *((float32x4_t *)v13 + 12);
      float32x4_t v44 = *((float32x4_t *)v13 + 13);
      float32x4_t v45 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 1);
      float32x4_t v46 = (int8x16_t *)(v5 + v10);
      v46[-1] = vbslq_s8(v15, (int8x16_t)v12, (int8x16_t)vaddq_f32(v45, vmulq_f32(vaddq_f32(v33, vmulq_f32(v37, vaddq_f32(vaddq_f32(v43, vmulq_f32(v37, v44)), vmulq_f32(vmulq_f32(v37, v37), v41)))), (float32x4_t)vbslq_s8(v15, (int8x16_t)v12, v19))));
      *float32x4_t v46 = vbslq_s8(v15, (int8x16_t)v11, (int8x16_t)vaddq_f32(v45, vmulq_f32(vaddq_f32(v34, vmulq_f32(v38, vaddq_f32(vaddq_f32(v43, vmulq_f32(v38, v44)), vmulq_f32(vmulq_f32(v38, v38), v42)))), v26)));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v47 = -v9;
    if (v47 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v48 = 16 * v47;
    float32x4_t v49 = *(float32x4_t *)(v6 + v48);
    float32x4_t v50 = (_OWORD *)*((void *)this + 51);
    float32x4_t v51 = *((float32x4_t *)v50 + 2);
    int8x16_t v52 = *((int8x16_t *)v50 + 3);
    float32x4_t v53 = vaddq_f32(vmulq_laneq_f32(vabsq_f32(v49), *(float32x4_t *)v50, 2), v51);
    float32x4_t v54 = (float32x4_t)vorrq_s8(vandq_s8(*((int8x16_t *)v50 + 4), (int8x16_t)v53), (int8x16_t)v51);
    float32x4_t v55 = (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v54, *((float32x4_t *)v50 + 8)));
    float32x4_t v56 = vsubq_f32(vsubq_f32(v54, v51), vmulq_f32(vmulq_f32(*((float32x4_t *)v50 + 9), v55), v54));
    *(int8x16_t *)(v5 + v48) = vbslq_s8(v52, (int8x16_t)v49, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50, 1), vmulq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v53, 0x17uLL)), (float32x4_t)vandq_s8(*((int8x16_t *)v50 + 6), (int8x16_t)vcgtq_f32(*((float32x4_t *)v50 + 5), v53))), *((float32x4_t *)v50 + 7)), v55), vmulq_f32(v56,
                                                    vaddq_f32(vaddq_f32(*((float32x4_t *)v50 + 12), vmulq_f32(v56, *((float32x4_t *)v50 + 13))), vmulq_f32(vmulq_f32(v56, v56), vaddq_f32(*((float32x4_t *)v50 + 10), vmulq_f32(*((float32x4_t *)v50 + 11), v56)))))), (float32x4_t)vbslq_s8(v52, (int8x16_t)v49, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v52, (int8x16_t)v49, (int8x16_t)vsubq_f32((float32x4_t)vbslq_s8(v52, (int8x16_t)v49, vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(v49, *((float32x4_t *)v50 + 1)))), (float32x4_t)vandq_s8((int8x16_t)v51, (int8x16_t)vcgtq_f32(*((float32x4_t *)v50 + 1), v49)))), COERCE_FLOAT(*v50))))));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcCanonLog_encode::GetDOD(HgcCanonLog_encode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcCanonLog_encode::GetROI(HgcCanonLog_encode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcCanonLog_encode::HgcCanonLog_encode(HgcCanonLog_encode *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10FA680;
  operator new();
}

void sub_1B79483B4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcCanonLog_encode::~HgcCanonLog_encode(HGNode *this)
{
  *(void *)this = &unk_1F10FA680;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C405DF52C91);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10FA680;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C405DF52C91);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcCanonLog_encode::SetParameter(HgcCanonLog_encode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcCanonLog_encode::GetParameter(HgcCanonLog_encode *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcNikonLog_encode::GetProgram(HgcNikonLog_encode *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, half3(hg_Params[0].www));\n"
             "    r2.xyz = r0.xyz*half3(hg_Params[0].xxx) + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].zzz));\n"
             "    r1.xyz = log2(r1.xyz);\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[1].xxx) + half3(hg_Params[1].yyy);\n"
             "    r0.xyz = half3(r0.xyz >= half3(hg_Params[0].www));\n"
             "    output.color0.xyz = select(float3(r2.xyz), float3(r1.xyz), -float3(r0.xyz) < 0.00000h);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=3f8ec093:0799bfad:07283387:be79b09a\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003f7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, hg_Params[0].www);\n"
             "    r2.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
             "    r2.xyz = fmax(r2.xyz, c0.xxx);\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].zzz);\n"
             "    r1.xyz = log2(r1.xyz);\n"
             "    r1.xyz = r1.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
             "    r0.xyz = float3(r0.xyz >= hg_Params[0].www);\n"
             "    output.color0.xyz = select(r2.xyz, r1.xyz, -r0.xyz < 0.00000f);\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=9edade93:85582fd4:1e848f4f:c25d5331\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000448\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, hg_ProgramLocal0.www);\n"
           "    r2.xyz = r0.xyz*hg_ProgramLocal0.xxx + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = max(r2.xyz, c0.xxx);\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.zzz);\n"
           "    r1.xyz = log2(r1.xyz);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal1.xxx + hg_ProgramLocal1.yyy;\n"
           "    r0.xyz = vec3(greaterThanEqual(r0.xyz, hg_ProgramLocal0.www));\n"
           "    gl_FragColor.xyz = vec3(-r0.x < 0.00000 ? r1.x : r2.x, -r0.y < 0.00000 ? r1.y : r2.y, -r0.z < 0.00000 ? r"
           "1.z : r2.z);\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=07c9b4e2:ac369c2c:083b433b:0792297e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcNikonLog_encode::InitProgramDescriptor(HgcNikonLog_encode *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcNikonLog_encode_hgc_visible", "//Metal1.0     \n//LEN=00000002d3\n[[ visible ]] FragmentOut HgcNikonLog_encode_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fmax(r0.xyz, hg_Params[0].www);\n"
    "    r2.xyz = r0.xyz*hg_Params[0].xxx + hg_Params[0].yyy;\n"
    "    r2.xyz = fmax(r2.xyz, c0.xxx);\n"
    "    r2.xyz = pow(r2.xyz, hg_Params[0].zzz);\n"
    "    r1.xyz = log2(r1.xyz);\n"
    "    r1.xyz = r1.xyz*hg_Params[1].xxx + hg_Params[1].yyy;\n"
    "    r0.xyz = float3(r0.xyz >= hg_Params[0].www);\n"
    "    output.color0.xyz = select(r2.xyz, r1.xyz, -r0.xyz < 0.00000f);\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcNikonLog_encode");
}

void sub_1B7948830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B7948860(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B7948858);
}

double HgcNikonLog_encode::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  int v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcNikonLog_encode [hgc1]");
  return *(double *)"og_encode [hgc1]";
}

uint64_t HgcNikonLog_encode::BindTexture(HgcNikonLog_encode *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcNikonLog_encode::Bind(HgcNikonLog_encode *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcNikonLog_encode::RenderTile(HgcNikonLog_encode *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    while (v4 < 2)
    {
      int v74 = 0;
      if (v4 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      v6 += v8;
      v5 += v7;
      if (++v3 == v2) {
        return 0;
      }
    }
    int v9 = 0;
    uint64_t v10 = 16;
    do
    {
      float32x4_t v11 = *(float32x4_t *)(v6 + v10 - 16);
      float32x4_t v12 = *(float32x4_t *)(v6 + v10);
      uint64_t v13 = (_OWORD *)*((void *)this + 51);
      long long v14 = v13[1];
      float32x4_t v15 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v13, 3);
      float32x4_t v16 = vmaxq_f32(v11, v15);
      float32x4_t v17 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13, 1);
      float32x4_t v18 = vmaxq_f32(v12, v15);
      float32x4_t v19 = vaddq_f32(v17, vmulq_n_f32(v11, COERCE_FLOAT(*v13)));
      float32x4_t v20 = vaddq_f32(v17, vmulq_n_f32(v12, COERCE_FLOAT(*v13)));
      float32x4_t v21 = *((float32x4_t *)v13 + 2);
      int8x16_t v22 = *((int8x16_t *)v13 + 3);
      float32x4_t v23 = vmaxq_f32(v19, v21);
      float32x4_t v24 = vmaxq_f32(v20, v21);
      float32x4_t v25 = *((float32x4_t *)v13 + 4);
      float32x4_t v26 = *((float32x4_t *)v13 + 5);
      float32x4_t v27 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v23), (int8x16_t)v25);
      float32x4_t v28 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v24), (int8x16_t)v25);
      int8x16_t v29 = *((int8x16_t *)v13 + 6);
      float32x4_t v30 = *((float32x4_t *)v13 + 7);
      float32x4_t v31 = *((float32x4_t *)v13 + 8);
      float32x4_t v32 = *((float32x4_t *)v13 + 9);
      float32x4_t v33 = (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v27, v31));
      float32x4_t v34 = (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v28, v31));
      float32x4_t v35 = vsubq_f32(vsubq_f32(v27, v25), vmulq_f32(vmulq_f32(v32, v33), v27));
      float32x4_t v36 = vsubq_f32(vsubq_f32(v28, v25), vmulq_f32(vmulq_f32(v32, v34), v28));
      float32x4_t v37 = *((float32x4_t *)v13 + 10);
      float32x4_t v38 = *((float32x4_t *)v13 + 11);
      float32x4_t v39 = *((float32x4_t *)v13 + 12);
      float32x4_t v40 = *((float32x4_t *)v13 + 13);
      float32x4_t v41 = vmulq_laneq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v23))), v30), v33), vmulq_f32(v35, vaddq_f32(vaddq_f32(v39, vmulq_f32(v35, v40)), vmulq_f32(vmulq_f32(v35, v35), vaddq_f32(v37, vmulq_f32(v38, v35)))))), *(float32x4_t *)v13, 2);
      float32x4_t v42 = vmulq_laneq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x17uLL)), (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v24))), v30), v34), vmulq_f32(v36, vaddq_f32(vaddq_f32(v39, vmulq_f32(v36, v40)), vmulq_f32(vmulq_f32(v36, v36), vaddq_f32(v37, vmulq_f32(v38, v36)))))), *(float32x4_t *)v13, 2);
      float32x4_t v43 = *((float32x4_t *)v13 + 14);
      float32x4_t v44 = *((float32x4_t *)v13 + 15);
      float32x4_t v45 = vmaxq_f32(v41, v43);
      float32x4_t v46 = vmaxq_f32(v42, v43);
      float32x4_t v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
      float32x4_t v48 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
      float32x4_t v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v47, v45)));
      float32x4_t v50 = vsubq_f32(v48, (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v48, v46)));
      float32x4_t v51 = vsubq_f32(v45, v49);
      float32x4_t v52 = *((float32x4_t *)v13 + 16);
      float32x4_t v53 = *((float32x4_t *)v13 + 17);
      float32x4_t v54 = vsubq_f32(v46, v50);
      int32x4_t v55 = *((int32x4_t *)v13 + 18);
      int8x16_t v56 = *((int8x16_t *)v13 + 19);
      int32x4_t v57 = vaddq_s32(v55, vcvtq_s32_f32(v50));
      float32x4_t v58 = (float32x4_t)vshlq_n_s32(vaddq_s32(v55, vcvtq_s32_f32(v49)), 0x17uLL);
      float32x4_t v59 = (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v16));
      float32x4_t v60 = (float32x4_t)vandq_s8(v29, (int8x16_t)vcgtq_f32(v26, v18));
      float32x4_t v61 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v16), (int8x16_t)v25);
      float32x4_t v62 = (float32x4_t)vorrq_s8(vandq_s8(v22, (int8x16_t)v18), (int8x16_t)v25);
      float32x4_t v63 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), v59), v30);
      float32x4_t v64 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), v60), v30);
      float32x4_t v65 = (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v61, v31));
      float32x4_t v66 = (float32x4_t)vandq_s8((int8x16_t)v25, (int8x16_t)vcgtq_f32(v62, v31));
      float32x4_t v67 = vaddq_f32(v64, v66);
      float32x4_t v68 = vmulq_f32(v32, v66);
      float32x4_t v69 = vsubq_f32(vsubq_f32(v61, v25), vmulq_f32(vmulq_f32(v32, v65), v61));
      float32x4_t v70 = vsubq_f32(vsubq_f32(v62, v25), vmulq_f32(v68, v62));
      float32x4_t v71 = vaddq_f32(v67, vmulq_f32(v70, vaddq_f32(vaddq_f32(v39, vmulq_f32(v70, v40)), vmulq_f32(vmulq_f32(v70, v70), vaddq_f32(v37, vmulq_f32(v38, v70))))));
      float32x4_t v72 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v14, 1);
      float32x4_t v73 = (int8x16_t *)(v5 + v10);
      v73[-1] = vbslq_s8(v56, (int8x16_t)v11, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v56, (int8x16_t)v11, vandq_s8((int8x16_t)v25, (int8x16_t)vcgeq_f32(v11, v15))), v21), (int8x16_t)vaddq_f32(v72, vmulq_n_f32(vaddq_f32(vaddq_f32(v63, v65), vmulq_f32(v69, vaddq_f32(vaddq_f32(v39, vmulq_f32(v69, v40)), vmulq_f32(vmulq_f32(v69, v69), vaddq_f32(v37, vmulq_f32(v38, v69)))))),
                                   *(float *)&v14)),
                    (int8x16_t)vmulq_f32(vaddq_f32(v25, vmulq_f32(v51, vaddq_f32(v53, vmulq_f32(v51, vaddq_f32(v44, vmulq_f32(v52, v51)))))), v58)));
      *float32x4_t v73 = vbslq_s8(v56, (int8x16_t)v12, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(v56, (int8x16_t)v12, vandq_s8((int8x16_t)v25, (int8x16_t)vcgeq_f32(v12, v15))), v21), (int8x16_t)vaddq_f32(v72, vmulq_n_f32(v71, *(float *)&v14)), (int8x16_t)vmulq_f32(vaddq_f32(v25, vmulq_f32(v54, vaddq_f32(v53, vmulq_f32(v54, vaddq_f32(v44, vmulq_f32(v52, v54)))))), (float32x4_t)vshlq_n_s32(v57, 0x17uLL))));
      v9 -= 2;
      v10 += 32;
    }
    while (v4 + v9 > 1);
    int v74 = -v9;
    if (v74 >= v4) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v75 = 16 * v74;
    float32x4_t v76 = *(float32x4_t *)(v6 + v75);
    float32x4_t v77 = (_OWORD *)*((void *)this + 51);
    float32x4_t v78 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v77, 3);
    float32x4_t v79 = vmaxq_f32(v76, v78);
    float32x4_t v80 = *((float32x4_t *)v77 + 2);
    int8x16_t v81 = *((int8x16_t *)v77 + 3);
    float32x4_t v82 = vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v77, 1), vmulq_n_f32(v76, COERCE_FLOAT(*v77))), v80);
    float32x4_t v83 = *((float32x4_t *)v77 + 4);
    float32x4_t v84 = *((float32x4_t *)v77 + 5);
    float32x4_t v85 = (float32x4_t)vorrq_s8(vandq_s8(v81, (int8x16_t)v82), (int8x16_t)v83);
    int8x16_t v86 = *((int8x16_t *)v77 + 6);
    float32x4_t v87 = *((float32x4_t *)v77 + 7);
    float32x4_t v88 = *((float32x4_t *)v77 + 8);
    float32x4_t v89 = *((float32x4_t *)v77 + 9);
    float32x4_t v90 = (float32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vcgtq_f32(v85, v88));
    float32x4_t v91 = vsubq_f32(vsubq_f32(v85, v83), vmulq_f32(vmulq_f32(v89, v90), v85));
    float32x4_t v92 = *((float32x4_t *)v77 + 10);
    float32x4_t v93 = *((float32x4_t *)v77 + 11);
    float32x4_t v94 = *((float32x4_t *)v77 + 12);
    float32x4_t v95 = *((float32x4_t *)v77 + 13);
    float32x4_t v96 = vmaxq_f32(vmulq_laneq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v82, 0x17uLL)), (float32x4_t)vandq_s8(v86, (int8x16_t)vcgtq_f32(v84, v82))), v87), v90), vmulq_f32(v91, vaddq_f32(vaddq_f32(v94, vmulq_f32(v91, v95)), vmulq_f32(vmulq_f32(v91, v91), vaddq_f32(v92, vmulq_f32(v93, v91)))))), *(float32x4_t *)v77, 2), *((float32x4_t *)v77 + 14));
    float32x4_t v97 = vcvtq_f32_s32(vcvtq_s32_f32(v96));
    float32x4_t v98 = vsubq_f32(v97, (float32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vcgtq_f32(v97, v96)));
    float32x4_t v99 = vsubq_f32(v96, v98);
    int8x16_t v100 = (int8x16_t)vmulq_f32(vaddq_f32(v83, vmulq_f32(v99, vaddq_f32(*((float32x4_t *)v77 + 17), vmulq_f32(v99, vaddq_f32(*((float32x4_t *)v77 + 15), vmulq_f32(*((float32x4_t *)v77 + 16), v99)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*((int32x4_t *)v77 + 18), vcvtq_s32_f32(v98)), 0x17uLL));
    float32x4_t v101 = (float32x4_t)vorrq_s8(vandq_s8(v81, (int8x16_t)v79), (int8x16_t)v83);
    float32x4_t v102 = (float32x4_t)vandq_s8((int8x16_t)v83, (int8x16_t)vcgtq_f32(v101, v88));
    float32x4_t v103 = vsubq_f32(vsubq_f32(v101, v83), vmulq_f32(vmulq_f32(v89, v102), v101));
    *(int8x16_t *)(v5 + v75) = vbslq_s8(*((int8x16_t *)v77 + 19), (int8x16_t)v76, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vbslq_s8(*((int8x16_t *)v77 + 19), (int8x16_t)v76, vandq_s8((int8x16_t)v83, (int8x16_t)vcgeq_f32(v76, v78))), v80), (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v77[1], 1), vmulq_n_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v79, 0x17uLL)), (float32x4_t)vandq_s8(v86, (int8x16_t)vcgtq_f32(v84, v79))), v87),
                                                      v102),
                                                    vmulq_f32(v103, vaddq_f32(vaddq_f32(v94, vmulq_f32(v103, v95)), vmulq_f32(vmulq_f32(v103, v103), vaddq_f32(v92, vmulq_f32(v93, v103)))))), COERCE_FLOAT(v77[1]))), v100));
    goto LABEL_3;
  }
  return 0;
}

uint64_t HgcNikonLog_encode::GetDOD(HgcNikonLog_encode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcNikonLog_encode::GetROI(HgcNikonLog_encode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcNikonLog_encode::HgcNikonLog_encode(HgcNikonLog_encode *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F10FA8E8;
  operator new();
}

void sub_1B79490EC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcNikonLog_encode::~HgcNikonLog_encode(HGNode *this)
{
  *(void *)this = &unk_1F10FA8E8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B2834900);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10FA8E8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B2834900);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcNikonLog_encode::SetParameter(HgcNikonLog_encode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcNikonLog_encode::GetParameter(HgcNikonLog_encode *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

void sub_1B7949E20(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFB90](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

BOOL FxIsSupportedNCLCValue_Private(int a1)
{
  BOOL v1 = ((1 << SBYTE1(a1)) & 0x52102) != 0 && a1 == 0;
  if (BYTE1(a1) > 0x12u) {
    BOOL v1 = 0;
  }
  if (((1 << SBYTE2(a1)) & 0x1202) == 0) {
    BOOL v1 = 0;
  }
  return BYTE2(a1) <= 0xCu && v1;
}

uint64_t FxIsDebugFlagOn()
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (Current - *(double *)&FxIsDebugFlagOn_lastCheckTicks > 1.0)
  {
    CFStringRef v1 = (const __CFString *)*MEMORY[0x1E4F1D3D8];
    if ((FxIsDebugFlagOn_addedSuitePrefs & 1) == 0)
    {
      FxIsDebugFlagOn_addedSuitePrefs = 1;
      CFPreferencesAddSuitePreferencesToApp(v1, @"com.apple.FxPlug");
    }
    uint64_t v2 = (void *)CFPreferencesCopyAppValue(@"DEBUG", v1);
    if (v2)
    {
      int v3 = v2;
      FxIsDebugFlagOn_uint64_t result = [v2 isEqual:@"YES"];
      CFRelease(v3);
    }
    else
    {
      FxIsDebugFlagOn_uint64_t result = 0;
    }
    FxIsDebugFlagOn_lastCheckTicks = *(void *)&Current;
  }
  return FxIsDebugFlagOn_result;
}

void FxDebugLog(NSString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (FxIsDebugFlagOn()) {
    NSLogv(a1, &a9);
  }
}

uint64_t FxDebugAssert(uint64_t a1, NSString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if ((a1 & 1) == 0 && FxIsDebugFlagOn()) {
    NSLogv(a2, &a9);
  }
  return a1;
}

void MyDataProviderReleaser(id a1)
{
  if (a1) {
}
  }

BOOL __gl_vertLeq(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)(a1 + 56);
  double v3 = *(double *)(a2 + 56);
  if (v2 < v3) {
    return 1;
  }
  if (v2 == v3) {
    return *(double *)(a1 + 64) <= *(double *)(a2 + 64);
  }
  return 0;
}

double __gl_edgeEval(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v3 = *(double *)(a1 + 56);
  double v4 = *(double *)(a2 + 56);
  if (v3 >= v4 && (v3 != v4 || *(double *)(a1 + 64) > *(double *)(a2 + 64))
    || (double v5 = *(double *)(a3 + 56), v4 >= v5) && (v4 != v5 || *(double *)(a2 + 64) > *(double *)(a3 + 64)))
  {
    __gl_edgeEval_cold_1();
  }
  double v6 = v4 - v3;
  double v7 = v5 - v4;
  double v8 = v4 - v3 + v7;
  double result = 0.0;
  if (v8 > 0.0)
  {
    if (v6 >= v7) {
      uint64_t v10 = a3;
    }
    else {
      uint64_t v10 = a1;
    }
    if (v6 >= v7) {
      uint64_t v11 = a1;
    }
    else {
      uint64_t v11 = a3;
    }
    if (v6 < v7) {
      double v7 = v6;
    }
    return *(double *)(a2 + 64) - *(double *)(v10 + 64) + v7 / v8 * (*(double *)(v10 + 64) - *(double *)(v11 + 64));
  }
  return result;
}

double __gl_edgeSign(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v3 = *(double *)(a1 + 56);
  double v4 = *(double *)(a2 + 56);
  if (v3 >= v4 && (v3 != v4 || *(double *)(a1 + 64) > *(double *)(a2 + 64))
    || (double v5 = *(double *)(a3 + 56), v4 >= v5) && (v4 != v5 || *(double *)(a2 + 64) > *(double *)(a3 + 64)))
  {
    __gl_edgeSign_cold_1();
  }
  double v6 = v4 - v3;
  double v7 = v5 - v4;
  double result = 0.0;
  if (v6 + v7 > 0.0) {
    return v6 * (*(double *)(a2 + 64) - *(double *)(a3 + 64)) + v7 * (*(double *)(a2 + 64) - *(double *)(a1 + 64));
  }
  return result;
}

double __gl_transEval(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v3 = *(double *)(a1 + 64);
  double v4 = *(double *)(a2 + 64);
  if (v3 >= v4 && (v3 != v4 || *(double *)(a1 + 56) > *(double *)(a2 + 56))
    || (double v5 = *(double *)(a3 + 64), v4 >= v5) && (v4 != v5 || *(double *)(a2 + 56) > *(double *)(a3 + 56)))
  {
    __gl_transEval_cold_1();
  }
  double v6 = v4 - v3;
  double v7 = v5 - v4;
  double v8 = v4 - v3 + v7;
  double result = 0.0;
  if (v8 > 0.0)
  {
    if (v6 >= v7) {
      uint64_t v10 = a3;
    }
    else {
      uint64_t v10 = a1;
    }
    if (v6 >= v7) {
      uint64_t v11 = a1;
    }
    else {
      uint64_t v11 = a3;
    }
    if (v6 < v7) {
      double v7 = v6;
    }
    return *(double *)(a2 + 56) - *(double *)(v10 + 56) + v7 / v8 * (*(double *)(v10 + 56) - *(double *)(v11 + 56));
  }
  return result;
}

double __gl_transSign(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v3 = *(double *)(a1 + 64);
  double v4 = *(double *)(a2 + 64);
  if (v3 >= v4 && (v3 != v4 || *(double *)(a1 + 56) > *(double *)(a2 + 56))
    || (double v5 = *(double *)(a3 + 64), v4 >= v5) && (v4 != v5 || *(double *)(a2 + 56) > *(double *)(a3 + 56)))
  {
    __gl_transSign_cold_1();
  }
  double v6 = v4 - v3;
  double v7 = v5 - v4;
  double result = 0.0;
  if (v6 + v7 > 0.0) {
    return v6 * (*(double *)(a2 + 56) - *(double *)(a3 + 56)) + v7 * (*(double *)(a2 + 56) - *(double *)(a1 + 56));
  }
  return result;
}

void __gl_edgeIntersect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double v7 = *(double *)(a1 + 56);
  double v8 = *(double *)(a2 + 56);
  if (v7 < v8 || v7 == v8 && *(double *)(a1 + 64) <= *(double *)(a2 + 64))
  {
    uint64_t v9 = a2;
    a2 = a1;
  }
  else
  {
    uint64_t v9 = a1;
  }
  double v10 = *(double *)(a3 + 56);
  double v11 = *(double *)(a4 + 56);
  if (v10 < v11 || v10 == v11 && *(double *)(a3 + 64) <= *(double *)(a4 + 64))
  {
    double v11 = *(double *)(a3 + 56);
    uint64_t v12 = a4;
    a4 = a3;
  }
  else
  {
    uint64_t v12 = a3;
  }
  double v13 = *(double *)(a2 + 56);
  if (v13 < v11 || v13 == v11 && *(double *)(a2 + 64) <= *(double *)(a4 + 64))
  {
    double v13 = v11;
    uint64_t v14 = v12;
    uint64_t v15 = a4;
    uint64_t v12 = v9;
    a4 = a2;
  }
  else
  {
    uint64_t v14 = v9;
    uint64_t v15 = a2;
  }
  double v16 = *(double *)(v12 + 56);
  if (v13 >= v16 && (v13 != v16 || *(double *)(v15 + 64) > *(double *)(v12 + 64)))
  {
    double v17 = v13 + v16;
LABEL_49:
    double v29 = v17 * 0.5;
    goto LABEL_50;
  }
  double v18 = *(double *)(v14 + 56);
  if (v16 < v18 || v16 == v18 && *(double *)(v12 + 64) <= *(double *)(v14 + 64))
  {
    double v26 = __gl_edgeEval(a4, v15, v12);
    double v27 = __gl_edgeEval(v15, v12, v14);
    if (v26 + v27 >= 0.0) {
      double v28 = v27;
    }
    else {
      double v28 = -v27;
    }
    if (v26 + v27 >= 0.0) {
      double v22 = v26;
    }
    else {
      double v22 = -v26;
    }
    double v23 = 0.0;
    if (v22 < 0.0) {
      double v22 = 0.0;
    }
    if (v28 >= 0.0) {
      double v23 = v28;
    }
    double v24 = *(double *)(v15 + 56);
    if (v22 > v23)
    {
      double v25 = *(double *)(v12 + 56);
      goto LABEL_44;
    }
    double v30 = *(double *)(v12 + 56);
LABEL_47:
    if (v23 != 0.0)
    {
      double v29 = v24 + v22 / (v22 + v23) * (v30 - v24);
      goto LABEL_50;
    }
    double v17 = v24 + v30;
    goto LABEL_49;
  }
  double v19 = __gl_edgeSign(a4, v15, v12);
  double v20 = __gl_edgeSign(a4, v14, v12);
  double v21 = -v20;
  if (v19 - v20 >= 0.0)
  {
    double v22 = v19;
  }
  else
  {
    double v21 = v20;
    double v22 = -v19;
  }
  double v23 = 0.0;
  if (v22 < 0.0) {
    double v22 = 0.0;
  }
  if (v21 >= 0.0) {
    double v23 = v21;
  }
  double v24 = *(double *)(v15 + 56);
  if (v22 <= v23)
  {
    double v30 = *(double *)(v14 + 56);
    goto LABEL_47;
  }
  double v25 = *(double *)(v14 + 56);
LABEL_44:
  double v29 = v25 + v23 / (v22 + v23) * (v24 - v25);
LABEL_50:
  *(double *)(a5 + 56) = v29;
  double v31 = *(double *)(a4 + 64);
  double v32 = *(double *)(v12 + 64);
  if (v31 < v32 || v31 == v32 && *(double *)(a4 + 56) <= *(double *)(v12 + 56))
  {
    uint64_t v33 = v12;
    uint64_t v12 = a4;
  }
  else
  {
    uint64_t v33 = a4;
  }
  double v34 = *(double *)(v15 + 64);
  double v35 = *(double *)(v14 + 64);
  if (v34 < v35 || v34 == v35 && *(double *)(v15 + 56) <= *(double *)(v14 + 56))
  {
    double v35 = *(double *)(v15 + 64);
    uint64_t v36 = v14;
    uint64_t v14 = v15;
  }
  else
  {
    uint64_t v36 = v15;
  }
  double v37 = *(double *)(v12 + 64);
  if (v37 < v35 || v37 == v35 && *(double *)(v12 + 56) <= *(double *)(v14 + 56))
  {
    double v37 = v35;
    uint64_t v38 = v36;
    uint64_t v39 = v14;
    uint64_t v36 = v33;
    uint64_t v14 = v12;
  }
  else
  {
    uint64_t v38 = v33;
    uint64_t v39 = v12;
  }
  double v40 = *(double *)(v36 + 64);
  if (v37 >= v40 && (v37 != v40 || *(double *)(v39 + 56) > *(double *)(v36 + 56)))
  {
    double v41 = v37 + v40;
LABEL_99:
    double v53 = v41 * 0.5;
    goto LABEL_100;
  }
  double v42 = *(double *)(v38 + 64);
  if (v40 < v42 || v40 == v42 && *(double *)(v36 + 56) <= *(double *)(v38 + 56))
  {
    double v50 = __gl_transEval(v14, v39, v36);
    double v51 = __gl_transEval(v39, v36, v38);
    if (v50 + v51 >= 0.0) {
      double v52 = v51;
    }
    else {
      double v52 = -v51;
    }
    if (v50 + v51 >= 0.0) {
      double v46 = v50;
    }
    else {
      double v46 = -v50;
    }
    double v47 = 0.0;
    if (v46 < 0.0) {
      double v46 = 0.0;
    }
    if (v52 >= 0.0) {
      double v47 = v52;
    }
    double v48 = *(double *)(v39 + 64);
    if (v46 > v47)
    {
      double v49 = *(double *)(v36 + 64);
      goto LABEL_93;
    }
    double v54 = *(double *)(v36 + 64);
LABEL_97:
    if (v47 != 0.0)
    {
      double v53 = v48 + v46 / (v46 + v47) * (v54 - v48);
      goto LABEL_100;
    }
    double v41 = v48 + v54;
    goto LABEL_99;
  }
  double v43 = __gl_transSign(v14, v39, v36);
  double v44 = __gl_transSign(v14, v38, v36);
  double v45 = -v44;
  if (v43 - v44 >= 0.0)
  {
    double v46 = v43;
  }
  else
  {
    double v45 = v44;
    double v46 = -v43;
  }
  double v47 = 0.0;
  if (v46 < 0.0) {
    double v46 = 0.0;
  }
  if (v45 >= 0.0) {
    double v47 = v45;
  }
  double v48 = *(double *)(v39 + 64);
  if (v46 <= v47)
  {
    double v54 = *(double *)(v38 + 64);
    goto LABEL_97;
  }
  double v49 = *(double *)(v38 + 64);
LABEL_93:
  double v53 = v49 + v47 / (v46 + v47) * (v48 - v49);
LABEL_100:
  *(double *)(a5 + 64) = v53;
}

void __gl_edgeEval_cold_1()
{
}

void __gl_edgeSign_cold_1()
{
}

void __gl_transEval_cold_1()
{
}

void __gl_transSign_cold_1()
{
}

uint64_t __gl_meshTessellateMonoRegion(uint64_t a1)
{
  CFStringRef v1 = *(void **)(a1 + 16);
  uint64_t v2 = v1[3];
  if ((void *)v2 == v1 || *(void **)(v2 + 24) == v1) {
    __gl_meshTessellateMonoRegion_cold_1();
  }
  while (1)
  {
    uint64_t v3 = *(void *)(v1[1] + 32);
    double v4 = *(double *)(v3 + 56);
    uint64_t v5 = v1[4];
    double v6 = *(double *)(v5 + 56);
    if (v4 >= v6 && (v4 != v6 || *(double *)(v3 + 64) > *(double *)(v5 + 64))) {
      break;
    }
    CFStringRef v1 = *(void **)(v1[2] + 8);
  }
  while (v6 < v4 || v6 == v4 && *(double *)(v5 + 64) <= *(double *)(v3 + 64))
  {
    CFStringRef v1 = (void *)v1[3];
    uint64_t v5 = v1[4];
    double v6 = *(double *)(v5 + 56);
    uint64_t v3 = *(void *)(v1[1] + 32);
    double v4 = *(double *)(v3 + 56);
  }
  double v7 = *(void **)(v1[2] + 8);
  while ((void *)v1[3] != v7)
  {
    uint64_t v8 = *(void *)(v1[1] + 32);
    double v9 = *(double *)(v8 + 56);
    uint64_t v10 = v7[4];
    double v11 = *(double *)(v10 + 56);
    if (v9 < v11 || v9 == v11 && *(double *)(v8 + 64) <= *(double *)(v10 + 64))
    {
      while (1)
      {
        double v18 = (void *)v7[3];
        if (v18 == v1) {
          break;
        }
        uint64_t v19 = *(void *)(v18[1] + 32);
        double v20 = *(double *)(v19 + 56);
        uint64_t v21 = v18[4];
        double v22 = *(double *)(v21 + 56);
        if (v20 >= v22 && (v20 != v22 || *(double *)(v19 + 64) > *(double *)(v21 + 64)))
        {
          if (__gl_edgeSign(v7[4], *(void *)(v7[1] + 32), v19) > 0.0) {
            break;
          }
          double v18 = (void *)v7[3];
        }
        uint64_t result = (uint64_t)__gl_meshConnect(v18, v7);
        if (!result) {
          return result;
        }
        double v7 = *(void **)(result + 8);
      }
      double v7 = *(void **)(v7[2] + 8);
    }
    else
    {
      while ((void *)v7[3] != v1)
      {
        uint64_t v12 = *(void **)(v1[2] + 8);
        uint64_t v13 = v12[4];
        double v14 = *(double *)(v13 + 56);
        uint64_t v15 = *(void *)(v12[1] + 32);
        double v16 = *(double *)(v15 + 56);
        if (v14 >= v16 && (v14 != v16 || *(double *)(v13 + 64) > *(double *)(v15 + 64)))
        {
          if (__gl_edgeSign(*(void *)(v1[1] + 32), v1[4], v13) < 0.0) {
            break;
          }
          uint64_t v12 = *(void **)(v1[2] + 8);
        }
        uint64_t result = (uint64_t)__gl_meshConnect(v1, v12);
        if (!result) {
          return result;
        }
        CFStringRef v1 = *(void **)(result + 8);
      }
      CFStringRef v1 = (void *)v1[3];
    }
  }
  double v23 = (void *)v7[3];
  if (v23 == v1) {
    __gl_meshTessellateMonoRegion_cold_2();
  }
  while ((void *)v23[3] != v1)
  {
    uint64_t result = (uint64_t)__gl_meshConnect(v23, v7);
    if (!result) {
      return result;
    }
    double v7 = *(void **)(result + 8);
    double v23 = (void *)v7[3];
  }
  return 1;
}

uint64_t __gl_meshTessellateInterior(uint64_t a1)
{
  uint64_t v2 = a1 + 80;
  uint64_t v1 = *(void *)(a1 + 80);
  if (v1 == v2) {
    return 1;
  }
  while (1)
  {
    uint64_t v3 = *(void *)v1;
    if (*(unsigned char *)(v1 + 41))
    {
      uint64_t result = __gl_meshTessellateMonoRegion(v1);
      if (!result) {
        break;
      }
    }
    uint64_t v1 = v3;
    if (v3 == v2) {
      return 1;
    }
  }
  return result;
}

uint64_t __gl_meshDiscardExterior(uint64_t a1)
{
  uint64_t v2 = a1 + 80;
  uint64_t result = *(void *)(a1 + 80);
  if (result != v2)
  {
    do
    {
      uint64_t v3 = *(void *)result;
      if (!*(unsigned char *)(result + 41)) {
        __gl_meshZapFace((uint64_t *)result);
      }
      uint64_t result = v3;
    }
    while (v3 != v2);
  }
  return result;
}

uint64_t __gl_meshSetWindingNumber(uint64_t a1, int a2, int a3)
{
  double v4 = (uint64_t *)(a1 + 128);
  uint64_t v3 = *(uint64_t **)(a1 + 128);
  if (v3 != v4)
  {
    int v7 = -a2;
    do
    {
      uint64_t v8 = (uint64_t *)*v3;
      if (*(unsigned __int8 *)(*(void *)(v3[1] + 40) + 41) == *(unsigned __int8 *)(v3[5] + 41))
      {
        if (a3)
        {
          uint64_t result = __gl_meshDelete(v3);
          if (!result) {
            return result;
          }
          goto LABEL_12;
        }
        int v10 = 0;
      }
      else if (*(unsigned char *)(v3[5] + 41))
      {
        int v10 = a2;
      }
      else
      {
        int v10 = v7;
      }
      *((_DWORD *)v3 + 14) = v10;
LABEL_12:
      uint64_t v3 = v8;
    }
    while (v8 != v4);
  }
  return 1;
}

void __gl_meshTessellateMonoRegion_cold_1()
{
  __assert_rtn("__gl_meshTessellateMonoRegion", "tessmono.c", 84, "up->Lnext != up && up->Lnext->Lnext != up");
}

void __gl_meshTessellateMonoRegion_cold_2()
{
  __assert_rtn("__gl_meshTessellateMonoRegion", "tessmono.c", 120, "lo->Lnext != up");
}

uint64_t __gl_computeInterior(uint64_t a1)
{
  *(unsigned char *)(a1 + 116) = 0;
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v5 = *(void **)(v2 + 128);
  double v4 = (void *)(v2 + 128);
  uint64_t v3 = v5;
  if (v5 != v4)
  {
    while (1)
    {
      int v7 = (void *)v3[3];
      uint64_t v6 = v3[4];
      uint64_t v8 = (void *)*v3;
      uint64_t v9 = *(void *)(v3[1] + 32);
      if (*(double *)(v6 + 56) == *(double *)(v9 + 56)
        && *(double *)(v6 + 64) == *(double *)(v9 + 64)
        && (void *)v7[3] != v3)
      {
        SpliceMergeVertices(a1, (void *)v3[3], v3);
        if (!__gl_meshDelete(v3)) {
          break;
        }
        uint64_t v3 = v7;
        int v7 = (void *)v7[3];
      }
      if ((void *)v7[3] == v3)
      {
        if (v7 != v3)
        {
          if (v7 == v8 || v7 == (void *)v8[1]) {
            uint64_t v8 = (void *)*v8;
          }
          if (!__gl_meshDelete(v7)) {
            break;
          }
        }
        if (v3 == v8 || v3 == (void *)v8[1]) {
          uint64_t v8 = (void *)*v8;
        }
        if (!__gl_meshDelete(v3)) {
          break;
        }
      }
      uint64_t v3 = v8;
      if (v8 == v4) {
        goto LABEL_18;
      }
    }
LABEL_52:
    longjmp((int *)(a1 + 3464), 1);
  }
LABEL_18:
  uint64_t result = (uint64_t)__gl_pqSortNewPriorityQ(__gl_vertLeq);
  *(void *)(a1 + 128) = result;
  if (result)
  {
    double v11 = (uint64_t *)result;
    uint64_t v12 = *(void **)(a1 + 16);
    uint64_t v13 = v12;
    while (1)
    {
      uint64_t v13 = (void *)*v13;
      if (v13 == v12) {
        break;
      }
      uint64_t v14 = __gl_pqSortInsert((uint64_t)v11, (uint64_t)v13);
      v13[9] = v14;
      if (v14 == 0x7FFFFFFFFFFFFFFFLL) {
        goto LABEL_46;
      }
    }
    if (__gl_pqSortInit(v11))
    {
      uint64_t v15 = __gl_dictListNewDict(a1, (uint64_t)EdgeLeq);
      *(void *)(a1 + 120) = v15;
      if (!v15) {
        goto LABEL_52;
      }
      AddSentinel(a1, -4.0e150);
      AddSentinel(a1, 4.0e150);
      uint64_t Min = __gl_pqSortExtractMin(*(void *)(a1 + 128));
      if (Min)
      {
        uint64_t v17 = Min;
        do
        {
          while (1)
          {
            uint64_t v18 = __gl_pqSortMinimum(*(void **)(a1 + 128));
            if (!v18
              || *(double *)(v18 + 56) != *(double *)(v17 + 56)
              || *(double *)(v18 + 64) != *(double *)(v17 + 64))
            {
              break;
            }
            uint64_t v19 = __gl_pqSortExtractMin(*(void *)(a1 + 128));
            SpliceMergeVertices(a1, *(void **)(v17 + 16), *(void **)(v19 + 16));
          }
          SweepEvent(a1, v17);
          uint64_t v17 = __gl_pqSortExtractMin(*(void *)(a1 + 128));
        }
        while (v17);
      }
      int v20 = 0;
      uint64_t v21 = **(unsigned char ***)(*(void *)(a1 + 120) + 8);
      *(void *)(a1 + 136) = *(void *)(*(void *)v21 + 32);
      do
      {
        if (!v21[21])
        {
          if (!v21[23]) {
            __gl_computeInterior_cold_1();
          }
          if (v20) {
            __gl_computeInterior_cold_4();
          }
          int v20 = 1;
        }
        if (*((_DWORD *)v21 + 4)) {
          __gl_computeInterior_cold_3();
        }
        DeleteRegion(a1, v21);
        uint64_t v22 = *(void *)(a1 + 120);
        uint64_t v21 = **(unsigned char ***)(v22 + 8);
      }
      while (v21);
      __gl_dictListDeleteDict((void *)v22);
      __gl_pqSortDeletePriorityQ(*(void ****)(a1 + 128));
      double v23 = *(void **)(a1 + 16);
      double v24 = v23 + 10;
      double v25 = (void *)v23[10];
      if (v25 == v23 + 10)
      {
LABEL_45:
        __gl_meshCheckMesh(v23);
        return 1;
      }
      else
      {
        while (1)
        {
          uint64_t v26 = v25[2];
          uint64_t v27 = *(void *)(v26 + 24);
          if (v27 == v26) {
            __gl_computeInterior_cold_2();
          }
          double v25 = (void *)*v25;
          if (*(void *)(v27 + 24) == v26)
          {
            uint64_t v29 = *(void *)(v26 + 8);
            uint64_t v28 = *(void *)(v26 + 16);
            *(_DWORD *)(v28 + 56) += *(_DWORD *)(v26 + 56);
            *(_DWORD *)(*(void *)(v28 + 8) + 56) += *(_DWORD *)(v29 + 56);
            uint64_t result = __gl_meshDelete((void *)v26);
            if (!result) {
              break;
            }
          }
          if (v25 == v24)
          {
            double v23 = *(void **)(a1 + 16);
            goto LABEL_45;
          }
        }
      }
    }
    else
    {
LABEL_46:
      __gl_pqSortDeletePriorityQ(*(void ****)(a1 + 128));
      uint64_t result = 0;
      *(void *)(a1 + 128) = 0;
    }
  }
  return result;
}

uint64_t SpliceMergeVertices(uint64_t a1, void *a2, void *a3)
{
  v10[4] = *MEMORY[0x1E4F143B8];
  v10[2] = 0;
  v10[3] = 0;
  long long v9 = xmmword_1B7E76310;
  uint64_t v6 = a2[4];
  uint64_t v7 = *(void *)(a3[4] + 24);
  v10[0] = *(void *)(v6 + 24);
  v10[1] = v7;
  CallCombine(a1, v6, v10, (uint64_t)&v9, 0);
  uint64_t result = __gl_meshSplice(a2, a3);
  if (!result) {
    longjmp((int *)(a1 + 3464), 1);
  }
  return result;
}

void SweepEvent(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 136) = a2;
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = v4;
  do
  {
    uint64_t v6 = *(void **)(v5 + 48);
    if (v6)
    {
      uint64_t v17 = TopLeftRegion(v6);
      if (!v17) {
        goto LABEL_54;
      }
      uint64_t v18 = v17;
      uint64_t v19 = *(void ****)(v17[1] + 16);
      int v20 = **v19;
      uint64_t v21 = FinishLeftRegions(a1, *v19, 0);
      uint64_t v22 = (void *)v21[2];
      if (v22 == v20)
      {
        double v23 = v21;
        double v24 = (void *)*v18;
        double v25 = **(unsigned char ***)(v18[1] + 16);
        uint64_t v26 = *(void *)v25;
        if (*(void *)(*(void *)(*v18 + 8) + 32) != *(void *)(*(void *)(*(void *)v25 + 8) + 32)) {
          CheckForIntersect(a1, v18);
        }
        uint64_t v27 = v24[4];
        uint64_t v28 = *(void *)(a1 + 136);
        double v29 = *(double *)(v28 + 56);
        if (*(double *)(v27 + 56) == v29 && *(double *)(v27 + 64) == *(double *)(v28 + 64))
        {
          if (!__gl_meshSplice(*(void **)(v20[1] + 24), v24)) {
            goto LABEL_54;
          }
          double v30 = TopLeftRegion(v18);
          if (!v30) {
            goto LABEL_54;
          }
          uint64_t v18 = v30;
          double v31 = *(void ****)(v30[1] + 16);
          int v20 = **v31;
          FinishLeftRegions(a1, *v31, v25);
          char v32 = 0;
          uint64_t v28 = *(void *)(a1 + 136);
          double v29 = *(double *)(v28 + 56);
        }
        else
        {
          char v32 = 1;
        }
        uint64_t v41 = *(void *)(v26 + 32);
        double v42 = *(double *)(v41 + 56);
        if (v42 == v29 && *(double *)(v41 + 64) == *(double *)(v28 + 64))
        {
          if (!__gl_meshSplice(v23, *(void **)(*(void *)(v26 + 8) + 24))) {
            goto LABEL_54;
          }
          double v23 = FinishLeftRegions(a1, (void **)v25, 0);
        }
        else if (v32)
        {
          uint64_t v43 = v24[4];
          double v44 = *(double *)(v43 + 56);
          if (v42 < v44 || v42 == v44 && *(double *)(v41 + 64) <= *(double *)(v43 + 64)) {
            double v24 = *(void **)(*(void *)(v26 + 8) + 24);
          }
          double v45 = __gl_meshConnect(*(void **)(v23[2] + 8), v24);
          if (!v45) {
            goto LABEL_54;
          }
          double v46 = v45;
          AddRightEdges(a1, (uint64_t)v18, v45, (void *)v45[2], v45[2], 0);
          *(unsigned char *)(*(void *)(v46[1] + 48) + 23) = 1;
          WalkDirtyRegions(a1, v18);
          return;
        }
        uint64_t v22 = (void *)v23[2];
      }
      AddRightEdges(a1, (uint64_t)v18, v22, v20, (uint64_t)v20, 1);
      return;
    }
    uint64_t v5 = *(void *)(v5 + 16);
  }
  while (v5 != v4);
  v49[1] = 0;
  v49[2] = 0;
  v49[0] = *(void *)(v4 + 8);
  uint64_t v7 = (uint64_t **)__gl_dictListSearch(*(void *)(a1 + 120), (uint64_t)v49);
  uint64_t v8 = *v7;
  uint64_t v9 = **v7;
  int v10 = **(uint64_t ***)((*v7)[1] + 16);
  uint64_t v11 = *v10;
  if (__gl_edgeSign(*(void *)(*(void *)(v9 + 8) + 32), a2, *(void *)(v9 + 32)) == 0.0)
  {
    uint64_t v12 = *v8;
    uint64_t v13 = *(void *)(*v8 + 32);
    double v14 = *(double *)(a2 + 56);
    if (*(double *)(v13 + 56) == v14 && *(double *)(v13 + 64) == *(double *)(a2 + 64)) {
      SweepEvent_cold_1();
    }
    uint64_t v15 = *(void *)(v12 + 8);
    uint64_t v16 = *(void *)(v15 + 32);
    if (*(double *)(v16 + 56) == v14 && *(double *)(v16 + 64) == *(double *)(a2 + 64)) {
      SweepEvent_cold_2();
    }
    if (!__gl_meshSplitEdge(v15)) {
      goto LABEL_54;
    }
    if (!*((unsigned char *)v8 + 23)) {
      goto LABEL_13;
    }
    if (!__gl_meshDelete(*(void **)(v12 + 16))) {
      goto LABEL_54;
    }
    *((unsigned char *)v8 + 23) = 0;
LABEL_13:
    if (!__gl_meshSplice(*(void **)(a2 + 16), (void *)v12)) {
LABEL_54:
    }
      longjmp((int *)(a1 + 3464), 1);
    goto LABEL_56;
  }
  uint64_t v33 = *(void *)(v11 + 8);
  uint64_t v34 = *(void *)(v33 + 32);
  double v35 = *(double *)(v34 + 56);
  uint64_t v36 = *(void *)(*(void *)(v9 + 8) + 32);
  double v37 = *(double *)(v36 + 56);
  uint64_t v38 = (uint64_t)v8;
  if (v35 >= v37)
  {
    if (v35 != v37 || (uint64_t v38 = (uint64_t)v8, *(double *)(v34 + 64) > *(double *)(v36 + 64))) {
      uint64_t v38 = (uint64_t)v10;
    }
  }
  if (*((unsigned char *)v8 + 20) || *(unsigned char *)(v38 + 23))
  {
    if ((uint64_t *)v38 == v8)
    {
      double v40 = __gl_meshConnect(*(void **)(*(void *)(a2 + 16) + 8), *(void **)(v9 + 24));
      if (!v40) {
        goto LABEL_54;
      }
    }
    else
    {
      uint64_t v39 = __gl_meshConnect(*(void **)(*(void *)(v33 + 16) + 8), *(void **)(a2 + 16));
      if (!v39) {
        goto LABEL_54;
      }
      double v40 = (void *)v39[1];
    }
    if (*(unsigned char *)(v38 + 23))
    {
      if (!FixUpperEdge(v38, (uint64_t)v40)) {
        goto LABEL_54;
      }
    }
    else
    {
      double v47 = AddRegionBelow(a1, (uint64_t)v8, (uint64_t)v40);
      unsigned int v48 = *(_DWORD *)(*v47 + 56) + *(_DWORD *)(**(void **)(v47[1] + 8) + 16);
      *((_DWORD *)v47 + 4) = v48;
      *((unsigned char *)v47 + 20) = IsWindingInside(a1, v48);
    }
LABEL_56:
    SweepEvent(a1, a2);
    return;
  }
  AddRightEdges(a1, (uint64_t)v8, *(void **)(a2 + 16), *(void **)(a2 + 16), 0, 1);
}

BOOL EdgeLeq(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 136);
  uint64_t v4 = *a2;
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(*(void *)(*a2 + 8) + 32);
  uint64_t v7 = *(void *)(*(void *)(*a3 + 8) + 32);
  if (v6 == v3)
  {
    if (v7 == v3)
    {
      uint64_t v16 = *(void *)(v4 + 32);
      double v17 = *(double *)(v16 + 56);
      uint64_t v11 = *(void *)(v5 + 32);
      double v18 = *(double *)(v11 + 56);
      if (v17 >= v18 && (v17 != v18 || *(double *)(v16 + 64) > *(double *)(v11 + 64)))
      {
        uint64_t v6 = v3;
        uint64_t v14 = *(void *)(v5 + 32);
        uint64_t v8 = *(void *)(v4 + 32);
        goto LABEL_7;
      }
      uint64_t v12 = v3;
      uint64_t v13 = *(void *)(v4 + 32);
    }
    else
    {
      uint64_t v11 = *(void *)(v5 + 32);
      uint64_t v12 = v7;
      uint64_t v13 = v3;
    }
    return __gl_edgeSign(v12, v13, v11) <= 0.0;
  }
  uint64_t v8 = *(void *)(v4 + 32);
  if (v7 != v3)
  {
    double v9 = __gl_edgeEval(v6, v3, v8);
    BOOL v10 = v9 < __gl_edgeEval(*(void *)(*(void *)(v5 + 8) + 32), v3, *(void *)(v5 + 32));
    return !v10;
  }
  uint64_t v14 = v3;
LABEL_7:
  BOOL v10 = __gl_edgeSign(v6, v14, v8) < 0.0;
  return !v10;
}

void *AddSentinel(uint64_t a1, double a2)
{
  uint64_t v4 = malloc_type_malloc(0x18uLL, 0x102004062D53EE8uLL);
  if (!v4) {
    goto LABEL_4;
  }
  uint64_t v5 = (uint64_t)v4;
  Edge = __gl_meshMakeEdge(*(void *)(a1 + 16));
  if (!Edge) {
    goto LABEL_4;
  }
  uint64_t v7 = Edge[4];
  *(void *)(v7 + 56) = 0x5F338D352E5096AFLL;
  *(double *)(v7 + 64) = a2;
  uint64_t v8 = *(void *)(Edge[1] + 32);
  *(void *)(v8 + 56) = 0xDF338D352E5096AFLL;
  *(double *)(v8 + 64) = a2;
  *(void *)(a1 + 136) = v8;
  *(void *)uint64_t v5 = Edge;
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 20) = 256;
  uint64_t result = __gl_dictListInsertBefore(*(void *)(a1 + 120), *(void **)(a1 + 120), v5);
  *(void *)(v5 + 8) = result;
  if (!result) {
LABEL_4:
  }
    longjmp((int *)(a1 + 3464), 1);
  return result;
}

uint64_t CallCombine(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, int a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  *(void *)(a2 + 24) = 0;
  uint64_t v8 = (void *)(a2 + 24);
  long long v12 = *(_OWORD *)(a2 + 32);
  uint64_t v13 = *(void *)(a2 + 48);
  double v9 = *(uint64_t (**)())(a1 + 3456);
  if (v9 == __gl_noCombineData) {
    uint64_t result = (*(uint64_t (**)(long long *, void *, uint64_t, void *))(a1 + 144))(&v12, a3, a4, v8);
  }
  else {
    uint64_t result = ((uint64_t (*)(long long *, void *, uint64_t, void *, void))v9)(&v12, a3, a4, v8, *(void *)(a1 + 3656));
  }
  if (!*v8)
  {
    if (a5)
    {
      if (!*(unsigned char *)(a1 + 116))
      {
        uint64_t v11 = *(uint64_t (**)())(a1 + 3448);
        if (v11 == __gl_noErrorData) {
          uint64_t result = (*(uint64_t (**)(uint64_t))(a1 + 24))(100156);
        }
        else {
          uint64_t result = ((uint64_t (*)(uint64_t, void))v11)(100156, *(void *)(a1 + 3656));
        }
        *(unsigned char *)(a1 + 116) = 1;
      }
    }
    else
    {
      *uint64_t v8 = *a3;
    }
  }
  return result;
}

void *TopLeftRegion(void *a1)
{
  uint64_t v1 = a1;
  do
    uint64_t v1 = **(void ***)(v1[1] + 8);
  while (*(void *)(*v1 + 32) == *(void *)(*a1 + 32));
  if (*((unsigned char *)v1 + 23))
  {
    uint64_t v2 = __gl_meshConnect(*(void **)(***(void ***)(v1[1] + 16) + 8), *(void **)(*v1 + 24));
    if (v2 && FixUpperEdge((uint64_t)v1, (uint64_t)v2)) {
      return **(void ***)(v1[1] + 8);
    }
    else {
      return 0;
    }
  }
  return v1;
}

void *FinishLeftRegions(uint64_t a1, void **a2, unsigned char *a3)
{
  uint64_t v3 = *a2;
  if (a2 != (void **)a3)
  {
    uint64_t v5 = a2;
    do
    {
      v5[23] = 0;
      uint64_t v7 = **(unsigned char ***)(*((void *)v5 + 1) + 16);
      uint64_t v8 = *(void **)v7;
      if (*(void *)(*(void *)v7 + 32) != v3[4])
      {
        if (!v7[23])
        {
          uint64_t v12 = v3[5];
          *(unsigned char *)(v12 + 41) = v5[20];
          *(void *)(v12 + 16) = v3;
          DeleteRegion(a1, v5);
          return v3;
        }
        double v9 = __gl_meshConnect(*(void **)(v3[2] + 8), (void *)v8[1]);
        if (!v9 || (uint64_t v8 = v9, !FixUpperEdge((uint64_t)v7, (uint64_t)v9))) {
LABEL_14:
        }
          longjmp((int *)(a1 + 3464), 1);
      }
      if ((void *)v3[2] != v8
        && (!__gl_meshSplice(*(void **)(v8[1] + 24), v8) || !__gl_meshSplice(v3, v8)))
      {
        goto LABEL_14;
      }
      uint64_t v10 = *(void *)v5;
      uint64_t v11 = *(void *)(*(void *)v5 + 40);
      *(unsigned char *)(v11 + 41) = v5[20];
      *(void *)(v11 + 16) = v10;
      DeleteRegion(a1, v5);
      uint64_t v3 = *(void **)v7;
      uint64_t v5 = v7;
    }
    while (v7 != a3);
  }
  return v3;
}

void AddRightEdges(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, int a6)
{
  do
  {
    uint64_t v12 = a3[4];
    double v13 = *(double *)(v12 + 56);
    uint64_t v14 = a3[1];
    uint64_t v15 = *(void *)(v14 + 32);
    double v16 = *(double *)(v15 + 56);
    if (v13 >= v16 && (v13 != v16 || *(double *)(v12 + 64) > *(double *)(v15 + 64))) {
      AddRightEdges_cold_2();
    }
    AddRegionBelow(a1, a2, v14);
    a3 = (void *)a3[2];
  }
  while (a3 != a4);
  double v17 = **(_DWORD ***)(*(void *)(a2 + 8) + 16);
  uint64_t v18 = *(void *)(*(void *)v17 + 8);
  if (!a5) {
    a5 = *(void *)(v18 + 16);
  }
  if (*(void *)(v18 + 32) == *(void *)(a5 + 32))
  {
    char v19 = 0;
    do
    {
      uint64_t v20 = a2;
      uint64_t v21 = a5;
      a2 = (uint64_t)v17;
      a5 = v18;
      if (*(void *)(v18 + 16) != v21
        && (!__gl_meshSplice(*(void **)(*(void *)(v18 + 8) + 24), (void *)v18)
         || !__gl_meshSplice(*(void **)(*(void *)(v21 + 8) + 24), (void *)a5))
        || (unsigned int v22 = *(_DWORD *)(v20 + 16) - *(_DWORD *)(a5 + 56),
            *(_DWORD *)(a2 + 16) = v22,
            *(unsigned char *)(a2 + 20) = IsWindingInside(a1, v22),
            *(unsigned char *)(v20 + 22) = 1,
            (v19 & 1) != 0)
        && CheckForRightSplice(a1, (unsigned char *)v20)
        && (*(_DWORD *)(a5 + 56) += *(_DWORD *)(v21 + 56),
            *(_DWORD *)(*(void *)(a5 + 8) + 56) += *(_DWORD *)(*(void *)(v21 + 8) + 56),
            DeleteRegion(a1, (unsigned char *)v20),
            !__gl_meshDelete((void *)v21)))
      {
        longjmp((int *)(a1 + 3464), 1);
      }
      double v17 = **(_DWORD ***)(*(void *)(a2 + 8) + 16);
      uint64_t v18 = *(void *)(*(void *)v17 + 8);
      char v19 = 1;
    }
    while (*(void *)(v18 + 32) == *(void *)(a5 + 32));
  }
  *(unsigned char *)(a2 + 22) = 1;
  if (*(_DWORD *)(a2 + 16) - *(_DWORD *)(v18 + 56) != v17[4]) {
    AddRightEdges_cold_1();
  }
  if (a6)
  {
    WalkDirtyRegions(a1, (uint64_t *)a2);
  }
}

uint64_t FixUpperEdge(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 23)) {
    FixUpperEdge_cold_1();
  }
  uint64_t result = __gl_meshDelete(*(void **)a1);
  if (result)
  {
    *(unsigned char *)(a1 + 23) = 0;
    *(void *)a1 = a2;
    uint64_t result = 1;
    *(void *)(a2 + 48) = a1;
  }
  return result;
}

void *AddRegionBelow(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = malloc_type_malloc(0x18uLL, 0x102004062D53EE8uLL);
  if (!v6
    || (uint64_t v7 = v6,
        *uint64_t v6 = a3,
        uint64_t v8 = __gl_dictListInsertBefore(*(void *)(a1 + 120), *(void **)(a2 + 8), (uint64_t)v6),
        (v7[1] = v8) == 0))
  {
    longjmp((int *)(a1 + 3464), 1);
  }
  *((unsigned char *)v7 + 23) = 0;
  *(_WORD *)((char *)v7 + 21) = 0;
  *(void *)(a3 + 48) = v7;
  return v7;
}

uint64_t IsWindingInside(uint64_t a1, unsigned int a2)
{
  switch(*(_DWORD *)(a1 + 112))
  {
    case 0x18722:
      uint64_t result = a2 & 1;
      break;
    case 0x18723:
      uint64_t result = a2 != 0;
      break;
    case 0x18724:
      uint64_t result = (int)a2 > 0;
      break;
    case 0x18725:
      uint64_t result = a2 >> 31;
      break;
    case 0x18726:
      uint64_t result = a2 - 2 < 0xFFFFFFFD;
      break;
    default:
      IsWindingInside_cold_1();
  }
  return result;
}

void DeleteRegion(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(void *)a2;
  if (a2[23] && *(_DWORD *)(v3 + 56)) {
    DeleteRegion_cold_1();
  }
  *(void *)(v3 + 48) = 0;
  __gl_dictListDelete(*(void *)(a1 + 120), *((void **)a2 + 1));

  free(a2);
}

uint64_t CheckForIntersect(uint64_t a1, void *a2)
{
  v61[4] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a2;
  uint64_t v5 = **(unsigned char ***)(a2[1] + 16);
  uint64_t v6 = *(void *)v5;
  uint64_t v7 = *(void *)(*a2 + 32);
  uint64_t v8 = *(void *)(*(void *)v5 + 32);
  uint64_t v9 = *(void *)(*(void *)(*a2 + 8) + 32);
  uint64_t v10 = *(void *)(*(void *)(*(void *)v5 + 8) + 32);
  memset(v58, 0, sizeof(v58));
  if (*(double *)(v10 + 56) == *(double *)(v9 + 56) && *(double *)(v10 + 64) == *(double *)(v9 + 64)) {
    CheckForIntersect_cold_1();
  }
  if (__gl_edgeSign(v9, *(void *)(a1 + 136), v7) > 0.0) {
    CheckForIntersect_cold_2();
  }
  if (__gl_edgeSign(v10, *(void *)(a1 + 136), v8) < 0.0) {
    CheckForIntersect_cold_3();
  }
  uint64_t v11 = *(void *)(a1 + 136);
  if (v7 == v11 || v8 == v11) {
    CheckForIntersect_cold_9();
  }
  if (*((unsigned char *)a2 + 23) || v5[23]) {
    CheckForIntersect_cold_8();
  }
  if (v7 == v8) {
    return 0;
  }
  double v12 = *(double *)(v7 + 64);
  if (v12 > *(double *)(v9 + 64)) {
    double v13 = *(double *)(v9 + 64);
  }
  else {
    double v13 = *(double *)(v7 + 64);
  }
  double v14 = *(double *)(v8 + 64);
  double v15 = *(double *)(v10 + 64);
  if (v14 >= v15) {
    double v15 = *(double *)(v8 + 64);
  }
  if (v13 > v15) {
    return 0;
  }
  double v16 = *(double *)(v7 + 56);
  double v17 = *(double *)(v8 + 56);
  if (v16 >= v17 && (v12 > v14 || v16 != v17))
  {
    if (__gl_edgeSign(v9, v8, v7) < 0.0) {
      return 0;
    }
LABEL_24:
    __gl_edgeIntersect(v9, v7, v10, v8, (uint64_t)v58);
    double v19 = *(double *)(v7 + 64);
    double v20 = *(double *)(v9 + 64);
    if (v19 > v20) {
      double v21 = *(double *)(v9 + 64);
    }
    else {
      double v21 = *(double *)(v7 + 64);
    }
    double v22 = *(double *)&v58[4];
    if (v21 > *(double *)&v58[4]) {
      CheckForIntersect_cold_4();
    }
    double v23 = *(double *)(v8 + 64);
    double v24 = *(double *)(v10 + 64);
    if (v23 >= v24) {
      double v24 = *(double *)(v8 + 64);
    }
    if (*(double *)&v58[4] > v24) {
      CheckForIntersect_cold_5();
    }
    double v25 = *(double *)(v10 + 56);
    double v26 = *(double *)(v9 + 56);
    if (v25 > v26) {
      double v27 = *(double *)(v9 + 56);
    }
    else {
      double v27 = *(double *)(v10 + 56);
    }
    double v28 = *((double *)&v58[3] + 1);
    if (v27 > *((double *)&v58[3] + 1)) {
      CheckForIntersect_cold_6();
    }
    double v29 = *(double *)(v8 + 56);
    double v30 = *(double *)(v7 + 56);
    if (v29 < v30) {
      double v31 = *(double *)(v7 + 56);
    }
    else {
      double v31 = *(double *)(v8 + 56);
    }
    if (*((double *)&v58[3] + 1) > v31) {
      CheckForIntersect_cold_7();
    }
    uint64_t v32 = *(void *)(a1 + 136);
    double v33 = *(double *)(v32 + 56);
    if (*((double *)&v58[3] + 1) >= v33)
    {
      if (*((double *)&v58[3] + 1) != v33 || (double v34 = *(double *)(v32 + 64), *(double *)&v58[4] > v34))
      {
LABEL_44:
        double v35 = v30;
        uint64_t v36 = v7;
        if (v30 >= v29)
        {
          BOOL v37 = v30 != v29;
          if (v19 > v23) {
            BOOL v37 = 1;
          }
          if (v37) {
            double v35 = v29;
          }
          else {
            double v35 = v30;
          }
          if (v37) {
            uint64_t v36 = v8;
          }
          else {
            uint64_t v36 = v7;
          }
        }
        if (v35 >= v28)
        {
          if (v35 != v28) {
            goto LABEL_58;
          }
          double v38 = *(double *)(v36 + 64);
          if (v38 > v22) {
            goto LABEL_58;
          }
        }
        else
        {
          double v38 = *(double *)(v36 + 64);
        }
        *((double *)&v58[3] + 1) = v35;
        *(double *)&v58[4] = v38;
        double v22 = v38;
        double v28 = v35;
LABEL_58:
        if (v28 == v30 && v22 == v19 || v28 == v29 && v22 == *(double *)(v8 + 64))
        {
          CheckForRightSplice(a1, a2);
          return 0;
        }
        double v41 = *(double *)(v32 + 56);
        if (v26 != v41 || v20 != *(double *)(v32 + 64))
        {
          if (__gl_edgeSign(v9, v32, (uint64_t)v58) >= 0.0) {
            goto LABEL_77;
          }
          double v25 = *(double *)(v10 + 56);
          uint64_t v32 = *(void *)(a1 + 136);
          double v41 = *(double *)(v32 + 56);
        }
        if (v25 == v41 && *(double *)(v10 + 64) == *(double *)(v32 + 64) || __gl_edgeSign(v10, v32, (uint64_t)v58) > 0.0)
        {
          if (__gl_meshSplitEdge(*(void *)(v4 + 8))
            && __gl_meshSplitEdge(*(void *)(v6 + 8))
            && __gl_meshSplice(*(void **)(*(void *)(v6 + 8) + 24), (void *)v4))
          {
            uint64_t v42 = *(void *)(v4 + 32);
            *(_OWORD *)(v42 + 56) = *(_OWORD *)((char *)&v58[3] + 8);
            uint64_t v43 = __gl_pqSortInsert(*(void *)(a1 + 128), v42);
            uint64_t v44 = *(void *)(v4 + 32);
            *(void *)(v44 + 72) = v43;
            if (v43 != 0x7FFFFFFFFFFFFFFFLL)
            {
              uint64_t v45 = *(void *)(v9 + 24);
              v61[0] = *(void *)(v7 + 24);
              v61[1] = v45;
              uint64_t v46 = *(void *)(v10 + 24);
              v61[2] = *(void *)(v8 + 24);
              v61[3] = v46;
              *(void *)(v44 + 40) = 0;
              *(void *)(v44 + 48) = 0;
              *(void *)(v44 + 32) = 0;
              VertexWeights((double *)v44, (double *)v7, (double *)v9, (uint64_t)v59);
              VertexWeights((double *)v44, (double *)v8, (double *)v10, (uint64_t)&v60);
              CallCombine(a1, v44, v61, (uint64_t)v59, 1);
              uint64_t v39 = 0;
              v5[22] = 1;
              *((unsigned char *)a2 + 22) = 1;
              *(unsigned char *)(**(void **)(a2[1] + 8) + 22) = 1;
              return v39;
            }
            __gl_pqSortDeletePriorityQ(*(void ****)(a1 + 128));
            *(void *)(a1 + 128) = 0;
          }
          goto LABEL_106;
        }
LABEL_77:
        uint64_t v47 = *(void *)(a1 + 136);
        if (v10 == v47)
        {
          if (!__gl_meshSplitEdge(*(void *)(v4 + 8))) {
            goto LABEL_106;
          }
          if (!__gl_meshSplice(*(void **)(v6 + 8), (void *)v4)) {
            goto LABEL_106;
          }
          double v49 = TopLeftRegion(a2);
          if (!v49) {
            goto LABEL_106;
          }
          double v50 = v49;
          double v51 = *(uint64_t ***)(v49[1] + 16);
          uint64_t v52 = **v51;
          FinishLeftRegions(a1, (void **)*v51, v5);
          uint64_t v53 = *(void *)(*(void *)(v52 + 8) + 24);
          uint64_t v39 = 1;
          uint64_t v54 = a1;
          int32x4_t v55 = v50;
          uint64_t v56 = v52;
        }
        else
        {
          if (v9 != v47)
          {
            if (__gl_edgeSign(v9, v47, (uint64_t)v58) >= 0.0)
            {
              *((unsigned char *)a2 + 22) = 1;
              *(unsigned char *)(**(void **)(a2[1] + 8) + 22) = 1;
              if (!__gl_meshSplitEdge(*(void *)(v4 + 8))) {
                goto LABEL_106;
              }
              uint64_t v48 = *(void *)(a1 + 136);
              *(_OWORD *)(*(void *)(v4 + 32) + 56) = *(_OWORD *)(v48 + 56);
            }
            else
            {
              uint64_t v48 = *(void *)(a1 + 136);
            }
            if (__gl_edgeSign(v10, v48, (uint64_t)v58) > 0.0) {
              return 0;
            }
            v5[22] = 1;
            *((unsigned char *)a2 + 22) = 1;
            if (__gl_meshSplitEdge(*(void *)(v6 + 8)))
            {
              uint64_t v39 = 0;
              *(_OWORD *)(*(void *)(v6 + 32) + 56) = *(_OWORD *)(*(void *)(a1 + 136) + 56);
              return v39;
            }
LABEL_106:
            longjmp((int *)(a1 + 3464), 1);
          }
          if (!__gl_meshSplitEdge(*(void *)(v6 + 8))
            || !__gl_meshSplice(*(void **)(v4 + 24), *(void **)(*(void *)(v6 + 8) + 24)))
          {
            goto LABEL_106;
          }
          int32x4_t v57 = a2;
          do
            int32x4_t v57 = **(void ***)(v57[1] + 8);
          while (*(void *)(*(void *)(*v57 + 8) + 32) == *(void *)(*(void *)(*a2 + 8) + 32));
          uint64_t v52 = *(void *)(*(void *)(***(void ***)(v57[1] + 16) + 8) + 16);
          *a2 = *(void *)(*(void *)(v6 + 8) + 24);
          uint64_t v53 = FinishLeftRegions(a1, (void **)a2, 0)[2];
          uint64_t v56 = *(void *)(*(void *)(v4 + 8) + 16);
          uint64_t v39 = 1;
          uint64_t v54 = a1;
          int32x4_t v55 = v57;
        }
        AddRightEdges(v54, v55, v53, v56, v52, 1);
        return v39;
      }
    }
    else
    {
      double v34 = *(double *)(v32 + 64);
    }
    *((void *)&v58[3] + 1) = *(void *)(v32 + 56);
    *(double *)&v58[4] = v34;
    double v22 = v34;
    double v28 = v33;
    goto LABEL_44;
  }
  if (__gl_edgeSign(v10, v7, v8) <= 0.0) {
    goto LABEL_24;
  }
  return 0;
}

void WalkDirtyRegions(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = **(uint64_t ***)(a2[1] + 16);
  while (1)
  {
    if (*((unsigned char *)v4 + 22))
    {
      do
      {
        uint64_t v5 = v4;
        uint64_t v4 = **(uint64_t ***)(v4[1] + 16);
      }
      while (*((unsigned char *)v4 + 22));
    }
    else
    {
      uint64_t v5 = v2;
    }
    if (*((unsigned char *)v5 + 22))
    {
      uint64_t v2 = v5;
      uint64_t v5 = v4;
      goto LABEL_10;
    }
    uint64_t v2 = **(uint64_t ***)(v5[1] + 8);
    if (!v2 || !*((unsigned char *)v2 + 22)) {
      break;
    }
LABEL_10:
    *((unsigned char *)v2 + 22) = 0;
    uint64_t v6 = *v2;
    uint64_t v7 = *v5;
    uint64_t v8 = *(void *)(*(void *)(*v2 + 8) + 32);
    if (v8 == *(void *)(*(void *)(*v5 + 8) + 32)) {
      goto LABEL_32;
    }
    uint64_t v9 = **(unsigned char ***)(v2[1] + 16);
    uint64_t v10 = *(void *)v9;
    double v11 = *(double *)(v8 + 56);
    uint64_t v12 = *(void *)(*(void *)(*(void *)v9 + 8) + 32);
    double v13 = *(double *)(v12 + 56);
    if (v11 == v13)
    {
      double v14 = *(double *)(v8 + 64);
      double v15 = *(double *)(v12 + 64);
      if (v14 == v15) {
        WalkDirtyRegions_cold_1();
      }
      if (v11 < v13 || v14 <= v15)
      {
LABEL_17:
        if (__gl_edgeSign(*(void *)(*(void *)(*v2 + 8) + 32), *(void *)(*(void *)(*(void *)v9 + 8) + 32), *(void *)(v6 + 32)) < 0.0)goto LABEL_32; {
        *((unsigned char *)v2 + 22) = 1;
        }
        *(unsigned char *)(**(void **)(v2[1] + 8) + 22) = 1;
        double v17 = __gl_meshSplitEdge(v6);
        if (!v17) {
          goto LABEL_51;
        }
        uint64_t v18 = v17;
        if (!__gl_meshSplice(*(void **)(v10 + 8), v17)) {
          goto LABEL_51;
        }
        goto LABEL_26;
      }
    }
    else if (v11 < v13)
    {
      goto LABEL_17;
    }
    if (__gl_edgeSign(*(void *)(*(void *)(*(void *)v9 + 8) + 32), v8, *(void *)(v10 + 32)) > 0.0) {
      goto LABEL_32;
    }
    v9[22] = 1;
    *((unsigned char *)v2 + 22) = 1;
    double v19 = __gl_meshSplitEdge(v10);
    if (!v19 || (double v20 = v19, !__gl_meshSplice(*(void **)(v6 + 24), *(void **)(v10 + 8)))) {
LABEL_51:
    }
      longjmp((int *)(a1 + 3464), 1);
    uint64_t v18 = (void *)v20[1];
LABEL_26:
    *(unsigned char *)(v18[5] + 41) = *((unsigned char *)v2 + 20);
    if (*((unsigned char *)v5 + 23))
    {
      DeleteRegion(a1, v5);
      if (!__gl_meshDelete((void *)v7)) {
        goto LABEL_51;
      }
      double v21 = *(uint64_t ***)(v2[1] + 16);
      uint64_t v4 = *v21;
      uint64_t v7 = **v21;
      goto LABEL_33;
    }
    if (*((unsigned char *)v2 + 23))
    {
      DeleteRegion(a1, v2);
      if (!__gl_meshDelete((void *)v6)) {
        goto LABEL_51;
      }
      double v22 = *(uint64_t ***)(v5[1] + 8);
      uint64_t v2 = *v22;
      uint64_t v6 = **v22;
    }
LABEL_32:
    uint64_t v4 = v5;
LABEL_33:
    if (*(void *)(v6 + 32) != *(void *)(v7 + 32))
    {
      uint64_t v23 = *(void *)(*(void *)(v6 + 8) + 32);
      uint64_t v24 = *(void *)(*(void *)(v7 + 8) + 32);
      if (v23 == v24
        || *((unsigned char *)v2 + 23)
        || *((unsigned char *)v4 + 23)
        || ((uint64_t v25 = *(void *)(a1 + 136), v23 != v25) ? (v26 = v24 == v25) : (v26 = 1), !v26))
      {
        CheckForRightSplice(a1, v2);
      }
      else if (CheckForIntersect(a1, v2))
      {
        return;
      }
    }
    if (*(void *)(v6 + 32) == *(void *)(v7 + 32))
    {
      uint64_t v27 = *(void *)(v6 + 8);
      uint64_t v28 = *(void *)(v7 + 8);
      if (*(void *)(v27 + 32) == *(void *)(v28 + 32))
      {
        *(_DWORD *)(v7 + 56) += *(_DWORD *)(v6 + 56);
        *(_DWORD *)(v28 + 56) += *(_DWORD *)(v27 + 56);
        DeleteRegion(a1, v2);
        if (!__gl_meshDelete((void *)v6)) {
          goto LABEL_51;
        }
        uint64_t v2 = **(uint64_t ***)(v4[1] + 8);
      }
    }
  }
}

uint64_t CheckForRightSplice(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = *(void **)a2;
  uint64_t v5 = **(unsigned char ***)(*((void *)a2 + 1) + 16);
  uint64_t v6 = *(void *)v5;
  uint64_t v7 = *(void *)(*(void *)a2 + 32);
  double v8 = *(double *)(v7 + 56);
  uint64_t v9 = *(void *)(*(void *)v5 + 32);
  double v10 = *(double *)(v9 + 56);
  if (v8 >= v10 && (v8 != v10 || *(double *)(v7 + 64) > *(double *)(v9 + 64)))
  {
    if (__gl_edgeSign(*(void *)(v4[1] + 32), *(void *)(*(void *)v5 + 32), v7) >= 0.0)
    {
      a2[22] = 1;
      *(unsigned char *)(**(void **)(*((void *)a2 + 1) + 8) + 22) = 1;
      if (!__gl_meshSplitEdge(v4[1]) || !__gl_meshSplice(*(void **)(*(void *)(v6 + 8) + 24), v4)) {
        goto LABEL_18;
      }
      return 1;
    }
    return 0;
  }
  if (__gl_edgeSign(*(void *)(*(void *)(v6 + 8) + 32), *(void *)(*(void *)a2 + 32), v9) > 0.0) {
    return 0;
  }
  uint64_t v12 = v4[4];
  uint64_t v13 = *(void *)(v6 + 32);
  if (*(double *)(v12 + 56) == *(double *)(v13 + 56) && *(double *)(v12 + 64) == *(double *)(v13 + 64))
  {
    if (v12 != v13)
    {
      __gl_pqSortDelete(*(uint64_t **)(a1 + 128), *(void *)(v12 + 72));
      SpliceMergeVertices(a1, *(void **)(*(void *)(v6 + 8) + 24), v4);
    }
    return 1;
  }
  if (!__gl_meshSplitEdge(*(void *)(v6 + 8))
    || !__gl_meshSplice(v4, *(void **)(*(void *)(v6 + 8) + 24)))
  {
LABEL_18:
    longjmp((int *)(a1 + 3464), 1);
  }
  uint64_t result = 1;
  v5[22] = 1;
  a2[22] = 1;
  return result;
}

double VertexWeights(double *a1, double *a2, double *a3, uint64_t a4)
{
  double v5 = a1[6];
  double v4 = a1[7];
  double v6 = a2[7] - v4;
  if (v6 < 0.0) {
    double v6 = -v6;
  }
  double v7 = a1[8];
  double v8 = a2[8] - v7;
  if (v8 < 0.0) {
    double v8 = -v8;
  }
  double v9 = a3[7] - v4;
  if (v9 < 0.0) {
    double v9 = -v9;
  }
  double v10 = a3[8] - v7;
  if (v10 < 0.0) {
    double v10 = -v10;
  }
  double v11 = v6 + v8;
  double v12 = v11 + v9 + v10;
  float v13 = (v9 + v10) * 0.5 / v12;
  *(float *)&double v11 = v11 * 0.5 / v12;
  *(float *)a4 = v13;
  *(_DWORD *)(a4 + 4) = LODWORD(v11);
  double v14 = *(float *)&v11;
  double v15 = a1[5];
  a1[4] = a1[4] + a2[4] * v13 + a3[4] * v14;
  a1[5] = v15 + a2[5] * v13 + a3[5] * v14;
  double result = v5 + a2[6] * v13 + a3[6] * v14;
  a1[6] = result;
  return result;
}

void __gl_computeInterior_cold_1()
{
}

void __gl_computeInterior_cold_2()
{
  __assert_rtn("RemoveDegenerateFaces", "sweep.c", 1286, "e->Lnext != e");
}

void __gl_computeInterior_cold_3()
{
  __assert_rtn("DoneEdgeDict", "sweep.c", 1187, "reg->windingNumber == 0");
}

void __gl_computeInterior_cold_4()
{
  __assert_rtn("DoneEdgeDict", "sweep.c", 1185, "++fixedEdges == 1");
}

void SweepEvent_cold_1()
{
}

void SweepEvent_cold_2()
{
}

void AddRightEdges_cold_1()
{
  __assert_rtn("AddRightEdges", "sweep.c", 399, "regPrev->windingNumber - e->winding == reg->windingNumber");
}

void AddRightEdges_cold_2()
{
}

void FixUpperEdge_cold_1()
{
}

void IsWindingInside_cold_1()
{
}

void DeleteRegion_cold_1()
{
  __assert_rtn("DeleteRegion", "sweep.c", 154, "reg->eUp->winding == 0");
}

void CheckForIntersect_cold_1()
{
}

void CheckForIntersect_cold_2()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 625, "EdgeSign( dstUp, tess->event, orgUp) <= 0");
}

void CheckForIntersect_cold_3()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 626, "EdgeSign( dstLo, tess->event, orgLo) >= 0");
}

void CheckForIntersect_cold_4()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 647, "MIN( orgUp->t, dstUp->t) <= isect.t");
}

void CheckForIntersect_cold_5()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 648, "isect.t <= MAX( orgLo->t, dstLo->t)");
}

void CheckForIntersect_cold_6()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 649, "MIN( dstLo->s, dstUp->s) <= isect.s");
}

void CheckForIntersect_cold_7()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 650, "isect.s <= MAX( orgLo->s, orgUp->s)");
}

void CheckForIntersect_cold_8()
{
}

void CheckForIntersect_cold_9()
{
  __assert_rtn("CheckForIntersect", "sweep.c", 627, "orgUp != tess->event && orgLo != tess->event");
}

void WalkDirtyRegions_cold_1()
{
}

void *__gl_dictListNewDict(uint64_t a1, uint64_t a2)
{
  double result = malloc_type_malloc(0x28uLL, 0xA0040D423F0E8uLL);
  if (result)
  {
    void *result = 0;
    result[1] = result;
    result[2] = result;
    result[3] = a1;
    result[4] = a2;
  }
  return result;
}

void __gl_dictListDeleteDict(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2 != a1)
  {
    do
    {
      uint64_t v3 = (void *)v2[1];
      free(v2);
      uint64_t v2 = v3;
    }
    while (v3 != a1);
  }

  free(a1);
}

void *__gl_dictListInsertBefore(uint64_t a1, void *a2, uint64_t a3)
{
  do
    a2 = (void *)a2[2];
  while (*a2 && !(*(unsigned int (**)(void, void, uint64_t))(a1 + 32))(*(void *)(a1 + 24), *a2, a3));
  double result = malloc_type_malloc(0x18uLL, 0xA00409BE6959DuLL);
  if (result)
  {
    uint64_t v7 = a2[1];
    void *result = a3;
    result[1] = v7;
    *(void *)(a2[1] + 16) = result;
    result[2] = a2;
    a2[1] = result;
  }
  return result;
}

void __gl_dictListDelete(int a1, void *a2)
{
  uint64_t v2 = a2[1];
  *(void *)(v2 + 16) = a2[2];
  *(void *)(a2[2] + 8) = v2;
  free(a2);
}

void *__gl_dictListSearch(uint64_t a1, uint64_t a2)
{
  double v4 = (void *)a1;
  do
    double v4 = (void *)v4[1];
  while (*v4 && !(*(unsigned int (**)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 24), a2));
  return v4;
}

void *__gl_meshMakeEdge(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x50uLL, 0x10A004024993A61uLL);
  uint64_t v3 = malloc_type_malloc(0x50uLL, 0x10A004024993A61uLL);
  double v4 = malloc_type_malloc(0x30uLL, 0x10A0040FE2E6FF0uLL);
  double v5 = v4;
  if (!v2 || !v3 || !v4)
  {
    if (v2) {
      free(v2);
    }
    if (v3) {
      free(v3);
    }
    if (!v5) {
      return 0;
    }
    goto LABEL_19;
  }
  double result = MakeEdge(a1 + 128);
  if (!result)
  {
    free(v2);
    free(v3);
LABEL_19:
    free(v5);
    return 0;
  }
  uint64_t v7 = *(void **)(a1 + 8);
  *uint64_t v7 = v2;
  v2[1] = v7;
  v2[2] = result;
  v2[3] = 0;
  double v8 = result;
  do
  {
    v8[4] = v2;
    double v8 = (void *)v8[2];
  }
  while (v8 != result);
  uint64_t v9 = result[1];
  *uint64_t v2 = v3;
  *uint64_t v3 = a1;
  v3[1] = v2;
  *(void *)(a1 + 8) = v3;
  v3[2] = v9;
  v3[3] = 0;
  uint64_t v10 = v9;
  do
  {
    *(void *)(v10 + 32) = v3;
    uint64_t v10 = *(void *)(v10 + 16);
  }
  while (v10 != v9);
  double v11 = *(void **)(a1 + 88);
  *double v11 = v5;
  void *v5 = a1 + 80;
  v5[1] = v11;
  *(void *)(a1 + 88) = v5;
  v5[2] = result;
  v5[3] = 0;
  v5[4] = 0;
  *((unsigned char *)v5 + 40) = 0;
  *((unsigned char *)v5 + 41) = *(unsigned char *)(a1 + 121);
  double v12 = result;
  do
  {
    v12[5] = v5;
    double v12 = (void *)v12[3];
  }
  while (v12 != result);
  return result;
}

void *MakeEdge(unint64_t a1)
{
  double result = malloc_type_malloc(0x80uLL, 0x1020040E084476EuLL);
  if (result)
  {
    unint64_t v3 = *(void *)(a1 + 8);
    if (v3 >= a1) {
      unint64_t v3 = a1;
    }
    double v4 = *(uint64_t **)(v3 + 8);
    uint64_t v5 = *v4;
    result[8] = *v4;
    **(void **)(v5 + 8) = result;
    void *result = v3;
    *double v4 = (uint64_t)(result + 8);
    result[1] = result + 8;
    result[2] = result;
    result[3] = result + 8;
    result[4] = 0;
    result[5] = 0;
    result[6] = 0;
    *((_DWORD *)result + 14) = 0;
    result[9] = result;
    result[10] = result + 8;
    result[11] = result;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    *((_DWORD *)result + 30) = 0;
  }
  return result;
}

uint64_t __gl_meshSplice(void *a1, void *a2)
{
  if (a1 == a2) {
    return 1;
  }
  double v4 = (uint64_t *)a2[4];
  uint64_t v5 = (uint64_t *)a1[4];
  if (v4 != v5)
  {
    uint64_t v6 = v4[2];
    uint64_t v7 = v6;
    do
    {
      *(void *)(v7 + 32) = v5;
      uint64_t v7 = *(void *)(v7 + 16);
    }
    while (v7 != v6);
    uint64_t v9 = *v4;
    double v8 = (void *)v4[1];
    *(void *)(v9 + 8) = v8;
    *double v8 = v9;
    free(v4);
  }
  uint64_t v10 = (uint64_t *)a2[5];
  double v11 = (uint64_t *)a1[5];
  if (v10 != v11)
  {
    uint64_t v12 = v10[2];
    uint64_t v13 = v12;
    do
    {
      *(void *)(v13 + 40) = v11;
      uint64_t v13 = *(void *)(v13 + 24);
    }
    while (v13 != v12);
    uint64_t v15 = *v10;
    double v14 = (void *)v10[1];
    *(void *)(v15 + 8) = v14;
    *double v14 = v15;
    free(v10);
  }
  uint64_t v16 = a2[2];
  uint64_t v17 = a1[2];
  *(void *)(*(void *)(v16 + 8) + 24) = a1;
  *(void *)(*(void *)(v17 + 8) + 24) = a2;
  a2[2] = v17;
  a1[2] = v16;
  if (v4 == v5)
  {
    uint64_t result = (uint64_t)malloc_type_malloc(0x50uLL, 0x10A004024993A61uLL);
    if (!result) {
      return result;
    }
    uint64_t v19 = a1[4];
    double v20 = *(uint64_t **)(v19 + 8);
    *double v20 = result;
    *(void *)uint64_t result = v19;
    *(void *)(result + 8) = v20;
    *(void *)(v19 + 8) = result;
    *(void *)(result + 16) = a2;
    *(void *)(result + 24) = 0;
    double v21 = a2;
    do
    {
      v21[4] = result;
      double v21 = (void *)v21[2];
    }
    while (v21 != a2);
    *(void *)(a1[4] + 16) = a1;
  }
  if (v10 == v11)
  {
    uint64_t result = (uint64_t)malloc_type_malloc(0x30uLL, 0x10A0040FE2E6FF0uLL);
    if (!result) {
      return result;
    }
    uint64_t v22 = a1[5];
    uint64_t v23 = *(uint64_t **)(v22 + 8);
    *uint64_t v23 = result;
    *(void *)uint64_t result = v22;
    *(void *)(result + 8) = v23;
    *(void *)(v22 + 8) = result;
    *(void *)(result + 24) = 0;
    *(void *)(result + 32) = 0;
    *(void *)(result + 16) = a2;
    *(unsigned char *)(result + 40) = 0;
    *(unsigned char *)(result + 41) = *(unsigned char *)(v22 + 41);
    uint64_t v24 = a2;
    do
    {
      v24[5] = result;
      uint64_t v24 = (void *)v24[3];
    }
    while (v24 != a2);
    *(void *)(a1[5] + 16) = a1;
  }
  return 1;
}

uint64_t __gl_meshDelete(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  unint64_t v3 = (uint64_t *)a1[5];
  double v4 = (uint64_t *)v2[5];
  if (v3 != v4)
  {
    uint64_t v5 = v3[2];
    uint64_t v6 = v5;
    do
    {
      *(void *)(v6 + 40) = v4;
      uint64_t v6 = *(void *)(v6 + 24);
    }
    while (v6 != v5);
    uint64_t v8 = *v3;
    uint64_t v7 = (void *)v3[1];
    *(void *)(v8 + 8) = v7;
    *uint64_t v7 = v8;
    free(v3);
  }
  uint64_t v9 = (void *)a1[2];
  if (v9 == a1)
  {
    uint64_t v17 = (uint64_t *)a1[4];
    uint64_t v18 = v17[2];
    uint64_t v19 = v18;
    do
    {
      *(void *)(v19 + 32) = 0;
      uint64_t v19 = *(void *)(v19 + 16);
    }
    while (v19 != v18);
    uint64_t v21 = *v17;
    double v20 = (void *)v17[1];
    *(void *)(v21 + 8) = v20;
    *double v20 = v21;
    free(v17);
  }
  else
  {
    uint64_t v10 = a1[1];
    uint64_t v11 = *(void *)(v10 + 24);
    *(void *)(*(void *)(v10 + 40) + 16) = v11;
    *(void *)(a1[4] + 16) = v9;
    uint64_t v12 = *(void *)(v11 + 16);
    *(void *)(v9[1] + 24) = v11;
    *(void *)(*(void *)(v12 + 8) + 24) = a1;
    a1[2] = v12;
    *(void *)(v11 + 16) = v9;
    if (v3 == v4)
    {
      uint64_t result = (uint64_t)malloc_type_malloc(0x30uLL, 0x10A0040FE2E6FF0uLL);
      if (!result) {
        return result;
      }
      uint64_t v14 = a1[5];
      uint64_t v15 = *(uint64_t **)(v14 + 8);
      *uint64_t v15 = result;
      *(void *)uint64_t result = v14;
      *(void *)(result + 8) = v15;
      *(void *)(v14 + 8) = result;
      *(void *)(result + 24) = 0;
      *(void *)(result + 32) = 0;
      *(void *)(result + 16) = a1;
      *(unsigned char *)(result + 40) = 0;
      *(unsigned char *)(result + 41) = *(unsigned char *)(v14 + 41);
      uint64_t v16 = a1;
      do
      {
        v16[5] = result;
        uint64_t v16 = (void *)v16[3];
      }
      while (v16 != a1);
    }
  }
  uint64_t v22 = (void *)v2[2];
  if (v22 == v2)
  {
    uint64_t v25 = (uint64_t *)v2[4];
    uint64_t v26 = v25[2];
    uint64_t v27 = v26;
    do
    {
      *(void *)(v27 + 32) = 0;
      uint64_t v27 = *(void *)(v27 + 16);
    }
    while (v27 != v26);
    uint64_t v29 = *v25;
    uint64_t v28 = (void *)v25[1];
    *(void *)(v29 + 8) = v28;
    *uint64_t v28 = v29;
    free(v25);
    double v30 = (uint64_t *)v2[5];
    uint64_t v31 = v30[2];
    uint64_t v32 = v31;
    do
    {
      *(void *)(v32 + 40) = 0;
      uint64_t v32 = *(void *)(v32 + 24);
    }
    while (v32 != v31);
    uint64_t v34 = *v30;
    double v33 = (void *)v30[1];
    *(void *)(v34 + 8) = v33;
    *double v33 = v34;
    free(v30);
  }
  else
  {
    uint64_t v23 = *(void *)(v2[1] + 24);
    *(void *)(a1[5] + 16) = v23;
    *(void *)(v2[4] + 16) = v22;
    uint64_t v24 = *(void *)(v23 + 16);
    *(void *)(v22[1] + 24) = v23;
    *(void *)(*(void *)(v24 + 8) + 24) = v2;
    v2[2] = v24;
    *(void *)(v23 + 16) = v22;
  }
  if (a1[1] >= (unint64_t)a1) {
    double v35 = a1;
  }
  else {
    double v35 = (uint64_t *)a1[1];
  }
  uint64_t v36 = *v35;
  uint64_t v37 = *(void *)v35[1];
  **(void **)(*v35 + 8) = v37;
  **(void **)(v37 + 8) = v36;
  free(v35);
  return 1;
}

void *__gl_meshAddEdgeVertex(void *a1)
{
  Edge = MakeEdge((unint64_t)a1);
  unint64_t v3 = Edge;
  if (Edge)
  {
    uint64_t v4 = a1[3];
    uint64_t v6 = Edge[1];
    uint64_t v5 = Edge[2];
    uint64_t v7 = *(void *)(v4 + 16);
    *(void *)(*(void *)(v5 + 8) + 24) = v4;
    *(void *)(*(void *)(v7 + 8) + 24) = Edge;
    Edge[2] = v7;
    *(void *)(v4 + 16) = v5;
    Edge[4] = *(void *)(a1[1] + 32);
    uint64_t v8 = malloc_type_malloc(0x50uLL, 0x10A004024993A61uLL);
    if (v8)
    {
      uint64_t v9 = v3[4];
      uint64_t v10 = *(void **)(v9 + 8);
      *uint64_t v10 = v8;
      *uint64_t v8 = v9;
      v8[1] = v10;
      *(void *)(v9 + 8) = v8;
      v8[2] = v6;
      v8[3] = 0;
      uint64_t v11 = v6;
      do
      {
        *(void *)(v11 + 32) = v8;
        uint64_t v11 = *(void *)(v11 + 16);
      }
      while (v11 != v6);
      uint64_t v12 = a1[5];
      *(void *)(v6 + 40) = v12;
      v3[5] = v12;
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

void *__gl_meshSplitEdge(uint64_t a1)
{
  uint64_t result = __gl_meshAddEdgeVertex((void *)a1);
  if (result)
  {
    uint64_t result = (void *)result[1];
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = *(void *)(v3 + 16);
    uint64_t v5 = *(void *)(*(void *)(v3 + 8) + 24);
    uint64_t v6 = *(void *)(v5 + 16);
    *(void *)(*(void *)(v4 + 8) + 24) = v5;
    *(void *)(*(void *)(v6 + 8) + 24) = v3;
    *(void *)(v3 + 16) = v6;
    *(void *)(v5 + 16) = v4;
    uint64_t v7 = *(void *)(v3 + 16);
    *(void *)(*(void *)(v7 + 8) + 24) = result;
    uint64_t v9 = result[1];
    uint64_t v8 = result[2];
    *(void *)(*(void *)(v8 + 8) + 24) = v3;
    *(void *)(v3 + 16) = v8;
    result[2] = v7;
    *(void *)(v3 + 32) = result[4];
    *(void *)(*(void *)(v9 + 32) + 16) = v9;
    *(void *)(v9 + 40) = *(void *)(v3 + 40);
    *((_DWORD *)result + 14) = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(v9 + 56) = *(_DWORD *)(v3 + 56);
  }
  return result;
}

void *__gl_meshConnect(void *a1, void *a2)
{
  Edge = MakeEdge((unint64_t)a1);
  uint64_t v5 = Edge;
  if (Edge)
  {
    uint64_t v6 = (void *)Edge[1];
    uint64_t v7 = (uint64_t *)a2[5];
    uint64_t v8 = (uint64_t *)a1[5];
    if (v7 == v8)
    {
      uint64_t v13 = a2[5];
    }
    else
    {
      uint64_t v9 = v7[2];
      uint64_t v10 = v9;
      do
      {
        *(void *)(v10 + 40) = v8;
        uint64_t v10 = *(void *)(v10 + 24);
      }
      while (v10 != v9);
      uint64_t v12 = *v7;
      uint64_t v11 = (void *)v7[1];
      *(void *)(v12 + 8) = v11;
      *uint64_t v11 = v12;
      free(v7);
      uint64_t v13 = a1[5];
    }
    uint64_t v14 = a1[3];
    uint64_t v15 = v5[2];
    uint64_t v16 = *(void *)(v14 + 16);
    *(void *)(*(void *)(v15 + 8) + 24) = v14;
    *(void *)(*(void *)(v16 + 8) + 24) = v5;
    v5[2] = v16;
    *(void *)(v14 + 16) = v15;
    uint64_t v17 = v6[2];
    uint64_t v18 = a2[2];
    *(void *)(*(void *)(v17 + 8) + 24) = a2;
    *(void *)(*(void *)(v18 + 8) + 24) = v6;
    v6[2] = v18;
    a2[2] = v17;
    v5[4] = *(void *)(a1[1] + 32);
    v6[4] = a2[4];
    v6[5] = v13;
    v5[5] = v13;
    *(void *)(a1[5] + 16) = v6;
    if (v7 == v8)
    {
      uint64_t v19 = malloc_type_malloc(0x30uLL, 0x10A0040FE2E6FF0uLL);
      if (v19)
      {
        uint64_t v20 = a1[5];
        uint64_t v21 = *(void **)(v20 + 8);
        *uint64_t v21 = v19;
        *uint64_t v19 = v20;
        v19[1] = v21;
        *(void *)(v20 + 8) = v19;
        v19[3] = 0;
        v19[4] = 0;
        v19[2] = v5;
        *((unsigned char *)v19 + 40) = 0;
        *((unsigned char *)v19 + 41) = *(unsigned char *)(v20 + 41);
        uint64_t v22 = v5;
        do
        {
          v22[5] = v19;
          uint64_t v22 = (void *)v22[3];
        }
        while (v22 != v5);
      }
      else
      {
        return 0;
      }
    }
  }
  return v5;
}

void __gl_meshZapFace(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[2];
  uint64_t v3 = (uint64_t *)v2[3];
  do
  {
    uint64_t v4 = (uint64_t *)v3[3];
    v3[5] = 0;
    uint64_t v5 = (uint64_t *)v3[1];
    if (!v5[5])
    {
      uint64_t v6 = (uint64_t *)v3[2];
      uint64_t v7 = (uint64_t *)v3[4];
      if (v6 == v3)
      {
        uint64_t v10 = v7[2];
        uint64_t v11 = v10;
        do
        {
          *(void *)(v11 + 32) = 0;
          uint64_t v11 = *(void *)(v11 + 16);
        }
        while (v11 != v10);
        uint64_t v13 = *v7;
        uint64_t v12 = (void *)v7[1];
        *(void *)(v13 + 8) = v12;
        *uint64_t v12 = v13;
        free(v7);
        uint64_t v5 = (uint64_t *)v3[1];
      }
      else
      {
        v7[2] = (uint64_t)v6;
        uint64_t v8 = v5[3];
        uint64_t v9 = *(void *)(v8 + 16);
        *(void *)(v6[1] + 24) = v8;
        *(void *)(*(void *)(v9 + 8) + 24) = v3;
        v3[2] = v9;
        *(void *)(v8 + 16) = v6;
      }
      uint64_t v14 = (uint64_t *)v5[2];
      uint64_t v15 = (uint64_t *)v5[4];
      if (v14 == v5)
      {
        uint64_t v18 = v15[2];
        uint64_t v19 = v18;
        do
        {
          *(void *)(v19 + 32) = 0;
          uint64_t v19 = *(void *)(v19 + 16);
        }
        while (v19 != v18);
        uint64_t v21 = *v15;
        uint64_t v20 = (void *)v15[1];
        *(void *)(v21 + 8) = v20;
        *uint64_t v20 = v21;
        free(v15);
        uint64_t v5 = (uint64_t *)v3[1];
      }
      else
      {
        v15[2] = (uint64_t)v14;
        uint64_t v16 = *(void *)(v5[1] + 24);
        uint64_t v17 = *(void *)(v16 + 16);
        *(void *)(v14[1] + 24) = v16;
        *(void *)(*(void *)(v17 + 8) + 24) = v5;
        v5[2] = v17;
        *(void *)(v16 + 16) = v14;
      }
      if (v5 >= v3) {
        uint64_t v22 = v3;
      }
      else {
        uint64_t v22 = v5;
      }
      uint64_t v23 = *v22;
      uint64_t v24 = *(void *)v22[1];
      **(void **)(*v22 + 8) = v24;
      **(void **)(v24 + 8) = v23;
      free(v22);
    }
    BOOL v25 = v3 == v2;
    uint64_t v3 = v4;
  }
  while (!v25);
  uint64_t v27 = *a1;
  uint64_t v26 = (void *)a1[1];
  *(void *)(v27 + 8) = v26;
  *uint64_t v26 = v27;

  free(a1);
}

double __gl_meshNewMesh()
{
  v0 = (char *)malloc_type_malloc(0x100uLL, 0x10A0040185A6F1AuLL);
  if (v0)
  {
    *(void *)v0 = v0;
    *((void *)v0 + 1) = v0;
    *((void *)v0 + 2) = 0;
    *((void *)v0 + 3) = 0;
    *((void *)v0 + 10) = v0 + 80;
    *((void *)v0 + 11) = v0 + 80;
    *((void *)v0 + 13) = 0;
    *((void *)v0 + 14) = 0;
    *((void *)v0 + 12) = 0;
    *((_WORD *)v0 + 60) = 0;
    *((void *)v0 + 16) = v0 + 128;
    *((void *)v0 + 17) = v0 + 192;
    double result = 0.0;
    *((_OWORD *)v0 + 9) = 0u;
    *((_OWORD *)v0 + 10) = 0u;
    *(_OWORD *)(v0 + 172) = 0u;
    *((void *)v0 + 24) = v0 + 192;
    *((void *)v0 + 25) = v0 + 128;
    *(_OWORD *)(v0 + 236) = 0u;
    *((_OWORD *)v0 + 13) = 0u;
    *((_OWORD *)v0 + 14) = 0u;
  }
  return result;
}

void __gl_meshDeleteMesh(void **a1)
{
  uint64_t v3 = (char *)(a1 + 10);
  uint64_t v2 = (char *)a1[10];
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = *(char **)v2;
      free(v2);
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  uint64_t v5 = (void **)*a1;
  if (*a1 != a1)
  {
    do
    {
      uint64_t v6 = (void **)*v5;
      free(v5);
      uint64_t v5 = v6;
    }
    while (v6 != a1);
  }
  uint64_t v7 = (void **)a1[16];
  if (v7 != a1 + 16)
  {
    do
    {
      uint64_t v8 = (void **)*v7;
      free(v7);
      uint64_t v7 = v8;
    }
    while (v8 != a1 + 16);
  }

  free(a1);
}

void *__gl_meshCheckMesh(void *result)
{
  uint64_t v1 = (void *)result[10];
  uint64_t v2 = result + 10;
  while (v1 != result + 10)
  {
    uint64_t v3 = v2;
    uint64_t v2 = v1;
    if ((void *)v1[1] != v3) {
      __gl_meshCheckMesh_cold_22();
    }
    uint64_t v4 = (void *)v1[2];
    do
    {
      uint64_t v5 = v4[1];
      if ((void *)v5 == v4) {
        __gl_meshCheckMesh_cold_17();
      }
      if (*(void **)(v5 + 8) != v4) {
        __gl_meshCheckMesh_cold_21();
      }
      uint64_t v6 = v4[3];
      if (*(void **)(*(void *)(v6 + 16) + 8) != v4) {
        __gl_meshCheckMesh_cold_20();
      }
      if (*(void **)(*(void *)(v4[2] + 8) + 24) != v4) {
        __gl_meshCheckMesh_cold_19();
      }
      if ((void *)v4[5] != v1) {
        __gl_meshCheckMesh_cold_18();
      }
      uint64_t v4 = (void *)v4[3];
    }
    while (v6 != v1[2]);
    uint64_t v1 = (void *)*v1;
  }
  if ((void *)result[11] != v2 || result[12] || result[13]) {
    __gl_meshCheckMesh_cold_16();
  }
  uint64_t v7 = (void *)*result;
  uint64_t v8 = result;
  if ((void *)*result != result)
  {
    uint64_t v8 = result;
    do
    {
      uint64_t v9 = v8;
      uint64_t v8 = v7;
      if ((void *)v7[1] != v9) {
        __gl_meshCheckMesh_cold_15();
      }
      uint64_t v10 = v7[2];
      uint64_t v11 = *(void *)(v10 + 8);
      uint64_t v12 = (void *)v8[2];
      do
      {
        if ((void *)v11 == v12) {
          __gl_meshCheckMesh_cold_10();
        }
        if (*(void **)(v11 + 8) != v12) {
          __gl_meshCheckMesh_cold_14();
        }
        if (*(void **)(*(void *)(v12[3] + 16) + 8) != v12) {
          __gl_meshCheckMesh_cold_13();
        }
        uint64_t v13 = v12[2];
        uint64_t v11 = *(void *)(v13 + 8);
        if (*(void **)(v11 + 24) != v12) {
          __gl_meshCheckMesh_cold_12();
        }
        if ((void *)v12[4] != v8) {
          __gl_meshCheckMesh_cold_11();
        }
        uint64_t v12 = (void *)v12[2];
      }
      while (v13 != v10);
      uint64_t v7 = (void *)*v8;
    }
    while ((void *)*v8 != result);
  }
  if ((void *)result[1] != v8 || result[2] || result[3]) {
    __gl_meshCheckMesh_cold_9();
  }
  uint64_t v14 = result + 16;
  uint64_t v15 = result + 16;
  while (1)
  {
    uint64_t v17 = v15;
    uint64_t v15 = (void *)*v15;
    uint64_t v16 = v17[1];
    if (v15 == v14) {
      break;
    }
    uint64_t v18 = (void *)v15[1];
    if (*v18 != v16) {
      __gl_meshCheckMesh_cold_8();
    }
    if (v18 == v15) {
      __gl_meshCheckMesh_cold_2();
    }
    if ((void *)v18[1] != v15) {
      __gl_meshCheckMesh_cold_7();
    }
    if (!v15[4]) {
      __gl_meshCheckMesh_cold_3();
    }
    if (!v18[4]) {
      __gl_meshCheckMesh_cold_4();
    }
    if (*(void **)(*(void *)(v15[3] + 16) + 8) != v15) {
      __gl_meshCheckMesh_cold_6();
    }
    if (*(void **)(*(void *)(v15[2] + 8) + 24) != v15) {
      __gl_meshCheckMesh_cold_5();
    }
  }
  uint64_t v19 = (void *)result[17];
  BOOL v20 = *v19 == v16 && v19 == result + 24;
  if (!v20 || (void *)v19[1] != v14 || result[20] || v19[4] || result[21] || v19[5]) {
    __gl_meshCheckMesh_cold_1();
  }
  return result;
}

void __gl_meshCheckMesh_cold_1()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 800, "e->Sym->next == ePrev->Sym && e->Sym == &mesh->eHeadSym && e->Sym->Sym == e && e->Org == NULL && e->Dst == NULL && e->Lface == NULL && e->Rface == NULL");
}

void __gl_meshCheckMesh_cold_2()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 789, "e->Sym != e");
}

void __gl_meshCheckMesh_cold_3()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 791, "e->Org != NULL");
}

void __gl_meshCheckMesh_cold_4()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 792, "e->Dst != NULL");
}

void __gl_meshCheckMesh_cold_5()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 794, "e->Onext->Sym->Lnext == e");
}

void __gl_meshCheckMesh_cold_6()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 793, "e->Lnext->Onext->Sym == e");
}

void __gl_meshCheckMesh_cold_7()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 790, "e->Sym->Sym == e");
}

void __gl_meshCheckMesh_cold_8()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 788, "e->Sym->next == ePrev->Sym");
}

void __gl_meshCheckMesh_cold_9()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 782, "v->prev == vPrev && v->anEdge == NULL && v->data == NULL");
}

void __gl_meshCheckMesh_cold_10()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 774, "e->Sym != e");
}

void __gl_meshCheckMesh_cold_11()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 778, "e->Org == v");
}

void __gl_meshCheckMesh_cold_12()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 777, "e->Onext->Sym->Lnext == e");
}

void __gl_meshCheckMesh_cold_13()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 776, "e->Lnext->Onext->Sym == e");
}

void __gl_meshCheckMesh_cold_14()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 775, "e->Sym->Sym == e");
}

void __gl_meshCheckMesh_cold_15()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 771, "v->prev == vPrev");
}

void __gl_meshCheckMesh_cold_16()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 765, "f->prev == fPrev && f->anEdge == NULL && f->data == NULL");
}

void __gl_meshCheckMesh_cold_17()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 757, "e->Sym != e");
}

void __gl_meshCheckMesh_cold_18()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 761, "e->Lface == f");
}

void __gl_meshCheckMesh_cold_19()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 760, "e->Onext->Sym->Lnext == e");
}

void __gl_meshCheckMesh_cold_20()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 759, "e->Lnext->Onext->Sym == e");
}

void __gl_meshCheckMesh_cold_21()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 758, "e->Sym->Sym == e");
}

void __gl_meshCheckMesh_cold_22()
{
  __assert_rtn("__gl_meshCheckMesh", "mesh.c", 754, "f->prev == fPrev");
}

void **__gl_pqHeapNewPriorityQ(void *a1)
{
  uint64_t v2 = (void **)malloc_type_malloc(0x38uLL, 0x10A0040AA9CE83FuLL);
  uint64_t v3 = v2;
  if (v2)
  {
    *((_OWORD *)v2 + 1) = xmmword_1B8377960;
    uint64_t v4 = malloc_type_malloc(0x108uLL, 0x100004000313F17uLL);
    *uint64_t v3 = v4;
    if (v4)
    {
      uint64_t v5 = malloc_type_malloc(0x210uLL, 0x1080040FC6463CFuLL);
      v3[1] = v5;
      if (v5)
      {
        *((_DWORD *)v3 + 10) = 0;
        v3[4] = 0;
        v3[6] = a1;
        *((void *)*v3 + 1) = 1;
        *((void *)v5 + 2) = 0;
        return v3;
      }
      free(*v3);
    }
    free(v3);
    return 0;
  }
  return v3;
}

void __gl_pqHeapDeletePriorityQ(void **a1)
{
  free(a1[1]);
  free(*a1);

  free(a1);
}

uint64_t *FloatDown(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = *(void *)(*result + 8 * a2);
  uint64_t v5 = result[2];
  uint64_t v6 = result[3];
  uint64_t v7 = v3 + 16 * v4;
  while (1)
  {
    uint64_t v8 = 2 * a2;
    if (2 * a2 < v5)
    {
      uint64_t v9 = *(void *)(v3 + 16 * *(void *)(v2 + 8 * (v8 | 1)));
      double v10 = *(double *)(v9 + 56);
      uint64_t v11 = *(void *)(v3 + 16 * *(void *)(v2 + 16 * a2));
      double v12 = *(double *)(v11 + 56);
      if (v10 < v12 || v10 == v12 && *(double *)(v9 + 64) <= *(double *)(v11 + 64)) {
        v8 |= 1uLL;
      }
    }
    if (v8 > v6) {
      FloatDown_cold_1();
    }
    if (v8 > v5) {
      break;
    }
    uint64_t v13 = *(void *)(v2 + 8 * v8);
    double v14 = *(double *)(*(void *)v7 + 56);
    uint64_t v15 = *(void *)(v3 + 16 * v13);
    double v16 = *(double *)(v15 + 56);
    if (v14 < v16 || v14 == v16 && *(double *)(*(void *)v7 + 64) <= *(double *)(v15 + 64)) {
      break;
    }
    *(void *)(v2 + 8 * a2) = v13;
    *(void *)(v3 + 16 * v13 + 8) = a2;
    a2 = v8;
  }
  *(void *)(v2 + 8 * a2) = v4;
  *(void *)(v3 + 16 * v4 + 8) = a2;
  return result;
}

uint64_t __gl_pqHeapInsert(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 16) + 1;
  *(void *)(a1 + 16) = v5;
  if (v4 >= 2 * v5) {
    goto LABEL_4;
  }
  uint64_t v6 = *(void **)a1;
  uint64_t v7 = *(void *)(a1 + 8);
  *(void *)(a1 + 24) = 2 * v4;
  uint64_t v8 = malloc_type_realloc(v6, (16 * v4) | 8, 0x6EA5B48uLL);
  *(void *)a1 = v8;
  if (!v8)
  {
    *(void *)a1 = v6;
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  uint64_t v9 = malloc_type_realloc(*(void **)(a1 + 8), 16 * *(void *)(a1 + 24) + 16, 0xCE5AD38BuLL);
  *(void *)(a1 + 8) = v9;
  if (!v9)
  {
    *(void *)(a1 + 8) = v7;
    return 0x7FFFFFFFFFFFFFFFLL;
  }
LABEL_4:
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 8);
  uint64_t v12 = v5;
  if (v10)
  {
    *(void *)(a1 + 32) = *(void *)(v11 + 16 * v10 + 8);
    uint64_t v12 = v10;
  }
  *(void *)(*(void *)a1 + 8 * v5) = v12;
  uint64_t v13 = (void *)(v11 + 16 * v12);
  *uint64_t v13 = a2;
  v13[1] = v5;
  if (*(_DWORD *)(a1 + 40)) {
    FloatUp((uint64_t *)a1, v5);
  }
  if (v12 == 0x7FFFFFFFFFFFFFFFLL) {
    __gl_pqHeapInsert_cold_1();
  }
  return v12;
}

uint64_t *FloatUp(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = *(void *)(*result + 8 * a2);
  if ((unint64_t)a2 >= 2)
  {
    uint64_t v6 = *(void *)(v3 + 16 * v4);
    double v7 = *(double *)(v6 + 56);
    while (1)
    {
      uint64_t v5 = a2 >> 1;
      uint64_t v8 = *(void *)(v2 + 8 * (a2 >> 1));
      uint64_t v9 = *(void *)(v3 + 16 * v8);
      double v10 = *(double *)(v9 + 56);
      if (v10 < v7 || v10 == v7 && *(double *)(v9 + 64) <= *(double *)(v6 + 64)) {
        break;
      }
      *(void *)(v2 + 8 * a2) = v8;
      *(void *)(v3 + 16 * v8 + 8) = a2;
      BOOL v11 = (unint64_t)a2 >= 4;
      a2 >>= 1;
      if (!v11) {
        goto LABEL_3;
      }
    }
  }
  uint64_t v5 = a2;
LABEL_3:
  *(void *)(v2 + 8 * v5) = v4;
  *(void *)(v3 + 16 * v4 + 8) = v5;
  return result;
}

uint64_t __gl_pqHeapExtractMin(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v3 = *(void *)(*a1 + 8);
  uint64_t v4 = (uint64_t *)(v2 + 16 * v3);
  uint64_t v5 = *v4;
  uint64_t v6 = a1[2];
  if (v6 >= 1)
  {
    uint64_t v7 = *(void *)(v1 + 8 * v6);
    *(void *)(v1 + 8) = v7;
    *(void *)(v2 + 16 * v7 + 8) = 1;
    uint64_t v8 = a1[4];
    *uint64_t v4 = 0;
    v4[1] = v8;
    a1[4] = v3;
    a1[2] = v6 - 1;
    if (v6 != 1) {
      FloatDown(a1, 1);
    }
  }
  return v5;
}

uint64_t *__gl_pqHeapDelete(uint64_t *result, uint64_t a2)
{
  if (a2 < 1 || (uint64_t v3 = result, result[3] < a2) || (v4 = result[1], v5 = (void *)(v4 + 16 * a2), !*v5)) {
    __gl_pqHeapDelete_cold_1();
  }
  uint64_t v6 = v5[1];
  uint64_t v7 = *result;
  uint64_t v8 = result[2];
  uint64_t v9 = *(void *)(*result + 8 * v8);
  *(void *)(*result + 8 * v6) = v9;
  *(void *)(v4 + 16 * v9 + 8) = v6;
  result[2] = v8 - 1;
  if (v6 < v8)
  {
    if (v6 < 2
      || (uint64_t v10 = *(void *)(v4 + 16 * *(void *)(v7 + ((4 * v6) & 0xFFFFFFFFFFFFFFF8))),
          double v11 = *(double *)(v10 + 56),
          uint64_t v12 = *(void *)(v4 + 16 * v9),
          double v13 = *(double *)(v12 + 56),
          v11 < v13)
      || v11 == v13 && *(double *)(v10 + 64) <= *(double *)(v12 + 64))
    {
      double result = FloatDown(result, v6);
    }
    else
    {
      double result = FloatUp(result, v6);
    }
  }
  void *v5 = 0;
  v5[1] = v3[4];
  v3[4] = a2;
  return result;
}

char *__gl_pqSortNewPriorityQ(void *a1)
{
  uint64_t v2 = (char *)malloc_type_malloc(0x38uLL, 0x10A004025C1D612uLL);
  if (v2)
  {
    uint64_t v3 = __gl_pqHeapNewPriorityQ(a1);
    *(void *)uint64_t v2 = v3;
    if (v3)
    {
      uint64_t v4 = malloc_type_malloc(0x100uLL, 0x80040B8603338uLL);
      *((void *)v2 + 1) = v4;
      if (v4)
      {
        *(_OWORD *)(v2 + 24) = xmmword_1B8377960;
        *((_DWORD *)v2 + 10) = 0;
        *((void *)v2 + 6) = a1;
        return v2;
      }
      __gl_pqHeapDeletePriorityQ(*(void ***)v2);
    }
    free(v2);
    return 0;
  }
  return v2;
}

void __gl_pqSortDeletePriorityQ(void ***a1)
{
  if (!a1) {
    __gl_pqSortDeletePriorityQ_cold_1();
  }
  uint64_t v2 = *a1;
  if (v2) {
    __gl_pqHeapDeletePriorityQ(v2);
  }
  uint64_t v3 = a1[2];
  if (v3) {
    free(v3);
  }
  uint64_t v4 = a1[1];
  if (v4) {
    free(v4);
  }

  free(a1);
}

uint64_t __gl_pqSortInit(uint64_t *a1)
{
  v53[98] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = malloc_type_malloc(8 * a1[3] + 8, 0x54C8DA60uLL);
  a1[2] = (uint64_t)v2;
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1[3];
  unint64_t v4 = (unint64_t)&v2[v3 - 1];
  if ((unint64_t)v2 <= v4)
  {
    uint64_t v5 = a1[1];
    uint64_t v6 = v2;
    do
    {
      *v6++ = v5;
      v5 += 8;
    }
    while ((unint64_t)v6 <= v4);
  }
  uint64_t v7 = v53;
  v52[0] = v2;
  v52[1] = &v2[v3 - 1];
  unint64_t v8 = 2016473283;
  uint64_t v9 = (void **)v52;
  do
  {
    uint64_t v10 = *v9;
    unint64_t v11 = *(v7 - 1);
    uint64_t v7 = v9;
    if (v11 > (unint64_t)(*v9 + 10))
    {
      do
      {
        unint64_t v8 = 1539415821 * v8 + 1;
        unint64_t v12 = v8 % (((uint64_t)(v11 - (void)v10) >> 3) + 1);
        double v13 = (uint64_t *)v10[v12];
        v10[v12] = *v10;
        *uint64_t v10 = v13;
        double v14 = (char *)(v10 - 1);
        uint64_t v15 = (void *)(v11 + 8);
        do
        {
          uint64_t v16 = *v13;
          double v17 = *(double *)(*v13 + 56);
          uint64_t v18 = v14 + 8;
          uint64_t v19 = (uint64_t *)*((void *)v14 + 1);
          uint64_t v20 = *v19;
          double v21 = *(double *)(*v19 + 56);
          if (v21 >= v17)
          {
            v14 += 8;
            while (1)
            {
              uint64_t v18 = v14;
              if (v21 == v17 && *(double *)(v20 + 64) <= *(double *)(v16 + 64)) {
                break;
              }
              v14 += 8;
              uint64_t v19 = (uint64_t *)*((void *)v18 + 1);
              uint64_t v20 = *v19;
              double v21 = *(double *)(*v19 + 56);
              uint64_t v22 = v18;
              if (v21 < v17) {
                goto LABEL_17;
              }
            }
            uint64_t v22 = v14 - 8;
          }
          else
          {
            uint64_t v22 = v14;
          }
          double v14 = v18;
LABEL_17:
          uint64_t v24 = v15 - 1;
          uint64_t v23 = (uint64_t *)*(v15 - 1);
          uint64_t v25 = *v23;
          double v26 = *(double *)(*v23 + 56);
          if (v17 >= v26)
          {
            --v15;
            while (1)
            {
              uint64_t v24 = v15;
              if (v17 == v26 && *(double *)(v16 + 64) <= *(double *)(v25 + 64)) {
                break;
              }
              --v15;
              uint64_t v23 = (uint64_t *)*(v24 - 1);
              uint64_t v25 = *v23;
              double v26 = *(double *)(*v23 + 56);
              uint64_t v27 = v24;
              if (v17 < v26) {
                goto LABEL_26;
              }
            }
            uint64_t v27 = v15 + 1;
          }
          else
          {
            uint64_t v27 = v15;
          }
          uint64_t v15 = v24;
LABEL_26:
          *(void *)double v14 = v23;
          *uint64_t v15 = v19;
        }
        while (v14 < (char *)v15);
        uint64_t v28 = *(void *)v14;
        *(void *)double v14 = v19;
        *uint64_t v15 = v28;
        if (v14 - (char *)v10 >= (uint64_t)(v11 - (void)v15)) {
          uint64_t v29 = v10;
        }
        else {
          uint64_t v29 = v27;
        }
        if (v14 - (char *)v10 >= (uint64_t)(v11 - (void)v15)) {
          unint64_t v30 = (unint64_t)v22;
        }
        else {
          unint64_t v30 = v11;
        }
        if (v14 - (char *)v10 >= (uint64_t)(v11 - (void)v15)) {
          uint64_t v10 = v27;
        }
        else {
          unint64_t v11 = (unint64_t)v22;
        }
        *uint64_t v7 = v29;
        v7[1] = v30;
        v7 += 2;
      }
      while (v11 > (unint64_t)(v10 + 10));
    }
    for (i = v10 + 1; (unint64_t)i <= v11; ++i)
    {
      uint64_t v32 = *i;
      double v33 = i;
      if (i > v10)
      {
        uint64_t v34 = i;
        double v33 = i;
        while (1)
        {
          double v35 = *(double *)(*(void *)v32 + 56);
          uint64_t v37 = (uint64_t *)*--v33;
          uint64_t v36 = v37;
          uint64_t v38 = *v37;
          double v39 = *(double *)(*v37 + 56);
          if (v35 < v39 || v35 == v39 && *(double *)(*(void *)v32 + 64) <= *(double *)(v38 + 64)) {
            break;
          }
          *uint64_t v34 = v36;
          uint64_t v34 = v33;
          if (v33 <= v10) {
            goto LABEL_47;
          }
        }
        double v33 = v34;
      }
LABEL_47:
      *double v33 = v32;
    }
    uint64_t v9 = (void **)(v7 - 2);
  }
  while (v7 - 2 >= v52);
  a1[4] = v3;
  uint64_t v40 = 1;
  *((_DWORD *)a1 + 10) = 1;
  uint64_t v41 = *a1;
  uint64_t v42 = *(void *)(*a1 + 16);
  if (v42 >= 1)
  {
    do
      FloatDown((uint64_t *)v41, v42);
    while ((unint64_t)v42-- > 1);
  }
  *(_DWORD *)(v41 + 40) = 1;
  unint64_t v44 = a1[2];
  unint64_t v45 = v44 + 8 * a1[3] - 8;
  if (v44 < v45)
  {
    uint64_t v46 = **(void **)v44;
    double v47 = *(double *)(v46 + 56);
    do
    {
      double v48 = v47;
      double v49 = *(uint64_t **)(v44 + 8);
      v44 += 8;
      uint64_t v50 = *v49;
      double v47 = *(double *)(*v49 + 56);
      if (v47 >= v48 && (v47 != v48 || *(double *)(v50 + 64) > *(double *)(v46 + 64))) {
        __gl_pqSortInit_cold_1();
      }
      uint64_t v46 = v50;
    }
    while (v44 < v45);
    return 1;
  }
  return v40;
}

uint64_t __gl_pqSortInsert(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a1 + 40))
  {
    uint64_t v7 = *(void *)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    *(void *)(a1 + 24) = v7 + 1;
    unint64_t v8 = *(void **)(a1 + 8);
    if (v7 + 1 >= v6)
    {
      *(void *)(a1 + 32) = 2 * v6;
      uint64_t v9 = malloc_type_realloc(v8, 16 * v6, 0xA18345C8uLL);
      *(void *)(a1 + 8) = v9;
      if (!v9)
      {
        *(void *)(a1 + 8) = v8;
        return 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      uint64_t v9 = *(void **)(a1 + 8);
    }
    v9[v7] = a2;
    return ~v7;
  }
  uint64_t v4 = *(void *)a1;

  return __gl_pqHeapInsert(v4, a2);
}

uint64_t __gl_pqSortExtractMin(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    return __gl_pqHeapExtractMin(*(uint64_t **)a1);
  }
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = **(void **)(v2 + 8 * v1 - 8);
  if (*(void *)(*(void *)a1 + 16))
  {
    uint64_t v4 = *(void *)(*(void *)(*(void *)a1 + 8) + 16 * *(void *)(**(void **)a1 + 8));
    double v5 = *(double *)(v4 + 56);
    double v6 = *(double *)(v3 + 56);
    if (v5 < v6 || v5 == v6 && *(double *)(v4 + 64) <= *(double *)(v3 + 64)) {
      return __gl_pqHeapExtractMin(*(uint64_t **)a1);
    }
  }
  if (v1 >= 1) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 24);
  }
  uint64_t v8 = v7 - 1;
  uint64_t v9 = v2 - 16;
  while (v1 >= 2)
  {
    uint64_t v10 = v1 - 1;
    if (**(void **)(v9 + 8 * v1--)) {
      goto LABEL_16;
    }
  }
  uint64_t v10 = v8;
LABEL_16:
  *(void *)(a1 + 24) = v10;
  return v3;
}

uint64_t __gl_pqSortMinimum(void *a1)
{
  uint64_t v1 = a1[3];
  if (!v1) {
    return *(void *)(*(void *)(*a1 + 8) + 16 * *(void *)(*(void *)*a1 + 8));
  }
  uint64_t v2 = **(void **)(a1[2] + 8 * v1 - 8);
  if (!*(void *)(*a1 + 16)) {
    return v2;
  }
  uint64_t result = *(void *)(*(void *)(*a1 + 8) + 16 * *(void *)(*(void *)*a1 + 8));
  double v4 = *(double *)(result + 56);
  double v5 = *(double *)(v2 + 56);
  if (v4 >= v5 && (v4 != v5 || *(double *)(result + 64) > *(double *)(v2 + 64))) {
    return v2;
  }
  return result;
}

uint64_t *__gl_pqSortDelete(uint64_t *result, uint64_t a2)
{
  if (a2 < 0)
  {
    uint64_t v3 = ~a2;
    if (result[4] <= ~a2 || (uint64_t v4 = result[1], !*(void *)(v4 + 8 * v3))) {
      __gl_pqSortDelete_cold_1();
    }
    *(void *)(v4 + 8 * v3) = 0;
    uint64_t v5 = result[3];
    BOOL v7 = __OFSUB__(v5, 1);
    BOOL v6 = v5 - 1 < 0;
    uint64_t v8 = v5 - 1;
    if (v6 == v7)
    {
      uint64_t v9 = result[2];
      do
      {
        if (**(void **)(v9 + 8 * v8)) {
          break;
        }
        result[3] = v8;
        unint64_t v10 = v8-- + 1;
      }
      while (v10 > 1);
    }
  }
  else
  {
    uint64_t v2 = (uint64_t *)*result;
    return __gl_pqHeapDelete(v2, a2);
  }
  return result;
}

void FloatDown_cold_1()
{
  __assert_rtn("FloatDown", "priorityq-heap.c", 110, "child <= pq->max");
}

void __gl_pqHeapInsert_cold_1()
{
  __assert_rtn("__gl_pqHeapInsert", "priorityq-heap.c", 205, "free != LONG_MAX");
}

void __gl_pqHeapDelete_cold_1()
{
  __assert_rtn("__gl_pqHeapDelete", "priorityq-heap.c", 239, "hCurr >= 1 && hCurr <= pq->max && h[hCurr].key != NULL");
}

void __gl_pqSortDeletePriorityQ_cold_1()
{
  __assert_rtn("__gl_pqSortDeletePriorityQ", "priorityq.c", 80, "pq != NULL");
}

void __gl_pqSortInit_cold_1()
{
}

void __gl_pqSortDelete_cold_1()
{
  __assert_rtn("__gl_pqSortDelete", "priorityq.c", 257, "curr < pq->max && pq->keys[curr] != NULL");
}

double __gl_projectPolygon(uint64_t a1)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(double **)(a1 + 16);
  double v2 = *(double *)(a1 + 32);
  double v3 = *(double *)(a1 + 40);
  double v54 = v2;
  double v55 = v3;
  double v4 = *(double *)(a1 + 48);
  double v56 = v4;
  BOOL v5 = v2 == 0.0;
  if (v3 != 0.0) {
    BOOL v5 = 0;
  }
  BOOL v6 = v4 == 0.0 && v5;
  BOOL v7 = *(double **)v1;
  if (v6)
  {
    memset(v58, 0, sizeof(v58));
    memset(v57, 0, sizeof(v57));
    double v63 = -2.0e150;
    int64x2_t v62 = vdupq_n_s64(0xDF238D352E5096AFLL);
    double v61 = 2.0e150;
    int64x2_t v60 = vdupq_n_s64(0x5F238D352E5096AFuLL);
    if (v7 == v1)
    {
      double v11 = -4.0e150;
      double v12 = -4.0e150;
      double v13 = -4.0e150;
    }
    else
    {
      uint64_t v8 = v7;
      do
      {
        for (uint64_t i = 0; i != 3; ++i)
        {
          double v10 = v8[i + 4];
          if (v10 < *(double *)&v60.i64[i])
          {
            *(double *)&v60.i64[i] = v10;
            v57[i] = v8;
          }
          if (v10 > *(double *)&v62.i64[i])
          {
            *(double *)&v62.i64[i] = v10;
            v58[i] = v8;
          }
        }
        uint64_t v8 = *(double **)v8;
      }
      while (v8 != v1);
      double v11 = *(double *)&v62.i64[1] - *(double *)&v60.i64[1];
      double v12 = *(double *)v62.i64 - *(double *)v60.i64;
      double v13 = v63 - v61;
    }
    uint64_t v14 = 2;
    if (v13 <= *(double *)((unint64_t)&v62 | (8 * (v11 > v12)))
              - *(double *)((unint64_t)&v60 & 0xFFFFFFFFFFFFFFF7 | (8 * (v11 > v12))))
      uint64_t v14 = v11 > v12;
    if (*(double *)&v60.i64[v14] >= *(double *)&v62.i64[v14])
    {
      uint64_t v37 = &v56;
      double v54 = 0.0;
      double v55 = 0.0;
LABEL_43:
      *uint64_t v37 = 1.0;
      double v2 = v54;
      double v3 = v55;
      double v4 = v56;
      goto LABEL_44;
    }
    uint64_t v15 = (double *)v57[v14];
    uint64_t v16 = (double *)v58[v14];
    if (v15) {
      BOOL v17 = v16 == 0;
    }
    else {
      BOOL v17 = 1;
    }
    if (!v17)
    {
      double v18 = v16[4];
      double v19 = v16[5];
      double v20 = v15[4] - v18;
      double v21 = v15[5] - v19;
      v59[0] = v20;
      v59[1] = v21;
      double v22 = v16[6];
      double v23 = v15[6] - v22;
      if (v7 == v1) {
        goto LABEL_31;
      }
      double v24 = 0.0;
      uint64_t v25 = v7;
      do
      {
        double v26 = v25[4] - v18;
        double v27 = v25[5] - v19;
        double v28 = v25[6] - v22;
        double v29 = v21 * v28 - v23 * v27;
        double v30 = v23 * v26 - v20 * v28;
        double v31 = v20 * v27 - v21 * v26;
        if (v31 * v31 + v29 * v29 + v30 * v30 > v24)
        {
          double v4 = v31;
          double v3 = v30;
          double v2 = v29;
          double v24 = v31 * v31 + v29 * v29 + v30 * v30;
        }
        uint64_t v25 = *(double **)v25;
      }
      while (v25 != v1);
      double v54 = v2;
      double v55 = v3;
      double v56 = v4;
      if (v24 <= 0.0)
      {
LABEL_31:
        double v32 = -v21;
        if (v21 >= 0.0) {
          double v32 = v21;
        }
        double v33 = -v20;
        if (v20 >= 0.0) {
          double v33 = v20;
        }
        uint64_t v34 = v32 > v33;
        double v35 = -v23;
        if (v23 >= 0.0) {
          double v35 = v23;
        }
        double v54 = 0.0;
        double v55 = 0.0;
        double v56 = 0.0;
        double v36 = v59[v34];
        if (v36 < 0.0) {
          double v36 = -v36;
        }
        if (v35 > v36) {
          uint64_t v34 = 2;
        }
        uint64_t v37 = &v54 + v34;
        goto LABEL_43;
      }
    }
  }
LABEL_44:
  uint64_t v38 = a1 + 56;
  if (v3 < 0.0) {
    double v3 = -v3;
  }
  if (v2 < 0.0) {
    double v2 = -v2;
  }
  unsigned int v39 = v3 > v2;
  if (v4 < 0.0) {
    double v4 = -v4;
  }
  double v40 = *(&v54 + (v3 > v2));
  if (v40 < 0.0) {
    double v40 = -v40;
  }
  if (v4 > v40) {
    unsigned int v39 = 2;
  }
  *(void *)(v38 + 8 * v39) = 0;
  if (v39 == 2) {
    signed int v41 = 0;
  }
  else {
    signed int v41 = v39 + 1;
  }
  *(void *)(v38 + 8 * v41) = 0x3FF0000000000000;
  unsigned int v42 = (v39 + 2) % 3;
  *(void *)(v38 + 8 * v42) = 0;
  uint64_t v43 = a1 + 80;
  *(void *)(a1 + 80 + 8 * v39) = 0;
  BOOL v44 = *(&v54 + v39) <= 0.0;
  double v45 = -0.0;
  if (*(&v54 + v39) <= 0.0) {
    double v45 = 0.0;
  }
  *(double *)(v43 + 8 * v41) = v45;
  double result = -1.0;
  if (!v44) {
    double result = 1.0;
  }
  *(double *)(v43 + 8 * v42) = result;
  if (v7 != v1)
  {
    double v47 = v7;
    do
    {
      double v48 = v47[4];
      double v49 = v47[5];
      double v50 = v47[6];
      v47[7] = v48 * *(double *)(a1 + 56) + v49 * *(double *)(a1 + 64) + v50 * *(double *)(a1 + 72);
      double result = v48 * *(double *)(a1 + 80) + v49 * *(double *)(a1 + 88) + v50 * *(double *)(a1 + 96);
      v47[8] = result;
      double v47 = *(double **)v47;
    }
    while (v47 != v1);
  }
  if (v6)
  {
    double v51 = (double *)*((void *)v1 + 10);
    if (v51 != v1 + 10)
    {
      double result = 0.0;
      do
      {
        uint64_t v52 = *((void *)v51 + 2);
        if (*(int *)(v52 + 56) >= 1)
        {
          uint64_t v53 = (void *)*((void *)v51 + 2);
          do
          {
            double result = result
                   + (*(double *)(v53[4] + 56) - *(double *)(*(void *)(v53[1] + 32) + 56))
                   * (*(double *)(v53[4] + 64) + *(double *)(*(void *)(v53[1] + 32) + 64));
            uint64_t v53 = (void *)v53[3];
          }
          while (v53 != (void *)v52);
        }
        double v51 = *(double **)v51;
      }
      while (v51 != v1 + 10);
      if (result < 0.0)
      {
        while (v7 != v1)
        {
          v7[8] = -v7[8];
          BOOL v7 = *(double **)v7;
        }
        *(float64x2_t *)(a1 + 80) = vnegq_f64(*(float64x2_t *)(a1 + 80));
        double result = -*(double *)(a1 + 96);
        *(double *)(a1 + 96) = result;
      }
    }
  }
  return result;
}

GLUtesselator *gluNewTess(void)
{
  if (!TXParagraphStyleFolder_Factory::version((TXParagraphStyleFolder_Factory *)0x80)) {
    return 0;
  }
  double result = (GLUtesselator *)malloc_type_malloc(0xE50uLL, 0x10A004023E6F836uLL);
  if (result)
  {
    *(_DWORD *)double result = 0;
    *((void *)result + 13) = 0;
    *((void *)result + 5) = 0;
    *((void *)result + 6) = 0;
    *((_DWORD *)result + 28) = 100130;
    *((_WORD *)result + 76) = 0;
    *((void *)result + 21) = noBegin;
    *((void *)result + 22) = noEdgeFlag;
    *((void *)result + 23) = noVertex;
    *((void *)result + 24) = noEnd;
    *((void *)result + 3) = noError;
    *((void *)result + 4) = 0;
    *((void *)result + 18) = noCombine;
    *((void *)result + 25) = noMesh;
    *((void *)result + 427) = __gl_noBeginData;
    *((void *)result + 428) = __gl_noEdgeFlagData;
    *((void *)result + 429) = __gl_noVertexData;
    *((void *)result + 430) = __gl_noEndData;
    *((void *)result + 431) = __gl_noErrorData;
    *((void *)result + 432) = __gl_noCombineData;
    *((void *)result + 457) = 0;
  }
  return result;
}

void gluDeleteTess(GLUtesselator *tess)
{
  if (*(_DWORD *)tess) {
    GotoState((uint64_t)tess, 0);
  }

  free(tess);
}

void GotoState(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != a2)
  {
    BOOL v5 = (void *)(a1 + 8);
    do
    {
      if (v2 >= a2)
      {
        if (v2 == 1)
        {
          uint64_t v9 = *(uint64_t (**)())(a1 + 3448);
          if (v9 == __gl_noErrorData) {
            (*(void (**)(uint64_t))(a1 + 24))(100153);
          }
          else {
            ((void (*)(uint64_t, void))v9)(100153, *(void *)(a1 + 3656));
          }
          double v10 = *(void ***)(a1 + 16);
          if (v10) {
            __gl_meshDeleteMesh(v10);
          }
          unsigned int v2 = 0;
          *(_DWORD *)a1 = 0;
          void *v5 = 0;
          v5[1] = 0;
        }
        else if (v2 == 2)
        {
          BOOL v7 = *(uint64_t (**)())(a1 + 3448);
          if (v7 == __gl_noErrorData) {
            (*(void (**)(uint64_t))(a1 + 24))(100154);
          }
          else {
            ((void (*)(uint64_t, void))v7)(100154, *(void *)(a1 + 3656));
          }
          if (*(_DWORD *)a1 != 2) {
            GotoState(a1, 2);
          }
          unsigned int v2 = 1;
          *(_DWORD *)a1 = 1;
        }
      }
      else if (v2 == 1)
      {
        uint64_t v8 = *(uint64_t (**)())(a1 + 3448);
        if (v8 == __gl_noErrorData) {
          (*(void (**)(uint64_t))(a1 + 24))(100152);
        }
        else {
          ((void (*)(uint64_t, void))v8)(100152, *(void *)(a1 + 3656));
        }
        gluTessBeginContour((GLUtesselator *)a1);
        unsigned int v2 = *(_DWORD *)a1;
      }
      else if (!v2)
      {
        BOOL v6 = *(uint64_t (**)())(a1 + 3448);
        if (v6 == __gl_noErrorData) {
          (*(void (**)(uint64_t))(a1 + 24))(100151);
        }
        else {
          ((void (*)(uint64_t, void))v6)(100151, *(void *)(a1 + 3656));
        }
        if (*(_DWORD *)a1) {
          GotoState(a1, 0);
        }
        unsigned int v2 = 1;
        *(_DWORD *)a1 = 1;
        *(_DWORD *)(a1 + 212) = 0;
        *(unsigned char *)(a1 + 208) = 0;
        *(void *)(a1 + 16) = 0;
        *(void *)(a1 + 3656) = 0;
      }
    }
    while (v2 != a2);
  }
}

void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble data)
{
  switch(which)
  {
    case 0x1872Cu:
      unsigned int v3 = data;
      if ((double)data != data)
      {
LABEL_8:
        double v4 = (uint64_t (*)())*((void *)tess + 431);
        if (v4 == __gl_noErrorData) {
          (*((void (**)(uint64_t))tess + 3))(100901);
        }
        else {
          ((void (*)(uint64_t, void))v4)(100901, *((void *)tess + 457));
        }
        return;
      }
      if (v3 - 100130 <= 4)
      {
        *((_DWORD *)tess + 28) = v3;
        return;
      }
LABEL_15:
      *((unsigned char *)tess + 153) = data != 0.0;
      return;
    case 0x1872Du:
      goto LABEL_15;
    case 0x1872Eu:
      if (data >= 0.0 && data <= 1.0)
      {
        *((GLdouble *)tess + 13) = data;
        return;
      }
      goto LABEL_8;
  }
  BOOL v5 = (uint64_t (*)())*((void *)tess + 431);
  if (v5 == __gl_noErrorData) {
    (*((void (**)(uint64_t, GLdouble))tess + 3))(100900, data);
  }
  else {
    ((void (*)(uint64_t, void, double))v5)(100900, *((void *)tess + 457), data);
  }
}

void gluTessCallback(GLUtesselator *tess, GLenum which, GLvoid (*CallBackFunc)(void))
{
  switch(which)
  {
    case 0x18704u:
      if (CallBackFunc) {
        unsigned int v3 = CallBackFunc;
      }
      else {
        unsigned int v3 = (GLvoid (*)(void))noBegin;
      }
      *((void *)tess + 21) = v3;
      break;
    case 0x18705u:
      if (CallBackFunc) {
        BOOL v5 = CallBackFunc;
      }
      else {
        BOOL v5 = (GLvoid (*)(void))noVertex;
      }
      *((void *)tess + 23) = v5;
      break;
    case 0x18706u:
      if (CallBackFunc) {
        BOOL v6 = CallBackFunc;
      }
      else {
        BOOL v6 = (GLvoid (*)(void))noEnd;
      }
      *((void *)tess + 24) = v6;
      break;
    case 0x18707u:
      if (CallBackFunc) {
        BOOL v7 = CallBackFunc;
      }
      else {
        BOOL v7 = (GLvoid (*)(void))noError;
      }
      *((void *)tess + 3) = v7;
      break;
    case 0x18708u:
      BOOL v8 = CallBackFunc == 0;
      if (CallBackFunc) {
        uint64_t v9 = CallBackFunc;
      }
      else {
        uint64_t v9 = (GLvoid (*)(void))noEdgeFlag;
      }
      *((void *)tess + 22) = v9;
      goto LABEL_48;
    case 0x18709u:
      if (CallBackFunc) {
        double v10 = CallBackFunc;
      }
      else {
        double v10 = (GLvoid (*)(void))noCombine;
      }
      *((void *)tess + 18) = v10;
      break;
    case 0x1870Au:
      if (CallBackFunc) {
        double v11 = CallBackFunc;
      }
      else {
        double v11 = (GLvoid (*)(void))__gl_noBeginData;
      }
      *((void *)tess + 427) = v11;
      break;
    case 0x1870Bu:
      if (CallBackFunc) {
        double v12 = CallBackFunc;
      }
      else {
        double v12 = (GLvoid (*)(void))__gl_noVertexData;
      }
      *((void *)tess + 429) = v12;
      break;
    case 0x1870Cu:
      if (CallBackFunc) {
        double v13 = CallBackFunc;
      }
      else {
        double v13 = (GLvoid (*)(void))__gl_noEndData;
      }
      *((void *)tess + 430) = v13;
      break;
    case 0x1870Du:
      if (CallBackFunc) {
        uint64_t v14 = CallBackFunc;
      }
      else {
        uint64_t v14 = (GLvoid (*)(void))__gl_noErrorData;
      }
      *((void *)tess + 431) = v14;
      break;
    case 0x1870Eu:
      BOOL v8 = CallBackFunc == 0;
      if (CallBackFunc) {
        uint64_t v15 = CallBackFunc;
      }
      else {
        uint64_t v15 = (GLvoid (*)(void))__gl_noEdgeFlagData;
      }
      *((void *)tess + 428) = v15;
LABEL_48:
      char v16 = !v8;
      *((unsigned char *)tess + 152) = v16;
      break;
    case 0x1870Fu:
      if (CallBackFunc) {
        BOOL v17 = CallBackFunc;
      }
      else {
        BOOL v17 = (GLvoid (*)(void))__gl_noCombineData;
      }
      *((void *)tess + 432) = v17;
      break;
    case 0x18710u:
      if (CallBackFunc) {
        double v18 = CallBackFunc;
      }
      else {
        double v18 = (GLvoid (*)(void))noMesh;
      }
      *((void *)tess + 25) = v18;
      break;
    default:
      double v4 = (uint64_t (*)())*((void *)tess + 431);
      if (v4 == __gl_noErrorData) {
        (*((void (**)(uint64_t))tess + 3))(100900);
      }
      else {
        ((void (*)(uint64_t, void))v4)(100900, *((void *)tess + 457));
      }
      break;
  }
}

void gluTessVertex(GLUtesselator *tess, GLdouble *location, GLvoid *data)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)tess != 2) {
    GotoState((uint64_t)tess, 2u);
  }
  if (*((unsigned char *)tess + 208))
  {
    EmptyCache((uint64_t)tess);
    if (!v8) {
      goto LABEL_28;
    }
    *((void *)tess + 1) = 0;
  }
  uint64_t v9 = 0;
  int v10 = 0;
  v3.n128_u64[0] = 0xDF138D352E5096AFLL;
  v4.n128_u64[0] = 0x5F138D352E5096AFLL;
  do
  {
    double v11 = location[v9];
    if (v11 >= -1.0e150) {
      double v12 = location[v9];
    }
    else {
      double v12 = -1.0e150;
    }
    if (v12 <= 1.0e150)
    {
      BOOL v13 = v11 < -1.0e150;
    }
    else
    {
      double v12 = 1.0e150;
      BOOL v13 = 1;
    }
    if (v13) {
      int v10 = 1;
    }
    *(double *)((char *)&v21 + v9 * 8) = v12;
    ++v9;
  }
  while (v9 != 3);
  if (v10)
  {
    uint64_t v14 = (uint64_t (*)())*((void *)tess + 431);
    if (v14 == __gl_noErrorData) {
      (*((void (**)(uint64_t, __n128, __n128))tess + 3))(100155, v3, v4);
    }
    else {
      ((void (*)(uint64_t, void, __n128, __n128))v14)(100155, *((void *)tess + 457), v3, v4);
    }
  }
  if (*((void *)tess + 2)) {
    goto LABEL_37;
  }
  uint64_t v15 = *((int *)tess + 53);
  if ((int)v15 <= 99)
  {
    char v16 = (char *)tess + 32 * v15;
    *((void *)v16 + 30) = data;
    *(_OWORD *)(v16 + 216) = v21;
    *((void *)v16 + 29) = v22;
    *((_DWORD *)tess + 53) = v15 + 1;
    return;
  }
  EmptyCache((uint64_t)tess);
  if (v17)
  {
LABEL_37:
    if (AddVertex((uint64_t)tess, &v21, (uint64_t)data)) {
      return;
    }
  }
LABEL_28:
  double v18 = (uint64_t (*)())*((void *)tess + 431);
  if (v18 == __gl_noErrorData)
  {
    double v20 = (void (*)(uint64_t))*((void *)tess + 3);
    v20(100902);
  }
  else
  {
    uint64_t v19 = *((void *)tess + 457);
    ((void (*)(uint64_t, uint64_t))v18)(100902, v19);
  }
}

void EmptyCache(uint64_t a1)
{
  __gl_meshNewMesh();
  *(void *)(a1 + 16) = v2;
  if (v2)
  {
    uint64_t v3 = *(int *)(a1 + 212);
    if ((int)v3 < 1)
    {
LABEL_6:
      *(_DWORD *)(a1 + 212) = 0;
      *(unsigned char *)(a1 + 208) = 0;
    }
    else
    {
      __n128 v4 = (void *)(a1 + 216);
      unint64_t v5 = a1 + 216 + 32 * v3;
      while (AddVertex(a1, v4, v4[3]))
      {
        v4 += 4;
        if ((unint64_t)v4 >= v5) {
          goto LABEL_6;
        }
      }
    }
  }
}

uint64_t AddVertex(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint64_t result = (uint64_t)__gl_meshSplitEdge(*(void *)(a1 + 8));
    if (!result) {
      return result;
    }
    uint64_t v8 = *(void *)(v6 + 24);
    goto LABEL_6;
  }
  uint64_t result = (uint64_t)__gl_meshMakeEdge(*(void *)(a1 + 16));
  if (result)
  {
    uint64_t v8 = result;
    uint64_t result = __gl_meshSplice((void *)result, *(void **)(result + 8));
    if (result)
    {
LABEL_6:
      uint64_t v9 = *(void **)(v8 + 32);
      v9[3] = a3;
      v9[4] = *a2;
      v9[5] = a2[1];
      v9[6] = a2[2];
      uint64_t result = 1;
      *(_DWORD *)(v8 + 56) = 1;
      *(_DWORD *)(*(void *)(v8 + 8) + 56) = -1;
      *(void *)(a1 + 8) = v8;
    }
  }
  return result;
}

void gluTessBeginPolygon(GLUtesselator *tess, GLvoid *data)
{
  if (*(_DWORD *)tess) {
    GotoState((uint64_t)tess, 0);
  }
  *(_DWORD *)tess = 1;
  *((_DWORD *)tess + 53) = 0;
  *((unsigned char *)tess + 208) = 0;
  *((void *)tess + 2) = 0;
  *((void *)tess + 457) = data;
}

void gluTessBeginContour(GLUtesselator *tess)
{
  if (*(_DWORD *)tess != 1) {
    GotoState(tess, 1);
  }
  *(_DWORD *)tess = 2;
  *((void *)tess + 1) = 0;
  if (*((int *)tess + 53) >= 1) {
    *((unsigned char *)tess + 208) = 1;
  }
}

void gluTessEndContour(GLUtesselator *tess)
{
  if (*(_DWORD *)tess != 2) {
    GotoState((uint64_t)tess, 2u);
  }
  *(_DWORD *)tess = 1;
}

void gluTessEndPolygon(GLUtesselator *tess)
{
  uint64_t v2 = (int *)((char *)tess + 3464);
  if (!setjmp((int *)tess + 866))
  {
    if (*(_DWORD *)tess != 1) {
      GotoState((uint64_t)tess, 1u);
    }
    *(_DWORD *)tess = 0;
    if (*((void *)tess + 2)) {
      goto LABEL_37;
    }
    if (!*((unsigned char *)tess + 152)
      && *((uint64_t (**)())tess + 25) == noMesh
      && __gl_renderCache((uint64_t)tess))
    {
      goto LABEL_31;
    }
    EmptyCache((uint64_t)tess);
    if (v4)
    {
LABEL_37:
      __gl_projectPolygon((uint64_t)tess);
      if (__gl_computeInterior((uint64_t)tess))
      {
        unint64_t v5 = (void **)*((void *)tess + 2);
        if (*((unsigned char *)tess + 116)) {
          goto LABEL_12;
        }
        if (*((unsigned char *)tess + 153)) {
          int v6 = __gl_meshSetWindingNumber(*((void *)tess + 2), 1, 1);
        }
        else {
          int v6 = __gl_meshTessellateInterior(*((void *)tess + 2));
        }
        if (v6)
        {
          __gl_meshCheckMesh(v5);
          if (*((uint64_t (**)())tess + 21) != noBegin
            || *((uint64_t (**)())tess + 24) != noEnd
            || *((uint64_t (**)())tess + 23) != noVertex
            || *((uint64_t (**)())tess + 22) != noEdgeFlag
            || *((uint64_t (**)())tess + 427) != __gl_noBeginData
            || *((uint64_t (**)())tess + 430) != __gl_noEndData
            || *((uint64_t (**)())tess + 429) != __gl_noVertexData
            || *((uint64_t (**)())tess + 428) != __gl_noEdgeFlagData)
          {
            if (*((unsigned char *)tess + 153)) {
              __gl_renderBoundary((uint64_t)tess, (uint64_t)v5);
            }
            else {
              __gl_renderMesh((uint64_t)tess, (uint64_t)v5);
            }
          }
          if (*((uint64_t (**)())tess + 25) != noMesh)
          {
            __gl_meshDiscardExterior((uint64_t)v5);
            (*((void (**)(void **))tess + 25))(v5);
            *((void *)tess + 2) = 0;
LABEL_31:
            *((void *)tess + 457) = 0;
            return;
          }
LABEL_12:
          __gl_meshDeleteMesh(v5);
          *((void *)tess + 457) = 0;
          *((void *)tess + 2) = 0;
          return;
        }
      }
    }
    longjmp(v2, 1);
  }
  uint64_t v3 = (uint64_t (*)())*((void *)tess + 431);
  if (v3 == __gl_noErrorData) {
    (*((void (**)(uint64_t))tess + 3))(100902);
  }
  else {
    ((void (*)(uint64_t, void))v3)(100902, *((void *)tess + 457));
  }
}

uint64_t __gl_renderMesh(uint64_t result, uint64_t a2)
{
  *(void *)(result + 160) = 0;
  uint64_t v2 = (uint64_t *)(a2 + 80);
  uint64_t v3 = *(uint64_t **)(a2 + 80);
  if (v3 != (uint64_t *)(a2 + 80))
  {
    uint64_t v4 = result;
    unint64_t v5 = *(uint64_t **)(a2 + 80);
    do
    {
      *((unsigned char *)v5 + 40) = 0;
      unint64_t v5 = (uint64_t *)*v5;
    }
    while (v5 != v2);
    if (v3 != v2)
    {
      do
      {
        if (*((unsigned char *)v3 + 41) && !*((unsigned char *)v3 + 40))
        {
          int v6 = (void *)v3[2];
          if (*(unsigned char *)(v4 + 152))
          {
            uint64_t result = RenderTriangle(v4, (uint64_t)v6, 1);
          }
          else
          {
            MaximumFan(v3[2], (uint64_t)&v24);
            if (v24 <= 1) {
              uint64_t v7 = 1;
            }
            else {
              uint64_t v7 = v24;
            }
            if (v24 <= 1) {
              uint64_t v8 = v6;
            }
            else {
              uint64_t v8 = v25;
            }
            if (v24 <= 1) {
              uint64_t v9 = RenderTriangle;
            }
            else {
              uint64_t v9 = v26;
            }
            MaximumFan(v6[3], (uint64_t)&v24);
            if (v24 > v7)
            {
              uint64_t v7 = v24;
              uint64_t v8 = v25;
              uint64_t v9 = v26;
            }
            MaximumFan(*(void *)(v6[2] + 8), (uint64_t)&v24);
            if (v24 > v7)
            {
              uint64_t v7 = v24;
              uint64_t v8 = v25;
              uint64_t v9 = v26;
            }
            MaximumStrip(v6, (uint64_t)&v24);
            if (v24 <= v7)
            {
              int v10 = v9;
            }
            else
            {
              uint64_t v7 = v24;
              uint64_t v8 = v25;
              int v10 = v26;
            }
            MaximumStrip((void *)v6[3], (uint64_t)&v24);
            BOOL v11 = v24 <= v7;
            if (v24 <= v7)
            {
              double v12 = v8;
            }
            else
            {
              uint64_t v7 = v24;
              double v12 = v25;
            }
            if (v11) {
              BOOL v13 = v10;
            }
            else {
              BOOL v13 = v26;
            }
            MaximumStrip(*(void **)(v6[2] + 8), (uint64_t)&v24);
            if (v24 <= v7) {
              uint64_t result = v13(v4, (uint64_t)v12, v7);
            }
            else {
              uint64_t result = v26(v4, (uint64_t)v25, v24);
            }
          }
          if (!*((unsigned char *)v3 + 40)) {
            __gl_renderMesh_cold_1();
          }
        }
        uint64_t v3 = (uint64_t *)*v3;
      }
      while (v3 != v2);
      uint64_t v14 = *(void *)(v4 + 160);
      if (v14)
      {
        uint64_t v15 = *(uint64_t (**)())(v4 + 3416);
        if (v15 == __gl_noBeginData) {
          (*(void (**)(uint64_t))(v4 + 168))(4);
        }
        else {
          ((void (*)(uint64_t, void))v15)(4, *(void *)(v4 + 3656));
        }
        int v16 = -1;
        do
        {
          int v17 = *(void **)(v14 + 16);
          do
          {
            if (*(unsigned char *)(v4 + 152))
            {
              int v18 = *(unsigned __int8 *)(*(void *)(v17[1] + 40) + 41);
              int v19 = *(unsigned char *)(*(void *)(v17[1] + 40) + 41) == 0;
              if (v16 != v19)
              {
                double v20 = *(uint64_t (**)())(v4 + 3424);
                if (v20 == __gl_noEdgeFlagData) {
                  (*(void (**)(BOOL))(v4 + 176))(v18 == 0);
                }
                else {
                  ((void (*)(BOOL, void))v20)(v18 == 0, *(void *)(v4 + 3656));
                }
                int v16 = v19;
              }
            }
            long long v21 = *(uint64_t (**)())(v4 + 3432);
            if (v21 == __gl_noVertexData) {
              uint64_t v22 = (*(uint64_t (**)(void))(v4 + 184))(*(void *)(v17[4] + 24));
            }
            else {
              uint64_t v22 = ((uint64_t (*)(void, void))v21)(*(void *)(v17[4] + 24), *(void *)(v4 + 3656));
            }
            int v17 = (void *)v17[3];
          }
          while (v17 != *(void **)(v14 + 16));
          uint64_t v14 = *(void *)(v14 + 32);
        }
        while (v14);
        uint64_t v23 = *(uint64_t (**)())(v4 + 3440);
        if (v23 == __gl_noEndData) {
          uint64_t result = (*(uint64_t (**)(uint64_t))(v4 + 192))(v22);
        }
        else {
          uint64_t result = ((uint64_t (*)(void))v23)(*(void *)(v4 + 3656));
        }
        *(void *)(v4 + 160) = 0;
      }
    }
  }
  return result;
}

uint64_t __gl_renderBoundary(uint64_t result, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)(a2 + 80);
  uint64_t v3 = *(uint64_t **)(a2 + 80);
  if (v3 != (uint64_t *)(a2 + 80))
  {
    uint64_t v4 = result;
    do
    {
      if (*((unsigned char *)v3 + 41))
      {
        unint64_t v5 = *(uint64_t (**)())(v4 + 3416);
        if (v5 == __gl_noBeginData) {
          (*(void (**)(uint64_t))(v4 + 168))(2);
        }
        else {
          ((void (*)(uint64_t, void))v5)(2, *(void *)(v4 + 3656));
        }
        uint64_t v6 = v3[2];
        do
        {
          uint64_t v7 = *(uint64_t (**)())(v4 + 3432);
          if (v7 == __gl_noVertexData) {
            uint64_t v8 = (*(uint64_t (**)(void))(v4 + 184))(*(void *)(*(void *)(v6 + 32) + 24));
          }
          else {
            uint64_t v8 = ((uint64_t (*)(void, void))v7)(*(void *)(*(void *)(v6 + 32) + 24), *(void *)(v4 + 3656));
          }
          uint64_t v6 = *(void *)(v6 + 24);
        }
        while (v6 != v3[2]);
        uint64_t v9 = *(uint64_t (**)())(v4 + 3440);
        if (v9 == __gl_noEndData) {
          uint64_t result = (*(uint64_t (**)(uint64_t))(v4 + 192))(v8);
        }
        else {
          uint64_t result = ((uint64_t (*)(void))v9)(*(void *)(v4 + 3656));
        }
      }
      uint64_t v3 = (uint64_t *)*v3;
    }
    while (v3 != v2);
  }
  return result;
}

uint64_t __gl_renderCache(uint64_t a1)
{
  v23[3] = *(double *)MEMORY[0x1E4F143B8];
  uint64_t v1 = *(int *)(a1 + 212);
  if ((int)v1 >= 3)
  {
    double v3 = *(double *)(a1 + 40);
    v23[0] = *(double *)(a1 + 32);
    v23[1] = v3;
    double v4 = *(double *)(a1 + 48);
    v23[2] = v4;
    if (v23[0] == 0.0 && v3 == 0.0 && v4 == 0.0) {
      ComputeNormal(a1, v23, 0);
    }
    int v5 = ComputeNormal(a1, v23, 1);
    if (v5 == 2) {
      return 0;
    }
    int v6 = v5;
    if (v5)
    {
      int v7 = *(_DWORD *)(a1 + 112);
      if (v7 != 100134)
      {
        if (v7 != 100133)
        {
          if (v7 == 100132 && v5 < 0) {
            return 1;
          }
LABEL_15:
          uint64_t v9 = *(uint64_t (**)())(a1 + 3416);
          if (v9 == __gl_noBeginData)
          {
            if (v1 >= 4) {
              unsigned int v12 = 6;
            }
            else {
              unsigned int v12 = 4;
            }
            if (*(unsigned char *)(a1 + 153)) {
              uint64_t v13 = 2;
            }
            else {
              uint64_t v13 = v12;
            }
            (*(void (**)(uint64_t))(a1 + 168))(v13);
          }
          else
          {
            if (v1 >= 4) {
              unsigned int v10 = 6;
            }
            else {
              unsigned int v10 = 4;
            }
            if (*(unsigned char *)(a1 + 153)) {
              uint64_t v11 = 2;
            }
            else {
              uint64_t v11 = v10;
            }
            ((void (*)(uint64_t, void))v9)(v11, *(void *)(a1 + 3656));
          }
          unint64_t v14 = a1 + 216;
          uint64_t v15 = *(uint64_t (**)())(a1 + 3432);
          if (v15 == __gl_noVertexData) {
            uint64_t v16 = (*(uint64_t (**)(void))(a1 + 184))(*(void *)(a1 + 240));
          }
          else {
            uint64_t v16 = ((uint64_t (*)(void, void))v15)(*(void *)(a1 + 240), *(void *)(a1 + 3656));
          }
          unint64_t v17 = v14 + 32 * v1;
          if (v6 <= 0)
          {
            for (unint64_t i = v17 - 32; i > v14; i -= 32)
            {
              long long v21 = *(uint64_t (**)())(a1 + 3432);
              if (v21 == __gl_noVertexData) {
                uint64_t v16 = (*(uint64_t (**)(void))(a1 + 184))(*(void *)(i + 24));
              }
              else {
                uint64_t v16 = ((uint64_t (*)(void, void))v21)(*(void *)(i + 24), *(void *)(a1 + 3656));
              }
            }
          }
          else
          {
            for (unint64_t j = a1 + 248; j < v17; j += 32)
            {
              int v19 = *(uint64_t (**)())(a1 + 3432);
              if (v19 == __gl_noVertexData) {
                uint64_t v16 = (*(uint64_t (**)(void))(a1 + 184))(*(void *)(j + 24));
              }
              else {
                uint64_t v16 = ((uint64_t (*)(void, void))v19)(*(void *)(j + 24), *(void *)(a1 + 3656));
              }
            }
          }
          uint64_t v22 = *(uint64_t (**)())(a1 + 3440);
          if (v22 == __gl_noEndData) {
            (*(void (**)(uint64_t))(a1 + 192))(v16);
          }
          else {
            ((void (*)(void))v22)(*(void *)(a1 + 3656));
          }
          return 1;
        }
        if (v5 <= 0) {
          goto LABEL_15;
        }
      }
    }
  }
  return 1;
}

uint64_t ComputeNormal(uint64_t a1, double *a2, int a3)
{
  unint64_t v3 = a1 + 32 * *(int *)(a1 + 212) + 216;
  if (!a3)
  {
    *a2 = 0.0;
    a2[1] = 0.0;
    a2[2] = 0.0;
  }
  double v4 = (double *)(a1 + 280);
  if (a1 + 280 < v3)
  {
    uint64_t v5 = 0;
    double v6 = *(double *)(a1 + 264) - *(double *)(a1 + 232);
    double v7 = *(double *)(a1 + 256) - *(double *)(a1 + 224);
    double v8 = *(double *)(a1 + 248) - *(double *)(a1 + 216);
    double v9 = *a2;
    double v10 = a2[1];
    double v11 = a2[2];
    while (1)
    {
      double v12 = v7;
      double v13 = v6;
      double v7 = v4[1] - *(double *)(a1 + 224);
      double v6 = v4[2] - *(double *)(a1 + 232);
      double v14 = v8 * v6;
      double v15 = v8 * v7;
      double v8 = *v4 - *(double *)(a1 + 216);
      double v16 = v12 * v6 - v13 * v7;
      double v17 = v13 * v8 - v14;
      double v18 = v15 - v12 * v8;
      double v19 = v18 * v11 + v9 * v16 + v10 * v17;
      if (a3)
      {
        if (v19 != 0.0)
        {
          if (v19 <= 0.0)
          {
            if ((int)v5 > 0) {
              return 2;
            }
            uint64_t v5 = 0xFFFFFFFFLL;
          }
          else
          {
            if ((v5 & 0x80000000) != 0) {
              return 2;
            }
            uint64_t v5 = 1;
          }
        }
      }
      else
      {
        if (v19 < 0.0)
        {
          double v9 = v9 - v16;
          double v10 = v10 - v17;
          *a2 = v9;
          a2[1] = v10;
          double v11 = v11 - v18;
        }
        else
        {
          double v9 = v9 + v16;
          double v10 = v10 + v17;
          *a2 = v9;
          a2[1] = v10;
          double v11 = v18 + v11;
        }
        a2[2] = v11;
      }
      v4 += 4;
      if ((unint64_t)v4 >= v3) {
        return v5;
      }
    }
  }
  return 0;
}

uint64_t RenderTriangle(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3 != 1) {
    RenderTriangle_cold_1();
  }
  uint64_t v3 = *(void *)(a2 + 40);
  *(void *)(v3 + 32) = *(void *)(result + 160);
  *(void *)(result + 160) = v3;
  *(unsigned char *)(v3 + 40) = 1;
  return result;
}

uint64_t MaximumFan@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_1F10FAB40;
  *(void *)(a2 + 16) = off_1F10FAB50;
  uint64_t v2 = *(void *)(result + 40);
  if (*(unsigned char *)(v2 + 41))
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = result;
    while (1)
    {
      uint64_t v6 = v2;
      if (*(unsigned char *)(v2 + 40)) {
        break;
      }
      *(void *)(v2 + 32) = v3;
      *(unsigned char *)(v2 + 40) = 1;
      *(void *)a2 = ++v4;
      uint64_t v5 = *(void *)(v5 + 16);
      uint64_t v2 = *(void *)(v5 + 40);
      uint64_t v3 = v6;
      if (!*(unsigned char *)(v2 + 41)) {
        goto LABEL_8;
      }
    }
    uint64_t v6 = v3;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v6 = 0;
  }
LABEL_8:
  uint64_t v7 = *(void *)(result + 8);
  uint64_t v8 = *(void *)(v7 + 40);
  if (*(unsigned char *)(v8 + 41) && !*(unsigned char *)(v8 + 40))
  {
    while (1)
    {
      uint64_t v9 = v8;
      *(void *)(v8 + 32) = v6;
      *(unsigned char *)(v8 + 40) = 1;
      uint64_t result = *(void *)(v7 + 24);
      uint64_t v7 = *(void *)(result + 8);
      uint64_t v8 = *(void *)(v7 + 40);
      if (!*(unsigned char *)(v8 + 41)) {
        break;
      }
      ++v4;
      uint64_t v6 = v9;
      if (*(unsigned char *)(v8 + 40))
      {
        *(void *)a2 = v4;
        goto LABEL_11;
      }
    }
    *(void *)a2 = v4 + 1;
    *(void *)(a2 + 8) = result;
    goto LABEL_12;
  }
  uint64_t v9 = v6;
LABEL_11:
  for (*(void *)(a2 + 8) = result; v9; uint64_t v9 = *(void *)(v9 + 32))
LABEL_12:
    *(unsigned char *)(v9 + 40) = 0;
  return result;
}

void *MaximumStrip@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_1F10FAB58;
  *(void *)(a2 + 16) = off_1F10FAB68;
  uint64_t v2 = result[5];
  if (*(unsigned char *)(v2 + 41))
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = result;
    while (!*(unsigned char *)(v2 + 40))
    {
      *(void *)(v2 + 32) = v3;
      *(unsigned char *)(v2 + 40) = 1;
      uint64_t v5 = *(void **)(v5[3] + 8);
      uint64_t v3 = v5[5];
      if (!*(unsigned char *)(v3 + 41) || *(unsigned char *)(v3 + 40))
      {
        ++v4;
        uint64_t v3 = v2;
        break;
      }
      *(void *)(v3 + 32) = v2;
      *(unsigned char *)(v3 + 40) = 1;
      v4 += 2;
      uint64_t v5 = (void *)v5[2];
      uint64_t v2 = v5[5];
      if (!*(unsigned char *)(v2 + 41)) {
        break;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v3 = 0;
    uint64_t v5 = result;
  }
  uint64_t v6 = result[1];
  uint64_t v7 = *(void *)(v6 + 40);
  if (*(unsigned char *)(v7 + 41) && !*(unsigned char *)(v7 + 40))
  {
    uint64_t v10 = 1;
    while (1)
    {
      uint64_t v8 = v10;
      *(void *)(v7 + 32) = v3;
      *(unsigned char *)(v7 + 40) = 1;
      uint64_t result = *(void **)(v6 + 24);
      uint64_t v11 = result[1];
      uint64_t v3 = *(void *)(v11 + 40);
      if (!*(unsigned char *)(v3 + 41) || *(unsigned char *)(v3 + 40)) {
        break;
      }
      *(void *)(v3 + 32) = v7;
      *(unsigned char *)(v3 + 40) = 1;
      uint64_t result = *(void **)(*(void *)(v11 + 16) + 8);
      uint64_t v6 = result[1];
      uint64_t v7 = *(void *)(v6 + 40);
      if (*(unsigned char *)(v7 + 41))
      {
        v10 += 2;
        if (!*(unsigned char *)(v7 + 40)) {
          continue;
        }
      }
      ++v8;
      goto LABEL_13;
    }
    uint64_t v3 = v7;
  }
  else
  {
    uint64_t v8 = 0;
  }
LABEL_13:
  *(void *)a2 = v8 + v4;
  if (v4)
  {
    if ((v8 & 1) == 0) {
      goto LABEL_18;
    }
    *(void *)a2 = v8 + v4 - 1;
    uint64_t v9 = result + 2;
  }
  else
  {
    uint64_t v9 = v5 + 1;
  }
  uint64_t result = (void *)*v9;
LABEL_18:
  for (*(void *)(a2 + 8) = result; v3; uint64_t v3 = *(void *)(v3 + 32))
    *(unsigned char *)(v3 + 40) = 0;
  return result;
}

uint64_t RenderFan(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *(uint64_t (**)())(a1 + 3416);
  if (v6 == __gl_noBeginData) {
    (*(void (**)(uint64_t))(a1 + 168))(6);
  }
  else {
    ((void (*)(uint64_t, void))v6)(6, *(void *)(a1 + 3656));
  }
  uint64_t v7 = *(uint64_t (**)())(a1 + 3432);
  if (v7 == __gl_noVertexData) {
    (*(void (**)(void))(a1 + 184))(*(void *)(a2[4] + 24));
  }
  else {
    ((void (*)(void, void))v7)(*(void *)(a2[4] + 24), *(void *)(a1 + 3656));
  }
  uint64_t v8 = *(uint64_t (**)())(a1 + 3432);
  if (v8 == __gl_noVertexData) {
    (*(void (**)(void))(a1 + 184))(*(void *)(*(void *)(a2[1] + 32) + 24));
  }
  else {
    ((void (*)(void, void))v8)(*(void *)(*(void *)(a2[1] + 32) + 24), *(void *)(a1 + 3656));
  }
  for (uint64_t i = a2[5]; *(unsigned char *)(i + 41); --a3)
  {
    if (*(unsigned char *)(i + 40)) {
      break;
    }
    *(unsigned char *)(i + 40) = 1;
    a2 = (void *)a2[2];
    uint64_t v10 = *(uint64_t (**)())(a1 + 3432);
    if (v10 == __gl_noVertexData) {
      (*(void (**)(void))(a1 + 184))(*(void *)(*(void *)(a2[1] + 32) + 24));
    }
    else {
      ((void (*)(void, void))v10)(*(void *)(*(void *)(a2[1] + 32) + 24), *(void *)(a1 + 3656));
    }
    uint64_t i = a2[5];
  }
  if (a3) {
    RenderFan_cold_1();
  }
  uint64_t v11 = *(uint64_t (**)())(a1 + 3440);
  if (v11 == __gl_noEndData)
  {
    double v14 = *(uint64_t (**)(void))(a1 + 192);
    return v14();
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 3656);
    return ((uint64_t (*)(uint64_t))v11)(v12);
  }
}

uint64_t RenderStrip(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *(uint64_t (**)())(a1 + 3416);
  if (v6 == __gl_noBeginData) {
    (*(void (**)(uint64_t))(a1 + 168))(5);
  }
  else {
    ((void (*)(uint64_t, void))v6)(5, *(void *)(a1 + 3656));
  }
  uint64_t v7 = *(uint64_t (**)())(a1 + 3432);
  if (v7 == __gl_noVertexData) {
    (*(void (**)(void))(a1 + 184))(*(void *)(a2[4] + 24));
  }
  else {
    ((void (*)(void, void))v7)(*(void *)(a2[4] + 24), *(void *)(a1 + 3656));
  }
  uint64_t v8 = *(uint64_t (**)())(a1 + 3432);
  if (v8 == __gl_noVertexData) {
    (*(void (**)(void))(a1 + 184))(*(void *)(*(void *)(a2[1] + 32) + 24));
  }
  else {
    ((void (*)(void, void))v8)(*(void *)(*(void *)(a2[1] + 32) + 24), *(void *)(a1 + 3656));
  }
  uint64_t v9 = a2[5];
  if (*(unsigned char *)(v9 + 41))
  {
    while (!*(unsigned char *)(v9 + 40))
    {
      *(unsigned char *)(v9 + 40) = 1;
      uint64_t v10 = *(void **)(a2[3] + 8);
      uint64_t v11 = *(uint64_t (**)())(a1 + 3432);
      if (v11 == __gl_noVertexData) {
        (*(void (**)(void))(a1 + 184))(*(void *)(v10[4] + 24));
      }
      else {
        ((void (*)(void, void))v11)(*(void *)(v10[4] + 24), *(void *)(a1 + 3656));
      }
      uint64_t v12 = v10[5];
      if (!*(unsigned char *)(v12 + 41) || *(unsigned char *)(v12 + 40))
      {
        --a3;
        break;
      }
      *(unsigned char *)(v12 + 40) = 1;
      a2 = (void *)v10[2];
      double v13 = *(uint64_t (**)())(a1 + 3432);
      if (v13 == __gl_noVertexData) {
        (*(void (**)(void))(a1 + 184))(*(void *)(*(void *)(a2[1] + 32) + 24));
      }
      else {
        ((void (*)(void, void))v13)(*(void *)(*(void *)(a2[1] + 32) + 24), *(void *)(a1 + 3656));
      }
      uint64_t v9 = a2[5];
      a3 -= 2;
      if (!*(unsigned char *)(v9 + 41)) {
        break;
      }
    }
  }
  if (a3) {
    RenderStrip_cold_1();
  }
  double v14 = *(uint64_t (**)())(a1 + 3440);
  if (v14 == __gl_noEndData)
  {
    double v17 = *(uint64_t (**)(void))(a1 + 192);
    return v17();
  }
  else
  {
    uint64_t v15 = *(void *)(a1 + 3656);
    return ((uint64_t (*)(uint64_t))v14)(v15);
  }
}

void __gl_renderMesh_cold_1()
{
}

void RenderTriangle_cold_1()
{
  __assert_rtn("RenderTriangle", "render.c", 241, "size == 1");
}

void RenderFan_cold_1()
{
  __assert_rtn("RenderFan", "render.c", 298, "size == 0");
}

void RenderStrip_cold_1()
{
  __assert_rtn("RenderStrip", "render.c", 326, "size == 0");
}

ProGL::Private *PGLInit(ProGL::Private *result)
{
  {
    inited = (ProGL::Private *)ProGL::Private::initContextSharing(result);
    ProGL::Private::initShareGroup(inited);
    ProGL::Private::initContext(v2);
    ProGL::Private::initPerThreadContext(v3);
    ProGL::Private::initContextInfo(v4);
  }
  return result;
}

void PGLCleanup(ProGL::Private *a1)
{
  {
    uint64_t v1 = (ProGL::Private *)ProGL::Private::cleanUpLazyTexture(a1);
    uint64_t v2 = (ProGL::Private *)ProGL::Private::cleanUpTexturePool(v1);
    uint64_t v3 = (ProGL::Private *)ProGL::Private::cleanUpTextureHandle(v2);
    uint64_t v4 = (ProGL::Private *)ProGL::Private::cleanUpProgram(v3);
    uint64_t v6 = ProGL::Private::cleanUpDeleteObjects(v4, v5);
    uint64_t v7 = (ProGL::Private *)ProGL::Private::cleanUpAuxiliaryContexts((ProGL::Private *)v6);
    uint64_t v8 = (ProGL::Private *)ProGL::Private::cleanUpContextInfo(v7);
    uint64_t v9 = (OZChannelBase *)ProGL::Private::cleanUpPerThreadContext(v8);
    uint64_t v11 = (ProGL::Private *)OZChannelBase::setRangeName(v9, v10);
    uint64_t v12 = (ProGL::Private *)ProGL::Private::cleanUpShareGroup(v11);
    ProGL::Private::cleanUpContextSharing(v12);
  }
}

ProGL::Init *ProGL::Init::Init(ProGL::Init *this)
{
  return this;
}

void ProGL::Init::~Init(ProGL::Init *this)
{
}

BOOL ProGL::SharedPerThreadAuxiliaryMap::Key::operator<(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 < *(void *)a2) {
    return 1;
  }
  if (*(void *)a1 > *(void *)a2) {
    return 0;
  }
  uint64_t v4 = (void *)(a1 + 8);
  uint64_t v5 = (void *)(a2 + 8);
  if (ProGL::operator<((void *)(a1 + 8), (void *)(a2 + 8))) {
    return 1;
  }
  return !ProGL::operator>(v4, v5) && *(_DWORD *)(a1 + 16) < *(_DWORD *)(a2 + 16);
}

void ProGL::SharedPerThreadAuxiliaryMap::SharedPerThreadAuxiliaryMap(ProGL::SharedPerThreadAuxiliaryMap *this)
{
  *(_DWORD *)this = 0;
  operator new();
}

void sub_1B795932C(_Unwind_Exception *a1)
{
  PCSpinLock::~PCSpinLock(v1);
  _Unwind_Resume(a1);
}

void ProGL::SharedPerThreadAuxiliaryMap::get(ProGL::SharedPerThreadAuxiliaryMap *this@<X0>, os_unfair_lock_s **a2@<X1>, int a3@<W2>, ProGL::ContextHandle *a4@<X8>)
{
  if (this) {
    PCSpinLock::unlock((os_unfair_lock_t)this);
  }
}

void sub_1B79593AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void ProGL::Private::AuxiliaryContextMap<ProGL::SharedPerThreadAuxiliaryMap::Key>::get(uint64_t *a1@<X0>, os_unfair_lock_s **a2@<X1>, int a3@<W2>, ProGL::ContextHandle *a4@<X8>)
{
  pthread_t v11 = pthread_self();
  ProGL::ContextHandle::getShareGroup(a2, &v12);
  int v13 = a3;
  char v10 = 0;
  PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::findValue((void *)*a1, (uint64_t)&v11, &v10, a4);
  if (!v10)
  {
    ProGL::makeEAGLContext(a2, v8, v9);
    ProGL::ContextHandle::operator=(a4, v9);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v9);
    ProGL::ContextHandle::setVirtualScreen(a4);
    PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::addValue(*a1, (uint64_t)&v11, (uint64_t *)a4, 0);
  }
}

void sub_1B7959478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  ProGL::ContextHandle::~ContextHandle(v9);
  _Unwind_Resume(a1);
}

void ProGL::Private::initAuxiliaryContexts(ProGL::Private *this)
{
}

void sub_1B7959558(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1020C40D5A9D86FLL);
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::cleanUpAuxiliaryContexts(ProGL::Private *this)
{
  {
    uint64_t result = MEMORY[0x1BA9BFBA0](v2, 0x20C4093837F09);
  }
  {
    PCSpinLock::~PCSpinLock(v3);
    uint64_t result = MEMORY[0x1BA9BFBA0]();
  }
  return result;
}

uint64_t *PCCache<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::~PCCache(uint64_t *a1)
{
  uint64_t v2 = *a1 + 32;
  std::__tree<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedAuxiliaryMap::Key,std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>>>::destroy(*a1 + 24, *(void **)v2);
  *(void *)(v2 - 8) = v2;
  *(void *)uint64_t v2 = 0;
  *(void *)(v2 + 8) = 0;
  *(void *)(v2 + 24) = *(void *)(v2 + 16);
  *(void *)(v2 + 48) = 0;
  std::unique_ptr<PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>>::reset[abi:ne180100](a1, 0);
  return a1;
}

void std::__tree<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedAuxiliaryMap::Key,std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedAuxiliaryMap::Key,std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedAuxiliaryMap::Key,std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>>>::destroy(a1, a2[1]);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(a2 + 6));
    operator delete(a2);
  }
}

uint64_t std::unique_ptr<PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::~PCCacheImpl(result);
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

uint64_t PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::~PCCacheImpl(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  std::__tree<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedAuxiliaryMap::Key,std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedAuxiliaryMap::Key>>::Data>>>::destroy(a1 + 24, *(void **)(a1 + 32));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t *PCCache<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::~PCCache(uint64_t *a1)
{
  uint64_t v2 = *a1 + 32;
  std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::destroy(*a1 + 24, *(void **)v2);
  *(void *)(v2 - 8) = v2;
  *(void *)uint64_t v2 = 0;
  *(void *)(v2 + 8) = 0;
  *(void *)(v2 + 24) = *(void *)(v2 + 16);
  *(void *)(v2 + 48) = 0;
  std::unique_ptr<PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>>::reset[abi:ne180100](a1, 0);
  return a1;
}

void std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::destroy(a1, a2[1]);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(a2 + 7));
    operator delete(a2);
  }
}

uint64_t std::unique_ptr<PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::~PCCacheImpl(result);
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

uint64_t PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::~PCCacheImpl(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::destroy(a1 + 24, *(void **)(a1 + 32));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void *PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::findValue@<X0>(void *a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X2>, void *a4@<X8>)
{
  uint64_t result = std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::find<ProGL::SharedPerThreadAuxiliaryMap::Key>((uint64_t)(a1 + 3), a2);
  char v10 = result;
  if (a1 + 4 == result)
  {
    *a3 = 0;
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    uint64_t v8 = result[8];
    *a4 = result[7];
    a4[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = a1[9] + 1;
    a1[9] = v9;
    result[10] = v9;
    uint64_t result = PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::bubble(a1 + 6, (uint64_t)&v10);
    *a3 = 1;
  }
  return result;
}

void sub_1B7959940(_Unwind_Exception *a1)
{
  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

void *std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::find<ProGL::SharedPerThreadAuxiliaryMap::Key>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = (void *)(a1 + 8);
  do
  {
    BOOL v6 = ProGL::SharedPerThreadAuxiliaryMap::Key::operator<((uint64_t)(v3 + 4), a2);
    uint64_t v7 = v3 + 1;
    if (!v6)
    {
      uint64_t v7 = v3;
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2 || ProGL::SharedPerThreadAuxiliaryMap::Key::operator<(a2, (uint64_t)(v5 + 4))) {
    return v2;
  }
  return v5;
}

void PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::addValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  if (*(void *)(a1 + 88) >= a4 || *(void *)(a1 + 104))
  {
    uint64_t v8 = std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::find<ProGL::SharedPerThreadAuxiliaryMap::Key>(a1 + 24, a2);
    double v27 = v8;
    if ((void *)(a1 + 32) == v8)
    {
      uint64_t v9 = *(void *)(a1 + 72) + 1;
      *(void *)(a1 + 72) = v9;
      uint64_t v10 = a3[1];
      uint64_t v23 = *a3;
      uint64_t v24 = v10;
      if (v10) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
      }
      *(void *)&long long v25 = a4;
      *((void *)&v25 + 1) = v9;
      uint64_t v26 = 0;
      double v16 = *(uint64_t **)a2;
      ProGL::ShareGroup::ShareGroup(&v17, (void *)(a2 + 8));
      int v18 = *(_DWORD *)(a2 + 16);
      v19[0] = v23;
      v19[1] = v24;
      if (v24) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
      }
      long long v20 = v25;
      uint64_t v21 = v26;
      v22[0] = (uint64_t)std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::__emplace_unique_key_args<ProGL::SharedPerThreadAuxiliaryMap::Key,std::pair<ProGL::SharedPerThreadAuxiliaryMap::Key const,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>((uint64_t **)(a1 + 24), (uint64_t)&v16, (uint64_t)&v16);
      v22[1] = v11;
      ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v19);
      PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::add((void **)(a1 + 48), v22);
      unint64_t v12 = *(void *)(a1 + 80) + a4;
      *(void *)(a1 + 80) = v12;
      if (!*(void *)(a1 + 104))
      {
        while (v12 > *(void *)(a1 + 88) || *(void *)(a1 + 40) > *(void *)(a1 + 96))
        {
          uint64_t v15 = *(uint64_t ***)(a1 + 48);
          if (v15 == *(uint64_t ***)(a1 + 56)) {
            break;
          }
          double v16 = *v15;
          PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::remove((uint64_t *)(a1 + 48), (uint64_t)&v16);
          int v13 = v16;
          double v14 = (ProGL::ContextHandle *)(v16 + 7);
          *(void *)(a1 + 80) -= v16[9];
          std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v13);
          ProGL::ContextHandle::~ContextHandle(v14);
          operator delete(v13);
          unint64_t v12 = *(void *)(a1 + 80);
        }
      }
      ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v23);
    }
    else
    {
      ProGL::ContextHandle::operator=(v8 + 7, a3);
      PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::update(a1, (uint64_t)&v27, a4);
    }
  }
}

void sub_1B7959BAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  _Unwind_Resume(a1);
}

void PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::update(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 72) + 1;
  *(void *)(a1 + 72) = v6;
  *(void *)(*(void *)a2 + 80) = v6;
  uint64_t v7 = (uint64_t *)(a1 + 48);
  PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::bubble((uint64_t *)(a1 + 48), a2);
  uint64_t v8 = *(void *)a2;
  uint64_t v9 = a3 - *(void *)(*(void *)a2 + 72);
  if (v9)
  {
    unint64_t v10 = v9 + *(void *)(a1 + 80);
    *(void *)(a1 + 80) = v10;
    *(void *)(v8 + 72) = a3;
    if (!*(void *)(a1 + 104))
    {
      while (v10 > *(void *)(a1 + 88) || *(void *)(a1 + 40) > *(void *)(a1 + 96))
      {
        unsigned __int8 v11 = *(uint64_t ***)(a1 + 48);
        if (v11 == *(uint64_t ***)(a1 + 56)) {
          break;
        }
        double v14 = *v11;
        PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,std::__tree_node<std::__value_type<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCacheImpl<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>,PCCFRef<vImageConverter *>,PCNoLock,std::less<std::tuple<PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat,PCCFRef<CGColorSpace *>,PCColorUtil::AlphaFormat>>>::Data>,void *> *,long>>>::remove(v7, (uint64_t)&v14);
        unint64_t v12 = v14;
        int v13 = (ProGL::ContextHandle *)(v14 + 7);
        *(void *)(a1 + 80) -= v14[9];
        std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v12);
        ProGL::ContextHandle::~ContextHandle(v13);
        operator delete(v12);
        unint64_t v10 = *(void *)(a1 + 80);
      }
    }
  }
}

uint64_t *std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::__emplace_unique_key_args<ProGL::SharedPerThreadAuxiliaryMap::Key,std::pair<ProGL::SharedPerThreadAuxiliaryMap::Key const,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t **)std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::__find_equal<ProGL::SharedPerThreadAuxiliaryMap::Key>((uint64_t)a1, &v10, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = v5;
    std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::__construct_node<std::pair<ProGL::SharedPerThreadAuxiliaryMap::Key const,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>((uint64_t)a1, a3, (uint64_t)v9);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v7, v9[0]);
    uint64_t v6 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,void *>>>>::reset[abi:ne180100]((uint64_t *)v9, 0);
  }
  return v6;
}

void *std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::__find_equal<ProGL::SharedPerThreadAuxiliaryMap::Key>(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = v4;
        uint64_t v8 = (uint64_t)(v4 + 4);
        if (!ProGL::SharedPerThreadAuxiliaryMap::Key::operator<(a3, (uint64_t)(v4 + 4))) {
          break;
        }
        uint64_t v4 = (void *)*v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!ProGL::SharedPerThreadAuxiliaryMap::Key::operator<(v8, a3)) {
        break;
      }
      uint64_t v5 = v7 + 1;
      uint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t std::__tree<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::__map_value_compare<ProGL::SharedPerThreadAuxiliaryMap::Key,std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>,true>,std::allocator<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>>::__construct_node<std::pair<ProGL::SharedPerThreadAuxiliaryMap::Key const,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x60uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = std::pair<ProGL::SharedPerThreadAuxiliaryMap::Key const,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>::pair[abi:ne180100]((uint64_t)v6 + 32, a2);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1B7959E58(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t std::pair<ProGL::SharedPerThreadAuxiliaryMap::Key const,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>::pair[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  ProGL::ShareGroup::ShareGroup((void *)(a1 + 8), (void *)(a2 + 8));
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::SharedPerThreadAuxiliaryMap::Key,PCCacheImpl<ProGL::SharedPerThreadAuxiliaryMap::Key,ProGL::ContextHandle,PCNoLock,std::less<ProGL::SharedPerThreadAuxiliaryMap::Key>>::Data>,void *>>>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16)) {
      ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(v2 + 56));
    }
    operator delete((void *)v2);
  }
}

void *ProGL::ShareGroup::findGroup@<X0>(void *this@<X0>, void *a2@<X8>)
{
  if (this) {
    this = (void *)[this sharegroup];
  }
  *a2 = this;
  return this;
}

void *ProGL::ShareGroup::ShareGroup(void *result, void *a2)
{
  void *result = *a2;
  return result;
}

uint64_t (*ProGL::ShareGroup::operator void (ProGL::ShareGroup::*)(void)(void *a1))(ProGL::ShareGroup *__hidden this)
{
  if (*a1) {
    return ProGL::ShareGroup::dummyFunc;
  }
  else {
    return 0;
  }
}

BOOL ProGL::operator==(void *a1, void *a2)
{
  return *a1 == *a2;
}

BOOL ProGL::operator<(void *a1, void *a2)
{
  if (*a2) {
    BOOL v2 = *a1 >= *a2;
  }
  else {
    BOOL v2 = 1;
  }
  return !v2;
}

BOOL ProGL::operator>(void *a1, void *a2)
{
  if (*a1) {
    BOOL v2 = *a2 >= *a1;
  }
  else {
    BOOL v2 = 1;
  }
  return !v2;
}

void ProGL::masterShareGroup(void *a1@<X8>)
{
  {
    BOOL v2 = (void *)PGLMasterEAGLContext();
    if (v2) {
      uint64_t v3 = [v2 sharegroup];
    }
    else {
      uint64_t v3 = 0;
    }
    if (v3) {
      uint64_t v4 = ProGL::ShareGroup::dummyFunc;
    }
    else {
      uint64_t v4 = 0;
    }
    if (!v4)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v8);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"ProGL::masterShareGroup(): ", 27);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"Master share group is 0 because there is no master CGLContextObj.\n", 66);
      std::stringbuf::str();
      if (v7 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      NSLog(&cfstr_S.isa, p_p);
      if (v7 < 0) {
        operator delete(__p);
      }
      v8[0] = *MEMORY[0x1E4FBA418];
      *(void *)((char *)v8 + *(void *)(v8[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
      v8[1] = MEMORY[0x1E4FBA470] + 16;
      if (v9 < 0) {
        operator delete((void *)v8[9]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x1BA9BFAB0](&v10);
    }
    operator new();
  }
}

void sub_1B795A1D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void ProGL::Private::initShareGroup(ProGL::Private *this)
{
  ProGL::masterShareGroup(&v1);
}

uint64_t ProGL::Private::cleanUpShareGroup(ProGL::Private *this)
{
  return result;
}

ProGL::GL_Wrap *ProGL::GL_Wrap::GL_Wrap(ProGL::GL_Wrap *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  ProGL::getCurrentContext(v3);
  ProGL::ContextHandle::operator=(this, v3);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v3);
  *((unsigned char *)this + 16) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 1;
  return this;
}

void sub_1B795A2C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  ProGL::ContextHandle::~ContextHandle(v9);
  _Unwind_Resume(a1);
}

ProGL::GL_Wrap *ProGL::GL_Wrap::GL_Wrap(ProGL::GL_Wrap *this, const ProGL::GL_Wrap *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  ProGL::ContextHandle::operator=(this, (uint64_t *)a2);
  *((unsigned char *)this + 16) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = *((unsigned char *)a2 + 32);
  return this;
}

void sub_1B795A328(_Unwind_Exception *a1)
{
  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

ProGL::GL_Wrap *ProGL::GL_Wrap::GL_Wrap(ProGL::GL_Wrap *this, const ProGL::ContextHandle *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  ProGL::ContextHandle::operator=(this, (uint64_t *)a2);
  *((unsigned char *)this + 16) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 1;
  return this;
}

void sub_1B795A378(_Unwind_Exception *a1)
{
  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

void ProGL::GL_Wrap::~GL_Wrap(ProGL::GL_Wrap *this)
{
  BOOL v2 = (ProGL::MatrixState *)*((void *)this + 3);
  if (v2)
  {
    ProGL::MatrixState::~MatrixState(v2);
    MEMORY[0x1BA9BFBA0]();
  }

  ProGL::ContextHandle::~ContextHandle(this);
}

void ProGL::GL_Wrap::getIntegerv(ProGL::GL_Wrap *this, GLenum pname, GLint *params)
{
}

void *ProGL::GL::getPGLContextHandle@<X0>(void *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = this[1];
  *a2 = *this;
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

_DWORD *ProGL::Private::TextureParameters::resetDefaultsForTarget(_DWORD *this)
{
  int v1 = this[4];
  if (v1 == 9986)
  {
    this[22] &= ~4u;
  }
  else if (!v1)
  {
    this[4] = 9986;
  }
  int v2 = this[5];
  if (v2 == 10497)
  {
    this[22] &= ~0x10u;
  }
  else if (!v2)
  {
    this[5] = 10497;
  }
  int v3 = this[6];
  if (v3 == 10497)
  {
    this[22] &= ~0x20u;
  }
  else if (!v3)
  {
    this[6] = 10497;
  }
  int v4 = this[7];
  if (v4 == 10497)
  {
    this[22] &= ~0x40u;
  }
  else if (!v4)
  {
    this[7] = 10497;
  }
  return this;
}

double ProGL::Private::TextureParameters::reset(ProGL::Private::TextureParameters *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 9729;
  *(void *)((char *)this + 36) = 0xC47A00003F800000;
  *((_DWORD *)this + 11) = 1148846080;
  *((void *)this + 6) = 0x3E800000000;
  *((_DWORD *)this + 14) = 0;
  *(void *)&double result = 6409;
  *(_OWORD *)((char *)this + 60) = xmmword_1B83779D0;
  *((_DWORD *)this + 19) = 1065353216;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 1;
  return result;
}

void ProGL::Private::TextureParameters::bind(ProGL::Private::TextureParameters *this, GLuint a2, ProGL::GL *a3, GLenum target)
{
  if (!*((unsigned char *)this + 84))
  {
    glBindTexture(target, a2);
    *((unsigned char *)this + 84) = 1;
    int v6 = *((_DWORD *)this + 22);
    if (v6)
    {
      if (v6)
      {
        ProGL::Private::TextureParameters::resetDefaultsForTarget(this);
        int v6 = *((_DWORD *)this + 22);
        if ((v6 & 4) == 0)
        {
LABEL_5:
          if ((v6 & 8) == 0) {
            goto LABEL_6;
          }
          goto LABEL_12;
        }
      }
      else if ((v6 & 4) == 0)
      {
        goto LABEL_5;
      }
      glTexParameteri(target, 0x2801u, *((_DWORD *)this + 4));
      int v6 = *((_DWORD *)this + 22);
      if ((v6 & 8) == 0)
      {
LABEL_6:
        if ((v6 & 0x10) == 0)
        {
LABEL_8:
          *((_DWORD *)this + 22) = 0;
          return;
        }
LABEL_7:
        glTexParameteri(target, 0x2802u, *((_DWORD *)this + 5));
        goto LABEL_8;
      }
LABEL_12:
      glTexParameteri(target, 0x2800u, *((_DWORD *)this + 8));
      if ((*((_DWORD *)this + 22) & 0x10) == 0) {
        goto LABEL_8;
      }
      goto LABEL_7;
    }
  }
}

uint64_t ProGL::Private::TextureParameters::isBound(ProGL::Private::TextureParameters *this)
{
  return *((unsigned __int8 *)this + 84);
}

void ProGL::Private::TextureParameters::unbind(ProGL::Private::TextureParameters *this, ProGL::GL *a2, GLenum target)
{
  if (*((unsigned char *)this + 84))
  {
    glBindTexture(target, 0);
    *((unsigned char *)this + 84) = 0;
  }
}

void ProGL::Private::TextureParameters::setMinFilter(ProGL::Private::TextureParameters *this, ProGL::GL *a2, GLenum target, GLint param)
{
  if (*((_DWORD *)this + 4) != param)
  {
    *((_DWORD *)this + 4) = param;
    if (*((unsigned char *)this + 84)) {
      glTexParameteri(target, 0x2801u, param);
    }
    else {
      *((_DWORD *)this + 22) |= 4u;
    }
  }
}

void ProGL::Private::TextureParameters::setMagFilter(ProGL::Private::TextureParameters *this, ProGL::GL *a2, GLenum target, GLint param)
{
  if (*((_DWORD *)this + 8) != param)
  {
    *((_DWORD *)this + 8) = param;
    if (*((unsigned char *)this + 84)) {
      glTexParameteri(target, 0x2800u, param);
    }
    else {
      *((_DWORD *)this + 22) |= 8u;
    }
  }
}

void ProGL::Private::TextureParameters::setWrapS(ProGL::Private::TextureParameters *this, ProGL::GL *a2, GLenum target, GLint param)
{
  if (*((_DWORD *)this + 5) != param)
  {
    *((_DWORD *)this + 5) = param;
    if (*((unsigned char *)this + 84)) {
      glTexParameteri(target, 0x2802u, param);
    }
    else {
      *((_DWORD *)this + 22) |= 0x10u;
    }
  }
}

void ProGL::Private::TextureParameters::setWrapT(ProGL::Private::TextureParameters *this, ProGL::GL *a2, GLenum target, GLint param)
{
  if (*((_DWORD *)this + 6) != param)
  {
    *((_DWORD *)this + 6) = param;
    if (*((unsigned char *)this + 84)) {
      glTexParameteri(target, 0x2803u, param);
    }
    else {
      *((_DWORD *)this + 22) |= 0x20u;
    }
  }
}

uint64_t ProGL::Private::TextureParameters::getGenerateMipmap(ProGL::Private::TextureParameters *this)
{
  return *((unsigned __int8 *)this + 72);
}

void ProGL::Private::TextureParameters::setMaxAnisotropy(GLfloat *this, ProGL::GL *a2, GLenum target, GLfloat a4)
{
  if (this[19] != a4)
  {
    this[19] = a4;
    if (*((unsigned char *)this + 84)) {
      glTexParameterf(target, 0x84FEu, a4);
    }
    else {
      *((_DWORD *)this + 22) |= 0x20000u;
    }
  }
}

ProGL::Private::TextureImpl **ProGL::Private::deleteTextures(ProGL::Private::TextureImpl **this, ProGL::Private::TextureImpl **a2, ProGL::Private::TextureImpl **a3)
{
  if (this != a2) {
    operator new();
  }
  return this;
}

void sub_1B795A808(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::DeleteTextureInst::~DeleteTextureInst(OZChannelBase *this, const PCString *a2)
{
  this->var0 = (void **)&unk_1F10FAB80;
  var1 = (void **)this->var1;
  if (var1)
  {
    this->var2 = var1;
    operator delete(var1);
  }

  OZChannelBase::setRangeName(this, a2);
}

{
  void **var1;
  uint64_t vars8;

  this->var0 = (void **)&unk_1F10FAB80;
  var1 = (void **)this->var1;
  if (var1)
  {
    this->var2 = var1;
    operator delete(var1);
  }
  OZChannelBase::setRangeName(this, a2);

  JUMPOUT(0x1BA9BFBA0);
}

void anonymous namespace'::DeleteTextureInst::execute(_anonymous_namespace_::DeleteTextureInst *this)
{
  int v1 = (uint64_t *)*((void *)this + 1);
  int v2 = (HGPixelBufferObj **)*((void *)this + 2);
  if ((char *)v2 - (char *)v1 == 8)
  {
    ProGL::Private::TextureImpl::getContext(*v1, v41);
    int v3 = (const ProGL::ContextHandle *)HGPixelBufferObj::format((HGPixelBufferObj *)*v1);
    ProGL::getDeletionContext(v41, v3, (ProGL::ContextHandle *)&v40);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v41);
    ProGL::CurrentContextSentry::CurrentContextSentry((ProGL::CurrentContextSentry *)v41, (const ProGL::ContextHandle *)&v40);
    textures[0] = HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)*v1);
    glDeleteTextures(1, textures);
    uint64_t v4 = *v1;
    if (*v1)
    {
      long long v5 = *(std::__shared_weak_count **)(v4 + 256);
      if (v5) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v5);
      }
      PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v4 + 208));
      std::__tree<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>>>::destroy(v4 + 176, *(void **)(v4 + 184));
      ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(v4 + 24));
      PCSpinLock::~PCSpinLock((PCSpinLock *)(v4 + 16));
      int v6 = *(std::__shared_weak_count **)(v4 + 8);
      if (v6) {
        std::__shared_weak_count::__release_weak(v6);
      }
      MEMORY[0x1BA9BFBA0](v4, 0x1020C40A7E6A51ELL);
    }
    ProGL::CurrentContextSentry::~CurrentContextSentry((ProGL::CurrentContextSentry *)v41);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v40);
  }
  else
  {
    memset(&v40, 0, sizeof(v40));
    std::vector<unsigned int>::reserve(&v40, ((char *)v2 - (char *)v1) >> 3);
    if (v1 != (uint64_t *)v2)
    {
      char v7 = v1;
      do
      {
        ProGL::Private::TextureImpl::getContext(*v7, textures);
        uint64_t v8 = (const ProGL::ContextHandle *)HGPixelBufferObj::format((HGPixelBufferObj *)*v7);
        ProGL::getDeletionContext((os_unfair_lock_s **)textures, v8, (ProGL::ContextHandle *)v41);
        ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)textures);
        v40.__end_ = v40.__begin_;
        unsigned int AlphaOperation = HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)*v7);
        unsigned int v10 = AlphaOperation;
        std::vector<unsigned int>::pointer end = v40.__end_;
        if (v40.__end_ >= v40.__end_cap_.__value_)
        {
          std::vector<unsigned int>::pointer begin = v40.__begin_;
          int64_t v14 = v40.__end_ - v40.__begin_;
          unint64_t v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 62) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          int64_t v16 = (char *)v40.__end_cap_.__value_ - (char *)v40.__begin_;
          if (((char *)v40.__end_cap_.__value_ - (char *)v40.__begin_) >> 1 > v15) {
            unint64_t v15 = v16 >> 1;
          }
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v17 = v15;
          }
          if (v17)
          {
            int v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v40.__end_cap_, v17);
            std::vector<unsigned int>::pointer begin = v40.__begin_;
            std::vector<unsigned int>::pointer end = v40.__end_;
          }
          else
          {
            int v18 = 0;
          }
          double v19 = (unsigned int *)&v18[4 * v14];
          *double v19 = v10;
          unint64_t v12 = v19 + 1;
          while (end != begin)
          {
            unsigned int v20 = *--end;
            *--double v19 = v20;
          }
          v40.__begin_ = v19;
          v40.__end_ = v12;
          v40.__end_cap_.__value_ = (unsigned int *)&v18[4 * v17];
          if (begin) {
            operator delete(begin);
          }
        }
        else
        {
          *v40.__end_ = AlphaOperation;
          unint64_t v12 = end + 1;
        }
        v40.__end_ = v12;
        uint64_t v21 = (HGPixelBufferObj **)(v7 + 1);
        *(void *)textures = *v7;
        uint64_t v22 = v2;
        if (v7 + 1 != (uint64_t *)v2)
        {
          uint64_t v22 = v2;
          while (2)
          {
            {
              if (++v21 == v22) {
                goto LABEL_37;
              }
            }
            do
            {
              if (--v22 == v21)
              {
                uint64_t v22 = v21;
                goto LABEL_37;
              }
            }
            uint64_t v23 = *v21;
            *v21++ = *v22;
            *uint64_t v22 = v23;
            if (v22 != v21) {
              continue;
            }
            break;
          }
        }
LABEL_37:
        if (v7 != (uint64_t *)v22)
        {
          do
          {
            unsigned int v24 = HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)*v7);
            unsigned int v25 = v24;
            std::vector<unsigned int>::pointer v26 = v40.__end_;
            if (v40.__end_ >= v40.__end_cap_.__value_)
            {
              std::vector<unsigned int>::pointer v28 = v40.__begin_;
              int64_t v29 = v40.__end_ - v40.__begin_;
              unint64_t v30 = v29 + 1;
              if ((unint64_t)(v29 + 1) >> 62) {
                std::vector<double>::__throw_length_error[abi:ne180100]();
              }
              int64_t v31 = (char *)v40.__end_cap_.__value_ - (char *)v40.__begin_;
              if (((char *)v40.__end_cap_.__value_ - (char *)v40.__begin_) >> 1 > v30) {
                unint64_t v30 = v31 >> 1;
              }
              if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v32 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v32 = v30;
              }
              if (v32)
              {
                double v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v40.__end_cap_, v32);
                std::vector<unsigned int>::pointer v28 = v40.__begin_;
                std::vector<unsigned int>::pointer v26 = v40.__end_;
              }
              else
              {
                double v33 = 0;
              }
              uint64_t v34 = (unsigned int *)&v33[4 * v29];
              *uint64_t v34 = v25;
              double v27 = v34 + 1;
              while (v26 != v28)
              {
                unsigned int v35 = *--v26;
                *--uint64_t v34 = v35;
              }
              v40.__begin_ = v34;
              v40.__end_ = v27;
              v40.__end_cap_.__value_ = (unsigned int *)&v33[4 * v32];
              if (v28) {
                operator delete(v28);
              }
            }
            else
            {
              *v40.__end_ = v24;
              double v27 = v26 + 1;
            }
            v40.__end_ = v27;
            ++v7;
          }
          while (v7 != (uint64_t *)v22);
          char v7 = (uint64_t *)v22;
        }
        ProGL::CurrentContextSentry::CurrentContextSentry((ProGL::CurrentContextSentry *)textures, (const ProGL::ContextHandle *)v41);
        glDeleteTextures((unint64_t)((char *)v40.__end_ - (char *)v40.__begin_) >> 2, v40.__begin_);
        ProGL::CurrentContextSentry::~CurrentContextSentry((ProGL::CurrentContextSentry *)textures);
        ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v41);
      }
      while (v7 != (uint64_t *)v2);
      do
      {
        uint64_t v36 = *v1;
        if (*v1)
        {
          uint64_t v37 = *(std::__shared_weak_count **)(v36 + 256);
          if (v37) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v37);
          }
          PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v36 + 208));
          std::__tree<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>>>::destroy(v36 + 176, *(void **)(v36 + 184));
          ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(v36 + 24));
          PCSpinLock::~PCSpinLock((PCSpinLock *)(v36 + 16));
          uint64_t v38 = *(std::__shared_weak_count **)(v36 + 8);
          if (v38) {
            std::__shared_weak_count::__release_weak(v38);
          }
          MEMORY[0x1BA9BFBA0](v36, 0x1020C40A7E6A51ELL);
        }
        ++v1;
      }
      while (v1 != (uint64_t *)v2);
    }
    if (v40.__begin_)
    {
      v40.__end_ = v40.__begin_;
      operator delete(v40.__begin_);
    }
  }
}

void sub_1B795AD64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15)
{
}

void std::vector<unsigned int>::reserve(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (char *)this->__end_ - (char *)this->__begin_;
    int v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)p_end_cap, __n);
    char v7 = (unsigned int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    char v9 = (unsigned int *)&v6[4 * v8];
    std::vector<unsigned int>::pointer begin = this->__begin_;
    std::vector<unsigned int>::pointer end = this->__end_;
    unint64_t v12 = v7;
    if (end != this->__begin_)
    {
      unint64_t v12 = v7;
      do
      {
        unsigned int v13 = *--end;
        *--unint64_t v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

BOOL anonymous namespace'::SameShareGroup::operator()(uint64_t *a1, HGPixelBufferObj *a2)
{
  ProGL::Private::TextureImpl::getContext(*a1, v9);
  ProGL::Private::TextureImpl::getContext((uint64_t)a2, v8);
  if (ProGL::areContextsShared(v9, v8, v4))
  {
    int v5 = HGPixelBufferObj::format((HGPixelBufferObj *)*a1);
    BOOL v6 = v5 == HGPixelBufferObj::format(a2);
  }
  else
  {
    BOOL v6 = 0;
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v8);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v9);
  return v6;
}

void sub_1B795AF28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<anonymous namespace'::DeleteTextureInst *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::DeleteTextureInst>,std::allocator<anonymous namespace'::DeleteTextureInst>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<anonymous namespace'::DeleteTextureInst *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::DeleteTextureInst>,std::allocator<anonymous namespace'::DeleteTextureInst>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<anonymous namespace'::DeleteTextureInst *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::DeleteTextureInst>,std::allocator<anonymous namespace'::DeleteTextureInst>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void ProGL::Private::initLazyTexture(ProGL::Private *this)
{
}

uint64_t ProGL::Private::cleanUpLazyTexture(ProGL::Private *this)
{
  {
    uint64_t result = MEMORY[0x1BA9BFBA0]();
  }
  return result;
}

ProGL::TextureDescription *ProGL::TextureDescription::TextureDescription(ProGL::TextureDescription *this, const ProGL::ContextHandle *a2)
{
  uint64_t v3 = *((void *)a2 + 1);
  *(void *)this = *(void *)a2;
  *((void *)this + 1) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *((_DWORD *)this + 4) = ProGL::ContextHandle::getVirtualScreen(this);
  *(void *)((char *)this + 20) = 0;
  *(void *)((char *)this + 36) = 0;
  *(void *)((char *)this + 28) = 0;
  return this;
}

void sub_1B795B0D4(_Unwind_Exception *a1)
{
  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

ProGL::TextureDescription *ProGL::TextureDescription::TextureDescription(ProGL::TextureDescription *this, int a2, int a3, int a4, int a5, const ProGL::ContextHandle *a6)
{
  uint64_t v11 = *((void *)a6 + 1);
  *(void *)this = *(void *)a6;
  *((void *)this + 1) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *((_DWORD *)this + 4) = ProGL::ContextHandle::getVirtualScreen(this);
  *((_DWORD *)this + 5) = a2;
  *((_DWORD *)this + 6) = a3;
  *(void *)((char *)this + 28) = 0x100000001;
  *((_DWORD *)this + 9) = a4;
  *((_DWORD *)this + 10) = a5;
  return this;
}

void sub_1B795B164(_Unwind_Exception *a1)
{
  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

ProGL::TextureDescription *ProGL::TextureDescription::TextureDescription(ProGL::TextureDescription *this, int a2, int a3, int a4, int a5, int a6, const ProGL::ContextHandle *a7)
{
  uint64_t v13 = *((void *)a7 + 1);
  *(void *)this = *(void *)a7;
  *((void *)this + 1) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *((_DWORD *)this + 4) = ProGL::ContextHandle::getVirtualScreen(this);
  *((_DWORD *)this + 5) = a2;
  *((_DWORD *)this + 6) = a3;
  *((_DWORD *)this + 7) = a4;
  *((_DWORD *)this + 8) = 1;
  *((_DWORD *)this + 9) = a5;
  *((_DWORD *)this + 10) = a6;
  return this;
}

void sub_1B795B1F8(_Unwind_Exception *a1)
{
  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

void ProGL::TextureDescription::reset(ProGL::TextureDescription *this)
{
  memset(v2, 0, sizeof(v2));
  ProGL::ContextHandle::operator=(this, (uint64_t *)v2);
  *((_OWORD *)this + 1) = v2[1];
  *(_OWORD *)((char *)this + 28) = *(_OWORD *)((char *)&v2[1] + 12);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v2);
}

void sub_1B795B264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ProGL::Private::initTextureHandle(ProGL::Private *this)
{
}

void sub_1B795B34C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::cleanUpTextureHandle(ProGL::Private *this)
{
  {
    MEMORY[0x1BA9BFBA0](v1, 0x1020C4062D53EE8);
  }
  {
    PCSpinLock::~PCSpinLock(v2);
    MEMORY[0x1BA9BFBA0]();
  }
  {
    uint64_t result = MEMORY[0x1BA9BFBA0]();
  }
  return result;
}

void (*ProGL::TextureHandle::operator void (ProGL::TextureHandle::*)(void)(void (**a1)(_anonymous_namespace_ **this)))(_anonymous_namespace_ **this)
{
  uint64_t result = *a1;
  if (result)
  {
    if (HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)result)) {
      return ProGL::TextureHandle::detach;
    }
    else {
      return 0;
    }
  }
  return result;
}

void ProGL::TextureHandle::detach(_anonymous_namespace_ **this)
{
  int v2 = *this;
  if (v2)
  {
    Serializer = OZChannelBase::getSerializer((OZChannelBase *)v2);
    PCSpinLock::lock((os_unfair_lock_t)Serializer);
    ProGL::Private::TextureImpl::detach(*this);
    PCSpinLock::unlock((os_unfair_lock_t)Serializer);
  }
}

void sub_1B795B4F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

HGGLBlendingInfo *ProGL::TextureHandle::getName(HGGLBlendingInfo **this)
{
  uint64_t result = *this;
  if (result) {
    return (HGGLBlendingInfo *)HGGLBlendingInfo::GetAlphaOperation(result);
  }
  return result;
}

uint64_t ProGL::TextureHandle::getContext@<X0>(ProGL::TextureHandle *this@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)this;
  if (result) {
    return ProGL::Private::TextureImpl::getContext(result, a2);
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void ProGL::TextureHandle::setPooled(OZChannelBase **this, char a2)
{
  uint64_t v3 = *this;
  if (v3)
  {
    Serializer = OZChannelBase::getSerializer(v3);
    PCSpinLock::lock((os_unfair_lock_t)Serializer);
    ProGL::Private::TextureImpl::setPooled((uint64_t)*this, a2);
    PCSpinLock::unlock((os_unfair_lock_t)Serializer);
  }
}

void sub_1B795B590(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

ProGL::Private::TextureImpl *ProGL::TextureHandle::getSize(ProGL::Private::TextureImpl **this)
{
  uint64_t result = *this;
  if (result) {
    return (ProGL::Private::TextureImpl *)ProGL::Private::TextureImpl::getSize(result);
  }
  return result;
}

ProGL::Private::TextureImpl *ProGL::TextureHandle::getTarget(ProGL::Private::TextureImpl **this)
{
  uint64_t result = *this;
  if (result) {
    return (ProGL::Private::TextureImpl *)ProGL::Private::TextureImpl::getTarget(result);
  }
  return result;
}

ProGL::Private::TextureImpl *ProGL::TextureHandle::getWidth(ProGL::Private::TextureImpl **this)
{
  uint64_t result = *this;
  if (result) {
    return (ProGL::Private::TextureImpl *)ProGL::Private::TextureImpl::getWidth(result);
  }
  return result;
}

ProGL::Private::TextureImpl *ProGL::TextureHandle::getHeight(ProGL::Private::TextureImpl **this)
{
  uint64_t result = *this;
  if (result) {
    return (ProGL::Private::TextureImpl *)ProGL::Private::TextureImpl::getHeight(result);
  }
  return result;
}

ProGL::Private::TextureImpl *ProGL::TextureHandle::getBorder(ProGL::Private::TextureImpl **this)
{
  uint64_t result = *this;
  if (result) {
    return (ProGL::Private::TextureImpl *)ProGL::Private::TextureImpl::getBorder(result);
  }
  return result;
}

ProGL::Private::TextureImpl *ProGL::TextureHandle::getActualInternalFormat(ProGL::Private::TextureImpl **this)
{
  uint64_t result = *this;
  if (result) {
    return (ProGL::Private::TextureImpl *)ProGL::Private::TextureImpl::getActualInternalFormat(result);
  }
  return result;
}

uint64_t anonymous namespace'::removeTexture(_anonymous_namespace_ *this, ProGL::Private::TextureImpl *a2)
{
  uint64_t result = HGGLBlendingInfo::GetAlphaOperation(this);
  if (result)
  {
    int AlphaOperation = HGGLBlendingInfo::GetAlphaOperation(this);
    ProGL::Private::TextureImpl::getContext((uint64_t)this, &v6);
    ProGL::ContextHandle::getShareGroup(&v6, &v8);
    int v9 = AlphaOperation;
    ProGL::ShareGroup::ShareGroup(&v10, &v8);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v6);
    char v7 = 1;
    if (v5) {
      return PCMutex::unlock(v5);
    }
  }
  return result;
}

void sub_1B795B6B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

void ProGL::TextureHandle::bind(OZChannelBase **this, ProGL::GL *a2, GLenum a3)
{
  Serializer = OZChannelBase::getSerializer(*this);
  PCSpinLock::lock((os_unfair_lock_t)Serializer);
  ProGL::Private::TextureImpl::bind((ProGL::Private::TextureImpl *)*this, a2, a3);
  PCSpinLock::unlock((os_unfair_lock_t)Serializer);
}

void sub_1B795B73C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void ProGL::TextureHandle::unbind(OZChannelBase **this, ProGL::GL *a2)
{
  Serializer = OZChannelBase::getSerializer(*this);
  PCSpinLock::lock((os_unfair_lock_t)Serializer);
  ProGL::Private::TextureImpl::unbind((ProGL::Private::TextureImpl *)*this, a2);
  PCSpinLock::unlock((os_unfair_lock_t)Serializer);
}

void sub_1B795B7B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

uint64_t ProGL::TextureHandle::isBound(ProGL::Private::TextureImpl **this)
{
  int v2 = *this;
  if (!v2) {
    return 0;
  }
  Serializer = OZChannelBase::getSerializer((OZChannelBase *)v2);
  PCSpinLock::lock((os_unfair_lock_t)Serializer);
  uint64_t isBound = ProGL::Private::TextureImpl::isBound(*this);
  PCSpinLock::unlock((os_unfair_lock_t)Serializer);
  return isBound;
}

void sub_1B795B828(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void ProGL::TextureHandle::texParameter(OZChannelBase **this, ProGL::GL *a2, GLenum a3, GLint a4)
{
  Serializer = OZChannelBase::getSerializer(*this);
  PCSpinLock::lock((os_unfair_lock_t)Serializer);
  ProGL::Private::TextureImpl::texParameter((ProGL::Private::TextureImpl *)*this, a2, a3, a4);
  PCSpinLock::unlock((os_unfair_lock_t)Serializer);
}

void sub_1B795B8B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void ProGL::TextureHandle::texImage2D(OZChannelBase **this, ProGL::GL *a2, GLenum a3, GLint a4, GLint a5, GLsizei a6, GLsizei a7, GLint a8, GLenum a9, GLenum a10, GLvoid *a11)
{
  Serializer = OZChannelBase::getSerializer(*this);
  PCSpinLock::lock((os_unfair_lock_t)Serializer);
  ProGL::Private::TextureImpl::texImage2D((ProGL::Private::TextureImpl *)*this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  PCSpinLock::unlock((os_unfair_lock_t)Serializer);
}

void sub_1B795B978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void ProGL::createTexture(ProGL *this, ProGL::GL *a2)
{
}

void sub_1B795BA30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::makeImplPtr(_anonymous_namespace_ *this@<X0>, void *a2@<X8>)
{
  *a2 = this;
  operator new();
}

void sub_1B795BAE8(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_rethrow();
}

void sub_1B795BAFC(_Unwind_Exception *a1)
{
}

uint64_t *anonymous namespace'::addTexture(_anonymous_namespace_ *this, ProGL::Private::TextureImpl *a2)
{
  int AlphaOperation = HGGLBlendingInfo::GetAlphaOperation(this);
  ProGL::Private::TextureImpl::getContext((uint64_t)this, &v7);
  ProGL::ContextHandle::getShareGroup(&v7, &v9);
  int v11 = AlphaOperation;
  ProGL::ShareGroup::ShareGroup(&v12, &v9);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v7);
  char v10 = 1;
  LODWORD(v7) = v11;
  ProGL::ShareGroup::ShareGroup(v8, &v12);
  v8[1] = this;
  uint64_t result = std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__emplace_unique_key_args<std::pair<unsigned int,ProGL::ShareGroup>,std::pair<std::pair<unsigned int,ProGL::ShareGroup> const,ProGL::Private::TextureImpl *>>(v5, (unsigned int *)&v7, (uint64_t)&v7);
  if (v4) {
    return (uint64_t *)PCMutex::unlock(v4);
  }
  return result;
}

void sub_1B795BBE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

void ProGL::createExternallyOwnedTexture()
{
}

void sub_1B795BCF4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1020C40A7E6A51ELL);
  _Unwind_Resume(a1);
}

void ProGL::findTextureInPool(ProGL *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *(void *)this;
  uint64_t v5 = *((void *)this + 1);
  uint64_t v19 = *(void *)this;
  uint64_t v20 = v5;
  if (v5)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    v21[0] = *((_OWORD *)this + 1);
    *(_OWORD *)((char *)v21 + 12) = *(_OWORD *)((char *)this + 28);
    uint64_t v17 = v4;
    uint64_t v18 = v5;
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  else
  {
    v21[0] = *((_OWORD *)this + 1);
    *(_OWORD *)((char *)v21 + 12) = *(_OWORD *)((char *)this + 28);
    uint64_t v17 = v4;
    uint64_t v18 = 0;
  }
  char v7 = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(&v17);
  if (v6) {
    BOOL v8 = (v6 & 1 | (unint64_t)v7) == 0;
  }
  else {
    BOOL v8 = 1;
  }
  int v9 = v8;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v17);
  if (!v7 && v9)
  {
    ProGL::getCurrentContext(&v17);
    ProGL::ContextHandle::operator=(&v19, &v17);
    LODWORD(v21[0]) = ProGL::ContextHandle::getVirtualScreen((ProGL::ContextHandle *)&v19);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v17);
  }
  uint64_t v17 = v19;
  uint64_t v18 = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  int v11 = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(&v17);
  if (v10) {
    BOOL v12 = (v10 & 1 | (unint64_t)v11) == 0;
  }
  else {
    BOOL v12 = 1;
  }
  int v13 = v12;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v17);
  if (v11 || !v13)
  {
    LOBYTE(v18) = 1;
    *a2 = 0;
    a2[1] = 0;
    if (v14) {
      PCMutex::unlock(v14);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v19);
}

void sub_1B795BF98(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  if (a3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a3);
  }
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va1);
  _Unwind_Resume(a1);
}

void *std::multimap<ProGL::TextureDescription,ProGL::Private::TextureImpl *,anonymous namespace'::CompareTextureDescription,std::allocator<std::pair<ProGL::TextureDescription const,ProGL::Private::TextureImpl *>>>::find[abi:ne180100](uint64_t a1, uint64_t a2)
{
  int v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = (void *)(a1 + 8);
  do
  {
    char v7 = v3 + 1;
    if (!v6)
    {
      char v7 = v3;
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
    return v2;
  return v5;
}

void ProGL::createTextureFromPool(ProGL *this@<X0>, ProGL::GL *a2@<X1>, HGGLBlendingInfo **a3@<X8>)
{
  char v7 = (atomic_ullong *)*((void *)a2 + 1);
  double v27 = *(HGGLBlendingInfo **)a2;
  std::vector<unsigned int>::pointer v28 = (HGGLBlendingInfo *)v7;
  if (v7) {
    atomic_fetch_add_explicit(v7 + 1, 1uLL, memory_order_relaxed);
  }
  BOOL v8 = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(&v27);
  if (v9) {
    BOOL v10 = (v9 & 1 | (unint64_t)v8) == 0;
  }
  else {
    BOOL v10 = 1;
  }
  char v11 = v10;
  if (v8 || (v11 & 1) == 0)
  {
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v27);
  }
  else
  {
    ProGL::GL::getPGLContextHandle(this, v30);
    int v13 = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(v30);
    if (v12) {
      BOOL v14 = (v12 & 1 | (unint64_t)v13) == 0;
    }
    else {
      BOOL v14 = 1;
    }
    int v15 = v14;
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v30);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v27);
    if (!v13 && v15)
    {
      *a3 = 0;
      a3[1] = 0;
      return;
    }
  }
  *a3 = 0;
  a3[1] = 0;
  int64_t v16 = (atomic_ullong *)*((void *)a2 + 1);
  double v27 = *(HGGLBlendingInfo **)a2;
  std::vector<unsigned int>::pointer v28 = (HGGLBlendingInfo *)v16;
  if (v16) {
    atomic_fetch_add_explicit(v16 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(&v27);
  if (v17) {
    BOOL v19 = (v17 & 1 | (unint64_t)v18) == 0;
  }
  else {
    BOOL v19 = 1;
  }
  int v20 = v19;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v27);
  if (!v18 && v20)
  {
    uint64_t v21 = (atomic_ullong *)*((void *)a2 + 1);
    double v27 = *(HGGLBlendingInfo **)a2;
    std::vector<unsigned int>::pointer v28 = (HGGLBlendingInfo *)v21;
    if (v21) {
      atomic_fetch_add_explicit(v21 + 1, 1uLL, memory_order_relaxed);
    }
    v29[0] = *((_OWORD *)a2 + 1);
    *(_OWORD *)((char *)v29 + 12) = *(_OWORD *)((char *)a2 + 28);
    ProGL::GL::getPGLContextHandle(this, v30);
    ProGL::ContextHandle::operator=(&v27, v30);
    LODWORD(v29[0]) = ProGL::ContextHandle::getVirtualScreen((ProGL::ContextHandle *)&v27);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v30);
    ProGL::findTextureInPool((ProGL *)&v27, v30);
    uint64_t v23 = (HGGLBlendingInfo *)v30[0];
    uint64_t v22 = v30[1];
    *a3 = (HGGLBlendingInfo *)v30[0];
    a3[1] = (HGGLBlendingInfo *)v22;
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v27);
    if (!v23) {
      goto LABEL_34;
    }
LABEL_36:
    if (HGGLBlendingInfo::GetAlphaOperation(v23)) {
      unsigned int v25 = ProGL::TextureHandle::detach;
    }
    else {
      unsigned int v25 = 0;
    }
    goto LABEL_39;
  }
  ProGL::findTextureInPool(a2, &v27);
  uint64_t v23 = v27;
  std::vector<unsigned int>::pointer v26 = v28;
  *a3 = v27;
  a3[1] = v26;
  if (v23) {
    goto LABEL_36;
  }
LABEL_34:
  unsigned int v25 = 0;
LABEL_39:
  if (!v25) {
    ProGL::createTexture(this, v24);
  }
}

void sub_1B795C2A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::evictIfNecessary(uint64_t a1, uint64_t a2, ProGL::Private::TextureImpl **a3)
{
  {
    return;
  }
  __p = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  while (1)
  {
    {
      goto LABEL_7;
    }
      break;
LABEL_7:
    int v6 = (char *)(v5 + 8 * (v4 >> 9));
    uint64_t v7 = *(void *)v6 + 8 * (v4 & 0x1FF);
      uint64_t v8 = 0;
    else {
      uint64_t v8 = v7;
    }
    if (v8 == *(void *)v6)
    {
      uint64_t v9 = *((void *)v6 - 1);
      v6 -= 8;
      uint64_t v8 = v9 + 4096;
    }
    uint64_t v11 = *(void *)(v8 - 8);
    BOOL v10 = (uint64_t **)(v8 - 8);
    uint64_t v12 = *(ProGL::Private::TextureImpl **)(v11 + 80);
    if (v22 >= v23)
    {
      uint64_t v14 = v22 - __p;
      if ((unint64_t)(v14 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v15 = ((char *)v23 - (char *)__p) >> 2;
      if (v15 <= v14 + 1) {
        unint64_t v15 = v14 + 1;
      }
      if ((unint64_t)((char *)v23 - (char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v15;
      }
      if (v16) {
        uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v23, v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = (ProGL::Private::TextureImpl **)&v17[8 * v14];
      *uint64_t v18 = v12;
      int v13 = v18 + 1;
      BOOL v19 = v22;
      if (v22 != __p)
      {
        do
        {
          int v20 = *--v19;
          *--uint64_t v18 = v20;
        }
        while (v19 != __p);
        BOOL v19 = __p;
      }
      __p = v18;
      uint64_t v23 = (ProGL::Private::TextureImpl **)&v17[8 * v16];
      if (v19) {
        operator delete(v19);
      }
    }
    else
    {
      *uint64_t v22 = v12;
      int v13 = v22 + 1;
    }
    uint64_t v22 = v13;
  }
  ProGL::Private::deleteTextures(__p, v22, a3);
  if (__p) {
    operator delete(__p);
  }
}

void sub_1B795C4F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ProGL::clearTexturePool(ProGL *this)
{
  if (v1) {
    PCMutex::unlock(v1);
  }
}

void sub_1B795C568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void anonymous namespace'::evictEverything(_anonymous_namespace_ *this)
{
  if (v1)
  {
    std::vector<ProGL::Private::TextureImpl *>::vector(&__p, v1);
    unint64_t v3 = (ProGL::Private::TextureImpl **)__p;
    {
      do
      {
        *v3++ = (ProGL::Private::TextureImpl *)v5[10];
        int v6 = (void *)v5[1];
        if (v6)
        {
          do
          {
            uint64_t v7 = v6;
            int v6 = (void *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            uint64_t v7 = (void *)v5[2];
            BOOL v8 = *v7 == (void)v5;
            uint64_t v5 = v7;
          }
          while (!v8);
        }
        uint64_t v5 = v7;
      }
      while (v7 != (void *)v4);
      unint64_t v3 = (ProGL::Private::TextureImpl **)__p;
    }
    ProGL::Private::deleteTextures(v3, v18, v2);
    *uint64_t v9 = v10;
    uint64_t v9[2] = 0;
    *BOOL v10 = 0;
    unint64_t v14 = v13 - (void)v12;
    if (v14 >= 0x11)
    {
      do
      {
        operator delete(*v12);
        uint64_t v15 = v11[2];
        uint64_t v12 = (void **)(v11[1] + 8);
        v11[1] = v12;
        unint64_t v14 = v15 - (void)v12;
      }
      while (v14 > 0x10);
    }
    if (v14 >> 3 == 1)
    {
      uint64_t v16 = 256;
    }
    else
    {
      if (v14 >> 3 != 2) {
        goto LABEL_17;
      }
      uint64_t v16 = 512;
    }
    v11[4] = v16;
LABEL_17:
    if (__p)
    {
      uint64_t v18 = (ProGL::Private::TextureImpl **)__p;
      operator delete(__p);
    }
  }
}

void sub_1B795C6B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ProGL::Private::initTexturePool(ProGL::Private *this)
{
}

void sub_1B795C7AC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::cleanUpTexturePool(ProGL::Private *this)
{
  ProGL::clearTexturePool(this);
  {
    MEMORY[0x1BA9BFBA0](v1, 0x1020C4062D53EE8);
  }
  {
    uint64_t result = MEMORY[0x1BA9BFBA0](v3, 0x1080C40BE8D5F09);
  }
  return result;
}

CGColorSpace **ProGL::TextureHandle::setColorSpace(CGColorSpace **this, CGColorSpace **a2)
{
  if (*this) {
    return PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)*this + 26, a2);
  }
  return this;
}

CGColorSpace **ProGL::TextureHandle::getColorSpace@<X0>(CGColorSpace **this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  uint64_t v3 = *this;
  if (*this)
  {
    uint64_t v4 = *((void *)v3 + 26);
    if (v4) {
      PCCFRefTraits<CGColorSpace *>::retain(*((CGColorSpaceRef *)v3 + 26));
    }
    *a2 = v4;
    uint64_t v5 = 0;
    return PCCFRef<CGColorSpace *>::~PCCFRef(&v5);
  }
  return this;
}

void sub_1B795C8E4(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

__n128 ProGL::TextureHandle::setTextureCoords(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    __n128 result = *(__n128 *)a2;
    *(_OWORD *)(v2 + 232) = *(_OWORD *)(a2 + 16);
    *(__n128 *)(v2 + 216) = result;
  }
  return result;
}

__n128 ProGL::TextureHandle::getTextureCoords@<Q0>(ProGL::TextureHandle *this@<X0>, __n128 *a2@<X8>)
{
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  a2[1] = result;
  uint64_t v7 = *(void *)this;
  if (*(void *)this)
  {
    __n128 result = *(__n128 *)(v7 + 216);
    __n128 v8 = *(__n128 *)(v7 + 232);
    *a2 = result;
    a2[1] = v8;
  }
  return result;
}

void std::__tree<std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>,std::__map_value_compare<std::pair<unsigned int,ProGL::Private::TextureImpl *>,std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>,std::less<std::pair<unsigned int,ProGL::Private::TextureImpl *>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>,std::__map_value_compare<std::pair<unsigned int,ProGL::Private::TextureImpl *>,std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>,std::less<std::pair<unsigned int,ProGL::Private::TextureImpl *>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>,std::__map_value_compare<std::pair<unsigned int,ProGL::Private::TextureImpl *>,std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>,std::less<std::pair<unsigned int,ProGL::Private::TextureImpl *>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::Private::TextureImpl *>,ProGL::Private::Any>>>::destroy(a1, a2[1]);
    ProGL::Private::Any::~Any((ProGL::Private::Any *)(a2 + 6));
    operator delete(a2);
  }
}

uint64_t std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__erase_unique<std::pair<unsigned int,ProGL::ShareGroup>>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::find<std::pair<unsigned int,ProGL::ShareGroup>>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3) {
    return 0;
  }
  uint64_t v4 = v3;
  std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(a1, v3);
  operator delete(v4);
  return 1;
}

uint64_t *std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::find<std::pair<unsigned int,ProGL::ShareGroup>>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)(a1 + 8);
  uint64_t v4 = std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__lower_bound<std::pair<unsigned int,ProGL::ShareGroup>>(a1, (unsigned int *)a2, *(uint64_t **)(a1 + 8), (uint64_t *)(a1 + 8));
  if (v3 == v4) {
    return v3;
  }
  uint64_t v5 = v4;
  unsigned int v6 = *((_DWORD *)v4 + 8);
  if (*(_DWORD *)a2 < v6 || v6 >= *(_DWORD *)a2 && ProGL::operator<((void *)(a2 + 8), v4 + 5)) {
    return v3;
  }
  return v5;
}

uint64_t *std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__lower_bound<std::pair<unsigned int,ProGL::ShareGroup>>(uint64_t a1, unsigned int *a2, uint64_t *a3, uint64_t *a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    uint64_t v7 = a2 + 2;
    do
    {
      unsigned int v8 = *((_DWORD *)v5 + 8);
      if (v8 >= *a2)
      {
        if (*a2 >= v8)
        {
          if (ProGL::operator<(v5 + 5, v7)) {
            ++v5;
          }
          else {
            a4 = v5;
          }
        }
        else
        {
          a4 = v5;
        }
      }
      else
      {
        ++v5;
      }
      uint64_t v5 = (uint64_t *)*v5;
    }
    while (v5);
  }
  return a4;
}

void anonymous namespace'::TextureImplDelete::operator()(uint64_t a1)
{
  int64_t v29 = (ProGL::Private::TextureImpl *)a1;
  if (ProGL::Private::TextureImpl::isExternallyOwned((ProGL::Private::TextureImpl *)a1))
  {
    goto LABEL_10;
  }
  if (!HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)a1))
  {
LABEL_10:
    if (a1)
    {
      uint64_t v11 = *(std::__shared_weak_count **)(a1 + 256);
      if (v11) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v11);
      }
      PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(a1 + 208));
      std::__tree<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>>>::destroy(a1 + 176, *(void **)(a1 + 184));
      ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(a1 + 24));
      PCSpinLock::~PCSpinLock((PCSpinLock *)(a1 + 16));
      uint64_t v12 = *(std::__shared_weak_count **)(a1 + 8);
      if (v12) {
        std::__shared_weak_count::__release_weak(v12);
      }
      JUMPOUT(0x1BA9BFBA0);
    }
    return;
  }
  if (!ProGL::Private::TextureImpl::wantsPooling((ProGL::Private::TextureImpl *)a1)
    || !ProGL::Private::TextureImpl::getSize((ProGL::Private::TextureImpl *)a1))
  {
    goto LABEL_34;
  }
  char v35 = 1;
        uint64_t v8 = ProGL::Private::TextureImpl::getDescription((ProGL::Private::TextureImpl *)a1),
  {
    OZChannelBase::setRangeName((OZChannelBase *)a1, v6);
    uint64_t Description = ProGL::Private::TextureImpl::getDescription((ProGL::Private::TextureImpl *)a1);
    uint64_t v16 = *(ProGL::Private::TextureImpl **)Description;
    uint64_t v15 = *(atomic_ullong **)(Description + 8);
    v30[0] = *(ProGL::Private::TextureImpl **)Description;
    v30[1] = (ProGL::Private::TextureImpl *)v15;
    if (v15) {
      atomic_fetch_add_explicit(v15 + 1, 1uLL, memory_order_relaxed);
    }
    long long v17 = *(_OWORD *)(Description + 16);
    *(_OWORD *)&v31[12] = *(_OWORD *)(Description + 28);
    *(_OWORD *)int64_t v31 = v17;
    uint64_t v32 = a1;
    uint64_t v18 = (char *)operator new(0x58uLL);
    BOOL v19 = (uint64_t **)(v13 + 8);
    v36[0] = (uint64_t)v18;
    v36[1] = v13 + 8;
    *((void *)v18 + 4) = v16;
    uint64_t v20 = (uint64_t)(v18 + 32);
    *((void *)v18 + 5) = v15;
    if (v15) {
      atomic_fetch_add_explicit(v15 + 1, 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)(v18 + 60) = *(_OWORD *)&v31[12];
    *((_OWORD *)v18 + 3) = *(_OWORD *)v31;
    *((void *)v18 + 10) = a1;
    char v37 = 1;
    while (1)
    {
      uint64_t v21 = *v19;
      uint64_t v22 = v19;
      if (!*v19) {
        break;
      }
      while (1)
      {
        BOOL v19 = (uint64_t **)v21;
          break;
        uint64_t v21 = v19[1];
        if (!v21)
        {
          uint64_t v22 = v19 + 1;
          goto LABEL_27;
        }
      }
    }
LABEL_27:
    uint64_t v23 = (uint64_t *)v36[0];
    *(void *)v36[0] = 0;
    v23[1] = 0;
    v23[2] = (uint64_t)v19;
    *uint64_t v22 = v23;
    uint64_t v24 = **(void **)v13;
    if (v24)
    {
      *(void *)uint64_t v13 = v24;
      uint64_t v23 = *v22;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v13 + 8), v23);
    ++*(void *)(v13 + 16);
    uint64_t v25 = v36[0];
    v36[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *>>>>::reset[abi:ne180100](v36, 0);
    uint64_t v33 = v25;
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v30);
    unint64_t Size = ProGL::Private::TextureImpl::getSize((ProGL::Private::TextureImpl *)a1);
    uint64_t v4 = (PCMutex *)v34;
    BOOL v9 = v35 == 0;
    char v10 = 1;
  }
  else
  {
    BOOL v9 = 0;
    char v10 = 0;
  }
  if (v4 && !v9) {
    PCMutex::unlock(v4);
  }
  if ((v10 & 1) == 0) {
LABEL_34:
  }
    ProGL::Private::deleteTextures(&v29, v30, v3);
}

void sub_1B795CDF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<ProGL::Private::TextureImpl *,anonymous namespace'::TextureImplDelete,std::allocator<ProGL::Private::TextureImpl>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::__shared_ptr_pointer<ProGL::Private::TextureImpl *,anonymous namespace'::TextureImplDelete,std::allocator<ProGL::Private::TextureImpl>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<ProGL::Private::TextureImpl *,anonymous namespace'::TextureImplDelete,std::allocator<ProGL::Private::TextureImpl>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

void ProGL::Private::AnyMap_Template<std::pair<unsigned int,ProGL::Private::TextureImpl *>,PCSpinLock>::remove_if<ProGL::Private::PerContextAnyMap<ProGL::Private::TextureImpl *,PCSpinLock>::ContextPred>(uint64_t a1, uint64_t a2)
{
  PCSpinLock::lock((os_unfair_lock_t)a1);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4 == (uint64_t *)(a1 + 16)) {
    goto LABEL_17;
  }
  do
  {
    uint64_t v5 = (uint64_t *)v4[1];
    if (v4[5] == a2)
    {
      uint64_t v8 = v4;
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          uint64_t v5 = (uint64_t *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (uint64_t *)v8[2];
          BOOL v7 = *v6 == (void)v8;
          uint64_t v8 = v6;
        }
        while (!v7);
      }
      std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 8), v4);
      ProGL::Private::Any::~Any((ProGL::Private::Any *)(v4 + 6));
      operator delete(v4);
    }
    else if (v5)
    {
      do
      {
        uint64_t v6 = v5;
        uint64_t v5 = (uint64_t *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        uint64_t v6 = (uint64_t *)v4[2];
        BOOL v7 = *v6 == (void)v4;
        uint64_t v4 = v6;
      }
      while (!v7);
    }
    uint64_t v4 = v6;
  }
  while (v6 != (uint64_t *)(a1 + 16));
  if (a1) {
LABEL_17:
  }
    PCSpinLock::unlock((os_unfair_lock_t)a1);
}

void std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::push_front(uint64_t a1, void *a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::__add_front_capacity((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 >> 9));
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *v6 + 8 * (v4 & 0x1FF);
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4096;
  }
  *(void *)(v7 - 8) = *a2;
  uint64_t v8 = *(void *)(a1 + 40) + 1;
  *(void *)(a1 + 32) = v4 - 1;
  *(void *)(a1 + 40) = v8;
}

uint64_t anonymous namespace'::CompareTextureDescription::operator()(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 24);
  int v3 = *(_DWORD *)(a2 + 24);
  if (v2 < v3) {
    return 1;
  }
  if (v2 > v3) {
    return 0;
  }
  int v5 = *(_DWORD *)(a1 + 28);
  int v6 = *(_DWORD *)(a2 + 28);
  if (v5 < v6) {
    return 1;
  }
  if (v5 > v6) {
    return 0;
  }
  int v7 = *(_DWORD *)(a1 + 32);
  int v8 = *(_DWORD *)(a2 + 32);
  if (v7 < v8) {
    return 1;
  }
  if (v7 > v8) {
    return 0;
  }
  int v9 = *(_DWORD *)(a1 + 36);
  int v10 = *(_DWORD *)(a2 + 36);
  if (v9 < v10) {
    return 1;
  }
  if (v9 > v10) {
    return 0;
  }
  int v11 = *(_DWORD *)(a1 + 40);
  int v12 = *(_DWORD *)(a2 + 40);
  if (v11 < v12) {
    return 1;
  }
  if (v11 > v12) {
    return 0;
  }
  unsigned int v13 = *(_DWORD *)(a1 + 20);
  unsigned int v14 = *(_DWORD *)(a2 + 20);
  if (v13 < v14) {
    return 1;
  }
  if (v13 > v14) {
    return 0;
  }
  int v15 = *(_DWORD *)(a1 + 16);
  int v16 = *(_DWORD *)(a2 + 16);
  if (v15 < v16) {
    return 1;
  }
  if (v15 > v16) {
    return 0;
  }
  uint64_t v18 = *(void *)(a1 + 8);
  v23[0] = *(os_unfair_lock_s **)a1;
  v23[1] = (os_unfair_lock_s *)v18;
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  ProGL::ContextHandle::getShareGroup(v23, &v24);
  uint64_t v19 = *(void *)(a2 + 8);
  v21[0] = *(os_unfair_lock_s **)a2;
  v21[1] = (os_unfair_lock_s *)v19;
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  ProGL::ContextHandle::getShareGroup(v21, &v22);
  BOOL v20 = ProGL::operator<(&v24, &v22);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v21);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v23);
  return v20;
}

void sub_1B795D174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *>>>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16)) {
      ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(v2 + 32));
    }
    operator delete((void *)v2);
  }
}

void std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::__add_front_capacity(void **a1)
{
  uint64_t v2 = a1[1];
  int v3 = a1[2];
  unint64_t v4 = v3 - v2;
  if (v3 == v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = ((v3 - v2) << 6) - 1;
  }
  int v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x200)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    int v8 = a1[3];
    int v9 = *a1;
    uint64_t v10 = v8 - (unsigned char *)*a1;
    if (v4 >= v10)
    {
      if (v8 == v9) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      uint64_t v46 = a1 + 3;
      __p = std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v7, v11);
      uint64_t v43 = (char *)__p;
      BOOL v44 = (char *)__p;
      double v45 = (char *)__p + 8 * v12;
      signed int v41 = operator new(0x1000uLL);
      std::__split_buffer<unsigned long *>::push_back(&__p, &v41);
      unsigned int v13 = (char *)a1[1];
      unsigned int v14 = v44;
      if (v13 == a1[2])
      {
        uint64_t v33 = (char *)a1[1];
      }
      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (unsigned char *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1;
              }
              else {
                unint64_t v23 = (v14 - (unsigned char *)__p) >> 2;
              }
              PCSharedCount v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v46, v23);
              std::vector<unsigned int>::pointer v26 = v43;
              unsigned int v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                unsigned int v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v28 = 8 * (v27 >> 3);
                int64_t v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)int64_t v29 = v30;
                  v29 += 8;
                  v28 -= 8;
                }
                while (v28);
              }
              int64_t v31 = __p;
              __p = v24;
              uint64_t v43 = &v24[8 * (v23 >> 2)];
              BOOL v44 = v14;
              double v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                unsigned int v14 = v44;
              }
            }
            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              BOOL v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                unsigned int v14 = v43;
              }
              PCSharedCount v22 = &v14[-8 * (v19 >> 1)];
              unsigned int v14 = &v20[v21];
              uint64_t v43 = v22;
              BOOL v44 = &v20[v21];
            }
          }
          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)unsigned int v14 = v32;
          unsigned int v14 = v44 + 8;
          v44 += 8;
        }
        while (v13 != a1[2]);
        uint64_t v33 = (char *)a1[1];
      }
      uint64_t v36 = *a1;
      char v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      __p = v36;
      uint64_t v43 = v33;
      uint64_t v38 = (char *)a1[3];
      unsigned int v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      BOOL v44 = v13;
      double v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 256;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 512;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        BOOL v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v36) {
        operator delete(v36);
      }
    }
    else
    {
      if (v2 == v9)
      {
        __p = operator new(0x1000uLL);
        std::__split_buffer<unsigned long *>::push_back(a1, &__p);
        uint64_t v34 = a1[2];
        __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }
      else
      {
        __p = operator new(0x1000uLL);
      }
      std::__split_buffer<unsigned long *>::push_front((uint64_t)a1, &__p);
      if ((unsigned char *)a1[2] - (unsigned char *)a1[1] == 8) {
        uint64_t v35 = 256;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 512;
      }
      a1[4] = (void *)v35;
    }
  }
  else
  {
    a1[4] = v6 + 512;
    __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    std::__split_buffer<unsigned long *>::push_front((uint64_t)a1, &__p);
  }
}

void sub_1B795D4B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  operator delete(v12);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__emplace_unique_key_args<std::pair<unsigned int,ProGL::ShareGroup>,std::pair<std::pair<unsigned int,ProGL::ShareGroup> const,ProGL::Private::TextureImpl *>>(uint64_t **a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t **)std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__find_equal<std::pair<unsigned int,ProGL::ShareGroup>>((uint64_t)a1, &v8, a2);
  __n128 result = *v5;
  if (!*v5)
  {
    std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__construct_node<std::pair<std::pair<unsigned int,ProGL::ShareGroup> const,ProGL::Private::TextureImpl *>>((uint64_t)a1, a3, (uint64_t)&v7);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__find_equal<std::pair<unsigned int,ProGL::ShareGroup>>(uint64_t a1, void *a2, unsigned int *a3)
{
  uint64_t v5 = (uint64_t *)(a1 + 8);
  unint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a3 + 2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = v4;
        unsigned int v9 = *a3;
        unsigned int v10 = *((_DWORD *)v4 + 8);
        if (*a3 >= v10) {
          break;
        }
LABEL_6:
        unint64_t v4 = (uint64_t *)*v8;
        uint64_t v5 = v8;
        if (!*v8) {
          goto LABEL_15;
        }
      }
      if (v10 >= v9)
      {
        if (ProGL::operator<(v7, v8 + 5)) {
          goto LABEL_6;
        }
        unsigned int v10 = *((_DWORD *)v8 + 8);
        unsigned int v9 = *a3;
      }
      if (v10 < v9 || v9 >= v10 && ProGL::operator<(v8 + 5, v7))
      {
        uint64_t v5 = v8 + 1;
        unint64_t v4 = (uint64_t *)v8[1];
        if (v4) {
          continue;
        }
      }
      goto LABEL_15;
    }
  }
  uint64_t v8 = (uint64_t *)(a1 + 8);
LABEL_15:
  *a2 = v8;
  return v5;
}

void *std::__tree<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::__map_value_compare<std::pair<unsigned int,ProGL::ShareGroup>,std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>,std::less<std::pair<unsigned int,ProGL::ShareGroup>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,ProGL::ShareGroup>,ProGL::Private::TextureImpl *>>>::__construct_node<std::pair<std::pair<unsigned int,ProGL::ShareGroup> const,ProGL::Private::TextureImpl *>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  int v6 = operator new(0x38uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  v6[8] = *(_DWORD *)a2;
  __n128 result = ProGL::ShareGroup::ShareGroup((void *)v6 + 5, (void *)(a2 + 8));
  *((void *)v6 + 6) = *(void *)(a2 + 16);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1B795D6B0(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  operator delete(v2);
  _Unwind_Resume(a1);
}

void *std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::erase(int64x2_t *a1, char *a2, char *a3)
{
  uint64_t v4 = a1->i64[1];
  uint64_t v5 = (char *)(v4 + 8 * ((unint64_t)a1[2].i64[0] >> 9));
  if (a1[1].i64[0] == v4) {
    int v6 = 0;
  }
  else {
    int v6 = (char *)(*(void *)v5 + 8 * (a1[2].i64[0] & 0x1FF));
  }
  uint64_t v32 = (char **)(v4 + 8 * ((unint64_t)a1[2].i64[0] >> 9));
  uint64_t v33 = v6;
  if (v6 == a3) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = ((uint64_t)&a3[-*(void *)a2] >> 3) + ((a2 - v5) << 6) - ((uint64_t)&v6[-*(void *)v5] >> 3);
  }
  uint64_t v8 = (char **)std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>::operator+[abi:ne180100]((uint64_t)&v32, v7);
  unint64_t v10 = (unint64_t)v8;
  unint64_t v11 = (unint64_t)v9;
  uint64_t v12 = a1[2].i64[1];
  if (v7 <= (unint64_t)(v12 - 1) >> 1)
  {
    uint64_t v18 = v9 - *v8;
    uint64_t v19 = v18 >> 3;
    if (v18 < -7)
    {
      unint64_t v28 = 510 - v19;
      int64_t v21 = &v8[-(v28 >> 9)];
      PCSharedCount v22 = &(*v21)[8 * (~(_WORD)v28 & 0x1FF)];
    }
    else
    {
      unint64_t v20 = v19 + 1;
      int64_t v21 = &v8[v20 >> 9];
      PCSharedCount v22 = &(*v21)[8 * (v20 & 0x1FF)];
    }
    std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,0>(v32, v33, v8, v9, v21, v22, v34);
    a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1B7E73580);
    std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1, 1);
  }
  else
  {
    uint64_t v13 = v9 - *v8;
    uint64_t v14 = v13 >> 3;
    if (v13 < -7)
    {
      unint64_t v23 = 510 - v14;
      uint64_t v16 = &v8[-(v23 >> 9)];
      BOOL v17 = &(*v16)[8 * (~(_WORD)v23 & 0x1FF)];
    }
    else
    {
      unint64_t v15 = v14 + 1;
      uint64_t v16 = &v8[v15 >> 9];
      BOOL v17 = &(*v16)[8 * (v15 & 0x1FF)];
    }
    unint64_t v24 = a1[2].i64[0] + v12;
    uint64_t v25 = a1->i64[1];
    std::vector<unsigned int>::pointer v26 = (char **)(v25 + 8 * (v24 >> 9));
    if (a1[1].i64[0] == v25) {
      uint64_t v27 = 0;
    }
    else {
      uint64_t v27 = &(*v26)[8 * (v24 & 0x1FF)];
    }
    v34[0].n128_u64[0] = v10;
    v34[0].n128_u64[1] = v11;
    std::__for_each_segment[abi:ne180100]<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>>>(v16, v17, v26, v27, (uint64_t)v34);
    --a1[2].i64[1];
    std::deque<unsigned long>::__maybe_remove_back_spare[abi:ne180100](a1, 1);
  }
  uint64_t v29 = a1->i64[1];
  if (a1[1].i64[0] == v29) {
    uint64_t v30 = 0;
  }
  else {
    uint64_t v30 = *(void *)(v29 + 8 * ((unint64_t)a1[2].i64[0] >> 9)) + 8 * (a1[2].i64[0] & 0x1FF);
  }
  v34[0].n128_u64[0] = v29 + 8 * ((unint64_t)a1[2].i64[0] >> 9);
  v34[0].n128_u64[1] = v30;
  return std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>::operator+[abi:ne180100]((uint64_t)v34, v7);
}

void std::multimap<ProGL::TextureDescription,ProGL::Private::TextureImpl *,anonymous namespace'::CompareTextureDescription,std::allocator<std::pair<ProGL::TextureDescription const,ProGL::Private::TextureImpl *>>>::erase[abi:ne180100](uint64_t **a1, uint64_t *a2)
{
  int v3 = (uint64_t *)a2[1];
  if (v3)
  {
    do
    {
      uint64_t v4 = v3;
      int v3 = (uint64_t *)*v3;
    }
    while (v3);
  }
  else
  {
    uint64_t v5 = a2;
    do
    {
      uint64_t v4 = (uint64_t *)v5[2];
      BOOL v6 = *v4 == (void)v5;
      uint64_t v5 = v4;
    }
    while (!v6);
  }
  if (*a1 == a2) {
    *a1 = v4;
  }
  unint64_t v7 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v7, a2);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(a2 + 4));

  operator delete(a2);
}

void *std::__find_segment_if[abi:ne180100]<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__find_segment<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>,std::__identity>(void *result, void *a2, void **a3, void *a4, void *a5)
{
  if (result == a3)
  {
    if (a2 != a4)
    {
      while (*a2 != *a5)
      {
        if (++a2 == a4)
        {
          a2 = a4;
          break;
        }
      }
    }
    if (result && (void *)(*result + 4096) == a2) {
      ++result;
    }
  }
  else
  {
    uint64_t v5 = *result + 4096;
    if ((void *)v5 == a2) {
      goto LABEL_14;
    }
    while (*a2 != *a5)
    {
      if (++a2 == (void *)v5) {
        goto LABEL_14;
      }
    }
    if (a2 == (void *)v5)
    {
LABEL_14:
      BOOL v6 = result + 1;
      if (result + 1 == a3)
      {
        uint64_t v8 = result;
      }
      else
      {
        do
        {
          uint64_t v7 = 0;
          uint64_t v8 = v6;
          uint64_t v9 = *v6;
          do
          {
            if (*(void *)(v9 + v7) == *a5) {
              return v8;
            }
            v7 += 8;
          }
          while (v7 != 4096);
          BOOL v6 = v8 + 1;
        }
        while (v8 + 1 != a3);
      }
      if (*a3 == a4)
      {
        return a3;
      }
      else
      {
        unint64_t v10 = *a3;
        while (*v10 != *a5)
        {
          if (++v10 == a4)
          {
            unint64_t v10 = a4;
            break;
          }
        }
        __n128 result = a3;
        if (*a3 + 512 == v10) {
          return v8 + 2;
        }
      }
    }
  }
  return result;
}

void *std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>::operator+[abi:ne180100](uint64_t a1, uint64_t a2)
{
  __n128 result = *(void **)a1;
  if (a2)
  {
    uint64_t v4 = a2 + ((uint64_t)(*(void *)(a1 + 8) - *result) >> 3);
    if (v4 < 1) {
      result -= (unint64_t)(511 - v4) >> 9;
    }
    else {
      result += (unint64_t)v4 >> 9;
    }
  }
  return result;
}

uint64_t std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::__maybe_remove_front_spare[abi:ne180100](uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x200) {
    a2 = 1;
  }
  if (v2 < 0x400) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 512;
  }
  return v4 ^ 1u;
}

__n128 std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,0>@<Q0>(char **a1@<X1>, char *a2@<X2>, char **a3@<X3>, char *a4@<X4>, void *a5@<X5>, char *a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    uint64_t v19 = a2;
    uint64_t v18 = a4;
    unint64_t v15 = a5;
    uint64_t v16 = a6;
  }
  else
  {
    uint64_t v13 = a3 - 1;
    uint64_t v12 = *a3;
    uint64_t v14 = a4;
    unint64_t v15 = a5;
    uint64_t v16 = a6;
    while (1)
    {
      std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>(v12, v14, v15, v16, &v21);
      uint64_t v16 = (char *)v22.n128_u64[1];
      unint64_t v15 = (void *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      BOOL v17 = *v13--;
      uint64_t v12 = v17;
      uint64_t v14 = v17 + 4096;
    }
    uint64_t v18 = *a1 + 4096;
    uint64_t v19 = a2;
  }
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>(v19, v18, v15, v16, &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = (unint64_t)a4;
  a7[1] = result;
  return result;
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>@<X0>(char *a1@<X1>, char *a2@<X2>, void *a3@<X3>, char *a4@<X4>, void *a5@<X8>)
{
  BOOL v6 = a3;
  if (a1 == a2)
  {
    uint64_t v9 = a1;
  }
  else
  {
    uint64_t v9 = a2;
    uint64_t v10 = *a3;
    unint64_t v11 = a2;
    while (1)
    {
      uint64_t v12 = (uint64_t)&a4[-v10];
      if ((v11 - a1) >> 3 >= v12 >> 3) {
        uint64_t v13 = v12 >> 3;
      }
      else {
        uint64_t v13 = (v11 - a1) >> 3;
      }
      v11 -= 8 * v13;
      a4 -= 8 * v13;
      if (v13) {
        __n128 result = memmove(a4, v11, 8 * v13);
      }
      if (v11 == a1) {
        break;
      }
      uint64_t v15 = *--v6;
      uint64_t v10 = v15;
      a4 = (char *)(v15 + 4096);
    }
    if ((char *)(*v6 + 4096) == a4)
    {
      uint64_t v16 = (char *)v6[1];
      ++v6;
      a4 = v16;
    }
  }
  *a5 = v9;
  a5[1] = v6;
  a5[2] = a4;
  return result;
}

double std::__for_each_segment[abi:ne180100]<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>*,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>**,long,512l>>>(char **a1, char *__src, char **a3, char *a4, uint64_t a5)
{
  if (a1 == a3)
  {
    unint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
    uint64_t v10 = __src;
  }
  else
  {
    uint64_t v8 = a1 + 1;
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>(__src, *(char **)(a5 + 8), *a1 + 4096, *(void ***)a5, &v14);
    for (*(_OWORD *)a5 = v15; v8 != a3; *(_OWORD *)a5 = v15)
    {
      uint64_t v9 = *v8++;
      std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>(v9, *(char **)(a5 + 8), v9 + 4096, *(void ***)a5, &v14);
    }
    uint64_t v10 = *a3;
    unint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
  }
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>(v10, v12, a4, v11, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

char *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__deque_iterator<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> *,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>&,std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>> **,long,512l>,0>@<X0>(char *__src@<X0>, char *__dst@<X3>, char *a3@<X1>, void **a4@<X2>, char **a5@<X8>)
{
  BOOL v6 = a4;
  if (__src != a3)
  {
    uint64_t v9 = __src;
    BOOL v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      uint64_t v11 = v10 - __dst + 4096;
      uint64_t v12 = (a3 - v9) >> 3 >= v11 >> 3 ? v11 >> 3 : (a3 - v9) >> 3;
      if (v12) {
        __src = (char *)memmove(__dst, v9, 8 * v12);
      }
      v9 += 8 * v12;
      if (v9 == a3) {
        break;
      }
      uint64_t v13 = (char *)*v6++;
      uint64_t v10 = v13;
      __dst = v13;
    }
    __dst += 8 * v12;
    if ((char *)*(v6 - 1) + 4096 == __dst) {
      __dst = (char *)*v6;
    }
    else {
      --v6;
    }
  }
  *a5 = a3;
  a5[1] = (char *)v6;
  a5[2] = __dst;
  return __src;
}

void *std::vector<ProGL::Private::TextureImpl *>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<double>::__vallocate[abi:ne180100](a1, a2);
    int v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1B795DEEC(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__map_value_compare<ProGL::TextureDescription,std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,anonymous namespace'::CompareTextureDescription,true>,std::allocator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>>>::destroy(void *a1)
{
  if (a1)
  {
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(a1 + 4));
    operator delete(a1);
  }
}

ProGL::Private::TextureImpl *ProGL::Private::TextureImpl::TextureImpl(ProGL::Private::TextureImpl *this, ProGL::GL *a2)
{
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  ProGL::GL::getPGLContextHandle(a2, v9);
  ProGL::TextureDescription::TextureDescription((ProGL::Private::TextureImpl *)((char *)this + 24), (const ProGL::ContextHandle *)v9);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v9);
  *((void *)this + 23) = 0;
  *((void *)this + 22) = (char *)this + 184;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 13) = 0x260100000000;
  *((void *)this + 14) = 0xC47A00003F800000;
  *((_DWORD *)this + 30) = 1148846080;
  *(void *)((char *)this + 124) = 0x3E800000000;
  *((_DWORD *)this + 33) = 0;
  *((void *)this + 17) = 6409;
  *((_DWORD *)this + 36) = 515;
  *((unsigned char *)this + 148) = 0;
  *((_DWORD *)this + 38) = 1065353216;
  *((unsigned char *)this + 160) = 0;
  *((_DWORD *)this + 41) = 1;
  *((unsigned char *)this + 168) = 0;
  *((void *)this + 24) = 0;
  *((_WORD *)this + 100) = 0;
  *((unsigned char *)this + 202) = 0;
  *(void *)((char *)this + 212) = 0;
  *(void *)((char *)this + 204) = 0;
  *((_DWORD *)this + 57) = 0;
  *(void *)((char *)this + 220) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)((char *)this + 232) = _Q0;
  *((void *)this + 31) = 0;
  *((void *)this + 32) = 0;
  glGenTextures(1, (GLuint *)this + 5);
  return this;
}

void sub_1B795E084(_Unwind_Exception *a1)
{
  uint64_t v8 = *(std::__shared_weak_count **)(v1 + 256);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  PCCFRef<CGColorSpace *>::~PCCFRef(v5);
  std::__tree<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>>>::destroy(v4, *v6);
  ProGL::ContextHandle::~ContextHandle(v3);
  PCSpinLock::~PCSpinLock(v2);
  uint64_t v9 = *(std::__shared_weak_count **)(v1 + 8);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::TextureImpl::TextureImpl(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ProGL::ContextHandle *a9, void *a10)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = a2;
  ProGL::TextureDescription::TextureDescription((ProGL::TextureDescription *)(a1 + 24), a9);
  *(void *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 104) = 0x260100000000;
  *(void *)(a1 + 112) = 0xC47A00003F800000;
  *(_DWORD *)(a1 + 120) = 1148846080;
  *(void *)(a1 + 124) = 0x3E800000000;
  *(_DWORD *)(a1 + 132) = 0;
  *(void *)(a1 + 136) = 6409;
  *(_DWORD *)(a1 + 144) = 515;
  *(unsigned char *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 152) = 1065353216;
  *(unsigned char *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 164) = 1;
  *(unsigned char *)(a1 + 168) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 176) = a1 + 184;
  *(_WORD *)(a1 + 200) = 0;
  *(unsigned char *)(a1 + 202) = 0;
  *(void *)(a1 + 212) = 0;
  *(void *)(a1 + 204) = 0;
  *(_DWORD *)(a1 + 228) = 0;
  *(void *)(a1 + 220) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 232) = _Q0;
  uint64_t v22 = a10[1];
  *(void *)(a1 + 248) = *a10;
  *(void *)(a1 + 256) = v22;
  if (v22) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 44) = a3;
  *(_DWORD *)(a1 + 48) = a4;
  *(_DWORD *)(a1 + 52) = a5;
  *(_DWORD *)(a1 + 56) = a6;
  *(_DWORD *)(a1 + 60) = a7;
  *(_DWORD *)(a1 + 64) = a8;
  *(_DWORD *)(a1 + 72) = a8;
  return a1;
}

{
  return ProGL::Private::TextureImpl::TextureImpl(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

void sub_1B795E20C(_Unwind_Exception *a1)
{
  PCSpinLock::~PCSpinLock((PCSpinLock *)(v1 + 16));
  int v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::TextureImpl::getContext@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 32);
  *a2 = *(void *)(this + 24);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

BOOL ProGL::Private::TextureImpl::isExternallyOwned(ProGL::Private::TextureImpl *this)
{
  return *((void *)this + 31) != 0;
}

uint64_t ProGL::Private::TextureImpl::getTarget(ProGL::Private::TextureImpl *this)
{
  return *((unsigned int *)this + 11);
}

uint64_t ProGL::Private::TextureImpl::getWidth(ProGL::Private::TextureImpl *this)
{
  return *((unsigned int *)this + 12);
}

uint64_t ProGL::Private::TextureImpl::getHeight(ProGL::Private::TextureImpl *this)
{
  return *((unsigned int *)this + 13);
}

uint64_t ProGL::Private::TextureImpl::getBorder(ProGL::Private::TextureImpl *this)
{
  return *((unsigned int *)this + 15);
}

uint64_t ProGL::Private::TextureImpl::getActualInternalFormat(ProGL::Private::TextureImpl *this)
{
  return *((unsigned int *)this + 18);
}

unint64_t ProGL::Private::TextureImpl::getSize(ProGL::Private::TextureImpl *this)
{
  uint64_t v1 = *((int *)this + 51);
  if (!v1)
  {
    unsigned int v2 = *((_DWORD *)this + 13);
    if (v2 <= 0x80) {
      unsigned int v2 = 128;
    }
    uint64_t v3 = 6;
    if (*((_DWORD *)this + 11) != 34067) {
      uint64_t v3 = 1;
    }
    unint64_t v4 = ((*((int *)this + 12) + 127) & 0xFFFFFFFFFFFFFF80) * (int)v2 * *((int *)this + 14) * v3;
    if (*((unsigned char *)this + 201)
      || ProGL::Private::TextureParameters::getGenerateMipmap((ProGL::Private::TextureImpl *)((char *)this + 76)))
    {
      return 16 * v4 / 3;
    }
    else
    {
      return 4 * v4;
    }
  }
  return v1;
}

uint64_t ProGL::Private::TextureImpl::wantsPooling(ProGL::Private::TextureImpl *this)
{
  return *((unsigned __int8 *)this + 200);
}

uint64_t ProGL::Private::TextureImpl::setPooled(uint64_t this, char a2)
{
  if (!*(void *)(this + 248)) {
    *(unsigned char *)(this + 200) = a2;
  }
  return this;
}

uint64_t ProGL::Private::TextureImpl::getDescription(ProGL::Private::TextureImpl *this)
{
  return (uint64_t)this + 24;
}

void ProGL::Private::TextureImpl::detach(ProGL::Private::TextureImpl *this)
{
  if (*((_DWORD *)this + 5))
  {
    *((_DWORD *)this + 5) = 0;
    ProGL::TextureDescription::reset((ProGL::Private::TextureImpl *)((char *)this + 24));
    *((_DWORD *)this + 18) = 0;
    ProGL::Private::TextureParameters::reset((ProGL::Private::TextureImpl *)((char *)this + 76));
    *((unsigned char *)this + 168) = 0;
    *((unsigned char *)this + 200) = 0;
    if (!*((void *)this + 31))
    {
      uint64_t v3 = (void *)*((void *)this + 23);
      unsigned int v2 = (void *)((char *)this + 184);
      std::__tree<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>>>::destroy((uint64_t)(v2 - 1), v3);
      *(v2 - 1) = v2;
      *unsigned int v2 = 0;
      v2[1] = 0;
    }
  }
}

void ProGL::Private::TextureImpl::bind(ProGL::Private::TextureImpl *this, ProGL::GL *a2, GLenum target)
{
  *((_DWORD *)this + 11) = target;
}

void ProGL::Private::TextureImpl::unbind(ProGL::Private::TextureImpl *this, ProGL::GL *a2)
{
}

uint64_t ProGL::Private::TextureImpl::isBound(ProGL::Private::TextureImpl *this)
{
  return ProGL::Private::TextureParameters::isBound((ProGL::Private::TextureImpl *)((char *)this + 76));
}

void ProGL::Private::TextureImpl::texParameter(ProGL::Private::TextureImpl *this, ProGL::GL *a2, GLenum a3, GLint param)
{
  switch(a3)
  {
    case 0x2800u:
      BOOL v6 = (ProGL::Private::TextureImpl *)((char *)this + 76);
      GLenum v7 = *((_DWORD *)this + 11);
      ProGL::Private::TextureParameters::setMagFilter(v6, a2, v7, param);
      break;
    case 0x2801u:
      uint64_t v11 = (ProGL::Private::TextureImpl *)((char *)this + 76);
      GLenum v12 = *((_DWORD *)this + 11);
      ProGL::Private::TextureParameters::setMinFilter(v11, a2, v12, param);
      break;
    case 0x2802u:
      uint64_t v13 = (ProGL::Private::TextureImpl *)((char *)this + 76);
      GLenum v14 = *((_DWORD *)this + 11);
      ProGL::Private::TextureParameters::setWrapS(v13, a2, v14, param);
      break;
    case 0x2803u:
      long long v15 = (ProGL::Private::TextureImpl *)((char *)this + 76);
      GLenum v16 = *((_DWORD *)this + 11);
      ProGL::Private::TextureParameters::setWrapT(v15, a2, v16, param);
      break;
    default:
      if (a3 == 34046)
      {
        uint64_t v9 = (GLfloat *)((char *)this + 76);
        GLenum v10 = *((_DWORD *)this + 11);
        ProGL::Private::TextureParameters::setMaxAnisotropy(v9, a2, v10, (float)param);
      }
      else
      {
        BOOL v17 = (void *)MEMORY[0x1E4FBA250];
        int v18 = *(_DWORD *)(MEMORY[0x1E4FBA250] + *(void *)(*MEMORY[0x1E4FBA250] - 24) + 8);
        uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"ProGL::TextureHandle::texParameter(): unknown parameter passed (", 64);
        uint64_t v20 = *v19;
        *(_DWORD *)((char *)v19 + *(void *)(*v19 - 24) + 8) = *(_DWORD *)((unsigned char *)v19 + *(void *)(*v19 - 24) + 8) & 0xFFFFFFB5 | 8;
        *(_DWORD *)((char *)v19 + *(void *)(v20 - 24) + 8) |= 0x4000u;
        uint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"0x", 2);
        char v27 = 48;
        uint64_t v22 = std::operator<<[abi:ne180100]<std::char_traits<char>>(v21, &v27);
        *(void *)((char *)v22 + *(void *)(*v22 - 24) + 24) = 4;
        unint64_t v23 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"), not saved in parameter state, ", 33);
        if (ProGL::Private::TextureParameters::isBound((ProGL::Private::TextureImpl *)((char *)this + 76)))
        {
          glTexParameteri(*((_DWORD *)this + 11), a3, param);
          unint64_t v24 = (void *)MEMORY[0x1E4FBA250];
          uint64_t v25 = "just passed on to OpenGL.\n";
          uint64_t v26 = 26;
        }
        else
        {
          unint64_t v24 = (void *)MEMORY[0x1E4FBA250];
          uint64_t v25 = "just discarded.\n";
          uint64_t v26 = 16;
        }
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)v25, v26);
        *(_DWORD *)((char *)v17 + *(void *)(*v17 - 24) + 8) = v18;
      }
      break;
  }
}

void ProGL::Private::TextureImpl::texImage2D(ProGL::Private::TextureImpl *this, ProGL::GL *a2, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum a9, GLenum a10, GLvoid *pixels)
{
  if (!*((void *)this + 31))
  {
    if (target - 34069 >= 6) {
      GLenum v18 = target;
    }
    else {
      GLenum v18 = 34067;
    }
    glTexImage2D(target, level, internalformat, width, height, border, a9, a10, pixels);
    *((_DWORD *)this + 11) = v18;
    ProGL::GL::getPGLContextHandle(a2, v19);
    *((_DWORD *)this + 10) = ProGL::ContextHandle::getVirtualScreen((ProGL::ContextHandle *)v19);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v19);
    *((_DWORD *)this + 12) = width;
    *((_DWORD *)this + 13) = height;
    *((_DWORD *)this + 14) = 1;
    *((_DWORD *)this + 15) = border;
    *((_DWORD *)this + 16) = internalformat;
    *((_DWORD *)this + 18) = internalformat;
    if (level) {
      *((unsigned char *)this + 201) = 1;
    }
  }
}

void sub_1B795E7D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  _Unwind_Resume(a1);
}

uint64_t ProGL::getMaxNumberOfTexturesPerShareGroup(ProGL *this)
{
  return 100000;
}

uint64_t ProGL::Private::ProgramHelper::getProgramContext@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 24);
  *a2 = *(void *)(result + 16);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

ProGL::Private::VariableBase *ProGL::Private::VariableBase::VariableBase(ProGL::Private::VariableBase *this, ProGL::Program *a2)
{
  *(void *)this = &unk_1F10FAC98;
  *((void *)this + 1) = a2;
  ProGL::Private::VariableList::add((ProGL::Program *)((char *)a2 + 168), this);
  return this;
}

void ProGL::Private::VariableBase::~VariableBase(ProGL::Private::VariableBase *this)
{
  *(void *)this = &unk_1F10FAC98;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    ProGL::Private::VariableList::remove((ProGL::Private::VariableList *)(v1 + 168), this);
  }
}

{
  uint64_t v1;

  *(void *)this = &unk_1F10FAC98;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    ProGL::Private::VariableList::remove((ProGL::Private::VariableList *)(v1 + 168), this);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1F10FAC98;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    ProGL::Private::VariableList::remove((ProGL::Private::VariableList *)(v1 + 168), this);
  }

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProGL::Private::VariableBase::prepare(ProGL::Private::VariableBase *this, ProGL::GL *a2)
{
  return 1;
}

uint64_t ProGL::Private::VariableBase::isValidIn(ProGL::Private::VariableBase *this)
{
  return 1;
}

void ProGL::Private::VariableBase::getString(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void ProGL::Private::VariableList::add(ProGL::Private::VariableList *this, ProGL::Private::VariableBase *a2)
{
  uint64_t v4 = *(void *)this;
  uint64_t v5 = (ProGL::Private::VariableBase **)*((void *)this + 1);
  BOOL v6 = *(ProGL::Private::VariableBase ***)this;
  if (*(ProGL::Private::VariableBase ***)this != v5)
  {
    while (*v6 != a2)
    {
      if (++v6 == v5)
      {
        BOOL v6 = (ProGL::Private::VariableBase **)*((void *)this + 1);
        break;
      }
    }
  }
  if (v6 == v5)
  {
    GLenum v7 = (char *)this + 16;
    unint64_t v8 = *((void *)this + 2);
    if ((unint64_t)v5 >= v8)
    {
      uint64_t v10 = ((uint64_t)v5 - v4) >> 3;
      if ((unint64_t)(v10 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v11 = v8 - v4;
      uint64_t v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
        uint64_t v12 = v10 + 1;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      if (v13) {
        GLenum v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v7, v13);
      }
      else {
        GLenum v14 = 0;
      }
      long long v15 = &v14[8 * v10];
      GLenum v16 = &v14[8 * v13];
      *(void *)long long v15 = a2;
      uint64_t v9 = v15 + 8;
      GLenum v18 = *(char **)this;
      BOOL v17 = (char *)*((void *)this + 1);
      if (v17 != *(char **)this)
      {
        do
        {
          uint64_t v19 = *((void *)v17 - 1);
          v17 -= 8;
          *((void *)v15 - 1) = v19;
          v15 -= 8;
        }
        while (v17 != v18);
        BOOL v17 = *(char **)this;
      }
      *(void *)this = v15;
      *((void *)this + 1) = v9;
      *((void *)this + 2) = v16;
      if (v17) {
        operator delete(v17);
      }
    }
    else
    {
      uint64_t *v5 = a2;
      uint64_t v9 = v5 + 1;
    }
    uint64_t v21 = (char *)*((void *)this + 4);
    uint64_t v20 = (void *)((char *)this + 32);
    *(v20 - 3) = v9;
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy((uint64_t)(v20 - 1), v21);
    *(v20 - 1) = v20;
    *uint64_t v20 = 0;
    v20[1] = 0;
  }
}

void ProGL::Private::VariableList::remove(ProGL::Private::VariableList *this, ProGL::Private::VariableBase *a2)
{
  uint64_t v4 = *(ProGL::Private::VariableBase ***)this;
  uint64_t v3 = (ProGL::Private::VariableBase **)*((void *)this + 1);
  if (*(ProGL::Private::VariableBase ***)this != v3)
  {
    while (*v4 != a2)
    {
      if (++v4 == v3)
      {
        uint64_t v4 = (ProGL::Private::VariableBase **)*((void *)this + 1);
        break;
      }
    }
  }
  if (v4 != v3)
  {
    int64_t v5 = (char *)v3 - (char *)(v4 + 1);
    if (v3 != v4 + 1) {
      memmove(v4, v4 + 1, (char *)v3 - (char *)(v4 + 1));
    }
    GLenum v7 = (char *)*((void *)this + 4);
    BOOL v6 = (void *)((char *)this + 32);
    *(v6 - 3) = (char *)v4 + v5;
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy((uint64_t)(v6 - 1), v7);
    *(v6 - 1) = v6;
    *BOOL v6 = 0;
    v6[1] = 0;
  }
}

uint64_t **ProGL::Private::VariableList::getString(uint64_t **this, uint64_t a2)
{
  unsigned int v4 = a2;
  ProGL::Private::VariableList::makeSortedString((ProGL::Private::VariableList *)this, a2);
  int64_t v5 = &v4;
  return std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(this + 3, &v4, (uint64_t)&std::piecewise_construct, &v5)+ 5;
}

void ProGL::Private::VariableList::makeSortedString(ProGL::Private::VariableList *this, uint64_t a2)
{
  unsigned int v4 = (uint64_t **)((char *)this + 32);
  uint64_t v3 = (char *)*((void *)this + 4);
  if (!v3) {
    goto LABEL_12;
  }
  int64_t v5 = (uint64_t **)((char *)this + 32);
  do
  {
    unsigned int v6 = *((_DWORD *)v3 + 8);
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      unint64_t v8 = (char **)v3;
    }
    else {
      unint64_t v8 = (char **)(v3 + 8);
    }
    if (v7) {
      int64_t v5 = (uint64_t **)v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 == v4 || *((_DWORD *)v5 + 8) > a2)
  {
LABEL_12:
    unint64_t v15 = 0;
    unint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v9 = *(void **)this;
    uint64_t v10 = (void *)*((void *)this + 1);
    if (*(void **)this == v10)
    {
      unint64_t v12 = 0;
      unint64_t v11 = 0;
    }
    else
    {
      do
      {
        if ((*(unsigned int (**)(void, uint64_t))(*(void *)*v9 + 32))(*v9, a2)) {
          operator new();
        }
        ++v9;
      }
      while (v9 != v10);
      unint64_t v11 = v15;
      unint64_t v12 = v16;
    }
    v13[0] = 0;
    v13[1] = 0;
    uint64_t v14 = 0;
    LODWORD(v18) = a2;
    long long __p = *(_OWORD *)v13;
    uint64_t v20 = 0;
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::string>>(v4 - 1, (unsigned int *)&v18, (uint64_t)&v18);
    if (SHIBYTE(v20) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v14) < 0) {
      operator delete(v13[0]);
    }
    GLenum v18 = (void **)&v15;
    std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__destroy_vector::operator()[abi:ne180100](&v18);
  }
}

void sub_1B795EE6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  long long __p = &a16;
  std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

double ProGL::Program::Program(ProGL::Program *this)
{
  *(void *)this = &unk_1F10FACD8;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 25) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = (char *)this + 200;
  *((unsigned char *)this + 216) = 1;
  return result;
}

void ProGL::Program::~Program(ProGL::Program *this)
{
  *(void *)this = &unk_1F10FACD8;
  if (*((_DWORD *)this + 2)) {
    operator new();
  }
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy((uint64_t)this + 192, *((char **)this + 25));
  uint64_t v2 = (void *)*((void *)this + 21);
  if (v2)
  {
    *((void *)this + 22) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 20);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  unsigned int v4 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  if (*((char *)this + 135) < 0) {
    operator delete(*((void **)this + 14));
  }
  if (*((char *)this + 111) < 0) {
    operator delete(*((void **)this + 11));
  }
  if (*((char *)this + 87) < 0) {
    operator delete(*((void **)this + 8));
  }
  if (*((char *)this + 63) < 0) {
    operator delete(*((void **)this + 5));
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::Program *)((char *)this + 16));
}

{
  uint64_t vars8;

  ProGL::Program::~Program(this);

  JUMPOUT(0x1BA9BFBA0);
}

void sub_1B795F0F0(void *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  __clang_call_terminate(a1);
}

void ProGL::Program::setFragmentSource(ProGL::Program *this, const char *a2)
{
}

void ProGL::Program::setFragmentSource()
{
}

uint64_t ProGL::Program::build(ProGL::Program *this, ProGL::GL *a2)
{
  if (*((char *)this + 87) < 0) {
    uint64_t v4 = *((void *)this + 9);
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)this + 87);
  }
  if (v4)
  {
    String = ProGL::Private::VariableList::getString((uint64_t **)this + 21, 35633);
    if (*((char *)String + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v68, (const std::string::value_type *)*String, (std::string::size_type)String[1]);
    }
    else
    {
      long long v6 = *(_OWORD *)String;
      v68.__r_.__value_.__r.__words[2] = (std::string::size_type)String[2];
      *(_OWORD *)&v68.__r_.__value_.__l.__data_ = v6;
    }
    memset(&v67, 0, sizeof(v67));
    std::string::operator=(&v67, (const std::string *)((char *)this + 40));
    if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v8 = &v68;
    }
    else {
      unint64_t v8 = (std::string *)v68.__r_.__value_.__r.__words[0];
    }
    if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v68.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v68.__r_.__value_.__l.__size_;
    }
    std::string::append(&v67, (const std::string::value_type *)v8, size);
    int v10 = *((char *)this + 135);
    if (v10 >= 0) {
      unint64_t v11 = (char *)this + 112;
    }
    else {
      unint64_t v11 = (const std::string::value_type *)*((void *)this + 14);
    }
    if (v10 >= 0) {
      std::string::size_type v12 = *((unsigned __int8 *)this + 135);
    }
    else {
      std::string::size_type v12 = *((void *)this + 15);
    }
    std::string::append(&v67, v11, v12);
    int v13 = *((char *)this + 87);
    if (v13 >= 0) {
      uint64_t v14 = (char *)this + 64;
    }
    else {
      uint64_t v14 = (const std::string::value_type *)*((void *)this + 8);
    }
    if (v13 >= 0) {
      std::string::size_type v15 = *((unsigned __int8 *)this + 87);
    }
    else {
      std::string::size_type v15 = *((void *)this + 9);
    }
    std::string::append(&v67, v14, v15);
    if ((v67.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v16 = &v67;
    }
    else {
      unint64_t v16 = (std::string *)v67.__r_.__value_.__r.__words[0];
    }
    long long v17 = v66;
    long long v66 = 0uLL;
    GLenum v18 = (std::__shared_weak_count *)*((void *)this + 18);
    *(_OWORD *)((char *)this + 136) = v17;
    if (v18)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v18);
      if (*((void *)&v66 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v66 + 1));
      }
    }
    BOOL v19 = ProGL::Private::Shader::good(*((ProGL::Private::Shader **)this + 17));
    if (!v19)
    {
      uint64_t v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"Error compiling vertex shader. log is:\n", 39);
      uint64_t RootChannel = OZStyle::getRootChannel(*((OZStyle **)this + 17));
      int v22 = *(char *)(RootChannel + 23);
      if (v22 >= 0) {
        uint64_t v23 = RootChannel;
      }
      else {
        uint64_t v23 = *(void *)RootChannel;
      }
      if (v22 >= 0) {
        uint64_t v24 = *(unsigned __int8 *)(RootChannel + 23);
      }
      else {
        uint64_t v24 = *(void *)(RootChannel + 8);
      }
      uint64_t v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, v23, v24);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"\n", 1);
    }
    if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v67.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v68.__r_.__value_.__l.__data_);
      if (!v19) {
        goto LABEL_118;
      }
    }
    else if (!v19)
    {
      goto LABEL_118;
    }
  }
  else
  {
    BOOL v7 = (std::__shared_weak_count *)*((void *)this + 18);
    *((void *)this + 17) = 0;
    *((void *)this + 18) = 0;
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  if (*((char *)this + 111) < 0)
  {
    if (*((void *)this + 12))
    {
LABEL_50:
      uint64_t v26 = ProGL::Private::VariableList::getString((uint64_t **)this + 21, 35632);
      if (*((char *)v26 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v68, (const std::string::value_type *)*v26, (std::string::size_type)v26[1]);
      }
      else
      {
        long long v27 = *(_OWORD *)v26;
        v68.__r_.__value_.__r.__words[2] = (std::string::size_type)v26[2];
        *(_OWORD *)&v68.__r_.__value_.__l.__data_ = v27;
      }
      memset(&v67, 0, sizeof(v67));
      std::string::operator=(&v67, (const std::string *)((char *)this + 40));
      if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v29 = &v68;
      }
      else {
        uint64_t v29 = (std::string *)v68.__r_.__value_.__r.__words[0];
      }
      if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v30 = HIBYTE(v68.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v30 = v68.__r_.__value_.__l.__size_;
      }
      std::string::append(&v67, (const std::string::value_type *)v29, v30);
      int v31 = *((char *)this + 135);
      if (v31 >= 0) {
        uint64_t v32 = (char *)this + 112;
      }
      else {
        uint64_t v32 = (const std::string::value_type *)*((void *)this + 14);
      }
      if (v31 >= 0) {
        std::string::size_type v33 = *((unsigned __int8 *)this + 135);
      }
      else {
        std::string::size_type v33 = *((void *)this + 15);
      }
      std::string::append(&v67, v32, v33);
      int v34 = *((char *)this + 111);
      if (v34 >= 0) {
        uint64_t v35 = (char *)this + 88;
      }
      else {
        uint64_t v35 = (const std::string::value_type *)*((void *)this + 11);
      }
      if (v34 >= 0) {
        std::string::size_type v36 = *((unsigned __int8 *)this + 111);
      }
      else {
        std::string::size_type v36 = *((void *)this + 12);
      }
      std::string::append(&v67, v35, v36);
      if ((v67.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        char v37 = &v67;
      }
      else {
        char v37 = (std::string *)v67.__r_.__value_.__r.__words[0];
      }
      long long v38 = v66;
      long long v66 = 0uLL;
      unsigned int v39 = (std::__shared_weak_count *)*((void *)this + 20);
      *(_OWORD *)((char *)this + 152) = v38;
      if (v39)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v39);
        if (*((void *)&v66 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v66 + 1));
        }
      }
      BOOL v40 = ProGL::Private::Shader::good(*((ProGL::Private::Shader **)this + 19));
      if (!v40)
      {
        signed int v41 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"Error compiling fragment shader. log is:\n", 41);
        uint64_t v42 = OZStyle::getRootChannel(*((OZStyle **)this + 19));
        int v43 = *(char *)(v42 + 23);
        if (v43 >= 0) {
          uint64_t v44 = v42;
        }
        else {
          uint64_t v44 = *(void *)v42;
        }
        if (v43 >= 0) {
          uint64_t v45 = *(unsigned __int8 *)(v42 + 23);
        }
        else {
          uint64_t v45 = *(void *)(v42 + 8);
        }
        uint64_t v46 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, v44, v45);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v46, (uint64_t)"\n", 1);
      }
      if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v67.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v68.__r_.__value_.__l.__data_);
        if (v40) {
          goto LABEL_94;
        }
      }
      else if (v40)
      {
        goto LABEL_94;
      }
LABEL_118:
      char v56 = 0;
      return v56 & 1;
    }
  }
  else if (*((unsigned char *)this + 111))
  {
    goto LABEL_50;
  }
  unint64_t v28 = (std::__shared_weak_count *)*((void *)this + 20);
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  if (v28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  }
LABEL_94:
  ProGL::GL::getPGLContextHandle(a2, &v68);
  ProGL::ContextHandle::operator=((void *)this + 2, (uint64_t *)&v68);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v68);
  *((_DWORD *)this + 8) = ProGL::ContextHandle::getVirtualScreen((ProGL::Program *)((char *)this + 16));
  GLuint Program = glCreateProgram();
  *((_DWORD *)this + 2) = Program;
  double v48 = (HGRenderQueue *)*((void *)this + 17);
  if (v48)
  {
    GLuint DebugQueueVerboseMask = HGRenderQueue::GetDebugQueueVerboseMask(v48);
    glAttachShader(Program, DebugQueueVerboseMask);
    GLuint Program = *((_DWORD *)this + 2);
  }
  double v50 = (HGRenderQueue *)*((void *)this + 19);
  if (v50)
  {
    GLuint v51 = HGRenderQueue::GetDebugQueueVerboseMask(v50);
    glAttachShader(Program, v51);
    GLuint Program = *((_DWORD *)this + 2);
  }
  glLinkProgram(Program);
  GLuint v52 = *((_DWORD *)this + 2);
  LODWORD(v68.__r_.__value_.__l.__data_) = 0;
  glGetProgramiv(v52, 0x8B82u, (GLint *)&v68);
  if (!LODWORD(v68.__r_.__value_.__l.__data_))
  {
    GLuint v61 = *((_DWORD *)this + 2);
    LODWORD(v68.__r_.__value_.__l.__data_) = 0;
    glGetProgramiv(v61, 0x8B84u, (GLint *)&v68);
    LODWORD(v67.__r_.__value_.__l.__data_) = v68.__r_.__value_.__l.__data_;
    if (SLODWORD(v68.__r_.__value_.__l.__data_) < 2)
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"Error linking program object; error unknown.",
        44);
    }
    else
    {
      std::vector<char>::vector((std::vector<char> *)&v68, LODWORD(v68.__r_.__value_.__l.__data_));
      glGetProgramInfoLog(*((_DWORD *)this + 2), LODWORD(v68.__r_.__value_.__r.__words[1]) - LODWORD(v68.__r_.__value_.__l.__data_), (GLsizei *)&v67, v68.__r_.__value_.__l.__data_);
      int64x2_t v62 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"Error linking program object. log is:\n", 38);
      size_t v63 = strlen(v68.__r_.__value_.__l.__data_);
      uint64_t v64 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v62, (uint64_t)v68.__r_.__value_.__l.__data_, v63);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v64, (uint64_t)"\n", 1);
      if (v68.__r_.__value_.__r.__words[0])
      {
        v68.__r_.__value_.__l.__size_ = v68.__r_.__value_.__r.__words[0];
        operator delete(v68.__r_.__value_.__l.__data_);
      }
    }
    goto LABEL_118;
  }
  uint64_t v53 = (void *)*((void *)this + 21);
  double v54 = (void *)*((void *)this + 22);
  if (v53 == v54)
  {
    char v56 = 1;
  }
  else
  {
    double v55 = (void *)MEMORY[0x1E4FBA240];
    char v56 = 1;
    do
    {
      if (((*(uint64_t (**)(void, ProGL::GL *))(*(void *)*v53 + 16))(*v53, a2) & 1) == 0)
      {
        int32x4_t v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v55, (uint64_t)"Error setting up program variable: ", 35);
        (*(void (**)(std::string *__return_ptr))(*(void *)*v53 + 40))(&v68);
        if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          float32x4_t v58 = &v68;
        }
        else {
          float32x4_t v58 = (std::string *)v68.__r_.__value_.__r.__words[0];
        }
        if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v59 = HIBYTE(v68.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v59 = v68.__r_.__value_.__l.__size_;
        }
        int64x2_t v60 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)v58, v59);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v60, (uint64_t)"\n", 1);
        if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v68.__r_.__value_.__l.__data_);
        }
        char v56 = 0;
      }
      ++v53;
    }
    while (v53 != v54);
  }
  return v56 & 1;
}

void sub_1B795F79C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ProGL::Program::use(ProGL::Program *this, ProGL::GL *a2)
{
  if (*((unsigned char *)this + 216)) {
    glUseProgram(*((_DWORD *)this + 2));
  }
}

void ProGL::Program::unuse(ProGL::Program *this, ProGL::GL *a2)
{
  if (*((unsigned char *)this + 216)) {
    glUseProgram(0);
  }
}

uint64_t ProGL::Private::ProgramHandleImpl::ProgramHandleImpl(uint64_t result, void *a2, int a3)
{
  *(_DWORD *)double result = 0;
  if (a3 <= 1) {
    int v3 = 1;
  }
  else {
    int v3 = a3;
  }
  *(_DWORD *)(result + 8) = v3;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)(result + 40) = 0;
  *(void *)(result + 16) = result + 24;
  uint64_t v4 = a2[1];
  *(void *)(result + 48) = *a2;
  *(void *)(result + 56) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t ProGL::Private::ProgramHandleImpl::prepareProgram(os_unfair_lock_s *this, ProGL::GL *a2, int a3)
{
  os_unfair_lock_t lock = this;
  PCSpinLock::lock(this);
  ProGL::GL::getPGLContextHandle(a2, &v22);
  v21[0] = v22;
  v21[1] = v23;
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
  }
  long long v6 = this + 4;
  BOOL v7 = (os_unfair_lock_s *)std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::find<ProGL::Private::ProgramHandleImpl::ContextKey>((uint64_t)&this[4], (ProGL::ContextHandle *)v21);
  unint64_t v8 = (char *)&this[6];
  if (&this[6] == v7)
  {
    uint64_t v9 = 0;
    long long v20 = 0uLL;
LABEL_9:
    (***(void (****)(long long *__return_ptr))&this[12]._os_unfair_lock_opaque)(&v19);
    unint64_t v11 = (int *)&this[2];
    long long v12 = v19;
    long long v19 = 0uLL;
    long long v20 = v12;
    if (v9)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
      if (*((void *)&v19 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v19 + 1));
      }
    }
    ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::add(v11, v21, (uint64_t *)&v20);
    uint64_t v10 = v20;
    goto LABEL_13;
  }
  uint64_t v9 = *(std::__shared_weak_count **)&v7[14]._os_unfair_lock_opaque;
  ++*(void *)&v7[16]._os_unfair_lock_opaque;
  uint64_t v10 = *(void *)&v7[12]._os_unfair_lock_opaque;
  *(void *)&long long v20 = v10;
  *((void *)&v20 + 1) = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v10) {
    goto LABEL_9;
  }
LABEL_13:
  if (!*(unsigned char *)(v10 + 216))
  {
    uint64_t v13 = 0;
    goto LABEL_30;
  }
  if (*(_DWORD *)(v10 + 8))
  {
    uint64_t v13 = 1;
  }
  else
  {
    uint64_t v13 = ProGL::Program::build((ProGL::Program *)v10, a2);
    *(unsigned char *)(v10 + 216) = v13;
    if (!v13) {
      goto LABEL_30;
    }
  }
  if (a3)
  {
    (*(void (**)(void, ProGL::GL *))(*(void *)v20 + 16))(v20, a2);
    uint64_t v14 = *(char **)&v6->_os_unfair_lock_opaque;
    if (*(char **)&v6->_os_unfair_lock_opaque != v8)
    {
      while (*((void *)v14 + 6) != (void)v20)
      {
        std::string::size_type v15 = (char *)*((void *)v14 + 1);
        if (v15)
        {
          do
          {
            unint64_t v16 = v15;
            std::string::size_type v15 = *(char **)v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            unint64_t v16 = (char *)*((void *)v14 + 2);
            BOOL v17 = *(void *)v16 == (void)v14;
            uint64_t v14 = v16;
          }
          while (!v17);
        }
        uint64_t v14 = v16;
        if (v16 == v8) {
          goto LABEL_29;
        }
      }
      v14[72] = 0;
    }
LABEL_29:
    uint64_t v13 = 1;
  }
LABEL_30:
  if (*((void *)&v20 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v20 + 1));
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v21);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v22);
  if (lock) {
    PCSpinLock::unlock(lock);
  }
  return v13;
}

void sub_1B795FA8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t a6, ...)
{
  va_start(va2, a6);
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  if (a5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a5);
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va1);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va2);
  _Unwind_Resume(a1);
}

void ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::add(int *a1, unint64_t *a2, uint64_t *a3)
{
  long long v6 = (uint64_t **)(a1 + 2);
  if (*((void *)a1 + 3) >= (unint64_t)*a1)
  {
    uint64_t v7 = (uint64_t *)(a1 + 4);
    do
    {
      unint64_t v8 = *v6;
      if (*v6 == v7) {
        break;
      }
      uint64_t v9 = (uint64_t *)(a1 + 4);
      do
      {
        if (*((unsigned char *)v8 + 72))
        {
          uint64_t v10 = v8;
          if (v9 != v7)
          {
            if (v8[8] >= (unint64_t)v9[8]) {
              uint64_t v10 = v9;
            }
            else {
              uint64_t v10 = v8;
            }
          }
        }
        else
        {
          uint64_t v10 = v9;
        }
        unint64_t v11 = (uint64_t *)v8[1];
        if (v11)
        {
          do
          {
            uint64_t v12 = v11;
            unint64_t v11 = (uint64_t *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            uint64_t v12 = (uint64_t *)v8[2];
            BOOL v13 = *v12 == (void)v8;
            unint64_t v8 = v12;
          }
          while (!v13);
        }
        uint64_t v9 = v10;
        unint64_t v8 = v12;
      }
      while (v12 != v7);
      if (v10 == v7) {
        break;
      }
      std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(v6, v10);
      std::pair<ProGL::Private::ProgramHandleImpl::ContextKey const,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>::~pair((ProGL::ContextHandle *)(v10 + 4));
      operator delete(v10);
    }
    while (*((void *)a1 + 3) >= (unint64_t)*a1);
  }
  uint64_t v14 = *((void *)a1 + 4) + 1;
  *((void *)a1 + 4) = v14;
  uint64_t v16 = *a3;
  std::string::size_type v15 = (std::__shared_weak_count *)a3[1];
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v17 = a2[1];
  v20.n128_u64[0] = *a2;
  v20.n128_u64[1] = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v21 = v16;
  unint64_t v22 = v15;
  uint64_t v23 = v14;
  char v24 = 1;
  std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__emplace_unique_key_args<ProGL::Private::ProgramHandleImpl::ContextKey,std::pair<ProGL::Private::ProgramHandleImpl::ContextKey const,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>(v6, (ProGL::ContextHandle *)&v20, &v20);
  char v19 = v18;
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v20);
  if ((v19 & 1) == 0) {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"The inserted item is already present in the map, which shouldn't happen.\n", 73);
  }
}

void sub_1B795FC60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ProGL::Private::ProgramHandleImpl::unuse(ProGL::Private::ProgramHandleImpl *this, ProGL::GL *a2)
{
  os_unfair_lock_t lock = (os_unfair_lock_t)this;
  PCSpinLock::lock((os_unfair_lock_t)this);
  ProGL::GL::getPGLContextHandle(a2, &v14);
  v13[0] = v14;
  v13[1] = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = (char **)((char *)this + 16);
  int64_t v5 = std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::find<ProGL::Private::ProgramHandleImpl::ContextKey>((uint64_t)this + 16, (ProGL::ContextHandle *)v13);
  long long v6 = (char *)this + 24;
  if ((void *)((char *)this + 24) == v5)
  {
    uint64_t v8 = 0;
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = (std::__shared_weak_count *)v5[7];
    ++v5[8];
    uint64_t v8 = v5[6];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  (*(void (**)(uint64_t, ProGL::GL *))(*(void *)v8 + 24))(v8, a2);
  uint64_t v9 = *v4;
  if (*v4 == v6) {
    goto LABEL_19;
  }
  while (*((void *)v9 + 6) != v8)
  {
    uint64_t v10 = (char *)*((void *)v9 + 1);
    if (v10)
    {
      do
      {
        unint64_t v11 = v10;
        uint64_t v10 = *(char **)v10;
      }
      while (v10);
    }
    else
    {
      do
      {
        unint64_t v11 = (char *)*((void *)v9 + 2);
        BOOL v12 = *(void *)v11 == (void)v9;
        uint64_t v9 = v11;
      }
      while (!v12);
    }
    uint64_t v9 = v11;
    if (v11 == v6) {
      goto LABEL_19;
    }
  }
  if (v9[72])
  {
LABEL_19:
    if (!v7) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if (*((void *)this + 4) < (unint64_t)*((int *)this + 2))
  {
    v9[72] = 1;
    goto LABEL_19;
  }
  std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)this + 2, (uint64_t *)v9);
  std::pair<ProGL::Private::ProgramHandleImpl::ContextKey const,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>::~pair((ProGL::ContextHandle *)(v9 + 32));
  operator delete(v9);
  if (v7) {
LABEL_20:
  }
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
LABEL_21:
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v13);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v14);
  if (lock) {
    PCSpinLock::unlock(lock);
  }
}

void sub_1B795FE18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va1);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va2);
  _Unwind_Resume(a1);
}

void ProGL::Private::ProgramHandleImpl::getProgram(os_unfair_lock_s *this@<X0>, ProGL::GL *a2@<X1>, void *a3@<X8>)
{
  unint64_t v11 = this;
  PCSpinLock::lock(this);
  ProGL::GL::getPGLContextHandle(a2, &v9);
  v8[0] = v9;
  v8[1] = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (os_unfair_lock_s *)std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::find<ProGL::Private::ProgramHandleImpl::ContextKey>((uint64_t)&this[4], (ProGL::ContextHandle *)v8);
  if (&this[6] == v6)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    ++*(void *)&v6[16]._os_unfair_lock_opaque;
    uint64_t v7 = *(void *)&v6[14]._os_unfair_lock_opaque;
    *a3 = *(void *)&v6[12]._os_unfair_lock_opaque;
    a3[1] = v7;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v8);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v9);
  if (this) {
    PCSpinLock::unlock(this);
  }
}

void sub_1B795FF20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va1);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va2);
  _Unwind_Resume(a1);
}

uint64_t ProGL::ProgramHandle::use(os_unfair_lock_s **this, ProGL::GL *a2)
{
  uint64_t v2 = *this;
  if (v2)
  {
    return ProGL::Private::ProgramHandleImpl::prepareProgram(v2, a2, 1);
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"Can't use an empty program handle.\n", 35);
    return 0;
  }
}

void ProGL::ProgramHandle::unuse(ProGL::Private::ProgramHandleImpl **this, ProGL::GL *a2)
{
  uint64_t v2 = *this;
  if (v2) {
    ProGL::Private::ProgramHandleImpl::unuse(v2, a2);
  }
  else {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"Can't unuse an empty program handle.\n", 37);
  }
}

ProGL::UseProgramSentry *ProGL::UseProgramSentry::UseProgramSentry(ProGL::UseProgramSentry *this, ProGL::GL *a2, const ProGL::ProgramHandle *a3)
{
  uint64_t v5 = ProGL::GL::GL(this, a2);
  uint64_t v6 = *((void *)a3 + 1);
  *(void *)(v5 + 40) = *(void *)a3;
  *(void *)(v5 + 48) = v6;
  uint64_t v7 = (os_unfair_lock_s **)(v5 + 40);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  ProGL::ProgramHandle::use(v7, this);
  return this;
}

void sub_1B7960010(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)*((void *)v1 + 6);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  ProGL::GL::~GL(v1);
  _Unwind_Resume(a1);
}

void ProGL::UseProgramSentry::~UseProgramSentry(ProGL::Private::ProgramHandleImpl **this)
{
  ProGL::ProgramHandle::unuse(this + 5, (ProGL::GL *)this);
  uint64_t v2 = (std::__shared_weak_count *)this[6];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  ProGL::GL::~GL((ProGL::GL *)this);
}

void ProGL::Private::initProgram(ProGL::Private *this)
{
}

void sub_1B79600CC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1020C400CA8E147);
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::cleanUpProgram(ProGL::Private *this)
{
  {
    PCSpinLock::~PCSpinLock(v1);
    uint64_t result = MEMORY[0x1BA9BFBA0]();
  }
  return result;
}

void anonymous namespace'::DeleteProgramInstruction::~DeleteProgramInstruction(OZChannelBase *this)
{
  this->var0 = (void **)&unk_1F10FAD28;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);

  OZChannelBase::setRangeName(this, v2);
}

{
  const PCString *v2;
  uint64_t vars8;

  this->var0 = (void **)&unk_1F10FAD28;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);
  OZChannelBase::setRangeName(this, v2);

  JUMPOUT(0x1BA9BFBA0);
}

void anonymous namespace'::DeleteProgramInstruction::execute(_anonymous_namespace_::DeleteProgramInstruction *this)
{
  ProGL::getDeletionContext((os_unfair_lock_s **)this + 2, (const ProGL::ContextHandle *)*((unsigned int *)this + 8), (ProGL::ContextHandle *)v2);
  ProGL::GL::GL((ProGL::GL *)v3, (const ProGL::ContextHandle *)v2);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v2);
  glDeleteProgram(*((_DWORD *)this + 2));
  ProGL::GL::~GL((ProGL::GL *)v3);
}

void sub_1B796025C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(a1, *((void *)a2 + 1));
    if (a2[63] < 0) {
      operator delete(*((void **)a2 + 5));
    }
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>,0>(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (*(char *)(a1 + 39) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 16);
    operator delete(v3);
  }
}

uint64_t **std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    unint64_t v11 = operator new(0x40uLL);
    v11[8] = **a4;
    *((void *)v11 + 6) = 0;
    *((void *)v11 + 7) = 0;
    *((void *)v11 + 5) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

void std::shared_ptr<std::string>::shared_ptr[abi:ne180100]<std::string,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B79604CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    std::default_delete<std::string>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<std::string *,std::shared_ptr<std::string>::__shared_ptr_default_delete<std::string,std::string>,std::allocator<std::string>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<std::string *,std::shared_ptr<std::string>::__shared_ptr_default_delete<std::string,std::string>,std::allocator<std::string>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::default_delete<std::string>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    JUMPOUT(0x1BA9BFBA0);
  }
}

uint64_t std::vector<std::shared_ptr<std::string>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<std::string>>,std::reverse_iterator<std::shared_ptr<std::string>*>,std::reverse_iterator<std::shared_ptr<std::string>*>,std::reverse_iterator<std::shared_ptr<std::string>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<std::string>>,std::reverse_iterator<std::shared_ptr<std::string>*>,std::reverse_iterator<std::shared_ptr<std::string>*>,std::reverse_iterator<std::shared_ptr<std::string>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<std::string>>,std::reverse_iterator<std::shared_ptr<std::string>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<std::string>>,std::reverse_iterator<std::shared_ptr<std::string>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TXTextObject>>,std::reverse_iterator<std::shared_ptr<TXTextObject>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::__introsort<std::_ClassicAlgPolicy,anonymous namespace'::StrPtrLess &,std::shared_ptr<std::string> *,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
BOOL anonymous namespace'::StrPtrLess::operator()(const void ***a1, const void ***a2)
{
  int v2 = *((char *)*a2 + 23);
  int v3 = *((char *)*a1 + 23);
  if (v3 >= 0) {
    size_t v4 = *((unsigned __int8 *)*a1 + 23);
  }
  else {
    size_t v4 = (size_t)(*a1)[1];
  }
  if (v3 >= 0) {
    BOOL v5 = *a1;
  }
  else {
    BOOL v5 = **a1;
  }
  if (v2 >= 0) {
    size_t v6 = *((unsigned __int8 *)*a2 + 23);
  }
  else {
    size_t v6 = (size_t)(*a2)[1];
  }
  if (v2 >= 0) {
    uint64_t v7 = *a2;
  }
  else {
    uint64_t v7 = **a2;
  }
  if (v6 >= v4) {
    size_t v8 = v4;
  }
  else {
    size_t v8 = v6;
  }
  int v9 = memcmp(v5, v7, v8);
  if (v9) {
    return v9 < 0;
  }
  else {
    return v4 < v6;
  }
}

BOOL std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,anonymous namespace'::StrPtrLess &,std::shared_ptr<std::string> *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
  {
    uint64_t v11 = *(const void ***)a4;
    *(void *)a4 = *(void *)a5;
    *(void *)a5 = v11;
    uint64_t v12 = *(void *)(a4 + 8);
    *(void *)(a4 + 8) = *(void *)(a5 + 8);
    *(void *)(a5 + 8) = v12;
    if (result)
    {
      uint64_t v13 = *(const void ***)a3;
      *(void *)a3 = *(void *)a4;
      *(void *)a4 = v13;
      uint64_t v14 = *(void *)(a3 + 8);
      *(void *)(a3 + 8) = *(void *)(a4 + 8);
      *(void *)(a4 + 8) = v14;
      if (result)
      {
        unint64_t v15 = *(const void ***)a2;
        *(void *)a2 = *(void *)a3;
        *(void *)a3 = v15;
        uint64_t v16 = *(void *)(a2 + 8);
        *(void *)(a2 + 8) = *(void *)(a3 + 8);
        *(void *)(a3 + 8) = v16;
        if (result)
        {
          long long v17 = *(const void ***)a1;
          *(void *)a1 = *(void *)a2;
          *(void *)a2 = v17;
          uint64_t v18 = *(void *)(a1 + 8);
          *(void *)(a1 + 8) = *(void *)(a2 + 8);
          *(void *)(a2 + 8) = v18;
        }
      }
    }
  }
  return result;
}

BOOL std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,anonymous namespace'::StrPtrLess &,std::shared_ptr<std::string> *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (v6)
  {
    size_t v8 = *(const void ***)a1;
    if (result)
    {
      *(void *)a1 = *(void *)a3;
      *(void *)a3 = v8;
      int v9 = (uint64_t *)(a3 + 8);
      uint64_t v10 = (uint64_t *)(a1 + 8);
    }
    else
    {
      *(void *)a1 = *(void *)a2;
      *(void *)a2 = v8;
      uint64_t v15 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)(a2 + 8) = v15;
      if (!result) {
        return result;
      }
      uint64_t v16 = *(const void ***)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v16;
      int v9 = (uint64_t *)(a3 + 8);
      uint64_t v10 = (uint64_t *)(a2 + 8);
    }
    uint64_t v13 = v9;
    goto LABEL_10;
  }
  if (result)
  {
    uint64_t v11 = *(const void ***)a2;
    *(void *)a2 = *(void *)a3;
    *(void *)a3 = v11;
    uint64_t v13 = (uint64_t *)(a2 + 8);
    uint64_t v12 = *(void *)(a2 + 8);
    *(void *)(a2 + 8) = *(void *)(a3 + 8);
    *(void *)(a3 + 8) = v12;
    if (result)
    {
      uint64_t v14 = *(const void ***)a1;
      *(void *)a1 = *(void *)a2;
      uint64_t v10 = (uint64_t *)(a1 + 8);
      *(void *)a2 = v14;
LABEL_10:
      uint64_t v17 = *v10;
      *uint64_t v10 = *v13;
      *uint64_t v13 = v17;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,anonymous namespace'::StrPtrLess &,std::shared_ptr<std::string> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      {
        BOOL v6 = *(const void ***)a1;
        *(void *)a1 = *(void *)(a2 - 16);
        *(void *)(a2 - 16) = v6;
        uint64_t v7 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v7;
      }
      return 1;
    case 3:
      return 1;
    case 4:
      return 1;
    case 5:
      return 1;
    default:
      size_t v8 = (const void ***)(a1 + 32);
      uint64_t v9 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    {
      long long v20 = *(_OWORD *)v9;
      *(void *)uint64_t v9 = 0;
      *(void *)(v9 + 8) = 0;
      uint64_t v12 = v10;
      while (1)
      {
        uint64_t v13 = a1 + v12;
        long long v14 = *(_OWORD *)(a1 + v12 + 32);
        *(void *)(v13 + 32) = 0;
        *(void *)(v13 + 40) = 0;
        uint64_t v15 = *(std::__shared_weak_count **)(a1 + v12 + 56);
        *(_OWORD *)(v13 + 48) = v14;
        if (v15) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v15);
        }
        if (v12 == -32) {
          break;
        }
        v12 -= 16;
        if (!v16)
        {
          uint64_t v17 = a1 + v12 + 48;
          goto LABEL_14;
        }
      }
      uint64_t v17 = a1;
LABEL_14:
      long long v18 = v20;
      long long v20 = 0uLL;
      unint64_t v19 = *(std::__shared_weak_count **)(v17 + 8);
      *(_OWORD *)uint64_t v17 = v18;
      if (v19) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v19);
      }
      if (*((void *)&v20 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v20 + 1));
      }
      if (++v11 == 8) {
        return v9 + 16 == a2;
      }
    }
    size_t v8 = (const void ***)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2) {
      return 1;
    }
  }
}

BOOL std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,anonymous namespace'::StrPtrLess &,std::shared_ptr<std::string> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    uint64_t v9 = *(const void ***)a3;
    *(void *)a3 = *(void *)a4;
    *(void *)a4 = v9;
    uint64_t v10 = *(void *)(a3 + 8);
    *(void *)(a3 + 8) = *(void *)(a4 + 8);
    *(void *)(a4 + 8) = v10;
    if (result)
    {
      int v11 = *(const void ***)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v11;
      uint64_t v12 = *(void *)(a2 + 8);
      *(void *)(a2 + 8) = *(void *)(a3 + 8);
      *(void *)(a3 + 8) = v12;
      if (result)
      {
        uint64_t v13 = *(const void ***)a1;
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v13;
        uint64_t v14 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = *(void *)(a2 + 8);
        *(void *)(a2 + 8) = v14;
      }
    }
  }
  return result;
}

uint64_t **std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::string>>(uint64_t **a1, unsigned int *a2, uint64_t a3)
{
  BOOL v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        size_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9) {
          break;
        }
        BOOL v5 = *v8;
        BOOL v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      BOOL v5 = v8[1];
      if (!v5)
      {
        BOOL v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    size_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (char *)operator new(0x40uLL);
    *((_DWORD *)v10 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v10 + 40) = *(_OWORD *)(a3 + 8);
    *((void *)v10 + 7) = *(void *)(a3 + 24);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, (uint64_t)v8, v6, (uint64_t *)v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void std::__shared_ptr_pointer<anonymous namespace'::DeleteProgramInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::DeleteProgramInstruction>,std::allocator<anonymous namespace'::DeleteProgramInstruction>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<anonymous namespace'::DeleteProgramInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::DeleteProgramInstruction>,std::allocator<anonymous namespace'::DeleteProgramInstruction>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<anonymous namespace'::DeleteProgramInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::DeleteProgramInstruction>,std::allocator<anonymous namespace'::DeleteProgramInstruction>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::find<ProGL::Private::ProgramHandleImpl::ContextKey>(uint64_t a1, ProGL::ContextHandle *a2)
{
  int v3 = (void *)(a1 + 8);
  uint64_t v4 = std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__lower_bound<ProGL::Private::ProgramHandleImpl::ContextKey>(a1, a2, *(void **)(a1 + 8), (void *)(a1 + 8));
  if (v3 == v4) {
    return v3;
  }
  BOOL v5 = v4;
  BOOL v6 = (ProGL::ContextHandle *)(v4 + 4);
  unint64_t EAGLContext = ProGL::ContextHandle::getEAGLContext(a2);
  if (EAGLContext < ProGL::ContextHandle::getEAGLContext(v6)) {
    return v3;
  }
  return v5;
}

void *std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__lower_bound<ProGL::Private::ProgramHandleImpl::ContextKey>(uint64_t a1, ProGL::ContextHandle *a2, void *a3, void *a4)
{
  if (a3)
  {
    BOOL v5 = a3;
    do
    {
      unint64_t EAGLContext = ProGL::ContextHandle::getEAGLContext((ProGL::ContextHandle *)(v5 + 4));
      unint64_t v8 = ProGL::ContextHandle::getEAGLContext(a2);
      unsigned int v9 = v5 + 1;
      if (EAGLContext >= v8)
      {
        unsigned int v9 = v5;
        a4 = v5;
      }
      BOOL v5 = (void *)*v9;
    }
    while (*v9);
  }
  return a4;
}

void std::pair<ProGL::Private::ProgramHandleImpl::ContextKey const,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>::~pair(ProGL::ContextHandle *this)
{
  int v2 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  ProGL::ContextHandle::~ContextHandle(this);
}

uint64_t *std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__emplace_unique_key_args<ProGL::Private::ProgramHandleImpl::ContextKey,std::pair<ProGL::Private::ProgramHandleImpl::ContextKey const,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>(uint64_t **a1, ProGL::ContextHandle *this, __n128 *a3)
{
  BOOL v5 = (uint64_t **)std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__find_equal<ProGL::Private::ProgramHandleImpl::ContextKey>((uint64_t)a1, &v10, this);
  BOOL v6 = *v5;
  if (!*v5)
  {
    unsigned int v7 = v5;
    std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__construct_node<std::pair<ProGL::Private::ProgramHandleImpl::ContextKey const,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>((uint64_t)a1, a3, (uint64_t)v9);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v7, v9[0]);
    BOOL v6 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,void *>>>>::reset[abi:ne180100]((uint64_t *)v9, 0);
  }
  return v6;
}

void *std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__find_equal<ProGL::Private::ProgramHandleImpl::ContextKey>(uint64_t a1, void *a2, ProGL::ContextHandle *this)
{
  BOOL v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        unsigned int v7 = v4;
        unint64_t v8 = (ProGL::ContextHandle *)(v4 + 4);
        unint64_t EAGLContext = ProGL::ContextHandle::getEAGLContext(this);
        if (EAGLContext >= ProGL::ContextHandle::getEAGLContext(v8)) {
          break;
        }
        uint64_t v4 = (void *)*v7;
        BOOL v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      unint64_t v10 = ProGL::ContextHandle::getEAGLContext(v8);
      if (v10 >= ProGL::ContextHandle::getEAGLContext(this)) {
        break;
      }
      BOOL v5 = v7 + 1;
      uint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    unsigned int v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

__n128 std::__tree<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,std::__map_value_compare<ProGL::Private::ProgramHandleImpl::ContextKey,std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,ProGL::Private::ProgramHandleImpl::LessContextKey,true>,std::allocator<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>>::__construct_node<std::pair<ProGL::Private::ProgramHandleImpl::ContextKey const,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>>@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  BOOL v6 = (__n128 *)operator new(0x50uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  unint64_t v7 = a2->n128_u64[1];
  v6[2].n128_u64[0] = a2->n128_u64[0];
  v6[2].n128_u64[1] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = a2[1];
  v6[3] = result;
  a2[1].n128_u64[0] = 0;
  a2[1].n128_u64[1] = 0;
  v6[4].n128_u64[0] = a2[2].n128_u64[0];
  v6[4].n128_u8[8] = a2[2].n128_u8[8];
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::Private::ProgramHandleImpl::ContextKey,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>,void *>>>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16)) {
      std::pair<ProGL::Private::ProgramHandleImpl::ContextKey const,ProGL::Private::SimpleCache<ProGL::Private::ProgramHandleImpl::ContextKey,std::shared_ptr<ProGL::Program>,ProGL::Private::ProgramHandleImpl::LessContextKey>::Rec>::~pair((ProGL::ContextHandle *)(v2 + 32));
    }
    operator delete((void *)v2);
  }
}

ProGL::Private::Shader *ProGL::Private::Shader::Shader(ProGL::Private::Shader *this, ProGL::GL *a2, unsigned int a3, const char *a4)
{
  BOOL v6 = (ProGL::ContextHandle *)(ProGL::Private::ShaderString::ShaderString(this, a3, a4) + 48);
  ProGL::GL::getPGLContextHandle(a2, v6);
  *((_DWORD *)this + 16) = ProGL::ContextHandle::getVirtualScreen(v6);
  *(void *)((char *)this + 68) = 0;
  *(void *)((char *)this + 84) = 0;
  *(void *)((char *)this + 76) = 0;
  *((_DWORD *)this + 23) = 0;
  ProGL::Private::Shader::compile(this, v7);
  return this;
}

void sub_1B7961A10(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 95) < 0) {
    operator delete(*(void **)(v1 + 72));
  }
  ProGL::ContextHandle::~ContextHandle(v2);
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*(void **)(v1 + 8));
  }
  _Unwind_Resume(a1);
}

void ProGL::Private::Shader::compile(ProGL::Private::Shader *this, ProGL::GL *a2)
{
  GLenum Size = PVPerfStats::FrameStats::GetSize(this);
  *((_DWORD *)this + 17) = glCreateShader(Size);
  string = (GLchar *)ProGL::Private::ShaderString::c_str(this);
  glShaderSource(*((_DWORD *)this + 17), 1, (const GLchar *const *)&string, 0);
  glCompileShader(*((_DWORD *)this + 17));
  GLuint v4 = *((_DWORD *)this + 17);
  LODWORD(params.__begin_) = 0;
  glGetShaderiv(v4, 0x8B81u, (GLint *)&params);
  if (!LODWORD(params.__begin_))
  {
    GLuint v5 = *((_DWORD *)this + 17);
    LODWORD(params.__begin_) = 0;
    glGetShaderiv(v5, 0x8B84u, (GLint *)&params);
    GLsizei length = (GLsizei)params.__begin_;
    if (SLODWORD(params.__begin_) < 2)
    {
      MEMORY[0x1BA9BF660]((char *)this + 72, "Shader compile() member function failed; error unknown.");
    }
    else
    {
      std::vector<char>::vector(&params, LODWORD(params.__begin_));
      glGetShaderInfoLog(*((_DWORD *)this + 17), LODWORD(params.__end_) - LODWORD(params.__begin_), &length, params.__begin_);
      std::string::__assign_trivial[abi:ne180100]<std::__wrap_iter<char *>,std::__wrap_iter<char *>>((std::string *)this + 3, params.__begin_, params.__end_, params.__end_ - params.__begin_);
      if (params.__begin_)
      {
        params.__end_ = params.__begin_;
        operator delete(params.__begin_);
      }
    }
    operator new();
  }
}

void sub_1B7961BC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  _Unwind_Resume(exception_object);
}

void std::shared_ptr<ProGL::DeletionInstruction>::shared_ptr[abi:ne180100]<anonymous namespace'::DeleteShaderInstruction,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B7961C58(_Unwind_Exception *exception_object)
{
  if (v1) {
  _Unwind_Resume(exception_object);
  }
}

void ProGL::Private::Shader::~Shader(ProGL::Private::Shader *this)
{
  if (*((_DWORD *)this + 17)) {
    operator new();
  }
  if (*((char *)this + 95) < 0) {
    operator delete(*((void **)this + 9));
  }
  ProGL::ContextHandle::~ContextHandle((ProGL::Private::Shader *)((char *)this + 48));
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

BOOL ProGL::Private::Shader::good(ProGL::Private::Shader *this)
{
  if (*((char *)this + 95) < 0) {
    uint64_t v1 = *((void *)this + 10);
  }
  else {
    uint64_t v1 = *((unsigned __int8 *)this + 95);
  }
  return v1 == 0;
}

void ProGL::Private::makeShader(ProGL::Private *this, ProGL::GL *a2, unsigned int a3, const char *a4)
{
}

void sub_1B7961DE8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1032C40C2FE074CLL);
  _Unwind_Resume(a1);
}

void anonymous namespace'::DeleteShaderInstruction::~DeleteShaderInstruction(OZChannelBase *this)
{
  this->var0 = (void **)&unk_1F10FAE58;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);

  OZChannelBase::setRangeName(this, v2);
}

{
  const PCString *v2;
  uint64_t vars8;

  this->var0 = (void **)&unk_1F10FAE58;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);
  OZChannelBase::setRangeName(this, v2);

  JUMPOUT(0x1BA9BFBA0);
}

void anonymous namespace'::DeleteShaderInstruction::execute(_anonymous_namespace_::DeleteShaderInstruction *this)
{
  ProGL::getDeletionContext((os_unfair_lock_s **)this + 2, (const ProGL::ContextHandle *)*((unsigned int *)this + 8), (ProGL::ContextHandle *)v2);
  ProGL::GL::GL((ProGL::GL *)v3, (const ProGL::ContextHandle *)v2);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v2);
  glDeleteShader(*((_DWORD *)this + 2));
  ProGL::GL::~GL((ProGL::GL *)v3);
}

void sub_1B7961F24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

void std::string::__assign_trivial[abi:ne180100]<std::__wrap_iter<char *>,std::__wrap_iter<char *>>(std::string *this, std::string::value_type *a2, std::string::value_type *a3, std::string::size_type a4)
{
  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    unint64_t v8 = this;
    if (a4 <= 0x16) {
      goto LABEL_11;
    }
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    std::string::size_type v10 = 22;
    goto LABEL_6;
  }
  unint64_t v11 = this->__r_.__value_.__r.__words[2];
  std::string::size_type v10 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v10 < a4)
  {
    std::string::size_type size = this->__r_.__value_.__l.__size_;
LABEL_6:
    std::string::__grow_by(this, v10, a4 - v10, size, 0, size, 0);
    this->__r_.__value_.__l.__size_ = 0;
    LOBYTE(v12) = *((unsigned char *)&this->__r_.__value_.__s + 23);
    goto LABEL_8;
  }
  unint64_t v12 = HIBYTE(v11);
LABEL_8:
  unint64_t v8 = this;
  if ((v12 & 0x80) != 0) {
    unint64_t v8 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
LABEL_11:
  while (a2 != a3)
  {
    std::string::value_type v13 = *a2++;
    v8->__r_.__value_.__s.__data_[0] = v13;
    unint64_t v8 = (std::string *)((char *)v8 + 1);
  }
  v8->__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
    this->__r_.__value_.__l.__size_ = a4;
  }
  else {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = a4 & 0x7F;
  }
}

void std::__shared_ptr_pointer<anonymous namespace'::DeleteShaderInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::DeleteShaderInstruction>,std::allocator<anonymous namespace'::DeleteShaderInstruction>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<anonymous namespace'::DeleteShaderInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::DeleteShaderInstruction>,std::allocator<anonymous namespace'::DeleteShaderInstruction>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<anonymous namespace'::DeleteShaderInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::DeleteShaderInstruction>,std::allocator<anonymous namespace'::DeleteShaderInstruction>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::shared_ptr<ProGL::Private::Shader>::shared_ptr[abi:ne180100]<ProGL::Private::Shader,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B796213C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<ProGL::Private::Shader>::reset[abi:ne180100]((ProGL::Private::Shader **)va, 0);
  _Unwind_Resume(a1);
}

ProGL::Private::Shader *std::__shared_ptr_pointer<ProGL::Private::Shader *,std::shared_ptr<ProGL::Private::Shader>::__shared_ptr_default_delete<ProGL::Private::Shader,ProGL::Private::Shader>,std::allocator<ProGL::Private::Shader>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(ProGL::Private::Shader **)(a1 + 24);
  if (result)
  {
    ProGL::Private::Shader::~Shader(result);
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<ProGL::Private::Shader *,std::shared_ptr<ProGL::Private::Shader>::__shared_ptr_default_delete<ProGL::Private::Shader,ProGL::Private::Shader>,std::allocator<ProGL::Private::Shader>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

ProGL::Private::Shader *std::unique_ptr<ProGL::Private::Shader>::reset[abi:ne180100](ProGL::Private::Shader **a1, ProGL::Private::Shader *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    ProGL::Private::Shader::~Shader(result);
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

uint64_t std::shared_ptr<ProGL::DeletionInstruction>::shared_ptr[abi:ne180100]<anonymous namespace'::DeleteShaderInstruction,void>(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

uint64_t ProGL::Private::ShaderCache::ShaderCache(uint64_t this)
{
  *(void *)(this + 16) = 0;
  *(_DWORD *)this = 0;
  *(void *)(this + 8) = this + 16;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 24) = 0;
  return this;
}

void ProGL::Private::ShaderCache::find(ProGL::Private::ShaderCache *this@<X0>, ProGL::GL *a2@<X1>, const char *a3@<X3>, ProGL::GL *a4@<X2>, void *a5@<X8>)
{
  ProGL::GL::getPGLContextHandle(a2, &v15);
  ProGL::ContextHandle::getShareGroup(&v15, v16);
  ProGL::ShareGroup::ShareGroup(&v17, v16);
  ProGL::Private::ShaderString::ShaderString((ProGL::Private::ShaderString *)v18, a4, a3);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v15);
  *a5 = 0;
  a5[1] = 0;
  v16[3].var0 = (PC_Sp_counted_base *)this;
  PCSpinLock::lock((os_unfair_lock_t)this);
  std::string::size_type v10 = std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::find<ProGL::Private::ShaderCache::Key>((uint64_t)this + 8, &v17);
  if ((void *)((char *)this + 16) == v10) {
    ProGL::Private::makeShader(a2, a4, a3, v11);
  }
  uint64_t v12 = *((void *)this + 4);
  *((void *)this + 4) = v12 + 1;
  v10[13] = v12;
  uint64_t v14 = v10[11];
  uint64_t v13 = v10[12];
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *a5 = v14;
  a5[1] = v13;
  ProGL::Private::ShaderCache::maybePurge(this);
  PCSpinLock::unlock((os_unfair_lock_t)this);
  if (v19 < 0) {
    operator delete(v18[1]);
  }
}

void sub_1B7962424(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  BOOL v16 = va_arg(va1, std::__shared_weak_count *);
  uint64_t v17 = va_arg(va1, void);
  std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>::~pair((uint64_t)va);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va1);
  if (*(char *)(v2 - 65) < 0) {
    operator delete(*(void **)(v2 - 88));
  }
  _Unwind_Resume(a1);
}

uint64_t std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>::~pair(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void ProGL::Private::ShaderCache::maybePurge(ProGL::Private::ShaderCache *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = *((void *)this + 5);
  if (v3 > v2)
  {
    unint64_t v4 = *((void *)this + 4);
    if (v4 >= 2 * v2)
    {
      GLuint v5 = (uint64_t *)*((void *)this + 1);
      uint64_t v6 = (uint64_t *)((char *)this + 16);
      if (v5 != (uint64_t *)((char *)this + 16))
      {
        unint64_t v7 = v4 - 2 * v2;
        do
        {
          uint64_t v8 = v5[12];
          if (v8 && *(uint64_t *)(v8 + 8) > 0 || v5[13] > v7)
          {
            uint64_t v9 = (uint64_t *)v5[1];
            if (v9)
            {
              do
              {
                uint64_t v10 = v9;
                uint64_t v9 = (uint64_t *)*v9;
              }
              while (v9);
            }
            else
            {
              do
              {
                uint64_t v10 = (uint64_t *)v5[2];
                BOOL v11 = *v10 == (void)v5;
                GLuint v5 = v10;
              }
              while (!v11);
            }
          }
          else
          {
            uint64_t v12 = (uint64_t *)v5[1];
            uint64_t v13 = v5;
            if (v12)
            {
              do
              {
                uint64_t v10 = v12;
                uint64_t v12 = (uint64_t *)*v12;
              }
              while (v12);
            }
            else
            {
              do
              {
                uint64_t v10 = (uint64_t *)v13[2];
                BOOL v11 = *v10 == (void)v13;
                uint64_t v13 = v10;
              }
              while (!v11);
            }
            std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)this + 1, v5);
            std::__destroy_at[abi:ne180100]<std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>,0>((uint64_t)(v5 + 4));
            operator delete(v5);
          }
          GLuint v5 = v10;
        }
        while (v10 != v6);
      }
    }
    unint64_t v3 = 0;
  }
  *((void *)this + 5) = v3 + 1;
}

uint64_t std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>::pair[abi:ne180100]<ProGL::Private::ShaderCache::Key&,ProGL::Private::ShaderCache::Value&,0>(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = ProGL::ShareGroup::ShareGroup((void *)a1, (void *)a2);
  *((_DWORD *)v6 + 2) = *(_DWORD *)(a2 + 8);
  unint64_t v7 = (std::string *)(v6 + 2);
  if (*(char *)(a2 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 16);
    v7->__r_.__value_.__r.__words[2] = *(void *)(a2 + 32);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  uint64_t v9 = a3[1];
  *(void *)(a1 + 56) = *a3;
  *(void *)(a1 + 64) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = a3[2];
  return a1;
}

void *std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::find<ProGL::Private::ShaderCache::Key>(uint64_t a1, void *a2)
{
  unint64_t v3 = (void *)(a1 + 8);
  unint64_t v4 = std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__lower_bound<ProGL::Private::ShaderCache::Key>(a1, a2, *(void **)(a1 + 8), (void *)(a1 + 8));
  if (v3 == v4) {
    return v3;
  }
  GLuint v5 = v4;
  if (ProGL::operator<(a2, v4 + 4) || ProGL::Private::operator<((uint64_t)(a2 + 1), (uint64_t)(v5 + 5))) {
    return v3;
  }
  return v5;
}

void *std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__lower_bound<ProGL::Private::ShaderCache::Key>(uint64_t a1, void *a2, void *a3, void *a4)
{
  if (a3)
  {
    GLuint v5 = a3;
    uint64_t v7 = (uint64_t)(a2 + 1);
    do
    {
      if (ProGL::operator<(v5 + 4, a2) || ProGL::Private::operator<((uint64_t)(v5 + 5), v7)) {
        ++v5;
      }
      else {
        a4 = v5;
      }
      GLuint v5 = (void *)*v5;
    }
    while (v5);
  }
  return a4;
}

uint64_t *std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__emplace_unique_key_args<ProGL::Private::ShaderCache::Key,std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>>(uint64_t **a1, void *a2, uint64_t a3)
{
  GLuint v5 = (uint64_t **)std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__find_equal<ProGL::Private::ShaderCache::Key>((uint64_t)a1, &v10, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = v5;
    std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__construct_node<std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>>((uint64_t)a1, a3, (uint64_t)v9);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v7, v9[0]);
    uint64_t v6 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,void *>>>>::reset[abi:ne180100]((uint64_t)v9, 0);
  }
  return v6;
}

void *std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__find_equal<ProGL::Private::ShaderCache::Key>(uint64_t a1, void *a2, void *a3)
{
  GLuint v5 = (void *)(a1 + 8);
  unint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = (uint64_t)(a3 + 1);
    do
    {
      while (1)
      {
        long long v8 = v4;
        uint64_t v9 = v4 + 4;
        if (!ProGL::operator<(a3, v4 + 4) && !ProGL::Private::operator<(v7, (uint64_t)(v8 + 5))) {
          break;
        }
        unint64_t v4 = (void *)*v8;
        GLuint v5 = v8;
        if (!*v8) {
          goto LABEL_12;
        }
      }
      if (!ProGL::operator<(v9, a3) && !ProGL::Private::operator<((uint64_t)(v8 + 5), v7)) {
        break;
      }
      GLuint v5 = v8 + 1;
      unint64_t v4 = (void *)v8[1];
    }
    while (v4);
  }
  else
  {
    long long v8 = (void *)(a1 + 8);
  }
LABEL_12:
  *a2 = v8;
  return v5;
}

uint64_t std::__tree<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::__map_value_compare<ProGL::Private::ShaderCache::Key,std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,std::less<ProGL::Private::ShaderCache::Key>,true>,std::allocator<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>>>::__construct_node<std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x70uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>::pair[abi:ne180100]((uint64_t)v6 + 32, a2);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1B7962928(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>::pair[abi:ne180100](uint64_t a1, uint64_t a2)
{
  unint64_t v4 = ProGL::ShareGroup::ShareGroup((void *)a1, (void *)a2);
  *((_DWORD *)v4 + 2) = *(_DWORD *)(a2 + 8);
  uint64_t v5 = (std::string *)(v4 + 2);
  if (*(char *)(a2 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 16);
    v5->__r_.__value_.__r.__words[2] = *(void *)(a2 + 32);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<ProGL::Private::ShaderCache::Key,ProGL::Private::ShaderCache::Value>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<ProGL::Private::ShaderCache::Key const,ProGL::Private::ShaderCache::Value>,0>((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

ProGL::Private::ShaderString *ProGL::Private::ShaderString::ShaderString(ProGL::Private::ShaderString *this, int a2, char *__s)
{
  unint64_t v3 = __s;
  *(_DWORD *)this = a2;
  uint64_t v5 = (ProGL::Private::ShaderString *)((char *)this + 32);
  std::string::basic_string[abi:ne180100]<0>((void *)this + 1, __s);
  PCWorkingColorVector::PCWorkingColorVector(v5);
  std::vector<unsigned char>::vector(&__p, 4uLL);
  *(_DWORD *)long long __p = *(_DWORD *)this;
  char v6 = *v3;
  if (*v3)
  {
    uint64_t v7 = v22;
    do
    {
      if (v7 >= v23)
      {
        unint64_t v9 = (unint64_t)__p;
        uint64_t v10 = v7 - (unsigned char *)__p;
        uint64_t v11 = v7 - (unsigned char *)__p + 1;
        if (v11 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v12 = v23 - (unsigned char *)__p;
        if (2 * (v23 - (unsigned char *)__p) > (unint64_t)v11) {
          uint64_t v11 = 2 * v12;
        }
        if (v12 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v13 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v13 = v11;
        }
        if (v13) {
          uint64_t v14 = (char *)operator new(v13);
        }
        else {
          uint64_t v14 = 0;
        }
        uint64_t v15 = &v14[v10];
        BOOL v16 = &v14[v10];
        *BOOL v16 = v6;
        long long v8 = v16 + 1;
        if (v7 != (char *)v9)
        {
          uint64_t v17 = &v7[~v9];
          do
          {
            char v18 = *--v7;
            (v17--)[(void)v14] = v18;
          }
          while (v7 != (char *)v9);
          uint64_t v7 = (char *)__p;
          uint64_t v15 = v14;
        }
        long long __p = v15;
        unint64_t v22 = v8;
        uint64_t v23 = &v14[v13];
        if (v7) {
          operator delete(v7);
        }
      }
      else
      {
        *uint64_t v7 = v6;
        long long v8 = v7 + 1;
      }
      unint64_t v22 = v8;
      int v19 = *++v3;
      char v6 = v19;
      uint64_t v7 = v8;
    }
    while (v19);
  }
  else
  {
    LODWORD(v8) = v22;
  }
  PCHash128::addData((int8x8_t *)v5, (const unsigned __int8 *)__p, (v8 - __p));
  if (__p)
  {
    unint64_t v22 = (char *)__p;
    operator delete(__p);
  }
  return this;
}

void sub_1B7962BB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  if (*(char *)(v11 + 31) < 0) {
    operator delete(*a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ProGL::Private::ShaderString::c_str(ProGL::Private::ShaderString *this)
{
  uint64_t result = (uint64_t)this + 8;
  if (*((char *)this + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

BOOL ProGL::Private::operator<(uint64_t a1, uint64_t a2)
{
  return operator<((const PCHash128 *)(a1 + 32), (const PCHash128 *)(a2 + 32));
}

void ProGL::Private::uploadUniform(ProGL::Private *this, GLint location, GLint x)
{
}

void ProGL::Private::uploadUniform(ProGL::Private *this, GLint location, GLfloat a3)
{
}

void ProGL::Private::uploadUniform(int a1, GLint location, GLfloat *a3)
{
}

void ProGL::Private::uploadUniform(int a1, GLint location, GLfloat *value)
{
}

ProGL::Framebuffer *ProGL::Framebuffer::Framebuffer(ProGL::Framebuffer *this)
{
  ProGL::getCurrentContext(this);
  *((void *)this + 4) = 0;
  *((void *)this + 3) = (char *)this + 32;
  *((void *)this + 5) = 0;
  ProGL::GL::GL((ProGL::GL *)v3, this);
  glGenFramebuffers(1, (GLuint *)this + 4);
  ProGL::GL::~GL((ProGL::GL *)v3);
  return this;
}

void sub_1B7962CC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ProGL::GL::~GL((ProGL::GL *)va);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v3, *((void **)v2 + 4));
  ProGL::ContextHandle::~ContextHandle(v2);
  _Unwind_Resume(a1);
}

ProGL::Framebuffer *ProGL::Framebuffer::Framebuffer(ProGL::Framebuffer *this, ProGL::GL *a2)
{
  *((void *)this + 4) = 0;
  *((void *)this + 3) = (char *)this + 32;
  *((void *)this + 5) = 0;
  glGenFramebuffers(1, (GLuint *)this + 4);
  return this;
}

void sub_1B7962D54(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v2, *((void **)v1 + 4));
  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

void ProGL::Framebuffer::~Framebuffer(GLuint *this)
{
  ProGL::GL::GL((ProGL::GL *)v2, (const ProGL::ContextHandle *)this);
  glDeleteFramebuffers(1, this + 4);
  ProGL::GL::~GL((ProGL::GL *)v2);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)(this + 6), *((void **)this + 4));
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)this);
}

void ProGL::Framebuffer::bind(ProGL::Framebuffer *this, ProGL::GL *a2, GLenum target)
{
}

void ProGL::Framebuffer::unbind(ProGL::Framebuffer *this, ProGL::GL *a2, GLenum target)
{
}

uint64_t *ProGL::Framebuffer::attach(uint64_t **this, ProGL::GL *a2, GLenum a3, GLenum a4, ProGL::Private::TextureImpl **a5, GLint a6)
{
  GLenum Target = ProGL::TextureHandle::getTarget(a5);
  GLuint Name = ProGL::TextureHandle::getName(a5);

  return ProGL::Framebuffer::attach(this, v12, a3, a4, Target, Name, a6);
}

uint64_t *ProGL::Framebuffer::attach(uint64_t **this, ProGL::GL *a2, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  GLenum v10 = attachment;
  if (textarget - 34069 < 6 || textarget == 3553) {
    glFramebufferTexture2D(target, attachment, textarget, texture, level);
  }
  uint64_t v11 = &v10;
  uint64_t result = std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(this + 3, &v10, (uint64_t)&std::piecewise_construct, &v11);
  *((_DWORD *)result + 8) = textarget;
  return result;
}

uint64_t *ProGL::Framebuffer::attach(uint64_t a1, int a2, GLenum a3, GLenum a4, HGGLBlendingInfo **this)
{
  GLenum v10 = a4;
  GLuint Name = ProGL::TextureHandle::getName(this);
  glFramebufferRenderbuffer(a3, a4, 0x8D41u, Name);
  uint64_t v11 = &v10;
  uint64_t result = std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>((uint64_t **)(a1 + 24), &v10, (uint64_t)&std::piecewise_construct, &v11);
  *((_DWORD *)result + 8) = 36161;
  return result;
}

void ProGL::Framebuffer::detach(ProGL::Framebuffer *this, ProGL::GL *a2, GLenum target, GLenum attachment)
{
  char v6 = (char *)*((void *)this + 4);
  unint64_t v4 = (char *)this + 32;
  uint64_t v5 = v6;
  if (v6)
  {
    uint64_t v7 = (uint64_t **)(v4 - 8);
    long long v8 = v4;
    do
    {
      GLenum v9 = *((_DWORD *)v5 + 7);
      BOOL v10 = v9 >= attachment;
      if (v9 >= attachment) {
        uint64_t v11 = (char **)v5;
      }
      else {
        uint64_t v11 = (char **)(v5 + 8);
      }
      if (v10) {
        long long v8 = v5;
      }
      uint64_t v5 = *v11;
    }
    while (*v11);
    if (v8 != v4 && *((_DWORD *)v8 + 7) <= attachment)
    {
      int v12 = *((_DWORD *)v8 + 8);
      if (v12 == 36161)
      {
        glFramebufferRenderbuffer(target, attachment, 0x8D41u, 0);
      }
      else if (v12 == 3553)
      {
        glFramebufferTexture2D(target, attachment, 0xDE1u, 0, 0);
      }
      std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(v7, (uint64_t *)v8);
      operator delete(v8);
    }
  }
}

void ProGL::Framebuffer::detach(ProGL::Framebuffer *this, GLenum a2, GLenum a3)
{
  ProGL::GL::GL((ProGL::GL *)v7);
  ProGL::Framebuffer::detach(this, v6, a2, a3);
  ProGL::GL::~GL((ProGL::GL *)v7);
}

void sub_1B79630A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

void *ProGL::getPerThreadContext@<X0>(void *a1@<X8>)
{
  uint64_t result = pthread_getspecific(*(void *)sPerThreadContexts);
  if (!result)
  {
    ProGL::makeSharedEAGLContext(&v5);
    operator new();
  }
  uint64_t v4 = result[2];
  *a1 = result[1];
  a1[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1B7963174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ProGL::Private::initPerThreadContext(ProGL::Private *this)
{
  if (!sPerThreadContexts) {
    operator new();
  }
}

void sub_1B7963208(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1000C4000313F17);
  _Unwind_Resume(a1);
}

uint64_t ProGL::Private::cleanUpPerThreadContext(ProGL::Private *this)
{
  uint64_t result = sPerThreadContexts;
  if (sPerThreadContexts) {
    uint64_t result = MEMORY[0x1BA9BFBA0](sPerThreadContexts, 0x1000C4000313F17);
  }
  sPerThreadContexts = 0;
  return result;
}

uint64_t PCThreadSpecific<anonymous namespace'::Holder>::destroy(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (ProGL::Init *)result;
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(result + 8));
    ProGL::Init::~Init(v1);
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

void ProGL::Private::RenderbufferHelper::makeRenderbuffer(ProGL::Private::RenderbufferHelper *this, ProGL::Private::RenderbufferImpl *a2)
{
  std::shared_ptr<ProGL::Private::RenderbufferImpl>::shared_ptr[abi:ne180100]<ProGL::Private::RenderbufferImpl,void>(&v2, (uint64_t)this);
}

void ProGL::createMultisampleRenderbuffer(ProGL *this, ProGL::GL *a2)
{
}

void sub_1B79633B4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1020C4062D53EE8);
  _Unwind_Resume(a1);
}

void std::shared_ptr<ProGL::Private::RenderbufferImpl>::shared_ptr[abi:ne180100]<ProGL::Private::RenderbufferImpl,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B796344C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<ProGL::Private::RenderbufferImpl>::reset[abi:ne180100]((ProGL::Private::RenderbufferImpl **)va, 0);
  _Unwind_Resume(a1);
}

ProGL::Private::RenderbufferImpl *std::__shared_ptr_pointer<ProGL::Private::RenderbufferImpl *,std::shared_ptr<ProGL::Private::RenderbufferImpl>::__shared_ptr_default_delete<ProGL::Private::RenderbufferImpl,ProGL::Private::RenderbufferImpl>,std::allocator<ProGL::Private::RenderbufferImpl>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(ProGL::Private::RenderbufferImpl **)(a1 + 24);
  if (result)
  {
    ProGL::Private::RenderbufferImpl::~RenderbufferImpl(result);
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<ProGL::Private::RenderbufferImpl *,std::shared_ptr<ProGL::Private::RenderbufferImpl>::__shared_ptr_default_delete<ProGL::Private::RenderbufferImpl,ProGL::Private::RenderbufferImpl>,std::allocator<ProGL::Private::RenderbufferImpl>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

ProGL::Private::RenderbufferImpl *std::unique_ptr<ProGL::Private::RenderbufferImpl>::reset[abi:ne180100](ProGL::Private::RenderbufferImpl **a1, ProGL::Private::RenderbufferImpl *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    ProGL::Private::RenderbufferImpl::~RenderbufferImpl(result);
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

void DeleteRenderbufferInstruction::~DeleteRenderbufferInstruction(OZChannelBase *this)
{
  this->var0 = (void **)&unk_1F10FB000;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);

  OZChannelBase::setRangeName(this, v2);
}

{
  const PCString *v2;
  uint64_t vars8;

  this->var0 = (void **)&unk_1F10FB000;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);
  OZChannelBase::setRangeName(this, v2);

  JUMPOUT(0x1BA9BFBA0);
}

void DeleteRenderbufferInstruction::execute(DeleteRenderbufferInstruction *this)
{
  ProGL::getDeletionContext((os_unfair_lock_s **)this + 2, (const ProGL::ContextHandle *)*((unsigned int *)this + 8), (ProGL::ContextHandle *)v2);
  ProGL::GL::GL((ProGL::GL *)v3, (const ProGL::ContextHandle *)v2);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v2);
  glDeleteRenderbuffers(1, (const GLuint *)this + 2);
  ProGL::GL::~GL((ProGL::GL *)v3);
}

void sub_1B796365C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

ProGL::Private::RenderbufferImpl *ProGL::Private::RenderbufferImpl::RenderbufferImpl(ProGL::Private::RenderbufferImpl *this, ProGL::GL *a2)
{
  *((_DWORD *)this + 4) = ProGL::ContextHandle::getVirtualScreen(this);
  glGenRenderbuffers(1, (GLuint *)this + 5);
  glBindRenderbuffer(0x8D41u, *((_DWORD *)this + 5));
  glRenderbufferStorageMultisampleAPPLE();
  return this;
}

void sub_1B7963710(_Unwind_Exception *a1)
{
  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

void ProGL::Private::RenderbufferImpl::~RenderbufferImpl(ProGL::Private::RenderbufferImpl *this)
{
}

void std::shared_ptr<ProGL::DeletionInstruction>::shared_ptr[abi:ne180100]<DeleteRenderbufferInstruction,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B7963840(_Unwind_Exception *exception_object)
{
  if (v1) {
  _Unwind_Resume(exception_object);
  }
}

uint64_t std::__shared_ptr_pointer<DeleteRenderbufferInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,DeleteRenderbufferInstruction>,std::allocator<DeleteRenderbufferInstruction>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<DeleteRenderbufferInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,DeleteRenderbufferInstruction>,std::allocator<DeleteRenderbufferInstruction>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void ProGL::Private::Any::~Any(ProGL::Private::Any *this)
{
  uint64_t v1 = *(void *)this;
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

void ProGL::getDeletionContext(os_unfair_lock_s **this@<X0>, const ProGL::ContextHandle *a2@<X1>, ProGL::ContextHandle *a3@<X8>)
{
}

uint64_t ProGL::postDeletionInstruction(long long *a1)
{
}

uint64_t anonymous namespace'::DeletionThreadLoop::postInstruction(PCMutex *this, long long *a2)
{
  {
      operator new();
    if (v7) {
      PCMutex::unlock(v7);
    }
  }
  PCMutex::lock(this);
  std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::push_back(&this[1]._Mutex.__opaque[32], a2);
  uint64_t result = PCConditionVariable::signal((pthread_cond_t *)&this[1]);
  if (this) {
    return PCMutex::unlock(this);
  }
  return result;
}

void sub_1B7963A34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  MEMORY[0x1BA9BFBA0](v9, 0x20C4093837F09);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ProGL::Private::initDeleteObjects(ProGL::Private *this)
{
}

void sub_1B7963B28(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

OZChannelBase *ProGL::Private::cleanUpDeleteObjects(ProGL::Private *this, const PCString *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  {
    PCSemaphore::PCSemaphore((PCSemaphore *)v7, 0);
    operator new();
  }
  {
                                                                                           + 120));
    PCConditionVariable::~PCConditionVariable((pthread_cond_t *)(v3 + 72));
    PCMutex::~PCMutex((PCMutex *)v3);
    MEMORY[0x1BA9BFBA0]();
  }
  {
    PCSpinLock::~PCSpinLock(v4);
    MEMORY[0x1BA9BFBA0]();
  }
  if (result)
  {
    uint64_t v6 = OZChannelBase::setRangeName(result, a2);
    uint64_t result = (OZChannelBase *)MEMORY[0x1BA9BFBA0](v6, 0x20C4093837F09);
  }
  return result;
}

void sub_1B7963D74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  PCSemaphore::~PCSemaphore((PCSemaphore *)va);
  _Unwind_Resume(a1);
}

void anonymous namespace'::threadFunc(_anonymous_namespace_ *this, void *a2)
{
  do
  {
    PCMutex::lock((PCMutex *)v2);
    while (!*(void *)(v2 + 160))
      PCConditionVariable::wait((pthread_cond_t *)(v2 + 72), (PCMutex *)v2);
    uint64_t v3 = (uint64_t *)(*(void *)(*(void *)(v2 + 128) + ((*(void *)(v2 + 152) >> 5) & 0x7FFFFFFFFFFFFF8))
                   + 16 * *(void *)(v2 + 152));
    uint64_t v5 = *v3;
    uint64_t v4 = (std::__shared_weak_count *)v3[1];
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::pop_front((void *)(v2 + 120));
    PCMutex::unlock((PCMutex *)v2);
    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
  while (!*(unsigned char *)(v2 + 168));
}

void sub_1B7963EB0(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::pop_front(void *a1)
{
  unint64_t v2 = a1[4];
  uint64_t v3 = *(std::__shared_weak_count **)(*(void *)(a1[1] + ((v2 >> 5) & 0x7FFFFFFFFFFFFF8))
                                    + 16 * v2
                                    + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    unint64_t v2 = a1[4];
  }
  uint64_t v4 = a1[5] - 1;
  a1[4] = v2 + 1;
  a1[5] = v4;

  return std::deque<PVLoadedEffectItem>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1, 1);
}

void std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::push_back(void *a1, long long *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = 32 * (v4 - v5) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = v7 + a1[4];
  }
  long long v9 = *a2;
  *(_OWORD *)(*(void *)(v5 + ((v8 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v8) = *a2;
  if (*((void *)&v9 + 1))
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v9 + 1) + 8), 1uLL, memory_order_relaxed);
    uint64_t v7 = a1[5];
  }
  a1[5] = v7 + 1;
}

void std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      char v37 = &v34[8 * v36];
      long long v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    int v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<unsigned long *>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<unsigned long *>::push_front((uint64_t)a1, &v54);
    unint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      char v37 = &v34[8 * v47];
      long long v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        long long v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)long long v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  int64_t v53 = operator new(0x1000uLL);
  std::__split_buffer<unsigned long *>::push_back(&v54, &v53);
  long long v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<unsigned long *>::push_front((uint64_t)&v54, v27);
  }
  BOOL v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1B79642D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void anonymous namespace'::QuitInstruction::~QuitInstruction(_anonymous_namespace_::QuitInstruction *this)
{
}

uint64_t anonymous namespace'::QuitInstruction::execute(PCSemaphore **this)
{
  return PCSemaphore::signal(this[1]);
}

void std::__shared_ptr_pointer<anonymous namespace'::QuitInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::QuitInstruction>,std::allocator<anonymous namespace'::QuitInstruction>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<anonymous namespace'::QuitInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::QuitInstruction>,std::allocator<anonymous namespace'::QuitInstruction>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<anonymous namespace'::QuitInstruction *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::QuitInstruction>,std::allocator<anonymous namespace'::QuitInstruction>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::deque<std::shared_ptr<ProGL::DeletionInstruction>>::~deque[abi:ne180100](void *a1)
{
  unint64_t v2 = (void **)a1[1];
  BOOL v3 = (void **)a1[2];
  if (v3 == v2)
  {
    unint64_t v4 = a1 + 5;
    BOOL v3 = (void **)a1[1];
  }
  else
  {
    unint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 >> 8];
    uint64_t v7 = (uint64_t)*v6;
    uint64_t v8 = (uint64_t)*v6 + 16 * v5;
    uint64_t v9 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 5) & 0x7FFFFFFFFFFFFF8))
       + 16 * (*((unsigned char *)a1 + 40) + v5);
    if (v8 != v9)
    {
      do
      {
        uint64_t v10 = *(std::__shared_weak_count **)(v8 + 8);
        if (v10)
        {
          std::__shared_weak_count::__release_shared[abi:ne180100](v10);
          uint64_t v7 = (uint64_t)*v6;
        }
        v8 += 16;
        if (v8 - v7 == 4096)
        {
          uint64_t v11 = (uint64_t)v6[1];
          ++v6;
          uint64_t v7 = v11;
          uint64_t v8 = v11;
        }
      }
      while (v8 != v9);
      unint64_t v2 = (void **)a1[1];
      BOOL v3 = (void **)a1[2];
    }
  }
  *unint64_t v4 = 0;
  unint64_t v12 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = (void **)a1[2];
      unint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v12 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v13 = v12 >> 3;
  if (v13 == 1)
  {
    uint64_t v14 = 128;
  }
  else
  {
    if (v13 != 2) {
      goto LABEL_18;
    }
    uint64_t v14 = 256;
  }
  a1[4] = v14;
LABEL_18:
  while (v2 != v3)
  {
    uint64_t v15 = *v2++;
    operator delete(v15);
  }

  return std::__split_buffer<unsigned long *>::~__split_buffer((uint64_t)a1);
}

void PCMatrix44Tmpl<double>::rotate(uint64_t a1, double *a2, int a3, double a4)
{
  double v6 = *a2;
  double v5 = a2[1];
  double v7 = a2[2];
  if (a3)
  {
    double v8 = sqrt(v6 * v6 + v5 * v5 + v7 * v7 + a2[3] * a2[3]);
    double v6 = v6 / v8;
    double v5 = v5 / v8;
    double v7 = v7 / v8;
  }
  double sinval = 0.0;
  double cosval = 1.0;
  if (a4 != 0.0)
  {
    double sinval = 1.0;
    double cosval = 0.0;
    if (fabs(a4 + -1.57079633) >= 0.0000001 && fabs(a4 + 4.71238898) >= 0.0000001)
    {
      double sinval = -1.0;
      if (fabs(a4 + 1.57079633) >= 0.0000001 && fabs(a4 + -4.71238898) >= 0.0000001)
      {
        double sinval = 0.0;
        double cosval = -1.0;
        if (fabs(a4 + -3.14159265) >= 0.0000001 && fabs(a4 + 3.14159265) >= 0.0000001)
        {
          __double2 v11 = __sincos_stret(a4);
          double cosval = v11.__cosval;
          double sinval = v11.__sinval;
        }
      }
    }
  }
  double v12 = v5 * v6 * (1.0 - cosval);
  double v13 = v7 * v6 * (1.0 - cosval);
  double v14 = v7 * v5 * (1.0 - cosval);
  double v15 = v6 * sinval;
  double v16 = v5 * sinval;
  double v17 = v7 * sinval;
  uint64_t v21 = 0x3FF0000000000000;
  v18[3] = 0.0;
  v18[7] = 0.0;
  long long v19 = 0u;
  long long v20 = 0u;
  v18[0] = cosval + v6 * v6 * (1.0 - cosval);
  v18[1] = v12 - v17;
  v18[2] = v13 + v16;
  v18[4] = v12 + v17;
  v18[5] = cosval + v5 * v5 * (1.0 - cosval);
  v18[6] = v14 - v15;
  v18[8] = v13 - v16;
  v18[9] = v14 + v15;
  v18[10] = cosval + v7 * v7 * (1.0 - cosval);
  PCMatrix44Tmpl<double>::rightMult(a1, v18);
}

void ProGL::MatrixState::~MatrixState(ProGL::MatrixState *this)
{
  unint64_t v2 = (void *)*((void *)this + 1);
  if (v2 != *(void **)this)
  {
    uint64_t v3 = 0;
    if ((unint64_t)(((uint64_t)v2 - *(void *)this) >> 3) <= 1) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = ((uint64_t)v2 - *(void *)this) >> 3;
    }
    do
    {
      uint64_t v5 = *(void *)(*(void *)this + 8 * v3);
      if (v5)
      {
        double v6 = *(void **)(v5 + 16);
        if (v6)
        {
          *(void *)(v5 + 24) = v6;
          operator delete(v6);
        }
        MEMORY[0x1BA9BFBA0](v5, 0x1020C4081634310);
      }
      ++v3;
    }
    while (v4 != v3);
    unint64_t v2 = *(void **)this;
  }
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

uint64_t ProGL::ObjectHandle::Data::Data(uint64_t a1, int a2, void *a3, uint64_t a4)
{
  *(_DWORD *)a1 = a2;
  uint64_t v6 = a3[1];
  *(void *)(a1 + 8) = *a3;
  *(void *)(a1 + 16) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 24) = ProGL::ContextHandle::getVirtualScreen((ProGL::ContextHandle *)(a1 + 8));
  *(void *)(a1 + 32) = a4;
  return a1;
}

void sub_1B7964818(_Unwind_Exception *a1)
{
  ProGL::ContextHandle::~ContextHandle(v1);
  _Unwind_Resume(a1);
}

void ProGL::ObjectHandle::Data::~Data(ProGL::ObjectHandle::Data *this)
{
}

void sub_1B7964948(void *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  __clang_call_terminate(a1);
}

uint64_t ProGL::ObjectHandle::name(ProGL::ObjectHandle *this)
{
  if (*(void *)this) {
    return **(unsigned int **)this;
  }
  else {
    return 0;
  }
}

void ProGL::createShaderObject(ProGL *this@<X0>, GLenum type@<W1>, void *a3@<X8>)
{
  GLuint Shader = glCreateShader(type);
  ProGL::GL::getPGLContextHandle(this, v6);
  GLuint v8 = Shader;
  uint64_t v7 = MEMORY[0x1E4F38D68];
  std::allocate_shared[abi:ne180100]<ProGL::ObjectHandle::Data,std::allocator<ProGL::ObjectHandle::Data>,unsigned int &,ProGL::ContextHandle const&,void (*&),void>((int *)&v8, v6, &v7, a3);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v6);
}

void sub_1B7964A1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ProGL::createProgramObject(ProGL *this@<X0>, void *a2@<X8>)
{
  GLuint Program = glCreateProgram();
  ProGL::GL::getPGLContextHandle(this, v6);
  GLuint v8 = Program;
  uint64_t v7 = MEMORY[0x1E4F38D60];
  std::allocate_shared[abi:ne180100]<ProGL::ObjectHandle::Data,std::allocator<ProGL::ObjectHandle::Data>,unsigned int &,ProGL::ContextHandle const&,void (*&),void>((int *)&v8, v6, &v7, a2);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v6);
}

void sub_1B7964AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void anonymous namespace'::DeleteObjectInst::~DeleteObjectInst(OZChannelBase *this)
{
  this->var0 = (void **)&unk_1F10FB198;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);

  OZChannelBase::setRangeName(this, v2);
}

{
  const PCString *v2;
  uint64_t vars8;

  this->var0 = (void **)&unk_1F10FB198;
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&this->var2);
  OZChannelBase::setRangeName(this, v2);

  JUMPOUT(0x1BA9BFBA0);
}

void anonymous namespace'::DeleteObjectInst::execute(os_unfair_lock_s **this)
{
  ProGL::getDeletionContext(this + 2, (const ProGL::ContextHandle *)*((unsigned int *)this + 8), (ProGL::ContextHandle *)v4);
  ProGL::CurrentContextSentry::CurrentContextSentry((ProGL::CurrentContextSentry *)v3, (const ProGL::ContextHandle *)v4);
  ((void (*)(void))this[5])(*((unsigned int *)this + 2));
  ProGL::GL::GL((ProGL::GL *)v2, (const ProGL::ContextHandle *)v4);
  ProGL::GL::~GL((ProGL::GL *)v2);
  ProGL::CurrentContextSentry::~CurrentContextSentry((ProGL::CurrentContextSentry *)v3);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v4);
}

void sub_1B7964BF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  ProGL::CurrentContextSentry::~CurrentContextSentry((ProGL::CurrentContextSentry *)va);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)(v7 - 32));
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<anonymous namespace'::DeleteObjectInst *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::DeleteObjectInst>,std::allocator<anonymous namespace'::DeleteObjectInst>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<anonymous namespace'::DeleteObjectInst *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::DeleteObjectInst>,std::allocator<anonymous namespace'::DeleteObjectInst>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<anonymous namespace'::DeleteObjectInst *,std::shared_ptr<ProGL::DeletionInstruction>::__shared_ptr_default_delete<ProGL::DeletionInstruction,anonymous namespace'::DeleteObjectInst>,std::allocator<anonymous namespace'::DeleteObjectInst>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *std::allocate_shared[abi:ne180100]<ProGL::ObjectHandle::Data,std::allocator<ProGL::ObjectHandle::Data>,unsigned int &,ProGL::ContextHandle const&,void (*&)(unsigned int),void>@<X0>(int *a1@<X1>, void *a2@<X2>, uint64_t *a3@<X3>, void *a4@<X8>)
{
  GLuint v8 = operator new(0x40uLL);
  uint64_t result = std::__shared_ptr_emplace<ProGL::ObjectHandle::Data>::__shared_ptr_emplace[abi:ne180100]<unsigned int &,ProGL::ContextHandle const&,void (*&),std::allocator<ProGL::ObjectHandle::Data>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1B7964D28(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<ProGL::ObjectHandle::Data>::__shared_ptr_emplace[abi:ne180100]<unsigned int &,ProGL::ContextHandle const&,void (*&)(unsigned int),std::allocator<ProGL::ObjectHandle::Data>,0>(void *a1, int *a2, void *a3, uint64_t *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F10FB250;
  std::allocator<ProGL::ObjectHandle::Data>::construct[abi:ne180100]<ProGL::ObjectHandle::Data,unsigned int &,ProGL::ContextHandle const&,void (*&)>((uint64_t)&v6, (uint64_t)(a1 + 3), a2, a3, a4);
  return a1;
}

void sub_1B7964DA0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<ProGL::ObjectHandle::Data>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10FB250;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ProGL::ObjectHandle::Data>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10FB250;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::__shared_ptr_emplace<ProGL::ObjectHandle::Data>::__on_zero_shared(uint64_t a1)
{
}

void std::allocator<ProGL::ObjectHandle::Data>::construct[abi:ne180100]<ProGL::ObjectHandle::Data,unsigned int &,ProGL::ContextHandle const&,void (*&)(unsigned int)>(uint64_t a1, uint64_t a2, int *a3, void *a4, uint64_t *a5)
{
  int v6 = *a3;
  uint64_t v7 = a4[1];
  v8[0] = *a4;
  v8[1] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  ProGL::ObjectHandle::Data::Data(a2, v6, v8, *a5);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v8);
}

void sub_1B7964E8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t PGLMasterEAGLContext()
{
  {
    PCAutoreleasePool::PCAutoreleasePool((PCAutoreleasePool *)&v1);
    PCAutoreleasePool::~PCAutoreleasePool(&v1);
  }
  return result;
}

void sub_1B7964F00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCAutoreleasePool::~PCAutoreleasePool((id *)va);
  _Unwind_Resume(a1);
}

void ProGL::Private::cleanUpContextSharing(ProGL::Private *this)
{
  {
  }
}

uint64_t PGLCreateSharedEAGLContext()
{
  PCAutoreleasePool::PCAutoreleasePool((PCAutoreleasePool *)&v3);
  id v0 = objc_alloc(MEMORY[0x1E4F38D58]);
  PCAutoreleasePool::~PCAutoreleasePool(&v3);
  return v1;
}

void sub_1B7964FAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCAutoreleasePool::~PCAutoreleasePool((id *)va);
  _Unwind_Resume(a1);
}

void ProGL::ContextHandle::~ContextHandle(ProGL::ContextHandle *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void *ProGL::ContextHandle::operator=(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return a1;
}

uint64_t ProGL::ContextHandle::makeCurrent(ProGL::ContextHandle *this)
{
  uint64_t result = *(void *)this;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t ProGL::ContextHandle::getEAGLContext(ProGL::ContextHandle *this)
{
  uint64_t result = *(void *)this;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t ProGL::ContextHandle::setVirtualScreen(ProGL::ContextHandle *this)
{
  uint64_t result = *(void *)this;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t ProGL::ContextHandle::getVirtualScreen(ProGL::ContextHandle *this)
{
  uint64_t result = *(void *)this;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

uint64_t (*ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(void *a1))(ProGL::ContextHandle *this)
{
  if (*a1) {
    return ProGL::ContextHandle::makeCurrent;
  }
  else {
    return 0;
  }
}

void ProGL::ContextHandle::getShareGroup(os_unfair_lock_s **this@<X0>, PCSharedCount *a2@<X8>)
{
  unint64_t v2 = *this;
  if (v2) {
    ProGL::Private::ContextImpl::getShareGroup(v2, a2);
  }
  else {
    PCSharedCount::PCSharedCount(a2);
  }
}

_anonymous_namespace_ *ProGL::getCurrentContext@<X0>(void *a1@<X8>)
{
  uint64_t result = (_anonymous_namespace_ *)[MEMORY[0x1E4F38D58] currentContext];
  if (result)
  {
  }
  *a1 = 0;
  a1[1] = 0;
  return result;
}

void anonymous namespace'::HandleFromExistingEAGLContext(_anonymous_namespace_ *this, EAGLContext *a2)
{
  PCMakeNSRefAndRetain<EAGLContext *>(this, &v2);
  operator new();
}

void sub_1B7965214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  MEMORY[0x1BA9BFBA0](v4, 0x1081C402D5EB2C2);
  ProCore_Impl::PCNSRefImpl::release((id *)va);
  _Unwind_Resume(a1);
}

void ProGL::makeSharedEAGLContext(void *a1@<X8>)
{
  uint64_t v3 = PGLCreateSharedEAGLContext();
  if (v3) {
    operator new();
  }
  *a1 = 0;
  a1[1] = 0;
  ProCore_Impl::PCNSRefImpl::release((id *)&v3);
}

void sub_1B79652F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ProCore_Impl::PCNSRefImpl::release((id *)va);
  _Unwind_Resume(a1);
}

void ProGL::makeEAGLContext(os_unfair_lock_s **this@<X0>, const ProGL::ContextHandle *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *this;
  if (v5) {
    int v6 = (void *)(*(uint64_t (**)(os_unfair_lock_s *, const ProGL::ContextHandle *))(*(void *)&v5->_os_unfair_lock_opaque
  }
                                                                                             + 24))(v5, a2);
  else {
    int v6 = 0;
  }
  ProGL::ContextHandle::getShareGroup(this, &v10);
  uint64_t v7 = objc_msgSend(objc_alloc(MEMORY[0x1E4F38D58]), "initWithAPI:sharegroup:", objc_msgSend(v6, "API"), objc_msgSend(v6, "sharegroup"));
  if (v7)
  {
    id v11 = v7;
    operator new();
  }
  GLuint v8 = (void *)MEMORY[0x1E4FBA250];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"ProGL::unnamed::NewEAGLContext(EAGLContext): ", 45);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"Unable to create a EAGLContext that shares with %p", 50);
  uint64_t v9 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)".\n", 2);
  id v11 = 0;
  *a3 = 0;
  a3[1] = 0;
  ProCore_Impl::PCNSRefImpl::release(&v11);
}

void sub_1B796549C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  MEMORY[0x1BA9BFBA0](v4, 0x1081C402D5EB2C2);
  ProCore_Impl::PCNSRefImpl::release((id *)va);
  _Unwind_Resume(a1);
}

_anonymous_namespace_ *ProGL::findContext@<X0>(_anonymous_namespace_ *this@<X0>, EAGLContext *a2@<X1>, void *a3@<X8>)
{
  if (this) {
  *a3 = 0;
  }
  a3[1] = 0;
  return this;
}

BOOL ProGL::areContextsShared(os_unfair_lock_s **this, os_unfair_lock_s **a2, const ProGL::ContextHandle *a3)
{
  ProGL::ContextHandle::getShareGroup(this, &v6);
  ProGL::ContextHandle::getShareGroup(a2, &v5);
  return ProGL::operator==(&v6, &v5);
}

void ProGL::Private::initContext(ProGL::Private *this)
{
  PCAutoreleasePool::PCAutoreleasePool((PCAutoreleasePool *)&v3);
  uint64_t v1 = (_anonymous_namespace_ *)[MEMORY[0x1E4F38D58] currentContext];
  if (v1) {
  PCAutoreleasePool::~PCAutoreleasePool(&v3);
  }
}

void sub_1B7965588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PCAutoreleasePool::~PCAutoreleasePool((id *)va);
  _Unwind_Resume(a1);
}

id PCMakeNSRefAndRetain<EAGLContext *>@<X0>(void *a1@<X0>, id *a2@<X8>)
{
  *a2 = a1;
  return ProCore_Impl::PCNSRefImpl::retain(a2);
}

void sub_1B79655C8(_Unwind_Exception *a1)
{
  ProCore_Impl::PCNSRefImpl::release(v1);
  _Unwind_Resume(a1);
}

void std::shared_ptr<ProGL::Private::ContextImpl>::shared_ptr[abi:ne180100]<ProGL::Private::EAGLContextImpl,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B7965648(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<ProGL::Private::ContextImpl>::shared_ptr[abi:ne180100]<ProGL::Private::EAGLContextImpl,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<ProGL::Private::EAGLContextImpl *,std::shared_ptr<ProGL::Private::ContextImpl>::__shared_ptr_default_delete<ProGL::Private::ContextImpl,ProGL::Private::EAGLContextImpl>,std::allocator<ProGL::Private::EAGLContextImpl>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<ProGL::Private::EAGLContextImpl *,std::shared_ptr<ProGL::Private::ContextImpl>::__shared_ptr_default_delete<ProGL::Private::ContextImpl,ProGL::Private::EAGLContextImpl>,std::allocator<ProGL::Private::EAGLContextImpl>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::shared_ptr<ProGL::Private::ContextImpl>::shared_ptr[abi:ne180100]<ProGL::Private::EAGLContextImpl,void>(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

ProGL::Private::ContextImpl *ProGL::Private::ContextImpl::ContextImpl(ProGL::Private::ContextImpl *this, const ProGL::ShareGroup *a2)
{
  *(void *)this = &unk_1F10FB318;
  *((_DWORD *)this + 2) = 0;
  ProGL::ShareGroup::ShareGroup((void *)this + 2, a2);
  return this;
}

void sub_1B7965748(_Unwind_Exception *a1)
{
  PCSpinLock::~PCSpinLock(v1);
  _Unwind_Resume(a1);
}

void ProGL::Private::ContextImpl::getShareGroup(os_unfair_lock_s *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = this + 2;
  v10[1] = this + 2;
  PCSpinLock::lock(this + 2);
  PCSharedCount v5 = ProGL::ShareGroup::operator void (ProGL::ShareGroup::*)(void)(&this[4]._os_unfair_lock_opaque);
  if (v6) {
    BOOL v7 = (v6 & 1 | (unint64_t)v5) == 0;
  }
  else {
    BOOL v7 = 1;
  }
  int v8 = v7;
  if (!v5 && v8)
  {
    uint64_t v9 = (void *)(*(uint64_t (**)(os_unfair_lock_s *))(*(void *)&this->_os_unfair_lock_opaque + 24))(this);
    ProGL::ShareGroup::findGroup(v9, v10);
    *(void *)&this[4]._os_unfair_lock_opaque = v10[0];
  }
  ProGL::ShareGroup::ShareGroup(a2, &this[4]._os_unfair_lock_opaque);
  PCSpinLock::unlock(v4);
}

void sub_1B7965820(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

ProGL::Private::ContextImpl *ProGL::Private::EAGLContextImpl::EAGLContextImpl(ProGL::Private::ContextImpl *a1, void *a2)
{
  PCSharedCount::PCSharedCount(&v6);
  uint64_t v4 = ProGL::Private::ContextImpl::ContextImpl(a1, (const ProGL::ShareGroup *)&v6);
  *(void *)a1 = &unk_1F10FB360;
  *((void *)v4 + 3) = *a2;
  ProCore_Impl::PCNSRefImpl::retain((id *)v4 + 3);
  return a1;
}

void sub_1B79658A4(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &unk_1F10FB318;
  PCSpinLock::~PCSpinLock((PCSpinLock *)(v1 + 8));
  _Unwind_Resume(a1);
}

ProGL::Private::ContextImpl *ProGL::Private::EAGLContextImpl::EAGLContextImpl(ProGL::Private::ContextImpl *a1, void *a2, ProGL::ShareGroup *a3)
{
  PCSharedCount v5 = ProGL::Private::ContextImpl::ContextImpl(a1, a3);
  *(void *)PCSharedCount v5 = &unk_1F10FB360;
  *((void *)v5 + 3) = *a2;
  ProCore_Impl::PCNSRefImpl::retain((id *)v5 + 3);
  return a1;
}

void sub_1B7965930(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &unk_1F10FB318;
  PCSpinLock::~PCSpinLock((PCSpinLock *)(v1 + 8));
  _Unwind_Resume(a1);
}

void ProGL::Private::EAGLContextImpl::~EAGLContextImpl(ProGL::Private::EAGLContextImpl *this)
{
  *(void *)this = &unk_1F10FB360;
  ProCore_Impl::PCNSRefImpl::release((id *)this + 3);
  *(void *)this = &unk_1F10FB318;
  PCSpinLock::~PCSpinLock((PCSpinLock *)this + 2);
}

{
  uint64_t vars8;

  ProGL::Private::EAGLContextImpl::~EAGLContextImpl(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProGL::Private::EAGLContextImpl::makeCurrent(ProGL::Private::EAGLContextImpl *this)
{
  return [MEMORY[0x1E4F38D58] setCurrentContext:*((void *)this + 3)];
}

uint64_t ProGL::Private::EAGLContextImpl::getEAGLContext(ProGL::Private::EAGLContextImpl *this)
{
  return *((void *)this + 3);
}

uint64_t ProGL::Private::EAGLContextImpl::numVirtualScreens(ProGL::Private::EAGLContextImpl *this)
{
  return 1;
}

uint64_t ProGL::Private::EAGLContextImpl::getVirtualScreen(ProGL::Private::EAGLContextImpl *this)
{
  return 0;
}

ProGL::CurrentContextSentry *ProGL::CurrentContextSentry::CurrentContextSentry(ProGL::CurrentContextSentry *this)
{
  *(void *)this = [MEMORY[0x1E4F38D58] currentContext];
  *((void *)this + 1) = 0;
  return this;
}

ProGL::CurrentContextSentry *ProGL::CurrentContextSentry::CurrentContextSentry(ProGL::CurrentContextSentry *this, EAGLContext *a2)
{
  *(void *)this = [MEMORY[0x1E4F38D58] currentContext];
  *((void *)this + 1) = a2;
  if (a2)
  {
    uint64_t v4 = a2;
    [MEMORY[0x1E4F38D58] setCurrentContext:a2];
  }
  return this;
}

ProGL::CurrentContextSentry *ProGL::CurrentContextSentry::CurrentContextSentry(ProGL::CurrentContextSentry *this, const ProGL::ContextHandle *a2)
{
  *(void *)this = [MEMORY[0x1E4F38D58] currentContext];
  *((void *)this + 1) = ProGL::ContextHandle::getEAGLContext(a2);
  uint64_t v4 = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(a2);
  if (v5) {
    BOOL v6 = (v5 & 1 | (unint64_t)v4) == 0;
  }
  else {
    BOOL v6 = 1;
  }
  int v7 = !v6;
  if (v4 || v7)
  {
    id v8 = *((id *)this + 1);
    ProGL::ContextHandle::makeCurrent(a2);
  }
  return this;
}

void ProGL::CurrentContextSentry::~CurrentContextSentry(id *this)
{
}

void ProGL::Private::initContextInfo(ProGL::Private *this)
{
}

uint64_t ProGL::Private::cleanUpContextInfo(ProGL::Private *this)
{
  {
    uint64_t result = MEMORY[0x1BA9BFBA0]();
  }
  {
    uint64_t result = MEMORY[0x1BA9BFBA0](v2, 0x1020C4062D53EE8);
  }
  return result;
}

void std::__tree<std::__value_type<std::pair<ProGL::ShareGroup,int>,anonymous namespace'::PerGroupContextInfo>,std::__map_value_compare<std::pair<ProGL::ShareGroup,int>,std::__value_type<std::pair<ProGL::ShareGroup,int>,anonymous namespace'::PerGroupContextInfo>,std::less<std::pair<ProGL::ShareGroup,int>>,true>,std::allocator<std::__value_type<std::pair<ProGL::ShareGroup,int>,anonymous namespace'::PerGroupContextInfo>>>::destroy(void *a1)
{
  if (a1)
  {
    operator delete(a1);
  }
}

uint64_t OZFactories::getInstance(OZFactories *this)
{
  if (OZFactories::getInstance(void)::once != -1) {
    dispatch_once(&OZFactories::getInstance(void)::once, &__block_literal_global_62);
  }
  return OZFactories::_instance;
}

void ___ZN11OZFactories11getInstanceEv_block_invoke()
{
}

void sub_1B7965D38(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40A4A8B666);
  _Unwind_Resume(a1);
}

void OZFactories::OZFactories(OZFactories *this)
{
  PCSingleton::PCSingleton(this, 0);
  *uint64_t v2 = &unk_1F10FB3F0;
  v2[2] = 0;
  v2[1] = v2 + 2;
  _OWORD v2[3] = 0;
  OZFactories::addChannelFactories((uint64_t **)this);
}

void sub_1B7965DE4(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v2, *((void **)v1 + 2));
  PCSingleton::~PCSingleton(v1);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::makeThreadKey(_anonymous_namespace_ *this)
{
}

{
}

_OWORD *OZFactories::addChannelFactories(uint64_t **this)
{
  uint64_t v1 = this;
  uint64_t Instance = OZChannelBase_Factory::getInstance((OZChannelBase_Factory *)this);
  ++v1;
  float32x4_t v128 = (_OWORD *)(Instance + 8);
  id v3 = (OZChannel_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(Instance + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v3 + 6) = Instance;
  uint64_t v4 = OZChannel_Factory::getInstance(v3);
  float32x4_t v128 = (_OWORD *)(v4 + 8);
  uint64_t v5 = (OZChannelDouble_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v4 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v5 + 6) = v4;
  uint64_t v6 = OZChannelDouble_Factory::getInstance(v5);
  float32x4_t v128 = (_OWORD *)(v6 + 8);
  int v7 = (OZChannelBool_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v6 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v7 + 6) = v6;
  uint64_t v8 = OZChannelBool_Factory::getInstance(v7);
  float32x4_t v128 = (_OWORD *)(v8 + 8);
  uint64_t v9 = (OZChannelUint32_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v8 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v9 + 6) = v8;
  uint64_t v10 = OZChannelUint32_Factory::getInstance(v9);
  float32x4_t v128 = (_OWORD *)(v10 + 8);
  id v11 = (OZChannelAngle_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v10 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v11 + 6) = v10;
  uint64_t v12 = OZChannelAngle_Factory::getInstance(v11);
  float32x4_t v128 = (_OWORD *)(v12 + 8);
  double v13 = (OZChannelPercent_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v12 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v13 + 6) = v12;
  uint64_t v14 = OZChannelPercent_Factory::getInstance(v13);
  float32x4_t v128 = (_OWORD *)(v14 + 8);
  double v15 = (OZChannelShearAngle_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v14 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v15 + 6) = v14;
  uint64_t v16 = OZChannelShearAngle_Factory::getInstance(v15);
  float32x4_t v128 = (_OWORD *)(v16 + 8);
  double v17 = (OZChannelAspectRatio_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v16 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v17 + 6) = v16;
  uint64_t v18 = OZChannelAspectRatio_Factory::getInstance(v17);
  float32x4_t v128 = (_OWORD *)(v18 + 8);
  long long v19 = (OZChannelAspectRatioFootage_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v18 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v19 + 6) = v18;
  uint64_t v20 = OZChannelAspectRatioFootage_Factory::getInstance(v19);
  float32x4_t v128 = (_OWORD *)(v20 + 8);
  uint64_t v21 = (OZChannelGammaFootage_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v20 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v21 + 6) = v20;
  uint64_t v22 = OZChannelGammaFootage_Factory::getInstance(v21);
  float32x4_t v128 = (_OWORD *)(v22 + 8);
  uint64_t v23 = (OZChannelFolder_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v22 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v23 + 6) = v22;
  uint64_t v24 = OZChannelFolder_Factory::getInstance(v23);
  float32x4_t v128 = (_OWORD *)(v24 + 8);
  unint64_t v25 = (OZCompoundChannel_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v24 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v25 + 6) = v24;
  uint64_t v26 = OZCompoundChannel_Factory::getInstance(v25);
  float32x4_t v128 = (_OWORD *)(v26 + 8);
  long long v27 = (OZChannel2D_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v26 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v27 + 6) = v26;
  uint64_t v28 = OZChannel2D_Factory::getInstance(v27);
  float32x4_t v128 = (_OWORD *)(v28 + 8);
  BOOL v29 = (OZChannelBool3D_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v28 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v29 + 6) = v28;
  uint64_t v30 = OZChannelBool3D_Factory::getInstance(v29);
  float32x4_t v128 = (_OWORD *)(v30 + 8);
  long long v31 = (OZChannelPosition_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v30 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v31 + 6) = v30;
  uint64_t v32 = OZChannelPosition_Factory::getInstance(v31);
  float32x4_t v128 = (_OWORD *)(v32 + 8);
  unint64_t v33 = (OZChannelPositionPercent_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v32 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v33 + 6) = v32;
  uint64_t v34 = OZChannelPositionPercent_Factory::getInstance(v33);
  float32x4_t v128 = (_OWORD *)(v34 + 8);
  uint64_t v35 = (OZChannelShear_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v34 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v35 + 6) = v34;
  uint64_t v36 = OZChannelShear_Factory::getInstance(v35);
  float32x4_t v128 = (_OWORD *)(v36 + 8);
  char v37 = (OZChannelScale_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v36 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v37 + 6) = v36;
  uint64_t v38 = OZChannelScale_Factory::getInstance(v37);
  float32x4_t v128 = (_OWORD *)(v38 + 8);
  uint64_t v39 = (OZChannel3D_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v38 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v39 + 6) = v38;
  uint64_t v40 = OZChannel3D_Factory::getInstance(v39);
  float32x4_t v128 = (_OWORD *)(v40 + 8);
  uint64_t v41 = (OZChannelPosition3D_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v40 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v41 + 6) = v40;
  uint64_t v42 = OZChannelPosition3D_Factory::getInstance(v41);
  float32x4_t v128 = (_OWORD *)(v42 + 8);
  uint64_t v43 = (OZChannelRotation3D_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v42 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v43 + 6) = v42;
  uint64_t v44 = OZChannelRotation3D_Factory::getInstance(v43);
  float32x4_t v128 = (_OWORD *)(v44 + 8);
  uint64_t v45 = (OZChannelScale3D_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v44 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v45 + 6) = v44;
  uint64_t v46 = OZChannelScale3D_Factory::getInstance(v45);
  float32x4_t v128 = (_OWORD *)(v46 + 8);
  uint64_t v47 = (OZChannelColorNoAlpha_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v46 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v47 + 6) = v46;
  uint64_t v48 = OZChannelColorNoAlpha_Factory::getInstance(v47);
  float32x4_t v128 = (_OWORD *)(v48 + 8);
  uint64_t v49 = (OZChannelColor_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v48 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v49 + 6) = v48;
  uint64_t v50 = OZChannelColor_Factory::getInstance(v49);
  float32x4_t v128 = (_OWORD *)(v50 + 8);
  long long v51 = (OZChannelQuad_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v50 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v51 + 6) = v50;
  uint64_t v52 = OZChannelQuad_Factory::getInstance(v51);
  float32x4_t v128 = (_OWORD *)(v52 + 8);
  int64_t v53 = (OZChannelCrop_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v52 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v53 + 6) = v52;
  uint64_t v54 = OZChannelCrop_Factory::getInstance(v53);
  float32x4_t v128 = (_OWORD *)(v54 + 8);
  long long v55 = (OZChannelDiscreteColor_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v54 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v55 + 6) = v54;
  uint64_t v56 = OZChannelDiscreteColor_Factory::getInstance(v55);
  float32x4_t v128 = (_OWORD *)(v56 + 8);
  unint64_t v57 = (OZChannelGradient_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v56 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v57 + 6) = v56;
  uint64_t v58 = OZChannelGradient_Factory::getInstance(v57);
  float32x4_t v128 = (_OWORD *)(v58 + 8);
  unint64_t v59 = (OZChannelGradientRGBFolder_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v58 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v59 + 6) = v58;
  uint64_t v60 = OZChannelGradientRGBFolder_Factory::getInstance(v59);
  float32x4_t v128 = (_OWORD *)(v60 + 8);
  GLuint v61 = (OZChannelGradientAlphaFolder_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v60 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v61 + 6) = v60;
  uint64_t v62 = OZChannelGradientAlphaFolder_Factory::getInstance(v61);
  float32x4_t v128 = (_OWORD *)(v62 + 8);
  uint64_t v63 = (OZChannelGradientSample_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v62 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v63 + 6) = v62;
  uint64_t v64 = OZChannelGradientSample_Factory::getInstance(v63);
  float32x4_t v128 = (_OWORD *)(v64 + 8);
  float32x4_t v65 = (OZChannelGradientSampleRGB_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v64 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v65 + 6) = v64;
  uint64_t v66 = OZChannelGradientSampleRGB_Factory::getInstance(v65);
  float32x4_t v128 = (_OWORD *)(v66 + 8);
  std::string v67 = (OZChannelGradientSampleAlpha_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v66 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v67 + 6) = v66;
  uint64_t v68 = OZChannelGradientSampleAlpha_Factory::getInstance(v67);
  float32x4_t v128 = (_OWORD *)(v68 + 8);
  float32x4_t v69 = (OZChannelGradientExtras_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v68 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v69 + 6) = v68;
  uint64_t v70 = OZChannelGradientExtras_Factory::getInstance(v69);
  float32x4_t v128 = (_OWORD *)(v70 + 8);
  unint64_t v71 = (OZChannelGradientPositioned_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v70 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v71 + 6) = v70;
  uint64_t v72 = OZChannelGradientPositioned_Factory::getInstance(v71);
  float32x4_t v128 = (_OWORD *)(v72 + 8);
  uint64_t v73 = (OZChannelVaryingFolder_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v72 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v73 + 6) = v72;
  uint64_t v74 = OZChannelVaryingFolder_Factory::getInstance(v73);
  float32x4_t v128 = (_OWORD *)(v74 + 8);
  long long v75 = (OZChannelObjectRootBase_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v74 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v75 + 6) = v74;
  uint64_t v76 = OZChannelObjectRootBase_Factory::getInstance(v75);
  float32x4_t v128 = (_OWORD *)(v76 + 8);
  long long v77 = (OZChannelHistogram_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v76 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v77 + 6) = v76;
  uint64_t v78 = OZChannelHistogram_Factory::getInstance(v77);
  float32x4_t v128 = (_OWORD *)(v78 + 8);
  float32x4_t v79 = (OZChannelLevels_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v78 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v79 + 6) = v78;
  uint64_t v80 = OZChannelLevels_Factory::getInstance(v79);
  float32x4_t v128 = (_OWORD *)(v80 + 8);
  unint64_t v81 = (OZChannelButton_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v80 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v81 + 6) = v80;
  uint64_t v82 = OZChannelButton_Factory::getInstance(v81);
  float32x4_t v128 = (_OWORD *)(v82 + 8);
  uint64_t v83 = (OZChannelHelpButton_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v82 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v83 + 6) = v82;
  uint64_t v84 = OZChannelHelpButton_Factory::getInstance(v83);
  float32x4_t v128 = (_OWORD *)(v84 + 8);
  float32x4_t v85 = (OZChannelText_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v84 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v85 + 6) = v84;
  uint64_t v86 = OZChannelText_Factory::getInstance(v85);
  float32x4_t v128 = (_OWORD *)(v86 + 8);
  float32x4_t v87 = (OZChannelDoubleOverRange_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v86 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v87 + 6) = v86;
  uint64_t v88 = OZChannelDoubleOverRange_Factory::getInstance(v87);
  float32x4_t v128 = (_OWORD *)(v88 + 8);
  unint64_t v89 = (OZChannelScaleOverRange_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v88 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v89 + 6) = v88;
  uint64_t v90 = OZChannelScaleOverRange_Factory::getInstance(v89);
  float32x4_t v128 = (_OWORD *)(v90 + 8);
  unint64_t v91 = (OZChannelAngleOverRange_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v90 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v91 + 6) = v90;
  uint64_t v92 = OZChannelAngleOverRange_Factory::getInstance(v91);
  float32x4_t v128 = (_OWORD *)(v92 + 8);
  float32x4_t v93 = (OZChannelPercentOverRange_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v92 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v93 + 6) = v92;
  uint64_t v94 = OZChannelPercentOverRange_Factory::getInstance(v93);
  float32x4_t v128 = (_OWORD *)(v94 + 8);
  long long v95 = (OZChannel2DOverRange_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v94 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v95 + 6) = v94;
  uint64_t v96 = OZChannel2DOverRange_Factory::getInstance(v95);
  float32x4_t v128 = (_OWORD *)(v96 + 8);
  uint64_t v97 = (OZChannelTransformSwitch_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v96 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v97 + 6) = v96;
  uint64_t v98 = OZChannelTransformSwitch_Factory::getInstance(v97);
  float32x4_t v128 = (_OWORD *)(v98 + 8);
  float32x4_t v99 = (OZChannelUint16_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v98 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v99 + 6) = v98;
  uint64_t v100 = OZChannelUint16_Factory::getInstance(v99);
  float32x4_t v128 = (_OWORD *)(v100 + 8);
  float32x4_t v101 = (OZChannelSeed_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v100 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v101 + 6) = v100;
  uint64_t v102 = OZChannelSeed_Factory::getInstance(v101);
  float32x4_t v128 = (_OWORD *)(v102 + 8);
  float32x4_t v103 = (OZChannelDecibel_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v102 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v103 + 6) = v102;
  uint64_t v104 = OZChannelDecibel_Factory::getInstance(v103);
  float32x4_t v128 = (_OWORD *)(v104 + 8);
  float32x4_t v105 = (OZChannelFrame_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v104 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v105 + 6) = v104;
  uint64_t v106 = OZChannelFrame_Factory::getInstance(v105);
  float32x4_t v128 = (_OWORD *)(v106 + 8);
  float32x4_t v107 = (OZChannelTimecode_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v106 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v107 + 6) = v106;
  uint64_t v108 = OZChannelTimecode_Factory::getInstance(v107);
  float32x4_t v128 = (_OWORD *)(v108 + 8);
  float32x4_t v109 = (OZChannelBlindData_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v108 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v109 + 6) = v108;
  uint64_t v110 = OZChannelBlindData_Factory::getInstance(v109);
  float32x4_t v128 = (_OWORD *)(v110 + 8);
  int v111 = (OZChannelCurve_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v110 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v111 + 6) = v110;
  uint64_t v112 = OZChannelCurve_Factory::getInstance(v111);
  float32x4_t v128 = (_OWORD *)(v112 + 8);
  float32x4_t v113 = (OZChannelEnum_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v112 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v113 + 6) = v112;
  uint64_t v114 = OZChannelEnum_Factory::getInstance(v113);
  float32x4_t v128 = (_OWORD *)(v114 + 8);
  float32x4_t v115 = (OZChannelGradientWithAngle_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v114 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v115 + 6) = v114;
  uint64_t v116 = OZChannelGradientWithAngle_Factory::getInstance(v115);
  float32x4_t v128 = (_OWORD *)(v116 + 8);
  float32x4_t v117 = (OZChannelHistogramSample_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v116 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v117 + 6) = v116;
  uint64_t v118 = OZChannelHistogramSample_Factory::getInstance(v117);
  float32x4_t v128 = (_OWORD *)(v118 + 8);
  int8x16_t v119 = (OZChannelProgress_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v118 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v119 + 6) = v118;
  uint64_t v120 = OZChannelProgress_Factory::getInstance(v119);
  float32x4_t v128 = (_OWORD *)(v120 + 8);
  float32x4_t v121 = (OZChannelScaleOverLife_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v120 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v121 + 6) = v120;
  uint64_t v122 = OZChannelScaleOverLife_Factory::getInstance(v121);
  float32x4_t v128 = (_OWORD *)(v122 + 8);
  float32x4_t v123 = (OZChannelVertexFolder_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v122 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v123 + 6) = v122;
  uint64_t v124 = OZChannelVertexFolder_Factory::getInstance(v123);
  float32x4_t v128 = (_OWORD *)(v124 + 8);
  float32x4_t v125 = (OZChanObjectRef_Factory *)std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v124 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)v125 + 6) = v124;
  uint64_t v126 = OZChanObjectRef_Factory::getInstance(v125);
  float32x4_t v128 = (_OWORD *)(v126 + 8);
  uint64_t result = std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(v1, (unsigned int *)(v126 + 8), (uint64_t)&std::piecewise_construct, &v128);
  *((void *)result + 6) = v126;
  return result;
}

void OZFactories::~OZFactories(OZFactories *this)
{
  *(void *)this = &unk_1F10FB3F0;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 8, *((void **)this + 2));

  PCSingleton::~PCSingleton(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F10FB3F0;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 8, *((void **)this + 2));
  PCSingleton::~PCSingleton(this);

  JUMPOUT(0x1BA9BFBA0);
}

_OWORD *OZFactories::addFactory(uint64_t **this, OZFactory *a2)
{
  uint64_t v4 = (_OWORD *)((char *)a2 + 8);
  uint64_t result = std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(this + 1, (unsigned int *)a2 + 2, (uint64_t)&std::piecewise_construct, &v4);
  *((void *)result + 6) = a2;
  return result;
}

uint64_t OZChannelBase_Factory::getInstance(OZChannelBase_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelBase_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelBase_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelBase_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelBase_Factory::_instance;
}

uint64_t OZChannel_Factory::getInstance(OZChannel_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannel_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannel_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannel_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannel_Factory::_instance;
}

uint64_t OZChannelDouble_Factory::getInstance(OZChannelDouble_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelDouble_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelDouble_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDouble_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelDouble_Factory::_instance;
}

uint64_t OZChannelBool_Factory::getInstance(OZChannelBool_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelBool_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelBool_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelBool_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelBool_Factory::_instance;
}

uint64_t OZChannelUint32_Factory::getInstance(OZChannelUint32_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelUint32_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelUint32_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelUint32_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelUint32_Factory::_instance;
}

uint64_t OZChannelAngle_Factory::getInstance(OZChannelAngle_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelAngle_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelAngle_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAngle_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAngle_Factory::_instance;
}

uint64_t OZChannelPercent_Factory::getInstance(OZChannelPercent_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelPercent_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelPercent_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelPercent_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelPercent_Factory::_instance;
}

uint64_t OZChannelShearAngle_Factory::getInstance(OZChannelShearAngle_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelShearAngle_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelShearAngle_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelShearAngle_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelShearAngle_Factory::_instance;
}

uint64_t OZChannelAspectRatio_Factory::getInstance(OZChannelAspectRatio_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelAspectRatio_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelAspectRatio_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatio_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAspectRatio_Factory::_instance;
}

uint64_t OZChannelAspectRatioFootage_Factory::getInstance(OZChannelAspectRatioFootage_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelAspectRatioFootage_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelAspectRatioFootage_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatioFootage_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAspectRatioFootage_Factory::_instance;
}

uint64_t OZChannelGammaFootage_Factory::getInstance(OZChannelGammaFootage_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelGammaFootage_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelGammaFootage_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGammaFootage_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGammaFootage_Factory::_instance;
}

uint64_t OZChannelFolder_Factory::getInstance(OZChannelFolder_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelFolder_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelFolder_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelFolder_Factory::_instance;
}

uint64_t OZCompoundChannel_Factory::getInstance(OZCompoundChannel_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZCompoundChannel_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZCompoundChannel_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZCompoundChannel_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZCompoundChannel_Factory::_instance;
}

uint64_t OZChannel2D_Factory::getInstance(OZChannel2D_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannel2D_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannel2D_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannel2D_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannel2D_Factory::_instance;
}

uint64_t OZChannelBool3D_Factory::getInstance(OZChannelBool3D_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelBool3D_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelBool3D_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelBool3D_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelBool3D_Factory::_instance;
}

uint64_t OZChannelPosition_Factory::getInstance(OZChannelPosition_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelPosition_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelPosition_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelPosition_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelPosition_Factory::_instance;
}

uint64_t OZChannelPositionPercent_Factory::getInstance(OZChannelPositionPercent_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelPositionPercent_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelPositionPercent_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelPositionPercent_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelPositionPercent_Factory::_instance;
}

uint64_t OZChannelShear_Factory::getInstance(OZChannelShear_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelShear_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelShear_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelShear_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelShear_Factory::_instance;
}

uint64_t OZChannelScale_Factory::getInstance(OZChannelScale_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelScale_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelScale_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelScale_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelScale_Factory::_instance;
}

uint64_t OZChannel3D_Factory::getInstance(OZChannel3D_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannel3D_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannel3D_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannel3D_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannel3D_Factory::_instance;
}

uint64_t OZChannelPosition3D_Factory::getInstance(OZChannelPosition3D_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelPosition3D_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelPosition3D_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelPosition3D_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelPosition3D_Factory::_instance;
}

uint64_t OZChannelRotation3D_Factory::getInstance(OZChannelRotation3D_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelRotation3D_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelRotation3D_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelRotation3D_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelRotation3D_Factory::_instance;
}

uint64_t OZChannelScale3D_Factory::getInstance(OZChannelScale3D_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelScale3D_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelScale3D_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelScale3D_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelScale3D_Factory::_instance;
}

uint64_t OZChannelColorNoAlpha_Factory::getInstance(OZChannelColorNoAlpha_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelColorNoAlpha_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelColorNoAlpha_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelColorNoAlpha_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelColorNoAlpha_Factory::_instance;
}

uint64_t OZChannelColor_Factory::getInstance(OZChannelColor_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelColor_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelColor_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelColor_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelColor_Factory::_instance;
}

uint64_t OZChannelQuad_Factory::getInstance(OZChannelQuad_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelQuad_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelQuad_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelQuad_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelQuad_Factory::_instance;
}

uint64_t OZChannelCrop_Factory::getInstance(OZChannelCrop_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelCrop_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelCrop_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelCrop_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelCrop_Factory::_instance;
}

uint64_t OZChannelDiscreteColor_Factory::getInstance(OZChannelDiscreteColor_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelDiscreteColor_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelDiscreteColor_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDiscreteColor_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelDiscreteColor_Factory::_instance;
}

uint64_t OZChannelGradient_Factory::getInstance(OZChannelGradient_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelGradient_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelGradient_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradient_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradient_Factory::_instance;
}

uint64_t OZChannelGradientRGBFolder_Factory::getInstance(OZChannelGradientRGBFolder_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelGradientRGBFolder_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelGradientRGBFolder_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientRGBFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientRGBFolder_Factory::_instance;
}

uint64_t OZChannelGradientAlphaFolder_Factory::getInstance(OZChannelGradientAlphaFolder_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelGradientAlphaFolder_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelGradientAlphaFolder_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientAlphaFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientAlphaFolder_Factory::_instance;
}

uint64_t OZChannelGradientSample_Factory::getInstance(OZChannelGradientSample_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelGradientSample_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelGradientSample_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientSample_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientSample_Factory::_instance;
}

uint64_t OZChannelGradientSampleRGB_Factory::getInstance(OZChannelGradientSampleRGB_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelGradientSampleRGB_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelGradientSampleRGB_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientSampleRGB_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientSampleRGB_Factory::_instance;
}

uint64_t OZChannelGradientSampleAlpha_Factory::getInstance(OZChannelGradientSampleAlpha_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelGradientSampleAlpha_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelGradientSampleAlpha_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientSampleAlpha_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientSampleAlpha_Factory::_instance;
}

uint64_t OZChannelGradientExtras_Factory::getInstance(OZChannelGradientExtras_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelGradientExtras_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelGradientExtras_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientExtras_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientExtras_Factory::_instance;
}

uint64_t OZChannelGradientPositioned_Factory::getInstance(OZChannelGradientPositioned_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelGradientPositioned_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelGradientPositioned_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientPositioned_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientPositioned_Factory::_instance;
}

uint64_t OZChannelVaryingFolder_Factory::getInstance(OZChannelVaryingFolder_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelVaryingFolder_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelVaryingFolder_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelVaryingFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelVaryingFolder_Factory::_instance;
}

uint64_t OZChannelObjectRootBase_Factory::getInstance(OZChannelObjectRootBase_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelObjectRootBase_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelObjectRootBase_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelObjectRootBase_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelObjectRootBase_Factory::_instance;
}

uint64_t OZChannelHistogram_Factory::getInstance(OZChannelHistogram_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelHistogram_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelHistogram_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelHistogram_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelHistogram_Factory::_instance;
}

uint64_t OZChannelLevels_Factory::getInstance(OZChannelLevels_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelLevels_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelLevels_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelLevels_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelLevels_Factory::_instance;
}

uint64_t OZChannelButton_Factory::getInstance(OZChannelButton_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelButton_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelButton_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelButton_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelButton_Factory::_instance;
}

uint64_t OZChannelHelpButton_Factory::getInstance(OZChannelHelpButton_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelHelpButton_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelHelpButton_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelHelpButton_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelHelpButton_Factory::_instance;
}

uint64_t OZChannelText_Factory::getInstance(OZChannelText_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelText_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelText_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelText_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelText_Factory::_instance;
}

uint64_t OZChannelDoubleOverRange_Factory::getInstance(OZChannelDoubleOverRange_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelDoubleOverRange_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelDoubleOverRange_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDoubleOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelDoubleOverRange_Factory::_instance;
}

uint64_t OZChannelScaleOverRange_Factory::getInstance(OZChannelScaleOverRange_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelScaleOverRange_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelScaleOverRange_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelScaleOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelScaleOverRange_Factory::_instance;
}

uint64_t OZChannelAngleOverRange_Factory::getInstance(OZChannelAngleOverRange_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelAngleOverRange_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelAngleOverRange_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAngleOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAngleOverRange_Factory::_instance;
}

uint64_t OZChannelPercentOverRange_Factory::getInstance(OZChannelPercentOverRange_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelPercentOverRange_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelPercentOverRange_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelPercentOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelPercentOverRange_Factory::_instance;
}

uint64_t OZChannel2DOverRange_Factory::getInstance(OZChannel2DOverRange_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannel2DOverRange_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannel2DOverRange_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannel2DOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannel2DOverRange_Factory::_instance;
}

uint64_t OZChannelTransformSwitch_Factory::getInstance(OZChannelTransformSwitch_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelTransformSwitch_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelTransformSwitch_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelTransformSwitch_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelTransformSwitch_Factory::_instance;
}

uint64_t OZChannelUint16_Factory::getInstance(OZChannelUint16_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelUint16_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelUint16_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelUint16_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelUint16_Factory::_instance;
}

uint64_t OZChannelSeed_Factory::getInstance(OZChannelSeed_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelSeed_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelSeed_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelSeed_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelSeed_Factory::_instance;
}

uint64_t OZChannelDecibel_Factory::getInstance(OZChannelDecibel_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelDecibel_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelDecibel_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDecibel_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelDecibel_Factory::_instance;
}

uint64_t OZChannelFrame_Factory::getInstance(OZChannelFrame_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelFrame_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelFrame_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelFrame_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelFrame_Factory::_instance;
}

uint64_t OZChannelTimecode_Factory::getInstance(OZChannelTimecode_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelTimecode_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelTimecode_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelTimecode_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelTimecode_Factory::_instance;
}

uint64_t OZChannelBlindData_Factory::getInstance(OZChannelBlindData_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelBlindData_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelBlindData_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelBlindData_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelBlindData_Factory::_instance;
}

uint64_t OZChannelCurve_Factory::getInstance(OZChannelCurve_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelCurve_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelCurve_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelCurve_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelCurve_Factory::_instance;
}

uint64_t OZChannelEnum_Factory::getInstance(OZChannelEnum_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelEnum_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelEnum_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelEnum_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelEnum_Factory::_instance;
}

uint64_t OZChannelGradientWithAngle_Factory::getInstance(OZChannelGradientWithAngle_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelGradientWithAngle_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelGradientWithAngle_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGradientWithAngle_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGradientWithAngle_Factory::_instance;
}

uint64_t OZChannelHistogramSample_Factory::getInstance(OZChannelHistogramSample_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelHistogramSample_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelHistogramSample_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelHistogramSample_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelHistogramSample_Factory::_instance;
}

uint64_t OZChannelProgress_Factory::getInstance(OZChannelProgress_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelProgress_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelProgress_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelProgress_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelProgress_Factory::_instance;
}

uint64_t OZChannelScaleOverLife_Factory::getInstance(OZChannelScaleOverLife_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelScaleOverLife_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelScaleOverLife_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelScaleOverLife_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelScaleOverLife_Factory::_instance;
}

uint64_t OZChannelVertexFolder_Factory::getInstance(OZChannelVertexFolder_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelVertexFolder_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChannelVertexFolder_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelVertexFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelVertexFolder_Factory::_instance;
}

uint64_t OZChanObjectRef_Factory::getInstance(OZChanObjectRef_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChanObjectRef_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    id v3 = &v4;
    std::__call_once(&OZChanObjectRef_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChanObjectRef_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChanObjectRef_Factory::_instance;
}

void *OZFactories::getFactoryLoadMap(OZFactories *this)
{
  if (!v1) {
    operator new();
  }
  return v1;
}

uint64_t **OZFactories::setFactoryLoadID(OZFactories *this, unsigned int a2, OZFactory *a3)
{
  unsigned int v6 = a2;
  FactoryLoadMap = (uint64_t **)OZFactories::getFactoryLoadMap(this);
  int v7 = &v6;
  uint64_t result = std::__tree<std::__value_type<unsigned int,PVImageBuffer * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVImageBuffer * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVImageBuffer * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(FactoryLoadMap, &v6, (uint64_t)&std::piecewise_construct, &v7);
  result[5] = (uint64_t *)a3;
  return result;
}

void OZFactories::clearFactoryLoadIDs(OZFactories *this)
{
  FactoryLoadMap = (char *)OZFactories::getFactoryLoadMap(this);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)FactoryLoadMap, *((void **)FactoryLoadMap + 1));
  *(void *)FactoryLoadMap = FactoryLoadMap + 8;
  *((void *)FactoryLoadMap + 2) = 0;
  *((void *)FactoryLoadMap + 1) = 0;
}

uint64_t OZFactories::lookupFactory(OZFactories *this, unsigned int a2)
{
  FactoryLoadMap = OZFactories::getFactoryLoadMap(this);
  unsigned int v6 = (char *)FactoryLoadMap[1];
  uint64_t v4 = (char *)(FactoryLoadMap + 1);
  uint64_t v5 = v6;
  if (!v6) {
    return 0;
  }
  int v7 = v4;
  do
  {
    unsigned int v8 = *((_DWORD *)v5 + 8);
    BOOL v9 = v8 >= a2;
    if (v8 >= a2) {
      uint64_t v10 = (char **)v5;
    }
    else {
      uint64_t v10 = (char **)(v5 + 8);
    }
    if (v9) {
      int v7 = v5;
    }
    uint64_t v5 = *v10;
  }
  while (*v10);
  if (v7 != v4 && *((_DWORD *)v7 + 8) <= a2) {
    return *((void *)v7 + 5);
  }
  else {
    return 0;
  }
}

uint64_t OZFactories::findFactory(uint64_t a1, unsigned int *a2)
{
  id v3 = std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::find<PCUUID>(a1 + 8, a2);
  if ((_DWORD *)(a1 + 16) == v3) {
    return 0;
  }
  else {
    return *((void *)v3 + 6);
  }
}

uint64_t OZFactories::saveFactories(OZFactories *this, PCSerializerWriteStream *a2)
{
  TXSequenceChannels::pushChannelIntoChannelList(a2, (OZChannelBase *)&OZFactoryScope);
  uint64_t v4 = (char *)*((void *)this + 1);
  uint64_t v5 = (char *)this + 16;
  if (v4 != (char *)this + 16)
  {
    uint64_t v6 = 1;
    do
    {
      int v7 = (OZFactory *)*((void *)v4 + 6);
      OZFactory::setFileRefID(v7, 0);
      if (OZFactory::needsSaving(v7, v8))
      {
        unsigned int v9 = (*(uint64_t (**)(OZFactory *))(*(void *)v7 + 64))(v7);
        unsigned int v10 = (*(uint64_t (**)(OZFactory *))(*(void *)v7 + 72))(v7);
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(void *)a2 + 16))(a2, 92);
        (*(void (**)(PCSerializerWriteStream *, uint64_t, uint64_t))(*(void *)a2 + 144))(a2, 111, v6);
        (*(void (**)(PCSerializerWriteStream *, uint64_t, uint64_t))(*(void *)a2 + 192))(a2, 117, (uint64_t)v7 + 8);
        (*(void (**)(PCString *__return_ptr, OZFactory *))(*(void *)v7 + 40))(&v16, v7);
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(void *)a2 + 16))(a2, 93);
        (*(void (**)(PCSerializerWriteStream *, PCString *))(*(void *)a2 + 104))(a2, &v16);
        (*(void (**)(PCSerializerWriteStream *))(*(void *)a2 + 24))(a2);
        PCString::~PCString(&v16);
        (*(void (**)(PCString *__return_ptr, OZFactory *))(*(void *)v7 + 56))(&v15, v7);
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(void *)a2 + 16))(a2, 95);
        (*(void (**)(PCSerializerWriteStream *, PCString *))(*(void *)a2 + 104))(a2, &v15);
        (*(void (**)(PCSerializerWriteStream *))(*(void *)a2 + 24))(a2);
        PCString::~PCString(&v15);
        (*(void (**)(PCSerializerWriteStream *, uint64_t))(*(void *)a2 + 16))(a2, 94);
        (*(void (**)(PCSerializerWriteStream *, double))(*(void *)a2 + 88))(a2, (double)v10 * 0.1 + (double)v9);
        (*(void (**)(PCSerializerWriteStream *))(*(void *)a2 + 24))(a2);
        (*(void (**)(PCSerializerWriteStream *))(*(void *)a2 + 24))(a2);
        (*(void (**)(PCSerializerWriteStream *))(*(void *)a2 + 224))(a2);
        OZFactory::setNeedsSaving(v7, 0);
        OZFactory::setFileRefID(v7, (const OZFactory *)v6);
        uint64_t v6 = (v6 + 1);
      }
      id v11 = (char *)*((void *)v4 + 1);
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          id v11 = *(char **)v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (char *)*((void *)v4 + 2);
          BOOL v13 = *(void *)v12 == (void)v4;
          uint64_t v4 = v12;
        }
        while (!v13);
      }
      uint64_t v4 = v12;
    }
    while (v12 != v5);
  }
  (*(void (**)(PCSerializerWriteStream *))(*(void *)a2 + 224))(a2);
  PCSerializerWriteStream::popScope((uint64_t)a2);
  return 1;
}

void sub_1B79689C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCString::~PCString((PCString *)va);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::freeThreadSpecific(_anonymous_namespace_ *this, void *a2)
{
  id v3 = (void *)((char *)this + 8);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this, *((void **)this + 1));
  *(void *)this = v3;
  *((void *)this + 2) = 0;
  *id v3 = 0;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this, 0);
  MEMORY[0x1BA9BFBA0](this, 0x1020C4062D53EE8);

  return pthread_setspecific(v4, 0);
}

void std::__call_once_param<std::tuple<OZChannelBase_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7968AAC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelBase_Factory::OZChannelBase_Factory(OZChannelBase_Factory *this)
{
  long long v4 = xmmword_1B8378A00;
  long long v3 = 0uLL;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *char v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FB428;
  *((void *)this + 16) = &unk_1F10FB4F8;
}

void sub_1B7968B78(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelBase_Factory::create(OZChannelBase_Factory *this, const PCString *a2)
{
}

void sub_1B7968BEC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40384E9B0FLL);
  _Unwind_Resume(a1);
}

void OZChannelBase_Factory::createCopy(OZChannelBase_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7968CA4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40384E9B0FLL);
  _Unwind_Resume(a1);
}

void OZChannelBase_Factory::createChannelCopy(OZChannelBase_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7968D14(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40384E9B0FLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannel_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7968D84(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannel_Factory::OZChannel_Factory(OZChannel_Factory *this)
{
  long long v3 = xmmword_1B8378A00;
  long long v4 = xmmword_1B8378A10;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *char v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FB550;
  *((void *)this + 16) = &unk_1F10FB620;
}

void sub_1B7968E54(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelDouble_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7968EB4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelDouble_Factory::OZChannelDouble_Factory(OZChannelDouble_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378A20;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *char v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FB678;
  *((void *)this + 16) = &unk_1F10FB748;
}

void sub_1B7968F84(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelDouble_Factory::create(OZChannelDouble_Factory *this, const PCString *a2)
{
}

void sub_1B7969000(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelDouble_Factory::createCopy(OZChannelDouble_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B79690F4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelDouble_Factory::createChannelCopy(OZChannelDouble_Factory *this, OZChannelBase *a2)
{
}

void sub_1B79691E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelDouble::OZChannelDouble(OZChannelDouble *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  *(void *)unsigned int v9 = &unk_1F1100CF0;
  *((void *)v9 + 2) = &unk_1F1101050;
  OZChannelDoubleInfo = (OZChannelDouble *)OZChannelDouble::createOZChannelDoubleInfo(v9);
  if (a6)
  {
    uint64_t v11 = *((void *)this + 17);
  }
  else
  {
    uint64_t v11 = OZChannelDouble::_OZChannelDoubleInfo;
    *((void *)this + 17) = OZChannelDouble::_OZChannelDoubleInfo;
  }
  *((void *)this + 16) = v11;
  OZChannelDouble::createOZChannelDoubleImpl(OZChannelDoubleInfo);
  if (a5)
  {
    uint64_t v12 = *((void *)this + 15);
  }
  else
  {
    uint64_t v12 = OZChannelDouble::_OZChannelDoubleImpl;
    *((void *)this + 15) = OZChannelDouble::_OZChannelDoubleImpl;
  }
  *((void *)this + 14) = v12;
}

void sub_1B79692DC(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelBool_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796933C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelBool_Factory::OZChannelBool_Factory(OZChannelBool_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378A30;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *char v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FB7A0;
  *((void *)this + 16) = &unk_1F10FB870;
}

void sub_1B796940C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelBool_Factory::create(OZChannelBool_Factory *this, const PCString *a2)
{
}

void sub_1B7969488(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelBool_Factory::createCopy(OZChannelBool_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7969540(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelBool_Factory::createChannelCopy(OZChannelBool_Factory *this, OZChannelBase *a2)
{
}

void sub_1B79695F8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelUint32_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7969668(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelUint32_Factory::OZChannelUint32_Factory(OZChannelUint32_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378A40;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *char v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FB8C8;
  *((void *)this + 16) = &unk_1F10FB998;
}

void sub_1B7969738(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelUint32_Factory::create(OZChannelUint32_Factory *this, const PCString *a2)
{
}

void sub_1B79697B4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelUint32_Factory::createCopy(OZChannelUint32_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B79698A8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelUint32_Factory::createChannelCopy(OZChannelUint32_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796999C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelUint32::OZChannelUint32(OZChannelUint32 *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&unk_1F1101490;
  v9->var2 = (void **)&unk_1F11017F0;
  OZChannelUint32Info = (OZChannelUint32 *)OZChannelUint32::createOZChannelUint32Info(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelUint32::_OZChannelUint32Info;
    this->var17 = (OZChannelInfo *)OZChannelUint32::_OZChannelUint32Info;
  }
  this->var16 = var17;
  OZChannelUint32::createOZChannelUint32Impl(OZChannelUint32Info);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelUint32::_OZChannelUint32Impl;
    this->var15 = (OZChannelImpl *)OZChannelUint32::_OZChannelUint32Impl;
  }
  this->var14 = var15;
}

void sub_1B7969A90(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelAngle_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7969AF0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelAngle_Factory::OZChannelAngle_Factory(OZChannelAngle_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378A50;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *char v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FB9F0;
  *((void *)this + 16) = &unk_1F10FBAC0;
}

void sub_1B7969BC0(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelAngle_Factory::create(OZChannelAngle_Factory *this, const PCString *a2)
{
}

void sub_1B7969C3C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelAngle_Factory::createCopy(OZChannelAngle_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7969D30(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelAngle_Factory::createChannelCopy(OZChannelAngle_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7969E24(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelAngle::OZChannelAngle(OZChannelAngle *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&unk_1F11010C0;
  v9->var2 = (void **)&unk_1F1101420;
  OZChannelAngleInfo = (OZChannelAngle *)OZChannelAngle::createOZChannelAngleInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelAngle::_OZChannelAngleInfo;
    this->var17 = (OZChannelInfo *)OZChannelAngle::_OZChannelAngleInfo;
  }
  this->var16 = var17;
  OZChannelAngle::createOZChannelAngleImpl(OZChannelAngleInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelAngle::_OZChannelAngleImpl;
    this->var15 = (OZChannelImpl *)OZChannelAngle::_OZChannelAngleImpl;
  }
  this->var14 = var15;
}

void sub_1B7969F18(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelPercent_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7969F78(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelPercent_Factory::OZChannelPercent_Factory(OZChannelPercent_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378A60;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *char v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FBB18;
  *((void *)this + 16) = &unk_1F10FBBE8;
}

void sub_1B796A048(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelPercent_Factory::create(OZChannelPercent_Factory *this, const PCString *a2)
{
}

void sub_1B796A0C4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelPercent_Factory::createCopy(OZChannelPercent_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796A17C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelPercent_Factory::createChannelCopy(OZChannelPercent_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796A234(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelShearAngle_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796A2A4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelShearAngle_Factory::OZChannelShearAngle_Factory(OZChannelShearAngle_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378A70;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *char v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FBC40;
  *((void *)this + 16) = &unk_1F10FBD10;
}

void sub_1B796A374(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelShearAngle_Factory::create(OZChannelShearAngle_Factory *this, const PCString *a2)
{
}

void sub_1B796A3F0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelShearAngle_Factory::createCopy(OZChannelShearAngle_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796A4E4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelShearAngle_Factory::createChannelCopy(OZChannelShearAngle_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796A5D8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelShearAngle::OZChannelShearAngle(OZChannelShearAngle *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&unk_1F1101C30;
  v9->var2 = (void **)&unk_1F1101F90;
  OZChannelShearAngleInfo = (OZChannelShearAngle *)OZChannelShearAngle::createOZChannelShearAngleInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelShearAngle::_OZChannelShearAngleInfo;
    this->var17 = (OZChannelInfo *)OZChannelShearAngle::_OZChannelShearAngleInfo;
  }
  this->var16 = var17;
  OZChannelShearAngle::createOZChannelShearAngleImpl(OZChannelShearAngleInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelShearAngle::_OZChannelShearAngleImpl;
    this->var15 = (OZChannelImpl *)OZChannelShearAngle::_OZChannelShearAngleImpl;
  }
  this->var14 = var15;
}

void sub_1B796A6CC(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelShearAngle::createOZChannelShearAngleInfo(OZChannelShearAngle *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelShearAngle::createOZChannelShearAngleInfo(void)::_OZChannelShearAngleInfo_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelShearAngle::createOZChannelShearAngleInfo(void)::_OZChannelShearAngleInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelShearAngle::createOZChannelShearAngleInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelShearAngle::_OZChannelShearAngleInfo;
}

uint64_t OZChannelShearAngle::createOZChannelShearAngleImpl(OZChannelShearAngle *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelShearAngle::createOZChannelShearAngleImpl(void)::_OZChannelShearAngleImpl_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelShearAngle::createOZChannelShearAngleImpl(void)::_OZChannelShearAngleImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelShearAngle::createOZChannelShearAngleImpl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelShearAngle::_OZChannelShearAngleImpl;
}

void std::__call_once_param<std::tuple<OZChannelShearAngle::createOZChannelShearAngleInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZChannelShearAngle::_OZChannelShearAngleInfo) {
    operator new();
  }
}

void sub_1B796A80C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelShearAngleInfo::OZChannelShearAngleInfo(OZChannelShearAngleInfo *this)
{
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -1.57079633, 1.57079633, 0.0174532925, 0.000174532925, 57.2957795, "°");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(void *)this = &unk_1F10FBD68;
  *((void *)this + 1glBindFramebuffer(target, 0) = &unk_1F10FBD88;
}

void sub_1B796A8CC(_Unwind_Exception *a1)
{
  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelShearAngle::createOZChannelShearAngleImpl(void)::{lambda(void)#1} &&>>()
{
}

void OZChannelShearAngle::createOZChannelShearAngleImpl(void)::{lambda(void)#1}::operator()()
{
  if (!OZChannelShearAngle::_OZChannelShearAngleImpl) {
    operator new();
  }
}

void sub_1B796A9C0(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelAspectRatio_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796AA64(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatio_Factory::OZChannelAspectRatio_Factory(OZChannelAspectRatio_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378A80;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FBE58;
  *((void *)this + 16) = &unk_1F10FBF28;
}

void sub_1B796AB34(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatio_Factory::create(OZChannelAspectRatio_Factory *this, const PCString *a2)
{
}

void sub_1B796ABB0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatio_Factory::createCopy(OZChannelAspectRatio_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796ACA4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatio_Factory::createChannelCopy(OZChannelAspectRatio_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796AD98(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatio::OZChannelAspectRatio(OZChannelAspectRatio *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&unk_1F1102000;
  v9->var2 = (void **)&unk_1F1102360;
  OZChannelAspectRatioInfo = (OZChannelAspectRatio *)OZChannelAspectRatio::createOZChannelAspectRatioInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelAspectRatio::_OZChannelAspectRatioInfo;
    this->var17 = (OZChannelInfo *)OZChannelAspectRatio::_OZChannelAspectRatioInfo;
  }
  this->var16 = var17;
  OZChannelAspectRatio::createOZChannelAspectRatioImpl(OZChannelAspectRatioInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelAspectRatio::_OZChannelAspectRatioImpl;
    this->var15 = (OZChannelImpl *)OZChannelAspectRatio::_OZChannelAspectRatioImpl;
  }
  this->var14 = var15;
}

void sub_1B796AE8C(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelAspectRatio::createOZChannelAspectRatioInfo(OZChannelAspectRatio *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelAspectRatio::createOZChannelAspectRatioInfo(void)::_OZChannelAspectRatioInfo_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelAspectRatio::createOZChannelAspectRatioInfo(void)::_OZChannelAspectRatioInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatio::createOZChannelAspectRatioInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAspectRatio::_OZChannelAspectRatioInfo;
}

uint64_t OZChannelAspectRatio::createOZChannelAspectRatioImpl(OZChannelAspectRatio *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelAspectRatio::createOZChannelAspectRatioImpl(void)::_OZChannelAspectRatioImpl_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelAspectRatio::createOZChannelAspectRatioImpl(void)::_OZChannelAspectRatioImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatio::createOZChannelAspectRatioImpl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAspectRatio::_OZChannelAspectRatioImpl;
}

void std::__call_once_param<std::tuple<OZChannelAspectRatio::createOZChannelAspectRatioInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZChannelAspectRatio::_OZChannelAspectRatioInfo) {
    operator new();
  }
}

void sub_1B796AFCC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatioInfo::OZChannelAspectRatioInfo(OZChannelAspectRatioInfo *this)
{
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 3.0, 0.0001, 0.1, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(void *)this = &unk_1F10FBF80;
  *((void *)this + 1glBindFramebuffer(target, 0) = &unk_1F10FBFA0;
}

void sub_1B796B080(_Unwind_Exception *a1)
{
  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatio::createOZChannelAspectRatioImpl(void)::{lambda(void)#1} &&>>()
{
}

void OZChannelAspectRatio::createOZChannelAspectRatioImpl(void)::{lambda(void)#1}::operator()()
{
  if (!OZChannelAspectRatio::_OZChannelAspectRatioImpl) {
    operator new();
  }
}

void sub_1B796B174(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelAspectRatioFootage_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796B218(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatioFootage_Factory::OZChannelAspectRatioFootage_Factory(OZChannelAspectRatioFootage_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378A90;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FC070;
  *((void *)this + 16) = &unk_1F10FC140;
}

void sub_1B796B2E8(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatioFootage_Factory::create(OZChannelAspectRatioFootage_Factory *this, const PCString *a2)
{
}

void sub_1B796B364(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatioFootage_Factory::createCopy(OZChannelAspectRatioFootage_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796B458(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatioFootage_Factory::createChannelCopy(OZChannelAspectRatioFootage_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796B54C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatioFootage::OZChannelAspectRatioFootage(OZChannelAspectRatioFootage *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&unk_1F11023D0;
  v9->var2 = (void **)&unk_1F1102730;
  OZChannelAspectRatioFootageInfo = (OZChannelAspectRatioFootage *)OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageInfo;
    this->var17 = (OZChannelInfo *)OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageInfo;
  }
  this->var16 = var17;
  OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(OZChannelAspectRatioFootageInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageImpl;
    this->var15 = (OZChannelImpl *)OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageImpl;
  }
  this->var14 = var15;
}

void sub_1B796B640(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageInfo(OZChannelAspectRatioFootage *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageInfo(void)::_OZChannelAspectRatioFootageInfo_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageInfo(void)::_OZChannelAspectRatioFootageInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageInfo;
}

uint64_t OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(OZChannelAspectRatioFootage *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(void)::_OZChannelAspectRatioFootageImpl_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(void)::_OZChannelAspectRatioFootageImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageImpl;
}

void std::__call_once_param<std::tuple<OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageInfo) {
    operator new();
  }
}

void sub_1B796B780(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelAspectRatioFootageInfo::OZChannelAspectRatioFootageInfo(OZChannelAspectRatioFootageInfo *this)
{
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 3.0, 0.0001, 0.1, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(void *)this = &unk_1F10FC198;
  *((void *)this + 1glBindFramebuffer(target, 0) = &unk_1F10FC1B8;
}

void sub_1B796B834(_Unwind_Exception *a1)
{
  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(void)::{lambda(void)#1} &&>>()
{
}

void OZChannelAspectRatioFootage::createOZChannelAspectRatioFootageImpl(void)::{lambda(void)#1}::operator()()
{
  if (!OZChannelAspectRatioFootage::_OZChannelAspectRatioFootageImpl) {
    operator new();
  }
}

void sub_1B796B928(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGammaFootage_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796B9CC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGammaFootage_Factory::OZChannelGammaFootage_Factory(OZChannelGammaFootage_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378AA0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FC288;
  *((void *)this + 16) = &unk_1F10FC358;
}

void sub_1B796BA9C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelGammaFootage_Factory::create(OZChannelGammaFootage_Factory *this, const PCString *a2)
{
}

void sub_1B796BB18(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelGammaFootage_Factory::createCopy(OZChannelGammaFootage_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796BC0C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelGammaFootage_Factory::createChannelCopy(OZChannelGammaFootage_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796BD00(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelGammaFootage::OZChannelGammaFootage(OZChannelGammaFootage *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&unk_1F11027A0;
  v9->var2 = (void **)&unk_1F1102B00;
  OZChannelGammaFootageInfo = (OZChannelGammaFootage *)OZChannelGammaFootage::createOZChannelGammaFootageInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelGammaFootage::_OZChannelGammaFootageInfo;
    this->var17 = (OZChannelInfo *)OZChannelGammaFootage::_OZChannelGammaFootageInfo;
  }
  this->var16 = var17;
  OZChannelGammaFootage::createOZChannelGammaFootageImpl(OZChannelGammaFootageInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelGammaFootage::_OZChannelGammaFootageImpl;
    this->var15 = (OZChannelImpl *)OZChannelGammaFootage::_OZChannelGammaFootageImpl;
  }
  this->var14 = var15;
}

void sub_1B796BDF4(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelGammaFootage::createOZChannelGammaFootageInfo(OZChannelGammaFootage *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelGammaFootage::createOZChannelGammaFootageInfo(void)::_OZChannelGammaFootageInfo_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelGammaFootage::createOZChannelGammaFootageInfo(void)::_OZChannelGammaFootageInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGammaFootage::createOZChannelGammaFootageInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGammaFootage::_OZChannelGammaFootageInfo;
}

uint64_t OZChannelGammaFootage::createOZChannelGammaFootageImpl(OZChannelGammaFootage *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelGammaFootage::createOZChannelGammaFootageImpl(void)::_OZChannelGammaFootageImpl_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelGammaFootage::createOZChannelGammaFootageImpl(void)::_OZChannelGammaFootageImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGammaFootage::createOZChannelGammaFootageImpl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelGammaFootage::_OZChannelGammaFootageImpl;
}

void std::__call_once_param<std::tuple<OZChannelGammaFootage::createOZChannelGammaFootageInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZChannelGammaFootage::_OZChannelGammaFootageInfo) {
    operator new();
  }
}

void sub_1B796BF34(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelGammaFootageInfo::OZChannelGammaFootageInfo(OZChannelGammaFootageInfo *this)
{
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 3.0, 0.0001, 0.1, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(void *)this = &unk_1F10FC3B0;
  *((void *)this + 1glBindFramebuffer(target, 0) = &unk_1F10FC3D0;
}

void sub_1B796BFE8(_Unwind_Exception *a1)
{
  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelGammaFootage::createOZChannelGammaFootageImpl(void)::{lambda(void)#1} &&>>()
{
}

void OZChannelGammaFootage::createOZChannelGammaFootageImpl(void)::{lambda(void)#1}::operator()()
{
  if (!OZChannelGammaFootage::_OZChannelGammaFootageImpl) {
    operator new();
  }
}

void sub_1B796C0DC(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796C180(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelFolder_Factory::OZChannelFolder_Factory(OZChannelFolder_Factory *this)
{
  long long v3 = xmmword_1B8378A00;
  long long v4 = xmmword_1B7E77A70;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FC4A0;
  *((void *)this + 16) = &unk_1F10FC570;
}

void sub_1B796C250(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelFolder_Factory::create(OZChannelFolder_Factory *this, const PCString *a2)
{
}

void sub_1B796C2C8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void OZChannelFolder_Factory::createCopy(OZChannelFolder_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796C380(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void OZChannelFolder_Factory::createChannelCopy(OZChannelFolder_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796C438(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZCompoundChannel_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796C4A8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZCompoundChannel_Factory::OZCompoundChannel_Factory(OZCompoundChannel_Factory *this)
{
  long long v3 = xmmword_1B7E77A70;
  long long v4 = xmmword_1B7E78CE0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FC5C8;
  *((void *)this + 16) = &unk_1F10FC698;
}

void sub_1B796C578(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZCompoundChannel_Factory::create(OZCompoundChannel_Factory *this, const PCString *a2)
{
}

void sub_1B796C5F0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40441104D3);
  _Unwind_Resume(a1);
}

void OZCompoundChannel_Factory::createCopy(OZCompoundChannel_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796C6A8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40441104D3);
  _Unwind_Resume(a1);
}

void OZCompoundChannel_Factory::createChannelCopy(OZCompoundChannel_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796C760(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40441104D3);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannel2D_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796C7D0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannel2D_Factory::OZChannel2D_Factory(OZChannel2D_Factory *this)
{
  long long v3 = xmmword_1B7E78CE0;
  long long v4 = xmmword_1B8378AB0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FC6F0;
  *((void *)this + 16) = &unk_1F10FC7C0;
}

void sub_1B796C8A0(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannel2D_Factory::create(OZChannel2D_Factory *this, const PCString *a2)
{
}

void sub_1B796C920(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

void OZChannel2D_Factory::createCopy(OZChannel2D_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796C9D8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

void OZChannel2D_Factory::createChannelCopy(OZChannel2D_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796CA90(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelBool3D_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796CB00(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelBool3D_Factory::OZChannelBool3D_Factory(OZChannelBool3D_Factory *this)
{
  long long v3 = xmmword_1B7E78CE0;
  long long v4 = xmmword_1B8378AC0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FC818;
  *((void *)this + 16) = &unk_1F10FC8E8;
}

void sub_1B796CBD0(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelBool3D_Factory::create(OZChannelBool3D_Factory *this, const PCString *a2)
{
}

void sub_1B796CC48(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void OZChannelBool3D_Factory::createCopy(OZChannelBool3D_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796CD00(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void OZChannelBool3D_Factory::createChannelCopy(OZChannelBool3D_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796CDB8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelPosition_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796CE28(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelPosition_Factory::OZChannelPosition_Factory(OZChannelPosition_Factory *this)
{
  long long v3 = xmmword_1B8378AB0;
  long long v4 = xmmword_1B8378AD0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FC940;
  *((void *)this + 16) = &unk_1F10FCA10;
}

void sub_1B796CEF8(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelPosition_Factory::create(OZChannelPosition_Factory *this, const PCString *a2)
{
}

void sub_1B796CF78(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C4011F1C4E7);
  _Unwind_Resume(a1);
}

void OZChannelPosition_Factory::createCopy(OZChannelPosition_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796D030(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C4011F1C4E7);
  _Unwind_Resume(a1);
}

void OZChannelPosition_Factory::createChannelCopy(OZChannelPosition_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796D0E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C4011F1C4E7);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelPositionPercent_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796D158(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelPositionPercent_Factory::OZChannelPositionPercent_Factory(OZChannelPositionPercent_Factory *this)
{
  long long v3 = xmmword_1B8378AB0;
  long long v4 = xmmword_1B8378AE0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FCA68;
  *((void *)this + 16) = &unk_1F10FCB38;
}

void sub_1B796D228(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelPositionPercent_Factory::create(OZChannelPositionPercent_Factory *this, const PCString *a2)
{
}

void sub_1B796D29C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40D0902988);
  _Unwind_Resume(a1);
}

void OZChannelPositionPercent_Factory::createCopy(OZChannelPositionPercent_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796D354(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40D0902988);
  _Unwind_Resume(a1);
}

void OZChannelPositionPercent_Factory::createChannelCopy(OZChannelPositionPercent_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796D40C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40D0902988);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelShear_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796D47C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelShear_Factory::OZChannelShear_Factory(OZChannelShear_Factory *this)
{
  long long v3 = xmmword_1B7E78CE0;
  long long v4 = xmmword_1B8378AF0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FCB90;
  *((void *)this + 16) = &unk_1F10FCC60;
}

void sub_1B796D54C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelShear_Factory::create(OZChannelShear_Factory *this, const PCString *a2)
{
}

void sub_1B796D5C4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

void OZChannelShear_Factory::createCopy(OZChannelShear_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796D67C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

void OZChannelShear_Factory::createChannelCopy(OZChannelShear_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796D734(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelScale_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796D7A4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelScale_Factory::OZChannelScale_Factory(OZChannelScale_Factory *this)
{
  long long v3 = xmmword_1B8378AB0;
  long long v4 = xmmword_1B8378B00;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FCCB8;
  *((void *)this + 16) = &unk_1F10FCD88;
}

void sub_1B796D874(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelScale_Factory::create(OZChannelScale_Factory *this, const PCString *a2)
{
}

void sub_1B796D8E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

void OZChannelScale_Factory::createCopy(OZChannelScale_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796D9A0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

void OZChannelScale_Factory::createChannelCopy(OZChannelScale_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796DA58(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40479DDD51);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannel3D_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796DAC8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannel3D_Factory::OZChannel3D_Factory(OZChannel3D_Factory *this)
{
  long long v3 = xmmword_1B7E78CE0;
  long long v4 = xmmword_1B8378B10;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FCDE0;
  *((void *)this + 16) = &unk_1F10FCEB0;
}

void sub_1B796DB98(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannel3D_Factory::create(OZChannel3D_Factory *this, const PCString *a2)
{
}

void sub_1B796DC18(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void OZChannel3D_Factory::createCopy(OZChannel3D_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796DCD0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void OZChannel3D_Factory::createChannelCopy(OZChannel3D_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796DD88(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelPosition3D_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796DDF8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelPosition3D_Factory::OZChannelPosition3D_Factory(OZChannelPosition3D_Factory *this)
{
  long long v3 = xmmword_1B8378AD0;
  long long v4 = xmmword_1B8378B20;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FCF08;
  *((void *)this + 16) = &unk_1F10FCFD8;
}

void sub_1B796DEC8(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelPosition3D_Factory::create(OZChannelPosition3D_Factory *this, const PCString *a2)
{
}

void sub_1B796DF40(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40CC6A35F7);
  _Unwind_Resume(a1);
}

void OZChannelPosition3D_Factory::createCopy(OZChannelPosition3D_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796DFF8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40CC6A35F7);
  _Unwind_Resume(a1);
}

void OZChannelPosition3D_Factory::createChannelCopy(OZChannelPosition3D_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796E0B0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40CC6A35F7);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelRotation3D_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796E120(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelRotation3D_Factory::OZChannelRotation3D_Factory(OZChannelRotation3D_Factory *this)
{
  long long v3 = xmmword_1B7E78CE0;
  long long v4 = xmmword_1B8378B30;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FD030;
  *((void *)this + 16) = &unk_1F10FD100;
}

void sub_1B796E1F0(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelRotation3D_Factory::create(OZChannelRotation3D_Factory *this, const PCString *a2)
{
}

void sub_1B796E268(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40A120F8A5);
  _Unwind_Resume(a1);
}

void OZChannelRotation3D_Factory::createCopy(OZChannelRotation3D_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796E320(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40A120F8A5);
  _Unwind_Resume(a1);
}

void OZChannelRotation3D_Factory::createChannelCopy(OZChannelRotation3D_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796E3D8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40A120F8A5);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelScale3D_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796E448(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelScale3D_Factory::OZChannelScale3D_Factory(OZChannelScale3D_Factory *this)
{
  long long v3 = xmmword_1B8378B00;
  long long v4 = xmmword_1B8378B40;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FD158;
  *((void *)this + 16) = &unk_1F10FD228;
}

void sub_1B796E518(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelScale3D_Factory::create(OZChannelScale3D_Factory *this, const PCString *a2)
{
}

void sub_1B796E58C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void OZChannelScale3D_Factory::createCopy(OZChannelScale3D_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796E644(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void OZChannelScale3D_Factory::createChannelCopy(OZChannelScale3D_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796E6FC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelColorNoAlpha_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796E76C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelColorNoAlpha_Factory::OZChannelColorNoAlpha_Factory(OZChannelColorNoAlpha_Factory *this)
{
  long long v3 = xmmword_1B7E78CE0;
  long long v4 = xmmword_1B8378B50;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FD280;
  *((void *)this + 16) = &unk_1F10FD350;
}

void sub_1B796E83C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelColorNoAlpha_Factory::create(OZChannelColorNoAlpha_Factory *this, const PCString *a2)
{
}

void sub_1B796E8B4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40C7C6813ELL);
  _Unwind_Resume(a1);
}

void OZChannelColorNoAlpha_Factory::createCopy(OZChannelColorNoAlpha_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796E96C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40C7C6813ELL);
  _Unwind_Resume(a1);
}

void OZChannelColorNoAlpha_Factory::createChannelCopy(OZChannelColorNoAlpha_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796EA24(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40C7C6813ELL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelColor_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796EA94(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelColor_Factory::OZChannelColor_Factory(OZChannelColor_Factory *this)
{
  long long v3 = xmmword_1B8378B50;
  long long v4 = xmmword_1B8378B60;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FD3A8;
  *((void *)this + 16) = &unk_1F10FD478;
}

void sub_1B796EB64(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelColor_Factory::create(OZChannelColor_Factory *this, const PCString *a2)
{
}

void sub_1B796EBDC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C400BEEEC36);
  _Unwind_Resume(a1);
}

void OZChannelColor_Factory::createCopy(OZChannelColor_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796EC94(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C400BEEEC36);
  _Unwind_Resume(a1);
}

void OZChannelColor_Factory::createChannelCopy(OZChannelColor_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796ED4C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C400BEEEC36);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelQuad_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796EDBC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelQuad_Factory::OZChannelQuad_Factory(OZChannelQuad_Factory *this)
{
  long long v3 = xmmword_1B7E77A70;
  long long v4 = xmmword_1B8378B70;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FD4D0;
  *((void *)this + 16) = &unk_1F10FD5A0;
}

void sub_1B796EE8C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelQuad_Factory::create(OZChannelQuad_Factory *this, const PCString *a2)
{
}

void sub_1B796EF04(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C408B27E029);
  _Unwind_Resume(a1);
}

void OZChannelQuad_Factory::createCopy(OZChannelQuad_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796EFBC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C408B27E029);
  _Unwind_Resume(a1);
}

void OZChannelQuad_Factory::createChannelCopy(OZChannelQuad_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796F074(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C408B27E029);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelCrop_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796F0E4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelCrop_Factory::OZChannelCrop_Factory(OZChannelCrop_Factory *this)
{
  long long v3 = xmmword_1B7E78CE0;
  long long v4 = xmmword_1B8378B80;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FD5F8;
  *((void *)this + 16) = &unk_1F10FD6C8;
}

void sub_1B796F1B4(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelCrop_Factory::create(OZChannelCrop_Factory *this, const PCString *a2)
{
}

void sub_1B796F22C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40044ED5BALL);
  _Unwind_Resume(a1);
}

void OZChannelCrop_Factory::createCopy(OZChannelCrop_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796F2E4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40044ED5BALL);
  _Unwind_Resume(a1);
}

void OZChannelCrop_Factory::createChannelCopy(OZChannelCrop_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796F39C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40044ED5BALL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelDiscreteColor_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796F40C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelDiscreteColor_Factory::OZChannelDiscreteColor_Factory(OZChannelDiscreteColor_Factory *this)
{
  long long v3 = xmmword_1B8378BA0;
  long long v4 = xmmword_1B8378B90;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 0);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FD720;
  *((void *)this + 16) = &unk_1F10FD7F0;
}

void sub_1B796F4DC(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelDiscreteColor_Factory::create(OZChannelDiscreteColor_Factory *this, const PCString *a2)
{
}

void sub_1B796F594(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

void OZChannelDiscreteColor_Factory::createCopy(OZChannelDiscreteColor_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796F688(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

void OZChannelDiscreteColor_Factory::createChannelCopy(OZChannelDiscreteColor_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796F77C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradient_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796F7EC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradient_Factory::OZChannelGradient_Factory(OZChannelGradient_Factory *this)
{
  long long v3 = xmmword_1B7E77A70;
  long long v4 = xmmword_1B8378BB0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FD848;
  *((void *)this + 16) = &unk_1F10FD918;
}

void sub_1B796F8BC(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelGradient_Factory::create(OZChannelGradient_Factory *this, const PCString *a2)
{
}

void sub_1B796F930(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4072D3B705);
  _Unwind_Resume(a1);
}

void OZChannelGradient_Factory::createCopy(OZChannelGradient_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796F9E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4072D3B705);
  _Unwind_Resume(a1);
}

void OZChannelGradient_Factory::description(PCString *a1@<X8>)
{
}

PCString *OZChannelGradient_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Channel Gradient Desc");
}

const char *OZChannelGradient_Factory::getBundleID(OZChannelGradient_Factory *this)
{
  return "com.apple.prochannel.framework";
}

PCString *OZChannelGradient_Factory::getLibraryIconNameInternal@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "OZLibraryGradientIcon");
}

void OZChannelGradient_Factory::createChannelCopy(OZChannelGradient_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796FAE4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4072D3B705);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientRGBFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796FB54(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientRGBFolder_Factory::OZChannelGradientRGBFolder_Factory(OZChannelGradientRGBFolder_Factory *this)
{
  long long v3 = xmmword_1B8378BD0;
  long long v4 = xmmword_1B8378BC0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FD970;
  *((void *)this + 16) = &unk_1F10FDA40;
}

void sub_1B796FC24(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelGradientRGBFolder_Factory::create(OZChannelGradientRGBFolder_Factory *this, const PCString *a2)
{
}

void sub_1B796FC98(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void OZChannelGradientRGBFolder_Factory::createCopy(OZChannelGradientRGBFolder_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B796FD50(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void OZChannelGradientRGBFolder_Factory::createChannelCopy(OZChannelGradientRGBFolder_Factory *this, OZChannelBase *a2)
{
}

void sub_1B796FE08(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientAlphaFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B796FE78(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientAlphaFolder_Factory::OZChannelGradientAlphaFolder_Factory(OZChannelGradientAlphaFolder_Factory *this)
{
  long long v3 = xmmword_1B8378BD0;
  long long v4 = xmmword_1B8378BE0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FDA98;
  *((void *)this + 16) = &unk_1F10FDB68;
}

void sub_1B796FF48(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelGradientAlphaFolder_Factory::create(OZChannelGradientAlphaFolder_Factory *this, const PCString *a2)
{
}

void sub_1B796FFBC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void OZChannelGradientAlphaFolder_Factory::createCopy(OZChannelGradientAlphaFolder_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7970074(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void OZChannelGradientAlphaFolder_Factory::createChannelCopy(OZChannelGradientAlphaFolder_Factory *this, OZChannelBase *a2)
{
}

void sub_1B797012C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientSample_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B797019C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientSample_Factory::OZChannelGradientSample_Factory(OZChannelGradientSample_Factory *this)
{
  long long v3 = xmmword_1B7E77A70;
  long long v4 = xmmword_1B8378BF0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FDBC0;
  *((void *)this + 16) = &unk_1F10FDC90;
}

void sub_1B797026C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelGradientSample_Factory::create(OZChannelGradientSample_Factory *this, const PCString *a2)
{
}

void sub_1B79702E0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40E74858DCLL);
  _Unwind_Resume(a1);
}

void OZChannelGradientSample_Factory::createCopy(OZChannelGradientSample_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7970398(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40E74858DCLL);
  _Unwind_Resume(a1);
}

void OZChannelGradientSample_Factory::createChannelCopy(OZChannelGradientSample_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7970450(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40E74858DCLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientSampleRGB_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B79704C0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientSampleRGB_Factory::OZChannelGradientSampleRGB_Factory(OZChannelGradientSampleRGB_Factory *this)
{
  long long v3 = xmmword_1B8378BF0;
  long long v4 = xmmword_1B8378C00;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FDCE8;
  *((void *)this + 16) = &unk_1F10FDDB8;
}

void sub_1B7970590(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelGradientSampleRGB_Factory::create(OZChannelGradientSampleRGB_Factory *this, const PCString *a2)
{
}

void sub_1B7970604(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40C9B629ABLL);
  _Unwind_Resume(a1);
}

void OZChannelGradientSampleRGB_Factory::createCopy(OZChannelGradientSampleRGB_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B79706BC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40C9B629ABLL);
  _Unwind_Resume(a1);
}

void OZChannelGradientSampleRGB_Factory::createChannelCopy(OZChannelGradientSampleRGB_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7970774(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40C9B629ABLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientSampleAlpha_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B79707E4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientSampleAlpha_Factory::OZChannelGradientSampleAlpha_Factory(OZChannelGradientSampleAlpha_Factory *this)
{
  long long v3 = xmmword_1B8378BF0;
  long long v4 = xmmword_1B8378C10;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FDE10;
  *((void *)this + 16) = &unk_1F10FDEE0;
}

void sub_1B79708B4(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelGradientSampleAlpha_Factory::create(OZChannelGradientSampleAlpha_Factory *this, const PCString *a2)
{
}

void sub_1B7970928(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C408C14BFF9);
  _Unwind_Resume(a1);
}

void OZChannelGradientSampleAlpha_Factory::createCopy(OZChannelGradientSampleAlpha_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B79709E0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C408C14BFF9);
  _Unwind_Resume(a1);
}

void OZChannelGradientSampleAlpha_Factory::createChannelCopy(OZChannelGradientSampleAlpha_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7970A98(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C408C14BFF9);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientExtras_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7970B08(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientExtras_Factory::OZChannelGradientExtras_Factory(OZChannelGradientExtras_Factory *this)
{
  long long v3 = xmmword_1B8378BB0;
  long long v4 = xmmword_1B8378C20;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FDF38;
  *((void *)this + 16) = &unk_1F10FE008;
}

void sub_1B7970BD8(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelGradientExtras_Factory::create(OZChannelGradientExtras_Factory *this, const PCString *a2)
{
}

void sub_1B7970C4C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C409FA7E95DLL);
  _Unwind_Resume(a1);
}

void OZChannelGradientExtras_Factory::createCopy(OZChannelGradientExtras_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7970D04(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C409FA7E95DLL);
  _Unwind_Resume(a1);
}

void OZChannelGradientExtras_Factory::description(PCString *a1@<X8>)
{
}

PCString *OZChannelGradientExtras_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "GradientExtras");
}

void OZChannelGradientExtras_Factory::createChannelCopy(OZChannelGradientExtras_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7970DE4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C409FA7E95DLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientPositioned_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7970E54(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientPositioned_Factory::OZChannelGradientPositioned_Factory(OZChannelGradientPositioned_Factory *this)
{
  long long v3 = xmmword_1B8378C20;
  long long v4 = xmmword_1B8378C30;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FE060;
  *((void *)this + 16) = &unk_1F10FE130;
}

void sub_1B7970F24(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelGradientPositioned_Factory::create(OZChannelGradientPositioned_Factory *this, const PCString *a2)
{
}

void sub_1B7970F98(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40C94B7CBALL);
  _Unwind_Resume(a1);
}

void OZChannelGradientPositioned_Factory::createCopy(OZChannelGradientPositioned_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7971050(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40C94B7CBALL);
  _Unwind_Resume(a1);
}

void OZChannelGradientPositioned_Factory::createChannelCopy(OZChannelGradientPositioned_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7971108(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40C94B7CBALL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelVaryingFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7971178(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelVaryingFolder_Factory::OZChannelVaryingFolder_Factory(OZChannelVaryingFolder_Factory *this)
{
  long long v3 = xmmword_1B7E77A70;
  long long v4 = xmmword_1B8378BD0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FE188;
  *((void *)this + 16) = &unk_1F10FE258;
}

void sub_1B7971248(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelVaryingFolder_Factory::create(OZChannelVaryingFolder_Factory *this, const PCString *a2)
{
}

void sub_1B79712BC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void OZChannelVaryingFolder_Factory::createCopy(OZChannelVaryingFolder_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7971374(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void OZChannelVaryingFolder_Factory::createChannelCopy(OZChannelVaryingFolder_Factory *this, OZChannelBase *a2)
{
}

void sub_1B797142C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40138C3426);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelObjectRootBase_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B797149C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelObjectRootBase_Factory::OZChannelObjectRootBase_Factory(OZChannelObjectRootBase_Factory *this)
{
  long long v3 = xmmword_1B7E77A70;
  long long v4 = xmmword_1B8378C40;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FE2B0;
  *((void *)this + 16) = &unk_1F10FE380;
}

void sub_1B797156C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelObjectRootBase_Factory::create(OZChannelObjectRootBase_Factory *this, const PCString *a2)
{
}

void sub_1B79715E0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40C173384DLL);
  _Unwind_Resume(a1);
}

void OZChannelObjectRootBase_Factory::createCopy(OZChannelObjectRootBase_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7971698(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40C173384DLL);
  _Unwind_Resume(a1);
}

void OZChannelObjectRootBase_Factory::createChannelCopy(OZChannelObjectRootBase_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7971750(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40C173384DLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelHistogram_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B79717C0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelHistogram_Factory::OZChannelHistogram_Factory(OZChannelHistogram_Factory *this)
{
  long long v3 = xmmword_1B7E77A70;
  long long v4 = xmmword_1B8378C50;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FE3D8;
  *((void *)this + 16) = &unk_1F10FE4A8;
}

void sub_1B7971890(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelHistogram_Factory::create(OZChannelHistogram_Factory *this, const PCString *a2)
{
}

void sub_1B7971908(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40F1099EF6);
  _Unwind_Resume(a1);
}

void OZChannelHistogram_Factory::createCopy(OZChannelHistogram_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B79719C0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40F1099EF6);
  _Unwind_Resume(a1);
}

void OZChannelHistogram_Factory::createChannelCopy(OZChannelHistogram_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7971A78(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40F1099EF6);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelLevels_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7971AE8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelLevels_Factory::OZChannelLevels_Factory(OZChannelLevels_Factory *this)
{
  long long v3 = xmmword_1B7E77A70;
  long long v4 = xmmword_1B8378C60;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FE500;
  *((void *)this + 16) = &unk_1F10FE5D0;
}

void sub_1B7971BB8(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelLevels_Factory::create(OZChannelLevels_Factory *this, const PCString *a2)
{
}

void sub_1B7971C30(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void OZChannelLevels_Factory::createCopy(OZChannelLevels_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7971CE8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void OZChannelLevels_Factory::createChannelCopy(OZChannelLevels_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7971DA0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelButton_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7971E10(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelButton_Factory::OZChannelButton_Factory(OZChannelButton_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378C70;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FE628;
  *((void *)this + 16) = &unk_1F10FE6F8;
}

void sub_1B7971EE0(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelButton_Factory::create(OZChannelButton_Factory *this, const PCString *a2)
{
}

void sub_1B7971F54(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

void OZChannelButton_Factory::createCopy(OZChannelButton_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B797200C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

void OZChannelButton_Factory::createChannelCopy(OZChannelButton_Factory *this, OZChannelBase *a2)
{
}

void sub_1B79720C4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelHelpButton_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7972134(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelHelpButton_Factory::OZChannelHelpButton_Factory(OZChannelHelpButton_Factory *this)
{
  long long v3 = xmmword_1B8378C70;
  long long v4 = xmmword_1B8378C80;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FE750;
  *((void *)this + 16) = &unk_1F10FE820;
}

void sub_1B7972204(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelHelpButton_Factory::create(OZChannelHelpButton_Factory *this, const PCString *a2)
{
}

void sub_1B7972278(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

void OZChannelHelpButton_Factory::createCopy(OZChannelHelpButton_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7972330(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

void OZChannelHelpButton_Factory::createChannelCopy(OZChannelHelpButton_Factory *this, OZChannelBase *a2)
{
}

void sub_1B79723E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C400C70C378);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelText_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7972458(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelText_Factory::OZChannelText_Factory(OZChannelText_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B7E78CA0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FE878;
  *((void *)this + 16) = &unk_1F10FE948;
}

void sub_1B7972528(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelText_Factory::create(OZChannelText_Factory *this, const PCString *a2)
{
}

void sub_1B797259C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BB3F29BDLL);
  _Unwind_Resume(a1);
}

void OZChannelText_Factory::createCopy(OZChannelText_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7972654(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BB3F29BDLL);
  _Unwind_Resume(a1);
}

void OZChannelText_Factory::createChannelCopy(OZChannelText_Factory *this, OZChannelBase *a2)
{
}

void sub_1B797270C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BB3F29BDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelDoubleOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B797277C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelDoubleOverRange_Factory::OZChannelDoubleOverRange_Factory(OZChannelDoubleOverRange_Factory *this)
{
  long long v3 = xmmword_1B8378A20;
  long long v4 = xmmword_1B8378C90;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FE9A0;
  *((void *)this + 16) = &unk_1F10FEA70;
}

void sub_1B797284C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelDoubleOverRange_Factory::create(OZChannelDoubleOverRange_Factory *this, const PCString *a2)
{
}

void sub_1B79728C0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

void OZChannelDoubleOverRange_Factory::createCopy(OZChannelDoubleOverRange_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7972978(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

void OZChannelDoubleOverRange_Factory::createChannelCopy(OZChannelDoubleOverRange_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7972A30(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelScaleOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7972AA0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelScaleOverRange_Factory::OZChannelScaleOverRange_Factory(OZChannelScaleOverRange_Factory *this)
{
  long long v3 = xmmword_1B8378B00;
  long long v4 = xmmword_1B8378CA0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FEAC8;
  *((void *)this + 16) = &unk_1F10FEB98;
}

void sub_1B7972B70(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelScaleOverRange_Factory::create(OZChannelScaleOverRange_Factory *this, const PCString *a2)
{
}

void sub_1B7972BE4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40112F5121);
  _Unwind_Resume(a1);
}

void OZChannelScaleOverRange_Factory::createCopy(OZChannelScaleOverRange_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7972C9C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40112F5121);
  _Unwind_Resume(a1);
}

void OZChannelScaleOverRange_Factory::createChannelCopy(OZChannelScaleOverRange_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7972D54(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40112F5121);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelAngleOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7972DC4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelAngleOverRange_Factory::OZChannelAngleOverRange_Factory(OZChannelAngleOverRange_Factory *this)
{
  long long v3 = xmmword_1B8378A50;
  long long v4 = xmmword_1B8378CB0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FEBF0;
  *((void *)this + 16) = &unk_1F10FECC0;
}

void sub_1B7972E94(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelAngleOverRange_Factory::create(OZChannelAngleOverRange_Factory *this, const PCString *a2)
{
}

void sub_1B7972F08(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

void OZChannelAngleOverRange_Factory::createCopy(OZChannelAngleOverRange_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7972FC0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

void OZChannelAngleOverRange_Factory::createChannelCopy(OZChannelAngleOverRange_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7973078(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelPercentOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B79730E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelPercentOverRange_Factory::OZChannelPercentOverRange_Factory(OZChannelPercentOverRange_Factory *this)
{
  long long v3 = xmmword_1B8378A60;
  long long v4 = xmmword_1B8378CC0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FED18;
  *((void *)this + 16) = &unk_1F10FEDE8;
}

void sub_1B79731B8(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelPercentOverRange_Factory::create(OZChannelPercentOverRange_Factory *this, const PCString *a2)
{
}

void sub_1B797322C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

void OZChannelPercentOverRange_Factory::createCopy(OZChannelPercentOverRange_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B79732E4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

void OZChannelPercentOverRange_Factory::createChannelCopy(OZChannelPercentOverRange_Factory *this, OZChannelBase *a2)
{
}

void sub_1B797339C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BC15552ELL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannel2DOverRange_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B797340C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannel2DOverRange_Factory::OZChannel2DOverRange_Factory(OZChannel2DOverRange_Factory *this)
{
  long long v3 = xmmword_1B8378AB0;
  long long v4 = xmmword_1B8378CD0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FEE40;
  *((void *)this + 16) = &unk_1F10FEF10;
}

void sub_1B79734DC(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannel2DOverRange_Factory::create(OZChannel2DOverRange_Factory *this, const PCString *a2)
{
}

void sub_1B7973550(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40112F5121);
  _Unwind_Resume(a1);
}

void OZChannel2DOverRange_Factory::createCopy(OZChannel2DOverRange_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7973608(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40112F5121);
  _Unwind_Resume(a1);
}

void OZChannel2DOverRange_Factory::createChannelCopy(OZChannel2DOverRange_Factory *this, OZChannelBase *a2)
{
}

void sub_1B79736C0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40112F5121);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelTransformSwitch_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7973730(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelTransformSwitch_Factory::OZChannelTransformSwitch_Factory(OZChannelTransformSwitch_Factory *this)
{
  long long v3 = xmmword_1B7E78CE0;
  long long v4 = xmmword_1B8378CE0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FEF68;
  *((void *)this + 16) = &unk_1F10FF038;
}

void sub_1B7973800(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelTransformSwitch_Factory::create(OZChannelTransformSwitch_Factory *this, const PCString *a2)
{
}

void sub_1B7973878(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void OZChannelTransformSwitch_Factory::createCopy(OZChannelTransformSwitch_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7973930(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void OZChannelTransformSwitch_Factory::createChannelCopy(OZChannelTransformSwitch_Factory *this, OZChannelBase *a2)
{
}

void sub_1B79739E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406E094D3BLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelUint16_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7973A58(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelUint16_Factory::OZChannelUint16_Factory(OZChannelUint16_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378CF0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FF090;
  *((void *)this + 16) = &unk_1F10FF160;
}

void sub_1B7973B28(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelUint16_Factory::create(OZChannelUint16_Factory *this, const PCString *a2)
{
}

void sub_1B7973BA4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelUint16_Factory::createCopy(OZChannelUint16_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7973C98(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelUint16_Factory::createChannelCopy(OZChannelUint16_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7973D8C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelUint16::OZChannelUint16(OZChannelUint16 *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&unk_1F1101860;
  v9->var2 = (void **)&unk_1F1101BC0;
  OZChannelUint16Info = (OZChannelUint16 *)OZChannelUint16::createOZChannelUint16Info(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelUint16::_OZChannelUint16Info;
    this->var17 = (OZChannelInfo *)OZChannelUint16::_OZChannelUint16Info;
  }
  this->var16 = var17;
  OZChannelUint16::createOZChannelUint16Impl(OZChannelUint16Info);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelUint16::_OZChannelUint16Impl;
    this->var15 = (OZChannelImpl *)OZChannelUint16::_OZChannelUint16Impl;
  }
  this->var14 = var15;
}

void sub_1B7973E80(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelUint16::createOZChannelUint16Info(OZChannelUint16 *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelUint16::createOZChannelUint16Info(void)::_OZChannelUint16Info_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelUint16::createOZChannelUint16Info(void)::_OZChannelUint16Info_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelUint16::createOZChannelUint16Info(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelUint16::_OZChannelUint16Info;
}

uint64_t OZChannelUint16::createOZChannelUint16Impl(OZChannelUint16 *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelUint16::createOZChannelUint16Impl(void)::_OZChannelUint16Impl_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelUint16::createOZChannelUint16Impl(void)::_OZChannelUint16Impl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelUint16::createOZChannelUint16Impl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelUint16::_OZChannelUint16Impl;
}

void std::__call_once_param<std::tuple<OZChannelUint16::createOZChannelUint16Info(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZChannelUint16::_OZChannelUint16Info) {
    operator new();
  }
}

void sub_1B7973FC0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelUint16Info::OZChannelUint16Info(OZChannelUint16Info *this)
{
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 65535.0, 1.0, 1.0, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(void *)this = &unk_1F10FF1B8;
  *((void *)this + 1glBindFramebuffer(target, 0) = &unk_1F10FF1D8;
}

void sub_1B7974070(_Unwind_Exception *a1)
{
  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelUint16::createOZChannelUint16Impl(void)::{lambda(void)#1} &&>>()
{
}

void OZChannelUint16::createOZChannelUint16Impl(void)::{lambda(void)#1}::operator()()
{
  if (!OZChannelUint16::_OZChannelUint16Impl) {
    operator new();
  }
}

void sub_1B7974164(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelSeed_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7974208(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelSeed_Factory::OZChannelSeed_Factory(OZChannelSeed_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378D00;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FF2A8;
  *((void *)this + 16) = &unk_1F10FF378;
}

void sub_1B79742D8(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelSeed_Factory::create(OZChannelSeed_Factory *this, const PCString *a2)
{
}

void sub_1B7974354(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelSeed_Factory::createCopy(OZChannelSeed_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7974448(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelSeed_Factory::createChannelCopy(OZChannelSeed_Factory *this, OZChannelBase *a2)
{
}

void sub_1B797453C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelSeed::OZChannelSeed(OZChannelSeed *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&unk_1F1102B70;
  v9->var2 = (void **)&unk_1F1102ED0;
  OZChannelSeedInfo = (OZChannelSeed *)OZChannelSeed::createOZChannelSeedInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelSeed::_OZChannelSeedInfo;
    this->var17 = (OZChannelInfo *)OZChannelSeed::_OZChannelSeedInfo;
  }
  this->var16 = var17;
  OZChannelSeed::createOZChannelSeedImpl(OZChannelSeedInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelSeed::_OZChannelSeedImpl;
    this->var15 = (OZChannelImpl *)OZChannelSeed::_OZChannelSeedImpl;
  }
  this->var14 = var15;
}

void sub_1B7974630(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelDecibel_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7974690(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelDecibel_Factory::OZChannelDecibel_Factory(OZChannelDecibel_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378D10;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FF3D0;
  *((void *)this + 16) = &unk_1F10FF4A0;
}

void sub_1B7974760(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelDecibel_Factory::create(OZChannelDecibel_Factory *this, const PCString *a2)
{
}

void sub_1B79747DC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelDecibel_Factory::createCopy(OZChannelDecibel_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B79748D0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelDecibel_Factory::createChannelCopy(OZChannelDecibel_Factory *this, OZChannelBase *a2)
{
}

void sub_1B79749C4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelDecibel::OZChannelDecibel(OZChannelDecibel *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&unk_1F1102F40;
  v9->var2 = (void **)&unk_1F11032A0;
  OZChannelDecibelInfo = (OZChannelDecibel *)OZChannelDecibel::createOZChannelDecibelInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelDecibel::_OZChannelDecibelInfo;
    this->var17 = (OZChannelInfo *)OZChannelDecibel::_OZChannelDecibelInfo;
  }
  this->var16 = var17;
  OZChannelDecibel::createOZChannelDecibelImpl(OZChannelDecibelInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelDecibel::_OZChannelDecibelImpl;
    this->var15 = (OZChannelImpl *)OZChannelDecibel::_OZChannelDecibelImpl;
  }
  this->var14 = var15;
}

void sub_1B7974AB8(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelDecibel::createOZChannelDecibelInfo(OZChannelDecibel *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelDecibel::createOZChannelDecibelInfo(void)::_OZChannelDecibelInfo_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelDecibel::createOZChannelDecibelInfo(void)::_OZChannelDecibelInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDecibel::createOZChannelDecibelInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelDecibel::_OZChannelDecibelInfo;
}

uint64_t OZChannelDecibel::createOZChannelDecibelImpl(OZChannelDecibel *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelDecibel::createOZChannelDecibelImpl(void)::_OZChannelDecibelImpl_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelDecibel::createOZChannelDecibelImpl(void)::_OZChannelDecibelImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDecibel::createOZChannelDecibelImpl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelDecibel::_OZChannelDecibelImpl;
}

void std::__call_once_param<std::tuple<OZChannelDecibel::createOZChannelDecibelInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZChannelDecibel::_OZChannelDecibelInfo) {
    operator new();
  }
}

void sub_1B7974BF8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelDecibelInfo::OZChannelDecibelInfo(OZChannelDecibelInfo *this)
{
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 4.0, 1.0, 0.1, 1.0, "dB");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(void *)this = &unk_1F10FF4F8;
  *((void *)this + 1glBindFramebuffer(target, 0) = &unk_1F10FF518;
}

void sub_1B7974CA8(_Unwind_Exception *a1)
{
  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelDecibel::createOZChannelDecibelImpl(void)::{lambda(void)#1} &&>>()
{
}

void OZChannelDecibel::createOZChannelDecibelImpl(void)::{lambda(void)#1}::operator()()
{
  if (!OZChannelDecibel::_OZChannelDecibelImpl) {
    operator new();
  }
}

void sub_1B7974D9C(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelFrame_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7974E40(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelFrame_Factory::OZChannelFrame_Factory(OZChannelFrame_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378D20;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FF5E8;
  *((void *)this + 16) = &unk_1F10FF6B8;
}

void sub_1B7974F10(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelFrame_Factory::create(OZChannelFrame_Factory *this, const PCString *a2)
{
}

void sub_1B7974F8C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelFrame_Factory::createCopy(OZChannelFrame_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7975080(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelFrame_Factory::createChannelCopy(OZChannelFrame_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7975174(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelFrame::OZChannelFrame(OZChannelFrame *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&unk_1F1103310;
  v9->var2 = (void **)&unk_1F1103670;
  OZChannelFrameInfo = (OZChannelFrame *)OZChannelFrame::createOZChannelFrameInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelFrame::_OZChannelFrameInfo;
    this->var17 = (OZChannelInfo *)OZChannelFrame::_OZChannelFrameInfo;
  }
  this->var16 = var17;
  OZChannelFrame::createOZChannelFrameImpl(OZChannelFrameInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelFrame::_OZChannelFrameImpl;
    this->var15 = (OZChannelImpl *)OZChannelFrame::_OZChannelFrameImpl;
  }
  this->var14 = var15;
}

void sub_1B7975268(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelFrame::createOZChannelFrameInfo(OZChannelFrame *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelFrame::createOZChannelFrameInfo(void)::_OZChannelFrameInfo_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelFrame::createOZChannelFrameInfo(void)::_OZChannelFrameInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelFrame::createOZChannelFrameInfo(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelFrame::_OZChannelFrameInfo;
}

uint64_t OZChannelFrame::createOZChannelFrameImpl(OZChannelFrame *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelFrame::createOZChannelFrameImpl(void)::_OZChannelFrameImpl_once, memory_order_acquire) != -1)
  {
    long long v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&OZChannelFrame::createOZChannelFrameImpl(void)::_OZChannelFrameImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelFrame::createOZChannelFrameImpl(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelFrame::_OZChannelFrameImpl;
}

void std::__call_once_param<std::tuple<OZChannelFrame::createOZChannelFrameInfo(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZChannelFrame::_OZChannelFrameInfo) {
    operator new();
  }
}

void sub_1B79753A8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelFrameInfo::OZChannelFrameInfo(OZChannelFrameInfo *this)
{
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 100.0, 1.0, 0.01, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(void *)this = &unk_1F10FF710;
  *((void *)this + 1glBindFramebuffer(target, 0) = &unk_1F10FF730;
}

void sub_1B797545C(_Unwind_Exception *a1)
{
  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelFrame::createOZChannelFrameImpl(void)::{lambda(void)#1} &&>>()
{
}

void OZChannelFrame::createOZChannelFrameImpl(void)::{lambda(void)#1}::operator()()
{
  if (!OZChannelFrame::_OZChannelFrameImpl) {
    operator new();
  }
}

void sub_1B7975550(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelTimecode_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B79755F4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelTimecode_Factory::OZChannelTimecode_Factory(OZChannelTimecode_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378D30;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FF800;
  *((void *)this + 16) = &unk_1F10FF8D0;
}

void sub_1B79756C4(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelTimecode_Factory::create(OZChannelTimecode_Factory *this, const PCString *a2)
{
}

void sub_1B7975740(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelTimecode_Factory::createCopy(OZChannelTimecode_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7975834(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelTimecode_Factory::createChannelCopy(OZChannelTimecode_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7975928(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChannelTimecode::OZChannelTimecode(OZChannelTimecode *this, OZFactory *a2, const PCString *a3, unsigned int a4, OZChannelImpl *a5, OZChannelInfo *a6)
{
  OZChannel::OZChannel((OZChannel *)this, a2, a3, 0, a4, 0, a5, a6);
  v9->var0 = (void **)&unk_1F11036E0;
  v9->var2 = (void **)&unk_1F1103A40;
  OZChannelTimecodeInfo = (OZChannelTimecode *)OZChannelTimecode::createOZChannelTimecodeInfo(v9);
  if (a6)
  {
    var17 = this->var17;
  }
  else
  {
    var17 = (OZChannelInfo *)OZChannelTimecode::_OZChannelTimecodeInfo;
    this->var17 = (OZChannelInfo *)OZChannelTimecode::_OZChannelTimecodeInfo;
  }
  this->var16 = var17;
  OZChannelTimecode::createOZChannelTimecodeImpl(OZChannelTimecodeInfo);
  if (a5)
  {
    var15 = this->var15;
  }
  else
  {
    var15 = (OZChannelImpl *)OZChannelTimecode::_OZChannelTimecodeImpl;
    this->var15 = (OZChannelImpl *)OZChannelTimecode::_OZChannelTimecodeImpl;
  }
  this->var14 = var15;
}

void sub_1B7975A1C(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelBlindData_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7975A7C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelBlindData_Factory::OZChannelBlindData_Factory(OZChannelBlindData_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378D40;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FF928;
  *((void *)this + 16) = &unk_1F10FF9F8;
}

void sub_1B7975B4C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelBlindData_Factory::create(OZChannelBlindData_Factory *this, const PCString *a2)
{
}

void sub_1B7975BDC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C4038C80BD5);
  _Unwind_Resume(a1);
}

void OZChannelBlindData_Factory::createCopy(OZChannelBlindData_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7975C94(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C4038C80BD5);
  _Unwind_Resume(a1);
}

void OZChannelBlindData_Factory::createChannelCopy(OZChannelBlindData_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7975D4C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C4038C80BD5);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelCurve_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7975DBC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelCurve_Factory::OZChannelCurve_Factory(OZChannelCurve_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378D50;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FFA50;
  *((void *)this + 16) = &unk_1F10FFB20;
}

void sub_1B7975E8C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelCurve_Factory::create(OZChannelCurve_Factory *this, const PCString *a2)
{
}

void sub_1B7975F00(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

void OZChannelCurve_Factory::createCopy(OZChannelCurve_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7975FB8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

void OZChannelCurve_Factory::createChannelCopy(OZChannelCurve_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7976070(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelEnum_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B79760E0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelEnum_Factory::OZChannelEnum_Factory(OZChannelEnum_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378BA0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FFB78;
  *((void *)this + 16) = &unk_1F10FFC48;
}

void sub_1B79761B0(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelEnum_Factory::create(OZChannelEnum_Factory *this, const PCString *a2)
{
}

void sub_1B797622C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

void OZChannelEnum_Factory::createCopy(OZChannelEnum_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B79762E4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

void OZChannelEnum_Factory::createChannelCopy(OZChannelEnum_Factory *this, OZChannelBase *a2)
{
}

void sub_1B797639C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C405E89EA5DLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelGradientWithAngle_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B797640C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelGradientWithAngle_Factory::OZChannelGradientWithAngle_Factory(OZChannelGradientWithAngle_Factory *this)
{
  long long v3 = xmmword_1B8378C20;
  long long v4 = xmmword_1B8378D60;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FFCA0;
  *((void *)this + 16) = &unk_1F10FFD70;
}

void sub_1B79764DC(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelGradientWithAngle_Factory::create(OZChannelGradientWithAngle_Factory *this, const PCString *a2)
{
}

void sub_1B7976550(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40FB5DE3D8);
  _Unwind_Resume(a1);
}

void OZChannelGradientWithAngle_Factory::createCopy(OZChannelGradientWithAngle_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7976608(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40FB5DE3D8);
  _Unwind_Resume(a1);
}

void OZChannelGradientWithAngle_Factory::createChannelCopy(OZChannelGradientWithAngle_Factory *this, OZChannelBase *a2)
{
}

void sub_1B79766C0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40FB5DE3D8);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelHistogramSample_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7976730(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelHistogramSample_Factory::OZChannelHistogramSample_Factory(OZChannelHistogramSample_Factory *this)
{
  long long v3 = xmmword_1B7E77A70;
  long long v4 = xmmword_1B8378D70;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FFDC8;
  *((void *)this + 16) = &unk_1F10FFE98;
}

void sub_1B7976800(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelHistogramSample_Factory::create(OZChannelHistogramSample_Factory *this, const PCString *a2)
{
}

void sub_1B7976878(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40933A2D21);
  _Unwind_Resume(a1);
}

void OZChannelHistogramSample_Factory::createCopy(OZChannelHistogramSample_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7976930(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40933A2D21);
  _Unwind_Resume(a1);
}

void OZChannelHistogramSample_Factory::createChannelCopy(OZChannelHistogramSample_Factory *this, OZChannelBase *a2)
{
}

void sub_1B79769E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40933A2D21);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelProgress_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7976A58(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelProgress_Factory::OZChannelProgress_Factory(OZChannelProgress_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378D80;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F10FFEF0;
  *((void *)this + 16) = &unk_1F10FFFC0;
}

void sub_1B7976B28(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelProgress_Factory::create(OZChannelProgress_Factory *this, const PCString *a2)
{
}

void sub_1B7976B9C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40C6BB7E01);
  _Unwind_Resume(a1);
}

void OZChannelProgress_Factory::createCopy(OZChannelProgress_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7976C54(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40C6BB7E01);
  _Unwind_Resume(a1);
}

void OZChannelProgress_Factory::createChannelCopy(OZChannelProgress_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7976D0C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40C6BB7E01);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelScaleOverLife_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7976D7C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelScaleOverLife_Factory::OZChannelScaleOverLife_Factory(OZChannelScaleOverLife_Factory *this)
{
  long long v3 = xmmword_1B8378D50;
  long long v4 = xmmword_1B8378D90;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F1100018;
  *((void *)this + 16) = &unk_1F11000E8;
}

void sub_1B7976E4C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelScaleOverLife_Factory::create(OZChannelScaleOverLife_Factory *this, const PCString *a2)
{
}

void sub_1B7976EC0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

void OZChannelScaleOverLife_Factory::createCopy(OZChannelScaleOverLife_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7976F78(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

void OZChannelScaleOverLife_Factory::createChannelCopy(OZChannelScaleOverLife_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7977030(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C401ABBD6EFLL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelVertexFolder_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B79770A0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelVertexFolder_Factory::OZChannelVertexFolder_Factory(OZChannelVertexFolder_Factory *this)
{
  long long v3 = xmmword_1B7E77A70;
  long long v4 = xmmword_1B8378DA0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F1100140;
  *((void *)this + 16) = &unk_1F1100210;
}

void sub_1B7977170(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelVertexFolder_Factory::create(OZChannelVertexFolder_Factory *this, const PCString *a2)
{
}

void sub_1B79771E4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40C4B5480ALL);
  _Unwind_Resume(a1);
}

void OZChannelVertexFolder_Factory::createCopy(OZChannelVertexFolder_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B797729C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40C4B5480ALL);
  _Unwind_Resume(a1);
}

void OZChannelVertexFolder_Factory::createChannelCopy(OZChannelVertexFolder_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7977354(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40C4B5480ALL);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChanObjectRef_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B79773C4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChanObjectRef_Factory::OZChanObjectRef_Factory(OZChanObjectRef_Factory *this)
{
  long long v3 = xmmword_1B8378A10;
  long long v4 = xmmword_1B8378DB0;
  uint64_t v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *uint64_t v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F1100268;
  *((void *)this + 16) = &unk_1F1100338;
}

void sub_1B7977494(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChanObjectRef_Factory::create(OZChanObjectRef_Factory *this, const PCString *a2)
{
}

void sub_1B7977508(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChanObjectRef_Factory::createCopy(OZChanObjectRef_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B79775C0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

void OZChanObjectRef_Factory::createChannelCopy(OZChanObjectRef_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7977678(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409BAC03F7);
  _Unwind_Resume(a1);
}

_OWORD *std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__emplace_unique_key_args<PCUUID,std::piecewise_construct_t const&,std::tuple<PCUUID const&>,std::tuple<>>(uint64_t **a1, unsigned int *a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v6 = std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__find_equal<PCUUID>((uint64_t)a1, &v10, a2);
  int v7 = (_OWORD *)*v6;
  if (!*v6)
  {
    unsigned int v8 = (uint64_t **)v6;
    int v7 = operator new(0x38uLL);
    v7[2] = **a4;
    *((void *)v7 + 6) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t *std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__find_equal<PCUUID>(uint64_t a1, void *a2, unsigned int *a3)
{
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  uint64_t result = (uint64_t *)(a1 + 8);
  long long v4 = v5;
  if (v5)
  {
    unsigned int v6 = *a3;
    unsigned int v7 = a3[1];
    unsigned int v8 = a3[2];
    unsigned int v9 = a3[3];
    while (1)
    {
      uint64_t v10 = v4;
      unsigned int v11 = *((_DWORD *)v4 + 8);
      if (v6 != v11) {
        break;
      }
      unsigned int v12 = *((_DWORD *)v10 + 9);
      if (v7 == v12)
      {
        unsigned int v13 = *((_DWORD *)v10 + 10);
        BOOL v14 = v8 >= v13;
        if (v8 == v13) {
          BOOL v14 = v9 >= *((_DWORD *)v10 + 11);
        }
        if (!v14) {
          goto LABEL_18;
        }
        unsigned int v15 = *((_DWORD *)v10 + 10);
        BOOL v16 = v15 >= v8;
        if (v15 != v8) {
          goto LABEL_14;
        }
        if (*((_DWORD *)v10 + 11) >= v9) {
          goto LABEL_23;
        }
LABEL_15:
        uint64_t result = v10 + 1;
        long long v4 = (uint64_t *)v10[1];
        if (!v4) {
          goto LABEL_23;
        }
      }
      else
      {
        if (v7 >= v12)
        {
          if (v12 >= v7) {
            goto LABEL_23;
          }
          goto LABEL_15;
        }
LABEL_18:
        long long v4 = (uint64_t *)*v10;
        uint64_t result = v10;
        if (!*v10) {
          goto LABEL_23;
        }
      }
    }
    if (v6 >= v11)
    {
      BOOL v16 = v11 >= v6;
LABEL_14:
      if (v16) {
        goto LABEL_23;
      }
      goto LABEL_15;
    }
    goto LABEL_18;
  }
  uint64_t v10 = result;
LABEL_23:
  *a2 = v10;
  return result;
}

_DWORD *std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::find<PCUUID>(uint64_t a1, unsigned int *a2)
{
  long long v3 = (_DWORD *)(a1 + 8);
  uint64_t result = std::__tree<std::__value_type<PCUUID,OZFactory *>,std::__map_value_compare<PCUUID,std::__value_type<PCUUID,OZFactory *>,std::less<PCUUID>,true>,std::allocator<std::__value_type<PCUUID,OZFactory *>>>::__lower_bound<PCUUID>(a1, a2, *(_DWORD **)(a1 + 8), (_DWORD *)(a1 + 8));
  if (v3 == result) {
    return v3;
  }
  unsigned int v5 = result[8];
  BOOL v6 = *a2 >= v5;
  if (*a2 == v5)
  {
    unsigned int v7 = a2[1];
    unsigned int v8 = result[9];
    BOOL v6 = v7 >= v8;
    if (v7 == v8)
    {
      unsigned int v9 = a2[2];
      unsigned int v10 = result[10];
      BOOL v6 = v9 >= v10;
      if (v9 == v10) {
        BOOL v6 = a2[3] >= result[11];
      }
    }
  }
  if (!v6) {
    return v3;
  }
  return result;
}