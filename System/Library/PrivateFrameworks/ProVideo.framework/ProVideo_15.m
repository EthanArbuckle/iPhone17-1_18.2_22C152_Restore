uint64_t non-virtual thunk to'PSEmitter::doesTransformFromLocalToScreenSpace(PSEmitter *this, CMTime *a2)
{
  return PSEmitter::doesTransformFromLocalToScreenSpace((PSEmitter *)((char *)this - 200), a2);
}

void PSEmitter::makeRenderImageSource(PSEmitter *this, OZRenderParams *a2, const OZRenderGraphState *a3, int a4)
{
  int shouldDoLocalParticleRender = PSEmitter::shouldDoLocalParticleRender(this);
  int v7 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 168))(this) ^ 1;
  if (!a4)
  {
    if (v7 | shouldDoLocalParticleRender) {
      operator new();
    }
  }
  operator new();
}

void sub_1B7DB43CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  PCSharedCount::~PCSharedCount(v73);
  PCSharedCount::~PCSharedCount(v72);
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray((uint64_t)&STACK[0x290]);
  std::__list_imp<unsigned int>::clear(&a71);
  LiGraphBuilder::~LiGraphBuilder((LiGraphBuilder *)&STACK[0x2E0]);
  std::unique_ptr<LiGraphBuilder>::reset[abi:ne180100]((LiGraphBuilder **)(v74 - 112), 0);
  PCSharedCount::~PCSharedCount(v71);
  _Unwind_Resume(a1);
}

void *PSEmitter::buildRealRenderGraph(uint64_t a1, void *a2, OZRenderParams *a3, uint64_t a4, OZRenderGraphState *a5)
{
  OZRenderGraphState::OZRenderGraphState((OZRenderGraphState *)v31, a5);
  (*(void (**)(uint64_t, OZRenderParams *, unsigned char *))(*(void *)(a1 + 200) + 2064))(a1 + 200, a3, v31);
  if (!OZChannel::getValueAsInt((OZChannel *)(a1 + 33352), MEMORY[0x1E4F1FA48], 0.0))
  {
    if (!*a2) {
      throw_PCNullPointerException(1);
    }
    (*(void (**)(void, uint64_t))(*(void *)*a2 + 192))(*a2, 1);
  }
  BOOL hasParameter = OZRenderParams::hasParameter(a3, (const char *)kPSIsPreviewRender);
  v10 = (OZLockingGroup *)Li3DEngineScene::sceneManager((Li3DEngineScene *)a1);
  OZLockingGroup::WriteSentry::WriteSentry((OZLockingGroup::WriteSentry *)v30, v10);
  unsigned int v29 = 0;
  uint64_t v26 = (uint64_t)&v26;
  v27 = &v26;
  uint64_t v28 = 0;
  CMTime v25 = *(CMTime *)a3;
  PSEmitter::getSimList(a1, &v25, hasParameter, (uint64_t)&v26, &v29);
  if (v28)
  {
    v24[0] = &v26;
    v24[1] = a3;
    for (i = v27; i != &v26; i = (uint64_t *)i[1])
      (*(void (**)(void, OZRenderParams *))(**(void **)(i[2] + 40) + 1288))(*(void *)(i[2] + 40), a3);
    PSEmitter::RenderParams::RenderParams((PSEmitter::RenderParams *)v21, a3);
    PSEmitter::setupEmitterParams((PSEmitter *)a1, a3, (PSEmitter::RenderParams *)v21);
    __p = 0;
    v19 = 0;
    uint64_t v20 = 0;
    v17[0] = 0.0;
    v17[1] = 0.0;
    v17[2] = 1.0;
    PSEmitter::buildRenderList3D(a1, v12, &v26, v29, (long long **)&__p, 1, v17);
    v14 = (uint64_t *)__p;
    for (j = v19;
          j != v14;
          PSParticleType::buildParticleRenderGraph(j[2], (uint64_t)a2, v21, j[1], v15, a4, (const OZRenderGraphState *)v31))
    {
      v15 = (double *)*(j - 8);
      j -= 8;
    }
    if (__p)
    {
      v19 = (uint64_t *)__p;
      operator delete(__p);
    }
    LiClipSet::~LiClipSet((LiClipSet *)&v23);
    OZRenderParams::~OZRenderParams((OZRenderParams *)&v22);
    PSEmitter::PostRenderFinalizer::~PostRenderFinalizer((PSEmitter::PostRenderFinalizer *)v24);
  }
  std::__list_imp<unsigned int>::clear(&v26);
  OZLockingGroup::WriteSentry::~WriteSentry((OZLockingGroup::WriteSentry *)v30);
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray((uint64_t)&v33);
  return std::__list_imp<unsigned int>::clear(v32);
}

void sub_1B7DB47E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *__p, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  if (__p) {
    operator delete(__p);
  }
  LiClipSet::~LiClipSet((LiClipSet *)&STACK[0x5D8]);
  OZRenderParams::~OZRenderParams((OZRenderParams *)va);
  PSEmitter::PostRenderFinalizer::~PostRenderFinalizer((PSEmitter::PostRenderFinalizer *)&STACK[0x760]);
  std::__list_imp<unsigned int>::clear(&STACK[0x788]);
  OZLockingGroup::WriteSentry::~WriteSentry((OZLockingGroup::WriteSentry *)&STACK[0x7A8]);
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray((uint64_t)&STACK[0x890]);
  std::__list_imp<unsigned int>::clear(&STACK[0x7F0]);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'PSEmitter::makeRenderImageSource(PSEmitter *this, OZRenderParams *a2, const OZRenderGraphState *a3, int a4)
{
}

{
  PSEmitter::makeRenderImageSource((PSEmitter *)((char *)this - 6728), a2, a3, a4);
}

uint64_t PSEmitter::getPrecompCameraType(PSEmitter *this, const OZRenderState *a2)
{
  return 0;
}

uint64_t non-virtual thunk to'PSEmitter::getPrecompCameraType(PSEmitter *this, const OZRenderState *a2)
{
  return 0;
}

uint64_t PSEmitter::acceptsShapeMasks(PSEmitter *this)
{
  return (*(unsigned int (**)(PSEmitter *))(*(void *)this + 168))(this) ^ 1;
}

uint64_t non-virtual thunk to'PSEmitter::acceptsShapeMasks(PSEmitter *this)
{
  return (*(unsigned int (**)(void))(*((void *)this - 25) + 168))() ^ 1;
}

uint64_t PSEmitter::restrictImageMaskToStencil(PSEmitter *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 168))();
}

uint64_t non-virtual thunk to'PSEmitter::restrictImageMaskToStencil(PSEmitter *this)
{
  return (*(uint64_t (**)(void))(*((void *)this - 25) + 168))();
}

BOOL PSEmitter::is3D(PSEmitter *this)
{
  return OZChannel::getValueAsInt((OZChannel *)((char *)this + 32792), MEMORY[0x1E4F1FA48], 0.0) != 0;
}

BOOL non-virtual thunk to'PSEmitter::is3D(PSEmitter *this)
{
  return OZChannel::getValueAsInt((OZChannel *)((char *)this + 32592), MEMORY[0x1E4F1FA48], 0.0) != 0;
}

void PSEmitter::buildRenderGraph(PSEmitter *this, CMTime *a2, LiGraphBuilder *a3, const OZRenderGraphState *a4)
{
  int v8 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 168))(this);
  char v9 = v8;
  if (v8)
  {
    CMTime v11 = *a2;
    if (PSEmitter::shouldPrecompose(this, &v11)) {
      int shouldDoLocalParticleRender = 1;
    }
    else {
      int shouldDoLocalParticleRender = PSEmitter::shouldDoLocalParticleRender(this);
    }
  }
  else
  {
    int shouldDoLocalParticleRender = 0;
  }
  if ((*(unsigned int (**)(char *))(*((void *)this + 25) + 1440))((char *)this + 200))
  {
    (*(void (**)(char *, CMTime *, LiGraphBuilder *))(*((void *)this + 25) + 1976))((char *)this + 200, a2, a3);
  }
  else if (v9)
  {
    if (!shouldDoLocalParticleRender) {
      operator new();
    }
    OZRenderGraphState::OZRenderGraphState((OZRenderGraphState *)&v11, a4);
    if (PSEmitter::shouldDoLocalParticleRender(this)) {
      char v13 = 0;
    }
    LiGraphBuilder::partitionWorld((uint64_t)a3);
    OZElement::buildRenderGraph((OZElement *)((char *)this + 200), a2, a3, (const OZRenderGraphState *)&v11);
    LiGraphBuilder::partitionWorld((uint64_t)a3);
    PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray((uint64_t)&v14);
    std::__list_imp<unsigned int>::clear(v12);
  }
  else
  {
    OZElement::buildRenderGraph((OZElement *)((char *)this + 200), a2, a3, a4);
  }
}

void sub_1B7DB4C4C(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v2);
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'PSEmitter::buildRenderGraph(PSEmitter *this, CMTime *a2, LiGraphBuilder *a3, const OZRenderGraphState *a4)
{
}

{
  PSEmitter::buildRenderGraph((PSEmitter *)((char *)this - 6728), a2, a3, a4);
}

uint64_t PSEmitter::setGeodeProperties3D(PSEmitter *this, CMTime *a2, const OZRenderGraphState *a3, LiGeode *a4)
{
  OZElement::setGeodeProperties3D((uint64_t)this + 200, (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t result = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 168))(this);
  int v9 = result;
  if (*((unsigned char *)a3 + 258)) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = result == 0;
  }
  if (!v10)
  {
    uint64_t result = PSEmitter::shouldDoLocalParticleRender(this);
    if ((result & 1) == 0)
    {
      CMTime v12 = *a2;
      uint64_t result = PSEmitter::shouldPrecompose(this, &v12);
      if (result) {
        *((unsigned char *)a4 + 554) = 0;
      }
    }
  }
  if (v9 && (uint64_t result = PSEmitter::shouldDoLocalParticleRender(this), result))
  {
    CMTime v12 = *a2;
    uint64_t result = OZChannel::getValueAsInt((OZChannel *)((char *)this + 33200), &v12, 0.0);
    BOOL v11 = result != 0;
  }
  else
  {
    BOOL v11 = 0;
  }
  *((unsigned char *)a4 + 556) = v11;
  return result;
}

uint64_t non-virtual thunk to'PSEmitter::setGeodeProperties3D(PSEmitter *this, CMTime *a2, const OZRenderGraphState *a3, LiGeode *a4)
{
  return PSEmitter::setGeodeProperties3D((PSEmitter *)((char *)this - 200), a2, a3, a4);
}

uint64_t PSEmitter::hitCheck(uint64_t a1, float *a2, long long *a3, uint64_t a4, uint64_t a5, char a6)
{
  if (a6 & 4) != 0 && ((*(uint64_t (**)(void))(*(void *)(a1 + 200) + 680))()) {
    return 0;
  }
  if ((a6 & 2) != 0)
  {
    long long v31 = *a3;
    uint64_t v32 = *((void *)a3 + 2);
    if (!(*(unsigned int (**)(uint64_t, long long *, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 216) + 104))(a1 + 216, &v31, 1, 1, 1))return 0; {
  }
    }
  double v12 = *a2;
  double v29 = a2[1];
  double v30 = v12;
  uint64_t v14 = *(void *)(a1 + 200);
  uint64_t v13 = a1 + 200;
  uint64_t v28 = 0;
  int v15 = (*(uint64_t (**)(uint64_t, uint64_t, double *, double *, uint64_t *, long long *, void))(v14 + 1368))(v13, a4, &v30, &v29, &v28, a3, 0);
  uint64_t result = 0;
  if (!v15) {
    return result;
  }
  double v25 = 0.0;
  double v26 = 0.0;
  __asm { FMOV            V0.2D, #-1.0 }
  long long v27 = _Q0;
  (*(void (**)(uint64_t, double *, long long *))(*(void *)v13 + 1488))(v13, &v25, a3);
  uint64_t result = 0;
  if (*(double *)&v27 < 0.0) {
    return result;
  }
  if (*((double *)&v27 + 1) < 0.0) {
    return 0;
  }
  if (v25 > v30 || *(double *)&v27 + v25 < v30) {
    return 0;
  }
  uint64_t result = 0;
  double v23 = v29;
  if (v26 <= v29 && *((double *)&v27 + 1) + v26 >= v29)
  {
    uint64_t v24 = v28;
    *(double *)a5 = v30;
    *(double *)(a5 + 8) = v23;
    *(void *)(a5 + 16) = v24;
    return v13;
  }
  return result;
}

uint64_t non-virtual thunk to'PSEmitter::hitCheck(uint64_t a1, float *a2, long long *a3, uint64_t a4, uint64_t a5, char a6)
{
  return PSEmitter::hitCheck(a1 - 200, a2, a3, a4, a5, a6);
}

BOOL PSEmitter::hasDescendants(PSEmitter *this)
{
  return *((void *)this + 4212) != 0;
}

BOOL non-virtual thunk to'PSEmitter::hasDescendants(PSEmitter *this)
{
  return *((void *)this + 4187) != 0;
}

uint64_t PSEmitter::numberOfDescendants(PSEmitter *this)
{
  return *((unsigned int *)this + 8424);
}

uint64_t non-virtual thunk to'PSEmitter::numberOfDescendants(PSEmitter *this)
{
  return *((unsigned int *)this + 8374);
}

uint64_t PSEmitter::getDescendantAtIndex(PSEmitter *this, int a2)
{
  v2 = (char *)this + 33680;
  v3 = (char *)*((void *)this + 4211);
  BOOL v4 = v3 != (char *)this + 33680;
  if (v3 != (char *)this + 33680 && a2 != 0)
  {
    int v6 = a2 - 1;
    do
    {
      v3 = (char *)*((void *)v3 + 1);
      BOOL v8 = v6-- != 0;
      BOOL v4 = v3 != v2;
    }
    while (v3 != v2 && v8);
  }
  if (!v4) {
    return 0;
  }
  uint64_t v9 = *((void *)v3 + 2);
  if (v9) {
    return v9 + 16;
  }
  else {
    return 0;
  }
}

uint64_t non-virtual thunk to'PSEmitter::getDescendantAtIndex(PSEmitter *this, int a2)
{
  v2 = (char *)this + 33480;
  v3 = (char *)*((void *)this + 4186);
  BOOL v4 = v3 != (char *)this + 33480;
  if (a2 && v3 != (char *)this + 33480)
  {
    int v5 = a2 - 1;
    do
    {
      v3 = (char *)*((void *)v3 + 1);
      BOOL v7 = v5-- != 0;
      BOOL v4 = v3 != v2;
    }
    while (v3 != v2 && v7);
  }
  if (!v4) {
    return 0;
  }
  uint64_t v8 = *((void *)v3 + 2);
  if (v8) {
    return v8 + 16;
  }
  else {
    return 0;
  }
}

void *PSEmitter::addDescendantAfter(void *this, OZSceneNode *lpsrc, OZSceneNode *a3)
{
  if (lpsrc)
  {
    int v5 = this;
    if (this)
    {
      int v6 = v5 + 4211;
      PSParticleType::setEmitter(this, (PSEmitter *)v5);
      if (a3)
      {
        BOOL v7 = v5 + 4210;
        for (i = (void *)*v6; i != v7; i = (void *)i[1])
        {
          if ((OZSceneNode *)i[2] == a3)
          {
            if (i == v7) {
              break;
            }
            uint64_t v9 = (uint64_t *)i[1];
            BOOL v10 = operator new(0x18uLL);
            v10[2] = lpsrc;
            uint64_t v11 = *v9;
            *(void *)(v11 + 8) = v10;
            void *v10 = v11;
            *uint64_t v9 = (uint64_t)v10;
            v10[1] = v9;
            goto LABEL_12;
          }
        }
      }
      double v12 = operator new(0x18uLL);
      uint64_t v13 = (void *)*v6;
      *double v12 = v5 + 4210;
      v12[1] = v13;
      v12[2] = lpsrc;
      *uint64_t v13 = v12;
      *int v6 = v12;
LABEL_12:
      ++v5[4212];
      if (a3)
      {
        uint64_t v14 = (const OZChannelBase *)(*(uint64_t (**)(OZSceneNode *))(*(void *)a3 + 640))(a3);
        int v15 = (OZChannelBase *)(*(uint64_t (**)(OZSceneNode *))(*(void *)lpsrc + 640))(lpsrc);
        OZChannelFolder::insertDescendantAfter((OZChannelFolder *)(v5 + 2372), v14, v15);
      }
      else
      {
        v16 = (OZChannelBase *)(*(uint64_t (**)(OZSceneNode *))(*(void *)lpsrc + 640))(lpsrc);
        OZChannelFolder::push_front((OZChannelFolder *)(v5 + 2372), v16);
      }
      (*(void (**)(OZSceneNode *, void *))(*(void *)lpsrc + 256))(lpsrc, v5 + 25);
      v17 = (OZScene *)v5[146];
      if (v17)
      {
        OZScene::registerNode(v17, lpsrc);
        OZScene::addAllDependencies(v5[146], lpsrc);
      }
      v18 = *(uint64_t (**)(void *))(*v5 + 424);
      return (void *)v18(v5);
    }
  }
  return this;
}

void *non-virtual thunk to'PSEmitter::addDescendantAfter(PSEmitter *this, OZSceneNode *a2, OZSceneNode *a3)
{
  return PSEmitter::addDescendantAfter((void *)this - 25, a2, a3);
}

void *PSEmitter::addDescendantBefore(void *this, OZSceneNode *lpsrc, OZSceneNode *a3)
{
  if (lpsrc)
  {
    int v5 = this;
    if (this)
    {
      int v6 = v5 + 4210;
      PSParticleType::setEmitter(this, (PSEmitter *)v5);
      BOOL v7 = v5 + 4210;
      if (a3)
      {
        BOOL v7 = v5 + 4210;
        if ((uint64_t *)v5[4211] != v6)
        {
          BOOL v7 = (uint64_t *)v5[4211];
          while ((OZSceneNode *)v7[2] != a3)
          {
            BOOL v7 = (uint64_t *)v7[1];
            if (v7 == v6)
            {
              BOOL v7 = v5 + 4210;
              break;
            }
          }
        }
      }
      uint64_t v8 = operator new(0x18uLL);
      v8[2] = lpsrc;
      uint64_t v9 = *v7;
      *(void *)(v9 + 8) = v8;
      *uint64_t v8 = v9;
      *BOOL v7 = (uint64_t)v8;
      v8[1] = v7;
      ++v5[4212];
      if (a3)
      {
        BOOL v10 = (const OZChannelBase *)(*(uint64_t (**)(OZSceneNode *))(*(void *)a3 + 640))(a3);
        uint64_t v11 = (OZChannelBase *)(*(uint64_t (**)(OZSceneNode *))(*(void *)lpsrc + 640))(lpsrc);
        OZChannelFolder::insertDescendantBefore((OZChannelFolder *)(v5 + 2372), v10, v11);
      }
      else
      {
        double v12 = (OZChannelBase *)(*(uint64_t (**)(OZSceneNode *))(*(void *)lpsrc + 640))(lpsrc);
        OZChannelFolder::push_back((OZChannelFolder *)(v5 + 2372), v12);
      }
      (*(void (**)(OZSceneNode *, void *))(*(void *)lpsrc + 256))(lpsrc, v5 + 25);
      uint64_t v13 = (OZScene *)v5[146];
      if (v13)
      {
        OZScene::registerNode(v13, lpsrc);
        OZScene::addAllDependencies(v5[146], lpsrc);
      }
      uint64_t v14 = *(uint64_t (**)(void *))(*v5 + 424);
      return (void *)v14(v5);
    }
  }
  return this;
}

void *non-virtual thunk to'PSEmitter::addDescendantBefore(PSEmitter *this, OZSceneNode *a2, OZSceneNode *a3)
{
  return PSEmitter::addDescendantBefore((void *)this - 25, a2, a3);
}

OZChannelFolder *PSEmitter::removeDescendant(PSEmitter *this, OZSceneNode *a2)
{
  BOOL v4 = (char *)this + 33688;
  int v5 = (OZSceneNode **)((char *)this + 33680);
  for (i = (OZSceneNode **)*((void *)this + 4211); i != v5; i = (OZSceneNode **)i[1])
  {
    if (i[2] == a2)
    {
      if (i != v5)
      {
        (*(void (**)(OZSceneNode *, void))(*(void *)a2 + 256))(a2, 0);
        BOOL v7 = *i;
        *((void *)v7 + 1) = i[1];
        *(void *)i[1] = v7;
        --*((void *)v4 + 1);
        operator delete(i);
        (*(void (**)(PSEmitter *))(*(void *)this + 424))(this);
        uint64_t v8 = (char *)this + 200;
        if ((*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200))
        {
          uint64_t v9 = (OZScene *)(*(uint64_t (**)(char *))(*(void *)v8 + 272))((char *)this + 200);
          OZScene::unregisterNode(v9, a2);
          BOOL v10 = (OZScene *)(*(uint64_t (**)(char *))(*(void *)v8 + 272))((char *)this + 200);
          OZScene::removeAllDependencies(v10, a2);
        }
      }
      break;
    }
  }
  uint64_t v11 = (OZChannelBase *)(*(uint64_t (**)(OZSceneNode *))(*(void *)a2 + 640))(a2);

  return OZChannelFolder::removeDescendant((OZChannelFolder *)((char *)this + 18976), v11);
}

OZChannelFolder *non-virtual thunk to'PSEmitter::removeDescendant(PSEmitter *this, OZSceneNode *a2)
{
  return PSEmitter::removeDescendant((PSEmitter *)((char *)this - 200), a2);
}

uint64_t PSEmitter::begin_descendants(PSEmitter *this)
{
  return *((void *)this + 4211);
}

uint64_t non-virtual thunk to'PSEmitter::begin_descendants(PSEmitter *this)
{
  return *((void *)this + 4186);
}

uint64_t PSEmitter::end_descendants(PSEmitter *this)
{
  return (uint64_t)this + 33680;
}

uint64_t non-virtual thunk to'PSEmitter::end_descendants(PSEmitter *this)
{
  return (uint64_t)this + 33480;
}

uint64_t PSEmitter::isFourCornerPinned(PSEmitter *this)
{
  uint64_t result = OZElement::isFourCornerPinned((OZElement *)((char *)this + 200));
  if (result) {
    return (*(unsigned int (**)(PSEmitter *))(*(void *)this + 168))(this) ^ 1;
  }
  return result;
}

uint64_t non-virtual thunk to'PSEmitter::isFourCornerPinned(OZElement *this)
{
  uint64_t result = OZElement::isFourCornerPinned(this);
  if (result) {
    return (*(unsigned int (**)(char *))(*((void *)this - 25) + 168))((char *)this - 200) ^ 1;
  }
  return result;
}

uint64_t PSEmitter::isCropped(PSEmitter *this)
{
  uint64_t result = OZElement::isCropped((OZElement *)((char *)this + 200));
  if (result) {
    return (*(unsigned int (**)(PSEmitter *))(*(void *)this + 168))(this) ^ 1;
  }
  return result;
}

uint64_t non-virtual thunk to'PSEmitter::isCropped(OZElement *this)
{
  uint64_t result = OZElement::isCropped(this);
  if (result) {
    return (*(unsigned int (**)(char *))(*((void *)this - 25) + 168))((char *)this - 200) ^ 1;
  }
  return result;
}

uint64_t PSEmitter::isDropShadowEnabled(PSEmitter *this)
{
  uint64_t result = OZElement::isDropShadowEnabled((OZElement *)((char *)this + 200));
  if (result) {
    return (*(unsigned int (**)(PSEmitter *))(*(void *)this + 168))(this) ^ 1;
  }
  return result;
}

uint64_t non-virtual thunk to'PSEmitter::isDropShadowEnabled(OZElement *this)
{
  uint64_t result = OZElement::isDropShadowEnabled(this);
  if (result) {
    return (*(unsigned int (**)(char *))(*((void *)this - 25) + 168))((char *)this - 200) ^ 1;
  }
  return result;
}

uint64_t PSEmitter::canReflect(PSEmitter *this)
{
  uint64_t result = OZElement::canReflect((OZElement *)((char *)this + 200));
  if (result) {
    return (*(unsigned int (**)(PSEmitter *))(*(void *)this + 168))(this) ^ 1;
  }
  return result;
}

uint64_t non-virtual thunk to'PSEmitter::canReflect(OZElement *this)
{
  uint64_t result = OZElement::canReflect(this);
  if (result) {
    return (*(unsigned int (**)(char *))(*((void *)this - 25) + 168))((char *)this - 200) ^ 1;
  }
  return result;
}

uint64_t PSEmitter::writeBody(PSEmitter *this, PCSerializerWriteStream *a2, uint64_t a3, int a4, uint64_t a5)
{
  if (a4)
  {
    TXSequenceChannels::pushChannelIntoChannelList(a2, (OZChannelBase *)&OZEmitterScope);
    uint64_t v10 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 256))(this);
    uint64_t v11 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 264))(this);
    if (v10 != v11)
    {
      uint64_t v12 = v11;
      do
      {
        uint64_t v13 = *(void *)(v10 + 16);
        if (!OZChannelBase::testFlag((OZChannelBase *)(v13 + 56), 8))
        {
          uint64_t v15 = *(void *)(v13 + 48);
          uint64_t v14 = v13 + 48;
          (*(void (**)(uint64_t, PCSerializerWriteStream *, void))(v15 + 16))(v14, a2, 0);
          (*(void (**)(uint64_t, PCSerializerWriteStream *, void, uint64_t, uint64_t))(*(void *)v14 + 24))(v14, a2, 0, 1, a5);
          (*(void (**)(PCSerializerWriteStream *))(*(void *)a2 + 24))(a2);
        }
        uint64_t v10 = *(void *)(v10 + 8);
      }
      while (v10 != v12);
    }
    PCSerializerWriteStream::popScope((uint64_t)a2);
  }
  int v16 = *((_DWORD *)this + 70);
  if (v16 != OZChannel::getValueAsInt((OZChannel *)((char *)this + 31784), MEMORY[0x1E4F1FA48], 0.0)) {
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 31784), 0x100000000, 1);
  }

  return OZElement::writeBody((OZElement *)((char *)this + 200), a2, a3, a4, a5);
}

uint64_t non-virtual thunk to'PSEmitter::writeBody(PSEmitter *this, PCSerializerWriteStream *a2, uint64_t a3, int a4, uint64_t a5)
{
  return PSEmitter::writeBody((PSEmitter *)((char *)this - 200), a2, a3, a4, a5);
}

{
  return PSEmitter::writeBody((PSEmitter *)((char *)this - 248), a2, a3, a4, a5);
}

uint64_t PSEmitter::parseBegin(PSEmitter *this, PCSerializerReadStream *a2)
{
  if (*((_DWORD *)a2 + 26) <= 4u)
  {
    BOOL v4 = (const CMTime *)MEMORY[0x1E4F1FA48];
    OZChannel::setValue((OZChannel *)((char *)this + 31936), MEMORY[0x1E4F1FA48], 0.0, 0);
    OZChannel::setValue((OZChannel *)((char *)this + 19896), v4, 3.0, 0);
  }
  OZElement::parseBegin((OZElement *)((char *)this + 200), a2);
  PCSerializerReadStream::pushScope(a2, (uint64_t)&OZEmitterScope);
  return 1;
}

uint64_t non-virtual thunk to'PSEmitter::parseBegin(PSEmitter *this, PCSerializerReadStream *a2)
{
  return 1;
}

{
  PSEmitter::parseBegin((PSEmitter *)((char *)this - 248), a2);
  return 1;
}

uint64_t PSEmitter::parseEnd(PSEmitter *this, PCSerializerReadStream *a2)
{
  OZElement::parseEnd((OZElement *)((char *)this + 200), a2);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 27824), 4.71238898);
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19232), MEMORY[0x1E4F1FA48], 0.0);
  switch(ValueAsInt)
  {
    case 2:
      uint64_t v9 = (OZChannel *)((char *)this + 19896);
      if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), MEMORY[0x1E4F1FA48], 0.0) != 3) {
        goto LABEL_11;
      }
      uint64_t v8 = (const CMTime *)MEMORY[0x1E4F1FA48];
      double v7 = 0.0;
      break;
    case 5:
      uint64_t v9 = (OZChannel *)((char *)this + 19896);
      if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), MEMORY[0x1E4F1FA48], 0.0) != 3) {
        goto LABEL_11;
      }
      uint64_t v8 = (const CMTime *)MEMORY[0x1E4F1FA48];
      double v7 = 2.0;
      break;
    case 3:
      int v5 = (const CMTime *)MEMORY[0x1E4F1FA48];
      OZChannel::setValue((OZChannel *)((char *)this + 19232), MEMORY[0x1E4F1FA48], 2.0, 0);
      int v6 = (OZChannel *)((char *)this + 19896);
      double v7 = 1.0;
      uint64_t v8 = v5;
      goto LABEL_10;
    default:
      goto LABEL_11;
  }
  int v6 = v9;
LABEL_10:
  OZChannel::setValue(v6, v8, v7, 0);
LABEL_11:
  (*(void (**)(PSEmitter *, void))(*(void *)this + 456))(this, 0);
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), MEMORY[0x1E4F1FA48], 0.0) == 3) {
    OZChannelBase::reset((OZChannelBase *)((char *)this + 19896), 0);
  }
  if (!OZChannel::getValueAsInt((OZChannel *)((char *)this + 27048), MEMORY[0x1E4F1FA48], 0.0))
  {
    uint64_t v10 = (const CMTime *)MEMORY[0x1E4F1FA48];
    OZChannel::setValue((OZChannel *)((char *)this + 27048), MEMORY[0x1E4F1FA48], 1.0, 0);
    OZChannel::setValue((OZChannel *)((char *)this + 27200), v10, 0.0, 0);
  }
  if (*((_DWORD *)a2 + 26) <= 2u) {
    OZChannel::setValue((OZChannel *)((char *)this + 32792), MEMORY[0x1E4F1FA48], 0.0, 0);
  }
  (*(void (**)(PSEmitter *, uint64_t))(*(void *)this + 448))(this, 1);
  return 1;
}

uint64_t non-virtual thunk to'PSEmitter::parseEnd(PSEmitter *this, PCSerializerReadStream *a2)
{
  return 1;
}

{
  PSEmitter::parseEnd((PSEmitter *)((char *)this - 248), a2);
  return 1;
}

uint64_t PSEmitter::parseElement(PSEmitter *this, PCSerializerReadStream *a2, PCStreamElement *a3)
{
  PCSharedCount::PCSharedCount(&v19);
  *(void *)v18 = 0;
  OZElement::parseElement((OZElement *)((char *)this + 200), a2, a3);
  if (*((_DWORD *)a3 + 2) == 62)
  {
    PCSerializerReadStream::getAttributeAsUInt32((uint64_t)a2, (uint64_t)a3, 113, (uint64_t)v18);
    PCSerializerReadStream::getAttributeAsString((uint64_t)a2, (uint64_t)a3, 110, (uint64_t)&v19);
    PCSerializerReadStream::getAttributeAsUInt32((uint64_t)a2, (uint64_t)a3, 111, (uint64_t)&v18[1]);
    int v6 = (const void *)OZFactories::lookupFactory(*(OZFactories **)(theApp + 32), v18[0]);
    if (v6)
    {
      if (v7)
      {
        uint64_t v8 = (char *)(*(uint64_t (**)(void *, PCSharedCount *, void))(*(void *)v7 + 168))(v7, &v19, v18[1]);
        uint64_t v9 = v8;
        if (v8)
        {
          OZChannelBase::setID((OZChannelBase *)((char *)v10 + 56), v18[1]);
          PSParticleType::setEmitter(v10, this);
          (*(void (**)(OZSceneNode *, char *))(*(void *)v10 + 256))(v10, (char *)this + 200);
          uint64_t v11 = operator new(0x18uLL);
          v11[1] = (char *)this + 33680;
          v11[2] = v9;
          uint64_t v12 = *((void *)this + 4210);
          *uint64_t v11 = v12;
          *(void *)(v12 + 8) = v11;
          *((void *)this + 4210) = v11;
          ++*((void *)this + 4212);
          uint64_t v13 = (OZChannelBase *)(*(uint64_t (**)(char *))(*(void *)v9 + 640))(v9);
          OZChannelFolder::push_back((OZChannelFolder *)((char *)this + 18976), v13);
          uint64_t v14 = (OZChannelBase *)(*(uint64_t (**)(char *))(*(void *)v9 + 640))(v9);
          OZChannelBase::resetFlag(v14, 64, 0);
          uint64_t v15 = (OZScene *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200);
          uint64_t v16 = (uint64_t)v15;
          if (v15)
          {
            OZScene::registerNode(v15, v10);
            OZScene::addAllDependencies(v16, v10);
          }
          PCSerializerReadStream::pushHandler(a2, (PCSerializer *)(v9 + 48));
        }
      }
    }
  }
  PCString::~PCString((PCString *)&v19);
  return 1;
}

void sub_1B7DB62C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t non-virtual thunk to'PSEmitter::parseElement(PSEmitter *this, PCSerializerReadStream *a2, PCStreamElement *a3)
{
  return 1;
}

{
  PSEmitter::parseElement((PSEmitter *)((char *)this - 248), a2, a3);
  return 1;
}

uint64_t PSEmitter::createParticleType(PSEmitter *this, OZImageNode *a2)
{
  PCURL::PCURL((PCURL *)&v8, @"Particle Type Default Name");
  if (a2)
  {
    if (v3)
    {
      Name = (const PCString *)OZObjectManipulator::getName((OZObjectManipulator *)&v3->var2);
      PCString::set(&v8, Name);
    }
  }
  NextUniqueID = (const PCString *)OZChannelBase::getNextUniqueID(v3);
  uint64_t ParticleType = PSParticleType::createParticleType((PSParticleType *)&v8, NextUniqueID);
  (*(void (**)(void))(*(void *)(ParticleType + 16) + 120))();
  PCString::~PCString(&v8);
  return ParticleType;
}

void sub_1B7DB6418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

BOOL PSEmitter::isRenderingOldestParticleFirst(PSEmitter *this)
{
  return OZChannel::getValueAsInt((OZChannel *)((char *)this + 31072), MEMORY[0x1E4F1FA48], 0.0) == 0;
}

uint64_t PSEmitter::getFillSeed(PSEmitter *this, PSParticleType *a2)
{
  return PSParticleType::getSeed(a2);
}

void PSEmitter::getIconName(PSEmitter *this@<X0>, PCURL *a2@<X8>)
{
  if (!OZChannel::getValueAsInt((OZChannel *)((char *)this + 32792), MEMORY[0x1E4F1FA48], 0.0)) {
    goto LABEL_9;
  }
  BOOL v4 = (_DWORD *)((char *)this + 33708);
  if (*((unsigned char *)this + 33712))
  {
    if (*v4) {
      goto LABEL_9;
    }
  }
  else
  {
    int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 32944), MEMORY[0x1E4F1FA48], 0.0);
    *BOOL v4 = ValueAsInt;
    *((unsigned char *)this + 33712) = 1;
    if (ValueAsInt) {
      goto LABEL_9;
    }
  }
  if ((*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200))
  {
    int v6 = (OZScene *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200);
    OZScene::getCurrentTime(v6, (__n128 *)&v7);
    if (PSEmitter::shouldPrecompose(this, &v7))
    {
      PCURL::PCURL(a2, @"M_LayersList_ObjectIconColor-ParticleEmitterRasterized");
      return;
    }
  }
LABEL_9:
  (*(void (**)(void))(**((void **)this + 26) + 80))(*((void *)this + 26));
}

void non-virtual thunk to'PSEmitter::getIconName(PSEmitter *this@<X0>, PCURL *a2@<X8>)
{
}

void PSEmitter::getIconNameBW(PSEmitter *this@<X0>, PCURL *a2@<X8>)
{
  if (!OZChannel::getValueAsInt((OZChannel *)((char *)this + 32792), MEMORY[0x1E4F1FA48], 0.0)) {
    goto LABEL_9;
  }
  BOOL v4 = (_DWORD *)((char *)this + 33708);
  if (*((unsigned char *)this + 33712))
  {
    if (*v4) {
      goto LABEL_9;
    }
  }
  else
  {
    int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 32944), MEMORY[0x1E4F1FA48], 0.0);
    *BOOL v4 = ValueAsInt;
    *((unsigned char *)this + 33712) = 1;
    if (ValueAsInt) {
      goto LABEL_9;
    }
  }
  if ((*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200))
  {
    int v6 = (OZScene *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200);
    OZScene::getCurrentTime(v6, (__n128 *)&v7);
    if (PSEmitter::shouldPrecompose(this, &v7))
    {
      PCURL::PCURL(a2, @"M_LayersList_ObjectIconGrey-ParticleEmitterRasterized");
      return;
    }
  }
LABEL_9:
  (*(void (**)(void))(**((void **)this + 26) + 88))(*((void *)this + 26));
}

void non-virtual thunk to'PSEmitter::getIconNameBW(PSEmitter *this@<X0>, PCURL *a2@<X8>)
{
}

uint64_t PSEmitter::getIconID(PSEmitter *this)
{
  if (!OZChannel::getValueAsInt((OZChannel *)((char *)this + 32792), MEMORY[0x1E4F1FA48], 0.0)) {
    return (*(uint64_t (**)(void))(**((void **)this + 26) + 96))(*((void *)this + 26));
  }
  v2 = (_DWORD *)((char *)this + 33708);
  if (*((unsigned char *)this + 33712))
  {
    if (*v2) {
      return (*(uint64_t (**)(void))(**((void **)this + 26) + 96))(*((void *)this + 26));
    }
  }
  else
  {
    int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 32944), MEMORY[0x1E4F1FA48], 0.0);
    _DWORD *v2 = ValueAsInt;
    *((unsigned char *)this + 33712) = 1;
    if (ValueAsInt) {
      return (*(uint64_t (**)(void))(**((void **)this + 26) + 96))(*((void *)this + 26));
    }
  }
  if ((*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200))
  {
    BOOL v4 = (OZScene *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200);
    OZScene::getCurrentTime(v4, (__n128 *)&v6);
    if (PSEmitter::shouldPrecompose(this, &v6)) {
      return 29;
    }
  }
  return (*(uint64_t (**)(void))(**((void **)this + 26) + 96))(*((void *)this + 26));
}

uint64_t non-virtual thunk to'PSEmitter::getIconID(PSEmitter *this)
{
  return PSEmitter::getIconID((PSEmitter *)((char *)this - 200));
}

__n128 PSEmitter::getNaturalDuration@<Q0>(PSEmitter *this@<X0>, __n128 *a2@<X8>)
{
  v3 = (char *)this + 200;
  if ((*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200))
  {
    BOOL v4 = (OZSceneSettings *)((*(uint64_t (**)(char *))(*(void *)v3 + 272))(v3) + 336);
    result.n128_u64[0] = OZSceneSettings::getFrameDuration(v4, a2).n128_u64[0];
  }
  else
  {
    uint64_t v6 = MEMORY[0x1E4F1FA48];
    __n128 result = *(__n128 *)MEMORY[0x1E4F1FA48];
    *a2 = *(__n128 *)MEMORY[0x1E4F1FA48];
    a2[1].n128_u64[0] = *(void *)(v6 + 16);
  }
  return result;
}

double non-virtual thunk to'PSEmitter::getNaturalDuration@<D0>(PSEmitter *this@<X0>, __n128 *a2@<X8>)
{
  *(void *)&double result = PSEmitter::getNaturalDuration((PSEmitter *)((char *)this - 216), a2).n128_u64[0];
  return result;
}

void *PSEmitter::addParticleType(PSEmitter *this, PSParticleType *a2)
{
  BOOL v4 = (uint64_t *)((char *)this + 33680);
  PSParticleType::setEmitter(a2, this);
  int v5 = (OZChannelBase *)(*(uint64_t (**)(PSParticleType *))(*(void *)a2 + 640))(a2);
  OZChannelFolder::push_front((OZChannelFolder *)((char *)this + 18976), v5);
  (*(void (**)(PSParticleType *, char *))(*(void *)a2 + 256))(a2, (char *)this + 200);
  uint64_t v6 = (OZScene *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200);
  if (v6)
  {
    uint64_t v7 = (uint64_t)v6;
    OZScene::registerNode(v6, a2);
    OZScene::addAllDependencies(v7, a2);
    OZDocument::postNotification(*(OZDocument **)(v7 + 1584), 16);
    (*(void (**)(PSParticleType *, uint64_t))(*(void *)a2 + 280))(a2, v7);
  }
  double result = operator new(0x18uLL);
  result[1] = v4;
  result[2] = a2;
  uint64_t v9 = *v4;
  *double result = *v4;
  *(void *)(v9 + 8) = result;
  *BOOL v4 = (uint64_t)result;
  ++v4[2];
  return result;
}

PSParticleType *PSEmitter::addNewParticleType(PSEmitter *this, OZImageNode *lpsrc)
{
  if (lpsrc)
  {
    if (v4)
    {
      if ((*(unsigned int (**)(void *))(*(void *)v4 + 248))(v4))
      {
        int v5 = (const CMTime *)MEMORY[0x1E4F1FA48];
        OZChannel::setValue((OZChannel *)((char *)this + 32792), MEMORY[0x1E4F1FA48], 1.0, 0);
        OZChannel::setValue((OZChannel *)((char *)this + 32944), v5, 0.0, 0);
        (*(void (**)(PSEmitter *, uint64_t))(*(void *)this + 456))(this, 1);
      }
    }
  }
  uint64_t v6 = (PSParticleType *)(*(uint64_t (**)(PSEmitter *, OZImageNode *))(*(void *)this + 568))(this, lpsrc);
  PSEmitter::addParticleType(this, v6);
  (*(void (**)(PSParticleType *, OZImageNode *))(*(void *)v6 + 1328))(v6, lpsrc);
  __n128 TimeOffset = OZChannelObjectRootBase::getTimeOffset((__n128 *)this + 16, &v13);
  (*(void (**)(PSParticleType *, __n128 *, void, __n128))(*(void *)v6 + 1120))(v6, &v13, 0, TimeOffset);
  long long v9 = *(_OWORD *)((char *)this + 408);
  uint64_t v10 = *((void *)this + 53);
  long long v11 = *((_OWORD *)this + 27);
  uint64_t v12 = *((void *)this + 56);
  (*(void (**)(PSParticleType *, long long *, void))(*(void *)v6 + 1136))(v6, &v9, 0);
  return v6;
}

void PSEmitter::allowDrag(PSEmitter *this, OZFactoryBase *lpsrc, OZChannelBase *a3, unsigned int a4, unsigned int *a5, unsigned int *a6, int a7)
{
  PCString v8 = a6;
  uint64_t v14 = (char *)this + 33504;
  *a5 = 0;
  *((_WORD *)this + 16752) = 0;
  if (!lpsrc) {
    goto LABEL_51;
  }
  if (v16)
  {
    v17 = (char *)this + 33680;
    uint64_t v18 = *((void *)v14 + 23);
    if ((PSEmitter *)v18 == (PSEmitter *)((char *)this + 33680))
    {
      *a6 = 0;
    }
    else
    {
      uint64_t v19 = *((void *)v14 + 23);
      while (*(void **)(v19 + 16) != v16)
      {
        uint64_t v19 = *(void *)(v19 + 8);
        if ((char *)v19 == v17) {
          goto LABEL_25;
        }
      }
      if ((char *)v19 != v17)
      {
        if ((OZChannelBase *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 640))((char *)this + 200) == a3) {
          return;
        }
        uint64_t v18 = *((void *)v14 + 23);
      }
LABEL_25:
      *a6 = 0;
      if ((char *)v18 != v17)
      {
        char v29 = a4;
        uint64_t v25 = 0;
        uint64_t v26 = -1;
        uint64_t v27 = -1;
        do
        {
          if ((OZChannelBase *)(*(uint64_t (**)(void))(**(void **)(v18 + 16) + 640))(*(void *)(v18 + 16)) == a3) {
            uint64_t v26 = v25;
          }
          if (*(void **)(v18 + 16) == v15) {
            uint64_t v27 = v25;
          }
          if ((v27 & 0x8000000000000000) == 0 && (v26 & 0x8000000000000000) == 0) {
            break;
          }
          ++v25;
          uint64_t v18 = *(void *)(v18 + 8);
        }
        while ((char *)v18 != v17);
        if (v27 != v26 && ((v26 | v27) & 0x8000000000000000) == 0)
        {
          *a5 = v29 & 2;
          if (v27 > v26) {
            unsigned int v28 = 2;
          }
          else {
            unsigned int v28 = 3;
          }
          *a6 = v28;
LABEL_42:
          if (!*a5) {
            return;
          }
LABEL_45:
          v14[1] = 1;
          return;
        }
        LOBYTE(a4) = v29;
        if ((v26 & 0x8000000000000000) == 0)
        {
LABEL_44:
          *a5 = a4 & 1;
          if ((a4 & 1) == 0) {
            return;
          }
          goto LABEL_45;
        }
      }
    }
    if ((OZChannelBase *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 640))((char *)this + 200) != a3) {
      goto LABEL_42;
    }
    goto LABEL_44;
  }
  PCString v8 = a6;
  if (v15 {
    && (*(uint64_t (**)(void *))(*v15 + 272))(v15)
  }
  {
    *a6 = 1;
    *a5 = a4 & 9;
    char *v14 = 1;
    if ((a4 & 9) != 0) {
      return;
    }
  }
  else
  {
LABEL_51:
    if (*a5) {
      return;
    }
  }
  OZElement::allowDrag((OZElement *)((char *)this + 200), lpsrc, a3, a4, a5, v8, a7);
  if (!*a5)
  {
    unint64_t v23 = *((void *)lpsrc + 1);
    long long v31 = xmmword_1B8378BB0;
    if (OZFactory::isKindOfClass(v23, (int32x4_t *)&v31))
    {
      int v24 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 216))(this);
      if (a7 == 1
        && v24 == 1
        && (OZChannelBase *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 640))((char *)this + 200) == a3)
      {
        *a5 = a4 & 1;
        *PCString v8 = 1;
      }
    }
  }
}

void non-virtual thunk to'PSEmitter::allowDrag(PSEmitter *this, OZFactoryBase *a2, OZChannelBase *a3, unsigned int a4, unsigned int *a5, unsigned int *a6, int a7)
{
}

{
  PSEmitter::allowDrag((PSEmitter *)((char *)this - 216), a2, a3, a4, a5, a6, a7);
}

uint64_t PSEmitter::prepareForDragOperation(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 33504) || *(unsigned char *)(a1 + 33505)) {
    return 1;
  }
  else {
    return OZSceneNode::prepareForDragOperation();
  }
}

uint64_t non-virtual thunk to'PSEmitter::prepareForDragOperation(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 33304) || *(unsigned char *)(a1 + 33305)) {
    return 1;
  }
  else {
    return OZSceneNode::prepareForDragOperation();
  }
}

{
  if (*(unsigned char *)(a1 + 33288) || *(unsigned char *)(a1 + 33289)) {
    return 1;
  }
  else {
    return OZSceneNode::prepareForDragOperation();
  }
}

uint64_t PSEmitter::performDragOperation(PSEmitter *this, OZFactoryBase *a2, OZChannelBase *a3, uint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7, const CMTime *a8)
{
  uint64_t v15 = (char *)this + 33504;
  if ((*(unsigned int (**)(PSEmitter *))(*(void *)this + 624))(this) && (v15[1] || *v15))
  {
    PCURL::PCURL((PCURL *)&v40, @"Undo Drop");
    (*(void (**)(char *, PCString *, uint64_t))(*((void *)this + 27) + 176))((char *)this + 216, &v40, 3);
    PCString::~PCString(&v40);
    while (*((void *)v15 + 24))
    {
      uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(*((void *)v15 + 23) + 16) + 640))(*(void *)(*((void *)v15 + 23) + 16));
      (*(void (**)(PSEmitter *, uint64_t))(*(void *)this + 416))(this, v16);
    }
    char v17 = 1;
    if (!a2)
    {
LABEL_15:
      if (*v15) {
        return 1;
      }
      goto LABEL_21;
    }
  }
  else
  {
    char v17 = 0;
    if (!a2) {
      goto LABEL_15;
    }
  }
  if (v15[1])
  {
    uint64_t v20 = v19[120];
    if ((OZChannelBase *)(*(uint64_t (**)(void))(*v19 + 640))() == a3) {
      return 0;
    }
    if (v20)
    {
      if ((v17 & 1) == 0)
      {
        PCURL::PCURL((PCURL *)&v40, @"Undo Reorder");
        (*(void (**)(void *, PCString *, uint64_t))(v19[2] + 176))(v19 + 2, &v40, 3);
        PCString::~PCString(&v40);
      }
      (*(void (**)(uint64_t, void *))(*(void *)v20 + 1000))(v20, v19);
    }
    else if ((v17 & 1) == 0)
    {
      PCURL::PCURL((PCURL *)&v40, @"Undo Drop");
      (*(void (**)(char *, PCString *, uint64_t))(*((void *)this + 27) + 176))((char *)this + 216, &v40, 3);
      PCString::~PCString(&v40);
    }
    long long v32 = (void *)*((void *)v15 + 23);
    if (v32 != (void *)((char *)this + 33680))
    {
      long long v33 = v32 + 2;
      if ((OZChannelBase *)(*(uint64_t (**)(void))(*(void *)v32[2] + 640))(v32[2]) == a3)
      {
        uint64_t v34 = 0;
LABEL_42:
        if (a5 == 3) {
          uint64_t v34 = *v33;
        }
        goto LABEL_44;
      }
      while (1)
      {
        long long v32 = (void *)v32[1];
        if (v32 == (void *)((char *)this + 33680)) {
          break;
        }
        uint64_t v34 = *v33;
        long long v33 = v32 + 2;
        if ((OZChannelBase *)(*(uint64_t (**)(void))(*(void *)v32[2] + 640))(v32[2]) == a3) {
          goto LABEL_42;
        }
      }
    }
    uint64_t v34 = 0;
LABEL_44:
    (*(void (**)(PSEmitter *, void *, uint64_t))(*(void *)this + 232))(this, v19, v34);
    (*(void (**)(PSEmitter *))(*(void *)this + 424))(this);
    uint64_t v35 = *((void *)this + 146);
    if (!v35) {
      return 1;
    }
    double v30 = *(OZDocument **)(v35 + 1584);
    int v31 = 16;
LABEL_46:
    OZDocument::postNotification(v30, v31);
    return 1;
  }
  if (*v15 && ((a7 & 8) == 0 || !v18 || (v18[1224] & 8) != 0))
  {
    if (!v24) {
      return 1;
    }
    uint64_t v25 = v24;
    int v26 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 168))(this);
    uint64_t v27 = PSEmitter::addNewParticleType(this, v25);
    if ((v17 & 1) == 0)
    {
      unsigned int v28 = v27;
      PCURL::PCURL((PCURL *)&v40, @"Undo Drop");
      (*(void (**)(uint64_t, PCString *, uint64_t))(*((void *)v28 + 2) + 176))((uint64_t)v28 + 16, &v40, 1);
      PCString::~PCString(&v40);
    }
    (*(void (**)(PSEmitter *))(*(void *)this + 424))(this);
    if (v26 == (*(unsigned int (**)(PSEmitter *))(*(void *)this + 168))(this)) {
      return 1;
    }
    uint64_t v29 = *((void *)this + 146);
    if (!v29) {
      return 1;
    }
    double v30 = *(OZDocument **)(v29 + 1584);
    int v31 = 12;
    goto LABEL_46;
  }
LABEL_21:
  unint64_t v21 = *((void *)a2 + 1);
  int32x4_t v39 = (int32x4_t)xmmword_1B8378BB0;
  if (!OZFactory::isKindOfClass(v21, &v39)
    || (int v22 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 216))(this), a6 != 1)
    || v22 != 1
    || (OZChannelBase *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 640))((char *)this + 200) != a3)
  {
    OZElement::performDragOperation((OZElement *)((char *)this + 200), a2, a3, a4, a5, a6, a7, a8);
    return 1;
  }
  v37 = (void *)(*(uint64_t (**)(PSEmitter *, void))(*(void *)this + 224))(this, 0);
  if (v37) {
  uint64_t v23 = 1;
  }
  (*(void (**)(void *, OZFactoryBase *, OZChannelBase *, uint64_t, void, uint64_t, uint64_t, const CMTime *))(*(void *)v37 + 584))(v37, a2, a3, a4, a5, 1, a7, a8);
  return v23;
}

void sub_1B7DB795C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, PCString a14)
{
}

uint64_t non-virtual thunk to'PSEmitter::performDragOperation(PSEmitter *this, OZFactoryBase *a2, OZChannelBase *a3, uint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7, const CMTime *a8)
{
  return PSEmitter::performDragOperation((PSEmitter *)((char *)this - 200), a2, a3, a4, a5, a6, a7, a8);
}

{
  return PSEmitter::performDragOperation((PSEmitter *)((char *)this - 216), a2, a3, a4, a5, a6, a7, a8);
}

uint64_t PSEmitter::deleteThis(PSEmitter *this, OZChannelBase *a2)
{
  BOOL v4 = (uint64_t *)(*(uint64_t (**)(PSEmitter *))(*(void *)this + 256))(this);
  uint64_t v5 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 264))(this);
  if (v4 == (uint64_t *)v5)
  {
LABEL_5:
    return OZSceneNode::deleteThis((PSEmitter *)((char *)this + 200), a2);
  }
  else
  {
    uint64_t v6 = (uint64_t *)v5;
    while (1)
    {
      uint64_t v7 = (void *)v4[2];
      if ((OZChannelBase *)(*(uint64_t (**)(void *))(*(void *)v7 + 640))(v7) == a2) {
        break;
      }
      BOOL v4 = (uint64_t *)v4[1];
      if (v4 == v6) {
        goto LABEL_5;
      }
    }
    uint64_t v10 = *v4;
    *(void *)(v10 + 8) = v4[1];
    *(void *)v4[1] = v10;
    --*((void *)this + 4212);
    operator delete(v4);
    long long v11 = (OZChannelBase *)(*(uint64_t (**)(void *))(*(void *)v9 + 640))(v9);
    OZChannelFolder::removeDescendant((OZChannelFolder *)((char *)this + 18976), v11);
    uint64_t v12 = (OZScene *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200);
    if (v12)
    {
      __n128 v13 = (OZDocument **)v12;
      OZScene::unregisterNode(v12, (OZSceneNode *)v7);
      OZScene::removeAllDependencies((OZScene *)v13, (OZSceneNode *)v7);
      OZDocument::postNotification(v13[198], 16);
    }
    (*(void (**)(void *))(*(void *)v9 + 8))(v9);
    return 1;
  }
}

uint64_t non-virtual thunk to'PSEmitter::deleteThis(PSEmitter *this, OZChannelBase *a2)
{
  return PSEmitter::deleteThis((PSEmitter *)((char *)this - 200), a2);
}

{
  return PSEmitter::deleteThis((PSEmitter *)((char *)this - 216), a2);
}

uint64_t PSEmitter::dirty(PSEmitter *this)
{
  uint64_t result = OZElement::dirty((OZElement *)((char *)this + 200));
  *((_DWORD *)this + 8396) = -1;
  return result;
}

uint64_t non-virtual thunk to'PSEmitter::dirty(OZElement *this)
{
  uint64_t result = OZElement::dirty(this);
  *((_DWORD *)this + 8346) = -1;
  return result;
}

uint64_t non-virtual thunk to'PSEmitter::dirty(PSEmitter *this)
{
  uint64_t result = OZElement::dirty((OZElement *)((char *)this - 16));
  *((_DWORD *)this + 8342) = -1;
  return result;
}

uint64_t PSEmitter::calcStaticHash(uint64_t a1)
{
  uint64_t result = OZChannelBase::testFlag((OZChannelBase *)(a1 + 256), 8);
  if ((result & 1) == 0)
  {
    return OZTransformNode::calcStaticHash(a1 + 200);
  }
  return result;
}

uint64_t non-virtual thunk to'PSEmitter::calcStaticHash(uint64_t a1)
{
  uint64_t result = OZChannelBase::testFlag((OZChannelBase *)(a1 + 56), 8);
  if ((result & 1) == 0)
  {
    return OZTransformNode::calcStaticHash(a1);
  }
  return result;
}

double PSEmitter::calcHashForState(PSEmitter *a1, const void *a2, long long *a3)
{
  (*(void (**)(void))(*((void *)a1 + 25) + 536))();
  if (!v6) {
    __cxa_bad_cast();
  }
  uint64_t v7 = v6;
  __n128 v12 = *(__n128 *)PCHashWriteStream::getHash(v6)->i8;
  if (PSEmitter::simulatingAnyParticleTypes(a1))
  {
    (*(void (**)(const void *))(*(void *)a2 + 40))(a2);
    long long v10 = *a3;
    uint64_t v11 = *((void *)a3 + 2);
    (*(void (**)(const void *, long long *))(*(void *)a2 + 112))(a2, &v10);
  }
  Hash = PCHashWriteStream::getHash(v7);
  PCHash128::operator+=((int *)&v12, (int *)Hash);
  *(void *)&double result = PCHashWriteStream::setHash((__n128 *)v7, &v12).n128_u64[0];
  return result;
}

uint64_t PSEmitter::simulatingAnyParticleTypes(PSEmitter *this)
{
  uint64_t v2 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 256))(this);
  uint64_t v3 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 264))(this);
  if (v2 == v3) {
    return 0;
  }
  uint64_t v4 = v3;
  do
  {
    uint64_t v5 = *(void **)(v2 + 16);
    if (v5) {
    uint64_t result = (*(uint64_t (**)(void *))(*(void *)v5 + 1384))(v5);
    }
    if (result) {
      break;
    }
    uint64_t v2 = *(void *)(v2 + 8);
  }
  while (v2 != v4);
  return result;
}

double non-virtual thunk to'PSEmitter::calcHashForState(uint64_t a1, const void *a2, long long *a3)
{
  return PSEmitter::calcHashForState((PSEmitter *)(a1 - 200), a2, a3);
}

{
  return PSEmitter::calcHashForState((PSEmitter *)(a1 - 216), a2, a3);
}

const void *PSEmitter::getGeometryNode(PSEmitter *this)
{
  return OZChanRotoshapeRef::getRotoshape((OZChannelBase *)((char *)this + 27352));
}

OZChannelBase *PSEmitter::updateChanHiddenFlag(PSEmitter *this, OZChannelBase *a2, int a3, char a4)
{
  uint64_t v7 = (char *)this + 200;
  if ((*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200)) {
    uint64_t v8 = *(void *)((*(uint64_t (**)(char *))(*(void *)v7 + 272))(v7) + 1584);
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t result = (OZChannelBase *)OZChannelBase::testFlag(a2, 2);
  if (result != a3)
  {
    if ((a4 & 1) == 0)
    {
      if (v8)
      {
        long long v10 = *(OZNotificationManager **)(v8 + 168);
        if (!v10 || !OZNotificationManager::wasChannelModified(v10, a2))
        {
          PCSharedCount::PCSharedCount(&v11);
          (*((void (**)(OZChannelBase *, PCSharedCount *))a2->var0 + 43))(a2, &v11);
          PCString::~PCString((PCString *)&v11);
        }
      }
    }
    if (a3) {
      return OZChannelBase::setFlag(a2, 2, a4);
    }
    else {
      return OZChannelBase::resetFlag(a2, 2, a4);
    }
  }
  return result;
}

void sub_1B7DB8154(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PSEmitter::updateEmitterHiddenFlags(PSEmitter *this, char a2)
{
  v620[0] = 0;
  v620[1] = 0;
  v619 = (uint64_t *)v620;
  v613 = (OZChannel *)((char *)this + 19744);
  v616 = (char *)this + 19744;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 19896;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 20152;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 20304;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 20456;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 20608;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 20760;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 20912;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v597 = (char *)this + 21064;
  v616 = (char *)this + 21064;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 21216;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 21472;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 21728;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 21984;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 22240;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 22496;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 22752;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 23008;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 23160;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v599 = (char *)this + 20456;
  v616 = (char *)this + 23312;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 23464;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 24352;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v600 = (char *)this + 23464;
  v616 = (char *)this + 25392;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v596 = (char *)this + 25392;
  v616 = (char *)this + 25528;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 25680;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 25832;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v592 = (char *)this + 25984;
  v616 = (char *)this + 25984;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 26136;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v595 = (char *)this + 25528;
  v616 = (char *)this + 26288;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 26440;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v602 = (char *)this + 23312;
  v616 = (char *)this + 26592;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v601 = (char *)this + 20152;
  v616 = (char *)this + 26744;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 26896;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v594 = (char *)this + 27200;
  v616 = (char *)this + 27200;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  uint64_t v4 = (char *)this + 27352;
  v616 = (char *)this + 27352;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v598 = (OZChannel *)((char *)this + 20304);
  v593 = (char *)this + 27512;
  v616 = (char *)this + 27512;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 27672;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v611 = (char *)this + 27824;
  v612 = (char *)this + 27672;
  v616 = (char *)this + 27824;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 27976;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v608 = (char *)this + 28256;
  v616 = (char *)this + 28256;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v607 = (char *)this + 28560;
  v616 = (char *)this + 28560;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v606 = (char *)this + 28712;
  v616 = (char *)this + 28712;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v605 = (char *)this + 28864;
  v616 = (char *)this + 28864;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v604 = (char *)this + 29456;
  v616 = (char *)this + 29456;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v603 = (char *)this + 29608;
  v616 = (char *)this + 29608;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 29760;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 30920;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v610 = (char *)this + 31072;
  v616 = (char *)this + 31072;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 31328;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v609 = (char *)this + 31480;
  v616 = (char *)this + 31480;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = (char *)this + 31784;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v619, (unint64_t *)&v616, (uint64_t *)&v616);
  v616 = 0;
  v617 = 0;
  unint64_t v618 = 0;
  CMTime v615 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19232), &v615, 0.0);
  uint64_t v6 = (char *)this + 19896;
  int v7 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), &v615, 0.0);
  int v8 = OZChannel::getValueAsInt(v613, &v615, 0.0);
  if (ValueAsInt == 1)
  {
    int v16 = v8;
    char v17 = v617;
    if ((unint64_t)v617 >= v618)
    {
      uint64_t v26 = (v617 - v616) >> 3;
      uint64_t v18 = (char *)this + 24352;
      if ((unint64_t)(v26 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v27 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v27 <= v26 + 1) {
        unint64_t v27 = v26 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v28 = v27;
      }
      if (v28) {
        uint64_t v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v28);
      }
      else {
        uint64_t v29 = 0;
      }
      v52 = &v29[8 * v26];
      v53 = &v29[8 * v28];
      *(void *)v52 = v600;
      uint64_t v19 = v52 + 8;
      v55 = v616;
      v54 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v56 = *((void *)v54 - 1);
          v54 -= 8;
          *((void *)v52 - 1) = v56;
          v52 -= 8;
        }
        while (v54 != v55);
        v54 = v616;
      }
      v616 = v52;
      v617 = (char *)v19;
      unint64_t v618 = (unint64_t)v53;
      if (v54) {
        operator delete(v54);
      }
    }
    else
    {
      uint64_t v18 = (char *)this + 24352;
      *(void *)v617 = v600;
      uint64_t v19 = v17 + 8;
    }
    v617 = (char *)v19;
    if ((unint64_t)v19 >= v618)
    {
      uint64_t v58 = ((char *)v19 - v616) >> 3;
      if ((unint64_t)(v58 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v59 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v59 <= v58 + 1) {
        unint64_t v59 = v58 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v60 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v60 = v59;
      }
      if (v60) {
        v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v60);
      }
      else {
        v61 = 0;
      }
      v80 = &v61[8 * v58];
      v81 = &v61[8 * v60];
      *(void *)v80 = v18;
      v57 = (OZChannel **)(v80 + 8);
      v83 = v616;
      v82 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v84 = *((void *)v82 - 1);
          v82 -= 8;
          *((void *)v80 - 1) = v84;
          v80 -= 8;
        }
        while (v82 != v83);
        v82 = v616;
      }
      v616 = v80;
      v617 = (char *)v57;
      unint64_t v618 = (unint64_t)v81;
      if (v82) {
        operator delete(v82);
      }
    }
    else
    {
      void *v19 = v18;
      v57 = (OZChannel **)(v19 + 1);
    }
    v617 = (char *)v57;
    if ((unint64_t)v57 >= v618)
    {
      uint64_t v86 = ((char *)v57 - v616) >> 3;
      if ((unint64_t)(v86 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v87 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v87 <= v86 + 1) {
        unint64_t v87 = v86 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v88 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v88 = v87;
      }
      if (v88) {
        v89 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v88);
      }
      else {
        v89 = 0;
      }
      v97 = (OZChannel **)&v89[8 * v86];
      v98 = &v89[8 * v88];
      *v97 = v613;
      v85 = (char *)(v97 + 1);
      v100 = v616;
      v99 = v617;
      if (v617 != v616)
      {
        do
        {
          v101 = (OZChannel *)*((void *)v99 - 1);
          v99 -= 8;
          *--v97 = v101;
        }
        while (v99 != v100);
        v99 = v616;
      }
      v616 = (char *)v97;
      v617 = v85;
      unint64_t v618 = (unint64_t)v98;
      if (v99) {
        operator delete(v99);
      }
    }
    else
    {
      *v57 = v613;
      v85 = (char *)(v57 + 1);
    }
    v617 = v85;
    if (!v16) {
      goto LABEL_754;
    }
    if ((unint64_t)v85 >= v618)
    {
      uint64_t v104 = (v85 - v616) >> 3;
      if ((unint64_t)(v104 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v105 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v105 <= v104 + 1) {
        unint64_t v105 = v104 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v106 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v106 = v105;
      }
      v102 = (char *)this + 23160;
      if (v106) {
        v107 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v106);
      }
      else {
        v107 = 0;
      }
      v136 = &v107[8 * v104];
      v137 = &v107[8 * v106];
      *(void *)v136 = v601;
      v103 = v136 + 8;
      v139 = v616;
      v138 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v140 = *((void *)v138 - 1);
          v138 -= 8;
          *((void *)v136 - 1) = v140;
          v136 -= 8;
        }
        while (v138 != v139);
        v138 = v616;
      }
      v616 = v136;
      v617 = v103;
      unint64_t v618 = (unint64_t)v137;
      if (v138) {
        operator delete(v138);
      }
    }
    else
    {
      v102 = (char *)this + 23160;
      *(void *)v85 = v601;
      v103 = v85 + 8;
    }
    v617 = v103;
    if ((unint64_t)v103 < v618)
    {
      *(void *)v103 = v102;
      v141 = v103 + 8;
LABEL_718:
      v617 = v141;
      goto LABEL_754;
    }
    uint64_t v142 = (v103 - v616) >> 3;
    if ((unint64_t)(v142 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v143 = (uint64_t)(v618 - (void)v616) >> 2;
    if (v143 <= v142 + 1) {
      unint64_t v143 = v142 + 1;
    }
    if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v144 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v144 = v143;
    }
    if (v144) {
      v145 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v144);
    }
    else {
      v145 = 0;
    }
    v146 = &v145[8 * v142];
    v147 = &v145[8 * v144];
    *(void *)v146 = v102;
    v141 = v146 + 8;
    v149 = v616;
    v148 = v617;
    if (v617 != v616)
    {
      do
      {
        uint64_t v150 = *((void *)v148 - 1);
        v148 -= 8;
        *((void *)v146 - 1) = v150;
        v146 -= 8;
      }
      while (v148 != v149);
      goto LABEL_232;
    }
LABEL_233:
    v616 = v146;
    v617 = v141;
    unint64_t v618 = (unint64_t)v147;
    if (v148) {
      operator delete(v148);
    }
    goto LABEL_718;
  }
  if (ValueAsInt == 10)
  {
    int v12 = v8;
    __n128 v13 = v617;
    if ((unint64_t)v617 >= v618)
    {
      uint64_t v22 = (v617 - v616) >> 3;
      uint64_t v15 = (char *)this + 23312;
      if ((unint64_t)(v22 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v23 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v23 <= v22 + 1) {
        unint64_t v23 = v22 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v23;
      }
      if (v24) {
        uint64_t v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v24);
      }
      else {
        uint64_t v25 = 0;
      }
      v42 = &v25[8 * v22];
      v43 = &v25[8 * v24];
      *(void *)v42 = v6;
      uint64_t v14 = v42 + 8;
      v45 = v616;
      v44 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v46 = *((void *)v44 - 1);
          v44 -= 8;
          *((void *)v42 - 1) = v46;
          v42 -= 8;
        }
        while (v44 != v45);
        v44 = v616;
      }
      v616 = v42;
      v617 = (char *)v14;
      unint64_t v618 = (unint64_t)v43;
      if (v44) {
        operator delete(v44);
      }
    }
    else
    {
      *(void *)v617 = v6;
      uint64_t v14 = v13 + 8;
      uint64_t v15 = (char *)this + 23312;
    }
    v617 = (char *)v14;
    if ((unint64_t)v14 >= v618)
    {
      uint64_t v48 = ((char *)v14 - v616) >> 3;
      if ((unint64_t)(v48 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v49 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v49 <= v48 + 1) {
        unint64_t v49 = v48 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v50 = v49;
      }
      if (v50) {
        v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v50);
      }
      else {
        v51 = 0;
      }
      v72 = &v51[8 * v48];
      v73 = &v51[8 * v50];
      *(void *)v72 = v15;
      v47 = (OZChannel **)(v72 + 8);
      v75 = v616;
      uint64_t v74 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v76 = *((void *)v74 - 1);
          v74 -= 8;
          *((void *)v72 - 1) = v76;
          v72 -= 8;
        }
        while (v74 != v75);
        uint64_t v74 = v616;
      }
      v616 = v72;
      v617 = (char *)v47;
      unint64_t v618 = (unint64_t)v73;
      if (v74) {
        operator delete(v74);
      }
    }
    else
    {
      void *v14 = v15;
      v47 = (OZChannel **)(v14 + 1);
    }
    v617 = (char *)v47;
    if (v7 != 2)
    {
      if (v7 == 1)
      {
        if ((unint64_t)v47 >= v618)
        {
          uint64_t v112 = ((char *)v47 - v616) >> 3;
          if ((unint64_t)(v112 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v113 = (uint64_t)(v618 - (void)v616) >> 2;
          if (v113 <= v112 + 1) {
            unint64_t v113 = v112 + 1;
          }
          if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v114 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v114 = v113;
          }
          if (v114) {
            v115 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v114);
          }
          else {
            v115 = 0;
          }
          v195 = &v115[8 * v112];
          v196 = &v115[8 * v114];
          *(void *)v195 = v598;
          v78 = v195 + 8;
          v198 = v616;
          v197 = v617;
          if (v617 != v616)
          {
            do
            {
              uint64_t v199 = *((void *)v197 - 1);
              v197 -= 8;
              *((void *)v195 - 1) = v199;
              v195 -= 8;
            }
            while (v197 != v198);
            v197 = v616;
          }
          v616 = v195;
          v617 = v78;
          unint64_t v618 = (unint64_t)v196;
          if (v197) {
            operator delete(v197);
          }
        }
        else
        {
          *v47 = v598;
          v78 = (char *)(v47 + 1);
        }
        v617 = v78;
        if ((unint64_t)v78 >= v618)
        {
          uint64_t v200 = (v78 - v616) >> 3;
          if ((unint64_t)(v200 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v201 = (uint64_t)(v618 - (void)v616) >> 2;
          if (v201 <= v200 + 1) {
            unint64_t v201 = v200 + 1;
          }
          if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v202 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v202 = v201;
          }
          if (v202) {
            v203 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v202);
          }
          else {
            v203 = 0;
          }
          v266 = &v203[8 * v200];
          v267 = &v203[8 * v202];
          *(void *)v266 = v599;
          v79 = v266 + 8;
          v269 = v616;
          v268 = v617;
          if (v617 != v616)
          {
            do
            {
              uint64_t v270 = *((void *)v268 - 1);
              v268 -= 8;
              *((void *)v266 - 1) = v270;
              v266 -= 8;
            }
            while (v268 != v269);
            v268 = v616;
          }
          v616 = v266;
          v617 = v79;
          unint64_t v618 = (unint64_t)v267;
          if (v268) {
            operator delete(v268);
          }
        }
        else
        {
          *(void *)v78 = v599;
          v79 = v78 + 8;
        }
        v617 = v79;
        if ((unint64_t)v79 >= v618)
        {
          uint64_t v271 = (v79 - v616) >> 3;
          if ((unint64_t)(v271 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v272 = (uint64_t)(v618 - (void)v616) >> 2;
          if (v272 <= v271 + 1) {
            unint64_t v272 = v271 + 1;
          }
          if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v273 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v273 = v272;
          }
          if (v273) {
            v274 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v273);
          }
          else {
            v274 = 0;
          }
          v302 = &v274[8 * v271];
          v303 = &v274[8 * v273];
          *(void *)v302 = v597;
          v304 = v302 + 8;
          v306 = v616;
          v305 = v617;
          if (v617 == v616) {
            goto LABEL_751;
          }
          do
          {
            uint64_t v307 = *((void *)v305 - 1);
            v305 -= 8;
            *((void *)v302 - 1) = v307;
            v302 -= 8;
          }
          while (v305 != v306);
          goto LABEL_750;
        }
LABEL_454:
        v236 = (char *)this + 21064;
        goto LABEL_641;
      }
      if (v7) {
        goto LABEL_754;
      }
      if ((unint64_t)v47 >= v618)
      {
        uint64_t v120 = ((char *)v47 - v616) >> 3;
        if ((unint64_t)(v120 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v121 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v121 <= v120 + 1) {
          unint64_t v121 = v120 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v122 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v122 = v121;
        }
        if (v122) {
          v123 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v122);
        }
        else {
          v123 = 0;
        }
        v213 = (OZChannel **)&v123[8 * v120];
        v214 = &v123[8 * v122];
        *v213 = v613;
        v77 = v213 + 1;
        v216 = v616;
        v215 = v617;
        if (v617 != v616)
        {
          do
          {
            v217 = (OZChannel *)*((void *)v215 - 1);
            v215 -= 8;
            *--v213 = v217;
          }
          while (v215 != v216);
          v215 = v616;
        }
        v616 = (char *)v213;
        v617 = (char *)v77;
        unint64_t v618 = (unint64_t)v214;
        if (v215) {
          operator delete(v215);
        }
      }
      else
      {
        *v47 = v613;
        v77 = v47 + 1;
      }
      v617 = (char *)v77;
      if (!v12) {
        goto LABEL_754;
      }
      if ((unint64_t)v77 >= v618)
      {
        uint64_t v218 = ((char *)v77 - v616) >> 3;
        if ((unint64_t)(v218 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v219 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v219 <= v218 + 1) {
          unint64_t v219 = v218 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v220 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v220 = v219;
        }
        if (v220) {
          v221 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v220);
        }
        else {
          v221 = 0;
        }
        v382 = &v221[8 * v218];
        v383 = &v221[8 * v220];
        *(void *)v382 = v598;
        v79 = v382 + 8;
        v385 = v616;
        v384 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v386 = *((void *)v384 - 1);
            v384 -= 8;
            *((void *)v382 - 1) = v386;
            v382 -= 8;
          }
          while (v384 != v385);
          v384 = v616;
        }
        v616 = v382;
        v617 = v79;
        unint64_t v618 = (unint64_t)v383;
        if (v384) {
          operator delete(v384);
        }
      }
      else
      {
        *v77 = v598;
        v79 = (char *)(v77 + 1);
      }
      v617 = v79;
      if ((unint64_t)v79 >= v618)
      {
        uint64_t v387 = (v79 - v616) >> 3;
        if ((unint64_t)(v387 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v388 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v388 <= v387 + 1) {
          unint64_t v388 = v387 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v389 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v389 = v388;
        }
        if (v389) {
          v390 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v389);
        }
        else {
          v390 = 0;
        }
        v302 = &v390[8 * v387];
        v303 = &v390[8 * v389];
        *(void *)v302 = v599;
        v304 = v302 + 8;
        v402 = v616;
        v305 = v617;
        if (v617 == v616) {
          goto LABEL_751;
        }
        do
        {
          uint64_t v403 = *((void *)v305 - 1);
          v305 -= 8;
          *((void *)v302 - 1) = v403;
          v302 -= 8;
        }
        while (v305 != v402);
        goto LABEL_750;
      }
      v236 = (char *)this + 20456;
LABEL_641:
      *(void *)v79 = v236;
      v304 = v79 + 8;
LABEL_753:
      v617 = v304;
      goto LABEL_754;
    }
    if ((unint64_t)v47 >= v618)
    {
      uint64_t v116 = ((char *)v47 - v616) >> 3;
      if ((unint64_t)(v116 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v117 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v117 <= v116 + 1) {
        unint64_t v117 = v116 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v118 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v118 = v117;
      }
      if (v118) {
        v119 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v118);
      }
      else {
        v119 = 0;
      }
      v204 = (OZChannel **)&v119[8 * v116];
      v205 = &v119[8 * v118];
      *v204 = v613;
      v79 = (char *)(v204 + 1);
      v207 = v616;
      v206 = v617;
      if (v617 != v616)
      {
        do
        {
          v208 = (OZChannel *)*((void *)v206 - 1);
          v206 -= 8;
          *--v204 = v208;
        }
        while (v206 != v207);
        v206 = v616;
      }
      v616 = (char *)v204;
      v617 = v79;
      unint64_t v618 = (unint64_t)v205;
      if (v206) {
        operator delete(v206);
      }
    }
    else
    {
      *v47 = v613;
      v79 = (char *)(v47 + 1);
    }
    v617 = v79;
    if (!v12) {
      goto LABEL_754;
    }
    if ((unint64_t)v79 >= v618)
    {
      uint64_t v209 = (v79 - v616) >> 3;
      if ((unint64_t)(v209 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v210 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v210 <= v209 + 1) {
        unint64_t v210 = v209 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v211 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v211 = v210;
      }
      if (v211) {
        v212 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v211);
      }
      else {
        v212 = 0;
      }
      v302 = &v212[8 * v209];
      v303 = &v212[8 * v211];
      *(void *)v302 = v601;
      v304 = v302 + 8;
      v380 = v616;
      v305 = v617;
      if (v617 == v616) {
        goto LABEL_751;
      }
      do
      {
        uint64_t v381 = *((void *)v305 - 1);
        v305 -= 8;
        *((void *)v302 - 1) = v381;
        v302 -= 8;
      }
      while (v305 != v380);
      goto LABEL_750;
    }
LABEL_386:
    v236 = (char *)this + 20152;
    goto LABEL_641;
  }
  int v591 = v8;
  if (ValueAsInt == 2)
  {
    long long v9 = v617;
    if ((unint64_t)v617 >= v618)
    {
      uint64_t v30 = (v617 - v616) >> 3;
      PCSharedCount v11 = (char *)this + 23312;
      if ((unint64_t)(v30 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v31 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v31 <= v30 + 1) {
        unint64_t v31 = v30 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v32 = v31;
      }
      if (v32) {
        long long v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v32);
      }
      else {
        long long v33 = 0;
      }
      v62 = &v33[8 * v30];
      v63 = &v33[8 * v32];
      *(void *)v62 = v6;
      long long v10 = v62 + 8;
      v65 = v616;
      v64 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v66 = *((void *)v64 - 1);
          v64 -= 8;
          *((void *)v62 - 1) = v66;
          v62 -= 8;
        }
        while (v64 != v65);
        v64 = v616;
      }
      v616 = v62;
      v617 = (char *)v10;
      unint64_t v618 = (unint64_t)v63;
      if (v64) {
        operator delete(v64);
      }
    }
    else
    {
      *(void *)v617 = v6;
      long long v10 = v9 + 8;
      PCSharedCount v11 = (char *)this + 23312;
    }
    v617 = (char *)v10;
    if ((unint64_t)v10 >= v618)
    {
      uint64_t v68 = ((char *)v10 - v616) >> 3;
      if ((unint64_t)(v68 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v69 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v69 <= v68 + 1) {
        unint64_t v69 = v68 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v70 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v70 = v69;
      }
      if (v70) {
        v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v70);
      }
      else {
        v71 = 0;
      }
      v90 = &v71[8 * v68];
      v91 = &v71[8 * v70];
      *(void *)v90 = v11;
      v67 = (OZChannel **)(v90 + 8);
      v93 = v616;
      v92 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v94 = *((void *)v92 - 1);
          v92 -= 8;
          *((void *)v90 - 1) = v94;
          v90 -= 8;
        }
        while (v92 != v93);
        v92 = v616;
      }
      v616 = v90;
      v617 = (char *)v67;
      unint64_t v618 = (unint64_t)v91;
      if (v92) {
        operator delete(v92);
      }
    }
    else
    {
      void *v10 = v11;
      v67 = (OZChannel **)(v10 + 1);
    }
    v617 = (char *)v67;
    if (v7 != 2)
    {
      if (v7 != 1)
      {
        if (!v7)
        {
          if ((unint64_t)v67 >= v618)
          {
            uint64_t v132 = ((char *)v67 - v616) >> 3;
            if ((unint64_t)(v132 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v133 = (uint64_t)(v618 - (void)v616) >> 2;
            if (v133 <= v132 + 1) {
              unint64_t v133 = v132 + 1;
            }
            if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v134 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v134 = v133;
            }
            if (v134) {
              v135 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v134);
            }
            else {
              v135 = 0;
            }
            v255 = (OZChannel **)&v135[8 * v132];
            v256 = &v135[8 * v134];
            *v255 = v613;
            v95 = (char *)(v255 + 1);
            v258 = v616;
            v257 = v617;
            if (v617 != v616)
            {
              do
              {
                v259 = (OZChannel *)*((void *)v257 - 1);
                v257 -= 8;
                *--v255 = v259;
              }
              while (v257 != v258);
              v257 = v616;
            }
            v616 = (char *)v255;
            v617 = v95;
            unint64_t v618 = (unint64_t)v256;
            if (v257) {
              operator delete(v257);
            }
          }
          else
          {
            *v67 = v613;
            v95 = (char *)(v67 + 1);
          }
          v617 = v95;
          if (v591)
          {
            if ((unint64_t)v95 >= v618)
            {
              uint64_t v262 = (v95 - v616) >> 3;
              if ((unint64_t)(v262 + 1) >> 61) {
                std::vector<double>::__throw_length_error[abi:ne180100]();
              }
              unint64_t v263 = (uint64_t)(v618 - (void)v616) >> 2;
              if (v263 <= v262 + 1) {
                unint64_t v263 = v262 + 1;
              }
              if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v264 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v264 = v263;
              }
              v260 = (char *)this + 23160;
              if (v264) {
                v265 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v264);
              }
              else {
                v265 = 0;
              }
              v393 = &v265[8 * v262];
              v394 = &v265[8 * v264];
              *(void *)v393 = v601;
              v261 = v393 + 8;
              v396 = v616;
              v395 = v617;
              if (v617 != v616)
              {
                do
                {
                  uint64_t v397 = *((void *)v395 - 1);
                  v395 -= 8;
                  *((void *)v393 - 1) = v397;
                  v393 -= 8;
                }
                while (v395 != v396);
                v395 = v616;
              }
              v616 = v393;
              v617 = v261;
              unint64_t v618 = (unint64_t)v394;
              if (v395) {
                operator delete(v395);
              }
            }
            else
            {
              v260 = (char *)this + 23160;
              *(void *)v95 = v601;
              v261 = v95 + 8;
            }
            v617 = v261;
            if ((unint64_t)v261 < v618)
            {
              *(void *)v261 = v260;
              v304 = v261 + 8;
              goto LABEL_753;
            }
            uint64_t v398 = (v261 - v616) >> 3;
            if ((unint64_t)(v398 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v399 = (uint64_t)(v618 - (void)v616) >> 2;
            if (v399 <= v398 + 1) {
              unint64_t v399 = v398 + 1;
            }
            if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v400 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v400 = v399;
            }
            if (v400) {
              v401 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v400);
            }
            else {
              v401 = 0;
            }
            v302 = &v401[8 * v398];
            v303 = &v401[8 * v400];
            *(void *)v302 = v260;
            v304 = v302 + 8;
            v404 = v616;
            v305 = v617;
            if (v617 != v616)
            {
              do
              {
                uint64_t v405 = *((void *)v305 - 1);
                v305 -= 8;
                *((void *)v302 - 1) = v405;
                v302 -= 8;
              }
              while (v305 != v404);
LABEL_750:
              v305 = v616;
              goto LABEL_751;
            }
            goto LABEL_751;
          }
        }
        goto LABEL_754;
      }
      if ((unint64_t)v67 >= v618)
      {
        uint64_t v124 = ((char *)v67 - v616) >> 3;
        if ((unint64_t)(v124 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v125 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v125 <= v124 + 1) {
          unint64_t v125 = v124 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v126 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v126 = v125;
        }
        if (v126) {
          v127 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v126);
        }
        else {
          v127 = 0;
        }
        v222 = &v127[8 * v124];
        v223 = &v127[8 * v126];
        *(void *)v222 = v598;
        v96 = v222 + 8;
        v225 = v616;
        v224 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v226 = *((void *)v224 - 1);
            v224 -= 8;
            *((void *)v222 - 1) = v226;
            v222 -= 8;
          }
          while (v224 != v225);
          v224 = v616;
        }
        v616 = v222;
        v617 = v96;
        unint64_t v618 = (unint64_t)v223;
        if (v224) {
          operator delete(v224);
        }
      }
      else
      {
        *v67 = v598;
        v96 = (char *)(v67 + 1);
      }
      v617 = v96;
      if ((unint64_t)v96 >= v618)
      {
        uint64_t v227 = (v96 - v616) >> 3;
        if ((unint64_t)(v227 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v228 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v228 <= v227 + 1) {
          unint64_t v228 = v227 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v229 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v229 = v228;
        }
        if (v229) {
          v230 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v229);
        }
        else {
          v230 = 0;
        }
        v275 = &v230[8 * v227];
        v276 = &v230[8 * v229];
        *(void *)v275 = v599;
        v79 = v275 + 8;
        v278 = v616;
        v277 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v279 = *((void *)v277 - 1);
            v277 -= 8;
            *((void *)v275 - 1) = v279;
            v275 -= 8;
          }
          while (v277 != v278);
          v277 = v616;
        }
        v616 = v275;
        v617 = v79;
        unint64_t v618 = (unint64_t)v276;
        if (v277) {
          operator delete(v277);
        }
      }
      else
      {
        *(void *)v96 = v599;
        v79 = v96 + 8;
      }
      v617 = v79;
      if ((unint64_t)v79 >= v618)
      {
        uint64_t v280 = (v79 - v616) >> 3;
        if ((unint64_t)(v280 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v281 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v281 <= v280 + 1) {
          unint64_t v281 = v280 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v282 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v282 = v281;
        }
        if (v282) {
          v283 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v282);
        }
        else {
          v283 = 0;
        }
        v302 = &v283[8 * v280];
        v303 = &v283[8 * v282];
        *(void *)v302 = v597;
        v304 = v302 + 8;
        v308 = v616;
        v305 = v617;
        if (v617 == v616) {
          goto LABEL_751;
        }
        do
        {
          uint64_t v309 = *((void *)v305 - 1);
          v305 -= 8;
          *((void *)v302 - 1) = v309;
          v302 -= 8;
        }
        while (v305 != v308);
        goto LABEL_750;
      }
      goto LABEL_454;
    }
    if ((unint64_t)v67 >= v618)
    {
      uint64_t v128 = ((char *)v67 - v616) >> 3;
      if ((unint64_t)(v128 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v129 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v129 <= v128 + 1) {
        unint64_t v129 = v128 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v130 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v130 = v129;
      }
      if (v130) {
        v131 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v130);
      }
      else {
        v131 = 0;
      }
      v231 = (OZChannel **)&v131[8 * v128];
      v232 = &v131[8 * v130];
      *v231 = v613;
      v79 = (char *)(v231 + 1);
      v234 = v616;
      v233 = v617;
      if (v617 != v616)
      {
        do
        {
          v235 = (OZChannel *)*((void *)v233 - 1);
          v233 -= 8;
          *--v231 = v235;
        }
        while (v233 != v234);
        v233 = v616;
      }
      v616 = (char *)v231;
      v617 = v79;
      unint64_t v618 = (unint64_t)v232;
      if (v233) {
        operator delete(v233);
      }
    }
    else
    {
      *v67 = v613;
      v79 = (char *)(v67 + 1);
    }
    v617 = v79;
    if (!v591) {
      goto LABEL_754;
    }
    if ((unint64_t)v79 >= v618)
    {
      uint64_t v237 = (v79 - v616) >> 3;
      if ((unint64_t)(v237 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v238 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v238 <= v237 + 1) {
        unint64_t v238 = v237 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v239 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v239 = v238;
      }
      if (v239) {
        v240 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v239);
      }
      else {
        v240 = 0;
      }
      v302 = &v240[8 * v237];
      v303 = &v240[8 * v239];
      *(void *)v302 = v601;
      v304 = v302 + 8;
      v391 = v616;
      v305 = v617;
      if (v617 == v616) {
        goto LABEL_751;
      }
      do
      {
        uint64_t v392 = *((void *)v305 - 1);
        v305 -= 8;
        *((void *)v302 - 1) = v392;
        v302 -= 8;
      }
      while (v305 != v391);
      goto LABEL_750;
    }
    goto LABEL_386;
  }
  if ((ValueAsInt - 5) <= 1)
  {
    uint64_t v20 = v617;
    if ((unint64_t)v617 >= v618)
    {
      uint64_t v38 = (v617 - v616) >> 3;
      if ((unint64_t)(v38 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v39 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v39 <= v38 + 1) {
        unint64_t v39 = v38 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v40 = v39;
      }
      if (v40) {
        v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v40);
      }
      else {
        v41 = 0;
      }
      v151 = &v41[8 * v38];
      v152 = &v41[8 * v40];
      *(void *)v151 = v6;
      unint64_t v21 = v151 + 8;
      v154 = v616;
      v153 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v155 = *((void *)v153 - 1);
          v153 -= 8;
          *((void *)v151 - 1) = v155;
          v151 -= 8;
        }
        while (v153 != v154);
        v153 = v616;
      }
      v616 = v151;
      v617 = (char *)v21;
      unint64_t v618 = (unint64_t)v152;
      if (v153) {
        operator delete(v153);
      }
    }
    else
    {
      *(void *)v617 = v6;
      unint64_t v21 = v20 + 8;
    }
    v617 = (char *)v21;
    if (ValueAsInt == 5)
    {
      if ((unint64_t)v21 >= v618)
      {
        uint64_t v159 = ((char *)v21 - v616) >> 3;
        if ((unint64_t)(v159 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v160 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v160 <= v159 + 1) {
          unint64_t v160 = v159 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v161 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v161 = v160;
        }
        if (v161) {
          v162 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v161);
        }
        else {
          v162 = 0;
        }
        v175 = &v162[8 * v159];
        v176 = &v162[8 * v161];
        *(void *)v175 = v593;
        v156 = v175 + 8;
        v178 = v616;
        v177 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v179 = *((void *)v177 - 1);
            v177 -= 8;
            *((void *)v175 - 1) = v179;
            v175 -= 8;
          }
          while (v177 != v178);
          v177 = v616;
        }
        v616 = v175;
        v617 = (char *)v156;
        unint64_t v618 = (unint64_t)v176;
        if (v177) {
          operator delete(v177);
        }
      }
      else
      {
        *unint64_t v21 = v593;
        v156 = v21 + 1;
      }
      v617 = (char *)v156;
      if ((unint64_t)v156 < v618)
      {
        void *v156 = v594;
        v180 = (OZChannel **)(v156 + 1);
LABEL_469:
        v617 = (char *)v180;
        if (v7)
        {
          if (v7 != 2)
          {
            if (v7 != 1) {
              goto LABEL_754;
            }
            if ((unint64_t)v180 >= v618)
            {
              uint64_t v298 = ((char *)v180 - v616) >> 3;
              if ((unint64_t)(v298 + 1) >> 61) {
                std::vector<double>::__throw_length_error[abi:ne180100]();
              }
              unint64_t v299 = (uint64_t)(v618 - (void)v616) >> 2;
              if (v299 <= v298 + 1) {
                unint64_t v299 = v298 + 1;
              }
              if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v300 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v300 = v299;
              }
              v286 = (char *)this + 20456;
              if (v300) {
                v301 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v300);
              }
              else {
                v301 = 0;
              }
              v416 = &v301[8 * v298];
              v417 = &v301[8 * v300];
              *(void *)v416 = v598;
              v287 = v416 + 8;
              v419 = v616;
              v418 = v617;
              if (v617 != v616)
              {
                do
                {
                  uint64_t v420 = *((void *)v418 - 1);
                  v418 -= 8;
                  *((void *)v416 - 1) = v420;
                  v416 -= 8;
                }
                while (v418 != v419);
                v418 = v616;
              }
              v616 = v416;
              v617 = v287;
              unint64_t v618 = (unint64_t)v417;
              if (v418) {
                operator delete(v418);
              }
            }
            else
            {
              v286 = (char *)this + 20456;
              *v180 = v598;
              v287 = (char *)(v180 + 1);
            }
            v617 = v287;
            if ((unint64_t)v287 >= v618)
            {
              uint64_t v422 = (v287 - v616) >> 3;
              if ((unint64_t)(v422 + 1) >> 61) {
                std::vector<double>::__throw_length_error[abi:ne180100]();
              }
              unint64_t v423 = (uint64_t)(v618 - (void)v616) >> 2;
              if (v423 <= v422 + 1) {
                unint64_t v423 = v422 + 1;
              }
              if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v424 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v424 = v423;
              }
              if (v424) {
                v425 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v424);
              }
              else {
                v425 = 0;
              }
              v426 = &v425[8 * v422];
              v427 = &v425[8 * v424];
              *(void *)v426 = v286;
              v421 = v426 + 8;
              v429 = v616;
              v428 = v617;
              if (v617 != v616)
              {
                do
                {
                  uint64_t v430 = *((void *)v428 - 1);
                  v428 -= 8;
                  *((void *)v426 - 1) = v430;
                  v426 -= 8;
                }
                while (v428 != v429);
                v428 = v616;
              }
              v616 = v426;
              v617 = v421;
              unint64_t v618 = (unint64_t)v427;
              if (v428) {
                operator delete(v428);
              }
            }
            else
            {
              *(void *)v287 = v286;
              v421 = v287 + 8;
            }
            v617 = v421;
            if ((unint64_t)v421 < v618)
            {
              *(void *)v421 = v597;
              v141 = v421 + 8;
              goto LABEL_718;
            }
            uint64_t v431 = (v421 - v616) >> 3;
            if ((unint64_t)(v431 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v432 = (uint64_t)(v618 - (void)v616) >> 2;
            if (v432 <= v431 + 1) {
              unint64_t v432 = v431 + 1;
            }
            if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v433 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v433 = v432;
            }
            if (v433) {
              v434 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v433);
            }
            else {
              v434 = 0;
            }
            v146 = &v434[8 * v431];
            v147 = &v434[8 * v433];
            *(void *)v146 = v597;
            v141 = v146 + 8;
            v435 = v616;
            v148 = v617;
            if (v617 != v616)
            {
              do
              {
                uint64_t v436 = *((void *)v148 - 1);
                v148 -= 8;
                *((void *)v146 - 1) = v436;
                v146 -= 8;
              }
              while (v148 != v435);
LABEL_232:
              v148 = v616;
              goto LABEL_233;
            }
            goto LABEL_233;
          }
          if ((unint64_t)v180 >= v618)
          {
            uint64_t v290 = ((char *)v180 - v616) >> 3;
            if ((unint64_t)(v290 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v291 = (uint64_t)(v618 - (void)v616) >> 2;
            if (v291 <= v290 + 1) {
              unint64_t v291 = v290 + 1;
            }
            if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v292 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v292 = v291;
            }
            if (v292) {
              v293 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v292);
            }
            else {
              v293 = 0;
            }
            v406 = (OZChannel **)&v293[8 * v290];
            v407 = &v293[8 * v292];
            *v406 = v613;
            v288 = (char *)(v406 + 1);
            v409 = v616;
            v408 = v617;
            if (v617 != v616)
            {
              do
              {
                v410 = (OZChannel *)*((void *)v408 - 1);
                v408 -= 8;
                *--v406 = v410;
              }
              while (v408 != v409);
              v408 = v616;
            }
            v616 = (char *)v406;
            v617 = v288;
            unint64_t v618 = (unint64_t)v407;
            if (v408) {
              operator delete(v408);
            }
          }
          else
          {
            *v180 = v613;
            v288 = (char *)(v180 + 1);
          }
          v617 = v288;
          if (!v591) {
            goto LABEL_754;
          }
LABEL_626:
          v614 = (OZChannelBase *)((char *)this + 20152);
          std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
          goto LABEL_754;
        }
        if ((unint64_t)v180 >= v618)
        {
          uint64_t v294 = ((char *)v180 - v616) >> 3;
          if ((unint64_t)(v294 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v295 = (uint64_t)(v618 - (void)v616) >> 2;
          if (v295 <= v294 + 1) {
            unint64_t v295 = v294 + 1;
          }
          if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v296 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v296 = v295;
          }
          if (v296) {
            v297 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v296);
          }
          else {
            v297 = 0;
          }
          v411 = (OZChannel **)&v297[8 * v294];
          v412 = &v297[8 * v296];
          *v411 = v613;
          v289 = (char *)(v411 + 1);
          v414 = v616;
          v413 = v617;
          if (v617 != v616)
          {
            do
            {
              v415 = (OZChannel *)*((void *)v413 - 1);
              v413 -= 8;
              *--v411 = v415;
            }
            while (v413 != v414);
            v413 = v616;
          }
          v616 = (char *)v411;
          v617 = v289;
          unint64_t v618 = (unint64_t)v412;
          if (v413) {
            operator delete(v413);
          }
        }
        else
        {
          *v180 = v613;
          v289 = (char *)(v180 + 1);
        }
        v617 = v289;
        if (!v591) {
          goto LABEL_754;
        }
        goto LABEL_280;
      }
      uint64_t v181 = ((char *)v156 - v616) >> 3;
      if ((unint64_t)(v181 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v182 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v182 <= v181 + 1) {
        unint64_t v182 = v181 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v183 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v183 = v182;
      }
      if (v183) {
        v184 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v183);
      }
      else {
        v184 = 0;
      }
      v241 = &v184[8 * v181];
      v242 = &v184[8 * v183];
      *(void *)v241 = v594;
      v180 = (OZChannel **)(v241 + 8);
      v244 = v616;
      v243 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v245 = *((void *)v243 - 1);
          v243 -= 8;
          *((void *)v241 - 1) = v245;
          v241 -= 8;
        }
        while (v243 != v244);
LABEL_466:
        v243 = v616;
      }
    }
    else
    {
      if ((unint64_t)v21 >= v618)
      {
        uint64_t v163 = ((char *)v21 - v616) >> 3;
        v158 = (char *)this + 25680;
        if ((unint64_t)(v163 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v164 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v164 <= v163 + 1) {
          unint64_t v164 = v163 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v165 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v165 = v164;
        }
        if (v165) {
          v166 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v165);
        }
        else {
          v166 = 0;
        }
        v185 = &v166[8 * v163];
        v186 = &v166[8 * v165];
        *(void *)v185 = v596;
        v157 = v185 + 8;
        v188 = v616;
        v187 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v189 = *((void *)v187 - 1);
            v187 -= 8;
            *((void *)v185 - 1) = v189;
            v185 -= 8;
          }
          while (v187 != v188);
          v187 = v616;
        }
        v616 = v185;
        v617 = (char *)v157;
        unint64_t v618 = (unint64_t)v186;
        if (v187) {
          operator delete(v187);
        }
      }
      else
      {
        *unint64_t v21 = v596;
        v157 = v21 + 1;
        v158 = (char *)this + 25680;
      }
      v617 = (char *)v157;
      if ((unint64_t)v157 >= v618)
      {
        uint64_t v191 = ((char *)v157 - v616) >> 3;
        if ((unint64_t)(v191 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v192 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v192 <= v191 + 1) {
          unint64_t v192 = v191 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v193 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v193 = v192;
        }
        if (v193) {
          v194 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v193);
        }
        else {
          v194 = 0;
        }
        v246 = &v194[8 * v191];
        v247 = &v194[8 * v193];
        *(void *)v246 = v595;
        v190 = v246 + 8;
        v249 = v616;
        v248 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v250 = *((void *)v248 - 1);
            v248 -= 8;
            *((void *)v246 - 1) = v250;
            v246 -= 8;
          }
          while (v248 != v249);
          v248 = v616;
        }
        v616 = v246;
        v617 = (char *)v190;
        unint64_t v618 = (unint64_t)v247;
        if (v248) {
          operator delete(v248);
        }
      }
      else
      {
        void *v157 = v595;
        v190 = v157 + 1;
      }
      v617 = (char *)v190;
      if ((unint64_t)v190 < v618)
      {
        void *v190 = v158;
        v180 = (OZChannel **)(v190 + 1);
        goto LABEL_469;
      }
      uint64_t v251 = ((char *)v190 - v616) >> 3;
      if ((unint64_t)(v251 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v252 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v252 <= v251 + 1) {
        unint64_t v252 = v251 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v253 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v253 = v252;
      }
      if (v253) {
        v254 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v253);
      }
      else {
        v254 = 0;
      }
      v241 = &v254[8 * v251];
      v242 = &v254[8 * v253];
      *(void *)v241 = v158;
      v180 = (OZChannel **)(v241 + 8);
      v284 = v616;
      v243 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v285 = *((void *)v243 - 1);
          v243 -= 8;
          *((void *)v241 - 1) = v285;
          v241 -= 8;
        }
        while (v243 != v284);
        goto LABEL_466;
      }
    }
    v616 = v241;
    v617 = (char *)v180;
    unint64_t v618 = (unint64_t)v242;
    if (v243) {
      operator delete(v243);
    }
    goto LABEL_469;
  }
  if (ValueAsInt != 4)
  {
    if (ValueAsInt == 11)
    {
      uint64_t v34 = v617;
      if ((unint64_t)v617 >= v618)
      {
        uint64_t v167 = (v617 - v616) >> 3;
        v36 = (char *)this + 25680;
        v37 = (char *)this + 25832;
        if ((unint64_t)(v167 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v168 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v168 <= v167 + 1) {
          unint64_t v168 = v167 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v169 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v169 = v168;
        }
        if (v169) {
          v170 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v169);
        }
        else {
          v170 = 0;
        }
        v314 = &v170[8 * v167];
        v315 = &v170[8 * v169];
        *(void *)v314 = v6;
        uint64_t v35 = v314 + 8;
        v317 = v616;
        v316 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v318 = *((void *)v316 - 1);
            v316 -= 8;
            *((void *)v314 - 1) = v318;
            v314 -= 8;
          }
          while (v316 != v317);
          v316 = v616;
        }
        v616 = v314;
        v617 = v35;
        unint64_t v618 = (unint64_t)v315;
        if (v316) {
          operator delete(v316);
        }
      }
      else
      {
        *(void *)v617 = v6;
        uint64_t v35 = v34 + 8;
        v36 = (char *)this + 25680;
        v37 = (char *)this + 25832;
      }
      v617 = v35;
      if ((unint64_t)v35 >= v618)
      {
        uint64_t v320 = (v35 - v616) >> 3;
        if ((unint64_t)(v320 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v321 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v321 <= v320 + 1) {
          unint64_t v321 = v320 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v322 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v322 = v321;
        }
        if (v322) {
          v323 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v322);
        }
        else {
          v323 = 0;
        }
        v334 = &v323[8 * v320];
        v335 = &v323[8 * v322];
        *(void *)v334 = v596;
        v319 = v334 + 8;
        v337 = v616;
        v336 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v338 = *((void *)v336 - 1);
            v336 -= 8;
            *((void *)v334 - 1) = v338;
            v334 -= 8;
          }
          while (v336 != v337);
          v336 = v616;
        }
        v616 = v334;
        v617 = v319;
        unint64_t v618 = (unint64_t)v335;
        if (v336) {
          operator delete(v336);
        }
      }
      else
      {
        *(void *)uint64_t v35 = v596;
        v319 = v35 + 8;
      }
      v617 = v319;
      if ((unint64_t)v319 >= v618)
      {
        uint64_t v340 = (v319 - v616) >> 3;
        if ((unint64_t)(v340 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v341 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v341 <= v340 + 1) {
          unint64_t v341 = v340 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v342 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v342 = v341;
        }
        if (v342) {
          v343 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v342);
        }
        else {
          v343 = 0;
        }
        v355 = &v343[8 * v340];
        v356 = &v343[8 * v342];
        *(void *)v355 = v595;
        v339 = v355 + 8;
        v358 = v616;
        v357 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v359 = *((void *)v357 - 1);
            v357 -= 8;
            *((void *)v355 - 1) = v359;
            v355 -= 8;
          }
          while (v357 != v358);
          v357 = v616;
        }
        v616 = v355;
        v617 = v339;
        unint64_t v618 = (unint64_t)v356;
        if (v357) {
          operator delete(v357);
        }
      }
      else
      {
        *(void *)v319 = v595;
        v339 = v319 + 8;
      }
      v617 = v339;
      if ((unint64_t)v339 >= v618)
      {
        uint64_t v361 = (v339 - v616) >> 3;
        if ((unint64_t)(v361 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v362 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v362 <= v361 + 1) {
          unint64_t v362 = v361 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v363 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v363 = v362;
        }
        if (v363) {
          v364 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v363);
        }
        else {
          v364 = 0;
        }
        v365 = &v364[8 * v361];
        v366 = &v364[8 * v363];
        *(void *)v365 = v36;
        v360 = v365 + 8;
        v368 = v616;
        v367 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v369 = *((void *)v367 - 1);
            v367 -= 8;
            *((void *)v365 - 1) = v369;
            v365 -= 8;
          }
          while (v367 != v368);
          v367 = v616;
        }
        v616 = v365;
        v617 = v360;
        unint64_t v618 = (unint64_t)v366;
        if (v367) {
          operator delete(v367);
        }
      }
      else
      {
        *(void *)v339 = v36;
        v360 = v339 + 8;
      }
      v617 = v360;
      if ((unint64_t)v360 >= v618)
      {
        uint64_t v371 = (v360 - v616) >> 3;
        if ((unint64_t)(v371 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v372 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v372 <= v371 + 1) {
          unint64_t v372 = v371 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v373 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v373 = v372;
        }
        if (v373) {
          v374 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v373);
        }
        else {
          v374 = 0;
        }
        v375 = &v374[8 * v371];
        v376 = &v374[8 * v373];
        *(void *)v375 = v37;
        v370 = v375 + 8;
        v378 = v616;
        v377 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v379 = *((void *)v377 - 1);
            v377 -= 8;
            *((void *)v375 - 1) = v379;
            v375 -= 8;
          }
          while (v377 != v378);
          v377 = v616;
        }
        v616 = v375;
        v617 = v370;
        unint64_t v618 = (unint64_t)v376;
        if (v377) {
          operator delete(v377);
        }
      }
      else
      {
        *(void *)v360 = v37;
        v370 = v360 + 8;
      }
      v617 = v370;
      if (!v7)
      {
        v614 = (OZChannelBase *)v613;
        std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
        if (v591)
        {
          v614 = (OZChannelBase *)((char *)this + 20304);
          std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
          v614 = (OZChannelBase *)((char *)this + 20456);
          std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
          v614 = (OZChannelBase *)((char *)this + 23160);
          std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
        }
        goto LABEL_754;
      }
      if (v7 != 2)
      {
        if (v7 == 1)
        {
          v614 = (OZChannelBase *)((char *)this + 20304);
          std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
          v614 = (OZChannelBase *)((char *)this + 20456);
          std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
          v614 = (OZChannelBase *)((char *)this + 20608);
          std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
          v614 = (OZChannelBase *)((char *)this + 21064);
          std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
        }
        goto LABEL_754;
      }
      v614 = (OZChannelBase *)v613;
      std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
      if (!v591) {
        goto LABEL_754;
      }
      goto LABEL_626;
    }
    if ((ValueAsInt - 7) <= 1)
    {
      v110 = v617;
      if ((unint64_t)v617 >= v618)
      {
        uint64_t v310 = (v617 - v616) >> 3;
        if ((unint64_t)(v310 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v311 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v311 <= v310 + 1) {
          unint64_t v311 = v310 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v312 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v312 = v311;
        }
        if (v312) {
          v313 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v312);
        }
        else {
          v313 = 0;
        }
        v566 = &v313[8 * v310];
        v567 = &v313[8 * v312];
        *(void *)v566 = v602;
        v111 = v566 + 8;
        v569 = v616;
        v568 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v570 = *((void *)v568 - 1);
            v568 -= 8;
            *((void *)v566 - 1) = v570;
            v566 -= 8;
          }
          while (v568 != v569);
          v568 = v616;
        }
        v616 = v566;
        v617 = v111;
        unint64_t v618 = (unint64_t)v567;
        if (v568) {
          operator delete(v568);
        }
      }
      else
      {
        *(void *)v617 = v602;
        v111 = v110 + 8;
      }
      v617 = v111;
      if (ValueAsInt == 8)
      {
        v614 = (OZChannelBase *)((char *)this + 26288);
        std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
        v111 = v617;
      }
      if ((unint64_t)v111 >= v618)
      {
        uint64_t v572 = (v111 - v616) >> 3;
        if ((unint64_t)(v572 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v573 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v573 <= v572 + 1) {
          unint64_t v573 = v572 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v574 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v574 = v573;
        }
        if (v574) {
          v575 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v574);
        }
        else {
          v575 = 0;
        }
        v576 = &v575[8 * v572];
        v577 = &v575[8 * v574];
        *(void *)v576 = v592;
        v571 = (OZChannel **)(v576 + 8);
        v579 = v616;
        v578 = v617;
        if (v617 != v616)
        {
          do
          {
            uint64_t v580 = *((void *)v578 - 1);
            v578 -= 8;
            *((void *)v576 - 1) = v580;
            v576 -= 8;
          }
          while (v578 != v579);
          v578 = v616;
        }
        v616 = v576;
        v617 = (char *)v571;
        unint64_t v618 = (unint64_t)v577;
        if (v578) {
          operator delete(v578);
        }
      }
      else
      {
        *(void *)v111 = v592;
        v571 = (OZChannel **)(v111 + 8);
      }
      v617 = (char *)v571;
      if ((unint64_t)v571 >= v618)
      {
        uint64_t v582 = ((char *)v571 - v616) >> 3;
        if ((unint64_t)(v582 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v583 = (uint64_t)(v618 - (void)v616) >> 2;
        if (v583 <= v582 + 1) {
          unint64_t v583 = v582 + 1;
        }
        if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v584 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v584 = v583;
        }
        if (v584) {
          v585 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v584);
        }
        else {
          v585 = 0;
        }
        v586 = (OZChannel **)&v585[8 * v582];
        v587 = &v585[8 * v584];
        *v586 = v613;
        v581 = (char *)(v586 + 1);
        v589 = v616;
        v588 = v617;
        if (v617 != v616)
        {
          do
          {
            v590 = (OZChannel *)*((void *)v588 - 1);
            v588 -= 8;
            *--v586 = v590;
          }
          while (v588 != v589);
          v588 = v616;
        }
        v616 = (char *)v586;
        v617 = v581;
        unint64_t v618 = (unint64_t)v587;
        if (v588) {
          operator delete(v588);
        }
      }
      else
      {
        *v571 = v613;
        v581 = (char *)(v571 + 1);
      }
      v617 = v581;
      if (v591)
      {
        v614 = (OZChannelBase *)((char *)this + 26136);
        std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
        v614 = (OZChannelBase *)((char *)this + 23160);
        std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
      }
      goto LABEL_754;
    }
    if (ValueAsInt != 9) {
      goto LABEL_754;
    }
    v614 = (OZChannelBase *)((char *)this + 23464);
    std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
    v614 = (OZChannelBase *)((char *)this + 24352);
    std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
    v614 = (OZChannelBase *)((char *)this + 26440);
    std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
    v614 = (OZChannelBase *)((char *)this + 26592);
    std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
    v614 = (OZChannelBase *)((char *)this + 26744);
    std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
    v614 = (OZChannelBase *)((char *)this + 26896);
    std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
    v614 = (OZChannelBase *)v613;
    std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
    if (!v591) {
      goto LABEL_754;
    }
LABEL_280:
    v614 = (OZChannelBase *)((char *)this + 20152);
    std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
    v614 = (OZChannelBase *)((char *)this + 23160);
    std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v616, &v614);
    goto LABEL_754;
  }
  v108 = v617;
  if ((unint64_t)v617 >= v618)
  {
    uint64_t v171 = (v617 - v616) >> 3;
    if ((unint64_t)(v171 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v172 = (uint64_t)(v618 - (void)v616) >> 2;
    if (v172 <= v171 + 1) {
      unint64_t v172 = v171 + 1;
    }
    if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v173 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v173 = v172;
    }
    if (v173) {
      v174 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v173);
    }
    else {
      v174 = 0;
    }
    v324 = &v174[8 * v171];
    v325 = &v174[8 * v173];
    *(void *)v324 = v4;
    v109 = (OZChannel **)(v324 + 8);
    v327 = v616;
    v326 = v617;
    if (v617 != v616)
    {
      do
      {
        uint64_t v328 = *((void *)v326 - 1);
        v326 -= 8;
        *((void *)v324 - 1) = v328;
        v324 -= 8;
      }
      while (v326 != v327);
      v326 = v616;
    }
    v616 = v324;
    v617 = (char *)v109;
    unint64_t v618 = (unint64_t)v325;
    if (v326) {
      operator delete(v326);
    }
  }
  else
  {
    *(void *)v617 = v4;
    v109 = (OZChannel **)(v108 + 8);
  }
  v617 = (char *)v109;
  if ((unint64_t)v109 >= v618)
  {
    uint64_t v330 = ((char *)v109 - v616) >> 3;
    if ((unint64_t)(v330 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v331 = (uint64_t)(v618 - (void)v616) >> 2;
    if (v331 <= v330 + 1) {
      unint64_t v331 = v330 + 1;
    }
    if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v332 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v332 = v331;
    }
    if (v332) {
      v333 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v332);
    }
    else {
      v333 = 0;
    }
    v344 = (OZChannel **)&v333[8 * v330];
    v345 = &v333[8 * v332];
    *v344 = v613;
    v329 = (char *)(v344 + 1);
    v347 = v616;
    v346 = v617;
    if (v617 != v616)
    {
      do
      {
        v348 = (OZChannel *)*((void *)v346 - 1);
        v346 -= 8;
        *--v344 = v348;
      }
      while (v346 != v347);
      v346 = v616;
    }
    v616 = (char *)v344;
    v617 = v329;
    unint64_t v618 = (unint64_t)v345;
    if (v346) {
      operator delete(v346);
    }
  }
  else
  {
    *v109 = v613;
    v329 = (char *)(v109 + 1);
  }
  v617 = v329;
  if (v591)
  {
    if ((unint64_t)v329 >= v618)
    {
      uint64_t v351 = (v329 - v616) >> 3;
      if ((unint64_t)(v351 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v352 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v352 <= v351 + 1) {
        unint64_t v352 = v351 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v353 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v353 = v352;
      }
      v349 = (char *)this + 23160;
      if (v353) {
        v354 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v353);
      }
      else {
        v354 = 0;
      }
      v437 = &v354[8 * v351];
      v438 = &v354[8 * v353];
      *(void *)v437 = v601;
      v350 = v437 + 8;
      v440 = v616;
      v439 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v441 = *((void *)v439 - 1);
          v439 -= 8;
          *((void *)v437 - 1) = v441;
          v437 -= 8;
        }
        while (v439 != v440);
        v439 = v616;
      }
      v616 = v437;
      v617 = v350;
      unint64_t v618 = (unint64_t)v438;
      if (v439) {
        operator delete(v439);
      }
    }
    else
    {
      v349 = (char *)this + 23160;
      *(void *)v329 = v601;
      v350 = v329 + 8;
    }
    v617 = v350;
    if ((unint64_t)v350 < v618)
    {
      *(void *)v350 = v349;
      v304 = v350 + 8;
      goto LABEL_753;
    }
    uint64_t v442 = (v350 - v616) >> 3;
    if ((unint64_t)(v442 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v443 = (uint64_t)(v618 - (void)v616) >> 2;
    if (v443 <= v442 + 1) {
      unint64_t v443 = v442 + 1;
    }
    if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v444 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v444 = v443;
    }
    if (v444) {
      v445 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v444);
    }
    else {
      v445 = 0;
    }
    v302 = &v445[8 * v442];
    v303 = &v445[8 * v444];
    *(void *)v302 = v349;
    v304 = v302 + 8;
    v446 = v616;
    v305 = v617;
    if (v617 != v616)
    {
      do
      {
        uint64_t v447 = *((void *)v305 - 1);
        v305 -= 8;
        *((void *)v302 - 1) = v447;
        v302 -= 8;
      }
      while (v305 != v446);
      goto LABEL_750;
    }
LABEL_751:
    v616 = v302;
    v617 = v304;
    unint64_t v618 = (unint64_t)v303;
    if (v305) {
      operator delete(v305);
    }
    goto LABEL_753;
  }
LABEL_754:
  v448 = v617;
  if ((unint64_t)v617 >= v618)
  {
    uint64_t v451 = (v617 - v616) >> 3;
    v450 = (char *)this + 27976;
    if ((unint64_t)(v451 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v452 = (uint64_t)(v618 - (void)v616) >> 2;
    if (v452 <= v451 + 1) {
      unint64_t v452 = v451 + 1;
    }
    if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v453 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v453 = v452;
    }
    if (v453) {
      v454 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v453);
    }
    else {
      v454 = 0;
    }
    v455 = &v454[8 * v451];
    v456 = &v454[8 * v453];
    *(void *)v455 = v612;
    v449 = v455 + 8;
    v458 = v616;
    v457 = v617;
    if (v617 != v616)
    {
      do
      {
        uint64_t v459 = *((void *)v457 - 1);
        v457 -= 8;
        *((void *)v455 - 1) = v459;
        v455 -= 8;
      }
      while (v457 != v458);
      v457 = v616;
    }
    v616 = v455;
    v617 = v449;
    unint64_t v618 = (unint64_t)v456;
    if (v457) {
      operator delete(v457);
    }
  }
  else
  {
    *(void *)v617 = v612;
    v449 = v448 + 8;
    v450 = (char *)this + 27976;
  }
  v617 = v449;
  if ((unint64_t)v449 >= v618)
  {
    uint64_t v461 = (v449 - v616) >> 3;
    if ((unint64_t)(v461 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v462 = (uint64_t)(v618 - (void)v616) >> 2;
    if (v462 <= v461 + 1) {
      unint64_t v462 = v461 + 1;
    }
    if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v463 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v463 = v462;
    }
    if (v463) {
      v464 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v463);
    }
    else {
      v464 = 0;
    }
    v465 = &v464[8 * v461];
    v466 = &v464[8 * v463];
    *(void *)v465 = v611;
    v460 = v465 + 8;
    v468 = v616;
    v467 = v617;
    if (v617 != v616)
    {
      do
      {
        uint64_t v469 = *((void *)v467 - 1);
        v467 -= 8;
        *((void *)v465 - 1) = v469;
        v465 -= 8;
      }
      while (v467 != v468);
      v467 = v616;
    }
    v616 = v465;
    v617 = v460;
    unint64_t v618 = (unint64_t)v466;
    if (v467) {
      operator delete(v467);
    }
  }
  else
  {
    *(void *)v449 = v611;
    v460 = v449 + 8;
  }
  v617 = v460;
  if ((unint64_t)v460 >= v618)
  {
    uint64_t v471 = (v460 - v616) >> 3;
    if ((unint64_t)(v471 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v472 = (uint64_t)(v618 - (void)v616) >> 2;
    if (v472 <= v471 + 1) {
      unint64_t v472 = v471 + 1;
    }
    if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v473 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v473 = v472;
    }
    if (v473) {
      v474 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v473);
    }
    else {
      v474 = 0;
    }
    v475 = &v474[8 * v471];
    v476 = &v474[8 * v473];
    *(void *)v475 = v450;
    v470 = v475 + 8;
    v478 = v616;
    v477 = v617;
    if (v617 != v616)
    {
      do
      {
        uint64_t v479 = *((void *)v477 - 1);
        v477 -= 8;
        *((void *)v475 - 1) = v479;
        v475 -= 8;
      }
      while (v477 != v478);
      v477 = v616;
    }
    v616 = v475;
    v617 = v470;
    unint64_t v618 = (unint64_t)v476;
    if (v477) {
      operator delete(v477);
    }
  }
  else
  {
    *(void *)v460 = v450;
    v470 = v460 + 8;
  }
  v617 = v470;
  if ((unint64_t)v470 >= v618)
  {
    uint64_t v481 = (v470 - v616) >> 3;
    if ((unint64_t)(v481 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v482 = (uint64_t)(v618 - (void)v616) >> 2;
    if (v482 <= v481 + 1) {
      unint64_t v482 = v481 + 1;
    }
    if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v483 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v483 = v482;
    }
    if (v483) {
      v484 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v483);
    }
    else {
      v484 = 0;
    }
    v485 = &v484[8 * v481];
    v486 = &v484[8 * v483];
    *(void *)v485 = v610;
    v480 = v485 + 8;
    v488 = v616;
    v487 = v617;
    if (v617 != v616)
    {
      do
      {
        uint64_t v489 = *((void *)v487 - 1);
        v487 -= 8;
        *((void *)v485 - 1) = v489;
        v485 -= 8;
      }
      while (v487 != v488);
      v487 = v616;
    }
    v616 = v485;
    v617 = v480;
    unint64_t v618 = (unint64_t)v486;
    if (v487) {
      operator delete(v487);
    }
  }
  else
  {
    *(void *)v470 = v610;
    v480 = v470 + 8;
  }
  v617 = v480;
  if ((unint64_t)v480 >= v618)
  {
    uint64_t v491 = (v480 - v616) >> 3;
    if ((unint64_t)(v491 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v492 = (uint64_t)(v618 - (void)v616) >> 2;
    if (v492 <= v491 + 1) {
      unint64_t v492 = v491 + 1;
    }
    if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v493 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v493 = v492;
    }
    if (v493) {
      v494 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v493);
    }
    else {
      v494 = 0;
    }
    v495 = &v494[8 * v491];
    v496 = &v494[8 * v493];
    *(void *)v495 = v609;
    v490 = v495 + 8;
    v498 = v616;
    v497 = v617;
    if (v617 != v616)
    {
      do
      {
        uint64_t v499 = *((void *)v497 - 1);
        v497 -= 8;
        *((void *)v495 - 1) = v499;
        v495 -= 8;
      }
      while (v497 != v498);
      v497 = v616;
    }
    v616 = v495;
    v617 = v490;
    unint64_t v618 = (unint64_t)v496;
    if (v497) {
      operator delete(v497);
    }
  }
  else
  {
    *(void *)v480 = v609;
    v490 = v480 + 8;
  }
  v617 = v490;
  if ((*(unsigned int (**)(PSEmitter *))(*(void *)this + 216))(this) == 1
    && (OZChannelFolder::hasMoreThanOneKeypoint((OZChannelFolder *)((char *)this + 28128)) & 1) == 0)
  {
    v506 = v617;
  }
  else
  {
    v500 = v617;
    if ((unint64_t)v617 >= v618)
    {
      uint64_t v502 = (v617 - v616) >> 3;
      if ((unint64_t)(v502 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v503 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v503 <= v502 + 1) {
        unint64_t v503 = v502 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v504 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v504 = v503;
      }
      if (v504) {
        v505 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v504);
      }
      else {
        v505 = 0;
      }
      v507 = &v505[8 * v502];
      v508 = &v505[8 * v504];
      *(void *)v507 = v608;
      v501 = v507 + 8;
      v510 = v616;
      v509 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v511 = *((void *)v509 - 1);
          v509 -= 8;
          *((void *)v507 - 1) = v511;
          v507 -= 8;
        }
        while (v509 != v510);
        v509 = v616;
      }
      v616 = v507;
      v617 = v501;
      unint64_t v618 = (unint64_t)v508;
      if (v509) {
        operator delete(v509);
      }
    }
    else
    {
      *(void *)v617 = v608;
      v501 = v500 + 8;
    }
    v617 = v501;
    if ((unint64_t)v501 >= v618)
    {
      uint64_t v513 = (v501 - v616) >> 3;
      if ((unint64_t)(v513 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v514 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v514 <= v513 + 1) {
        unint64_t v514 = v513 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v515 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v515 = v514;
      }
      if (v515) {
        v516 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v515);
      }
      else {
        v516 = 0;
      }
      v517 = &v516[8 * v513];
      v518 = &v516[8 * v515];
      *(void *)v517 = v607;
      v512 = v517 + 8;
      v520 = v616;
      v519 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v521 = *((void *)v519 - 1);
          v519 -= 8;
          *((void *)v517 - 1) = v521;
          v517 -= 8;
        }
        while (v519 != v520);
        v519 = v616;
      }
      v616 = v517;
      v617 = v512;
      unint64_t v618 = (unint64_t)v518;
      if (v519) {
        operator delete(v519);
      }
    }
    else
    {
      *(void *)v501 = v607;
      v512 = v501 + 8;
    }
    v617 = v512;
    if ((unint64_t)v512 >= v618)
    {
      uint64_t v523 = (v512 - v616) >> 3;
      if ((unint64_t)(v523 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v524 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v524 <= v523 + 1) {
        unint64_t v524 = v523 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v525 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v525 = v524;
      }
      if (v525) {
        v526 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v525);
      }
      else {
        v526 = 0;
      }
      v527 = &v526[8 * v523];
      v528 = &v526[8 * v525];
      *(void *)v527 = v606;
      v522 = v527 + 8;
      v530 = v616;
      v529 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v531 = *((void *)v529 - 1);
          v529 -= 8;
          *((void *)v527 - 1) = v531;
          v527 -= 8;
        }
        while (v529 != v530);
        v529 = v616;
      }
      v616 = v527;
      v617 = v522;
      unint64_t v618 = (unint64_t)v528;
      if (v529) {
        operator delete(v529);
      }
    }
    else
    {
      *(void *)v512 = v606;
      v522 = v512 + 8;
    }
    v617 = v522;
    if ((unint64_t)v522 >= v618)
    {
      uint64_t v533 = (v522 - v616) >> 3;
      if ((unint64_t)(v533 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v534 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v534 <= v533 + 1) {
        unint64_t v534 = v533 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v535 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v535 = v534;
      }
      if (v535) {
        v536 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v535);
      }
      else {
        v536 = 0;
      }
      v537 = &v536[8 * v533];
      v538 = &v536[8 * v535];
      *(void *)v537 = v605;
      v532 = v537 + 8;
      v540 = v616;
      v539 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v541 = *((void *)v539 - 1);
          v539 -= 8;
          *((void *)v537 - 1) = v541;
          v537 -= 8;
        }
        while (v539 != v540);
        v539 = v616;
      }
      v616 = v537;
      v617 = v532;
      unint64_t v618 = (unint64_t)v538;
      if (v539) {
        operator delete(v539);
      }
    }
    else
    {
      *(void *)v522 = v605;
      v532 = v522 + 8;
    }
    v617 = v532;
    if ((unint64_t)v532 >= v618)
    {
      uint64_t v543 = (v532 - v616) >> 3;
      if ((unint64_t)(v543 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v544 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v544 <= v543 + 1) {
        unint64_t v544 = v543 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v545 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v545 = v544;
      }
      if (v545) {
        v546 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v545);
      }
      else {
        v546 = 0;
      }
      v547 = &v546[8 * v543];
      v548 = &v546[8 * v545];
      *(void *)v547 = v604;
      v542 = v547 + 8;
      v550 = v616;
      v549 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v551 = *((void *)v549 - 1);
          v549 -= 8;
          *((void *)v547 - 1) = v551;
          v547 -= 8;
        }
        while (v549 != v550);
        v549 = v616;
      }
      v616 = v547;
      v617 = v542;
      unint64_t v618 = (unint64_t)v548;
      if (v549) {
        operator delete(v549);
      }
    }
    else
    {
      *(void *)v532 = v604;
      v542 = v532 + 8;
    }
    v617 = v542;
    if ((unint64_t)v542 >= v618)
    {
      uint64_t v552 = (v542 - v616) >> 3;
      if ((unint64_t)(v552 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v553 = (uint64_t)(v618 - (void)v616) >> 2;
      if (v553 <= v552 + 1) {
        unint64_t v553 = v552 + 1;
      }
      if (v618 - (unint64_t)v616 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v554 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v554 = v553;
      }
      if (v554) {
        v555 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v618, v554);
      }
      else {
        v555 = 0;
      }
      v556 = &v555[8 * v552];
      v557 = &v555[8 * v554];
      *(void *)v556 = v603;
      v506 = v556 + 8;
      v559 = v616;
      v558 = v617;
      if (v617 != v616)
      {
        do
        {
          uint64_t v560 = *((void *)v558 - 1);
          v558 -= 8;
          *((void *)v556 - 1) = v560;
          v556 -= 8;
        }
        while (v558 != v559);
        v558 = v616;
      }
      v616 = v556;
      v617 = v506;
      unint64_t v618 = (unint64_t)v557;
      if (v558) {
        operator delete(v558);
      }
    }
    else
    {
      *(void *)v542 = v603;
      v506 = v542 + 8;
    }
    v617 = v506;
  }
  for (i = (OZChannelBase **)v616; i != (OZChannelBase **)v506; ++i)
  {
    v614 = *i;
    PSEmitter::updateChanHiddenFlag(this, v614, 0, a2);
    std::__tree<OZLocking *>::__erase_unique<OZLocking *>((uint64_t)&v619, (unint64_t *)&v614);
  }
  v562 = v619;
  if (v619 != (uint64_t *)v620)
  {
    do
    {
      PSEmitter::updateChanHiddenFlag(this, (OZChannelBase *)v562[4], 1, a2);
      v563 = (uint64_t *)v562[1];
      if (v563)
      {
        do
        {
          v564 = v563;
          v563 = (uint64_t *)*v563;
        }
        while (v563);
      }
      else
      {
        do
        {
          v564 = (uint64_t *)v562[2];
          BOOL v565 = *v564 == (void)v562;
          v562 = v564;
        }
        while (!v565);
      }
      v562 = v564;
    }
    while (v564 != (uint64_t *)v620);
  }
  PSEmitter::updatePropertiesChans(this, a2);
  if (v616)
  {
    v617 = v616;
    operator delete(v616);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v619, v620[0]);
}

void sub_1B7DBB5D0(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void **)(v1 - 136);
  if (v3)
  {
    *(void *)(v1 - 128) = v3;
    operator delete(v3);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1 - 112, *(void **)(v1 - 104));
  _Unwind_Resume(a1);
}

void std::vector<OZChannelBase *>::push_back[abi:ne180100](void **a1, void *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  int v7 = *(void **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = ((char *)v7 - (unsigned char *)*a1) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v5 - (void)*a1;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      __n128 v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v4, v12);
    }
    else {
      __n128 v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    uint64_t v15 = &v13[8 * v12];
    *(void *)uint64_t v14 = *a2;
    int v8 = v14 + 8;
    char v17 = (char *)*a1;
    int v16 = (char *)a1[1];
    if (v16 != *a1)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *((void *)v14 - 1) = v18;
        v14 -= 8;
      }
      while (v16 != v17);
      int v16 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v8;
    a1[2] = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *int v7 = *a2;
    int v8 = v7 + 1;
  }
  a1[1] = v8;
}

OZChannelBase *PSEmitter::updatePropertiesChans(PSEmitter *this, char a2)
{
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 32792), MEMORY[0x1E4F1FA48], 0.0);
  BOOL v5 = ValueAsInt != 0;
  PSEmitter::updateChanHiddenFlag(this, (OZChannelBase *)((char *)this + 14768), v5, a2);
  PSEmitter::updateChanHiddenFlag(this, (OZChannelBase *)((char *)this + 17720), v5, a2);
  PSEmitter::updateChanHiddenFlag(this, (OZChannelBase *)((char *)this + 12872), v5, a2);
  if (ValueAsInt)
  {
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 6880), 2048, a2);
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 7032), 2048, a2);
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 14768), 2048, a2);
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 8432), 2048, a2);
    return (OZChannelBase *)OZChannelBase::setRangeName((OZChannelBase *)((char *)this + 200), v6);
  }
  else
  {
    OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 6880), 2048, a2);
    OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 7032), 2048, a2);
    OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 14768), 2048, a2);
    return OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 8432), 2048, a2);
  }
}

void PSEmitter::getBirthRateFraction(PSEmitter *this, const CMTime *a2)
{
}

void PSEmitter::getInitialNumFraction(PSEmitter *this, const CMTime *a2)
{
}

void PSEmitter::tintColor(PSEmitter *this, const CMTime *a2, PCColor *a3)
{
  OZChannel::getValueAsDouble((OZChannel *)((char *)this + 30920), a2, 0.0);
  double v7 = v6;
  if (fabs(v6) >= 0.0000001)
  {
    PCColor::PCColor(&v11);
    OZChannelColor::getColor((PSEmitter *)((char *)this + 29760), a2, &v11);
    float v8 = v7;
    PCColor::mix(a3, &v11, v8);
    float Alpha = PCColor::getAlpha(a3);
    float v10 = (1.0 - v7) * Alpha + v7 * PCColor::getAlpha(&v11);
    PCColor::setAlpha(a3, v10);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v11.var1._obj);
  }
}

void sub_1B7DBBB84(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v1 + 48));
  _Unwind_Resume(a1);
}

double PSEmitter::getFrameRate(PSEmitter *this)
{
  return *(double *)((*(uint64_t (**)(void))(*((void *)this + 25) + 272))() + 368);
}

void PSEmitter::getPreviewTransformMatrix(OZChannel *a1, uint64_t a2, CMTime *a3)
{
  if (*(OZChannel **)&a3[2].timescale == (OZChannel *)&a1[1].var6)
  {
    *(_OWORD *)(a2 + 24) = 0u;
    *(_OWORD *)(a2 + 8) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 88) = 0u;
    *(_OWORD *)(a2 + 104) = 0u;
    double v11 = 1.0;
  }
  else
  {
    OZChannel::getValueAsDouble(a1 + 212, a3, 0.0);
    double v7 = v6;
    OZChannel::getValueAsDouble(a1 + 213, a3, 0.0);
    uint64_t v9 = v8;
    double v10 = *(double *)&a3[1].epoch;
    double v11 = (*((double (**)(OZChannel *))a1->var0 + 44))(a1) / v10;
    *(_OWORD *)(a2 + 24) = 0u;
    *(_OWORD *)(a2 + 8) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(void *)(a2 + 104) = 0;
    *(void *)(a2 + 112) = 0;
    *(double *)(a2 + 24) = v7 - v11 * 0.0;
    *(void *)(a2 + 56) = v9;
    *(void *)(a2 + 88) = 0;
    *(void *)(a2 + 96) = 0;
  }
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(double *)a2 = v11;
}

double PSEmitter::getInvPreviewTransformMatrix(OZChannel *a1, uint64_t a2, CMTime *a3)
{
  if (*(OZChannel **)&a3[2].timescale == (OZChannel *)&a1[1].var6)
  {
    *(void *)(a2 + 120) = 0x3FF0000000000000;
    *(void *)(a2 + 80) = 0x3FF0000000000000;
    *(void *)(a2 + 40) = 0x3FF0000000000000;
    *(void *)a2 = 0x3FF0000000000000;
    double result = 0.0;
    *(_OWORD *)(a2 + 8) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 88) = 0u;
    *(_OWORD *)(a2 + 104) = 0u;
  }
  else
  {
    OZChannel::getValueAsDouble(a1 + 212, a3, 0.0);
    double v7 = v6;
    OZChannel::getValueAsDouble(a1 + 213, a3, 0.0);
    uint64_t v9 = v8;
    double v10 = *(double *)&a3[1].epoch;
    double v11 = (*((double (**)(OZChannel *))a1->var0 + 44))(a1) / v10;
    *(_OWORD *)(a2 + 24) = 0u;
    *(_OWORD *)(a2 + 8) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(void *)(a2 + 112) = 0;
    *(void *)(a2 + 120) = 0x3FF0000000000000;
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 104) = 0;
    *(double *)a2 = v11;
    *(void *)(a2 + 40) = 0x3FF0000000000000;
    *(double *)(a2 + 24) = v7 - v11 * 0.0;
    *(void *)(a2 + 56) = v9;
    *(_OWORD *)(a2 + 80) = xmmword_1B7E733D0;
    PCMatrix44Tmpl<double>::invert((double *)a2, (double *)a2, 0.0);
  }
  return result;
}

void PSEmitter::initParticles(PSEmitter *this, uint64_t a2, PSParticleType *a3, uint64_t a4, void *a5, OZSimStateArray *a6)
{
  unsigned int v252 = a4;
  unsigned int v235 = a2;
  uint64_t v8 = (unsigned int *)((char *)this + 28736);
  CMTime v330 = *(CMTime *)((unsigned char *)a6 + 1);
  memset(&v329, 0, sizeof(v329));
  uint64_t v9 = (char *)this + 200;
  uint64_t v10 = (*(uint64_t (**)(char *, uint64_t, PSParticleType *, uint64_t, void *))(*((void *)this + 25) + 272))((char *)this + 200, a2, a3, a4, a5);
  __n128 FrameDuration = OZSceneSettings::getFrameDuration((OZSceneSettings *)(v10 + 336), (__n128 *)&v329);
  double v12 = *(double *)((*(uint64_t (**)(char *, __n128))(*(void *)v9 + 272))(v9, FrameDuration) + 368);
  uint64_t Seed = PSParticleType::getSeed(a3);
  (*(void (**)(CMTime *__return_ptr, char *))(*(void *)v9 + 1128))(v328, v9);
  int v234 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 168))(this);
  v236 = this;
  unsigned int v226 = *v8;
  double v14 = 0.0;
  OZChannel::getValueAsDouble((OZChannel *)((char *)this + 28712), &v330, 0.0);
  double v16 = v15;
  if ((*(unsigned int (**)(PSParticleType *))(*(void *)a3 + 1576))(a3))
  {
    CMTime time = v328[1];
    double Seconds = CMTimeGetSeconds(&time);
  }
  else
  {
    OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 1576), &v330, 0.0);
    double Seconds = v18;
    OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 1728), &v330, 0.0);
    double v14 = v19;
  }
  unsigned int v224 = v8[186];
  OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 1880), &v330, 0.0);
  double v21 = v20;
  OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 2032), &v330, 0.0);
  double v23 = v22;
  OZChannel::getValueAsDouble((OZChannel *)((char *)this + 29456), &v330, 0.0);
  uint64_t v25 = v24;
  unsigned int v227 = *((_DWORD *)a3 + 3758);
  float64x2_t v325 = 0uLL;
  double v326 = 0.0;
  OZChannelRotation3D::getValueAsEulerAngles((uint64_t)a3 + 2336, &v330, &v325, 0.0);
  float64x2_t v323 = 0uLL;
  double v324 = 0.0;
  OZChannelRotation3D::getValueAsEulerAngles((uint64_t)a3 + 3192, &v330, &v323, 0.0);
  float64x2_t v321 = 0uLL;
  double v322 = 0.0;
  OZChannelRotation3D::getValueAsEulerAngles((uint64_t)a3 + 4208, &v330, &v321, 0.0);
  if ((v234 & 1) == 0)
  {
    float64x2_t v325 = 0uLL;
    float64x2_t v323 = 0uLL;
    float64x2_t v321 = 0uLL;
  }
  unsigned int v223 = v8[224];
  OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 5064), &v330, 0.0);
  double v27 = v26;
  OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 5216), &v330, 0.0);
  double v253 = v28;
  OZChannel::getValueAsDouble((OZChannel *)((char *)this + 29608), &v330, 0.0);
  double v248 = v29;
  unsigned int v240 = v8[38];
  double v320 = 0.0;
  double v319 = 0.0;
  double v318 = 0.0;
  OZChannelScale3D::getValue((PSParticleType *)((char *)a3 + 8040), &v330, &v320, &v319, &v318, 0.0);
  double v317 = 0.0;
  double v316 = 0.0;
  double v315 = 0.0;
  OZChannelScale3D::getValue((PSParticleType *)((char *)a3 + 8632), &v330, &v317, &v316, &v315, 0.0);
  double v314 = 0.0;
  double v313 = 0.0;
  double v312 = 0.0;
  OZChannelScale3D::getValue((PSParticleType *)((char *)a3 + 9224), &v330, &v314, &v313, &v312, 0.0);
  double v311 = 0.0;
  double v310 = 0.0;
  double v309 = 0.0;
  OZChannelScale3D::getValue((PSEmitter *)((char *)this + 28864), &v330, &v311, &v310, &v309, 0.0);
  double v320 = v311 * v320;
  double v319 = v310 * v319;
  double v318 = v309 * v318;
  double v314 = v311 * v314;
  double v313 = v310 * v313;
  double v312 = v309 * v312;
  OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 13200), &v330, 0.0);
  double v233 = v30;
  OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 13352), &v330, 0.0);
  double v232 = v31;
  OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 13640), &v330, 0.0);
  double v231 = v32;
  OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 13792), &v330, 0.0);
  double v230 = v33;
  OZChannel::getValueAsDouble((OZChannel *)((char *)this + 27672), &v330, 0.0);
  double v228 = v34;
  OZChannel::getValueAsDouble((OZChannel *)((char *)this + 27824), &v330, 0.0);
  double v246 = v35;
  OZChannel::getValueAsDouble((OZChannel *)((char *)this + 27976), &v330, 0.0);
  double v225 = v36;
  double v244 = cos(v36 * 0.5);
  OZRenderState::OZRenderState(&v308);
  v308.var0 = ($3CC8671D27C23BF42ADDB32F2B5E48AE)v330;
  v308.var8 = 0;
  uint64_t v307 = 0x3FF0000000000000;
  uint64_t v304 = 0x3FF0000000000000;
  uint64_t v301 = 0x3FF0000000000000;
  uint64_t v298 = 0x3FF0000000000000;
  long long v299 = 0u;
  long long v300 = 0u;
  long long v302 = 0u;
  long long v303 = 0u;
  long long v305 = 0u;
  long long v306 = 0u;
  uint64_t v297 = 0x3FF0000000000000;
  uint64_t v294 = 0x3FF0000000000000;
  uint64_t v291 = 0x3FF0000000000000;
  uint64_t v288 = 0x3FF0000000000000;
  long long v289 = 0u;
  long long v290 = 0u;
  long long v292 = 0u;
  long long v293 = 0u;
  long long v295 = 0u;
  long long v296 = 0u;
  if (v235 == 1)
  {
    float64x2_t v286 = 0uLL;
    *(double *)&CMTimeEpoch v287 = 0.0;
    uint64_t v37 = (*(uint64_t (**)(char *))(*(void *)v9 + 272))(v9);
    OZSceneSettings::getFrameDuration((OZSceneSettings *)(v37 + 336), (__n128 *)&v286);
    PSEmitter::getPreviewTransformMatrix((OZChannel *)this, (uint64_t)&v298, (CMTime *)&v308);
    if ((*(unsigned int (**)(PSParticleType *))(*(void *)a3 + 1488))(a3))
    {
      CMTime time1 = v330;
      *(float64x2_t *)&time2.value = v286;
      time2.CMTimeEpoch epoch = v287;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v285);
      CMTime time2 = v328[0];
      CMTime time1 = v285;
      if (CMTimeCompare(&time1, &time2) >= 1)
      {
        CMTime time1 = v330;
        *(float64x2_t *)&time2.value = v286;
        time2.CMTimeEpoch epoch = v287;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v285);
        v308.var0 = ($3CC8671D27C23BF42ADDB32F2B5E48AE)v285;
      }
    }
    PSEmitter::getPreviewTransformMatrix((OZChannel *)this, (uint64_t)&v288, (CMTime *)&v308);
  }
  else
  {
    float64x2_t v286 = 0uLL;
    *(double *)&CMTimeEpoch v287 = 0.0;
    uint64_t v38 = (*(uint64_t (**)(char *))(*(void *)v9 + 272))(v9);
    __n128 v39 = OZSceneSettings::getFrameDuration((OZSceneSettings *)(v38 + 336), (__n128 *)&v286);
    (*(void (**)(char *, uint64_t *, OZRenderState *, __n128))(*(void *)v9 + 1256))(v9, &v298, &v308, v39);
    if ((*(unsigned int (**)(PSParticleType *))(*(void *)a3 + 1488))(a3))
    {
      CMTime time1 = v330;
      *(float64x2_t *)&time2.value = v286;
      time2.CMTimeEpoch epoch = v287;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v285);
      CMTime time2 = v328[0];
      CMTime time1 = v285;
      if (CMTimeCompare(&time1, &time2) >= 1)
      {
        CMTime time1 = v330;
        *(float64x2_t *)&time2.value = v286;
        time2.CMTimeEpoch epoch = v287;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v285);
        v308.var0 = ($3CC8671D27C23BF42ADDB32F2B5E48AE)v285;
      }
    }
    (*(void (**)(char *, uint64_t *, OZRenderState *))(*(void *)v9 + 1256))(v9, &v288, &v308);
  }
  float64x2_t v286 = 0uLL;
  *(double *)&CMTimeEpoch v287 = 0.0;
  memset(&v285, 0, sizeof(v285));
  PCMatrix44Tmpl<double>::transform<double>((double *)&v298, v286.f64, v286.f64);
  PCMatrix44Tmpl<double>::transform<double>((double *)&v288, (double *)&v285.value, (double *)&v285.value);
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)a3 + 10272), &v330, 0.0);
  OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 10424), &v330, 0.0);
  double v217 = v40;
  unint64_t v238 = v25;
  double v241 = v21;
  OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 10576), &v330, 0.0);
  double v216 = v41;
  double v42 = v16;
  double v43 = v12;
  int v218 = (*(uint64_t (**)(PSParticleType *))(*(void *)a3 + 1584))(a3);
  double v44 = v23;
  OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 10888), &v330, 0.0);
  double v46 = v45;
  OZChannel::getValueAsDouble((OZChannel *)((char *)a3 + 11040), &v330, 0.0);
  double v48 = v47;
  int v49 = OZChannel::getValueAsInt((OZChannel *)((char *)a3 + 10120), &v330, 0.0);
  if (v49) {
    double v50 = v46;
  }
  else {
    double v50 = 0.0;
  }
  double v239 = v50;
  if (v49) {
    double v51 = v48;
  }
  else {
    double v51 = 0.0;
  }
  double v222 = v51;
  CMTime v284 = *(CMTime *)((unsigned char *)a3 + 686);
  char v283 = 0;
  int v52 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19232), &v330, 0.0);
  if (v52 == 5) {
    PSEmitter::getSrcImage(v236, v235, &v330);
  }
  int v215 = v52;
  if (v252)
  {
    int v53 = 0;
    double v54 = v43 * v42 * Seconds;
    double v55 = v43 * v42 * v14;
    double v56 = v241 * *(double *)&v238;
    double v57 = v44 * *(double *)&v238;
    double v58 = v27 * v248;
    double v237 = v253 * v248;
    double v221 = 1.0 - v244;
    unsigned int v59 = -1108378657 * ((*((void *)a6 + 1) - *(void *)a6) >> 3) - v252;
    double v219 = v27 * v248;
    double v220 = v44 * *(double *)&v238;
    do
    {
      uint64_t v60 = *(void *)a6;
      uint64_t v61 = *(void *)a6 + 248 * v59;
      v62 = *(const void **)(v61 + 232);
      if (v62) {
      else
      }
        v63 = 0;
      unsigned int v64 = (*(uint64_t (**)(char *))(*(void *)v63 + 32))(v63);
      unsigned int v65 = v64;
      double v66 = v54;
      if (v55 > 0.0)
      {
        int v67 = -32;
        int v68 = -1640531527;
        unsigned int v69 = v64;
        unsigned int v70 = v226;
        do
        {
          v69 += (Seed + 16 * v70) ^ (v70 + v68) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                  + (v70 >> 5));
          v70 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v69) ^ (v68 + v69) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v69 >> 5));
          v68 -= 1640531527;
          _CF = __CFADD__(v67++, 1);
        }
        while (!_CF);
        double v66 = v54 + v55 * ((double)(int)(v70 ^ v69) / 2147483650.0 * 0.5);
      }
      if (v66 < 0.0) {
        double v66 = 0.0;
      }
      v72 = operator*(&v329, &time1, v66);
      *(CMTime *)(v63 + 32) = time1;
      v73 = PCColor::WHITE((PCColor *)v72);
      long long v74 = *(_OWORD *)v73;
      long long v75 = *((_OWORD *)v73 + 2);
      *((_OWORD *)v63 + 8) = *((_OWORD *)v73 + 1);
      *((_OWORD *)v63 + 9) = v75;
      *((_OWORD *)v63 + 7) = v74;
      PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)v63 + 20, (CGColorSpace **)v73 + 6);
      float64x2_t __x = (float64x2_t)0x3FF0000000000000uLL;
      double v282 = 0.0;
      *(void *)uint64_t v61 = 0;
      *(void *)(v61 + 8) = 0;
      *(void *)(v61 + 16) = 0;
      (*(void (**)(void))(*(void *)v236 + 648))();
      float64x2_t v279 = *(float64x2_t *)v61;
      double v280 = *(double *)(v61 + 16);
      float64x2_t v277 = *(float64x2_t *)v61;
      double v278 = *(double *)(v61 + 16);
      PCMatrix44Tmpl<double>::transform<double>((double *)&v298, v279.f64, v279.f64);
      PCMatrix44Tmpl<double>::transform<double>((double *)&v288, v277.f64, v277.f64);
      long long v275 = 0uLL;
      uint64_t v276 = 0;
      long long v76 = *(_OWORD *)(v63 + 8);
      v273.CMTimeEpoch epoch = *((void *)v63 + 3);
      *(_OWORD *)&v273.value = v76;
      CMTime v272 = v329;
      PC_CMTimeFloorToSampleDuration(&v273, &v272, (uint64_t)&v274);
      long long v77 = *(_OWORD *)(v63 + 8);
      time1.CMTimeEpoch epoch = *((void *)v63 + 3);
      *(_OWORD *)&time1.value = v77;
      CMTime time2 = v274;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v275);
      operator/(&v275, (uint64_t)&v329, (uint64_t)&v271);
      double v78 = CMTimeGetSeconds(&v271);
      double v79 = v78 * v280 + (1.0 - v78) * v278;
      double v254 = v78;
      double v249 = 1.0 - v78;
      *(float64x2_t *)uint64_t v61 = vaddq_f64(vmulq_n_f64(v279, v78), vmulq_n_f64(v277, 1.0 - v78));
      *(double *)(v61 + 16) = v79;
      *(_OWORD *)&v274.value = 0uLL;
      double v270 = 0.0;
      double v269 = 0.0;
      (*(void (**)(PSParticleType *, CMTime *, char *, uint64_t, CMTime *, double *))(*(void *)a3 + 1560))(a3, &v330, v63, Seed, &v274, &v269);
      *(_OWORD *)(v63 + 56) = *(_OWORD *)&v274.value;
      *((void *)v63 + 9) = 0x3FF0000000000000;
      double v268 = 0.0;
      double v267 = 0.0;
      OZChannel2DOverRange::getValueOverRange((PSParticleType *)((char *)a3 + 13944), &v330, *((Float64 *)v63 + 21), &v268, &v267);
      int v80 = PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1;
      int v81 = -32;
      int v82 = PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2;
      int v83 = -1640531527;
      unsigned int v84 = v65;
      unsigned int v85 = v240 + 10000;
      int v86 = PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3;
      do
      {
        v84 += (Seed + 16 * v85) ^ (v83 + v85) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                + (v85 >> 5));
        v85 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v84) ^ (v83 + v84) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v84 >> 5));
        v83 -= 1640531527;
        _CF = __CFADD__(v81++, 1);
      }
      while (!_CF);
      double v87 = (double)(int)(v85 ^ v84);
      int v88 = -32;
      int v89 = -1640531527;
      unsigned int v90 = v65;
      unsigned int v91 = v240 + 10001;
      do
      {
        v90 += (Seed + 16 * v91) ^ (v89 + v91) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                + (v91 >> 5));
        v91 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v90) ^ (v89 + v90) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v90 >> 5));
        v89 -= 1640531527;
        _CF = __CFADD__(v88++, 1);
      }
      while (!_CF);
      double v92 = (v233 + (v231 + v268) * (v87 / 2147483650.0 * 0.5)) * v269;
      double v93 = (v232 + (v230 + v267) * ((double)(int)(v91 ^ v90) / 2147483650.0 * 0.5)) * v270;
      if (v92 <= -0.0000001 || v92 >= 0.0000001 || v93 <= -0.0000001 || v93 >= 0.0000001)
      {
        double v94 = v92 * 0.0 + v93 * v282;
        float64x2_t v95 = vmulq_n_f64(__x, v93);
        int8x16_t v96 = (int8x16_t)vmulq_n_f64(__x, v92);
        float64x2_t v97 = (float64x2_t)vextq_s8(v96, v96, 8uLL);
        *(void *)&v98.f64[0] = *(_OWORD *)&vsubq_f64(v95, v97);
        v98.f64[1] = vaddq_f64(v95, v97).f64[1];
        *(float64x2_t *)uint64_t v61 = vaddq_f64(v98, *(float64x2_t *)v61);
        *(double *)(v61 + 16) = v94 + *(double *)(v61 + 16);
      }
      double v99 = *(double *)&v287;
      float64x2_t v242 = *(float64x2_t *)&v285.value;
      float64x2_t v245 = v286;
      double v100 = *(double *)&v285.epoch;
      memset(&time2, 0, sizeof(time2));
      if (v234)
      {
        double v101 = v56;
        unsigned int v102 = 538680;
        int v103 = -32;
        int v104 = -1640531527;
        unsigned int v105 = v65;
        do
        {
          v105 += (Seed + 16 * v102) ^ (v102 + v104) ^ (v80 + (v102 >> 5));
          v102 += (v82 + 16 * v105) ^ (v104 + v105) ^ (v86 + (v105 >> 5));
          v104 -= 1640531527;
          _CF = __CFADD__(v103++, 1);
        }
        while (!_CF);
        double v106 = v55;
        double v107 = v54;
        double v108 = (double)(v102 ^ v105);
        int v109 = -32;
        int v110 = -1640531527;
        unsigned int v111 = v65;
        unsigned int v112 = 230275;
        do
        {
          v111 += (Seed + 16 * v112) ^ (v110 + v112) ^ (v80 + (v112 >> 5));
          v112 += (v82 + 16 * v111) ^ (v110 + v111) ^ (v86 + (v111 >> 5));
          v110 -= 1640531527;
          _CF = __CFADD__(v109++, 1);
        }
        while (!_CF);
        double v113 = v221 * (v108 / 4294967300.0) + -1.0;
        double v114 = sqrt(1.0 - v113 * v113);
        __double2 v115 = __sincos_stret((double)(int)(v112 ^ v111) / 2147483650.0 * 6.28318531);
        *(double *)&time2.value = v114 * v115.__cosval;
        *(double *)&time2.timescale = v114 * v115.__sinval;
        *(double *)&time2.CMTimeEpoch epoch = -v113;
        uint64_t v266 = 0x3FF0000000000000;
        uint64_t v263 = 0x3FF0000000000000;
        uint64_t v260 = 0x3FF0000000000000;
        time1.value = 0x3FF0000000000000;
        *(_OWORD *)&time1.timescale = 0u;
        long long v259 = 0u;
        long long v261 = 0u;
        long long v262 = 0u;
        long long v264 = 0u;
        long long v265 = 0u;
        PCMatrix44Tmpl<double>::rightRotate((double *)&time1.value, 1, -v246);
        PCMatrix44Tmpl<double>::rightRotate((double *)&time1.value, 0, -v228);
        PCMatrix44Tmpl<double>::transform<double>((double *)&time1.value, (double *)&time2.value, (double *)&time2.value);
        double v54 = v107;
        double v55 = v106;
        double v56 = v101;
        double v58 = v219;
        double v57 = v220;
      }
      else
      {
        int v116 = -32;
        int v117 = -1640531527;
        unsigned int v118 = v65;
        unsigned int v119 = 230275;
        do
        {
          v118 += (Seed + 16 * v119) ^ (v117 + v119) ^ (v80 + (v119 >> 5));
          v119 += (v82 + 16 * v118) ^ (v117 + v118) ^ (v86 + (v118 >> 5));
          v117 -= 1640531527;
          _CF = __CFADD__(v116++, 1);
        }
        while (!_CF);
        long double v120 = atan2(__x.f64[1], __x.f64[0]);
        __double2 v121 = __sincos_stret(v228 + v120 + v225 * ((double)(int)(v119 ^ v118) / 2147483650.0 * 0.5));
        time2.value = *(void *)&v121.__cosval;
        *(double *)&time2.timescale = v121.__sinval;
      }
      double v122 = v56;
      if (v57 > 0.0)
      {
        int v123 = -32;
        int v124 = -1640531527;
        unsigned int v125 = v65;
        unsigned int v126 = v224;
        do
        {
          v125 += (Seed + 16 * v126) ^ (v126 + v124) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                      + (v126 >> 5));
          v126 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v125) ^ (v124 + v125) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v125 >> 5));
          v124 -= 1640531527;
          _CF = __CFADD__(v123++, 1);
        }
        while (!_CF);
        double v122 = v56 + v57 * ((double)(int)(v126 ^ v125) / 2147483650.0 * 0.5);
      }
      *(double *)&time2.value = v122 * *(double *)&time2.value;
      *(double *)&time2.timescale = v122 * *(double *)&time2.timescale;
      *(double *)&time2.CMTimeEpoch epoch = v122 * *(double *)&time2.epoch;
      CMTime time1 = time2;
      PCMatrix44Tmpl<double>::transform<double>((double *)&v298, (double *)&time2.value, (double *)&time2.value);
      PCMatrix44Tmpl<double>::transform<double>((double *)&v288, (double *)&time1.value, (double *)&time1.value);
      *(float64x2_t *)&time2.value = vaddq_f64(vmulq_n_f64(*(float64x2_t *)&time2.value, v254), vmulq_n_f64(*(float64x2_t *)&time1.value, v249));
      *(double *)&time2.CMTimeEpoch epoch = v254 * *(double *)&time2.epoch + v249 * *(double *)&time1.epoch;
      CMTimeEpoch epoch = time2.epoch;
      uint64_t v128 = v60 + 248 * v59;
      *(float64x2_t *)(v128 + 56) = vsubq_f64(*(float64x2_t *)&time2.value, vaddq_f64(vmulq_n_f64(v245, v254), vmulq_n_f64(v242, v249)));
      *(double *)(v128 + 72) = *(double *)&epoch - (v254 * v99 + v249 * v100);
      double v129 = v58;
      if (v237 > 0.0)
      {
        int v130 = -32;
        int v131 = -1640531527;
        unsigned int v132 = v223;
        do
        {
          v65 += (Seed + 16 * v132) ^ (v132 + v131) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                     + (v132 >> 5));
          v132 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v65) ^ (v131 + v65) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v65 >> 5));
          v131 -= 1640531527;
          _CF = __CFADD__(v130++, 1);
        }
        while (!_CF);
        double v129 = v58 + v237 * ((double)(int)(v132 ^ v65) / 2147483650.0 * 0.5);
      }
      uint64_t v133 = v60 + 248 * v59;
      *(void *)(v133 + 80) = 0;
      *(void *)(v133 + 88) = 0;
      *(double *)(v133 + 96) = v129;
      *(_OWORD *)(v133 + 104) = *(_OWORD *)(v133 + 80);
      *(void *)(v133 + 120) = *(void *)(v133 + 96);
      (*(void (**)(PSParticleType *, CMTime *, char *, uint64_t, char *))(*(void *)a3 + 1552))(a3, &v330, v63, Seed, v63 + 112);
      ++v59;
      ++v53;
    }
    while (v53 != v252);
    if (!v283) {
      PSEmitter::calcOrderIndexFromOrderFraction(v236, a6, v252);
    }
    int v134 = 0;
    unsigned int v135 = -1108378657 * ((*((void *)a6 + 1) - *(void *)a6) >> 3) - v252;
    __asm { FMOV            V0.2D, #0.5 }
    float64x2_t v243 = _Q0;
    do
    {
      uint64_t v140 = *(void *)a6;
      v141 = *(const void **)(*(void *)a6 + 248 * v135 + 232);
      if (v141) {
      else
      }
        uint64_t v142 = 0;
      unsigned int v143 = (*(uint64_t (**)(double *))(*(void *)v142 + 32))(v142);
      unsigned int v144 = v143;
      double v145 = v142[21];
      double v146 = (1.0 - v145) * v326 + v145 * (v326 + v324);
      float64x2_t v147 = vaddq_f64(vmulq_n_f64(v325, 1.0 - v145), vmulq_n_f64(vaddq_f64(v325, v323), v145));
      double v247 = v145;
      double v250 = 1.0 - v145;
      if (vaddvq_f64(vmulq_f64(v321, v321)) + v322 * v322 <= 0.0)
      {
        float64x2_t v255 = v147;
      }
      else
      {
        int v148 = -32;
        int v149 = -1640531527;
        unsigned int v150 = v143;
        unsigned int v151 = v227 + 2;
        do
        {
          v150 += (Seed + 16 * v151) ^ (v149 + v151) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                      + (v151 >> 5));
          v151 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v150) ^ (v149 + v150) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v150 >> 5));
          v149 -= 1640531527;
          _CF = __CFADD__(v148++, 1);
        }
        while (!_CF);
        v152.f64[0] = (double)(int)(v151 ^ v150) / 2147483650.0;
        int v153 = -32;
        int v154 = -1640531527;
        unsigned int v155 = v143;
        unsigned int v156 = v227 + 1;
        do
        {
          v155 += (Seed + 16 * v156) ^ (v154 + v156) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                      + (v156 >> 5));
          v156 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v155) ^ (v154 + v155) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v155 >> 5));
          v154 -= 1640531527;
          _CF = __CFADD__(v153++, 1);
        }
        while (!_CF);
        double v157 = (double)(int)(v156 ^ v155);
        int v158 = -32;
        int v159 = -1640531527;
        unsigned int v160 = v143;
        unsigned int v161 = v227;
        do
        {
          v160 += (Seed + 16 * v161) ^ (v161 + v159) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                      + (v161 >> 5));
          v161 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v160) ^ (v159 + v160) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v160 >> 5));
          v159 -= 1640531527;
          _CF = __CFADD__(v158++, 1);
        }
        while (!_CF);
        v152.f64[1] = v157 / 2147483650.0;
        float64x2_t v255 = vaddq_f64(v147, vmulq_f64(vmulq_f64(v321, v152), v243));
        double v146 = v146 + v322 * ((double)(int)(v161 ^ v160) / 2147483650.0) * 0.5;
      }
      double v162 = (*(double (**)(PSParticleType *, CMTime *, double *, uint64_t))(*(void *)a3 + 1568))(a3, &v330, v142, Seed);
      uint64_t v163 = (double *)(v140 + 248 * v135);
      __double2 v164 = __sincos_stret((v146 + v162) * 0.5);
      double v165 = v164.__sinval * 0.0;
      __double2 v166 = __sincos_stret(0.5 * v255.f64[0]);
      __double2 v167 = __sincos_stret(vmuld_lane_f64(0.5, v255, 1));
      double v168 = v166.__cosval * (v167.__sinval * 0.0);
      double v169 = v166.__sinval * 0.0 * v167.__sinval;
      double v170 = v166.__sinval * 0.0 * (v167.__sinval * 0.0);
      double v171 = v166.__sinval * v167.__cosval + v168 + v169 - v170;
      double v172 = v171 * (v164.__sinval * 0.0);
      double v173 = v166.__sinval * 0.0 * v167.__cosval;
      double v174 = v166.__sinval * (v167.__sinval * 0.0);
      double v175 = v173 + v166.__cosval * v167.__sinval + v174 - v170;
      double v176 = v166.__cosval * v167.__cosval - (v170 + v169 + v174);
      v184.f64[0] = v170 - v166.__sinval * v167.__sinval + v173 + v168;
      double v177 = v176 * v164.__sinval + v184.f64[0] * v164.__cosval + v171 * v165 - v175 * v165;
      double v178 = v175 * v164.__cosval + v176 * v165 + v184.f64[0] * v165 - v171 * v164.__sinval;
      double v179 = v171 * v164.__cosval + v176 * v165 + v175 * v164.__sinval - v184.f64[0] * v165;
      v184.f64[0] = v176 * v164.__cosval - (v184.f64[0] * v164.__sinval + v172 + v175 * (v164.__sinval * 0.0));
      double v180 = v163[3];
      double v181 = v163[4];
      double v182 = v163[5];
      double v183 = v163[6];
      v163[5] = v178 * v180 + v184.f64[0] * v182 + v179 * v183 - v177 * v181;
      v163[6] = v178 * v181 - v179 * v182 + v177 * v180 + v184.f64[0] * v183;
      v163[3] = v184.f64[0] * v180 - (v179 * v181 + v178 * v182 + v177 * v183);
      v163[4] = v179 * v180 + v184.f64[0] * v181 + v177 * v182 - v178 * v183;
      v184.f64[0] = v320 * (v250 + v247 * v317);
      if (v314 > 0.0)
      {
        int v185 = -32;
        int v186 = -1640531527;
        unsigned int v187 = v144;
        unsigned int v188 = v240;
        do
        {
          v187 += (Seed + 16 * v188) ^ (v188 + v186) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                      + (v188 >> 5));
          v188 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v187) ^ (v186 + v187) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v187 >> 5));
          v186 -= 1640531527;
          _CF = __CFADD__(v185++, 1);
        }
        while (!_CF);
        v184.f64[0] = v184.f64[0] + v314 * ((double)(int)(v188 ^ v187) / 2147483650.0 * 0.5);
        if (v184.f64[0] < 0.0) {
          v184.f64[0] = 0.0;
        }
      }
      double v189 = v319 * (v250 + v247 * v316);
      if (v313 > 0.0)
      {
        int v190 = -32;
        int v191 = -1640531527;
        unsigned int v192 = v144;
        unsigned int v193 = v240;
        do
        {
          v192 += (Seed + 16 * v193) ^ (v193 + v191) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                      + (v193 >> 5));
          v193 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v192) ^ (v191 + v192) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v192 >> 5));
          v191 -= 1640531527;
          _CF = __CFADD__(v190++, 1);
        }
        while (!_CF);
        double v189 = v189 + v313 * ((double)(int)(v193 ^ v192) / 2147483650.0 * 0.5);
        if (v189 < 0.0) {
          double v189 = 0.0;
        }
      }
      double v194 = v318 * (v250 + v247 * v315);
      if (v312 > 0.0)
      {
        int v195 = -32;
        int v196 = -1640531527;
        unsigned int v197 = v144;
        unsigned int v198 = v240;
        do
        {
          v197 += (Seed + 16 * v198) ^ (v198 + v196) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                      + (v198 >> 5));
          v198 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v197) ^ (v196 + v197) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v197 >> 5));
          v196 -= 1640531527;
          _CF = __CFADD__(v195++, 1);
        }
        while (!_CF);
        double v194 = v194 + v312 * ((double)(int)(v198 ^ v197) / 2147483650.0 * 0.5);
        if (v194 < 0.0) {
          double v194 = 0.0;
        }
      }
      double v199 = v194 * v142[9];
      v184.f64[1] = v189;
      *(float64x2_t *)(v142 + 7) = vmulq_f64(v184, *(float64x2_t *)(v142 + 7));
      v142[9] = v199;
      if (ValueAsInt)
      {
        memset(&time1, 0, sizeof(time1));
        unsigned int v200 = 945328649;
        int v201 = -32;
        int v202 = -1640531527;
        unsigned int v203 = v144;
        do
        {
          v203 += (Seed + 16 * v200) ^ (v202 + v200) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                      + (v200 >> 5));
          v200 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v203) ^ (v202 + v203) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v203 >> 5));
          v202 -= 1640531527;
          _CF = __CFADD__(v201++, 1);
        }
        while (!_CF);
        operator*(&v284, &time1, (double)(v200 ^ v203) / 4294967300.0);
        CMTime v257 = time1;
        CMTime v256 = v329;
        PC_CMTimeFloorToSampleDuration(&v257, &v256, (uint64_t)&time2);
        *((_OWORD *)v142 + 5) = *(_OWORD *)&time2.value;
        CMTimeEpoch v204 = time2.epoch;
      }
      else
      {
        if (v218)
        {
          OZChannelDoubleOverRange::getValueOverRangeAsDouble((OZChannel *)((char *)a3 + 10728), &v330, v142[21]);
          operator*(&v329, &time1, v205);
        }
        else
        {
          operator*(&v329, &time1, v217 + v216 * v142[22]);
        }
        *((_OWORD *)v142 + 5) = *(_OWORD *)&time1.value;
        CMTimeEpoch v204 = time1.epoch;
      }
      *((void *)v142 + 12) = v204;
      double v206 = v239;
      if (v239 > 0.0)
      {
        unsigned int v207 = -2096987786;
        int v208 = -32;
        int v209 = -1640531527;
        do
        {
          v144 += (Seed + 16 * v207) ^ (v209 + v207) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                      + (v207 >> 5));
          v207 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v144) ^ (v209 + v144) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v144 >> 5));
          v209 -= 1640531527;
          _CF = __CFADD__(v208++, 1);
        }
        while (!_CF);
        double v206 = v239 + v222 * ((double)(v207 ^ v144) / 4294967300.0);
        if (v206 < 1.0) {
          double v206 = 1.0;
        }
      }
      v142[13] = v206;
      ++v135;
      ++v134;
    }
    while (v134 != v252);
  }
  if (OZChannel::getValueAsInt((OZChannel *)((char *)v236 + 31632), MEMORY[0x1E4F1FA48], 0.0))
  {
    unint64_t v210 = (long long *)*((void *)a6 + 1);
    unint64_t v211 = (OZSimStateElement *)(*(void *)a6
                               + 248 * (0xEF7BDEF7BDEF7BDFLL * (((uint64_t)v210 - *(void *)a6) >> 3) - v252));
    unint64_t v212 = 126 - 2 * __clz(0xEF7BDEF7BDEF7BDFLL * (((char *)v210 - (char *)v211) >> 3));
    time1.value = (CMTimeValue)lessThanOrderingSimElem;
    if (v210 == (long long *)v211) {
      uint64_t v213 = 0;
    }
    else {
      uint64_t v213 = v212;
    }
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*,false>(v211, v210, (uint64_t (**)(long long *, const OZSimStateElement *))&time1, v213, 1);
  }
  if (v215 == 5)
  {
    v214 = (std::__shared_weak_count *)*((void *)v236 + 4190);
    *((void *)v236 + 4189) = 0;
    *((void *)v236 + 4190) = 0;
    if (v214) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v214);
    }
    *((void *)v236 + 4191) = 0x3FF0000000000000;
    *((_OWORD *)v236 + 2096) = 0u;
  }
}

void PSEmitter::getSrcImage(PSEmitter *this, int a2, const CMTime *a3)
{
  double v6 = (char *)this + 33512;
  double v7 = (std::__shared_weak_count *)*((void *)this + 4190);
  *(_OWORD *)double v6 = 0u;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  *((void *)v6 + 3) = 0;
  *((void *)v6 + 4) = 0;
  *((void *)v6 + 2) = 0x3FF0000000000000;
  ImageNode = OZChanElementOrFootageRef::getImageNode((OZChannelBase *)((char *)this + 27512));
  if (ImageNode)
  {
    uint64_t v9 = ImageNode;
    OZRenderParams::OZRenderParams((OZRenderParams *)&v33);
    long long v33 = *(_OWORD *)&a3->value;
    CMTimeEpoch epoch = a3->epoch;
    long long v37 = 0uLL;
    CMTimeEpoch v34 = epoch;
    double v31 = 1.0;
    double v32 = 1.0;
    uint64_t v30 = 0x3FF0000000000000;
    if (v11)
    {
      double v12 = v11;
      *((double *)v6 + 2) = (*(double (**)(void *))(*(void *)v11 + 1328))(v11);
      if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 31936), MEMORY[0x1E4F1FA48], 0.0)) {
        (*(void (**)(void *, double *, double *, uint64_t *, long long *, void))(*(void *)v12 + 1312))(v12, &v32, &v31, &v30, &v33, 0);
      }
    }
    v28[0] = 0;
    v28[1] = 0;
    __asm { FMOV            V0.2D, #-1.0 }
    long long v29 = _Q0;
    (*(void (**)(const void *, void *, long long *))(*(void *)v9 + 16))(v9, v28, &v33);
    double v18 = v31 * *((double *)&v29 + 1);
    *((double *)v6 + 3) = v32 * *(double *)&v29 * *((double *)v6 + 2);
    *((double *)v6 + 4) = v18;
    if (a2 != 2 && (PSEmitter::needSourceBitmap(this, a3) & 1) != 0)
    {
      uint64_t v20 = *((void *)this + 25);
      double v19 = (char *)this + 200;
      (*(void (**)(FxColorDescription *__return_ptr, char *))(v20 + 288))(&v27, v19);
      OZRenderParams::setWorkingColorDescription((CGColorSpace **)&v33, &v27);
      PCCFRef<CGColorSpace *>::~PCCFRef(&v27._pcColorDesc._colorSpaceRef._obj);
      float v21 = (*(float (**)(char *))(*(void *)v19 + 296))(v19);
      OZRenderParams::setBlendingGamma((uint64_t)&v33, v21);
      double v22 = (PGContext *)PGGetPerThreadContext();
      OZRenderParams::setImageContext((OZRenderParams *)&v33, v22);
      uint64_t v23 = (*(uint64_t (**)(char *))(*(void *)v19 + 272))(v19);
      if (v23)
      {
        uint64_t v24 = *(void *)(v23 + 1504);
        if (v24)
        {
          uint64_t FactoryForSerialization = OZFactoryBase::getFactoryForSerialization(v24);
          OZRenderParams::setImageType((uint64_t)&v33, 1);
          OZRenderParams::setWidth((OZRenderParams *)&v33, (int)*(double *)&v29);
          OZRenderParams::setHeight((OZRenderParams *)&v33, (int)*((double *)&v29 + 1));
          int v36 = 3;
          long long v37 = 0u;
          long long v38 = 0u;
          LiHelium::getDefaultGPU(v25, &v26);
          *(_OWORD *)&v27._pcColorDesc._colorSpaceRef._obj = v26;
          long long v26 = 0uLL;
          OZRenderParams::setRenderDevice((uint64_t)&v33, (uint64_t *)&v27);
          if (*(void *)&v27._pcColorDesc._dynamicRange) {
            std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v27._pcColorDesc._dynamicRange);
          }
          if (*((void *)&v26 + 1)) {
            std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v26 + 1));
          }
          operator new();
        }
        operator new();
      }
    }
    OZRenderParams::~OZRenderParams((OZRenderParams *)&v33);
  }
}

void sub_1B7DBE118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  MEMORY[0x1BA9BFBA0](v15, 0xC400A2AC0F1);
  OZRenderParams::~OZRenderParams((OZRenderParams *)va);
  _Unwind_Resume(a1);
}

double PCRandom::getRandTEAf(PCRandom *this, unsigned int a2, int a3)
{
  int v3 = -32;
  int v4 = -1640531527;
  do
  {
    LODWORD(this) = ((a3 + 16 * a2) ^ (v4 + a2) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                 + (a2 >> 5)))
                  + this;
    a2 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * this) ^ (v4 + this) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (this >> 5));
    v4 -= 1640531527;
  }
  while (!__CFADD__(v3++, 1));
  return (double)(a2 ^ this) / 4294967300.0;
}

void PSEmitter::calcOrderIndexFromOrderFraction(PSEmitter *this, OZSimStateArray *a2, unsigned int a3)
{
  BOOL v5 = this;
  v39[0] = 0;
  v39[1] = 0;
  long long v38 = (uint64_t *)v39;
  int v6 = -1108378657 * ((*((void *)a2 + 1) - *(void *)a2) >> 3) - a3;
  if (a3)
  {
    uint64_t v7 = a3;
    unsigned int v8 = -1108378657 * ((*((void *)a2 + 1) - *(void *)a2) >> 3) - a3;
    do
    {
      uint64_t v9 = *(double **)(*(void *)a2 + 248 * v8 + 232);
      if (v9) {
      std::__tree<double,LessThanDouble,std::allocator<double>>::__emplace_unique_key_args<double,double const&>(&v38, v9 + 21, (uint64_t *)v9 + 21);
      }
      ++v8;
      --v7;
    }
    while (v7);
    uint64_t v10 = v38;
    __p = 0;
    int v36 = 0;
    long long v37 = 0;
    if (v38 == (uint64_t *)v39)
    {
      uint64_t v24 = 0;
      double v11 = 0;
    }
    else
    {
      double v11 = 0;
      do
      {
        if (v11 >= v37)
        {
          double v12 = __p;
          uint64_t v13 = (v11 - __p) >> 3;
          unint64_t v14 = v13 + 1;
          if ((unint64_t)(v13 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v15 = v37 - __p;
          if ((v37 - __p) >> 2 > v14) {
            unint64_t v14 = v15 >> 2;
          }
          if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v16 = v14;
          }
          if (v16)
          {
            char v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v37, v16);
            double v12 = __p;
            double v11 = v36;
          }
          else
          {
            char v17 = 0;
          }
          double v18 = &v17[8 * v13];
          *(void *)double v18 = v10[4];
          double v19 = v18 + 8;
          while (v11 != v12)
          {
            uint64_t v20 = *((void *)v11 - 1);
            v11 -= 8;
            *((void *)v18 - 1) = v20;
            v18 -= 8;
          }
          __p = v18;
          long long v37 = &v17[8 * v16];
          if (v12) {
            operator delete(v12);
          }
          double v11 = v19;
        }
        else
        {
          *(void *)double v11 = v10[4];
          v11 += 8;
        }
        int v36 = v11;
        float v21 = (uint64_t *)v10[1];
        if (v21)
        {
          do
          {
            double v22 = v21;
            float v21 = (uint64_t *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            double v22 = (uint64_t *)v10[2];
            BOOL v23 = *v22 == (void)v10;
            uint64_t v10 = v22;
          }
          while (!v23);
        }
        uint64_t v10 = v22;
      }
      while (v22 != (uint64_t *)v39);
      BOOL v5 = this;
      uint64_t v24 = __p;
    }
  }
  else
  {
    uint64_t v24 = 0;
    double v11 = 0;
    __p = 0;
    int v36 = 0;
    long long v37 = 0;
  }
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)v5 + 23008), MEMORY[0x1E4F1FA48], 0.0);
  unsigned int v26 = OZChannel::getValueAsInt((OZChannel *)((char *)v5 + 31784), MEMORY[0x1E4F1FA48], 0.0);
  if (!a3)
  {
    double v31 = __p;
    if (!__p) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }
  unsigned int v27 = v26;
  uint64_t v28 = 0;
  do
  {
    long long v29 = *(const void **)(*(void *)a2 + 248 * (v6 + v28) + 232);
    if (v29) {
    else
    }
      uint64_t v30 = 0;
    double v31 = __p;
    if (__p != v36)
    {
      uint64_t v32 = 0;
      long long v33 = (double *)__p;
      while (vabdd_f64(*v33, v30[21]) >= 0.0000001)
      {
        ++v33;
        uint64_t v32 = (v32 + 1);
        if (v33 == (double *)v36) {
          goto LABEL_47;
        }
      }
      if (ValueAsInt)
      {
        LODWORD(v32) = PSEmitter::shuffleOrder(this, v32, (unint64_t)(v11 - v24) >> 3, v27);
        double v31 = __p;
      }
      v30[22] = (double)v32;
      v30[21] = *(double *)&v31[8 * v32];
    }
LABEL_47:
    ++v28;
  }
  while (v28 != a3);
  if (v31) {
LABEL_49:
  }
    operator delete(v31);
LABEL_50:
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v38, v39[0]);
}

void sub_1B7DBE5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, void *a15)
{
  if (__p) {
    operator delete(__p);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&a14, a15);
  _Unwind_Resume(a1);
}

BOOL lessThanOrderingSimElem(const OZSimStateElement *a1, const OZSimStateElement *a2)
{
  int v3 = (const void *)*((void *)a1 + 29);
  if (v3) {
  else
  }
    int v4 = 0;
  BOOL v5 = (const void *)*((void *)a2 + 29);
  if (v5) {
  else
  }
    int v6 = 0;
  double v7 = v4[22];
  double v8 = v6[22];
  if (vabdd_f64(v7, v8) >= 0.0000001) {
    return v7 < v8;
  }
  unsigned int v9 = (*(uint64_t (**)(double *))(*(void *)v4 + 32))(v4);
  return v9 < (*(unsigned int (**)(double *))(*(void *)v6 + 32))(v6);
}

void PSEmitter::initPropertiesFromShape(uint64_t a1, int a2, CMTime *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  *a8 = 1;
  double v280 = 0.0;
  double v281 = 0.0;
  double v282 = 1.0;
  unsigned int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 19232), a3, 0.0);
  int v12 = OZChannel::getValueAsInt((OZChannel *)(a1 + 19896), a3, 0.0);
  if (ValueAsInt == 4)
  {
    BOOL EmitAtPoints = PSEmitter::getEmitAtPoints((PSEmitter *)a1);
    BOOL v14 = OZChannel::getValueAsInt((OZChannel *)(a1 + 31632), a3, 0.0) == 0;
    unsigned int v15 = OZChannel::getValueAsInt((OZChannel *)(a1 + 20152), a3, 0.0);
    BOOL v262 = 0;
    if (!EmitAtPoints)
    {
      int v16 = 1;
      goto LABEL_38;
    }
    goto LABEL_34;
  }
  int v17 = v12;
  BOOL v19 = ValueAsInt == 10 && v12 == 0;
  int v16 = ((ValueAsInt & 0xFFFFFFFB) == 2 || ValueAsInt == 5) && v12 == 0 || v19;
  BOOL v256 = PSEmitter::getEmitAtPoints((PSEmitter *)a1);
  int v22 = OZChannel::getValueAsInt((OZChannel *)(a1 + 31632), a3, 0.0);
  BOOL v14 = v22 == 0;
  unsigned int v23 = ValueAsInt - 9;
  BOOL v262 = ValueAsInt == 9;
  if (ValueAsInt <= 9 && ((1 << ValueAsInt) & 0x213) != 0)
  {
    double v24 = 0.0;
    unsigned int v15 = OZChannel::getValueAsInt((OZChannel *)(a1 + 20152), a3, 0.0);
    if (!ValueAsInt)
    {
LABEL_47:
      PSEmitter::genOrderLinear((PSEmitter *)a1, v24, v16, v15, a3, (double *)(a5 + 168), (double *)(a5 + 176));
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 23160), a3, 0.0);
      double v41 = v24 + v40.n128_f64[0];
      uint64_t v42 = a6;
      if (v16)
      {
        __y.f64[0] = 0.0;
        modf(v41, (long double *)__y.f64);
        double v41 = v41 - __y.f64[0];
        if (v41 < 0.0) {
          double v41 = v41 + 1.0;
        }
      }
      switch(ValueAsInt)
      {
        case 1u:
          PSEmitter::genPosLine(a1, a3, (double *)a6, a7, v41);
          break;
        case 2u:
          PSEmitter::genPosCircle(a1, a3, a6, a7, v41);
          break;
        case 4u:
          PSEmitter::genPosGeometry(a1, a3, (double *)a6, (void *)a7, v41);
          break;
        case 5u:
          if (a2 == 2)
          {
            int v43 = 0;
            BOOL v44 = 0;
          }
          else
          {
            BOOL v44 = OZChannel::getValueAsInt((OZChannel *)(a4 + 5368), a3, 0.0) == 4;
            int v43 = 0;
            if (OZChannel::getValueAsInt((OZChannel *)(a1 + 27048), a3, 0.0))
            {
              OZChannel::getValueAsDouble((OZChannel *)(a1 + 27200), a3, 0.0);
              if (v40.n128_f64[0] > 0.0) {
                int v43 = 1;
              }
            }
          }
          v40.n128_f64[0] = v41;
          PSEmitter::initPropertiesFromImageOutline(a1, a3, v43, v44, a5, (double *)a6, a7, v40);
          break;
        case 6u:
          __y.f64[0] = 0.0;
          double cosval = 0.0;
          double v279 = 0.0;
          OZChannelScale3D::getValue((OZChannelScale3D *)(a1 + 25392), a3, __y.f64, &cosval, &v279, 0.0);
          PSEmitter::genPosRect(v41, __y.f64[0], cosval, v45, v46, (double *)a6, a7);
          break;
        case 9u:
          PSEmitter::genPosWave(a1, a3, (double *)a6, (double *)a7, &v280, v41);
          break;
        default:
          goto LABEL_65;
      }
      goto LABEL_65;
    }
LABEL_32:
    if (!v256)
    {
LABEL_38:
      unsigned int v29 = 923990407;
      unsigned int v30 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
      int v31 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
      int v32 = -32;
      int v33 = -1640531527;
      do
      {
        v30 += (v31 + 16 * v29) ^ (v33 + v29) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                               + (v29 >> 5));
        v29 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v30) ^ (v33 + v30) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v30 >> 5));
        v33 -= 1640531527;
        BOOL v34 = __CFADD__(v32++, 1);
      }
      while (!v34);
      double v27 = (double)(v29 ^ v30);
      double v28 = 4294967300.0;
LABEL_46:
      double v24 = v27 / v28;
      goto LABEL_47;
    }
    if (!v16)
    {
      unsigned int v26 = v15 - 1;
      if (v15 != 1) {
        goto LABEL_35;
      }
LABEL_59:
      double v24 = 0.5;
      goto LABEL_47;
    }
LABEL_34:
    int v16 = 1;
    unsigned int v26 = v15;
    if (v15)
    {
LABEL_35:
      if (v14 || (*(unsigned int (**)(uint64_t))(*(void *)a5 + 32))(a5) >= v15)
      {
        unsigned int v35 = 923990407;
        unsigned int v36 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
        int v37 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
        int v38 = -32;
        int v39 = -1640531527;
        do
        {
          v36 += (v37 + 16 * v35) ^ (v39 + v35) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                 + (v35 >> 5));
          v35 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v36) ^ (v39 + v36) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v36 >> 5));
          v39 -= 1640531527;
          BOOL v34 = __CFADD__(v38++, 1);
        }
        while (!v34);
        double v27 = floor((double)(v35 ^ v36) / 4294967300.0 * (double)v15 + 0.0000001);
        double v28 = (float)v26;
      }
      else
      {
        double v27 = (double)(*(unsigned int (**)(uint64_t))(*(void *)a5 + 32))(a5);
        double v28 = (double)v26;
      }
      goto LABEL_46;
    }
    goto LABEL_59;
  }
  if (ValueAsInt == 6 && !v17 || (ValueAsInt != 5 ? (BOOL v25 = ValueAsInt == 2) : (BOOL v25 = 1), v25 && !v17))
  {
    unsigned int v15 = OZChannel::getValueAsInt((OZChannel *)(a1 + 20152), a3, 0.0);
    goto LABEL_32;
  }
  if ((ValueAsInt & 0xFFFFFFFE) == 0xA && (v17 - 1) <= 1)
  {
    int v253 = v22;
    double v79 = (PCRandom *)(*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
    int v80 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
    double RandTEAf = PCRandom::getRandTEAf(v79, 0x3712F987u, v80);
    int v82 = (PCRandom *)(*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
    int v83 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
    double v84 = PCRandom::getRandTEAf(v82, 0x83820093, v83);
    unsigned int v85 = (PCRandom *)(*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
    int v86 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
    double v87 = PCRandom::getRandTEAf(v85, 0x39002838u, v86);
    BOOL v88 = v17 != 2 && v256;
    if (v17 != 1 && !v88)
    {
      double v89 = v87;
      double v90 = 0.0;
      int v91 = 1;
      int v92 = 1;
      int v93 = 1;
      goto LABEL_244;
    }
    int v93 = OZChannel::getValueAsInt((OZChannel *)(a1 + 20304), a3, 0.0);
    int v117 = OZChannel::getValueAsInt((OZChannel *)(a1 + 20456), a3, 0.0);
    int v91 = OZChannel::getValueAsInt((OZChannel *)(a1 + 20608), a3, 0.0);
    unsigned int v249 = v117 * v93;
    signed int v251 = v117 * v93 * v91;
    int v258 = v93 - 1;
    unsigned int v261 = v117;
    double v84 = 0.5;
    double RandTEAf = 0.5;
    if (v93 >= 2)
    {
      if (v253 && (*(int (**)(uint64_t))(*(void *)a5 + 32))(a5) < v251)
      {
        double RandTEAf = (double)((*(unsigned int (**)(uint64_t))(*(void *)a5 + 32))(a5) % v93) / (double)v258;
        if (v117 < 2)
        {
          int v118 = v253;
LABEL_227:
          int v195 = v91 - 1;
          double v89 = 0.5;
          if (v91 >= 2)
          {
            if (v118 && (*(int (**)(uint64_t))(*(void *)a5 + 32))(a5) < v251)
            {
              double v196 = (double)((*(unsigned int (**)(uint64_t))(*(void *)a5 + 32))(a5) / v249);
              double v197 = (double)v195;
            }
            else
            {
              unsigned int v198 = (PCRandom *)(*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
              int v199 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
              double v200 = PCRandom::getRandTEAf(v198, 0x39002838u, v199);
              if (vabdd_f64(1.0, v200) < 0.0000001) {
                double v200 = 0.0;
              }
              double v196 = floor(v200 * (double)v91 + 0.0000001);
              double v197 = (float)v195;
            }
            double v89 = v196 / v197;
          }
          double v90 = 0.0;
          if (OZChannel::getValueAsInt((OZChannel *)(a1 + 19896), a3, 0.0) == 1 && v93 >= 2)
          {
            OZChannel::getValueAsDouble((OZChannel *)(a1 + 21064), a3, 0.0);
            long double v202 = v84 * (double)v195 * v201;
            __y.f64[0] = 0.0;
            modf(v202, (long double *)__y.f64);
            double v203 = v202 - __y.f64[0];
            BOOL isOrderByRowColStack = PSEmitter::isOrderByRowColStack((PSEmitter *)a1);
            double v205 = v203 / (double)v258;
            if (isOrderByRowColStack) {
              double v90 = v203 / (double)v258;
            }
            else {
              double v90 = 0.0;
            }
            if (isOrderByRowColStack) {
              double v205 = -0.0;
            }
            double RandTEAf = RandTEAf + v205;
          }
          int v92 = v261;
LABEL_244:
          if (ValueAsInt == 11)
          {
            PSEmitter::genOrderFilledBox((PSEmitter *)a1, RandTEAf, v84, v89, v93, v92, v91, a3, (double *)(a5 + 168), (double *)(a5 + 176));
            if (*(double *)(a5 + 176) < 0.0) {
              *a8 = 0;
            }
            uint64_t v42 = a6;
            PSEmitter::genPosFilledBox(a1, a3, (float64x2_t *)a6, 0, 0, v90 + RandTEAf, v84, v89);
          }
          else if (ValueAsInt == 10)
          {
            uint64_t v42 = a6;
            float64x2_t __y = *(float64x2_t *)a6;
            double v268 = *(double *)(a6 + 16);
            LOBYTE(v180) = PSEmitter::genPosFilledSphere(a1, a3, &__y, &cosval, RandTEAf, v84, v89);
            if (!v88 && ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 584))(a1) & 1) == 0)
            {
              if (v180)
              {
                LOBYTE(v180) = 1;
              }
              else
              {
                unsigned int v206 = 1;
                do
                {
                  unsigned int v207 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
                  unsigned int v208 = v206 + 923990407;
                  int v209 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
                  int v210 = -32;
                  int v211 = -1640531527;
                  do
                  {
                    v207 += (v209 + 16 * v208) ^ (v211 + v208) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                                + (v208 >> 5));
                    v208 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v207) ^ (v211 + v207) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v207 >> 5));
                    v211 -= 1640531527;
                    BOOL v34 = __CFADD__(v210++, 1);
                  }
                  while (!v34);
                  double v212 = (double)(v208 ^ v207);
                  unsigned int v213 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
                  unsigned int v214 = v206 - 2088632173;
                  int v215 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
                  int v216 = -32;
                  int v217 = -1640531527;
                  do
                  {
                    v213 += (v215 + 16 * v214) ^ (v217 + v214) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                                + (v214 >> 5));
                    v214 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v213) ^ (v217 + v213) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v213 >> 5));
                    v217 -= 1640531527;
                    BOOL v34 = __CFADD__(v216++, 1);
                  }
                  while (!v34);
                  double v218 = (double)(v214 ^ v213);
                  unsigned int v219 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
                  unsigned int v220 = v206 + 956311608;
                  int v221 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
                  int v222 = -32;
                  int v223 = -1640531527;
                  do
                  {
                    v219 += (v221 + 16 * v220) ^ (v223 + v220) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                                + (v220 >> 5));
                    v220 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v219) ^ (v223 + v219) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v219 >> 5));
                    v223 -= 1640531527;
                    BOOL v34 = __CFADD__(v222++, 1);
                  }
                  while (!v34);
                  double RandTEAf = v212 / 4294967300.0;
                  double v84 = v218 / 4294967300.0;
                  float64x2_t __y = *(float64x2_t *)a6;
                  double v268 = *(double *)(a6 + 16);
                  double v89 = (double)(v220 ^ v219) / 4294967300.0;
                  BOOL v224 = PSEmitter::genPosFilledSphere(a1, a3, &__y, &cosval, RandTEAf, v84, v89);
                  if (v224) {
                    break;
                  }
                  BOOL v34 = v206++ >= 0x13;
                }
                while (!v34);
                if (v224)
                {
                  LOBYTE(v180) = 1;
                }
                else
                {
                  fwrite("kMaxCirlceAttempts reached\n", 0x1BuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
                  LOBYTE(v180) = 0;
                }
                uint64_t v42 = a6;
              }
            }
            *(float64x2_t *)uint64_t v42 = __y;
            *(double *)(v42 + 16) = v268;
            unsigned int v227 = (double *)(a5 + 168);
            double v228 = (double *)(a5 + 176);
            unint64_t v229 = (PSEmitter *)a1;
            double v230 = RandTEAf;
            double v231 = v84;
            double v232 = v89;
LABEL_278:
            PSEmitter::genOrderFilledCircle(v229, v230, v231, v232, a3, v227, v228);
            if (*(double *)(a5 + 176) < 0.0) {
              *a8 = 0;
            }
            if ((v180 & 1) == 0)
            {
              uint64_t v233 = MEMORY[0x1E4F1FA48];
              *(_OWORD *)(a5 + 32) = *MEMORY[0x1E4F1FA48];
              *(void *)(a5 + 48) = *(void *)(v233 + 16);
            }
          }
          else
          {
            uint64_t v42 = a6;
          }
          goto LABEL_65;
        }
        BOOL v248 = v88;
        int v153 = v117 - 1;
LABEL_221:
        if ((*(int (**)(uint64_t))(*(void *)a5 + 32))(a5) < v251)
        {
          double v189 = (double)((*(unsigned int (**)(uint64_t))(*(void *)a5 + 32))(a5) % v249 / v93);
          double v190 = (double)v153;
LABEL_226:
          double v84 = v189 / v190;
          int v118 = v253;
          LOBYTE(v88) = v248;
          goto LABEL_227;
        }
LABEL_223:
        int v191 = v117;
        unsigned int v192 = (PCRandom *)(*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
        int v193 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
        double v194 = PCRandom::getRandTEAf(v192, 0x83820093, v193);
        if (vabdd_f64(1.0, v194) < 0.0000001) {
          double v194 = 0.0;
        }
        double v189 = floor(v194 * (double)v191 + 0.0000001);
        double v190 = (float)v153;
        goto LABEL_226;
      }
      uint64_t v149 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
      int v150 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
      unsigned int v151 = (PCRandom *)v149;
      int v117 = v261;
      double v152 = PCRandom::getRandTEAf(v151, 0x3712F987u, v150);
      if (vabdd_f64(1.0, v152) < 0.0000001) {
        double v152 = 0.0;
      }
      double RandTEAf = floor(v152 * (double)v93 + 0.0000001) / (float)v258;
    }
    int v118 = v253;
    if (v117 < 2) {
      goto LABEL_227;
    }
    BOOL v248 = v88;
    int v153 = v117 - 1;
    if (!v253) {
      goto LABEL_223;
    }
    goto LABEL_221;
  }
  uint64_t v42 = a6;
  if (ValueAsInt == 11 && !v17)
  {
    if (v256)
    {
      int v94 = v22;
      int v95 = OZChannel::getValueAsInt((OZChannel *)(a1 + 20304), a3, 0.0);
      int v96 = OZChannel::getValueAsInt((OZChannel *)(a1 + 20456), a3, 0.0);
      int v97 = OZChannel::getValueAsInt((OZChannel *)(a1 + 20608), a3, 0.0);
      if (v95 <= 1) {
        int v98 = 1;
      }
      else {
        int v98 = v95;
      }
      int v99 = v98 - 1;
      if (v96 <= 1) {
        int v100 = 1;
      }
      else {
        int v100 = v96;
      }
      signed int v101 = v100 - 1;
      if (v97 <= 1) {
        int v102 = 1;
      }
      else {
        int v102 = v97;
      }
      int v257 = v102 - 1;
      signed int v260 = v101;
      if (v95 <= 2) {
        int v103 = 2;
      }
      else {
        int v103 = v95;
      }
      int v254 = v96 - 2;
      int v104 = v97 - 2;
      int v105 = ((v96 - 2) & ~((v96 - 2) >> 31)) * (v103 - 2) * (v104 & ~(v104 >> 31));
      int v106 = v96 * v95;
      int v107 = v106 * v97 - v105;
      int v108 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
      if (!v94 || v108 >= v107)
      {
        int v109 = (PCRandom *)(*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
        int v110 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
        int v111 = (int)(PCRandom::getRandTEAf(v109, 0x3712F987u, v110) * (double)v107);
        if (v107 <= v111) {
          int v108 = 0;
        }
        else {
          int v108 = v111;
        }
      }
      double v112 = (double)v99;
      double v113 = (double)v260;
      if (v108 >= 2 * v106)
      {
        double v154 = (double)v257;
        int v155 = v104 * v95;
        int v156 = (v155 & ~(v155 >> 31)) + v106;
        if (v108 >= 2 * v156)
        {
          int v186 = v108 - 2 * v156;
          int v187 = v104 * v254;
          double v114 = 0.5;
          double v116 = 0.5;
          if (v257) {
            double v116 = (double)(v186 % v104 + 1) / v154;
          }
          int v188 = v187 & ~(v187 >> 31);
          uint64_t v42 = a6;
          if (v260)
          {
            if (v187 <= 1) {
              int v187 = 1;
            }
            double v114 = (double)(v186 % v187 / v104 + 1) / v113;
          }
          if (v186 >= v188) {
            double v115 = 1.0;
          }
          else {
            double v115 = 0.0;
          }
        }
        else
        {
          int v157 = v108 - 2 * v106;
          double v116 = 0.5;
          double v115 = 0.5;
          if (v99) {
            double v115 = (double)(v157 % v95) / v112;
          }
          uint64_t v42 = a6;
          if (v257)
          {
            if (v155 <= 1) {
              int v158 = 1;
            }
            else {
              int v158 = v104 * v95;
            }
            double v116 = (double)(v157 % v158 / v95 + 1) / v154;
          }
          if (v260)
          {
            if (v155 <= 1) {
              int v155 = 1;
            }
            double v114 = (double)(v157 / v155);
          }
          else
          {
            double v114 = 0.5;
          }
        }
      }
      else
      {
        double v114 = 0.5;
        double v115 = 0.5;
        if (v99) {
          double v115 = (double)(v108 % v95) / v112;
        }
        if (v260) {
          double v114 = (double)(v108 % v106 / v95) / v113;
        }
        if (v257) {
          double v116 = (double)(v108 / v106);
        }
        else {
          double v116 = 0.5;
        }
        uint64_t v42 = a6;
      }
      PSEmitter::genPosFilledBox(a1, a3, (float64x2_t *)v42, (double *)a7, (uint64_t)&v280, v115, v114, v116);
      PSEmitter::genOrderFilledBox((PSEmitter *)a1, v115, v114, v116, 1, 1, 1, a3, (double *)(a5 + 168), (double *)(a5 + 176));
    }
    else
    {
      unsigned int v126 = (PCRandom *)(*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
      int v127 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
      double v128 = PCRandom::getRandTEAf(v126, 0x3712F987u, v127);
      double v129 = (PCRandom *)(*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
      int v130 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
      double v131 = PCRandom::getRandTEAf(v129, 0x83820093, v130);
      unsigned int v132 = (PCRandom *)(*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
      int v133 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
      double v134 = PCRandom::getRandTEAf(v132, 0x39002838u, v133);
      __y.f64[0] = 0.0;
      double cosval = 0.0;
      double v279 = 0.0;
      OZChannelScale3D::getValue((OZChannelScale3D *)(a1 + 25392), a3, __y.f64, &cosval, &v279, 0.0);
      double v135 = (cosval + cosval) * v279;
      double v136 = v279 * (__y.f64[0] + __y.f64[0]);
      double v137 = cosval * (__y.f64[0] + __y.f64[0]);
      double v138 = v135 + v136;
      double v139 = v128 * (v137 + v135 + v136);
      BOOL v140 = v139 < v136 + v135 + v137 * 0.5;
      double v141 = 1.0;
      if (v140) {
        double v142 = 0.0;
      }
      else {
        double v142 = 1.0;
      }
      if (v139 >= v135 + v136 * 0.5) {
        double v143 = 1.0;
      }
      else {
        double v143 = 0.0;
      }
      if (v139 < v138)
      {
        double v144 = v134;
      }
      else
      {
        double v143 = v134;
        double v144 = v142;
      }
      if (v139 < v135 * 0.5) {
        double v141 = 0.0;
      }
      if (v139 < v135) {
        float64_t v145 = v141;
      }
      else {
        float64_t v145 = v131;
      }
      if (v139 >= v135)
      {
        double v131 = v143;
        double v134 = v144;
      }
      PSEmitter::genPosFilledBox(a1, a3, (float64x2_t *)a6, (double *)a7, (uint64_t)&v280, v145, v131, v134);
      PSEmitter::genOrderFilledBox((PSEmitter *)a1, v145, v131, v134, 1, 1, 1, a3, (double *)(a5 + 168), (double *)(a5 + 176));
      if (*(double *)(a5 + 176) >= 0.0) {
        goto LABEL_65;
      }
    }
    *a8 = 0;
    goto LABEL_65;
  }
  int v255 = v22;
  unsigned int v119 = (PCRandom *)(*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
  int v120 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
  double v121 = PCRandom::getRandTEAf(v119, 0x3712F987u, v120);
  double v122 = (PCRandom *)(*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
  int v123 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
  double v124 = PCRandom::getRandTEAf(v122, 0x83820093, v123);
  if (v256)
  {
    if (v23 >= 0xFFFFFFFE)
    {
      int v252 = OZChannel::getValueAsInt((OZChannel *)(a1 + 26136), a3, 0.0);
      uint64_t v125 = 25984;
    }
    else
    {
      int v252 = OZChannel::getValueAsInt((OZChannel *)(a1 + 20304), a3, 0.0);
      uint64_t v125 = 20456;
    }
    signed int v148 = OZChannel::getValueAsInt((OZChannel *)(a1 + v125), a3, 0.0);
    int v159 = v148 * v252;
    int v250 = v252 - 1;
    if (v16) {
      int v160 = v252;
    }
    else {
      int v160 = v252 - 1;
    }
    double v146 = 0.5;
    double v121 = 0.5;
    if (v160 >= 1)
    {
      if (v255 && (*(int (**)(uint64_t))(*(void *)a5 + 32))(a5) < v159)
      {
        double v121 = (double)((*(unsigned int (**)(uint64_t))(*(void *)a5 + 32))(a5) % v252) / (double)v160;
        int v161 = (__PAIR64__(v148, v23) - 4294967294u) >> 32;
        if (v161 >= 1)
        {
          uint64_t v42 = a6;
LABEL_176:
          if ((*(int (**)(uint64_t))(*(void *)a5 + 32))(a5) < v159)
          {
            double v166 = (double)((*(unsigned int (**)(uint64_t))(*(void *)a5 + 32))(a5) / v252);
            double v167 = (double)v161;
LABEL_181:
            double v146 = v166 / v167;
LABEL_183:
            double v147 = 0.0;
            if (ValueAsInt <= 6 && ((1 << ValueAsInt) & 0x64) != 0)
            {
              int v174 = OZChannel::getValueAsInt((OZChannel *)(a1 + 19896), a3, 0.0);
              if (v252 >= 2 && v174 == 1)
              {
                OZChannel::getValueAsDouble((OZChannel *)(a1 + 21064), a3, 0.0);
                long double v176 = v146 * (double)v161 * v175;
                __y.f64[0] = 0.0;
                modf(v176, (long double *)__y.f64);
                double v177 = v176 - __y.f64[0];
                BOOL isOrderByRowOrCol = PSEmitter::isOrderByRowOrCol((PSEmitter *)a1);
                double v179 = v177 / (double)v250;
                if (isOrderByRowOrCol) {
                  double v147 = v177 / (double)v250;
                }
                else {
                  double v147 = 0.0;
                }
                if (isOrderByRowOrCol) {
                  double v179 = -0.0;
                }
                double v121 = v121 + v179;
              }
            }
            goto LABEL_193;
          }
LABEL_178:
          int v168 = v161;
          signed int v169 = v148;
          uint64_t v170 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
          int v171 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
          double v172 = (PCRandom *)v170;
          signed int v148 = v169;
          int v161 = v168;
          double v173 = PCRandom::getRandTEAf(v172, 0x83820093, v171);
          if (vabdd_f64(1.0, v173) < 0.0000001) {
            double v173 = 0.0;
          }
          double v166 = floor(v173 * (double)v148 + 0.0000001);
          double v167 = (float)v168;
          goto LABEL_181;
        }
        goto LABEL_182;
      }
      uint64_t v162 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
      int v163 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
      __double2 v164 = (PCRandom *)v162;
      int v159 = v148 * v252;
      double v165 = PCRandom::getRandTEAf(v164, 0x3712F987u, v163);
      if (vabdd_f64(1.0, v165) < 0.0000001) {
        double v165 = 0.0;
      }
      double v121 = floor(v165 * (double)v252 + 0.0000001) / (float)v160;
    }
    int v161 = (__PAIR64__(v148, v23) - 4294967294u) >> 32;
    if (v161 >= 1)
    {
      uint64_t v42 = a6;
      if (!v255) {
        goto LABEL_178;
      }
      goto LABEL_176;
    }
LABEL_182:
    uint64_t v42 = a6;
    goto LABEL_183;
  }
  double v146 = v124;
  double v147 = 0.0;
  int v252 = 1;
  signed int v148 = 1;
LABEL_193:
  switch(ValueAsInt)
  {
    case 2u:
      float64x2_t __y = *(float64x2_t *)v42;
      double v268 = *(double *)(v42 + 16);
      int v180 = PSEmitter::genPosFilledCircle(a1, a3, &__y, a7, v121, v146);
      if (!v256)
      {
        int v181 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 584))(a1);
        if ((v181 | v180))
        {
          LOBYTE(v180) = v181 ^ 1 | v180;
        }
        else
        {
          unsigned int v234 = 1;
          do
          {
            unsigned int v235 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
            unsigned int v236 = v234 + 923990407;
            int v237 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
            int v238 = -32;
            int v239 = -1640531527;
            do
            {
              v235 += (v237 + 16 * v236) ^ (v239 + v236) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                          + (v236 >> 5));
              v236 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v235) ^ (v239 + v235) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v235 >> 5));
              v239 -= 1640531527;
              BOOL v34 = __CFADD__(v238++, 1);
            }
            while (!v34);
            double v240 = (double)(v236 ^ v235);
            unsigned int v241 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 32))(a5);
            unsigned int v242 = v234 - 2088632173;
            int v243 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 600))(a1, a4);
            int v244 = -32;
            int v245 = -1640531527;
            do
            {
              v241 += (v243 + 16 * v242) ^ (v245 + v242) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                          + (v242 >> 5));
              v242 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v241) ^ (v245 + v241) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v241 >> 5));
              v245 -= 1640531527;
              BOOL v34 = __CFADD__(v244++, 1);
            }
            while (!v34);
            double v246 = (double)(v242 ^ v241);
            double v121 = v240 / 4294967300.0;
            uint64_t v42 = a6;
            float64x2_t __y = *(float64x2_t *)a6;
            double v268 = *(double *)(a6 + 16);
            double v146 = v246 / 4294967300.0;
            BOOL v247 = PSEmitter::genPosFilledCircle(a1, a3, &__y, a7, v121, v246 / 4294967300.0);
            if (v247) {
              break;
            }
            BOOL v34 = v234++ >= 0x13;
          }
          while (!v34);
          if (v247)
          {
            LOBYTE(v180) = 1;
          }
          else
          {
            fwrite("kMaxCirlceAttempts reached\n", 0x1BuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
            LOBYTE(v180) = 0;
          }
        }
      }
      *(float64x2_t *)uint64_t v42 = __y;
      *(double *)(v42 + 16) = v268;
      unsigned int v227 = (double *)(a5 + 168);
      double v228 = (double *)(a5 + 176);
      double v232 = 0.5;
      unint64_t v229 = (PSEmitter *)a1;
      double v230 = v121;
      double v231 = v146;
      goto LABEL_278;
    case 5u:
      PSEmitter::genOrderFilledRect((PSEmitter *)a1, v121, v146, v252, v148, a3, (double *)(a5 + 168), (double *)(a5 + 176));
      if (*(double *)(a5 + 176) < 0.0) {
        *a8 = 0;
      }
      double v182 = v147 + v121;
      if (a2 == 2)
      {
        BOOL v183 = 0;
      }
      else
      {
        BOOL v183 = OZChannel::getValueAsInt((OZChannel *)(a4 + 5368), a3, 0.0) == 4;
        if (OZChannel::getValueAsInt((OZChannel *)(a1 + 27048), a3, 0.0))
        {
          OZChannel::getValueAsDouble((OZChannel *)(a1 + 27200), a3, 0.0);
          if (v225 > 0.0)
          {
            char v226 = 1;
            goto LABEL_273;
          }
        }
      }
      char v226 = 0;
LABEL_273:
      PSEmitter::initPropertiesFromImage((CGColorSpace **)a1, v182, v146, a3, v226, v183, (PCColor *)a5, (float64x2_t *)v42);
      break;
    case 6u:
      PSEmitter::genOrderFilledRect((PSEmitter *)a1, v121, v146, v252, v148, a3, (double *)(a5 + 168), (double *)(a5 + 176));
      if (*(double *)(a5 + 176) < 0.0) {
        *a8 = 0;
      }
      PSEmitter::genPosFilledRect(a1, a3, (float64x2_t *)v42, v147 + v121, v146);
      break;
    case 7u:
      PSEmitter::genOrderRadial((PSEmitter *)a1, v121, v252, a3, (double *)(a5 + 168), (double *)(a5 + 176));
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 23160), a3, 0.0);
      PSEmitter::genPosRadial(a1, a3, v42, a7, v121 + v184, v146);
      break;
    case 8u:
      PSEmitter::genOrderRadial((PSEmitter *)a1, v121, v252, a3, (double *)(a5 + 168), (double *)(a5 + 176));
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 23160), a3, 0.0);
      PSEmitter::genPosSpiral(a1, a3, (float64x2_t *)v42, a7, v121 + v185, v146);
      break;
    case 0xAu:
      PSEmitter::genPosSurfaceSphere(a1, a3, (float64x2_t *)v42, (float64x2_t *)a7, &v280, v121, v146);
      PSEmitter::genOrderLinear((PSEmitter *)a1, v121, v16, v252, a3, (double *)(a5 + 168), (double *)(a5 + 176));
      break;
    default:
      break;
  }
LABEL_65:
  if (OZChannel::getValueAsInt((OZChannel *)(a1 + 23008), a3, 0.0) && *a8)
  {
    unsigned int OrderLength = PSEmitter::getOrderLength((PSEmitter *)a1, a3);
    unsigned int v48 = (*(double *)(a5 + 168) * (double)OrderLength + 0.00001);
    unsigned int v49 = OrderLength - 1;
    if (OrderLength - 1 >= v48) {
      uint64_t v50 = v48;
    }
    else {
      uint64_t v50 = v49;
    }
    unsigned int v51 = OZChannel::getValueAsInt((OZChannel *)(a1 + 31784), MEMORY[0x1E4F1FA48], 0.0);
    unsigned int v52 = PSEmitter::shuffleOrder((PSEmitter *)a1, v50, OrderLength, v51);
    *(double *)(a5 + 168) = (double)v52 / (double)v49;
    *(double *)(a5 + 176) = (double)v52;
  }
  if (PSEmitter::canAlignRotation((PSEmitter *)a1, a3)
    && OZChannel::getValueAsInt((OZChannel *)(a4 + 2184), a3, 0.0))
  {
    double cosval = 1.0;
    double v276 = 0.0;
    double v277 = 0.0;
    double sinval = 0.0;
    if ((ValueAsInt & 0xFFFFFFFE) == 0xA)
    {
      double v57 = *(double *)(a7 + 8);
      v53.i64[0] = *(void *)(a7 + 16);
      long double v58 = *(double *)a7;
      *(double *)v55.i64 = v281 * *(double *)v53.i64 - v282 * v57;
      double v59 = v282 * *(double *)a7 - *(double *)v53.i64 * v280;
      double v60 = v57 * v280 - v281 * *(double *)a7;
      double v61 = -v280;
      *(double *)v54.i64 = -v281;
      *(double *)v56.i64 = -v282;
      __y.f64[0] = -v280;
      __y.f64[1] = *(double *)v55.i64;
      double v272 = -v282;
      double v273 = v60;
      double v268 = v58;
      double v269 = -v281;
      double v270 = v59;
      double v271 = v57;
      double v274 = *(double *)v53.i64;
    }
    else
    {
      if (!v262)
      {
        long double v66 = atan2(*(long double *)a7, -*(double *)(a7 + 8));
        __double2 v67 = __sincos_stret(v66 * 0.5);
        double cosval = v67.__cosval;
        double v276 = v67.__sinval * 0.0;
        double v277 = v67.__sinval * 0.0;
        double sinval = v67.__sinval;
LABEL_79:
        if (&cosval != (double *)(v42 + 24))
        {
          double v68 = *(double *)(v42 + 24);
          double v69 = *(double *)(v42 + 32);
          double v70 = *(double *)(v42 + 40);
          double v71 = *(double *)(v42 + 48);
          double v72 = v68 * cosval - (v69 * v276 + v70 * v277 + v71 * sinval);
          double v73 = cosval * v69 + v68 * v276;
          double v74 = cosval * v70 + v68 * v277;
          double v75 = cosval * v71 + v68 * sinval;
          double v76 = v70 * sinval - v277 * v71;
          double v77 = v276 * v71 - v69 * sinval;
          double v78 = v69 * v277 - v276 * v70;
          *(double *)(v42 + 40) = v74 + v77;
          *(double *)(v42 + 48) = v78 + v75;
          *(double *)(v42 + 24) = v72;
          *(double *)(v42 + 32) = v73 + v76;
        }
        return;
      }
      double v62 = *(double *)(a7 + 8);
      v53.i64[0] = *(void *)(a7 + 16);
      double v61 = v280;
      *(double *)v54.i64 = v281;
      *(double *)v56.i64 = v282;
      float64_t v63 = *(double *)a7;
      *(double *)v55.i64 = -(v281 * *(double *)v53.i64 - v282 * v62);
      double v64 = -(v282 * *(double *)a7 - *(double *)v53.i64 * v280);
      double v65 = -(v62 * v280 - v281 * *(double *)a7);
      __y.f64[0] = *(double *)v55.i64;
      __y.f64[1] = v63;
      double v272 = v65;
      double v273 = *(double *)v53.i64;
      double v268 = v280;
      double v269 = v64;
      double v270 = v62;
      double v271 = v281;
      double v274 = v282;
    }
    PCMatrix33Tmpl<double>::getQuaternionFromRotationMatrix((uint64_t)&__y, (uint64_t)&cosval, v53, v54, v61, v55, v56);
    goto LABEL_79;
  }
}

BOOL PSEmitter::getEmitAtPoints(PSEmitter *this)
{
  uint64_t v2 = (const CMTime *)MEMORY[0x1E4F1FA48];
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19744), MEMORY[0x1E4F1FA48], 0.0);
  unsigned int v4 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19232), v2, 0.0);
  unsigned int v5 = v4;
  if (ValueAsInt)
  {
    BOOL result = 1;
    BOOL v7 = v5 > 6;
    int v8 = (1 << v5) & 0x64;
    if (!v7 && v8 != 0) {
      return OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), MEMORY[0x1E4F1FA48], 0.0) != 2;
    }
  }
  else
  {
    return v4 <= 6
        && ((1 << v4) & 0x64) != 0
        && OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), MEMORY[0x1E4F1FA48], 0.0) == 1;
  }
  return result;
}

void PSEmitter::genOrderLinear(PSEmitter *this, double a2, int a3, unsigned int a4, const CMTime *a5, double *a6, double *a7)
{
  if (!a3)
  {
    int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 22240), a5, 0.0);
    if (ValueAsInt == 2)
    {
      double v17 = fabs(a2 + -0.5);
      double v18 = v17 + v17;
      *a6 = v18;
      double v19 = ceil((double)a4 * 0.5) + -1.0;
    }
    else
    {
      if (ValueAsInt != 1)
      {
        if (ValueAsInt) {
          return;
        }
        *a6 = a2;
        double v14 = (double)(a4 - 1) * a2;
        goto LABEL_18;
      }
      double v18 = 1.0 - a2;
      double v19 = (double)(a4 - 1);
      *a6 = 1.0 - a2;
    }
    double v14 = v18 * v19;
LABEL_18:
    double __y = 0.0;
    modf(v14 + 0.0001, &__y);
    double v16 = __y;
    goto LABEL_19;
  }
  int v11 = OZChannel::getValueAsInt((OZChannel *)this + 148, a5, 0.0);
  if (v11)
  {
    if (v11 == 1)
    {
      *a6 = a2;
      if (a7)
      {
        double v12 = (double)a4 * a2 + 0.5 + 0.0000001;
LABEL_14:
        double v16 = (double)(int)vcvtmd_s64_f64(v12);
LABEL_19:
        *a7 = v16;
      }
    }
  }
  else
  {
    double v15 = 1.0 - a2;
    if (vabdd_f64(1.0, 1.0 - a2) < 0.0000001) {
      double v15 = 0.0;
    }
    *a6 = v15;
    if (a7)
    {
      double v12 = v15 * (double)a4 + 0.5 + 0.0000001;
      goto LABEL_14;
    }
  }
}

float64x2_t PSEmitter::genPosCircle(uint64_t a1, const CMTime *a2, uint64_t a3, uint64_t a4, double a5)
{
  double v7 = a5 * -2.0 * 3.14159265;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 23312), a2, 0.0);
  double v9 = v8;
  __double2 v10 = __sincos_stret(v7);
  *(double *)a4 = v10.__cosval * v9;
  *(double *)(a4 + 8) = v10.__sinval * v9;
  *(void *)(a4 + 16) = 0;
  *(double *)a3 = v10.__cosval * v9 + *(double *)a3;
  float64x2_t result = vaddq_f64((float64x2_t)COERCE_UNSIGNED_INT64(v10.__sinval * v9), *(float64x2_t *)(a3 + 8));
  *(float64x2_t *)(a3 + 8) = result;
  return result;
}

double PSEmitter::genPosLine(uint64_t a1, const CMTime *a2, double *a3, uint64_t a4, double a5)
{
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 23600), a2, 0.0);
  double v11 = v10;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 23752), a2, 0.0);
  double v13 = v12;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 24200), a2, 0.0);
  double v15 = v14;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 24488), a2, 0.0);
  double v17 = v16;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 24640), a2, 0.0);
  double v19 = v18;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 25088), a2, 0.0);
  double v21 = v20;
  int v22 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 168))(a1);
  if (v22) {
    double v23 = v21;
  }
  else {
    double v23 = 0.0;
  }
  if (!v22) {
    double v15 = 0.0;
  }
  double v24 = v17 - v11;
  double v25 = v19 - v13;
  double v26 = v23 - v15;
  double v27 = v24 * v24 + v25 * v25 + v26 * v26;
  if (v27 <= -0.0000001 || v27 >= 0.0000001)
  {
    *(double *)a4 = v25;
    *(double *)(a4 + 8) = -v24;
    *(void *)(a4 + 16) = 0;
    PCVector3<double>::normalize((double *)a4, 0.000000100000001);
  }
  double v28 = v13 + v25 * a5 + a3[1];
  *a3 = v11 + v24 * a5 + *a3;
  a3[1] = v28;
  double result = v15 + v26 * a5 + a3[2];
  a3[2] = result;
  return result;
}

void PSEmitter::genPosGeometry(uint64_t a1, const CMTime *a2, double *a3, void *a4, long double a5)
{
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 616))(a1);
  if (v10)
  {
    double v11 = (void *)v10;
    double v22 = 0.0;
    for (double i = 0.0; a5 < 0.0; a5 = a5 + 1.0)
      ;
    for (; a5 > 1.0; a5 = a5 + -1.0)
      ;
    double v12 = 0.0;
    if (OZChannel::getValueAsInt((OZChannel *)(a1 + 31936), MEMORY[0x1E4F1FA48], 0.0))
    {
      OZRenderState::OZRenderState(&v21);
      *(_OWORD *)&v21.var0.var0 = *(_OWORD *)&a2->value;
      v21.var0.var3 = a2->epoch;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      int v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 608))(a1);
      OZRotoshape::getReparametrizedPointOnContour((uint64_t)v11, (long long *)&v21.var0.var0, &i, &v22, (double *)&v20, (double *)&v19, v13, 0, a5, 0);
      double v14 = i;
      double v15 = v14 * (*(double (**)(void *))(v11[25] + 1328))(v11 + 25);
      uint64_t v16 = v19;
      *a4 = v20;
      a4[1] = v16;
      a4[2] = 0;
    }
    else
    {
      double v17 = (void *)v11[2431];
      if (v17) {
        double v12 = (double)((int)((v17[1] - *v17) >> 3) / 2);
      }
      OZChannelCurve::getCurveValueWithParameter((OZChannelCurve *)(v11 + 2398), a2, a5 * v12, &i, &v22);
      double v15 = i;
    }
    double v18 = a3[1] + v22;
    *a3 = *a3 + v15;
    a3[1] = v18;
  }
}

double PSEmitter::genPosRect(double a1, double a2, double a3, uint64_t a4, uint64_t a5, double *a6, uint64_t a7)
{
  double v7 = a2 / a3;
  double v8 = v7 + v7 + 2.0;
  double v9 = 1.0 / v8;
  if (1.0 / v8 <= a1)
  {
    double v14 = v7 / v8;
    if (v9 + v14 <= a1)
    {
      double v18 = v14 + v9 + v9;
      if (v18 > a1)
      {
        double v19 = 1.0 - (a1 - (v9 + v14)) / v9;
        double v11 = a2 * 0.5;
        double v12 = (v19 + v19 + -1.0) * a3 * 0.5;
        *(void *)(a7 + 16) = 0;
        unint64_t v13 = 0x3FF0000000000000;
        goto LABEL_7;
      }
      double v11 = (1.0 - (a1 - v18) / v14 + 1.0 - (a1 - v18) / v14 + -1.0) * a2 * 0.5;
      double v16 = -0.5;
      long long v17 = xmmword_1B7E7E030;
    }
    else
    {
      double v15 = ((a1 - v9) / v14 + (a1 - v9) / v14 + -1.0) * a2;
      double v16 = 0.5;
      double v11 = v15 * 0.5;
      long long v17 = xmmword_1B7E733E0;
    }
    double v12 = a3 * v16;
    *(_OWORD *)a7 = v17;
    *(void *)(a7 + 16) = 0;
    goto LABEL_10;
  }
  double v10 = a1 / v9;
  double v11 = a2 * -0.5;
  double v12 = (v10 + v10 + -1.0) * a3 * 0.5;
  *(void *)(a7 + 16) = 0;
  unint64_t v13 = 0xBFF0000000000000;
LABEL_7:
  *(void *)a7 = v13;
  *(void *)(a7 + 8) = 0;
LABEL_10:
  double result = v11 + *a6;
  double v21 = v12 + a6[1];
  *a6 = result;
  a6[1] = v21;
  return result;
}

double PSEmitter::initPropertiesFromImageOutline(uint64_t a1, const CMTime *a2, int a3, int a4, uint64_t a5, double *a6, uint64_t a7, __n128 a8)
{
  uint64_t v8 = a1 + 33512;
  double v9 = *(double *)(a1 + 33536);
  if (v9 == 0.0) {
    return a8.n128_f64[0];
  }
  double v10 = *(double *)(a1 + 33544);
  if (v10 == 0.0) {
    return a8.n128_f64[0];
  }
  char v15 = a3;
  double v17 = a8.n128_f64[0];
  if (a3)
  {
    uint64_t v19 = *(void *)v8;
    if (!*(void *)v8) {
      return a8.n128_f64[0];
    }
    goto LABEL_9;
  }
  if (a4)
  {
    uint64_t v19 = *(void *)v8;
LABEL_9:
    memset(&v44.var1, 0, 24);
    double v20 = (double)(*(unsigned int (**)(uint64_t))(*(void *)v19 + 16))(v19);
    uint64_t v21 = (*(uint64_t (**)(void))(**(void **)v8 + 24))();
    double v22 = (double)v21;
    PSEmitter::genPosRect(v17, v20, (double)v21, v21, v23, (double *)&v44.var1, a7);
    double v24 = v20 * 0.5 + *(double *)&v44.var1;
    double v25 = v22 * 0.5 + *(double *)&v44.var2;
    OZChannel::getValueAsDouble((OZChannel *)(a1 + 27200), a2, 0.0);
    unsigned int v27 = vcvtmd_s64_f64(v26 * 255.0 + 0.5 + 0.0000001);
    uint64_t v28 = (*(uint64_t (**)(void))(**(void **)(*(void *)v8 + 64) + 16))(*(void *)(*(void *)v8 + 64));
    signed int v29 = (*(_DWORD *)(*(void *)v8 + 36) * *(_DWORD *)(*(void *)v8 + 40)) >> 3;
    uint64_t BytesPerRow = PCBitmap::getBytesPerRow(*(PCBitmap **)v8);
    int v32 = vcvtmd_s64_f64(v24 + 0.0000001);
    int v33 = vcvtmd_s64_f64(v25 + 0.0000001);
    BOOL v34 = (unsigned __int8 *)(v28
                            + BytesPerRow * (uint64_t)(v33 - ((double)v33 == v22))
                            + v29 * (uint64_t)(v32 - ((double)v32 == v20)));
    if (v27 > *v34 && (v15 & 1) != 0)
    {
      uint64_t v35 = MEMORY[0x1E4F1FA48];
      a8 = *(__n128 *)MEMORY[0x1E4F1FA48];
      *(_OWORD *)(a5 + 32) = *MEMORY[0x1E4F1FA48];
      *(void *)(a5 + 48) = *(void *)(v35 + 16);
    }
    else
    {
      a8.n128_f64[0] = PSEmitter::genPosRect(v17, *(double *)(v8 + 24), *(double *)(v8 + 32), BytesPerRow, v31, a6, a7);
      if (a4)
      {
        a8.n128_u8[0] = v34[1];
        *(double *)&unint64_t v36 = (double)a8.n128_u64[0] / 255.0;
        float v37 = *(double *)&v36;
        LOBYTE(v36) = v34[2];
        *(double *)&unint64_t v38 = (double)v36 / 255.0;
        float v39 = *(double *)&v38;
        LOBYTE(v38) = v34[3];
        *(double *)&unint64_t v40 = (double)v38 / 255.0;
        float v41 = *(double *)&v40;
        LOBYTE(v40) = *v34;
        float v42 = (double)v40 / 255.0;
        PCImage::getColorSpace(*(PCImage **)v8, (CGColorSpace **)&v44);
        PCColor::setRGBA((PCColor *)(a5 + 112), v37, v39, v41, v42, &v44);
        PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v44);
      }
    }
    return a8.n128_f64[0];
  }

  a8.n128_f64[0] = PSEmitter::genPosRect(a8.n128_f64[0], v9, v10, a1, (uint64_t)a2, a6, a7);
  return a8.n128_f64[0];
}

void sub_1B7DC15D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGColorSpace *a9)
{
}

BOOL PSEmitter::genPosWave(uint64_t a1, const CMTime *a2, double *a3, double *a4, double *a5, double a6)
{
  double v11 = 0.0;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 23600), a2, 0.0);
  double v13 = v12;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 23752), a2, 0.0);
  double v15 = v14;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 24200), a2, 0.0);
  double v17 = v16;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 24488), a2, 0.0);
  double v19 = v18;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 24640), a2, 0.0);
  double v21 = v20;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 25088), a2, 0.0);
  double v23 = v22;
  int v24 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 168))(a1);
  if (v24) {
    double v25 = v23;
  }
  else {
    double v25 = 0.0;
  }
  if (v24) {
    double v26 = v17;
  }
  else {
    double v26 = 0.0;
  }
  double v59 = v15;
  double v60 = v13;
  double v27 = v19 - v13;
  double v28 = v21 - v15;
  double v29 = v25 - v26;
  double v30 = v27 * v27;
  double v31 = v27 * v27 + v28 * v28;
  double v32 = sqrt(v31 + v29 * v29);
  if (v32 <= -0.0000001 || (double v33 = 1.0, v34 = 0.0, v35 = 0.0, v36 = 0.0, v32 >= 0.0000001))
  {
    double v57 = v26;
    BOOL v37 = v31 <= 0.0;
    double v38 = v29 - v28 * 0.0;
    if (v31 > 0.0)
    {
      double v38 = 0.0 - v28;
      double v39 = v27;
    }
    else
    {
      double v30 = (v27 * 0.0 - v29 * 0.0) * (v27 * 0.0 - v29 * 0.0);
      double v39 = v27 * 0.0 - v29 * 0.0;
    }
    if (v37) {
      double v34 = v28 * 0.0 - v27;
    }
    else {
      double v34 = v28 * 0.0 - v27 * 0.0;
    }
    double v40 = sqrt(v38 * v38 + v30 + v34 * v34);
    if (v40 <= -0.000000100000001 || v40 >= 0.000000100000001)
    {
      double v56 = v38 / v40;
      double v58 = v39 / v40;
      double v34 = v34 / v40;
    }
    else
    {
      double v56 = v38;
      double v58 = v39;
    }
    OZChannel::getValueAsDouble((OZChannel *)(a1 + 26592), a2, 0.0);
    double v42 = v41;
    double v55 = v41;
    OZChannel::getValueAsDouble((OZChannel *)(a1 + 26440), a2, 0.0);
    double v44 = v43;
    OZChannel::getValueAsDouble((OZChannel *)(a1 + 26744), a2, 0.0);
    double v54 = v45 + (v42 * a6 + v42 * a6) * 3.14159265;
    OZChannel::getValueAsDouble((OZChannel *)(a1 + 26896), a2, 0.0);
    double v47 = fabs(v46);
    if (v46 >= 0.0) {
      double v48 = a6;
    }
    else {
      double v48 = 1.0 - a6;
    }
    double v49 = exp(-(v47 * v48));
    __double2 v50 = __sincos_stret(v54);
    double v35 = v50.__sinval * (v44 * v49);
    double v51 = v50.__cosval * (v44 * 6.28318531 * v49 / v32);
    double v11 = v56;
    double v36 = v55 * v51;
    double v26 = v57;
    double v33 = v58;
  }
  double v52 = v59 + v28 * a6 + v33 * v35 + a3[1];
  *a3 = v60 + v27 * a6 + v11 * v35 + *a3;
  a3[1] = v52;
  a3[2] = v26 + v29 * a6 + v34 * v35 + a3[2];
  if (v32 <= -0.000000100000001 || v32 >= 0.000000100000001)
  {
    double v27 = v27 / v32;
    double v28 = v28 / v32;
    double v29 = v29 / v32;
  }
  *a4 = v11 - v36 * v27;
  a4[1] = v33 - v36 * v28;
  a4[2] = v34 - v36 * v29;
  PCVector3<double>::normalize(a4, 0.000000100000001);
  *a5 = v34 * v28 - v33 * v29;
  a5[1] = v11 * v29 - v34 * v27;
  a5[2] = v33 * v27 - v11 * v28;

  return PCVector3<double>::normalize(a5, 0.000000100000001);
}

BOOL PSEmitter::isOrderByRowColStack(PSEmitter *this)
{
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 19232), MEMORY[0x1E4F1FA48], 0.0) != 11
    || OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), MEMORY[0x1E4F1FA48], 0.0) == 2)
  {
    return 0;
  }
  int v3 = (const CMTime *)MEMORY[0x1E4F1FA48];
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 21984), MEMORY[0x1E4F1FA48], 0.0);
  unsigned int v5 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 21728), v3, 0.0);
  if (ValueAsInt) {
    BOOL v6 = v5 >= 8;
  }
  else {
    BOOL v6 = 1;
  }
  return !v6;
}

BOOL PSEmitter::genPosFilledSphere(uint64_t a1, const CMTime *a2, float64x2_t *a3, float64_t *a4, float64_t a5, float64_t a6, double a7)
{
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 23312), a2, 0.0);
  double v11 = v10 * v10;
  v12.f64[0] = a5;
  v12.f64[1] = a6;
  float64x2_t v13 = vaddq_f64(v12, v12);
  __asm { FMOV            V3.2D, #-1.0 }
  float64x2_t v19 = vmulq_n_f64(vaddq_f64(v13, _Q3), v10);
  double v20 = (a7 + a7 + -1.0) * v10;
  double v21 = v20 * v20 + vaddvq_f64(vmulq_f64(v19, v19));
  if (v21 <= v11)
  {
    *a3 = vaddq_f64(v19, *a3);
    a3[1].f64[0] = v20 + a3[1].f64[0];
    if (v21 <= -0.0000001 || v21 >= 0.0000001)
    {
      double v22 = sqrt(v21);
      double v23 = v19.f64[1];
      if (v22 <= -0.000000100000001 || v22 >= 0.000000100000001)
      {
        v19.f64[0] = v19.f64[0] / v22;
        double v23 = v19.f64[1] / v22;
        double v20 = v20 / v22;
      }
      *a4 = v19.f64[0];
      a4[1] = v23;
      a4[2] = v20;
    }
  }
  return v21 <= v11;
}

uint64_t PSEmitter::genOrderFilledCircle(PSEmitter *this, double a2, double a3, double a4, const CMTime *a5, double *a6, double *a7)
{
  double v9 = sqrt((a2 + a2 + -1.0) * (a2 + a2 + -1.0) + (a3 + a3 + -1.0) * (a3 + a3 + -1.0) + (a4 + a4 + -1.0)
                                                                                      * (a4 + a4 + -1.0));
  uint64_t result = OZChannel::getValueAsInt((OZChannel *)((char *)this + 22752), a5, 0.0);
  double v11 = 1.0 - v9;
  if (result != 1) {
    double v11 = v9;
  }
  *a6 = v11;
  if (a7) {
    *a7 = -1.0;
  }
  return result;
}

void PSEmitter::genOrderFilledBox(PSEmitter *this, double a2, double a3, double a4, int a5, int a6, int a7, const CMTime *a8, double *a9, double *a10)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  signed int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 21728), a8, 0.0);
  int v21 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 21984), a8, 0.0);
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), MEMORY[0x1E4F1FA48], 0.0) == 2) {
    int v22 = 0;
  }
  else {
    int v22 = v21;
  }
  if (ValueAsInt == 14)
  {
    double v23 = sqrt((a2 + -0.5 + a2 + -0.5) * (a2 + -0.5 + a2 + -0.5)+ (a3 + -0.5 + a3 + -0.5) * (a3 + -0.5 + a3 + -0.5)+ (a4 + -0.5 + a4 + -0.5) * (a4 + -0.5 + a4 + -0.5));
    double v24 = 1.73205081;
LABEL_19:
    double v30 = v23 / v24;
LABEL_20:
    *a9 = v30;
    if (a10) {
      *a10 = -1.0;
    }
    return;
  }
  if ((ValueAsInt - 15) <= 2)
  {
    double v25 = a2 + -0.5 + a2 + -0.5;
    double v26 = a3 + -0.5 + a3 + -0.5;
    double v27 = a4 + -0.5 + a4 + -0.5;
    if (ValueAsInt == 16) {
      double v28 = 0.0;
    }
    else {
      double v28 = a3 + -0.5 + a3 + -0.5;
    }
    if (ValueAsInt == 16) {
      double v29 = a4 + -0.5 + a4 + -0.5;
    }
    else {
      double v29 = 0.0;
    }
    if (ValueAsInt == 15) {
      double v25 = 0.0;
    }
    else {
      double v26 = v28;
    }
    if (ValueAsInt != 15) {
      double v27 = v29;
    }
    double v23 = sqrt(v25 * v25 + v26 * v26 + v27 * v27);
    double v24 = 1.41421356;
    goto LABEL_19;
  }
  if ((vmaxv_u16((uint16x4_t)vmovn_s32(vceqq_s32(vdupq_n_s32(ValueAsInt), (int32x4_t)xmmword_1B8386210))) & 1) != 0
    || ValueAsInt == 8
    || (v22 ? (BOOL v31 = ValueAsInt == 13) : (BOOL v31 = 1), v31))
  {
    if (ValueAsInt > 0xD)
    {
      double v43 = 1.0;
      double v37 = 0.0;
      double v38 = 0.0;
      double v39 = 0.0;
      double v40 = 0.0;
      double v41 = 0.0;
      double v42 = 0.0;
    }
    else
    {
      double v37 = dbl_1B8386C90[ValueAsInt];
      double v38 = dbl_1B8386D00[ValueAsInt];
      double v39 = dbl_1B8386D70[ValueAsInt];
      double v40 = dbl_1B8386DE0[ValueAsInt];
      double v41 = dbl_1B8386E50[ValueAsInt];
      double v42 = dbl_1B8386EC0[ValueAsInt];
      double v43 = dbl_1B8386F30[ValueAsInt];
    }
    double v30 = ((a2 - v37) * v40 + (a3 - v38) * v41 + (a4 - v39) * v42) / v43;
    goto LABEL_20;
  }
  int v32 = a5 - 1;
  unsigned int v33 = vcvtmd_s64_f64((double)(a5 - 1) * a2 + 0.5 + 0.0000001);
  int v34 = a6 - 1;
  unsigned int v35 = vcvtmd_s64_f64((double)(a6 - 1) * a3 + 0.5 + 0.0000001);
  unsigned int v36 = vcvtmd_s64_f64((double)(a7 - 1) * a4 + 0.5 + 0.0000001);
  switch(ValueAsInt)
  {
    case 0:
      goto LABEL_31;
    case 1:
      unsigned int v33 = v32 - v33;
LABEL_31:
      unsigned int v35 = v34 - v35;
      goto LABEL_39;
    case 2:
      goto LABEL_39;
    case 3:
      unsigned int v33 = v32 - v33;
LABEL_39:
      unsigned int v36 = a7 - 1 - v36;
      break;
    case 4:
      goto LABEL_37;
    case 5:
      unsigned int v33 = v32 - v33;
LABEL_37:
      unsigned int v35 = v34 - v35;
      break;
    case 7:
      unsigned int v33 = v32 - v33;
      break;
    default:
      break;
  }
  v52[0] = a5;
  v52[1] = a6;
  v52[2] = a7;
  v51[0] = v33;
  v51[1] = v35;
  int v44 = v22 - 1;
  v51[2] = v36;
  if ((v22 - 1) > 4)
  {
    uint64_t v45 = 0;
    uint64_t v47 = 2;
    uint64_t v46 = 1;
  }
  else
  {
    uint64_t v45 = qword_1B8386FA0[v44];
    uint64_t v46 = qword_1B8386FC8[v44];
    uint64_t v47 = qword_1B8386FF0[v44];
  }
  double v48 = (double)(a6 * a5 * a7 - 1);
  double v49 = (double)(v51[v47] + (v51[v46] + v51[v45] * v52[v46]) * v52[v47]) / v48;
  *a9 = v49;
  if (a10)
  {
    double __y = 0.0;
    modf(v49 * v48 + 0.0001, &__y);
    *a10 = __y;
  }
}

void PSEmitter::genPosFilledBox(uint64_t a1, const CMTime *a2, float64x2_t *a3, double *a4, uint64_t a5, float64_t a6, float64_t a7, double a8)
{
  float64_t v37 = 0.0;
  float64_t v38 = 0.0;
  double v36 = 0.0;
  OZChannelScale3D::getValue((OZChannelScale3D *)(a1 + 25392), a2, &v38, &v37, &v36, 0.0);
  v12.f64[0] = a6;
  v12.f64[1] = a7;
  double v13 = a8 + a8 + -1.0;
  v14.f64[0] = v38;
  double v15 = v13 * v36 * 0.5 + a3[1].f64[0];
  __asm { FMOV            V4.2D, #-1.0 }
  float64x2_t v21 = vaddq_f64(vaddq_f64(v12, v12), _Q4);
  v14.f64[1] = v37;
  __asm { FMOV            V4.2D, #0.5 }
  *a3 = vaddq_f64(vmulq_f64(vmulq_f64(v21, v14), _Q4), *a3);
  a3[1].f64[0] = v15;
  if (a4 && a5)
  {
    a4[1] = 0.0;
    *a4 = 0.0;
    a4[2] = 0.0;
    float64_t v23 = 0.0;
    float64_t v24 = 0.0;
    if (vabdd_f64(1.0, fabs(v21.f64[0])) < 0.0000001)
    {
      *a4 = v21.f64[0];
      float64_t v24 = v21.f64[0];
      a4[1] = 0.0;
      a4[2] = 0.0;
    }
    if (vabdd_f64(1.0, fabs(v21.f64[1])) < 0.0000001)
    {
      *a4 = v24;
      a4[1] = v21.f64[1];
      float64_t v23 = v21.f64[1];
      a4[2] = 0.0;
    }
    if (vabdd_f64(1.0, fabs(v13)) < 0.0000001)
    {
      *a4 = v24;
      a4[1] = v23;
      a4[2] = v13;
    }
    PCVector3<double>::normalize(a4, 0.000000100000001);
    double v26 = *a4;
    double v25 = a4[1];
    double v27 = a4[2];
    double v28 = v25 * 0.0 - v27;
    double v29 = v27 * 0.0 - *a4 * 0.0;
    double v30 = *a4 - v25 * 0.0;
    if (v30 * v30 + v28 * v28 + v29 * v29 <= 0.0)
    {
      *(void *)a5 = 0;
      *(void *)(a5 + 8) = 0;
      *(void *)(a5 + 16) = 0xBFF0000000000000;
    }
    else
    {
      double v31 = v27 * v29 - v25 * v30;
      double v32 = v26 * v30 - v27 * v28;
      double v33 = v25 * v28 - v26 * v29;
      *(double *)a5 = v31;
      *(double *)(a5 + 8) = v32;
      *(double *)(a5 + 16) = v33;
      if (v32 < 0.0)
      {
        *(double *)a5 = -v31;
        *(double *)(a5 + 8) = -v32;
        *(double *)(a5 + 16) = -v33;
      }
      PCVector3<double>::normalize((double *)a5, 0.000000100000001);
    }
  }
}

BOOL PSEmitter::isOrderByRowOrCol(PSEmitter *this)
{
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 19232), MEMORY[0x1E4F1FA48], 0.0) - 7 < 0xFFFFFFFE
    || OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), MEMORY[0x1E4F1FA48], 0.0) == 2)
  {
    return 0;
  }
  int v3 = (const CMTime *)MEMORY[0x1E4F1FA48];
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 21472), MEMORY[0x1E4F1FA48], 0.0);
  unsigned int v5 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 21216), v3, 0.0);
  return (ValueAsInt - 1) < 2 && v5 < 4;
}

BOOL PSEmitter::genPosFilledCircle(uint64_t a1, const CMTime *a2, float64x2_t *a3, uint64_t a4, float64_t a5, float64_t a6)
{
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 23312), a2, 0.0);
  double v9 = v8 * v8;
  v10.f64[0] = a5;
  v10.f64[1] = a6;
  float64x2_t v11 = vaddq_f64(v10, v10);
  __asm { FMOV            V2.2D, #-1.0 }
  float64x2_t v17 = vmulq_n_f64(vaddq_f64(v11, _Q2), v8);
  double v18 = vaddvq_f64(vmulq_f64(v17, v17));
  if (v18 <= v9)
  {
    *a3 = vaddq_f64(v17, *a3);
    a3[1].f64[0] = a3[1].f64[0] + 0.0;
    if (v18 <= -0.0000001 || v18 >= 0.0000001)
    {
      *(float64x2_t *)a4 = v17;
      *(void *)(a4 + 16) = 0;
      PCVector3<double>::normalize((double *)a4, 0.000000100000001);
    }
    else
    {
      *(_OWORD *)a4 = xmmword_1B7E733E0;
      *(void *)(a4 + 16) = 0;
    }
  }
  return v18 <= v9;
}

double PSEmitter::genPosSurfaceSphere(uint64_t a1, const CMTime *a2, float64x2_t *a3, float64x2_t *a4, double *a5, double a6, double a7)
{
  double v12 = a7 + a7 + -1.0;
  double v13 = sqrt(1.0 - v12 * v12);
  __double2 v14 = __sincos_stret(a6 * 6.28318531);
  a4->f64[0] = v14.__cosval * v13;
  a4->f64[1] = -v12;
  a4[1].f64[0] = v14.__sinval * v13;
  *a5 = v12 * -0.0 - v14.__sinval * v13;
  a5[1] = v14.__sinval * v13 * 0.0 + v14.__cosval * v13 * -0.0;
  a5[2] = v14.__cosval * v13 - v12 * -0.0;
  PCVector3<double>::normalize(a5, 0.000000100000001);
  double v15 = sqrt(*a5 * *a5 + a5[1] * a5[1] + a5[2] * a5[2]);
  if (v15 > -0.0000001 && v15 < 0.0000001)
  {
    *a5 = -v14.__sinval;
    a5[1] = 0.0;
    a5[2] = v14.__cosval;
  }
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 23312), a2, 0.0);
  double v17 = v16 * a4[1].f64[0];
  *a3 = vaddq_f64(vmulq_n_f64(*a4, v16), *a3);
  double result = v17 + a3[1].f64[0];
  a3[1].f64[0] = result;
  return result;
}

void PSEmitter::genOrderFilledRect(PSEmitter *this, double a2, double a3, unsigned int a4, unsigned int a5, const CMTime *a6, double *a7, double *a8)
{
  signed int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 21216), a6, 0.0);
  int v17 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 21472), a6, 0.0);
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), MEMORY[0x1E4F1FA48], 0.0) == 2) {
    int v17 = 0;
  }
  if (ValueAsInt == 4)
  {
    double v18 = sqrt((a2 + -0.5 + a2 + -0.5) * (a2 + -0.5 + a2 + -0.5) + (a3 + -0.5 + a3 + -0.5) * (a3 + -0.5 + a3 + -0.5))
        / 1.41421356;
    goto LABEL_28;
  }
  if (v17) {
    BOOL v19 = ValueAsInt == 5;
  }
  else {
    BOOL v19 = 1;
  }
  if (v19 || ValueAsInt == 6 || ValueAsInt == 7 || ValueAsInt == 8)
  {
    if (ValueAsInt > 8)
    {
      double v27 = 1.0;
      double v23 = 0.0;
      double v24 = 0.0;
      double v25 = 0.0;
      double v26 = 0.0;
    }
    else
    {
      double v23 = dbl_1B8387018[ValueAsInt];
      double v24 = dbl_1B8387060[ValueAsInt];
      double v25 = dbl_1B83870A8[ValueAsInt];
      double v26 = dbl_1B83870F0[ValueAsInt];
      double v27 = dbl_1B8387138[ValueAsInt];
    }
    double v18 = (v24 * (a3 - v25) + v23 * (a2 - v26)) / v27;
LABEL_28:
    *a7 = v18;
    double v32 = -1.0;
    if (!a8) {
      return;
    }
LABEL_43:
    *a8 = v32;
    return;
  }
  unsigned int v28 = a4 - 1;
  unsigned int v29 = vcvtmd_s64_f64((double)(a4 - 1) * a2 + 0.5 + 0.0000001);
  unsigned int v30 = a5 - 1;
  unsigned int v31 = vcvtmd_s64_f64((double)(a5 - 1) * a3 + 0.5 + 0.0000001);
  switch(ValueAsInt)
  {
    case 3:
      unsigned int v29 = v28 - v29;
      break;
    case 1:
      unsigned int v29 = v28 - v29;
      unsigned int v31 = v30 - v31;
      break;
    case 0:
      unsigned int v31 = v30 - v31;
      if (v31 >= a5) {
        fwrite("WTH\n", 4uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
      }
      break;
  }
  if (v17 == 1) {
    unsigned int v33 = a4;
  }
  else {
    unsigned int v33 = a5;
  }
  if (v17 == 1) {
    unsigned int v34 = v29;
  }
  else {
    unsigned int v34 = v31;
  }
  if (v17 == 1) {
    unsigned int v35 = v31;
  }
  else {
    unsigned int v35 = v29;
  }
  double v36 = (double)(a5 * a4 - 1);
  double v37 = (double)(v34 + v35 * v33) / v36;
  *a7 = v37;
  if (a8)
  {
    double __y = 0.0;
    modf(v37 * v36 + 0.0001, &__y);
    double v32 = __y;
    goto LABEL_43;
  }
}

CGColorSpace **PSEmitter::initPropertiesFromImage(CGColorSpace **this, float64_t a2, float64_t a3, const CMTime *a4, char a5, int a6, PCColor *a7, float64x2_t *a8)
{
  v8.f64[0] = a2;
  double v9 = this + 4189;
  *(void *)&v10.f64[0] = this[4192];
  if (v10.f64[0] != 0.0 && *((double *)this + 4193) != 0.0)
  {
    if ((a5 & 1) == 0 && (a6 & 1) == 0)
    {
      *(void *)&v10.f64[1] = this[4193];
      v8.f64[1] = a3;
      float64x2_t v15 = vmulq_f64(v10, v8);
      __asm { FMOV            V2.2D, #-0.5 }
      *(int32x2_t *)&v15.f64[0] = vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(v15, (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL)))));
      v21.i64[0] = SLODWORD(v15.f64[0]);
      v21.i64[1] = SHIDWORD(v15.f64[0]);
      int32x2_t v22 = vmovn_s64(vcvtq_s64_f64(vaddq_f64(vcvtq_f64_s64(v21), vmulq_f64(v10, _Q2))));
      v21.i64[0] = v22.i32[0];
      v21.i64[1] = v22.i32[1];
      *a8 = vaddq_f64(*a8, vcvtq_f64_s64(v21));
      a8[1].f64[0] = a8[1].f64[0] + 0.0;
      return this;
    }
    if (*v9)
    {
      double v47 = v8.f64[0];
      OZChannel::getValueAsDouble((OZChannel *)(this + 3400), a4, 0.0);
      unsigned int v24 = vcvtmd_s64_f64(v23 * 255.0 + 0.5 + 0.0000001);
      int v25 = (*(uint64_t (**)(void))(*(void *)*v9 + 16))();
      int v26 = (*(uint64_t (**)(void))(*(void *)*v9 + 24))();
      uint64_t v27 = (*(uint64_t (**)(void))(**((void **)*v9 + 8) + 16))(*((void *)*v9 + 8));
      signed int v28 = (*((_DWORD *)*v9 + 9) * *((_DWORD *)*v9 + 10)) >> 3;
      this = (CGColorSpace **)PCBitmap::getBytesPerRow((PCBitmap *)*v9);
      v29.f64[0] = v47;
      unsigned int v30 = vcvtmd_s64_f64((double)v25 * v47 + 0.0000001);
      unsigned int v31 = vcvtmd_s64_f64((double)v26 * a3 + 0.0000001);
      double v32 = (unsigned __int8 *)(v27
                              + this * (uint64_t)(int)(v31 - (v26 == v31))
                              + v28 * (uint64_t)(int)(v30 - (v25 == v30)));
      if (v24 <= *v32 || (a5 & 1) == 0)
      {
        v29.f64[1] = a3;
        float64x2_t v33 = *(float64x2_t *)(v9 + 3);
        int32x2_t v34 = vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vmulq_f64(v33, v29), (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL)))));
        v35.i64[0] = v34.i32[0];
        v35.i64[1] = v34.i32[1];
        __asm { FMOV            V2.2D, #-0.5 }
        *(int32x2_t *)&v33.f64[0] = vmovn_s64(vcvtq_s64_f64(vaddq_f64(vcvtq_f64_s64(v35), vmulq_f64(v33, _Q2))));
        v35.i64[0] = SLODWORD(v33.f64[0]);
        v35.i64[1] = SHIDWORD(v33.f64[0]);
        *a8 = vaddq_f64(*a8, vcvtq_f64_s64(v35));
        double v37 = a8[1].f64[0] + 0.0;
        a8[1].f64[0] = v37;
        if (a6)
        {
          LOBYTE(v37) = v32[1];
          *(double *)&unint64_t v38 = (double)*(unint64_t *)&v37 / 255.0;
          float v39 = *(double *)&v38;
          LOBYTE(v38) = v32[2];
          *(double *)&unint64_t v40 = (double)v38 / 255.0;
          float v41 = *(double *)&v40;
          LOBYTE(v40) = v32[3];
          *(double *)&unint64_t v42 = (double)v40 / 255.0;
          float v43 = *(double *)&v42;
          LOBYTE(v42) = *v32;
          float v44 = (double)v42 / 255.0;
          PCImage::getColorSpace(*v9, (CGColorSpace **)&v48);
          PCColor::setRGBA(a7 + 2, v39, v41, v43, v44, &v48);
          return PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v48);
        }
        return this;
      }
    }
    else
    {
      this = (CGColorSpace **)OZChanObjectManipRef::getObjectID((OZChannel *)this + 181);
      if (!this) {
        return this;
      }
    }
    uint64_t v45 = MEMORY[0x1E4F1FA48];
    *(_OWORD *)&a7->var0.var1[3] = *MEMORY[0x1E4F1FA48];
    a7->var1._obj = *(CGColorSpace **)(v45 + 16);
  }
  return this;
}

void sub_1B7DC2AF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

float64x2_t PSEmitter::genPosFilledRect(uint64_t a1, const CMTime *a2, float64x2_t *a3, float64_t a4, float64_t a5)
{
  float64_t v19 = 0.0;
  float64_t v20 = 0.0;
  double v18 = 0.0;
  OZChannelScale3D::getValue((OZChannelScale3D *)(a1 + 25392), a2, &v20, &v19, &v18, 0.0);
  v6.f64[0] = a4;
  v6.f64[1] = a5;
  float64x2_t v7 = vaddq_f64(v6, v6);
  v6.f64[0] = v20;
  __asm { FMOV            V2.2D, #-1.0 }
  v6.f64[1] = v19;
  float64x2_t v13 = vmulq_f64(vaddq_f64(v7, _Q2), v6);
  __asm { FMOV            V1.2D, #0.5 }
  float64x2_t result = vaddq_f64(*a3, vmulq_f64(v13, _Q1));
  *a3 = result;
  return result;
}

void PSEmitter::genOrderRadial(PSEmitter *this, double a2, int a3, const CMTime *a4, double *a5, double *a6)
{
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 22752), a4, 0.0);
  double v11 = 1.0 - a2;
  if (ValueAsInt != 1) {
    double v11 = a2;
  }
  *a5 = v11;
  if (a6)
  {
    double __y = 0.0;
    modf(v11 * (double)(a3 - 1) + 0.0001, &__y);
    *a6 = __y;
  }
}

float64x2_t PSEmitter::genPosRadial(uint64_t a1, const CMTime *a2, uint64_t a3, uint64_t a4, double a5, double a6)
{
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 23312), a2, 0.0);
  double v13 = v12;
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 25984), a2, 0.0);
  double v15 = floor((double)ValueAsInt * a6 + 0.01 + 0.0000001) / (double)ValueAsInt;
  double v16 = v13 * a5;
  if (v15 <= (double)ValueAsInt) {
    double v17 = (v15 + v15) * 3.14159265;
  }
  else {
    double v17 = 0.0;
  }
  __double2 v18 = __sincos_stret(v17);
  *(double *)a4 = v16 * v18.__sinval;
  *(double *)(a4 + 8) = -(v16 * v18.__cosval);
  *(void *)(a4 + 16) = 0;
  PCVector3<double>::normalize((double *)a4, 0.000000100000001);
  *(double *)a3 = *(double *)a3 + v16 * v18.__cosval;
  float64x2_t result = vaddq_f64(*(float64x2_t *)(a3 + 8), (float64x2_t)COERCE_UNSIGNED_INT64(v16 * v18.__sinval));
  *(float64x2_t *)(a3 + 8) = result;
  return result;
}

float64x2_t PSEmitter::genPosSpiral(uint64_t a1, const CMTime *a2, float64x2_t *a3, uint64_t a4, double a5, double a6)
{
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 23312), a2, 0.0);
  double v13 = v12;
  double ValueAsInt = (double)(int)OZChannel::getValueAsInt((OZChannel *)(a1 + 25984), a2, 0.0);
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 26288), a2, 0.0);
  double v15 = floor(ValueAsInt * a6 + 0.01 + 0.0000001);
  double v17 = v16 * 6.28318531 * a5;
  __double2 v18 = __sincos_stret(v17 + (v15 / ValueAsInt + v15 / ValueAsInt) * 3.14159265);
  *(double *)a4 = v13 * v18.__sinval + v17 * (v13 * v18.__cosval);
  *(double *)(a4 + 8) = -(v13 * v18.__cosval - v17 * (v13 * v18.__sinval));
  *(void *)(a4 + 16) = 0;
  PCVector3<double>::normalize((double *)a4, 0.000000100000001);
  v19.f64[0] = v18.__cosval;
  v19.f64[1] = v18.__sinval;
  float64x2_t result = vaddq_f64(*a3, vmulq_n_f64(v19, v13 * a5));
  *a3 = result;
  return result;
}

uint64_t PSEmitter::getOrderLength(PSEmitter *this, const CMTime *a2)
{
  uint64_t v2 = (_DWORD *)((char *)this + 33584);
  uint64_t v3 = *((unsigned int *)this + 8396);
  if ((v3 & 0x80000000) != 0)
  {
    _DWORD *v2 = 0;
    int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19232), a2, 0.0);
    unsigned int v7 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), a2, 0.0);
    if (!ValueAsInt)
    {
      uint64_t v3 = 1;
LABEL_19:
      _DWORD *v2 = v3;
      return v3;
    }
    unsigned int v8 = ValueAsInt - 5;
    BOOL v10 = ValueAsInt == 2 || v8 < 2;
    if (v10 && v7 == 0)
    {
      uint64_t v13 = 20152;
LABEL_17:
      uint64_t NumEmissionPoints = OZChannel::getValueAsInt((OZChannel *)((char *)this + v13), a2, 0.0);
      goto LABEL_18;
    }
    if (ValueAsInt == 4)
    {
      uint64_t NumEmissionPoints = PSEmitter::getNumEmissionPoints(this, a2);
LABEL_18:
      uint64_t v3 = NumEmissionPoints;
      goto LABEL_19;
    }
    if ((ValueAsInt & 0xFFFFFFF7) == 1)
    {
      uint64_t v3 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 20152), a2, 0.0);
      if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 22240), a2, 0.0) == 2) {
        LODWORD(v3) = vcvtpd_s64_f64((double)(int)v3 * 0.5);
      }
      goto LABEL_19;
    }
    if (v7 != 2) {
      BOOL v10 = 0;
    }
    if (v10)
    {
      OZChannel::getValueAsInt((OZChannel *)((char *)this + 20152), a2, 0.0);
      OZChannel::getValueAsInt((OZChannel *)((char *)this + 31784), a2, 0.0);
      operator new[]();
    }
    if (v8 > 1)
    {
      if (ValueAsInt == 11 && v7 < 2 || ValueAsInt == 10 && v7 == 1)
      {
        int v17 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 21728), a2, 0.0);
        if (PSEmitter::isOrderByRowColStack(this))
        {
          int v18 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 20304), a2, 0.0);
          int v19 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 20456), a2, 0.0) * v18;
          uint64_t v3 = v19 * OZChannel::getValueAsInt((OZChannel *)((char *)this + 20608), a2, 0.0);
          goto LABEL_19;
        }
        unsigned int v20 = v17 & 0xFFFFFFFE;
        if ((v17 & 0xFFFFFFFE) == 0xC)
        {
          uint64_t v13 = 20608;
          goto LABEL_17;
        }
        if (v20 == 10) {
          goto LABEL_47;
        }
        if (v20 != 8)
        {
          OZChannel::getValueAsInt((OZChannel *)((char *)this + 20304), a2, 0.0);
          OZChannel::getValueAsInt((OZChannel *)((char *)this + 20456), a2, 0.0);
          OZChannel::getValueAsInt((OZChannel *)((char *)this + 20608), a2, 0.0);
          operator new[]();
        }
      }
      else
      {
        if ((ValueAsInt & 0xFFFFFFFE) == 0xA && v7 == 2)
        {
          OZChannel::getValueAsInt((OZChannel *)((char *)this + 20152), a2, 0.0);
          OZChannel::getValueAsInt((OZChannel *)((char *)this + 31784), a2, 0.0);
          operator new[]();
        }
        if (ValueAsInt == 2 && v7 == 1)
        {
          OZChannel::getValueAsInt((OZChannel *)((char *)this + 20304), a2, 0.0);
          OZChannel::getValueAsInt((OZChannel *)((char *)this + 20456), a2, 0.0);
          operator new[]();
        }
        if (ValueAsInt != 10 || v7)
        {
          if ((ValueAsInt - 7) > 1)
          {
            uint64_t v3 = 0;
            goto LABEL_19;
          }
          uint64_t v13 = 26136;
          goto LABEL_17;
        }
      }
    }
    else
    {
      int v15 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 21216), a2, 0.0);
      if (PSEmitter::isOrderByRowOrCol(this))
      {
        int v16 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 20304), a2, 0.0);
        uint64_t v3 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 20456), a2, 0.0) * v16;
        goto LABEL_19;
      }
      if ((v15 - 5) > 1)
      {
        if ((v15 - 7) > 1)
        {
          OZChannel::getValueAsInt((OZChannel *)((char *)this + 20304), a2, 0.0);
          OZChannel::getValueAsInt((OZChannel *)((char *)this + 20456), a2, 0.0);
          operator new[]();
        }
LABEL_47:
        uint64_t v13 = 20456;
        goto LABEL_17;
      }
    }
    uint64_t v13 = 20304;
    goto LABEL_17;
  }
  return v3;
}

uint64_t PSEmitter::shuffleOrder(PSEmitter *this, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a3 >= 2)
  {
    unsigned int v7 = (void *)((char *)this + 33664);
    unsigned int v8 = (PCMutex *)((char *)this + 33592);
    PCMutex::lock((PCMutex *)((char *)this + 33592));
    if (v7[1] != __PAIR64__(a4, a3))
    {
      if (*v7) {
        MEMORY[0x1BA9BFB70](*v7, 0x1000C8052888210);
      }
      *unsigned int v7 = 0;
      operator new[]();
    }
    a2 = *(unsigned int *)(*v7 + 4 * a2);
    PCMutex::unlock(v8);
  }
  return a2;
}

uint64_t PSEmitter::canAlignRotation(PSEmitter *this, const CMTime *a2)
{
  unsigned int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19232), a2, 0.0);
  int v5 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), a2, 0.0);
  if (ValueAsInt == 1) {
    return 1;
  }
  unsigned int v7 = (0x390u >> ValueAsInt) & 1;
  if (ValueAsInt > 9) {
    unsigned int v7 = 0;
  }
  if (v5) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = ValueAsInt == 10;
  }
  if (v8) {
    unsigned int v7 = 1;
  }
  if (((ValueAsInt & 0xFFFFFFFB) == 2 || ValueAsInt == 5 || ValueAsInt == 11) && v5 == 0) {
    return 1;
  }
  else {
    return v7;
  }
}

uint64_t PSEmitter::getNumEmissionPoints(PSEmitter *this, const CMTime *a2)
{
  uint64_t result = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 592))(this);
  if (!result) {
    return result;
  }
  unsigned int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19232), a2, 0.0);
  if (!ValueAsInt) {
    return 1;
  }
  unsigned int v6 = ValueAsInt;
  int v7 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), a2, 0.0);
  if ((v6 & 0xFFFFFFF7) == 1) {
    goto LABEL_13;
  }
  if (v6 <= 6 && ((1 << v6) & 0x64) != 0)
  {
    if ((v7 & 0xFFFFFFFD) == 0) {
      goto LABEL_13;
    }
  }
  else if (v6 - 7 <= 1)
  {
    int v8 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 26136), a2, 0.0);
    uint64_t v9 = 25984;
    return OZChannel::getValueAsInt((OZChannel *)((char *)this + v9), a2, 0.0) * v8;
  }
  if (v6 == 4)
  {
LABEL_13:
    return OZChannel::getValueAsInt((OZChannel *)((char *)this + 20152), a2, 0.0);
  }
  if ((v6 & 0xFFFFFFFE) != 0xA)
  {
    int v8 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 20304), a2, 0.0);
    uint64_t v9 = 20456;
    return OZChannel::getValueAsInt((OZChannel *)((char *)this + v9), a2, 0.0) * v8;
  }
  if (v7)
  {
    if (v7 != 2)
    {
      if (v7 != 1) {
        return 0;
      }
      int v10 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 20304), a2, 0.0);
      int v11 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 20456), a2, 0.0) * v10;
      return v11 * OZChannel::getValueAsInt((OZChannel *)((char *)this + 20608), a2, 0.0);
    }
    goto LABEL_13;
  }
  int v12 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 20304), a2, 0.0);
  int v13 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 20456), a2, 0.0);
  int v14 = v13;
  if (v6 != 11) {
    return (v13 * v12);
  }
  int v15 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 20608), a2, 0.0);
  if (v12 <= 2) {
    int v16 = 2;
  }
  else {
    int v16 = v12;
  }
  int v17 = v16 - 2;
  if (v14 <= 2) {
    int v18 = 2;
  }
  else {
    int v18 = v14;
  }
  int v19 = v18 - 2;
  if (v15 <= 2) {
    int v20 = 2;
  }
  else {
    int v20 = v15;
  }
  return (v14 * v12 * v15 - v19 * v17 * (v20 - 2));
}

BOOL PSEmitter::shouldDrawEmissionPoints(PSEmitter *this)
{
  return PSEmitter::getEmitAtPoints(this)
      || OZChannel::getValueAsInt((OZChannel *)((char *)this + 19232), MEMORY[0x1E4F1FA48], 0.0) == 0;
}

void PSEmitter::getSourceBitmap(int a1, void *a2, OZRenderParams *a3)
{
  OZRenderParams::OZRenderParams((OZRenderParams *)&v16, a3);
  OZRenderParams::setImageType((uint64_t)&v16, 1);
  char v18 = 1;
  long long v19 = 0u;
  long long v20 = 0u;
  __asm { FMOV            V0.2D, #1.0 }
  v13[0] = _Q0;
  OZRenderParams::setResolution(&v16, v13);
  int v17 = a2;
  v16.var5 = (PCString *)0x3FF0000000000000;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v10 = *a2;
  if (v11)
  {
    v16.var7 = (unint64_t)v11;
    (*(void (**)(void *))(*(void *)v11 + 1328))(v11);
    uint64_t v10 = *a2;
  }
  v14[1] = 0;
  v14[0] = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  long long v15 = _Q0;
  (*(void (**)(void *, void *, OZRenderParams *))(v10 + 16))(a2, v14, a3);
  operator new();
}

void sub_1B7DC4A14(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  PCSharedCount::~PCSharedCount((PCSharedCount *)&STACK[0x338]);
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray((uint64_t)&a37);
  std::__list_imp<unsigned int>::clear(&a17);
  LiGraphBuilder::~LiGraphBuilder((LiGraphBuilder *)&a68);
  Render360GroupAsEquirectSentry::~Render360GroupAsEquirectSentry((Render360GroupAsEquirectSentry *)&STACK[0x350]);
  PCSharedCount::~PCSharedCount(v69);
  if (a2 == 2)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 != 1)
    {
      if (STACK[0x3B8]) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)STACK[0x3B8]);
      }
      PCSharedCount::~PCSharedCount(v68);
      OZRenderParams::~OZRenderParams((OZRenderParams *)&STACK[0x3F0]);
      _Unwind_Resume(a1);
    }
    double v72 = __cxa_begin_catch(a1);
    (*(void (**)(void *))(*(void *)v72 + 40))(v72);
    __cxa_end_catch();
  }
  JUMPOUT(0x1B7DC49D4);
}

void PSEmitter::buildLighting(PSEmitter *this, LiGeode *a2, const LiLightSet *a3, const OZRenderParams *a4)
{
  int v8 = (char *)this + 33708;
  char v9 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 168))(this);
  if (v8[4])
  {
    int ValueAsInt = *(_DWORD *)v8;
  }
  else
  {
    int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 32944), MEMORY[0x1E4F1FA48], 0.0);
    *(_DWORD *)int v8 = ValueAsInt;
    v8[4] = 1;
  }
  if (ValueAsInt) {
    char v11 = v9;
  }
  else {
    char v11 = 0;
  }
  if ((v11 & 1) == 0)
  {
    OZElement::buildLighting((OZElement *)((char *)this + 200), a2, a3, a4);
  }
}

void non-virtual thunk to'PSEmitter::buildLighting(PSEmitter *this, LiGeode *a2, const LiLightSet *a3, const OZRenderParams *a4)
{
}

double PSEmitter::setShadowBounds(PSEmitter *this, const OZRenderState *a2, LiMaterialProperties *a3, const LiGeode *a4)
{
  int v8 = (char *)this + 33708;
  char v9 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 168))(this);
  if (v8[4])
  {
    int ValueAsInt = *(_DWORD *)v8;
  }
  else
  {
    int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 32944), MEMORY[0x1E4F1FA48], 0.0);
    *(_DWORD *)int v8 = ValueAsInt;
    v8[4] = 1;
  }
  if (ValueAsInt) {
    char v12 = 1;
  }
  else {
    char v12 = v9;
  }
  if ((v12 & 1) == 0)
  {
    *(void *)&double result = OZElement::setShadowBounds((uint64_t)this + 200, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4).n128_u64[0];
  }
  return result;
}

double non-virtual thunk to'PSEmitter::setShadowBounds(PSEmitter *this, const OZRenderState *a2, LiMaterialProperties *a3, const LiGeode *a4)
{
  return PSEmitter::setShadowBounds((PSEmitter *)((char *)this - 200), a2, a3, a4);
}

uint64_t PSEmitter::isValidLightClipPlane(PSEmitter *this)
{
  uint64_t v1 = (OZElement *)((char *)this + 200);
  int v2 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 168))(this);
  return OZElement::isValidLightClipPlane(v1) & (v2 ^ 1);
}

uint64_t non-virtual thunk to'PSEmitter::isValidLightClipPlane(PSEmitter *this)
{
  int v2 = (*(uint64_t (**)(void))(*((void *)this - 25) + 168))();
  return OZElement::isValidLightClipPlane((OZElement *)this) & (v2 ^ 1);
}

uint64_t PSEmitter::isPrecomposed(PSEmitter *this, const CMTime *a2)
{
  uint64_t result = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 168))(this);
  if (result)
  {
    return PSEmitter::shouldPrecompose(this, a2);
  }
  return result;
}

uint64_t non-virtual thunk to'PSEmitter::isPrecomposed(PSEmitter *this, const CMTime *a2)
{
  uint64_t v3 = (PSEmitter *)((char *)this - 200);
  uint64_t result = (*(uint64_t (**)(char *))(*((void *)this - 25) + 168))((char *)this - 200);
  if (result)
  {
    return PSEmitter::shouldPrecompose(v3, a2);
  }
  return result;
}

uint64_t PSEmitter::isFlattened(PSEmitter *this)
{
  return (*(unsigned int (**)(PSEmitter *))(*(void *)this + 168))(this) ^ 1;
}

uint64_t non-virtual thunk to'PSEmitter::isFlattened(PSEmitter *this)
{
  return (*(unsigned int (**)(void))(*((void *)this - 25) + 168))() ^ 1;
}

uint64_t PSEmitter::openMedia(PSEmitter *this)
{
  uint64_t v2 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 256))(this);
  uint64_t v3 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 264))(this);
  if (v2 != v3)
  {
    uint64_t v4 = v3;
    do
    {
      int v5 = *(void **)(v2 + 16);
      if (v5) {
      (*(void (**)(void *))(*(void *)v5 + 104))(v5);
      }
      uint64_t v2 = *(void *)(v2 + 8);
    }
    while (v2 != v4);
  }
  return 0;
}

uint64_t non-virtual thunk to'PSEmitter::openMedia(PSEmitter *this)
{
  return 0;
}

uint64_t PSEmitter::prerollBegin(void *a1, CMTime *a2, uint64_t a3, uint64_t a4, double a5)
{
  OZSceneNode::prerollBegin((uint64_t)(a1 + 25), (uint64_t)a2, a3, a4, a5);
  uint64_t v8 = (*(uint64_t (**)(void *))(*a1 + 256))(a1);
  uint64_t v9 = (*(uint64_t (**)(void *))(*a1 + 264))(a1);
  if (v8 != v9)
  {
    uint64_t v10 = v9;
    do
    {
      char v11 = *(const void **)(v8 + 16);
      if (v11) {
      else
      }
        char v12 = 0;
      unint64_t v13 = a1[26];
      long long v21 = xmmword_1B837FEB0;
      char isKindOfClass = OZFactory::isKindOfClass(v13, (int32x4_t *)&v21);
      CMTime v20 = *a2;
      int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(v12 + 10272), &v20, 0.0);
      CMTime v20 = *a2;
      OZChannel::getValueAsDouble((OZChannel *)(v12 + 10576), &v20, 0.0);
      if ((isKindOfClass & 1) == 0 && !ValueAsInt && v16 == 0.0) {
        (*(void (**)(char *, CMTime *, uint64_t, uint64_t, double))(*(void *)v12 + 112))(v12, a2, a3, a4, a5);
      }
      uint64_t v8 = *(void *)(v8 + 8);
    }
    while (v8 != v10);
  }
  return 0;
}

uint64_t non-virtual thunk to'PSEmitter::prerollBegin(uint64_t a1, CMTime *a2, uint64_t a3, uint64_t a4, double a5)
{
  return 0;
}

uint64_t PSEmitter::prerollEnd(PSEmitter *this, const OZRenderParams *a2, PMFrameRequest *a3)
{
  OZSceneNode::prerollEnd((uint64_t)this + 200, (uint64_t)a2, (uint64_t)a3);
  uint64_t v4 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 256))(this);
  uint64_t v5 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 264))(this);
  if (v4 != v5)
  {
    uint64_t v6 = v5;
    int v7 = (const CMTime *)MEMORY[0x1E4F1FA48];
    do
    {
      uint64_t v8 = *(const void **)(v4 + 16);
      if (v8) {
      else
      }
        uint64_t v9 = 0;
      unint64_t v10 = *((void *)this + 26);
      long long v17 = xmmword_1B837FEB0;
      char isKindOfClass = OZFactory::isKindOfClass(v10, (int32x4_t *)&v17);
      int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(v9 + 10272), v7, 0.0);
      OZChannel::getValueAsDouble((OZChannel *)(v9 + 10576), v7, 0.0);
      if ((isKindOfClass & 1) == 0 && !ValueAsInt && v13 == 0.0) {
        (*(void (**)(char *, const OZRenderParams *, PMFrameRequest *))(*(void *)v9 + 120))(v9, a2, a3);
      }
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4 != v6);
  }
  return 0;
}

uint64_t non-virtual thunk to'PSEmitter::prerollEnd(PSEmitter *this, const OZRenderParams *a2, PMFrameRequest *a3)
{
  return 0;
}

uint64_t PSEmitter::setRate(PSEmitter *this, CMTime *a2, PMFrameRequest *a3, double a4)
{
  OZSceneNode::setRate((uint64_t)this + 200, (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t v7 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 256))(this);
  uint64_t v8 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 264))(this);
  if (v7 != v8)
  {
    uint64_t v9 = v8;
    do
    {
      unint64_t v10 = *(const void **)(v7 + 16);
      if (v10) {
      else
      }
        char v11 = 0;
      unint64_t v12 = *((void *)this + 26);
      long long v19 = xmmword_1B837FEB0;
      char isKindOfClass = OZFactory::isKindOfClass(v12, (int32x4_t *)&v19);
      CMTime v18 = *a2;
      int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(v11 + 10272), &v18, 0.0);
      CMTime v18 = *a2;
      OZChannel::getValueAsDouble((OZChannel *)(v11 + 10576), &v18, 0.0);
      if ((isKindOfClass & 1) == 0 && !ValueAsInt && v15 == 0.0) {
        (*(void (**)(char *, CMTime *, PMFrameRequest *, double))(*(void *)v11 + 128))(v11, a2, a3, a4);
      }
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7 != v9);
  }
  return 0;
}

uint64_t non-virtual thunk to'PSEmitter::setRate(PSEmitter *this, CMTime *a2, PMFrameRequest *a3, double a4)
{
  return 0;
}

uint64_t PSEmitter::scheduleTokens(void *a1, CMTime *a2, long long **a3, uint64_t a4, uint64_t a5)
{
  memset(v22, 0, sizeof(v22));
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__init_with_size[abi:ne180100]<std::pair<CMTime,std::vector<CMTime>>*,std::pair<CMTime,std::vector<CMTime>>*>(v22, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (a3[1] - *a3));
  (*(void (**)(void *, CMTime *, void *, uint64_t))(a1[25] + 184))(a1 + 25, a2, v22, a4);
  OZSceneNode::scheduleTokens((uint64_t)(a1 + 25), (uint64_t)a2, (uint64_t)v22, a4, a5);
  uint64_t v9 = (*(uint64_t (**)(void *))(*a1 + 256))(a1);
  for (i = (*(uint64_t (**)(void *))(*a1 + 264))(a1); v9 != i; uint64_t v9 = *(void *)(v9 + 8))
  {
    char v11 = *(const void **)(v9 + 16);
    if (v11) {
    else
    }
      unint64_t v12 = 0;
    unint64_t v13 = a1[26];
    int32x4_t v21 = (int32x4_t)xmmword_1B837FEB0;
    char isKindOfClass = OZFactory::isKindOfClass(v13, &v21);
    CMTime v20 = *a2;
    int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(v12 + 10272), &v20, 0.0);
    CMTime v20 = *a2;
    OZChannel::getValueAsDouble((OZChannel *)(v12 + 10576), &v20, 0.0);
    if (ValueAsInt) {
      char v17 = 1;
    }
    else {
      char v17 = isKindOfClass;
    }
    if ((v17 & 1) == 0 && v16 == 0.0)
    {
      if (a5)
      {
        memset(&v20, 0, sizeof(v20));
        (*(void (**)(char *, CMTime *, void *, uint64_t, CMTime *))(*(void *)v12 + 136))(v12, a2, v22, a4, &v20);
        value = (void *)v20.value;
        if (v20.value != *(void *)&v20.timescale)
        {
          std::vector<unsigned long>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned long *>,std::__wrap_iter<unsigned long *>>(a5, *(void *)(a5 + 8), (char *)v20.value, *(char **)&v20.timescale, (*(void *)&v20.timescale - v20.value) >> 3);
          value = (void *)v20.value;
        }
        if (value)
        {
          *(void *)&v20.timescale = value;
          operator delete(value);
        }
      }
      else
      {
        (*(void (**)(char *, CMTime *, void *, uint64_t, void))(*(void *)v12 + 136))(v12, a2, v22, a4, 0);
      }
    }
  }
  v20.value = (CMTimeValue)v22;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v20);
  return 0;
}

void sub_1B7DC5B1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  __p = &a20;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'PSEmitter::scheduleTokens(uint64_t a1, CMTime *a2, long long **a3, uint64_t a4, uint64_t a5)
{
  return 0;
}

uint64_t PSEmitter::hintTokensWillImage(void *a1, CMTime *a2, long long **a3, uint64_t a4)
{
  memset(v20, 0, sizeof(v20));
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__init_with_size[abi:ne180100]<std::pair<CMTime,std::vector<CMTime>>*,std::pair<CMTime,std::vector<CMTime>>*>(v20, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (a3[1] - *a3));
  (*(void (**)(void *, CMTime *, void *, uint64_t))(a1[25] + 184))(a1 + 25, a2, v20, a4);
  OZSceneNode::hintTokensWillImage((uint64_t)(a1 + 25), (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t v8 = (*(uint64_t (**)(void *))(*a1 + 256))(a1);
  for (i = (*(uint64_t (**)(void *))(*a1 + 264))(a1); v8 != i; uint64_t v8 = *(void *)(v8 + 8))
  {
    unint64_t v10 = *(const void **)(v8 + 16);
    if (v10) {
    else
    }
      char v11 = 0;
    unint64_t v12 = a1[26];
    int32x4_t v19 = (int32x4_t)xmmword_1B837FEB0;
    char isKindOfClass = OZFactory::isKindOfClass(v12, &v19);
    CMTime v18 = *a2;
    int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(v11 + 10272), &v18, 0.0);
    CMTime v18 = *a2;
    OZChannel::getValueAsDouble((OZChannel *)(v11 + 10576), &v18, 0.0);
    if (ValueAsInt) {
      char v16 = 1;
    }
    else {
      char v16 = isKindOfClass;
    }
    if ((v16 & 1) == 0 && v15 == 0.0) {
      (*(void (**)(char *, CMTime *, long long **, uint64_t))(*(void *)v11 + 144))(v11, a2, a3, a4);
    }
  }
  v18.value = (CMTimeValue)v20;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v18);
  return 0;
}

void sub_1B7DC5DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  a13 = (void **)&a20;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100](&a13);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'PSEmitter::hintTokensWillImage(uint64_t a1, CMTime *a2, long long **a3, uint64_t a4)
{
  return 0;
}

uint64_t PSEmitter::getTokensImage(void *a1, CMTime *a2, long long **a3, uint64_t a4)
{
  memset(v20, 0, sizeof(v20));
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__init_with_size[abi:ne180100]<std::pair<CMTime,std::vector<CMTime>>*,std::pair<CMTime,std::vector<CMTime>>*>(v20, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (a3[1] - *a3));
  (*(void (**)(void *, CMTime *, void *, uint64_t))(a1[25] + 184))(a1 + 25, a2, v20, a4);
  OZSceneNode::getTokensImage((uint64_t)(a1 + 25), (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t v8 = (*(uint64_t (**)(void *))(*a1 + 256))(a1);
  for (i = (*(uint64_t (**)(void *))(*a1 + 264))(a1); v8 != i; uint64_t v8 = *(void *)(v8 + 8))
  {
    unint64_t v10 = *(const void **)(v8 + 16);
    if (v10) {
    else
    }
      char v11 = 0;
    unint64_t v12 = a1[26];
    int32x4_t v19 = (int32x4_t)xmmword_1B837FEB0;
    char isKindOfClass = OZFactory::isKindOfClass(v12, &v19);
    CMTime v18 = *a2;
    int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(v11 + 10272), &v18, 0.0);
    CMTime v18 = *a2;
    OZChannel::getValueAsDouble((OZChannel *)(v11 + 10576), &v18, 0.0);
    if (ValueAsInt) {
      char v16 = 1;
    }
    else {
      char v16 = isKindOfClass;
    }
    if ((v16 & 1) == 0 && v15 == 0.0) {
      (*(void (**)(char *, CMTime *, long long **, uint64_t))(*(void *)v11 + 152))(v11, a2, a3, a4);
    }
  }
  v18.value = (CMTimeValue)v20;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v18);
  return 0;
}

void sub_1B7DC60B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  a13 = (void **)&a20;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100](&a13);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'PSEmitter::getTokensImage(uint64_t a1, CMTime *a2, long long **a3, uint64_t a4)
{
  return 0;
}

void PSEmitter::pruneTokensAtTime(PSEmitter *this, CMTime *a2, const char *a3)
{
  CMTime v18 = *a2;
  OZSceneNode::pruneTokensAtTime((uint64_t)this + 200, &v18, a3);
  uint64_t v5 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 256))(this);
  uint64_t v6 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 264))(this);
  if (v5 != v6)
  {
    uint64_t v7 = v6;
    do
    {
      uint64_t v8 = *(const void **)(v5 + 16);
      if (v8) {
      else
      }
        uint64_t v9 = 0;
      unint64_t v10 = *((void *)this + 26);
      long long v17 = xmmword_1B837FEB0;
      char isKindOfClass = OZFactory::isKindOfClass(v10, (int32x4_t *)&v17);
      int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(v9 + 10272), a2, 0.0);
      OZChannel::getValueAsDouble((OZChannel *)(v9 + 10576), a2, 0.0);
      if ((isKindOfClass & 1) == 0 && !ValueAsInt && v13 == 0.0)
      {
        long long v15 = *(_OWORD *)&a2->value;
        CMTimeEpoch epoch = a2->epoch;
        (*(void (**)(char *, long long *, const char *))(*(void *)v9 + 160))(v9, &v15, a3);
      }
      uint64_t v5 = *(void *)(v5 + 8);
    }
    while (v5 != v7);
  }
}

void non-virtual thunk to'PSEmitter::pruneTokensAtTime(PSEmitter *this, CMTime *a2, const char *a3)
{
}

void PSEmitter::pruneTokensExceptAtTime(PSEmitter *this, CMTime *a2, const char *a3)
{
  CMTime v18 = *a2;
  OZSceneNode::pruneTokensExceptAtTime((uint64_t)this + 200, &v18, a3);
  uint64_t v5 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 256))(this);
  uint64_t v6 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 264))(this);
  if (v5 != v6)
  {
    uint64_t v7 = v6;
    do
    {
      uint64_t v8 = *(const void **)(v5 + 16);
      if (v8) {
      else
      }
        uint64_t v9 = 0;
      unint64_t v10 = *((void *)this + 26);
      long long v17 = xmmword_1B837FEB0;
      char isKindOfClass = OZFactory::isKindOfClass(v10, (int32x4_t *)&v17);
      int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(v9 + 10272), a2, 0.0);
      OZChannel::getValueAsDouble((OZChannel *)(v9 + 10576), a2, 0.0);
      if ((isKindOfClass & 1) == 0 && !ValueAsInt && v13 == 0.0)
      {
        long long v15 = *(_OWORD *)&a2->value;
        CMTimeEpoch epoch = a2->epoch;
        (*(void (**)(char *, long long *, const char *))(*(void *)v9 + 168))(v9, &v15, a3);
      }
      uint64_t v5 = *(void *)(v5 + 8);
    }
    while (v5 != v7);
  }
}

void non-virtual thunk to'PSEmitter::pruneTokensExceptAtTime(PSEmitter *this, CMTime *a2, const char *a3)
{
}

void PSEmitter::pruneAllTokens(PSEmitter *this, const char *a2)
{
  OZSceneNode::pruneAllTokens((uint64_t)this + 200, a2);
  uint64_t v3 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 256))(this);
  uint64_t v4 = (*(uint64_t (**)(PSEmitter *))(*(void *)this + 264))(this);
  if (v3 != v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = (const CMTime *)MEMORY[0x1E4F1FA48];
    do
    {
      uint64_t v7 = *(const void **)(v3 + 16);
      if (v7) {
      else
      }
        uint64_t v8 = 0;
      unint64_t v9 = *((void *)this + 26);
      long long v14 = xmmword_1B837FEB0;
      char isKindOfClass = OZFactory::isKindOfClass(v9, (int32x4_t *)&v14);
      int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(v8 + 10272), v6, 0.0);
      OZChannel::getValueAsDouble((OZChannel *)(v8 + 10576), v6, 0.0);
      if ((isKindOfClass & 1) == 0 && !ValueAsInt && v12 == 0.0) {
        (*(void (**)(char *, const char *))(*(void *)v8 + 176))(v8, a2);
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v5);
  }
}

void non-virtual thunk to'PSEmitter::pruneAllTokens(PSEmitter *this, const char *a2)
{
}

PSEmitter::RenderParams *PSEmitter::RenderParams::RenderParams(PSEmitter::RenderParams *this, const OZRenderParams *a2)
{
  *((void *)this + 1) = a2;
  uint64_t v3 = (_OWORD *)((char *)this + 16);
  OZRenderParams::OZRenderParams((PSEmitter::RenderParams *)((char *)this + 16), a2);
  LiClipSet::LiClipSet((PSEmitter::RenderParams *)((char *)this + 1440));
  *((void *)this + 203) = 0x3FF0000000000000;
  *((void *)this + 198) = 0x3FF0000000000000;
  *((void *)this + 193) = 0x3FF0000000000000;
  *((void *)this + 188) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1512) = 0u;
  *(_OWORD *)((char *)this + 1528) = 0u;
  *((_OWORD *)this + 97) = 0u;
  *((_OWORD *)this + 98) = 0u;
  *(_OWORD *)((char *)this + 1592) = 0u;
  *(_OWORD *)((char *)this + 1608) = 0u;
  *((void *)this + 219) = 0x3FF0000000000000;
  *((void *)this + 214) = 0x3FF0000000000000;
  *((void *)this + 209) = 0x3FF0000000000000;
  *((void *)this + 204) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1640) = 0u;
  *(_OWORD *)((char *)this + 1656) = 0u;
  *((_OWORD *)this + 105) = 0u;
  *((_OWORD *)this + 106) = 0u;
  *(_OWORD *)((char *)this + 1736) = 0u;
  *(_OWORD *)((char *)this + 1720) = 0u;
  *((void *)this + 228) = 0;
  *((_OWORD *)this + 113) = 0u;
  *((_OWORD *)this + 112) = 0u;
  *((_OWORD *)this + 111) = 0u;
  *((_OWORD *)this + 110) = 0u;
  OZRenderParams::setImageType((uint64_t)v3, 2);
  *((unsigned char *)this + 376) = 1;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  __asm { FMOV            V0.2D, #1.0 }
  long long v10 = _Q0;
  OZRenderParams::setResolution(v3, &v10);
  return this;
}

void sub_1B7DC67CC(_Unwind_Exception *a1)
{
  OZRenderParams::~OZRenderParams(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::getErrorDisplayName(PSEmitter *this)
{
  return OZObjectManipulator::getName((PSEmitter *)((char *)this + 216));
}

uint64_t PSEmitter::PSEmitter_emitPatternChanImpl::getInstance(PSEmitter::PSEmitter_emitPatternChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_emitPatternChanImpl::getInstance(void)::PSEmitter_emitPatternChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    uint64_t v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_emitPatternChanImpl::getInstance(void)::PSEmitter_emitPatternChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_emitPatternChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_emitPatternChanImpl::_PSEmitter_emitPatternChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_emitPatternChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_emitPatternChanImpl::_PSEmitter_emitPatternChan) {
    operator new();
  }
}

void sub_1B7DC68B0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_emitPatternChanImpl::PSEmitter_emitPatternChanImpl(PSEmitter::PSEmitter_emitPatternChanImpl *this)
{
}

void sub_1B7DC6984(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_numPointsChanImpl::getInstance(PSEmitter::PSEmitter_numPointsChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_numPointsChanImpl::getInstance(void)::PSEmitter_numPointsChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    uint64_t v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_numPointsChanImpl::getInstance(void)::PSEmitter_numPointsChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_numPointsChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_numPointsChanImpl::_PSEmitter_numPointsChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_numPointsChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_numPointsChanImpl::_PSEmitter_numPointsChan) {
    operator new();
  }
}

void sub_1B7DC6A60(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_numPointsChanImpl::PSEmitter_numPointsChanImpl(OZChannelUint32 *this)
{
}

void sub_1B7DC6B34(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_numPointsChanInfo::getInstance(PSEmitter::PSEmitter_numPointsChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_numPointsChanInfo::getInstance(void)::PSEmitter_numPointsChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    uint64_t v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_numPointsChanInfo::getInstance(void)::PSEmitter_numPointsChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_numPointsChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_numPointsChanInfo::_PSEmitter_numPointsChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_numPointsChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_numPointsChanInfo::_PSEmitter_numPointsChanInfo) {
    operator new();
  }
}

void sub_1B7DC6C10(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_numPointsChanInfo *PSEmitter::PSEmitter_numPointsChanInfo::PSEmitter_numPointsChanInfo(PSEmitter::PSEmitter_numPointsChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 20.0, 1.0, 1.0, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_numPointsChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118B748;
  *((void *)this + 10) = &unk_1F118B768;
  return this;
}

void sub_1B7DC6CDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_numPointsUChanImpl::getInstance(PSEmitter::PSEmitter_numPointsUChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_numPointsUChanImpl::getInstance(void)::PSEmitter_numPointsUChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_numPointsUChanImpl::getInstance(void)::PSEmitter_numPointsUChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_numPointsUChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_numPointsUChanImpl::_PSEmitter_numPointsUChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_numPointsUChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_numPointsUChanImpl::_PSEmitter_numPointsUChan) {
    operator new();
  }
}

void sub_1B7DC6DB8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_numPointsUChanImpl::PSEmitter_numPointsUChanImpl(OZChannelUint32 *this)
{
}

void sub_1B7DC6E8C(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_numPointsUChanInfo::getInstance(PSEmitter::PSEmitter_numPointsUChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_numPointsUChanInfo::getInstance(void)::PSEmitter_numPointsUChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_numPointsUChanInfo::getInstance(void)::PSEmitter_numPointsUChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_numPointsUChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_numPointsUChanInfo::_PSEmitter_numPointsUChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_numPointsUChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_numPointsUChanInfo::_PSEmitter_numPointsUChanInfo) {
    operator new();
  }
}

void sub_1B7DC6F68(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_numPointsUChanInfo *PSEmitter::PSEmitter_numPointsUChanInfo::PSEmitter_numPointsUChanInfo(PSEmitter::PSEmitter_numPointsUChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 20.0, 1.0, 1.0, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_numPointsUChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118B838;
  *((void *)this + 10) = &unk_1F118B858;
  return this;
}

void sub_1B7DC7034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_numPointsVChanImpl::getInstance(PSEmitter::PSEmitter_numPointsVChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_numPointsVChanImpl::getInstance(void)::PSEmitter_numPointsVChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_numPointsVChanImpl::getInstance(void)::PSEmitter_numPointsVChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_numPointsVChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_numPointsVChanImpl::_PSEmitter_numPointsVChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_numPointsVChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_numPointsVChanImpl::_PSEmitter_numPointsVChan) {
    operator new();
  }
}

void sub_1B7DC7110(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_numPointsVChanImpl::PSEmitter_numPointsVChanImpl(OZChannelUint32 *this)
{
}

void sub_1B7DC71E4(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_numPointsVChanInfo::getInstance(PSEmitter::PSEmitter_numPointsVChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_numPointsVChanInfo::getInstance(void)::PSEmitter_numPointsVChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_numPointsVChanInfo::getInstance(void)::PSEmitter_numPointsVChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_numPointsVChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_numPointsVChanInfo::_PSEmitter_numPointsVChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_numPointsVChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_numPointsVChanInfo::_PSEmitter_numPointsVChanInfo) {
    operator new();
  }
}

void sub_1B7DC72C0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_numPointsVChanInfo *PSEmitter::PSEmitter_numPointsVChanInfo::PSEmitter_numPointsVChanInfo(PSEmitter::PSEmitter_numPointsVChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 20.0, 1.0, 1.0, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_numPointsVChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118B928;
  *((void *)this + 10) = &unk_1F118B948;
  return this;
}

void sub_1B7DC738C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_numPointsWChanImpl::getInstance(PSEmitter::PSEmitter_numPointsWChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_numPointsWChanImpl::getInstance(void)::PSEmitter_numPointsWChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_numPointsWChanImpl::getInstance(void)::PSEmitter_numPointsWChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_numPointsWChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_numPointsWChanImpl::_PSEmitter_numPointsWChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_numPointsWChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_numPointsWChanImpl::_PSEmitter_numPointsWChan) {
    operator new();
  }
}

void sub_1B7DC7468(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_numPointsWChanImpl::PSEmitter_numPointsWChanImpl(OZChannelUint32 *this)
{
}

void sub_1B7DC753C(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_numPointsWChanInfo::getInstance(PSEmitter::PSEmitter_numPointsWChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_numPointsWChanInfo::getInstance(void)::PSEmitter_numPointsWChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_numPointsWChanInfo::getInstance(void)::PSEmitter_numPointsWChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_numPointsWChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_numPointsWChanInfo::_PSEmitter_numPointsWChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_numPointsWChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_numPointsWChanInfo::_PSEmitter_numPointsWChanInfo) {
    operator new();
  }
}

void sub_1B7DC7618(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_numPointsWChanInfo *PSEmitter::PSEmitter_numPointsWChanInfo::PSEmitter_numPointsWChanInfo(PSEmitter::PSEmitter_numPointsWChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 20.0, 1.0, 1.0, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_numPointsWChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118BA18;
  *((void *)this + 10) = &unk_1F118BA38;
  return this;
}

void sub_1B7DC76E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_strokeWidthChanImpl::getInstance(PSEmitter::PSEmitter_strokeWidthChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_strokeWidthChanImpl::getInstance(void)::PSEmitter_strokeWidthChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_strokeWidthChanImpl::getInstance(void)::PSEmitter_strokeWidthChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_strokeWidthChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_strokeWidthChanImpl::_PSEmitter_strokeWidthChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_strokeWidthChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_strokeWidthChanImpl::_PSEmitter_strokeWidthChan) {
    operator new();
  }
}

void sub_1B7DC77C0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_strokeWidthChanImpl::PSEmitter_strokeWidthChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DC7894(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_strokeWidthChanInfo::getInstance(PSEmitter::PSEmitter_strokeWidthChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_strokeWidthChanInfo::getInstance(void)::PSEmitter_strokeWidthChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_strokeWidthChanInfo::getInstance(void)::PSEmitter_strokeWidthChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_strokeWidthChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_strokeWidthChanInfo::_PSEmitter_strokeWidthChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_strokeWidthChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_strokeWidthChanInfo::_PSEmitter_strokeWidthChanInfo) {
    operator new();
  }
}

void sub_1B7DC7970(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_strokeWidthChanInfo *PSEmitter::PSEmitter_strokeWidthChanInfo::PSEmitter_strokeWidthChanInfo(PSEmitter::PSEmitter_strokeWidthChanInfo *this)
{
  PCString::PCString(&v3, "%");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 4.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_strokeWidthChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118BB08;
  *((void *)this + 10) = &unk_1F118BB28;
  return this;
}

void sub_1B7DC7A48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_strokeWidthOSChanImpl::getInstance(PSEmitter::PSEmitter_strokeWidthOSChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_strokeWidthOSChanImpl::getInstance(void)::PSEmitter_strokeWidthOSChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_strokeWidthOSChanImpl::getInstance(void)::PSEmitter_strokeWidthOSChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_strokeWidthOSChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_strokeWidthOSChanImpl::_PSEmitter_strokeWidthOSChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_strokeWidthOSChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_strokeWidthOSChanImpl::_PSEmitter_strokeWidthOSChan) {
    operator new();
  }
}

void sub_1B7DC7B24(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_strokeWidthOSChanImpl::PSEmitter_strokeWidthOSChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DC7BF8(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_strokeWidthOSChanInfo::getInstance(PSEmitter::PSEmitter_strokeWidthOSChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_strokeWidthOSChanInfo::getInstance(void)::PSEmitter_strokeWidthOSChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_strokeWidthOSChanInfo::getInstance(void)::PSEmitter_strokeWidthOSChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_strokeWidthOSChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_strokeWidthOSChanInfo::_PSEmitter_strokeWidthOSChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_strokeWidthOSChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_strokeWidthOSChanInfo::_PSEmitter_strokeWidthOSChanInfo) {
    operator new();
  }
}

void sub_1B7DC7CD4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_strokeWidthOSChanInfo *PSEmitter::PSEmitter_strokeWidthOSChanInfo::PSEmitter_strokeWidthOSChanInfo(PSEmitter::PSEmitter_strokeWidthOSChanInfo *this)
{
  PCString::PCString(&v3, "%");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 4.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_strokeWidthOSChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118BBF8;
  *((void *)this + 10) = &unk_1F118BC18;
  return this;
}

void sub_1B7DC7DAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_tileOffsetChanImpl::getInstance(PSEmitter::PSEmitter_tileOffsetChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_tileOffsetChanImpl::getInstance(void)::PSEmitter_tileOffsetChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_tileOffsetChanImpl::getInstance(void)::PSEmitter_tileOffsetChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_tileOffsetChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_tileOffsetChanImpl::_PSEmitter_tileOffsetChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_tileOffsetChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_tileOffsetChanImpl::_PSEmitter_tileOffsetChan) {
    operator new();
  }
}

void sub_1B7DC7E88(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_tileOffsetChanImpl::PSEmitter_tileOffsetChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DC7F60(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_tileOffsetChanInfo::getInstance(PSEmitter::PSEmitter_tileOffsetChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_tileOffsetChanInfo::getInstance(void)::PSEmitter_tileOffsetChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_tileOffsetChanInfo::getInstance(void)::PSEmitter_tileOffsetChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_tileOffsetChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_tileOffsetChanInfo::_PSEmitter_tileOffsetChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_tileOffsetChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_tileOffsetChanInfo::_PSEmitter_tileOffsetChanInfo) {
    operator new();
  }
}

void sub_1B7DC803C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_tileOffsetChanInfo *PSEmitter::PSEmitter_tileOffsetChanInfo::PSEmitter_tileOffsetChanInfo(PSEmitter::PSEmitter_tileOffsetChanInfo *this)
{
  PCString::PCString(&v3, "%");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -1.0, 1.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_tileOffsetChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118BCE8;
  *((void *)this + 10) = &unk_1F118BD08;
  return this;
}

void sub_1B7DC8114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_rectBuildOriginChanImpl::getInstance(PSEmitter::PSEmitter_rectBuildOriginChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_rectBuildOriginChanImpl::getInstance(void)::PSEmitter_rectBuildOriginChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_rectBuildOriginChanImpl::getInstance(void)::PSEmitter_rectBuildOriginChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_rectBuildOriginChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_rectBuildOriginChanImpl::_PSEmitter_rectBuildOriginChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_rectBuildOriginChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_rectBuildOriginChanImpl::_PSEmitter_rectBuildOriginChan) {
    operator new();
  }
}

void sub_1B7DC81F0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_rectBuildOriginChanImpl::PSEmitter_rectBuildOriginChanImpl(PSEmitter::PSEmitter_rectBuildOriginChanImpl *this)
{
}

void sub_1B7DC82C4(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_rectBuildStyleChanImpl::getInstance(PSEmitter::PSEmitter_rectBuildStyleChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_rectBuildStyleChanImpl::getInstance(void)::PSEmitter_rectBuildStyleChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_rectBuildStyleChanImpl::getInstance(void)::PSEmitter_rectBuildStyleChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_rectBuildStyleChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_rectBuildStyleChanImpl::_PSEmitter_rectBuildStyleChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_rectBuildStyleChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_rectBuildStyleChanImpl::_PSEmitter_rectBuildStyleChan) {
    operator new();
  }
}

void sub_1B7DC83A0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_rectBuildStyleChanImpl::PSEmitter_rectBuildStyleChanImpl(PSEmitter::PSEmitter_rectBuildStyleChanImpl *this)
{
}

void sub_1B7DC8474(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_boxBuildOriginChanImpl::getInstance(PSEmitter::PSEmitter_boxBuildOriginChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_boxBuildOriginChanImpl::getInstance(void)::PSEmitter_boxBuildOriginChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_boxBuildOriginChanImpl::getInstance(void)::PSEmitter_boxBuildOriginChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_boxBuildOriginChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_boxBuildOriginChanImpl::_PSEmitter_boxBuildOriginChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_boxBuildOriginChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_boxBuildOriginChanImpl::_PSEmitter_boxBuildOriginChan) {
    operator new();
  }
}

void sub_1B7DC8550(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_boxBuildOriginChanImpl::PSEmitter_boxBuildOriginChanImpl(PSEmitter::PSEmitter_boxBuildOriginChanImpl *this)
{
}

void sub_1B7DC8624(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_boxBuildStyleChanImpl::getInstance(PSEmitter::PSEmitter_boxBuildStyleChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_boxBuildStyleChanImpl::getInstance(void)::PSEmitter_boxBuildStyleChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_boxBuildStyleChanImpl::getInstance(void)::PSEmitter_boxBuildStyleChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_boxBuildStyleChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_boxBuildStyleChanImpl::_PSEmitter_boxBuildStyleChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_boxBuildStyleChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_boxBuildStyleChanImpl::_PSEmitter_boxBuildStyleChan) {
    operator new();
  }
}

void sub_1B7DC8700(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_boxBuildStyleChanImpl::PSEmitter_boxBuildStyleChanImpl(PSEmitter::PSEmitter_boxBuildStyleChanImpl *this)
{
}

void sub_1B7DC87D4(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_openBuildOriginChanImpl::getInstance(PSEmitter::PSEmitter_openBuildOriginChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_openBuildOriginChanImpl::getInstance(void)::PSEmitter_openBuildOriginChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_openBuildOriginChanImpl::getInstance(void)::PSEmitter_openBuildOriginChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_openBuildOriginChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_openBuildOriginChanImpl::_PSEmitter_openBuildOriginChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_openBuildOriginChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_openBuildOriginChanImpl::_PSEmitter_openBuildOriginChan) {
    operator new();
  }
}

void sub_1B7DC88B0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_openBuildOriginChanImpl::PSEmitter_openBuildOriginChanImpl(PSEmitter::PSEmitter_openBuildOriginChanImpl *this)
{
}

void sub_1B7DC8984(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_closedBuildOriginChanImpl::getInstance(PSEmitter::PSEmitter_closedBuildOriginChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_closedBuildOriginChanImpl::getInstance(void)::PSEmitter_closedBuildOriginChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_closedBuildOriginChanImpl::getInstance(void)::PSEmitter_closedBuildOriginChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_closedBuildOriginChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_closedBuildOriginChanImpl::_PSEmitter_closedBuildOriginChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_closedBuildOriginChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_closedBuildOriginChanImpl::_PSEmitter_closedBuildOriginChan) {
    operator new();
  }
}

void sub_1B7DC8A60(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_closedBuildOriginChanImpl::PSEmitter_closedBuildOriginChanImpl(PSEmitter::PSEmitter_closedBuildOriginChanImpl *this)
{
}

void sub_1B7DC8B34(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_radialBuildOriginChanImpl::getInstance(PSEmitter::PSEmitter_radialBuildOriginChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_radialBuildOriginChanImpl::getInstance(void)::PSEmitter_radialBuildOriginChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_radialBuildOriginChanImpl::getInstance(void)::PSEmitter_radialBuildOriginChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_radialBuildOriginChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_radialBuildOriginChanImpl::_PSEmitter_radialBuildOriginChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_radialBuildOriginChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_radialBuildOriginChanImpl::_PSEmitter_radialBuildOriginChan) {
    operator new();
  }
}

void sub_1B7DC8C10(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_radialBuildOriginChanImpl::PSEmitter_radialBuildOriginChanImpl(PSEmitter::PSEmitter_radialBuildOriginChanImpl *this)
{
}

void sub_1B7DC8CE4(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_outlineOffsetChanImpl::getInstance(PSEmitter::PSEmitter_outlineOffsetChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_outlineOffsetChanImpl::getInstance(void)::PSEmitter_outlineOffsetChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_outlineOffsetChanImpl::getInstance(void)::PSEmitter_outlineOffsetChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_outlineOffsetChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_outlineOffsetChanImpl::_PSEmitter_outlineOffsetChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_outlineOffsetChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_outlineOffsetChanImpl::_PSEmitter_outlineOffsetChan) {
    operator new();
  }
}

void sub_1B7DC8DC0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_outlineOffsetChanImpl::PSEmitter_outlineOffsetChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DC8E98(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_outlineOffsetChanInfo::getInstance(PSEmitter::PSEmitter_outlineOffsetChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_outlineOffsetChanInfo::getInstance(void)::PSEmitter_outlineOffsetChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_outlineOffsetChanInfo::getInstance(void)::PSEmitter_outlineOffsetChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_outlineOffsetChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_outlineOffsetChanInfo::_PSEmitter_outlineOffsetChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_outlineOffsetChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_outlineOffsetChanInfo::_PSEmitter_outlineOffsetChanInfo) {
    operator new();
  }
}

void sub_1B7DC8F74(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_outlineOffsetChanInfo *PSEmitter::PSEmitter_outlineOffsetChanInfo::PSEmitter_outlineOffsetChanInfo(PSEmitter::PSEmitter_outlineOffsetChanInfo *this)
{
  PCString::PCString(&v3, "%");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -2.0, 2.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_outlineOffsetChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118C120;
  *((void *)this + 10) = &unk_1F118C140;
  return this;
}

void sub_1B7DC904C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_radiusChanImpl::getInstance(PSEmitter::PSEmitter_radiusChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_radiusChanImpl::getInstance(void)::PSEmitter_radiusChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_radiusChanImpl::getInstance(void)::PSEmitter_radiusChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_radiusChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_radiusChanImpl::_PSEmitter_radiusChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_radiusChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_radiusChanImpl::_PSEmitter_radiusChan) {
    operator new();
  }
}

void sub_1B7DC9128(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_radiusChanImpl::PSEmitter_radiusChanImpl(PSEmitter::PSEmitter_radiusChanImpl *this)
{
}

void sub_1B7DC920C(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_radiusChanInfo::getInstance(PSEmitter::PSEmitter_radiusChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_radiusChanInfo::getInstance(void)::PSEmitter_radiusChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_radiusChanInfo::getInstance(void)::PSEmitter_radiusChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_radiusChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_radiusChanInfo::_PSEmitter_radiusChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_radiusChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_radiusChanInfo::_PSEmitter_radiusChanInfo) {
    operator new();
  }
}

void sub_1B7DC92E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_radiusChanInfo *PSEmitter::PSEmitter_radiusChanInfo::PSEmitter_radiusChanInfo(PSEmitter::PSEmitter_radiusChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 1000.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_radiusChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118C210;
  *((void *)this + 10) = &unk_1F118C230;
  return this;
}

void sub_1B7DC93BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_rectWidthChanImpl::getInstance(PSEmitter::PSEmitter_rectWidthChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_rectWidthChanImpl::getInstance(void)::PSEmitter_rectWidthChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_rectWidthChanImpl::getInstance(void)::PSEmitter_rectWidthChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_rectWidthChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_rectWidthChanImpl::_PSEmitter_rectWidthChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_rectWidthChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_rectWidthChanImpl::_PSEmitter_rectWidthChan) {
    operator new();
  }
}

void sub_1B7DC9498(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_rectWidthChanImpl::PSEmitter_rectWidthChanImpl(PSEmitter::PSEmitter_rectWidthChanImpl *this)
{
}

void sub_1B7DC9580(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_rectSizeChanImpl::getInstance(PSEmitter::PSEmitter_rectSizeChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_rectSizeChanImpl::getInstance(void)::PSEmitter_rectSizeChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_rectSizeChanImpl::getInstance(void)::PSEmitter_rectSizeChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_rectSizeChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_rectSizeChanImpl::_PSEmitter_rectSizeChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_rectSizeChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_rectSizeChanImpl::_PSEmitter_rectSizeChan) {
    operator new();
  }
}

void sub_1B7DC965C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_rectSizeChanImpl::PSEmitter_rectSizeChanImpl(PSEmitter::PSEmitter_rectSizeChanImpl *this)
{
}

void sub_1B7DC9740(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_rectSizeChanInfo::getInstance(PSEmitter::PSEmitter_rectSizeChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_rectSizeChanInfo::getInstance(void)::PSEmitter_rectSizeChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_rectSizeChanInfo::getInstance(void)::PSEmitter_rectSizeChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_rectSizeChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_rectSizeChanInfo::_PSEmitter_rectSizeChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_rectSizeChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_rectSizeChanInfo::_PSEmitter_rectSizeChanInfo) {
    operator new();
  }
}

void sub_1B7DC981C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_rectSizeChanInfo *PSEmitter::PSEmitter_rectSizeChanInfo::PSEmitter_rectSizeChanInfo(PSEmitter::PSEmitter_rectSizeChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 1000.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_rectSizeChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118C378;
  *((void *)this + 10) = &unk_1F118C398;
  return this;
}

void sub_1B7DC98F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_numRadialArmsChanImpl::getInstance(PSEmitter::PSEmitter_numRadialArmsChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_numRadialArmsChanImpl::getInstance(void)::PSEmitter_numRadialArmsChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_numRadialArmsChanImpl::getInstance(void)::PSEmitter_numRadialArmsChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_numRadialArmsChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_numRadialArmsChanImpl::_PSEmitter_numRadialArmsChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_numRadialArmsChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_numRadialArmsChanImpl::_PSEmitter_numRadialArmsChan) {
    operator new();
  }
}

void sub_1B7DC99CC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_numRadialArmsChanImpl::PSEmitter_numRadialArmsChanImpl(OZChannelUint32 *this)
{
}

void sub_1B7DC9AA0(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_numRadialArmsChanInfo::getInstance(PSEmitter::PSEmitter_numRadialArmsChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_numRadialArmsChanInfo::getInstance(void)::PSEmitter_numRadialArmsChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_numRadialArmsChanInfo::getInstance(void)::PSEmitter_numRadialArmsChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_numRadialArmsChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_numRadialArmsChanInfo::_PSEmitter_numRadialArmsChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_numRadialArmsChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_numRadialArmsChanInfo::_PSEmitter_numRadialArmsChanInfo) {
    operator new();
  }
}

void sub_1B7DC9B7C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_numRadialArmsChanInfo *PSEmitter::PSEmitter_numRadialArmsChanInfo::PSEmitter_numRadialArmsChanInfo(PSEmitter::PSEmitter_numRadialArmsChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 10.0, 1.0, 1.0, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_numRadialArmsChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118C468;
  *((void *)this + 10) = &unk_1F118C488;
  return this;
}

void sub_1B7DC9C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_pointsPerArmChanImpl::getInstance(PSEmitter::PSEmitter_pointsPerArmChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_pointsPerArmChanImpl::getInstance(void)::PSEmitter_pointsPerArmChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_pointsPerArmChanImpl::getInstance(void)::PSEmitter_pointsPerArmChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_pointsPerArmChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_pointsPerArmChanImpl::_PSEmitter_pointsPerArmChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_pointsPerArmChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_pointsPerArmChanImpl::_PSEmitter_pointsPerArmChan) {
    operator new();
  }
}

void sub_1B7DC9D24(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_pointsPerArmChanImpl::PSEmitter_pointsPerArmChanImpl(OZChannelUint32 *this)
{
}

void sub_1B7DC9DF8(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_pointsPerArmChanInfo::getInstance(PSEmitter::PSEmitter_pointsPerArmChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_pointsPerArmChanInfo::getInstance(void)::PSEmitter_pointsPerArmChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_pointsPerArmChanInfo::getInstance(void)::PSEmitter_pointsPerArmChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_pointsPerArmChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_pointsPerArmChanInfo::_PSEmitter_pointsPerArmChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_pointsPerArmChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_pointsPerArmChanInfo::_PSEmitter_pointsPerArmChanInfo) {
    operator new();
  }
}

void sub_1B7DC9ED4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_pointsPerArmChanInfo *PSEmitter::PSEmitter_pointsPerArmChanInfo::PSEmitter_pointsPerArmChanInfo(PSEmitter::PSEmitter_pointsPerArmChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 25.0, 1.0, 1.0, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_pointsPerArmChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118C558;
  *((void *)this + 10) = &unk_1F118C578;
  return this;
}

void sub_1B7DC9FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_spiralCoeffChanImpl::getInstance(PSEmitter::PSEmitter_spiralCoeffChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_spiralCoeffChanImpl::getInstance(void)::PSEmitter_spiralCoeffChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_spiralCoeffChanImpl::getInstance(void)::PSEmitter_spiralCoeffChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_spiralCoeffChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_spiralCoeffChanImpl::_PSEmitter_spiralCoeffChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_spiralCoeffChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_spiralCoeffChanImpl::_PSEmitter_spiralCoeffChan) {
    operator new();
  }
}

void sub_1B7DCA07C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_spiralCoeffChanImpl::PSEmitter_spiralCoeffChanImpl(PSEmitter::PSEmitter_spiralCoeffChanImpl *this)
{
}

void sub_1B7DCA154(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_spiralCoeffChanInfo::getInstance(PSEmitter::PSEmitter_spiralCoeffChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_spiralCoeffChanInfo::getInstance(void)::PSEmitter_spiralCoeffChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_spiralCoeffChanInfo::getInstance(void)::PSEmitter_spiralCoeffChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_spiralCoeffChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_spiralCoeffChanInfo::_PSEmitter_spiralCoeffChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_spiralCoeffChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_spiralCoeffChanInfo::_PSEmitter_spiralCoeffChanInfo) {
    operator new();
  }
}

void sub_1B7DCA230(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_spiralCoeffChanInfo *PSEmitter::PSEmitter_spiralCoeffChanInfo::PSEmitter_spiralCoeffChanInfo(PSEmitter::PSEmitter_spiralCoeffChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -2.0, 2.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_spiralCoeffChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118C648;
  *((void *)this + 10) = &unk_1F118C668;
  return this;
}

void sub_1B7DCA300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_waveAmplitudeChanImpl::getInstance(PSEmitter::PSEmitter_waveAmplitudeChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_waveAmplitudeChanImpl::getInstance(void)::PSEmitter_waveAmplitudeChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_waveAmplitudeChanImpl::getInstance(void)::PSEmitter_waveAmplitudeChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_waveAmplitudeChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_waveAmplitudeChanImpl::_PSEmitter_waveAmplitudeChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_waveAmplitudeChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_waveAmplitudeChanImpl::_PSEmitter_waveAmplitudeChan) {
    operator new();
  }
}

void sub_1B7DCA3DC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_waveAmplitudeChanImpl::PSEmitter_waveAmplitudeChanImpl(PSEmitter::PSEmitter_waveAmplitudeChanImpl *this)
{
}

void sub_1B7DCA4C4(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_waveFrequencyChanImpl::getInstance(PSEmitter::PSEmitter_waveFrequencyChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_waveFrequencyChanImpl::getInstance(void)::PSEmitter_waveFrequencyChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_waveFrequencyChanImpl::getInstance(void)::PSEmitter_waveFrequencyChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_waveFrequencyChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_waveFrequencyChanImpl::_PSEmitter_waveFrequencyChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_waveFrequencyChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_waveFrequencyChanImpl::_PSEmitter_waveFrequencyChan) {
    operator new();
  }
}

void sub_1B7DCA5A0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_waveFrequencyChanImpl::PSEmitter_waveFrequencyChanImpl(PSEmitter::PSEmitter_waveFrequencyChanImpl *this)
{
}

void sub_1B7DCA674(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_waveFrequencyChanInfo::getInstance(PSEmitter::PSEmitter_waveFrequencyChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_waveFrequencyChanInfo::getInstance(void)::PSEmitter_waveFrequencyChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_waveFrequencyChanInfo::getInstance(void)::PSEmitter_waveFrequencyChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_waveFrequencyChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_waveFrequencyChanInfo::_PSEmitter_waveFrequencyChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_waveFrequencyChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_waveFrequencyChanInfo::_PSEmitter_waveFrequencyChanInfo) {
    operator new();
  }
}

void sub_1B7DCA750(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_waveFrequencyChanInfo *PSEmitter::PSEmitter_waveFrequencyChanInfo::PSEmitter_waveFrequencyChanInfo(PSEmitter::PSEmitter_waveFrequencyChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 5.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_waveFrequencyChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118C7B0;
  *((void *)this + 10) = &unk_1F118C7D0;
  return this;
}

void sub_1B7DCA820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_wavePhaseChanInfo::getInstance(PSEmitter::PSEmitter_wavePhaseChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_wavePhaseChanInfo::getInstance(void)::PSEmitter_wavePhaseChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_wavePhaseChanInfo::getInstance(void)::PSEmitter_wavePhaseChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_wavePhaseChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_wavePhaseChanInfo::_PSEmitter_wavePhaseChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_wavePhaseChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_wavePhaseChanInfo::_PSEmitter_wavePhaseChanInfo) {
    operator new();
  }
}

void sub_1B7DCA8FC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_wavePhaseChanInfo *PSEmitter::PSEmitter_wavePhaseChanInfo::PSEmitter_wavePhaseChanInfo(PSEmitter::PSEmitter_wavePhaseChanInfo *this)
{
  PCString::PCString(&v3, "°");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -3.40282347e38, 360.0, 0.0174532925, 0.000174532925, 57.2957795, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_wavePhaseChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118C828;
  *((void *)this + 10) = &unk_1F118C848;
  return this;
}

void sub_1B7DCA9DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_waveDampingChanImpl::getInstance(PSEmitter::PSEmitter_waveDampingChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_waveDampingChanImpl::getInstance(void)::PSEmitter_waveDampingChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_waveDampingChanImpl::getInstance(void)::PSEmitter_waveDampingChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_waveDampingChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_waveDampingChanImpl::_PSEmitter_waveDampingChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_waveDampingChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_waveDampingChanImpl::_PSEmitter_waveDampingChan) {
    operator new();
  }
}

void sub_1B7DCAAB8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_waveDampingChanImpl::PSEmitter_waveDampingChanImpl(PSEmitter::PSEmitter_waveDampingChanImpl *this)
{
}

void sub_1B7DCAB90(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_waveDampingChanInfo::getInstance(PSEmitter::PSEmitter_waveDampingChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_waveDampingChanInfo::getInstance(void)::PSEmitter_waveDampingChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_waveDampingChanInfo::getInstance(void)::PSEmitter_waveDampingChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_waveDampingChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_waveDampingChanInfo::_PSEmitter_waveDampingChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_waveDampingChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_waveDampingChanInfo::_PSEmitter_waveDampingChanInfo) {
    operator new();
  }
}

void sub_1B7DCAC6C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_waveDampingChanInfo *PSEmitter::PSEmitter_waveDampingChanInfo::PSEmitter_waveDampingChanInfo(PSEmitter::PSEmitter_waveDampingChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -10.0, 10.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_waveDampingChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118C918;
  *((void *)this + 10) = &unk_1F118C938;
  return this;
}

void sub_1B7DCAD3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_emissionLatitudeChanImpl::getInstance(PSEmitter::PSEmitter_emissionLatitudeChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_emissionLatitudeChanImpl::getInstance(void)::PSEmitter_emissionLatitudeChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_emissionLatitudeChanImpl::getInstance(void)::PSEmitter_emissionLatitudeChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_emissionLatitudeChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_emissionLatitudeChanImpl::_PSEmitter_emissionLatitudeChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_emissionLatitudeChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_emissionLatitudeChanImpl::_PSEmitter_emissionLatitudeChan) {
    operator new();
  }
}

void sub_1B7DCAE18(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_emissionLatitudeChanImpl::PSEmitter_emissionLatitudeChanImpl(OZChannelAngle *this)
{
}

void sub_1B7DCAEEC(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_emissionLongitudeChanImpl::getInstance(PSEmitter::PSEmitter_emissionLongitudeChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_emissionLongitudeChanImpl::getInstance(void)::PSEmitter_emissionLongitudeChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_emissionLongitudeChanImpl::getInstance(void)::PSEmitter_emissionLongitudeChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_emissionLongitudeChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_emissionLongitudeChanImpl::_PSEmitter_emissionLongitudeChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_emissionLongitudeChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_emissionLongitudeChanImpl::_PSEmitter_emissionLongitudeChan) {
    operator new();
  }
}

void sub_1B7DCAFC8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_emissionLongitudeChanImpl::PSEmitter_emissionLongitudeChanImpl(OZChannelAngle *this)
{
}

void sub_1B7DCB0AC(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_emissionRangeChanImpl::getInstance(PSEmitter::PSEmitter_emissionRangeChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_emissionRangeChanImpl::getInstance(void)::PSEmitter_emissionRangeChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_emissionRangeChanImpl::getInstance(void)::PSEmitter_emissionRangeChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_emissionRangeChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_emissionRangeChanImpl::_PSEmitter_emissionRangeChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_emissionRangeChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_emissionRangeChanImpl::_PSEmitter_emissionRangeChan) {
    operator new();
  }
}

void sub_1B7DCB188(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_emissionRangeChanImpl::PSEmitter_emissionRangeChanImpl(OZChannelAngle *this)
{
}

void sub_1B7DCB268(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_birthRateChanImpl::getInstance(PSEmitter::PSEmitter_birthRateChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_birthRateChanImpl::getInstance(void)::PSEmitter_birthRateChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_birthRateChanImpl::getInstance(void)::PSEmitter_birthRateChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_birthRateChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_birthRateChanImpl::_PSEmitter_birthRateChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_birthRateChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_birthRateChanImpl::_PSEmitter_birthRateChan) {
    operator new();
  }
}

void sub_1B7DCB344(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_birthRateChanImpl::PSEmitter_birthRateChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DCB418(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_birthRateChanInfo::getInstance(PSEmitter::PSEmitter_birthRateChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_birthRateChanInfo::getInstance(void)::PSEmitter_birthRateChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_birthRateChanInfo::getInstance(void)::PSEmitter_birthRateChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_birthRateChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_birthRateChanInfo::_PSEmitter_birthRateChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_birthRateChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_birthRateChanInfo::_PSEmitter_birthRateChanInfo) {
    operator new();
  }
}

void sub_1B7DCB4F4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_birthRateChanInfo *PSEmitter::PSEmitter_birthRateChanInfo::PSEmitter_birthRateChanInfo(PSEmitter::PSEmitter_birthRateChanInfo *this)
{
  PCString::PCString(&v3, "%");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 5.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_birthRateChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118CB70;
  *((void *)this + 10) = &unk_1F118CB90;
  return this;
}

void sub_1B7DCB5CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_initialNumChanImpl::getInstance(PSEmitter::PSEmitter_initialNumChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_initialNumChanImpl::getInstance(void)::PSEmitter_initialNumChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_initialNumChanImpl::getInstance(void)::PSEmitter_initialNumChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_initialNumChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_initialNumChanImpl::_PSEmitter_initialNumChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_initialNumChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_initialNumChanImpl::_PSEmitter_initialNumChan) {
    operator new();
  }
}

void sub_1B7DCB6A8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_initialNumChanImpl::PSEmitter_initialNumChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DCB778(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_lifetimeChanImpl::getInstance(PSEmitter::PSEmitter_lifetimeChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_lifetimeChanImpl::getInstance(void)::PSEmitter_lifetimeChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_lifetimeChanImpl::getInstance(void)::PSEmitter_lifetimeChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_lifetimeChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_lifetimeChanImpl::_PSEmitter_lifetimeChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_lifetimeChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_lifetimeChanImpl::_PSEmitter_lifetimeChan) {
    operator new();
  }
}

void sub_1B7DCB854(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_lifetimeChanImpl::PSEmitter_lifetimeChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DCB928(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_lifetimeChanInfo::getInstance(PSEmitter::PSEmitter_lifetimeChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_lifetimeChanInfo::getInstance(void)::PSEmitter_lifetimeChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_lifetimeChanInfo::getInstance(void)::PSEmitter_lifetimeChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_lifetimeChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_lifetimeChanInfo::_PSEmitter_lifetimeChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_lifetimeChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_lifetimeChanInfo::_PSEmitter_lifetimeChanInfo) {
    operator new();
  }
}

void sub_1B7DCBA04(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_lifetimeChanInfo *PSEmitter::PSEmitter_lifetimeChanInfo::PSEmitter_lifetimeChanInfo(PSEmitter::PSEmitter_lifetimeChanInfo *this)
{
  PCString::PCString(&v3, "%");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 5.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_lifetimeChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118CCD8;
  *((void *)this + 10) = &unk_1F118CCF8;
  return this;
}

void sub_1B7DCBADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_speedChanImpl::getInstance(PSEmitter::PSEmitter_speedChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_speedChanImpl::getInstance(void)::PSEmitter_speedChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_speedChanImpl::getInstance(void)::PSEmitter_speedChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_speedChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_speedChanImpl::_PSEmitter_speedChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_speedChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_speedChanImpl::_PSEmitter_speedChan) {
    operator new();
  }
}

void sub_1B7DCBBB8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_speedChanImpl::PSEmitter_speedChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DCBC8C(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_speedChanInfo::getInstance(PSEmitter::PSEmitter_speedChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_speedChanInfo::getInstance(void)::PSEmitter_speedChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_speedChanInfo::getInstance(void)::PSEmitter_speedChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_speedChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_speedChanInfo::_PSEmitter_speedChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_speedChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_speedChanInfo::_PSEmitter_speedChanInfo) {
    operator new();
  }
}

void sub_1B7DCBD68(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_speedChanInfo *PSEmitter::PSEmitter_speedChanInfo::PSEmitter_speedChanInfo(PSEmitter::PSEmitter_speedChanInfo *this)
{
  PCString::PCString(&v3, "%");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 5.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_speedChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118CDC8;
  *((void *)this + 10) = &unk_1F118CDE8;
  return this;
}

void sub_1B7DCBE40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_spinChanImpl::getInstance(PSEmitter::PSEmitter_spinChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_spinChanImpl::getInstance(void)::PSEmitter_spinChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_spinChanImpl::getInstance(void)::PSEmitter_spinChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_spinChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_spinChanImpl::_PSEmitter_spinChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_spinChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_spinChanImpl::_PSEmitter_spinChan) {
    operator new();
  }
}

void sub_1B7DCBF1C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_spinChanImpl::PSEmitter_spinChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DCBFF0(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_spinChanInfo::getInstance(PSEmitter::PSEmitter_spinChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_spinChanInfo::getInstance(void)::PSEmitter_spinChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_spinChanInfo::getInstance(void)::PSEmitter_spinChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_spinChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_spinChanInfo::_PSEmitter_spinChanInfo;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_spinChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_spinChanInfo::_PSEmitter_spinChanInfo) {
    operator new();
  }
}

void sub_1B7DCC0CC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSEmitter::PSEmitter_spinChanInfo *PSEmitter::PSEmitter_spinChanInfo::PSEmitter_spinChanInfo(PSEmitter::PSEmitter_spinChanInfo *this)
{
  PCString::PCString(&v3, "%");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 5.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSEmitter::PSEmitter_spinChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118CEB8;
  *((void *)this + 10) = &unk_1F118CED8;
  return this;
}

void sub_1B7DCC1A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_tintAmountChanImpl::getInstance(PSEmitter::PSEmitter_tintAmountChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_tintAmountChanImpl::getInstance(void)::PSEmitter_tintAmountChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_tintAmountChanImpl::getInstance(void)::PSEmitter_tintAmountChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_tintAmountChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_tintAmountChanImpl::_PSEmitter_tintAmountChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_tintAmountChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_tintAmountChanImpl::_PSEmitter_tintAmountChan) {
    operator new();
  }
}

void sub_1B7DCC280(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_tintAmountChanImpl::PSEmitter_tintAmountChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DCC350(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSEmitter::PSEmitter_renderSpaceChanImpl::getInstance(PSEmitter::PSEmitter_renderSpaceChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter::PSEmitter_renderSpaceChanImpl::getInstance(void)::PSEmitter_renderSpaceChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSEmitter::PSEmitter_renderSpaceChanImpl::getInstance(void)::PSEmitter_renderSpaceChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter::PSEmitter_renderSpaceChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter::PSEmitter_renderSpaceChanImpl::_PSEmitter_renderSpaceChan;
}

void std::__call_once_param<std::tuple<PSEmitter::PSEmitter_renderSpaceChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSEmitter::PSEmitter_renderSpaceChanImpl::_PSEmitter_renderSpaceChan) {
    operator new();
  }
}

void sub_1B7DCC42C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSEmitter::PSEmitter_renderSpaceChanImpl::PSEmitter_renderSpaceChanImpl(PSEmitter::PSEmitter_renderSpaceChanImpl *this)
{
}

void sub_1B7DCC500(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*,false>(long long *a1, __n128 *a2, uint64_t (**a3)(long long *, long long *), uint64_t a4, char a5, __n128 a6)
{
uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(uint64_t result, _OWORD *a2, uint64_t (**a3)(_OWORD *, void))
{
  if ((_OWORD *)result != a2)
  {
    uint64_t v25 = v3;
    uint64_t v26 = v4;
    char v6 = (_OWORD *)result;
    char v7 = (_OWORD *)(result + 64);
    if ((_OWORD *)(result + 64) != a2)
    {
      uint64_t v9 = 0;
      long long v10 = (_OWORD *)result;
      do
      {
        char v11 = v10;
        long long v10 = v7;
        uint64_t result = (*a3)(v7, v11);
        if (result)
        {
          long long v12 = v10[1];
          long long v21 = *v10;
          long long v22 = v12;
          long long v13 = v10[3];
          long long v23 = v10[2];
          long long v24 = v13;
          uint64_t v14 = v9;
          while (1)
          {
            uint64_t v15 = (_OWORD *)((char *)v6 + v14);
            long long v16 = *(_OWORD *)((char *)v6 + v14 + 16);
            v15[4] = *(_OWORD *)((char *)v6 + v14);
            v15[5] = v16;
            long long v17 = *(_OWORD *)((char *)v6 + v14 + 48);
            v15[6] = *(_OWORD *)((char *)v6 + v14 + 32);
            v15[7] = v17;
            if (!v14) {
              break;
            }
            v14 -= 64;
            uint64_t result = (*a3)(&v21, (char *)v6 + v14);
            if ((result & 1) == 0)
            {
              unint64_t v18 = (_OWORD *)((char *)v6 + v14 + 64);
              goto LABEL_10;
            }
          }
          unint64_t v18 = v6;
LABEL_10:
          long long v19 = v22;
          *unint64_t v18 = v21;
          v18[1] = v19;
          long long v20 = v24;
          unsigned int v18[2] = v23;
          v18[3] = v20;
        }
        char v7 = v10 + 4;
        v9 += 64;
      }
      while (v10 + 4 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(uint64_t result, _OWORD *a2, uint64_t (**a3)(long long *, _OWORD *))
{
  if ((_OWORD *)result != a2)
  {
    uint64_t v22 = v3;
    uint64_t v23 = v4;
    char v6 = (_OWORD *)result;
    char v7 = (_OWORD *)(result + 64);
    if ((_OWORD *)(result + 64) != a2)
    {
      uint64_t v9 = (_OWORD *)(result - 64);
      do
      {
        long long v10 = v6;
        char v6 = v7;
        uint64_t result = (*a3)(v7, v10);
        if (result)
        {
          long long v11 = v6[1];
          long long v18 = *v6;
          long long v19 = v11;
          long long v12 = v6[3];
          long long v20 = v6[2];
          long long v21 = v12;
          long long v13 = v9;
          do
          {
            long long v14 = v13[5];
            v13[8] = v13[4];
            v13[9] = v14;
            long long v15 = v13[7];
            v13[10] = v13[6];
            v13[11] = v15;
            uint64_t result = (*a3)(&v18, v13);
            v13 -= 4;
          }
          while ((result & 1) != 0);
          long long v16 = v19;
          v13[8] = v18;
          v13[9] = v16;
          long long v17 = v21;
          v13[10] = v20;
          v13[11] = v17;
        }
        char v7 = v6 + 4;
        v9 += 4;
      }
      while (v6 + 4 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(long long *a1, long long *a2, long long *a3, uint64_t (**a4)(long long *, long long *))
{
  char v8 = (*a4)(a2, a1);
  uint64_t result = (*a4)(a3, a2);
  if (v8)
  {
    if (result)
    {
      long long v11 = a1[2];
      long long v10 = a1[3];
      long long v13 = *a1;
      long long v12 = a1[1];
      long long v14 = a3[3];
      long long v16 = *a3;
      long long v15 = a3[1];
      a1[2] = a3[2];
      a1[3] = v14;
      *a1 = v16;
      a1[1] = v15;
      *a3 = v13;
      a3[1] = v12;
      uint64_t result = 1;
LABEL_9:
      a3[2] = v11;
      a3[3] = v10;
      return result;
    }
    long long v32 = a1[2];
    long long v31 = a1[3];
    long long v34 = *a1;
    long long v33 = a1[1];
    long long v35 = a2[3];
    long long v37 = *a2;
    long long v36 = a2[1];
    a1[2] = a2[2];
    a1[3] = v35;
    *a1 = v37;
    a1[1] = v36;
    *a2 = v34;
    a2[1] = v33;
    a2[2] = v32;
    a2[3] = v31;
    if ((*a4)(a3, a2))
    {
      long long v11 = a2[2];
      long long v10 = a2[3];
      long long v39 = *a2;
      long long v38 = a2[1];
      long long v40 = a3[3];
      long long v42 = *a3;
      long long v41 = a3[1];
      a2[2] = a3[2];
      a2[3] = v40;
      *a2 = v42;
      a2[1] = v41;
      *a3 = v39;
      a3[1] = v38;
      uint64_t result = 2;
      goto LABEL_9;
    }
  }
  else
  {
    if (!result) {
      return result;
    }
    long long v18 = a2[2];
    long long v17 = a2[3];
    long long v20 = *a2;
    long long v19 = a2[1];
    long long v21 = a3[3];
    long long v23 = *a3;
    long long v22 = a3[1];
    a2[2] = a3[2];
    a2[3] = v21;
    *a2 = v23;
    a2[1] = v22;
    *a3 = v20;
    a3[1] = v19;
    a3[2] = v18;
    a3[3] = v17;
    if ((*a4)(a2, a1))
    {
      long long v25 = a1[2];
      long long v24 = a1[3];
      long long v27 = *a1;
      long long v26 = a1[1];
      long long v28 = a2[3];
      long long v30 = *a2;
      long long v29 = a2[1];
      a1[2] = a2[2];
      a1[3] = v28;
      *a1 = v30;
      a1[1] = v29;
      *a2 = v27;
      a2[1] = v26;
      uint64_t result = 2;
      a2[2] = v25;
      a2[3] = v24;
      return result;
    }
  }
  return 1;
}

long long *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,PSEmitter::RenderEntry *,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&)>(long long *a1, long long *a2, uint64_t (**a3)(long long *, long long *))
{
  uint64_t v4 = a2;
  long long v6 = a1[1];
  long long v28 = *a1;
  long long v29 = v6;
  long long v7 = a1[3];
  long long v30 = a1[2];
  long long v31 = v7;
  if ((*a3)(&v28, a2 - 4))
  {
    char v8 = a1;
    do
      v8 += 4;
    while (((*a3)(&v28, v8) & 1) == 0);
  }
  else
  {
    uint64_t v9 = a1 + 4;
    do
    {
      char v8 = v9;
      if (v9 >= v4) {
        break;
      }
      int v10 = (*a3)(&v28, v9);
      uint64_t v9 = v8 + 4;
    }
    while (!v10);
  }
  if (v8 < v4)
  {
    do
      v4 -= 4;
    while (((*a3)(&v28, v4) & 1) != 0);
  }
  while (v8 < v4)
  {
    long long v11 = *v8;
    long long v12 = v8[1];
    long long v13 = v8[3];
    long long v34 = v8[2];
    long long v35 = v13;
    long long v32 = v11;
    long long v33 = v12;
    long long v14 = *v4;
    long long v15 = v4[1];
    long long v16 = v4[3];
    v8[2] = v4[2];
    v8[3] = v16;
    *char v8 = v14;
    v8[1] = v15;
    long long v17 = v32;
    long long v18 = v33;
    long long v19 = v35;
    v4[2] = v34;
    v4[3] = v19;
    *uint64_t v4 = v17;
    v4[1] = v18;
    do
      v8 += 4;
    while (!(*a3)(&v28, v8));
    do
      v4 -= 4;
    while (((*a3)(&v28, v4) & 1) != 0);
  }
  long long v20 = v8 - 4;
  if (v8 - 4 != a1)
  {
    long long v21 = *v20;
    long long v22 = *(v8 - 3);
    long long v23 = *(v8 - 1);
    a1[2] = *(v8 - 2);
    a1[3] = v23;
    *a1 = v21;
    a1[1] = v22;
  }
  long long v24 = v28;
  long long v25 = v29;
  long long v26 = v31;
  *(v8 - 2) = v30;
  *(v8 - 1) = v26;
  *long long v20 = v24;
  *(v8 - 3) = v25;
  return v8;
}

long long *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,PSEmitter::RenderEntry *,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&)>(long long *a1, long long *a2, uint64_t (**a3)(long long *, long long *))
{
  uint64_t v6 = 0;
  long long v7 = a1[1];
  long long v27 = *a1;
  long long v28 = v7;
  long long v8 = a1[3];
  long long v29 = a1[2];
  long long v30 = v8;
  do
    v6 += 4;
  while (((*a3)(&a1[v6], &v27) & 1) != 0);
  uint64_t v9 = &a1[v6];
  int v10 = &a1[v6 - 4];
  if (v6 == 4)
  {
    do
    {
      if (v9 >= a2) {
        break;
      }
      a2 -= 4;
    }
    while (((*a3)(a2, &v27) & 1) == 0);
  }
  else
  {
    do
      a2 -= 4;
    while (!(*a3)(a2, &v27));
  }
  if (v9 < a2)
  {
    long long v11 = &a1[v6];
    long long v12 = a2;
    do
    {
      long long v14 = v11[1];
      long long v31 = *v11;
      long long v13 = v31;
      long long v32 = v14;
      long long v16 = v11[3];
      long long v33 = v11[2];
      long long v15 = v33;
      long long v34 = v16;
      long long v18 = v12[2];
      long long v17 = v12[3];
      long long v19 = v12[1];
      *long long v11 = *v12;
      v11[1] = v19;
      v11[2] = v18;
      v11[3] = v17;
      v12[2] = v15;
      void v12[3] = v16;
      *long long v12 = v13;
      v12[1] = v14;
      do
        v11 += 4;
      while (((*a3)(v11, &v27) & 1) != 0);
      do
        v12 -= 4;
      while (!(*a3)(v12, &v27));
    }
    while (v11 < v12);
    int v10 = v11 - 4;
  }
  if (v10 != a1)
  {
    long long v20 = *v10;
    long long v21 = v10[1];
    long long v22 = v10[3];
    a1[2] = v10[2];
    a1[3] = v22;
    *a1 = v20;
    a1[1] = v21;
  }
  long long v23 = v27;
  long long v24 = v28;
  long long v25 = v30;
  v10[2] = v29;
  v10[3] = v25;
  long long *v10 = v23;
  v10[1] = v24;
  return v10;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(long long *a1, long long *a2, uint64_t (**a3)(long long *, long long *))
{
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 6;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v8 = a2 - 4;
      if (!(*a3)(a2 - 4, a1)) {
        return 1;
      }
      long long v10 = a1[2];
      long long v9 = a1[3];
      long long v12 = *a1;
      long long v11 = a1[1];
      long long v13 = *(a2 - 1);
      long long v15 = *v8;
      long long v14 = *(a2 - 3);
      a1[2] = *(a2 - 2);
      a1[3] = v13;
      *a1 = v15;
      a1[1] = v14;
      *long long v8 = v12;
      *(a2 - 3) = v11;
      BOOL result = 1;
      *(a2 - 2) = v10;
      *(a2 - 1) = v9;
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(a1, a1 + 4, a2 - 4, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>((uint64_t)a1, a1 + 4, a1 + 8, a2 - 4, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>((uint64_t)a1, a1 + 4, a1 + 8, a1 + 12, a2 - 4, a3);
      return 1;
    default:
      long long v16 = a1 + 8;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(a1, a1 + 4, a1 + 8, a3);
      long long v17 = a1 + 12;
      if (a1 + 12 == a2) {
        return 1;
      }
      uint64_t v18 = 0;
      int v19 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(v17, v16))
    {
      long long v20 = v17[1];
      long long v29 = *v17;
      long long v30 = v20;
      long long v21 = v17[3];
      long long v31 = v17[2];
      long long v32 = v21;
      uint64_t v22 = v18;
      while (1)
      {
        long long v23 = (long long *)((char *)a1 + v22);
        long long v24 = *(long long *)((char *)a1 + v22 + 144);
        v23[12] = *(long long *)((char *)a1 + v22 + 128);
        v23[13] = v24;
        long long v25 = *(long long *)((char *)a1 + v22 + 176);
        v23[14] = *(long long *)((char *)a1 + v22 + 160);
        v23[15] = v25;
        if (v22 == -128) {
          break;
        }
        v22 -= 64;
        if (((*a3)(&v29, v23 + 4) & 1) == 0)
        {
          long long v26 = (long long *)((char *)a1 + v22 + 192);
          goto LABEL_12;
        }
      }
      long long v26 = a1;
LABEL_12:
      long long v27 = v30;
      *long long v26 = v29;
      v26[1] = v27;
      long long v28 = v32;
      v26[2] = v31;
      v26[3] = v28;
      if (++v19 == 8) {
        return v17 + 4 == a2;
      }
    }
    long long v16 = v17;
    v18 += 64;
    v17 += 4;
    if (v17 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(uint64_t a1, long long *a2, long long *a3, long long *a4, uint64_t (**a5)(long long *, long long *))
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>((long long *)a1, a2, a3, a5);
  if ((*a5)(a4, a3))
  {
    long long v12 = a3[2];
    long long v11 = a3[3];
    long long v14 = *a3;
    long long v13 = a3[1];
    long long v15 = a4[3];
    long long v17 = *a4;
    long long v16 = a4[1];
    a3[2] = a4[2];
    a3[3] = v15;
    *a3 = v17;
    a3[1] = v16;
    *a4 = v14;
    a4[1] = v13;
    a4[2] = v12;
    a4[3] = v11;
    if ((*a5)(a3, a2))
    {
      long long v19 = a2[2];
      long long v18 = a2[3];
      long long v21 = *a2;
      long long v20 = a2[1];
      long long v22 = a3[3];
      long long v24 = *a3;
      long long v23 = a3[1];
      a2[2] = a3[2];
      a2[3] = v22;
      *a2 = v24;
      a2[1] = v23;
      *a3 = v21;
      a3[1] = v20;
      a3[2] = v19;
      a3[3] = v18;
      if ((*a5)(a2, (long long *)a1))
      {
        long long v25 = *(_OWORD *)(a1 + 32);
        __n128 result = *(__n128 *)(a1 + 48);
        long long v27 = *(_OWORD *)a1;
        long long v26 = *(_OWORD *)(a1 + 16);
        long long v28 = a2[3];
        long long v30 = *a2;
        long long v29 = a2[1];
        *(_OWORD *)(a1 + 32) = a2[2];
        *(_OWORD *)(a1 + 48) = v28;
        *(_OWORD *)a1 = v30;
        *(_OWORD *)(a1 + 16) = v29;
        *a2 = v27;
        a2[1] = v26;
        a2[2] = v25;
        a2[3] = (__int128)result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(uint64_t a1, long long *a2, long long *a3, long long *a4, long long *a5, uint64_t (**a6)(long long *, long long *))
{
  __n128 v12 = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(a1, a2, a3, a4, a6);
  if (((unsigned int (*)(long long *, long long *, __n128))*a6)(a5, a4, v12))
  {
    long long v15 = a4[2];
    long long v14 = a4[3];
    long long v17 = *a4;
    long long v16 = a4[1];
    long long v18 = a5[3];
    long long v20 = *a5;
    long long v19 = a5[1];
    a4[2] = a5[2];
    a4[3] = v18;
    *a4 = v20;
    a4[1] = v19;
    *a5 = v17;
    a5[1] = v16;
    a5[2] = v15;
    a5[3] = v14;
    if ((*a6)(a4, a3))
    {
      long long v22 = a3[2];
      long long v21 = a3[3];
      long long v24 = *a3;
      long long v23 = a3[1];
      long long v25 = a4[3];
      long long v27 = *a4;
      long long v26 = a4[1];
      a3[2] = a4[2];
      a3[3] = v25;
      *a3 = v27;
      a3[1] = v26;
      *a4 = v24;
      a4[1] = v23;
      a4[2] = v22;
      a4[3] = v21;
      if ((*a6)(a3, a2))
      {
        long long v29 = a2[2];
        long long v28 = a2[3];
        long long v31 = *a2;
        long long v30 = a2[1];
        long long v32 = a3[3];
        long long v34 = *a3;
        long long v33 = a3[1];
        a2[2] = a3[2];
        a2[3] = v32;
        *a2 = v34;
        a2[1] = v33;
        *a3 = v31;
        a3[1] = v30;
        a3[2] = v29;
        a3[3] = v28;
        if ((*a6)(a2, (long long *)a1))
        {
          long long v35 = *(_OWORD *)(a1 + 32);
          __n128 result = *(__n128 *)(a1 + 48);
          long long v37 = *(_OWORD *)a1;
          long long v36 = *(_OWORD *)(a1 + 16);
          long long v38 = a2[3];
          long long v40 = *a2;
          long long v39 = a2[1];
          *(_OWORD *)(a1 + 32) = a2[2];
          *(_OWORD *)(a1 + 48) = v38;
          *(_OWORD *)a1 = v40;
          *(_OWORD *)(a1 + 16) = v39;
          *a2 = v37;
          a2[1] = v36;
          a2[2] = v35;
          a2[3] = (__int128)result;
        }
      }
    }
  }
  return result;
}

__n128 *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*,PSEmitter::RenderEntry*>(uint64_t a1, __n128 *a2, __n128 *a3, unsigned int (**a4)(__n128 *, __n128 *), __n128 a5)
{
  if ((__n128 *)a1 != a2)
  {
    long long v7 = a2;
    uint64_t v9 = (uint64_t)a2 - a1;
    uint64_t v10 = ((uint64_t)a2 - a1) >> 6;
    if ((uint64_t)a2 - a1 >= 65)
    {
      unint64_t v11 = (unint64_t)(v10 - 2) >> 1;
      unint64_t v12 = v11 + 1;
      long long v13 = (__n128 *)(a1 + (v11 << 6));
      do
      {
        a5 = std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(a1, a4, v10, v13);
        v13 -= 4;
        --v12;
      }
      while (v12);
    }
    long long v14 = v7;
    if (v7 != a3)
    {
      long long v15 = v7;
      do
      {
        if (((unsigned int (*)(__n128 *, uint64_t, __n128))*a4)(v15, a1, a5))
        {
          __n128 v17 = v15[2];
          __n128 v16 = v15[3];
          __n128 v19 = *v15;
          __n128 v18 = v15[1];
          __n128 v20 = *(__n128 *)(a1 + 48);
          __n128 v22 = *(__n128 *)a1;
          __n128 v21 = *(__n128 *)(a1 + 16);
          v15[2] = *(__n128 *)(a1 + 32);
          v15[3] = v20;
          __n128 *v15 = v22;
          v15[1] = v21;
          *(__n128 *)a1 = v19;
          *(__n128 *)(a1 + 16) = v18;
          *(__n128 *)(a1 + 32) = v17;
          *(__n128 *)(a1 + 48) = v16;
          a5 = std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(a1, a4, v10, (__n128 *)a1);
        }
        v15 += 4;
      }
      while (v15 != a3);
      long long v14 = a3;
    }
    if (v9 < 65)
    {
      return v14;
    }
    else
    {
      long long v37 = v14;
      uint64_t v23 = (unint64_t)v9 >> 6;
      do
      {
        uint64_t v24 = 0;
        __n128 v38 = *(__n128 *)a1;
        __n128 v39 = *(__n128 *)(a1 + 16);
        __n128 v40 = *(__n128 *)(a1 + 32);
        __n128 v41 = *(__n128 *)(a1 + 48);
        long long v25 = (_OWORD *)a1;
        do
        {
          long long v26 = (__n128 *)&v25[4 * v24 + 4];
          uint64_t v27 = (2 * v24) | 1;
          uint64_t v28 = 2 * v24 + 2;
          if (v28 < v23 && (*a4)((__n128 *)&v25[4 * v24 + 4], (__n128 *)&v25[4 * v24 + 8]))
          {
            v26 += 4;
            uint64_t v27 = v28;
          }
          __n128 v29 = *v26;
          __n128 v30 = v26[1];
          __n128 v31 = v26[3];
          v25[2] = v26[2];
          v25[3] = v31;
          *long long v25 = v29;
          v25[1] = v30;
          long long v25 = v26;
          uint64_t v24 = v27;
        }
        while (v27 <= (uint64_t)((unint64_t)(v23 - 2) >> 1));
        v7 -= 4;
        if (v26 == v7)
        {
          v26[2] = v40;
          v26[3] = v41;
          *long long v26 = v38;
          v26[1] = v39;
        }
        else
        {
          __n128 v32 = *v7;
          __n128 v33 = v7[1];
          __n128 v34 = v7[3];
          v26[2] = v7[2];
          v26[3] = v34;
          *long long v26 = v32;
          v26[1] = v33;
          *long long v7 = v38;
          v7[1] = v39;
          v7[2] = v40;
          v7[3] = v41;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(a1, (uint64_t)&v26[4], (uint64_t (**)(long long *, long long *))a4, ((uint64_t)&v26[4] - a1) >> 6);
        }
      }
      while (v23-- > 2);
      return v37;
    }
  }
  return a3;
}

__n128 std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(uint64_t a1, unsigned int (**a2)(__n128 *, __n128 *), uint64_t a3, __n128 *a4)
{
  unint64_t v6 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v31 = v4;
    uint64_t v32 = v5;
    long long v7 = a4;
    int64_t v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= ((uint64_t)a4 - a1) >> 6)
    {
      uint64_t v12 = ((uint64_t)a4 - a1) >> 5;
      uint64_t v13 = v12 + 1;
      long long v14 = (__n128 *)(a1 + ((v12 + 1) << 6));
      uint64_t v15 = v12 + 2;
      if (v12 + 2 < a3 && (*a2)(v14, v14 + 4))
      {
        v14 += 4;
        uint64_t v13 = v15;
      }
      if ((((uint64_t (*)(__n128 *, __n128 *))*a2)(v14, v7) & 1) == 0)
      {
        __n128 v17 = v7[1];
        __n128 v27 = *v7;
        __n128 v28 = v17;
        __n128 v18 = v7[3];
        __n128 v29 = v7[2];
        __n128 v30 = v18;
        do
        {
          __n128 v19 = v14;
          __n128 v20 = *v14;
          __n128 v21 = v14[1];
          __n128 v22 = v14[3];
          v7[2] = v14[2];
          v7[3] = v22;
          *long long v7 = v20;
          v7[1] = v21;
          if (v9 < v13) {
            break;
          }
          uint64_t v23 = (2 * v13) | 1;
          long long v14 = (__n128 *)(a1 + (v23 << 6));
          uint64_t v24 = 2 * v13 + 2;
          if (v24 < a3)
          {
            if ((*a2)((__n128 *)(a1 + (v23 << 6)), v14 + 4))
            {
              v14 += 4;
              uint64_t v23 = v24;
            }
          }
          long long v7 = v19;
          uint64_t v13 = v23;
        }
        while (!(*a2)(v14, &v27));
        __n128 result = v27;
        __n128 v25 = v28;
        __n128 v26 = v30;
        v19[2] = v29;
        v19[3] = v26;
        __n128 *v19 = result;
        v19[1] = v25;
      }
    }
  }
  return result;
}

double std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(PSEmitter::RenderEntry const&,PSEmitter::RenderEntry const&),PSEmitter::RenderEntry*>(uint64_t a1, uint64_t a2, uint64_t (**a3)(long long *, long long *), uint64_t a4)
{
  unint64_t v6 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v25 = v4;
    uint64_t v26 = v5;
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = (long long *)(a1 + (v6 >> 1 << 6));
    unint64_t v11 = (long long *)(a2 - 64);
    if ((*a3)(v10, (long long *)(a2 - 64)))
    {
      long long v13 = v11[1];
      long long v21 = *v11;
      long long v22 = v13;
      long long v14 = v11[3];
      long long v23 = v11[2];
      long long v24 = v14;
      do
      {
        uint64_t v15 = v10;
        long long v16 = *v10;
        long long v17 = v10[1];
        long long v18 = v10[3];
        v11[2] = v10[2];
        v11[3] = v18;
        *unint64_t v11 = v16;
        v11[1] = v17;
        if (!v9) {
          break;
        }
        unint64_t v9 = (v9 - 1) >> 1;
        uint64_t v10 = (long long *)(a1 + (v9 << 6));
        unint64_t v11 = v15;
      }
      while (((*a3)(v10, &v21) & 1) != 0);
      long long v19 = v22;
      long long *v15 = v21;
      v15[1] = v19;
      double result = *(double *)&v23;
      long long v20 = v24;
      v15[2] = v23;
      v15[3] = v20;
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*,false>(OZSimStateElement *a1, long long *a2, uint64_t (**a3)(long long *, const OZSimStateElement *), uint64_t a4, char a5)
{
  unint64_t v9 = (const OZSimStateElement *)a2;
  uint64_t v10 = (long long *)a1;
  uint64_t v25 = a2;
  uint64_t v26 = a1;
LABEL_2:
  for (uint64_t i = 1 - a4; ; ++i)
  {
    uint64_t v12 = v9 - (const OZSimStateElement *)v10;
    unint64_t v13 = 0xEF7BDEF7BDEF7BDFLL * ((v9 - (const OZSimStateElement *)v10) >> 3);
    if (!(!v6 & v5))
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          long long v23 = *a3;
          uint64_t v25 = (long long *)((char *)v9 - 248);
          if (((unsigned int (*)(void))v23)()) {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>(&v26, &v25);
          }
          break;
        case 3uLL:
          uint64_t v25 = (long long *)((char *)v9 - 248);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((const OZSimStateElement *)v10, (long long *)((char *)v10 + 248), (long long *)((char *)v9 - 248), a3);
          break;
        case 4uLL:
          uint64_t v25 = (long long *)((char *)v9 - 248);
          std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((const OZSimStateElement *)v10, (long long *)((char *)v10 + 248), v10 + 31, (long long *)((char *)v9 - 248), a3);
          break;
        case 5uLL:
          uint64_t v25 = (long long *)((char *)v9 - 248);
          std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((const OZSimStateElement *)v10, (long long *)((char *)v10 + 248), v10 + 31, (long long *)((char *)v10 + 744), (long long *)((char *)v9 - 248), a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v12 <= 5951)
    {
      if (a5) {
        std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((const OZSimStateElement *)v10, v9, (uint64_t (**)(long long *, uint64_t))a3);
      }
      else {
        std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(v10, v9, (uint64_t (**)(long long *, long long *))a3);
      }
      return;
    }
    if (i == 1) {
      break;
    }
    unint64_t v14 = v13 >> 1;
    uint64_t v15 = (long long *)((char *)v9 - 248);
    if ((unint64_t)v12 >= 0x7C01)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((const OZSimStateElement *)v10, (long long *)((char *)v10 + 248 * (v13 >> 1)), v15, a3);
      uint64_t v16 = 248 * v14;
      uint64_t v17 = 248 * v14 - 248;
      long long v18 = v25;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((OZSimStateElement *)((char *)v26 + 248), (long long *)((char *)v26 + v17), v25 - 31, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((OZSimStateElement *)((char *)v26 + 496), (long long *)((char *)v26 + v16 + 248), (long long *)((char *)v18 - 744), a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((OZSimStateElement *)((char *)v26 + v17), (long long *)((char *)v26 + v16), (long long *)((char *)v26 + v16 + 248), a3);
      long long v24 = (long long *)((char *)v26 + v16);
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *>(&v26, &v24);
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((const OZSimStateElement *)((char *)v10 + 248 * (v13 >> 1)), v10, v15, a3);
      if (a5)
      {
LABEL_13:
        unint64_t v9 = (const OZSimStateElement *)v25;
        goto LABEL_14;
      }
    }
    char v19 = ((uint64_t (*)(char *))*a3)((char *)v26 - 248);
    unint64_t v9 = (const OZSimStateElement *)v25;
    if ((v19 & 1) == 0)
    {
      uint64_t v10 = (long long *)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,OZSimStateElement *,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&)>(v26, v25, (unsigned int (**)(long long *))a3);
LABEL_22:
      a5 = 0;
      uint64_t v26 = (OZSimStateElement *)v10;
      a4 = -i;
      goto LABEL_2;
    }
LABEL_14:
    long long v20 = (long long *)std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,OZSimStateElement *,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&)>(v26, (long long *)v9, (uint64_t (**)(void))a3);
    if ((v21 & 1) == 0) {
      goto LABEL_21;
    }
    int v22 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((long long *)v26, v20, a3);
    uint64_t v10 = (long long *)((char *)v20 + 248);
    if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((long long *)((char *)v20 + 248), (long long *)v9, a3))
    {
      if (v22) {
        return;
      }
      uint64_t v25 = v20;
      uint64_t v10 = (long long *)v26;
      unint64_t v9 = (const OZSimStateElement *)v20;
    }
    else
    {
      if (!v22)
      {
LABEL_21:
        std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*,false>(v26, v20, a3, -i, a5 & 1);
        uint64_t v10 = (long long *)((char *)v20 + 248);
        goto LABEL_22;
      }
      uint64_t v26 = (OZSimStateElement *)((char *)v20 + 248);
    }
  }
  if (v10 != (long long *)v9) {
    std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*,OZSimStateElement*>((OZSimStateElement *)v10, v9, v9, a3);
  }
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>(const OZSimStateElement **a1, long long **a2)
{
  char v2 = *a1;
  uint64_t v3 = *a2;
  OZSimStateElement::OZSimStateElement((OZSimStateElement *)v4, *a1);
  OZSimStateElement::operator=((uint64_t)v2, v3);
  OZSimStateElement::operator=((uint64_t)v3, v4);
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)v4);
}

void sub_1B7DCDAB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)va);
  _Unwind_Resume(a1);
}

void std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(const OZSimStateElement *a1, const OZSimStateElement *a2, uint64_t (**a3)(long long *, uint64_t))
{
  if (a1 != a2)
  {
    char v5 = (const OZSimStateElement *)((char *)a1 + 248);
    if ((const OZSimStateElement *)((char *)a1 + 248) != a2)
    {
      uint64_t v7 = 0;
      long long v8 = a1;
      do
      {
        unint64_t v9 = v8;
        long long v8 = v5;
        if ((*a3)((long long *)v5, (uint64_t)v9))
        {
          OZSimStateElement::OZSimStateElement((OZSimStateElement *)v13, v8);
          uint64_t v10 = v7;
          while (1)
          {
            OZSimStateElement::operator=((uint64_t)a1 + v10 + 248, (long long *)((char *)a1 + v10));
            if (!v10) {
              break;
            }
            char v11 = (*a3)(v13, (uint64_t)a1 + v10 - 248);
            v10 -= 248;
            if ((v11 & 1) == 0)
            {
              uint64_t v12 = (uint64_t)a1 + v10 + 248;
              goto LABEL_10;
            }
          }
          uint64_t v12 = (uint64_t)a1;
LABEL_10:
          OZSimStateElement::operator=(v12, v13);
          OZSimStateElement::~OZSimStateElement((OZSimStateElement *)v13);
        }
        char v5 = (const OZSimStateElement *)((char *)v8 + 248);
        v7 += 248;
      }
      while ((const OZSimStateElement *)((char *)v8 + 248) != a2);
    }
  }
}

void sub_1B7DCDBB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)va);
  _Unwind_Resume(a1);
}

void std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(long long *a1, const OZSimStateElement *a2, uint64_t (**a3)(long long *, long long *))
{
  if (a1 != (long long *)a2)
  {
    uint64_t v4 = a1;
    char v5 = (const OZSimStateElement *)((char *)a1 + 248);
    if ((const OZSimStateElement *)((char *)a1 + 248) != a2)
    {
      do
      {
        uint64_t v7 = v5;
        if ((*a3)((long long *)v5, v4))
        {
          OZSimStateElement::OZSimStateElement((OZSimStateElement *)v8, v7);
          do
          {
            OZSimStateElement::operator=((uint64_t)v4 + 248, v4);
            uint64_t v4 = (long long *)((char *)v4 - 248);
          }
          while (((*a3)(v8, v4) & 1) != 0);
          OZSimStateElement::operator=((uint64_t)v4 + 248, v8);
          OZSimStateElement::~OZSimStateElement((OZSimStateElement *)v8);
        }
        char v5 = (const OZSimStateElement *)((char *)v7 + 248);
        uint64_t v4 = (long long *)v7;
      }
      while ((const OZSimStateElement *)((char *)v7 + 248) != a2);
    }
  }
}

void sub_1B7DCDC88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(const OZSimStateElement *a1, long long *a2, long long *a3, uint64_t (**a4)(long long *, const OZSimStateElement *))
{
  uint64_t v12 = a2;
  unint64_t v13 = a1;
  char v11 = a3;
  char v7 = (*a4)(a2, a1);
  uint64_t result = (*a4)(a3, (const OZSimStateElement *)a2);
  if ((v7 & 1) == 0)
  {
    if (!result) {
      return result;
    }
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>((const OZSimStateElement **)&v12, &v11);
    if (!(*a4)(v12, v13)) {
      return 1;
    }
    unint64_t v9 = &v13;
    uint64_t v10 = &v12;
    goto LABEL_9;
  }
  if (!result)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>(&v13, &v12);
    if (!(*a4)(v11, (const OZSimStateElement *)v12)) {
      return 1;
    }
    unint64_t v9 = (const OZSimStateElement **)&v12;
    uint64_t v10 = &v11;
LABEL_9:
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>(v9, v10);
    return 2;
  }
  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>(&v13, &v11);
  return 1;
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *>(const OZSimStateElement **a1, long long **a2)
{
  char v2 = *a1;
  uint64_t v3 = *a2;
  OZSimStateElement::OZSimStateElement((OZSimStateElement *)v4, *a1);
  OZSimStateElement::operator=((uint64_t)v2, v3);
  OZSimStateElement::operator=((uint64_t)v3, v4);
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)v4);
}

void sub_1B7DCDDDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)va);
  _Unwind_Resume(a1);
}

const OZSimStateElement *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,OZSimStateElement *,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&)>(OZSimStateElement *a1, long long *a2, unsigned int (**a3)(long long *))
{
  unint64_t v13 = (const OZSimStateElement *)a2;
  unint64_t v14 = a1;
  OZSimStateElement::OZSimStateElement((OZSimStateElement *)v12, a1);
  if (((uint64_t (*)(long long *, uint64_t))*a3)(v12, (uint64_t)a2 - 248))
  {
    char v6 = a1;
    do
    {
      char v6 = (const OZSimStateElement *)((char *)v6 + 248);
      unint64_t v14 = v6;
    }
    while ((((uint64_t (*)(long long *, const OZSimStateElement *))*a3)(v12, v6) & 1) == 0);
  }
  else
  {
    char v7 = (OZSimStateElement *)((char *)a1 + 248);
    do
    {
      char v6 = v7;
      unint64_t v14 = v7;
      if (v7 >= v13) {
        break;
      }
      int v8 = ((uint64_t (*)(long long *, const OZSimStateElement *))*a3)(v12, v7);
      char v7 = (const OZSimStateElement *)((char *)v6 + 248);
    }
    while (!v8);
  }
  unint64_t v9 = (long long *)v13;
  if (v6 < v13)
  {
    do
    {
      unint64_t v9 = (long long *)((char *)v9 - 248);
      unint64_t v13 = (const OZSimStateElement *)v9;
    }
    while ((((uint64_t (*)(long long *, long long *))*a3)(v12, v9) & 1) != 0);
    char v6 = v14;
  }
  if (v6 < (const OZSimStateElement *)v9)
  {
    do
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>(&v14, (long long **)&v13);
      do
        unint64_t v14 = (const OZSimStateElement *)((char *)v14 + 248);
      while (!(*a3)(v12));
      do
        unint64_t v13 = (const OZSimStateElement *)((char *)v13 - 248);
      while ((((uint64_t (*)(long long *))*a3)(v12) & 1) != 0);
      char v6 = v14;
    }
    while (v14 < v13);
  }
  if ((const OZSimStateElement *)((char *)v6 - 248) != a1) {
    OZSimStateElement::operator=((uint64_t)a1, (long long *)((char *)v6 - 248));
  }
  OZSimStateElement::operator=((uint64_t)v6 - 248, v12);
  uint64_t v10 = v14;
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)v12);
  return v10;
}

void sub_1B7DCDF60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,OZSimStateElement *,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&)>(OZSimStateElement *a1, long long *a2, uint64_t (**a3)(void))
{
  uint64_t v15 = (const OZSimStateElement *)a2;
  OZSimStateElement::OZSimStateElement((OZSimStateElement *)v14, a1);
  uint64_t v5 = 0;
  do
  {
    uint64_t v16 = (OZSimStateElement *)((char *)a1 + v5 + 248);
    v5 += 248;
  }
  while (((*a3)() & 1) != 0);
  char v6 = (long long *)v15;
  if (v5 == 248)
  {
    unint64_t v9 = (OZSimStateElement *)((char *)a1 + 248);
    do
    {
      if (v9 >= (const OZSimStateElement *)v6) {
        break;
      }
      uint64_t v10 = *a3;
      char v6 = (long long *)((char *)v6 - 248);
      uint64_t v15 = (const OZSimStateElement *)v6;
    }
    while ((((uint64_t (*)(long long *, long long *))v10)(v6, v14) & 1) == 0);
  }
  else
  {
    char v7 = (long long *)((char *)v15 - 248);
    do
    {
      uint64_t v15 = (const OZSimStateElement *)v7;
      int v8 = ((uint64_t (*)(long long *, long long *))*a3)(v7, v14);
      char v7 = (long long *)((char *)v7 - 248);
    }
    while (!v8);
    unint64_t v9 = v16;
  }
  char v11 = v9;
  if (v9 < v15)
  {
    do
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>(&v16, (long long **)&v15);
      do
        uint64_t v16 = (const OZSimStateElement *)((char *)v16 + 248);
      while (((*a3)() & 1) != 0);
      do
        uint64_t v15 = (const OZSimStateElement *)((char *)v15 - 248);
      while (!(*a3)());
      char v11 = v16;
    }
    while (v16 < v15);
  }
  uint64_t v12 = (uint64_t)v11 - 248;
  if ((const OZSimStateElement *)((char *)v11 - 248) != a1) {
    OZSimStateElement::operator=((uint64_t)a1, (long long *)((char *)v11 - 248));
  }
  OZSimStateElement::operator=(v12, v14);
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)v14);
  return v12;
}

void sub_1B7DCE0F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(long long *a1, long long *a2, uint64_t (**a3)(long long *, const OZSimStateElement *))
{
  unint64_t v14 = a2;
  uint64_t v15 = (const OZSimStateElement *)a1;
  BOOL v6 = 1;
  switch(0xEF7BDEF7BDEF7BDFLL * (((char *)a2 - (char *)a1) >> 3))
  {
    case 0uLL:
    case 1uLL:
      return v6;
    case 2uLL:
      char v7 = *a3;
      unint64_t v14 = (long long *)((char *)a2 - 248);
      if (((unsigned int (*)(void))v7)()) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>(&v15, &v14);
      }
      return v6;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((const OZSimStateElement *)a1, (long long *)((char *)a1 + 248), (long long *)((char *)a2 - 248), a3);
      return v6;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((const OZSimStateElement *)a1, (long long *)((char *)a1 + 248), a1 + 31, (long long *)((char *)a2 - 248), a3);
      return v6;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((const OZSimStateElement *)a1, (long long *)((char *)a1 + 248), a1 + 31, (long long *)((char *)a1 + 744), (long long *)((char *)a2 - 248), a3);
      return v6;
    default:
      int v8 = a1 + 31;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((const OZSimStateElement *)a1, (long long *)((char *)a1 + 248), a1 + 31, a3);
      unint64_t v9 = (long long *)((char *)a1 + 744);
      if (v9 == a2) {
        return 1;
      }
      int v10 = 0;
      break;
  }
  while (!(*a3)(v9, (const OZSimStateElement *)v8))
  {
LABEL_12:
    int v8 = v9;
    unint64_t v9 = (long long *)((char *)v9 + 248);
    if (v9 == v14) {
      return 1;
    }
  }
  OZSimStateElement::OZSimStateElement((OZSimStateElement *)v13, (const OZSimStateElement *)v9);
  do
  {
    uint64_t v11 = (uint64_t)v8;
    OZSimStateElement::operator=((uint64_t)v8 + 248, v8);
    if (v8 == (long long *)v15) {
      break;
    }
    int v8 = (long long *)((char *)v8 - 248);
  }
  while (((*a3)(v13, (const OZSimStateElement *)(v11 - 248)) & 1) != 0);
  OZSimStateElement::operator=(v11, v13);
  if (++v10 != 8)
  {
    OZSimStateElement::~OZSimStateElement((OZSimStateElement *)v13);
    goto LABEL_12;
  }
  BOOL v6 = (long long *)((char *)v9 + 248) == v14;
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)v13);
  return v6;
}

void sub_1B7DCE304(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)va);
  _Unwind_Resume(a1);
}

void std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(const OZSimStateElement *a1, long long *a2, long long *a3, long long *a4, uint64_t (**a5)(long long *, const OZSimStateElement *))
{
  uint64_t v12 = a2;
  unint64_t v13 = a1;
  int v10 = a4;
  uint64_t v11 = a3;
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(a1, a2, a3, a5);
  if ((*a5)(a4, (const OZSimStateElement *)a3))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>((const OZSimStateElement **)&v11, &v10);
    if ((*a5)(v11, (const OZSimStateElement *)a2))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>((const OZSimStateElement **)&v12, &v11);
      if ((*a5)(v12, a1)) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>(&v13, &v12);
      }
    }
  }
}

void std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(const OZSimStateElement *a1, long long *a2, long long *a3, long long *a4, long long *a5, uint64_t (**a6)(long long *, const OZSimStateElement *))
{
  uint64_t v15 = a2;
  uint64_t v16 = a1;
  unint64_t v13 = a4;
  unint64_t v14 = a3;
  uint64_t v12 = a5;
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(a1, a2, a3, a4, a6);
  if ((*a6)(a5, (const OZSimStateElement *)a4))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>((const OZSimStateElement **)&v13, &v12);
    if ((*a6)(v13, (const OZSimStateElement *)a3))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>((const OZSimStateElement **)&v14, &v13);
      if ((*a6)(v14, (const OZSimStateElement *)a2))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>((const OZSimStateElement **)&v15, &v14);
        if ((*a6)(v15, a1)) {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>(&v16, &v15);
        }
      }
    }
  }
}

const OZSimStateElement *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*,OZSimStateElement*>(OZSimStateElement *a1, const OZSimStateElement *a2, const OZSimStateElement *a3, uint64_t (**a4)(long long *, const OZSimStateElement *))
{
  uint64_t v15 = a1;
  if (a1 != a2)
  {
    char v7 = a1;
    uint64_t v8 = (a2 - a1) / 248;
    if (a2 - a1 >= 249)
    {
      unint64_t v9 = (unint64_t)(v8 - 2) >> 1;
      unint64_t v10 = v9 + 1;
      uint64_t v11 = (OZSimStateElement *)((char *)a1 + 248 * v9);
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((uint64_t)v7, a4, v8, v11);
        uint64_t v11 = (const OZSimStateElement *)((char *)v11 - 248);
        --v10;
      }
      while (v10);
    }
    unint64_t v14 = a2;
    if (a2 != a3)
    {
      uint64_t v12 = a2;
      do
      {
        if ((*a4)((long long *)v12, v15))
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<OZSimStateElement *&,OZSimStateElement *&>(&v14, (long long **)&v15);
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((uint64_t)v15, a4, v8, v15);
        }
        uint64_t v12 = (const OZSimStateElement *)((char *)v14 + 248);
        unint64_t v14 = v12;
      }
      while (v12 != a3);
      char v7 = v15;
    }
    std::__sort_heap[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(v7, (uint64_t)a2, (unsigned int (**)(uint64_t, uint64_t))a4);
    return v14;
  }
  return a3;
}

void std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(uint64_t a1, uint64_t (**a2)(long long *, const OZSimStateElement *), uint64_t a3, const OZSimStateElement *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v5 = a4;
    int64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= (uint64_t)(0xEF7BDEF7BDEF7BDFLL * (((uint64_t)a4 - a1) >> 3)))
    {
      int64_t v10 = (0xDEF7BDEF7BDEF7BELL * (((uint64_t)a4 - a1) >> 3)) | 1;
      uint64_t v11 = (long long *)(a1 + 248 * v10);
      int64_t v12 = 0xDEF7BDEF7BDEF7BELL * (((uint64_t)a4 - a1) >> 3) + 2;
      if (v12 < a3 && (*a2)((long long *)(a1 + 248 * v10), (const OZSimStateElement *)((char *)v11 + 248)))
      {
        uint64_t v11 = (long long *)((char *)v11 + 248);
        int64_t v10 = v12;
      }
      if (((*a2)(v11, v5) & 1) == 0)
      {
        OZSimStateElement::OZSimStateElement((OZSimStateElement *)v15, v5);
        do
        {
          uint64_t v13 = (uint64_t)v11;
          OZSimStateElement::operator=((uint64_t)v5, v11);
          if (v7 < v10) {
            break;
          }
          uint64_t v14 = (2 * v10) | 1;
          uint64_t v11 = (long long *)(a1 + 248 * v14);
          int64_t v10 = 2 * v10 + 2;
          if (v10 >= a3)
          {
            int64_t v10 = v14;
          }
          else if ((*a2)((long long *)(a1 + 248 * v14), (const OZSimStateElement *)((char *)v11 + 248)))
          {
            uint64_t v11 = (long long *)((char *)v11 + 248);
          }
          else
          {
            int64_t v10 = v14;
          }
          uint64_t v5 = (const OZSimStateElement *)v13;
        }
        while (!(*a2)(v11, (const OZSimStateElement *)v15));
        OZSimStateElement::operator=(v13, v15);
        OZSimStateElement::~OZSimStateElement((OZSimStateElement *)v15);
      }
    }
  }
}

void sub_1B7DCE764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__sort_heap[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(OZSimStateElement *a1, uint64_t a2, unsigned int (**a3)(uint64_t, uint64_t))
{
  if (a2 - (uint64_t)a1 >= 249)
  {
    unint64_t v5 = (a2 - (uint64_t)a1) / 0xF8uLL;
    BOOL v6 = (long long *)(a2 - 248);
    do
    {
      OZSimStateElement::OZSimStateElement((OZSimStateElement *)v12, a1);
      int64_t v7 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((uint64_t)a1, a3, v5);
      uint64_t v8 = v7;
      if (v6 == v7)
      {
        OZSimStateElement::operator=((uint64_t)v7, v12);
      }
      else
      {
        OZSimStateElement::operator=((uint64_t)v7, v6);
        OZSimStateElement::operator=((uint64_t)v6, v12);
        std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>((uint64_t)a1, (uint64_t)v8 + 248, (uint64_t (**)(long long *, long long *))a3, 0xEF7BDEF7BDEF7BDFLL * (((char *)v8 + 248 - (char *)a1) >> 3));
      }
      OZSimStateElement::~OZSimStateElement((OZSimStateElement *)v12);
      BOOL v6 = (long long *)((char *)v6 - 248);
      BOOL v11 = __OFSUB__(v5, 2);
      BOOL v9 = v5 == 2;
      BOOL v10 = (uint64_t)(v5 - 2) < 0;
      --v5;
    }
    while (!(v10 ^ v11 | v9));
  }
}

void sub_1B7DCE884(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)va);
  _Unwind_Resume(a1);
}

long long *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(uint64_t a1, unsigned int (**a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    BOOL v9 = (long long *)(a1 + 248 * v6 + 248);
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)(a1 + 248 * v6 + 248, a1 + 248 * v6 + 496))
    {
      BOOL v9 = (long long *)((char *)v9 + 248);
      uint64_t v10 = v11;
    }
    OZSimStateElement::operator=(a1, v9);
    a1 = (uint64_t)v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

void std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(OZSimStateElement const&,OZSimStateElement const&),OZSimStateElement*>(uint64_t a1, uint64_t a2, uint64_t (**a3)(long long *, long long *), uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = (long long *)(a1 + 248 * (v4 >> 1));
    BOOL v9 = (const OZSimStateElement *)(a2 - 248);
    if ((*a3)(v8, (long long *)(a2 - 248)))
    {
      OZSimStateElement::OZSimStateElement((OZSimStateElement *)v11, v9);
      do
      {
        uint64_t v10 = (uint64_t)v8;
        OZSimStateElement::operator=((uint64_t)v9, v8);
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (long long *)(a1 + 248 * v7);
        BOOL v9 = (const OZSimStateElement *)v10;
      }
      while (((*a3)(v8, v11) & 1) != 0);
      OZSimStateElement::operator=(v10, v11);
      OZSimStateElement::~OZSimStateElement((OZSimStateElement *)v11);
    }
  }
}

void sub_1B7DCEA24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  OZSimStateElement::~OZSimStateElement((OZSimStateElement *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<double,LessThanDouble,std::allocator<double>>::__emplace_unique_key_args<double,double const&>(uint64_t **a1, double *a2, uint64_t *a3)
{
  unint64_t v5 = (uint64_t **)std::__tree<double,LessThanDouble,std::allocator<double>>::__find_equal<double>((uint64_t)a1, &v9, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    unint64_t v7 = v5;
    uint64_t v6 = (uint64_t *)operator new(0x28uLL);
    v6[4] = *a3;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

void *std::__tree<double,LessThanDouble,std::allocator<double>>::__find_equal<double>(uint64_t a1, void *a2, double *a3)
{
  unint64_t v5 = *(uint64_t **)(a1 + 8);
  uint64_t result = (void *)(a1 + 8);
  unint64_t v4 = v5;
  if (v5)
  {
    double v6 = *a3;
    do
    {
      while (1)
      {
        unint64_t v7 = v4;
        double v8 = *((double *)v4 + 4);
        if (v6 >= v8 || vabdd_f64(v6, v8) < 0.0000001) {
          break;
        }
        unint64_t v4 = (uint64_t *)*v4;
        uint64_t result = v7;
        if (!*v7) {
          goto LABEL_12;
        }
      }
      if (v8 >= v6) {
        break;
      }
      if (vabdd_f64(v8, v6) < 0.0000001) {
        break;
      }
      uint64_t result = v4 + 1;
      unint64_t v4 = (uint64_t *)v4[1];
    }
    while (v4);
  }
  else
  {
    unint64_t v7 = result;
  }
LABEL_12:
  *a2 = v7;
  return result;
}

void PSParticle::PSParticle(PSParticle *this)
{
  *(void *)this = &unk_1F118D020;
  char v2 = (long long *)MEMORY[0x1E4F1FA48];
  long long v3 = *MEMORY[0x1E4F1FA48];
  *((void *)this + 3) = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  *(_OWORD *)((char *)this + 8) = v3;
  long long v4 = *v2;
  *((_OWORD *)this + 2) = *v2;
  uint64_t v5 = *((void *)v2 + 2);
  *((void *)this + 6) = v5;
  __asm { FMOV            V1.2D, #1.0 }
  *(_OWORD *)((char *)this + 56) = _Q1;
  *((void *)this + 9) = 0x3FF0000000000000;
  *((_OWORD *)this + 5) = v4;
  *((void *)this + 12) = v5;
  *((void *)this + 13) = 0;
  uint64_t v11 = (PCColor *)((char *)this + 112);
  PCInfo::getDefaultRGBColorSpace(&v12);
  PCColor::PCColor(v11, 1.0, 1.0, 1.0, 1.0, (OZChannelBase *)&v12);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v12);
  *((void *)this + 21) = 0;
  *((unsigned char *)this + 184) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = 0x3FF0000000000000;
  *((_DWORD *)this + 56) = 0;
}

void sub_1B7DCEC04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PSParticle::PSParticle(PSParticle *this, int a2, const CMTime *a3)
{
  *(void *)this = &unk_1F118D020;
  long long v5 = *(_OWORD *)&a3->value;
  *((void *)this + 3) = a3->epoch;
  *(_OWORD *)((char *)this + 8) = v5;
  uint64_t v6 = MEMORY[0x1E4F1FA48];
  long long v7 = *MEMORY[0x1E4F1FA48];
  *((_OWORD *)this + 2) = *MEMORY[0x1E4F1FA48];
  uint64_t v8 = *(void *)(v6 + 16);
  *((void *)this + 6) = v8;
  __asm { FMOV            V1.2D, #1.0 }
  *(_OWORD *)((char *)this + 56) = _Q1;
  *((void *)this + 9) = 0x3FF0000000000000;
  *((_OWORD *)this + 5) = v7;
  *((void *)this + 12) = v8;
  *((void *)this + 13) = 0;
  uint64_t v14 = (PCColor *)((char *)this + 112);
  PCInfo::getDefaultRGBColorSpace(&v15);
  PCColor::PCColor(v14, 1.0, 1.0, 1.0, 1.0, (OZChannelBase *)&v15);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v15);
  *((void *)this + 21) = 0;
  *((unsigned char *)this + 184) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = 0x3FF0000000000000;
  *((_DWORD *)this + 56) = a2;
}

void sub_1B7DCECF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PSParticle::~PSParticle(CGColorSpace **this)
{
  *this = (CGColorSpace *)&unk_1F118D020;
  PCCFRef<CGColorSpace *>::~PCCFRef(this + 20);
}

{
  uint64_t vars8;

  *this = (CGColorSpace *)&unk_1F118D020;
  PCCFRef<CGColorSpace *>::~PCCFRef(this + 20);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PSParticle::simulationIsObjectAlive(PSParticle *this, CMTime *a2)
{
  CMTime time1 = *(CMTime *)((char *)this + 8);
  CMTime time2 = *(CMTime *)((char *)this + 32);
  PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v4);
  CMTime time1 = *a2;
  CMTime time2 = v4;
  return CMTimeCompare(&time1, &time2) >> 31;
}

uint64_t PSParticle::getID(PSParticle *this)
{
  return *((unsigned int *)this + 56);
}

void PSParticle::clone(PSParticle *this)
{
}

void sub_1B7DCEF10(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40AE952B93);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType(PSParticleType *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  OZSceneNode::OZSceneNode(this, a2, a3, a4);
  OZImageNode::OZImageNode((OZImageNode *)(v5 + 1088));
  *(void *)this = &unk_1F118D070;
  *((void *)this + 2) = &unk_1F118D6F0;
  *((void *)this + 6) = &unk_1F118D948;
  *((void *)this + 136) = &unk_1F118D9A0;
  *((void *)this + 139) = &unk_1F118DA78;
  PCURL::PCURL((PCURL *)&v131, @"Particle Type Birth Rate");
  Instance = (PSParticleType::PSParticleType_birthRateChanInfo *)PSParticleType::PSParticleType_birthRateChanImpl::getInstance(v6);
  uint64_t v8 = (OZChannelInfo *)PSParticleType::PSParticleType_birthRateChanInfo::getInstance(Instance);
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 1120), 30.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x65u, 0, (OZChannelImpl *)Instance, v8);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v9, @"Particle Type Birth Rate Variance ");
  uint64_t v11 = (OZChannelImpl *)PSParticleType::PSParticleType_birthRateVarChanImpl::getInstance(v10);
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 1272), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x66u, 0, v11, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v12, @"Particle Type Initial Num");
  uint64_t v14 = (OZChannelImpl *)PSParticleType::PSParticleType_initialNumChanImpl::getInstance(v13);
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 1424), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x67u, 0, v14, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v15, @"Particle Type Lifetime");
  uint64_t v17 = (PSParticleType::PSParticleType_lifetimeChanInfo *)PSParticleType::PSParticleType_lifetimeChanImpl::getInstance(v16);
  long long v18 = (OZChannelInfo *)PSParticleType::PSParticleType_lifetimeChanInfo::getInstance(v17);
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 1576), 5.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x68u, 0, (OZChannelImpl *)v17, v18);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v19, @"Particle Type Lifetime Variance");
  char v21 = (OZChannelImpl *)PSParticleType::PSParticleType_lifetimeVarChanImpl::getInstance(v20);
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 1728), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x69u, 0, v21, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v22, @"Emitter Speed");
  long long v24 = (PSParticleType::PSParticleType_speedChanInfo *)PSParticleType::PSParticleType_speedChanImpl::getInstance(v23);
  uint64_t v25 = (OZChannelInfo *)PSParticleType::PSParticleType_speedChanInfo::getInstance(v24);
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 1880), 100.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x6Au, 0, (OZChannelImpl *)v24, v25);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v26, @"Particle Type Speed Variance");
  __n128 v28 = (PSParticleType::PSParticleType_speedVarChanInfo *)PSParticleType::PSParticleType_speedVarChanImpl::getInstance(v27);
  __n128 v29 = (OZChannelInfo *)PSParticleType::PSParticleType_speedVarChanInfo::getInstance(v28);
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 2032), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x6Bu, 0, (OZChannelImpl *)v28, v29);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v30, @"Particle Type Align Rotation");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 2184), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x84u, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v31, @"Particle Type Rotation");
  OZChannelRotation3D::OZChannelRotation3D((PSParticleType *)((char *)this + 2336), 0.0, 0.0, 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x92u, 0, 4u, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v32, @"Particle Type Rotation End");
  OZChannelRotation3D::OZChannelRotation3D((PSParticleType *)((char *)this + 3192), 0.0, 0.0, 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x93u, 0, 4u, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v33, @"Particle Type Rotation Over Stroke");
  OZChannelAngleOverRange::OZChannelAngleOverRange((PSParticleType *)((char *)this + 4048), 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x91u, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v34, @"Particle Type Rotation Variance");
  long long v36 = (OZChannelInfo *)PSParticleType::PSParticleType_rotVarChanInfo::getInstance(v35);
  OZChannelRotation3D::OZChannelRotation3D((PSParticleType *)((char *)this + 4208), 0.0, 0.0, 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x94u, 0, 4u, 0, v36);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v37, @"Particle Type Spin");
  __n128 v39 = (OZChannelInfo *)PSParticleType::PSParticleType_spinChanInfo::getInstance(v38);
  OZChannelAngle::OZChannelAngle((OZChannelAngle *)((char *)this + 5064), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x6Eu, 0, 0, v39);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v40, @"Particle Type Spin Variance");
  long long v42 = (PSParticleType::PSParticleType_spinVarChanInfo *)PSParticleType::PSParticleType_spinVarChanImpl::getInstance(v41);
  float v43 = (OZChannelInfo *)PSParticleType::PSParticleType_spinVarChanInfo::getInstance(v42);
  OZChannelAngle::OZChannelAngle((OZChannelAngle *)((char *)this + 5216), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x6Fu, 0, (OZChannelImpl *)v42, v43);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v44, @"Particle Type Color Mode Enum");
  PCURL::PCURL((PCURL *)&v132, @"Particle Type Color Mode");
  uint64_t v46 = (OZChannelImpl *)PSParticleType::PSParticleType_colorModeChanImpl::getInstance(v45);
  OZChannelEnum::OZChannelEnum((PSParticleType *)((char *)this + 5368), 0, (const PCString *)&v131, &v132, (OZChannelFolder *)((char *)this + 448), 0x81u, 0, v46, 0);
  PCString::~PCString(&v132);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v47, @"Particle Type Solid Color");
  OZChannelColor::OZChannelColor((PSParticleType *)((char *)this + 5624), 1.0, 1.0, 1.0, 1.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x82u, 0, 6u);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v48, @"Particle Type Color Over Life");
  OZChannelGradient::OZChannelGradient((PSParticleType *)((char *)this + 6784), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x70u, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v49, @"Particle Type Random Color");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 7584), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x72u, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v50, @"Particle Type Color Repetitions");
  double v52 = (OZChannelInfo *)PSParticleType::PSParticleType_colorRepetitionsChanInfo::getInstance(v51);
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 7736), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x71u, 0, 0, v52);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v53, @"Particle Type Take Image Color");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 7888), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x73u, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v54, @"Particle Type Scale");
  OZChannelScale3D::OZChannelScale3D((PSParticleType *)((char *)this + 8040), 1.0, 1.0, 1.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x74u, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v55, @"Particle Type Scale End");
  OZChannelScale3D::OZChannelScale3D((PSParticleType *)((char *)this + 8632), 1.0, 1.0, 1.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x85u, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v56, @"Particle Type Scale Variance");
  double v58 = (PSParticleType::PSParticleType_scaleVarChanInfo *)PSParticleType::PSParticleType_scaleVarChanImpl::getInstance(v57);
  double v59 = (OZChannelInfo *)PSParticleType::PSParticleType_scaleVarChanInfo::getInstance(v58);
  OZChannel3D::OZChannel3D((PSParticleType *)((char *)this + 9224), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x75u, 0, 2u, (OZChannelImpl *)v58, v59);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v60, @"Particle Type Is Premultiplied");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 9816), 0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x77u, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v61, @"Particle Type Is Additive Blend");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 9968), 0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x78u, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v62, @"Particle Type Animate Image");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 10120), 1, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x79u, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v63, @"Particle Type Random Source Start Frame");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 10272), 1, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x7Au, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v64, @"Particle Type Source Start Frame");
  long double v66 = (PSParticleType::PSParticleType_sourceStartFrameChanInfo *)PSParticleType::PSParticleType_sourceStartFrameChanImpl::getInstance(v65);
  __double2 v67 = (OZChannelInfo *)PSParticleType::PSParticleType_sourceStartFrameChanInfo::getInstance(v66);
  OZChannelFrame::OZChannelFrame((OZChannelFrame *)((char *)this + 10424), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x7Bu, 0, (OZChannelImpl *)v66, v67);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v68, @"Particle Type Source Start Frame Offset");
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 10576), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x87u, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v69, @"Particle Type Source Start Frame OS");
  double v71 = (PSParticleType::PSParticleType_sourceStartFrameOSChanInfo *)PSParticleType::PSParticleType_sourceStartFrameOSChanImpl::getInstance(v70);
  double v72 = (OZChannelInfo *)PSParticleType::PSParticleType_sourceStartFrameOSChanInfo::getInstance(v71);
  OZChannelDoubleOverRange::OZChannelDoubleOverRange((PSParticleType *)((char *)this + 10728), 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x95u, 2u, (OZChannelImpl *)v71, v72);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v73, @"Particle Type Hold Frames");
  double v75 = (OZChannelImpl *)PSParticleType::PSParticleType_sourceHoldFramesChanImpl::getInstance(v74);
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 10888), 1, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x7Cu, 0, v75, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v76, @"Particle Type Hold Frames Variance");
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 11040), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x7Du, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v77, @"Particle Type Attach To Emitter");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 11192), 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x7Eu, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v78, @"Particle Type Shape Enum");
  PCURL::PCURL((PCURL *)&v132, @"Particle Type Shape");
  int v80 = (OZChannelImpl *)PSParticleType::PSParticleType_shapeChanImpl::getInstance(v79);
  OZChannelEnum::OZChannelEnum((PSParticleType *)((char *)this + 11344), 3u, (const PCString *)&v131, &v132, (OZChannelFolder *)((char *)this + 448), 0x64u, 0, v80, 0);
  PCString::~PCString(&v132);
  PCString::~PCString((PCString *)&v131);
  LODWORD(v71) = *((_DWORD *)this + 20);
  PCURL::PCURL(v81, @"Particle Type Seed");
  OZChannelSeed::OZChannelSeed((OZChannelSeed *)((char *)this + 11600), v71, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x83u, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v82, @"Particle Type Point Size");
  double v84 = (PSParticleType::PSParticleType_pointSizeChanInfo *)PSParticleType::PSParticleType_pointSizeChanImpl::getInstance(v83);
  unsigned int v85 = (OZChannelInfo *)PSParticleType::PSParticleType_pointSizeChanInfo::getInstance(v84);
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 11752), 2.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x7Fu, 0, (OZChannelImpl *)v84, v85);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v86, @"Particle Type Simulation Folder");
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 11904), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x89u, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCString::PCString(v87, "Hidden Channel");
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 12032), 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 11904), 1u, 2, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v88, @"Particle Type Point Spacing");
  double v90 = (PSParticleType::PSParticleType_pointSpacingChanInfo *)PSParticleType::PSParticleType_pointSpacingChanImpl::getInstance(v89);
  int v91 = (OZChannelInfo *)PSParticleType::PSParticleType_pointSpacingChanInfo::getInstance(v90);
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 12184), 0.25, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x8Au, 0, (OZChannelImpl *)v90, v91);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v92, @"Particle Type Point Spacing OS");
  int v94 = (PSParticleType::PSParticleType_pointSpacingOSChanInfo *)PSParticleType::PSParticleType_pointSpacingOSChanImpl::getInstance(v93);
  int v95 = (OZChannelInfo *)PSParticleType::PSParticleType_pointSpacingOSChanInfo::getInstance(v94);
  OZChannelPercentOverRange::OZChannelPercentOverRange((PSParticleType *)((char *)this + 12336), 1.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x8Bu, 0, (OZChannelImpl *)v94, v95);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v96, @"Particle Type Stroke Width OS");
  int v98 = (PSParticleType::PSParticleType_strokeWidthOSChanInfo *)PSParticleType::PSParticleType_strokeWidthOSChanImpl::getInstance(v97);
  int v99 = (OZChannelInfo *)PSParticleType::PSParticleType_strokeWidthOSChanInfo::getInstance(v98);
  OZChannelPercentOverRange::OZChannelPercentOverRange((PSParticleType *)((char *)this + 12496), 1.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x8Cu, 0, (OZChannelImpl *)v98, v99);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v100, @"Particle Type Is Constant Num Dabs");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 12656), 1, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x8Du, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v101, @"Particle Type Anchor Dabs To Enum");
  PCURL::PCURL((PCURL *)&v132, @"Particle Type Anchor Dabs To");
  int v103 = (OZChannelImpl *)PSParticleType::PSParticleType_anchorDabsToChanImpl::getInstance(v102);
  OZChannelEnum::OZChannelEnum((PSParticleType *)((char *)this + 12808), 1u, (const PCString *)&v131, &v132, (OZChannelFolder *)((char *)this + 448), 0x97u, 0, v103, 0);
  PCString::~PCString(&v132);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v104, @"Particle Type Position Offset");
  OZChannel2D::OZChannel2D((PSParticleType *)((char *)this + 13064), 0.0, 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x8Eu, 0, 2u, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v105, @"Particle Type Position Offset Variance");
  int v107 = (OZChannelImpl *)PSParticleType::PSParticleType_posOffsetVarChanImpl::getInstance(v106);
  OZChannelScale::OZChannelScale((PSParticleType *)((char *)this + 13504), 0.0, 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x8Fu, 0, 2u, v107, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v108, @"Particle Type Position Offset Variance OS");
  OZChannelScaleOverRange::OZChannelScaleOverRange((PSParticleType *)((char *)this + 13944), 0.0, 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x90u, 0, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v109, @"Particle Type Image Node Ref");
  OZChanElementOrFootageRef::OZChanElementOrFootageRef((PSParticleType *)((char *)this + 14392), (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x80u, 0);
  PCString::~PCString((PCString *)&v131);
  PCString::PCString(v110, "Hidden Channel");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14552), 0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x88u, 2u, 0, 0);
  PCString::~PCString((PCString *)&v131);
  double v112 = (PSParticleType::PSParticleType_versionChanImpl *)PCString::PCString(v111, "Hidden Channel");
  double v113 = (OZChannelImpl *)PSParticleType::PSParticleType_versionChanImpl::getInstance(v112);
  OZChannelDouble::OZChannelDouble((PSParticleType *)((char *)this + 14704), 5, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x96u, 2, v113, 0);
  PCString::~PCString((PCString *)&v131);
  PCString::PCString(v114, "Hidden Channel");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14856), 0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x98u, 2u, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCString::PCString(v115, "Obsolete Rotation");
  OZChannelAngle::OZChannelAngle((OZChannelAngle *)((char *)this + 15008), 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x6Cu, 2, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCString::PCString(v116, "Obsolete Rotation End");
  OZChannelAngle::OZChannelAngle((OZChannelAngle *)((char *)this + 15160), 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x86u, 2, 0, 0);
  PCString::~PCString((PCString *)&v131);
  PCString::PCString(v117, "Obsolete Rotational Variance");
  OZChannelAngle::OZChannelAngle((OZChannelAngle *)((char *)this + 15312), 0.0, (const PCString *)&v131, (OZChannelFolder *)((char *)this + 448), 0x6Du, 2, 0, 0);
  PCString::~PCString((PCString *)&v131);
  *((unsigned char *)this + 15464) = 1;
  *((void *)this + 1936) = 0;
  *((void *)this + 1935) = 0;
  *((void *)this + 1934) = (char *)this + 15480;
  *((void *)this + 1939) = 0;
  *((void *)this + 1938) = 0;
  *((void *)this + 1937) = (char *)this + 15504;
  OZSystemSimulator::OZSystemSimulator();
  OZSystemSimulator::OZSystemSimulator();
  OZSystemSimulator::OZSystemSimulator();
  *(_OWORD *)((char *)this + 16408) = 0u;
  *(_OWORD *)((char *)this + 16424) = 0u;
  *(_OWORD *)((char *)this + 16376) = 0u;
  *(_OWORD *)((char *)this + 16392) = 0u;
  *(_OWORD *)((char *)this + 16360) = 0u;
  uint64_t v118 = MEMORY[0x1E4F1FA48];
  long long v119 = *MEMORY[0x1E4F1FA48];
  *(_OWORD *)((char *)this + 16440) = *MEMORY[0x1E4F1FA48];
  uint64_t v120 = *(void *)(v118 + 16);
  *((void *)this + 2057) = v120;
  *((_OWORD *)this + 1029) = v119;
  *((void *)this + 2060) = v120;
  *((unsigned char *)this + 16544) = 0;
  *((unsigned char *)this + 16560) = 0;
  *((_OWORD *)this + 1036) = 0u;
  *(_OWORD *)((char *)this + 16488) = 0u;
  *((void *)this + 2063) = 0;
  *((void *)this + 2071) = (char *)this + 16576;
  *((void *)this + 2076) = 0;
  *((void *)this + 2075) = 0;
  *((void *)this + 2074) = (char *)this + 16600;
  PCSharedMutex::PCSharedMutex((PSParticleType *)((char *)this + 16616));
  *((void *)this + 2092) = 0;
  *((void *)this + 2091) = 0;
  *((void *)this + 2090) = (char *)this + 16728;
  PCSharedMutex::PCSharedMutex((PSParticleType *)((char *)this + 16744));
  *((void *)this + 2108) = 0;
  *((_OWORD *)this + 1053) = 0u;
  PCSharedMutex::PCSharedMutex((PSParticleType *)((char *)this + 16872));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 9816), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 9816));
  OZChannel::setMin((OZChannel *)((char *)this + 4344), 0.0);
  OZChannel::setMin((OZChannel *)((char *)this + 4496), 0.0);
  OZChannel::setMin((OZChannel *)((char *)this + 4648), 0.0);
  OZChannel::setMin((OZChannel *)((char *)this + 12336), 0.01);
  OZChannel::setSliderMin((OZChannel *)((char *)this + 12336), 0.05);
  OZChannel::setMax((OZChannel *)((char *)this + 12336), 3.40282347e38);
  OZChannel::setSliderMax((OZChannel *)((char *)this + 12336), 4.0);
  OZChannel::setMax((OZChannel *)((char *)this + 12496), 3.40282347e38);
  OZChannel::setSliderMax((OZChannel *)((char *)this + 12496), 4.0);
  OZScene::setApplyMotionEffectScaleTo3DObjectRenders((uint64_t)this + 14392, 0);
  OZChanObjectManipRef::setAlwaysUpdateDefaultValue((uint64_t)this + 14392, 1);
  OZChannel::setValueAndIgnoreRecordOption((OZChannel *)((char *)this + 4048), MEMORY[0x1E4F1FA48]);
  OZFigTimeForChannelSeconds(&v131, 1.0, 0x40000);
  OZChannel::setValueAndIgnoreRecordOption((OZChannel *)((char *)this + 4048), &v131);
  OZChannel::setValueAndIgnoreRecordOption((OZChannel *)((char *)this + 12336), MEMORY[0x1E4F1FA48]);
  OZFigTimeForChannelSeconds(&v131, 1.0, 0x40000);
  OZChannel::setValueAndIgnoreRecordOption((OZChannel *)((char *)this + 12336), &v131);
  OZChannel::setValueAndIgnoreRecordOption((OZChannel *)((char *)this + 12496), MEMORY[0x1E4F1FA48]);
  OZFigTimeForChannelSeconds(&v131, 1.0, 0x40000);
  OZChannel::setValueAndIgnoreRecordOption((OZChannel *)((char *)this + 12496), &v131);
  OZChannel::setValueAndIgnoreRecordOption((OZChannel *)((char *)this + 10728), MEMORY[0x1E4F1FA48]);
  OZFigTimeForChannelSeconds(&v131, 1.0, 0x40000);
  OZChannel::setValueAndIgnoreRecordOption((OZChannel *)((char *)this + 10728), &v131);
  (*(void (**)(char *, void))(*((void *)this + 1760) + 728))((char *)this + 14080, MEMORY[0x1E4F1FA48]);
  OZFigTimeForChannelSeconds(&v131, 1.0, 0x40000);
  (*(void (**)(char *, CMTime *))(*((void *)this + 1760) + 728))((char *)this + 14080, &v131);
  (*(void (**)(char *, void))(*((void *)this + 1779) + 728))((char *)this + 14232, MEMORY[0x1E4F1FA48]);
  OZFigTimeForChannelSeconds(&v131, 1.0, 0x40000);
  (*(void (**)(char *, CMTime *))(*((void *)this + 1779) + 728))((char *)this + 14232, &v131);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1728), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1728));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1272), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1272));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1424), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1424));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2032), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 2032));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2184), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 2184));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2336), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 2336));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 3192), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 3192));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 4048), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 4048));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 4208), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 4208));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 5216), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 5216));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 5368), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 5368));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 5624), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 5624));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 6784), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 6784));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 7584), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 7584));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 7736), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 7736));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 7888), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 7888));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 8040), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 8040));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 8632), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 8632));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 9816), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 9816));
  OZChannelBase::resetFlag((OZChannelBase *)this + 89, 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)this + 89);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 10120), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 10120));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 10272), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 10272));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 10424), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 10424));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 10576), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 10576));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 10888), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 10888));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 11040), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 11040));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 11192), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 11192));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 11600), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 11600));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 11752), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 11752));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 11904), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 11904));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12184), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 12184));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12336), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 12336));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12496), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 12496));
  OZChannelBase::resetFlag((OZChannelBase *)this + 113, 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)this + 113);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12808), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 12808));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 13064), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 13064));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 13504), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 13504));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 13944), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 13944));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 14392), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 14392));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 14552), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 14552));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 14704), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 14704));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 14856), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 14856));
  PCURL::PCURL((PCURL *)&v131, @"Particle Type Stroke Range");
  PCString::set((PCString *)this + 525, (const PCString *)&v131);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v121, @"Particle Type Stroke Range");
  PCString::set((PCString *)this + 1561, (const PCString *)&v131);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v122, @"Particle Type Stroke Range");
  PCString::set((PCString *)this + 1581, (const PCString *)&v131);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v123, @"Particle Type Stroke Range");
  PCString::set((PCString *)this + 1798, (const PCString *)&v131);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v124, @"Particle Type Stroke Range");
  PCString::set((PCString *)this + 1360, (const PCString *)&v131);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v125, @"Particle Type Rotation");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 2776), (const PCString *)&v131, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v126, @"Particle Type Rotation End");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 3632), (const PCString *)&v131, 0);
  PCString::~PCString((PCString *)&v131);
  PCURL::PCURL(v127, @"Particle Type Rotation Variance");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 4648), (const PCString *)&v131, 0);
  PCString::~PCString((PCString *)&v131);
  (*(void (**)(PSParticleType *, uint64_t))(*(void *)this + 1528))(this, 1);
  OZChannelFolder::setFoldFlag((OZChannelFolder *)((char *)this + 11904), 8519684);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 11904));
  *(_OWORD *)&v131.value = xmmword_1B83871A0;
  Behavior = (const void *)OZApplication::createBehavior(theApp, (unsigned int *)&v131);
  if (Behavior) {
  else
  }
    double v129 = 0;
  (*(void (**)(PSParticleType *, char *, void))(*(void *)this + 360))(this, v129, 0);
  unsigned int v130 = OZSimulationBehavior::_MTF_IDGenerator--;
  OZChannelBase::setID((OZChannelBase *)(v129 + 56), v130);
}

void sub_1B7DD0AD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, std::mutex *a12, void **a13, std::mutex *a14, OZSystemSimulator *a15, OZChannel *a16, OZSystemSimulator *a17, OZSystemSimulator *a18, void **a19, void **a20,OZChannel *a21,OZChannel *a22,OZChannel *a23,OZChannelEnum *a24,OZChannel3D *a25,OZChannel *a26,OZChannel *a27,OZChannel *a28,OZChannel *a29,OZChannelBase *a30,OZChannel *a31,OZChannelBool *a32,PCString *a33,OZChannel2D *a34,OZChannel2D *a35,OZChannelEnum *a36,OZChannelBool *a37,OZChannelPercent *a38,OZChannel *a39,OZChannel *a40,OZChannelPercent *a41,OZChannel *a42,OZChannel *a43,OZChannel *a44,OZChannel *a45,OZChannelBool *a46,OZChannelBool *a47,OZChannelBool *a48,OZChannelScale3D *a49,OZChannelScale3D *a50,OZChannelBool *a51,OZChannel *a52,OZChannelBool *a53,PCString *a54)
{
  PCSharedMutex::~PCSharedMutex(a11);
  float64_t v63 = *(void **)(v54 + 16848);
  if (v63)
  {
    *(void *)(v54 + 16856) = v63;
    operator delete(v63);
  }
  PCSharedMutex::~PCSharedMutex(a12);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v54 + 16720, *a13);
  PCSharedMutex::~PCSharedMutex(a14);
  std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::destroy(v54 + 16592, *(PCSharedCount **)(v54 + 16600));
  std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::destroy(v54 + 16568, *(void **)(v54 + 16576));
  double v64 = *(void **)(v54 + 16408);
  if (v64)
  {
    *(void *)(v54 + 16416) = v64;
    operator delete(v64);
  }
  double v65 = *(void **)(v54 + 0x4000);
  if (v65)
  {
    *(void *)(v54 + 16392) = v65;
    operator delete(v65);
  }
  long double v66 = *v55;
  if (*v55)
  {
    *(void *)(v54 + 16368) = v66;
    operator delete(v66);
  }
  OZSystemSimulator::~OZSystemSimulator(a15);
  OZSystemSimulator::~OZSystemSimulator(a17);
  OZSystemSimulator::~OZSystemSimulator(a18);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v54 + 15496, *a19);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v54 + 15472, *a20);
  OZChannel::~OZChannel(a21);
  OZChannel::~OZChannel(a22);
  OZChannel::~OZChannel(a16);
  OZChannelBool::~OZChannelBool(v57);
  OZChannel::~OZChannel(a31);
  OZChannelBool::~OZChannelBool(a32);
  OZChanElementOrFootageRef::~OZChanElementOrFootageRef(v60);
  OZChannelScaleOverRange::~OZChannelScaleOverRange(a33);
  OZChannel2D::~OZChannel2D(a34);
  OZChannel2D::~OZChannel2D(a35);
  OZChannelEnum::~OZChannelEnum(a36);
  OZChannelBool::~OZChannelBool(a37);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(v59);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(v56);
  OZChannelPercent::~OZChannelPercent(a38);
  OZChannel::~OZChannel(a23);
  OZChannelFolder::~OZChannelFolder(v58);
  OZChannel::~OZChannel(a39);
  OZChannel::~OZChannel(a40);
  OZChannelEnum::~OZChannelEnum(a24);
  OZChannelPercent::~OZChannelPercent(a41);
  OZChannel::~OZChannel(a42);
  OZChannel::~OZChannel(a43);
  OZChannelDoubleOverRange::~OZChannelDoubleOverRange(a54);
  OZChannel::~OZChannel(a44);
  OZChannel::~OZChannel(a45);
  OZChannelBool::~OZChannelBool(a46);
  OZChannelBool::~OZChannelBool(a47);
  OZChannelBool::~OZChannelBool(a48);
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v61 - 160));
  OZChannel3D::~OZChannel3D(a25);
  OZChannelScale3D::~OZChannelScale3D(a49);
  OZChannelScale3D::~OZChannelScale3D(a50);
  OZChannelBool::~OZChannelBool(a51);
  OZChannel::~OZChannel(a52);
  OZChannelBool::~OZChannelBool(a53);
  OZChannelGradient::~OZChannelGradient(*(OZChannelGradient **)(v61 - 256));
  OZChannelColor::~OZChannelColor(*(OZChannelColor **)(v61 - 248));
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v61 - 240));
  OZChannel::~OZChannel(*(OZChannel **)(v61 - 232));
  OZChannel::~OZChannel(a26);
  OZChannelRotation3D::~OZChannelRotation3D(*(OZChannelRotation3D **)(v61 - 224));
  OZChannelAngleOverRange::~OZChannelAngleOverRange(*(PCString **)(v61 - 152));
  OZChannelRotation3D::~OZChannelRotation3D(*(OZChannelRotation3D **)(v61 - 216));
  OZChannelRotation3D::~OZChannelRotation3D(*(OZChannelRotation3D **)(v61 - 208));
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v61 - 200));
  OZChannel::~OZChannel(*(OZChannel **)(v61 - 192));
  OZChannel::~OZChannel(a27);
  OZChannel::~OZChannel(*(OZChannel **)(v61 - 184));
  OZChannel::~OZChannel(a28);
  OZChannel::~OZChannel(*(OZChannel **)(v61 - 176));
  OZChannel::~OZChannel(*(OZChannel **)(v61 - 168));
  OZChannel::~OZChannel(a29);
  OZChannelBase::setRangeName(a30, v67);
  OZSceneNode::~OZSceneNode((OZSceneNode *)v54);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType(PSParticleType *this, PSParticleType *a2, char a3)
{
  OZSceneNode::OZSceneNode(this, a2, a3);
  OZImageNode::OZImageNode((OZImageNode *)(v5 + 1088));
  *(void *)this = &unk_1F118D070;
  *((void *)this + 2) = &unk_1F118D6F0;
  *((void *)this + 6) = &unk_1F118D948;
  *((void *)this + 136) = &unk_1F118D9A0;
  *((void *)this + 139) = &unk_1F118DA78;
  OZChannel::OZChannel((OZChannel *)((char *)this + 1120), (const OZChannelBase *)a2 + 10, (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 140) = &unk_1F1100CF0;
  *((void *)this + 142) = &unk_1F1101050;
  OZChannel::OZChannel((OZChannel *)((char *)this + 1272), (const OZChannelBase *)((char *)a2 + 1272), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 159) = &unk_1F1100CF0;
  *((void *)this + 161) = &unk_1F1101050;
  OZChannel::OZChannel((OZChannel *)((char *)this + 1424), (const OZChannelBase *)((char *)a2 + 1424), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 178) = &unk_1F1100CF0;
  *((void *)this + 180) = &unk_1F1101050;
  OZChannel::OZChannel((OZChannel *)((char *)this + 1576), (const OZChannelBase *)((char *)a2 + 1576), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 197) = &unk_1F1100CF0;
  *((void *)this + 199) = &unk_1F1101050;
  OZChannel::OZChannel((OZChannel *)((char *)this + 1728), (const OZChannelBase *)((char *)a2 + 1728), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 216) = &unk_1F1100CF0;
  *((void *)this + 218) = &unk_1F1101050;
  OZChannel::OZChannel((OZChannel *)((char *)this + 1880), (const OZChannelBase *)((char *)a2 + 1880), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 235) = &unk_1F1100CF0;
  *((void *)this + 237) = &unk_1F1101050;
  OZChannel::OZChannel((OZChannel *)((char *)this + 2032), (const OZChannelBase *)((char *)a2 + 2032), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 254) = &unk_1F1100CF0;
  *((void *)this + 256) = &unk_1F1101050;
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 2184), (const OZChannelBase *)((char *)a2 + 2184), (OZChannelFolder *)((char *)this + 448));
  OZChannelRotation3D::OZChannelRotation3D((PSParticleType *)((char *)this + 2336), (PSParticleType *)((char *)a2 + 2336), (OZChannelFolder *)((char *)this + 448));
  OZChannelRotation3D::OZChannelRotation3D((PSParticleType *)((char *)this + 3192), (PSParticleType *)((char *)a2 + 3192), (OZChannelFolder *)((char *)this + 448));
  OZChannelAngleOverRange::OZChannelAngleOverRange((PSParticleType *)((char *)this + 4048), (PSParticleType *)((char *)a2 + 4048), (OZChannelFolder *)((char *)this + 448));
  OZChannelRotation3D::OZChannelRotation3D((PSParticleType *)((char *)this + 4208), (PSParticleType *)((char *)a2 + 4208), (OZChannelFolder *)((char *)this + 448));
  OZChannel::OZChannel((OZChannel *)((char *)this + 5064), (const OZChannelBase *)((char *)a2 + 5064), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 633) = &unk_1F11010C0;
  *((void *)this + 635) = &unk_1F1101420;
  OZChannel::OZChannel((OZChannel *)((char *)this + 5216), (const OZChannelBase *)((char *)a2 + 5216), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 652) = &unk_1F11010C0;
  *((void *)this + 654) = &unk_1F1101420;
  OZChannelEnum::OZChannelEnum((PSParticleType *)((char *)this + 5368), (PSParticleType *)((char *)a2 + 5368), (OZChannelFolder *)((char *)this + 448));
  OZChannelColor::OZChannelColor((PSParticleType *)((char *)this + 5624), (PSParticleType *)((char *)a2 + 5624), (OZChannelFolder *)((char *)this + 448));
  OZChannelGradient::OZChannelGradient((PSParticleType *)((char *)this + 6784), (PSParticleType *)((char *)a2 + 6784), (OZChannelFolder *)((char *)this + 448));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 7584), (const OZChannelBase *)((char *)a2 + 7584), (OZChannelFolder *)((char *)this + 448));
  OZChannel::OZChannel((OZChannel *)((char *)this + 7736), (const OZChannelBase *)((char *)a2 + 7736), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 967) = &unk_1F1100CF0;
  *((void *)this + 969) = &unk_1F1101050;
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 7888), (const OZChannelBase *)((char *)a2 + 7888), (OZChannelFolder *)((char *)this + 448));
  OZChannelScale3D::OZChannelScale3D((PSParticleType *)((char *)this + 8040), (PSParticleType *)((char *)a2 + 8040), (OZChannelFolder *)((char *)this + 448));
  OZChannelScale3D::OZChannelScale3D((PSParticleType *)((char *)this + 8632), (PSParticleType *)((char *)a2 + 8632), (OZChannelFolder *)((char *)this + 448));
  OZChannel3D::OZChannel3D((PSParticleType *)((char *)this + 9224), (PSParticleType *)((char *)a2 + 9224), (OZChannelFolder *)((char *)this + 448));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 9816), (const OZChannelBase *)((char *)a2 + 9816), (OZChannelFolder *)((char *)this + 448));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 9968), (const OZChannelBase *)a2 + 89, (OZChannelFolder *)((char *)this + 448));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 10120), (const OZChannelBase *)((char *)a2 + 10120), (OZChannelFolder *)((char *)this + 448));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 10272), (const OZChannelBase *)((char *)a2 + 10272), (OZChannelFolder *)((char *)this + 448));
  OZChannel::OZChannel((OZChannel *)((char *)this + 10424), (const OZChannelBase *)((char *)a2 + 10424), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 1303) = &unk_1F1103310;
  *((void *)this + 1305) = &unk_1F1103670;
  OZChannel::OZChannel((OZChannel *)((char *)this + 10576), (const OZChannelBase *)((char *)a2 + 10576), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 1322) = &unk_1F1100CF0;
  *((void *)this + 1324) = &unk_1F1101050;
  OZChannelDoubleOverRange::OZChannelDoubleOverRange((PSParticleType *)((char *)this + 10728), (PSParticleType *)((char *)a2 + 10728), (OZChannelFolder *)((char *)this + 448));
  OZChannel::OZChannel((OZChannel *)((char *)this + 10888), (const OZChannelBase *)((char *)a2 + 10888), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 1361) = &unk_1F1100CF0;
  *((void *)this + 1363) = &unk_1F1101050;
  OZChannel::OZChannel((OZChannel *)((char *)this + 11040), (const OZChannelBase *)((char *)a2 + 11040), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 1380) = &unk_1F1100CF0;
  *((void *)this + 1382) = &unk_1F1101050;
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 11192), (const OZChannelBase *)((char *)a2 + 11192), (OZChannelFolder *)((char *)this + 448));
  OZChannelEnum::OZChannelEnum((PSParticleType *)((char *)this + 11344), (PSParticleType *)((char *)a2 + 11344), (OZChannelFolder *)((char *)this + 448));
  OZChannel::OZChannel((OZChannel *)((char *)this + 11600), (const OZChannelBase *)((char *)a2 + 11600), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 1450) = &unk_1F1102B70;
  *((void *)this + 1452) = &unk_1F1102ED0;
  OZChannel::OZChannel((OZChannel *)((char *)this + 11752), (const OZChannelBase *)((char *)a2 + 11752), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 1469) = &unk_1F1100CF0;
  *((void *)this + 1471) = &unk_1F1101050;
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 11904), (const OZChannelFolder *)((char *)a2 + 11904), (OZChannelFolder *)((char *)this + 448));
  OZChannel::OZChannel((OZChannel *)((char *)this + 12032), (const OZChannelBase *)((char *)a2 + 12032), (OZChannelFolder *)((char *)this + 11904));
  *((void *)this + 1504) = &unk_1F1100CF0;
  *((void *)this + 1506) = &unk_1F1101050;
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 12184), (const OZChannelBase *)((char *)a2 + 12184), (OZChannelFolder *)((char *)this + 448));
  OZChannelPercentOverRange::OZChannelPercentOverRange((PSParticleType *)((char *)this + 12336), (PSParticleType *)((char *)a2 + 12336), (OZChannelFolder *)((char *)this + 448));
  OZChannelPercentOverRange::OZChannelPercentOverRange((PSParticleType *)((char *)this + 12496), (PSParticleType *)((char *)a2 + 12496), (OZChannelFolder *)((char *)this + 448));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 12656), (const OZChannelBase *)a2 + 113, (OZChannelFolder *)((char *)this + 448));
  OZChannelEnum::OZChannelEnum((PSParticleType *)((char *)this + 12808), (PSParticleType *)((char *)a2 + 12808), (OZChannelFolder *)((char *)this + 448));
  OZChannel2D::OZChannel2D((PSParticleType *)((char *)this + 13064), (PSParticleType *)((char *)a2 + 13064), (OZChannelFolder *)((char *)this + 448));
  OZChannelScale::OZChannelScale((PSParticleType *)((char *)this + 13504), (PSParticleType *)((char *)a2 + 13504), (OZChannelFolder *)((char *)this + 448));
  OZChannelScaleOverRange::OZChannelScaleOverRange((PSParticleType *)((char *)this + 13944), (PSParticleType *)((char *)a2 + 13944), (OZChannelFolder *)((char *)this + 448));
  OZChanElementOrFootageRef::OZChanElementOrFootageRef((PSParticleType *)((char *)this + 14392), (PSParticleType *)((char *)a2 + 14392), (OZChannelFolder *)((char *)this + 448));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14552), (const OZChannelBase *)((char *)a2 + 14552), (OZChannelFolder *)((char *)this + 448));
  OZChannel::OZChannel((OZChannel *)((char *)this + 14704), (const OZChannelBase *)((char *)a2 + 14704), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 1838) = &unk_1F1100CF0;
  *((void *)this + 1840) = &unk_1F1101050;
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14856), (const OZChannelBase *)((char *)a2 + 14856), (OZChannelFolder *)((char *)this + 448));
  OZChannel::OZChannel((OZChannel *)((char *)this + 15008), (const OZChannelBase *)a2 + 134, (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 1876) = &unk_1F11010C0;
  *((void *)this + 1878) = &unk_1F1101420;
  OZChannel::OZChannel((OZChannel *)((char *)this + 15160), (const OZChannelBase *)((char *)a2 + 15160), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 1895) = &unk_1F11010C0;
  *((void *)this + 1897) = &unk_1F1101420;
  OZChannel::OZChannel((OZChannel *)((char *)this + 15312), (const OZChannelBase *)((char *)a2 + 15312), (OZChannelFolder *)((char *)this + 448));
  *((void *)this + 1914) = &unk_1F11010C0;
  *((void *)this + 1916) = &unk_1F1101420;
  *((unsigned char *)this + 15464) = 1;
  *((void *)this + 1936) = 0;
  *((void *)this + 1935) = 0;
  *((void *)this + 1934) = (char *)this + 15480;
  *((void *)this + 1939) = 0;
  *((void *)this + 1938) = 0;
  *((void *)this + 1937) = (char *)this + 15504;
  OZSystemSimulator::OZSystemSimulator((char *)this + 15520, (char *)this + 1112);
  OZSystemSimulator::OZSystemSimulator((char *)this + 15800, (char *)this + 1112);
  OZSystemSimulator::OZSystemSimulator((char *)this + 16080, (char *)this + 1112);
  *(_OWORD *)((char *)this + 16424) = 0u;
  uint64_t v6 = (long long *)MEMORY[0x1E4F1FA48];
  *(_OWORD *)((char *)this + 16392) = 0u;
  *(_OWORD *)((char *)this + 16408) = 0u;
  long long v7 = *v6;
  *(_OWORD *)((char *)this + 16440) = *v6;
  *(_OWORD *)((char *)this + 16360) = 0u;
  *(_OWORD *)((char *)this + 16376) = 0u;
  uint64_t v8 = *((void *)v6 + 2);
  *((void *)this + 2057) = v8;
  *((_OWORD *)this + 1029) = v7;
  *((void *)this + 2060) = v8;
  *(_OWORD *)((char *)this + 16488) = 0u;
  *((unsigned char *)this + 16544) = *((unsigned char *)a2 + 16544);
  *((unsigned char *)this + 16560) = *((unsigned char *)a2 + 16560);
  *((void *)this + 2073) = 0;
  *((void *)this + 2072) = 0;
  *((void *)this + 2071) = (char *)this + 16576;
  *((void *)this + 2076) = 0;
  *((void *)this + 2075) = 0;
  *((void *)this + 2074) = (char *)this + 16600;
  PCSharedMutex::PCSharedMutex((PSParticleType *)((char *)this + 16616));
  *((void *)this + 2092) = 0;
  *((void *)this + 2091) = 0;
  *((void *)this + 2090) = (char *)this + 16728;
  PCSharedMutex::PCSharedMutex((PSParticleType *)((char *)this + 16744));
  *((void *)this + 2108) = 0;
  *((_OWORD *)this + 1053) = 0u;
  PCSharedMutex::PCSharedMutex((PSParticleType *)((char *)this + 16872));
  OZScene::setApplyMotionEffectScaleTo3DObjectRenders((uint64_t)this + 14392, 0);
  OZChanObjectManipRef::setAlwaysUpdateDefaultValue((uint64_t)this + 14392, 1);
  PCURL::PCURL((PCURL *)&v15, @"Particle Type Stroke Range");
  PCString::set((PCString *)this + 525, &v15);
  PCString::~PCString(&v15);
  PCURL::PCURL(v9, @"Particle Type Stroke Range");
  PCString::set((PCString *)this + 1561, &v15);
  PCString::~PCString(&v15);
  PCURL::PCURL(v10, @"Particle Type Stroke Range");
  PCString::set((PCString *)this + 1581, &v15);
  PCString::~PCString(&v15);
  PCURL::PCURL(v11, @"Particle Type Stroke Range");
  PCString::set((PCString *)this + 1798, &v15);
  PCString::~PCString(&v15);
  PCURL::PCURL(v12, @"Particle Type Rotation");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 2776), &v15, 0);
  PCString::~PCString(&v15);
  PCURL::PCURL(v13, @"Particle Type Rotation End");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 3632), &v15, 0);
  PCString::~PCString(&v15);
  PCURL::PCURL(v14, @"Particle Type Rotation Variance");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 4648), &v15, 0);
  PCString::~PCString(&v15);
}

void sub_1B7DD220C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, OZSystemSimulator *a9, OZSystemSimulator *a10, OZSystemSimulator *a11, void **a12, void **a13, OZChannel *a14, OZChannelBool *a15, OZChannel *a16, OZChannelBool *a17, PCString *a18, OZChannel2D *a19, OZChannel2D *a20,OZChannelEnum *a21,OZChannelBool *a22,PCString *a23,PCString *a24,OZChannelPercent *a25,OZChannel *a26,OZChannelFolder *a27,OZChannel *a28,OZChannel *a29,OZChannelEnum *a30,OZChannelPercent *a31,OZChannel *a32,OZChannel *a33,PCString *a34,OZChannel *a35,OZChannel *a36,OZChannelBool *a37,OZChannelBool *a38,OZChannelBool *a39,OZChannelBool *a40,OZChannel3D *a41,OZChannelScale3D *a42,OZChannelScale3D *a43,OZChannelBool *a44)
{
  PCString::~PCString((PCString *)(v53 - 96));
  PCSharedMutex::~PCSharedMutex(v45);
  double v55 = *(void **)(v44 + 16848);
  if (v55)
  {
    *(void *)(v44 + 16856) = v55;
    operator delete(v55);
  }
  PCSharedMutex::~PCSharedMutex(v46);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v44 + 16720, *v49);
  PCSharedMutex::~PCSharedMutex(v47);
  std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::destroy(v44 + 16592, *(PCSharedCount **)(v44 + 16600));
  std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::destroy(v44 + 16568, *(void **)(v44 + 16576));
  double v56 = *(void **)(v44 + 16408);
  if (v56)
  {
    *(void *)(v44 + 16416) = v56;
    operator delete(v56);
  }
  double v57 = *(void **)(v44 + 0x4000);
  if (v57)
  {
    *(void *)(v44 + 16392) = v57;
    operator delete(v57);
  }
  double v58 = *v50;
  if (*v50)
  {
    *(void *)(v44 + 16368) = v58;
    operator delete(v58);
  }
  OZSystemSimulator::~OZSystemSimulator(a9);
  OZSystemSimulator::~OZSystemSimulator(a10);
  OZSystemSimulator::~OZSystemSimulator(a11);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v44 + 15496, *a12);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v44 + 15472, *a13);
  OZChannel::~OZChannel(v52);
  OZChannel::~OZChannel(v51);
  OZChannel::~OZChannel(a14);
  OZChannelBool::~OZChannelBool(a15);
  OZChannel::~OZChannel(a16);
  OZChannelBool::~OZChannelBool(a17);
  OZChanElementOrFootageRef::~OZChanElementOrFootageRef(v48);
  OZChannelScaleOverRange::~OZChannelScaleOverRange(a18);
  OZChannel2D::~OZChannel2D(a19);
  OZChannel2D::~OZChannel2D(a20);
  OZChannelEnum::~OZChannelEnum(a21);
  OZChannelBool::~OZChannelBool(a22);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(a23);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(a24);
  OZChannelPercent::~OZChannelPercent(a25);
  OZChannel::~OZChannel(a26);
  OZChannelFolder::~OZChannelFolder(a27);
  OZChannel::~OZChannel(a28);
  OZChannel::~OZChannel(a29);
  OZChannelEnum::~OZChannelEnum(a30);
  OZChannelPercent::~OZChannelPercent(a31);
  OZChannel::~OZChannel(a32);
  OZChannel::~OZChannel(a33);
  OZChannelDoubleOverRange::~OZChannelDoubleOverRange(a34);
  OZChannel::~OZChannel(a35);
  OZChannel::~OZChannel(a36);
  OZChannelBool::~OZChannelBool(a37);
  OZChannelBool::~OZChannelBool(a38);
  OZChannelBool::~OZChannelBool(a39);
  OZChannelBool::~OZChannelBool(a40);
  OZChannel3D::~OZChannel3D(a41);
  OZChannelScale3D::~OZChannelScale3D(a42);
  OZChannelScale3D::~OZChannelScale3D(a43);
  OZChannelBool::~OZChannelBool(a44);
  OZChannel::~OZChannel(*(OZChannel **)(v53 - 256));
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v53 - 248));
  OZChannelGradient::~OZChannelGradient(*(OZChannelGradient **)(v53 - 240));
  OZChannelColor::~OZChannelColor(*(OZChannelColor **)(v53 - 232));
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v53 - 224));
  OZChannel::~OZChannel(*(OZChannel **)(v53 - 216));
  OZChannel::~OZChannel(*(OZChannel **)(v53 - 208));
  OZChannelRotation3D::~OZChannelRotation3D(*(OZChannelRotation3D **)(v53 - 200));
  OZChannelAngleOverRange::~OZChannelAngleOverRange(*(PCString **)(v53 - 192));
  OZChannelRotation3D::~OZChannelRotation3D(*(OZChannelRotation3D **)(v53 - 184));
  OZChannelRotation3D::~OZChannelRotation3D(*(OZChannelRotation3D **)(v53 - 176));
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v53 - 168));
  OZChannel::~OZChannel(*(OZChannel **)(v53 - 160));
  OZChannel::~OZChannel(*(OZChannel **)(v53 - 152));
  OZChannel::~OZChannel(*(OZChannel **)(v53 - 144));
  OZChannel::~OZChannel(*(OZChannel **)(v53 - 136));
  OZChannel::~OZChannel(*(OZChannel **)(v53 - 128));
  OZChannel::~OZChannel(*(OZChannel **)(v53 - 120));
  OZChannel::~OZChannel(*(OZChannel **)(v53 - 112));
  OZChannelBase::setRangeName(*(OZChannelBase **)(v53 - 104), v59);
  OZSceneNode::~OZSceneNode((OZSceneNode *)v44);
  _Unwind_Resume(a1);
}

void PSParticleType::~PSParticleType(PSParticleType *this)
{
  *(void *)this = &unk_1F118D070;
  *((void *)this + 2) = &unk_1F118D6F0;
  *((void *)this + 6) = &unk_1F118D948;
  char v2 = (OZChannelBase *)((char *)this + 1088);
  *((void *)this + 136) = &unk_1F118D9A0;
  *((void *)this + 139) = &unk_1F118DA78;
  long long v3 = (PSParticleType *)((char *)this + 15520);
  OZSystemSimulator::flushCache((PSParticleType *)((char *)this + 15520), 1, 0);
  OZSystemSimulator::flushCache((PSParticleType *)((char *)this + 15800), 1, 0);
  OZSystemSimulator::flushCache((PSParticleType *)((char *)this + 16080), 1, 0);
  PCSharedMutex::~PCSharedMutex((std::mutex *)((char *)this + 16872));
  CMTime v4 = (void *)*((void *)this + 2106);
  if (v4)
  {
    *((void *)this + 2107) = v4;
    operator delete(v4);
  }
  PCSharedMutex::~PCSharedMutex((std::mutex *)((char *)this + 16744));
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 16720, *((void **)this + 2091));
  PCSharedMutex::~PCSharedMutex((std::mutex *)((char *)this + 16616));
  std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::destroy((uint64_t)this + 16592, *((PCSharedCount **)this + 2075));
  std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::destroy((uint64_t)this + 16568, *((void **)this + 2072));
  uint64_t v5 = (void *)*((void *)this + 2051);
  if (v5)
  {
    *((void *)this + 2052) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 2048);
  if (v6)
  {
    *((void *)this + 2049) = v6;
    operator delete(v6);
  }
  long long v7 = (void *)*((void *)this + 2045);
  if (v7)
  {
    *((void *)this + 2046) = v7;
    operator delete(v7);
  }
  OZSystemSimulator::~OZSystemSimulator((PSParticleType *)((char *)this + 16080));
  OZSystemSimulator::~OZSystemSimulator((PSParticleType *)((char *)this + 15800));
  OZSystemSimulator::~OZSystemSimulator(v3);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 15496, *((void **)this + 1938));
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 15472, *((void **)this + 1935));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 15312));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 15160));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 15008));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 14856));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 14704));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 14552));
  OZChanElementOrFootageRef::~OZChanElementOrFootageRef((PSParticleType *)((char *)this + 14392));
  *((void *)this + 1743) = &unk_1F110E170;
  *((void *)this + 1745) = &unk_1F110E4E8;
  PCString::~PCString((PCString *)this + 1798);
  OZChannel2D::~OZChannel2D((PSParticleType *)((char *)this + 13944));
  OZChannel2D::~OZChannel2D((PSParticleType *)((char *)this + 13504));
  OZChannel2D::~OZChannel2D((PSParticleType *)((char *)this + 13064));
  OZChannelEnum::~OZChannelEnum((PSParticleType *)((char *)this + 12808));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 12656));
  *((void *)this + 1562) = &unk_1F110D998;
  *((void *)this + 1564) = &unk_1F110DD48;
  PCString::~PCString((PCString *)this + 1581);
  OZChanObjectRef::~OZChanObjectRef((PSParticleType *)((char *)this + 12496));
  *((void *)this + 1542) = &unk_1F110D998;
  *((void *)this + 1544) = &unk_1F110DD48;
  PCString::~PCString((PCString *)this + 1561);
  OZChanObjectRef::~OZChanObjectRef((PSParticleType *)((char *)this + 12336));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 12184));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 12032));
  OZChannelFolder::~OZChannelFolder((OZChannelFolder *)((char *)this + 11904));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 11752));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 11600));
  OZChannelEnum::~OZChannelEnum((PSParticleType *)((char *)this + 11344));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 11192));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 11040));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 10888));
  *((void *)this + 1341) = &unk_1F110D188;
  *((void *)this + 1343) = &unk_1F110D538;
  PCString::~PCString((PCString *)this + 1360);
  OZChannel::~OZChannel((OZChannel *)((char *)this + 10728));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 10576));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 10424));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 10272));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 10120));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 9968));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 9816));
  *((void *)this + 1153) = &unk_1F1106258;
  *((void *)this + 1155) = &unk_1F11065B8;
  OZChannel::~OZChannel((OZChannel *)((char *)this + 9664));
  OZChannel2D::~OZChannel2D((PSParticleType *)((char *)this + 9224));
  *((void *)this + 1079) = &unk_1F1110838;
  *((void *)this + 1081) = &unk_1F1110B90;
  OZChannel::~OZChannel((OZChannel *)((char *)this + 9072));
  OZChannel2D::~OZChannel2D((PSParticleType *)((char *)this + 8632));
  *((void *)this + 1005) = &unk_1F1110838;
  *((void *)this + 1007) = &unk_1F1110B90;
  OZChannel::~OZChannel((OZChannel *)((char *)this + 8480));
  OZChannel2D::~OZChannel2D((PSParticleType *)((char *)this + 8040));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 7888));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 7736));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 7584));
  OZChannelGradient::~OZChannelGradient((PSParticleType *)((char *)this + 6784));
  *((void *)this + 703) = &unk_1F1107698;
  *((void *)this + 705) = &unk_1F1107A08;
  OZChannel::~OZChannel((OZChannel *)((char *)this + 6632));
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha((PSParticleType *)((char *)this + 5624));
  OZChannelEnum::~OZChannelEnum((PSParticleType *)((char *)this + 5368));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 5216));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 5064));
  OZChannelRotation3D::~OZChannelRotation3D((PSParticleType *)((char *)this + 4208));
  *((void *)this + 506) = &unk_1F110D590;
  *((void *)this + 508) = &unk_1F110D940;
  PCString::~PCString((PCString *)this + 525);
  OZChannel::~OZChannel((OZChannel *)((char *)this + 4048));
  OZChannelRotation3D::~OZChannelRotation3D((PSParticleType *)((char *)this + 3192));
  OZChannelRotation3D::~OZChannelRotation3D((PSParticleType *)((char *)this + 2336));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 2184));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 2032));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1880));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1728));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1576));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1424));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1272));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1120));
  OZChannelBase::setRangeName(v2, v8);

  OZSceneNode::~OZSceneNode(this);
}

{
  uint64_t vars8;

  PSParticleType::~PSParticleType(this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'PSParticleType::~PSParticleType(PSParticleType *this)
{
}

{
  PSParticleType::~PSParticleType((PSParticleType *)((char *)this - 48));
}

{
  PSParticleType::~PSParticleType((PSParticleType *)((char *)this - 1088));
}

{
  PSParticleType::~PSParticleType((PSParticleType *)((char *)this - 1112));
}

{
  uint64_t vars8;

  PSParticleType::~PSParticleType((PSParticleType *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSParticleType::~PSParticleType((PSParticleType *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSParticleType::~PSParticleType((PSParticleType *)((char *)this - 1088));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSParticleType::~PSParticleType((PSParticleType *)((char *)this - 1112));

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PSParticleType::createParticleType(PSParticleType *this, const PCString *a2)
{
  long long v3 = xmmword_1B8381350;
  return OZApplication::createSceneNode(theApp, (unsigned int *)&v3);
}

uint64_t PSParticleType::operator=(uint64_t a1, const void *a2)
{
  OZSceneNode::operator=(a1, (uint64_t)a2);
  if (!v4) {
    __cxa_bad_cast();
  }
  uint64_t v5 = (const PCString *)v4;
  uint64_t v6 = v4 + 16544;
  long long v7 = v4 + 6624;
  OZChannelBase::operator=(a1 + 11344, (uint64_t)(v4 + 11344));
  OZChannelBase::operator=(a1 + 1120, (uint64_t)&v5[140]);
  OZChannelBase::operator=(a1 + 1272, (uint64_t)&v5[159]);
  OZChannelBase::operator=(a1 + 1424, (uint64_t)&v5[178]);
  OZChannelBase::operator=(a1 + 1576, (uint64_t)&v5[197]);
  OZChannelBase::operator=(a1 + 1728, (uint64_t)&v5[216]);
  OZChannelBase::operator=(a1 + 1880, (uint64_t)&v5[235]);
  OZChannelBase::operator=(a1 + 2032, (uint64_t)&v5[254]);
  OZChannelPosition::operator=(a1 + 2336, (uint64_t)&v5[292]);
  OZChannelPosition::operator=(a1 + 3192, (uint64_t)&v5[399]);
  OZChannelBase::operator=(a1 + 4048, (uint64_t)&v5[506]);
  PCString::set((PCString *)(a1 + 4200), v5 + 525);
  OZChannelPosition::operator=(a1 + 4208, (uint64_t)&v5[526]);
  OZChannelBase::operator=(a1 + 5064, (uint64_t)&v5[633]);
  OZChannelBase::operator=(a1 + 5216, (uint64_t)&v5[652]);
  OZChannelBase::operator=(a1 + 5368, (uint64_t)&v5[671]);
  OZChannelFolder::operator=(a1 + 5624);
  OZChannelBase::operator=(a1 + 5760, (uint64_t)&v5[720]);
  OZChannelBase::operator=(a1 + 5912, (uint64_t)&v5[739]);
  OZChannelBase::operator=(a1 + 6064, (uint64_t)&v5[758]);
  OZChannelBase::operator=(a1 + 6216, (uint64_t)&v5[777]);
  OZChannelBase::operator=(a1 + 6368, (uint64_t)&v5[796]);
  *(unsigned char *)(a1 + 6624) = *v7;
  OZChannelBase::operator=(a1 + 6632, (uint64_t)&v5[829]);
  OZChannelFolder::operator=(a1 + 6784);
  OZChannelFolder::operator=(a1 + 6912);
  OZChannelFolder::operator=(a1 + 7040);
  OZChannelBase::operator=(a1 + 7168, (uint64_t)&v5[896]);
  OZChannelBase::operator=(a1 + 7320, (uint64_t)&v5[915]);
  char v8 = BYTE4(v5[947].var0);
  *(_DWORD *)(a1 + 7576) = v5[947].var0;
  *(unsigned char *)(a1 + 7580) = v8;
  OZChannelBase::operator=(a1 + 7584, (uint64_t)&v5[948]);
  OZChannelBase::operator=(a1 + 7736, (uint64_t)&v5[967]);
  OZChannelBase::operator=(a1 + 7888, (uint64_t)&v5[986]);
  OZChannelFolder::operator=(a1 + 8040);
  OZChannelBase::operator=(a1 + 8176, (uint64_t)&v5[1022]);
  OZChannelBase::operator=(a1 + 8328, (uint64_t)&v5[1041]);
  OZChannelBase::operator=(a1 + 8480, (uint64_t)&v5[1060]);
  OZChannelFolder::operator=(a1 + 8632);
  OZChannelBase::operator=(a1 + 8768, (uint64_t)&v5[1096]);
  OZChannelBase::operator=(a1 + 8920, (uint64_t)&v5[1115]);
  OZChannelBase::operator=(a1 + 9072, (uint64_t)&v5[1134]);
  OZChannelFolder::operator=(a1 + 9224);
  OZChannelBase::operator=(a1 + 9360, (uint64_t)&v5[1170]);
  OZChannelBase::operator=(a1 + 9512, (uint64_t)&v5[1189]);
  OZChannelBase::operator=(a1 + 9664, (uint64_t)&v5[1208]);
  OZChannelBase::operator=(a1 + 9816, (uint64_t)&v5[1227]);
  OZChannelBase::operator=(a1 + 9968, (uint64_t)&v5[1246]);
  OZChannelBase::operator=(a1 + 10120, (uint64_t)&v5[1265]);
  OZChannelBase::operator=(a1 + 10272, (uint64_t)&v5[1284]);
  OZChannelBase::operator=(a1 + 10424, (uint64_t)&v5[1303]);
  OZChannelBase::operator=(a1 + 10576, (uint64_t)&v5[1322]);
  OZChannelBase::operator=(a1 + 10728, (uint64_t)&v5[1341]);
  PCString::set((PCString *)(a1 + 10880), v5 + 1360);
  OZChannelBase::operator=(a1 + 10888, (uint64_t)&v5[1361]);
  OZChannelBase::operator=(a1 + 11040, (uint64_t)&v5[1380]);
  OZChannelBase::operator=(a1 + 11192, (uint64_t)&v5[1399]);
  OZChannelBase::operator=(a1 + 11600, (uint64_t)&v5[1450]);
  OZChannelBase::operator=(a1 + 11752, (uint64_t)&v5[1469]);
  OZChannelFolder::operator=(a1 + 11904);
  OZChannelBase::operator=(a1 + 12032, (uint64_t)&v5[1504]);
  OZChannelFolder::operator=(a1 + 13064);
  OZChannelBase::operator=(a1 + 13200, (uint64_t)&v5[1650]);
  OZChannelBase::operator=(a1 + 13352, (uint64_t)&v5[1669]);
  OZChannelFolder::operator=(a1 + 13504);
  OZChannelBase::operator=(a1 + 13640, (uint64_t)&v5[1705]);
  OZChannelBase::operator=(a1 + 13792, (uint64_t)&v5[1724]);
  OZChannelFolder::operator=(a1 + 13944);
  OZChannelBase::operator=(a1 + 14080, (uint64_t)&v5[1760]);
  OZChannelBase::operator=(a1 + 14232, (uint64_t)&v5[1779]);
  PCString::set((PCString *)(a1 + 14384), v5 + 1798);
  OZChanSceneNodeRef::operator=(a1 + 14392, (uint64_t)&v5[1799]);
  OZChannelBase::operator=(a1 + 14552, (uint64_t)&v5[1819]);
  OZChannelBase::operator=(a1 + 14704, (uint64_t)&v5[1838]);
  OZChannelBase::operator=(a1 + 14856, (uint64_t)&v5[1857]);
  OZChannelBase::operator=(a1 + 15008, (uint64_t)&v5[1876]);
  OZChannelBase::operator=(a1 + 15160, (uint64_t)&v5[1895]);
  OZChannelBase::operator=(a1 + 15312, (uint64_t)&v5[1914]);
  *(unsigned char *)(a1 + 15464) = 1;
  OZSystemSimulator::flushCache((OZSystemSimulator *)(a1 + 15520), 1, 1);
  OZSystemSimulator::flushCache((OZSystemSimulator *)(a1 + 15800), 1, 1);
  uint64_t result = OZSystemSimulator::flushCache((OZSystemSimulator *)(a1 + 16080), 1, 1);
  *(unsigned char *)(a1 + 16544) = *v6;
  *(unsigned char *)(a1 + 16560) = v6[16];
  return result;
}

__n128 PSParticleType::getBounds(uint64_t a1, __n128 *a2)
{
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1336))(a1);
  if (v3)
  {
    CMTime v4 = *(void (**)(void))(*(void *)v3 + 16);
    v4();
  }
  else
  {
    __asm { FMOV            V0.2D, #-1.0 }
    a2[1] = result;
  }
  return result;
}

double non-virtual thunk to'PSParticleType::getBounds(uint64_t a1, __n128 *a2)
{
  *(void *)&double result = PSParticleType::getBounds(a1 - 1088, a2).n128_u64[0];
  return result;
}

uint64_t PSParticleType::getDimensions(PSParticleType *this, float *a2, float *a3, const OZRenderState *a4)
{
  uint64_t result = (*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this);
  if (result)
  {
    long long v7 = *(uint64_t (**)(void))(*(void *)result + 96);
    return v7();
  }
  else
  {
    *a2 = 0.0;
    *a3 = 0.0;
  }
  return result;
}

uint64_t non-virtual thunk to'PSParticleType::getDimensions(PSParticleType *this, float *a2, float *a3, const OZRenderState *a4)
{
  return PSParticleType::getDimensions((PSParticleType *)((char *)this - 1088), a2, a3, a4);
}

uint64_t PSParticleType::getState(PSParticleType *this, int a2, const CMTime *a3, OZSimStateArray **a4, BOOL *a5)
{
  uint64_t result = (*(uint64_t (**)(PSParticleType *))(*(void *)this + 1640))(this);
  if (a2 == 2)
  {
    uint64_t v11 = 16080;
  }
  else if (a2 == 1)
  {
    uint64_t v11 = 15800;
  }
  else
  {
    if (a2) {
      return result;
    }
    uint64_t v11 = 15520;
  }

  return OZSystemSimulator::getState((PSParticleType *)((char *)this + v11), a3, a4, a5);
}

void PSParticleType::getSourceImageBounds(uint64_t a1, const OZRenderState *a2, _OWORD *a3)
{
  float64x2_t v43 = 0uLL;
  __asm { FMOV            V0.2D, #-1.0 }
  long long v44 = _Q0;
  $3CC8671D27C23BF42ADDB32F2B5E48AE var0 = a2->var0;
  __n128 v40 = 0uLL;
  CMTimeEpoch v41 = 0;
  uint64_t v11 = (*(uint64_t (**)(void))(*(void *)a1 + 272))();
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v11 + 336), &v40);
  $3CC8671D27C23BF42ADDB32F2B5E48AE v39 = var0;
  *(__n128 *)&v38.value = v40;
  v38.CMTimeEpoch epoch = v41;
  PC_CMTimeFloorToSampleDuration((CMTime *)&v39, &v38, (uint64_t)&var0);
  PCSharedMutex::lock((std::mutex *)(a1 + 16872));
  int64_t v12 = *(long long **)(a1 + 16848);
  uint64_t v13 = *(long long **)(a1 + 16856);
  while (v12 != v13)
  {
    time1.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = var0;
    uint64_t v14 = *((void *)v12 + 2);
    long long v35 = *v12;
    *(void *)long long v36 = v14;
    if (!CMTimeCompare((CMTime *)&time1, (CMTime *)&v35))
    {
      long long v15 = *(long long *)((char *)v12 + 40);
      *a3 = *(long long *)((char *)v12 + 24);
      a3[1] = v15;
      goto LABEL_27;
    }
    int64_t v12 = (long long *)((char *)v12 + 56);
  }
  OZRenderState::OZRenderState(&time1, a2);
  if (OZChannel::getValueAsInt((OZChannel *)(a1 + 14552), MEMORY[0x1E4F1FA48], 0.0)
    || (uint64_t v16 = *(void *)(a1 + 16504)) == 0)
  {
    (*(void (**)(void, float64x2_t *, OZRenderState *))(**(void **)(a1 + 16488) + 16))(*(void *)(a1 + 16488), &v43, &time1);
  }
  else
  {
    OZElement::getImageBoundsWithDropShadow(v16, &v43, (const CMTime *)&time1);
  }
  float64x2_t v17 = v43;
  long long v18 = v44;
  *a3 = v43;
  a3[1] = v18;
  long long v35 = *(_OWORD *)&var0.var0;
  *(void *)long long v36 = var0.var3;
  *(float64x2_t *)&v36[8] = v17;
  *(_OWORD *)&v36[24] = v18;
  unint64_t v19 = *(void *)(a1 + 16856);
  unint64_t v20 = *(void *)(a1 + 16864);
  if (v19 >= v20)
  {
    uint64_t v22 = *(void *)(a1 + 16848);
    uint64_t v23 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v19 - v22) >> 3);
    unint64_t v24 = v23 + 1;
    if ((unint64_t)(v23 + 1) > 0x492492492492492) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v25 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v20 - v22) >> 3);
    if (2 * v25 > v24) {
      unint64_t v24 = 2 * v25;
    }
    if (v25 >= 0x249249249249249) {
      unint64_t v26 = 0x492492492492492;
    }
    else {
      unint64_t v26 = v24;
    }
    if (v26) {
      __n128 v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSParticleType::SourceBoundsCacheEntry>>(a1 + 16864, v26);
    }
    else {
      __n128 v27 = 0;
    }
    __n128 v28 = &v27[56 * v23];
    __n128 v29 = &v27[56 * v26];
    *(_OWORD *)__n128 v28 = v35;
    *((_OWORD *)v28 + 1) = *(_OWORD *)v36;
    *((_OWORD *)v28 + 2) = *(_OWORD *)&v36[16];
    *((void *)v28 + 6) = *(void *)&v36[32];
    char v21 = v28 + 56;
    __n128 v30 = *(char **)(a1 + 16856);
    uint64_t v31 = *(char **)(a1 + 16848);
    if (v30 != v31)
    {
      do
      {
        long long v32 = *(_OWORD *)(v30 - 56);
        long long v33 = *(_OWORD *)(v30 - 40);
        long long v34 = *(_OWORD *)(v30 - 24);
        *((void *)v28 - 1) = *((void *)v30 - 1);
        *(_OWORD *)(v28 - 24) = v34;
        *(_OWORD *)(v28 - 40) = v33;
        *(_OWORD *)(v28 - 56) = v32;
        v28 -= 56;
        v30 -= 56;
      }
      while (v30 != v31);
      __n128 v30 = *(char **)(a1 + 16848);
    }
    *(void *)(a1 + 16848) = v28;
    *(void *)(a1 + 16856) = v21;
    *(void *)(a1 + 16864) = v29;
    if (v30) {
      operator delete(v30);
    }
  }
  else
  {
    *(_OWORD *)unint64_t v19 = v35;
    *(_OWORD *)(v19 + 16) = *(_OWORD *)v36;
    *(_OWORD *)(v19 + 32) = *(_OWORD *)&v36[16];
    *(void *)(v19 + 48) = *(void *)&v36[32];
    char v21 = (char *)(v19 + 56);
  }
  *(void *)(a1 + 16856) = v21;
LABEL_27:
  PCSharedMutex::unlock((std::mutex *)(a1 + 16872));
}

float64x2_t PSParticleType::getPointParticleBounds(uint64_t a1, float64x2_t *a2, CMTime *a3, float64x2_t *a4)
{
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 11752), a3, 0.0);
  a4[1].f64[0] = *(double *)&v6 + *(double *)&v6;
  a4[1].f64[1] = *(double *)&v6 + *(double *)&v6;
  float64x2_t result = vsubq_f64(a2[11], (float64x2_t)vdupq_lane_s64(v6, 0));
  *a4 = result;
  return result;
}

CGColorSpace **PSParticleType::addProjectedPointParticleBounds(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  v30[12] = *(double *)MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a2 + 8);
  CMTimeEpoch v9 = *(void *)(v8 + 16);
  *(_OWORD *)&v29.value = *(_OWORD *)v8;
  v29.CMTimeEpoch epoch = v9;
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 11752), &v29, 0.0);
  double v11 = v10;
  PSSequencedValues::PSSequencedValues((PSSequencedValues *)v26);
  int64_t v12 = *(const void **)(a3 + 232);
  if (v12) {
  else
  }
    uint64_t v13 = 0;
  uint64_t v14 = (PCArray_base *)(*(uint64_t (**)(uint64_t, CMTime *, void *, unsigned char *))(*(void *)a1 + 1616))(a1, &v29, v13, v26);
  double v15 = *(double *)(a3 + 176) + *(double *)&v27[5];
  float64x2_t v24 = vaddq_f64(*(float64x2_t *)(a3 + 184), v28);
  uint64_t v16 = *(unsigned int *)(a2 + 1452);
  if ((int)v16 < 1)
  {
LABEL_10:
    uint64_t v21 = 0;
    v30[0] = v15 - v11;
    v30[1] = v24.f64[0] - v11;
    v30[2] = v24.f64[1] + 0.0;
    v30[3] = v11 + v15;
    v30[4] = v24.f64[0] - v11;
    v30[5] = v24.f64[1] + 0.0;
    v30[6] = v11 + v15;
    v30[7] = v11 + v24.f64[0];
    char v30[8] = v24.f64[1] + 0.0;
    v30[9] = v15 - v11;
    v30[10] = v11 + v24.f64[0];
    v30[11] = v24.f64[1] + 0.0;
    uint64_t v22 = (double *)(a2 + 1632);
    do
    {
      PCMatrix44Tmpl<double>::transform<double>(v22, &v30[v21], &v30[v21]);
      float64x2_t v25 = *(float64x2_t *)&v30[v21];
      PCRect<double>::operator|=(a4, &v25);
      v21 += 3;
    }
    while (v21 != 12);
  }
  else
  {
    uint64_t v17 = 0;
    uint64_t v18 = 24;
    while (1)
    {
      if (v17 >= *(int *)(a2 + 1452)) {
        PCArray_base::badIndex(v14);
      }
      unint64_t v19 = (double *)(*(void *)(a2 + 1456) + v18);
      float64x2_t v20 = vmulq_f64(v24, *(float64x2_t *)(v19 - 2));
      if (*v19 + v15 * *(v19 - 3) + v20.f64[0] + v20.f64[1] < 0.0) {
        break;
      }
      ++v17;
      v18 += 32;
      if (v16 == v17) {
        goto LABEL_10;
      }
    }
  }
  return PCCFRef<CGColorSpace *>::~PCCFRef(v27);
}

void sub_1B7DD3D18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

float64x2_t PSParticleType::getLineParticleBounds(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v9 = *(double *)(a2 + 16) + *(double *)(a2 + 72);
  float64x2_t v25 = vaddq_f64(*(float64x2_t *)a2, *(float64x2_t *)(a2 + 56));
  double v26 = v9;
  uint64_t v24 = 0x3FF0000000000000;
  uint64_t v21 = 0x3FF0000000000000;
  uint64_t v18 = 0x3FF0000000000000;
  uint64_t v15 = 0x3FF0000000000000;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 1416))(a1, a1 + 15520, &v15, a3, a5, a6, a7, a8);
  PCMatrix44Tmpl<double>::transform<double>((double *)&v15, v25.f64, v25.f64);
  int8x16_t v10 = vbicq_s8((int8x16_t)v25, (int8x16_t)vcltzq_f64(v25));
  int8x16_t v11 = (int8x16_t)vminnmq_f64(v25, (float64x2_t)0);
  int8x16_t v12 = (int8x16_t)vcgtq_f64((float64x2_t)v11, (float64x2_t)v10);
  float64x2_t v13 = (float64x2_t)vbslq_s8(v12, v11, v10);
  float64x2_t result = (float64x2_t)vbslq_s8(v12, v10, v11);
  *a4 = result;
  a4[1] = vsubq_f64(v13, result);
  return result;
}

CGColorSpace **PSParticleType::addProjectedLineParticleBounds(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = *(long long **)(a2 + 8);
  uint64_t v9 = *((void *)v8 + 2);
  long long v59 = *v8;
  uint64_t v60 = v9;
  PSSequencedValues::PSSequencedValues((PSSequencedValues *)v55);
  int8x16_t v10 = *(const void **)(a3 + 232);
  if (v10) {
  else
  }
    int8x16_t v11 = 0;
  (*(void (**)(uint64_t, long long *, void *, unsigned char *))(*(void *)a1 + 1616))(a1, &v59, v11, v55);
  double v12 = *(double *)(a3 + 192) + v58;
  float64x2_t v39 = vaddq_f64(*(float64x2_t *)(a3 + 176), v57);
  float64x2_t v53 = v39;
  double v54 = v12;
  double v13 = *(double *)(a3 + 16) + *(double *)(a3 + 72);
  float64x2_t v51 = vaddq_f64(*(float64x2_t *)a3, *(float64x2_t *)(a3 + 56));
  double v52 = v13;
  uint64_t v50 = 0x3FF0000000000000;
  uint64_t v47 = 0x3FF0000000000000;
  uint64_t v44 = 0x3FF0000000000000;
  uint64_t v41 = 0x3FF0000000000000;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  (*(void (**)(uint64_t, uint64_t, uint64_t *, long long *))(*(void *)a1 + 1416))(a1, a1 + 15520, &v41, &v59);
  uint64_t v14 = PCMatrix44Tmpl<double>::transform<double>((double *)&v41, v51.f64, v51.f64);
  float64x2_t v15 = vaddq_f64(v57, v51);
  float64x2_t v51 = v15;
  double v16 = v58 + v52;
  double v52 = v58 + v52;
  uint64_t v17 = *(unsigned int *)(a2 + 1452);
  if ((int)v17 < 1)
  {
LABEL_21:
    long long v37 = (double *)(a2 + 1632);
    PCMatrix44Tmpl<double>::transform<double>(v37, v53.f64, v53.f64);
    float64x2_t v40 = v53;
    PCRect<double>::operator|=(a4, &v40);
    PCMatrix44Tmpl<double>::transform<double>(v37, v51.f64, v51.f64);
    float64x2_t v40 = v51;
    PCRect<double>::operator|=(a4, &v40);
  }
  else
  {
    uint64_t v18 = 0;
    double v19 = v15.f64[1];
    double v20 = v39.f64[1];
    uint64_t v21 = 16;
    while (1)
    {
      if (v18 >= *(int *)(a2 + 1452)) {
        PCArray_base::badIndex((PCArray_base *)v14);
      }
      long long v22 = (double *)(*(void *)(a2 + 1456) + v21);
      double v24 = *(v22 - 2);
      double v23 = *(v22 - 1);
      double v26 = *v22;
      double v25 = v22[1];
      double v27 = v24 * v39.f64[0] + v23 * v20 + *v22 * v12;
      double v28 = v24 * v15.f64[0] + v23 * v19 + *v22 * v16;
      double v29 = v25 + v28;
      if (v25 + v27 < 0.0 && v29 < 0.0) {
        break;
      }
      if (v25 + v27 < 0.0)
      {
        double v35 = v24 * (v39.f64[0] - v15.f64[0]) + v23 * (v20 - v19) + v26 * (v12 - v16);
        if (v35 > -0.0000001 && v35 < 0.0000001) {
          return PCCFRef<CGColorSpace *>::~PCCFRef(&v56);
        }
        double v36 = (-v28 - v25) / v35;
        if (v36 <= 0.0) {
          return PCCFRef<CGColorSpace *>::~PCCFRef(&v56);
        }
        double v20 = v19 + (v20 - v19) * v36;
        double v12 = v16 + (v12 - v16) * v36;
        v39.f64[0] = v15.f64[0] + (v39.f64[0] - v15.f64[0]) * v36;
        v53.f64[0] = v39.f64[0];
        v53.f64[1] = v20;
        double v54 = v12;
      }
      else if (v29 < 0.0)
      {
        double v30 = v15.f64[0] - v39.f64[0];
        double v31 = v19 - v20;
        double v32 = v16 - v12;
        double v33 = v24 * v30 + v23 * v31 + v26 * v32;
        if (v33 > -0.0000001 && v33 < 0.0000001) {
          return PCCFRef<CGColorSpace *>::~PCCFRef(&v56);
        }
        double v34 = (-v27 - v25) / v33;
        if (v34 <= 0.0) {
          return PCCFRef<CGColorSpace *>::~PCCFRef(&v56);
        }
        v15.f64[0] = v39.f64[0] + v30 * v34;
        double v19 = v20 + v31 * v34;
        double v16 = v12 + v32 * v34;
        v51.f64[0] = v15.f64[0];
        v51.f64[1] = v19;
        double v52 = v16;
      }
      ++v18;
      v21 += 32;
      if (v17 == v18) {
        goto LABEL_21;
      }
    }
  }
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v56);
}

void sub_1B7DD4214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,CGColorSpace *a46)
{
}

float64x2_t PSParticleType::getImageParticleBounds(uint64_t a1, uint64_t a2, OZRenderState *a3, float64x2_t *a4)
{
  if (*(void *)(a1 + 16488)
    || ((*(void (**)(uint64_t))(*(void *)a1 + 1640))(a1), *(void *)(a1 + 16488)))
  {
    uint64_t v8 = *(const void **)(a2 + 232);
    if (v8) {
    else
    }
      uint64_t v9 = 0;
    $3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *($3CC8671D27C23BF42ADDB32F2B5E48AE *)(v9 + 80);
    if (*((double *)v9 + 13) > 0.0)
    {
      long long v59 = 0uLL;
      uint64_t v60 = 0;
      v54.var0.int64_t var3 = a3->var0.var3;
      *(_OWORD *)&v54.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)&a3->var0.var0;
      long long v10 = *(_OWORD *)(v9 + 8);
      v43.CMTimeEpoch epoch = *((void *)v9 + 3);
      *(_OWORD *)&v43.value = v10;
      PC_CMTimeSaferSubtract((CMTime *)&v54, &v43, (uint64_t)&v59);
      operator/(&v59, (uint64_t)&v52, *((double *)v9 + 13));
      v54.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = var0;
      *(_OWORD *)&v43.value = v52;
      v43.CMTimeEpoch epoch = v53;
      PC_CMTimeSaferAdd((CMTime *)&v54, &v43, (uint64_t)&var0);
      long long v57 = *(_OWORD *)(a1 + 16464);
      uint64_t v58 = *(void *)(a1 + 16480);
      long long v55 = 0uLL;
      int64_t var3 = 0;
      operator/((long long *)&var0.var0, (uint64_t)&v57, (uint64_t)&v55);
      CMTimeMake(&v62, 1, 1);
      *(_OWORD *)&v54.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v55;
      v54.var0.int64_t var3 = var3;
      CMTime v43 = v62;
      PC_CMTimeFloorToSampleDuration((CMTime *)&v54, &v43, (uint64_t)&v63);
      *(_OWORD *)&v54.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v55;
      v54.var0.int64_t var3 = var3;
      CMTime v43 = v63;
      PC_CMTimeSaferSubtract((CMTime *)&v54, &v43, (uint64_t)&v52);
      operator*(&v52, (uint64_t)&v57, (uint64_t)&v54);
      int64_t var3 = v54.var0.var3;
      long long v55 = *(_OWORD *)&v54.var0.var0;
      $3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v54.var0;
    }
    long long v11 = *(_OWORD *)(a1 + 16440);
    *(void *)&long long v53 = *(void *)(a1 + 16456);
    long long v52 = v11;
    CMTime v43 = (CMTime)var0;
    PC_CMTimeSaferAdd(&v43, (CMTime *)&v52, (uint64_t)&v54);
    $3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v54.var0;
    OZRenderState::OZRenderState(&v54, a3);
    v54.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = var0;
    long long v52 = 0uLL;
    __asm { FMOV            V0.2D, #-1.0 }
    long long v53 = _Q0;
    PSParticleType::getSourceImageBounds(a1, &v54, &v52);
    double v42 = *((double *)&v52 + 1) + *((double *)&v53 + 1);
    int8x16_t v40 = (int8x16_t)v52;
    double v41 = *(double *)&v52 + *(double *)&v53;
    double v51 = 1.0;
    uint64_t v48 = 0x3FF0000000000000;
    float64_t v45 = 1.0;
    v43.value = 0x3FF0000000000000;
    *(_OWORD *)&v43.timescale = 0u;
    long long v44 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    PSParticleType::getImageParticleMatrix((CGColorSpace **)a1, (CMTime *)a3, (uint64_t)v9, (double *)a2, (uint64_t)&v43, 0);
    double v17 = vmuld_lane_f64(*(double *)&v50, (float64x2_t)v40, 1);
    v19.f64[0] = *(float64_t *)&v43.timescale;
    *(void *)&v18.f64[0] = v43.value;
    *(void *)&v20.f64[0] = v44;
    v21.f64[0] = *(float64_t *)&v43.timescale;
    v21.f64[1] = *((float64_t *)&v44 + 1);
    float64x2_t v22 = vmulq_f64((float64x2_t)vextq_s8(v40, v40, 8uLL), v21);
    *(void *)&v21.f64[0] = v43.value;
    v21.f64[1] = v45;
    float64x2_t v23 = vmulq_f64((float64x2_t)v40, v21);
    v20.f64[1] = *((float64_t *)&v46 + 1);
    int8x16_t v24 = (int8x16_t)vdivq_f64(vaddq_f64(v20, vaddq_f64(v22, v23)), (float64x2_t)vdupq_lane_s64(COERCE__INT64(v51 + *((double *)&v49 + 1) * *(double *)v40.i64 + v17), 0));
    v18.f64[1] = *((float64_t *)&v44 + 1);
    float64x2_t v25 = vmulq_n_f64(v18, v41);
    v26.f64[0] = v22.f64[0];
    v26.f64[1] = v23.f64[1];
    int8x16_t v27 = (int8x16_t)vdivq_f64(vaddq_f64(v20, vaddq_f64(v25, v26)), (float64x2_t)vdupq_lane_s64(COERCE__INT64(v51 + v41 * *((double *)&v49 + 1) + v17), 0));
    v19.f64[1] = v45;
    float64x2_t v28 = vmulq_n_f64(v19, v42);
    v23.f64[1] = v22.f64[1];
    int8x16_t v29 = (int8x16_t)vdivq_f64(vaddq_f64(v20, vaddq_f64(v28, v25)), (float64x2_t)vdupq_lane_s64(COERCE__INT64(v51 + v41 * *((double *)&v49 + 1) + v42 * *(double *)&v50), 0));
    int8x16_t v30 = (int8x16_t)vdivq_f64(vaddq_f64(v20, vaddq_f64(v23, v28)), (float64x2_t)vdupq_lane_s64(COERCE__INT64(v51 + *((double *)&v49 + 1) * *(double *)v40.i64+ v42 * *(double *)&v50), 0));
    int8x16_t v31 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v27, (float64x2_t)v24), v27, v24);
    int8x16_t v32 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v30, (float64x2_t)v29), v30, v29);
    int8x16_t v33 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v32, (float64x2_t)v31), v32, v31);
    int8x16_t v34 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v24, (float64x2_t)v27), v27, v24);
    int8x16_t v35 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v29, (float64x2_t)v30), v30, v29);
    int8x16_t v36 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v34, (float64x2_t)v35), v35, v34);
    int8x16_t v37 = (int8x16_t)vcgtq_f64((float64x2_t)v36, (float64x2_t)v33);
    float64x2_t v38 = (float64x2_t)vbslq_s8(v37, v36, v33);
    float64x2_t result = (float64x2_t)vbslq_s8(v37, v33, v36);
    *a4 = result;
    a4[1] = vsubq_f64(v38, result);
  }
  else
  {
    __asm { FMOV            V0.2D, #-1.0 }
    a4[1] = result;
  }
  return result;
}

CGColorSpace **PSParticleType::getImageParticleMatrix(CGColorSpace **result, CMTime *a2, uint64_t a3, double *a4, uint64_t a5, int a6)
{
  if (result[2061])
  {
    long long v11 = result;
    CMTime v123 = *a2;
    CMTime v122 = *a2;
    memset(v121, 0, sizeof(v121));
    uint64_t v12 = a3 + 8;
    *(_OWORD *)&v92.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)&a2->value;
    v92.var0.int64_t var3 = a2->epoch;
    CMTime v109 = *(CMTime *)(a3 + 8);
    v13.n128_f64[0] = PC_CMTimeSaferSubtract((CMTime *)&v92, &v109, (uint64_t)v121);
    __n128 v119 = 0uLL;
    uint64_t v14 = *((void *)v11[2054] + 25);
    uint64_t v120 = 0;
    uint64_t v15 = (*(uint64_t (**)(__n128))(v14 + 272))(v13);
    OZSceneSettings::getFrameDuration((OZSceneSettings *)(v15 + 336), &v119);
    __asm { FMOV            V0.2D, #1.0 }
    float64x2_t v117 = _Q0;
    double v118 = 1.0;
    (*((void (**)(CGColorSpace **, void *, uint64_t, uint64_t, float64x2_t *))*v11 + 201))(v11, v121, a3 + 32, v12, &v117);
    PSSequencedValues::PSSequencedValues((PSSequencedValues *)&v109);
    (*((void (**)(CGColorSpace **, CMTime *, uint64_t, CMTime *))*v11 + 202))(v11, &v122, a3, &v109);
    float64x2_t v117 = vmulq_f64(vmulq_f64(*(float64x2_t *)(a3 + 56), v117), v112);
    double v118 = *(double *)(a3 + 72) * v118 * v113;
    double v88 = (*(double (**)(CGColorSpace *))(*(void *)v11[2054] + 352))(v11[2054]);
    double v108 = 1.0;
    double v107 = 1.0;
    double v106 = 1.0;
    double v105 = 0.0;
    double v104 = 0.0;
    double v103 = 0.0;
    float64_t v102 = 0.0;
    double v101 = 0.0;
    double v26 = 0.0;
    double v27 = 1.0;
    float64x2_t v28 = (OZTransformNode *)v11[2062];
    if (!v28)
    {
      int v30 = 0;
      double v29 = 1.0;
      goto LABEL_7;
    }
    double v29 = *((double *)v11 + 2065);
    if (!*((unsigned char *)v11 + 16512)
      || (OZTransformNode::getPivot(v28, &v105, &v104, &v103, &v123),
          OZChannel::getValueAsInt((OZChannel *)(v11 + 1819), MEMORY[0x1E4F1FA48], 0.0)))
    {
      int v30 = 0;
LABEL_7:
      double v31 = 0.0;
      double v32 = 0.0;
      double v33 = 0.0;
      double v34 = 0.0;
      double v35 = 0.0;
      goto LABEL_8;
    }
    BOOL v100 = 0;
    Float64 v99 = 0.0;
    PSParticleType::getSequenceCompletion((PSParticleType *)v11, &v122, *(double *)(a3 + 176), &v100, &v99);
    if (v100)
    {
      memset(&v98, 0, sizeof(v98));
      *(_OWORD *)&v92.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *((_OWORD *)v11 + 1029);
      v92.var0.int64_t var3 = (int64_t)v11[2060];
      *(__n128 *)double v124 = v119;
      *(void *)&v124[16] = v120;
      PC_CMTimeSaferSubtract((CMTime *)&v92, (CMTime *)v124, (uint64_t)&v98);
      long long v94 = *(_OWORD *)(v11 + 2055);
      int64_t v95 = (int64_t)v11[2057];
      operator*(&v98, &v93, v99);
      *(_OWORD *)&v92.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v94;
      v92.var0.int64_t var3 = v95;
      *(CMTime *)double v124 = v93;
      PC_CMTimeSaferAdd((CMTime *)&v92, (CMTime *)v124, (uint64_t)&v96);
      *(_OWORD *)&v89.value = v96;
      CMTimeEpoch epoch = *(void *)&v97;
    }
    else
    {
      *(_OWORD *)&v89.value = *(_OWORD *)&v122.value;
      CMTimeEpoch epoch = v122.epoch;
    }
    v89.CMTimeEpoch epoch = epoch;
    long long v64 = *(_OWORD *)(v11 + 2055);
    *(void *)&v124[16] = v11[2057];
    *(_OWORD *)double v124 = v64;
    memset(&v98, 0, sizeof(v98));
    OZTransformNode::getTranslation((uint64_t)v11[2062], &v98, (CMTime *)v124);
    OZRenderState::OZRenderState(&v92, (const OZRenderState *)a2);
    v92.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = ($3CC8671D27C23BF42ADDB32F2B5E48AE)v89;
    long long v96 = 0uLL;
    double v97 = 0.0;
    OZTransformNode::getTranslation((uint64_t)v11[2062], &v96, &v89);
    double v66 = *((double *)&v96 + 1);
    double v65 = *(double *)&v96;
    double v67 = *(double *)&v98.timescale;
    double v86 = *(double *)&v98.value;
    double v87 = v97;
    double v85 = *(double *)&v98.epoch;
    (*(void (**)(CGColorSpace *, double *, double *, double *, OZRenderState *, void))(*(void *)v11[2062]
                                                                                                  + 1312))(v11[2062], &v108, &v107, &v106, &v92, 0);
    *(void *)&long long v94 = 0;
    v93.value = 0;
    double v91 = 0.0;
    if (a6)
    {
      OZTransformNode::getRotationX((OZTransformNode *)v11[2062], (double *)&v94, &v89);
      OZTransformNode::getRotationY((OZTransformNode *)v11[2062], (double *)&v93.value, &v89);
    }
    OZTransformNode::getRotationZ((OZTransformNode *)v11[2062], &v91, &v89);
    double v84 = v67;
    double v68 = *(double *)&v93.value;
    if (*(double *)&v94 <= -0.0000001 || *(double *)&v94 >= 0.0000001)
    {
      double v69 = v91;
    }
    else
    {
      double v69 = v91;
      if (*(double *)&v93.value > -0.0000001
        && *(double *)&v93.value < 0.0000001
        && v91 > -0.0000001
        && v91 < 0.0000001)
      {
        int v30 = 0;
        double v31 = 0.0;
        double v32 = 0.0;
LABEL_43:
        OZTransformNode::getShear((OZTransformNode *)v11[2062], &v102, &v101, &v89);
        double v33 = v65 - v86;
        double v34 = v66 - v84;
        double v35 = v87 - v85;
LABEL_8:
        double v36 = v108 * (v29 * v117.f64[0] / v88);
        double v37 = v117.f64[1] * v107;
        double v38 = v118 * v106;
        double v39 = a4[23];
        double v40 = a4[22] + v114;
        v117.f64[0] = v36;
        v117.f64[1] = v117.f64[1] * v107;
        double v118 = v118 * v106;
        double v41 = v39 + v115;
        if (a6)
        {
          double v42 = v35 + a4[24] + v116;
        }
        else
        {
          double v103 = 0.0;
          double v42 = 0.0;
        }
        double v43 = v33 + v40;
        double v44 = v34 + v41;
        if (v30)
        {
          double v45 = *(double *)&v109.epoch;
          double v46 = v110;
        }
        else
        {
          double v45 = *(double *)&v109.epoch;
          double v46 = v110;
          double v47 = *(double *)&v109.timescale * *(double *)&v109.timescale + v45 * v45 + v46 * v46;
          if (v47 > -0.0000001 && v47 < 0.0000001)
          {
            double v48 = a4[4] * a4[4] + a4[5] * a4[5] + a4[6] * a4[6];
            if (v48 > -0.0000001
              && v48 < 0.0000001
              && v102 > -0.0000001
              && v102 < 0.0000001
              && v101 > -0.0000001
              && v101 < 0.0000001)
            {
              *(void *)(a5 + 120) = 0x3FF0000000000000;
              *(_OWORD *)(a5 + 8) = 0u;
              *(_OWORD *)(a5 + 24) = 0u;
              *(_OWORD *)(a5 + 48) = 0u;
              *(_OWORD *)(a5 + 64) = 0u;
              *(_OWORD *)(a5 + 88) = 0u;
              *(_OWORD *)(a5 + 104) = 0u;
              *(double *)a5 = v36;
              *(double *)(a5 + 40) = v37;
              *(double *)(a5 + 80) = v38;
              PCMatrix44Tmpl<double>::leftTranslate((float64x2_t *)a5, (float64x2_t)*(unint64_t *)&v43, v44, v42);
              if (v88 != 1.0)
              {
                *(double *)(a5 + 32) = v88 * *(double *)(a5 + 32);
                *(double *)(a5 + 64) = v88 * *(double *)(a5 + 64);
                *(float64x2_t *)(a5 + 8) = vdivq_f64(*(float64x2_t *)(a5 + 8), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v88, 0));
              }
              PCMatrix44Tmpl<double>::rightTranslate((double *)a5, -v105, -v104, -v103);
              return PCCFRef<CGColorSpace *>::~PCCFRef(&v111);
            }
          }
        }
        double v49 = v27 * *(double *)&v109.value - (v32 * *(double *)&v109.timescale + v31 * v45 + v26 * v46);
        double v50 = v31 * *(double *)&v109.value + v27 * v45;
        double v51 = v26 * *(double *)&v109.value + v27 * v46;
        double v52 = v31 * *(double *)&v109.timescale - v32 * v45;
        double v53 = v32 * *(double *)&v109.value + v27 * *(double *)&v109.timescale + v26 * v45 - v31 * v46;
        double v54 = v50 + v32 * v46 - v26 * *(double *)&v109.timescale;
        double v55 = v52 + v51;
        double v56 = a4[3];
        double v57 = a4[4];
        double v58 = a4[5];
        double v59 = a4[6];
        *(double *)&v89.value = v56 * v49 - (v53 * v57 + v54 * v58 + v55 * v59);
        *(double *)&v89.timescale = v56 * v53 + v49 * v57 + v54 * v59 - v55 * v58;
        *(double *)&v89.CMTimeEpoch epoch = v56 * v54 + v49 * v58 + v57 * v55 - v53 * v59;
        double v90 = v53 * v58 - v57 * v54 + v56 * v55 + v49 * v59;
        if ((a6 & 1) == 0)
        {
          v92.var7.var0[1][2] = 1.0;
          v92.var7.var0[0][1] = 1.0;
          v92.int64_t var3 = 1.0;
          v92.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0x3FF0000000000000;
          memset(&v92.var0.var1, 0, 32);
          memset(&v92.var4, 0, 32);
          memset(&v92.var7.var0[0][2], 0, 32);
          PCMatrix44Tmpl<double>::setRotationFromQuaternion((uint64_t)&v92, (double *)&v89.value);
          long long v125 = 0u;
          memset(v124, 0, sizeof(v124));
          long long v127 = 0u;
          long long v128 = 0u;
          uint64_t v129 = 0;
          int v126 = 4;
          PCMatrix44Tmpl<double>::getTransformation((long long *)&v92.var0.var0, (uint64_t)v124);
          __double2 v60 = __sincos_stret(*(double *)&v128 * 0.5);
          double v61 = v60.__sinval * 0.0 * 0.0;
          double v62 = v60.__sinval * 0.0 + v60.__cosval * 0.0;
          *(double *)&v89.CMTimeEpoch epoch = v62 + v61 - v60.__sinval * 0.0;
          double v90 = v60.__sinval + v60.__cosval * 0.0 + v61 - v61;
          *(double *)&v89.value = v60.__cosval - (v60.__sinval * 0.0 + v61 + v61);
          *(double *)&v89.timescale = v62 + v60.__sinval * 0.0 - v61;
          double v37 = v117.f64[1];
          double v36 = v117.f64[0];
          double v38 = v118;
        }
        PCMatrix44Tmpl<double>::setTransformation(a5, (double *)&v89.value, 0, v43, v44, v42, v36, v37, v38, v102, v101, v21, v22, v23, v24, v25, v105, v104, v103,
          *(uint64_t *)&v88);
        return PCCFRef<CGColorSpace *>::~PCCFRef(&v111);
      }
    }
    __double2 v70 = __sincos_stret(*(double *)&v94 * 0.5);
    __double2 v71 = __sincos_stret(v68 * 0.5);
    __double2 v72 = __sincos_stret(v69 * 0.5);
    double v73 = v70.__sinval * 0.0 * (v71.__sinval * 0.0);
    double v74 = v70.__cosval * v71.__cosval - (v73 + v70.__sinval * 0.0 * v71.__sinval + v70.__sinval * (v71.__sinval * 0.0));
    double v75 = v70.__sinval * 0.0 * v71.__cosval;
    double v76 = v70.__cosval * (v71.__sinval * 0.0);
    double v77 = v70.__sinval * v71.__cosval + v76 + v70.__sinval * 0.0 * v71.__sinval - v73;
    double v78 = v75 + v70.__cosval * v71.__sinval + v70.__sinval * (v71.__sinval * 0.0) - v73;
    double v79 = v73 - v70.__sinval * v71.__sinval + v75 + v76;
    double v80 = v72.__sinval * 0.0 * v77;
    double v81 = v72.__sinval * 0.0 * v78;
    double v27 = v72.__cosval * v74 - (v72.__sinval * v79 + v80 + v81);
    double v82 = v72.__sinval * 0.0 * v74;
    double v83 = v72.__sinval * 0.0 * v79;
    double v32 = v72.__sinval * v78 - v83 + v72.__cosval * v77 + v82;
    double v31 = v83 - v72.__sinval * v77 + v72.__cosval * v78 + v82;
    double v26 = v80 - v81 + v72.__cosval * v79 + v72.__sinval * v74;
    int v30 = 1;
    goto LABEL_43;
  }
  return result;
}

void sub_1B7DD5084(_Unwind_Exception *a1)
{
}

void PSParticleType::addProjectedImageParticleBounds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 16488)
    || ((*(void (**)(uint64_t))(*(void *)a1 + 1640))(a1), *(void *)(a1 + 16488)))
  {
    uint64_t v8 = *(const void **)(a3 + 232);
    if (v8) {
    else
    }
      uint64_t v9 = 0;
    long long v10 = *(const OZRenderState **)(a2 + 8);
    OZRenderState::OZRenderState(&v57, v10);
    if (!*(unsigned char *)(a1 + 16529))
    {
      CMTime v56 = *(CMTime *)(v9 + 80);
      if (*((double *)v9 + 13) > 0.0)
      {
        long long v54 = 0uLL;
        uint64_t v55 = 0;
        long long v11 = *(_OWORD *)&v10->var0.var0;
        v40.int64_t var3 = v10->var0.var3;
        *(_OWORD *)&v40.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v11;
        long long v12 = *(_OWORD *)(v9 + 8);
        v59.CMTimeEpoch epoch = *((void *)v9 + 3);
        *(_OWORD *)&v59.value = v12;
        PC_CMTimeSaferSubtract((CMTime *)&v40, &v59, (uint64_t)&v54);
        operator/(&v54, (uint64_t)v39, *((double *)v9 + 13));
        CMTime v59 = v56;
        long long v49 = *(_OWORD *)v39;
        *(void *)&long long v50 = *(void *)&v39[16];
        PC_CMTimeSaferAdd(&v59, (CMTime *)&v49, (uint64_t)&v40);
        CMTime v56 = (CMTime)v40;
        long long v52 = *(_OWORD *)(a1 + 16464);
        uint64_t v53 = *(void *)(a1 + 16480);
        memset(&v51, 0, sizeof(v51));
        operator/((long long *)&v56.value, (uint64_t)&v52, (uint64_t)&v51);
        CMTimeMake(&v58, 1, 1);
        $3CC8671D27C23BF42ADDB32F2B5E48AE v40 = v51;
        CMTime v59 = v58;
        PC_CMTimeFloorToSampleDuration((CMTime *)&v40, &v59, (uint64_t)v39);
        $3CC8671D27C23BF42ADDB32F2B5E48AE v40 = v51;
        CMTime v59 = *(CMTime *)v39;
        PC_CMTimeSaferSubtract((CMTime *)&v40, &v59, (uint64_t)&v49);
        operator*(&v49, (uint64_t)&v52, (uint64_t)&v40);
        CMTime v56 = (CMTime)v40;
      }
      long long v13 = *(_OWORD *)(a1 + 16440);
      *(void *)&long long v50 = *(void *)(a1 + 16456);
      long long v49 = v13;
      CMTime v59 = v56;
      PC_CMTimeSaferAdd(&v59, (CMTime *)&v49, (uint64_t)&v40);
      v57.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v40;
    }
    long long v49 = 0uLL;
    __asm { FMOV            V0.2D, #-1.0 }
    long long v50 = _Q0;
    PSParticleType::getSourceImageBounds(a1, &v57, &v49);
    long long v19 = v49;
    long long v20 = v50;
    uint64_t v48 = 0x3FF0000000000000;
    uint64_t v45 = 0x3FF0000000000000;
    uint64_t v42 = 0x3FF0000000000000;
    v40.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0x3FF0000000000000;
    *(_OWORD *)&v40.var1 = 0u;
    long long v41 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    PSParticleType::getImageParticleMatrix3D((CGColorSpace **)a1, a2, (uint64_t)v9, (double *)a3, (uint64_t)&v40);
    double v22 = *((double *)&v19 + 1) + *((double *)&v20 + 1);
    double v23 = *(double *)&v19 + *(double *)&v20;
    *(_OWORD *)&v59.value = v19;
    v59.CMTimeEpoch epoch = 0;
    double v60 = *(double *)&v19 + *(double *)&v20;
    uint64_t v61 = *((void *)&v19 + 1);
    uint64_t v62 = 0;
    double v63 = *(double *)&v19 + *(double *)&v20;
    double v64 = *((double *)&v19 + 1) + *((double *)&v20 + 1);
    uint64_t v65 = 0;
    uint64_t v66 = v19;
    double v67 = *((double *)&v19 + 1) + *((double *)&v20 + 1);
    double v68 = 0;
    uint64_t v24 = *(unsigned int *)(a2 + 1452);
    if ((int)v24 >= 1)
    {
      uint64_t v25 = 0;
      long long v26 = 0uLL;
      while (2)
      {
        *(_OWORD *)double v39 = v26;
        *(_OWORD *)&v39[16] = v26;
        if (v25 >= *(int *)(a2 + 1452)) {
          PCArray_base::badIndex((PCArray_base *)v21);
        }
        uint64_t v21 = PCMatrix44Tmpl<double>::transform_row<double>((double *)&v40.var0, (double *)(*(void *)(a2 + 1456) + 32 * v25), (double *)v39);
        for (uint64_t i = 0; i != 96; i += 24)
        {
          float64x2_t v28 = vmulq_f64(*(float64x2_t *)((char *)&v59.timescale + i), *(float64x2_t *)&v39[8]);
          if (*(double *)&v39[24] + *(double *)((char *)&v59.value + i) * *(double *)v39 + v28.f64[0] + v28.f64[1] < 0.0)
          {
            LiImagePolygon::LiImagePolygon((LiImagePolygon *)&v59);
            std::vector<LiPolygon::PosEdge>::resize(v68, 4uLL);
            double v31 = v68;
            uint64_t v32 = *v68;
            *(_OWORD *)uint64_t v32 = v19;
            *(void *)(v32 + 16) = 0;
            *(double *)(v32 + 32) = v23;
            *(void *)(v32 + 40) = *((void *)&v19 + 1);
            *(void *)(v32 + 48) = 0;
            *(double *)(v32 + 64) = v23;
            *(double *)(v32 + 72) = v22;
            *(void *)(v32 + 80) = 0;
            *(void *)(v32 + 96) = v19;
            *(double *)(v32 + 104) = v22;
            *(void *)(v32 + 112) = 0;
            uint64_t v33 = *(unsigned int *)(a2 + 1452);
            if ((int)v33 >= 1)
            {
              for (uint64_t j = 0; j != v33; ++j)
              {
                memset(v39, 0, sizeof(v39));
                if (j >= *(int *)(a2 + 1452)) {
                  PCArray_base::badIndex(v30);
                }
                PCMatrix44Tmpl<double>::transform_row<double>((double *)&v40.var0, (double *)(*(void *)(a2 + 1456) + 32 * j), (double *)v39);
                int v30 = (PCArray_base *)LiImagePolygon::clip((uint64_t **)&v59, (float64x2_t *)v39, 0);
              }
              double v31 = v68;
              uint64_t v32 = *v68;
            }
            if ((int)((unint64_t)(v31[1] - v32) >> 5) >= 3)
            {
              PCMatrix44Tmpl<double>::leftMult((uint64_t)&v40, (double *)(a2 + 1632));
              uint64_t v35 = *v68;
              if ((int)((unint64_t)(v68[1] - *v68) >> 5) >= 1)
              {
                uint64_t v36 = 0;
                uint64_t v37 = 0;
                do
                {
                  *(_OWORD *)double v39 = *(_OWORD *)(v35 + v36);
                  *(void *)&v39[16] = 0;
                  PCMatrix44Tmpl<double>::transform<double>((double *)&v40.var0, (double *)v39, (double *)v39);
                  *(_OWORD *)&v58.value = *(_OWORD *)v39;
                  PCRect<double>::operator|=((float64x2_t *)a4, (float64x2_t *)&v58);
                  ++v37;
                  uint64_t v35 = *v68;
                  v36 += 32;
                }
                while (v37 < (int)((unint64_t)(v68[1] - *v68) >> 5));
              }
            }
            LiImagePolygon::~LiImagePolygon((LiImagePolygon *)&v59);
            return;
          }
        }
        ++v25;
        long long v26 = 0uLL;
        if (v25 != v24) {
          continue;
        }
        break;
      }
    }
    PCMatrix44Tmpl<double>::leftMult((uint64_t)&v40, (double *)(a2 + 1632));
    for (uint64_t k = 0; k != 96; k += 24)
    {
      *(_OWORD *)double v39 = *(_OWORD *)((char *)&v59.value + k);
      *(void *)&v39[16] = *(CMTimeEpoch *)((char *)&v59.epoch + k);
      PCMatrix44Tmpl<double>::transform<double>((double *)&v40.var0, (double *)v39, (double *)v39);
      *(_OWORD *)&v58.value = *(_OWORD *)v39;
      PCRect<double>::operator|=((float64x2_t *)a4, (float64x2_t *)&v58);
    }
  }
  else
  {
    __asm { FMOV            V0.2D, #-1.0 }
    *(_OWORD *)(a4 + 16) = _Q0;
  }
}

void sub_1B7DD5664(_Unwind_Exception *exception_object)
{
}

double PSParticleType::getImageParticleMatrix3D(CGColorSpace **a1, uint64_t a2, uint64_t a3, double *a4, uint64_t a5)
{
  PSParticleType::getImageParticleMatrix(a1, *(CMTime **)(a2 + 8), a3, a4, a5, *(unsigned __int8 *)(a2 + 1497));
  if (*(unsigned char *)(a2 + 1498))
  {
    if (*(unsigned char *)(*(void *)(a2 + 8) + 242))
    {
      return adjustImageParticleMatrixForFacingCameraEquirectRender((double *)a2, (double *)a5);
    }
    else
    {
      unint64_t v8 = *(void *)(a5 + 24);
      uint64_t v9 = *(void *)(a5 + 56);
      uint64_t v10 = *(void *)(a5 + 88);
      uint64_t v11 = *(void *)(a5 + 120);
      *(void *)(a5 + 24) = 0;
      *(void *)(a5 + 56) = 0;
      *(void *)(a5 + 88) = 0;
      *(void *)(a5 + 120) = 0x3FF0000000000000;
      uint64_t v19 = 0x3FF0000000000000;
      uint64_t v15 = 0x3FF0000000000000;
      uint64_t v12 = 0x3FF0000000000000;
      long long v13 = 0u;
      uint64_t v16 = 0;
      long long v18 = 0u;
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      uint64_t v21 = 0;
      long long v14 = v8;
      uint64_t v17 = v9;
      uint64_t v20 = v10;
      uint64_t v24 = v11;
      PCMatrix44Tmpl<double>::leftMult(a5, (double *)(a2 + 1504));
      return PCMatrix44Tmpl<double>::leftMult(a5, (double *)&v12);
    }
  }
  return result;
}

uint64_t PSParticleType::willGetParticleBounds(PSParticleType *this)
{
  uint64_t result = (*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this);
  if (result != *((void *)this + 2061))
  {
    uint64_t v3 = *(uint64_t (**)(PSParticleType *))(*(void *)this + 1640);
    return v3(this);
  }
  return result;
}

float64_t PSParticleType::getParticleBounds(uint64_t a1, float64x2_t *a2, OZRenderState *a3, float64x2_t *a4)
{
  $3CC8671D27C23BF42ADDB32F2B5E48AE var0 = a3->var0;
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 11344), (const CMTime *)&var0, 0.0);
  if (*(void *)(a1 + 16488)) {
    int v14 = ValueAsInt;
  }
  else {
    int v14 = 0;
  }
  if ((v14 - 2) < 2)
  {
    *(void *)&v13.f64[0] = *(_OWORD *)&PSParticleType::getImageParticleBounds(a1, (uint64_t)a2, a3, a4);
  }
  else if (v14 == 1)
  {
    *(void *)&v13.f64[0] = *(_OWORD *)&PSParticleType::getLineParticleBounds(a1, (uint64_t)a2, (uint64_t)&var0, a4, v9, v10, v11, v12);
  }
  else if (!v14)
  {
    OZChannel::getValueAsDouble((OZChannel *)(a1 + 11752), (const CMTime *)&var0, 0.0);
    a4[1].f64[0] = *(double *)&v15 + *(double *)&v15;
    a4[1].f64[1] = *(double *)&v15 + *(double *)&v15;
    float64x2_t v13 = vsubq_f64(a2[11], (float64x2_t)vdupq_lane_s64(v15, 0));
    *a4 = v13;
  }
  return v13.f64[0];
}

void PSParticleType::addProjectedParticleBounds(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = *(void *)(a2 + 8);
  CMTimeEpoch v9 = *(void *)(v8 + 16);
  *(_OWORD *)&v12.value = *(_OWORD *)v8;
  v12.CMTimeEpoch epoch = v9;
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 11344), &v12, 0.0);
  if (*(void *)(a1 + 16488)) {
    int v11 = ValueAsInt;
  }
  else {
    int v11 = 0;
  }
  if ((v11 - 2) < 2)
  {
    PSParticleType::addProjectedImageParticleBounds(a1, a2, a3, (uint64_t)a4);
  }
  else if (v11 == 1)
  {
    PSParticleType::addProjectedLineParticleBounds(a1, a2, a3, a4);
  }
  else if (!v11)
  {
    PSParticleType::addProjectedPointParticleBounds(a1, a2, a3, a4);
  }
}

unint64_t PSParticleType::estimateRenderMemoryImageParticle(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(v1 + 16488)) {
    return 0;
  }
  uint64_t v5 = v4;
  uint64_t v6 = (double *)v3;
  uint64_t v7 = v2;
  uint64_t v8 = v1;
  CMTimeEpoch v9 = *(const void **)(v3 + 232);
  if (v9) {
  else
  }
    uint64_t v10 = 0;
  CMTime v12 = *(const OZRenderState **)(v7 + 8);
  OZRenderState::OZRenderState(&v44, v12);
  if (!*(unsigned char *)(v8 + 16529))
  {
    CMTime v43 = *(CMTime *)(v10 + 80);
    if (*((double *)v10 + 13) > 0.0)
    {
      long long v41 = 0uLL;
      uint64_t v42 = 0;
      long long v13 = *(_OWORD *)&v12->var0.var0;
      v48[0].CMTimeEpoch epoch = v12->var0.var3;
      *(_OWORD *)&v48[0].value = v13;
      long long v14 = *(_OWORD *)(v10 + 8);
      *(void *)&v30[16] = *((void *)v10 + 3);
      *(_OWORD *)int v30 = v14;
      PC_CMTimeSaferSubtract(v48, (CMTime *)v30, (uint64_t)&v41);
      operator/(&v41, (uint64_t)&v46, *((double *)v10 + 13));
      *(CMTime *)int v30 = v43;
      CMTime v47 = v46;
      PC_CMTimeSaferAdd((CMTime *)v30, &v47, (uint64_t)v48);
      CMTime v43 = v48[0];
      long long v39 = *(_OWORD *)(v8 + 16464);
      uint64_t v40 = *(void *)(v8 + 16480);
      memset(&v38, 0, sizeof(v38));
      operator/((long long *)&v43.value, (uint64_t)&v39, (uint64_t)&v38);
      CMTimeMake(&v45, 1, 1);
      v48[0] = v38;
      *(CMTime *)int v30 = v45;
      PC_CMTimeFloorToSampleDuration(v48, (CMTime *)v30, (uint64_t)&v46);
      v48[0] = v38;
      *(CMTime *)int v30 = v46;
      PC_CMTimeSaferSubtract(v48, (CMTime *)v30, (uint64_t)&v47);
      operator*((long long *)&v47.value, (uint64_t)&v39, (uint64_t)v48);
      CMTime v43 = v48[0];
    }
    long long v15 = *(_OWORD *)(v8 + 16440);
    v47.CMTimeEpoch epoch = *(void *)(v8 + 16456);
    *(_OWORD *)&v47.value = v15;
    *(CMTime *)int v30 = v43;
    PC_CMTimeSaferAdd((CMTime *)v30, &v47, (uint64_t)v48);
    v44.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = ($3CC8671D27C23BF42ADDB32F2B5E48AE)v48[0];
  }
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)&v47.value = _Q0;
  PCHashWriteStream::PCHashWriteStream((PCHashWriteStream *)v48);
  PCHashWriteStream::writeValue((int8x8_t *)v48, *(const void **)(v8 + 16488));
  PCHashWriteStream::writeValue((int8x8_t *)v48, (const CMTime *)&v44);
  double v20 = 1.0;
  double v21 = 1.0;
  if (OZRenderParams::getDoHighQualityResampling(*(OZRenderParams **)(v7 + 8)))
  {
    uint64_t v37 = 0x3FF0000000000000;
    uint64_t v34 = 0x3FF0000000000000;
    uint64_t v31 = 0x3FF0000000000000;
    *(void *)int v30 = 0x3FF0000000000000;
    memset(&v30[8], 0, 32);
    long long v32 = 0u;
    long long v33 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    PSParticleType::getImageParticleMatrix3D((CGColorSpace **)v8, v7, (uint64_t)v10, v6, (uint64_t)v30);
    PSParticleType::getSourceScaleFactor(v22, v7, (long long *)v30, (float64x2_t *)&v47);
    double v21 = *(double *)&v47.value;
    PCHashWriteStream::writeValue((int8x8_t *)v48, *(double *)&v47.value);
    double v20 = *(double *)&v47.timescale;
    PCHashWriteStream::writeValue((int8x8_t *)v48, *(double *)&v47.timescale);
  }
  *(_OWORD *)&v46.value = *(_OWORD *)PCHashWriteStream::getHash((int8x8_t *)v48)->i8;
  if ((void *)(v5 + 8) == std::__tree<std::__value_type<PCHash128,BOOL>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,BOOL>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,BOOL>>>::find<PCHash128>(v5, (const PCHash128 *)&v46))
  {
    std::__tree<PCHash128>::__emplace_unique_key_args<PCHash128,PCHash128 const&>((uint64_t **)v5, (const PCHash128 *)&v46, &v46);
    __asm { FMOV            V0.2D, #-1.0 }
    *(_OWORD *)&v30[16] = _Q0;
    PSParticleType::getSourceImageBounds(v8, &v44, v30);
    unint64_t v11 = 0;
    double v24 = *(double *)&v30[16];
    if (*(double *)&v30[16] > 0.0)
    {
      double v25 = *(double *)&v30[24];
      if (*(double *)&v30[24] > 0.0)
      {
        uint64_t v26 = PCPixelFormat::getBitsPerPixel(*(_DWORD *)(*(void *)(v7 + 8) + 340)) >> 3;
        double v27 = 0.0;
        if (v25 >= 0.0 && v24 >= 0.0) {
          double v27 = v24 * v25;
        }
        unint64_t v11 = vcvtpd_u64_f64(v27 * v21 * v20) * v26;
      }
    }
  }
  else
  {
    unint64_t v11 = 0;
  }
  PCHashWriteStream::~PCHashWriteStream((PCHashWriteStream *)v48);
  return v11;
}

void sub_1B7DD5E08(_Unwind_Exception *a1)
{
}

uint64_t PSParticleType::getSourceScaleFactor(uint64_t a1, uint64_t a2, long long *a3, float64x2_t *a4)
{
  __asm { FMOV            V0.2D, #1.0 }
  *a4 = _Q0;
  uint64_t result = PCMatrix44Tmpl<double>::operator*(a2 + 1632, a3, (uint64_t)&v20);
  int8x16_t v11 = (int8x16_t)vmulq_f64(v24, (float64x2_t)0);
  float64x2_t v12 = (float64x2_t)vextq_s8(v11, v11, 8uLL);
  *(double *)v11.i64 = *(double *)&v25 + vaddvq_f64((float64x2_t)v11);
  int8x16_t v13 = (int8x16_t)vmulq_f64(v20, (float64x2_t)0);
  int8x16_t v14 = (int8x16_t)vmulq_f64(v22, (float64x2_t)0);
  float64x2_t v15 = vaddq_f64((float64x2_t)vdupq_lane_s64(v25, 0), vaddq_f64(v24, v12));
  float64x2_t v16 = vsubq_f64(vdivq_f64(vaddq_f64((float64x2_t)vdupq_lane_s64(v21, 0), vaddq_f64(v20, (float64x2_t)vextq_s8(v13, v13, 8uLL))), v15), (float64x2_t)vdupq_lane_s64(COERCE__INT64((*(double *)&v21 + vaddvq_f64((float64x2_t)v13)) / *(double *)v11.i64), 0));
  float64x2_t v17 = vsubq_f64(vdivq_f64(vaddq_f64((float64x2_t)vdupq_lane_s64(v23, 0), vaddq_f64(v22, (float64x2_t)vextq_s8(v14, v14, 8uLL))), v15), (float64x2_t)vdupq_lane_s64(COERCE__INT64((*(double *)&v23 + vaddvq_f64((float64x2_t)v14)) / *(double *)v11.i64), 0));
  float64x2_t v18 = vsqrtq_f64(vaddq_f64(vmulq_f64(v16, v16), vmulq_f64(v17, v17)));
  __asm { FMOV            V2.2D, #0.5 }
  *(int32x2_t *)&v16.f64[0] = vmovn_s64(vcgtq_f64(_Q2, vabsq_f64(v18)));
  if (LODWORD(v16.f64[0]) & HIDWORD(v16.f64[0])) {
    *a4 = v18;
  }
  return result;
}

unint64_t PSParticleType::estimateRenderMemory(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  CMTimeEpoch v4 = *(void *)(v3 + 16);
  *(_OWORD *)&v6.value = *(_OWORD *)v3;
  v6.CMTimeEpoch epoch = v4;
  if (OZChannel::getValueAsInt((OZChannel *)(a1 + 11344), &v6, 0.0) == 3) {
    return PSParticleType::estimateRenderMemoryImageParticle(a1);
  }
  else {
    return 0;
  }
}

unint64_t PSParticleType::estimateRenderMemoryImageBallpark(PSParticleType *this, const OZRenderParams *a2, BOOL *a3)
{
  uint64_t v6 = PCPixelFormat::getBitsPerPixel(*((_DWORD *)a2 + 85)) >> 3;
  if (*((unsigned char *)this + 16529))
  {
    __asm { FMOV            V0.2D, #-1.0 }
    *(_OWORD *)&v21.var0.int64_t var3 = _Q0;
    PSParticleType::getSourceImageBounds((uint64_t)this, (const OZRenderState *)a2, &v21);
    unint64_t result = 0;
    *a3 = 1;
    if (*(double *)&v21.var0.var3 > 0.0 && v21.var1 > 0.0)
    {
      _NF = v21.var1 < 0.0 || *(double *)&v21.var0.var3 < 0.0;
      double v13 = *(double *)&v21.var0.var3 * v21.var1;
      if (_NF) {
        double v13 = 0.0;
      }
      return vcvtpd_u64_f64(v13) * v6;
    }
  }
  else
  {
    OZRenderState::OZRenderState(&v21, (const OZRenderState *)a2);
    CMTime time = *(CMTime *)((unsigned char *)this + 686);
    double Seconds = CMTimeGetSeconds(&time);
    *a3 = 0;
    *(_OWORD *)&v21.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)((char *)this + 16440);
    v21.var0.int64_t var3 = *((void *)this + 2057);
    __asm { FMOV            V0.2D, #-1.0 }
    long long v19 = _Q0;
    PSParticleType::getSourceImageBounds((uint64_t)this, &v21, &v18);
    unint64_t result = 0;
    if (*(double *)&v19 > 0.0 && *((double *)&v19 + 1) > 0.0)
    {
      BOOL v16 = *((double *)&v19 + 1) < 0.0 || *(double *)&v19 < 0.0;
      double v17 = *(double *)&v19 * *((double *)&v19 + 1);
      if (v16) {
        double v17 = 0.0;
      }
      return vcvtpd_u64_f64(Seconds) * v6 * vcvtpd_u64_f64(v17);
    }
  }
  return result;
}

unint64_t PSParticleType::estimateRenderMemoryBallpark(PSParticleType *this, const OZRenderParams *a2, BOOL *a3)
{
  CMTime v8 = *(CMTime *)a2;
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 11344), &v8, 0.0);
  *a3 = 1;
  if (ValueAsInt == 3 && *((void *)this + 2061)) {
    return PSParticleType::estimateRenderMemoryImageBallpark(this, a2, a3);
  }
  else {
    return 0;
  }
}

CGColorSpace **PSParticleType::getInitialParticleColor(PSParticleType *this, const CMTime *a2, PSParticle *a3, int a4, PCColor *a5)
{
  unsigned int v10 = *((_DWORD *)this + 1902);
  unint64_t result = (CGColorSpace **)OZChannel::getValueAsInt((OZChannel *)((char *)this + 5368), a2, 0.0);
  if (result == 3)
  {
    unsigned int v13 = (*(uint64_t (**)(PSParticle *))(*(void *)a3 + 32))(a3);
    int v14 = -32;
    int v15 = -1640531527;
    do
    {
      v13 += (a4 + 16 * v10) ^ (v10 + v15) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1 + (v10 >> 5));
      v10 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v13) ^ (v15 + v13) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v13 >> 5));
      v15 -= 1640531527;
    }
    while (!__CFADD__(v14++, 1));
    double v17 = (double)(v10 ^ v13) / 4294967300.0;
    float Alpha = PCColor::getAlpha(a5);
    PCColor::PCColor(&v20);
    OZChannelGradient::getColor((uint64_t **)this + 848, a2, v17, &v20);
    long long v19 = *(_OWORD *)&v20.var0.var1[1];
    *(_OWORD *)&a5->var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)&v20.var0.var0;
    *(_OWORD *)&a5->var0.var1[1] = v19;
    *(_OWORD *)&a5->var0.var1[3] = *(_OWORD *)&v20.var0.var1[3];
    PCCFRef<CGColorSpace *>::operator=(&a5->var1._obj, &v20.var1._obj);
    if (!OZChannel::getValueAsInt((OZChannel *)((char *)this + 14552), MEMORY[0x1E4F1FA48], 0.0)) {
      PCColor::setAlpha(a5, Alpha);
    }
  }
  else
  {
    if (result != 1) {
      return result;
    }
    PCColor::PCColor(&v20);
    OZChannelColor::getColor((PSParticleType *)((char *)this + 5624), a2, &v20);
    long long v12 = *(_OWORD *)&v20.var0.var1[1];
    *(_OWORD *)&a5->var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)&v20.var0.var0;
    *(_OWORD *)&a5->var0.var1[1] = v12;
    *(_OWORD *)&a5->var0.var1[3] = *(_OWORD *)&v20.var0.var1[3];
    PCCFRef<CGColorSpace *>::operator=(&a5->var1._obj, &v20.var1._obj);
  }
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v20.var1._obj);
}

void sub_1B7DD63A8(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v1 + 48));
  _Unwind_Resume(a1);
}

__n128 PSParticleType::getInitialParticleScale(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __n128 *a5, __n128 *a6)
{
  __asm { FMOV            V0.2D, #1.0 }
  *a5 = result;
  *a6 = result;
  return result;
}

double PSParticleType::getInitialParticleRotation(PSParticleType *this, const CMTime *a2, PSParticle *a3)
{
  return 0.0;
}

BOOL PSParticleType::shouldDoLocalParticleRender(PSParticleType *this)
{
  return OZChannel::getValueAsInt((OZChannel *)((char *)this + 11344), MEMORY[0x1E4F1FA48], 0.0) != 3
      || (*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this) == 0;
}

CGColorSpace **PSParticleType::getParticleColor(PSParticleType *this, const CMTime *a2, PSParticle *a3, PSEmitter *a4, PCWorkingColor *a5)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  long long v39 = 0uLL;
  uint64_t v40 = 0;
  CMTime __y = *a2;
  *(_OWORD *)&v37.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)((char *)a3 + 8);
  v37.var0.var1[1] = *((double *)a3 + 3);
  PC_CMTimeSaferSubtract(&__y, (CMTime *)&v37, (uint64_t)&v39);
  operator/(&v39, (uint64_t)a3 + 32, (uint64_t)&time);
  double Seconds = CMTimeGetSeconds(&time);
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 5368), a2, 0.0);
  int v12 = ValueAsInt;
  unsigned int v13 = (const CMTime *)((char *)a3 + 8);
  if (*((unsigned char *)this + 15464))
  {
    if (ValueAsInt == 2) {
      char hasMoreThanOneKeypoint = OZChannelFolder::hasMoreThanOneKeypoint((OZChannelFolder *)((char *)this + 6784));
    }
    else {
      char hasMoreThanOneKeypoint = (*(uint64_t (**)(char *))(*((void *)this + 880) + 560))((char *)this + 7040);
    }
    *((unsigned char *)this + 15465) = hasMoreThanOneKeypoint ^ 1;
    if ((hasMoreThanOneKeypoint & 1) == 0)
    {
      std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 15472, *((void **)this + 1935));
      *((void *)this + 1934) = (char *)this + 15480;
      *((void *)this + 1936) = 0;
      *((void *)this + 1935) = 0;
      std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 15496, *((void **)this + 1938));
      *((void *)this + 1937) = (char *)this + 15504;
      unsigned int v13 = (const CMTime *)((char *)a3 + 8);
      *((void *)this + 1939) = 0;
      *((void *)this + 1938) = 0;
      (*(void (**)(char *, char *, char *))(*((void *)this + 880) + 728))((char *)this + 7040, (char *)a3 + 8, (char *)this + 15472);
      (*(void (**)(char *, char *, char *))(*((void *)this + 864) + 728))((char *)this + 6912, (char *)a3 + 8, (char *)this + 15496);
    }
    *((unsigned char *)this + 15464) = 0;
  }
  PCColor::PCColor(&v37);
  if (v12 == 2)
  {
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 7736), a2, 0.0);
    double v16 = v15 + 1.0;
    int v17 = *((unsigned __int8 *)this + 16544);
    if (*((unsigned char *)this + 16544))
    {
      __y.value = 0;
      modf(v16, (long double *)&__y.value);
      double v16 = *(double *)&__y.value;
    }
    if (v16 < 1.0) {
      double v16 = 1.0;
    }
    double v18 = Seconds * v16;
    __y.value = 0;
    modf(Seconds * v16 + -0.0001, (long double *)&__y.value);
    double v20 = v18 - *(double *)&__y.value;
    if (*((unsigned char *)this + 15465))
    {
      if (v17) {
        v19.n128_f64[0] = v20;
      }
      else {
        v19.n128_f64[0] = Seconds;
      }
      (*(void (**)(__n128))(*((void *)this + 880) + 736))(v19);
      (*(void (**)(char *, _DWORD *, char *, double))(*((void *)this + 864) + 736))((char *)this + 6912, v46, (char *)this + 15496, v20);
      float v21 = *(float *)&v46[1];
      float v22 = *(float *)&v46[2];
      float v23 = *(float *)&v46[3];
      float v24 = *(float *)&__y.value;
      ColorSpace = (CGColorSpace *)OZChannelGradient::getColorSpace((PSParticleType *)((char *)this + 6784));
      PCColor::setRGBA(&v37, v21, v22, v23, v24, ColorSpace);
      float Alpha = *(float *)&__y.value;
    }
    else
    {
      OZChannelGradient::getColor((uint64_t **)this + 848, v13, v20, &v37);
      float Alpha = PCColor::getAlpha(&v37);
    }
  }
  else
  {
    long long v27 = *((_OWORD *)a3 + 8);
    *(_OWORD *)&v37.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *((_OWORD *)a3 + 7);
    *(_OWORD *)&v37.var0.var1[1] = v27;
    *(_OWORD *)&v37.var0.var1[3] = *((_OWORD *)a3 + 9);
    PCCFRef<CGColorSpace *>::operator=(&v37.var1._obj, (CGColorSpace **)a3 + 20);
    float64x2_t v28 = (char *)this + 7040;
    if (*((unsigned char *)this + 15465))
    {
      (*(void (**)(char *, _DWORD *, char *, double))(*((void *)this + 880) + 736))((char *)this + 7040, v46, (char *)this + 15472, Seconds);
      float v29 = *(float *)v46;
      float Alpha = v29 * PCColor::getAlpha(&v37);
    }
    else
    {
      *(void *)&__y.timescale = 0;
      __y.CMTimeEpoch epoch = 0;
      __y.value = (CMTimeValue)&__y.timescale;
      (*(void (**)(char *, const CMTime *, CMTime *))(*(void *)v28 + 728))((char *)this + 7040, v13, &__y);
      (*(void (**)(char *, _DWORD *, CMTime *, double))(*(void *)v28 + 736))((char *)this + 7040, v46, &__y, Seconds);
      float v30 = *(float *)v46;
      float Alpha = v30 * PCColor::getAlpha(&v37);
      std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&__y, *(void **)&__y.timescale);
    }
  }
  PSSequencedValues::PSSequencedValues((PSSequencedValues *)&__y);
  long long v42 = *(_OWORD *)&v37.var0.var0;
  long long v43 = *(_OWORD *)&v37.var0.var1[1];
  long long v44 = *(_OWORD *)&v37.var0.var1[3];
  PCCFRef<CGColorSpace *>::operator=(v45, &v37.var1._obj);
  (*(void (**)(PSParticleType *, const CMTime *, PSParticle *, CMTime *))(*(void *)this + 1616))(this, a2, a3, &__y);
  *(_OWORD *)&v37.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v42;
  *(_OWORD *)&v37.var0.var1[1] = v43;
  *(_OWORD *)&v37.var0.var1[3] = v44;
  PCCFRef<CGColorSpace *>::operator=(&v37.var1._obj, v45);
  uint64_t v31 = v45[1];
  PSEmitter::tintColor(a4, a2, &v37);
  float v32 = *(double *)&v31 * Alpha;
  uint64_t v33 = *((void *)this + 2063);
  if (v33)
  {
    OZChannel::getValueAsDouble((OZChannel *)(v33 + 6680), a2, 0.0);
    double v35 = 1.0;
    if (*((double *)this + 2069) < 3.0) {
      double v35 = v34;
    }
    float v32 = v34 * v35 * v32;
  }
  PCColor::setAlpha(&v37, v32);
  PCWorkingColor::operator=((uint64_t)a5, &v37.var0.var0);
  PCCFRef<CGColorSpace *>::~PCCFRef(v45);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v37.var1._obj);
}

void sub_1B7DD6A64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PSParticleType::getSequenceCompletion(PSParticleType *this, const CMTime *a2, double a3, BOOL *a4, double *a5)
{
  *a4 = 0;
  FirstRemapTimeBehavior = PSParticleType::getFirstRemapTimeBehavior((uint64_t)this, (uint64_t *)this + 125);
  if ((FirstRemapTimeBehavior
     || (FirstRemapTimeBehavior = PSParticleType::getFirstRemapTimeBehavior(0, (uint64_t *)(*((void *)this + 2054) + 1200))) != 0)&& !OZChannel::getValueAsInt((OZChannel *)(FirstRemapTimeBehavior + 4640), MEMORY[0x1E4F1FA48], 0.0))
  {
    *a4 = 1;
    *a5 = PSSequenceBehavior::getCompletion((PSSequenceBehavior *)FirstRemapTimeBehavior, a2, a3);
  }
}

double adjustImageParticleMatrixForFacingCameraEquirectRender(double *a1, double *a2)
{
  double v2 = a1[223];
  double v3 = a1[224];
  double v4 = a1[220] - a2[3];
  double v5 = a1[221] - a2[7];
  double v6 = a1[222] - a2[11];
  double v7 = sqrt(v4 * v4 + v5 * v5 + v6 * v6);
  if (v7 < 0.000000100000001 && v7 > -0.000000100000001) {
    double v7 = 1.0;
  }
  double v9 = v4 / v7;
  double v10 = v5 / v7;
  double v11 = v6 / v7;
  if (fabs(a1[225] * v11 + v2 * v9 + v3 * v10) < 1.0)
  {
    double v12 = a1[225];
  }
  else
  {
    double v2 = a1[226];
    double v3 = a1[227];
    double v12 = a1[228];
  }
  double v13 = v11 * v3 - v10 * v12;
  double v14 = v9 * v12 - v11 * v2;
  double v15 = v10 * v2 - v9 * v3;
  double v16 = v10 * v15 - v11 * v14;
  double v17 = v11 * v13 - v9 * v15;
  double v18 = v9 * v14 - v10 * v13;
  double v19 = sqrt(v15 * v15 + v13 * v13 + v14 * v14);
  if (v19 <= -0.000000100000001 || v19 >= 0.000000100000001)
  {
    double v13 = v13 / v19;
    double v14 = v14 / v19;
    double v15 = v15 / v19;
  }
  double v20 = sqrt(v18 * v18 + v16 * v16 + v17 * v17);
  if (v20 <= -0.000000100000001 || v20 >= 0.000000100000001)
  {
    double v16 = v16 / v20;
    double v17 = v17 / v20;
    double v18 = v18 / v20;
  }
  void v22[3] = 0.0;
  v22[7] = 0.0;
  v22[0] = v13;
  v22[1] = v16;
  v22[4] = v14;
  v22[5] = v17;
  v22[8] = v15;
  v22[9] = v18;
  memset(&v22[11], 0, 24);
  v22[2] = v9;
  v22[6] = v10;
  v22[10] = v11;
  long long v23 = xmmword_1B7E733E0;
  return PCMatrix44Tmpl<double>::rightMult((uint64_t)a2, v22);
}

CGColorSpace **PSParticleType::addPointSprite(PSParticleType *this, PSEmitter::RenderParams *a2, PSParticle *a3, float64x2_t *a4, PSHeliumNode *a5)
{
  double v10 = (long long *)*((void *)a2 + 1);
  uint64_t v11 = *((void *)v10 + 2);
  long long v26 = *v10;
  uint64_t v27 = v11;
  PSSequencedValues::PSSequencedValues((PSSequencedValues *)v22);
  (*(void (**)(PSParticleType *, long long *, PSParticle *, unsigned char *))(*(void *)this + 1616))(this, &v26, a3, v22);
  double v12 = a4[12].f64[0] + v25;
  float64x2_t v20 = vaddq_f64(a4[11], v24);
  double v21 = v12;
  WorkingColorSpace = (CGColorSpace *)OZRenderParams::getWorkingColorSpace(*((FxColorDescription **)a2 + 1));
  PCWorkingColor::PCWorkingColor((PCWorkingColor *)&v18, 0.0, 0.0, 0.0, 0.0, WorkingColorSpace);
  (*(void (**)(PSParticleType *, long long *, PSParticle *, void, __n128 *))(*(void *)this + 1600))(this, &v26, a3, *(void *)a2, &v18);
  double v14 = *((double *)this + 2067);
  PCWorkingColor::operator=(&v17, &v18);
  float v15 = v14;
  PSHeliumNode::addPointParticle((uint64_t)a5, (long long *)&v20, &v17, *((unsigned char *)this + 16528), v15);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v19);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v23);
}

void sub_1B7DD6EA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CGColorSpace *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,CGColorSpace *a30)
{
}

CGColorSpace **PSParticleType::addLineSprite(PSParticleType *this, PSEmitter::RenderParams *a2, PSParticle *a3, OZSimStateElement *a4, PSHeliumNode *a5)
{
  double v10 = (FxColorDescription *)*((void *)a2 + 1);
  uint64_t v11 = *(void *)&v10->_pcColorDesc._toneMapMethod._gain;
  long long v42 = *(_OWORD *)&v10->_pcColorDesc._colorSpaceRef._obj;
  uint64_t v43 = v11;
  WorkingColorSpace = (CGColorSpace *)OZRenderParams::getWorkingColorSpace(v10);
  PCWorkingColor::PCWorkingColor((PCWorkingColor *)&v40, 0.0, 0.0, 0.0, 0.0, WorkingColorSpace);
  (*(void (**)(PSParticleType *, long long *, PSParticle *, void, __n128 *))(*(void *)this + 1600))(this, &v42, a3, *(void *)a2, &v40);
  PSSequencedValues::PSSequencedValues((PSSequencedValues *)v35);
  (*(void (**)(PSParticleType *, long long *, PSParticle *, unsigned char *))(*(void *)this + 1616))(this, &v42, a3, v35);
  double v13 = *((double *)a4 + 2) + *((double *)a4 + 9);
  float64x2_t v33 = vaddq_f64(*(float64x2_t *)a4, *(float64x2_t *)((char *)a4 + 56));
  double v34 = v13;
  uint64_t v32 = 0x3FF0000000000000;
  uint64_t v29 = 0x3FF0000000000000;
  uint64_t v26 = 0x3FF0000000000000;
  uint64_t v23 = 0x3FF0000000000000;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  (*(void (**)(PSParticleType *, char *, uint64_t *, long long *))(*(void *)this + 1416))(this, (char *)this + 15520, &v23, &v42);
  PCMatrix44Tmpl<double>::transform<double>((double *)&v23, v33.f64, v33.f64);
  v33.f64[0] = v37 + v33.f64[0];
  v33.f64[1] = v38 + v33.f64[1];
  double v14 = *((double *)a4 + 23);
  double v15 = v37 + *((double *)a4 + 22);
  double v34 = v39 + v34;
  double v16 = v39 + *((double *)a4 + 24);
  *(double *)&long long v21 = v15;
  *((double *)&v21 + 1) = v38 + v14;
  double v22 = v16;
  if ((v33.f64[0] - v15) * (v33.f64[0] - v15)
     + (v33.f64[1] - *((double *)&v21 + 1)) * (v33.f64[1] - *((double *)&v21 + 1))
     + (v34 - v16) * (v34 - v16) <= 1.0)
  {
    double v17 = *((double *)this + 2067);
    PCWorkingColor::operator=(&v20, &v40);
    float v18 = v17;
    PSHeliumNode::addPointParticle((uint64_t)a5, &v21, &v20, *((unsigned char *)this + 16528), v18);
  }
  else
  {
    PCWorkingColor::operator=(&v20, &v40);
    PSHeliumNode::addLineParticle((uint64_t)a5, (double *)&v21, v33.f64, &v20, *((unsigned char *)this + 16528));
  }
  PCCFRef<CGColorSpace *>::~PCCFRef(&v36);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v41);
}

void sub_1B7DD7180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,CGColorSpace *a45)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(&a45);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v45 - 136));
  _Unwind_Resume(a1);
}

CGColorSpace **PSParticleType::addOutlineSprite(CGColorSpace **this, PSEmitter::RenderParams *a2, PSParticle *a3, OZSimStateElement *a4, PSHeliumNode *a5)
{
  if (this[2061])
  {
    uint64_t v8 = (uint64_t)this;
    uint64_t v41 = 0x3FF0000000000000;
    uint64_t v38 = 0x3FF0000000000000;
    uint64_t v35 = 0x3FF0000000000000;
    uint64_t v32 = 0x3FF0000000000000;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    PSParticleType::getImageParticleMatrix3D(this, (uint64_t)a2, (uint64_t)a3, (double *)a4, (uint64_t)&v32);
    double v9 = (long long *)*((void *)a2 + 1);
    long long v10 = *v9;
    int64_t v31 = *((void *)v9 + 2);
    long long v30 = v10;
    long long v28 = 0uLL;
    uint64_t v29 = 0;
    *(_OWORD *)&v22.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v10;
    v22.var0.int64_t var3 = v31;
    v19[0] = *(CMTime *)((char *)a3 + 8);
    PC_CMTimeSaferSubtract((CMTime *)&v22, v19, (uint64_t)&v28);
    $3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *($3CC8671D27C23BF42ADDB32F2B5E48AE *)((char *)a3 + 80);
    double v11 = *((double *)a3 + 13);
    if (v11 > 0.0)
    {
      operator/(&v28, (uint64_t)&v20, v11);
      v22.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = var0;
      *(_OWORD *)&v19[0].value = v20;
      v19[0].CMTimeEpoch epoch = v21;
      PC_CMTimeSaferAdd((CMTime *)&v22, v19, (uint64_t)&var0);
      long long v25 = *(_OWORD *)(v8 + 16464);
      uint64_t v26 = *(void *)(v8 + 16480);
      long long v23 = 0uLL;
      int64_t var3 = 0;
      operator/((long long *)&var0.var0, (uint64_t)&v25, (uint64_t)&v23);
      CMTimeMake(&v42, 1, 1);
      *(_OWORD *)&v22.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v23;
      v22.var0.int64_t var3 = var3;
      v19[0] = v42;
      PC_CMTimeFloorToSampleDuration((CMTime *)&v22, v19, (uint64_t)&v43);
      *(_OWORD *)&v22.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v23;
      v22.var0.int64_t var3 = var3;
      *(__n128 *)&v19[0].value = v43;
      v19[0].CMTimeEpoch epoch = v44;
      PC_CMTimeSaferSubtract((CMTime *)&v22, v19, (uint64_t)&v20);
      operator*(&v20, (uint64_t)&v25, (uint64_t)&v22);
      int64_t var3 = v22.var0.var3;
      long long v23 = *(_OWORD *)&v22.var0.var0;
      $3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v22.var0;
    }
    long long v12 = *(_OWORD *)(v8 + 16440);
    *(void *)&long long v21 = *(void *)(v8 + 16456);
    long long v20 = v12;
    v19[0] = (CMTime)var0;
    PC_CMTimeSaferAdd(v19, (CMTime *)&v20, (uint64_t)&v22);
    $3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v22.var0;
    OZRenderState::OZRenderState(&v22, *((const OZRenderState **)a2 + 1));
    v22.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = var0;
    long long v20 = 0uLL;
    __asm { FMOV            V0.2D, #-1.0 }
    long long v21 = _Q0;
    PSParticleType::getSourceImageBounds(v8, &v22, &v20);
    WorkingColorSpace = (CGColorSpace *)OZRenderParams::getWorkingColorSpace(*((FxColorDescription **)a2 + 1));
    PCWorkingColor::PCWorkingColor((PCWorkingColor *)v19, 0.0, 0.0, 0.0, 0.0, WorkingColorSpace);
    (*(void (**)(uint64_t, long long *, PSParticle *, void, CMTime *))(*(void *)v8 + 1600))(v8, &v30, a3, *(void *)a2, v19);
    PCWorkingColor::operator=(&v43, (__n128 *)v19);
    PSHeliumNode::addOutlineParticle((uint64_t)a5, &v32, (double *)&v20, &v43, *(unsigned char *)(v8 + 16528));
    return PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v19[0].epoch);
  }
  return this;
}

void sub_1B7DD74BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PSParticleType::addImageSprite(PSParticleType *this, PSEmitter::RenderParams *a2, PSParticle *a3, OZSimStateElement *a4, PSHeliumNode *a5)
{
  uint64_t v46 = 0x3FF0000000000000;
  uint64_t v43 = 0x3FF0000000000000;
  uint64_t v40 = 0x3FF0000000000000;
  uint64_t v37 = 0x3FF0000000000000;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  PSParticleType::getImageParticleMatrix3D((CGColorSpace **)this, (uint64_t)a2, (uint64_t)a3, (double *)a4, (uint64_t)&v37);
  uint64_t v9 = *((void *)a2 + 1);
  CMTimeEpoch v10 = *(void *)(v9 + 16);
  *(_OWORD *)&v36.value = *(_OWORD *)v9;
  v36.CMTimeEpoch epoch = v10;
  CMTime v35 = *(CMTime *)((char *)a3 + 80);
  if (*((double *)a3 + 13) > 0.0)
  {
    __n128 v33 = 0uLL;
    uint64_t v34 = 0;
    v27[0] = v36;
    long long v28 = *(_OWORD *)((char *)a3 + 8);
    *(void *)&long long v29 = *((void *)a3 + 3);
    PC_CMTimeSaferSubtract(v27, (CMTime *)&v28, (uint64_t)&v33);
    operator/((long long *)&v33, (uint64_t)&v48, *((double *)a3 + 13));
    long long v28 = *(_OWORD *)&v35.value;
    *(void *)&long long v29 = v35.epoch;
    CMTime v49 = v48;
    PC_CMTimeSaferAdd((CMTime *)&v28, &v49, (uint64_t)v27);
    CMTime v35 = v27[0];
    long long v31 = *((_OWORD *)this + 1029);
    uint64_t v32 = *((void *)this + 2060);
    memset(&v30, 0, sizeof(v30));
    operator/((long long *)&v35.value, (uint64_t)&v31, (uint64_t)&v30);
    CMTimeMake(&v47, 1, 1);
    v27[0] = v30;
    long long v28 = *(_OWORD *)&v47.value;
    *(void *)&long long v29 = v47.epoch;
    PC_CMTimeFloorToSampleDuration(v27, (CMTime *)&v28, (uint64_t)&v48);
    v27[0] = v30;
    long long v28 = *(_OWORD *)&v48.value;
    *(void *)&long long v29 = v48.epoch;
    PC_CMTimeSaferSubtract(v27, (CMTime *)&v28, (uint64_t)&v49);
    operator*((long long *)&v49.value, (uint64_t)&v31, (uint64_t)v27);
    CMTime v35 = v27[0];
  }
  long long v11 = *(_OWORD *)((char *)this + 16440);
  v49.CMTimeEpoch epoch = *((void *)this + 2057);
  *(_OWORD *)&v49.value = v11;
  long long v28 = *(_OWORD *)&v35.value;
  *(void *)&long long v29 = v35.epoch;
  PC_CMTimeSaferAdd((CMTime *)&v28, &v49, (uint64_t)v27);
  CMTime v35 = v27[0];
  int v12 = *(_DWORD *)(*(void *)HGRenderJob::GetRenderNodeList(*((HGRenderJob **)a2 + 1)) + 8);
  _ZF = v12 == 0;
  BOOL v14 = v12 != 0;
  double v15 = (HGBitmapLoader **)&v31;
  if (!_ZF) {
    double v15 = 0;
  }
  BOOL v16 = v14 && *((unsigned char *)a5 + 864) != 0;
  long long v28 = 0uLL;
  __asm { FMOV            V0.2D, #-1.0 }
  long long v29 = _Q0;
  *(_OWORD *)&v49.value = 0uLL;
  *(_OWORD *)&v48.value = 0uLL;
  v47.value = 0;
  *(void *)&v47.timescale = 0;
  *(void *)&long long v31 = 0;
  if (_ZF) {
    long long v21 = 0;
  }
  else {
    long long v21 = &v48;
  }
  PSParticleType::getSourceOutput((uint64_t)this, (uint64_t)a2, (uint64_t)&v35, (uint64_t)&v37, (uint64_t)&v28, (uint64_t)&v49, (uint64_t)v21, (uint64_t)&v47, v15);
  WorkingColorSpace = (CGColorSpace *)OZRenderParams::getWorkingColorSpace(*((FxColorDescription **)a2 + 1));
  PCWorkingColor::PCWorkingColor((PCWorkingColor *)v27, 0.0, 0.0, 0.0, 0.0, WorkingColorSpace);
  (*(void (**)(PSParticleType *, CMTime *, PSParticle *, void, CMTime *))(*(void *)this + 1600))(this, &v36, a3, *(void *)a2, v27);
  if ((void)v31)
  {
    PCWorkingColor::operator=(&v33, (__n128 *)v27);
    PSHeliumNode::addImageParticle((uint64_t)a5, (double *)&v37, (unint64_t *)&v31, (double *)&v28, &v33, *((unsigned char *)this + 16528));
    goto LABEL_20;
  }
  if (v48.value)
  {
    long long v26 = *(_OWORD *)&v48.value;
    if (*(void *)&v48.timescale) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v48.timescale + 8), 1uLL, memory_order_relaxed);
    }
    PCWorkingColor::operator=(&v33, (__n128 *)v27);
    PSHeliumNode::addImageParticle((uint64_t)a5, (double *)&v37, &v26, (double *)&v28, &v33, *((unsigned char *)this + 16528));
    long long v23 = (std::__shared_weak_count *)*((void *)&v26 + 1);
    if (!*((void *)&v26 + 1)) {
      goto LABEL_20;
    }
LABEL_19:
    std::__shared_weak_count::__release_shared[abi:ne180100](v23);
    goto LABEL_20;
  }
  if (v49.value)
  {
    long long v25 = *(_OWORD *)&v49.value;
    if (*(void *)&v49.timescale) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v49.timescale + 8), 1uLL, memory_order_relaxed);
    }
    PCWorkingColor::operator=(&v33, (__n128 *)v27);
    PSHeliumNode::addImageParticle((uint64_t)a5, (double *)&v37, &v25, (double *)&v28, &v33, *((unsigned char *)this + 16528));
    long long v23 = (std::__shared_weak_count *)*((void *)&v25 + 1);
    if (*((void *)&v25 + 1)) {
      goto LABEL_19;
    }
  }
  else if (v47.value)
  {
    PCWorkingColor::operator=(&v33, (__n128 *)v27);
    PSHeliumNode::addImageParticle((uint64_t)a5, (double *)&v37, &v47, (double *)&v28, &v33, *((unsigned char *)this + 16528));
  }
LABEL_20:
  long long v24 = (OZScene *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 272))(this);
  if (!v16 && v24 != 0 && OZScene::inDesperationMode(v24))
  {
    PSHeliumNode::convertTexturesToBitmaps(a5);
    PCSharedMutex::lock((std::mutex *)((char *)this + 16616));
    std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::destroy((uint64_t)this + 16568, *((void **)this + 2072));
    *((void *)this + 2071) = (char *)this + 16576;
    *((void *)this + 2073) = 0;
    *((void *)this + 2072) = 0;
    PCSharedMutex::unlock((std::mutex *)((char *)this + 16616));
  }
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v27[0].epoch);
  if ((void)v31) {
    (*(void (**)(void))(*(void *)v31 + 24))(v31);
  }
  if (*(void *)&v47.timescale) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v47.timescale);
  }
  if (*(void *)&v48.timescale) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v48.timescale);
  }
  if (*(void *)&v49.timescale) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v49.timescale);
  }
}

void sub_1B7DD79EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CGColorSpace *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(&a17);
  if (a29) {
    (*(void (**)(uint64_t))(*(void *)a29 + 24))(a29);
  }
  long long v31 = *(std::__shared_weak_count **)(v29 - 120);
  if (v31) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v31);
  }
  uint64_t v32 = *(std::__shared_weak_count **)(v29 - 96);
  if (v32) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v32);
  }
  __n128 v33 = *(std::__shared_weak_count **)(v29 - 72);
  if (v33) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v33);
  }
  _Unwind_Resume(a1);
}

void PSParticleType::getSourceOutput(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGBitmapLoader **a9)
{
  __n128 v17 = MEMORY[0x1F4188790](a1);
  uint64_t v258 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(v9 + 16488)) {
    return;
  }
  float v18 = v16;
  uint64_t v19 = v13;
  long long v20 = v12;
  uint64_t v21 = v10;
  uint64_t v22 = v9;
  uint64_t v197 = v15;
  uint64_t v196 = v14;
  if (*(unsigned char *)(v9 + 16529))
  {
    long long v23 = *(OZRenderParams **)(v10 + 8);
    double v24 = *((double *)v23 + 2);
    long long v254 = *(_OWORD *)v23;
    double v255 = v24;
  }
  else
  {
    long long v25 = v11;
    __n128 __y = 0uLL;
    CMTimeEpoch v257 = 0;
    uint64_t v26 = (*(uint64_t (**)(__n128))(*(void *)(*(void *)(v9 + 16432) + 200) + 272))(v17);
    OZSceneSettings::getFrameDuration((OZSceneSettings *)(v26 + 336), &__y);
    CMTime v253 = *v25;
    *(__n128 *)&v252.value = __y;
    v252.CMTimeEpoch epoch = v257;
    PC_CMTimeFloorToSampleDuration(&v253, &v252, (uint64_t)&v224);
    long long v254 = v224;
    double v255 = v225;
    long long v23 = *(OZRenderParams **)(v21 + 8);
  }
  __asm { FMOV            V0.2D, #1.0 }
  float64x2_t v251 = _Q0;
  uint64_t DoHighQualityResampling = OZRenderParams::getDoHighQualityResampling(v23);
  int v33 = DoHighQualityResampling;
  double v34 = 1.0;
  double v35 = 1.0;
  if (DoHighQualityResampling)
  {
    PSParticleType::getSourceScaleFactor(DoHighQualityResampling, v21, v20, &v251);
    __y.n128_u64[0] = 0;
    modf(v251.f64[0] * 100000.003, __y.n128_f64);
    double v201 = __y.n128_f64[0] * 0.00000999999975;
    v251.f64[0] = __y.n128_f64[0] * 0.00000999999975;
    __y.n128_u64[0] = 0;
    modf(v251.f64[1] * 100000.003, __y.n128_f64);
    double v198 = __y.n128_f64[0] * 0.00000999999975;
    v251.f64[1] = __y.n128_f64[0] * 0.00000999999975;
    PCMatrix44Tmpl<double>::rightScale((double *)v20, 1.0 / v201, 1.0 / (__y.n128_f64[0] * 0.00000999999975), 1.0);
    double v34 = v198;
    double v35 = v201;
    if (v201 > -0.0000001 && v201 < 0.0000001) {
      goto LABEL_10;
    }
    if (v198 > -0.0000001 && v198 < 0.0000001)
    {
LABEL_10:
      __asm { FMOV            V0.2D, #-1.0 }
      *(_OWORD *)(v19 + 16) = _Q0;
      return;
    }
  }
  double v199 = v34;
  double v202 = v35;
  int v191 = (HGGLBlendingInfo *)(v21 + 1332);
  int EnableMetalRendering = LiRenderingTechnology::getEnableMetalRendering((LiRenderingTechnology *)(v21 + 1332));
  float64x2_t v250 = v251;
  long long v248 = v254;
  double v249 = v255;
  PCSharedMutex::lock_shared((std::mutex *)(v22 + 16616));
  int v193 = (uint64_t **)(v22 + 16568);
  uint64_t v38 = std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::find<PSParticleType::HGNodeCacheEntryKey>(v22 + 16568, (uint64_t)&v248);
  uint64_t v39 = v38;
  if (v22 + 16576 != v38)
  {
    long long v40 = *(_OWORD *)(v38 + 144);
    *(_OWORD *)uint64_t v19 = *(_OWORD *)(v38 + 128);
    *(_OWORD *)(v19 + 16) = v40;
    if (v197 && (uint64_t v41 = *(void *)(v38 + 112)) != 0)
    {
      uint64_t v42 = *(void *)(v38 + 120);
      if (v42) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v42 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v43 = (void *)v197;
    }
    else
    {
      uint64_t v41 = *(void *)(v38 + 80);
      if (v41) {
        char v44 = EnableMetalRendering;
      }
      else {
        char v44 = 1;
      }
      if (v44)
      {
        uint64_t v45 = *(void *)(v38 + 96);
        if (v45) {
          int v46 = EnableMetalRendering;
        }
        else {
          int v46 = 0;
        }
        if (v46 != 1)
        {
          char v49 = 0;
LABEL_35:
          if (a9)
          {
            long long v50 = *(HGBitmapLoader **)(v39 + 72);
            if (v50)
            {
              $3CC8671D27C23BF42ADDB32F2B5E48AE v51 = *a9;
              if (*a9 != v50)
              {
                if (v51)
                {
                  (*(void (**)(HGBitmapLoader *))(*(void *)v51 + 24))(*a9);
                  long long v50 = *(HGBitmapLoader **)(v39 + 72);
                  *a9 = v50;
                  if (!v50) {
                    goto LABEL_144;
                  }
                }
                else
                {
                  *a9 = v50;
                }
                (*(void (**)(HGBitmapLoader *))(*(void *)v50 + 16))(v50);
              }
LABEL_144:
              PCSharedMutex::unlock_shared((std::mutex *)(v22 + 16616));
              return;
            }
          }
          if (v49) {
            goto LABEL_144;
          }
          goto LABEL_42;
        }
        uint64_t v47 = *(void *)(v38 + 104);
        if (v47) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v47 + 8), 1uLL, memory_order_relaxed);
        }
        CMTime v48 = (std::__shared_weak_count *)*((void *)v18 + 1);
        *(void *)float v18 = v45;
        *((void *)v18 + 1) = v47;
        if (v48) {
          goto LABEL_33;
        }
        goto LABEL_34;
      }
      uint64_t v42 = *(void *)(v38 + 88);
      if (v42) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v42 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v43 = (void *)v196;
    }
    CMTime v48 = (std::__shared_weak_count *)v43[1];
    void *v43 = v41;
    v43[1] = v42;
    if (v48) {
LABEL_33:
    }
      std::__shared_weak_count::__release_shared[abi:ne180100](v48);
LABEL_34:
    char v49 = 1;
    goto LABEL_35;
  }
LABEL_42:
  PCSharedMutex::unlock_shared((std::mutex *)(v22 + 16616));
  *(_OWORD *)(v21 + 16) = v254;
  *(double *)(v21 + 32) = v255;
  *(void *)(v21 + 408) = 0;
  *(void *)(v21 + 416) = 0;
  *(void *)(v21 + 224) = *(void *)(v22 + 16488);
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)&v247);
  PCHashWriteStream::PCHashWriteStream((PCHashWriteStream *)&__y);
  v246[0] = v246;
  v246[1] = v246;
  v246[2] = 0;
  (*(void (**)(long long *__return_ptr))(**(void **)(v22 + 16488) + 48))(&v224);
  long long v247 = v224;
  PCHashWriteStream::reset((uint64_t)&__y);
  int RenderQuality = OZRenderParams::getRenderQuality((OZRenderParams *)(v21 + 16));
  PCHashWriteStream::writeValue((int8x8_t *)&__y, RenderQuality);
  Textint RenderQuality = OZRenderParams::getTextRenderQuality((OZRenderParams *)(v21 + 16));
  PCHashWriteStream::writeValue((int8x8_t *)&__y, TextRenderQuality);
  char v54 = OZRenderParams::getDoHighQualityResampling((OZRenderParams *)(v21 + 16));
  PCHashWriteStream::writeValue((int8x8_t *)&__y, v54);
  char DoShapeAntialiasing = OZRenderParams::getDoShapeAntialiasing((OZRenderParams *)(v21 + 16));
  PCHashWriteStream::writeValue((int8x8_t *)&__y, DoShapeAntialiasing);
  char Do3DIntersectionAntialiasing = OZRenderParams::getDo3DIntersectionAntialiasing((OZRenderParams *)(v21 + 16));
  PCHashWriteStream::writeValue((int8x8_t *)&__y, Do3DIntersectionAntialiasing);
  WorkingColorDescription = (const FxColorDescription *)OZRenderParams::getWorkingColorDescription((OZRenderParams *)(v21 + 16));
  FxHashColorDescription((int8x8_t *)&__y, WorkingColorDescription);
  Hash = PCHashWriteStream::getHash((int8x8_t *)&__y);
  PCHash128::operator+=((int *)&v247, (int *)Hash);
  if (v33)
  {
    PCHashWriteStream::reset((uint64_t)&__y);
    PCHashWriteStream::writeValue((int8x8_t *)&__y, v202);
    PCHashWriteStream::writeValue((int8x8_t *)&__y, v199);
    CMTime v59 = PCHashWriteStream::getHash((int8x8_t *)&__y);
    PCHash128::operator+=((int *)&v247, (int *)v59);
  }
  PCHashWriteStream::reset((uint64_t)&__y);
  char ReducedResolutionMedia = OZRenderParams::getReducedResolutionMedia((OZRenderParams *)(v21 + 16));
  PCHashWriteStream::writeValue((int8x8_t *)&__y, ReducedResolutionMedia);
  uint64_t v61 = PCHashWriteStream::getHash((int8x8_t *)&__y);
  PCHash128::operator+=((int *)&v247, (int *)v61);
  int v62 = *(_DWORD *)(*(void *)HGRenderJob::GetRenderNodeList(*(HGRenderJob **)(v21 + 8)) + 8);
  PCHashWriteStream::reset((uint64_t)&__y);
  PCHashWriteStream::writeValue((int8x8_t *)&__y, v62 == 0);
  double v63 = PCHashWriteStream::getHash((int8x8_t *)&__y);
  PCHash128::operator+=((int *)&v247, (int *)v63);
  double v189 = v18;
  unsigned int v192 = (std::mutex *)(v22 + 16616);
  if (!v62)
  {
    *(double *)&double v194 = 0.0;
    *(double *)&int v195 = 0.0;
    float64_t v70 = 0.0;
    float64_t v68 = 0.0;
    goto LABEL_107;
  }
  RenderGPU = (PSTextureCache *)OZRenderParams::getRenderGPU((OZRenderParams *)(v21 + 16), &v229);
  uint64_t v65 = PSTextureCache::Instance(RenderGPU);
  PSTextureCache::getTextureForKey(v65, (uint64_t)&v229, (const PCHash128 *)&v247, (uint64_t)&v224);
  double v67 = *((std::__shared_weak_count **)&v224 + 1);
  float64_t v68 = *(double *)&v224;
  if (*((void *)&v224 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v224 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  int v195 = v67;
  float64_t v70 = v225;
  uint64_t v69 = v226;
  if (*(double *)&v226 != 0.0) {
    atomic_fetch_add_explicit(&v226->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  double v194 = v69;
  if (v68 == 0.0) {
    char v71 = EnableMetalRendering;
  }
  else {
    char v71 = 1;
  }
  if ((v71 & 1) == 0)
  {
    __double2 v72 = (PGTextureCache *)OZCacheManager::Instance(*(OZCacheManager **)&v66);
    OZCacheManager::getTextureForKey(v72, (HGGPUComputeDevice **)&v229, (const PCHash128 *)&v247, 0, &v216);
    float64_t v73 = v216.f64[1];
    float64_t v68 = v216.f64[0];
    float64x2_t v216 = 0uLL;
    float64_t v66 = *(double *)&v195;
    if (*(double *)&v195 != 0.0)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v195);
      float64_t v66 = v216.f64[1];
      if (*(void *)&v216.f64[1]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v216.f64[1]);
      }
    }
    *(double *)&int v195 = v73;
  }
  if (v70 == 0.0) {
    int v74 = EnableMetalRendering;
  }
  else {
    int v74 = 0;
  }
  if (v74 == 1)
  {
    double v75 = (OZMetalTextureCache *)OZCacheManager::Instance(*(OZCacheManager **)&v66);
    OZCacheManager::getMetalTextureForKey(v75, *((void **)v229.var0 + 15), (const PCHash128 *)&v247, &v204);
    if (*(void *)&v204.f64[0])
    {
      v243._pcColorDesc._colorSpaceRef._obuint64_t j = 0;
      double v76 = *(const void **)(v21 + 1488);
      if (v76)
      {
        if (v77) {
          v243._pcColorDesc._colorSpaceRef._obuint64_t j = (CGColorSpace *)HGGPURenderer::GetMetalContext(v77);
        }
      }
      std::allocate_shared[abi:ne180100]<PGMetalTexture,std::allocator<PGMetalTexture>,HGRef<HGMetalTexture> &,HGMetalContext *&,void>((uint64_t *)&v204, (uint64_t *)&v243, &v216);
      float64_t v78 = v216.f64[1];
      float64_t v70 = v216.f64[0];
      float64x2_t v216 = 0uLL;
      if (*(double *)&v194 != 0.0)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v194);
        if (*(void *)&v216.f64[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v216.f64[1]);
        }
      }
      if (*(void *)&v204.f64[0]) {
        (*(void (**)(void))(**(void **)&v204.f64[0] + 24))(*(void *)&v204.f64[0]);
      }
    }
    else
    {
      float64_t v70 = 0.0;
      float64_t v78 = *(double *)&v194;
    }
    *(double *)&double v194 = v78;
  }
  if (v68 == 0.0) {
    int v79 = 1;
  }
  else {
    int v79 = EnableMetalRendering;
  }
  if (v79 == 1)
  {
    if (v70 == 0.0) {
      int v80 = 0;
    }
    else {
      int v80 = EnableMetalRendering;
    }
  }
  else
  {
    int v80 = 1;
  }
  if (a9 || !v80)
  {
LABEL_101:
    if (*(double *)&v226 != 0.0) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v226);
    }
    if (*((void *)&v224 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v224 + 1));
    }
    if (v230) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v230);
    }
LABEL_107:
    int v244 = 0;
    PCSharedCount::PCSharedCount(&v245);
    (*(void (**)(long long *__return_ptr, uint64_t, void, long long *, uint64_t))(*(void *)v22 + 1632))(&v224, v22, *(void *)(v21 + 8), &v254, 1);
    int v244 = (LiImageSource *)v224;
    PCSharedCount::PCSharedCount(&v229, (const PCSharedCount *)&v224 + 1);
    PCSharedCount::operator=((uint64_t *)&v245, (uint64_t *)&v229);
    PCSharedCount::~PCSharedCount(&v229);
    PCSharedCount::~PCSharedCount((PCSharedCount *)&v224 + 1);
    uint64_t v91 = OZRenderParams::getWorkingColorDescription(*(OZRenderParams **)(v21 + 8));
    OZRenderState v92 = *(CGColorSpace **)v91;
    v243._pcColorDesc._colorSpaceRef._obuint64_t j = v92;
    if (v92) {
      PCCFRefTraits<CGColorSpace *>::retain(v92);
    }
    uint64_t v93 = *(void *)(v91 + 8);
    v243._pcColorDesc._toneMapMethod._gain = *(float *)(v91 + 16);
    *(void *)&v243._pcColorDesc._dynamicRange = v93;
    v243._isPremultiplied = *(unsigned char *)(v91 + 24);
    float BlendingGamma = OZRenderParams::getBlendingGamma(*(OZRenderParams **)(v21 + 8));
    uint64_t RenderNodeList = HGRenderJob::GetRenderNodeList(*(HGRenderJob **)(v21 + 8));
    LiRenderParameters::LiRenderParameters(&v229, &v243, RenderNodeList, BlendingGamma);
    char v235 = OZRenderParams::getDo3DIntersectionAntialiasing(*(OZRenderParams **)(v21 + 8));
    long long v96 = *(OZRenderParams **)(v21 + 8);
    char v236 = *((unsigned char *)v96 + 516);
    double v97 = (GLRenderer *)OZRenderParams::getDoHighQualityResampling(v96);
    char v239 = (char)v97;
    BOOL v240 = GLRenderer::inDesperationMode(v97);
    LiRenderParameters::setHeliumRenderer((uint64_t)&v229, *(HGRenderer **)(v21 + 1488));
    CMTime v98 = (long long *)(*(void *)(v21 + 8) + 1316);
    long long v99 = *(_OWORD *)(*(void *)(v21 + 8) + 1332);
    long long v237 = *v98;
    v238[0] = v99;
    *(_OWORD *)((char *)v238 + 14) = *(long long *)((char *)v98 + 30);
    uint64_t v228 = 0;
    LiAgent::LiAgent((LiAgent *)&v224, (const LiRenderParameters *)&v229, 1);
    float64x2_t v100 = *(float64x2_t *)(v227 + 48);
    float64x2_t v102 = *(float64x2_t *)v227;
    float64x2_t v101 = *(float64x2_t *)(v227 + 16);
    float64x2_t v218 = *(float64x2_t *)(v227 + 32);
    float64x2_t v219 = v100;
    float64x2_t v216 = v102;
    float64x2_t v217 = v101;
    long long v103 = *(_OWORD *)(v227 + 112);
    long long v105 = *(_OWORD *)(v227 + 64);
    long long v104 = *(_OWORD *)(v227 + 80);
    long long v222 = *(_OWORD *)(v227 + 96);
    long long v223 = v103;
    long long v220 = v105;
    long long v221 = v104;
    if (v202 != 1.0)
    {
      float64x2_t v216 = vmulq_n_f64(v216, v202);
      float64x2_t v217 = vmulq_n_f64(v217, v202);
    }
    if (v199 != 1.0)
    {
      float64x2_t v218 = vmulq_n_f64(v218, v199);
      float64x2_t v219 = vmulq_n_f64(v219, v199);
    }
    LiAgent::setPixelTransform((uint64_t)&v224, (uint64_t)&v216);
    LiAgent::getHelium((LiAgent *)&v224, v244, (uint64_t *)&v204);
    float64_t v106 = v204.f64[0];
    if (v228 == *(void *)&v204.f64[0])
    {
      if (v228) {
        (*(void (**)(void))(*(void *)v228 + 24))();
      }
    }
    else
    {
      if (v228)
      {
        (*(void (**)(void))(*(void *)v228 + 24))();
        float64_t v106 = v204.f64[0];
      }
      uint64_t v228 = *(void *)&v106;
    }
    LiAgent::getDOD((uint64_t)&v224, (uint64_t)&v204);
    int v107 = LOBYTE(v205.f64[0]);
    float64_t v190 = v204.f64[0];
    float64x2_t v215 = v204;
    int v203 = HIDWORD(v204.f64[1]);
    int v200 = LODWORD(v204.f64[1]);
    double v108 = *(const void **)(v21 + 1488);
    if (v108)
    {
      if (v109)
      {
        uint64_t v110 = (uint64_t)v109;
        int v111 = PGHelium::convertBitsPerChannel((PGHelium *)4, *(_DWORD *)(*(void *)(v21 + 8) + 332), 0);
        if (!HGGPURenderer::ShouldAllocateGLTexture(v110, LODWORD(v215.f64[1]), HIDWORD(v215.f64[1]), v111))goto LABEL_302; {
      }
        }
    }
    if (v107)
    {
      float64x2_t v204 = 0uLL;
      __asm { FMOV            V0.2D, #-1.0 }
      float64x2_t v205 = _Q0;
      (*(void (**)(uint64_t, float64x2_t *, uint64_t))(*(void *)v22 + 1200))(v22, &v204, v21 + 16);
      *(int32x2_t *)&v215.f64[0] = vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(v204, (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL)))));
      *(int32x2_t *)&v215.f64[1] = vsub_s32(vmovn_s64(vcvtq_s64_f64(vrndpq_f64(vaddq_f64(v204, v205)))), *(int32x2_t *)&v215.f64[0]);
      int v113 = HIDWORD(v215.f64[1]);
      int v114 = LODWORD(v215.f64[1]);
    }
    else
    {
      int v114 = LODWORD(v215.f64[1]);
      int v113 = HIDWORD(v215.f64[1]);
    }
    if (v114 < 1 || v113 <= 0)
    {
      *(double *)uint64_t v19 = (double)SLODWORD(v190);
      *(double *)(v19 + 8) = (double)SHIDWORD(v190);
      *(double *)(v19 + 16) = (double)v200;
      *(double *)(v19 + 24) = (double)v203;
LABEL_302:
      LiAgent::~LiAgent((LiAgent *)&v224);
      if (v228) {
        (*(void (**)(uint64_t))(*(void *)v228 + 24))(v228);
      }
      double v88 = v194;
      double v90 = v195;
      if (v242) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v242);
      }
      PCCFRef<CGColorSpace *>::~PCCFRef(&v241);
      double v232 = &unk_1F10AD6B0;
      if (v233 < 0) {
        int v187 = 1;
      }
      else {
        int v187 = v233;
      }
      PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize((uint64_t)&v232, 0, v187);
      if (v234) {
        MEMORY[0x1BA9BFB70](v234, 0x1000C8077774924);
      }
      uint64_t v234 = 0;
      int v233 = 0;
      PCSharedCount::~PCSharedCount(&v231);
      PCCFRef<CGColorSpace *>::~PCCFRef(&v243._pcColorDesc._colorSpaceRef._obj);
      PCSharedCount::~PCSharedCount(&v245);
      goto LABEL_312;
    }
    float64x2_t v214 = 0uLL;
    float64x2_t v213 = 0uLL;
    if (v68 == 0.0) {
      char v115 = 1;
    }
    else {
      char v115 = EnableMetalRendering;
    }
    if ((v115 & 1) == 0)
    {
      if (*(double *)&v195 == 0.0)
      {
        float64x2_t v214 = (float64x2_t)*(unint64_t *)&v68;
        double v121 = v189;
        __n128 v119 = a9;
      }
      else
      {
        atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v120 = *(std::__shared_weak_count **)&v214.f64[1];
        v214.f64[0] = v68;
        *(void *)&v214.f64[1] = v195;
        double v121 = v189;
        __n128 v119 = a9;
        if (v120) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v120);
        }
      }
      if (!v119)
      {
        int v188 = 0;
        float64x2_t v117 = (uint64_t *)v197;
        goto LABEL_243;
      }
      long long v125 = *(const void **)(v21 + 1488);
      if (v125) {
      else
      }
        int v126 = 0;
      v204.f64[0] = v68;
      *(void *)&v204.f64[1] = v195;
      if (*(double *)&v195 != 0.0) {
        atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MetalContext = *(HGBitmapLoader **)&v215.f64[0];
      PGHelium::createTextureNode((uint64_t)&v204, (uint64_t)v126, (unsigned int *)&MetalContext, 0, 0, (HGBitmapLoader **)&v211);
      float64x2_t v117 = (uint64_t *)v197;
      long long v127 = *(HGBitmapLoader **)&v211.f64[0];
      if (*(void *)&v211.f64[0]) {
        v211.f64[0] = 0.0;
      }
      int v188 = v127;
      goto LABEL_171;
    }
    if (v70 == 0.0) {
      int v116 = 0;
    }
    else {
      int v116 = EnableMetalRendering;
    }
    if (v116 == 1)
    {
      float64x2_t v117 = (uint64_t *)v197;
      if (*(double *)&v194 == 0.0)
      {
        float64x2_t v213 = (float64x2_t)*(unint64_t *)&v70;
        __n128 v119 = a9;
      }
      else
      {
        atomic_fetch_add_explicit(&v194->__shared_owners_, 1uLL, memory_order_relaxed);
        double v118 = *(std::__shared_weak_count **)&v213.f64[1];
        v213.f64[0] = v70;
        *(void *)&v213.f64[1] = v194;
        __n128 v119 = a9;
        if (v118) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v118);
        }
      }
      double v121 = v189;
      if (v119)
      {
        long long v128 = *(const void **)(v21 + 1488);
        if (v128) {
        uint64_t v129 = *(HGBitmap **)(*(void *)&v213.f64[0] + 64);
        }
        if (v129) {
          (*(void (**)(void))(*(void *)v129 + 16))(*(void *)(*(void *)&v213.f64[0] + 64));
        }
        unsigned int v130 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
        HGBitmapLoader::HGBitmapLoader(v130, v129);
        int v188 = v130;
        if (v129)
        {
          (*(void (**)(HGBitmap *))(*(void *)v129 + 24))(v129);
          __n128 v119 = a9;
          goto LABEL_243;
        }
LABEL_242:
        __n128 v119 = a9;
        goto LABEL_243;
      }
      goto LABEL_187;
    }
    double v121 = v189;
    float64x2_t v117 = (uint64_t *)v197;
    int v188 = (HGBitmapLoader *)v228;
    if (v228) {
      (*(void (**)(uint64_t))(*(void *)v228 + 16))(v228);
    }
    if (!v62)
    {
      __n128 v119 = a9;
      if (a9)
      {
        CMTime v131 = *a9;
        if (*a9 != v188)
        {
          if (v131) {
            (*(void (**)(HGBitmapLoader *))(*(void *)v131 + 24))(v131);
          }
          __n128 v119 = a9;
          *a9 = v188;
          if (v188)
          {
            (*(void (**)(HGBitmapLoader *))(*(void *)v188 + 16))(v188);
            goto LABEL_242;
          }
LABEL_187:
          int v188 = 0;
        }
      }
LABEL_243:
      unsigned int v207 = 0;
      float64x2_t v205 = 0u;
      long long v206 = 0u;
      float64x2_t v204 = 0u;
      v154.i64[0] = SLODWORD(v215.f64[0]);
      v154.i64[1] = SHIDWORD(v215.f64[0]);
      float64x2_t v208 = vcvtq_f64_s64(v154);
      v154.i64[0] = SLODWORD(v215.f64[1]);
      v154.i64[1] = SHIDWORD(v215.f64[1]);
      float64x2_t v209 = vcvtq_f64_s64(v154);
      if (v119 && v188)
      {
        *(void *)&v204.f64[0] = v188;
        (*(void (**)(HGBitmapLoader *))(*(void *)v188 + 16))(v188);
      }
      if (v117)
      {
        uint64_t v156 = *v117;
        int v155 = (std::__shared_weak_count *)v117[1];
        if (v155) {
          atomic_fetch_add_explicit(&v155->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v157 = v207;
        *((void *)&v206 + 1) = v156;
        unsigned int v207 = v155;
        if (!v157) {
          goto LABEL_261;
        }
      }
      else
      {
        float64_t v158 = v214.f64[0];
        if (*(void *)&v214.f64[0])
        {
          float64_t v159 = v214.f64[1];
          if (*(void *)&v214.f64[1]) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v214.f64[1] + 8), 1uLL, memory_order_relaxed);
          }
          float64_t v160 = v205.f64[0];
          v204.f64[1] = v158;
          v205.f64[0] = v159;
          if (v160 != 0.0) {
            std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v160);
          }
        }
        float64_t v161 = v213.f64[0];
        if (!*(void *)&v213.f64[0]) {
          goto LABEL_261;
        }
        float64_t v162 = v213.f64[1];
        if (*(void *)&v213.f64[1]) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v213.f64[1] + 8), 1uLL, memory_order_relaxed);
        }
        int v157 = (std::__shared_weak_count *)v206;
        v205.f64[1] = v161;
        *(float64_t *)&long long v206 = v162;
        if (!v157) {
          goto LABEL_261;
        }
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v157);
LABEL_261:
      int v163 = v121;
      PCSharedMutex::lock(v192);
      *(void *)&v211.f64[0] = &v248;
      __double2 v164 = std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::__emplace_unique_key_args<PSParticleType::HGNodeCacheEntryKey,std::piecewise_construct_t const&,std::tuple<PSParticleType::HGNodeCacheEntryKey const&>,std::tuple<>>(v193, (uint64_t)&v248, (uint64_t)&std::piecewise_construct, (long long **)&v211);
      uint64_t v165 = *((void *)v164 + 9);
      float64_t v166 = v204.f64[0];
      if (v165 != *(void *)&v204.f64[0])
      {
        if (v165) {
          (*(void (**)(uint64_t))(*(void *)v165 + 24))(v165);
        }
        *((float64_t *)v164 + 9) = v166;
        if (v166 != 0.0) {
          (*(void (**)(float64_t))(**(void **)&v166 + 16))(COERCE_FLOAT64_T(*(void *)&v166));
        }
      }
      float64_t v167 = v204.f64[1];
      float64_t v168 = v205.f64[0];
      if (*(void *)&v205.f64[0]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v205.f64[0] + 8), 1uLL, memory_order_relaxed);
      }
      signed int v169 = (std::__shared_weak_count *)*((void *)v164 + 11);
      *((float64_t *)v164 + 10) = v167;
      *((float64_t *)v164 + 11) = v168;
      if (v169) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v169);
      }
      float64_t v170 = v205.f64[1];
      int v171 = (std::__shared_weak_count *)v206;
      if ((void)v206) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v206 + 8), 1uLL, memory_order_relaxed);
      }
      double v172 = (std::__shared_weak_count *)*((void *)v164 + 13);
      *((float64_t *)v164 + 12) = v170;
      *((void *)v164 + 13) = v171;
      if (v172) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v172);
      }
      uint64_t v173 = *((void *)&v206 + 1);
      int v174 = v207;
      if (v207) {
        atomic_fetch_add_explicit(&v207->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      double v175 = (std::__shared_weak_count *)*((void *)v164 + 15);
      *((void *)v164 + 14) = v173;
      *((void *)v164 + 15) = v174;
      if (v175) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v175);
      }
      float64x2_t v176 = v209;
      *((float64x2_t *)v164 + 8) = v208;
      *((float64x2_t *)v164 + 9) = v176;
      PCSharedMutex::unlock(v192);
      double v177 = (std::mutex *)(v22 + 16744);
      PCSharedMutex::lock((std::mutex *)(v22 + 16744));
      double v178 = v163;
      double v179 = (uint64_t **)(v22 + 16720);
      if (*(void *)(v22 + 16736) >= 0x400uLL)
      {
        int v180 = *v179;
        std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(v179, *v179);
        operator delete(v180);
      }
      *(void *)&v211.f64[0] = &v247;
      int v181 = (float64x2_t *)std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::__emplace_unique_key_args<PCHash128,std::piecewise_construct_t const&,std::tuple<PCHash128 const&>,std::tuple<>>(v179, (const PCHash128 *)&v247, (uint64_t)&std::piecewise_construct, &v211);
      float64x2_t v182 = v209;
      v181[3] = v208;
      v181[4] = v182;
      PCSharedMutex::unlock(v177);
      *(double *)uint64_t v19 = (double)SLODWORD(v190);
      *(double *)(v19 + 8) = (double)SHIDWORD(v190);
      *(double *)(v19 + 16) = (double)v200;
      *(double *)(v19 + 24) = (double)v203;
      float64x2_t v183 = v214;
      if (*(void *)&v214.f64[1]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v214.f64[1] + 8), 1uLL, memory_order_relaxed);
      }
      double v184 = *(std::__shared_weak_count **)(v196 + 8);
      *(float64x2_t *)uint64_t v196 = v183;
      if (v184) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v184);
      }
      float64x2_t v185 = v213;
      if (*(void *)&v213.f64[1]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v213.f64[1] + 8), 1uLL, memory_order_relaxed);
      }
      int v186 = (std::__shared_weak_count *)*((void *)v178 + 1);
      *(float64x2_t *)double v178 = v185;
      if (v186) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v186);
      }
      if (v174) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v174);
      }
      if (v171) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v171);
      }
      if (v168 != 0.0) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v168);
      }
      if (v166 != 0.0) {
        (*(void (**)(float64_t))(**(void **)&v166 + 24))(COERCE_FLOAT64_T(*(void *)&v166));
      }
      if (*(void *)&v213.f64[1]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v213.f64[1]);
      }
      if (*(void *)&v214.f64[1]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v214.f64[1]);
      }
      if (v188) {
        (*(void (**)(HGBitmapLoader *))(*(void *)v188 + 24))(v188);
      }
      goto LABEL_302;
    }
    unsigned int v122 = *(_DWORD *)(*(void *)(v21 + 8) + 340);
    HeliumRenderer = (const void *)LiAgent::getHeliumRenderer((LiRenderParameters **)&v224);
    if (HeliumRenderer) {
    else
    }
      double v124 = 0;
    if (EnableMetalRendering)
    {
      v211.f64[0] = 0.0;
      FxColorDescription::getCGColorSpace(&v243);
      PGHelium::renderNodeToMetalTexture(v124, &v228, (unsigned int *)&v215, v122, v191, &v204);
      float64_t v132 = v204.f64[0];
      if (*(void *)&v211.f64[0] == *(void *)&v204.f64[0])
      {
        __n128 v119 = a9;
        if (*(void *)&v211.f64[0]) {
          (*(void (**)(void))(**(void **)&v211.f64[0] + 24))();
        }
      }
      else
      {
        __n128 v119 = a9;
        if (*(void *)&v211.f64[0])
        {
          (*(void (**)(void))(**(void **)&v211.f64[0] + 24))();
          float64_t v132 = v204.f64[0];
        }
        v211.f64[0] = v132;
      }
      MetalContext = (HGBitmapLoader *)HGGPURenderer::GetMetalContext((HGGPURenderer *)v124);
      std::allocate_shared[abi:ne180100]<PGMetalTexture,std::allocator<PGMetalTexture>,HGRef<HGMetalTexture> &,HGMetalContext *,void>((uint64_t *)&v211, (uint64_t *)&MetalContext, &v204);
      float64x2_t v135 = v204;
      float64x2_t v204 = 0uLL;
      double v136 = *(std::__shared_weak_count **)&v213.f64[1];
      float64x2_t v213 = v135;
      if (v136)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v136);
        if (*(void *)&v204.f64[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v204.f64[1]);
        }
      }
      if (*(void *)&v211.f64[0]) {
        (*(void (**)(void))(**(void **)&v211.f64[0] + 24))(*(void *)&v211.f64[0]);
      }
    }
    else
    {
      FxColorDescription::getCGColorSpace(&v243);
      PGHelium::renderNodeToTexture(v124, &v228, (unsigned int *)&v215, v122, v191, 1, &v204);
      float64x2_t v133 = v204;
      float64x2_t v204 = 0uLL;
      double v134 = *(std::__shared_weak_count **)&v214.f64[1];
      float64x2_t v214 = v133;
      __n128 v119 = a9;
      if (v134)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v134);
        if (*(void *)&v204.f64[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v204.f64[1]);
        }
      }
    }
    if (*(void *)&v214.f64[0])
    {
      if (!v197)
      {
        double v139 = (OZCacheManager *)OZRenderParams::getRenderGPU((OZRenderParams *)(v21 + 16), &v204);
        BOOL v140 = (PGTextureCache *)OZCacheManager::Instance(v139);
        BOOL v141 = OZCacheManager::addTexture(v140, (uint64_t *)&v214, (HGGPUComputeDevice **)&v204, (PCHash128 *)&v247);
        uint64_t v142 = PSTextureCache::Instance((PSTextureCache *)v141);
        PSTextureCache::addTexture(v142, (uint64_t *)&v214, (uint64_t)&v204, (uint64_t *)&v247);
        double v143 = *(const void **)(v21 + 1488);
        if (v143) {
        else
        }
          double v144 = 0;
        int v153 = v188;
        float64x2_t v211 = v214;
        if (*(void *)&v214.f64[1]) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v214.f64[1] + 8), 1uLL, memory_order_relaxed);
        }
        float64_t v210 = v215.f64[0];
        PGHelium::createTextureNode((uint64_t)&v211, (uint64_t)v144, (unsigned int *)&v210, 0, 0, &MetalContext);
        if (v188 == MetalContext)
        {
          if (v188) {
            (*(void (**)(HGBitmapLoader *))(*(void *)v188 + 24))(v188);
          }
        }
        else
        {
          if (v188) {
            (*(void (**)(HGBitmapLoader *))(*(void *)v188 + 24))(v188);
          }
          int v153 = MetalContext;
          MetalContext = 0;
        }
        if (*(void *)&v211.f64[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v211.f64[1]);
        }
        int v188 = v153;
LABEL_171:
        if (*(void *)&v204.f64[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v204.f64[1]);
        }
        goto LABEL_243;
      }
      (*(void (**)(float64x2_t *__return_ptr))(**(void **)&v214.f64[0] + 72))(&v204);
    }
    else
    {
      if (!*(void *)&v213.f64[0]) {
        goto LABEL_243;
      }
      if (!v197)
      {
        float64_t v145 = (OZCacheManager *)OZRenderParams::getRenderGPU((OZRenderParams *)(v21 + 16), &v204);
        double v146 = v188;
        double v147 = (OZMetalTextureCache *)OZCacheManager::Instance(v145);
        float64_t v148 = *(double *)(*(void *)&v213.f64[0] + 64);
        v211.f64[0] = v148;
        if (v148 != 0.0) {
          (*(void (**)(float64_t))(**(void **)&v148 + 16))(COERCE_FLOAT64_T(*(void *)&v148));
        }
        OZCacheManager::addMetalTexture(v147, (uint64_t *)&v211, *(void **)(*(void *)&v204.f64[0] + 120), (PCHash128 *)&v247);
        uint64_t v149 = *(PSTextureCache **)&v211.f64[0];
        if (*(void *)&v211.f64[0]) {
          uint64_t v149 = (PSTextureCache *)(*(uint64_t (**)(void))(**(void **)&v211.f64[0] + 24))(*(void *)&v211.f64[0]);
        }
        uint64_t v150 = PSTextureCache::Instance(v149);
        PSTextureCache::addTexture(v150, (uint64_t *)&v213, (uint64_t)&v204, (uint64_t *)&v247);
        unsigned int v151 = *(HGBitmap **)(*(void *)&v213.f64[0] + 64);
        if (v151) {
          (*(void (**)(void))(*(void *)v151 + 16))(*(void *)(*(void *)&v213.f64[0] + 64));
        }
        double v152 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
        HGBitmapLoader::HGBitmapLoader(v152, v151);
        if (v188 == v152)
        {
          if (v188) {
            (*(void (**)(HGBitmapLoader *))(*(void *)v188 + 24))(v188);
          }
        }
        else
        {
          if (v188) {
            (*(void (**)(HGBitmapLoader *))(*(void *)v188 + 24))(v188);
          }
          double v146 = v152;
        }
        if (v151) {
          (*(void (**)(HGBitmap *))(*(void *)v151 + 24))(v151);
        }
        int v188 = v146;
        if (*(void *)&v204.f64[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v204.f64[1]);
        }
        goto LABEL_242;
      }
      (*(void (**)(float64x2_t *__return_ptr))(**(void **)&v213.f64[0] + 72))(&v204);
    }
    float64x2_t v137 = v204;
    float64x2_t v204 = 0uLL;
    double v138 = *(std::__shared_weak_count **)(v197 + 8);
    *(float64x2_t *)uint64_t v197 = v137;
    if (!v138) {
      goto LABEL_243;
    }
    std::__shared_weak_count::__release_shared[abi:ne180100](v138);
    goto LABEL_171;
  }
  PCSharedMutex::lock_shared((std::mutex *)(v22 + 16744));
  double v81 = std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::find<PCHash128>(v22 + 16720, (const PCHash128 *)&v247);
  if ((void *)(v22 + 16728) == v81)
  {
    PCSharedMutex::unlock_shared((std::mutex *)(v22 + 16744));
    goto LABEL_101;
  }
  PCSharedMutex::lock(v192);
  *(void *)&v216.f64[0] = &v248;
  double v82 = std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::__emplace_unique_key_args<PSParticleType::HGNodeCacheEntryKey,std::piecewise_construct_t const&,std::tuple<PSParticleType::HGNodeCacheEntryKey const&>,std::tuple<>>(v193, (uint64_t)&v248, (uint64_t)&std::piecewise_construct, (long long **)&v216);
  double v83 = v82;
  long long v84 = *((_OWORD *)v81 + 4);
  *((_OWORD *)v82 + 8) = *((_OWORD *)v81 + 3);
  *((_OWORD *)v82 + 9) = v84;
  if (v68 != 0.0)
  {
    if (*(double *)&v195 != 0.0) {
      atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    double v85 = (std::__shared_weak_count *)*((void *)v82 + 11);
    *((float64_t *)v83 + 10) = v68;
    *((double *)v83 + 11) = *(double *)&v195;
    if (v85) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v85);
    }
  }
  if (v70 != 0.0)
  {
    if (*(double *)&v194 != 0.0) {
      atomic_fetch_add_explicit(&v194->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    double v86 = (std::__shared_weak_count *)*((void *)v83 + 13);
    *((float64_t *)v83 + 12) = v70;
    *((double *)v83 + 13) = *(double *)&v194;
    if (v86) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v86);
    }
  }
  PCSharedMutex::unlock(v192);
  long long v87 = *((_OWORD *)v81 + 4);
  *(_OWORD *)uint64_t v19 = *((_OWORD *)v81 + 3);
  *(_OWORD *)(v19 + 16) = v87;
  if (EnableMetalRendering)
  {
    double v88 = v194;
    if (*(double *)&v194 != 0.0) {
      atomic_fetch_add_explicit(&v194->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CMTime v89 = (std::__shared_weak_count *)*((void *)v189 + 1);
    *double v189 = v70;
    v189[1] = *(double *)&v194;
    double v90 = v195;
    if (!v89) {
      goto LABEL_149;
    }
  }
  else
  {
    double v88 = v194;
    double v90 = v195;
    if (*(double *)&v195 != 0.0) {
      atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CMTime v89 = *(std::__shared_weak_count **)(v196 + 8);
    *(float64_t *)uint64_t v196 = v68;
    *(double *)(v196 + 8) = *(double *)&v195;
    if (!v89) {
      goto LABEL_149;
    }
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v89);
LABEL_149:
  PCSharedMutex::unlock_shared((std::mutex *)(v22 + 16744));
  if (*(double *)&v226 != 0.0) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v226);
  }
  if (*((void *)&v224 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v224 + 1));
  }
  if (v230) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v230);
  }
LABEL_312:
  if (v88) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v88);
  }
  if (v90) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v90);
  }
  std::__list_imp<unsigned int>::clear(v246);
  PCHashWriteStream::~PCHashWriteStream((PCHashWriteStream *)&__y);
}

void sub_1B7DD9438(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

CGColorSpace **PSParticleType::buildParticleRenderGraph(uint64_t a1, uint64_t a2, double *a3, uint64_t a4, double *a5, uint64_t a6, const OZRenderGraphState *a7)
{
  uint64_t v12 = *((void *)a3 + 1);
  CMTimeEpoch v13 = *(void *)(v12 + 16);
  *(_OWORD *)&v41.value = *(_OWORD *)v12;
  v41.CMTimeEpoch epoch = v13;
  CMTime v40 = *(CMTime *)(a4 + 80);
  if (*(double *)(a4 + 104) > 0.0)
  {
    memset(v39, 0, sizeof(v39));
    CMTime v21 = v41;
    v22[0] = *(CMTime *)(a4 + 8);
    PC_CMTimeSaferSubtract(&v21, v22, (uint64_t)v39);
    operator/((long long *)v39, (uint64_t)v20, *(double *)(a4 + 104));
    v22[0] = v40;
    CMTime v27 = v20[0];
    PC_CMTimeSaferAdd(v22, &v27, (uint64_t)&v21);
    CMTime v40 = v21;
    long long v37 = *(_OWORD *)(a1 + 16464);
    uint64_t v38 = *(void *)(a1 + 16480);
    memset(&v36, 0, sizeof(v36));
    operator/((long long *)&v40.value, (uint64_t)&v37, (uint64_t)&v36);
    CMTimeMake(&v26, 1, 1);
    CMTime v21 = v36;
    v22[0] = v26;
    PC_CMTimeFloorToSampleDuration(&v21, v22, (uint64_t)v20);
    CMTime v21 = v36;
    v22[0] = v20[0];
    PC_CMTimeSaferSubtract(&v21, v22, (uint64_t)&v27);
    operator*((long long *)&v27.value, (uint64_t)&v37, (uint64_t)&v21);
    CMTime v36 = v21;
    CMTime v40 = v21;
  }
  long long v14 = *(_OWORD *)(a1 + 16440);
  v27.CMTimeEpoch epoch = *(void *)(a1 + 16456);
  *(_OWORD *)&v27.value = v14;
  v22[0] = v40;
  PC_CMTimeSaferAdd(v22, &v27, (uint64_t)&v21);
  CMTime v40 = v21;
  uint64_t v15 = *(const void **)(a1 + 16488);
  if (v15) {
  else
  }
    BOOL v16 = 0;
  uint64_t v35 = 0x3FF0000000000000;
  uint64_t v32 = 0x3FF0000000000000;
  uint64_t v29 = 0x3FF0000000000000;
  v27.value = 0x3FF0000000000000;
  *(_OWORD *)&v27.timescale = 0u;
  long long v28 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  if (v16 && (*(unsigned int (**)(void *))(*(void *)v16 + 248))(v16))
  {
    PSParticleType::getImageParticleMatrix3D((CGColorSpace **)a1, (uint64_t)a3, a4, a5, (uint64_t)&v27);
  }
  else
  {
    PSParticleType::getImageParticleMatrix((CGColorSpace **)a1, *((CMTime **)a3 + 1), a4, a5, (uint64_t)&v27, *((unsigned __int8 *)a3 + 1497));
    if (*((unsigned char *)a3 + 1498) && *(unsigned char *)(*((void *)a3 + 1) + 242)) {
      adjustImageParticleMatrixForFacingCameraEquirectRender(a3, (double *)&v27.value);
    }
  }
  WorkingColorSpace = (CGColorSpace *)OZRenderParams::getWorkingColorSpace(*((FxColorDescription **)a3 + 1));
  PCWorkingColor::PCWorkingColor((PCWorkingColor *)&v26, 0.0, 0.0, 0.0, 0.0, WorkingColorSpace);
  (*(void (**)(uint64_t, CMTime *, uint64_t, void, CMTime *))(*(void *)a1 + 1600))(a1, &v41, a4, *(void *)a3, &v26);
  int v18 = *(unsigned __int8 *)(a1 + 16528);
  OZRenderGraphState::OZRenderGraphState((OZRenderGraphState *)v22, a7);
  v24[34] = 1;
  int v25 = 8 * v18;
  if (v16 && (*(unsigned int (**)(void *))(*(void *)v16 + 248))(v16)) {
    operator new();
  }
  v21.value = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)&v21.timescale);
  (*(void (**)(CMTime *__return_ptr, uint64_t, void, CMTime *, uint64_t))(*(void *)a1 + 1632))(v20, a1, *((void *)a3 + 1), &v40, 1);
  v21.value = v20[0].value;
  PCSharedCount::PCSharedCount(v39, (const PCSharedCount *)&v20[0].timescale);
  PCSharedCount::operator=((uint64_t *)&v21.timescale, (uint64_t *)v39);
  PCSharedCount::~PCSharedCount(v39);
  PCSharedCount::~PCSharedCount((PCSharedCount *)&v20[0].timescale);
  if (v21.value) {
    operator new();
  }
  PCSharedCount::~PCSharedCount((PCSharedCount *)&v21.timescale);
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray((uint64_t)v24);
  std::__list_imp<unsigned int>::clear(v23);
  return PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v26.epoch);
}

void sub_1B7DDA254(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v3, 0x10A1C40063EAE96);
  PCSharedCount::~PCSharedCount(v2);
  PCSharedCount::~PCSharedCount(v1);
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray((uint64_t)&STACK[0x6D0]);
  std::__list_imp<unsigned int>::clear(&STACK[0x630]);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&STACK[0x738]);
  _Unwind_Resume(a1);
}

void PSParticleType::setGeodeProperties(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double v9 = *(double *)a2;
  uint64_t v8 = *(OZRenderParams **)(a2 + 8);
  uint64_t DoHighQualityResampling = OZRenderParams::getDoHighQualityResampling(v8);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a4 + 280))(a4, DoHighQualityResampling);
  if (*(unsigned char *)a3
    && !OZChannel::getValueAsInt((OZChannel *)(*(void *)&v9 + 32792), MEMORY[0x1E4F1FA48], 0.0))
  {
    (*(void (**)(uint64_t, double))(*(void *)a4 + 192))(a4, *(double *)(a3 + 8));
    *(_DWORD *)(a4 + 680) = *(_DWORD *)(a3 + 48);
    if (*(unsigned char *)(a3 + 16))
    {
      (*(void (**)(uint64_t, double))(*(void *)a4 + 208))(a4, *(double *)(a3 + 24));
      (*(void (**)(uint64_t, double))(*(void *)a4 + 224))(a4, *(double *)(a3 + 32));
      (*(void (**)(uint64_t, double))(*(void *)a4 + 240))(a4, *(double *)(a3 + 40));
    }
    if (*(double *)(a3 + 56) > 0.0) {
      (*(void (**)(uint64_t))(*(void *)a4 + 256))(a4);
    }
  }
  else
  {
    (*(void (**)(uint64_t, double))(*(void *)a4 + 192))(a4, 0.0);
  }
  if (*(unsigned char *)(a4 + 552)) {
    _ZF = *(unsigned char *)(a3 + 288) == 0;
  }
  else {
    _ZF = 1;
  }
  char v12 = !_ZF;
  *(unsigned char *)(a4 + 552) = v12;
  if (*(unsigned char *)(a4 + 553)) {
    BOOL v13 = *(unsigned char *)(a3 + 289) == 0;
  }
  else {
    BOOL v13 = 1;
  }
  char v14 = !v13;
  *(unsigned char *)(a4 + 553) = v14;
  *(unsigned char *)(a4 + 696) = *(unsigned char *)(a3 + 88);
  if (*(void *)(a3 + 72) != a3 + 64) {
    operator new();
  }
  uint64_t v15 = (void *)*((void *)v8 + 160);
  int v25 = v15;
  if (v15) {
    BOOL v16 = (PCShared_base *)((char *)v15 + *(void *)(*v15 - 24));
  }
  else {
    BOOL v16 = 0;
  }
  PCSharedCount::PCSharedCount(&v26, v16);
  if ((*(unsigned int (**)(uint64_t, uint64_t, OZRenderParams *))(*(void *)(*(void *)&v9 + 200) + 2152))(*(void *)&v9 + 200, a3 + 224, v8))
  {
    long long v23 = 0uLL;
    __asm { FMOV            V0.2D, #-1.0 }
    long long v24 = _Q0;
    OZRenderState::OZRenderState(&v22, (const OZRenderState *)v8);
    v22.var9 = 1;
    (*(void (**)(void, long long *, OZRenderState *))(**(void **)(a1 + 16488) + 88))(*(void *)(a1 + 16488), &v23, &v22);
    long long v21 = v24;
    *(_OWORD *)(a4 + 704) = v23;
    *(_OWORD *)(a4 + 720) = v21;
  }
  (*(void (**)(double, OZRenderParams *, uint64_t, uint64_t))(**(void **)&v9 + 144))(COERCE_DOUBLE(*(void *)&v9), v8, a3, a4);
  PSParticleType::buildLighting(a1, a4, a3 + 224, (double *)a2);
  PCSharedCount::~PCSharedCount(&v26);
}

void sub_1B7DDA7E4(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void PSParticleType::buildRenderGraph(PSParticleType *this, OZRenderParams *a2, LiGraphBuilder *a3, const OZRenderGraphState *a4)
{
  *((void *)this + 2061) = (*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this);
  uint64_t v10 = 0;
  PCSharedCount::PCSharedCount(&v11);
  long long v6 = *(_OWORD *)a2;
  uint64_t v7 = *((void *)a2 + 2);
  (*(void (**)(LiImageSource **__return_ptr, PSParticleType *, OZRenderParams *, long long *, void))(*(void *)this + 1632))(&v8, this, a2, &v6, 0);
  uint64_t v10 = v8;
  PCSharedCount::PCSharedCount(&v12, &v9);
  PCSharedCount::operator=((uint64_t *)&v11, (uint64_t *)&v12);
  PCSharedCount::~PCSharedCount(&v12);
  PCSharedCount::~PCSharedCount(&v9);
  if (v10) {
    operator new();
  }
  PCSharedCount::~PCSharedCount(&v11);
}

void sub_1B7DDA9D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, PCSharedCount a16)
{
  PCSharedCount::~PCSharedCount(v18 + 1);
  PCSharedCount::~PCSharedCount(v17);
  PCSharedCount::~PCSharedCount(v16);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'PSParticleType::buildRenderGraph(PSParticleType *this, OZRenderParams *a2, LiGraphBuilder *a3, const OZRenderGraphState *a4)
{
}

void PSParticleType::getHeliumGraph(void *a1@<X8>)
{
  *a1 = 0;
}

void non-virtual thunk to'PSParticleType::getHeliumGraph(void *a1@<X8>)
{
  *a1 = 0;
}

void PSParticleType::addSprite(PSParticleType *this, PSEmitter::RenderParams *a2, PSParticle *a3, float64x2_t *a4, PSHeliumNode *a5)
{
  if (*((void *)this + 2061)) {
    int v5 = *((_DWORD *)this + 4133);
  }
  else {
    int v5 = 0;
  }
  switch(v5)
  {
    case 0:
      PSParticleType::addPointSprite(this, a2, a3, a4, a5);
      break;
    case 1:
      PSParticleType::addLineSprite(this, a2, a3, (OZSimStateElement *)a4, a5);
      break;
    case 2:
      PSParticleType::addOutlineSprite((CGColorSpace **)this, a2, a3, (OZSimStateElement *)a4, a5);
      break;
    case 3:
      PSParticleType::addImageSprite(this, a2, a3, (OZSimStateElement *)a4, a5);
      break;
    default:
      return;
  }
}

void PSParticleType::preRenderFrame(PSParticleType *this, const OZRenderParams *a2)
{
  double v4 = (BOOL *)this + 16528;
  (*(void (**)(PSParticleType *))(*(void *)this + 1640))(this);
  v4[1] = PSParticleType::isSourceSingleFrame(this);
  int v5 = (const CMTime *)MEMORY[0x1E4F1FA48];
  *((_DWORD *)v4 + 1) = OZChannel::getValueAsInt((OZChannel *)((char *)this + 11344), MEMORY[0x1E4F1FA48], 0.0);
  *double v4 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 9968), v5, 0.0) != 0;
  v4[16] = OZChannel::getValueAsInt((OZChannel *)((char *)this + 14552), v5, 0.0) != 0;
  OZChannel::getValueAsDouble((OZChannel *)((char *)this + 14704), v5, 0.0);
  *((void *)this + 2069) = v6;
  CMTime v10 = *(CMTime *)a2;
  double v7 = 1.0;
  if (!*((_DWORD *)v4 + 1))
  {
    OZRenderParams::getResolution(a2, &v11);
    if (v11.n128_f64[0] >= v11.n128_f64[1]) {
      double v8 = v11.n128_f64[0];
    }
    else {
      double v8 = v11.n128_f64[1];
    }
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 11752), &v10, 0.0);
    double v7 = v8 * v9;
  }
  *((double *)this + 2067) = v7;
}

BOOL PSParticleType::isSourceSingleFrame(PSParticleType *this)
{
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 11344), MEMORY[0x1E4F1FA48], 0.0) != 3) {
    return 1;
  }
  double v2 = (const void *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this);
  if (!v2) {
    return 1;
  }
  if (!v3) {
    return 1;
  }
  double v4 = v3;
  if (!(*(uint64_t (**)(void *))(*(void *)v3 + 264))(v3)) {
    return 1;
  }
  memset(&v9, 0, sizeof(v9));
  (*(void (**)(CMTime *__return_ptr, void *))(*(void *)v4 + 280))(&v9, v4);
  uint64_t v5 = (*(uint64_t (**)(void *))(*(void *)v4 + 264))(v4);
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v5 + 336), &v7);
  CMTime time1 = v9;
  *(__n128 *)&time2.value = v7;
  time2.CMTimeEpoch epoch = v8;
  return CMTimeCompare(&time1, &time2) < 1;
}

uint64_t PSParticleType::preRenderFrame(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 1288))();
}

void PSParticleType::postRenderFrame(PSParticleType *this, const OZRenderParams *a2)
{
  uint64_t v3 = (std::mutex *)((char *)this + 16616);
  PCSharedMutex::lock((std::mutex *)((char *)this + 16616));
  std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::destroy((uint64_t)this + 16568, *((void **)this + 2072));
  *((void *)this + 2071) = (char *)this + 16576;
  *((void *)this + 2073) = 0;
  *((void *)this + 2072) = 0;
  std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::destroy((uint64_t)this + 16592, *((PCSharedCount **)this + 2075));
  *((void *)this + 2074) = (char *)this + 16600;
  *((void *)this + 2076) = 0;
  *((void *)this + 2075) = 0;
  PCSharedMutex::unlock(v3);
  PCSharedMutex::lock((std::mutex *)((char *)this + 16872));
  *((void *)this + 2107) = *((void *)this + 2106);

  PCSharedMutex::unlock((std::mutex *)((char *)this + 16872));
}

uint64_t PSParticleType::setImageNode(PSParticleType *this, OZImageNode *lpsrc)
{
  double v3 = 0.0;
  if (lpsrc)
  {
    if (v4)
    {
      LODWORD(v5) = v4[20];
      double v3 = (double)v5;
    }
  }
  OZChanSceneNodeRef::setValue((OZChannelBase *)((char *)this + 14392), MEMORY[0x1E4F1FA48], v3, 0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 14392), v3);
  uint64_t v6 = *(uint64_t (**)(PSParticleType *))(*(void *)this + 1640);

  return v6(this);
}

uint64_t non-virtual thunk to'PSParticleType::setImageNode(PSParticleType *this, OZImageNode *a2)
{
  return PSParticleType::setImageNode((PSParticleType *)((char *)this - 16), a2);
}

const void *PSParticleType::getImageNode(PSParticleType *this)
{
  return OZChanElementOrFootageRef::getImageNode((OZChannelBase *)((char *)this + 14392));
}

const void *non-virtual thunk to'PSParticleType::getImageNode(PSParticleType *this)
{
  return OZChanElementOrFootageRef::getImageNode((OZChannelBase *)((char *)this + 14376));
}

OZFactories *PSParticleType::markFactoriesForSerialization(PSParticleType *this, PCSerializerWriteStream *a2)
{
  OZSceneNode::markFactoriesForSerialization((OZFactory **)this, a2);

  return OZChannelGradient::markFactoriesForSerialization((OZChannelFolder *)((char *)this + 6784), a2, 0);
}

OZFactories *non-virtual thunk to'PSParticleType::markFactoriesForSerialization(PSParticleType *this, PCSerializerWriteStream *a2)
{
  OZSceneNode::markFactoriesForSerialization((OZFactory **)this - 6, a2);

  return OZChannelGradient::markFactoriesForSerialization((OZChannelFolder *)((char *)this + 6736), a2, 0);
}

OZChannelBase *PSParticleType::didCreateCopyForCopyOnWrite(PSParticleType *this, double a2)
{
  double v2 = (OZChannel *)((char *)this + 11600);
  LODWORD(a2) = *((_DWORD *)this + 20);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 11600), (double)*(unint64_t *)&a2);
  OZChannel::resetCurve(v2);

  return OZChannelBase::resetFlag((OZChannelBase *)v2, 0x100000000, 1);
}

uint64_t PSParticleType::didAddToScene(PSParticleType *this, OZScene *a2)
{
  OZSceneNode::didAddToScene(this, a2);
  OZSystemSimulator::didAddToScene((PSParticleType *)((char *)this + 15520), a2);
  OZSystemSimulator::didAddToScene((PSParticleType *)((char *)this + 16080), a2);
  double v4 = *(uint64_t (**)(PSParticleType *))(*(void *)this + 1640);

  return v4(this);
}

void *PSParticleType::willRemoveFromScene(PSParticleType *this, OZScene *a2)
{
  OZSceneNode::willRemoveFromScene((uint64_t)this, (uint64_t)a2);
  OZSystemSimulator::willRemoveFromScene((PSParticleType *)((char *)this + 15520), a2);

  return OZSystemSimulator::willRemoveFromScene((PSParticleType *)((char *)this + 16080), a2);
}

void *PSParticleType::simGetForceBehaviors(uint64_t a1, uint64_t *a2, long long *a3)
{
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 640))(a1);
  std::list<OZSimulationBehavior *>::list(&v22, v5 + 224);
  for (uint64_t i = v23; i != &v22; uint64_t i = (uint64_t *)i[1])
  {
    __n128 v7 = (const void *)i[2];
    if (!v7
    {
      long long v20 = *a3;
      uint64_t v21 = *((void *)a3 + 2);
      if ((*(uint64_t (**)(const void *, long long *, void, uint64_t, uint64_t))(*(void *)v7 + 296))(v7, &v20, 0, 1, 1))
      {
        CMTimeEpoch v8 = operator new(0x18uLL);
        v8[1] = a2;
        v8[2] = v7;
        uint64_t v9 = *a2;
        *CMTimeEpoch v8 = *a2;
        *(void *)(v9 + 8) = v8;
        *a2 = (uint64_t)v8;
        ++a2[2];
      }
    }
  }
  for (uint64_t j = *(void *)(v5 + 48); j; uint64_t j = *(void *)(j + 48))
  {
    if ((*(unsigned char *)(j + 57) & 0x20) != 0)
    {
      if (v11)
      {
        std::list<OZSimulationBehavior *>::list(v19, (uint64_t)v11 + 224);
        for (uint64_t k = (void *)v19[1]; k != v19; uint64_t k = (void *)k[1])
        {
          BOOL v13 = (const void *)k[2];
          if (((*(uint64_t (**)(const void *))(*(void *)v13 + 656))(v13) & 1) == 0
          {
            long long v17 = *a3;
            uint64_t v18 = *((void *)a3 + 2);
            if ((*(uint64_t (**)(const void *, long long *, void, uint64_t, uint64_t))(*(void *)v13 + 296))(v13, &v17, 0, 1, 1))
            {
              char v14 = operator new(0x18uLL);
              v14[1] = a2;
              void v14[2] = v13;
              uint64_t v15 = *a2;
              void *v14 = *a2;
              *(void *)(v15 + 8) = v14;
              *a2 = (uint64_t)v14;
              ++a2[2];
            }
          }
        }
        std::__list_imp<unsigned int>::clear(v19);
      }
    }
  }
  return std::__list_imp<unsigned int>::clear(&v22);
}

void sub_1B7DDB488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::__list_imp<unsigned int>::clear((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *non-virtual thunk to'PSParticleType::simGetForceBehaviors(uint64_t a1, uint64_t *a2, long long *a3)
{
  return PSParticleType::simGetForceBehaviors(a1 - 1112, a2, a3);
}

void *PSParticleType::simGetCollisionBehaviors(uint64_t a1, uint64_t *a2, long long *a3)
{
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 640))(a1);
  std::list<OZSimulationBehavior *>::list(&v23, v5 + 224);
  for (uint64_t i = v24; i != &v23; uint64_t i = (uint64_t *)i[1])
  {
    __n128 v7 = (const void *)i[2];
    if (v7)
    {
      {
        long long v21 = *a3;
        uint64_t v22 = *((void *)a3 + 2);
        if ((*(uint64_t (**)(const void *, long long *, void, uint64_t, uint64_t))(*(void *)v7 + 296))(v7, &v21, 0, 1, 1))
        {
          CMTimeEpoch v8 = operator new(0x18uLL);
          v8[1] = a2;
          v8[2] = v7;
          uint64_t v9 = *a2;
          *CMTimeEpoch v8 = *a2;
          *(void *)(v9 + 8) = v8;
          *a2 = (uint64_t)v8;
          ++a2[2];
        }
      }
    }
  }
  for (uint64_t j = *(void *)(v5 + 48); j; uint64_t j = *(void *)(j + 48))
  {
    if ((*(unsigned char *)(j + 57) & 0x20) != 0)
    {
      if (v11)
      {
        std::list<OZSimulationBehavior *>::list(v20, (uint64_t)v11 + 224);
        for (uint64_t k = (void *)v20[1]; k != v20; uint64_t k = (void *)k[1])
        {
          BOOL v13 = (uint64_t *)k[2];
          if (v13)
          {
            uint64_t v14 = *v13;
            {
              if (((*(uint64_t (**)(uint64_t *))(v14 + 656))(v13) & 1) == 0)
              {
                long long v18 = *a3;
                uint64_t v19 = *((void *)a3 + 2);
                if ((*(uint64_t (**)(uint64_t *, long long *, void, uint64_t, uint64_t))(*v13 + 296))(v13, &v18, 0, 1, 1))
                {
                  uint64_t v15 = operator new(0x18uLL);
                  v15[1] = a2;
                  v15[2] = v13;
                  uint64_t v16 = *a2;
                  void *v15 = *a2;
                  *(void *)(v16 + 8) = v15;
                  *a2 = (uint64_t)v15;
                  ++a2[2];
                }
              }
            }
          }
        }
        std::__list_imp<unsigned int>::clear(v20);
      }
    }
  }
  return std::__list_imp<unsigned int>::clear(&v23);
}

void sub_1B7DDB7C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::__list_imp<unsigned int>::clear((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *non-virtual thunk to'PSParticleType::simGetCollisionBehaviors(uint64_t a1, uint64_t *a2, long long *a3)
{
  return PSParticleType::simGetCollisionBehaviors(a1 - 1112, a2, a3);
}

uint64_t PSParticleType::simAnyCollisionBehaviors(PSParticleType *this)
{
  uint64_t v1 = (*(uint64_t (**)(PSParticleType *))(*(void *)this + 640))(this);
  std::list<OZSimulationBehavior *>::list(&v10, v1 + 224);
  for (uint64_t i = v11; i != &v10; uint64_t i = (uint64_t *)i[1])
  {
    double v3 = (void *)i[2];
    if ((*(uint64_t (**)(void))(v3[2] + 24))())
    {
      {
        goto LABEL_18;
      }
    }
  }
  uint64_t v4 = *(void *)(v1 + 48);
  if (v4)
  {
    while (1)
    {
      if ((*(unsigned char *)(v4 + 57) & 0x20) != 0)
      {
        if (v5) {
          break;
        }
      }
LABEL_15:
      uint64_t v4 = *(void *)(v4 + 48);
      if (!v4) {
        goto LABEL_19;
      }
    }
    std::list<OZSimulationBehavior *>::list(v9, (uint64_t)v5 + 224);
    for (uint64_t j = (void *)v9[1]; ; uint64_t j = (void *)j[1])
    {
      if (j == v9)
      {
        std::__list_imp<unsigned int>::clear(v9);
        goto LABEL_15;
      }
      __n128 v7 = (void *)j[2];
      if (((*(uint64_t (**)(void *))(*v7 + 656))(v7) & 1) == 0 {
        && (*(unsigned int (**)(void *, void, uint64_t))(v7[2] + 24))(v7 + 2, 0, 1)
      }
      {
        break;
      }
    }
    std::__list_imp<unsigned int>::clear(v9);
LABEL_18:
    uint64_t v4 = 1;
  }
LABEL_19:
  std::__list_imp<unsigned int>::clear(&v10);
  return v4;
}

void sub_1B7DDBA78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__list_imp<unsigned int>::clear((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'PSParticleType::simAnyCollisionBehaviors(PSParticleType *this)
{
  return PSParticleType::simAnyCollisionBehaviors((PSParticleType *)((char *)this - 1112));
}

void *PSParticleType::simGetAllBehaviors(uint64_t a1, void *a2)
{
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 640))(a1);
  std::list<OZSimulationBehavior *>::list(&v17, v3 + 224);
  uint64_t v4 = v18;
  if (v18 != &v17)
  {
    uint64_t v5 = (void *)*a2;
    uint64_t v6 = a2[2] + 1;
    do
    {
      __n128 v7 = operator new(0x18uLL);
      uint64_t v8 = v4[2];
      v7[1] = a2;
      v7[2] = v8;
      *__n128 v7 = v5;
      v5[1] = v7;
      *a2 = v7;
      a2[2] = v6;
      uint64_t v4 = (uint64_t *)v4[1];
      ++v6;
      uint64_t v5 = v7;
    }
    while (v4 != &v17);
  }
  for (uint64_t i = *(void *)(v3 + 48); i; uint64_t i = *(void *)(i + 48))
  {
    if ((*(unsigned char *)(i + 57) & 0x20) != 0)
    {
      if (v10)
      {
        std::list<OZSimulationBehavior *>::list(v16, (uint64_t)v10 + 224);
        for (uint64_t j = (void *)v16[1]; j != v16; uint64_t j = (void *)j[1])
        {
          uint64_t v12 = j[2];
          if (((*(uint64_t (**)(uint64_t))(*(void *)v12 + 656))(v12) & 1) == 0)
          {
            BOOL v13 = operator new(0x18uLL);
            v13[1] = a2;
            v13[2] = v12;
            uint64_t v14 = (void *)*a2;
            *BOOL v13 = *a2;
            v14[1] = v13;
            *a2 = v13;
            ++a2[2];
          }
        }
        std::__list_imp<unsigned int>::clear(v16);
      }
    }
  }
  return std::__list_imp<unsigned int>::clear(&v17);
}

void sub_1B7DDBC70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__list_imp<unsigned int>::clear((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *non-virtual thunk to'PSParticleType::simGetAllBehaviors(uint64_t a1, void *a2)
{
  return PSParticleType::simGetAllBehaviors(a1 - 1112, a2);
}

uint64_t PSParticleType::simAnythingToSimulate(PSParticleType *this)
{
  return 1;
}

uint64_t non-virtual thunk to'PSParticleType::simAnythingToSimulate(PSParticleType *this)
{
  return 1;
}

uint64_t PSParticleType::areAnyLinkBehaviorsSourcingObjectsInSet(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == a2) {
    return 0;
  }
  uint64_t v5 = (void *)(a3 + 8);
  while (1)
  {
    uint64_t v6 = *(const void **)(v3 + 16);
    if (v6)
    {
      if (v7)
      {
        uint64_t Object = OZChanObjectManipRef::getObject((OZChannelBase *)(v7 + 1064));
        if (Object)
        {
          uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)Object + 256))(Object);
          unsigned int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 56))(v9);
          uint64_t v11 = *v5;
          if (*v5)
          {
            uint64_t v12 = v5;
            do
            {
              unsigned int v13 = *(_DWORD *)(v11 + 28);
              BOOL v14 = v13 >= v10;
              if (v13 >= v10) {
                uint64_t v15 = (uint64_t *)v11;
              }
              else {
                uint64_t v15 = (uint64_t *)(v11 + 8);
              }
              if (v14) {
                uint64_t v12 = (void *)v11;
              }
              uint64_t v11 = *v15;
            }
            while (*v15);
            if (v12 != v5 && v10 >= *((_DWORD *)v12 + 7)) {
              break;
            }
          }
        }
      }
    }
    uint64_t v3 = *(void *)(v3 + 8);
    if (v3 == a2) {
      return 0;
    }
  }
  return 1;
}

uint64_t PSParticleType::simDoesDependOnSceneNodes(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (const void *)a1;
  if (!a1)
  {
LABEL_18:
    uint64_t v12 = (*(uint64_t (**)(const void *))(*(void *)v3 + 640))(v3);
    std::list<OZSimulationBehavior *>::list(&v43, v12 + 224);
    BOOL v14 = v44;
    if (v44 == &v43)
    {
LABEL_37:
      uint64_t v25 = *(void *)(v12 + 48);
      if (!v25)
      {
LABEL_72:
        std::__list_imp<unsigned int>::clear(&v43);
        return v25;
      }
      PCSharedCount v26 = (uint64_t *)(a2 + 8);
      while (1)
      {
        if ((*(unsigned char *)(v25 + 57) & 0x20) != 0)
        {
          if (v27) {
            break;
          }
        }
LABEL_67:
        uint64_t v25 = *(void *)(v25 + 48);
        if (!v25) {
          goto LABEL_72;
        }
      }
      long long v28 = v27;
      uint64_t v29 = (const void *)(*(uint64_t (**)(void *))(*(void *)v27 + 840))(v27);
      if (v29) {
      else
      }
        long long v30 = 0;
      std::list<OZSimulationBehavior *>::list(v42, (uint64_t)v28 + 224);
      for (uint64_t i = (void *)v42[1]; ; uint64_t i = (void *)i[1])
      {
        if (i == v42)
        {
          std::__list_imp<unsigned int>::clear(v42);
          goto LABEL_67;
        }
        uint64_t v32 = (OZBehavior *)i[2];
        if (OZBehavior::isEnabledAndUseBehaviors(v32)
          && ((*(uint64_t (**)(OZBehavior *))(*(void *)v32 + 656))(v32) & 1) == 0)
        {
          uint64_t v33 = (*(uint64_t (**)(OZBehavior *))(*(void *)v32 + 664))(v32);
          if ((void *)v33 != v30 && v33 != 0) {
            break;
          }
        }
LABEL_65:
        ;
      }
      unsigned int v35 = *(_DWORD *)(v33 + 80);
      while (1)
      {
        if (*v26)
        {
          uint64_t v36 = a2 + 8;
          uint64_t v37 = *v26;
          do
          {
            unsigned int v38 = *(_DWORD *)(v37 + 28);
            BOOL v39 = v38 >= v35;
            if (v38 >= v35) {
              CMTime v40 = (uint64_t *)v37;
            }
            else {
              CMTime v40 = (uint64_t *)(v37 + 8);
            }
            if (v39) {
              uint64_t v36 = v37;
            }
            uint64_t v37 = *v40;
          }
          while (*v40);
          if ((uint64_t *)v36 != v26 && v35 >= *(_DWORD *)(v36 + 28)) {
            break;
          }
        }
        uint64_t v33 = *(void *)(v33 + 960);
        if (!v33) {
          goto LABEL_65;
        }
      }
      std::__list_imp<unsigned int>::clear(v42);
    }
    else
    {
      uint64_t v15 = (uint64_t *)(a2 + 8);
      while (1)
      {
        uint64_t v16 = (OZBehavior *)v14[2];
        if (OZBehavior::isEnabledAndUseBehaviors(v16))
        {
          uint64_t v17 = (*(uint64_t (**)(OZBehavior *))(*(void *)v16 + 664))(v16);
          if ((void *)v17 != v13 && v17 != 0)
          {
            uint64_t v19 = *v15;
            if (*v15)
            {
              unsigned int v20 = *(_DWORD *)(v17 + 80);
              uint64_t v21 = a2 + 8;
              do
              {
                unsigned int v22 = *(_DWORD *)(v19 + 28);
                BOOL v23 = v22 >= v20;
                if (v22 >= v20) {
                  long long v24 = (uint64_t *)v19;
                }
                else {
                  long long v24 = (uint64_t *)(v19 + 8);
                }
                if (v23) {
                  uint64_t v21 = v19;
                }
                uint64_t v19 = *v24;
              }
              while (*v24);
              if ((uint64_t *)v21 != v15 && v20 >= *(_DWORD *)(v21 + 28)) {
                break;
              }
            }
          }
        }
        BOOL v14 = (uint64_t *)v14[1];
        if (v14 == &v43) {
          goto LABEL_37;
        }
      }
    }
    uint64_t v25 = 1;
    goto LABEL_72;
  }
  uint64_t v4 = a1;
  while (1)
  {
    if (*(void *)(a2 + 8))
    {
      unsigned int v5 = *(_DWORD *)(v4 + 80);
      uint64_t v6 = a2 + 8;
      uint64_t v7 = *(void *)(a2 + 8);
      do
      {
        unsigned int v8 = *(_DWORD *)(v7 + 28);
        BOOL v9 = v8 >= v5;
        if (v8 >= v5) {
          unsigned int v10 = (uint64_t *)v7;
        }
        else {
          unsigned int v10 = (uint64_t *)(v7 + 8);
        }
        if (v9) {
          uint64_t v6 = v7;
        }
        uint64_t v7 = *v10;
      }
      while (*v10);
      if (v6 != a2 + 8 && v5 >= *(_DWORD *)(v6 + 28)) {
        return 1;
      }
    }
    uint64_t v4 = *(void *)(v4 + 960);
    if (!v4)
    {
      uint64_t v11 = a1;
      while (1)
      {
        a1 = PSParticleType::areAnyLinkBehaviorsSourcingObjectsInSet(a1, v11 + 1000, a2);
        if (a1) {
          return 1;
        }
        uint64_t v11 = *(void *)(v11 + 960);
        if (!v11) {
          goto LABEL_18;
        }
      }
    }
  }
}

void sub_1B7DDC1F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__list_imp<unsigned int>::clear((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'PSParticleType::simDoesDependOnSceneNodes(uint64_t a1, uint64_t a2)
{
  return PSParticleType::simDoesDependOnSceneNodes(a1 - 1112, a2);
}

uint64_t PSParticleType::simGetTransformNode(PSParticleType *this)
{
  uint64_t v1 = *((void *)this + 2054);
  if (v1) {
    return v1 + 200;
  }
  else {
    return 0;
  }
}

uint64_t non-virtual thunk to'PSParticleType::simGetTransformNode(PSParticleType *this)
{
  uint64_t v1 = *((void *)this + 1915);
  if (v1) {
    return v1 + 200;
  }
  else {
    return 0;
  }
}

void PSParticleType::simGetTransformMatrix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  OZRenderState::OZRenderState(&v9);
  *(_OWORD *)&v9.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)a4;
  v9.var0.int64_t var3 = *(void *)(a4 + 16);
  v9.var8 = 0;
  unsigned int v8 = *(OZChannel **)(a1 + 16432);
  if (a1 + 15800 == a2) {
    PSEmitter::getPreviewTransformMatrix(v8, a3, (CMTime *)&v9);
  }
  else {
    (*((void (**)(OZChannelFolder **, uint64_t, OZRenderState *))v8[1].var6 + 157))(&v8[1].var6, a3, &v9);
  }
}

void non-virtual thunk to'PSParticleType::simGetTransformMatrix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

double PSParticleType::simGetInvTransformMatrix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  OZRenderState::OZRenderState(&v10);
  *(_OWORD *)&v10.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)a4;
  v10.var0.int64_t var3 = *(void *)(a4 + 16);
  v10.var8 = 0;
  unsigned int v8 = *(OZChannel **)(a1 + 16432);
  if (a1 + 15800 == a2) {
    return PSEmitter::getInvPreviewTransformMatrix(v8, a3, (CMTime *)&v10);
  }
  (*((void (**)(OZChannelFolder **, uint64_t, OZRenderState *))v8[1].var6 + 158))(&v8[1].var6, a3, &v10);
  return result;
}

double non-virtual thunk to'PSParticleType::simGetInvTransformMatrix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return PSParticleType::simGetInvTransformMatrix(a1 - 1112, a2, a3, a4);
}

double PSParticleType::simGetScenePixelAspectRatio(PSParticleType *this)
{
  return *(double *)((*(uint64_t (**)(PSParticleType *))(*(void *)this + 272))(this) + 384);
}

double non-virtual thunk to'PSParticleType::simGetScenePixelAspectRatio(PSParticleType *this)
{
  return *(double *)((*(uint64_t (**)(char *))(*((void *)this - 139) + 272))((char *)this - 1112) + 384);
}

double PSParticleType::simGetSceneFrameDuration@<D0>(PSParticleType *this@<X0>, __n128 *a2@<X8>)
{
  uint64_t v3 = (OZSceneSettings *)((*(uint64_t (**)(PSParticleType *))(*(void *)this + 272))(this) + 336);

  *(void *)&double result = OZSceneSettings::getFrameDuration(v3, a2).n128_u64[0];
  return result;
}

double non-virtual thunk to'PSParticleType::simGetSceneFrameDuration@<D0>(PSParticleType *this@<X0>, __n128 *a2@<X8>)
{
  uint64_t v3 = (OZSceneSettings *)((*(uint64_t (**)(char *))(*((void *)this - 139) + 272))((char *)this - 1112)
                         + 336);

  *(void *)&double result = OZSceneSettings::getFrameDuration(v3, a2).n128_u64[0];
  return result;
}

double PSParticleType::simGetFirstFrame@<D0>(PSParticleType *this@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(long long *__return_ptr))(*(void *)this + 1128))(&v5);
  double result = *(double *)&v5;
  *(_OWORD *)a2 = v5;
  *(void *)(a2 + 16) = v6;
  return result;
}

double non-virtual thunk to'PSParticleType::simGetFirstFrame@<D0>(PSParticleType *this@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(long long *__return_ptr))(*((void *)this - 139) + 1128))(&v5);
  double result = *(double *)&v5;
  *(_OWORD *)a2 = v5;
  *(void *)(a2 + 16) = v6;
  return result;
}

char *PSParticleType::getParticlesForSimStyleType(PSParticleType *this, int a2)
{
  double v2 = (char *)this + 0x4000;
  uint64_t v3 = (char *)this + 16360;
  if (a2) {
    uint64_t v3 = 0;
  }
  if (a2 != 1) {
    double v2 = v3;
  }
  if (a2 == 2) {
    return (char *)this + 16408;
  }
  else {
    return v2;
  }
}

uint64_t PSParticleType::simAddObjects(PSParticleType *this, OZSystemSimulator *a2, OZSimStateArray *a3, double a4)
{
  if ((PSParticleType *)((char *)this + 15800) == a2) {
    unsigned int v6 = 1;
  }
  else {
    unsigned int v6 = 2;
  }
  if ((PSParticleType *)((char *)this + 15520) == a2) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v6;
  }
  CMTime v45 = *(CMTime *)((unsigned char *)a3 + 1);
  memset(&v44, 0, sizeof(v44));
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(*((void *)this + 2054) + 200) + 272))();
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v8 + 336), (__n128 *)&v44);
  double FrameRate = PSEmitter::getFrameRate(*((PSEmitter **)this + 2054));
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(*((void *)this + 2054) + 28408), &v45, 0.0);
  OZChannel::getValueAsDouble((OZChannel *)((char *)this + 1120), &v45, 0.0);
  double v12 = v11;
  PSEmitter::getBirthRateFraction(*((PSEmitter **)this + 2054), &v45);
  double v14 = v13;
  OZChannel::getValueAsDouble((OZChannel *)((char *)this + 1272), &v45, 0.0);
  double v16 = 25.0;
  if (!ValueAsInt) {
    double v16 = FrameRate;
  }
  double v17 = v12 / v16 * v14;
  double v18 = v15 / v16;
  if (v15 / v16 > 0.0)
  {
    CMTime time = v45;
    Float64 Seconds = CMTimeGetSeconds(&time);
    unsigned int v20 = (FrameRate * (Seconds + Seconds));
    unsigned int ValueAsUint = OZChannel::getValueAsUint((OZChannel *)((char *)this + 11600), MEMORY[0x1E4F1FA48], 0.0);
    int v22 = -32;
    int v23 = -1640531527;
    unsigned int v24 = v20;
    do
    {
      v24 += (v20 + 16 * ValueAsUint) ^ (ValueAsUint + v23) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1
                                                             + (ValueAsUint >> 5));
      ValueAsUint += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v24) ^ (v23 + v24) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v24 >> 5));
      v23 -= 1640531527;
    }
    while (!__CFADD__(v22++, 1));
    double v17 = v17 + v18 * ((double)(ValueAsUint ^ v24) / 4294967300.0);
  }
  memset(&v42, 0, sizeof(v42));
  operator*(&v44, &v42, -1.0);
  (*(void (**)(CMTime *__return_ptr, PSParticleType *))(*(void *)this + 1128))(&time1, this);
  CMTime time2 = time1;
  CMTime time1 = v45;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v40);
  CMTime time1 = v40;
  CMTime time2 = v44;
  uint64_t v26 = (uint64_t)&off_1B7E73000;
  if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0) {
    goto LABEL_15;
  }
  uint64_t v29 = (uint64_t *)*((void *)this + 2045);
  if (v29 == *((uint64_t **)this + 2046)) {
    goto LABEL_20;
  }
  uint64_t v30 = *v29;
  CMTime time1 = v45;
  CMTime time2 = v42;
  PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v39);
  long long v31 = *(_OWORD *)(v30 + 8);
  time1.CMTimeEpoch epoch = *(void *)(v30 + 24);
  *(_OWORD *)&time1.value = v31;
  CMTime time2 = v39;
  if (!CMTimeCompare(&time1, &time2))
  {
LABEL_20:
    int v28 = 1;
  }
  else
  {
LABEL_15:
    int v27 = (*(uint64_t (**)(void))(*((void *)this + 139) + 80))();
    int v28 = v27 ^ 1;
    if (fabs(v17) < 0.0000001 && (v27 & 1) != 0) {
      return 0;
    }
  }
  LODWORD(v26) = vcvtmd_s64_f64(v17 + 0.0000001);
  double v32 = v17 - (double)(int)v26;
  if (v32 > 0.0)
  {
    if (*((unsigned char *)this + 16560))
    {
      CMTime v38 = v45;
      double v33 = FrameRate * CMTimeGetSeconds(&v38);
    }
    else
    {
      operator/((long long *)&v45.value, (uint64_t)&v44, (uint64_t)&v37);
      double v33 = CMTimeGetSeconds(&v37);
    }
    if (v32 * v33 - floor(v32 * v33 + 0.0000001) >= v32 * 0.9) {
      uint64_t v26 = v26;
    }
    else {
      uint64_t v26 = (v26 + 1);
    }
  }
  if (v28)
  {
    PSEmitter::getInitialNumFraction(*((PSEmitter **)this + 2054), &v45);
    uint64_t v26 = v26
        + vcvtmd_s64_f64(v34 * (double)(int)OZChannel::getValueAsInt((OZChannel *)((char *)this + 1424), &v45, 0.0) + 0.0000001);
  }
  if ((int)v26 < 1) {
    return 0;
  }
  uint64_t Particles = PSParticleType::findOrCreateParticles(this, v7, v26, a3);
  PSEmitter::initParticles(*((PSEmitter **)this + 2054), v7, this, Particles, 0, a3);
  return Particles;
}

uint64_t PSParticleType::getSeed(PSParticleType *this)
{
  return OZChannel::getValueAsUint((OZChannel *)((char *)this + 11600), MEMORY[0x1E4F1FA48], 0.0);
}

uint64_t PSParticleType::findOrCreateParticles(PSParticleType *this, int a2, uint64_t a3, OZSimStateArray *a4)
{
  uint64_t v7 = (uint64_t **)((char *)this + 0x4000);
  uint64_t v8 = (uint64_t **)((char *)this + 16360);
  if (a2) {
    uint64_t v8 = 0;
  }
  if (a2 != 1) {
    uint64_t v7 = v8;
  }
  if (a2 == 2) {
    OZRenderState v9 = (uint64_t **)((char *)this + 16408);
  }
  else {
    OZRenderState v9 = v7;
  }
  if (!(*(unsigned int (**)(void))(*((void *)this + 139) + 80))()) {
    OZRenderState v9 = 0;
  }
  CMTime v29 = *(CMTime *)((unsigned char *)a4 + 1);
  __n128 v27 = 0uLL;
  uint64_t v10 = *(void *)(*((void *)this + 2054) + 200);
  CMTimeEpoch v28 = 0;
  uint64_t v11 = (*(uint64_t (**)(void))(v10 + 272))();
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v11 + 336), &v27);
  if (v9) {
    unint64_t v12 = (unint64_t)((char *)v9[1] - (char *)*v9) >> 3;
  }
  else {
    LODWORD(v12) = 0;
  }
  int v13 = -1108378657 * ((*((void *)a4 + 1) - *(void *)a4) >> 3);
  std::vector<OZSimStateElement>::resize((uint64_t *)a4, (v13 + a3));
  if (!v12) {
    goto LABEL_19;
  }
  uint64_t v14 = (*v9)[(v12 - 1)];
  CMTime time1 = v29;
  *(__n128 *)&time2.value = v27;
  time2.CMTimeEpoch epoch = v28;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v26);
  long long v15 = *(_OWORD *)(v14 + 8);
  time1.CMTimeEpoch epoch = *(void *)(v14 + 24);
  *(_OWORD *)&time1.value = v15;
  CMTime time2 = v26;
  if (CMTimeCompare(&time1, &time2) < 0)
  {
LABEL_19:
    PSParticleType::createParticles((uint64_t)this, v9, a3, (uint64_t *)a4);
  }
  else
  {
    double v17 = *v9;
    double v16 = v9[1];
    while (1)
    {
      if (v17 == v16) {
        goto LABEL_28;
      }
      uint64_t v18 = *v17;
      CMTime time1 = v29;
      *(__n128 *)&time2.value = v27;
      time2.CMTimeEpoch epoch = v28;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v26);
      long long v19 = *(_OWORD *)(v18 + 8);
      time1.CMTimeEpoch epoch = *(void *)(v18 + 24);
      *(_OWORD *)&time1.value = v19;
      CMTime time2 = v26;
      int32_t v20 = CMTimeCompare(&time1, &time2);
      double v16 = v9[1];
      if ((v20 & 0x80000000) == 0) {
        break;
      }
      ++v17;
    }
    if (v17 == v16)
    {
LABEL_28:
      uint64_t v21 = 0;
      goto LABEL_29;
    }
    uint64_t v21 = 0;
    do
    {
      long long v22 = *(_OWORD *)(*v17 + 8);
      time1.CMTimeEpoch epoch = *(void *)(*v17 + 24);
      *(_OWORD *)&time1.value = v22;
      CMTime time2 = v29;
      if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
      {
        long long v23 = *(_OWORD *)(*v17 + 8);
        time1.CMTimeEpoch epoch = *(void *)(*v17 + 24);
        *(_OWORD *)&time1.value = v23;
        CMTime time2 = v29;
        if (CMTimeCompare(&time1, &time2) > 0
          || ((*(uint64_t (**)(PSParticleType *))(*(void *)this + 1488))(this) & 1) != 0)
        {
          break;
        }
      }
      if (v21 >= a3) {
        break;
      }
      uint64_t v24 = *v17++;
      *(void *)(*(void *)a4 + 248 * (v13 + v21) + 232) = v24;
      uint64_t v21 = (v21 + 1);
    }
    while (v17 != v9[1]);
LABEL_29:
    if (v21 != a3)
    {
      std::vector<OZSimStateElement>::resize((uint64_t *)a4, 0xEF7BDEF7BDEF7BDFLL * ((uint64_t)(*((void *)a4 + 1) - *(void *)a4) >> 3) + (int)v21 - (int)a3);
      return v21;
    }
  }
  return a3;
}

uint64_t non-virtual thunk to'PSParticleType::simAddObjects(PSParticleType *this, OZSystemSimulator *a2, OZSimStateArray *a3, double a4)
{
  return PSParticleType::simAddObjects((PSParticleType *)((char *)this - 1112), a2, a3, a4);
}

void PSParticleType::createParticles(uint64_t a1, void *a2, unsigned int a3, uint64_t *a4)
{
  long long v26 = *(_OWORD *)(a4 + 3);
  uint64_t v27 = a4[5];
  uint64_t v9 = *a4;
  uint64_t v8 = a4[1];
  if (a2)
  {
    uint64_t v10 = (uint64_t)(a2[1] - *a2) >> 3;
    std::vector<TXParagraphStyle *>::resize((uint64_t)a2, v10 + a3);
  }
  else
  {
    uint64_t v10 = 0;
  }
  double v11 = 1.0 / (double)a3;
  memset(&v25, 0, sizeof(v25));
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 272))(a1);
  __n128 FrameDuration = OZSceneSettings::getFrameDuration((OZSceneSettings *)(v12 + 336), (__n128 *)&v25);
  int v14 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)a1 + 1488))(a1, FrameDuration);
  if (!v14) {
    double v11 = 0.0;
  }
  if (a3)
  {
    int v15 = -1108378657 * ((unint64_t)(v8 - v9) >> 3);
    if (v14) {
      double v16 = 0.0;
    }
    else {
      double v16 = 1.0;
    }
    int v17 = -a3;
    do
    {
      uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, long long *))(*(void *)a1 + 1480))(a1, v10, &v26);
      uint64_t v19 = v18;
      if (a2) {
        *(void *)(*a2 + 8 * v10) = v18;
      }
      operator*(&v25, &v24, 1.0 - v16);
      long long v20 = *(_OWORD *)(v19 + 8);
      v29.CMTimeEpoch epoch = *(void *)(v19 + 24);
      *(_OWORD *)&v29.value = v20;
      CMTime v28 = v24;
      PC_CMTimeSaferSubtract(&v29, &v28, (uint64_t)&v30);
      long long v21 = v30;
      *(void *)(v19 + 24) = v31;
      *(_OWORD *)(v19 + 8) = v21;
      uint64_t v22 = *a4 + 248 * (v15 + v17);
      *(void *)(v22 + 232) = v19;
      *(unsigned char *)(v22 + 240) = a2 == 0;
      uint64_t v10 = (v10 + 1);
      double v16 = v11 + v16;
    }
    while (!__CFADD__(v17++, 1));
  }
}

void PSParticleType::simFlushedCache(PSParticleType *this, OZSystemSimulator *a2)
{
  uint64_t v4 = (PSParticleType *)((char *)this + 15520);
  long long v5 = (char *)this + 16408;
  if ((PSParticleType *)((char *)this + 15800) == a2) {
    long long v5 = (char *)this + 0x4000;
  }
  if (v4 == a2) {
    unsigned int v6 = (char *)this + 16360;
  }
  else {
    unsigned int v6 = v5;
  }
  uint64_t v7 = *(void **)v6;
  if (*(void *)v6 != *((void *)v6 + 1))
  {
    do
    {
      if (*v7) {
        (*(void (**)(void))(*(void *)*v7 + 8))(*v7);
      }
      *v7++ = 0;
    }
    while (v7 != *((void **)v6 + 1));
    uint64_t v7 = *(void **)v6;
  }
  *((void *)v6 + 1) = v7;
  (*(void (**)(PSParticleType *))(*(void *)this + 1640))(this);
  if (v4 == a2)
  {
    *((unsigned char *)this + 15464) = 1;
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 15472, *((void **)this + 1935));
    *((void *)this + 1934) = (char *)this + 15480;
    *((void *)this + 1936) = 0;
    *((void *)this + 1935) = 0;
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 15496, *((void **)this + 1938));
    *((void *)this + 1937) = (char *)this + 15504;
    *((void *)this + 1939) = 0;
    *((void *)this + 1938) = 0;
  }
}

void non-virtual thunk to'PSParticleType::simFlushedCache(PSParticleType *this, OZSystemSimulator *a2)
{
}

void *PSParticleType::setEmitter(void *this, PSEmitter *a2)
{
  this[2054] = a2;
  if (this[127])
  {
    this = *(void **)(this[125] + 16);
    if (this)
    {
      if (this)
      {
        if (a2) {
          uint64_t v3 = (OZTransformNode *)((char *)a2 + 200);
        }
        else {
          uint64_t v3 = 0;
        }
        return (void *)OZSimSystemMoToFoBehavior::updateTransformNode((OZSimSystemMoToFoBehavior *)this, v3);
      }
    }
  }
  return this;
}

void PSParticleType::createParticle(PSParticleType *this, unsigned int a2, const CMTime *a3)
{
}

void sub_1B7DDD2C0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40AE952B93);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::getPreviewSceneNode(PSParticleType *this)
{
  uint64_t v1 = theApp;
  long long v6 = xmmword_1B8384170;
  PCURL::PCURL((PCURL *)&v5, @"Emitter Preview Emitter Name");
  OZChannelBase::getNextUniqueID(v2);
  uint64_t SceneNode = OZApplication::createSceneNode(v1, (unsigned int *)&v6);
  PCString::~PCString(&v5);
  return SceneNode;
}

void sub_1B7DDD360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

OZChannelBase *PSParticleType::getChannelFromRefAndVersion(PSParticleType *this, OZChannelRef *a2, double a3)
{
  ChannelFromRefAndVersion = OZObjectManipulator::getChannelFromRefAndVersion((PSParticleType *)((char *)this + 16), a2, a3);
  if (ChannelFromRefAndVersion == (OZChannelBase *)((char *)this + 15312)) {
    PCString v5 = (OZChannelBase *)((char *)this + 4648);
  }
  else {
    PCString v5 = ChannelFromRefAndVersion;
  }
  if (ChannelFromRefAndVersion == (OZChannelBase *)((char *)this + 15160)) {
    long long v6 = (OZChannelBase *)((char *)this + 3632);
  }
  else {
    long long v6 = v5;
  }
  if (ChannelFromRefAndVersion == (OZChannelBase *)((char *)this + 15008)) {
    return (OZChannelBase *)((char *)this + 2776);
  }
  else {
    return v6;
  }
}

OZChannelBase *non-virtual thunk to'PSParticleType::getChannelFromRefAndVersion(PSParticleType *this, OZChannelRef *a2, double a3)
{
  ChannelFromRefAndVersion = OZObjectManipulator::getChannelFromRefAndVersion(this, a2, a3);
  if (ChannelFromRefAndVersion == (OZChannelBase *)((char *)this + 15296)) {
    PCString v5 = (OZChannelBase *)((char *)this + 4632);
  }
  else {
    PCString v5 = ChannelFromRefAndVersion;
  }
  if (ChannelFromRefAndVersion == (OZChannelBase *)((char *)this + 15144)) {
    long long v6 = (OZChannelBase *)((char *)this + 3616);
  }
  else {
    long long v6 = v5;
  }
  if (ChannelFromRefAndVersion == (OZChannelBase *)((char *)this + 14992)) {
    return (OZChannelBase *)((char *)this + 2760);
  }
  else {
    return v6;
  }
}

uint64_t PSParticleType::updateReferenceIDs(uint64_t a1, void *a2)
{
  OZSceneNode::updateReferenceIDs(a1, a2);
  uint64_t v3 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 1640);

  return v3(a1);
}

uint64_t non-virtual thunk to'PSParticleType::updateReferenceIDs(uint64_t a1, void *a2)
{
  uint64_t v3 = a1 - 16;
  OZSceneNode::updateReferenceIDs(a1 - 16, a2);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)(a1 - 16) + 1640);

  return v4(v3);
}

void *PSParticleType::calcStaticHash(uint64_t a1, void *a2, uint64_t **a3, int a4)
{
  OZSceneNode::calcStaticHash(a1, a2, a3, a4);

  return OZSystemSimulator::calcStaticHash(a1 + 15520, a2, a3, a1);
}

void *PSParticleType::calcHashForState(uint64_t a1, void *a2, CMTime *a3, uint64_t **a4, int a5)
{
  OZSceneNode::calcHashForState(a1, a2, a3, a4, a5);

  return OZSystemSimulator::calcHashForState(a1 + 15520, a2, (OZRenderParams *)a3, a4, a1);
}

void PSParticleType::allowDrag(PSParticleType *this, OZFactoryBase *lpsrc, OZChannelBase *a3, unsigned int a4, unsigned int *a5, unsigned int *a6, int a7)
{
  if (!lpsrc
  {
    if (a7 != 1) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  if (!*((void *)this + 2054)
    || (OZChannelBase *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 640))(this) != a3)
  {
LABEL_10:
    unint64_t v16 = *((void *)lpsrc + 1);
    long long v17 = xmmword_1B8378BB0;
    if (OZFactory::isKindOfClass(v16, (int32x4_t *)&v17)
      && (OZChannelBase *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 640))(this) == a3)
    {
      *a5 = a4 & 1;
      *a6 = 1;
      return;
    }
LABEL_12:
    OZSceneNode::allowDrag(this, lpsrc, a3, a4, a5, a6, a7);
    return;
  }
  int v15 = *(void (**)(void))(**((void **)this + 2054) + 392);

  v15();
}

void non-virtual thunk to'PSParticleType::allowDrag(PSParticleType *this, OZFactoryBase *a2, OZChannelBase *a3, unsigned int a4, unsigned int *a5, unsigned int *a6, int a7)
{
}

void PSParticleType::prepareForDragOperation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B7DDD7F4()
{
  return 0;
}

void non-virtual thunk to'PSParticleType::prepareForDragOperation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B7DDD840()
{
  return 0;
}

uint64_t PSParticleType::performDragOperation(PSParticleType *this, OZFactoryBase *lpsrc, OZChannelBase *a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, const CMTime *a8)
{
  if (a6 != 1) {
    return OZSceneNode::performDragOperation(this, lpsrc, a3, a4, a5, a6, a7, a8);
  }
  if (lpsrc)
  {
    uint64_t v16 = *((void *)this + 2054);
    if (v16)
    {
      {
        {
          long long v17 = *(uint64_t (**)(uint64_t, OZFactoryBase *, OZChannelBase *, uint64_t, uint64_t, uint64_t, uint64_t, const CMTime *))(*(void *)v16 + 408);
          return v17(v16, lpsrc, a3, a4, a5, 1, a7, a8);
        }
        return OZSceneNode::performDragOperation(this, lpsrc, a3, a4, a5, a6, a7, a8);
      }
    }
  }
  unint64_t v19 = *((void *)lpsrc + 1);
  *(_OWORD *)&v25.value = xmmword_1B8378BB0;
  if (!OZFactory::isKindOfClass(v19, (int32x4_t *)&v25)) {
    return OZSceneNode::performDragOperation(this, lpsrc, a3, a4, a5, a6, a7, a8);
  }
  if ((OZChannelBase *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 640))(this) != a3)
  {
    uint64_t v20 = *((void *)this + 2054);
    if (!v20 || (OZChannelBase *)(*(uint64_t (**)(void))(*(void *)(v20 + 200) + 640))() != a3) {
      return OZSceneNode::performDragOperation(this, lpsrc, a3, a4, a5, a6, a7, a8);
    }
  }
  PCSharedCount::PCSharedCount((PCSharedCount *)&v25);
  OZChannelBase::addToUndo((OZChannelBase *)((char *)this + 6784), (const PCString *)&v25);
  PCString::~PCString((PCString *)&v25);
  if ((a7 & 2) != 0)
  {
    long long v23 = (OZScene *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 272))(this);
    OZScene::getCurrentTime(v23, (__n128 *)&v25);
    OZChannelFolder::copyKeyframesFromChannel((OZChannelFolder *)((char *)this + 6784), &v25, v21);
  }
  else
  {
    OZChannelFolder::operator=((uint64_t)this + 6784);
    OZChannelFolder::operator=((uint64_t)this + 6912);
    OZChannelFolder::operator=((uint64_t)this + 7040);
    OZChannelBase::operator=((uint64_t)this + 7168, (uint64_t)&v21[3].var6);
    OZChannelBase::operator=((uint64_t)this + 7320, (uint64_t)&v21[4].var11);
    int var1 = (int)v21[7].var1;
    *((unsigned char *)this + 7580) = BYTE4(v21[7].var1);
    *((_DWORD *)this + 1894) = var1;
  }
  (*(void (**)(PSParticleType *, void))(*(void *)this + 1528))(this, 0);
  (*(void (**)(PSParticleType *))(*(void *)this + 496))(this);
  uint64_t v24 = (*(uint64_t (**)(PSParticleType *))(*(void *)this + 272))(this);
  OZDocument::postNotification(*(OZDocument **)(v24 + 1584), 8);
  return 1;
}

void sub_1B7DDDC34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCString a9)
{
}

uint64_t non-virtual thunk to'PSParticleType::performDragOperation(PSParticleType *this, OZFactoryBase *a2, OZChannelBase *a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, const CMTime *a8)
{
  return PSParticleType::performDragOperation((PSParticleType *)((char *)this - 16), a2, a3, a4, a5, a6, a7, a8);
}

void PSParticleType::getAttachToEmitter(PSParticleType *this, const CMTime *a2)
{
}

uint64_t PSParticleType::writeBody(PSParticleType *this, PCSerializerWriteStream *a2, uint64_t a3, int a4, uint64_t a5)
{
  int v10 = *((_DWORD *)this + 20);
  double v11 = (OZChannelBase *)((char *)this + 11600);
  if (v10 != OZChannel::getValueAsInt((OZChannel *)((char *)this + 11600), MEMORY[0x1E4F1FA48], 0.0)) {
    OZChannelBase::setFlag(v11, 0x100000000, 1);
  }

  return OZSceneNode::writeBody((unsigned int **)this, a2, a3, a4, a5);
}

uint64_t non-virtual thunk to'PSParticleType::writeBody(PSParticleType *this, PCSerializerWriteStream *a2, uint64_t a3, int a4, uint64_t a5)
{
  return PSParticleType::writeBody((PSParticleType *)((char *)this - 48), a2, a3, a4, a5);
}

uint64_t PSParticleType::parseBegin(PSParticleType *this, PCSerializerReadStream *a2)
{
  if (*((_DWORD *)a2 + 26) <= 4u) {
    OZChannel::setValue((OZChannel *)((char *)this + 14552), MEMORY[0x1E4F1FA48], 1.0, 0);
  }
  OZChannel::setKeyframable((OZChannel *)((char *)this + 11600), 1);

  return OZSceneNode::parseBegin(this, a2);
}

uint64_t non-virtual thunk to'PSParticleType::parseBegin(PSParticleType *this, PCSerializerReadStream *a2)
{
  return PSParticleType::parseBegin((PSParticleType *)((char *)this - 48), a2);
}

uint64_t PSParticleType::parseEnd(PSParticleType *this, PCSerializerReadStream *a2)
{
  uint64_t v4 = (BOOL *)this + 16544;
  (*(void (**)(PSParticleType *, uint64_t))(*(void *)this + 1528))(this, 1);
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 14552), MEMORY[0x1E4F1FA48], 0.0);
  *uint64_t v4 = ValueAsInt != 0;
  if (!ValueAsInt) {
    OZChannel::setKeyframable((OZChannel *)((char *)this + 11600), 0);
  }
  unsigned int v6 = *((_DWORD *)a2 + 26);
  OZChannel::setValue((OZChannel *)((char *)this + 14704), MEMORY[0x1E4F1FA48], (double)v6, 0);
  if (v6 > 2)
  {
    if (v6 == 5 && *((_DWORD *)a2 + 27) <= 6u) {
      OZChannel::setValue((OZChannel *)((char *)this + 14856), MEMORY[0x1E4F1FA48], 1.0, 0);
    }
  }
  else
  {
    OZChannelBase::operator=((uint64_t)this + 2776, (uint64_t)this + 15008);
    OZChannelBase::operator=((uint64_t)this + 3632, (uint64_t)this + 15160);
    OZChannelBase::operator=((uint64_t)this + 4648, (uint64_t)this + 15312);
  }
  v4[16] = OZChannel::getValueAsInt((OZChannel *)((char *)this + 14856), MEMORY[0x1E4F1FA48], 0.0) != 0;
  OZChannelFolder::setFoldFlag((OZChannelFolder *)((char *)this + 11904), 0x800000);
  OZChannelBase::setFlag((OZChannelBase *)this + 134, 2, 1);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)this + 134);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 15160), 2, 1);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 15160));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 15312), 2, 1);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 15312));
  OZChannelBase::resetFlag((OZChannelBase *)this + 134, 16, 1);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)this + 134);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 15160), 16, 1);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 15160));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 15312), 16, 1);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 15312));

  return OZSceneNode::parseEnd(this, a2);
}

uint64_t non-virtual thunk to'PSParticleType::parseEnd(PSParticleType *this, PCSerializerReadStream *a2)
{
  return PSParticleType::parseEnd((PSParticleType *)((char *)this - 48), a2);
}

void PSParticleType::updateGradientStringName(PSParticleType *this, char a2)
{
  if ((a2 & 1) == 0)
  {
    if ((*(uint64_t (**)(PSParticleType *))(*(void *)this + 272))(this))
    {
      uint64_t v4 = *(void *)((*(uint64_t (**)(PSParticleType *))(*(void *)this + 272))(this) + 1584);
      if (v4)
      {
        PCString v5 = *(OZNotificationManager **)(v4 + 168);
        if (!v5 || !OZNotificationManager::wasChannelModified(v5, (const OZChannelBase *)((char *)this + 6784)))
        {
          PCSharedCount::PCSharedCount(&v6);
          OZChannelBase::addToUndo((OZChannelBase *)((char *)this + 6784), (const PCString *)&v6);
          PCString::~PCString((PCString *)&v6);
        }
      }
    }
  }
  switch(OZChannel::getValueAsInt((OZChannel *)((char *)this + 5368), MEMORY[0x1E4F1FA48], 0.0))
  {
    case 0u:
    case 1u:
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 6912), 2, a2);
      PCURL::PCURL((PCURL *)&v6, @"Emitter Opacity Over Life");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 6784), (const PCString *)&v6, 0);
      goto LABEL_11;
    case 2u:
      PCURL::PCURL((PCURL *)&v6, @"Emitter Color Over Life");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 6784), (const PCString *)&v6, 0);
      goto LABEL_11;
    case 3u:
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 6912), 2, a2);
      PCURL::PCURL((PCURL *)&v6, @"Emitter Color Range");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 6784), (const PCString *)&v6, 0);
LABEL_11:
      PCString::~PCString((PCString *)&v6);
      break;
    default:
      return;
  }
}

void sub_1B7DDE220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PSParticleType::updateRotationStringNames(PSParticleType *this)
{
  double v2 = (OZChannelBase *)((char *)this + 2776);
  PCURL::PCURL((PCURL *)&v3, @"Particle Type Rotation");
  OZChannelBase::setName(v2, &v3, 1);
  PCString::~PCString(&v3);
  PCURL::PCURL((PCURL *)&v3, @"Particle Type Rotation End");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 3632), &v3, 1);
  PCString::~PCString(&v3);
  PCURL::PCURL((PCURL *)&v3, @"Particle Type Rotation Variance");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 4648), &v3, 1);
  PCString::~PCString(&v3);
}

void sub_1B7DDE338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

__n128 PSParticleType::getNaturalDuration@<Q0>(PSParticleType *this@<X0>, __n128 *a2@<X8>)
{
  if ((*(uint64_t (**)(PSParticleType *))(*(void *)this + 272))(this))
  {
    uint64_t v4 = (OZSceneSettings *)((*(uint64_t (**)(PSParticleType *))(*(void *)this + 272))(this) + 336);
    result.n128_u64[0] = OZSceneSettings::getFrameDuration(v4, a2).n128_u64[0];
  }
  else
  {
    uint64_t v6 = MEMORY[0x1E4F1FA48];
    __n128 result = *(__n128 *)MEMORY[0x1E4F1FA48];
    *a2 = *(__n128 *)MEMORY[0x1E4F1FA48];
    a2[1].n128_u64[0] = *(void *)(v6 + 16);
  }
  return result;
}

double non-virtual thunk to'PSParticleType::getNaturalDuration@<D0>(PSParticleType *this@<X0>, __n128 *a2@<X8>)
{
  *(void *)&double result = PSParticleType::getNaturalDuration((PSParticleType *)((char *)this - 16), a2).n128_u64[0];
  return result;
}

void PSParticleType::getSourceRender(PSParticleType *this@<X0>, const OZRenderParams *a2@<X1>, const CMTime *a3@<X2>, int a4@<W3>, PCSharedCount *a5@<X8>)
{
  if (*((void *)this + 2061))
  {
    if (*((unsigned char *)this + 16529))
    {
      *(_OWORD *)&v42.value = *(_OWORD *)a2;
      CMTimeEpoch epoch = *((void *)a2 + 2);
    }
    else
    {
      memset(&v35, 0, 24);
      uint64_t v11 = (*(uint64_t (**)(void))(*(void *)(*((void *)this + 2054) + 200) + 272))();
      OZSceneSettings::getFrameDuration((OZSceneSettings *)(v11 + 336), (__n128 *)&v35);
      CMTime v41 = *a3;
      *(_OWORD *)&v40.value = *(_OWORD *)&v35.var0;
      v40.CMTimeEpoch epoch = (CMTimeEpoch)v35.var2;
      PC_CMTimeFloorToSampleDuration(&v41, &v40, (uint64_t)v31);
      *(_OWORD *)&v42.value = *(_OWORD *)&v31[0].value;
      CMTimeEpoch epoch = v31[0].epoch;
    }
    v42.CMTimeEpoch epoch = epoch;
    if (a4)
    {
      PCSharedMutex::lock_shared((std::mutex *)((char *)this + 16616));
      uint64_t v12 = (const PCSharedCount *)std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::find<CMTime>((uint64_t)this + 16592, &v42);
      if ((const PCSharedCount *)((char *)this + 16600) != v12)
      {
        a5->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v12[7].var0;
        PCSharedCount::PCSharedCount(a5 + 1, v12 + 8);
        PCSharedMutex::unlock_shared((std::mutex *)((char *)this + 16616));
        return;
      }
      PCSharedMutex::unlock_shared((std::mutex *)((char *)this + 16616));
    }
    OZRenderParams::OZRenderParams((OZRenderParams *)&v35, a2);
    *(_OWORD *)&v35.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)&v42.value;
    v35.var2 = (void **)v42.epoch;
    long long v38 = 0uLL;
    OZRenderParams::setImageType((uint64_t)&v35, 1);
    char v37 = 1;
    long long v38 = 0u;
    long long v39 = 0u;
    __asm { FMOV            V0.2D, #1.0 }
    *(_OWORD *)&v31[0].value = _Q0;
    OZRenderParams::setResolution(&v35, v31);
    uint64_t v36 = *((void *)this + 2061);
    v35.var5 = (PCString *)0x3FF0000000000000;
    long long v38 = 0u;
    long long v39 = 0u;
    if (*((void *)this + 2062)) {
      v35.var7 = *((void *)this + 2062);
    }
    if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 10120), MEMORY[0x1E4F1FA48], 0.0)) {
      goto LABEL_24;
    }
    if (!(*(unsigned int (**)(PSParticleType *))(*(void *)this + 1592))(this)) {
      goto LABEL_24;
    }
    uint64_t v18 = (const void *)*((void *)this + 2061);
    if (!v18) {
      goto LABEL_24;
    }
    if (v19)
    {
      double v20 = (*(double (**)(void *))(*(void *)v19 + 1328))(v19);
    }
    else
    {
      if (!v24 || (CMTime v25 = v24, !OZImageElement::getFootage(v24)))
      {
LABEL_24:
        v33[1] = 0;
        v33[0] = 0;
        __asm { FMOV            V0.2D, #-1.0 }
        float64x2_t v34 = _Q0;
        (*(void (**)(void, void *, const OZRenderParams *))(**((void **)this + 2061) + 16))(*((void *)this + 2061), v33, a2);
        OZRenderParams::getResolution(a2, (__n128 *)v31);
        __asm { FMOV            V1.2D, #0.5 }
        int32x2_t v29 = vcgt_s32((int32x2_t)0x100000001, vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vaddq_f64(vmulq_f64(*(float64x2_t *)&v31[0].value, v34), _Q1), (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL))))));
        if (((v29.i32[0] | v29.i32[1]) & 1) == 0) {
          operator new();
        }
        a5->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0;
        PCSharedCount::PCSharedCount(a5 + 1);
        OZRenderParams::~OZRenderParams((OZRenderParams *)&v35);
        return;
      }
      Footage = OZImageElement::getFootage(v25);
      (*(void (**)(void *))(*(void *)Footage + 1328))(Footage);
    }
    double v21 = v20;
    if (v20 > 0.0)
    {
      v30[0] = *(CMTime *)((unsigned char *)this + 685);
      v32[0] = v42;
      PC_CMTimeSaferSubtract(v32, v30, (uint64_t)v31);
      *(_OWORD *)&v42.value = *(_OWORD *)&v31[0].value;
      uint64_t v22 = *(void *)(*((void *)this + 2054) + 200);
      v42.CMTimeEpoch epoch = v31[0].epoch;
      uint64_t v23 = (*(uint64_t (**)(void))(v22 + 272))();
      operator*(&v42, v31, *(double *)(v23 + 368) / v21);
      CMTime v42 = v31[0];
      v30[0] = *(CMTime *)((unsigned char *)this + 685);
      v32[0] = v31[0];
      PC_CMTimeSaferAdd(v32, v30, (uint64_t)v31);
      CMTime v42 = v31[0];
      *(_OWORD *)&v35.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)&v31[0].value;
      v35.var2 = (void **)v31[0].epoch;
      long long v38 = 0uLL;
    }
    goto LABEL_24;
  }
  a5->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0;

  PCSharedCount::PCSharedCount(a5 + 1);
}

void sub_1B7DDED38(_Unwind_Exception *a1)
{
}

void PSTextureCache::CacheEntry::~CacheEntry(PSTextureCache::CacheEntry *this)
{
  double v2 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  PCString v3 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void PSParticleType::HGNodeCacheEntryValue::~HGNodeCacheEntryValue(PSParticleType::HGNodeCacheEntryValue *this)
{
  double v2 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  PCString v3 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  if (*(void *)this) {
    (*(void (**)(void))(**(void **)this + 24))(*(void *)this);
  }
}

BOOL PSParticleType::CompareHGNodeCacheEntries::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CMTime time1 = *(CMTime *)a2;
  CMTime v9 = *(CMTime *)a3;
  if (CMTimeCompare(&time1, &v9))
  {
    CMTime time1 = *(CMTime *)a2;
    CMTime v9 = *(CMTime *)a3;
    return CMTimeCompare(&time1, &v9) >> 31;
  }
  else
  {
    double v6 = *(double *)(a2 + 24) - *(double *)(a3 + 24);
    if (v6 <= -0.0075 || v6 >= 0.0075)
    {
      return v6 < 0.0;
    }
    else
    {
      double v7 = *(double *)(a2 + 32) - *(double *)(a3 + 32);
      BOOL v8 = v7 <= -0.0075;
      if (v7 >= 0.0075) {
        BOOL v8 = 1;
      }
      return v7 < 0.0 && v8;
    }
  }
}

char *PSParticleType::cacheSourceNode(PSParticleType *this)
{
  double result = (char *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 272))(this);
  if (result)
  {
    PCString v3 = (__n128 *)((char *)this + 16440);
    uint64_t v4 = (OZSceneSettings *)(result + 336);
    OZSceneSettings::getFrameDuration((OZSceneSettings *)(result + 336), &v20);
    *((__n128 *)this + 1029) = v20;
    *((void *)this + 2060) = v21;
    uint64_t v5 = MEMORY[0x1E4F1FA48];
    *(_OWORD *)((char *)this + 16440) = *MEMORY[0x1E4F1FA48];
    *((void *)this + 2057) = *(void *)(v5 + 16);
    double v6 = (const void *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this);
    double v7 = v6;
    if (v6)
    {
      if (v8)
      {
        CMTime v9 = (__n128 *)((char *)this + 16464);
        (*(void (**)(__n128 *__return_ptr))(*(void *)v8 + 1128))(&v20);
        if (v3 != &v20)
        {
          __n128 *v3 = v20;
          *((void *)this + 2057) = v21;
          *CMTime v9 = v22;
          *((void *)this + 2060) = v23;
        }
        __n128 v20 = *v9;
        uint64_t v21 = *((void *)this + 2060);
        OZSceneSettings::getFrameDuration(v4, &v18);
        operator/((long long *)&v20, (uint64_t)&v18, (uint64_t)&time);
        double Seconds = CMTimeGetSeconds(&time);
        OZChannel::setMax((OZChannel *)((char *)this + 10424), Seconds);
        OZChannel::setMax((OZChannel *)((char *)this + 10728), Seconds);
      }
      *((void *)this + 2061) = v7;
      *((void *)this + 2062) = v11;
      if (v11)
      {
        *((double *)this + 2065) = (*(double (**)(void *))(*(void *)v11 + 1328))(v11);
        uint64_t v12 = (OZBehavior *)(*((void *)this + 2062) + 1216);
        char MayAffectTransform = 1;
        if (((*(uint64_t (**)(OZBehavior *))(*(void *)v12 + 560))(v12) & 1) == 0 {
          && (OZBehavior::IsChannelAffectedByBehaviors(v12, (const OZChannelBase *)1) & 1) == 0
        }
        {
        }
        *((unsigned char *)this + 16512) = MayAffectTransform;
        double v7 = (const void *)*((void *)this + 2061);
        if (!v7) {
          goto LABEL_15;
        }
        goto LABEL_18;
      }
    }
    else
    {
      *(_OWORD *)((char *)this + 16488) = 0u;
    }
    *((void *)this + 2065) = 0x3FF0000000000000;
    *((unsigned char *)this + 16512) = 0;
    if (!v7)
    {
LABEL_15:
      double result = 0;
LABEL_19:
      *((void *)this + 2063) = result;
      return result;
    }
LABEL_18:
    goto LABEL_19;
  }
  return result;
}

uint64_t anonymous namespace'::channelMayAffectTransform(_anonymous_namespace_ *this, const OZChannelBase *a2)
{
  if ((*(uint64_t (**)(_anonymous_namespace_ *, uint64_t))(*(void *)this + 496))(this, 1)) {
    return 1;
  }

  return OZBehavior::IsChannelAffectedByBehaviors(this, (const OZChannelBase *)1);
}

void PSParticleType::applyAllScaleOverLifeBehaviors(uint64_t *a1, CMTime *a2, CMTime *a3, CMTime *a4, uint64_t a5)
{
  memset(&v13, 0, sizeof(v13));
  uint64_t v10 = (*(uint64_t (**)(uint64_t *))(*a1 + 272))(a1);
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v10 + 336), (__n128 *)&v13);
  PSParticleType::applyScaleOverLifeBehaviors(v11, a1 + 125, a2, a3, a4, &v13, a5);
  PSParticleType::applyScaleOverLifeBehaviors(v12, (uint64_t *)(a1[2054] + 1200), a2, a3, a4, &v13, a5);
}

void PSParticleType::applyScaleOverLifeBehaviors(uint64_t a1, uint64_t *a2, CMTime *a3, CMTime *a4, CMTime *a5, CMTime *a6, uint64_t a7)
{
  double v7 = (uint64_t *)a2[1];
  if (v7 != a2)
  {
    CMTime v13 = a2;
    do
    {
      int v14 = *(void **)(*v13 + 16);
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(*(int32x4_t *)(v14[1] + 8), (int32x4_t)xmmword_1B83871B0)))) & 1) == 0)
      {
        CMTime v19 = *a5;
        CMTime v18 = *a6;
        v16.n128_f64[0] = PC_CMTimeSaferAdd(&v19, &v18, (uint64_t)v17);
        if ((*(unsigned int (**)(void *, unsigned char *, void, uint64_t, uint64_t, __n128))(*(void *)v15 + 296))(v15, v17, 0, 1, 1, v16))
        {
          PSScaleOverLifeBehavior::getScale((uint64_t)v15, a3, a4, a7);
        }
      }
      CMTime v13 = (uint64_t *)*v13;
    }
    while (v13 != v7);
  }
}

void PSParticleType::applyAllSequenceBehaviors(PSParticleType *this, CMTime *a2, const PSParticle *a3, PSSequencedValues *a4)
{
  double v7 = *((double *)a3 + 22);
  PSParticleType::applySequenceBehaviors(v7, (uint64_t)this, (uint64_t *)this + 125, a2, (uint64_t)a4, a4);
  uint64_t v10 = (uint64_t *)(*((void *)this + 2054) + 1200);

  PSParticleType::applySequenceBehaviors(v7, v8, v10, a2, v9, a4);
}

void PSParticleType::applySequenceBehaviors(double a1, uint64_t a2, uint64_t *a3, CMTime *a4, uint64_t a5, PSSequencedValues *a6)
{
  double v6 = (uint64_t *)a3[1];
  if (v6 != a3)
  {
    uint64_t v10 = a3;
    do
    {
      uint64_t v11 = *(void **)(*v10 + 16);
      unint64_t v12 = v11[1];
      long long v14 = xmmword_1B8385810;
      if (OZFactory::isKindOfClass(v12, (int32x4_t *)&v14))
      {
        if ((*(unsigned int (**)(void))(*(void *)v13 + 296))()) {
          PSSequenceBehavior::getValues(v13, a4, a1, a6);
        }
      }
      uint64_t v10 = (uint64_t *)*v10;
    }
    while (v10 != v6);
  }
}

void PSParticleType::getAllSequenceBehaviors(uint64_t a1, uint64_t a2, void **a3)
{
  PSParticleType::getSequenceBehaviors(a1, (uint64_t *)(a1 + 1000), a2, a3);
  double v7 = (uint64_t *)(*(void *)(a1 + 16432) + 1200);

  PSParticleType::getSequenceBehaviors(v6, v7, a2, a3);
}

void PSParticleType::getSequenceBehaviors(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v4 = (uint64_t *)a2[1];
  if (v4 != a2)
  {
    uint64_t v6 = a2;
    uint64_t v7 = (uint64_t)(a4 + 2);
    do
    {
      uint64_t v8 = *(void **)(*v6 + 16);
      unint64_t v9 = v8[1];
      long long v23 = xmmword_1B8385810;
      if (OZFactory::isKindOfClass(v9, (int32x4_t *)&v23))
      {
        if ((*(unsigned int (**)(void))(*(void *)v10 + 296))())
        {
          unint64_t v12 = a4[1];
          unint64_t v11 = (unint64_t)a4[2];
          if ((unint64_t)v12 >= v11)
          {
            uint64_t v14 = ((char *)v12 - (unsigned char *)*a4) >> 3;
            if ((unint64_t)(v14 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v15 = v11 - (void)*a4;
            uint64_t v16 = v15 >> 2;
            if (v15 >> 2 <= (unint64_t)(v14 + 1)) {
              uint64_t v16 = v14 + 1;
            }
            if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v17 = v16;
            }
            if (v17) {
              CMTime v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v7, v17);
            }
            else {
              CMTime v18 = 0;
            }
            CMTime v19 = &v18[8 * v14];
            *(void *)CMTime v19 = v10;
            CMTime v13 = v19 + 8;
            uint64_t v21 = (char *)*a4;
            __n128 v20 = (char *)a4[1];
            if (v20 != *a4)
            {
              do
              {
                uint64_t v22 = *((void *)v20 - 1);
                v20 -= 8;
                *((void *)v19 - 1) = v22;
                v19 -= 8;
              }
              while (v20 != v21);
              __n128 v20 = (char *)*a4;
            }
            *a4 = v19;
            a4[1] = v13;
            a4[2] = &v18[8 * v17];
            if (v20) {
              operator delete(v20);
            }
          }
          else
          {
            *unint64_t v12 = v10;
            CMTime v13 = v12 + 1;
          }
          a4[1] = v13;
        }
      }
      uint64_t v6 = (uint64_t *)*v6;
    }
    while (v6 != v4);
  }
}

char *PSParticleType::getFirstRemapTimeBehavior(uint64_t a1, uint64_t *a2)
{
  double v2 = (uint64_t *)a2[1];
  if (v2 == a2) {
    return 0;
  }
  PCString v3 = a2;
  uint64_t v4 = (const CMTime *)MEMORY[0x1E4F1FA48];
  while (1)
  {
    uint64_t v5 = *(void **)(*v3 + 16);
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(*(int32x4_t *)(v5[1] + 8), (int32x4_t)xmmword_1B8385810)))) & 1) == 0)
    {
      if ((*(unsigned int (**)(void))(*((void *)v6 + 2) + 24))())
      {
        if (OZChannel::getValueAsInt((OZChannel *)(v6 + 4384), v4, 0.0) == 4) {
          break;
        }
      }
    }
    PCString v3 = (uint64_t *)*v3;
    if (v3 == v2) {
      return 0;
    }
  }
  return v6;
}

BOOL PSParticleType::variesOverTime(PSParticleType *this)
{
  double v2 = (const void *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this);
  return v2
}

uint64_t PSParticleType::buildLighting(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  double v9 = *a4;
  uint64_t v8 = *((void *)a4 + 1);
  CMTimeEpoch v10 = *(void *)(v8 + 16);
  *(_OWORD *)&v36.value = *(_OWORD *)v8;
  v36.CMTimeEpoch epoch = v10;
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(*(void *)&v9 + 32792), &v36, 0.0);
  if (OZChannel::getValueAsInt((OZChannel *)(*(void *)&v9 + 32944), &v36, 0.0) == 1
    && ValueAsInt != 0)
  {
    return LiGeode::setLit(a2, 0);
  }
  (*(void (**)(double, uint64_t, uint64_t, uint64_t))(**(void **)&v9 + 544))(COERCE_DOUBLE(*(void *)&v9), a2, a3, *((void *)a4 + 1));
  if (!ValueAsInt || !LiGeode::needsLights((LiGeode *)a2)) {
    return LiGeode::setLit(a2, 0);
  }
  uint64_t LightFilter = LiGeode::getLightFilter((LiGeode *)a2);
  PCMatrix44Tmpl<double>::operator*(LightFilter + 472, (long long *)(a2 + 8), (uint64_t)v35);
  double v14 = (*(double (**)(uint64_t, uint64_t))(*(void *)(*(void *)&v9 + 200) + 2144))(*(void *)&v9 + 200, *((void *)a4 + 1));
  if (*((unsigned char *)a4 + 1498)) {
    PCMatrix44Tmpl<double>::leftMult((uint64_t)v35, a4 + 188);
  }
  uint64_t v15 = LiGeode::getLightFilter((LiGeode *)a2);
  uint64_t v16 = (void *)v15;
  unint64_t v17 = (double *)(v15 + 472);
  if ((unsigned char *)(v15 + 472) != v35)
  {
    for (uint64_t i = 0; i != 16; i += 4)
    {
      CMTime v19 = &v17[i];
      long long v20 = *(_OWORD *)&v35[i * 8 + 16];
      *(_OWORD *)CMTime v19 = *(_OWORD *)&v35[i * 8];
      *((_OWORD *)v19 + 1) = v20;
    }
  }
  if (fabs(PCMatrix44Tmpl<double>::determinant((double *)(v15 + 472))) < 0.0000001)
  {
    long long v37 = 0uLL;
    long long v38 = xmmword_1B7E733D0;
    liFindMatrixPlane(v17, (double *)&v37);
    uint64_t v21 = *((void *)&v37 + 1);
    v16[61] = v37;
    v16[65] = v21;
    uint64_t v22 = *((void *)&v38 + 1);
    v16[69] = v38;
    v16[73] = v22;
  }
  *(double *)(LiGeode::getLightFilter((LiGeode *)a2) + 184) = v14;
  if (*(unsigned char *)(LiGeode::getLightFilter((LiGeode *)a2) + 174))
  {
    long long v37 = 0uLL;
    __asm { FMOV            V0.2D, #-1.0 }
    long long v38 = _Q0;
    PSParticleType::getSourceImageBounds(a1, *((const OZRenderState **)a4 + 1), &v37);
    uint64_t v27 = LiGeode::getLightFilter((LiGeode *)a2);
    long long v28 = v38;
    *(_OWORD *)(v27 + 200) = v37;
    *(_OWORD *)(v27 + 216) = v28;
    uint64_t result = LiGeode::getLightFilter((LiGeode *)a2);
    if ((unsigned char *)(result + 344) != v35)
    {
      for (uint64_t j = 0; j != 128; j += 32)
      {
        uint64_t v31 = (_OWORD *)(result + 344 + j);
        long long v32 = *(_OWORD *)&v35[j + 16];
        *uint64_t v31 = *(_OWORD *)&v35[j];
        v31[1] = v32;
      }
    }
  }
  else
  {
    uint64_t result = LiGeode::getLightFilter((LiGeode *)a2);
    if (*(unsigned char *)(result + 173))
    {
      long long v37 = 0uLL;
      __asm { FMOV            V0.2D, #-1.0 }
      long long v38 = _Q0;
      PSParticleType::getSourceImageBounds(a1, *((const OZRenderState **)a4 + 1), &v37);
      uint64_t result = LiGeode::getLightFilter((LiGeode *)a2);
      long long v34 = v38;
      *(_OWORD *)(result + 200) = v37;
      *(_OWORD *)(result + 216) = v34;
    }
  }
  return result;
}

void PSParticleType::globalToParticleTime(PSParticleType *this@<X0>, const CMTime *a2@<X1>, double a3@<D0>, CMTime *a4@<X8>)
{
  *a4 = *a2;
  if (!OZChannel::getValueAsInt((OZChannel *)((char *)this + 10120), MEMORY[0x1E4F1FA48], 0.0))
  {
    int v7 = (*(uint64_t (**)(PSParticleType *))(*(void *)this + 1592))(this);
    if (a3 > 0.0 && v7 != 0)
    {
      long long v9 = *(_OWORD *)((char *)this + 16440);
      v11.CMTimeEpoch epoch = *((void *)this + 2057);
      *(_OWORD *)&v11.value = v9;
      CMTime v12 = *a4;
      PC_CMTimeSaferSubtract(&v12, &v11, (uint64_t)&v13);
      *a4 = v13;
      uint64_t v10 = (*(uint64_t (**)(void))(*(void *)(*((void *)this + 2054) + 200) + 272))();
      operator*(a4, &v13, *(double *)(v10 + 368) / a3);
      *a4 = v13;
      CMTime v11 = *(CMTime *)((unsigned char *)this + 685);
      CMTime v12 = *a4;
      PC_CMTimeSaferAdd(&v12, &v11, (uint64_t)&v13);
      *a4 = v13;
    }
  }
}

uint64_t PSParticleType::openMedia(PSParticleType *this)
{
  uint64_t v1 = (const void *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this);
  if (!v1) {
    return 0;
  }
  double v2 = v1;
  if (!v3)
  {
    PCString v3 = v4;
    if (!v4) {
      return 0;
    }
  }
  uint64_t v5 = *(uint64_t (**)(void *))(*(void *)v3 + 104);

  return v5(v3);
}

uint64_t PSParticleType::prerollBegin(PSParticleType *a1, const OZRenderParams *a2, uint64_t a3, uint64_t a4, double a5)
{
  OZSceneNode::prerollBegin((uint64_t)a1, (uint64_t)a2, a3, a4, a5);
  uint64_t v10 = (void *)(*(uint64_t (**)(PSParticleType *))(*(void *)a1 + 1336))(a1);
  CMTime v11 = v10;
  if (!v10)
  {
    OZRenderParams::OZRenderParams((OZRenderParams *)v20, a2);
    CMTime v12 = 0;
    double v13 = 30.0;
LABEL_9:
    char v14 = 1;
    goto LABEL_10;
  }
  OZRenderParams::OZRenderParams((OZRenderParams *)v20, a2);
  if (!v12)
  {
    double v13 = 30.0;
    if (v11 && OZImageElement::getFootage((OZImageElement *)v11))
    {
      Footage = OZImageElement::getFootage((OZImageElement *)v11);
      double v13 = (*(double (**)(void *))(*(void *)Footage + 1328))(Footage);
    }
    CMTime v12 = 0;
    goto LABEL_9;
  }
  double v13 = (*(double (**)(void *))(*(void *)v12 + 1328))(v12);
  char v14 = 0;
LABEL_10:
  memset(&v19, 0, sizeof(v19));
  CMTime v18 = *(CMTime *)a2;
  PSParticleType::globalToParticleTime(a1, &v18, v13, &v19);
  v20[0] = v19;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  if ((v14 & 1) != 0 && (CMTime v12 = v11) == 0) {
    uint64_t v16 = 0;
  }
  else {
    uint64_t v16 = (*(uint64_t (**)(void *, CMTime *, uint64_t, uint64_t, double))(*(void *)v12 + 112))(v12, v20, a3, a4, a5);
  }
  OZRenderParams::~OZRenderParams((OZRenderParams *)v20);
  return v16;
}

void sub_1B7DE04B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  OZRenderParams::~OZRenderParams((OZRenderParams *)va);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::prerollEnd(PSParticleType *this, const OZRenderParams *a2, PMFrameRequest *a3)
{
  OZSceneNode::prerollEnd((uint64_t)this, (uint64_t)a2, (uint64_t)a3);
  uint64_t v6 = (void *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this);
  int v7 = v6;
  if (!v6)
  {
    OZRenderParams::OZRenderParams((OZRenderParams *)v16, a2);
    uint64_t v8 = 0;
    double v9 = 30.0;
LABEL_9:
    char v10 = 1;
    goto LABEL_10;
  }
  OZRenderParams::OZRenderParams((OZRenderParams *)v16, a2);
  if (!v8)
  {
    double v9 = 30.0;
    if (v7 && OZImageElement::getFootage((OZImageElement *)v7))
    {
      Footage = OZImageElement::getFootage((OZImageElement *)v7);
      double v9 = (*(double (**)(void *))(*(void *)Footage + 1328))(Footage);
    }
    uint64_t v8 = 0;
    goto LABEL_9;
  }
  double v9 = (*(double (**)(void *))(*(void *)v8 + 1328))(v8);
  char v10 = 0;
LABEL_10:
  memset(&v15, 0, sizeof(v15));
  CMTime v14 = *(CMTime *)a2;
  PSParticleType::globalToParticleTime(this, &v14, v9, &v15);
  v16[0] = v15;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  if ((v10 & 1) != 0 && (uint64_t v8 = v7) == 0) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (*(uint64_t (**)(void *, CMTime *, PMFrameRequest *))(*(void *)v8 + 120))(v8, v16, a3);
  }
  OZRenderParams::~OZRenderParams((OZRenderParams *)v16);
  return v12;
}

void sub_1B7DE071C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  OZRenderParams::~OZRenderParams((OZRenderParams *)va);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::setRate(PSParticleType *this, const OZRenderParams *a2, PMFrameRequest *a3, double a4)
{
  OZSceneNode::setRate((uint64_t)this, (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t v8 = (void *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this);
  double v9 = v8;
  if (!v8)
  {
    OZRenderParams::OZRenderParams((OZRenderParams *)v18, a2);
    char v10 = 0;
    double v11 = 30.0;
LABEL_9:
    char v12 = 1;
    goto LABEL_10;
  }
  OZRenderParams::OZRenderParams((OZRenderParams *)v18, a2);
  if (!v10)
  {
    double v11 = 30.0;
    if (v9 && OZImageElement::getFootage((OZImageElement *)v9))
    {
      Footage = OZImageElement::getFootage((OZImageElement *)v9);
      double v11 = (*(double (**)(void *))(*(void *)Footage + 1328))(Footage);
    }
    char v10 = 0;
    goto LABEL_9;
  }
  double v11 = (*(double (**)(void *))(*(void *)v10 + 1328))(v10);
  char v12 = 0;
LABEL_10:
  memset(&v17, 0, sizeof(v17));
  CMTime v16 = *(CMTime *)a2;
  PSParticleType::globalToParticleTime(this, &v16, v11, &v17);
  v18[0] = v17;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  if ((v12 & 1) != 0 && (char v10 = v9) == 0) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = (*(uint64_t (**)(void *, CMTime *, PMFrameRequest *, double))(*(void *)v10 + 128))(v10, v18, a3, a4);
  }
  OZRenderParams::~OZRenderParams((OZRenderParams *)v18);
  return v14;
}

void sub_1B7DE0994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  OZRenderParams::~OZRenderParams((OZRenderParams *)va);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::scheduleTokens(uint64_t a1, uint64_t a2, long long **a3, uint64_t a4, uint64_t a5)
{
  memset(v15, 0, sizeof(v15));
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__init_with_size[abi:ne180100]<std::pair<CMTime,std::vector<CMTime>>*,std::pair<CMTime,std::vector<CMTime>>*>(v15, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (a3[1] - *a3));
  (*(void (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)a1 + 184))(a1, a2, v15, a4);
  OZSceneNode::scheduleTokens(a1, a2, (uint64_t)v15, a4, a5);
  double v9 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1336))(a1);
  char v10 = v9;
  if (v9
  {
    uint64_t v13 = (*(uint64_t (**)(void *, uint64_t, void *, uint64_t, uint64_t))(*(void *)v11 + 136))(v11, a2, v15, a4, a5);
  }
  else
  {
    uint64_t v13 = 0;
  }
  CMTime v16 = (void **)v15;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100](&v16);
  return v13;
}

void sub_1B7DE0B78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::hintTokensWillImage(uint64_t a1, uint64_t a2, long long **a3, uint64_t a4)
{
  memset(v13, 0, sizeof(v13));
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__init_with_size[abi:ne180100]<std::pair<CMTime,std::vector<CMTime>>*,std::pair<CMTime,std::vector<CMTime>>*>(v13, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (a3[1] - *a3));
  (*(void (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)a1 + 184))(a1, a2, v13, a4);
  OZSceneNode::hintTokensWillImage(a1, a2, (uint64_t)v13, a4);
  int v7 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1336))(a1);
  uint64_t v8 = v7;
  if (v7
  {
    uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, void *, uint64_t))(*(void *)v9 + 144))(v9, a2, v13, a4);
  }
  else
  {
    uint64_t v11 = 0;
  }
  uint64_t v14 = (void **)v13;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100](&v14);
  return v11;
}

void sub_1B7DE0D50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::getTokensImage(uint64_t a1, uint64_t a2, long long **a3, uint64_t a4)
{
  memset(v13, 0, sizeof(v13));
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__init_with_size[abi:ne180100]<std::pair<CMTime,std::vector<CMTime>>*,std::pair<CMTime,std::vector<CMTime>>*>(v13, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (a3[1] - *a3));
  (*(void (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)a1 + 184))(a1, a2, v13, a4);
  OZSceneNode::getTokensImage(a1, a2, (uint64_t)v13, a4);
  int v7 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1336))(a1);
  uint64_t v8 = v7;
  if (v7
  {
    uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, void *, uint64_t))(*(void *)v9 + 152))(v9, a2, v13, a4);
  }
  else
  {
    uint64_t v11 = 0;
  }
  uint64_t v14 = (void **)v13;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100](&v14);
  return v11;
}

void sub_1B7DE0F28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void PSParticleType::remapTokens(PSParticleType *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  OZSceneNode::remapTokens((uint64_t)a1, a2, (uint64_t)a3, a4);
  uint64_t v6 = (const void *)(*(uint64_t (**)(PSParticleType *))(*(void *)a1 + 1336))(a1);
  double v7 = 30.0;
  if (v6)
  {
    uint64_t v8 = v6;
    if (Footage)
    {
LABEL_6:
      double v7 = (*(double (**)(void *))(*(void *)Footage + 1328))(Footage);
      goto LABEL_7;
    }
    uint64_t v11 = v10;
    if (v10 && OZImageElement::getFootage(v10))
    {
      Footage = OZImageElement::getFootage(v11);
      goto LABEL_6;
    }
  }
LABEL_7:
  uint64_t v13 = *a3;
  uint64_t v12 = a3[1];
  if (v12 != *a3)
  {
    uint64_t v14 = 0;
    unsigned int v15 = 0;
    do
    {
      uint64_t v16 = v13 + 48 * v14;
      uint64_t v19 = *(void *)(v16 + 24);
      uint64_t v18 = (uint64_t *)(v16 + 24);
      uint64_t v17 = v19;
      if (v18[1] != v19)
      {
        uint64_t v20 = 0;
        unsigned int v21 = 1;
        do
        {
          uint64_t v22 = 3 * v20;
          CMTime v27 = *(CMTime *)(v17 + 24 * v20);
          memset(&v26, 0, sizeof(v26));
          PSParticleType::globalToParticleTime(a1, &v27, v7, &v26);
          uint64_t v23 = *(void *)(*a3 + 48 * v14 + 24) + 8 * v22;
          long long v24 = *(_OWORD *)&v26.value;
          *(void *)(v23 + 16) = v26.epoch;
          *(_OWORD *)uint64_t v23 = v24;
          uint64_t v20 = v21;
          uint64_t v17 = *v18;
        }
        while (0xAAAAAAAAAAAAAAABLL * ((v18[1] - *v18) >> 3) > v21++);
        uint64_t v13 = *a3;
        uint64_t v12 = a3[1];
      }
      uint64_t v14 = ++v15;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 4) > v15);
  }
}

void *PSParticleType::pruneTokensAtTime(PSParticleType *this, CMTime *a2, const char *a3)
{
  CMTime v13 = *a2;
  OZSceneNode::pruneTokensAtTime((uint64_t)this, &v13, a3);
  uint64_t result = (void *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this);
  if (result)
  {
    double v7 = result;
    if (v8)
    {
      long long v11 = *(_OWORD *)&a2->value;
      CMTimeEpoch epoch = a2->epoch;
      return (void *)(*(uint64_t (**)(void *, long long *, const char *))(*(void *)v8 + 160))(v8, &v11, a3);
    }
    else
    {
      if (result)
      {
        long long v9 = *(_OWORD *)&a2->value;
        CMTimeEpoch v10 = a2->epoch;
        return (void *)(*(uint64_t (**)(void *, long long *, const char *))(*(void *)result + 160))(result, &v9, a3);
      }
    }
  }
  return result;
}

void *PSParticleType::pruneTokensExceptAtTime(PSParticleType *this, CMTime *a2, const char *a3)
{
  CMTime v13 = *a2;
  OZSceneNode::pruneTokensExceptAtTime((uint64_t)this, &v13, a3);
  uint64_t result = (void *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this);
  if (result)
  {
    double v7 = result;
    if (v8)
    {
      long long v11 = *(_OWORD *)&a2->value;
      CMTimeEpoch epoch = a2->epoch;
      return (void *)(*(uint64_t (**)(void *, long long *, const char *))(*(void *)v8 + 168))(v8, &v11, a3);
    }
    else
    {
      if (result)
      {
        long long v9 = *(_OWORD *)&a2->value;
        CMTimeEpoch v10 = a2->epoch;
        return (void *)(*(uint64_t (**)(void *, long long *, const char *))(*(void *)result + 168))(result, &v9, a3);
      }
    }
  }
  return result;
}

void *PSParticleType::pruneAllTokens(PSParticleType *this, const char *a2)
{
  OZSceneNode::pruneAllTokens((uint64_t)this, a2);
  uint64_t result = (void *)(*(uint64_t (**)(PSParticleType *))(*(void *)this + 1336))(this);
  if (result)
  {
    uint64_t v4 = result;
    if (result
    {
      uint64_t v5 = *(uint64_t (**)(void))(*(void *)result + 176);
      return (void *)v5();
    }
  }
  return result;
}

uint64_t PSParticleType::getSystemSimulator(PSParticleType *this)
{
  return (uint64_t)this + 15520;
}

uint64_t non-virtual thunk to'PSParticleType::getSystemSimulator(PSParticleType *this)
{
  return (uint64_t)this + 14408;
}

uint64_t PSParticleType::PSParticleType_birthRateChanImpl::getInstance(PSParticleType::PSParticleType_birthRateChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_birthRateChanImpl::getInstance(void)::PSParticleType_birthRateChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_birthRateChanImpl::getInstance(void)::PSParticleType_birthRateChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_birthRateChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_birthRateChanImpl::_PSParticleType_birthRateChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_birthRateChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_birthRateChanImpl::_PSParticleType_birthRateChan) {
    operator new();
  }
}

void sub_1B7DE1644(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_birthRateChanImpl::PSParticleType_birthRateChanImpl(PSParticleType::PSParticleType_birthRateChanImpl *this)
{
}

void sub_1B7DE1718(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_birthRateChanInfo::getInstance(PSParticleType::PSParticleType_birthRateChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_birthRateChanInfo::getInstance(void)::PSParticleType_birthRateChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_birthRateChanInfo::getInstance(void)::PSParticleType_birthRateChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_birthRateChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_birthRateChanInfo::_PSParticleType_birthRateChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_birthRateChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_birthRateChanInfo::_PSParticleType_birthRateChanInfo) {
    operator new();
  }
}

void sub_1B7DE17F4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_birthRateChanInfo *PSParticleType::PSParticleType_birthRateChanInfo::PSParticleType_birthRateChanInfo(PSParticleType::PSParticleType_birthRateChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 300.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_birthRateChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118DC00;
  *((void *)this + 10) = &unk_1F118DC20;
  return this;
}

void sub_1B7DE18C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_birthRateVarChanImpl::getInstance(PSParticleType::PSParticleType_birthRateVarChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_birthRateVarChanImpl::getInstance(void)::PSParticleType_birthRateVarChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_birthRateVarChanImpl::getInstance(void)::PSParticleType_birthRateVarChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_birthRateVarChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_birthRateVarChanImpl::_PSParticleType_birthRateVarChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_birthRateVarChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_birthRateVarChanImpl::_PSParticleType_birthRateVarChan) {
    operator new();
  }
}

void sub_1B7DE19A4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_birthRateVarChanImpl::PSParticleType_birthRateVarChanImpl(PSParticleType::PSParticleType_birthRateVarChanImpl *this)
{
}

void sub_1B7DE1A78(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_initialNumChanImpl::getInstance(PSParticleType::PSParticleType_initialNumChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_initialNumChanImpl::getInstance(void)::PSParticleType_initialNumChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_initialNumChanImpl::getInstance(void)::PSParticleType_initialNumChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_initialNumChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_initialNumChanImpl::_PSParticleType_initialNumChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_initialNumChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_initialNumChanImpl::_PSParticleType_initialNumChan) {
    operator new();
  }
}

void sub_1B7DE1B54(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_initialNumChanImpl::PSParticleType_initialNumChanImpl(PSParticleType::PSParticleType_initialNumChanImpl *this)
{
}

void sub_1B7DE1C28(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_lifetimeChanImpl::getInstance(PSParticleType::PSParticleType_lifetimeChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_lifetimeChanImpl::getInstance(void)::PSParticleType_lifetimeChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_lifetimeChanImpl::getInstance(void)::PSParticleType_lifetimeChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_lifetimeChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_lifetimeChanImpl::_PSParticleType_lifetimeChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_lifetimeChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_lifetimeChanImpl::_PSParticleType_lifetimeChan) {
    operator new();
  }
}

void sub_1B7DE1D04(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_lifetimeChanImpl::PSParticleType_lifetimeChanImpl(PSParticleType::PSParticleType_lifetimeChanImpl *this)
{
}

void sub_1B7DE1DD8(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_lifetimeChanInfo::getInstance(PSParticleType::PSParticleType_lifetimeChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_lifetimeChanInfo::getInstance(void)::PSParticleType_lifetimeChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_lifetimeChanInfo::getInstance(void)::PSParticleType_lifetimeChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_lifetimeChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_lifetimeChanInfo::_PSParticleType_lifetimeChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_lifetimeChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_lifetimeChanInfo::_PSParticleType_lifetimeChanInfo) {
    operator new();
  }
}

void sub_1B7DE1EB4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_lifetimeChanInfo *PSParticleType::PSParticleType_lifetimeChanInfo::PSParticleType_lifetimeChanInfo(PSParticleType::PSParticleType_lifetimeChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 10.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_lifetimeChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118DDE0;
  *((void *)this + 10) = &unk_1F118DE00;
  return this;
}

void sub_1B7DE1F84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_lifetimeVarChanImpl::getInstance(PSParticleType::PSParticleType_lifetimeVarChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_lifetimeVarChanImpl::getInstance(void)::PSParticleType_lifetimeVarChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_lifetimeVarChanImpl::getInstance(void)::PSParticleType_lifetimeVarChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_lifetimeVarChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_lifetimeVarChanImpl::_PSParticleType_lifetimeVarChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_lifetimeVarChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_lifetimeVarChanImpl::_PSParticleType_lifetimeVarChan) {
    operator new();
  }
}

void sub_1B7DE2060(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_lifetimeVarChanImpl::PSParticleType_lifetimeVarChanImpl(PSParticleType::PSParticleType_lifetimeVarChanImpl *this)
{
}

void sub_1B7DE2134(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_speedChanImpl::getInstance(PSParticleType::PSParticleType_speedChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_speedChanImpl::getInstance(void)::PSParticleType_speedChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_speedChanImpl::getInstance(void)::PSParticleType_speedChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_speedChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_speedChanImpl::_PSParticleType_speedChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_speedChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_speedChanImpl::_PSParticleType_speedChan) {
    operator new();
  }
}

void sub_1B7DE2210(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_speedChanImpl::PSParticleType_speedChanImpl(PSParticleType::PSParticleType_speedChanImpl *this)
{
}

void sub_1B7DE22F8(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_speedChanInfo::getInstance(PSParticleType::PSParticleType_speedChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_speedChanInfo::getInstance(void)::PSParticleType_speedChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_speedChanInfo::getInstance(void)::PSParticleType_speedChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_speedChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_speedChanInfo::_PSParticleType_speedChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_speedChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_speedChanInfo::_PSParticleType_speedChanInfo) {
    operator new();
  }
}

void sub_1B7DE23D4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_speedChanInfo *PSParticleType::PSParticleType_speedChanInfo::PSParticleType_speedChanInfo(PSParticleType::PSParticleType_speedChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 1000.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_speedChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118DF48;
  *((void *)this + 10) = &unk_1F118DF68;
  return this;
}

void sub_1B7DE24A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_speedVarChanImpl::getInstance(PSParticleType::PSParticleType_speedVarChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_speedVarChanImpl::getInstance(void)::PSParticleType_speedVarChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_speedVarChanImpl::getInstance(void)::PSParticleType_speedVarChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_speedVarChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_speedVarChanImpl::_PSParticleType_speedVarChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_speedVarChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_speedVarChanImpl::_PSParticleType_speedVarChan) {
    operator new();
  }
}

void sub_1B7DE2584(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_speedVarChanImpl::PSParticleType_speedVarChanImpl(PSParticleType::PSParticleType_speedVarChanImpl *this)
{
}

void sub_1B7DE2658(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_speedVarChanInfo::getInstance(PSParticleType::PSParticleType_speedVarChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_speedVarChanInfo::getInstance(void)::PSParticleType_speedVarChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_speedVarChanInfo::getInstance(void)::PSParticleType_speedVarChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_speedVarChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_speedVarChanInfo::_PSParticleType_speedVarChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_speedVarChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_speedVarChanInfo::_PSParticleType_speedVarChanInfo) {
    operator new();
  }
}

void sub_1B7DE2734(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_speedVarChanInfo *PSParticleType::PSParticleType_speedVarChanInfo::PSParticleType_speedVarChanInfo(PSParticleType::PSParticleType_speedVarChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 1000.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_speedVarChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118E038;
  *((void *)this + 10) = &unk_1F118E058;
  return this;
}

void sub_1B7DE2808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_rotVarChanInfo::getInstance(PSParticleType::PSParticleType_rotVarChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_rotVarChanInfo::getInstance(void)::PSParticleType_rotVarChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_rotVarChanInfo::getInstance(void)::PSParticleType_rotVarChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_rotVarChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_rotVarChanInfo::_PSParticleType_rotVarChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_rotVarChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_rotVarChanInfo::_PSParticleType_rotVarChanInfo) {
    operator new();
  }
}

void sub_1B7DE28E4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_rotVarChanInfo *PSParticleType::PSParticleType_rotVarChanInfo::PSParticleType_rotVarChanInfo(PSParticleType::PSParticleType_rotVarChanInfo *this)
{
  PCString::PCString(&v3, "°");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 3.40282347e38, 0.0174532925, 0.000174532925, 57.2957795, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_rotVarChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118E0B0;
  *((void *)this + 10) = &unk_1F118E0D0;
  return this;
}

void sub_1B7DE29C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_spinChanInfo::getInstance(PSParticleType::PSParticleType_spinChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_spinChanInfo::getInstance(void)::PSParticleType_spinChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_spinChanInfo::getInstance(void)::PSParticleType_spinChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_spinChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_spinChanInfo::_PSParticleType_spinChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_spinChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_spinChanInfo::_PSParticleType_spinChanInfo) {
    operator new();
  }
}

void sub_1B7DE2A9C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_spinChanInfo *PSParticleType::PSParticleType_spinChanInfo::PSParticleType_spinChanInfo(PSParticleType::PSParticleType_spinChanInfo *this)
{
  PCString::PCString(&v3, "°");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -12.5663706, 12.5663706, 0.0174532925, 0.000174532925, 57.2957795, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_spinChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118E128;
  *((void *)this + 10) = &unk_1F118E148;
  return this;
}

void sub_1B7DE2B7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_spinVarChanImpl::getInstance(PSParticleType::PSParticleType_spinVarChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_spinVarChanImpl::getInstance(void)::PSParticleType_spinVarChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_spinVarChanImpl::getInstance(void)::PSParticleType_spinVarChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_spinVarChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_spinVarChanImpl::_PSParticleType_spinVarChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_spinVarChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_spinVarChanImpl::_PSParticleType_spinVarChan) {
    operator new();
  }
}

void sub_1B7DE2C58(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_spinVarChanImpl::PSParticleType_spinVarChanImpl(OZChannelAngle *this)
{
}

void sub_1B7DE2D2C(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_spinVarChanInfo::getInstance(PSParticleType::PSParticleType_spinVarChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_spinVarChanInfo::getInstance(void)::PSParticleType_spinVarChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_spinVarChanInfo::getInstance(void)::PSParticleType_spinVarChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_spinVarChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_spinVarChanInfo::_PSParticleType_spinVarChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_spinVarChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_spinVarChanInfo::_PSParticleType_spinVarChanInfo) {
    operator new();
  }
}

void sub_1B7DE2E08(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_spinVarChanInfo *PSParticleType::PSParticleType_spinVarChanInfo::PSParticleType_spinVarChanInfo(PSParticleType::PSParticleType_spinVarChanInfo *this)
{
  PCString::PCString(&v3, "°");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -3.40282347e38, 20.0, 0.0174532925, 0.000174532925, 57.2957795, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_spinVarChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118E218;
  *((void *)this + 10) = &unk_1F118E238;
  return this;
}

void sub_1B7DE2EE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_colorModeChanImpl::getInstance(PSParticleType::PSParticleType_colorModeChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_colorModeChanImpl::getInstance(void)::PSParticleType_colorModeChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_colorModeChanImpl::getInstance(void)::PSParticleType_colorModeChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_colorModeChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_colorModeChanImpl::_PSParticleType_colorModeChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_colorModeChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_colorModeChanImpl::_PSParticleType_colorModeChan) {
    operator new();
  }
}

void sub_1B7DE2FC0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_colorModeChanImpl::PSParticleType_colorModeChanImpl(PSParticleType::PSParticleType_colorModeChanImpl *this)
{
}

void sub_1B7DE3094(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_colorRepetitionsChanInfo::getInstance(PSParticleType::PSParticleType_colorRepetitionsChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_colorRepetitionsChanInfo::getInstance(void)::PSParticleType_colorRepetitionsChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_colorRepetitionsChanInfo::getInstance(void)::PSParticleType_colorRepetitionsChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_colorRepetitionsChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_colorRepetitionsChanInfo::_PSParticleType_colorRepetitionsChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_colorRepetitionsChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_colorRepetitionsChanInfo::_PSParticleType_colorRepetitionsChanInfo) {
    operator new();
  }
}

void sub_1B7DE3170(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_colorRepetitionsChanInfo *PSParticleType::PSParticleType_colorRepetitionsChanInfo::PSParticleType_colorRepetitionsChanInfo(PSParticleType::PSParticleType_colorRepetitionsChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 5.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_colorRepetitionsChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118E308;
  *((void *)this + 10) = &unk_1F118E328;
  return this;
}

void sub_1B7DE3240(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_scaleVarChanImpl::getInstance(PSParticleType::PSParticleType_scaleVarChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_scaleVarChanImpl::getInstance(void)::PSParticleType_scaleVarChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_scaleVarChanImpl::getInstance(void)::PSParticleType_scaleVarChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_scaleVarChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_scaleVarChanImpl::_PSParticleType_scaleVarChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_scaleVarChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_scaleVarChanImpl::_PSParticleType_scaleVarChan) {
    operator new();
  }
}

void sub_1B7DE331C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_scaleVarChanImpl::PSParticleType_scaleVarChanImpl(PSParticleType::PSParticleType_scaleVarChanImpl *this)
{
}

void sub_1B7DE33F0(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_scaleVarChanInfo::getInstance(PSParticleType::PSParticleType_scaleVarChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_scaleVarChanInfo::getInstance(void)::PSParticleType_scaleVarChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_scaleVarChanInfo::getInstance(void)::PSParticleType_scaleVarChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_scaleVarChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_scaleVarChanInfo::_PSParticleType_scaleVarChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_scaleVarChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_scaleVarChanInfo::_PSParticleType_scaleVarChanInfo) {
    operator new();
  }
}

void sub_1B7DE34CC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_scaleVarChanInfo *PSParticleType::PSParticleType_scaleVarChanInfo::PSParticleType_scaleVarChanInfo(PSParticleType::PSParticleType_scaleVarChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 2.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_scaleVarChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118E3F8;
  *((void *)this + 10) = &unk_1F118E418;
  return this;
}

void sub_1B7DE35A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_sourceStartFrameChanImpl::getInstance(PSParticleType::PSParticleType_sourceStartFrameChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_sourceStartFrameChanImpl::getInstance(void)::PSParticleType_sourceStartFrameChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_sourceStartFrameChanImpl::getInstance(void)::PSParticleType_sourceStartFrameChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_sourceStartFrameChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_sourceStartFrameChanImpl::_PSParticleType_sourceStartFrameChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_sourceStartFrameChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_sourceStartFrameChanImpl::_PSParticleType_sourceStartFrameChan) {
    operator new();
  }
}

void sub_1B7DE3680(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_sourceStartFrameChanImpl::PSParticleType_sourceStartFrameChanImpl(PSParticleType::PSParticleType_sourceStartFrameChanImpl *this)
{
}

void sub_1B7DE3754(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_sourceStartFrameChanInfo::getInstance(PSParticleType::PSParticleType_sourceStartFrameChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_sourceStartFrameChanInfo::getInstance(void)::PSParticleType_sourceStartFrameChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_sourceStartFrameChanInfo::getInstance(void)::PSParticleType_sourceStartFrameChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_sourceStartFrameChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_sourceStartFrameChanInfo::_PSParticleType_sourceStartFrameChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_sourceStartFrameChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_sourceStartFrameChanInfo::_PSParticleType_sourceStartFrameChanInfo) {
    operator new();
  }
}

void sub_1B7DE3830(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_sourceStartFrameChanInfo *PSParticleType::PSParticleType_sourceStartFrameChanInfo::PSParticleType_sourceStartFrameChanInfo(PSParticleType::PSParticleType_sourceStartFrameChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 100.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_sourceStartFrameChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118E4E8;
  *((void *)this + 10) = &unk_1F118E508;
  return this;
}

void sub_1B7DE3904(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_sourceStartFrameOSChanImpl::getInstance(PSParticleType::PSParticleType_sourceStartFrameOSChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_sourceStartFrameOSChanImpl::getInstance(void)::PSParticleType_sourceStartFrameOSChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_sourceStartFrameOSChanImpl::getInstance(void)::PSParticleType_sourceStartFrameOSChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_sourceStartFrameOSChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_sourceStartFrameOSChanImpl::_PSParticleType_sourceStartFrameOSChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_sourceStartFrameOSChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_sourceStartFrameOSChanImpl::_PSParticleType_sourceStartFrameOSChan) {
    operator new();
  }
}

void sub_1B7DE39E0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_sourceStartFrameOSChanImpl::PSParticleType_sourceStartFrameOSChanImpl(PSParticleType::PSParticleType_sourceStartFrameOSChanImpl *this)
{
}

void sub_1B7DE3AB4(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_sourceStartFrameOSChanInfo::getInstance(PSParticleType::PSParticleType_sourceStartFrameOSChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_sourceStartFrameOSChanInfo::getInstance(void)::PSParticleType_sourceStartFrameOSChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_sourceStartFrameOSChanInfo::getInstance(void)::PSParticleType_sourceStartFrameOSChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_sourceStartFrameOSChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_sourceStartFrameOSChanInfo::_PSParticleType_sourceStartFrameOSChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_sourceStartFrameOSChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_sourceStartFrameOSChanInfo::_PSParticleType_sourceStartFrameOSChanInfo) {
    operator new();
  }
}

void sub_1B7DE3B90(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_sourceStartFrameOSChanInfo *PSParticleType::PSParticleType_sourceStartFrameOSChanInfo::PSParticleType_sourceStartFrameOSChanInfo(PSParticleType::PSParticleType_sourceStartFrameOSChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 25.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_sourceStartFrameOSChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118E5D8;
  *((void *)this + 10) = &unk_1F118E5F8;
  return this;
}

void sub_1B7DE3C60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_sourceHoldFramesChanImpl::getInstance(PSParticleType::PSParticleType_sourceHoldFramesChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_sourceHoldFramesChanImpl::getInstance(void)::PSParticleType_sourceHoldFramesChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_sourceHoldFramesChanImpl::getInstance(void)::PSParticleType_sourceHoldFramesChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_sourceHoldFramesChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_sourceHoldFramesChanImpl::_PSParticleType_sourceHoldFramesChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_sourceHoldFramesChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_sourceHoldFramesChanImpl::_PSParticleType_sourceHoldFramesChan) {
    operator new();
  }
}

void sub_1B7DE3D3C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_sourceHoldFramesChanImpl::PSParticleType_sourceHoldFramesChanImpl(PSParticleType::PSParticleType_sourceHoldFramesChanImpl *this)
{
}

void sub_1B7DE3E10(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_shapeChanImpl::getInstance(PSParticleType::PSParticleType_shapeChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_shapeChanImpl::getInstance(void)::PSParticleType_shapeChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_shapeChanImpl::getInstance(void)::PSParticleType_shapeChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_shapeChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_shapeChanImpl::_PSParticleType_shapeChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_shapeChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_shapeChanImpl::_PSParticleType_shapeChan) {
    operator new();
  }
}

void sub_1B7DE3EEC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_shapeChanImpl::PSParticleType_shapeChanImpl(PSParticleType::PSParticleType_shapeChanImpl *this)
{
}

void sub_1B7DE3FC0(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_pointSizeChanImpl::getInstance(PSParticleType::PSParticleType_pointSizeChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_pointSizeChanImpl::getInstance(void)::PSParticleType_pointSizeChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_pointSizeChanImpl::getInstance(void)::PSParticleType_pointSizeChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_pointSizeChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_pointSizeChanImpl::_PSParticleType_pointSizeChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_pointSizeChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_pointSizeChanImpl::_PSParticleType_pointSizeChan) {
    operator new();
  }
}

void sub_1B7DE409C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_pointSizeChanImpl::PSParticleType_pointSizeChanImpl(PSParticleType::PSParticleType_pointSizeChanImpl *this)
{
}

void sub_1B7DE4170(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_pointSizeChanInfo::getInstance(PSParticleType::PSParticleType_pointSizeChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_pointSizeChanInfo::getInstance(void)::PSParticleType_pointSizeChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_pointSizeChanInfo::getInstance(void)::PSParticleType_pointSizeChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_pointSizeChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_pointSizeChanInfo::_PSParticleType_pointSizeChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_pointSizeChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_pointSizeChanInfo::_PSParticleType_pointSizeChanInfo) {
    operator new();
  }
}

void sub_1B7DE424C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_pointSizeChanInfo *PSParticleType::PSParticleType_pointSizeChanInfo::PSParticleType_pointSizeChanInfo(PSParticleType::PSParticleType_pointSizeChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 10.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_pointSizeChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118E7B8;
  *((void *)this + 10) = &unk_1F118E7D8;
  return this;
}

void sub_1B7DE431C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_pointSpacingChanImpl::getInstance(PSParticleType::PSParticleType_pointSpacingChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_pointSpacingChanImpl::getInstance(void)::PSParticleType_pointSpacingChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_pointSpacingChanImpl::getInstance(void)::PSParticleType_pointSpacingChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_pointSpacingChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_pointSpacingChanImpl::_PSParticleType_pointSpacingChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_pointSpacingChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_pointSpacingChanImpl::_PSParticleType_pointSpacingChan) {
    operator new();
  }
}

void sub_1B7DE43F8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_pointSpacingChanImpl::PSParticleType_pointSpacingChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DE44D0(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_pointSpacingChanInfo::getInstance(PSParticleType::PSParticleType_pointSpacingChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_pointSpacingChanInfo::getInstance(void)::PSParticleType_pointSpacingChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_pointSpacingChanInfo::getInstance(void)::PSParticleType_pointSpacingChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_pointSpacingChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_pointSpacingChanInfo::_PSParticleType_pointSpacingChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_pointSpacingChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_pointSpacingChanInfo::_PSParticleType_pointSpacingChanInfo) {
    operator new();
  }
}

void sub_1B7DE45AC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_pointSpacingChanInfo *PSParticleType::PSParticleType_pointSpacingChanInfo::PSParticleType_pointSpacingChanInfo(PSParticleType::PSParticleType_pointSpacingChanInfo *this)
{
  PCString::PCString(&v3, "%");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.05, 2.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_pointSpacingChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118E8A8;
  *((void *)this + 10) = &unk_1F118E8C8;
  return this;
}

void sub_1B7DE4688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_pointSpacingOSChanImpl::getInstance(PSParticleType::PSParticleType_pointSpacingOSChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_pointSpacingOSChanImpl::getInstance(void)::PSParticleType_pointSpacingOSChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_pointSpacingOSChanImpl::getInstance(void)::PSParticleType_pointSpacingOSChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_pointSpacingOSChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_pointSpacingOSChanImpl::_PSParticleType_pointSpacingOSChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_pointSpacingOSChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_pointSpacingOSChanImpl::_PSParticleType_pointSpacingOSChan) {
    operator new();
  }
}

void sub_1B7DE4764(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_pointSpacingOSChanImpl::PSParticleType_pointSpacingOSChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DE483C(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_pointSpacingOSChanInfo::getInstance(PSParticleType::PSParticleType_pointSpacingOSChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_pointSpacingOSChanInfo::getInstance(void)::PSParticleType_pointSpacingOSChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_pointSpacingOSChanInfo::getInstance(void)::PSParticleType_pointSpacingOSChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_pointSpacingOSChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_pointSpacingOSChanInfo::_PSParticleType_pointSpacingOSChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_pointSpacingOSChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_pointSpacingOSChanInfo::_PSParticleType_pointSpacingOSChanInfo) {
    operator new();
  }
}

void sub_1B7DE4918(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_pointSpacingOSChanInfo *PSParticleType::PSParticleType_pointSpacingOSChanInfo::PSParticleType_pointSpacingOSChanInfo(PSParticleType::PSParticleType_pointSpacingOSChanInfo *this)
{
  PCString::PCString(&v3, "%");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.05, 4.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_pointSpacingOSChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118E998;
  *((void *)this + 10) = &unk_1F118E9B8;
  return this;
}

void sub_1B7DE49F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_strokeWidthOSChanImpl::getInstance(PSParticleType::PSParticleType_strokeWidthOSChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_strokeWidthOSChanImpl::getInstance(void)::PSParticleType_strokeWidthOSChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_strokeWidthOSChanImpl::getInstance(void)::PSParticleType_strokeWidthOSChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_strokeWidthOSChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_strokeWidthOSChanImpl::_PSParticleType_strokeWidthOSChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_strokeWidthOSChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_strokeWidthOSChanImpl::_PSParticleType_strokeWidthOSChan) {
    operator new();
  }
}

void sub_1B7DE4AD0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_strokeWidthOSChanImpl::PSParticleType_strokeWidthOSChanImpl(OZChannelPercent *this)
{
}

void sub_1B7DE4BA4(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_strokeWidthOSChanInfo::getInstance(PSParticleType::PSParticleType_strokeWidthOSChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_strokeWidthOSChanInfo::getInstance(void)::PSParticleType_strokeWidthOSChanInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_strokeWidthOSChanInfo::getInstance(void)::PSParticleType_strokeWidthOSChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_strokeWidthOSChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_strokeWidthOSChanInfo::_PSParticleType_strokeWidthOSChanInfo;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_strokeWidthOSChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_strokeWidthOSChanInfo::_PSParticleType_strokeWidthOSChanInfo) {
    operator new();
  }
}

void sub_1B7DE4C80(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSParticleType::PSParticleType_strokeWidthOSChanInfo *PSParticleType::PSParticleType_strokeWidthOSChanInfo::PSParticleType_strokeWidthOSChanInfo(PSParticleType::PSParticleType_strokeWidthOSChanInfo *this)
{
  PCString::PCString(&v3, "%");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 4.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSParticleType::PSParticleType_strokeWidthOSChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F118EA88;
  *((void *)this + 10) = &unk_1F118EAA8;
  return this;
}

void sub_1B7DE4D58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_anchorDabsToChanImpl::getInstance(PSParticleType::PSParticleType_anchorDabsToChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_anchorDabsToChanImpl::getInstance(void)::PSParticleType_anchorDabsToChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_anchorDabsToChanImpl::getInstance(void)::PSParticleType_anchorDabsToChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_anchorDabsToChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_anchorDabsToChanImpl::_PSParticleType_anchorDabsToChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_anchorDabsToChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_anchorDabsToChanImpl::_PSParticleType_anchorDabsToChan) {
    operator new();
  }
}

void sub_1B7DE4E34(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_anchorDabsToChanImpl::PSParticleType_anchorDabsToChanImpl(PSParticleType::PSParticleType_anchorDabsToChanImpl *this)
{
}

void sub_1B7DE4F08(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_posOffsetVarChanImpl::getInstance(PSParticleType::PSParticleType_posOffsetVarChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_posOffsetVarChanImpl::getInstance(void)::PSParticleType_posOffsetVarChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_posOffsetVarChanImpl::getInstance(void)::PSParticleType_posOffsetVarChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_posOffsetVarChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_posOffsetVarChanImpl::_PSParticleType_posOffsetVarChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_posOffsetVarChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_posOffsetVarChanImpl::_PSParticleType_posOffsetVarChan) {
    operator new();
  }
}

void sub_1B7DE4FE4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_posOffsetVarChanImpl::PSParticleType_posOffsetVarChanImpl(PSParticleType::PSParticleType_posOffsetVarChanImpl *this)
{
}

void sub_1B7DE50B8(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSParticleType::PSParticleType_versionChanImpl::getInstance(PSParticleType::PSParticleType_versionChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType::PSParticleType_versionChanImpl::getInstance(void)::PSParticleType_versionChanImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSParticleType::PSParticleType_versionChanImpl::getInstance(void)::PSParticleType_versionChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType::PSParticleType_versionChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType::PSParticleType_versionChanImpl::_PSParticleType_versionChan;
}

void std::__call_once_param<std::tuple<PSParticleType::PSParticleType_versionChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSParticleType::PSParticleType_versionChanImpl::_PSParticleType_versionChan) {
    operator new();
  }
}

void sub_1B7DE5194(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSParticleType::PSParticleType_versionChanImpl::PSParticleType_versionChanImpl(PSParticleType::PSParticleType_versionChanImpl *this)
{
}

void sub_1B7DE526C(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<PSParticleType::HGNodeCacheEntryKey const,PSParticleType::HGNodeCacheEntryValue>,0>(a2 + 4);
    operator delete(a2);
  }
}

uint64_t std::__destroy_at[abi:ne180100]<std::pair<PSParticleType::HGNodeCacheEntryKey const,PSParticleType::HGNodeCacheEntryValue>,0>(void *a1)
{
  char v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  PCString v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t result = a1[5];
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
  }
  return result;
}

void std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::destroy(uint64_t a1, PCSharedCount *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::destroy(a1, a2->var0);
    std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::destroy(a1, a2[1].var0);
    PCSharedCount::~PCSharedCount(a2 + 8);
    operator delete(a2);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<PSParticleType::SourceBoundsCacheEntry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(56 * a2);
}

uint64_t std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::find<CMTime>(uint64_t a1, CMTime *a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  uint64_t v6 = a1 + 8;
  do
  {
    int v7 = PSParticleType::LessThanFigTime::operator()(v5, (CMTime *)(v3 + 32), a2);
    uint64_t v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      uint64_t v8 = (uint64_t *)v3;
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || PSParticleType::LessThanFigTime::operator()(v5, a2, (CMTime *)(v6 + 32))) {
    return v2;
  }
  return v6;
}

uint64_t PSParticleType::LessThanFigTime::operator()(uint64_t a1, CMTime *a2, CMTime *a3)
{
  CMTime time1 = *a2;
  CMTime v6 = *a3;
  uint64_t result = CMTimeCompare(&time1, &v6);
  if (result)
  {
    CMTime time1 = *a2;
    CMTime v6 = *a3;
    return CMTimeCompare(&time1, &v6) >> 31;
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::__emplace_unique_key_args<CMTime,std::piecewise_construct_t const&,std::tuple<CMTime const&>,std::tuple<>>(uint64_t **a1, CMTime *a2, uint64_t a3, _OWORD **a4)
{
  CMTime v6 = (uint64_t **)std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::__find_equal<CMTime>((uint64_t)a1, &v11, a2);
  int v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = v6;
    std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<CMTime const&>,std::tuple<>>((uint64_t)a1, a4, (uint64_t)v10);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v11, v8, v10[0]);
    int v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<CMTime,PCPtr<LiImageSource>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<CMTime,PCPtr<LiImageSource>>,void *>>>>::reset[abi:ne180100]((uint64_t)v10, 0);
  }
  return v7;
}

void *std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::__find_equal<CMTime>(uint64_t a1, void *a2, CMTime *a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        uint64_t v8 = (void *)v4;
        long long v9 = (CMTime *)(v4 + 32);
        if (!PSParticleType::LessThanFigTime::operator()(v7, a3, (CMTime *)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v8;
        uint64_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!PSParticleType::LessThanFigTime::operator()(v7, v9, a3)) {
        break;
      }
      uint64_t v5 = v8 + 1;
      uint64_t v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

void std::__tree<std::__value_type<CMTime,PCPtr<LiImageSource>>,std::__map_value_compare<CMTime,std::__value_type<CMTime,PCPtr<LiImageSource>>,PSParticleType::LessThanFigTime,true>,std::allocator<std::__value_type<CMTime,PCPtr<LiImageSource>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<CMTime const&>,std::tuple<>>(uint64_t a1@<X0>, _OWORD **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  CMTime v6 = operator new(0x48uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t v7 = *((void *)*a2 + 2);
  *((_OWORD *)v6 + 2) = **a2;
  *((void *)v6 + 6) = v7;
  *((void *)v6 + 7) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)v6 + 8);
  *(unsigned char *)(a3 + 16) = 1;
}

void sub_1B7DE56D4(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<CMTime,PCPtr<LiImageSource>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<CMTime,PCPtr<LiImageSource>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<CMTime,PCPtr<LiImageSource>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<CMTime,PCPtr<LiImageSource>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(PCSharedCount **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      PCSharedCount::~PCSharedCount(v2 + 8);
    }
    operator delete(v2);
  }
}

uint64_t std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::find<PSParticleType::HGNodeCacheEntryKey>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    a1 = PSParticleType::CompareHGNodeCacheEntries::operator()(a1, (uint64_t)(v3 + 4), a2);
    CMTime v6 = v3 + 1;
    if (!a1)
    {
      CMTime v6 = v3;
      uint64_t v5 = (uint64_t)v3;
    }
    uint64_t v3 = (void *)*v6;
  }
  while (*v6);
  if (v5 == v2 || PSParticleType::CompareHGNodeCacheEntries::operator()(a1, a2, v5 + 32)) {
    return v2;
  }
  return v5;
}

void std::allocate_shared[abi:ne180100]<PGMetalTexture,std::allocator<PGMetalTexture>,HGRef<HGMetalTexture> &,HGMetalContext *&,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  CMTime v6 = operator new(0x68uLL);
  std::__shared_ptr_emplace<PGMetalTexture>::__shared_ptr_emplace[abi:ne180100]<HGRef<HGMetalTexture> &,HGMetalContext *&,std::allocator<PGMetalTexture>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7DE5828(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PGMetalTexture>::__shared_ptr_emplace[abi:ne180100]<HGRef<HGMetalTexture> &,HGMetalContext *&,std::allocator<PGMetalTexture>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F118EC68;
  PGMetalTexture::PGMetalTexture((PCImage *)(a1 + 3), a2, *a3);
  return a1;
}

void sub_1B7DE5888(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PGMetalTexture>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F118EC68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PGMetalTexture>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F118EC68;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PGMetalTexture>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

PCImage *PGMetalTexture::PGMetalTexture(PCImage *a1, uint64_t *a2, uint64_t a3)
{
  PCImage::PCImage(a1);
  *CMTime v6 = &unk_1F1133940;
  uint64_t v7 = *a2;
  *((void *)a1 + 8) = *a2;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
  }
  *((void *)a1 + 9) = a3;
  return a1;
}

void sub_1B7DE59C0(_Unwind_Exception *a1)
{
  PCImage::~PCImage(v1);
  _Unwind_Resume(a1);
}

char *std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::__emplace_unique_key_args<PSParticleType::HGNodeCacheEntryKey,std::piecewise_construct_t const&,std::tuple<PSParticleType::HGNodeCacheEntryKey const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t a3, long long **a4)
{
  CMTime v6 = (void **)std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::__find_equal<PSParticleType::HGNodeCacheEntryKey>((uint64_t)a1, &v19, a2);
  uint64_t v7 = (char *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = (char *)operator new(0xA0uLL);
    v17[1] = a1 + 1;
    long long v9 = *a4;
    long long v10 = **a4;
    *((void *)v7 + 6) = *((void *)*a4 + 2);
    *((_OWORD *)v7 + 2) = v10;
    *(_OWORD *)(v7 + 56) = *(long long *)((char *)v9 + 24);
    *((void *)v7 + 17) = 0;
    *(_OWORD *)(v7 + 120) = 0u;
    *(_OWORD *)(v7 + 104) = 0u;
    *(_OWORD *)(v7 + 88) = 0u;
    *(_OWORD *)(v7 + 72) = 0u;
    __asm { FMOV            V0.2D, #-1.0 }
    *((_OWORD *)v7 + 9) = _Q0;
    char v18 = 1;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v19, v8, (uint64_t *)v7);
    v17[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,void *>>>>::reset[abi:ne180100]((uint64_t)v17, 0);
  }
  return v7;
}

void *std::__tree<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,std::__map_value_compare<PSParticleType::HGNodeCacheEntryKey,std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,PSParticleType::CompareHGNodeCacheEntries,true>,std::allocator<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>>>::__find_equal<PSParticleType::HGNodeCacheEntryKey>(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = v4;
        uint64_t v8 = (uint64_t)(v4 + 4);
        a1 = PSParticleType::CompareHGNodeCacheEntries::operator()(a1, a3, (uint64_t)(v4 + 4));
        if (!a1) {
          break;
        }
        uint64_t v4 = (void *)*v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      a1 = PSParticleType::CompareHGNodeCacheEntries::operator()(a1, v8, a3);
      if (!a1) {
        break;
      }
      uint64_t v5 = v7 + 1;
      uint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

void std::unique_ptr<std::__tree_node<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<PSParticleType::HGNodeCacheEntryKey,PSParticleType::HGNodeCacheEntryValue>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<PSParticleType::HGNodeCacheEntryKey const,PSParticleType::HGNodeCacheEntryValue>,0>(v2 + 4);
    }
    operator delete(v2);
  }
}

void std::allocate_shared[abi:ne180100]<PGMetalTexture,std::allocator<PGMetalTexture>,HGRef<HGMetalTexture> &,HGMetalContext *,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  CMTime v6 = operator new(0x68uLL);
  std::__shared_ptr_emplace<PGMetalTexture>::__shared_ptr_emplace[abi:ne180100]<HGRef<HGMetalTexture> &,HGMetalContext *&,std::allocator<PGMetalTexture>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1B7DE5C08(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void PSReplicator::PSReplicator(PSReplicator *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  PSEmitter::PSEmitter(this, a2, a3, a4);
  *(void *)uint64_t v5 = &unk_1F118ECB8;
  *((void *)v5 + 25) = &unk_1F118EF58;
  *((void *)v5 + 27) = &unk_1F118F830;
  *((void *)v5 + 31) = &unk_1F118FA88;
  *((void *)v5 + 841) = &unk_1F118FAE0;
  PSReplicator::initChannels(v5);
  (*(void (**)(PSReplicator *, uint64_t))(*(void *)this + 448))(this, 1);
}

void sub_1B7DE5D1C(_Unwind_Exception *a1)
{
  PSEmitter::~PSEmitter(v1);
  _Unwind_Resume(a1);
}

uint64_t PSReplicator::initChannels(PSReplicator *this)
{
  uint64_t v2 = (OZChannelBase *)((char *)this + 19488);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Shape Anim");
  OZChannelBase::setName(v2, &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Shape Anim Enum");
  OZChannelEnum::setStrings((const PCString *)v2, &v4, 1);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Emit Pattern Type");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 19896), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Emit Pattern Enum");
  OZChannelEnum::setStrings((const PCString *)this + 2487, &v4, 1);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Num Points");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 20152), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Num Points U");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 20304), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Num Points V");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 20456), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Tile Offset");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 21064), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Rect Build Origin Type");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 21216), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Rect Build Origin Enum");
  OZChannelEnum::setStrings((const PCString *)this + 2652, &v4, 1);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Rect Build Style Type");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 21472), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Rect Build Style Enum");
  OZChannelEnum::setStrings((const PCString *)this + 2684, &v4, 1);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Box Build Origin Type");
  OZChannelBase::setName((OZChannelBase *)this + 194, &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Box Build Origin Enum");
  OZChannelEnum::setStrings((const PCString *)this + 2716, &v4, 1);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Box Build Style Type");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 21984), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Box Build Style Enum");
  OZChannelEnum::setStrings((const PCString *)this + 2748, &v4, 1);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Open Build Origin Type");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 22240), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Open Build Origin Enum");
  OZChannelEnum::setStrings((const PCString *)this + 2780, &v4, 1);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Closed Build Origin Type");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 22496), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Closed Build Origin Enum");
  OZChannelEnum::setStrings((const PCString *)this + 2812, &v4, 1);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Radial Build Origin Type");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 22752), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Radial Build Origin Type");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 22752), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Radial Build Origin Enum");
  OZChannelEnum::setStrings((const PCString *)this + 2844, &v4, 1);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Build Randomly");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 23008), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Outline Offset");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 23160), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Radius");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 23312), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Point 1");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 23464), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Point 2");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 24352), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Rect Width");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 25240), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Rect Size");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 25392), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Rect Size Width");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 25528), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Rect Size Height");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 25680), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Num Radial Arms");
  OZChannelBase::setName((OZChannelBase *)this + 232, &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Points Per Arm");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 26136), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Spiral Twists");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 26288), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Wave Amplitude");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 26440), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Wave Frequency");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 26592), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Wave Phase");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 26744), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Emit At Alpha");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 27048), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Emit Alpha Cutoff");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 27200), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Geometry Node Ref");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 27352), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Image Node Ref");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 27512), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Multiplier Properties");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 28128), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Scale");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 28864), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Tint Color");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 29760), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Tint Amount");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 30920), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Render Order");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 31072), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Render Order Enum");
  OZChannelEnum::setStrings((const PCString *)this + 3884, &v4, 1);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Reverse Stacking");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 31328), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Fill Points");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 31632), &v4, 0);
  PCString::~PCString(&v4);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Random Fill Seed");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 31784), &v4, 0);
  PCString::~PCString(&v4);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 19232), 6.0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 19744), 1.0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 28256), 0.0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 31632), 1.0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 29456), 0.0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 32792), 0.0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 32944), 0.0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 33200), 0.0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 19232), 0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 19744), 0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 28256), 0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 31632), 0);
  OZChannelBase::reset((OZChannelBase *)this + 263, 0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 32792), 0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 32944), 0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 33200), 0);
  PCURL::PCURL((PCURL *)&v4, @"Replicator Shape Type");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 19232), &v4, 0);
  PCString::~PCString(&v4);
  PSReplicator::updateReplicatorShapeEnum(this, 0);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 19232), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 19232));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 19896), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 19896));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 19744), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 19744));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 28128), 2, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 28128));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 27672), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 27672));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 27976), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 27976));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 31072), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 31072));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 31632), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 31632));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 32944), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 32944));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 6880), 16, 0);
  (*(void (**)(char *))(*((void *)this + 860) + 128))((char *)this + 6880);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 7032), 16, 0);
  return (*(uint64_t (**)(char *))(*((void *)this + 879) + 128))((char *)this + 7032);
}

void sub_1B7DE6BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12)
{
}

void PSReplicator::PSReplicator(PSReplicator *this, const PSReplicator *a2, uint64_t a3)
{
  PSEmitter::PSEmitter(this, a2, a3);
  void *v3 = &unk_1F118ECB8;
  v3[25] = &unk_1F118EF58;
  v3[27] = &unk_1F118F830;
  v3[31] = &unk_1F118FA88;
  v3[841] = &unk_1F118FAE0;
}

uint64_t non-virtual thunk to'PSReplicator::operator=(uint64_t a1, const void *a2)
{
  return PSEmitter::operator=(a1 - 200, a2);
}

void non-virtual thunk to'PSReplicator::~PSReplicator(PSReplicator *this)
{
}

{
  PSEmitter::~PSEmitter((PSReplicator *)((char *)this - 216));
}

{
  PSEmitter::~PSEmitter((PSReplicator *)((char *)this - 248));
}

{
  PSEmitter::~PSEmitter((PSReplicator *)((char *)this - 6728));
}

{
  uint64_t vars8;

  PSEmitter::~PSEmitter((PSReplicator *)((char *)this - 200));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSEmitter::~PSEmitter((PSReplicator *)((char *)this - 216));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSEmitter::~PSEmitter((PSReplicator *)((char *)this - 248));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSEmitter::~PSEmitter((PSReplicator *)((char *)this - 6728));

  JUMPOUT(0x1BA9BFBA0);
}

void PSReplicator::~PSReplicator(PSReplicator *this)
{
  PSEmitter::~PSEmitter(this);

  JUMPOUT(0x1BA9BFBA0);
}

void PSReplicator::updateReplicatorShapeEnum(PSReplicator *this, int a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    PCSharedCount::PCSharedCount(v9);
    OZChannelBase::addToUndo((OZChannelBase *)((char *)this + 19232), (const PCString *)v9);
    PCString::~PCString((PCString *)v9);
  }
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 32792), MEMORY[0x1E4F1FA48], 0.0);
  uint64_t v5 = (PSReplicator *)((char *)this + 19232);
  if (ValueAsInt)
  {
    uint64_t v11 = 0xA0000000BLL;
    *(_OWORD *)&v9[0].$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = xmmword_1B83879D0;
    long long v10 = unk_1B83879E0;
    OZChannelEnum::setTags(v5, (char *)v9, 10);
    PCURL::PCURL((PCURL *)&v8, @"Replicator Shape Enum 3D");
    OZChannelEnum::setStrings((const PCString *)v5, &v8, 1);
    PCString::~PCString(&v8);
    return;
  }
  *(_OWORD *)&v9[0].$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = xmmword_1B83879F8;
  long long v10 = unk_1B8387A08;
  OZChannelEnum::setTags(v5, (char *)v9, 8);
  PCURL::PCURL((PCURL *)&v8, @"Replicator Shape Enum 2D");
  OZChannelEnum::setStrings((const PCString *)v5, &v8, 1);
  PCString::~PCString(&v8);
  if (a2)
  {
    int v6 = OZChannel::getValueAsInt((OZChannel *)v5, MEMORY[0x1E4F1FA48], 0.0);
    if (v6 == 10)
    {
      double v7 = 2.0;
    }
    else
    {
      if (v6 != 11) {
        return;
      }
      double v7 = 6.0;
    }
    OZChannel::setValue((OZChannel *)v5, MEMORY[0x1E4F1FA48], v7, 0);
  }
}

void sub_1B7DE7084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10, char a11)
{
}

void PSReplicator::getIconName(PSReplicator *this@<X0>, PCURL *a2@<X8>)
{
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 32792), MEMORY[0x1E4F1FA48], 0.0)
    && (*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200)
    && (PCString v4 = (OZScene *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200),
        OZScene::getCurrentTime(v4, (__n128 *)&v5),
        PSEmitter::shouldPrecompose(this, &v5)))
  {
    PCURL::PCURL(a2, @"M_LayersList_ObjectIconColor-ReplicatorRasterized");
  }
  else
  {
    (*(void (**)(void))(**((void **)this + 26) + 80))(*((void *)this + 26));
  }
}

void non-virtual thunk to'PSReplicator::getIconName(PSReplicator *this@<X0>, PCURL *a2@<X8>)
{
}

void PSReplicator::getIconNameBW(PSReplicator *this@<X0>, PCURL *a2@<X8>)
{
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 32792), MEMORY[0x1E4F1FA48], 0.0)
    && (*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200)
    && (PCString v4 = (OZScene *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200),
        OZScene::getCurrentTime(v4, (__n128 *)&v5),
        PSEmitter::shouldPrecompose(this, &v5)))
  {
    PCURL::PCURL(a2, @"M_LayersList_ObjectIconGrey-ReplicatorRasterized");
  }
  else
  {
    (*(void (**)(void))(**((void **)this + 26) + 88))(*((void *)this + 26));
  }
}

void non-virtual thunk to'PSReplicator::getIconNameBW(PSReplicator *this@<X0>, PCURL *a2@<X8>)
{
}

uint64_t PSReplicator::getIconID(PSReplicator *this)
{
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 32792), MEMORY[0x1E4F1FA48], 0.0)
    && (*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200)
    && (uint64_t v2 = (OZScene *)(*(uint64_t (**)(char *))(*((void *)this + 25) + 272))((char *)this + 200),
        OZScene::getCurrentTime(v2, (__n128 *)&v4),
        (PSEmitter::shouldPrecompose(this, &v4) & 1) != 0))
  {
    return 30;
  }
  else
  {
    return (*(uint64_t (**)(void))(**((void **)this + 26) + 96))(*((void *)this + 26));
  }
}

uint64_t non-virtual thunk to'PSReplicator::getIconID(PSReplicator *this)
{
  return PSReplicator::getIconID((PSReplicator *)((char *)this - 200));
}

void PSReplicator::updateEmitterHiddenFlags(PSReplicator *this, char a2)
{
  v868[0] = 0;
  v868[1] = 0;
  v867 = (uint64_t *)v868;
  CMTime v4 = (OZChannel *)((char *)this + 19744);
  v864 = (char *)this + 19744;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  CMTime v5 = (char *)this + 19896;
  v864 = (char *)this + 19896;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v858 = (char *)this + 20152;
  v864 = (char *)this + 20152;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v855 = (char *)this + 20304;
  v864 = (char *)this + 20304;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v854 = (char *)this + 20456;
  v864 = (char *)this + 20456;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v849 = (char *)this + 21064;
  v864 = (char *)this + 21064;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v864 = (char *)this + 21216;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v864 = (char *)this + 21472;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v843 = (char *)this + 21472;
  v864 = (char *)this + 22240;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v864 = (char *)this + 22496;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v864 = (char *)this + 22752;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v864 = (char *)this + 23008;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v857 = (char *)this + 23160;
  v864 = (char *)this + 23160;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v850 = (char *)this + 22496;
  v864 = (char *)this + 23312;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  int v6 = (char *)this + 23464;
  v864 = (char *)this + 23464;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v848 = (char *)this + 24352;
  v864 = (char *)this + 24352;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v853 = (char *)this + 25392;
  v864 = (char *)this + 25392;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v852 = (char *)this + 25528;
  v864 = (char *)this + 25528;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v851 = (char *)this + 25680;
  v864 = (char *)this + 25680;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v846 = (char *)this + 25832;
  v864 = (char *)this + 25832;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v844 = (char *)this + 25984;
  v864 = (char *)this + 25984;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v856 = (char *)this + 23312;
  v842 = (char *)this + 26136;
  v864 = (char *)this + 26136;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  double v7 = (char *)this + 26288;
  v864 = (char *)this + 26288;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v841 = (char *)this + 26440;
  v864 = (char *)this + 26440;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v840 = (char *)this + 26592;
  v864 = (char *)this + 26592;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v847 = (char *)this + 22240;
  v839 = (char *)this + 26744;
  v864 = (char *)this + 26744;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  PCString v8 = (char *)this + 27200;
  v864 = (char *)this + 27200;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v845 = (char *)this + 22752;
  long long v9 = (char *)this + 27352;
  v864 = (char *)this + 27352;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  long long v10 = (char *)this + 27512;
  v864 = (char *)this + 27512;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v861 = (OZChannel *)((char *)this + 23008);
  v859 = (char *)this + 31784;
  v864 = (char *)this + 31784;
  std::__tree<OZLocking *>::__emplace_unique_key_args<OZLocking *,OZLocking *>(&v867, (unint64_t *)&v864, (uint64_t *)&v864);
  v864 = 0;
  v865 = 0;
  unint64_t v866 = 0;
  CMTime v863 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19232), &v863, 0.0);
  int v860 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 19896), &v863, 0.0);
  int v12 = OZChannel::getValueAsInt(v4, &v863, 0.0);
  switch(ValueAsInt)
  {
    case 1:
      int v34 = v12;
      OZChannelBase v35 = v865;
      if ((unint64_t)v865 >= v866)
      {
        uint64_t v70 = (v865 - v864) >> 3;
        long long v37 = (OZChannel *)((char *)this + 23008);
        if ((unint64_t)(v70 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v71 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v71 <= v70 + 1) {
          unint64_t v71 = v70 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v72 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v72 = v71;
        }
        if (v72) {
          float64_t v73 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v72);
        }
        else {
          float64_t v73 = 0;
        }
        BOOL v140 = &v73[8 * v70];
        BOOL v141 = &v73[8 * v72];
        *(void *)BOOL v140 = v6;
        CMTime v36 = v140 + 8;
        double v143 = v864;
        uint64_t v142 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v144 = *((void *)v142 - 1);
            v142 -= 8;
            *((void *)v140 - 1) = v144;
            v140 -= 8;
          }
          while (v142 != v143);
          uint64_t v142 = v864;
        }
        v864 = v140;
        v865 = (char *)v36;
        unint64_t v866 = (unint64_t)v141;
        if (v142) {
          operator delete(v142);
        }
      }
      else
      {
        *(void *)v865 = v6;
        CMTime v36 = v35 + 8;
        long long v37 = (OZChannel *)((char *)this + 23008);
      }
      v865 = (char *)v36;
      if ((unint64_t)v36 >= v866)
      {
        uint64_t v146 = ((char *)v36 - v864) >> 3;
        if ((unint64_t)(v146 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v147 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v147 <= v146 + 1) {
          unint64_t v147 = v146 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v148 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v148 = v147;
        }
        if (v148) {
          uint64_t v149 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v148);
        }
        else {
          uint64_t v149 = 0;
        }
        uint64_t v196 = &v149[8 * v146];
        uint64_t v197 = &v149[8 * v148];
        *(void *)uint64_t v196 = v848;
        float64_t v145 = v196 + 8;
        double v199 = v864;
        double v198 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v200 = *((void *)v198 - 1);
            v198 -= 8;
            *((void *)v196 - 1) = v200;
            v196 -= 8;
          }
          while (v198 != v199);
          double v198 = v864;
        }
        v864 = v196;
        v865 = (char *)v145;
        unint64_t v866 = (unint64_t)v197;
        if (v198) {
          operator delete(v198);
        }
      }
      else
      {
        void *v36 = v848;
        float64_t v145 = v36 + 1;
      }
      v865 = (char *)v145;
      unint64_t v201 = v866;
      if (v34)
      {
        if ((unint64_t)v145 >= v866)
        {
          uint64_t v203 = ((char *)v145 - v864) >> 3;
          if ((unint64_t)(v203 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v204 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v204 <= v203 + 1) {
            unint64_t v204 = v203 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v205 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v205 = v204;
          }
          if (v205) {
            long long v206 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v205);
          }
          else {
            long long v206 = 0;
          }
          unint64_t v352 = &v206[8 * v203];
          unint64_t v353 = &v206[8 * v205];
          *(void *)unint64_t v352 = v858;
          double v202 = v352 + 8;
          v355 = v864;
          v354 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v356 = *((void *)v354 - 1);
              v354 -= 8;
              *((void *)v352 - 1) = v356;
              v352 -= 8;
            }
            while (v354 != v355);
            v354 = v864;
          }
          v864 = v352;
          v865 = (char *)v202;
          unint64_t v866 = (unint64_t)v353;
          if (v354) {
            operator delete(v354);
          }
        }
        else
        {
          void *v145 = v858;
          double v202 = v145 + 1;
        }
        v865 = (char *)v202;
        if ((unint64_t)v202 >= v866)
        {
          uint64_t v357 = ((char *)v202 - v864) >> 3;
          if ((unint64_t)(v357 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v358 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v358 <= v357 + 1) {
            unint64_t v358 = v357 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v359 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v359 = v358;
          }
          if (v359) {
            v360 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v359);
          }
          else {
            v360 = 0;
          }
          v391 = &v360[8 * v357];
          uint64_t v392 = &v360[8 * v359];
          *(void *)v391 = v857;
          float64_t v145 = v391 + 8;
          v394 = v864;
          v393 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v395 = *((void *)v393 - 1);
              v393 -= 8;
              *((void *)v391 - 1) = v395;
              v391 -= 8;
            }
            while (v393 != v394);
            v393 = v864;
          }
          v864 = v391;
          v865 = (char *)v145;
          unint64_t v866 = (unint64_t)v392;
          if (v393) {
            operator delete(v393);
          }
        }
        else
        {
          *double v202 = v857;
          float64_t v145 = v202 + 1;
        }
        v865 = (char *)v145;
        unint64_t v201 = v866;
      }
      if ((unint64_t)v145 >= v201)
      {
        uint64_t v397 = ((char *)v145 - v864) >> 3;
        if ((unint64_t)(v397 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v398 = v201 - (void)v864;
        uint64_t v399 = v398 >> 2;
        if (v398 >> 2 <= (unint64_t)(v397 + 1)) {
          uint64_t v399 = v397 + 1;
        }
        if ((unint64_t)v398 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v400 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v400 = v399;
        }
        if (v400) {
          v401 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v400);
        }
        else {
          v401 = 0;
        }
        v402 = &v401[8 * v397];
        uint64_t v403 = &v401[8 * v400];
        *(void *)v402 = v847;
        v396 = (OZChannel **)(v402 + 8);
        uint64_t v405 = v864;
        v404 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v406 = *((void *)v404 - 1);
            v404 -= 8;
            *((void *)v402 - 1) = v406;
            v402 -= 8;
          }
          while (v404 != v405);
          v404 = v864;
        }
        v864 = v402;
        v865 = (char *)v396;
        unint64_t v866 = (unint64_t)v403;
        if (v404) {
          operator delete(v404);
        }
      }
      else
      {
        void *v145 = v847;
        v396 = (OZChannel **)(v145 + 1);
      }
      v865 = (char *)v396;
      if ((unint64_t)v396 >= v866)
      {
        uint64_t v408 = ((char *)v396 - v864) >> 3;
        if ((unint64_t)(v408 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v409 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v409 <= v408 + 1) {
          unint64_t v409 = v408 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v410 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v410 = v409;
        }
        if (v410) {
          v411 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v410);
        }
        else {
          v411 = 0;
        }
        v412 = (OZChannel **)&v411[8 * v408];
        v413 = &v411[8 * v410];
        char *v412 = v37;
        v407 = (char *)(v412 + 1);
        v415 = v864;
        v414 = v865;
        if (v865 != v864)
        {
          do
          {
            v416 = (OZChannel *)*((void *)v414 - 1);
            v414 -= 8;
            *--v412 = v416;
          }
          while (v414 != v415);
          v414 = v864;
        }
        v864 = (char *)v412;
        v865 = v407;
        unint64_t v866 = (unint64_t)v413;
        if (v414) {
          operator delete(v414);
        }
      }
      else
      {
        char *v396 = v37;
        v407 = (char *)(v396 + 1);
      }
      v865 = v407;
      if (OZChannel::getValueAsInt(v37, MEMORY[0x1E4F1FA48], 0.0))
      {
        double v124 = v865;
        if ((unint64_t)v865 < v866) {
          goto LABEL_1144;
        }
        uint64_t v417 = (v865 - v864) >> 3;
        if ((unint64_t)(v417 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v418 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v418 <= v417 + 1) {
          unint64_t v418 = v417 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v419 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v419 = v418;
        }
        if (v419) {
          uint64_t v420 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v419);
        }
        else {
          uint64_t v420 = 0;
        }
        v421 = &v420[8 * v417];
        uint64_t v422 = &v420[8 * v419];
        *(void *)v421 = v859;
        unint64_t v423 = v421 + 8;
        v427 = v864;
        unint64_t v424 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v428 = *((void *)v424 - 1);
            v424 -= 8;
            *((void *)v421 - 1) = v428;
            v421 -= 8;
          }
          while (v424 != v427);
          goto LABEL_1195;
        }
        goto LABEL_1196;
      }
      goto LABEL_1199;
    case 2:
      int v24 = v12;
      CMTime v25 = v865;
      if ((unint64_t)v865 >= v866)
      {
        uint64_t v58 = (v865 - v864) >> 3;
        CMTime v27 = (OZChannel *)((char *)this + 23008);
        int v28 = v860;
        if ((unint64_t)(v58 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v59 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v59 <= v58 + 1) {
          unint64_t v59 = v58 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v60 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v60 = v59;
        }
        if (v60) {
          uint64_t v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v60);
        }
        else {
          uint64_t v61 = 0;
        }
        CMTime v109 = &v61[8 * v58];
        uint64_t v110 = &v61[8 * v60];
        *(void *)CMTime v109 = v5;
        CMTime v26 = v109 + 8;
        float64x2_t v112 = v864;
        int v111 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v113 = *((void *)v111 - 1);
            v111 -= 8;
            *((void *)v109 - 1) = v113;
            v109 -= 8;
          }
          while (v111 != v112);
          int v111 = v864;
        }
        v864 = v109;
        v865 = v26;
        unint64_t v866 = (unint64_t)v110;
        if (v111) {
          operator delete(v111);
        }
      }
      else
      {
        *(void *)v865 = v5;
        CMTime v26 = v25 + 8;
        CMTime v27 = (OZChannel *)((char *)this + 23008);
        int v28 = v860;
      }
      v865 = v26;
      if ((unint64_t)v26 >= v866)
      {
        uint64_t v115 = (v26 - v864) >> 3;
        if ((unint64_t)(v115 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v116 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v116 <= v115 + 1) {
          unint64_t v116 = v115 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v117 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v117 = v116;
        }
        if (v117) {
          double v118 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v117);
        }
        else {
          double v118 = 0;
        }
        float64_t v161 = &v118[8 * v115];
        float64_t v162 = &v118[8 * v117];
        *(void *)float64_t v161 = v856;
        int v114 = v161 + 8;
        __double2 v164 = v864;
        int v163 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v165 = *((void *)v163 - 1);
            v163 -= 8;
            *((void *)v161 - 1) = v165;
            v161 -= 8;
          }
          while (v163 != v164);
          int v163 = v864;
        }
        v864 = v161;
        v865 = v114;
        unint64_t v866 = (unint64_t)v162;
        if (v163) {
          operator delete(v163);
        }
      }
      else
      {
        *(void *)CMTime v26 = v856;
        int v114 = v26 + 8;
      }
      v865 = v114;
      switch(v28)
      {
        case 2:
          if (v24)
          {
            v862 = (OZChannelBase *)((char *)this + 20152);
            std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v864, &v862);
            int v114 = v865;
          }
          if ((unint64_t)v114 >= v866)
          {
            uint64_t v327 = (v114 - v864) >> 3;
            if ((unint64_t)(v327 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v328 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v328 <= v327 + 1) {
              unint64_t v328 = v327 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v329 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v329 = v328;
            }
            if (v329) {
              CMTime v330 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v329);
            }
            else {
              CMTime v330 = 0;
            }
            v662 = &v330[8 * v327];
            v663 = &v330[8 * v329];
            *(void *)v662 = v845;
            float64_t v168 = (OZChannel **)(v662 + 8);
            v665 = v864;
            v664 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v666 = *((void *)v664 - 1);
                v664 -= 8;
                *((void *)v662 - 1) = v666;
                v662 -= 8;
              }
              while (v664 != v665);
              v664 = v864;
            }
            v864 = v662;
            v865 = (char *)v168;
            unint64_t v866 = (unint64_t)v663;
            if (v664) {
              operator delete(v664);
            }
          }
          else
          {
            *(void *)int v114 = v845;
            float64_t v168 = (OZChannel **)(v114 + 8);
          }
          v865 = (char *)v168;
          if ((unint64_t)v168 >= v866)
          {
            uint64_t v667 = ((char *)v168 - v864) >> 3;
            if ((unint64_t)(v667 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v668 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v668 <= v667 + 1) {
              unint64_t v668 = v667 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v669 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v669 = v668;
            }
            if (v669) {
              v670 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v669);
            }
            else {
              v670 = 0;
            }
            v702 = (OZChannel **)&v670[8 * v667];
            v703 = &v670[8 * v669];
            *v702 = v27;
            double v124 = (char *)(v702 + 1);
            v705 = v864;
            v704 = v865;
            if (v865 != v864)
            {
              do
              {
                v706 = (OZChannel *)*((void *)v704 - 1);
                v704 -= 8;
                *--v702 = v706;
              }
              while (v704 != v705);
              v704 = v864;
            }
            v864 = (char *)v702;
            v865 = v124;
            unint64_t v866 = (unint64_t)v703;
            if (v704) {
              operator delete(v704);
            }
          }
          else
          {
            *float64_t v168 = v27;
            double v124 = (char *)(v168 + 1);
          }
          v865 = v124;
          if ((unint64_t)v124 < v866) {
            goto LABEL_1144;
          }
          uint64_t v707 = (v124 - v864) >> 3;
          if ((unint64_t)(v707 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v708 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v708 <= v707 + 1) {
            unint64_t v708 = v707 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v709 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v709 = v708;
          }
          if (v709) {
            v710 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v709);
          }
          else {
            v710 = 0;
          }
          v421 = &v710[8 * v707];
          uint64_t v422 = &v710[8 * v709];
          *(void *)v421 = v859;
          unint64_t v423 = v421 + 8;
          v733 = v864;
          unint64_t v424 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v734 = *((void *)v424 - 1);
              v424 -= 8;
              *((void *)v421 - 1) = v734;
              v421 -= 8;
            }
            while (v424 != v733);
            goto LABEL_1195;
          }
          goto LABEL_1196;
        case 1:
          if ((unint64_t)v114 >= v866)
          {
            uint64_t v311 = (v114 - v864) >> 3;
            float64_t v167 = (char *)this + 22752;
            if ((unint64_t)(v311 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v312 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v312 <= v311 + 1) {
              unint64_t v312 = v311 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v313 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v313 = v312;
            }
            if (v313) {
              double v314 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v313);
            }
            else {
              double v314 = 0;
            }
            v622 = &v314[8 * v311];
            v623 = &v314[8 * v313];
            *(void *)v622 = v855;
            float64_t v166 = v622 + 8;
            v625 = v864;
            v624 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v626 = *((void *)v624 - 1);
                v624 -= 8;
                *((void *)v622 - 1) = v626;
                v622 -= 8;
              }
              while (v624 != v625);
              v624 = v864;
            }
            v864 = v622;
            v865 = (char *)v166;
            unint64_t v866 = (unint64_t)v623;
            if (v624) {
              operator delete(v624);
            }
          }
          else
          {
            *(void *)int v114 = v855;
            float64_t v166 = v114 + 8;
            float64_t v167 = (char *)this + 22752;
          }
          v865 = (char *)v166;
          if ((unint64_t)v166 >= v866)
          {
            uint64_t v628 = ((char *)v166 - v864) >> 3;
            if ((unint64_t)(v628 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v629 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v629 <= v628 + 1) {
              unint64_t v629 = v628 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v630 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v630 = v629;
            }
            if (v630) {
              v631 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v630);
            }
            else {
              v631 = 0;
            }
            v671 = &v631[8 * v628];
            v672 = &v631[8 * v630];
            *(void *)v671 = v854;
            v627 = v671 + 8;
            v674 = v864;
            v673 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v675 = *((void *)v673 - 1);
                v673 -= 8;
                *((void *)v671 - 1) = v675;
                v671 -= 8;
              }
              while (v673 != v674);
              v673 = v864;
            }
            v864 = v671;
            v865 = (char *)v627;
            unint64_t v866 = (unint64_t)v672;
            if (v673) {
              operator delete(v673);
            }
          }
          else
          {
            void *v166 = v854;
            v627 = v166 + 1;
          }
          v865 = (char *)v627;
          if ((unint64_t)v627 >= v866)
          {
            uint64_t v677 = ((char *)v627 - v864) >> 3;
            if ((unint64_t)(v677 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v678 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v678 <= v677 + 1) {
              unint64_t v678 = v677 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v679 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v679 = v678;
            }
            if (v679) {
              v680 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v679);
            }
            else {
              v680 = 0;
            }
            v711 = &v680[8 * v677];
            v712 = &v680[8 * v679];
            *(void *)v711 = v849;
            v676 = v711 + 8;
            v714 = v864;
            v713 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v715 = *((void *)v713 - 1);
                v713 -= 8;
                *((void *)v711 - 1) = v715;
                v711 -= 8;
              }
              while (v713 != v714);
              v713 = v864;
            }
            v864 = v711;
            v865 = (char *)v676;
            unint64_t v866 = (unint64_t)v712;
            if (v713) {
              operator delete(v713);
            }
          }
          else
          {
            void *v627 = v849;
            v676 = v627 + 1;
          }
          v865 = (char *)v676;
          if ((unint64_t)v676 >= v866)
          {
            uint64_t v717 = ((char *)v676 - v864) >> 3;
            if ((unint64_t)(v717 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v718 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v718 <= v717 + 1) {
              unint64_t v718 = v717 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v719 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v719 = v718;
            }
            if (v719) {
              v720 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v719);
            }
            else {
              v720 = 0;
            }
            v752 = &v720[8 * v717];
            v753 = &v720[8 * v719];
            *(void *)v752 = v167;
            v716 = (OZChannel **)(v752 + 8);
            v755 = v864;
            v754 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v756 = *((void *)v754 - 1);
                v754 -= 8;
                *((void *)v752 - 1) = v756;
                v752 -= 8;
              }
              while (v754 != v755);
              v754 = v864;
            }
            v864 = v752;
            v865 = (char *)v716;
            unint64_t v866 = (unint64_t)v753;
            if (v754) {
              operator delete(v754);
            }
          }
          else
          {
            void *v676 = v167;
            v716 = (OZChannel **)(v676 + 1);
          }
          v865 = (char *)v716;
          if ((unint64_t)v716 >= v866)
          {
            uint64_t v758 = ((char *)v716 - v864) >> 3;
            if ((unint64_t)(v758 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v759 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v759 <= v758 + 1) {
              unint64_t v759 = v758 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v760 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v760 = v759;
            }
            if (v760) {
              v761 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v760);
            }
            else {
              v761 = 0;
            }
            v787 = (OZChannel **)&v761[8 * v758];
            v788 = &v761[8 * v760];
            *v787 = v27;
            v757 = (char *)(v787 + 1);
            v790 = v864;
            v789 = v865;
            if (v865 != v864)
            {
              do
              {
                v791 = (OZChannel *)*((void *)v789 - 1);
                v789 -= 8;
                *--v787 = v791;
              }
              while (v789 != v790);
              v789 = v864;
            }
            v864 = (char *)v787;
            v865 = v757;
            unint64_t v866 = (unint64_t)v788;
            if (v789) {
              operator delete(v789);
            }
          }
          else
          {
            *v716 = v27;
            v757 = (char *)(v716 + 1);
          }
          v865 = v757;
          if (OZChannel::getValueAsInt(v27, MEMORY[0x1E4F1FA48], 0.0)) {
            goto LABEL_1364;
          }
          break;
        case 0:
          if (v24)
          {
            v862 = (OZChannelBase *)((char *)this + 20152);
            std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v864, &v862);
            v862 = (OZChannelBase *)((char *)this + 23160);
            std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v864, &v862);
            v862 = (OZChannelBase *)((char *)this + 22496);
            std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v864, &v862);
            v862 = (OZChannelBase *)v27;
            std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v864, &v862);
            if (OZChannel::getValueAsInt(v27, MEMORY[0x1E4F1FA48], 0.0)) {
              goto LABEL_1364;
            }
          }
          break;
      }
      goto LABEL_1199;
    case 4:
      int v20 = v12;
      unsigned int v21 = v865;
      if ((unint64_t)v865 >= v866)
      {
        uint64_t v54 = (v865 - v864) >> 3;
        uint64_t v23 = (OZChannel *)((char *)this + 23008);
        if ((unint64_t)(v54 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v55 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v55 <= v54 + 1) {
          unint64_t v55 = v54 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v56 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v56 = v55;
        }
        if (v56) {
          OZRenderState v57 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v56);
        }
        else {
          OZRenderState v57 = 0;
        }
        long long v99 = &v57[8 * v54];
        float64x2_t v100 = &v57[8 * v56];
        *(void *)long long v99 = v9;
        uint64_t v22 = (OZChannel **)(v99 + 8);
        float64x2_t v102 = v864;
        float64x2_t v101 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v103 = *((void *)v101 - 1);
            v101 -= 8;
            *((void *)v99 - 1) = v103;
            v99 -= 8;
          }
          while (v101 != v102);
          float64x2_t v101 = v864;
        }
        v864 = v99;
        v865 = (char *)v22;
        unint64_t v866 = (unint64_t)v100;
        if (v101) {
          operator delete(v101);
        }
      }
      else
      {
        *(void *)v865 = v9;
        uint64_t v22 = (OZChannel **)(v21 + 8);
        uint64_t v23 = (OZChannel *)((char *)this + 23008);
      }
      v865 = (char *)v22;
      if ((unint64_t)v22 >= v866)
      {
        uint64_t v105 = ((char *)v22 - v864) >> 3;
        if ((unint64_t)(v105 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v106 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v106 <= v105 + 1) {
          unint64_t v106 = v105 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v107 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v107 = v106;
        }
        if (v107) {
          double v108 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v107);
        }
        else {
          double v108 = 0;
        }
        uint64_t v150 = (OZChannel **)&v108[8 * v105];
        unsigned int v151 = &v108[8 * v107];
        *uint64_t v150 = v4;
        long long v104 = v150 + 1;
        int v153 = v864;
        double v152 = v865;
        if (v865 != v864)
        {
          do
          {
            int64x2_t v154 = (OZChannel *)*((void *)v152 - 1);
            v152 -= 8;
            *--uint64_t v150 = v154;
          }
          while (v152 != v153);
          double v152 = v864;
        }
        v864 = (char *)v150;
        v865 = (char *)v104;
        unint64_t v866 = (unint64_t)v151;
        if (v152) {
          operator delete(v152);
        }
      }
      else
      {
        *uint64_t v22 = v4;
        long long v104 = v22 + 1;
      }
      v865 = (char *)v104;
      unint64_t v155 = v866;
      if (v20)
      {
        if ((unint64_t)v104 >= v866)
        {
          uint64_t v157 = ((char *)v104 - v864) >> 3;
          if ((unint64_t)(v157 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v158 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v158 <= v157 + 1) {
            unint64_t v158 = v157 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v159 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v159 = v158;
          }
          if (v159) {
            float64_t v160 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v159);
          }
          else {
            float64_t v160 = 0;
          }
          v343 = &v160[8 * v157];
          v344 = &v160[8 * v159];
          *(void *)v343 = v858;
          uint64_t v156 = v343 + 8;
          v346 = v864;
          v345 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v347 = *((void *)v345 - 1);
              v345 -= 8;
              *((void *)v343 - 1) = v347;
              v343 -= 8;
            }
            while (v345 != v346);
            v345 = v864;
          }
          v864 = v343;
          v865 = (char *)v156;
          unint64_t v866 = (unint64_t)v344;
          if (v345) {
            operator delete(v345);
          }
        }
        else
        {
          *long long v104 = v858;
          uint64_t v156 = v104 + 1;
        }
        v865 = (char *)v156;
        if ((unint64_t)v156 >= v866)
        {
          uint64_t v348 = ((char *)v156 - v864) >> 3;
          if ((unint64_t)(v348 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v349 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v349 <= v348 + 1) {
            unint64_t v349 = v348 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v350 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v350 = v349;
          }
          if (v350) {
            uint64_t v351 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v350);
          }
          else {
            uint64_t v351 = 0;
          }
          uint64_t v361 = &v351[8 * v348];
          unint64_t v362 = &v351[8 * v350];
          *(void *)uint64_t v361 = v857;
          long long v104 = v361 + 8;
          v364 = v864;
          unint64_t v363 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v365 = *((void *)v363 - 1);
              v363 -= 8;
              *((void *)v361 - 1) = v365;
              v361 -= 8;
            }
            while (v363 != v364);
            unint64_t v363 = v864;
          }
          v864 = v361;
          v865 = (char *)v104;
          unint64_t v866 = (unint64_t)v362;
          if (v363) {
            operator delete(v363);
          }
        }
        else
        {
          void *v156 = v857;
          long long v104 = v156 + 1;
        }
        v865 = (char *)v104;
        unint64_t v155 = v866;
      }
      if ((unint64_t)v104 >= v155)
      {
        uint64_t v367 = ((char *)v104 - v864) >> 3;
        if ((unint64_t)(v367 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v368 = v155 - (void)v864;
        uint64_t v369 = v368 >> 2;
        if (v368 >> 2 <= (unint64_t)(v367 + 1)) {
          uint64_t v369 = v367 + 1;
        }
        if ((unint64_t)v368 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v370 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v370 = v369;
        }
        if (v370) {
          uint64_t v371 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v370);
        }
        else {
          uint64_t v371 = 0;
        }
        unint64_t v372 = &v371[8 * v367];
        unint64_t v373 = &v371[8 * v370];
        *(void *)unint64_t v372 = v850;
        v366 = (OZChannel **)(v372 + 8);
        v375 = v864;
        v374 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v376 = *((void *)v374 - 1);
            v374 -= 8;
            *((void *)v372 - 1) = v376;
            v372 -= 8;
          }
          while (v374 != v375);
          v374 = v864;
        }
        v864 = v372;
        v865 = (char *)v366;
        unint64_t v866 = (unint64_t)v373;
        if (v374) {
          operator delete(v374);
        }
      }
      else
      {
        *long long v104 = v850;
        v366 = (OZChannel **)(v104 + 1);
      }
      v865 = (char *)v366;
      if ((unint64_t)v366 >= v866)
      {
        uint64_t v378 = ((char *)v366 - v864) >> 3;
        if ((unint64_t)(v378 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v379 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v379 <= v378 + 1) {
          unint64_t v379 = v378 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v380 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v380 = v379;
        }
        if (v380) {
          uint64_t v381 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v380);
        }
        else {
          uint64_t v381 = 0;
        }
        v382 = (OZChannel **)&v381[8 * v378];
        v383 = &v381[8 * v380];
        char *v382 = v23;
        v377 = (char *)(v382 + 1);
        v385 = v864;
        v384 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v386 = (OZChannel *)*((void *)v384 - 1);
            v384 -= 8;
            *--v382 = v386;
          }
          while (v384 != v385);
          v384 = v864;
        }
        v864 = (char *)v382;
        v865 = v377;
        unint64_t v866 = (unint64_t)v383;
        if (v384) {
          operator delete(v384);
        }
      }
      else
      {
        char *v366 = v23;
        v377 = (char *)(v366 + 1);
      }
      v865 = v377;
      if (OZChannel::getValueAsInt(v23, MEMORY[0x1E4F1FA48], 0.0))
      {
        double v124 = v865;
        if ((unint64_t)v865 < v866) {
          goto LABEL_1144;
        }
        uint64_t v387 = (v865 - v864) >> 3;
        if ((unint64_t)(v387 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v388 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v388 <= v387 + 1) {
          unint64_t v388 = v387 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v389 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v389 = v388;
        }
        if (v389) {
          v390 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v389);
        }
        else {
          v390 = 0;
        }
        v421 = &v390[8 * v387];
        uint64_t v422 = &v390[8 * v389];
        *(void *)v421 = v859;
        unint64_t v423 = v421 + 8;
        v425 = v864;
        unint64_t v424 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v426 = *((void *)v424 - 1);
            v424 -= 8;
            *((void *)v421 - 1) = v426;
            v421 -= 8;
          }
          while (v424 != v425);
          goto LABEL_1195;
        }
        goto LABEL_1196;
      }
      goto LABEL_1199;
    case 5:
    case 6:
    case 12:
      int v13 = v12;
      uint64_t v14 = v865;
      if ((unint64_t)v865 >= v866)
      {
        uint64_t v16 = (v865 - v864) >> 3;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v17 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v17 <= v16 + 1) {
          unint64_t v17 = v16 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v17;
        }
        if (v18) {
          uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v18);
        }
        else {
          uint64_t v19 = 0;
        }
        CMTime v41 = &v19[8 * v16];
        CMTime v42 = &v19[8 * v18];
        *(void *)CMTime v41 = v5;
        unsigned int v15 = v41 + 8;
        CMTime v44 = v864;
        uint64_t v43 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v45 = *((void *)v43 - 1);
            v43 -= 8;
            *((void *)v41 - 1) = v45;
            v41 -= 8;
          }
          while (v43 != v44);
          uint64_t v43 = v864;
        }
        v864 = v41;
        v865 = (char *)v15;
        unint64_t v866 = (unint64_t)v42;
        if (v43) {
          operator delete(v43);
        }
      }
      else
      {
        *(void *)v865 = v5;
        unsigned int v15 = v14 + 8;
      }
      v865 = (char *)v15;
      if (ValueAsInt == 12 || ValueAsInt == 5)
      {
        if ((unint64_t)v15 >= v866)
        {
          uint64_t v49 = ((char *)v15 - v864) >> 3;
          uint64_t v47 = (OZChannel *)((char *)this + 23008);
          if ((unint64_t)(v49 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v50 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v50 <= v49 + 1) {
            unint64_t v50 = v49 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v51 = v50;
          }
          if (v51) {
            long long v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v51);
          }
          else {
            long long v52 = 0;
          }
          int v80 = &v52[8 * v49];
          double v81 = &v52[8 * v51];
          *(void *)int v80 = v10;
          int v46 = v80 + 8;
          double v83 = v864;
          double v82 = v865;
          if (v865 == v864)
          {
            int v48 = v860;
          }
          else
          {
            int v48 = v860;
            do
            {
              uint64_t v84 = *((void *)v82 - 1);
              v82 -= 8;
              *((void *)v80 - 1) = v84;
              v80 -= 8;
            }
            while (v82 != v83);
            double v82 = v864;
          }
          v864 = v80;
          v865 = (char *)v46;
          unint64_t v866 = (unint64_t)v81;
          if (v82) {
            operator delete(v82);
          }
        }
        else
        {
          void *v15 = v10;
          int v46 = v15 + 1;
          uint64_t v47 = (OZChannel *)((char *)this + 23008);
          int v48 = v860;
        }
        v865 = (char *)v46;
        if ((unint64_t)v46 < v866)
        {
          *int v46 = v8;
          double v85 = v46 + 1;
          goto LABEL_343;
        }
        uint64_t v86 = ((char *)v46 - v864) >> 3;
        if ((unint64_t)(v86 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v87 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v87 <= v86 + 1) {
          unint64_t v87 = v86 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v88 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v88 = v87;
        }
        if (v88) {
          CMTime v89 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v88);
        }
        else {
          CMTime v89 = 0;
        }
        double v90 = &v89[8 * v86];
        uint64_t v91 = &v89[8 * v88];
        *(void *)double v90 = v8;
        double v85 = v90 + 8;
        uint64_t v93 = v864;
        OZRenderState v92 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v94 = *((void *)v92 - 1);
            v92 -= 8;
            *((void *)v90 - 1) = v94;
            v90 -= 8;
          }
          while (v92 != v93);
LABEL_340:
          OZRenderState v92 = v864;
        }
      }
      else
      {
        if ((unint64_t)v15 >= v866)
        {
          uint64_t v76 = ((char *)v15 - v864) >> 3;
          int v48 = v860;
          if ((unint64_t)(v76 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v77 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v77 <= v76 + 1) {
            unint64_t v77 = v76 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v78 = v77;
          }
          uint64_t v47 = (OZChannel *)((char *)this + 23008);
          if (v78) {
            int v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v78);
          }
          else {
            int v79 = 0;
          }
          signed int v169 = &v79[8 * v76];
          float64_t v170 = &v79[8 * v78];
          *(void *)signed int v169 = v853;
          uint64_t v53 = v169 + 8;
          double v172 = v864;
          int v171 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v173 = *((void *)v171 - 1);
              v171 -= 8;
              *((void *)v169 - 1) = v173;
              v169 -= 8;
            }
            while (v171 != v172);
            int v171 = v864;
          }
          v864 = v169;
          v865 = (char *)v53;
          unint64_t v866 = (unint64_t)v170;
          if (v171) {
            operator delete(v171);
          }
        }
        else
        {
          void *v15 = v853;
          uint64_t v53 = v15 + 1;
          uint64_t v47 = (OZChannel *)((char *)this + 23008);
          int v48 = v860;
        }
        v865 = (char *)v53;
        if ((unint64_t)v53 >= v866)
        {
          uint64_t v175 = ((char *)v53 - v864) >> 3;
          if ((unint64_t)(v175 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v176 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v176 <= v175 + 1) {
            unint64_t v176 = v175 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v177 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v177 = v176;
          }
          if (v177) {
            double v178 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v177);
          }
          else {
            double v178 = 0;
          }
          unsigned int v207 = &v178[8 * v175];
          float64x2_t v208 = &v178[8 * v177];
          *(void *)unsigned int v207 = v852;
          int v174 = v207 + 8;
          float64_t v210 = v864;
          float64x2_t v209 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v211 = *((void *)v209 - 1);
              v209 -= 8;
              *((void *)v207 - 1) = v211;
              v207 -= 8;
            }
            while (v209 != v210);
            float64x2_t v209 = v864;
          }
          v864 = v207;
          v865 = (char *)v174;
          unint64_t v866 = (unint64_t)v208;
          if (v209) {
            operator delete(v209);
          }
        }
        else
        {
          void *v53 = v852;
          int v174 = v53 + 1;
        }
        v865 = (char *)v174;
        if ((unint64_t)v174 < v866)
        {
          void *v174 = v851;
          double v85 = v174 + 1;
          goto LABEL_343;
        }
        uint64_t v212 = ((char *)v174 - v864) >> 3;
        if ((unint64_t)(v212 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v213 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v213 <= v212 + 1) {
          unint64_t v213 = v212 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v214 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v214 = v213;
        }
        if (v214) {
          float64x2_t v215 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v214);
        }
        else {
          float64x2_t v215 = 0;
        }
        double v90 = &v215[8 * v212];
        uint64_t v91 = &v215[8 * v214];
        *(void *)double v90 = v851;
        double v85 = v90 + 8;
        char v226 = v864;
        OZRenderState v92 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v227 = *((void *)v92 - 1);
            v92 -= 8;
            *((void *)v90 - 1) = v227;
            v90 -= 8;
          }
          while (v92 != v226);
          goto LABEL_340;
        }
      }
      v864 = v90;
      v865 = (char *)v85;
      unint64_t v866 = (unint64_t)v91;
      if (v92) {
        operator delete(v92);
      }
LABEL_343:
      v865 = (char *)v85;
      if (v48)
      {
        if (v48 == 2)
        {
          unint64_t v230 = v866;
          if (v13)
          {
            if ((unint64_t)v85 >= v866)
            {
              uint64_t v239 = ((char *)v85 - v864) >> 3;
              if ((unint64_t)(v239 + 1) >> 61) {
                std::vector<double>::__throw_length_error[abi:ne180100]();
              }
              unint64_t v240 = (uint64_t)(v866 - (void)v864) >> 2;
              if (v240 <= v239 + 1) {
                unint64_t v240 = v239 + 1;
              }
              if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v241 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v241 = v240;
              }
              PCSharedCount v231 = (char *)this + 21216;
              if (v241) {
                unsigned int v242 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v241);
              }
              else {
                unsigned int v242 = 0;
              }
              v440 = &v242[8 * v239];
              uint64_t v441 = &v242[8 * v241];
              *(void *)v440 = v858;
              double v85 = v440 + 8;
              unint64_t v443 = v864;
              uint64_t v442 = v865;
              if (v865 != v864)
              {
                do
                {
                  uint64_t v444 = *((void *)v442 - 1);
                  v442 -= 8;
                  *((void *)v440 - 1) = v444;
                  v440 -= 8;
                }
                while (v442 != v443);
                uint64_t v442 = v864;
              }
              v864 = v440;
              v865 = (char *)v85;
              unint64_t v866 = (unint64_t)v441;
              if (v442) {
                operator delete(v442);
              }
            }
            else
            {
              *v85++ = v858;
              PCSharedCount v231 = (char *)this + 21216;
            }
            v865 = (char *)v85;
            unint64_t v230 = v866;
          }
          else
          {
            PCSharedCount v231 = (char *)this + 21216;
          }
          if ((unint64_t)v85 >= v230)
          {
            uint64_t v446 = ((char *)v85 - v864) >> 3;
            if ((unint64_t)(v446 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v447 = v230 - (void)v864;
            uint64_t v448 = v447 >> 2;
            if (v447 >> 2 <= (unint64_t)(v446 + 1)) {
              uint64_t v448 = v446 + 1;
            }
            if ((unint64_t)v447 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v449 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v449 = v448;
            }
            if (v449) {
              v450 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v449);
            }
            else {
              v450 = 0;
            }
            uint64_t v451 = &v450[8 * v446];
            unint64_t v452 = &v450[8 * v449];
            *(void *)uint64_t v451 = v231;
            v445 = (OZChannel **)(v451 + 8);
            v454 = v864;
            unint64_t v453 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v455 = *((void *)v453 - 1);
                v453 -= 8;
                *((void *)v451 - 1) = v455;
                v451 -= 8;
              }
              while (v453 != v454);
              unint64_t v453 = v864;
            }
            v864 = v451;
            v865 = (char *)v445;
            unint64_t v866 = (unint64_t)v452;
            if (v453) {
              operator delete(v453);
            }
          }
          else
          {
            void *v85 = v231;
            v445 = (OZChannel **)(v85 + 1);
          }
          v865 = (char *)v445;
          if ((unint64_t)v445 >= v866)
          {
            uint64_t v457 = ((char *)v445 - v864) >> 3;
            if ((unint64_t)(v457 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v458 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v458 <= v457 + 1) {
              unint64_t v458 = v457 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v459 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v459 = v458;
            }
            if (v459) {
              v460 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v459);
            }
            else {
              v460 = 0;
            }
            uint64_t v461 = (OZChannel **)&v460[8 * v457];
            unint64_t v462 = &v460[8 * v459];
            *uint64_t v461 = v47;
            v456 = (char *)(v461 + 1);
            v464 = v864;
            unint64_t v463 = v865;
            if (v865 != v864)
            {
              do
              {
                v465 = (OZChannel *)*((void *)v463 - 1);
                v463 -= 8;
                *--uint64_t v461 = v465;
              }
              while (v463 != v464);
              unint64_t v463 = v864;
            }
            v864 = (char *)v461;
            v865 = v456;
            unint64_t v866 = (unint64_t)v462;
            if (v463) {
              operator delete(v463);
            }
          }
          else
          {
            char *v445 = v47;
            v456 = (char *)(v445 + 1);
          }
          v865 = v456;
          if ((unint64_t)v456 >= v866)
          {
            uint64_t v467 = (v456 - v864) >> 3;
            if ((unint64_t)(v467 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v468 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v468 <= v467 + 1) {
              unint64_t v468 = v467 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v469 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v469 = v468;
            }
            if (v469) {
              v470 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v469);
            }
            else {
              v470 = 0;
            }
            uint64_t v471 = &v470[8 * v467];
            unint64_t v472 = &v470[8 * v469];
            *(void *)uint64_t v471 = v859;
            v466 = v471 + 8;
            v474 = v864;
            unint64_t v473 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v475 = *((void *)v473 - 1);
                v473 -= 8;
                *((void *)v471 - 1) = v475;
                v471 -= 8;
              }
              while (v473 != v474);
              unint64_t v473 = v864;
            }
            v864 = v471;
            v865 = v466;
            unint64_t v866 = (unint64_t)v472;
            if (v473) {
              operator delete(v473);
            }
          }
          else
          {
            *(void *)v456 = v859;
            v466 = v456 + 8;
          }
          v865 = v466;
        }
        else if (v48 == 1)
        {
          if ((unint64_t)v85 >= v866)
          {
            uint64_t v235 = ((char *)v85 - v864) >> 3;
            PCSharedCount v229 = (OZChannel *)((char *)this + 21216);
            if ((unint64_t)(v235 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v236 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v236 <= v235 + 1) {
              unint64_t v236 = v235 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v237 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v237 = v236;
            }
            if (v237) {
              int v238 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v237);
            }
            else {
              int v238 = 0;
            }
            long long v265 = &v238[8 * v235];
            uint64_t v266 = &v238[8 * v237];
            *(void *)long long v265 = v855;
            uint64_t v228 = v265 + 8;
            double v268 = v864;
            double v267 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v269 = *((void *)v267 - 1);
                v267 -= 8;
                *((void *)v265 - 1) = v269;
                v265 -= 8;
              }
              while (v267 != v268);
              double v267 = v864;
            }
            v864 = v265;
            v865 = (char *)v228;
            unint64_t v866 = (unint64_t)v266;
            if (v267) {
              operator delete(v267);
            }
          }
          else
          {
            void *v85 = v855;
            uint64_t v228 = v85 + 1;
            PCSharedCount v229 = (OZChannel *)((char *)this + 21216);
          }
          v865 = (char *)v228;
          if ((unint64_t)v228 >= v866)
          {
            uint64_t v271 = ((char *)v228 - v864) >> 3;
            if ((unint64_t)(v271 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v272 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v272 <= v271 + 1) {
              unint64_t v272 = v271 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v273 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v273 = v272;
            }
            if (v273) {
              double v274 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v273);
            }
            else {
              double v274 = 0;
            }
            long long v275 = &v274[8 * v271];
            double v276 = &v274[8 * v273];
            *(void *)long long v275 = v854;
            double v270 = v275 + 8;
            double v278 = v864;
            double v277 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v279 = *((void *)v277 - 1);
                v277 -= 8;
                *((void *)v275 - 1) = v279;
                v275 -= 8;
              }
              while (v277 != v278);
              double v277 = v864;
            }
            v864 = v275;
            v865 = (char *)v270;
            unint64_t v866 = (unint64_t)v276;
            if (v277) {
              operator delete(v277);
            }
          }
          else
          {
            *uint64_t v228 = v854;
            double v270 = v228 + 1;
          }
          v865 = (char *)v270;
          if ((unint64_t)v270 >= v866)
          {
            uint64_t v281 = ((char *)v270 - v864) >> 3;
            if ((unint64_t)(v281 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v282 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v282 <= v281 + 1) {
              unint64_t v282 = v281 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v283 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v283 = v282;
            }
            if (v283) {
              CMTime v284 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v283);
            }
            else {
              CMTime v284 = 0;
            }
            CMTime v285 = &v284[8 * v281];
            float64x2_t v286 = &v284[8 * v283];
            *(void *)CMTime v285 = v849;
            double v280 = (OZChannel **)(v285 + 8);
            uint64_t v288 = v864;
            CMTimeEpoch v287 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v289 = *((void *)v287 - 1);
                v287 -= 8;
                *((void *)v285 - 1) = v289;
                v285 -= 8;
              }
              while (v287 != v288);
              CMTimeEpoch v287 = v864;
            }
            v864 = v285;
            v865 = (char *)v280;
            unint64_t v866 = (unint64_t)v286;
            if (v287) {
              operator delete(v287);
            }
          }
          else
          {
            *double v270 = v849;
            double v280 = (OZChannel **)(v270 + 1);
          }
          v865 = (char *)v280;
          if ((unint64_t)v280 >= v866)
          {
            uint64_t v291 = ((char *)v280 - v864) >> 3;
            if ((unint64_t)(v291 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v292 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v292 <= v291 + 1) {
              unint64_t v292 = v291 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v293 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v293 = v292;
            }
            if (v293) {
              uint64_t v294 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v293);
            }
            else {
              uint64_t v294 = 0;
            }
            long long v295 = (OZChannel **)&v294[8 * v291];
            long long v296 = &v294[8 * v293];
            *long long v295 = v229;
            long long v290 = (char *)(v295 + 1);
            uint64_t v298 = v864;
            uint64_t v297 = v865;
            if (v865 != v864)
            {
              do
              {
                long long v299 = (OZChannel *)*((void *)v297 - 1);
                v297 -= 8;
                *--long long v295 = v299;
              }
              while (v297 != v298);
              uint64_t v297 = v864;
            }
            v864 = (char *)v295;
            v865 = v290;
            unint64_t v866 = (unint64_t)v296;
            if (v297) {
              operator delete(v297);
            }
          }
          else
          {
            *double v280 = v229;
            long long v290 = (char *)(v280 + 1);
          }
          v865 = v290;
          unsigned int v300 = OZChannel::getValueAsInt(v229, &v863, 0.0);
          long long v302 = (OZChannel **)v865;
          unint64_t v301 = v866;
          if (v300 <= 3)
          {
            if ((unint64_t)v865 >= v866)
            {
              uint64_t v303 = (v865 - v864) >> 3;
              if ((unint64_t)(v303 + 1) >> 61) {
                std::vector<double>::__throw_length_error[abi:ne180100]();
              }
              unint64_t v304 = (uint64_t)(v866 - (void)v864) >> 2;
              if (v304 <= v303 + 1) {
                unint64_t v304 = v303 + 1;
              }
              if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v305 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v305 = v304;
              }
              if (v305) {
                long long v306 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v305);
              }
              else {
                long long v306 = 0;
              }
              v517 = &v306[8 * v303];
              v518 = &v306[8 * v305];
              *(void *)v517 = v843;
              long long v302 = (OZChannel **)(v517 + 8);
              v520 = v864;
              v519 = v865;
              if (v865 != v864)
              {
                do
                {
                  uint64_t v521 = *((void *)v519 - 1);
                  v519 -= 8;
                  *((void *)v517 - 1) = v521;
                  v517 -= 8;
                }
                while (v519 != v520);
                v519 = v864;
              }
              v864 = v517;
              v865 = (char *)v302;
              unint64_t v866 = (unint64_t)v518;
              if (v519) {
                operator delete(v519);
              }
            }
            else
            {
              *(void *)v865 = v843;
              ++v302;
            }
            v865 = (char *)v302;
            unint64_t v301 = v866;
          }
          if ((unint64_t)v302 >= v301)
          {
            uint64_t v523 = ((char *)v302 - v864) >> 3;
            if ((unint64_t)(v523 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v524 = v301 - (void)v864;
            uint64_t v525 = v524 >> 2;
            if (v524 >> 2 <= (unint64_t)(v523 + 1)) {
              uint64_t v525 = v523 + 1;
            }
            if ((unint64_t)v524 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v526 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v526 = v525;
            }
            if (v526) {
              v527 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v526);
            }
            else {
              v527 = 0;
            }
            v528 = (OZChannel **)&v527[8 * v523];
            v529 = &v527[8 * v526];
            char *v528 = v47;
            v522 = (char *)(v528 + 1);
            uint64_t v531 = v864;
            v530 = v865;
            if (v865 != v864)
            {
              do
              {
                v532 = (OZChannel *)*((void *)v530 - 1);
                v530 -= 8;
                *--v528 = v532;
              }
              while (v530 != v531);
              v530 = v864;
            }
            v864 = (char *)v528;
            v865 = v522;
            unint64_t v866 = (unint64_t)v529;
            if (v530) {
              operator delete(v530);
            }
          }
          else
          {
            char *v302 = v47;
            v522 = (char *)(v302 + 1);
          }
          v865 = v522;
          if (OZChannel::getValueAsInt(v47, MEMORY[0x1E4F1FA48], 0.0))
          {
            double v124 = v865;
            if ((unint64_t)v865 < v866) {
              goto LABEL_1144;
            }
            uint64_t v533 = (v865 - v864) >> 3;
            if ((unint64_t)(v533 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v534 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v534 <= v533 + 1) {
              unint64_t v534 = v533 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v535 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v535 = v534;
            }
            if (v535) {
              v536 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v535);
            }
            else {
              v536 = 0;
            }
            v421 = &v536[8 * v533];
            uint64_t v422 = &v536[8 * v535];
            *(void *)v421 = v859;
            unint64_t v423 = v421 + 8;
            v537 = v864;
            unint64_t v424 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v538 = *((void *)v424 - 1);
                v424 -= 8;
                *((void *)v421 - 1) = v538;
                v421 -= 8;
              }
              while (v424 != v537);
              goto LABEL_1195;
            }
            goto LABEL_1196;
          }
        }
      }
      else
      {
        unint64_t v232 = v866;
        if (v13)
        {
          if ((unint64_t)v85 >= v866)
          {
            uint64_t v243 = ((char *)v85 - v864) >> 3;
            if ((unint64_t)(v243 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v244 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v244 <= v243 + 1) {
              unint64_t v244 = v243 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v245 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v245 = v244;
            }
            uint64_t v234 = (char *)this + 22496;
            if (v245) {
              double v246 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v245);
            }
            else {
              double v246 = 0;
            }
            v476 = &v246[8 * v243];
            v477 = &v246[8 * v245];
            *(void *)v476 = v858;
            int v233 = v476 + 8;
            uint64_t v479 = v864;
            v478 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v480 = *((void *)v478 - 1);
                v478 -= 8;
                *((void *)v476 - 1) = v480;
                v476 -= 8;
              }
              while (v478 != v479);
              v478 = v864;
            }
            v864 = v476;
            v865 = (char *)v233;
            unint64_t v866 = (unint64_t)v477;
            if (v478) {
              operator delete(v478);
            }
          }
          else
          {
            void *v85 = v858;
            int v233 = v85 + 1;
            uint64_t v234 = (char *)this + 22496;
          }
          v865 = (char *)v233;
          if ((unint64_t)v233 >= v866)
          {
            uint64_t v481 = ((char *)v233 - v864) >> 3;
            if ((unint64_t)(v481 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v482 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v482 <= v481 + 1) {
              unint64_t v482 = v481 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v483 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v483 = v482;
            }
            if (v483) {
              v484 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v483);
            }
            else {
              v484 = 0;
            }
            v485 = &v484[8 * v481];
            v486 = &v484[8 * v483];
            *(void *)v485 = v857;
            double v85 = v485 + 8;
            v488 = v864;
            v487 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v489 = *((void *)v487 - 1);
                v487 -= 8;
                *((void *)v485 - 1) = v489;
                v485 -= 8;
              }
              while (v487 != v488);
              v487 = v864;
            }
            v864 = v485;
            v865 = (char *)v85;
            unint64_t v866 = (unint64_t)v486;
            if (v487) {
              operator delete(v487);
            }
          }
          else
          {
            void *v233 = v857;
            double v85 = v233 + 1;
          }
          v865 = (char *)v85;
          unint64_t v232 = v866;
        }
        else
        {
          uint64_t v234 = (char *)this + 22496;
        }
        if ((unint64_t)v85 >= v232)
        {
          uint64_t v491 = ((char *)v85 - v864) >> 3;
          if ((unint64_t)(v491 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v492 = v232 - (void)v864;
          uint64_t v493 = v492 >> 2;
          if (v492 >> 2 <= (unint64_t)(v491 + 1)) {
            uint64_t v493 = v491 + 1;
          }
          if ((unint64_t)v492 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v494 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v494 = v493;
          }
          if (v494) {
            v495 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v494);
          }
          else {
            v495 = 0;
          }
          v496 = &v495[8 * v491];
          v497 = &v495[8 * v494];
          *(void *)v496 = v234;
          v490 = (OZChannel **)(v496 + 8);
          uint64_t v499 = v864;
          v498 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v500 = *((void *)v498 - 1);
              v498 -= 8;
              *((void *)v496 - 1) = v500;
              v496 -= 8;
            }
            while (v498 != v499);
            v498 = v864;
          }
          v864 = v496;
          v865 = (char *)v490;
          unint64_t v866 = (unint64_t)v497;
          if (v498) {
            operator delete(v498);
          }
        }
        else
        {
          void *v85 = v234;
          v490 = (OZChannel **)(v85 + 1);
        }
        v865 = (char *)v490;
        if ((unint64_t)v490 >= v866)
        {
          uint64_t v502 = ((char *)v490 - v864) >> 3;
          if ((unint64_t)(v502 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v503 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v503 <= v502 + 1) {
            unint64_t v503 = v502 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v504 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v504 = v503;
          }
          if (v504) {
            v505 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v504);
          }
          else {
            v505 = 0;
          }
          v506 = (OZChannel **)&v505[8 * v502];
          v507 = &v505[8 * v504];
          char *v506 = v47;
          v501 = (char *)(v506 + 1);
          v509 = v864;
          v508 = v865;
          if (v865 != v864)
          {
            do
            {
              v510 = (OZChannel *)*((void *)v508 - 1);
              v508 -= 8;
              *--v506 = v510;
            }
            while (v508 != v509);
            v508 = v864;
          }
          v864 = (char *)v506;
          v865 = v501;
          unint64_t v866 = (unint64_t)v507;
          if (v508) {
            operator delete(v508);
          }
        }
        else
        {
          char *v490 = v47;
          v501 = (char *)(v490 + 1);
        }
        v865 = v501;
        if (OZChannel::getValueAsInt(v47, MEMORY[0x1E4F1FA48], 0.0))
        {
          double v124 = v865;
          if ((unint64_t)v865 < v866) {
            goto LABEL_1144;
          }
          uint64_t v511 = (v865 - v864) >> 3;
          if ((unint64_t)(v511 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v512 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v512 <= v511 + 1) {
            unint64_t v512 = v511 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v513 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v513 = v512;
          }
          if (v513) {
            unint64_t v514 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v513);
          }
          else {
            unint64_t v514 = 0;
          }
          v421 = &v514[8 * v511];
          uint64_t v422 = &v514[8 * v513];
          *(void *)v421 = v859;
          unint64_t v423 = v421 + 8;
          unint64_t v515 = v864;
          unint64_t v424 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v516 = *((void *)v424 - 1);
              v424 -= 8;
              *((void *)v421 - 1) = v516;
              v421 -= 8;
            }
            while (v424 != v515);
            goto LABEL_1195;
          }
          goto LABEL_1196;
        }
      }
LABEL_1199:
      v735 = (char *)this + 31328;
      v736 = v865;
      if ((unint64_t)v865 >= v866)
      {
        uint64_t v738 = (v865 - v864) >> 3;
        if ((unint64_t)(v738 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v739 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v739 <= v738 + 1) {
          unint64_t v739 = v738 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v740 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v740 = v739;
        }
        if (v740) {
          v741 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v740);
        }
        else {
          v741 = 0;
        }
        v742 = &v741[8 * v738];
        v743 = &v741[8 * v740];
        *(void *)v742 = v735;
        v737 = v742 + 8;
        v745 = v864;
        v744 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v746 = *((void *)v744 - 1);
            v744 -= 8;
            *((void *)v742 - 1) = v746;
            v742 -= 8;
          }
          while (v744 != v745);
          v744 = v864;
        }
        v864 = v742;
        v865 = v737;
        unint64_t v866 = (unint64_t)v743;
        if (v744) {
          operator delete(v744);
        }
      }
      else
      {
        *(void *)v865 = v735;
        v737 = v736 + 8;
      }
      v865 = v737;
      for (uint64_t i = (OZChannelBase **)v864; i != (OZChannelBase **)v737; ++i)
      {
        v862 = *i;
        PSEmitter::updateChanHiddenFlag(this, v862, 0, a2);
        std::__tree<OZLocking *>::__erase_unique<OZLocking *>((uint64_t)&v867, (unint64_t *)&v862);
      }
      v748 = v867;
      if (v867 != (uint64_t *)v868)
      {
        do
        {
          PSEmitter::updateChanHiddenFlag(this, (OZChannelBase *)v748[4], 1, a2);
          v749 = (uint64_t *)v748[1];
          if (v749)
          {
            do
            {
              v750 = v749;
              v749 = (uint64_t *)*v749;
            }
            while (v749);
          }
          else
          {
            do
            {
              v750 = (uint64_t *)v748[2];
              BOOL v751 = *v750 == (void)v748;
              v748 = v750;
            }
            while (!v751);
          }
          v748 = v750;
        }
        while (v750 != (uint64_t *)v868);
      }
      PSEmitter::updatePropertiesChans(this, a2);
      if (v864)
      {
        v865 = v864;
        operator delete(v864);
      }
      std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v867, v868[0]);
      return;
    case 10:
      int32x2_t v29 = v865;
      if ((unint64_t)v865 >= v866)
      {
        uint64_t v62 = (v865 - v864) >> 3;
        int v31 = v860;
        if ((unint64_t)(v62 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v63 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v63 <= v62 + 1) {
          unint64_t v63 = v62 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v64 = v63;
        }
        if (v64) {
          uint64_t v65 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v64);
        }
        else {
          uint64_t v65 = 0;
        }
        __n128 v119 = &v65[8 * v62];
        uint64_t v120 = &v65[8 * v64];
        *(void *)__n128 v119 = v5;
        long long v30 = v119 + 8;
        unsigned int v122 = v864;
        double v121 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v123 = *((void *)v121 - 1);
            v121 -= 8;
            *((void *)v119 - 1) = v123;
            v119 -= 8;
          }
          while (v121 != v122);
          double v121 = v864;
        }
        v864 = v119;
        v865 = v30;
        unint64_t v866 = (unint64_t)v120;
        if (v121) {
          operator delete(v121);
        }
      }
      else
      {
        *(void *)v865 = v5;
        long long v30 = v29 + 8;
        int v31 = v860;
      }
      v865 = v30;
      if ((unint64_t)v30 >= v866)
      {
        uint64_t v125 = (v30 - v864) >> 3;
        if ((unint64_t)(v125 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v126 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v126 <= v125 + 1) {
          unint64_t v126 = v125 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v127 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v127 = v126;
        }
        if (v127) {
          long long v128 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v127);
        }
        else {
          long long v128 = 0;
        }
        double v179 = &v128[8 * v125];
        int v180 = &v128[8 * v127];
        *(void *)double v179 = v856;
        double v124 = v179 + 8;
        float64x2_t v182 = v864;
        int v181 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v183 = *((void *)v181 - 1);
            v181 -= 8;
            *((void *)v179 - 1) = v183;
            v179 -= 8;
          }
          while (v181 != v182);
          int v181 = v864;
        }
        v864 = v179;
        v865 = v124;
        unint64_t v866 = (unint64_t)v180;
        if (v181) {
          operator delete(v181);
        }
      }
      else
      {
        *(void *)long long v30 = v856;
        double v124 = v30 + 8;
      }
      v865 = v124;
      switch(v31)
      {
        case 2:
          if ((unint64_t)v124 < v866)
          {
            float64x2_t v185 = (char *)this + 20152;
            goto LABEL_1145;
          }
          uint64_t v319 = (v124 - v864) >> 3;
          if ((unint64_t)(v319 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v320 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v320 <= v319 + 1) {
            unint64_t v320 = v319 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v321 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v321 = v320;
          }
          if (v321) {
            double v322 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v321);
          }
          else {
            double v322 = 0;
          }
          v421 = &v322[8 * v319];
          uint64_t v422 = &v322[8 * v321];
          *(void *)v421 = v858;
          unint64_t v423 = v421 + 8;
          v641 = v864;
          unint64_t v424 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v642 = *((void *)v424 - 1);
              v424 -= 8;
              *((void *)v421 - 1) = v642;
              v421 -= 8;
            }
            while (v424 != v641);
            goto LABEL_1195;
          }
          goto LABEL_1196;
        case 1:
          if ((unint64_t)v124 >= v866)
          {
            uint64_t v315 = (v124 - v864) >> 3;
            if ((unint64_t)(v315 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v316 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v316 <= v315 + 1) {
              unint64_t v316 = v315 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v317 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v317 = v316;
            }
            if (v317) {
              double v318 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v317);
            }
            else {
              double v318 = 0;
            }
            v632 = &v318[8 * v315];
            v633 = &v318[8 * v317];
            *(void *)v632 = v855;
            double v184 = v632 + 8;
            v635 = v864;
            v634 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v636 = *((void *)v634 - 1);
                v634 -= 8;
                *((void *)v632 - 1) = v636;
                v632 -= 8;
              }
              while (v634 != v635);
              v634 = v864;
            }
            v864 = v632;
            v865 = v184;
            unint64_t v866 = (unint64_t)v633;
            if (v634) {
              operator delete(v634);
            }
          }
          else
          {
            *(void *)double v124 = v855;
            double v184 = v124 + 8;
          }
          v865 = v184;
          if ((unint64_t)v184 >= v866)
          {
            uint64_t v637 = (v184 - v864) >> 3;
            if ((unint64_t)(v637 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v638 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v638 <= v637 + 1) {
              unint64_t v638 = v637 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v639 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v639 = v638;
            }
            if (v639) {
              v640 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v639);
            }
            else {
              v640 = 0;
            }
            v681 = &v640[8 * v637];
            v682 = &v640[8 * v639];
            *(void *)v681 = v854;
            double v124 = v681 + 8;
            v684 = v864;
            v683 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v685 = *((void *)v683 - 1);
                v683 -= 8;
                *((void *)v681 - 1) = v685;
                v681 -= 8;
              }
              while (v683 != v684);
              v683 = v864;
            }
            v864 = v681;
            v865 = v124;
            unint64_t v866 = (unint64_t)v682;
            if (v683) {
              operator delete(v683);
            }
          }
          else
          {
            *(void *)double v184 = v854;
            double v124 = v184 + 8;
          }
          v865 = v124;
          if ((unint64_t)v124 < v866)
          {
            float64x2_t v185 = (char *)this + 21064;
            goto LABEL_1145;
          }
          uint64_t v686 = (v124 - v864) >> 3;
          if ((unint64_t)(v686 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v687 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v687 <= v686 + 1) {
            unint64_t v687 = v686 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v688 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v688 = v687;
          }
          if (v688) {
            v689 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v688);
          }
          else {
            v689 = 0;
          }
          v421 = &v689[8 * v686];
          uint64_t v422 = &v689[8 * v688];
          *(void *)v421 = v849;
          unint64_t v423 = v421 + 8;
          v721 = v864;
          unint64_t v424 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v722 = *((void *)v424 - 1);
              v424 -= 8;
              *((void *)v421 - 1) = v722;
              v421 -= 8;
            }
            while (v424 != v721);
            goto LABEL_1195;
          }
          goto LABEL_1196;
        case 0:
          if ((unint64_t)v124 >= v866)
          {
            uint64_t v323 = (v124 - v864) >> 3;
            if ((unint64_t)(v323 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v324 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v324 <= v323 + 1) {
              unint64_t v324 = v323 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v325 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v325 = v324;
            }
            if (v325) {
              double v326 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v325);
            }
            else {
              double v326 = 0;
            }
            v643 = &v326[8 * v323];
            v644 = &v326[8 * v325];
            *(void *)v643 = v855;
            double v124 = v643 + 8;
            v646 = v864;
            v645 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v647 = *((void *)v645 - 1);
                v645 -= 8;
                *((void *)v643 - 1) = v647;
                v643 -= 8;
              }
              while (v645 != v646);
              v645 = v864;
            }
            v864 = v643;
            v865 = v124;
            unint64_t v866 = (unint64_t)v644;
            if (v645) {
              operator delete(v645);
            }
          }
          else
          {
            *(void *)double v124 = v855;
            v124 += 8;
          }
          v865 = v124;
          if ((unint64_t)v124 < v866)
          {
            float64x2_t v185 = (char *)this + 20456;
            goto LABEL_1145;
          }
          uint64_t v648 = (v124 - v864) >> 3;
          if ((unint64_t)(v648 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v649 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v649 <= v648 + 1) {
            unint64_t v649 = v648 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v650 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v650 = v649;
          }
          if (v650) {
            v651 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v650);
          }
          else {
            v651 = 0;
          }
          v421 = &v651[8 * v648];
          uint64_t v422 = &v651[8 * v650];
          *(void *)v421 = v854;
          unint64_t v423 = v421 + 8;
          v690 = v864;
          unint64_t v424 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v691 = *((void *)v424 - 1);
              v424 -= 8;
              *((void *)v421 - 1) = v691;
              v421 -= 8;
            }
            while (v424 != v690);
            goto LABEL_1195;
          }
          goto LABEL_1196;
      }
      goto LABEL_1199;
    case 11:
      long long v32 = v865;
      if ((unint64_t)v865 >= v866)
      {
        uint64_t v66 = (v865 - v864) >> 3;
        if ((unint64_t)(v66 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v67 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v67 <= v66 + 1) {
          unint64_t v67 = v66 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v68 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v68 = v67;
        }
        if (v68) {
          uint64_t v69 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v68);
        }
        else {
          uint64_t v69 = 0;
        }
        uint64_t v129 = &v69[8 * v66];
        unsigned int v130 = &v69[8 * v68];
        *(void *)uint64_t v129 = v5;
        double v33 = v129 + 8;
        float64_t v132 = v864;
        CMTime v131 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v133 = *((void *)v131 - 1);
            v131 -= 8;
            *((void *)v129 - 1) = v133;
            v129 -= 8;
          }
          while (v131 != v132);
          CMTime v131 = v864;
        }
        v864 = v129;
        v865 = (char *)v33;
        unint64_t v866 = (unint64_t)v130;
        if (v131) {
          operator delete(v131);
        }
      }
      else
      {
        *(void *)v865 = v5;
        double v33 = v32 + 8;
      }
      v865 = (char *)v33;
      if ((unint64_t)v33 >= v866)
      {
        uint64_t v136 = ((char *)v33 - v864) >> 3;
        int v135 = v860;
        if ((unint64_t)(v136 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v137 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v137 <= v136 + 1) {
          unint64_t v137 = v136 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v138 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v138 = v137;
        }
        if (v138) {
          double v139 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v138);
        }
        else {
          double v139 = 0;
        }
        int v186 = &v139[8 * v136];
        int v187 = &v139[8 * v138];
        *(void *)int v186 = v853;
        double v134 = v186 + 8;
        double v189 = v864;
        int v188 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v190 = *((void *)v188 - 1);
            v188 -= 8;
            *((void *)v186 - 1) = v190;
            v186 -= 8;
          }
          while (v188 != v189);
          int v188 = v864;
        }
        v864 = v186;
        v865 = (char *)v134;
        unint64_t v866 = (unint64_t)v187;
        if (v188) {
          operator delete(v188);
        }
      }
      else
      {
        *double v33 = v853;
        double v134 = v33 + 1;
        int v135 = v860;
      }
      v865 = (char *)v134;
      if ((unint64_t)v134 >= v866)
      {
        uint64_t v192 = ((char *)v134 - v864) >> 3;
        if ((unint64_t)(v192 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v193 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v193 <= v192 + 1) {
          unint64_t v193 = v192 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v194 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v194 = v193;
        }
        if (v194) {
          int v195 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v194);
        }
        else {
          int v195 = 0;
        }
        float64x2_t v216 = &v195[8 * v192];
        float64x2_t v217 = &v195[8 * v194];
        *(void *)float64x2_t v216 = v852;
        int v191 = v216 + 8;
        float64x2_t v219 = v864;
        float64x2_t v218 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v220 = *((void *)v218 - 1);
            v218 -= 8;
            *((void *)v216 - 1) = v220;
            v216 -= 8;
          }
          while (v218 != v219);
          float64x2_t v218 = v864;
        }
        v864 = v216;
        v865 = (char *)v191;
        unint64_t v866 = (unint64_t)v217;
        if (v218) {
          operator delete(v218);
        }
      }
      else
      {
        *double v134 = v852;
        int v191 = v134 + 1;
      }
      v865 = (char *)v191;
      if ((unint64_t)v191 >= v866)
      {
        uint64_t v222 = ((char *)v191 - v864) >> 3;
        if ((unint64_t)(v222 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v223 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v223 <= v222 + 1) {
          unint64_t v223 = v222 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v224 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v224 = v223;
        }
        if (v224) {
          double v225 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v224);
        }
        else {
          double v225 = 0;
        }
        long long v247 = &v225[8 * v222];
        long long v248 = &v225[8 * v224];
        *(void *)long long v247 = v851;
        long long v221 = v247 + 8;
        float64x2_t v250 = v864;
        double v249 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v251 = *((void *)v249 - 1);
            v249 -= 8;
            *((void *)v247 - 1) = v251;
            v247 -= 8;
          }
          while (v249 != v250);
          double v249 = v864;
        }
        v864 = v247;
        v865 = (char *)v221;
        unint64_t v866 = (unint64_t)v248;
        if (v249) {
          operator delete(v249);
        }
      }
      else
      {
        *int v191 = v851;
        long long v221 = v191 + 1;
      }
      v865 = (char *)v221;
      if ((unint64_t)v221 >= v866)
      {
        uint64_t v253 = ((char *)v221 - v864) >> 3;
        if ((unint64_t)(v253 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v254 = (uint64_t)(v866 - (void)v864) >> 2;
        if (v254 <= v253 + 1) {
          unint64_t v254 = v253 + 1;
        }
        if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v255 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v255 = v254;
        }
        if (v255) {
          BOOL v256 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v255);
        }
        else {
          BOOL v256 = 0;
        }
        CMTimeEpoch v257 = &v256[8 * v253];
        uint64_t v258 = &v256[8 * v255];
        *(void *)CMTimeEpoch v257 = v846;
        CMTime v252 = v257 + 8;
        signed int v260 = v864;
        long long v259 = v865;
        if (v865 != v864)
        {
          do
          {
            uint64_t v261 = *((void *)v259 - 1);
            v259 -= 8;
            *((void *)v257 - 1) = v261;
            v257 -= 8;
          }
          while (v259 != v260);
          long long v259 = v864;
        }
        v864 = v257;
        v865 = (char *)v252;
        unint64_t v866 = (unint64_t)v258;
        if (v259) {
          operator delete(v259);
        }
      }
      else
      {
        void *v221 = v846;
        CMTime v252 = v221 + 1;
      }
      v865 = (char *)v252;
      if (v135)
      {
        if (v135 != 2)
        {
          if (v135 != 1) {
            goto LABEL_1199;
          }
          if ((unint64_t)v252 >= v866)
          {
            uint64_t v339 = ((char *)v252 - v864) >> 3;
            if ((unint64_t)(v339 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v340 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v340 <= v339 + 1) {
              unint64_t v340 = v339 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v341 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v341 = v340;
            }
            if (v341) {
              unint64_t v342 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v341);
            }
            else {
              unint64_t v342 = 0;
            }
            v777 = &v342[8 * v339];
            v778 = &v342[8 * v341];
            *(void *)v777 = v855;
            BOOL v262 = v777 + 8;
            v780 = v864;
            v779 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v781 = *((void *)v779 - 1);
                v779 -= 8;
                *((void *)v777 - 1) = v781;
                v777 -= 8;
              }
              while (v779 != v780);
              v779 = v864;
            }
            v864 = v777;
            v865 = (char *)v262;
            unint64_t v866 = (unint64_t)v778;
            if (v779) {
              operator delete(v779);
            }
          }
          else
          {
            *CMTime v252 = v855;
            BOOL v262 = v252 + 1;
          }
          v865 = (char *)v262;
          if ((unint64_t)v262 >= v866)
          {
            uint64_t v783 = ((char *)v262 - v864) >> 3;
            if ((unint64_t)(v783 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v784 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v784 <= v783 + 1) {
              unint64_t v784 = v783 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v785 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v785 = v784;
            }
            if (v785) {
              v786 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v785);
            }
            else {
              v786 = 0;
            }
            v801 = &v786[8 * v783];
            v802 = &v786[8 * v785];
            *(void *)v801 = v854;
            v782 = v801 + 8;
            v804 = v864;
            v803 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v805 = *((void *)v803 - 1);
                v803 -= 8;
                *((void *)v801 - 1) = v805;
                v801 -= 8;
              }
              while (v803 != v804);
              v803 = v864;
            }
            v864 = v801;
            v865 = (char *)v782;
            unint64_t v866 = (unint64_t)v802;
            if (v803) {
              operator delete(v803);
            }
          }
          else
          {
            *BOOL v262 = v854;
            v782 = v262 + 1;
          }
          v865 = (char *)v782;
          v806 = (char *)this + 20608;
          if ((unint64_t)v782 >= v866)
          {
            uint64_t v807 = ((char *)v782 - v864) >> 3;
            if ((unint64_t)(v807 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v808 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v808 <= v807 + 1) {
              unint64_t v808 = v807 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v809 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v809 = v808;
            }
            if (v809) {
              v810 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v809);
            }
            else {
              v810 = 0;
            }
            v823 = &v810[8 * v807];
            v824 = &v810[8 * v809];
            *(void *)v823 = v806;
            CMTime v252 = v823 + 8;
            v826 = v864;
            v825 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v827 = *((void *)v825 - 1);
                v825 -= 8;
                *((void *)v823 - 1) = v827;
                v823 -= 8;
              }
              while (v825 != v826);
              v825 = v864;
            }
            v864 = v823;
            v865 = (char *)v252;
            unint64_t v866 = (unint64_t)v824;
            if (v825) {
              operator delete(v825);
            }
          }
          else
          {
            void *v782 = v806;
            CMTime v252 = v782 + 1;
          }
          v865 = (char *)v252;
          if ((unint64_t)v252 < v866)
          {
            uint64_t v263 = (char *)this + 21064;
            goto LABEL_1348;
          }
          uint64_t v828 = ((char *)v252 - v864) >> 3;
          if ((unint64_t)(v828 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v829 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v829 <= v828 + 1) {
            unint64_t v829 = v828 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v830 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v830 = v829;
          }
          if (v830) {
            v831 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v830);
          }
          else {
            v831 = 0;
          }
          v762 = &v831[8 * v828];
          v763 = &v831[8 * v830];
          *(void *)v762 = v849;
          v764 = v762 + 8;
          v837 = v864;
          v765 = v865;
          if (v865 == v864)
          {
LABEL_1369:
            v864 = v762;
            v865 = v764;
            unint64_t v866 = (unint64_t)v763;
            if (v765) {
              operator delete(v765);
            }
            goto LABEL_1371;
          }
          do
          {
            uint64_t v838 = *((void *)v765 - 1);
            v765 -= 8;
            *((void *)v762 - 1) = v838;
            v762 -= 8;
          }
          while (v765 != v837);
LABEL_1368:
          v765 = v864;
          goto LABEL_1369;
        }
        if ((unint64_t)v252 >= v866)
        {
          uint64_t v331 = ((char *)v252 - v864) >> 3;
          if ((unint64_t)(v331 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v332 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v332 <= v331 + 1) {
            unint64_t v332 = v331 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v333 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v333 = v332;
          }
          if (v333) {
            v334 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v333);
          }
          else {
            v334 = 0;
          }
          v762 = &v334[8 * v331];
          v763 = &v334[8 * v333];
          *(void *)v762 = v858;
          v764 = v762 + 8;
          v766 = v864;
          v765 = v865;
          if (v865 == v864) {
            goto LABEL_1369;
          }
          do
          {
            uint64_t v767 = *((void *)v765 - 1);
            v765 -= 8;
            *((void *)v762 - 1) = v767;
            v762 -= 8;
          }
          while (v765 != v766);
          goto LABEL_1368;
        }
        uint64_t v263 = (char *)this + 20152;
      }
      else
      {
        if ((unint64_t)v252 >= v866)
        {
          uint64_t v335 = ((char *)v252 - v864) >> 3;
          if ((unint64_t)(v335 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v336 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v336 <= v335 + 1) {
            unint64_t v336 = v335 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v337 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v337 = v336;
          }
          if (v337) {
            uint64_t v338 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v337);
          }
          else {
            uint64_t v338 = 0;
          }
          v768 = &v338[8 * v335];
          v769 = &v338[8 * v337];
          *(void *)v768 = v855;
          long long v264 = v768 + 8;
          v771 = v864;
          v770 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v772 = *((void *)v770 - 1);
              v770 -= 8;
              *((void *)v768 - 1) = v772;
              v768 -= 8;
            }
            while (v770 != v771);
            v770 = v864;
          }
          v864 = v768;
          v865 = (char *)v264;
          unint64_t v866 = (unint64_t)v769;
          if (v770) {
            operator delete(v770);
          }
        }
        else
        {
          *CMTime v252 = v855;
          long long v264 = v252 + 1;
        }
        v865 = (char *)v264;
        if ((unint64_t)v264 >= v866)
        {
          uint64_t v773 = ((char *)v264 - v864) >> 3;
          if ((unint64_t)(v773 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v774 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v774 <= v773 + 1) {
            unint64_t v774 = v773 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v775 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v775 = v774;
          }
          if (v775) {
            v776 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v775);
          }
          else {
            v776 = 0;
          }
          v792 = &v776[8 * v773];
          v793 = &v776[8 * v775];
          *(void *)v792 = v854;
          CMTime v252 = v792 + 8;
          v795 = v864;
          v794 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v796 = *((void *)v794 - 1);
              v794 -= 8;
              *((void *)v792 - 1) = v796;
              v792 -= 8;
            }
            while (v794 != v795);
            v794 = v864;
          }
          v864 = v792;
          v865 = (char *)v252;
          unint64_t v866 = (unint64_t)v793;
          if (v794) {
            operator delete(v794);
          }
        }
        else
        {
          *long long v264 = v854;
          CMTime v252 = v264 + 1;
        }
        v865 = (char *)v252;
        if ((unint64_t)v252 >= v866)
        {
          uint64_t v797 = ((char *)v252 - v864) >> 3;
          if ((unint64_t)(v797 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v798 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v798 <= v797 + 1) {
            unint64_t v798 = v797 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v799 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v799 = v798;
          }
          if (v799) {
            v800 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v799);
          }
          else {
            v800 = 0;
          }
          v762 = &v800[8 * v797];
          v763 = &v800[8 * v799];
          *(void *)v762 = v857;
          v764 = v762 + 8;
          v821 = v864;
          v765 = v865;
          if (v865 == v864) {
            goto LABEL_1369;
          }
          do
          {
            uint64_t v822 = *((void *)v765 - 1);
            v765 -= 8;
            *((void *)v762 - 1) = v822;
            v762 -= 8;
          }
          while (v765 != v821);
          goto LABEL_1368;
        }
        uint64_t v263 = (char *)this + 23160;
      }
LABEL_1348:
      *CMTime v252 = v263;
      v764 = (char *)(v252 + 1);
LABEL_1371:
      v865 = v764;
      goto LABEL_1199;
    default:
      int v38 = v12;
      if ((ValueAsInt - 7) > 1)
      {
        if (ValueAsInt == 9)
        {
          int v74 = v865;
          if ((unint64_t)v865 >= v866)
          {
            uint64_t v307 = (v865 - v864) >> 3;
            if ((unint64_t)(v307 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v308 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v308 <= v307 + 1) {
              unint64_t v308 = v307 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v309 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v309 = v308;
            }
            if (v309) {
              double v310 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v309);
            }
            else {
              double v310 = 0;
            }
            v539 = &v310[8 * v307];
            v540 = &v310[8 * v309];
            *(void *)v539 = v6;
            double v75 = v539 + 8;
            v542 = v864;
            uint64_t v541 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v543 = *((void *)v541 - 1);
                v541 -= 8;
                *((void *)v539 - 1) = v543;
                v539 -= 8;
              }
              while (v541 != v542);
              uint64_t v541 = v864;
            }
            v864 = v539;
            v865 = v75;
            unint64_t v866 = (unint64_t)v540;
            if (v541) {
              operator delete(v541);
            }
          }
          else
          {
            *(void *)v865 = v6;
            double v75 = v74 + 8;
          }
          v865 = v75;
          if ((unint64_t)v75 >= v866)
          {
            uint64_t v545 = (v75 - v864) >> 3;
            if ((unint64_t)(v545 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v546 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v546 <= v545 + 1) {
              unint64_t v546 = v545 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v547 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v547 = v546;
            }
            if (v547) {
              v548 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v547);
            }
            else {
              v548 = 0;
            }
            v612 = &v548[8 * v545];
            v613 = &v548[8 * v547];
            *(void *)v612 = v848;
            unint64_t v544 = v612 + 8;
            CMTime v615 = v864;
            v614 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v616 = *((void *)v614 - 1);
                v614 -= 8;
                *((void *)v612 - 1) = v616;
                v612 -= 8;
              }
              while (v614 != v615);
              v614 = v864;
            }
            v864 = v612;
            v865 = v544;
            unint64_t v866 = (unint64_t)v613;
            if (v614) {
              operator delete(v614);
            }
          }
          else
          {
            *(void *)double v75 = v848;
            unint64_t v544 = v75 + 8;
          }
          v865 = v544;
          if ((unint64_t)v544 >= v866)
          {
            uint64_t v618 = (v544 - v864) >> 3;
            if ((unint64_t)(v618 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v619 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v619 <= v618 + 1) {
              unint64_t v619 = v618 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v620 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v620 = v619;
            }
            if (v620) {
              v621 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v620);
            }
            else {
              v621 = 0;
            }
            v652 = &v621[8 * v618];
            v653 = &v621[8 * v620];
            *(void *)v652 = v841;
            v617 = v652 + 8;
            v655 = v864;
            v654 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v656 = *((void *)v654 - 1);
                v654 -= 8;
                *((void *)v652 - 1) = v656;
                v652 -= 8;
              }
              while (v654 != v655);
              v654 = v864;
            }
            v864 = v652;
            v865 = v617;
            unint64_t v866 = (unint64_t)v653;
            if (v654) {
              operator delete(v654);
            }
          }
          else
          {
            *(void *)unint64_t v544 = v841;
            v617 = v544 + 8;
          }
          v865 = v617;
          if ((unint64_t)v617 >= v866)
          {
            uint64_t v658 = (v617 - v864) >> 3;
            if ((unint64_t)(v658 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v659 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v659 <= v658 + 1) {
              unint64_t v659 = v658 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v660 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v660 = v659;
            }
            if (v660) {
              v661 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v660);
            }
            else {
              v661 = 0;
            }
            v692 = &v661[8 * v658];
            v693 = &v661[8 * v660];
            *(void *)v692 = v840;
            v657 = v692 + 8;
            v695 = v864;
            v694 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v696 = *((void *)v694 - 1);
                v694 -= 8;
                *((void *)v692 - 1) = v696;
                v692 -= 8;
              }
              while (v694 != v695);
              v694 = v864;
            }
            v864 = v692;
            v865 = v657;
            unint64_t v866 = (unint64_t)v693;
            if (v694) {
              operator delete(v694);
            }
          }
          else
          {
            *(void *)v617 = v840;
            v657 = v617 + 8;
          }
          v865 = v657;
          if ((unint64_t)v657 >= v866)
          {
            uint64_t v698 = (v657 - v864) >> 3;
            if ((unint64_t)(v698 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v699 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v699 <= v698 + 1) {
              unint64_t v699 = v698 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v700 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v700 = v699;
            }
            if (v700) {
              v701 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v700);
            }
            else {
              v701 = 0;
            }
            v723 = &v701[8 * v698];
            v724 = &v701[8 * v700];
            *(void *)v723 = v839;
            v697 = v723 + 8;
            v726 = v864;
            v725 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v727 = *((void *)v725 - 1);
                v725 -= 8;
                *((void *)v723 - 1) = v727;
                v723 -= 8;
              }
              while (v725 != v726);
              v725 = v864;
            }
            v864 = v723;
            v865 = v697;
            unint64_t v866 = (unint64_t)v724;
            if (v725) {
              operator delete(v725);
            }
          }
          else
          {
            *(void *)v657 = v839;
            v697 = v657 + 8;
          }
          v865 = v697;
          if (v38)
          {
            v862 = (OZChannelBase *)((char *)this + 20152);
            std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v864, &v862);
            v862 = (OZChannelBase *)((char *)this + 23160);
            std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v864, &v862);
            v697 = v865;
          }
          if ((unint64_t)v697 >= v866)
          {
            uint64_t v729 = (v697 - v864) >> 3;
            if ((unint64_t)(v729 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v730 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v730 <= v729 + 1) {
              unint64_t v730 = v729 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v731 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v731 = v730;
            }
            if (v731) {
              v732 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v731);
            }
            else {
              v732 = 0;
            }
            v811 = &v732[8 * v729];
            v812 = &v732[8 * v731];
            *(void *)v811 = v847;
            v728 = (OZChannel **)(v811 + 8);
            v814 = v864;
            v813 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v815 = *((void *)v813 - 1);
                v813 -= 8;
                *((void *)v811 - 1) = v815;
                v811 -= 8;
              }
              while (v813 != v814);
              v813 = v864;
            }
            v864 = v811;
            v865 = (char *)v728;
            unint64_t v866 = (unint64_t)v812;
            if (v813) {
              operator delete(v813);
            }
          }
          else
          {
            *(void *)v697 = v847;
            v728 = (OZChannel **)(v697 + 8);
          }
          v865 = (char *)v728;
          if ((unint64_t)v728 >= v866)
          {
            uint64_t v817 = ((char *)v728 - v864) >> 3;
            if ((unint64_t)(v817 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v818 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v818 <= v817 + 1) {
              unint64_t v818 = v817 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v819 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v819 = v818;
            }
            if (v819) {
              v820 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v819);
            }
            else {
              v820 = 0;
            }
            v832 = (OZChannel **)&v820[8 * v817];
            v833 = &v820[8 * v819];
            *v832 = v861;
            v816 = (char *)(v832 + 1);
            v835 = v864;
            v834 = v865;
            if (v865 != v864)
            {
              do
              {
                v836 = (OZChannel *)*((void *)v834 - 1);
                v834 -= 8;
                *--v832 = v836;
              }
              while (v834 != v835);
              v834 = v864;
            }
            v864 = (char *)v832;
            v865 = v816;
            unint64_t v866 = (unint64_t)v833;
            if (v834) {
              operator delete(v834);
            }
          }
          else
          {
            *v728 = v861;
            v816 = (char *)(v728 + 1);
          }
          v865 = v816;
          if (OZChannel::getValueAsInt(v861, MEMORY[0x1E4F1FA48], 0.0))
          {
LABEL_1364:
            v862 = (OZChannelBase *)((char *)this + 31784);
            std::vector<OZChannelBase *>::push_back[abi:ne180100]((void **)&v864, &v862);
          }
        }
      }
      else
      {
        long long v39 = v865;
        if ((unint64_t)v865 >= v866)
        {
          uint64_t v95 = (v865 - v864) >> 3;
          if ((unint64_t)(v95 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v96 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v96 <= v95 + 1) {
            unint64_t v96 = v95 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v97 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v97 = v96;
          }
          if (v97) {
            CMTime v98 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v97);
          }
          else {
            CMTime v98 = 0;
          }
          v429 = &v98[8 * v95];
          uint64_t v430 = &v98[8 * v97];
          *(void *)v429 = v856;
          CMTime v40 = v429 + 8;
          unint64_t v432 = v864;
          uint64_t v431 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v433 = *((void *)v431 - 1);
              v431 -= 8;
              *((void *)v429 - 1) = v433;
              v429 -= 8;
            }
            while (v431 != v432);
            uint64_t v431 = v864;
          }
          v864 = v429;
          v865 = (char *)v40;
          unint64_t v866 = (unint64_t)v430;
          if (v431) {
            operator delete(v431);
          }
        }
        else
        {
          *(void *)v865 = v856;
          CMTime v40 = v39 + 8;
        }
        v865 = (char *)v40;
        unint64_t v434 = v866;
        if (ValueAsInt == 8)
        {
          v435 = (OZChannel *)((char *)this + 23008);
          if ((unint64_t)v40 >= v866)
          {
            uint64_t v436 = ((char *)v40 - v864) >> 3;
            if ((unint64_t)(v436 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v437 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v437 <= v436 + 1) {
              unint64_t v437 = v436 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v438 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v438 = v437;
            }
            if (v438) {
              v439 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v438);
            }
            else {
              v439 = 0;
            }
            v549 = &v439[8 * v436];
            v550 = &v439[8 * v438];
            *(void *)v549 = v7;
            CMTime v40 = v549 + 8;
            uint64_t v552 = v864;
            uint64_t v551 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v553 = *((void *)v551 - 1);
                v551 -= 8;
                *((void *)v549 - 1) = v553;
                v549 -= 8;
              }
              while (v551 != v552);
              uint64_t v551 = v864;
            }
            v864 = v549;
            v865 = (char *)v40;
            unint64_t v866 = (unint64_t)v550;
            if (v551) {
              operator delete(v551);
            }
          }
          else
          {
            *v40++ = v7;
          }
          v865 = (char *)v40;
          unint64_t v434 = v866;
        }
        else
        {
          v435 = (OZChannel *)((char *)this + 23008);
        }
        if ((unint64_t)v40 >= v434)
        {
          uint64_t v555 = ((char *)v40 - v864) >> 3;
          if ((unint64_t)(v555 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v556 = v434 - (void)v864;
          uint64_t v557 = v556 >> 2;
          if (v556 >> 2 <= (unint64_t)(v555 + 1)) {
            uint64_t v557 = v555 + 1;
          }
          if ((unint64_t)v556 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v558 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v558 = v557;
          }
          if (v558) {
            v559 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v558);
          }
          else {
            v559 = 0;
          }
          uint64_t v560 = &v559[8 * v555];
          v561 = &v559[8 * v558];
          *(void *)uint64_t v560 = v844;
          unint64_t v554 = v560 + 8;
          v563 = v864;
          v562 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v564 = *((void *)v562 - 1);
              v562 -= 8;
              *((void *)v560 - 1) = v564;
              v560 -= 8;
            }
            while (v562 != v563);
            v562 = v864;
          }
          v864 = v560;
          v865 = (char *)v554;
          unint64_t v866 = (unint64_t)v561;
          if (v562) {
            operator delete(v562);
          }
        }
        else
        {
          *CMTime v40 = v844;
          unint64_t v554 = v40 + 1;
        }
        v865 = (char *)v554;
        unint64_t v565 = v866;
        if (v38)
        {
          if ((unint64_t)v554 >= v866)
          {
            uint64_t v567 = ((char *)v554 - v864) >> 3;
            if ((unint64_t)(v567 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v568 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v568 <= v567 + 1) {
              unint64_t v568 = v567 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v569 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v569 = v568;
            }
            if (v569) {
              uint64_t v570 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v569);
            }
            else {
              uint64_t v570 = 0;
            }
            v571 = &v570[8 * v567];
            uint64_t v572 = &v570[8 * v569];
            *(void *)v571 = v842;
            v566 = v571 + 8;
            unint64_t v574 = v864;
            unint64_t v573 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v575 = *((void *)v573 - 1);
                v573 -= 8;
                *((void *)v571 - 1) = v575;
                v571 -= 8;
              }
              while (v573 != v574);
              unint64_t v573 = v864;
            }
            v864 = v571;
            v865 = (char *)v566;
            unint64_t v866 = (unint64_t)v572;
            if (v573) {
              operator delete(v573);
            }
          }
          else
          {
            *unint64_t v554 = v842;
            v566 = v554 + 1;
          }
          v865 = (char *)v566;
          if ((unint64_t)v566 >= v866)
          {
            uint64_t v576 = ((char *)v566 - v864) >> 3;
            if ((unint64_t)(v576 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v577 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v577 <= v576 + 1) {
              unint64_t v577 = v576 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v578 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v578 = v577;
            }
            if (v578) {
              v579 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v578);
            }
            else {
              v579 = 0;
            }
            uint64_t v580 = &v579[8 * v576];
            v581 = &v579[8 * v578];
            *(void *)uint64_t v580 = v857;
            unint64_t v554 = v580 + 8;
            unint64_t v583 = v864;
            uint64_t v582 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v584 = *((void *)v582 - 1);
                v582 -= 8;
                *((void *)v580 - 1) = v584;
                v580 -= 8;
              }
              while (v582 != v583);
              uint64_t v582 = v864;
            }
            v864 = v580;
            v865 = (char *)v554;
            unint64_t v866 = (unint64_t)v581;
            if (v582) {
              operator delete(v582);
            }
          }
          else
          {
            void *v566 = v857;
            unint64_t v554 = v566 + 1;
          }
          v865 = (char *)v554;
          unint64_t v565 = v866;
        }
        if ((unint64_t)v554 >= v565)
        {
          uint64_t v586 = ((char *)v554 - v864) >> 3;
          if ((unint64_t)(v586 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v587 = v565 - (void)v864;
          uint64_t v588 = v587 >> 2;
          if (v587 >> 2 <= (unint64_t)(v586 + 1)) {
            uint64_t v588 = v586 + 1;
          }
          if ((unint64_t)v587 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v589 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v589 = v588;
          }
          if (v589) {
            v590 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v589);
          }
          else {
            v590 = 0;
          }
          int v591 = &v590[8 * v586];
          v592 = &v590[8 * v589];
          *(void *)int v591 = v845;
          v585 = (OZChannel **)(v591 + 8);
          v594 = v864;
          v593 = v865;
          if (v865 != v864)
          {
            do
            {
              uint64_t v595 = *((void *)v593 - 1);
              v593 -= 8;
              *((void *)v591 - 1) = v595;
              v591 -= 8;
            }
            while (v593 != v594);
            v593 = v864;
          }
          v864 = v591;
          v865 = (char *)v585;
          unint64_t v866 = (unint64_t)v592;
          if (v593) {
            operator delete(v593);
          }
        }
        else
        {
          *unint64_t v554 = v845;
          v585 = (OZChannel **)(v554 + 1);
        }
        v865 = (char *)v585;
        if ((unint64_t)v585 >= v866)
        {
          uint64_t v597 = ((char *)v585 - v864) >> 3;
          if ((unint64_t)(v597 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v598 = (uint64_t)(v866 - (void)v864) >> 2;
          if (v598 <= v597 + 1) {
            unint64_t v598 = v597 + 1;
          }
          if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v599 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v599 = v598;
          }
          if (v599) {
            v600 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v599);
          }
          else {
            v600 = 0;
          }
          v601 = (OZChannel **)&v600[8 * v597];
          v602 = &v600[8 * v599];
          char *v601 = v435;
          v596 = (char *)(v601 + 1);
          v604 = v864;
          v603 = v865;
          if (v865 != v864)
          {
            do
            {
              v605 = (OZChannel *)*((void *)v603 - 1);
              v603 -= 8;
              *--v601 = v605;
            }
            while (v603 != v604);
            v603 = v864;
          }
          v864 = (char *)v601;
          v865 = v596;
          unint64_t v866 = (unint64_t)v602;
          if (v603) {
            operator delete(v603);
          }
        }
        else
        {
          char *v585 = v435;
          v596 = (char *)(v585 + 1);
        }
        v865 = v596;
        if (OZChannel::getValueAsInt(v435, MEMORY[0x1E4F1FA48], 0.0))
        {
          double v124 = v865;
          if ((unint64_t)v865 < v866)
          {
LABEL_1144:
            float64x2_t v185 = (char *)this + 31784;
LABEL_1145:
            *(void *)double v124 = v185;
            unint64_t v423 = v124 + 8;
          }
          else
          {
            uint64_t v606 = (v865 - v864) >> 3;
            if ((unint64_t)(v606 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v607 = (uint64_t)(v866 - (void)v864) >> 2;
            if (v607 <= v606 + 1) {
              unint64_t v607 = v606 + 1;
            }
            if (v866 - (unint64_t)v864 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v608 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v608 = v607;
            }
            if (v608) {
              v609 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v866, v608);
            }
            else {
              v609 = 0;
            }
            v421 = &v609[8 * v606];
            uint64_t v422 = &v609[8 * v608];
            *(void *)v421 = v859;
            unint64_t v423 = v421 + 8;
            v610 = v864;
            unint64_t v424 = v865;
            if (v865 != v864)
            {
              do
              {
                uint64_t v611 = *((void *)v424 - 1);
                v424 -= 8;
                *((void *)v421 - 1) = v611;
                v421 -= 8;
              }
              while (v424 != v610);
LABEL_1195:
              unint64_t v424 = v864;
            }
LABEL_1196:
            v864 = v421;
            v865 = v423;
            unint64_t v866 = (unint64_t)v422;
            if (v424) {
              operator delete(v424);
            }
          }
          v865 = v423;
        }
      }
      goto LABEL_1199;
  }
}

void sub_1B7DEB624(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void **)(v1 - 136);
  if (v3)
  {
    *(void *)(v1 - 128) = v3;
    operator delete(v3);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1 - 112, *(void **)(v1 - 104));
  _Unwind_Resume(a1);
}

uint64_t PSReplicator::createParticleType(PSReplicator *this, OZImageNode *a2)
{
  PCURL::PCURL((PCURL *)&v8, @"Particle Type Default Name");
  if (a2)
  {
    if (v3)
    {
      Name = (const PCString *)OZObjectManipulator::getName((OZObjectManipulator *)&v3->var2);
      PCString::set(&v8, Name);
    }
  }
  NextUniqueID = (const PCString *)OZChannelBase::getNextUniqueID(v3);
  uint64_t ReplicatorPType = PSReplicatorPType::createReplicatorPType((PSReplicatorPType *)&v8, NextUniqueID);
  (*(void (**)(void))(*(void *)(ReplicatorPType + 16) + 120))();
  PCString::~PCString(&v8);
  return ReplicatorPType;
}

void sub_1B7DEB980(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

BOOL PSReplicator::isRenderingOldestParticleFirst(PSReplicator *this)
{
  return OZChannel::getValueAsInt((OZChannel *)((char *)this + 31328), MEMORY[0x1E4F1FA48], 0.0) == 0;
}

uint64_t PSReplicator::shouldDrawEmissionPoints(PSReplicator *this)
{
  return 1;
}

uint64_t PSReplicator::getFillSeed(PSReplicator *this, PSParticleType *a2)
{
  return OZChannel::getValueAsInt((OZChannel *)((char *)this + 31784), MEMORY[0x1E4F1FA48], 0.0);
}

uint64_t PSReplicator::parseEnd(PSReplicator *this, PCSerializerReadStream *a2)
{
  uint64_t v3 = PSEmitter::parseEnd(this, a2);
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(*(int32x4_t *)(*(void *)((*(uint64_t (**)(char *))(*((void *)this + 25) + 664))((char *)this + 200)+ 8)+ 8), (int32x4_t)xmmword_1B8384180)))) & 1) == 0)
  {
    CMTime v4 = (OZChannel *)((char *)this + 32944);
    if (OZChannel::getValueAsInt(v4, MEMORY[0x1E4F1FA48], 0.0))
    {
      OZChannel::setDefaultValue(v4, 0.0);
      OZChannelBase::reset((OZChannelBase *)v4, 0);
    }
  }
  return v3;
}

uint64_t non-virtual thunk to'PSReplicator::parseEnd(PSReplicator *this, PCSerializerReadStream *a2)
{
  return PSReplicator::parseEnd((PSReplicator *)((char *)this - 200), a2);
}

{
  return PSReplicator::parseEnd((PSReplicator *)((char *)this - 248), a2);
}

void PSReplicatorPType::PSReplicatorPType(PSReplicatorPType *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  PSParticleType::PSParticleType(this, a2, a3, a4);
  *(void *)uint64_t v5 = &unk_1F118FBD0;
  *(void *)(v5 + 16) = &unk_1F1190260;
  *(void *)(v5 + 48) = &unk_1F11904B8;
  *(void *)(v5 + 1088) = &unk_1F1190510;
  *(void *)(v5 + 1112) = &unk_1F11905E8;
  *(unsigned char *)(v5 + 16976) = 0;
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Align Rotation");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 2184), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Rotation");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 2336), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Rotation End");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 3192), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Rotation Variance");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 4208), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Color Mode Enum");
  OZChannelEnum::setStrings((const PCString *)this + 671, &v6, 1);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Color Over Order");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 6784), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Solid Color");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 5624), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Random Color");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 7584), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Color Repetitions");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 7736), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Take Image Color");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 7888), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Scale");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 8040), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Scale End");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 8632), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Scale Variance");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 9224), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Is Additive Blend");
  OZChannelBase::setName((OZChannelBase *)this + 89, &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Animate Image");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 10120), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Random Source Start Frame");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 10272), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Source Start Frame");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 10424), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Source Start Frame Offset");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 10576), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Hold Frames");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 10888), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Hold Frames Variance");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 11040), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Shape");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 11344), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Shape Enum");
  OZChannelEnum::setStrings((const PCString *)this + 1418, &v6, 1);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Seed");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 11600), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Point Size");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 11752), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Image Node Ref");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 14392), &v6, 0);
  PCString::~PCString(&v6);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 1120), 0.0);
  OZChannelBase::reset((OZChannelBase *)this + 10, 0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 8768), 1.0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 8920), 1.0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 9072), 1.0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 8632), 0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 1576), 10000.0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 1576), 0);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 10272), 0.0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 10272), 0);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Color Mode Enum");
  OZChannelEnum::setStrings((const PCString *)this + 671, &v6, 1);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator PType Color Over Order");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 6784), &v6, 0);
  PCString::~PCString(&v6);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 11344), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 11344));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1576), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1576));
  OZChannelBase::resetFlag((OZChannelBase *)this + 10, 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)this + 10);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1880), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1880));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 5064), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 5064));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 8040), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 8040));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 8632), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 8632));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 9224), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 9224));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 2336), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 2336));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 3192), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 3192));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 4208), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 4208));
  OZChannelBase::setFlag((OZChannelBase *)this + 10, 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)this + 10);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 1272), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1272));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 1424), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1424));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 1576), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1576));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 1728), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1728));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 1880), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1880));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 2032), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 2032));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 5064), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 5064));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 5216), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 5216));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 9816), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 9816));
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 11192), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 11192));
  (*(void (**)(PSReplicatorPType *, uint64_t))(*(void *)this + 1528))(this, 1);
  PCString::PCString(&v6, "Channel Z", "com.apple.prochannel.framework");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 2776), &v6, 0);
  PCString::~PCString(&v6);
  PCString::PCString(&v6, "Channel Z", "com.apple.prochannel.framework");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 3632), &v6, 0);
  PCString::~PCString(&v6);
  PCString::PCString(&v6, "Channel Z", "com.apple.prochannel.framework");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 4648), &v6, 0);
  PCString::~PCString(&v6);
}

void sub_1B7DEC544(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, PCString a14)
{
  PCString::~PCString(&a14);
  PSParticleType::~PSParticleType(v14);
  _Unwind_Resume(a1);
}

void PSReplicatorPType::PSReplicatorPType(PSReplicatorPType *this, PSReplicatorPType *a2, char a3)
{
  PSParticleType::PSParticleType(this, a2, a3);
  *(void *)uint64_t v4 = &unk_1F118FBD0;
  *(void *)(v4 + 16) = &unk_1F1190260;
  *(void *)(v4 + 48) = &unk_1F11904B8;
  *(void *)(v4 + 1088) = &unk_1F1190510;
  *(void *)(v4 + 1112) = &unk_1F11905E8;
  *(unsigned char *)(v4 + 16976) = *((unsigned char *)a2 + 16976);
}

void PSReplicatorPType::~PSReplicatorPType(PSReplicatorPType *this)
{
  *(void *)this = &unk_1F118FBD0;
  *((void *)this + 2) = &unk_1F1190260;
  *((void *)this + 6) = &unk_1F11904B8;
  *((void *)this + 136) = &unk_1F1190510;
  *((void *)this + 139) = &unk_1F11905E8;
  OZSystemSimulator::flushCache((PSReplicatorPType *)((char *)this + 15520), 1, 0);
  OZSystemSimulator::flushCache((PSReplicatorPType *)((char *)this + 15800), 1, 0);

  PSParticleType::~PSParticleType(this);
}

{
  uint64_t vars8;

  PSReplicatorPType::~PSReplicatorPType(this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'PSReplicatorPType::~PSReplicatorPType(PSReplicatorPType *this)
{
}

{
  PSReplicatorPType::~PSReplicatorPType((PSReplicatorPType *)((char *)this - 48));
}

{
  PSReplicatorPType::~PSReplicatorPType((PSReplicatorPType *)((char *)this - 1088));
}

{
  PSReplicatorPType::~PSReplicatorPType((PSReplicatorPType *)((char *)this - 1112));
}

{
  uint64_t vars8;

  PSReplicatorPType::~PSReplicatorPType((PSReplicatorPType *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSReplicatorPType::~PSReplicatorPType((PSReplicatorPType *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSReplicatorPType::~PSReplicatorPType((PSReplicatorPType *)((char *)this - 1088));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSReplicatorPType::~PSReplicatorPType((PSReplicatorPType *)((char *)this - 1112));

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PSReplicatorPType::createReplicatorPType(PSReplicatorPType *this, const PCString *a2)
{
  long long v3 = xmmword_1B8387A30;
  return OZApplication::createSceneNode(theApp, (unsigned int *)&v3);
}

void PSReplicatorPType::createParticle(PSReplicatorPType *this, unsigned int a2, const CMTime *a3)
{
}

void sub_1B7DECA30(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40AE952B93);
  _Unwind_Resume(a1);
}

uint64_t PSReplicatorPType::getPreviewSceneNode(PSReplicatorPType *this)
{
  uint64_t v1 = theApp;
  long long v6 = xmmword_1B8384180;
  PCURL::PCURL((PCURL *)&v5, @"Replicator Name");
  OZChannelBase::getNextUniqueID(v2);
  uint64_t SceneNode = OZApplication::createSceneNode(v1, (unsigned int *)&v6);
  PCString::~PCString(&v5);
  return SceneNode;
}

void sub_1B7DECAD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t PSReplicatorPType::simAnythingToSimulate(PSReplicatorPType *this)
{
  uint64_t v1 = (*(uint64_t (**)(PSReplicatorPType *))(*(void *)this + 640))(this);
  std::list<OZSimulationBehavior *>::list(&v10, v1 + 224);
  uint64_t v2 = v11;
  if (v11 != &v10)
  {
    int v3 = 0;
    do
    {
      if ((*(unsigned int (**)(void))(*(void *)(v2[2] + 16) + 24))())
      {
        if (v3 > 0) {
          goto LABEL_19;
        }
        ++v3;
      }
      uint64_t v2 = (uint64_t *)v2[1];
    }
    while (v2 != &v10);
  }
  uint64_t v4 = *(void *)(v1 + 48);
  if (v4)
  {
    while (1)
    {
      if ((*(unsigned char *)(v4 + 57) & 0x20) != 0)
      {
        if (v5) {
          break;
        }
      }
LABEL_16:
      uint64_t v4 = *(void *)(v4 + 48);
      if (!v4) {
        goto LABEL_20;
      }
    }
    std::list<OZSimulationBehavior *>::list(v9, (uint64_t)v5 + 224);
    for (uint64_t i = (void *)v9[1]; ; uint64_t i = (void *)i[1])
    {
      if (i == v9)
      {
        std::__list_imp<unsigned int>::clear(v9);
        goto LABEL_16;
      }
      double v7 = (void *)i[2];
      if (((*(uint64_t (**)(void *))(*v7 + 656))(v7) & 1) == 0
        && ((*(uint64_t (**)(void *, void, uint64_t))(v7[2] + 24))(v7 + 2, 0, 1) & 1) != 0)
      {
        break;
      }
    }
    std::__list_imp<unsigned int>::clear(v9);
LABEL_19:
    uint64_t v4 = 1;
  }
LABEL_20:
  std::__list_imp<unsigned int>::clear(&v10);
  return v4;
}

void sub_1B7DECCD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__list_imp<unsigned int>::clear((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'PSReplicatorPType::simAnythingToSimulate(PSReplicatorPType *this)
{
  return PSReplicatorPType::simAnythingToSimulate((PSReplicatorPType *)((char *)this - 1112));
}

uint64_t PSReplicatorPType::simShouldCache(PSReplicatorPType *this)
{
  return 1;
}

uint64_t non-virtual thunk to'PSReplicatorPType::simShouldCache(PSReplicatorPType *this)
{
  return 1;
}

uint64_t PSReplicatorPType::simShouldStepFromCache(PSReplicatorPType *this)
{
  return *((unsigned __int8 *)this + 16976);
}

uint64_t non-virtual thunk to'PSReplicatorPType::simShouldStepFromCache(PSReplicatorPType *this)
{
  return *((unsigned __int8 *)this + 15864);
}

void PSReplicatorPType::simGetFirstFrame(PSReplicatorPType *this@<X0>, const CMTime *a2@<X1>, uint64_t a3@<X8>)
{
  if (*((unsigned char *)this + 16976))
  {
    PSParticleType::simGetFirstFrame(this, (uint64_t)&v5);
    *(_OWORD *)a3 = v5;
    CMTimeEpoch epoch = v6;
  }
  else
  {
    *(_OWORD *)a3 = *(_OWORD *)&a2->value;
    CMTimeEpoch epoch = a2->epoch;
  }
  *(void *)(a3 + 16) = epoch;
}

void non-virtual thunk to'PSReplicatorPType::simGetFirstFrame(PSReplicatorPType *this@<X0>, const CMTime *a2@<X1>, uint64_t a3@<X8>)
{
  if (*((unsigned char *)this + 15864))
  {
    PSParticleType::simGetFirstFrame((PSReplicatorPType *)((char *)this - 1112), (uint64_t)&v5);
    *(_OWORD *)a3 = v5;
    CMTimeEpoch epoch = v6;
  }
  else
  {
    *(_OWORD *)a3 = *(_OWORD *)&a2->value;
    CMTimeEpoch epoch = a2->epoch;
  }
  *(void *)(a3 + 16) = epoch;
}

PSEmitter *PSReplicatorPType::simFlushedCache(PSReplicatorPType *this, OZSystemSimulator *a2)
{
  PSParticleType::simFlushedCache(this, a2);
  uint64_t result = (PSEmitter *)PSReplicatorPType::getReplicator(this);
  if (result) {
    uint64_t result = (PSEmitter *)PSEmitter::simulatingAnyParticleTypes(result);
  }
  *((unsigned char *)this + 16976) = (_BYTE)result;
  return result;
}

void *PSReplicatorPType::getReplicator(PSReplicatorPType *this)
{
  uint64_t result = (void *)*((void *)this + 2054);
  if (result) {
  return result;
  }
}

PSEmitter *non-virtual thunk to'PSReplicatorPType::simFlushedCache(PSReplicatorPType *this, OZSystemSimulator *a2)
{
  return PSReplicatorPType::simFlushedCache((PSReplicatorPType *)((char *)this - 1112), a2);
}

void PSReplicatorPType::updateGradientStringName(PSReplicatorPType *this, char a2)
{
  if ((a2 & 1) == 0)
  {
    if ((*(uint64_t (**)(PSReplicatorPType *))(*(void *)this + 272))(this))
    {
      uint64_t v4 = *(void *)((*(uint64_t (**)(PSReplicatorPType *))(*(void *)this + 272))(this) + 1584);
      if (v4)
      {
        long long v5 = *(OZNotificationManager **)(v4 + 168);
        if (!v5 || !OZNotificationManager::wasChannelModified(v5, (const OZChannelBase *)((char *)this + 6784)))
        {
          PCSharedCount::PCSharedCount(&v6);
          OZChannelBase::addToUndo((OZChannelBase *)((char *)this + 6784), (const PCString *)&v6);
          PCString::~PCString((PCString *)&v6);
        }
      }
    }
  }
  switch(OZChannel::getValueAsInt((OZChannel *)((char *)this + 5368), MEMORY[0x1E4F1FA48], 0.0))
  {
    case 0u:
    case 1u:
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 6912), 2, a2);
      PCURL::PCURL((PCURL *)&v6, @"Replicator PType Opacity Over Order");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 6784), (const PCString *)&v6, 0);
      goto LABEL_11;
    case 2u:
      PCURL::PCURL((PCURL *)&v6, @"Replicator PType Color Over Order");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 6784), (const PCString *)&v6, 0);
      goto LABEL_11;
    case 3u:
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 6912), 2, a2);
      PCURL::PCURL((PCURL *)&v6, @"Emitter Color Range");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 6784), (const PCString *)&v6, 0);
LABEL_11:
      PCString::~PCString((PCString *)&v6);
      break;
    default:
      return;
  }
}

void sub_1B7DED0D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PSReplicatorPType::updateRotationStringNames(PSReplicatorPType *this)
{
  uint64_t v2 = *((void *)this + 2054);
  if (v2 && !OZChannel::getValueAsInt((OZChannel *)(v2 + 32792), MEMORY[0x1E4F1FA48], 0.0))
  {
    PCURL::PCURL((PCURL *)&v3, @"Particle Type Rotation");
    OZChannelBase::setName((OZChannelBase *)((char *)this + 2776), &v3, 1);
    PCString::~PCString(&v3);
    PCURL::PCURL((PCURL *)&v3, @"Particle Type Rotation End");
    OZChannelBase::setName((OZChannelBase *)((char *)this + 3632), &v3, 1);
    PCString::~PCString(&v3);
    PCURL::PCURL((PCURL *)&v3, @"Particle Type Rotation Variance");
    OZChannelBase::setName((OZChannelBase *)((char *)this + 4648), &v3, 1);
  }
  else
  {
    PCString::PCString(&v3, "Channel Z", "com.apple.prochannel.framework");
    OZChannelBase::setName((OZChannelBase *)((char *)this + 2776), &v3, 1);
    PCString::~PCString(&v3);
    PCString::PCString(&v3, "Channel Z", "com.apple.prochannel.framework");
    OZChannelBase::setName((OZChannelBase *)((char *)this + 3632), &v3, 1);
    PCString::~PCString(&v3);
    PCString::PCString(&v3, "Channel Z", "com.apple.prochannel.framework");
    OZChannelBase::setName((OZChannelBase *)((char *)this + 4648), &v3, 1);
  }
  PCString::~PCString(&v3);
}

void sub_1B7DED2B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PSReplicatorPType::getInitialParticleColor(PSReplicatorPType *this, const CMTime *a2, PSParticle *a3, int a4, PCColor *a5)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  unsigned int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 5368), a2, 0.0);
  unsigned int v11 = ValueAsInt;
  if (ValueAsInt == 3)
  {
    unsigned int v17 = *((_DWORD *)this + 1902);
    unsigned int v18 = (*(uint64_t (**)(PSParticle *))(*(void *)a3 + 32))(a3);
    int v19 = -32;
    int v20 = -1640531527;
    do
    {
      v18 += (a4 + 16 * v17) ^ (v17 + v20) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK1 + (v17 >> 5));
      v17 += (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK2 + 16 * v18) ^ (v20 + v18) ^ (PCRandom::hashTEA(unsigned int,unsigned int,unsigned int)::kK3 + (v18 >> 5));
      v20 -= 1640531527;
    }
    while (!__CFADD__(v19++, 1));
    float Alpha = PCColor::getAlpha(a5);
    PCColor::PCColor(&v26);
    OZChannelGradient::getColor((uint64_t **)this + 848, a2, (double)(v17 ^ v18) / 4294967300.0, &v26);
    long long v23 = *(_OWORD *)&v26.var0.var1[1];
    *(_OWORD *)&a5->var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)&v26.var0.var0;
    *(_OWORD *)&a5->var0.var1[1] = v23;
    *(_OWORD *)&a5->var0.var1[3] = *(_OWORD *)&v26.var0.var1[3];
    PCCFRef<CGColorSpace *>::operator=(&a5->var1._obj, &v26.var1._obj);
    if ((int)OZChannel::getValueAsInt((OZChannel *)((char *)this + 14704), MEMORY[0x1E4F1FA48], 0.0) <= 2) {
      PCColor::setAlpha(a5, Alpha);
    }
    PCCFRef<CGColorSpace *>::~PCCFRef(&v26.var1._obj);
  }
  else
  {
    if (ValueAsInt == 2)
    {
      OZChannel::getValueAsDouble((OZChannel *)((char *)this + 7736), a2, 0.0);
      double v13 = v12 + 1.0;
      if (v13 < 1.0) {
        double v13 = 1.0;
      }
      double v14 = *((double *)a3 + 21) * v13;
      *(void *)&v26.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0;
      modf(v14 + -0.0001, (long double *)&v26.var0.var0);
      double v15 = *(double *)&v26.var0.var0;
      PCColor::PCColor(&v26);
      OZChannelGradient::getColor((uint64_t **)this + 848, a2, v14 - v15, &v26);
      long long v16 = *(_OWORD *)&v26.var0.var1[1];
      *(_OWORD *)&a5->var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)&v26.var0.var0;
      *(_OWORD *)&a5->var0.var1[1] = v16;
      *(_OWORD *)&a5->var0.var1[3] = *(_OWORD *)&v26.var0.var1[3];
      PCCFRef<CGColorSpace *>::operator=(&a5->var1._obj, &v26.var1._obj);
      PCCFRef<CGColorSpace *>::~PCCFRef(&v26.var1._obj);
      return;
    }
    PSParticleType::getInitialParticleColor(this, a2, a3, a4, a5);
  }
  if (v11 <= 1)
  {
    v26.var0.var1[1] = 0.0;
    *(_OWORD *)&v26.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = (unint64_t)v26.var0.var1;
    (*(void (**)(char *, const CMTime *, PCColor *))(*((void *)this + 880) + 728))((char *)this + 7040, a2, &v26);
    (*(void (**)(char *, float *, PCColor *, double))(*((void *)this + 880) + 736))((char *)this + 7040, v27, &v26, *((double *)a3 + 21));
    float v24 = v27[0];
    float v25 = PCColor::getAlpha(a5);
    PCColor::setAlpha(a5, v24 * v25);
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v26, *(void **)&v26.var0.var1[0]);
  }
}

void sub_1B7DED620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

CGColorSpace **PSReplicatorPType::getParticleColor(PSReplicatorPType *this, const CMTime *a2, PSParticle *a3, PSEmitter *a4, PCWorkingColor *a5)
{
  PCColor::PCColor(&v22);
  long long v10 = *((_OWORD *)a3 + 8);
  *(_OWORD *)&v22.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *((_OWORD *)a3 + 7);
  *(_OWORD *)&v22.var0.var1[1] = v10;
  *(_OWORD *)&v22.var0.var1[3] = *((_OWORD *)a3 + 9);
  PCCFRef<CGColorSpace *>::operator=(&v22.var1._obj, (CGColorSpace **)a3 + 20);
  float Alpha = PCColor::getAlpha(&v22);
  PSSequencedValues::PSSequencedValues((PSSequencedValues *)v17);
  long long v18 = *(_OWORD *)&v22.var0.var0;
  long long v19 = *(_OWORD *)&v22.var0.var1[1];
  long long v20 = *(_OWORD *)&v22.var0.var1[3];
  PCCFRef<CGColorSpace *>::operator=(v21, &v22.var1._obj);
  (*(void (**)(PSReplicatorPType *, const CMTime *, PSParticle *, unsigned char *))(*(void *)this + 1616))(this, a2, a3, v17);
  *(_OWORD *)&v22.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v18;
  *(_OWORD *)&v22.var0.var1[1] = v19;
  *(_OWORD *)&v22.var0.var1[3] = v20;
  PCCFRef<CGColorSpace *>::operator=(&v22.var1._obj, v21);
  double v12 = v21[1];
  PSEmitter::tintColor(a4, a2, &v22);
  float v13 = *(double *)&v12 * Alpha;
  uint64_t v14 = *((void *)this + 2063);
  if (v14)
  {
    OZChannel::getValueAsDouble((OZChannel *)(v14 + 6680), a2, 0.0);
    float v13 = v15 * v13;
  }
  PCColor::setAlpha(&v22, v13);
  PCWorkingColor::operator=((uint64_t)a5, &v22.var0.var0);
  PCCFRef<CGColorSpace *>::~PCCFRef(v21);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v22.var1._obj);
}

void sub_1B7DED7F0(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v2);
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

uint64_t PSReplicatorPType::simAddObjects(PSReplicatorPType *this, OZSystemSimulator *a2, OZSimStateArray *a3, double a4)
{
  CMTime v28 = *(CMTime *)((unsigned char *)a3 + 1);
  if (!(*(unsigned int (**)(PSReplicatorPType *))(*(void *)this + 1656))(this)) {
    goto LABEL_7;
  }
  (*(void (**)(CMTime *__return_ptr, PSReplicatorPType *))(*(void *)this + 1128))(&time1, this);
  CMTime v27 = time1;
  __n128 v24 = 0uLL;
  uint64_t v7 = *(void *)(*((void *)this + 2054) + 200);
  CMTimeEpoch v25 = 0;
  uint64_t v8 = (*(uint64_t (**)(void))(v7 + 272))();
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v8 + 336), &v24);
  CMTime time1 = v28;
  CMTime time2 = v27;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v23);
  CMTime time1 = v23;
  *(__n128 *)&time2.value = v24;
  time2.CMTimeEpoch epoch = v25;
  int32_t v9 = CMTimeCompare(&time1, &time2);
  long long v10 = (uint64_t *)*((void *)this + 2045);
  unsigned int v11 = (uint64_t *)*((void *)this + 2046);
  if (v9 < 0 && v10 == v11) {
    goto LABEL_7;
  }
  if (v10 == v11) {
    return 0;
  }
  uint64_t v12 = *v10;
  long long v13 = *(_OWORD *)(v12 + 8);
  time1.CMTimeEpoch epoch = *(void *)(v12 + 24);
  *(_OWORD *)&time1.value = v13;
  CMTime time2 = v28;
  if (CMTimeCompare(&time1, &time2)) {
    return 0;
  }
LABEL_7:
  uint64_t NumEmissionPoints = PSEmitter::getNumEmissionPoints(*((PSEmitter **)this + 2054), &v28);
  if ((int)NumEmissionPoints >= 1)
  {
    if ((PSReplicatorPType *)((char *)this + 15800) == a2) {
      unsigned int v15 = 1;
    }
    else {
      unsigned int v15 = 2;
    }
    if ((PSReplicatorPType *)((char *)this + 15520) == a2) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = v15;
    }
    ParticlesForSimStyleType = PSParticleType::getParticlesForSimStyleType(this, v16);
    if (!(*(unsigned int (**)(PSReplicatorPType *))(*(void *)this + 1656))(this)) {
      ParticlesForSimStyleType = 0;
    }
    std::vector<OZSimStateElement>::resize((uint64_t *)a3, NumEmissionPoints - 1108378657 * ((*((void *)a3 + 1) - *(void *)a3) >> 3));
    if (!ParticlesForSimStyleType
      || (long long v19 = *(uint64_t **)ParticlesForSimStyleType,
          long long v18 = (uint64_t *)*((void *)ParticlesForSimStyleType + 1),
          v18 == *(uint64_t **)ParticlesForSimStyleType))
    {
      PSParticleType::createParticles((uint64_t)this, ParticlesForSimStyleType, NumEmissionPoints, (uint64_t *)a3);
    }
    else
    {
      long long v20 = (void *)(*(void *)a3 + 232);
      do
      {
        uint64_t v21 = *v19++;
        *long long v20 = v21;
        v20 += 31;
      }
      while (v19 != v18);
    }
    PSEmitter::initParticles(*((PSEmitter **)this + 2054), v16, this, NumEmissionPoints, 0, a3);
  }
  return NumEmissionPoints;
}

uint64_t non-virtual thunk to'PSReplicatorPType::simAddObjects(PSReplicatorPType *this, OZSystemSimulator *a2, OZSimStateArray *a3, double a4)
{
  return PSReplicatorPType::simAddObjects((PSReplicatorPType *)((char *)this - 1112), a2, a3, a4);
}

void PSEmitterMoToFoBehavior::PSEmitterMoToFoBehavior(PSEmitterMoToFoBehavior *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  OZSimSystemMoToFoBehavior::OZSimSystemMoToFoBehavior(this, a2, a3, a4);
  *(void *)uint64_t v4 = &unk_1F11906B8;
  *(void *)(v4 + 16) = &unk_1F11909B0;
  *(void *)(v4 + 48) = &unk_1F1190C08;
  OZChannelBase::setFlag((OZChannelBase *)(v4 + 56), 10, 0);
}

void sub_1B7DEDB90(_Unwind_Exception *a1)
{
  OZSimSystemMoToFoBehavior::~OZSimSystemMoToFoBehavior(v1);
  _Unwind_Resume(a1);
}

void PSEmitterMoToFoBehavior::PSEmitterMoToFoBehavior(PSEmitterMoToFoBehavior *this, PSEmitterMoToFoBehavior *a2, char a3)
{
  OZSimSystemMoToFoBehavior::OZSimSystemMoToFoBehavior(this, a2, a3);
  *long long v5 = &unk_1F11906B8;
  v5[2] = &unk_1F11909B0;
  v5[6] = &unk_1F1190C08;
  if ((a3 & 0x20) != 0)
  {
    unsigned int v6 = OZSimulationBehavior::_MTF_IDGenerator--;
    OZChannelBase::setID((OZChannelBase *)((char *)this + 56), v6);
  }
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 56), 10, 0);
}

void sub_1B7DEDC60(_Unwind_Exception *a1)
{
  OZSimSystemMoToFoBehavior::~OZSimSystemMoToFoBehavior(v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'PSEmitterMoToFoBehavior::~PSEmitterMoToFoBehavior(PSEmitterMoToFoBehavior *this)
{
}

{
  OZSimSystemMoToFoBehavior::~OZSimSystemMoToFoBehavior((PSEmitterMoToFoBehavior *)((char *)this - 48));
}

{
  uint64_t vars8;

  OZSimSystemMoToFoBehavior::~OZSimSystemMoToFoBehavior((PSEmitterMoToFoBehavior *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  OZSimSystemMoToFoBehavior::~OZSimSystemMoToFoBehavior((PSEmitterMoToFoBehavior *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

void PSEmitterMoToFoBehavior::~PSEmitterMoToFoBehavior(PSEmitterMoToFoBehavior *this)
{
  OZSimSystemMoToFoBehavior::~OZSimSystemMoToFoBehavior(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PSEmitterMoToFoBehavior::operator=(uint64_t a1)
{
  uint64_t result = OZSimSystemMoToFoBehavior::operator=(a1);
  *(void *)(a1 + 1088) = 0;
  return result;
}

uint64_t PSEmitterMoToFoBehavior::didAddToNode(PSEmitterMoToFoBehavior *this, OZSceneNode *lpsrc)
{
  if (lpsrc) {
  else
  }
    uint64_t v4 = 0;
  *((void *)this + 136) = v4;

  return OZSimSystemMoToFoBehavior::didAddToNode(this, lpsrc);
}

void *PSEmitterMoToFoBehavior::getParentTransformNode(PSEmitterMoToFoBehavior *this)
{
  uint64_t v1 = (*(uint64_t (**)(PSEmitterMoToFoBehavior *))(*(void *)this + 320))(this);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = *(const void **)(v1 + 960);
  if (!v2) {
    return 0;
  }
}

void PSEmitterMoToFoBehavior::getAttachToParentFraction(PSParticleType **this, CMTime *a2)
{
}

void PSScaleOverLifeBehavior::PSScaleOverLifeBehavior(PSScaleOverLifeBehavior *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  OZBehavior::OZBehavior(this, a2, a3, a4);
  *long long v5 = &unk_1F1190C78;
  v5[2] = &unk_1F1190EF8;
  v5[6] = &unk_1F1191150;
  PCURL::PCURL((PCURL *)&v13, @"Scale Over Life Behavior Increment Type Enum");
  PCURL::PCURL((PCURL *)v14, @"Scale Over Life Behavior Increment Type");
  Instance = (OZChannelImpl *)PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_incrementTypeChanImpl::getInstance(v6);
  OZChannelEnum::OZChannelEnum((PSScaleOverLifeBehavior *)((char *)this + 336), 3u, (const PCString *)&v13, v14, (OZChannelFolder *)((char *)this + 56), 0xC9u, 0, Instance, 0);
  PCString::~PCString(v14);
  PCString::~PCString((PCString *)&v13);
  PCURL::PCURL((PCURL *)&v13, @"Scale Over Life Behavior Scale Rate");
  int32_t v9 = (PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo *)PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanImpl::getInstance(v8);
  long long v10 = (OZChannelInfo *)PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo::getInstance(v9);
  OZChannel3D::OZChannel3D((PSScaleOverLifeBehavior *)((char *)this + 592), 0.2, 0.2, 0.2, (const PCString *)&v13, (OZChannelFolder *)((char *)this + 56), 0xCAu, 0, 2u, (OZChannelImpl *)v9, v10);
  PCString::~PCString((PCString *)&v13);
  PCURL::PCURL((PCURL *)&v13, @"Scale Over Life Behavior Begin Scale");
  OZChannelScale3D::OZChannelScale3D((PSScaleOverLifeBehavior *)((char *)this + 1184), 0.0, 0.0, 0.0, (const PCString *)&v13, (OZChannelFolder *)((char *)this + 56), 0xCBu, 0);
  PCString::~PCString((PCString *)&v13);
  PCURL::PCURL((PCURL *)&v13, @"Scale Over Life Behavior End Scale");
  OZChannelScale3D::OZChannelScale3D((PSScaleOverLifeBehavior *)((char *)this + 1776), 1.0, 1.0, 1.0, (const PCString *)&v13, (OZChannelFolder *)((char *)this + 56), 0xCCu, 0);
  PCString::~PCString((PCString *)&v13);
  PCURL::PCURL((PCURL *)&v13, @"Scale Over Life Behavior Custom Scale");
  uint64_t v12 = (OZChannelInfo *)PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo::getInstance(v11);
  OZChannelScaleOverRange::OZChannelScaleOverRange((PSScaleOverLifeBehavior *)((char *)this + 2368), (const PCString *)&v13, (OZChannelFolder *)((char *)this + 56), 0xC8u, 2u, 0, v12);
  PCString::~PCString((PCString *)&v13);
  *(_OWORD *)&v14[0].$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = xmmword_1B7E782E0;
  OZChannelEnum::setTags((PSScaleOverLifeBehavior *)((char *)this + 336), (char *)v14, 4);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2368), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 2368));
  (*(void (**)(char *, void))(*((void *)this + 313) + 728))((char *)this + 2504, MEMORY[0x1E4F1FA48]);
  OZFigTimeForChannelSeconds(&v13, 1.0, 0x40000);
  (*(void (**)(char *, CMTime *))(*((void *)this + 313) + 728))((char *)this + 2504, &v13);
  (*(void (**)(char *, void))(*((void *)this + 332) + 728))((char *)this + 2656, MEMORY[0x1E4F1FA48]);
  OZFigTimeForChannelSeconds(&v13, 1.0, 0x40000);
  (*(void (**)(char *, CMTime *))(*((void *)this + 332) + 728))((char *)this + 2656, &v13);
  PCURL::PCURL((PCURL *)&v13, @"Scale Over Life Behavior Over Life");
  PCString::set((PCString *)this + 351, (const PCString *)&v13);
  PCString::~PCString((PCString *)&v13);
  OZChannelScaleOverRange::setValueOverRange((PSScaleOverLifeBehavior *)((char *)this + 2368), 0.0, 0.0, 0.0, 0.0);
}

void sub_1B7DEE2C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10, uint64_t a11, uint64_t a12, PCString a13)
{
  PCString::~PCString(&a10);
  OZChannelScaleOverRange::~OZChannelScaleOverRange(v18);
  OZChannelScale3D::~OZChannelScale3D(v17);
  OZChannelScale3D::~OZChannelScale3D(v16);
  OZChannel3D::~OZChannel3D(v15);
  OZChannelEnum::~OZChannelEnum(v14);
  OZBehavior::~OZBehavior(v13);
  _Unwind_Resume(a1);
}

void PSScaleOverLifeBehavior::PSScaleOverLifeBehavior(PSScaleOverLifeBehavior *this, const PSScaleOverLifeBehavior *a2, char a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  OZBehavior::OZBehavior(this, a2, a3);
  *(void *)uint64_t v5 = &unk_1F1190C78;
  *(void *)(v5 + 16) = &unk_1F1190EF8;
  *(void *)(v5 + 48) = &unk_1F1191150;
  unsigned int v6 = (OZChannelEnum *)(v5 + 336);
  uint64_t v7 = (OZChannelFolder *)(v5 + 56);
  OZChannelEnum::OZChannelEnum((OZChannelEnum *)(v5 + 336), (const PSScaleOverLifeBehavior *)((char *)a2 + 336), (OZChannelFolder *)(v5 + 56));
  OZChannel3D::OZChannel3D((PSScaleOverLifeBehavior *)((char *)this + 592), (const PSScaleOverLifeBehavior *)((char *)a2 + 592), v7);
  OZChannelScale3D::OZChannelScale3D((PSScaleOverLifeBehavior *)((char *)this + 1184), (const PSScaleOverLifeBehavior *)((char *)a2 + 1184), v7);
  OZChannelScale3D::OZChannelScale3D((PSScaleOverLifeBehavior *)((char *)this + 1776), (const PSScaleOverLifeBehavior *)((char *)a2 + 1776), v7);
  OZChannelScaleOverRange::OZChannelScaleOverRange((PSScaleOverLifeBehavior *)((char *)this + 2368), (const PSScaleOverLifeBehavior *)((char *)a2 + 2368), v7);
  long long v8 = xmmword_1B7E782E0;
  OZChannelEnum::setTags(v6, (char *)&v8, 4);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2368), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 2368));
}

void sub_1B7DEE518(_Unwind_Exception *a1)
{
  OZChannelScale3D::~OZChannelScale3D(v5);
  OZChannelScale3D::~OZChannelScale3D(v4);
  OZChannel3D::~OZChannel3D(v3);
  OZChannelEnum::~OZChannelEnum(v2);
  OZBehavior::~OZBehavior(v1);
  _Unwind_Resume(a1);
}

void PSScaleOverLifeBehavior::~PSScaleOverLifeBehavior(PSScaleOverLifeBehavior *this)
{
  *(void *)this = &unk_1F1190C78;
  *((void *)this + 2) = &unk_1F1190EF8;
  *((void *)this + 6) = &unk_1F1191150;
  uint64_t v2 = (PSScaleOverLifeBehavior *)((char *)this + 2368);
  *((void *)this + 296) = &unk_1F110E170;
  *((void *)this + 298) = &unk_1F110E4E8;
  PCString::~PCString((PCString *)this + 351);
  OZChannel2D::~OZChannel2D(v2);
  *((void *)this + 222) = &unk_1F1110838;
  *((void *)this + 224) = &unk_1F1110B90;
  OZChannel::~OZChannel((OZChannel *)((char *)this + 2216));
  OZChannel2D::~OZChannel2D((PSScaleOverLifeBehavior *)((char *)this + 1776));
  *((void *)this + 148) = &unk_1F1110838;
  *((void *)this + 150) = &unk_1F1110B90;
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1624));
  OZChannel2D::~OZChannel2D((PSScaleOverLifeBehavior *)((char *)this + 1184));
  *((void *)this + 74) = &unk_1F1106258;
  *((void *)this + 76) = &unk_1F11065B8;
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1032));
  OZChannel2D::~OZChannel2D((PSScaleOverLifeBehavior *)((char *)this + 592));
  OZChannelEnum::~OZChannelEnum((PSScaleOverLifeBehavior *)((char *)this + 336));

  OZBehavior::~OZBehavior(this);
}

{
  uint64_t vars8;

  PSScaleOverLifeBehavior::~PSScaleOverLifeBehavior(this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'PSScaleOverLifeBehavior::~PSScaleOverLifeBehavior(PSScaleOverLifeBehavior *this)
{
}

{
  PSScaleOverLifeBehavior::~PSScaleOverLifeBehavior((PSScaleOverLifeBehavior *)((char *)this - 48));
}

{
  uint64_t vars8;

  PSScaleOverLifeBehavior::~PSScaleOverLifeBehavior((PSScaleOverLifeBehavior *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSScaleOverLifeBehavior::~PSScaleOverLifeBehavior((PSScaleOverLifeBehavior *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

void PSScaleOverLifeBehavior::operator=(PCString *a1, const void *a2)
{
  OZBehavior::operator=((uint64_t)a1, (uint64_t)a2);
  if (!v4) {
    __cxa_bad_cast();
  }
  uint64_t v5 = v4;
  OZChannelBase::operator=((uint64_t)&a1[42], (uint64_t)&v4[42]);
  OZChannelFolder::operator=((uint64_t)&a1[74]);
  OZChannelBase::operator=((uint64_t)&a1[91], (uint64_t)&v5[91]);
  OZChannelBase::operator=((uint64_t)&a1[110], (uint64_t)&v5[110]);
  OZChannelBase::operator=((uint64_t)&a1[129], (uint64_t)&v5[129]);
  OZChannelFolder::operator=((uint64_t)&a1[148]);
  OZChannelBase::operator=((uint64_t)&a1[165], (uint64_t)&v5[165]);
  OZChannelBase::operator=((uint64_t)&a1[184], (uint64_t)&v5[184]);
  OZChannelBase::operator=((uint64_t)&a1[203], (uint64_t)&v5[203]);
  OZChannelFolder::operator=((uint64_t)&a1[222]);
  OZChannelBase::operator=((uint64_t)&a1[239], (uint64_t)&v5[239]);
  OZChannelBase::operator=((uint64_t)&a1[258], (uint64_t)&v5[258]);
  OZChannelBase::operator=((uint64_t)&a1[277], (uint64_t)&v5[277]);
  OZChannelFolder::operator=((uint64_t)&a1[296]);
  OZChannelBase::operator=((uint64_t)&a1[313], (uint64_t)&v5[313]);
  OZChannelBase::operator=((uint64_t)&a1[332], (uint64_t)&v5[332]);

  PCString::set(a1 + 351, v5 + 351);
}

unint64_t PSScaleOverLifeBehavior::canAddToSceneNode(PSScaleOverLifeBehavior *this, OZSceneNode *a2)
{
  unint64_t v3 = *(void *)((*(uint64_t (**)(OZSceneNode *))(*(void *)a2 + 664))(a2) + 8);
  long long v11 = xmmword_1B8381350;
  if (OZFactory::isKindOfClass(v3, (int32x4_t *)&v11))
  {
    long long v10 = xmmword_1B8387A30;
    if (!OZFactory::isKindOfClass(v3, (int32x4_t *)&v10)) {
      return 1;
    }
  }
  long long v9 = xmmword_1B8384170;
  if (OZFactory::isKindOfClass(v3, (int32x4_t *)&v9))
  {
    long long v8 = xmmword_1B8384180;
    if (!OZFactory::isKindOfClass(v3, (int32x4_t *)&v8)) {
      return 1;
    }
  }
  long long v7 = xmmword_1B837FBE0;
  unint64_t result = OZFactory::isKindOfClass(v3, (int32x4_t *)&v7);
  if (!result) {
    return result;
  }
  if (!OZChannelBase::isEnabled((OZChannelBase *)(v5 + 25776), 0, 1)
    || (OZChannelBase::isEnabled((OZChannelBase *)(v5 + 21760), 0, 1) & 1) != 0)
  {
    return 0;
  }
  unsigned int v6 = (OZChannel *)(v5 + 25904);
  unint64_t result = OZChannel::getValueAsInt(v6, MEMORY[0x1E4F1FA48], 0.0);
  if (result == 1) {
    return result;
  }
  return OZChannel::getValueAsInt(v6, MEMORY[0x1E4F1FA48], 0.0) == 2;
}

BOOL PSScaleOverLifeBehavior::isRebuildUIChannel(PSScaleOverLifeBehavior *this, OZChannelBase *a2)
{
  return (OZChannelBase *)((char *)this + 336) == a2;
}

OZChannelBase *PSScaleOverLifeBehavior::updateHiddenFlags(uint64_t a1, uint64_t a2)
{
  unint64_t result = (OZChannelBase *)OZChannel::getValueAsInt((OZChannel *)(a1 + 336), MEMORY[0x1E4F1FA48], 0.0);
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4 != a2)
  {
    int v5 = (int)result;
    unsigned int v6 = (const CMTime *)MEMORY[0x1E4F1FA48];
    do
    {
      long long v7 = *(char **)(v4 + 16);
      if (v7) {
      unint64_t result = (OZChannelBase *)OZChannel::getValueAsInt((OZChannel *)(v7 + 336), v6, 0.0);
      }
      int v8 = (int)result;
      if (v5 != result) {
        break;
      }
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4 != a2);
    for (uint64_t i = *(void *)(a2 + 8); i != a2; uint64_t i = *(void *)(i + 8))
    {
      long long v10 = *(const void **)(i + 16);
      if (v10) {
      else
      }
        long long v11 = 0;
      uint64_t v12 = (OZChannelBase *)(v11 + 592);
      OZChannelBase::resetFlag((OZChannelBase *)(v11 + 592), 2, 1);
      CMTime v13 = (OZChannelBase *)(v11 + 1184);
      OZChannelBase::resetFlag((OZChannelBase *)(v11 + 1184), 2, 1);
      uint64_t v14 = (OZChannelBase *)(v11 + 1776);
      OZChannelBase::resetFlag((OZChannelBase *)(v11 + 1776), 2, 1);
      uint64_t v15 = (OZChannelBase *)(v11 + 2368);
      unint64_t result = OZChannelBase::resetFlag(v15, 2, 1);
      if (v5 == v8)
      {
        if (!v5)
        {
          OZChannelBase::resetFlag(v12, 0x400000, 1);
          OZChannelBase::setFlag(v13, 0x400000, 1);
          OZChannelBase::setFlag(v14, 0x400000, 1);
          goto LABEL_18;
        }
        if ((v5 & 0xFFFFFFFD) == 1)
        {
          OZChannelBase::setFlag(v12, 0x400000, 1);
          OZChannelBase::resetFlag(v13, 0x400000, 1);
          OZChannelBase::resetFlag(v14, 0x400000, 1);
LABEL_18:
          unint64_t result = OZChannelBase::setFlag(v15, 0x400000, 1);
          continue;
        }
        if (v5 != 2) {
          continue;
        }
        OZChannelBase::setFlag(v12, 0x400000, 1);
        OZChannelBase::setFlag(v13, 0x400000, 1);
        OZChannelBase::setFlag(v14, 0x400000, 1);
      }
      else
      {
        OZChannelBase::resetFlag(v12, 0x400000, 1);
        OZChannelBase::resetFlag(v13, 0x400000, 1);
        OZChannelBase::resetFlag(v14, 0x400000, 1);
      }
      unint64_t result = OZChannelBase::resetFlag(v15, 0x400000, 1);
    }
  }
  return result;
}

uint64_t PSScaleOverLifeBehavior::parseBegin(PSScaleOverLifeBehavior *this, PCSerializerReadStream *a2)
{
  if (*((_DWORD *)a2 + 26) <= 2u)
  {
    OZChannel::setDefaultValue((OZChannel *)((char *)this + 2504), 0.2);
    OZChannel::setDefaultValue((OZChannel *)((char *)this + 2656), 0.2);
    OZChannelBase::reset((OZChannelBase *)((char *)this + 2368), 0);
  }

  return OZBehavior::parseBegin(this, a2);
}

uint64_t non-virtual thunk to'PSScaleOverLifeBehavior::parseBegin(PSScaleOverLifeBehavior *this, PCSerializerReadStream *a2)
{
  return PSScaleOverLifeBehavior::parseBegin((PSScaleOverLifeBehavior *)((char *)this - 48), a2);
}

uint64_t PSScaleOverLifeBehavior::parseEnd(PSScaleOverLifeBehavior *this, PCSerializerReadStream *a2)
{
  if (*((_DWORD *)a2 + 26) <= 2u)
  {
    (*(void (**)(CMTime *__return_ptr, PSScaleOverLifeBehavior *))(*(void *)this + 608))(&v11, this);
    CMTime time1 = v12;
    CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    if (CMTimeCompare(&time1, &time2) < 1)
    {
      double v4 = 1.0;
    }
    else
    {
      CMTime v10 = v12;
      CMTime v9 = *(CMTime *)((char *)a2 + 112);
      double v4 = 1.0 / (double)PC_CMTimeGetSampleNumber(&v10, &v9);
    }
    uint64_t v5 = *(void *)(*(uint64_t (**)(PSScaleOverLifeBehavior *))(*(void *)this + 312))(this);
    (*(void (**)(CMTime *__return_ptr))(v5 + 320))(&v7);
    CMTime time2 = v11;
    CMTime time1 = v7;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v8);
    operator*(&v8, &time1, v4);
    CMTime v8 = time1;
    OZChannel::linearTimeWarp((OZChannel *)((char *)this + 2504), v4, &v8);
    OZChannel::linearTimeWarp((OZChannel *)((char *)this + 2656), v4, &v8);
  }
  return OZBehavior::parseEnd(this, a2);
}

uint64_t non-virtual thunk to'PSScaleOverLifeBehavior::parseEnd(PSScaleOverLifeBehavior *this, PCSerializerReadStream *a2)
{
  return PSScaleOverLifeBehavior::parseEnd((PSScaleOverLifeBehavior *)((char *)this - 48), a2);
}

void PSScaleOverLifeBehavior::getScale(uint64_t a1, CMTime *a2, CMTime *a3, uint64_t a4)
{
  CMTime time1 = *a3;
  CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  if (CMTimeCompare(&time1, &time2) <= 0)
  {
    __asm { FMOV            V0.2D, #1.0 }
    *(_OWORD *)a4 = _Q0;
    *(void *)(a4 + 16) = 0x3FF0000000000000;
  }
  else
  {
    double v8 = 0.0;
    double v9 = 0.0;
    double v10 = 0.0;
    switch(OZChannel::getValueAsInt((OZChannel *)(a1 + 336), MEMORY[0x1E4F1FA48], 0.0))
    {
      case 0u:
        time1.value = 0;
        double v53 = 0.0;
        time2.value = 0;
        OZChannelScale3D::getValue((OZChannelScale3D *)(a1 + 592), MEMORY[0x1E4F1FA48], (double *)&time1.value, (double *)&time2.value, &v53, 0.0);
        CMTime time = *a2;
        Float64 Seconds = CMTimeGetSeconds(&time);
        double v10 = fmax(Seconds * *(double *)&time1.value + 1.0, 0.0);
        CMTime v51 = *a2;
        Float64 v12 = CMTimeGetSeconds(&v51);
        double v9 = fmax(v12 * *(double *)&time2.value + 1.0, 0.0);
        CMTime v50 = *a2;
        Float64 v13 = CMTimeGetSeconds(&v50);
        double v8 = fmax(v13 * v53 + 1.0, 0.0);
        break;
      case 1u:
        operator/((long long *)&a2->value, (uint64_t)a3, (uint64_t)&v49);
        double v41 = CMTimeGetSeconds(&v49);
        time1.value = 0;
        double v53 = 0.0;
        time2.value = 0;
        CMTime v42 = (const CMTime *)MEMORY[0x1E4F1FA48];
        OZChannelScale3D::getValue((OZChannelScale3D *)(a1 + 1184), MEMORY[0x1E4F1FA48], (double *)&time1.value, (double *)&time2.value, &v53, 0.0);
        *(double *)&CMTimeValue v47 = 0.0;
        *(double *)&CMTimeValue v48 = 0.0;
        double v46 = 0.0;
        OZChannelScale3D::getValue((OZChannelScale3D *)(a1 + 1776), v42, (double *)&v48, (double *)&v47, &v46, 0.0);
        double v10 = *(double *)&time1.value + v41 * (*(double *)&v48 - *(double *)&time1.value);
        double v9 = *(double *)&time2.value + v41 * (*(double *)&v47 - *(double *)&time2.value);
        double v8 = v53 + v41 * (v46 - v53);
        break;
      case 2u:
        memset(&time1, 0, sizeof(time1));
        operator/((long long *)&a2->value, (uint64_t)a3, (uint64_t)&time1);
        OZChannel::getValueAsDouble((OZChannel *)(a1 + 2504), &time1, 0.0);
        double v10 = v18;
        OZChannel::getValueAsDouble((OZChannel *)(a1 + 2656), &time1, 0.0);
        double v9 = v19;
        double v8 = 1.0;
        break;
      case 3u:
        time1.value = 0;
        double v53 = 0.0;
        time2.value = 0;
        long long v20 = (const CMTime *)MEMORY[0x1E4F1FA48];
        OZChannelScale3D::getValue((OZChannelScale3D *)(a1 + 1184), MEMORY[0x1E4F1FA48], (double *)&time1.value, (double *)&time2.value, &v53, 0.0);
        *(double *)&CMTimeValue v47 = 0.0;
        *(double *)&CMTimeValue v48 = 0.0;
        double v46 = 0.0;
        OZChannelScale3D::getValue((OZChannelScale3D *)(a1 + 1776), v20, (double *)&v48, (double *)&v47, &v46, 0.0);
        double v21 = *(double *)&v48 - *(double *)&time1.value;
        double v22 = *(double *)&v47 - *(double *)&time2.value;
        double v23 = v46 - v53;
        if (*(double *)&v48 - *(double *)&time1.value <= 0.0) {
          double v24 = -1.0;
        }
        else {
          double v24 = 1.0;
        }
        if (v22 <= 0.0) {
          double v25 = -1.0;
        }
        else {
          double v25 = 1.0;
        }
        if (v23 <= 0.0) {
          double v26 = -1.0;
        }
        else {
          double v26 = 1.0;
        }
        operator/((long long *)&a2->value, (uint64_t)a3, (uint64_t)&v45);
        double v27 = CMTimeGetSeconds(&v45);
        double v28 = v27;
        _NF = v24 < 0.0;
        double v29 = v27;
        if (_NF)
        {
          time1.value = v48;
          double v29 = 1.0 - v27;
        }
        if (v25 < 0.0)
        {
          time2.value = v47;
          double v28 = 1.0 - v27;
        }
        _NF = v26 < 0.0;
        int v31 = &v53;
        if (v26 < 0.0) {
          int v31 = &v46;
        }
        double v32 = *v31;
        if (_NF) {
          double v33 = 1.0 - v27;
        }
        else {
          double v33 = v27;
        }
        long double v34 = log(fabs(v21) + 1.0);
        long double v35 = fabs(v22) + 1.0;
        long double v36 = v34 / 0.693147181;
        long double v37 = log(v35) / 0.693147181;
        long double v38 = log(fabs(v23) + 1.0) / 0.693147181;
        long double v39 = exp2(v36 * v29);
        double v10 = v39 + -1.0 + *(double *)&time1.value;
        long double v40 = exp2(v37 * v28);
        double v9 = v40 + -1.0 + *(double *)&time2.value;
        double v8 = exp2(v38 * v33) + -1.0 + v32;
        break;
      default:
        break;
    }
    double v43 = v9 * *(double *)(a4 + 8);
    double v44 = v8 * *(double *)(a4 + 16);
    *(double *)a4 = v10 * *(double *)a4;
    *(double *)(a4 + 8) = v43;
    *(double *)(a4 + 16) = v44;
  }
}

uint64_t PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_incrementTypeChanImpl::getInstance(PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_incrementTypeChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_incrementTypeChanImpl::getInstance(void)::PSScaleOverLifeBehavior_incrementTypeChanImpl_once, memory_order_acquire) != -1)
  {
    double v4 = &v2;
    unint64_t v3 = &v4;
    std::__call_once(&PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_incrementTypeChanImpl::getInstance(void)::PSScaleOverLifeBehavior_incrementTypeChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_incrementTypeChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_incrementTypeChanImpl::_PSScaleOverLifeBehavior_incrementTypeChan;
}

void std::__call_once_param<std::tuple<PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_incrementTypeChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_incrementTypeChanImpl::_PSScaleOverLifeBehavior_incrementTypeChan) {
    operator new();
  }
}

void sub_1B7DEF558(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_incrementTypeChanImpl::PSScaleOverLifeBehavior_incrementTypeChanImpl(PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_incrementTypeChanImpl *this)
{
}

void sub_1B7DEF62C(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanImpl::getInstance(PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanImpl::getInstance(void)::PSScaleOverLifeBehavior_scaleRateChanImpl_once, memory_order_acquire) != -1)
  {
    double v4 = &v2;
    unint64_t v3 = &v4;
    std::__call_once(&PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanImpl::getInstance(void)::PSScaleOverLifeBehavior_scaleRateChanImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanImpl::_PSScaleOverLifeBehavior_scaleRateChan;
}

void std::__call_once_param<std::tuple<PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanImpl::_PSScaleOverLifeBehavior_scaleRateChan) {
    operator new();
  }
}

void sub_1B7DEF708(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanImpl::PSScaleOverLifeBehavior_scaleRateChanImpl(PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanImpl *this)
{
}

void sub_1B7DEF7F0(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo::getInstance(PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo::getInstance(void)::PSScaleOverLifeBehavior_scaleRateChanInfo_once, memory_order_acquire) != -1)
  {
    double v4 = &v2;
    unint64_t v3 = &v4;
    std::__call_once(&PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo::getInstance(void)::PSScaleOverLifeBehavior_scaleRateChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo::_PSScaleOverLifeBehavior_scaleRateChanInfo;
}

void std::__call_once_param<std::tuple<PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo::_PSScaleOverLifeBehavior_scaleRateChanInfo) {
    operator new();
  }
}

void sub_1B7DEF8CC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo *PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo::PSScaleOverLifeBehavior_scaleRateChanInfo(PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -1.0, 1.0, 1.0, 0.01, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_scaleRateChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F11912B0;
  *((void *)this + 10) = &unk_1F11912D0;
  return this;
}

void sub_1B7DEF9A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo::getInstance(PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo::getInstance(void)::PSScaleOverLifeBehavior_customScaleChanInfo_once, memory_order_acquire) != -1)
  {
    double v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo::getInstance(void)::PSScaleOverLifeBehavior_customScaleChanInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo::_PSScaleOverLifeBehavior_customScaleChanInfo;
}

void std::__call_once_param<std::tuple<PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo::_PSScaleOverLifeBehavior_customScaleChanInfo) {
    operator new();
  }
}

void sub_1B7DEFA7C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo *PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo::PSScaleOverLifeBehavior_customScaleChanInfo(PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo *this)
{
  PCString::PCString(&v3, "%");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -5.0, 5.0, 0.01, 0.0001, 100.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((PSScaleOverLifeBehavior::PSScaleOverLifeBehavior_customScaleChanInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F1191328;
  *((void *)this + 10) = &unk_1F1191348;
  return this;
}

void sub_1B7DEFB54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

void PSSequencedValues::PSSequencedValues(PSSequencedValues *this)
{
  *(void *)this = 0x3FF0000000000000;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  char v2 = PCColor::WHITE((PCColor *)this);
  long long v3 = *((_OWORD *)v2 + 2);
  long long v4 = *(_OWORD *)v2;
  *((_OWORD *)this + 3) = *((_OWORD *)v2 + 1);
  *((_OWORD *)this + 4) = v3;
  *((_OWORD *)this + 2) = v4;
  uint64_t v5 = (CGColorSpace *)*((void *)v2 + 6);
  *((void *)this + 10) = v5;
  if (v5) {
    PCCFRefTraits<CGColorSpace *>::retain(v5);
  }
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)((char *)this + 88) = _Q0;
  *(_OWORD *)((char *)this + 104) = _Q0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0x3FF0000000000000;
}

void PSSequenceBehavior::PSSequenceBehavior(PSSequenceBehavior *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  OZBehavior::OZBehavior(this, a2, a3, a4);
  *uint64_t v5 = &unk_1F11913A0;
  v5[2] = &unk_1F1191670;
  v5[6] = &unk_1F11918C8;
  v5[42] = &unk_1F1191920;
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Rotation");
  OZChannelRotation3D::OZChannelRotation3D((PSSequenceBehavior *)((char *)this + 352), 0.0, 0.0, 0.0, (const PCString *)v7, (OZChannelFolder *)((char *)this + 56), 0xCEu, 2u, 4u, 0, 0);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Color");
  OZChannelColorNoAlpha::OZChannelColorNoAlpha((PSSequenceBehavior *)((char *)this + 1208), 1.0, 1.0, 1.0, (const PCString *)v7, (OZChannelFolder *)((char *)this + 56), 0xC9u, 2u, 5u);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Opacity");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 2216), 1.0, (const PCString *)v7, (OZChannelFolder *)((char *)this + 56), 0xCAu, 2u, 0, 0);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Scale");
  OZChannelScale3D::OZChannelScale3D((PSSequenceBehavior *)((char *)this + 2368), 1.0, 1.0, 1.0, (const PCString *)v7, (OZChannelFolder *)((char *)this + 56), 0xCBu, 2u);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Width");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 2960), 1.0, (const PCString *)v7, (OZChannelFolder *)((char *)this + 56), 0xCFu, 2u, 0, 0);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Pos");
  OZChannelPosition3D::OZChannelPosition3D((PSSequenceBehavior *)((char *)this + 3112), 0.0, 0.0, 0.0, (const PCString *)v7, (OZChannelFolder *)((char *)this + 56), 0xCCu, 2u, 3u);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Sequence Root");
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 4000), (const PCString *)v7, (OZChannelFolder *)((char *)this + 56), 0xCDu, 0, 0);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Map Animation Enum");
  PCURL::PCURL((PCURL *)&v6, @"Replicator Sequence Behavior Map Animation");
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 4128), 1u, (const PCString *)v7, &v6, (OZChannelFolder *)((char *)this + 4000), 0x3EEu, 2, 0, 0);
  PCString::~PCString(&v6);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Sequencing Enum");
  PCURL::PCURL((PCURL *)&v6, @"Replicator Sequence Behavior Sequencing");
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 4384), (const PCString *)v7, &v6, (OZChannelFolder *)((char *)this + 4000), 0x3F3u, 0, 0, 0);
  PCString::~PCString(&v6);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Source Anim Enum");
  PCURL::PCURL((PCURL *)&v6, @"Replicator Sequence Behavior Source Anim");
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 4640), (const PCString *)v7, &v6, (OZChannelFolder *)((char *)this + 4000), 0x3F4u, 0, 0, 0);
  PCString::~PCString(&v6);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Units Enum");
  PCURL::PCURL((PCURL *)&v6, @"Replicator Sequence Behavior Units");
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 4896), (const PCString *)v7, &v6, (OZChannelFolder *)((char *)this + 4000), 0x3F2u, 0, 0, 0);
  PCString::~PCString(&v6);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Start");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 5152), 0.0, (const PCString *)v7, (OZChannelFolder *)((char *)this + 4000), 0x3E9u, 0x400002u, 0, 0);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior End");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 5304), 0.1, (const PCString *)v7, (OZChannelFolder *)((char *)this + 4000), 0x3EAu, 0x400002u, 0, 0);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Spread");
  OZChannelDouble::OZChannelDouble((PSSequenceBehavior *)((char *)this + 5456), 1.0, (const PCString *)v7, (OZChannelFolder *)((char *)this + 4000), 0x3EBu, 0, 0, 0);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Offset Direction Enum");
  PCURL::PCURL((PCURL *)&v6, @"Replicator Sequence Behavior Offset Direction");
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 5608), (const PCString *)v7, &v6, (OZChannelFolder *)((char *)this + 4000), 0x3ECu, 2u, 0, 0);
  PCString::~PCString(&v6);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Offset Behavior Enum");
  PCURL::PCURL((PCURL *)&v6, @"Replicator Sequence Behavior Offset Behavior");
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 5864), (const PCString *)v7, &v6, (OZChannelFolder *)((char *)this + 4000), 0x3EFu, 0, 0, 0);
  PCString::~PCString(&v6);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Offset");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 6120), 0.0, (const PCString *)v7, (OZChannelFolder *)((char *)this + 4000), 0x3F0u, 0x400002u, 0, 0);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior Loops");
  OZChannelDouble::OZChannelDouble((PSSequenceBehavior *)((char *)this + 6272), 1.0, (const PCString *)v7, (OZChannelFolder *)((char *)this + 4000), 0x3F1u, 16, 0, 0);
  PCString::~PCString((PCString *)v7);
  PCURL::PCURL((PCURL *)v7, @"Replicator Sequence Behavior End Condition Enum");
  PCURL::PCURL((PCURL *)&v6, @"Replicator Sequence Behavior End Condition");
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 6424), 0, (const PCString *)v7, &v6, (OZChannelFolder *)((char *)this + 4000), 0x3EDu, 0, 0, 0);
  PCString::~PCString(&v6);
  PCString::~PCString((PCString *)v7);
  PCString::PCString((PCString *)v7, "Use Quadratic Ease");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 6680), 1, (const PCString *)v7, (OZChannelFolder *)((char *)this + 4000), 0x3F5u, 2u, 0, 0);
  PCString::~PCString((PCString *)v7);
  PCString::PCString((PCString *)v7, "Obsolete Rotation");
  OZChannelAngle::OZChannelAngle((OZChannelAngle *)((char *)this + 6832), 0.0, (const PCString *)v7, (OZChannelFolder *)((char *)this + 56), 0xC8u, 2, 0, 0);
  PCString::~PCString((PCString *)v7);
  *(_OWORD *)CMTime v7 = xmmword_1B8387BC4;
  *(_OWORD *)&v7[12] = *(long long *)((char *)&xmmword_1B8387BC4 + 12);
  OZChannelEnum::setTags((PSSequenceBehavior *)((char *)this + 5864), v7, 7);
  OZChannel::setMin((OZChannel *)((char *)this + 6120), -1.0);
  OZChannel::setSliderMin((OZChannel *)((char *)this + 6120), -1.0);
  OZChannel::setKeyframable((OZChannel *)((char *)this + 6272), 0);
  OZChannel::setMin((OZChannel *)((char *)this + 6272), 1.0);
  OZChannel::setMin((OZChannel *)((char *)this + 5456), 0.0);
  OZChannel::setSliderMin((OZChannel *)((char *)this + 5456), 0.0);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 4640), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 4640));
  OZChannelBase::resetFlag((OZChannelBase *)this + 46, 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)this + 46);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 5304), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 5304));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 6120), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 6120));
  *((unsigned char *)this + 3552) = 0;
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 352), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 352));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1208), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 1208));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2216), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 2216));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2368), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 2368));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2960), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 2960));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 3112), 16, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 3112));
}

void sub_1B7DF05D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, OZChannelEnum *a11, OZChannelEnum *a12, OZChannelEnum *a13, OZChannelEnum *a14, OZChannelPercent *a15, OZChannelPercent *a16, OZChannelPosition3D *a17, OZChannelPercent *a18, OZChannelEnum *a19, OZChannelScale3D *a20,OZChannelPercent *a21,OZChannelColorNoAlpha *a22,OZChannelRotation3D *a23,PCString a24,PCString a25)
{
  PCString::~PCString(&a25);
  OZChannelBool::~OZChannelBool(v26);
  OZChannelEnum::~OZChannelEnum(v32);
  OZChannel::~OZChannel(v30);
  OZChannelPercent::~OZChannelPercent(v28);
  OZChannelEnum::~OZChannelEnum(v29);
  OZChannelEnum::~OZChannelEnum(a11);
  OZChannel::~OZChannel(v27);
  OZChannelPercent::~OZChannelPercent(a15);
  OZChannelPercent::~OZChannelPercent(a16);
  OZChannelEnum::~OZChannelEnum(a12);
  OZChannelEnum::~OZChannelEnum(a19);
  OZChannelEnum::~OZChannelEnum(a13);
  OZChannelEnum::~OZChannelEnum(a14);
  OZChannelFolder::~OZChannelFolder(v31);
  OZChannelPosition3D::~OZChannelPosition3D(a17);
  OZChannelPercent::~OZChannelPercent(a18);
  OZChannelScale3D::~OZChannelScale3D(a20);
  OZChannelPercent::~OZChannelPercent(a21);
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha(a22);
  OZChannelRotation3D::~OZChannelRotation3D(a23);
  OZBehavior::~OZBehavior(v25);
  _Unwind_Resume(a1);
}

void PSSequenceBehavior::PSSequenceBehavior(PSSequenceBehavior *this, const PSSequenceBehavior *a2, char a3)
{
  OZBehavior::OZBehavior(this, a2, a3);
  *(void *)uint64_t v5 = &unk_1F11913A0;
  *(void *)(v5 + 16) = &unk_1F1191670;
  *(void *)(v5 + 48) = &unk_1F11918C8;
  *(void *)(v5 + 336) = &unk_1F1191920;
  PCString v6 = (OZChannelFolder *)(v5 + 56);
  OZChannelRotation3D::OZChannelRotation3D((OZChannelRotation3D *)(v5 + 352), (const PSSequenceBehavior *)((char *)a2 + 352), (OZChannelFolder *)(v5 + 56));
  OZChannelColorNoAlpha::OZChannelColorNoAlpha((PSSequenceBehavior *)((char *)this + 1208), (const PSSequenceBehavior *)((char *)a2 + 1208), v6);
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 2216), (const OZChannelBase *)((char *)a2 + 2216), v6);
  OZChannelScale3D::OZChannelScale3D((PSSequenceBehavior *)((char *)this + 2368), (const PSSequenceBehavior *)((char *)a2 + 2368), v6);
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 2960), (const OZChannelBase *)((char *)a2 + 2960), v6);
  OZChannelPosition3D::OZChannelPosition3D((PSSequenceBehavior *)((char *)this + 3112), (const PSSequenceBehavior *)((char *)a2 + 3112), v6);
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 4000), (const OZChannelFolder *)((char *)a2 + 4000), v6);
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 4128), (const PSSequenceBehavior *)((char *)a2 + 4128), (OZChannelFolder *)((char *)this + 4000));
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 4384), (const PSSequenceBehavior *)((char *)a2 + 4384), (OZChannelFolder *)((char *)this + 4000));
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 4640), (const PSSequenceBehavior *)((char *)a2 + 4640), (OZChannelFolder *)((char *)this + 4000));
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 4896), (const PSSequenceBehavior *)((char *)a2 + 4896), (OZChannelFolder *)((char *)this + 4000));
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 5152), (const OZChannelBase *)a2 + 46, (OZChannelFolder *)((char *)this + 4000));
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 5304), (const OZChannelBase *)((char *)a2 + 5304), (OZChannelFolder *)((char *)this + 4000));
  OZChannel::OZChannel((OZChannel *)((char *)this + 5456), (const OZChannelBase *)((char *)a2 + 5456), (OZChannelFolder *)((char *)this + 4000));
  *((void *)this + 682) = &unk_1F1100CF0;
  *((void *)this + 684) = &unk_1F1101050;
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 5608), (const PSSequenceBehavior *)((char *)a2 + 5608), (OZChannelFolder *)((char *)this + 4000));
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 5864), (const PSSequenceBehavior *)((char *)a2 + 5864), (OZChannelFolder *)((char *)this + 4000));
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 6120), (const OZChannelBase *)((char *)a2 + 6120), (OZChannelFolder *)((char *)this + 4000));
  OZChannel::OZChannel((OZChannel *)((char *)this + 6272), (const OZChannelBase *)a2 + 56, (OZChannelFolder *)((char *)this + 4000));
  *((void *)this + 784) = &unk_1F1100CF0;
  *((void *)this + 786) = &unk_1F1101050;
  OZChannelEnum::OZChannelEnum((PSSequenceBehavior *)((char *)this + 6424), (const PSSequenceBehavior *)((char *)a2 + 6424), (OZChannelFolder *)((char *)this + 4000));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 6680), (const OZChannelBase *)((char *)a2 + 6680), (OZChannelFolder *)((char *)this + 4000));
  OZChannel::OZChannel((OZChannel *)((char *)this + 6832), (const OZChannelBase *)a2 + 61, v6);
  *((void *)this + 854) = &unk_1F11010C0;
  *((void *)this + 856) = &unk_1F1101420;
}

void sub_1B7DF0C80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, OZChannelEnum *a10, OZChannelPercent *a11, OZChannelPercent *a12, OZChannelEnum *a13, OZChannelEnum *a14, OZChannelEnum *a15, OZChannelEnum *a16, OZChannelPosition3D *a17, OZChannelPercent *a18, OZChannelScale3D *a19, OZChannelPercent *a20,OZChannelColorNoAlpha *a21)
{
  OZChannelBool::~OZChannelBool(v28);
  OZChannelEnum::~OZChannelEnum(v25);
  OZChannel::~OZChannel(v24);
  OZChannelPercent::~OZChannelPercent(v23);
  OZChannelEnum::~OZChannelEnum(v22);
  OZChannelEnum::~OZChannelEnum(a10);
  OZChannel::~OZChannel(v27);
  OZChannelPercent::~OZChannelPercent(a11);
  OZChannelPercent::~OZChannelPercent(a12);
  OZChannelEnum::~OZChannelEnum(a13);
  OZChannelEnum::~OZChannelEnum(a14);
  OZChannelEnum::~OZChannelEnum(a15);
  OZChannelEnum::~OZChannelEnum(a16);
  OZChannelFolder::~OZChannelFolder(v26);
  OZChannelPosition3D::~OZChannelPosition3D(a17);
  OZChannelPercent::~OZChannelPercent(a18);
  OZChannelScale3D::~OZChannelScale3D(a19);
  OZChannelPercent::~OZChannelPercent(a20);
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha(a21);
  OZChannelRotation3D::~OZChannelRotation3D(*(OZChannelRotation3D **)(v29 - 88));
  OZBehavior::~OZBehavior(v21);
  _Unwind_Resume(a1);
}

void sub_1B7DF0D54()
{
}

void sub_1B7DF0D5C()
{
}

void sub_1B7DF0D64()
{
}

void sub_1B7DF0D6C()
{
}

void sub_1B7DF0D74()
{
}

void sub_1B7DF0D7C()
{
}

void sub_1B7DF0D84()
{
}

void sub_1B7DF0D8C()
{
}

void sub_1B7DF0D94()
{
}

void sub_1B7DF0D9C()
{
}

void sub_1B7DF0DA4()
{
}

void sub_1B7DF0DAC()
{
}

void sub_1B7DF0DB4()
{
}

void sub_1B7DF0DBC()
{
}

void sub_1B7DF0DC4()
{
}

void sub_1B7DF0DCC()
{
}

void PSSequenceBehavior::~PSSequenceBehavior(PSSequenceBehavior *this)
{
  *(void *)this = &unk_1F11913A0;
  *((void *)this + 2) = &unk_1F1191670;
  *((void *)this + 6) = &unk_1F11918C8;
  *((void *)this + 42) = &unk_1F1191920;
  OZChannel::~OZChannel((OZChannel *)((char *)this + 6832));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 6680));
  OZChannelEnum::~OZChannelEnum((PSSequenceBehavior *)((char *)this + 6424));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 6272));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 6120));
  OZChannelEnum::~OZChannelEnum((PSSequenceBehavior *)((char *)this + 5864));
  OZChannelEnum::~OZChannelEnum((PSSequenceBehavior *)((char *)this + 5608));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 5456));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 5304));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 5152));
  OZChannelEnum::~OZChannelEnum((PSSequenceBehavior *)((char *)this + 4896));
  OZChannelEnum::~OZChannelEnum((PSSequenceBehavior *)((char *)this + 4640));
  OZChannelEnum::~OZChannelEnum((PSSequenceBehavior *)((char *)this + 4384));
  OZChannelEnum::~OZChannelEnum((PSSequenceBehavior *)((char *)this + 4128));
  OZChannelFolder::~OZChannelFolder((OZChannelFolder *)((char *)this + 4000));
  OZChannelPosition3D::~OZChannelPosition3D((PSSequenceBehavior *)((char *)this + 3112));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 2960));
  *((void *)this + 296) = &unk_1F1110838;
  *((void *)this + 298) = &unk_1F1110B90;
  OZChannel::~OZChannel((OZChannel *)((char *)this + 2808));
  OZChannel2D::~OZChannel2D((PSSequenceBehavior *)((char *)this + 2368));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 2216));
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha((PSSequenceBehavior *)((char *)this + 1208));
  OZChannelRotation3D::~OZChannelRotation3D((PSSequenceBehavior *)((char *)this + 352));

  OZBehavior::~OZBehavior(this);
}

{
  uint64_t vars8;

  PSSequenceBehavior::~PSSequenceBehavior(this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'PSSequenceBehavior::~PSSequenceBehavior(PSSequenceBehavior *this)
{
}

{
  PSSequenceBehavior::~PSSequenceBehavior((PSSequenceBehavior *)((char *)this - 48));
}

{
  PSSequenceBehavior::~PSSequenceBehavior((PSSequenceBehavior *)((char *)this - 336));
}

{
  uint64_t vars8;

  PSSequenceBehavior::~PSSequenceBehavior((PSSequenceBehavior *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSSequenceBehavior::~PSSequenceBehavior((PSSequenceBehavior *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSSequenceBehavior::~PSSequenceBehavior((PSSequenceBehavior *)((char *)this - 336));

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PSSequenceBehavior::operator=(uint64_t a1, const void *a2)
{
  OZBehavior::operator=(a1, (uint64_t)a2);
  if (!v4) {
    __cxa_bad_cast();
  }
  uint64_t v5 = v4;
  OZChannelPosition::operator=(a1 + 352, (uint64_t)(v4 + 352));
  OZChannelFolder::operator=(a1 + 1208);
  OZChannelBase::operator=(a1 + 1344, (uint64_t)(v5 + 1344));
  OZChannelBase::operator=(a1 + 1496, (uint64_t)(v5 + 1496));
  OZChannelBase::operator=(a1 + 1648, (uint64_t)(v5 + 1648));
  OZChannelBase::operator=(a1 + 1800, (uint64_t)(v5 + 1800));
  OZChannelBase::operator=(a1 + 1952, (uint64_t)(v5 + 1952));
  *(unsigned char *)(a1 + 2208) = v5[2208];
  OZChannelBase::operator=(a1 + 2216, (uint64_t)(v5 + 2216));
  OZChannelFolder::operator=(a1 + 2368);
  OZChannelBase::operator=(a1 + 2504, (uint64_t)(v5 + 2504));
  OZChannelBase::operator=(a1 + 2656, (uint64_t)(v5 + 2656));
  OZChannelBase::operator=(a1 + 2808, (uint64_t)(v5 + 2808));
  OZChannelBase::operator=(a1 + 2960, (uint64_t)(v5 + 2960));
  OZChannelPosition::operator=(a1 + 3112, (uint64_t)(v5 + 3112));
  OZChannelFolder::operator=(a1 + 4000);
  OZChannelBase::operator=(a1 + 5864, (uint64_t)(v5 + 5864));
  OZChannelBase::operator=(a1 + 6120, (uint64_t)(v5 + 6120));
  OZChannelBase::operator=(a1 + 5608, (uint64_t)(v5 + 5608));
  OZChannelBase::operator=(a1 + 6424, (uint64_t)(v5 + 6424));
  OZChannelBase::operator=(a1 + 6680, (uint64_t)(v5 + 6680));
  OZChannelBase::operator=(a1 + 6272, (uint64_t)(v5 + 6272));
  OZChannelBase::operator=(a1 + 4384, (uint64_t)(v5 + 4384));
  OZChannelBase::operator=(a1 + 4640, (uint64_t)(v5 + 4640));
  OZChannelBase::operator=(a1 + 4896, (uint64_t)(v5 + 4896));
  OZChannelBase::operator=(a1 + 5152, (uint64_t)(v5 + 5152));
  OZChannelBase::operator=(a1 + 5304, (uint64_t)(v5 + 5304));
  OZChannelBase::operator=(a1 + 5456, (uint64_t)(v5 + 5456));
  OZChannelBase::operator=(a1 + 4128, (uint64_t)(v5 + 4128));

  return OZChannelBase::operator=(a1 + 6832, (uint64_t)(v5 + 6832));
}

uint64_t PSSequenceBehavior::didAddToNode(PSSequenceBehavior *this, OZSceneNode *a2)
{
  *((void *)this + 41) = a2;
  return (*(uint64_t (**)(void))(*(void *)this + 696))();
}

uint64_t PSSequenceBehavior::didInsert(PSSequenceBehavior *this, OZSceneNode *a2, OZBehavior *a3)
{
  *((void *)this + 41) = a2;
  return (*(uint64_t (**)(void))(*(void *)this + 696))();
}

uint64_t PSSequenceBehavior::didAddSceneNodeToScene(PSSequenceBehavior *this, OZScene *a2)
{
  uint64_t result = (*(uint64_t (**)(PSSequenceBehavior *, OZScene *))(*(void *)this + 320))(this, a2);
  if (*((void *)this + 43)) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = result == 0;
  }
  if (!v4)
  {
    uint64_t v5 = *(uint64_t (**)(PSSequenceBehavior *, uint64_t))(*(void *)this + 696);
    return v5(this, result);
  }
  return result;
}

void *PSSequenceBehavior::findEmitter(PSSequenceBehavior *this, OZSceneNode *lpsrc)
{
  if (lpsrc)
  {
    if (v4) {
      uint64_t result = (void *)v4[2054];
    }
    else {
  }
    }
  else
  {
    uint64_t result = 0;
  }
  *((void *)this + 43) = result;
  return result;
}

uint64_t PSSequenceBehavior::willRemove(uint64_t this)
{
  *(void *)(this + 344) = 0;
  *(void *)(this + 328) = 0;
  return this;
}

BOOL PSSequenceBehavior::canAddToSceneNode(PSSequenceBehavior *this, OZSceneNode *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  {
    return 1;
  }
}

BOOL PSSequenceBehavior::isRebuildUIChannel(PSSequenceBehavior *this, OZChannelBase *a2)
{
  return (OZChannelBase *)((char *)this + 4384) == a2
      || (OZChannelBase *)((char *)this + 4896) == a2
      || (OZChannelBase *)((char *)this + 5864) == a2;
}

OZChannelBase *PSSequenceBehavior::updateHiddenFlags(uint64_t a1)
{
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 4384), MEMORY[0x1E4F1FA48], 0.0);
  long long v3 = (OZChannelBase *)(a1 + 4640);
  if (ValueAsInt == 4) {
    OZChannelBase::resetFlag(v3, 4194306, 1);
  }
  else {
    OZChannelBase::setFlag(v3, 4194306, 1);
  }
  int v4 = OZChannel::getValueAsInt((OZChannel *)(a1 + 4896), MEMORY[0x1E4F1FA48], 0.0);
  uint64_t v5 = (OZChannelBase *)(a1 + 5152);
  if (v4 == 2)
  {
    OZChannelBase::resetFlag(v5, 4194306, 1);
    OZChannelBase::resetFlag((OZChannelBase *)(a1 + 5304), 4194306, 1);
  }
  else
  {
    OZChannelBase::setFlag(v5, 4194306, 1);
    OZChannelBase::setFlag((OZChannelBase *)(a1 + 5304), 4194306, 1);
    if (v4 == 1)
    {
      OZChannelBase::setFlag((OZChannelBase *)(a1 + 5456), 4227072, 1);
      goto LABEL_9;
    }
  }
  OZChannelBase::resetFlag((OZChannelBase *)(a1 + 5456), 4227072, 1);
LABEL_9:
  int v6 = OZChannel::getValueAsInt((OZChannel *)(a1 + 5864), MEMORY[0x1E4F1FA48], 0.0);
  CMTime v7 = (OZChannelBase *)(a1 + 6120);
  uint64_t v8 = (OZChannelBase *)(a1 + 6272);
  if (v6 == 4)
  {
    OZChannelBase::resetFlag(v7, 4194306, 1);
    return OZChannelBase::setFlag(v8, 0x400000, 1);
  }
  else
  {
    OZChannelBase::setFlag(v7, 4194306, 1);
    return OZChannelBase::resetFlag(v8, 4227072, 1);
  }
}

uint64_t PSSequenceBehavior::parseBegin(PSSequenceBehavior *this, PCSerializerReadStream *a2)
{
  if (*((_DWORD *)a2 + 26) <= 4u) {
    OZChannel::setValue((OZChannel *)((char *)this + 6680), MEMORY[0x1E4F1FA48], 0.0, 0);
  }

  return OZBehavior::parseBegin(this, a2);
}

uint64_t non-virtual thunk to'PSSequenceBehavior::parseBegin(PSSequenceBehavior *this, PCSerializerReadStream *a2)
{
  return PSSequenceBehavior::parseBegin((PSSequenceBehavior *)((char *)this - 48), a2);
}

uint64_t PSSequenceBehavior::parseEnd(PSSequenceBehavior *this, PCSerializerReadStream *a2)
{
  *((unsigned char *)this + 3552) = (*((void *)this + 396) & 2) == 0;
  OZChannelFolder::resetFoldFlag((OZChannelFolder *)((char *)this + 4000), 0x20000);
  if (!OZChannel::getValueAsInt((OZChannel *)((char *)this + 4128), MEMORY[0x1E4F1FA48], 0.0))
  {
    OZChannel::setValue((OZChannel *)((char *)this + 4384), MEMORY[0x1E4F1FA48], 4.0, 0);
    OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 4384), 4194306, 0);
    OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 4384));
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 4128), 2, 0);
    OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 4128));
  }
  if (*((_DWORD *)a2 + 26) <= 2u)
  {
    OZChannelBase::operator=((uint64_t)this + 792, (uint64_t)this + 6832);
    if (!OZChannelBase::testFlag((OZChannelBase *)this + 61, 2))
    {
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 352), 2, 0);
      OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 352));
      OZChannelBase::setFlag((OZChannelBase *)this + 61, 2, 0);
      OZChannelBase::saveStateAsDefault((OZChannelBase *)this + 61);
    }
  }

  return OZBehavior::parseEnd(this, a2);
}

uint64_t non-virtual thunk to'PSSequenceBehavior::parseEnd(PSSequenceBehavior *this, PCSerializerReadStream *a2)
{
  return PSSequenceBehavior::parseEnd((PSSequenceBehavior *)((char *)this - 48), a2);
}

uint64_t PSSequenceBehavior::getNumObjects(PSSequenceBehavior *this, const CMTime *a2)
{
  long long v3 = (PSEmitter *)*((void *)this + 43);
  uint64_t result = OZChannel::getValueAsInt((OZChannel *)((char *)this + 4896), MEMORY[0x1E4F1FA48], 0.0);
  if (result != 1)
  {
    return PSEmitter::getOrderLength(v3, a2);
  }
  return result;
}

void PSSequenceBehavior::getInfluence(PSSequenceBehavior *this, const CMTime *a2, double a3)
{
  CMTime v23 = *a2;
  if ((*(unsigned int (**)(PSSequenceBehavior *, CMTime *, void, uint64_t, uint64_t))(*(void *)this + 296))(this, &v23, 0, 1, 1)&& OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), MEMORY[0x1E4F1FA48], 0.0) != 4)
  {
    (*(void (**)(CMTime *__return_ptr, PSSequenceBehavior *, double))(*(void *)this + 608))(v22, this, 1.0);
    memset(&v21, 0, sizeof(v21));
    CMTime v20 = v22[0];
    OZBehavior::getFrameDuration(this, &v17);
    CMTime time1 = v22[0];
    CMTime time2 = v22[1];
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v24);
    CMTime time1 = v24;
    *(__n128 *)&time2.value = v17;
    time2.CMTimeEpoch epoch = v18;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v19);
    CMTime time1 = *a2;
    CMTime time2 = v20;
    if (CMTimeCompare(&time1, &time2) < 0)
    {
      int v6 = &v20;
    }
    else
    {
      CMTime time1 = *a2;
      CMTime time2 = v19;
      int v6 = CMTimeCompare(&time1, &time2) <= 0 ? (CMTime *)a2 : &v19;
    }
    CMTime v21 = *v6;
    double v7 = (*(double (**)(PSSequenceBehavior *, CMTime *, double))(*(void *)this + 688))(this, &v21, a3);
    time1.value = 0;
    LOBYTE(time2.value) = 0;
    (*(void (**)(PSSequenceBehavior *, CMTime *, CMTime *, CMTime *))(*(void *)this + 680))(this, &v21, &time1, &time2);
    double v8 = *(double *)&time1.value;
    double v9 = v8 + PSSequenceBehavior::getStart(this, &v21);
    double v10 = *(double *)&time1.value;
    double v11 = v10 + (*(double (**)(PSSequenceBehavior *, CMTime *))(*(void *)this + 672))(this, &v21);
    if (v9 <= v11)
    {
      unsigned int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), &v21, 0.0);
      unsigned int v13 = (*(uint64_t (**)(PSSequenceBehavior *, CMTime *))(*(void *)this + 664))(this, &v21);
      if (v13) {
        double v14 = (double)v13;
      }
      else {
        double v14 = 1.0;
      }
      OZChannel::getValueAsDouble((OZChannel *)((char *)this + 5456), &v21, 0.0);
      if (ValueAsInt >= 2) {
        double v16 = v15 / v14;
      }
      else {
        double v16 = 0.0;
      }
      trapezoid(v7, v9, v11, v15 / v14, v16, time2.value);
    }
  }
}

double PSSequenceBehavior::getStart(PSSequenceBehavior *this, const CMTime *a2)
{
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 4896), a2, 0.0) != 2) {
    return 0.0;
  }

  OZChannel::getValueAsDouble((OZChannel *)((char *)this + 5152), a2, 0.0);
  return result;
}

double trapezoid(double a1, double a2, double a3, double a4, double a5, unsigned __int8 a6)
{
  double v6 = a2 - a4;
  double v7 = 0.0;
  if (a2 - a4 <= a1)
  {
    double v8 = a3 + a5;
    while (1)
    {
      if (a1 < a2) {
        return (a1 - v6) / (a2 - v6) + 0.0;
      }
      if (a1 <= a3) {
        break;
      }
      if (v8 >= a1)
      {
        double v7 = 1.0 - (a1 - a3) / (v8 - a3);
        if (a6)
        {
          trapezoid(a1 + -1.0, a2, a3, a4, a5, 0);
          if (v7 < v12) {
            return v12;
          }
        }
        return v7;
      }
      BOOL v9 = v6 + 1.0 < a1;
      a1 = a1 + -1.0;
      if (v6 > a1) {
        BOOL v9 = 0;
      }
      char v10 = v9 & a6;
      a6 = 0;
      if ((v10 & 1) == 0) {
        return v7;
      }
    }
    double v7 = 1.0;
    if (((a5 == 0.0) & a6) != 0)
    {
      trapezoid(a1 + -1.0, a2, a3, a4, a5, 0);
      if (v11 <= 0.0) {
        return 1.0;
      }
      else {
        return v11;
      }
    }
  }
  return v7;
}

void PSSequenceBehavior::getValuesWithInfluence(PSSequenceBehavior *this, CMTime *a2, double a3, PSSequencedValues *a4)
{
  PSSequenceBehavior::getInfluence(this, a2, a3);
  double v49 = v8;
  if ((*((unsigned char *)this + 408) & 2) == 0)
  {
    double v9 = v8;
    if (OZChannelRotation3D::isQuaternionMode((PSSequenceBehavior *)((char *)this + 352)))
    {
      *(void *)&v44.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0x3FF0000000000000;
      memset(v44.var0.var1, 0, 24);
      v48[0] = 1.0;
      memset(&v48[1], 0, 24);
      OZChannelRotation3D::getValueAsQuatd((uint64_t)this + 352, v48, a2, 0.0);
      slerp<double>((double *)&v44.var0.var0, v48, &v49, (uint64_t)&v45);
      if (&v45 != (double *)a4)
      {
        *(double *)a4 = v45;
        *(_OWORD *)((char *)a4 + 8) = v46;
        *((void *)a4 + 3) = v47;
      }
    }
    else
    {
      OZChannel::getValueAsDouble((OZChannel *)((char *)this + 488), a2, 0.0);
      double v11 = v9 * v10;
      OZChannel::getValueAsDouble((OZChannel *)((char *)this + 640), a2, 0.0);
      double v13 = v9 * v12;
      OZChannel::getValueAsDouble((OZChannel *)((char *)this + 792), a2, 0.0);
      double v42 = v9 * v14;
      __double2 v15 = __sincos_stret(v11 * 0.5);
      double v16 = v15.__sinval * 0.0;
      __double2 v17 = __sincos_stret(v13 * 0.5);
      double v18 = v17.__sinval * 0.0;
      __double2 v19 = __sincos_stret(v42 * 0.5);
      double v20 = v15.__cosval * v17.__cosval - (v16 * v18 + v16 * v17.__sinval + v15.__sinval * v18);
      double v21 = v15.__sinval * v17.__cosval + v15.__cosval * v18 + v16 * v17.__sinval - v16 * v18;
      double v22 = v16 * v17.__cosval + v15.__cosval * v17.__sinval + v15.__sinval * v18 - v16 * v18;
      double v23 = v16 * v18 - v15.__sinval * v17.__sinval + v16 * v17.__cosval + v15.__cosval * v18;
      double v24 = v19.__sinval * 0.0 * v21;
      double v25 = v19.__sinval * 0.0 * v22;
      double v26 = v19.__sinval * 0.0 * v20;
      double v27 = v19.__sinval * 0.0 * v23;
      *((double *)a4 + 2) = v27 - v19.__sinval * v21 + v19.__cosval * v22 + v26;
      *((double *)a4 + 3) = v24 - v25 + v19.__cosval * v23 + v19.__sinval * v20;
      *(double *)a4 = v19.__cosval * v20 - (v19.__sinval * v23 + v24 + v25);
      *((double *)a4 + 1) = v19.__sinval * v22 - v27 + v19.__cosval * v21 + v26;
    }
  }
  if ((*((unsigned char *)this + 1264) & 2) == 0)
  {
    PCColor::PCColor(&v44);
    OZChannelColorNoAlpha::getColor((PSSequenceBehavior *)((char *)this + 1208), a2, &v44, a3);
    float v28 = v49;
    PCColor::mix((PCColor *)((char *)a4 + 32), &v44, v28);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v44.var1._obj);
  }
  if ((*((unsigned char *)this + 2272) & 2) == 0)
  {
    double v29 = v49;
    double v30 = *((double *)a4 + 11);
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 2216), a2, a3);
    *((double *)a4 + 11) = v30 + v29 * (v31 - v30);
  }
  if ((*((unsigned char *)this + 2424) & 2) == 0 || (*((unsigned char *)this + 3016) & 2) == 0)
  {
    *(void *)&v44.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0;
    v48[0] = 0.0;
    double v45 = 0.0;
    OZChannelScale3D::getValue((PSSequenceBehavior *)((char *)this + 2368), a2, (double *)&v44.var0.var0, v48, &v45, a3);
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 2960), a2, a3);
    v33.f64[0] = *(float64_t *)&v44.var0.var0;
    double v34 = v49;
    double v35 = *((double *)a4 + 14) + v49 * (v45 - *((double *)a4 + 14));
    v33.f64[1] = v48[0];
    *((float64x2_t *)a4 + 6) = vaddq_f64(*((float64x2_t *)a4 + 6), vmulq_n_f64(vsubq_f64(vmulq_n_f64(v33, v32), *((float64x2_t *)a4 + 6)), v49));
    *((double *)a4 + 14) = v35;
    if ((*((unsigned char *)this + 3016) & 2) == 0) {
      *((double *)a4 + 18) = *((double *)a4 + 18) + v34 * (v32 - *((double *)a4 + 18));
    }
  }
  if ((*((unsigned char *)this + 3168) & 2) == 0)
  {
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 3248), a2, a3);
    float64_t v43 = v36;
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 3400), a2, a3);
    float64_t v41 = v37;
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 3848), a2, a3);
    double v39 = v38 * v49;
    v40.f64[0] = v43;
    v40.f64[1] = v41;
    *(float64x2_t *)((char *)a4 + 120) = vaddq_f64(vmulq_n_f64(v40, v49), *(float64x2_t *)((char *)a4 + 120));
    *((double *)a4 + 17) = v39 + *((double *)a4 + 17);
  }
}

void sub_1B7DF21FC(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v1 + 48));
  _Unwind_Resume(a1);
}

double PSSequenceBehavior::getCompletion(PSSequenceBehavior *this, const CMTime *a2, double a3)
{
  double v6 = 0.0;
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), MEMORY[0x1E4F1FA48], 0.0) == 4)
  {
    (*(void (**)(void *__return_ptr, PSSequenceBehavior *))(*(void *)this + 608))(v23, this);
    unsigned int v7 = (*(uint64_t (**)(PSSequenceBehavior *, const CMTime *))(*(void *)this + 664))(this, a2);
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 5456), a2, 0.0);
    double v9 = v8;
    (*(void (**)(CMTime *__return_ptr, PSSequenceBehavior *))(*(void *)this + 608))(v22, this);
    long long v20 = 0uLL;
    CMTimeEpoch epoch = 0;
    CMTime v19 = v22[0];
    OZBehavior::getFrameDuration(this, &v16);
    CMTime time1 = v22[0];
    CMTime time2 = v22[1];
    PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v24);
    CMTime time1 = v24;
    *(__n128 *)&time2.value = v16;
    time2.CMTimeEpoch epoch = v17;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v18);
    CMTime time1 = *a2;
    CMTime time2 = v19;
    if (CMTimeCompare(&time1, &time2) < 0)
    {
      double v10 = &v19;
    }
    else
    {
      CMTime time1 = *a2;
      CMTime time2 = v18;
      double v10 = CMTimeCompare(&time1, &time2) <= 0 ? a2 : &v18;
    }
    long long v20 = *(_OWORD *)&v10->value;
    CMTimeEpoch epoch = v10->epoch;
    double v11 = (*(double (**)(PSSequenceBehavior *, long long *, double))(*(void *)this + 688))(this, &v20, a3);
    time1.value = 0;
    LOBYTE(time2.value) = 0;
    (*(void (**)(PSSequenceBehavior *, long long *, CMTime *, CMTime *))(*(void *)this + 680))(this, &v20, &time1, &time2);
    double v6 = 1.0;
    if (v11 > *(double *)&time1.value)
    {
      double v12 = v9 / (double)v7;
      if (v12 + *(double *)&time1.value >= v11)
      {
        double v14 = v11 - *(double *)&time1.value;
        return 1.0 - v14 / v12;
      }
      if (!LOBYTE(time2.value)) {
        return 0.0;
      }
      double v13 = v11 + -1.0;
      if (v11 + -1.0 > *(double *)&time1.value)
      {
        double v6 = 0.0;
        if (v12 + *(double *)&time1.value >= v13)
        {
          double v14 = v13 - *(double *)&time1.value;
          return 1.0 - v14 / v12;
        }
      }
    }
  }
  return v6;
}

void PSSequenceBehavior::getValuesRemapTime(uint64_t a1, CMTime *a2, uint64_t a3, double a4)
{
  (*(void (**)(CMTime *__return_ptr))(*(void *)a1 + 608))(v24);
  CMTime v23 = v24[1];
  PSSequenceBehavior::getKeyframeExtent((PSSequenceBehavior *)a1, &time2, &time1);
  memset(&v22, 0, sizeof(v22));
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v22);
  CMTime time1 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  CMTime time2 = v22;
  if (!CMTimeCompare(&time1, &time2)) {
    CMTime v22 = v23;
  }
  double Completion = PSSequenceBehavior::getCompletion((PSSequenceBehavior *)a1, a2, a4);
  memset(&v21, 0, sizeof(v21));
  operator*(&v22, &v20, Completion);
  CMTime time2 = v24[0];
  CMTime time1 = v20;
  PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v21);
  if ((*(unsigned char *)(a1 + 408) & 2) == 0) {
    OZChannelRotation3D::getValueAsQuatd(a1 + 352, (double *)a3, a2, 0.0);
  }
  if ((*(unsigned char *)(a1 + 1264) & 2) == 0)
  {
    OZChannelColorNoAlpha::getColor((OZChannelColorNoAlpha *)(a1 + 1208), &v21, (PCColor *)(a3 + 32), a4);
    PCColor::setAlpha((PCColor *)(a3 + 32), 1.0);
  }
  if ((*(unsigned char *)(a1 + 2272) & 2) == 0)
  {
    OZChannel::getValueAsDouble((OZChannel *)(a1 + 2216), &v21, a4);
    *(double *)(a3 + 88) = v9 * *(double *)(a3 + 88);
  }
  if ((*(unsigned char *)(a1 + 2424) & 2) == 0 || (*(unsigned char *)(a1 + 3016) & 2) == 0)
  {
    time1.value = 0;
    time2.value = 0;
    v20.value = 0;
    OZChannelScale3D::getValue((OZChannelScale3D *)(a1 + 2368), &v21, (double *)&time1.value, (double *)&time2.value, (double *)&v20.value, a4);
    OZChannel::getValueAsDouble((OZChannel *)(a1 + 2960), &v21, a4);
    double v11 = v10 * *(double *)&time1.value;
    v12.f64[0] = v10 * *(double *)&time2.value;
    float64x2_t v13 = *(float64x2_t *)(a3 + 104);
    *(void *)&v12.f64[1] = v20.value;
    *(double *)(a3 + 96) = v11 * v13.f64[0];
    *(float64x2_t *)(a3 + 104) = vmulq_f64(v12, v13);
  }
  if ((*(unsigned char *)(a1 + 3168) & 2) == 0)
  {
    OZChannel::getValueAsDouble((OZChannel *)(a1 + 3248), &v21, a4);
    double v15 = v14;
    OZChannel::getValueAsDouble((OZChannel *)(a1 + 3400), &v21, a4);
    double v17 = v16;
    OZChannel::getValueAsDouble((OZChannel *)(a1 + 3848), &v21, a4);
    double v18 = v17 + *(double *)(a3 + 128);
    *(double *)(a3 + 120) = v15 + *(double *)(a3 + 120);
    *(double *)(a3 + 128) = v18;
    *(double *)(a3 + 136) = v19 + *(double *)(a3 + 136);
  }
}

void PSSequenceBehavior::getKeyframeExtent(PSSequenceBehavior *this, CMTime *a2, CMTime *a3)
{
  __p = 0;
  double v108 = 0;
  CMTime v109 = 0;
  unsigned int v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v109, 1uLL);
  double v8 = &v7[8 * v6];
  *(void *)unsigned int v7 = (char *)this + 352;
  double v9 = v7 + 8;
  double v11 = (char *)__p;
  double v10 = v108;
  float64x2_t v12 = v7;
  if (v108 != __p)
  {
    do
    {
      uint64_t v13 = *((void *)v10 - 1);
      v10 -= 8;
      *((void *)v12 - 1) = v13;
      v12 -= 8;
    }
    while (v10 != v11);
    double v10 = (char *)__p;
  }
  __p = v12;
  double v108 = v7 + 8;
  CMTime v109 = &v7[8 * v6];
  if (v10)
  {
    operator delete(v10);
    double v8 = v109;
  }
  double v108 = v7 + 8;
  double v14 = (char *)this + 1208;
  if (v9 >= v8)
  {
    uint64_t v16 = (v9 - (unsigned char *)__p) >> 3;
    if ((unint64_t)(v16 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v17 = v8 - (unsigned char *)__p;
    uint64_t v18 = v17 >> 2;
    if (v17 >> 2 <= (unint64_t)(v16 + 1)) {
      uint64_t v18 = v16 + 1;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v18;
    }
    if (v19) {
      CMTime v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v109, v19);
    }
    else {
      CMTime v20 = 0;
    }
    CMTime v21 = &v20[8 * v16];
    CMTime v22 = &v20[8 * v19];
    *(void *)CMTime v21 = v14;
    double v15 = v21 + 8;
    CMTime v24 = (char *)__p;
    CMTime v23 = v108;
    if (v108 != __p)
    {
      do
      {
        uint64_t v25 = *((void *)v23 - 1);
        v23 -= 8;
        *((void *)v21 - 1) = v25;
        v21 -= 8;
      }
      while (v23 != v24);
      CMTime v23 = (char *)__p;
    }
    __p = v21;
    double v108 = v15;
    CMTime v109 = v22;
    if (v23) {
      operator delete(v23);
    }
  }
  else
  {
    *((void *)v7 + 1) = v14;
    double v15 = v7 + 16;
  }
  double v108 = v15;
  double v26 = (char *)this + 2216;
  if (v15 >= v109)
  {
    uint64_t v28 = (v15 - (unsigned char *)__p) >> 3;
    if ((unint64_t)(v28 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v29 = (v109 - (unsigned char *)__p) >> 2;
    if (v29 <= v28 + 1) {
      unint64_t v29 = v28 + 1;
    }
    if ((unint64_t)(v109 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v30 = v29;
    }
    if (v30) {
      double v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v109, v30);
    }
    else {
      double v31 = 0;
    }
    double v32 = &v31[8 * v28];
    float64x2_t v33 = &v31[8 * v30];
    *(void *)double v32 = v26;
    double v27 = v32 + 8;
    double v35 = (char *)__p;
    double v34 = v108;
    if (v108 != __p)
    {
      do
      {
        uint64_t v36 = *((void *)v34 - 1);
        v34 -= 8;
        *((void *)v32 - 1) = v36;
        v32 -= 8;
      }
      while (v34 != v35);
      double v34 = (char *)__p;
    }
    __p = v32;
    double v108 = v27;
    CMTime v109 = v33;
    if (v34) {
      operator delete(v34);
    }
  }
  else
  {
    *(void *)double v15 = v26;
    double v27 = v15 + 8;
  }
  double v108 = v27;
  double v37 = (char *)this + 2368;
  if (v27 >= v109)
  {
    uint64_t v39 = (v27 - (unsigned char *)__p) >> 3;
    if ((unint64_t)(v39 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v40 = (v109 - (unsigned char *)__p) >> 2;
    if (v40 <= v39 + 1) {
      unint64_t v40 = v39 + 1;
    }
    if ((unint64_t)(v109 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v41 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v41 = v40;
    }
    if (v41) {
      double v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v109, v41);
    }
    else {
      double v42 = 0;
    }
    float64_t v43 = &v42[8 * v39];
    PCColor v44 = &v42[8 * v41];
    *(void *)float64_t v43 = v37;
    double v38 = v43 + 8;
    long long v46 = (char *)__p;
    double v45 = v108;
    if (v108 != __p)
    {
      do
      {
        uint64_t v47 = *((void *)v45 - 1);
        v45 -= 8;
        *((void *)v43 - 1) = v47;
        v43 -= 8;
      }
      while (v45 != v46);
      double v45 = (char *)__p;
    }
    __p = v43;
    double v108 = v38;
    CMTime v109 = v44;
    if (v45) {
      operator delete(v45);
    }
  }
  else
  {
    *(void *)double v27 = v37;
    double v38 = v27 + 8;
  }
  double v108 = v38;
  CMTimeValue v48 = (char *)this + 2960;
  if (v38 >= v109)
  {
    uint64_t v50 = (v38 - (unsigned char *)__p) >> 3;
    if ((unint64_t)(v50 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v51 = (v109 - (unsigned char *)__p) >> 2;
    if (v51 <= v50 + 1) {
      unint64_t v51 = v50 + 1;
    }
    if ((unint64_t)(v109 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v52 = v51;
    }
    if (v52) {
      double v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v109, v52);
    }
    else {
      double v53 = 0;
    }
    uint64_t v54 = &v53[8 * v50];
    unint64_t v55 = &v53[8 * v52];
    *(void *)uint64_t v54 = v48;
    double v49 = v54 + 8;
    OZRenderState v57 = (char *)__p;
    unint64_t v56 = v108;
    if (v108 != __p)
    {
      do
      {
        uint64_t v58 = *((void *)v56 - 1);
        v56 -= 8;
        *((void *)v54 - 1) = v58;
        v54 -= 8;
      }
      while (v56 != v57);
      unint64_t v56 = (char *)__p;
    }
    __p = v54;
    double v108 = v49;
    CMTime v109 = v55;
    if (v56) {
      operator delete(v56);
    }
  }
  else
  {
    *(void *)double v38 = v48;
    double v49 = v38 + 8;
  }
  double v108 = v49;
  unint64_t v59 = (char *)this + 3112;
  long long v99 = a2;
  if (v49 >= v109)
  {
    uint64_t v61 = (v49 - (unsigned char *)__p) >> 3;
    if ((unint64_t)(v61 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v62 = (v109 - (unsigned char *)__p) >> 2;
    if (v62 <= v61 + 1) {
      unint64_t v62 = v61 + 1;
    }
    if ((unint64_t)(v109 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v63 = v62;
    }
    if (v63) {
      unint64_t v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v109, v63);
    }
    else {
      unint64_t v64 = 0;
    }
    uint64_t v65 = &v64[8 * v61];
    uint64_t v66 = &v64[8 * v63];
    *(void *)uint64_t v65 = v59;
    unint64_t v60 = v65 + 8;
    unint64_t v68 = (char *)__p;
    unint64_t v67 = v108;
    if (v108 != __p)
    {
      do
      {
        uint64_t v69 = *((void *)v67 - 1);
        v67 -= 8;
        *((void *)v65 - 1) = v69;
        v65 -= 8;
      }
      while (v67 != v68);
      unint64_t v67 = (char *)__p;
    }
    __p = v65;
    double v108 = v60;
    CMTime v109 = v66;
    if (v67) {
      operator delete(v67);
    }
  }
  else
  {
    *(void *)double v49 = v59;
    unint64_t v60 = v49 + 8;
  }
  double v108 = v60;
  uint64_t v70 = (char *)__p;
  unint64_t v71 = (long long *)MEMORY[0x1E4F1FA48];
  if (v60 == __p)
  {
    long long v96 = *MEMORY[0x1E4F1FA48];
    a2->CMTimeEpoch epoch = *(void *)(MEMORY[0x1E4F1FA48] + 16);
    *(_OWORD *)&a2->value = v96;
    long long v97 = *v71;
    a3->CMTimeEpoch epoch = *((void *)v71 + 2);
    *(_OWORD *)&a3->value = v97;
LABEL_123:
    double v108 = v60;
    operator delete(v60);
    return;
  }
  CMTime v98 = a3;
  char v72 = 0;
  CMTime v106 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
  CMTime v105 = v106;
  do
  {
    float64_t v73 = *(const void **)v70;
    if ((*(void *)(*(void *)v70 + 56) & 0x1000) != 0)
    {
      double v81 = v60;
      float64x2_t v100 = 0;
      float64x2_t v101 = 0;
      uint64_t v102 = 0;
      OZChannelFolder::getAllDescendantsFlattened((uint64_t)v82, (void **)&v100, 0, 0);
      double v83 = v100;
      uint64_t v84 = v101;
      if (v100 != v101)
      {
        do
        {
          if (*v83) {
          else
          }
            double v85 = 0;
          if ((*((uint64_t (**)(OZChannel *, void))v85->var0 + 69))(v85, 0))
          {
            OZChannel::getKeyframeMinTime(v85, (uint64_t)&time1);
            CMTime v104 = time1;
            OZChannel::getKeyframeMaxTime(v85, (uint64_t)&time1);
            CMTime v103 = time1;
            if (v72)
            {
              CMTime time1 = v106;
              CMTime time2 = v104;
              int32_t v86 = CMTimeCompare(&time1, &time2);
              unint64_t v87 = &v106;
              if (v86 > 0) {
                unint64_t v87 = &v104;
              }
              long long v88 = *(_OWORD *)&v87->value;
              v106.CMTimeEpoch epoch = v87->epoch;
              *(_OWORD *)&v106.value = v88;
              CMTime time1 = v105;
              CMTime time2 = v103;
              int32_t v89 = CMTimeCompare(&time1, &time2);
              double v90 = &v105;
              if (v89 < 0) {
                double v90 = &v103;
              }
              long long v91 = *(_OWORD *)&v90->value;
              v105.CMTimeEpoch epoch = v90->epoch;
              *(_OWORD *)&v105.value = v91;
            }
            else
            {
              CMTime v106 = v104;
              CMTime v105 = v103;
            }
            char v72 = 1;
          }
          ++v83;
        }
        while (v83 != v84);
        double v83 = v100;
      }
      unint64_t v60 = v81;
      if (v83)
      {
        float64x2_t v101 = v83;
        operator delete(v83);
      }
    }
    else
    {
      if ((*((uint64_t (**)(void))v74->var0 + 69))())
      {
        OZChannel::getKeyframeMinTime(v74, (uint64_t)&time1);
        CMTime v104 = time1;
        OZChannel::getKeyframeMaxTime(v74, (uint64_t)&time1);
        CMTime v103 = time1;
        if (v72)
        {
          CMTime time1 = v106;
          CMTime time2 = v104;
          int32_t v75 = CMTimeCompare(&time1, &time2);
          uint64_t v76 = &v106;
          if (v75 > 0) {
            uint64_t v76 = &v104;
          }
          long long v77 = *(_OWORD *)&v76->value;
          v106.CMTimeEpoch epoch = v76->epoch;
          *(_OWORD *)&v106.value = v77;
          CMTime time1 = v105;
          CMTime time2 = v103;
          int32_t v78 = CMTimeCompare(&time1, &time2);
          int v79 = &v105;
          if (v78 < 0) {
            int v79 = &v103;
          }
          long long v80 = *(_OWORD *)&v79->value;
          v105.CMTimeEpoch epoch = v79->epoch;
          *(_OWORD *)&v105.value = v80;
        }
        else
        {
          CMTime v106 = v104;
          CMTime v105 = v103;
        }
        char v72 = 1;
      }
    }
    v70 += 8;
  }
  while (v70 != v60);
  OZRenderState v92 = &v106;
  if ((v72 & 1) == 0) {
    OZRenderState v92 = (CMTime *)MEMORY[0x1E4F1FA48];
  }
  uint64_t v93 = &v105;
  if ((v72 & 1) == 0) {
    uint64_t v93 = (CMTime *)MEMORY[0x1E4F1FA48];
  }
  long long v94 = *(_OWORD *)&v92->value;
  v99->CMTimeEpoch epoch = v92->epoch;
  *(_OWORD *)&v99->value = v94;
  long long v95 = *(_OWORD *)&v93->value;
  v98->CMTimeEpoch epoch = v93->epoch;
  *(_OWORD *)&v98->value = v95;
  unint64_t v60 = (char *)__p;
  if (__p) {
    goto LABEL_123;
  }
}

void sub_1B7DF305C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void PSSequenceBehavior::getValues(PSSequenceBehavior *this, CMTime *a2, double a3, PSSequencedValues *a4)
{
  CMTime v8 = *a2;
  if ((*(unsigned int (**)(PSSequenceBehavior *, CMTime *, void, uint64_t, uint64_t))(*(void *)this + 296))(this, &v8, 0, 1, 1))
  {
    if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), MEMORY[0x1E4F1FA48], 0.0) == 4) {
      PSSequenceBehavior::getValuesRemapTime((uint64_t)this, a2, (uint64_t)a4, a3);
    }
    else {
      PSSequenceBehavior::getValuesWithInfluence(this, a2, a3, a4);
    }
  }
}

uint64_t PSSequenceBehavior::arAddToUndo(PSSequenceBehavior *this, const PCString *a2)
{
  return (*(uint64_t (**)(void))(*((void *)this + 2) + 176))();
}

uint64_t non-virtual thunk to'PSSequenceBehavior::arAddToUndo(PSSequenceBehavior *this, const PCString *a2)
{
  return (*(uint64_t (**)(char *, const PCString *))(*((void *)this - 40) + 176))((char *)this - 320, a2);
}

void PSSequenceBehavior::arAddChannel(PSSequenceBehavior *this, OZChannelBase *a2)
{
  OZChannelBase::resetFlag(a2, 2, 0);
  var6 = a2->var6;
  if (var6) {
    OZChannelBase::resetFlag((OZChannelBase *)var6, 2, 0);
  }
  if (v4)
  {
    LOBYTE(v4[3].var13) = 1;
    uint64_t ObjectManipulator = OZChannelBase::getObjectManipulator(v4);
    if (ObjectManipulator)
    {
      uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)ObjectManipulator + 264))(ObjectManipulator);
      if (v6)
      {
        unsigned int v7 = *(OZDocument **)(v6 + 1584);
        OZDocument::postNotification(v7, 32);
      }
    }
  }
}

void PSSequenceBehavior::arRemoveChannel(PSSequenceBehavior *this, OZChannelBase *a2)
{
  OZChannelBase::setFlag(a2, 2, 0);
  if (a2)
  {
    if (v3)
    {
      LOBYTE(v3[3].var13) = 0;
      uint64_t ObjectManipulator = OZChannelBase::getObjectManipulator(v3);
      if (ObjectManipulator)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)ObjectManipulator + 264))(ObjectManipulator);
        if (v5)
        {
          uint64_t v6 = *(OZDocument **)(v5 + 1584);
          OZDocument::postNotification(v6, 32);
        }
      }
    }
  }
}

void PSSequenceBehavior::arGetChannelList(uint64_t a1, void **a2)
{
  uint64_t v4 = a1 + 352;
  uint64_t v6 = (uint64_t)(a2 + 2);
  unint64_t v5 = (unint64_t)a2[2];
  unsigned int v7 = a2[1];
  if ((unint64_t)v7 >= v5)
  {
    uint64_t v9 = ((char *)v7 - (unsigned char *)*a2) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      goto LABEL_82;
    }
    uint64_t v10 = v5 - (void)*a2;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    double v14 = &v13[8 * v9];
    double v15 = &v13[8 * v12];
    *(void *)double v14 = v4;
    CMTime v8 = v14 + 8;
    uint64_t v17 = (char *)*a2;
    uint64_t v16 = (char *)a2[1];
    if (v16 != *a2)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *((void *)v14 - 1) = v18;
        v14 -= 8;
      }
      while (v16 != v17);
      uint64_t v16 = (char *)*a2;
    }
    *a2 = v14;
    a2[1] = v8;
    a2[2] = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *unsigned int v7 = v4;
    CMTime v8 = v7 + 1;
  }
  a2[1] = v8;
  uint64_t v19 = a1 + 1208;
  unint64_t v20 = (unint64_t)a2[2];
  if ((unint64_t)v8 >= v20)
  {
    uint64_t v22 = ((char *)v8 - (unsigned char *)*a2) >> 3;
    if ((unint64_t)(v22 + 1) >> 61) {
      goto LABEL_82;
    }
    uint64_t v23 = v20 - (void)*a2;
    uint64_t v24 = v23 >> 2;
    if (v23 >> 2 <= (unint64_t)(v22 + 1)) {
      uint64_t v24 = v22 + 1;
    }
    if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v25 = v24;
    }
    if (v25) {
      double v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6, v25);
    }
    else {
      double v26 = 0;
    }
    double v27 = &v26[8 * v22];
    uint64_t v28 = &v26[8 * v25];
    *(void *)double v27 = v19;
    CMTime v21 = v27 + 8;
    unint64_t v30 = (char *)*a2;
    unint64_t v29 = (char *)a2[1];
    if (v29 != *a2)
    {
      do
      {
        uint64_t v31 = *((void *)v29 - 1);
        v29 -= 8;
        *((void *)v27 - 1) = v31;
        v27 -= 8;
      }
      while (v29 != v30);
      unint64_t v29 = (char *)*a2;
    }
    *a2 = v27;
    a2[1] = v21;
    a2[2] = v28;
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    *CMTime v8 = v19;
    CMTime v21 = v8 + 1;
  }
  a2[1] = v21;
  uint64_t v32 = a1 + 2216;
  unint64_t v33 = (unint64_t)a2[2];
  if ((unint64_t)v21 >= v33)
  {
    uint64_t v35 = ((char *)v21 - (unsigned char *)*a2) >> 3;
    if ((unint64_t)(v35 + 1) >> 61) {
      goto LABEL_82;
    }
    uint64_t v36 = v33 - (void)*a2;
    uint64_t v37 = v36 >> 2;
    if (v36 >> 2 <= (unint64_t)(v35 + 1)) {
      uint64_t v37 = v35 + 1;
    }
    if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v38 = v37;
    }
    if (v38) {
      uint64_t v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6, v38);
    }
    else {
      uint64_t v39 = 0;
    }
    unint64_t v40 = &v39[8 * v35];
    unint64_t v41 = &v39[8 * v38];
    *(void *)unint64_t v40 = v32;
    double v34 = v40 + 8;
    float64_t v43 = (char *)*a2;
    double v42 = (char *)a2[1];
    if (v42 != *a2)
    {
      do
      {
        uint64_t v44 = *((void *)v42 - 1);
        v42 -= 8;
        *((void *)v40 - 1) = v44;
        v40 -= 8;
      }
      while (v42 != v43);
      double v42 = (char *)*a2;
    }
    *a2 = v40;
    a2[1] = v34;
    a2[2] = v41;
    if (v42) {
      operator delete(v42);
    }
  }
  else
  {
    *CMTime v21 = v32;
    double v34 = v21 + 1;
  }
  a2[1] = v34;
  uint64_t v45 = a1 + 2368;
  unint64_t v46 = (unint64_t)a2[2];
  if ((unint64_t)v34 >= v46)
  {
    uint64_t v48 = ((char *)v34 - (unsigned char *)*a2) >> 3;
    if ((unint64_t)(v48 + 1) >> 61) {
      goto LABEL_82;
    }
    uint64_t v49 = v46 - (void)*a2;
    uint64_t v50 = v49 >> 2;
    if (v49 >> 2 <= (unint64_t)(v48 + 1)) {
      uint64_t v50 = v48 + 1;
    }
    if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v51 = v50;
    }
    if (v51) {
      unint64_t v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6, v51);
    }
    else {
      unint64_t v52 = 0;
    }
    double v53 = &v52[8 * v48];
    uint64_t v54 = &v52[8 * v51];
    *(void *)double v53 = v45;
    uint64_t v47 = v53 + 8;
    unint64_t v56 = (char *)*a2;
    unint64_t v55 = (char *)a2[1];
    if (v55 != *a2)
    {
      do
      {
        uint64_t v57 = *((void *)v55 - 1);
        v55 -= 8;
        *((void *)v53 - 1) = v57;
        v53 -= 8;
      }
      while (v55 != v56);
      unint64_t v55 = (char *)*a2;
    }
    *a2 = v53;
    a2[1] = v47;
    a2[2] = v54;
    if (v55) {
      operator delete(v55);
    }
  }
  else
  {
    *double v34 = v45;
    uint64_t v47 = v34 + 1;
  }
  a2[1] = v47;
  uint64_t v58 = a1 + 3112;
  unint64_t v59 = (unint64_t)a2[2];
  if ((unint64_t)v47 < v59)
  {
    *uint64_t v47 = v58;
    unint64_t v60 = v47 + 1;
    goto LABEL_81;
  }
  uint64_t v61 = ((char *)v47 - (unsigned char *)*a2) >> 3;
  if ((unint64_t)(v61 + 1) >> 61) {
LABEL_82:
  }
    std::vector<double>::__throw_length_error[abi:ne180100]();
  uint64_t v62 = v59 - (void)*a2;
  uint64_t v63 = v62 >> 2;
  if (v62 >> 2 <= (unint64_t)(v61 + 1)) {
    uint64_t v63 = v61 + 1;
  }
  if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v64 = v63;
  }
  if (v64) {
    uint64_t v65 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6, v64);
  }
  else {
    uint64_t v65 = 0;
  }
  uint64_t v66 = &v65[8 * v61];
  unint64_t v67 = &v65[8 * v64];
  *(void *)uint64_t v66 = v58;
  unint64_t v60 = v66 + 8;
  uint64_t v69 = (char *)*a2;
  unint64_t v68 = (char *)a2[1];
  if (v68 != *a2)
  {
    do
    {
      uint64_t v70 = *((void *)v68 - 1);
      v68 -= 8;
      *((void *)v66 - 1) = v70;
      v66 -= 8;
    }
    while (v68 != v69);
    unint64_t v68 = (char *)*a2;
  }
  *a2 = v66;
  a2[1] = v60;
  a2[2] = v67;
  if (v68) {
    operator delete(v68);
  }
LABEL_81:
  a2[1] = v60;
}

void non-virtual thunk to'PSSequenceBehavior::arGetChannelList(uint64_t a1, void **a2)
{
}

uint64_t PSSequenceBehavior::arGetObjectManipulator(PSSequenceBehavior *this)
{
  uint64_t v1 = (OZChannelBase *)(*(uint64_t (**)(PSSequenceBehavior *))(*(void *)this + 312))(this);

  return OZChannelBase::getObjectManipulator(v1);
}

uint64_t non-virtual thunk to'PSSequenceBehavior::arGetObjectManipulator(PSSequenceBehavior *this)
{
  uint64_t v1 = (OZChannelBase *)(*(uint64_t (**)(char *))(*((void *)this - 42) + 312))((char *)this - 336);

  return OZChannelBase::getObjectManipulator(v1);
}

uint64_t PSSequenceBehavior::getOffsetAndDoWrap(PSSequenceBehavior *this, const CMTime *a2, double *a3, BOOL *a4)
{
  unsigned int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 5864), a2, 0.0);
  int v9 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), a2, 0.0);
  *a4 = 0;
  if (ValueAsInt > 6 || ValueAsInt == 4)
  {
    double v26 = 1.0
        / (double)(*(unsigned int (**)(PSSequenceBehavior *, const CMTime *))(*(void *)this + 664))(this, a2);
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 5456), a2, 0.0);
    double v28 = v27 * v26 + 1.0;
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 6120), a2, 0.0);
    double v30 = v29;
    uint64_t result = OZChannel::getValueAsInt((OZChannel *)((char *)this + 5608), a2, 0.0);
    double v31 = 1.0 - v30;
    if (result != 1) {
      double v31 = v30;
    }
    double v32 = v28 * v31 + 0.0;
  }
  else
  {
    int v11 = v9;
    (*(void (**)(CMTime *__return_ptr, PSSequenceBehavior *))(*(void *)this + 608))(&v67, this);
    CMTime v66 = v68;
    CMTime time1 = v68;
    CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    uint64_t result = CMTimeCompare(&time1, &time2);
    if ((int)result <= 0)
    {
      *a3 = 0.0;
      return result;
    }
    unsigned int v13 = v11 & 0xFFFFFFFE;
    unsigned int v14 = (*(uint64_t (**)(PSSequenceBehavior *, const CMTime *))(*(void *)this + 664))(this, a2);
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 5456), a2, 0.0);
    double v16 = v15;
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 6272), a2, 0.0);
    double v18 = v17;
    int v19 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 6424), a2, 0.0);
    __n128 v64 = 0uLL;
    CMTimeEpoch v65 = 0;
    uint64_t v20 = (*(uint64_t (**)(PSSequenceBehavior *))(*(void *)this + 336))(this);
    OZSceneSettings::getFrameDuration((OZSceneSettings *)(v20 + 336), &v64);
    CMTime time2 = v67;
    CMTime time1 = *a2;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v62);
    CMTime time1 = v66;
    *(__n128 *)&time2.value = v64;
    time2.CMTimeEpoch epoch = v65;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)v61);
    operator/(&v62, (uint64_t)v61, (uint64_t)&time);
    double Seconds = CMTimeGetSeconds(&time);
    if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 5608), a2, 0.0) == 1) {
      double Seconds = 1.0 - Seconds;
    }
    if (v19 == 1)
    {
      int v22 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), MEMORY[0x1E4F1FA48], 0.0);
      double v23 = (double)v14;
      double v24 = v18 * (double)v14;
      if (v22 == 4)
      {
        double v25 = v16 + v24;
      }
      else if (v13 == 2)
      {
        double v25 = v16 + v16 + v24;
      }
      else
      {
        double v25 = v16 + v24 + -1.0;
      }
    }
    else
    {
      double v23 = (double)v14;
      double v25 = v18 * (double)v14;
    }
    double v33 = (Seconds * v25 + 0.0) / v23;
    time1.value = 0;
    modf(v33 + -0.000001, (long double *)&time1.value);
    if (*(double *)&time1.value <= v18 + -1.0) {
      double v34 = *(double *)&time1.value;
    }
    else {
      double v34 = v18 + -1.0;
    }
    BOOL v36 = v34 > 0.0 && v19 == 1;
    *a4 = v36;
    double v37 = 1.0 / v23;
    int v38 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), MEMORY[0x1E4F1FA48], 0.0);
    double v39 = v37 * 0.5;
    double v40 = v37 * -0.5;
    double v41 = v16 * v37;
    double v42 = v40 - v41;
    if (v13 != 2) {
      double v42 = v39;
    }
    if (v38 == 4) {
      double v43 = v39 - v41;
    }
    else {
      double v43 = v42;
    }
    int v44 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), MEMORY[0x1E4F1FA48], 0.0);
    double v45 = v41 + 1.0 + v40;
    if (v44 == 4) {
      double v45 = v40 + 1.0;
    }
    double v46 = v39 + 1.0;
    if (v13 == 2) {
      double v46 = 1.0 - v39 - v41;
    }
    if (v44 == 4) {
      double v46 = 1.0 - v39;
    }
    if (v19 == 1) {
      double v47 = v46;
    }
    else {
      double v47 = v45;
    }
    double v48 = v33 - v34;
    double v49 = v47 - v43;
    double v50 = v43 + v48 * (v47 - v43);
    *(double *)&time1.value = v50;
    switch(ValueAsInt)
    {
      case 1u:
        int v51 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 6680), MEMORY[0x1E4F1FA48], 0.0);
        double v53 = *(double *)&time1.value;
        if (v51)
        {
          double v54 = 1.0;
          double v55 = 0.0;
          goto LABEL_49;
        }
        double v60 = cos((*(double *)&time1.value - v43) * 3.14159265 / v49 * 0.5);
        double v59 = 1.0;
        goto LABEL_55;
      case 2u:
        int v56 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 6680), MEMORY[0x1E4F1FA48], 0.0);
        double v53 = *(double *)&time1.value;
        if (v56)
        {
          double v54 = 0.0;
          double v55 = 1.0;
          goto LABEL_49;
        }
        double v58 = sin((*(double *)&time1.value - v43) * 3.14159265 / v49 * 0.5);
        goto LABEL_58;
      case 3u:
        int v57 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 6680), MEMORY[0x1E4F1FA48], 0.0);
        double v53 = *(double *)&time1.value;
        if (v57)
        {
          double v54 = 0.5;
          double v55 = 0.5;
LABEL_49:
          PCMath::easeInOut((double *)&time1.value, v53, v54, v55, v43, v47, 0, v52);
        }
        else
        {
          double v58 = sin((*(double *)&time1.value - v43) * 3.14159265 / v49 + -1.57079633) * 0.5 + 0.5;
LABEL_58:
          *(double *)&time1.value = v43 + v49 * v58;
        }
LABEL_59:
        uint64_t result = OZChannel::getValueAsInt((OZChannel *)((char *)this + 6424), a2, 0.0);
        if (result == 2)
        {
          double v32 = *(double *)&time1.value;
          if (((int)v34 & 0x80000001) == 1) {
            double v32 = v47 + v43 - *(double *)&time1.value;
          }
        }
        else
        {
          double v32 = *(double *)&time1.value;
        }
        break;
      case 5u:
        if (v49 <= 0.0) {
          goto LABEL_59;
        }
        double v58 = (v50 - v43) / v49 * ((v50 - v43) / v49);
        goto LABEL_58;
      case 6u:
        if (v49 <= 0.0) {
          goto LABEL_59;
        }
        double v59 = 1.0;
        double v60 = (1.0 - (v50 - v43) / v49) * (1.0 - (v50 - v43) / v49);
LABEL_55:
        double v58 = v59 - v60;
        goto LABEL_58;
      default:
        goto LABEL_59;
    }
  }
  *a3 = v32;
  return result;
}

uint64_t PSSequenceBehavior::normalizeIndex(PSSequenceBehavior *this, double a2, const CMTime *a3)
{
  return (*(uint64_t (**)(PSSequenceBehavior *, const CMTime *))(*(void *)this + 664))(this, a3);
}

double PSSequenceBehavior::getEnd(PSSequenceBehavior *this, const CMTime *a2)
{
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), a2, 0.0);
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 4896), a2, 0.0) == 2)
  {
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 5304), a2, 0.0);
  }
  else
  {
    double result = 1.0;
    if ((ValueAsInt & 0xFFFFFFFE) == 2) {
      return 1.0
    }
           / (double)(*(unsigned int (**)(PSSequenceBehavior *, const CMTime *, double))(*(void *)this
                                                                                                  + 664))(this, a2, 1.0);
  }
  return result;
}

void PSPaintSequenceBehavior::PSPaintSequenceBehavior(PSPaintSequenceBehavior *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  PSSequenceBehavior::PSSequenceBehavior(this, a2, a3, a4);
  *unint64_t v5 = &unk_1F11919B8;
  v5[2] = &unk_1F1191C88;
  v5[6] = &unk_1F1191EE0;
  v5[42] = &unk_1F1191F38;
  *(_OWORD *)unsigned int v7 = xmmword_1B8387BC4;
  *(_OWORD *)&v7[12] = *(long long *)((char *)&xmmword_1B8387BC4 + 12);
  OZChannelEnum::setTags((OZChannelEnum *)(v5 + 733), v7, 7);
  PCURL::PCURL((PCURL *)&v6, @"Particle Paint Sequence Behavior Units Enum");
  OZChannelEnum::setStrings((const PCString *)this + 612, &v6, 1);
  PCString::~PCString(&v6);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 4640), 4194306, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 4640));
  OZChannel::setScale((OZChannel *)((char *)this + 5456), 100.0);
  OZChannel::setSuffix((OZChannel *)((char *)this + 5456), "%");
  OZChannel::setMin((OZChannel *)((char *)this + 5456), 0.0);
  OZChannel::setSliderMin((OZChannel *)((char *)this + 5456), 0.0);
  OZChannel::setSliderMax((OZChannel *)((char *)this + 5456), 1.0);
  OZChannel::setCoarseDelta((OZChannel *)((char *)this + 5456), *(double *)(*((void *)this + 698) + 32) / 100.0);
  OZChannel::setFineDelta((OZChannel *)((char *)this + 5456), *(double *)(*((void *)this + 698) + 24) / 100.0);
}

void sub_1B7DF41B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  PSSequenceBehavior::~PSSequenceBehavior(v10);
  _Unwind_Resume(a1);
}

void PSPaintSequenceBehavior::PSPaintSequenceBehavior(PSPaintSequenceBehavior *this, const PSPaintSequenceBehavior *a2, char a3)
{
  PSSequenceBehavior::PSSequenceBehavior(this, a2, a3);
  void *v3 = &unk_1F11919B8;
  v3[2] = &unk_1F1191C88;
  v3[6] = &unk_1F1191EE0;
  v3[42] = &unk_1F1191F38;
}

OZChannelBase *PSPaintSequenceBehavior::updateHiddenFlags(uint64_t a1)
{
  char v2 = (OZChannelBase *)(a1 + 5152);
  OZChannelBase::setFlag((OZChannelBase *)(a1 + 5152), 4194306, 1);
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 4896), MEMORY[0x1E4F1FA48], 0.0);
  if (ValueAsInt == 2)
  {
    OZChannelBase::resetFlag(v2, 4194306, 1);
    OZChannelBase::resetFlag((OZChannelBase *)(a1 + 5304), 4194306, 1);
  }
  else
  {
    int v4 = ValueAsInt;
    OZChannelBase::setFlag(v2, 4194306, 1);
    OZChannelBase::setFlag((OZChannelBase *)(a1 + 5304), 4194306, 1);
    if (v4 == 1)
    {
      OZChannelBase::setFlag((OZChannelBase *)(a1 + 5456), 4227072, 1);
      goto LABEL_6;
    }
  }
  OZChannelBase::resetFlag((OZChannelBase *)(a1 + 5456), 4227072, 1);
LABEL_6:
  int v5 = OZChannel::getValueAsInt((OZChannel *)(a1 + 5864), MEMORY[0x1E4F1FA48], 0.0);
  PCString v6 = (OZChannelBase *)(a1 + 6120);
  unsigned int v7 = (OZChannelBase *)(a1 + 6272);
  if (v5 == 4)
  {
    OZChannelBase::resetFlag(v6, 4194306, 1);
    return OZChannelBase::setFlag(v7, 0x400000, 1);
  }
  else
  {
    OZChannelBase::setFlag(v6, 4194306, 1);
    return OZChannelBase::resetFlag(v7, 4227072, 1);
  }
}

BOOL PSPaintSequenceBehavior::isAffectingWidth(PSPaintSequenceBehavior *this)
{
  return (*((unsigned char *)this + 3016) & 2) == 0;
}

CGColorSpace **PSPaintSequenceBehavior::getWidthSamples(CGColorSpace **this, CMTime *a2, int a3, double *a4)
{
  if (a3)
  {
    unsigned int v7 = (PSSequenceBehavior *)this;
    PSSequencedValues::PSSequencedValues((PSSequencedValues *)v9);
    if (a3 == 1)
    {
      PSSequenceBehavior::getValues(v7, a2, 0.5, (PSSequencedValues *)v9);
      *a4 = v11;
    }
    else
    {
      uint64_t v8 = 0;
      do
      {
        double v11 = 1.0;
        PSSequenceBehavior::getValues(v7, a2, 1.0 / (double)(a3 - 1) * (double)v8, (PSSequencedValues *)v9);
        a4[v8++] = v11;
      }
      while (a3 != v8);
    }
    return PCCFRef<CGColorSpace *>::~PCCFRef(&v10);
  }
  return this;
}

void sub_1B7DF44F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PSPaintSequenceBehavior::arGetChannelList(uint64_t a1, void **a2)
{
  uint64_t v4 = a1 + 352;
  uint64_t v6 = (uint64_t)(a2 + 2);
  unint64_t v5 = (unint64_t)a2[2];
  unsigned int v7 = a2[1];
  if ((unint64_t)v7 >= v5)
  {
    uint64_t v9 = ((char *)v7 - (unsigned char *)*a2) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      goto LABEL_98;
    }
    uint64_t v10 = v5 - (void)*a2;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      unsigned int v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6, v12);
    }
    else {
      unsigned int v13 = 0;
    }
    unsigned int v14 = &v13[8 * v9];
    double v15 = &v13[8 * v12];
    *(void *)unsigned int v14 = v4;
    uint64_t v8 = v14 + 8;
    double v17 = (char *)*a2;
    double v16 = (char *)a2[1];
    if (v16 != *a2)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *((void *)v14 - 1) = v18;
        v14 -= 8;
      }
      while (v16 != v17);
      double v16 = (char *)*a2;
    }
    *a2 = v14;
    a2[1] = v8;
    a2[2] = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *unsigned int v7 = v4;
    uint64_t v8 = v7 + 1;
  }
  a2[1] = v8;
  uint64_t v19 = a1 + 1208;
  unint64_t v20 = (unint64_t)a2[2];
  if ((unint64_t)v8 >= v20)
  {
    uint64_t v22 = ((char *)v8 - (unsigned char *)*a2) >> 3;
    if ((unint64_t)(v22 + 1) >> 61) {
      goto LABEL_98;
    }
    uint64_t v23 = v20 - (void)*a2;
    uint64_t v24 = v23 >> 2;
    if (v23 >> 2 <= (unint64_t)(v22 + 1)) {
      uint64_t v24 = v22 + 1;
    }
    if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v25 = v24;
    }
    if (v25) {
      double v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6, v25);
    }
    else {
      double v26 = 0;
    }
    double v27 = &v26[8 * v22];
    double v28 = &v26[8 * v25];
    *(void *)double v27 = v19;
    CMTime v21 = v27 + 8;
    double v30 = (char *)*a2;
    double v29 = (char *)a2[1];
    if (v29 != *a2)
    {
      do
      {
        uint64_t v31 = *((void *)v29 - 1);
        v29 -= 8;
        *((void *)v27 - 1) = v31;
        v27 -= 8;
      }
      while (v29 != v30);
      double v29 = (char *)*a2;
    }
    *a2 = v27;
    a2[1] = v21;
    a2[2] = v28;
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    *uint64_t v8 = v19;
    CMTime v21 = v8 + 1;
  }
  a2[1] = v21;
  uint64_t v32 = a1 + 2216;
  unint64_t v33 = (unint64_t)a2[2];
  if ((unint64_t)v21 >= v33)
  {
    uint64_t v35 = ((char *)v21 - (unsigned char *)*a2) >> 3;
    if ((unint64_t)(v35 + 1) >> 61) {
      goto LABEL_98;
    }
    uint64_t v36 = v33 - (void)*a2;
    uint64_t v37 = v36 >> 2;
    if (v36 >> 2 <= (unint64_t)(v35 + 1)) {
      uint64_t v37 = v35 + 1;
    }
    if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v38 = v37;
    }
    if (v38) {
      double v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6, v38);
    }
    else {
      double v39 = 0;
    }
    double v40 = &v39[8 * v35];
    double v41 = &v39[8 * v38];
    *(void *)double v40 = v32;
    double v34 = v40 + 8;
    double v43 = (char *)*a2;
    double v42 = (char *)a2[1];
    if (v42 != *a2)
    {
      do
      {
        uint64_t v44 = *((void *)v42 - 1);
        v42 -= 8;
        *((void *)v40 - 1) = v44;
        v40 -= 8;
      }
      while (v42 != v43);
      double v42 = (char *)*a2;
    }
    *a2 = v40;
    a2[1] = v34;
    a2[2] = v41;
    if (v42) {
      operator delete(v42);
    }
  }
  else
  {
    *CMTime v21 = v32;
    double v34 = v21 + 1;
  }
  a2[1] = v34;
  uint64_t v45 = a1 + 2368;
  unint64_t v46 = (unint64_t)a2[2];
  if ((unint64_t)v34 >= v46)
  {
    uint64_t v48 = ((char *)v34 - (unsigned char *)*a2) >> 3;
    if ((unint64_t)(v48 + 1) >> 61) {
      goto LABEL_98;
    }
    uint64_t v49 = v46 - (void)*a2;
    uint64_t v50 = v49 >> 2;
    if (v49 >> 2 <= (unint64_t)(v48 + 1)) {
      uint64_t v50 = v48 + 1;
    }
    if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v51 = v50;
    }
    if (v51) {
      unint64_t v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6, v51);
    }
    else {
      unint64_t v52 = 0;
    }
    double v53 = &v52[8 * v48];
    double v54 = &v52[8 * v51];
    *(void *)double v53 = v45;
    double v47 = v53 + 8;
    int v56 = (char *)*a2;
    double v55 = (char *)a2[1];
    if (v55 != *a2)
    {
      do
      {
        uint64_t v57 = *((void *)v55 - 1);
        v55 -= 8;
        *((void *)v53 - 1) = v57;
        v53 -= 8;
      }
      while (v55 != v56);
      double v55 = (char *)*a2;
    }
    *a2 = v53;
    a2[1] = v47;
    a2[2] = v54;
    if (v55) {
      operator delete(v55);
    }
  }
  else
  {
    *double v34 = v45;
    double v47 = v34 + 1;
  }
  a2[1] = v47;
  uint64_t v58 = a1 + 2960;
  unint64_t v59 = (unint64_t)a2[2];
  if ((unint64_t)v47 >= v59)
  {
    uint64_t v61 = ((char *)v47 - (unsigned char *)*a2) >> 3;
    if ((unint64_t)(v61 + 1) >> 61) {
      goto LABEL_98;
    }
    uint64_t v62 = v59 - (void)*a2;
    uint64_t v63 = v62 >> 2;
    if (v62 >> 2 <= (unint64_t)(v61 + 1)) {
      uint64_t v63 = v61 + 1;
    }
    if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v64 = v63;
    }
    if (v64) {
      CMTimeEpoch v65 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6, v64);
    }
    else {
      CMTimeEpoch v65 = 0;
    }
    CMTime v66 = &v65[8 * v61];
    CMTime v67 = &v65[8 * v64];
    *(void *)CMTime v66 = v58;
    double v60 = v66 + 8;
    uint64_t v69 = (char *)*a2;
    CMTime v68 = (char *)a2[1];
    if (v68 != *a2)
    {
      do
      {
        uint64_t v70 = *((void *)v68 - 1);
        v68 -= 8;
        *((void *)v66 - 1) = v70;
        v66 -= 8;
      }
      while (v68 != v69);
      CMTime v68 = (char *)*a2;
    }
    *a2 = v66;
    a2[1] = v60;
    a2[2] = v67;
    if (v68) {
      operator delete(v68);
    }
  }
  else
  {
    *double v47 = v58;
    double v60 = v47 + 1;
  }
  a2[1] = v60;
  uint64_t v71 = a1 + 3112;
  unint64_t v72 = (unint64_t)a2[2];
  if ((unint64_t)v60 < v72)
  {
    *double v60 = v71;
    float64_t v73 = v60 + 1;
    goto LABEL_97;
  }
  uint64_t v74 = ((char *)v60 - (unsigned char *)*a2) >> 3;
  if ((unint64_t)(v74 + 1) >> 61) {
LABEL_98:
  }
    std::vector<double>::__throw_length_error[abi:ne180100]();
  uint64_t v75 = v72 - (void)*a2;
  uint64_t v76 = v75 >> 2;
  if (v75 >> 2 <= (unint64_t)(v74 + 1)) {
    uint64_t v76 = v74 + 1;
  }
  if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v77 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v77 = v76;
  }
  if (v77) {
    int32_t v78 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v6, v77);
  }
  else {
    int32_t v78 = 0;
  }
  int v79 = &v78[8 * v74];
  long long v80 = &v78[8 * v77];
  *(void *)int v79 = v71;
  float64_t v73 = v79 + 8;
  double v82 = (char *)*a2;
  double v81 = (char *)a2[1];
  if (v81 != *a2)
  {
    do
    {
      uint64_t v83 = *((void *)v81 - 1);
      v81 -= 8;
      *((void *)v79 - 1) = v83;
      v79 -= 8;
    }
    while (v81 != v82);
    double v81 = (char *)*a2;
  }
  *a2 = v79;
  a2[1] = v73;
  a2[2] = v80;
  if (v81) {
    operator delete(v81);
  }
LABEL_97:
  a2[1] = v73;
}

void non-virtual thunk to'PSPaintSequenceBehavior::arGetChannelList(uint64_t a1, void **a2)
{
}

uint64_t PSPaintSequenceBehavior::getNumObjects(PSPaintSequenceBehavior *this, const CMTime *a2)
{
  return 1;
}

uint64_t PSPaintSequenceBehavior::getOffsetAndDoWrap(PSPaintSequenceBehavior *this, const CMTime *a2, double *a3, BOOL *a4)
{
  unsigned int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 5864), a2, 0.0);
  int v9 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), a2, 0.0);
  *a4 = 0;
  if (ValueAsInt > 6 || ValueAsInt == 4)
  {
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 5456), a2, 0.0);
    double v40 = v39 + 1.0;
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 6120), a2, 0.0);
    double v42 = v41;
    uint64_t result = OZChannel::getValueAsInt((OZChannel *)((char *)this + 5608), a2, 0.0);
    double v43 = 1.0 - v42;
    if (result != 1) {
      double v43 = v42;
    }
    double v36 = v40 * v43 + 0.0;
  }
  else
  {
    int v11 = v9;
    (*(void (**)(CMTime *__return_ptr, PSPaintSequenceBehavior *))(*(void *)this + 608))(&v51, this);
    CMTime v50 = v52;
    CMTime time1 = v52;
    CMTime time2 = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    uint64_t result = CMTimeCompare(&time1, &time2);
    if ((int)result <= 0)
    {
      *a3 = 0.0;
      return result;
    }
    unsigned int v13 = v11 & 0xFFFFFFFE;
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 5456), a2, 0.0);
    double v15 = v14;
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 6272), a2, 0.0);
    double v17 = v16;
    int v18 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 6424), a2, 0.0);
    __n128 v48 = 0uLL;
    CMTimeEpoch v49 = 0;
    uint64_t v19 = (*(uint64_t (**)(PSPaintSequenceBehavior *))(*(void *)this + 336))(this);
    OZSceneSettings::getFrameDuration((OZSceneSettings *)(v19 + 336), &v48);
    CMTime time2 = v51;
    CMTime time1 = *a2;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v46);
    CMTime time1 = v50;
    *(__n128 *)&time2.value = v48;
    time2.CMTimeEpoch epoch = v49;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)v45);
    operator/(&v46, (uint64_t)v45, (uint64_t)&time);
    double Seconds = CMTimeGetSeconds(&time);
    if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 5608), a2, 0.0) == 1) {
      double Seconds = 1.0 - Seconds;
    }
    double v21 = v17;
    if (v18 == 1)
    {
      int v22 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), MEMORY[0x1E4F1FA48], 0.0);
      double v21 = v15 + v17;
      double v23 = v15 + v17 + -1.0;
      if (v13 == 2) {
        double v23 = v17 + v15 + v15;
      }
      if (v22 != 4) {
        double v21 = v23;
      }
    }
    double v24 = Seconds * v21 + 0.0;
    time1.value = 0;
    modf(v24 + -0.000001, (long double *)&time1.value);
    if (*(double *)&time1.value <= v17 + -1.0) {
      double v25 = *(double *)&time1.value;
    }
    else {
      double v25 = v17 + -1.0;
    }
    BOOL v27 = v25 > 0.0 && v18 == 1;
    *a4 = v27;
    if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), MEMORY[0x1E4F1FA48], 0.0) == 4)
    {
      double v28 = -v15;
    }
    else
    {
      double v28 = 0.0;
      if (v13 == 2)
      {
        double v28 = -v15;
        if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 4896), a2, 0.0) == 2)
        {
          OZChannel::getValueAsDouble((OZChannel *)((char *)this + 5304), a2, 0.0);
          double v28 = v28 - v29;
        }
      }
    }
    int v30 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), MEMORY[0x1E4F1FA48], 0.0);
    double v31 = 1.0;
    double v32 = v15 + 1.0;
    if (v30 == 4) {
      double v32 = 1.0;
    }
    double v33 = 1.0 - v15;
    if (v13 != 2) {
      double v33 = 1.0;
    }
    if (v30 != 4) {
      double v31 = v33;
    }
    if (v18 == 1) {
      double v34 = v31;
    }
    else {
      double v34 = v32;
    }
    double v35 = v34 - v28;
    double v36 = v28 + (v24 - v25) * (v34 - v28);
    switch(ValueAsInt)
    {
      case 1u:
        double v37 = cos((v36 - v28) * 3.14159265 / v35 * 0.5);
        double v38 = 1.0;
        goto LABEL_48;
      case 2u:
        double v44 = sin((v36 - v28) * 3.14159265 / v35 * 0.5);
        break;
      case 3u:
        double v44 = sin((v36 - v28) * 3.14159265 / v35 + -1.57079633) * 0.5 + 0.5;
        break;
      case 5u:
        if (v35 <= 0.0) {
          goto LABEL_50;
        }
        double v44 = (v36 - v28) / v35 * ((v36 - v28) / v35);
        break;
      case 6u:
        if (v35 <= 0.0) {
          goto LABEL_50;
        }
        double v38 = 1.0;
        double v37 = (1.0 - (v36 - v28) / v35) * (1.0 - (v36 - v28) / v35);
LABEL_48:
        double v44 = v38 - v37;
        break;
      default:
        goto LABEL_50;
    }
    double v36 = v28 + v35 * v44;
LABEL_50:
    uint64_t result = OZChannel::getValueAsInt((OZChannel *)((char *)this + 6424), a2, 0.0);
    if (result == 2 && ((int)v25 & 0x80000001) == 1) {
      double v36 = v34 + v28 - v36;
    }
  }
  *a3 = v36;
  return result;
}

uint64_t PSPaintSequenceBehavior::normalizeIndex(PSPaintSequenceBehavior *this, double a2, const CMTime *a3)
{
  return OZChannel::getValueAsInt((OZChannel *)((char *)this + 4896), MEMORY[0x1E4F1FA48], 0.0);
}

void PSPaintSequenceBehavior::getEnd(PSPaintSequenceBehavior *this, const CMTime *a2)
{
  OZChannel::getValueAsInt((OZChannel *)((char *)this + 4384), a2, 0.0);
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 4896), a2, 0.0) == 2)
  {
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 5304), a2, 0.0);
  }
}

uint64_t PSPaintSequenceBehavior::findEmitter(uint64_t this, OZSceneNode *a2)
{
  *(void *)(this + 344) = 0;
  return this;
}

void PSPaintSequenceBehavior::~PSPaintSequenceBehavior(PSPaintSequenceBehavior *this)
{
  PSSequenceBehavior::~PSSequenceBehavior(this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'PSPaintSequenceBehavior::~PSPaintSequenceBehavior(PSPaintSequenceBehavior *this)
{
}

{
  uint64_t vars8;

  PSSequenceBehavior::~PSSequenceBehavior((PSPaintSequenceBehavior *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  PSSequenceBehavior::~PSSequenceBehavior((PSPaintSequenceBehavior *)((char *)this - 48));
}

{
  uint64_t vars8;

  PSSequenceBehavior::~PSSequenceBehavior((PSPaintSequenceBehavior *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

{
  PSSequenceBehavior::~PSSequenceBehavior((PSPaintSequenceBehavior *)((char *)this - 336));
}

{
  uint64_t vars8;

  PSSequenceBehavior::~PSSequenceBehavior((PSPaintSequenceBehavior *)((char *)this - 336));

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PSEmitter_Factory::getInstance(PSEmitter_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitter_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSEmitter_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitter_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitter_Factory::_instance;
}

uint64_t PSParticleType_Factory::getInstance(PSParticleType_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSParticleType_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSParticleType_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSParticleType_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSParticleType_Factory::_instance;
}

uint64_t PSReplicator_Factory::getInstance(PSReplicator_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSReplicator_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSReplicator_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSReplicator_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSReplicator_Factory::_instance;
}

uint64_t PSReplicatorPType_Factory::getInstance(PSReplicatorPType_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSReplicatorPType_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSReplicatorPType_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSReplicatorPType_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSReplicatorPType_Factory::_instance;
}

uint64_t PSPaint_Factory::getInstance(PSPaint_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSPaint_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSPaint_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSPaint_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSPaint_Factory::_instance;
}

uint64_t PSPaintPType_Factory::getInstance(PSPaintPType_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSPaintPType_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSPaintPType_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSPaintPType_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSPaintPType_Factory::_instance;
}

uint64_t PSEmitterMoToFoBehavior_Factory::getInstance(PSEmitterMoToFoBehavior_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSEmitterMoToFoBehavior_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSEmitterMoToFoBehavior_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSEmitterMoToFoBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSEmitterMoToFoBehavior_Factory::_instance;
}

uint64_t PSScaleOverLifeBehavior_Factory::getInstance(PSScaleOverLifeBehavior_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSScaleOverLifeBehavior_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSScaleOverLifeBehavior_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSScaleOverLifeBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSScaleOverLifeBehavior_Factory::_instance;
}

uint64_t PSSequenceBehavior_Factory::getInstance(PSSequenceBehavior_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSSequenceBehavior_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSSequenceBehavior_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSSequenceBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSSequenceBehavior_Factory::_instance;
}

uint64_t PSPaintSequenceBehavior_Factory::getInstance(PSPaintSequenceBehavior_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSPaintSequenceBehavior_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSPaintSequenceBehavior_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSPaintSequenceBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSPaintSequenceBehavior_Factory::_instance;
}

uint64_t PSSpinOverLifeBehavior_Factory::getInstance(PSSpinOverLifeBehavior_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSSpinOverLifeBehavior_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSSpinOverLifeBehavior_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSSpinOverLifeBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSSpinOverLifeBehavior_Factory::_instance;
}

uint64_t PSPenPropertyBehavior_Factory::getInstance(PSPenPropertyBehavior_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSPenPropertyBehavior_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSPenPropertyBehavior_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSPenPropertyBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSPenPropertyBehavior_Factory::_instance;
}

uint64_t PSPenPressureBehavior_Factory::getInstance(PSPenPressureBehavior_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSPenPressureBehavior_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSPenPressureBehavior_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSPenPressureBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSPenPressureBehavior_Factory::_instance;
}

uint64_t PSPenSpeedBehavior_Factory::getInstance(PSPenSpeedBehavior_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSPenSpeedBehavior_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSPenSpeedBehavior_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSPenSpeedBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSPenSpeedBehavior_Factory::_instance;
}

uint64_t PSPenTiltBehavior_Factory::getInstance(PSPenTiltBehavior_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&PSPenTiltBehavior_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    long long v3 = &v4;
    std::__call_once(&PSPenTiltBehavior_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<PSPenTiltBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return PSPenTiltBehavior_Factory::_instance;
}

void sub_1B7DF5B10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  std::__hash_table<std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>,std::__unordered_map_hasher<OZSceneNode *,std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>,std::hash<OZSceneNode *>,std::equal_to<OZSceneNode *>,true>,std::__unordered_map_equal<OZSceneNode *,std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>,std::equal_to<OZSceneNode *>,std::hash<OZSceneNode *>,true>,std::allocator<std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<PSEmitter_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF5B9C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C409129CFF6);
  _Unwind_Resume(a1);
}

void PSEmitter_Factory::PSEmitter_Factory(PSEmitter_Factory *this)
{
  long long v3 = xmmword_1B7E78B90;
  long long v4 = xmmword_1B8384170;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 0);
  void *v2 = &unk_1F10ADA60;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F1191FB0;
  *((void *)this + 16) = &unk_1F1192080;
  *((void *)this + 17) = 0;
}

void sub_1B7DF5C6C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSEmitter_Factory::~PSEmitter_Factory(PSEmitter_Factory *this)
{
  PSEmitter_Factory::~PSEmitter_Factory(this);

  JUMPOUT(0x1BA9BFBA0);
}

{
  PCSingleton *v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F1191FB0;
  char v2 = (PSEmitter_Factory *)((char *)this + 128);
  *((void *)this + 16) = &unk_1F1192080;
  long long v3 = *((void *)this + 17);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 72))(v3);
  }
  *((void *)this + 17) = 0;
  PCSingleton::~PCSingleton(v2);

  OZFactory::~OZFactory((OZFactory *)this);
}

OZChannelBase *PSEmitter_Factory::create(PSEmitter_Factory *this, const PCString *a2, unsigned int NextUniqueID)
{
  if (!*((void *)this + 17))
  {
    OZChannelBase::setRangeName((OZChannelBase *)&v14, (const PCString *)@"Motion Effect");
    operator new();
  }
  OZChannelBase::setRangeName((OZChannelBase *)&v13, (const PCString *)@"Motion Effect");
  uint64_t v6 = *((void *)this + 17);
  if (v6) {
    uint64_t v7 = v6 + 200;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = (OZChannelBase *)(*(uint64_t (**)(PSEmitter_Factory *, uint64_t, uint64_t))(*(void *)this + 24))(this, v7, 40);
  int v9 = v8;
  if (!NextUniqueID) {
    NextUniqueID = OZChannelBase::getNextUniqueID(v8);
  }
  OZChannelBase::setID((OZChannelBase *)&v9->var7, NextUniqueID);
  uint64_t v10 = (OZChannelBase *)(*((uint64_t (**)(OZChannelBase *))v9->var0 + 80))(v9);
  OZChannelBase::setName(v10, a2, 0);
  (*((void (**)(OZChannelBase *))v9->var0 + 115))(v9);
  OZChannelBase::setRangeName((OZChannelBase *)&v13, v11);
  return v9;
}

void sub_1B7DF5E80(_Unwind_Exception *a1, int a2, uint64_t a3, OZChannelBase *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  MEMORY[0x1BA9BFBA0](v13, 0x10F1C408C860A13, a3, a4);
  OZChannelBase::setRangeName((OZChannelBase *)&a13, v15);
  _Unwind_Resume(a1);
}

void PSEmitter_Factory::createCopy(PSEmitter_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF5FD4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C408C860A13);
  _Unwind_Resume(a1);
}

void PSEmitter_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSEmitter_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Emitter Short Desc");
}

PCString *PSEmitter_Factory::getIconNameInternal@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "M_LayersList_ObjectIconColor-ParticleEmitter");
}

PCString *PSEmitter_Factory::getIconNameBWInternal@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "M_LayersList_ObjectIconGrey-ParticleEmitter");
}

uint64_t PSEmitter_Factory::getIconIDInternal(PSEmitter_Factory *this)
{
  return 8;
}

PCString *PSEmitter_Factory::getLibraryIconNameInternal@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "M_Library_Emitter_Icon");
}

void PSEmitter_Factory::createNodeCopy(PSEmitter_Factory *this, OZSceneNode *a2)
{
}

void sub_1B7DF60F8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C408C860A13);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'PSEmitter_Factory::~PSEmitter_Factory(PSEmitter_Factory *this)
{
}

{
  uint64_t vars8;

  PSEmitter_Factory::~PSEmitter_Factory((PSEmitter_Factory *)((char *)this - 128));

  JUMPOUT(0x1BA9BFBA0);
}

void std::__call_once_param<std::tuple<PSParticleType_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF6254(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C409129CFF6);
  _Unwind_Resume(a1);
}

void PSParticleType_Factory::PSParticleType_Factory(PSParticleType_Factory *this)
{
  long long v3 = xmmword_1B8380BC0;
  long long v4 = xmmword_1B8381350;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 0);
  void *v2 = &unk_1F10ADA60;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F11920D8;
  *((void *)this + 16) = &unk_1F11921A8;
  *((void *)this + 17) = 0;
}

void sub_1B7DF6324(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSParticleType_Factory::~PSParticleType_Factory(PSParticleType_Factory *this)
{
  PSParticleType_Factory::~PSParticleType_Factory(this);

  JUMPOUT(0x1BA9BFBA0);
}

{
  PCSingleton *v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F11920D8;
  char v2 = (PSParticleType_Factory *)((char *)this + 128);
  *((void *)this + 16) = &unk_1F11921A8;
  long long v3 = *((void *)this + 17);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *((void *)this + 17) = 0;
  PCSingleton::~PCSingleton(v2);

  OZFactory::~OZFactory((OZFactory *)this);
}

OZChannelBase *PSParticleType_Factory::create(PSParticleType_Factory *this, const PCString *a2, unsigned int NextUniqueID)
{
  if (!*((void *)this + 17))
  {
    OZChannelBase::setRangeName((OZChannelBase *)&v12, (const PCString *)@"Motion Effect");
    operator new();
  }
  OZChannelBase::setRangeName((OZChannelBase *)&v11, (const PCString *)@"Motion Effect");
  uint64_t v6 = (OZChannelBase *)(*(uint64_t (**)(PSParticleType_Factory *, void, uint64_t))(*(void *)this + 24))(this, *((void *)this + 17), 40);
  uint64_t v7 = v6;
  if (!NextUniqueID) {
    NextUniqueID = OZChannelBase::getNextUniqueID(v6);
  }
  OZChannelBase::setID((OZChannelBase *)&v7->var7, NextUniqueID);
  uint64_t v8 = (OZChannelBase *)(*((uint64_t (**)(OZChannelBase *))v7->var0 + 80))(v7);
  OZChannelBase::setName(v8, a2, 0);
  (*((void (**)(OZChannelBase *))v7->var0 + 115))(v7);
  OZChannelBase::setRangeName((OZChannelBase *)&v11, v9);
  return v7;
}

void sub_1B7DF652C(_Unwind_Exception *a1, int a2, uint64_t a3, OZChannelBase *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  MEMORY[0x1BA9BFBA0](v13, 0x10F1C409CD462B0, a3, a4);
  OZChannelBase::setRangeName((OZChannelBase *)&a13, v15);
  _Unwind_Resume(a1);
}

void PSParticleType_Factory::createCopy(PSParticleType_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF6680(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C409CD462B0);
  _Unwind_Resume(a1);
}

void PSParticleType_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSParticleType_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Particle Type Name");
}

PCString *PSParticleType_Factory::getIconNameInternal@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "M_LayersList_ObjectIconColor-ParticleCell");
}

PCString *PSParticleType_Factory::getIconNameBWInternal@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "M_LayersList_ObjectIconGrey-ParticleCell");
}

uint64_t PSParticleType_Factory::getIconIDInternal(PSParticleType_Factory *this)
{
  return 7;
}

void PSParticleType_Factory::createNodeCopy(PSParticleType_Factory *this, OZSceneNode *a2)
{
}

void sub_1B7DF6794(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C409CD462B0);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'PSParticleType_Factory::~PSParticleType_Factory(PSParticleType_Factory *this)
{
}

{
  uint64_t vars8;

  PSParticleType_Factory::~PSParticleType_Factory((PSParticleType_Factory *)((char *)this - 128));

  JUMPOUT(0x1BA9BFBA0);
}

void std::__call_once_param<std::tuple<PSReplicator_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF68F0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C409129CFF6);
  _Unwind_Resume(a1);
}

void PSReplicator_Factory::PSReplicator_Factory(PSReplicator_Factory *this)
{
  long long v3 = xmmword_1B8384170;
  long long v4 = xmmword_1B8384180;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 0);
  void *v2 = &unk_1F10ADA60;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F1192200;
  *((void *)this + 16) = &unk_1F11922D0;
  *((void *)this + 17) = 0;
}

void sub_1B7DF69C0(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSReplicator_Factory::~PSReplicator_Factory(PSReplicator_Factory *this)
{
  PSReplicator_Factory::~PSReplicator_Factory(this);

  JUMPOUT(0x1BA9BFBA0);
}

{
  PCSingleton *v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F1192200;
  char v2 = (PSReplicator_Factory *)((char *)this + 128);
  *((void *)this + 16) = &unk_1F11922D0;
  long long v3 = *((void *)this + 17);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 72))(v3);
  }
  *((void *)this + 17) = 0;
  PCSingleton::~PCSingleton(v2);

  OZFactory::~OZFactory((OZFactory *)this);
}

OZChannelBase *PSReplicator_Factory::create(PSReplicator_Factory *this, const PCString *a2, unsigned int NextUniqueID)
{
  if (!*((void *)this + 17))
  {
    OZChannelBase::setRangeName((OZChannelBase *)&v14, (const PCString *)@"Motion Effect");
    operator new();
  }
  OZChannelBase::setRangeName((OZChannelBase *)&v13, (const PCString *)@"Motion Effect");
  uint64_t v6 = *((void *)this + 17);
  if (v6) {
    uint64_t v7 = v6 + 200;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = (OZChannelBase *)(*(uint64_t (**)(PSReplicator_Factory *, uint64_t, uint64_t))(*(void *)this + 24))(this, v7, 40);
  int v9 = v8;
  if (!NextUniqueID) {
    NextUniqueID = OZChannelBase::getNextUniqueID(v8);
  }
  OZChannelBase::setID((OZChannelBase *)&v9->var7, NextUniqueID);
  uint64_t v10 = (OZChannelBase *)(*((uint64_t (**)(OZChannelBase *))v9->var0 + 80))(v9);
  OZChannelBase::setName(v10, a2, 0);
  (*((void (**)(OZChannelBase *))v9->var0 + 115))(v9);
  OZChannelBase::setRangeName((OZChannelBase *)&v13, v11);
  return v9;
}

void sub_1B7DF6BD4(_Unwind_Exception *a1, int a2, uint64_t a3, OZChannelBase *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  MEMORY[0x1BA9BFBA0](v13, 0x10F1C408C860A13, a3, a4);
  OZChannelBase::setRangeName((OZChannelBase *)&a13, v15);
  _Unwind_Resume(a1);
}

void PSReplicator_Factory::createCopy(PSReplicator_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF6D28(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C408C860A13);
  _Unwind_Resume(a1);
}

void PSReplicator_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSReplicator_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Replicator Short Desc");
}

PCString *PSReplicator_Factory::getIconNameInternal@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "M_LayersList_ObjectIconColor-Replicator");
}

PCString *PSReplicator_Factory::getIconNameBWInternal@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "M_LayersList_ObjectIconGrey-Replicator");
}

uint64_t PSReplicator_Factory::getIconIDInternal(PSReplicator_Factory *this)
{
  return 19;
}

PCString *PSReplicator_Factory::getLibraryIconNameInternal@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "M_Library_Replicator_Icon");
}

void PSReplicator_Factory::createNodeCopy(PSReplicator_Factory *this, OZSceneNode *a2)
{
}

void sub_1B7DF6E4C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C408C860A13);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'PSReplicator_Factory::~PSReplicator_Factory(PSReplicator_Factory *this)
{
}

{
  uint64_t vars8;

  PSReplicator_Factory::~PSReplicator_Factory((PSReplicator_Factory *)((char *)this - 128));

  JUMPOUT(0x1BA9BFBA0);
}

void std::__call_once_param<std::tuple<PSReplicatorPType_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF6FA8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C409129CFF6);
  _Unwind_Resume(a1);
}

void PSReplicatorPType_Factory::PSReplicatorPType_Factory(PSReplicatorPType_Factory *this)
{
  long long v3 = xmmword_1B8381350;
  long long v4 = xmmword_1B8387A30;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 0);
  void *v2 = &unk_1F10ADA60;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F1192328;
  *((void *)this + 16) = &unk_1F11923F8;
  *((void *)this + 17) = 0;
}

void sub_1B7DF7078(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSReplicatorPType_Factory::~PSReplicatorPType_Factory(PSReplicatorPType_Factory *this)
{
  PSReplicatorPType_Factory::~PSReplicatorPType_Factory(this);

  JUMPOUT(0x1BA9BFBA0);
}

{
  PCSingleton *v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F1192328;
  char v2 = (PSReplicatorPType_Factory *)((char *)this + 128);
  *((void *)this + 16) = &unk_1F11923F8;
  long long v3 = *((void *)this + 17);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *((void *)this + 17) = 0;
  PCSingleton::~PCSingleton(v2);

  OZFactory::~OZFactory((OZFactory *)this);
}

OZChannelBase *PSReplicatorPType_Factory::create(PSReplicatorPType_Factory *this, const PCString *a2, unsigned int NextUniqueID)
{
  if (!*((void *)this + 17))
  {
    OZChannelBase::setRangeName((OZChannelBase *)&v12, (const PCString *)@"Motion Effect");
    operator new();
  }
  OZChannelBase::setRangeName((OZChannelBase *)&v11, (const PCString *)@"Motion Effect");
  uint64_t v6 = (OZChannelBase *)(*(uint64_t (**)(PSReplicatorPType_Factory *, void, uint64_t))(*(void *)this + 24))(this, *((void *)this + 17), 40);
  uint64_t v7 = v6;
  if (!NextUniqueID) {
    NextUniqueID = OZChannelBase::getNextUniqueID(v6);
  }
  OZChannelBase::setID((OZChannelBase *)&v7->var7, NextUniqueID);
  uint64_t v8 = (OZChannelBase *)(*((uint64_t (**)(OZChannelBase *))v7->var0 + 80))(v7);
  OZChannelBase::setName(v8, a2, 0);
  (*((void (**)(OZChannelBase *))v7->var0 + 115))(v7);
  OZChannelBase::setRangeName((OZChannelBase *)&v11, v9);
  return v7;
}

void sub_1B7DF7280(_Unwind_Exception *a1, int a2, uint64_t a3, OZChannelBase *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  MEMORY[0x1BA9BFBA0](v13, 0x10F1C4095359925, a3, a4);
  OZChannelBase::setRangeName((OZChannelBase *)&a13, v15);
  _Unwind_Resume(a1);
}

void PSReplicatorPType_Factory::createCopy(PSReplicatorPType_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF73D4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4095359925);
  _Unwind_Resume(a1);
}

void PSReplicatorPType_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSReplicatorPType_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Replicator PType Name");
}

PCString *PSReplicatorPType_Factory::getIconNameInternal@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "M_LayersList_ObjectIconColor-ReplicatorCell");
}

PCString *PSReplicatorPType_Factory::getIconNameBWInternal@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "M_LayersList_ObjectIconGrey-ReplicatorCell");
}

uint64_t PSReplicatorPType_Factory::getIconIDInternal(PSReplicatorPType_Factory *this)
{
  return 20;
}

void PSReplicatorPType_Factory::createNodeCopy(PSReplicatorPType_Factory *this, OZSceneNode *a2)
{
}

void sub_1B7DF74E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4095359925);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'PSReplicatorPType_Factory::~PSReplicatorPType_Factory(PSReplicatorPType_Factory *this)
{
}

{
  uint64_t vars8;

  PSReplicatorPType_Factory::~PSReplicatorPType_Factory((PSReplicatorPType_Factory *)((char *)this - 128));

  JUMPOUT(0x1BA9BFBA0);
}

void std::__call_once_param<std::tuple<PSPaint_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF7644(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C409129CFF6);
  _Unwind_Resume(a1);
}

void PSPaint_Factory::PSPaint_Factory(PSPaint_Factory *this)
{
  long long v3 = xmmword_1B8384180;
  long long v4 = xmmword_1B837FEB0;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 0);
  void *v2 = &unk_1F10ADA60;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F1192450;
  *((void *)this + 16) = &unk_1F1192520;
  *((void *)this + 17) = 0;
}

void sub_1B7DF7714(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSPaint_Factory::~PSPaint_Factory(PSPaint_Factory *this)
{
  PSPaint_Factory::~PSPaint_Factory(this);

  JUMPOUT(0x1BA9BFBA0);
}

{
  PCSingleton *v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F1192450;
  char v2 = (PSPaint_Factory *)((char *)this + 128);
  *((void *)this + 16) = &unk_1F1192520;
  long long v3 = *((void *)this + 17);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 72))(v3);
  }
  *((void *)this + 17) = 0;
  PCSingleton::~PCSingleton(v2);

  OZFactory::~OZFactory((OZFactory *)this);
}

OZChannelBase *PSPaint_Factory::create(PSPaint_Factory *this, const PCString *a2, unsigned int NextUniqueID)
{
  if (!*((void *)this + 17))
  {
    OZChannelBase::setRangeName((OZChannelBase *)&v14, (const PCString *)@"Motion Effect");
    operator new();
  }
  OZChannelBase::setRangeName((OZChannelBase *)&v13, (const PCString *)@"Motion Effect");
  uint64_t v6 = *((void *)this + 17);
  if (v6) {
    uint64_t v7 = v6 + 200;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = (OZChannelBase *)(*(uint64_t (**)(PSPaint_Factory *, uint64_t, uint64_t))(*(void *)this + 24))(this, v7, 40);
  int v9 = v8;
  if (!NextUniqueID) {
    NextUniqueID = OZChannelBase::getNextUniqueID(v8);
  }
  OZChannelBase::setID((OZChannelBase *)&v9->var7, NextUniqueID);
  uint64_t v10 = (OZChannelBase *)(*((uint64_t (**)(OZChannelBase *))v9->var0 + 80))(v9);
  OZChannelBase::setName(v10, a2, 0);
  (*((void (**)(OZChannelBase *))v9->var0 + 115))(v9);
  OZChannelBase::setRangeName((OZChannelBase *)&v13, v11);
  return v9;
}

void sub_1B7DF7928(_Unwind_Exception *a1, int a2, uint64_t a3, OZChannelBase *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  MEMORY[0x1BA9BFBA0](v13, 0x10F1C40637A83DELL, a3, a4);
  OZChannelBase::setRangeName((OZChannelBase *)&a13, v15);
  _Unwind_Resume(a1);
}

void PSPaint_Factory::createCopy(PSPaint_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF7A7C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40637A83DELL);
  _Unwind_Resume(a1);
}

void PSPaint_Factory::createNodeCopy(PSPaint_Factory *this, OZSceneNode *a2)
{
}

void sub_1B7DF7B40(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40637A83DELL);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'PSPaint_Factory::~PSPaint_Factory(PSPaint_Factory *this)
{
}

{
  uint64_t vars8;

  PSPaint_Factory::~PSPaint_Factory((PSPaint_Factory *)((char *)this - 128));

  JUMPOUT(0x1BA9BFBA0);
}

void std::__call_once_param<std::tuple<PSPaintPType_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF7C9C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C409129CFF6);
  _Unwind_Resume(a1);
}

void PSPaintPType_Factory::PSPaintPType_Factory(PSPaintPType_Factory *this)
{
  long long v3 = xmmword_1B8387A30;
  long long v4 = xmmword_1B8381360;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 0);
  void *v2 = &unk_1F10ADA60;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F1192578;
  *((void *)this + 16) = &unk_1F1192648;
  *((void *)this + 17) = 0;
}

void sub_1B7DF7D6C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSPaintPType_Factory::~PSPaintPType_Factory(PSPaintPType_Factory *this)
{
  PSPaintPType_Factory::~PSPaintPType_Factory(this);

  JUMPOUT(0x1BA9BFBA0);
}

{
  PCSingleton *v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F1192578;
  char v2 = (PSPaintPType_Factory *)((char *)this + 128);
  *((void *)this + 16) = &unk_1F1192648;
  long long v3 = *((void *)this + 17);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *((void *)this + 17) = 0;
  PCSingleton::~PCSingleton(v2);

  OZFactory::~OZFactory((OZFactory *)this);
}

OZChannelBase *PSPaintPType_Factory::create(PSPaintPType_Factory *this, const PCString *a2, unsigned int NextUniqueID)
{
  if (!*((void *)this + 17))
  {
    OZChannelBase::setRangeName((OZChannelBase *)&v12, (const PCString *)@"Motion Effect");
    operator new();
  }
  OZChannelBase::setRangeName((OZChannelBase *)&v11, (const PCString *)@"Motion Effect");
  uint64_t v6 = (OZChannelBase *)(*(uint64_t (**)(PSPaintPType_Factory *, void, uint64_t))(*(void *)this + 24))(this, *((void *)this + 17), 40);
  uint64_t v7 = v6;
  if (!NextUniqueID) {
    NextUniqueID = OZChannelBase::getNextUniqueID(v6);
  }
  OZChannelBase::setID((OZChannelBase *)&v7->var7, NextUniqueID);
  uint64_t v8 = (OZChannelBase *)(*((uint64_t (**)(OZChannelBase *))v7->var0 + 80))(v7);
  OZChannelBase::setName(v8, a2, 0);
  (*((void (**)(OZChannelBase *))v7->var0 + 115))(v7);
  OZChannelBase::setRangeName((OZChannelBase *)&v11, v9);
  return v7;
}

void sub_1B7DF7F74(_Unwind_Exception *a1, int a2, uint64_t a3, OZChannelBase *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  MEMORY[0x1BA9BFBA0](v13, 0x10F1C4086FB70F7, a3, a4);
  OZChannelBase::setRangeName((OZChannelBase *)&a13, v15);
  _Unwind_Resume(a1);
}

void PSPaintPType_Factory::createCopy(PSPaintPType_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF80C8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4086FB70F7);
  _Unwind_Resume(a1);
}

void PSPaintPType_Factory::createNodeCopy(PSPaintPType_Factory *this, OZSceneNode *a2)
{
}

void sub_1B7DF818C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4086FB70F7);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'PSPaintPType_Factory::~PSPaintPType_Factory(PSPaintPType_Factory *this)
{
}

{
  uint64_t vars8;

  PSPaintPType_Factory::~PSPaintPType_Factory((PSPaintPType_Factory *)((char *)this - 128));

  JUMPOUT(0x1BA9BFBA0);
}

void std::__call_once_param<std::tuple<PSEmitterMoToFoBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF82E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40B6B76874);
  _Unwind_Resume(a1);
}

void PSEmitterMoToFoBehavior_Factory::PSEmitterMoToFoBehavior_Factory(PSEmitterMoToFoBehavior_Factory *this)
{
  long long v4 = xmmword_1B8380C90;
  long long v5 = xmmword_1B83871A0;
  long long v3 = xmmword_1B7E78C30;
  OZBehaviorFactory::OZBehaviorFactory((uint64_t)this, &v5, &v4, (__n128 *)&v3, 1);
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 144), 0);
  *(void *)this = &unk_1F11926A0;
  *((void *)this + 18) = &unk_1F1192780;
}

void sub_1B7DF83B0(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSEmitterMoToFoBehavior_Factory::create(PSEmitterMoToFoBehavior_Factory *this, const PCString *a2)
{
}

void sub_1B7DF8424(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40EF478AE9);
  _Unwind_Resume(a1);
}

void PSEmitterMoToFoBehavior_Factory::createCopy(PSEmitterMoToFoBehavior_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF84E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40EF478AE9);
  _Unwind_Resume(a1);
}

void PSEmitterMoToFoBehavior_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSEmitterMoToFoBehavior_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Emitter Motion To Forces Behavior");
}

void PSEmitterMoToFoBehavior_Factory::createBehaviorCopy(PSEmitterMoToFoBehavior_Factory *this, OZBehavior *a2)
{
}

void sub_1B7DF85D4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40EF478AE9);
  _Unwind_Resume(a1);
}

void PSEmitterMoToFoBehavior_Factory::longDescription(PCString *a1@<X8>)
{
}

void std::__call_once_param<std::tuple<PSScaleOverLifeBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF865C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40B6B76874);
  _Unwind_Resume(a1);
}

void PSScaleOverLifeBehavior_Factory::PSScaleOverLifeBehavior_Factory(PSScaleOverLifeBehavior_Factory *this)
{
  long long v4 = xmmword_1B837FF40;
  long long v5 = xmmword_1B83871B0;
  long long v3 = xmmword_1B8380BC0;
  OZBehaviorFactory::OZBehaviorFactory((uint64_t)this, &v5, &v4, (__n128 *)&v3, 0);
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 144), 0);
  *(void *)this = &unk_1F11927D8;
  *((void *)this + 18) = &unk_1F11928B8;
}

void sub_1B7DF8724(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSScaleOverLifeBehavior_Factory::create(PSScaleOverLifeBehavior_Factory *this, const PCString *a2)
{
}

void sub_1B7DF87C0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40EBEA7F86);
  _Unwind_Resume(a1);
}

void PSScaleOverLifeBehavior_Factory::createCopy(PSScaleOverLifeBehavior_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF8884(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40EBEA7F86);
  _Unwind_Resume(a1);
}

void PSScaleOverLifeBehavior_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSScaleOverLifeBehavior_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Scale Over Life Behavior");
}

void PSScaleOverLifeBehavior_Factory::getCategoryName(PCString *a1@<X8>)
{
}

PCString *PSScaleOverLifeBehavior_Factory::getEnglishCategoryName@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Particles");
}

void PSScaleOverLifeBehavior_Factory::createBehaviorCopy(PSScaleOverLifeBehavior_Factory *this, OZBehavior *a2)
{
}

void sub_1B7DF8998(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40EBEA7F86);
  _Unwind_Resume(a1);
}

void PSScaleOverLifeBehavior_Factory::longDescription(PCString *a1@<X8>)
{
}

void std::__call_once_param<std::tuple<PSSequenceBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF8A20(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40B6B76874);
  _Unwind_Resume(a1);
}

void PSSequenceBehavior_Factory::PSSequenceBehavior_Factory(PSSequenceBehavior_Factory *this)
{
  long long v4 = xmmword_1B837FF40;
  long long v5 = xmmword_1B8385810;
  long long v3 = xmmword_1B8380BC0;
  OZBehaviorFactory::OZBehaviorFactory((uint64_t)this, &v5, &v4, (__n128 *)&v3, 0);
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 144), 0);
  *(void *)this = &unk_1F1192910;
  *((void *)this + 18) = &unk_1F11929F0;
}

void sub_1B7DF8AE8(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSSequenceBehavior_Factory::create(PSSequenceBehavior_Factory *this, const PCString *a2)
{
}

void sub_1B7DF8B84(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C406AA8EC51);
  _Unwind_Resume(a1);
}

void PSSequenceBehavior_Factory::createCopy(PSSequenceBehavior_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF8C48(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C406AA8EC51);
  _Unwind_Resume(a1);
}

void PSSequenceBehavior_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSSequenceBehavior_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Replicator Sequence Behavior");
}

void PSSequenceBehavior_Factory::getCategoryName(PCString *a1@<X8>)
{
}

PCString *PSSequenceBehavior_Factory::getEnglishCategoryName@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Replicator");
}

void PSSequenceBehavior_Factory::createBehaviorCopy(PSSequenceBehavior_Factory *this, OZBehavior *a2)
{
}

void sub_1B7DF8D5C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C406AA8EC51);
  _Unwind_Resume(a1);
}

void PSSequenceBehavior_Factory::longDescription(PCString *a1@<X8>)
{
}

void std::__call_once_param<std::tuple<PSPaintSequenceBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF8DE4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40B6B76874);
  _Unwind_Resume(a1);
}

void PSPaintSequenceBehavior_Factory::PSPaintSequenceBehavior_Factory(PSPaintSequenceBehavior_Factory *this)
{
  long long v4 = xmmword_1B8385810;
  long long v5 = xmmword_1B8387C00;
  long long v3 = xmmword_1B837FBE0;
  OZBehaviorFactory::OZBehaviorFactory((uint64_t)this, &v5, &v4, (__n128 *)&v3, 0);
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 144), 0);
  *(void *)this = &unk_1F1192A48;
  *((void *)this + 18) = &unk_1F1192B28;
}

void sub_1B7DF8EAC(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSPaintSequenceBehavior_Factory::create(PSPaintSequenceBehavior_Factory *this, const PCString *a2)
{
}

void sub_1B7DF8F48(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C406AA8EC51);
  _Unwind_Resume(a1);
}

void PSPaintSequenceBehavior_Factory::createCopy(PSPaintSequenceBehavior_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF900C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C406AA8EC51);
  _Unwind_Resume(a1);
}

void PSPaintSequenceBehavior_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSPaintSequenceBehavior_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Particle Paint Sequence Behavior");
}

void PSPaintSequenceBehavior_Factory::createBehaviorCopy(PSPaintSequenceBehavior_Factory *this, OZBehavior *a2)
{
}

void sub_1B7DF90F8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C406AA8EC51);
  _Unwind_Resume(a1);
}

void PSPaintSequenceBehavior_Factory::longDescription(PCString *a1@<X8>)
{
}

void std::__call_once_param<std::tuple<PSSpinOverLifeBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF9180(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40B6B76874);
  _Unwind_Resume(a1);
}

void PSSpinOverLifeBehavior_Factory::PSSpinOverLifeBehavior_Factory(PSSpinOverLifeBehavior_Factory *this)
{
  long long v4 = xmmword_1B8380C70;
  long long v5 = xmmword_1B8387C10;
  long long v3 = xmmword_1B7E78C30;
  OZBehaviorFactory::OZBehaviorFactory((uint64_t)this, &v5, &v4, (__n128 *)&v3, 0);
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 144), 0);
  *(void *)this = &unk_1F1192B80;
  *((void *)this + 18) = &unk_1F1192C60;
}

void sub_1B7DF9248(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSSpinOverLifeBehavior_Factory::create(PSSpinOverLifeBehavior_Factory *this, const PCString *a2)
{
}

void sub_1B7DF92BC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40A49BEE3BLL);
  _Unwind_Resume(a1);
}

void PSSpinOverLifeBehavior_Factory::createCopy(PSSpinOverLifeBehavior_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF9380(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40A49BEE3BLL);
  _Unwind_Resume(a1);
}

void PSSpinOverLifeBehavior_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSSpinOverLifeBehavior_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Spin Over Life Behavior");
}

void PSSpinOverLifeBehavior_Factory::createBehaviorCopy(PSSpinOverLifeBehavior_Factory *this, OZBehavior *a2)
{
}

void sub_1B7DF946C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40A49BEE3BLL);
  _Unwind_Resume(a1);
}

void PSSpinOverLifeBehavior_Factory::longDescription(PCString *a1@<X8>)
{
}

void std::__call_once_param<std::tuple<PSPenPropertyBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF94F4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40B6B76874);
  _Unwind_Resume(a1);
}

void PSPenPropertyBehavior_Factory::PSPenPropertyBehavior_Factory(PSPenPropertyBehavior_Factory *this)
{
  long long v4 = xmmword_1B7E78BB0;
  long long v5 = xmmword_1B8387C20;
  long long v3 = xmmword_1B837FBE0;
  OZBehaviorFactory::OZBehaviorFactory((uint64_t)this, &v5, &v4, (__n128 *)&v3, 1);
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 144), 0);
  *(void *)this = &unk_1F1192CB8;
  *((void *)this + 18) = &unk_1F1192D98;
}

void sub_1B7DF95BC(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSPenPropertyBehavior_Factory::create(PSPenPropertyBehavior_Factory *this, const PCString *a2)
{
}

void sub_1B7DF9658(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40824AFB14);
  _Unwind_Resume(a1);
}

void PSPenPropertyBehavior_Factory::createCopy(PSPenPropertyBehavior_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF971C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40824AFB14);
  _Unwind_Resume(a1);
}

void PSPenPropertyBehavior_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSPenPropertyBehavior_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Pen Property Behavior");
}

void PSPenPropertyBehavior_Factory::createBehaviorCopy(PSPenPropertyBehavior_Factory *this, OZBehavior *a2)
{
}

void sub_1B7DF9808(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40824AFB14);
  _Unwind_Resume(a1);
}

void PSPenPropertyBehavior_Factory::longDescription(PCString *a1@<X8>)
{
}

void std::__call_once_param<std::tuple<PSPenPressureBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF9890(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40B6B76874);
  _Unwind_Resume(a1);
}

void PSPenPressureBehavior_Factory::PSPenPressureBehavior_Factory(PSPenPressureBehavior_Factory *this)
{
  long long v4 = xmmword_1B8387C20;
  long long v5 = xmmword_1B8387C30;
  long long v3 = xmmword_1B837FBE0;
  OZBehaviorFactory::OZBehaviorFactory((uint64_t)this, &v5, &v4, (__n128 *)&v3, 0);
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 144), 0);
  *(void *)this = &unk_1F1192DF0;
  *((void *)this + 18) = &unk_1F1192ED0;
}

void sub_1B7DF9958(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSPenPressureBehavior_Factory::create(PSPenPressureBehavior_Factory *this, const PCString *a2)
{
}

void sub_1B7DF99F4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4072E4963BLL);
  _Unwind_Resume(a1);
}

void PSPenPressureBehavior_Factory::createCopy(PSPenPressureBehavior_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF9AB8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4072E4963BLL);
  _Unwind_Resume(a1);
}

void PSPenPressureBehavior_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSPenPressureBehavior_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Pen Pressure Behavior");
}

void PSPenPressureBehavior_Factory::createBehaviorCopy(PSPenPressureBehavior_Factory *this, OZBehavior *a2)
{
}

void sub_1B7DF9BA4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4072E4963BLL);
  _Unwind_Resume(a1);
}

void PSPenPressureBehavior_Factory::longDescription(PCString *a1@<X8>)
{
}

void std::__call_once_param<std::tuple<PSPenSpeedBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF9C2C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40B6B76874);
  _Unwind_Resume(a1);
}

void PSPenSpeedBehavior_Factory::PSPenSpeedBehavior_Factory(PSPenSpeedBehavior_Factory *this)
{
  long long v4 = xmmword_1B8387C20;
  long long v5 = xmmword_1B8387C40;
  long long v3 = xmmword_1B837FBE0;
  OZBehaviorFactory::OZBehaviorFactory((uint64_t)this, &v5, &v4, (__n128 *)&v3, 0);
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 144), 0);
  *(void *)this = &unk_1F1192F28;
  *((void *)this + 18) = &unk_1F1193008;
}

void sub_1B7DF9CF4(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSPenSpeedBehavior_Factory::create(PSPenSpeedBehavior_Factory *this, const PCString *a2)
{
}

void sub_1B7DF9D90(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40C1ED5FCBLL);
  _Unwind_Resume(a1);
}

void PSPenSpeedBehavior_Factory::createCopy(PSPenSpeedBehavior_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DF9E54(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40C1ED5FCBLL);
  _Unwind_Resume(a1);
}

void PSPenSpeedBehavior_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSPenSpeedBehavior_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Pen Speed Behavior");
}

void PSPenSpeedBehavior_Factory::createBehaviorCopy(PSPenSpeedBehavior_Factory *this, OZBehavior *a2)
{
}

void sub_1B7DF9F40(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40C1ED5FCBLL);
  _Unwind_Resume(a1);
}

void PSPenSpeedBehavior_Factory::longDescription(PCString *a1@<X8>)
{
}

void std::__call_once_param<std::tuple<PSPenTiltBehavior_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7DF9FC8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40B6B76874);
  _Unwind_Resume(a1);
}

void PSPenTiltBehavior_Factory::PSPenTiltBehavior_Factory(PSPenTiltBehavior_Factory *this)
{
  long long v4 = xmmword_1B8387C20;
  long long v5 = xmmword_1B8387C50;
  long long v3 = xmmword_1B837FBE0;
  OZBehaviorFactory::OZBehaviorFactory((uint64_t)this, &v5, &v4, (__n128 *)&v3, 0);
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 144), 0);
  *(void *)this = &unk_1F1193060;
  *((void *)this + 18) = &unk_1F1193140;
}

void sub_1B7DFA090(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void PSPenTiltBehavior_Factory::create(PSPenTiltBehavior_Factory *this, const PCString *a2)
{
}

void sub_1B7DFA12C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4084311906);
  _Unwind_Resume(a1);
}

void PSPenTiltBehavior_Factory::createCopy(PSPenTiltBehavior_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7DFA1F0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4084311906);
  _Unwind_Resume(a1);
}

void PSPenTiltBehavior_Factory::description(PCString *a1@<X8>)
{
}

PCString *PSPenTiltBehavior_Factory::unlocalizedDescription@<X0>(PCString *a1@<X8>)
{
  return PCString::PCString(a1, "Pen Tilt Behavior");
}

void PSPenTiltBehavior_Factory::createBehaviorCopy(PSPenTiltBehavior_Factory *this, OZBehavior *a2)
{
}

void sub_1B7DFA2DC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C4084311906);
  _Unwind_Resume(a1);
}

void PSPenTiltBehavior_Factory::longDescription(PCString *a1@<X8>)
{
}

void PSSpinOverLifeBehavior::PSSpinOverLifeBehavior(PSSpinOverLifeBehavior *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  OZReflexiveBehavior::OZReflexiveBehavior(this, a2, a3, a4);
  *long long v5 = &unk_1F1193198;
  v5[2] = &unk_1F1193480;
  v5[6] = &unk_1F11936D8;
  v5[42] = &unk_1F1193730;
  PCURL::PCURL((PCURL *)&v6, @"Spin Over Life Behavior Increment Type Enum");
  PCURL::PCURL((PCURL *)&v7, @"Spin Over Life Behavior Increment Type");
  OZChannelEnum::OZChannelEnum((PSSpinOverLifeBehavior *)((char *)this + 504), (const PCString *)&v6, &v7, (OZChannelFolder *)((char *)this + 56), 0x190u, 0, 0, 0);
  PCString::~PCString(&v7);
  PCString::~PCString((PCString *)&v6);
  PCURL::PCURL((PCURL *)&v6, @"Spin Over Life Behavior Spin Rate");
  OZChannelAngle::OZChannelAngle((OZChannelAngle *)this + 5, 1.57079633, (const PCString *)&v6, (OZChannelFolder *)((char *)this + 56), 0x191u, 0, 0, 0);
  PCString::~PCString((PCString *)&v6);
  PCURL::PCURL((PCURL *)&v6, @"Spin Over Life Behavior Begin Spin");
  OZChannelAngle::OZChannelAngle((OZChannelAngle *)this + 6, 0.0, (const PCString *)&v6, (OZChannelFolder *)((char *)this + 56), 0x192u, 0, 0, 0);
  PCString::~PCString((PCString *)&v6);
  PCURL::PCURL((PCURL *)&v6, @"Spin Over Life Behavior End Spin");
  OZChannelAngle::OZChannelAngle((OZChannelAngle *)this + 7, 1.57079633, (const PCString *)&v6, (OZChannelFolder *)((char *)this + 56), 0x193u, 0, 0, 0);
  PCString::~PCString((PCString *)&v6);
  PCURL::PCURL((PCURL *)&v6, @"Spin Over Life Behavior Custom Spin");
  OZChannelAngleOverRange::OZChannelAngleOverRange((PSSpinOverLifeBehavior *)((char *)this + 1216), (const PCString *)&v6, (OZChannelFolder *)((char *)this + 56), 0x194u, 0, 0, 0);
  PCString::~PCString((PCString *)&v6);
  OZReflexiveBehavior::setAffectsLeafNodes(this, 1u);
  OZReflexiveBehavior::hideAffectsLeafNodes(this, 1);
  OZChannel::setSliderMin((OZChannel *)this + 5, -6.28318531);
  OZChannel::setSliderMax((OZChannel *)this + 5, 6.28318531);
  OZChannel::setSliderMin((OZChannel *)this + 6, -6.28318531);
  OZChannel::setSliderMax((OZChannel *)this + 6, 6.28318531);
  OZChannel::setSliderMin((OZChannel *)this + 7, -6.28318531);
  OZChannel::setSliderMax((OZChannel *)this + 7, 6.28318531);
  OZChannel::setSliderMin((OZChannel *)this + 8, -6.28318531);
  OZChannel::setSliderMax((OZChannel *)this + 8, 6.28318531);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1216), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1216));
  PCURL::PCURL((PCURL *)&v6, @"Spin Over Life Behavior Over Life");
  PCString::set((PCString *)this + 171, (const PCString *)&v6);
  PCString::~PCString((PCString *)&v6);
  OZChannel::setValueAndIgnoreRecordOption((OZChannel *)this + 8, MEMORY[0x1E4F1FA48]);
  OZFigTimeForChannelSeconds(&v6, 1.0, 0x40000);
  OZChannel::setValueAndIgnoreRecordOption((OZChannel *)this + 8, &v6);
  OZChannelAngleOverRange::setValueOverRange((OZChannel *)this + 8, 0.0, 1.0, 1.57079633);
}

void sub_1B7DFA6AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12)
{
  PCString::~PCString((PCString *)&a9);
  OZChannelAngleOverRange::~OZChannelAngleOverRange(v17);
  OZChannel::~OZChannel(v16);
  OZChannel::~OZChannel(v15);
  OZChannel::~OZChannel(v14);
  OZChannelEnum::~OZChannelEnum(v13);
  OZReflexiveBehavior::~OZReflexiveBehavior(v12);
  _Unwind_Resume(a1);
}

void PSSpinOverLifeBehavior::PSSpinOverLifeBehavior(PSSpinOverLifeBehavior *this, PSSpinOverLifeBehavior *a2, char a3)
{
  OZReflexiveBehavior::OZReflexiveBehavior(this, a2, a3);
  *(void *)uint64_t v5 = &unk_1F1193198;
  *(void *)(v5 + 16) = &unk_1F1193480;
  *(void *)(v5 + 48) = &unk_1F11936D8;
  *(void *)(v5 + 336) = &unk_1F1193730;
  CMTime v6 = (OZChannelFolder *)(v5 + 56);
  OZChannelEnum::OZChannelEnum((OZChannelEnum *)(v5 + 504), (PSSpinOverLifeBehavior *)((char *)a2 + 504), (OZChannelFolder *)(v5 + 56));
  OZChannel::OZChannel((OZChannel *)this + 5, (const OZChannelBase *)((char *)a2 + 760), v6);
  *((void *)this + 95) = &unk_1F11010C0;
  *((void *)this + 97) = &unk_1F1101420;
  OZChannel::OZChannel((OZChannel *)this + 6, (const OZChannelBase *)((char *)a2 + 912), v6);
  *((void *)this + 114) = &unk_1F11010C0;
  *((void *)this + 116) = &unk_1F1101420;
  OZChannel::OZChannel((OZChannel *)this + 7, (const OZChannelBase *)((char *)a2 + 1064), v6);
  *((void *)this + 133) = &unk_1F11010C0;
  *((void *)this + 135) = &unk_1F1101420;
  OZChannelAngleOverRange::OZChannelAngleOverRange((PSSpinOverLifeBehavior *)((char *)this + 1216), (PSSpinOverLifeBehavior *)((char *)a2 + 1216), v6);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1216), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1216));
}

void sub_1B7DFA980(_Unwind_Exception *a1)
{
  OZChannel::~OZChannel(v5);
  OZChannel::~OZChannel(v4);
  OZChannel::~OZChannel(v3);
  OZChannelEnum::~OZChannelEnum(v2);
  OZReflexiveBehavior::~OZReflexiveBehavior(v1);
  _Unwind_Resume(a1);
}

void PSSpinOverLifeBehavior::~PSSpinOverLifeBehavior(PSSpinOverLifeBehavior *this)
{
  *(void *)this = &unk_1F1193198;
  *((void *)this + 2) = &unk_1F1193480;
  *((void *)this + 6) = &unk_1F11936D8;
  *((void *)this + 42) = &unk_1F1193730;
  uint64_t v2 = (OZChannel *)((char *)this + 1216);
  *((void *)this + 152) = &unk_1F110D590;
  *((void *)this + 154) = &unk_1F110D940;
  PCString::~PCString((PCString *)this + 171);
  OZChannel::~OZChannel(v2);
  OZChannel::~OZChannel((OZChannel *)this + 7);
  OZChannel::~OZChannel((OZChannel *)this + 6);
  OZChannel::~OZChannel((OZChannel *)this + 5);
  OZChannelEnum::~OZChannelEnum((PSSpinOverLifeBehavior *)((char *)this + 504));

  OZReflexiveBehavior::~OZReflexiveBehavior(this);
}

{
  uint64_t vars8;

  PSSpinOverLifeBehavior::~PSSpinOverLifeBehavior(this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'PSSpinOverLifeBehavior::~PSSpinOverLifeBehavior(PSSpinOverLifeBehavior *this)
{
}

{
  PSSpinOverLifeBehavior::~PSSpinOverLifeBehavior((PSSpinOverLifeBehavior *)((char *)this - 48));
}

{
  PSSpinOverLifeBehavior::~PSSpinOverLifeBehavior((PSSpinOverLifeBehavior *)((char *)this - 336));
}

{
  uint64_t vars8;

  PSSpinOverLifeBehavior::~PSSpinOverLifeBehavior((PSSpinOverLifeBehavior *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSSpinOverLifeBehavior::~PSSpinOverLifeBehavior((PSSpinOverLifeBehavior *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSSpinOverLifeBehavior::~PSSpinOverLifeBehavior((PSSpinOverLifeBehavior *)((char *)this - 336));

  JUMPOUT(0x1BA9BFBA0);
}

void PSSpinOverLifeBehavior::operator=(PCString *a1, const void *a2)
{
  OZReflexiveBehavior::operator=((uint64_t)a1, a2);
  if (!v4) {
    __cxa_bad_cast();
  }
  uint64_t v5 = v4;
  OZChannelBase::operator=((uint64_t)&a1[63], (uint64_t)&v4[63]);
  OZChannelBase::operator=((uint64_t)&a1[95], (uint64_t)&v5[95]);
  OZChannelBase::operator=((uint64_t)&a1[114], (uint64_t)&v5[114]);
  OZChannelBase::operator=((uint64_t)&a1[133], (uint64_t)&v5[133]);
  OZChannelBase::operator=((uint64_t)&a1[152], (uint64_t)&v5[152]);

  PCString::set(a1 + 171, v5 + 171);
}

unint64_t PSSpinOverLifeBehavior::canAddToSceneNode(PSSpinOverLifeBehavior *this, OZSceneNode *a2)
{
  unint64_t v3 = *(void *)((*(uint64_t (**)(OZSceneNode *))(*(void *)a2 + 664))(a2) + 8);
  long long v11 = xmmword_1B8381350;
  if (OZFactory::isKindOfClass(v3, (int32x4_t *)&v11))
  {
    long long v10 = xmmword_1B8387A30;
    if (!OZFactory::isKindOfClass(v3, (int32x4_t *)&v10)) {
      return 1;
    }
  }
  long long v9 = xmmword_1B8384170;
  if (OZFactory::isKindOfClass(v3, (int32x4_t *)&v9))
  {
    long long v8 = xmmword_1B8384180;
    if (!OZFactory::isKindOfClass(v3, (int32x4_t *)&v8)) {
      return 1;
    }
  }
  long long v7 = xmmword_1B837FBE0;
  unint64_t result = OZFactory::isKindOfClass(v3, (int32x4_t *)&v7);
  if (!result) {
    return result;
  }
  if (!OZChannelBase::isEnabled((OZChannelBase *)(v5 + 25776), 0, 1)
    || (OZChannelBase::isEnabled((OZChannelBase *)(v5 + 21760), 0, 1) & 1) != 0)
  {
    return 0;
  }
  CMTime v6 = (OZChannel *)(v5 + 25904);
  unint64_t result = OZChannel::getValueAsInt(v6, MEMORY[0x1E4F1FA48], 0.0);
  if (result == 1) {
    return result;
  }
  return OZChannel::getValueAsInt(v6, MEMORY[0x1E4F1FA48], 0.0) == 2;
}

BOOL PSSpinOverLifeBehavior::isRebuildUIChannel(PSSpinOverLifeBehavior *this, OZChannelBase *a2)
{
  return (OZChannelBase *)((char *)this + 504) == a2;
}

OZChannelBase *PSSpinOverLifeBehavior::updateHiddenFlags(uint64_t a1, uint64_t a2)
{
  unint64_t result = (OZChannelBase *)OZChannel::getValueAsInt((OZChannel *)(a1 + 504), MEMORY[0x1E4F1FA48], 0.0);
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4 != a2)
  {
    int v5 = (int)result;
    CMTime v6 = (const CMTime *)MEMORY[0x1E4F1FA48];
    do
    {
      long long v7 = *(char **)(v4 + 16);
      if (v7) {
      unint64_t result = (OZChannelBase *)OZChannel::getValueAsInt((OZChannel *)(v7 + 504), v6, 0.0);
      }
      int v8 = (int)result;
      if (v5 != result) {
        break;
      }
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4 != a2);
    uint64_t v9 = *(void *)(a2 + 8);
    if (v9 != a2)
    {
      while (1)
      {
        long long v10 = *(const void **)(v9 + 16);
        long long v11 = v10
        char v12 = (OZChannelBase *)(v11 + 760);
        OZChannelBase::resetFlag((OZChannelBase *)(v11 + 760), 2, 1);
        uint64_t v13 = (OZChannelBase *)(v11 + 912);
        OZChannelBase::resetFlag((OZChannelBase *)(v11 + 912), 2, 1);
        char v14 = (OZChannelBase *)(v11 + 1064);
        OZChannelBase::resetFlag((OZChannelBase *)(v11 + 1064), 2, 1);
        double v15 = (OZChannelBase *)(v11 + 1216);
        unint64_t result = OZChannelBase::resetFlag(v15, 2, 1);
        if (v5 != v8) {
          break;
        }
        switch(v5)
        {
          case 2:
            OZChannelBase::setFlag(v12, 0x400000, 1);
            OZChannelBase::setFlag(v13, 0x400000, 1);
            OZChannelBase::setFlag(v14, 0x400000, 1);
            goto LABEL_17;
          case 1:
            OZChannelBase::setFlag(v12, 0x400000, 1);
            OZChannelBase::resetFlag(v13, 0x400000, 1);
            OZChannelBase::resetFlag(v14, 0x400000, 1);
            goto LABEL_19;
          case 0:
            OZChannelBase::resetFlag(v12, 0x400000, 1);
            OZChannelBase::setFlag(v13, 0x400000, 1);
            OZChannelBase::setFlag(v14, 0x400000, 1);
LABEL_19:
            unint64_t result = OZChannelBase::setFlag(v15, 0x400000, 1);
            break;
        }
LABEL_20:
        uint64_t v9 = *(void *)(v9 + 8);
        if (v9 == a2) {
          return result;
        }
      }
      OZChannelBase::resetFlag(v12, 0x400000, 1);
      OZChannelBase::resetFlag(v13, 0x400000, 1);
      OZChannelBase::resetFlag(v14, 0x400000, 1);
LABEL_17:
      unint64_t result = OZChannelBase::resetFlag(v15, 0x400000, 1);
      goto LABEL_20;
    }
  }
  return result;
}

void PSSpinOverLifeBehavior::accumForcesRate(OZChannel *this, OZSimStateArray *a2)
{
  CMTime v6 = *(CMTime *)((unsigned char *)a2 + 1);
  OZChannel::getValueAsDouble(this + 5, &v6, 0.0);
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = *((void *)a2 + 1);
  if (*(void *)a2 != v5)
  {
    do
    {
      *(float64x2_t *)(v4 + 152) = vaddq_f64(*(float64x2_t *)(v4 + 152), (float64x2_t)0);
      *(double *)(v4 + 168) = v3 + *(double *)(v4 + 168);
      v4 += 248;
    }
    while (v4 != v5);
  }
}

void PSSpinOverLifeBehavior::accumForcesDestination(OZChannel *this, OZSimStateArray *a2)
{
  uint64_t v4 = this + 6;
  if (OZChannel::hasMoreThanOneKeypoint(this + 6)
    || (uint64_t v5 = this + 7, OZChannel::hasMoreThanOneKeypoint(this + 7))
    || (OZBehavior::IsChannelAffectedByBehaviors((OZBehavior *)v4, (const OZChannelBase *)1) & 1) != 0
    || OZBehavior::IsChannelAffectedByBehaviors((OZBehavior *)&this[7], (const OZChannelBase *)1))
  {
    uint64_t v6 = *(void *)a2;
    if (*(void *)a2 != *((void *)a2 + 1))
    {
      long long v7 = this + 7;
      int v8 = (CMTime *)MEMORY[0x1E4F1FA48];
      do
      {
        uint64_t v9 = *(const void **)(v6 + 232);
        if (v9) {
        else
        }
          long long v10 = 0;
        CMTime v27 = *(CMTime *)(v10 + 32);
        CMTime time1 = *(CMTime *)(v10 + 32);
        CMTime time2 = *v8;
        if (CMTimeCompare(&time1, &time2) >= 1)
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          time1.CMTimeEpoch epoch = *((void *)v10 + 3);
          *(_OWORD *)&time1.value = v11;
          OZChannel::getValueAsDouble(v4, &time1, 0.0);
          double v13 = v12;
          OZChannel::getValueAsDouble(v7, &time1, 0.0);
          double v15 = v14 - v13;
          CMTime time = v27;
          Float64 Seconds = CMTimeGetSeconds(&time);
          *(float64x2_t *)(v6 + 152) = vaddq_f64(*(float64x2_t *)(v6 + 152), (float64x2_t)0);
          *(double *)(v6 + 168) = v15 * (1.0 / Seconds) + *(double *)(v6 + 168);
        }
        v6 += 248;
      }
      while (v6 != *((void *)a2 + 1));
    }
  }
  else
  {
    double v17 = (CMTime *)MEMORY[0x1E4F1FA48];
    OZChannel::getValueAsDouble(v4, MEMORY[0x1E4F1FA48], 0.0);
    double v19 = v18;
    OZChannel::getValueAsDouble(v5, v17, 0.0);
    uint64_t v21 = *(void *)a2;
    if (*(void *)a2 != *((void *)a2 + 1))
    {
      double v22 = v20 - v19;
      do
      {
        double v23 = *(char **)(v21 + 232);
        if (v23) {
        CMTime v27 = *(CMTime *)(v23 + 32);
        }
        CMTime time1 = *(CMTime *)(v23 + 32);
        CMTime time2 = *v17;
        if (CMTimeCompare(&time1, &time2) >= 1)
        {
          CMTime v25 = v27;
          Float64 v24 = CMTimeGetSeconds(&v25);
          *(float64x2_t *)(v21 + 152) = vaddq_f64(*(float64x2_t *)(v21 + 152), (float64x2_t)0);
          *(double *)(v21 + 168) = v22 * (1.0 / v24) + *(double *)(v21 + 168);
        }
        v21 += 248;
      }
      while (v21 != *((void *)a2 + 1));
    }
  }
}

void PSSpinOverLifeBehavior::accumForcesCustom(OZChannel *this, OZSimStateArray *a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this + 8;
  if (OZChannel::hasMoreThanOneKeypoint(this + 8)
    || OZBehavior::IsChannelAffectedByBehaviors((OZBehavior *)v4, (const OZChannelBase *)1))
  {
    uint64_t v5 = (*((uint64_t (**)(OZChannel *))this->var0 + 42))(this);
    double v6 = *(double *)(v5 + 368);
    CMTime v35 = *(CMTime *)((unsigned char *)a2 + 1);
    unsigned int v34 = 512;
    uint64_t v7 = ((uint64_t (*)(uint64_t))MEMORY[0x1F4188790])(v5);
    MEMORY[0x1F4188790](v7);
    double v32 = (double *)v23;
    double v33 = v8;
    OZChannel::getSamples(v4, 0.0, 0.001953125, &v34, &v33, &v32, 0.0);
    uint64_t v9 = *(void *)a2;
    if (*(void *)a2 != *((void *)a2 + 1))
    {
      long long v10 = (CMTime *)MEMORY[0x1E4F1FA48];
      do
      {
        long long v11 = *(unsigned char ***)(v9 + 232);
        if (v11) {
        CMTime v31 = *(CMTime *)(v11 + 1);
        }
        CMTime v30 = *(CMTime *)(v11 + 4);
        __n128 v28 = 0uLL;
        CMTimeEpoch v29 = 0;
        uint64_t v12 = (*((uint64_t (**)(OZChannel *))this->var0 + 42))(this);
        OZSceneSettings::getFrameDuration((OZSceneSettings *)(v12 + 336), &v28);
        CMTime time1 = v35;
        CMTime time2 = v31;
        PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v27);
        CMTime time1 = v27;
        *(__n128 *)&time2.value = v28;
        time2.CMTimeEpoch epoch = v29;
        if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
        {
          CMTime time1 = v30;
          CMTime time2 = *v10;
          if (CMTimeCompare(&time1, &time2) >= 1)
          {
            CMTime v26 = v30;
            Float64 Seconds = CMTimeGetSeconds(&v26);
            CMTime time1 = v35;
            CMTime time2 = v31;
            double v14 = 1.0 / Seconds;
            PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v25);
            double v15 = v14 * CMTimeGetSeconds(&v25);
            CMTime time1 = v35;
            *(__n128 *)&time2.value = v28;
            time2.CMTimeEpoch epoch = v29;
            PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v27);
            CMTime time1 = v27;
            CMTime time2 = v31;
            PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v24);
            Float64 v16 = CMTimeGetSeconds(&v24);
            LODWORD(v17) = v34;
            double v18 = (double)v17;
            unsigned int v19 = vcvtmd_s64_f64(v15 * v18 + 0.5 + 0.0000001);
            int v20 = vcvtmd_s64_f64(v14 * v16 * v18 + 0.5 + 0.0000001);
            int v21 = v20 & ~(v20 >> 31);
            if (v21 != v19)
            {
              double v22 = v6 * (*(double *)&v23[v19] - *(double *)&v23[v21]);
              *(float64x2_t *)(v9 + 152) = vaddq_f64(*(float64x2_t *)(v9 + 152), (float64x2_t)0);
              *(double *)(v9 + 168) = v22 + *(double *)(v9 + 168);
            }
          }
        }
        v9 += 248;
      }
      while (v9 != *((void *)a2 + 1));
    }
  }
}

void PSSpinOverLifeBehavior::accumForces(PSSpinOverLifeBehavior *this, OZSimStateArray *a2, OZTransformNode *a3)
{
  if ((*(uint64_t (**)(PSSpinOverLifeBehavior *, OZSimStateArray *, OZTransformNode *))(*(void *)this
                                                                                                 + 336))(this, a2, a3))
  {
    int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 504), MEMORY[0x1E4F1FA48], 0.0);
    switch(ValueAsInt)
    {
      case 2:
        PSSpinOverLifeBehavior::accumForcesCustom((OZChannel *)this, a2);
        break;
      case 1:
        PSSpinOverLifeBehavior::accumForcesDestination((OZChannel *)this, a2);
        break;
      case 0:
        PSSpinOverLifeBehavior::accumForcesRate((OZChannel *)this, a2);
        break;
    }
  }
}

void PSSpinOverLifeBehavior::accumInitialValues(PSSpinOverLifeBehavior *this, OZSimStateArray *a2, int a3, OZTransformNode *a4)
{
  CMTime v16 = *(CMTime *)((unsigned char *)a2 + 1);
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 504), MEMORY[0x1E4F1FA48], 0.0);
  if (ValueAsInt == 2)
  {
    OZChannelAngleOverRange::getValueOverRangeAsDouble((OZChannel *)this + 8, 0.0, 0.0);
  }
  else
  {
    double v8 = 0.0;
    if (ValueAsInt == 1) {
      OZChannel::getValueAsDouble((OZChannel *)this + 6, &v16, 0.0);
    }
  }
  uint64_t v9 = *(float64x2_t **)a2;
  uint64_t v10 = *((void *)a2 + 1);
  BOOL v11 = v10 == *(void *)a2 || a3 < 1;
  if (!v11)
  {
    uint64_t v12 = (float64x2_t *)(v10 - 248);
    int v13 = 1;
    do
    {
      double v14 = v8 + v12[7].f64[1];
      v12[7].f64[0] = v12[7].f64[0] + 0.0;
      v12[7].f64[1] = v14;
      float64x2_t v15 = vaddq_f64((float64x2_t)*(unint64_t *)&v8, v12[6]);
      v12[5] = vaddq_f64(v12[5], (float64x2_t)0);
      v12[6] = v15;
      if (v12 == v9) {
        break;
      }
      uint64_t v12 = (float64x2_t *)((char *)v12 - 248);
      BOOL v11 = v13++ < a3;
    }
    while (v11);
  }
}

void PSPaint::PSPaint(PSPaint *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  PSReplicator::PSReplicator(this, a2, a3, a4);
  *(void *)uint64_t v5 = &unk_1F1193770;
  *((void *)v5 + 25) = &unk_1F1193AA8;
  *((void *)v5 + 27) = &unk_1F1194380;
  *((void *)v5 + 31) = &unk_1F11945D8;
  *((void *)v5 + 841) = &unk_1F1194630;
  *((void *)v5 + 4215) = &unk_1F1194708;
  PSPaint::initPaintChannels(v5);
  (*(void (**)(PSPaint *, uint64_t))(*(void *)this + 448))(this, 1);
  PSEmitter::addNewParticleType(this, 0);
}

void sub_1B7DFBBE4(_Unwind_Exception *a1)
{
  PSReplicator::~PSReplicator(v1);
  _Unwind_Resume(a1);
}

OZChannelBase *PSPaint::initPaintChannels(PSPaint *this)
{
  uint64_t v1 = this;
  uint64_t v2 = (OZChannelBase *)((char *)this + 19488);
  PCURL::PCURL((PCURL *)&v6, @"Replicator Shape Anim");
  OZChannelBase::setName(v2, &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Replicator Shape Anim Enum");
  OZChannelEnum::setStrings((const PCString *)v2, &v6, 1);
  PCString::~PCString(&v6);
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 19896), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 19896));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 20152), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 20152));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 20304), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 20304));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 20456), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 20456));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 21064), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 21064));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 21216), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 21216));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 21472), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 21472));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 22240), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 22240));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 22496), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 22496));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 22752), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 22752));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 23008), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 23008));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 23160), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 23160));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 23312), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 23312));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 23464), 2, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)v1 + 23464));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 24352), 2, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)v1 + 24352));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 25240), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 25240));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 25392), 2, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)v1 + 25392));
  OZChannelBase::setFlag((OZChannelBase *)v1 + 232, 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)v1 + 232);
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 26136), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 26136));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 26288), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 26288));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 26440), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 26440));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 26592), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 26592));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 26744), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 26744));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 27048), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 27048));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 27200), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 27200));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 27352), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 27352));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 27512), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 27512));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 28128), 2, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)v1 + 28128));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 28864), 2, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)v1 + 28864));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 29760), 2, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)v1 + 29760));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 30920), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 30920));
  double v3 = (OZChannelBase *)((char *)v1 + 31072);
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 31072), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 31072));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 31328), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 31328));
  uint64_t v4 = (OZChannelBase *)((char *)v1 + 31632);
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 31632), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 31632));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 31784), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 31784));
  OZChannel::setDefaultValue((OZChannel *)((char *)v1 + 19232), 4.0);
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 19232), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 19232));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 27352), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 27352));
  OZChannel::setDefaultValue((OZChannel *)((char *)v1 + 28256), 0.0);
  OZChannel::setDefaultValue((OZChannel *)((char *)v1 + 31632), 1.0);
  OZChannel::setDefaultValue((OZChannel *)((char *)v1 + 29456), 1.0);
  OZChannel::setDefaultValue((OZChannel *)((char *)v1 + 32792), 0.0);
  PCURL::PCURL((PCURL *)&v6, @"Paint Is 3D");
  OZChannelBase::setName((OZChannelBase *)((char *)v1 + 32792), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Paint Is Depth Ordered");
  OZChannelBase::setName((OZChannelBase *)((char *)v1 + 33352), &v6, 0);
  PCString::~PCString(&v6);
  OZChannel::setDefaultValue((OZChannel *)((char *)v1 + 32944), 1.0);
  OZChannelBase::reset((OZChannelBase *)((char *)v1 + 19232), 0);
  OZChannelBase::reset((OZChannelBase *)((char *)v1 + 19744), 0);
  OZChannelBase::reset((OZChannelBase *)((char *)v1 + 28256), 0);
  OZChannelBase::reset((OZChannelBase *)((char *)v1 + 31632), 0);
  OZChannelBase::reset((OZChannelBase *)v1 + 263, 0);
  OZChannelBase::reset((OZChannelBase *)((char *)v1 + 32792), 0);
  OZChannelBase::reset((OZChannelBase *)((char *)v1 + 32944), 0);
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 19232), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 19232));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 19896), 16, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 19896));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 19744), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 19744));
  OZChannelBase::setFlag((OZChannelBase *)((char *)v1 + 28128), 2, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)v1 + 28128));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)v1 + 27672), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)v1 + 27672));
  uint64_t v1 = (PSPaint *)((char *)v1 + 27976);
  OZChannelBase::resetFlag((OZChannelBase *)v1, 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)v1);
  OZChannelBase::setFlag(v3, 2, 0);
  OZChannelBase::saveStateAsDefault(v3);
  OZChannelBase::setFlag(v4, 2, 0);
  return OZChannelBase::saveStateAsDefault(v4);
}

void sub_1B7DFC36C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PSPaint::PSPaint(PSPaint *this, const PSPaint *a2, uint64_t a3)
{
  char v3 = a3;
  PSReplicator::PSReplicator(this, a2, a3);
  *uint64_t v5 = &unk_1F1193770;
  v5[25] = &unk_1F1193AA8;
  v5[27] = &unk_1F1194380;
  v5[31] = &unk_1F11945D8;
  v5[841] = &unk_1F1194630;
  v5[4215] = &unk_1F1194708;
  if ((v3 & 0x60) == 0x20)
  {
    PaintPType = (OZChannelBase *)PSPaint::getPaintPType(this);
    uint64_t v7 = PaintPType;
    if (PaintPType)
    {
      unsigned int NextUniqueID = OZChannelBase::getNextUniqueID(PaintPType);
      OZChannelBase::setID((OZChannelBase *)&v7->var7, NextUniqueID);
    }
  }
}

void sub_1B7DFC4AC(_Unwind_Exception *a1)
{
  PSReplicator::~PSReplicator(v1);
  _Unwind_Resume(a1);
}

void *PSPaint::getPaintPType(PSPaint *this)
{
  if ((*(unsigned int (**)(PSPaint *))(*(void *)this + 216))(this) != 1) {
    return 0;
  }
  uint64_t v2 = (const void *)(*(uint64_t (**)(PSPaint *, void))(*(void *)this + 224))(this, 0);
  if (!v2) {
    return 0;
  }
}

uint64_t non-virtual thunk to'PSPaint::operator=(uint64_t a1)
{
  return PSReplicator::operator=(a1 - 200);
}

void non-virtual thunk to'PSPaint::~PSPaint(PSPaint *this)
{
}

{
  PSReplicator::~PSReplicator((PSPaint *)((char *)this - 216));
}

{
  PSReplicator::~PSReplicator((PSPaint *)((char *)this - 248));
}

{
  PSReplicator::~PSReplicator((PSPaint *)((char *)this - 6728));
}

{
  PSReplicator::~PSReplicator((PSPaint *)((char *)this - 33720));
}

{
  uint64_t vars8;

  PSReplicator::~PSReplicator((PSPaint *)((char *)this - 200));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSReplicator::~PSReplicator((PSPaint *)((char *)this - 216));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSReplicator::~PSReplicator((PSPaint *)((char *)this - 248));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSReplicator::~PSReplicator((PSPaint *)((char *)this - 6728));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSReplicator::~PSReplicator((PSPaint *)((char *)this - 33720));

  JUMPOUT(0x1BA9BFBA0);
}

void PSPaint::~PSPaint(PSPaint *this)
{
  PSReplicator::~PSReplicator(this);

  JUMPOUT(0x1BA9BFBA0);
}

OZChannelBase *PSPaint::didCreateCopyForCopyOnWrite(PSPaint *this, double a2)
{
  PSEmitter::didCreateCopyForCopyOnWrite(this, a2);
  unint64_t result = (OZChannelBase *)PSPaint::getRotoshape(this);
  if (result)
  {
    unint64_t result = (OZChannelBase *)LODWORD(result[2].var7);
    if (result >= *((_DWORD *)this + 70))
    {
      updated = OZChannelBase::updateIDGenerator(result);
      unsigned int NextUniqueID = OZChannelBase::getNextUniqueID(updated);
      OZChannelBase::setID((OZChannelBase *)((char *)this + 256), NextUniqueID);
      unint64_t result = (OZChannelBase *)PSPaint::getPaintPType(this);
      if (result)
      {
        PCString v6 = result;
        unsigned int v7 = OZChannelBase::getNextUniqueID(result);
        return OZChannelBase::setID((OZChannelBase *)&v6->var7, v7);
      }
    }
  }
  return result;
}

void *PSPaint::getRotoshape(PSPaint *this)
{
  unint64_t result = (void *)*((void *)this + 145);
  if (result) {
  return result;
  }
}

OZChannelBase *non-virtual thunk to'PSPaint::didCreateCopyForCopyOnWrite(PSPaint *this, double a2)
{
  return PSPaint::didCreateCopyForCopyOnWrite((PSPaint *)((char *)this - 200), a2);
}

CGColorSpace **PSPaint::getOriginalBounds(PSPaint *a1, float64x2_t *a2, uint64_t a3)
{
  Rotoshape = PSPaint::getRotoshape(a1);
  if (Rotoshape)
  {
    uint64_t v7 = (uint64_t)Rotoshape;
    OZShapeRenderState::OZShapeRenderState((OZShapeRenderState *)&v14);
    *(void *)&long long v15 = *(void *)(a3 + 16);
    long long v14 = *(_OWORD *)a3;
    BYTE8(v15) = *(unsigned char *)(a3 + 202);
    BYTE10(v15) = *(unsigned char *)(a3 + 220);
    long long v16 = *(_OWORD *)(a3 + 24);
    LODWORD(v17) = 1;
    v11[3] = v17;
    v11[4] = v18;
    v11[0] = v14;
    v11[1] = v15;
    v11[2] = v16;
    CGColorSpaceRef v12 = space;
    if (space) {
      PCCFRefTraits<CGColorSpace *>::retain(space);
    }
    int v13 = v20;
    uint64_t CurrentRenderParams = OZShape::getCurrentRenderParams(v7 + 18976, (uint64_t)v11);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v12);
    OZRotoshape::getOriginalBoundsNoLock(v7, a2, (long long *)a3, CurrentRenderParams);
    return PCCFRef<CGColorSpace *>::~PCCFRef(&space);
  }
  else
  {
    uint64_t v10 = *(uint64_t (**)(PSPaint *, float64x2_t *, uint64_t))(*(void *)a1 + 688);
    return (CGColorSpace **)v10(a1, a2, a3);
  }
}

void sub_1B7DFC988(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v2);
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

CGColorSpace **non-virtual thunk to'PSPaint::getOriginalBounds(uint64_t a1, float64x2_t *a2, uint64_t a3)
{
  return PSPaint::getOriginalBounds((PSPaint *)(a1 - 200), a2, a3);
}

void non-virtual thunk to'PSPaint::getPaintOriginalBounds(uint64_t a1, float64x2_t *a2, const CMTime *a3)
{
}

uint64_t PSPaint::getPaintProjectedBounds(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 184))();
}

uint64_t non-virtual thunk to'PSPaint::getPaintProjectedBounds(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 - 33720) + 184))();
}

BOOL PSPaint::getIsPaint3D(PSPaint *this)
{
  uint64_t v1 = (char *)this + 33728;
  if (*((unsigned char *)this + 33729)) {
    return *v1 != 0;
  }
  BOOL result = OZChannel::getValueAsInt((OZChannel *)((char *)this + 32792), MEMORY[0x1E4F1FA48], 0.0) != 0;
  char *v1 = result;
  v1[1] = 1;
  return result;
}

BOOL non-virtual thunk to'PSPaint::getIsPaint3D(PSPaint *this)
{
  return PSPaint::getIsPaint3D((PSPaint *)((char *)this - 33720));
}

BOOL PSPaint::getIsFacingCamera(PSPaint *this)
{
  return OZChannel::getValueAsInt((OZChannel *)((char *)this + 33200), MEMORY[0x1E4F1FA48], 0.0) != 0;
}

BOOL non-virtual thunk to'PSPaint::getIsFacingCamera(PSPaint *this)
{
  return OZChannel::getValueAsInt((OZChannel *)((char *)this - 520), MEMORY[0x1E4F1FA48], 0.0) != 0;
}

BOOL PSPaint::getIsSimulatingOrSequencing(PSPaint *this, const CMTime *a2)
{
  PaintPType = PSPaint::getPaintPType(this);
  if (!PaintPType) {
    return 0;
  }
  uint64_t v4 = PaintPType;
  if ((*(uint64_t (**)(void *))(*(void *)PaintPType + 1384))(PaintPType)) {
    return 1;
  }
  uint64_t v7 = 0;
  double v8 = 0;
  uint64_t v9 = 0;
  (*(void (**)(void *, const CMTime *, void **))(*(void *)v4 + 1624))(v4, a2, &v7);
  BOOL v5 = v8 != v7;
  if (v7)
  {
    double v8 = v7;
    operator delete(v7);
  }
  return v5;
}

void sub_1B7DFCBBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL non-virtual thunk to'PSPaint::getIsSimulatingOrSequencing(PSPaint *this, const CMTime *a2)
{
  return PSPaint::getIsSimulatingOrSequencing((PSPaint *)((char *)this - 33720), a2);
}

void *PSPaint::calcHashForSourceOnly(PSPaint *this, PCSerializerWriteStream *a2, OZRenderParams *a3)
{
  BOOL result = PSPaint::getRotoshape(this);
  if (result)
  {
    uint64_t v7 = result;
    double v8 = (OZMoShape *)(result + 2372);
    uint64_t StrokeWidthOSChan = OZMoShape::getStrokeWidthOSChan((OZMoShape *)(result + 2372));
    (*(void (**)(uint64_t, PCSerializerWriteStream *, void, uint64_t, uint64_t))(*(void *)StrokeWidthOSChan
                                                                                         + 408))(StrokeWidthOSChan, a2, 0, 1, 1);
    uint64_t v10 = *(void *)OZMoShape::getStrokeSpacingOSChan(v8);
    (*(void (**)(void))(v10 + 408))();
    uint64_t v11 = *(void *)OZMoShape::getStrokeJitterOSChan(v8);
    (*(void (**)(void))(v11 + 408))();
    uint64_t v12 = *(void *)OZMoShape::getStrokeRotationOSChan(v8);
    (*(void (**)(void))(v12 + 408))();
    BOOL result = PSPaint::getPaintPType(this);
    if (result)
    {
      int v13 = (PSParticleType *)result;
      BOOL result = (void *)OZChannel::getValueAsInt((OZChannel *)(v7 + 3238), MEMORY[0x1E4F1FA48], 0.0);
      if (result == 2)
      {
        BOOL result = (void *)(*(uint64_t (**)(PSParticleType *))(*(void *)v13 + 1336))(v13);
        if (result)
        {
          if (result)
          {
            long long v14 = result;
            v23[0] = v23;
            v23[1] = v23;
            v23[2] = 0;
            if (PSParticleType::isSourceSingleFrame(v13))
            {
              OZRenderParams::OZRenderParams((OZRenderParams *)&v19, a3);
              (*(void (**)(long long *__return_ptr, const void *))(*(void *)v14 + 1128))(&v17, v14);
              long long v19 = v17;
              uint64_t v21 = 0;
              uint64_t v22 = 0;
              uint64_t v20 = v18;
              (*(void (**)(const void *, PCSerializerWriteStream *, long long *, void *))(*(void *)v14 + 520))(v14, a2, &v19, v23);
              if (v15)
              {
                long long v17 = *(_OWORD *)a3;
                uint64_t v18 = *((void *)a3 + 2);
                (*(void (**)(void *, PCSerializerWriteStream *, long long *))(v15[136] + 448))(v15 + 136, a2, &v17);
              }
              if (v16)
              {
                long long v17 = *(_OWORD *)a3;
                uint64_t v18 = *((void *)a3 + 2);
                (*(void (**)(void *, PCSerializerWriteStream *, long long *))(v16[835] + 448))(v16 + 835, a2, &v17);
              }
              OZRenderParams::~OZRenderParams((OZRenderParams *)&v19);
            }
            else
            {
              (*(void (**)(const void *, PCSerializerWriteStream *, OZRenderParams *, void *))(*(void *)v14 + 520))(v14, a2, a3, v23);
            }
            return std::__list_imp<unsigned int>::clear(v23);
          }
        }
      }
    }
  }
  return result;
}

void sub_1B7DFD050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  OZRenderParams::~OZRenderParams((OZRenderParams *)va);
  std::__list_imp<unsigned int>::clear((void *)(v7 - 72));
  _Unwind_Resume(a1);
}

void *non-virtual thunk to'PSPaint::calcHashForSourceOnly(PSPaint *this, PCSerializerWriteStream *a2, OZRenderParams *a3)
{
  return PSPaint::calcHashForSourceOnly((PSPaint *)((char *)this - 33720), a2, a3);
}

uint64_t PSPaint::assignPaintIncludingDescendants(PSPaint *this, const OZElement *a2)
{
  PSReplicator::operator=(this);
  if (!v4) {
    __cxa_bad_cast();
  }
  BOOL v5 = v4;
  PaintPType = PSPaint::getPaintPType(this);
  uint64_t v7 = PSPaint::getPaintPType(v5);
  double v8 = *(uint64_t (**)(void *, void *))(*(void *)PaintPType + 80);

  return v8(PaintPType, v7);
}

uint64_t non-virtual thunk to'PSPaint::assignPaintIncludingDescendants(PSPaint *this, const OZElement *a2)
{
  return PSPaint::assignPaintIncludingDescendants((PSPaint *)((char *)this - 33720), a2);
}

OZChannelBase *PSPaint::updateEmitterHiddenFlags(PSPaint *this, char a2)
{
  PSReplicator::updateEmitterHiddenFlags(this, a2);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 19232), 2, 0);

  return OZChannelBase::setFlag((OZChannelBase *)((char *)this + 27352), 2, 0);
}

uint64_t PSPaint::createParticleType(PSPaint *this, OZImageNode *a2)
{
  PCURL::PCURL((PCURL *)&v8, @"Particle Type Default Name");
  if (a2)
  {
    if (v3)
    {
      Name = (const PCString *)OZObjectManipulator::getName((OZObjectManipulator *)&v3->var2);
      PCString::set(&v8, Name);
    }
  }
  unsigned int NextUniqueID = (const PCString *)OZChannelBase::getNextUniqueID(v3);
  uint64_t PaintPType = PSPaintPType::createPaintPType((PSPaintPType *)&v8, NextUniqueID);
  (*(void (**)(void))(*(void *)(PaintPType + 16) + 120))();
  PCString::~PCString(&v8);
  return PaintPType;
}

void sub_1B7DFD2B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void *PSPaint::getGeometryNode(PSPaint *this)
{
  BOOL result = (void *)*((void *)this + 145);
  if (result) {
  return result;
  }
}

void PSPaint::initPropertiesFromShape(int a1, int a2, CMTime *a3, uint64_t a4, uint64_t a5, float64x2_t *a6, uint64_t a7, unsigned char *a8)
{
  *a8 = 1;
  *a6 = vaddq_f64(*(float64x2_t *)(a5 + 192), *a6);
  a6[1].f64[0] = a6[1].f64[0] + 0.0;
  *(_OWORD *)a7 = *(_OWORD *)(a5 + 208);
  *(void *)(a7 + 16) = 0;
  if (OZChannel::getValueAsInt((OZChannel *)(a4 + 2184), a3, 0.0))
  {
    long double v10 = atan2(*(long double *)a7, -*(double *)(a7 + 8));
    __double2 v11 = __sincos_stret(v10 * 0.5);
    double v12 = a6[1].f64[1];
    double v13 = a6[2].f64[0];
    double v14 = v13 * (v11.__sinval * 0.0);
    double v15 = a6[2].f64[1];
    double v16 = a6[3].f64[0];
    double v17 = v15 * (v11.__sinval * 0.0);
    double v18 = v12 * (v11.__sinval * 0.0);
    double v19 = v11.__sinval * 0.0 * v16;
    a6[2].f64[1] = v11.__cosval * v15 + v18 + v19 - v13 * v11.__sinval;
    a6[3].f64[0] = v14 - v17 + v12 * v11.__sinval + v11.__cosval * v16;
    a6[1].f64[1] = v12 * v11.__cosval - (v14 + v17 + v11.__sinval * v16);
    a6[2].f64[0] = v11.__cosval * v13 + v18 + v11.__sinval * v15 - v19;
  }
}

uint64_t PSPaint::parseBegin(PSPaint *this, PCSerializerReadStream *a2)
{
  uint64_t v4 = (char *)this + 1200;
  BOOL v5 = (char *)*((void *)this + 151);
  double v17 = &v17;
  double v18 = &v17;
  uint64_t v19 = 0;
  if (v5 != (char *)this + 1200)
  {
    do
    {
      unint64_t v6 = *(void *)(*((void *)v5 + 2) + 8);
      int32x4_t v16 = (int32x4_t)xmmword_1B8387C20;
      if (OZFactory::isKindOfClass(v6, &v16))
      {
        uint64_t v7 = operator new(0x18uLL);
        uint64_t v8 = *((void *)v5 + 2);
        v7[1] = &v17;
        v7[2] = v8;
        uint64_t v9 = v17;
        *uint64_t v7 = v17;
        v9[1] = v7;
        double v17 = v7;
        ++v19;
      }
      BOOL v5 = (char *)*((void *)v5 + 1);
    }
    while (v5 != v4);
    for (uint64_t i = v18; i != &v17; uint64_t i = (void *)i[1])
    {
      uint64_t v11 = (*(uint64_t (**)(void))(*(void *)i[2] + 312))(i[2]);
      (*(void (**)(PSPaint *, uint64_t))(*(void *)this + 416))(this, v11);
    }
  }
  uint64_t v12 = (*(uint64_t (**)(PSPaint *, void))(*(void *)this + 224))(this, 0);
  if (v12)
  {
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 216))(v12);
    (*(void (**)(PSPaint *, uint64_t))(*(void *)this + 416))(this, v13);
  }
  uint64_t v14 = PSEmitter::parseBegin(this, a2);
  std::__list_imp<unsigned int>::clear(&v17);
  return v14;
}

void sub_1B7DFD5F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::__list_imp<unsigned int>::clear((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'PSPaint::parseBegin(PSPaint *this, PCSerializerReadStream *a2)
{
  return PSPaint::parseBegin((PSPaint *)((char *)this - 200), a2);
}

{
  return PSPaint::parseBegin((PSPaint *)((char *)this - 248), a2);
}

uint64_t PSPaint::parseEnd(PSPaint *this, PCSerializerReadStream *a2)
{
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(*(int32x4_t *)(*(void *)((*(uint64_t (**)(void))(*((void *)this + 25) + 664))()+ 8)+ 8), (int32x4_t)xmmword_1B837FEB0)))) & 1) == 0&& OZChannel::getValueAsInt((OZChannel *)((char *)this + 32944), MEMORY[0x1E4F1FA48], 0.0) != 1)
  {
    OZChannel::setDefaultValue((OZChannel *)((char *)this + 32944), 1.0);
    OZChannelBase::reset((OZChannelBase *)((char *)this + 32944), 0);
  }

  return PSReplicator::parseEnd(this, a2);
}

uint64_t non-virtual thunk to'PSPaint::parseEnd(PSPaint *this, PCSerializerReadStream *a2)
{
  return PSPaint::parseEnd((PSPaint *)((char *)this - 200), a2);
}

{
  return PSPaint::parseEnd((PSPaint *)((char *)this - 248), a2);
}

double PSPaint::calcHashForState(PSPaint *a1, const void *a2, long long *a3)
{
  Rotoshape = (char *)PSPaint::getRotoshape(a1);
  if (Rotoshape)
  {
    uint64_t v8 = Rotoshape;
    if (OZChannelBase::isEnabled((OZChannelBase *)(Rotoshape + 25776), 0, 1))
    {
      if ((OZChannelBase::isEnabled((OZChannelBase *)(v8 + 21760), 0, 1) & 1) == 0)
      {
        uint64_t v9 = (OZChannel *)(v8 + 25904);
        if (OZChannel::getValueAsInt(v9, MEMORY[0x1E4F1FA48], 0.0) == 1
          || OZChannel::getValueAsInt(v9, MEMORY[0x1E4F1FA48], 0.0) == 2)
        {
          return PSEmitter::calcHashForState(a1, a2, a3);
        }
      }
    }
  }
  return result;
}

double non-virtual thunk to'PSPaint::calcHashForState(uint64_t a1, const void *a2, long long *a3)
{
  return PSPaint::calcHashForState((PSPaint *)(a1 - 200), a2, a3);
}

{
  return PSPaint::calcHashForState((PSPaint *)(a1 - 216), a2, a3);
}

void PSPaint::addPenPropertyBehaviors(PSPaint *this)
{
  uint64_t v1 = (char *)this + 200;
  uint64_t v2 = (char *)this + 1200;
  char v3 = (char *)*((void *)this + 151);
  if (v3 == (char *)this + 1200)
  {
    LOBYTE(v4) = 0;
  }
  else
  {
    double v32 = (char *)this + 200;
    int v4 = 0;
    char v5 = 0;
    do
    {
      uint64_t v6 = *((void *)v3 + 2);
      uint64_t v7 = *(_DWORD **)(v6 + 8);
      int v8 = v7[2];
      int v9 = v7[3];
      int v10 = v7[4];
      int v11 = v7[5];
      BOOL v14 = v8 == 86313994 && v9 == -1831908132 && v10 == -2092803630 && v11 == -1221222574;
      if (!v14 || (v5 & 1) != 0)
      {
        BOOL v18 = v8 != 1704547312 || v9 != -1174322166 || v10 != -1352090407 || v11 != 1680446981;
        if (((v18 | v4) & 1) == 0)
        {
          PCURL::PCURL((PCURL *)v34, @"PPaint Pen Pressure");
          (*(void (**)(uint64_t, PCString *, void))(*(void *)(v6 + 16) + 120))(v6 + 16, v34, 0);
          PCString::~PCString(v34);
          int v4 = 1;
        }
      }
      else
      {
        PCURL::PCURL((PCURL *)v34, @"PPaint Pen Speed");
        (*(void (**)(uint64_t, PCString *, void))(*(void *)(v6 + 16) + 120))(v6 + 16, v34, 0);
        PCString::~PCString(v34);
        char v5 = 1;
      }
      char v3 = (char *)*((void *)v3 + 1);
    }
    while (v3 != v2);
    if (v5)
    {
      uint64_t v1 = v32;
      if (v4) {
        return;
      }
      goto LABEL_44;
    }
    uint64_t v1 = v32;
  }
  uint64_t v19 = theApp;
  *(_OWORD *)&v34[0].$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = xmmword_1B8387C40;
  PCURL::PCURL((PCURL *)&v33, @"PPaint Pen Speed");
  OZChannelBase::getNextUniqueID(v20);
  Behavior = (const void *)OZApplication::createBehavior(v19, (unsigned int *)v34);
  if (Behavior) {
  else
  }
    uint64_t v22 = 0;
  PCString::~PCString(&v33);
  int DefaultApplyTo = PSPenSpeedBehavior::getDefaultApplyTo(v23);
  if (DefaultApplyTo <= 0)
  {
    (*(void (**)(void *, void))(v22[2] + 40))(v22 + 2, 0);
  }
  else
  {
    unsigned int v25 = DefaultApplyTo;
    (*(void (**)(void *, void, void, double))(v22[67] + 712))(v22 + 67, MEMORY[0x1E4F1FA48], 0, (double)(DefaultApplyTo - 1));
    if (v25 <= 2) {
      (*(void (**)(void *, void, void, double))(v22[245] + 712))(v22 + 245, MEMORY[0x1E4F1FA48], 0, 1.0);
    }
  }
  (*(void (**)(char *, void *, void))(*(void *)v1 + 360))(v1, v22, 0);
  if ((v4 & 1) == 0)
  {
LABEL_44:
    uint64_t v26 = theApp;
    *(_OWORD *)&v34[0].$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = xmmword_1B8387C30;
    PCURL::PCURL((PCURL *)&v33, @"PPaint Pen Pressure");
    OZChannelBase::getNextUniqueID(v27);
    __n128 v28 = (const void *)OZApplication::createBehavior(v26, (unsigned int *)v34);
    if (v28) {
    else
    }
      CMTimeEpoch v29 = 0;
    PCString::~PCString(&v33);
    int v31 = PSPenPressureBehavior::getDefaultApplyTo(v30);
    if (v31 < 1) {
      (*(void (**)(void *, void))(v29[2] + 40))(v29 + 2, 0);
    }
    else {
      (*(void (**)(void *, void, void, double))(v29[67] + 712))(v29 + 67, MEMORY[0x1E4F1FA48], 0, (double)(v31 - 1));
    }
    (*(void (**)(char *, void *, void))(*(void *)v1 + 360))(v1, v29, 0);
  }
}

void sub_1B7DFDCD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10, PCString a11)
{
}

void non-virtual thunk to'PSPaint::addPenPropertyBehaviors(PSPaint *this)
{
}

void *PSPaint::initPenPropertyBehaviors(__n128 *this)
{
  __n128 v31 = 0uLL;
  CMTimeEpoch v32 = 0;
  __n128 TimeOffset = OZChannelObjectRootBase::getTimeOffset(this + 16, &v31);
  unint64_t v4 = this[12].n128_u64[1];
  char v3 = &this[12].n128_i8[8];
  double result = (*(void *(**)(void *__return_ptr, __int8 *, __n128))(v4 + 1128))(v30, v3, TimeOffset);
  uint64_t v6 = *((void *)v3 + 126);
  if ((__int8 *)v6 != v3 + 1000)
  {
    while (1)
    {
      double result = *(void **)(v6 + 16);
      uint64_t v7 = (_DWORD *)result[1];
      int v8 = v7[2];
      int v9 = v7[3];
      int v10 = v7[4];
      int v11 = v7[5];
      BOOL v12 = v8 == 86313994 && v9 == -1831908132;
      BOOL v13 = v12 && v10 == -2092803630;
      if (v13 && v11 == -1221222574) {
        break;
      }
      if (v8 != 1704547312 || v9 != -1174322166 || v10 != -1352090407 || v11 != 1680446981) {
        goto LABEL_29;
      }
      OZChannelObjectRootBase::setTimeExtent((OZChannelObjectRootBase *)(v18 + 7), (const PCTimeRange *)v30, 0);
      *(__n128 *)&v28.value = v31;
      v28.CMTimeEpoch epoch = v32;
      OZChannelObjectRootBase::setTimeOffset((__n128 *)(v18 + 7), &v28, 0);
      int DefaultApplyTo = PSPenPressureBehavior::getDefaultApplyTo(v19);
      int v21 = DefaultApplyTo - 1;
      if (DefaultApplyTo < 1) {
        goto LABEL_28;
      }
      (*(void (**)(void *, void))(v18[2] + 32))(v18 + 2, 0);
      v22.n128_f64[0] = (double)v21;
      (*(void (**)(__n128))(v18[67] + 712))(v22);
      double result = (void *)PSPenPropertyBehavior::updateApplyTo((PSPenPropertyBehavior *)v18);
LABEL_29:
      uint64_t v6 = *(void *)(v6 + 8);
      if ((__int8 *)v6 == v3 + 1000) {
        return result;
      }
    }
    OZChannelObjectRootBase::setTimeExtent((OZChannelObjectRootBase *)(v18 + 7), (const PCTimeRange *)v30, 0);
    *(__n128 *)&v29.value = v31;
    v29.CMTimeEpoch epoch = v32;
    OZChannelObjectRootBase::setTimeOffset((__n128 *)(v18 + 7), &v29, 0);
    int v24 = PSPenSpeedBehavior::getDefaultApplyTo(v23);
    int v25 = v24 - 1;
    if (v24 >= 1)
    {
      unsigned int v26 = v24;
      (*(void (**)(void *, void))(v18[2] + 32))(v18 + 2, 0);
      v27.n128_f64[0] = (double)v25;
      (*(void (**)(__n128))(v18[67] + 712))(v27);
      double result = (void *)PSPenPropertyBehavior::updateApplyTo((PSPenPropertyBehavior *)v18);
      if (v26 <= 2) {
        double result = (void *)(*(uint64_t (**)(void *, void, void, double))(v18[245] + 712))(v18 + 245, MEMORY[0x1E4F1FA48], 0, 1.0);
      }
      goto LABEL_29;
    }
LABEL_28:
    double result = (void *)(*(uint64_t (**)(void *, void))(v18[2] + 40))(v18 + 2, 0);
    goto LABEL_29;
  }
  return result;
}

void *non-virtual thunk to'PSPaint::initPenPropertyBehaviors(PSPaint *this)
{
  return PSPaint::initPenPropertyBehaviors((__n128 *)((char *)this - 33720));
}

void PSPaint::didApplyStyle(PSPaint *this)
{
  uint64_t PaintPType = (char *)PSPaint::getPaintPType(this);
  Rotoshape = (char *)PSPaint::getRotoshape(this);
  (*(void (**)(PSPaint *))(*(void *)this + 656))(this);
  if (PaintPType && Rotoshape)
  {
    if (OZChannel::getValueAsInt((OZChannel *)(Rotoshape + 25904), MEMORY[0x1E4F1FA48], 0.0) != 2) {
      OZChannelBase::reset((OZChannelBase *)(PaintPType + 14392), 0);
    }
    unint64_t v4 = (OZChannel *)(PaintPType + 11192);
    OZChannel::setDefaultValue(v4, 1.0);
    OZChannelBase::reset((OZChannelBase *)v4, 0);
  }
}

void non-virtual thunk to'PSPaint::didApplyStyle(PSPaint *this)
{
}

PSPaintPType *PSPaint::disableSourceNode(PSPaint *this)
{
  double result = (PSPaintPType *)PSPaint::getPaintPType(this);
  if (result)
  {
    return (PSPaintPType *)PSPaintPType::disableSourceNode(result);
  }
  return result;
}

PSPaintPType *non-virtual thunk to'PSPaint::disableSourceNode(PSPaint *this)
{
  double result = (PSPaintPType *)PSPaint::getPaintPType((PSPaint *)((char *)this - 33720));
  if (result)
  {
    return (PSPaintPType *)PSPaintPType::disableSourceNode(result);
  }
  return result;
}

void *PSPaint::beginInteractive(void *this)
{
  uint64_t v1 = this + 150;
  uint64_t v2 = (void *)this[151];
  if (v2 != this + 150)
  {
    do
    {
      this = (void *)v2[2];
      if (this)
      {
        if (this) {
          this = (void *)(*(uint64_t (**)(void *, uint64_t))(*this + 672))(this, 1);
        }
      }
      uint64_t v2 = (void *)v2[1];
    }
    while (v2 != v1);
  }
  return this;
}

void *non-virtual thunk to'PSPaint::beginInteractive(PSPaint *this)
{
  return PSPaint::beginInteractive((void *)this - 4215);
}

void *PSPaint::endInteractive(void *this)
{
  uint64_t v1 = this + 150;
  uint64_t v2 = (void *)this[151];
  if (v2 != this + 150)
  {
    do
    {
      this = (void *)v2[2];
      if (this)
      {
        if (this) {
          this = (void *)(*(uint64_t (**)(void *, void))(*this + 672))(this, 0);
        }
      }
      uint64_t v2 = (void *)v2[1];
    }
    while (v2 != v1);
  }
  return this;
}

void *non-virtual thunk to'PSPaint::endInteractive(PSPaint *this)
{
  return PSPaint::endInteractive((void *)this - 4215);
}

uint64_t PSPaint::getStrokeWidthOSChan(PSPaint *this)
{
  return (uint64_t)PSPaint::getPaintPType(this) + 12496;
}

uint64_t non-virtual thunk to'PSPaint::getStrokeWidthOSChan(PSPaint *this)
{
  return (uint64_t)PSPaint::getPaintPType((PSPaint *)((char *)this - 33720)) + 12496;
}

uint64_t PSPaint::getStrokeSpacingOSChan(PSPaint *this)
{
  return (uint64_t)PSPaint::getPaintPType(this) + 12336;
}

uint64_t non-virtual thunk to'PSPaint::getStrokeSpacingOSChan(PSPaint *this)
{
  return (uint64_t)PSPaint::getPaintPType((PSPaint *)((char *)this - 33720)) + 12336;
}

uint64_t PSPaint::getStrokeJitterOSChan(PSPaint *this)
{
  return (uint64_t)PSPaint::getPaintPType(this) + 13944;
}

uint64_t non-virtual thunk to'PSPaint::getStrokeJitterOSChan(PSPaint *this)
{
  return (uint64_t)PSPaint::getPaintPType((PSPaint *)((char *)this - 33720)) + 13944;
}

uint64_t PSPaint::getStrokeRotationOSChan(PSPaint *this)
{
  return (uint64_t)PSPaint::getPaintPType(this) + 4048;
}

uint64_t non-virtual thunk to'PSPaint::getStrokeRotationOSChan(PSPaint *this)
{
  return (uint64_t)PSPaint::getPaintPType((PSPaint *)((char *)this - 33720)) + 4048;
}

unint64_t PSPaint::getIsSimulationEnabled(PSPaint *this)
{
  uint64_t v1 = (OZChannelBase *)((char *)PSPaint::getPaintPType(this) + 11904);

  return OZChannelBase::isEnabled(v1, 0, 1);
}

unint64_t non-virtual thunk to'PSPaint::getIsSimulationEnabled(PSPaint *this)
{
  uint64_t v1 = (OZChannelBase *)((char *)PSPaint::getPaintPType((PSPaint *)((char *)this - 33720)) + 11904);

  return OZChannelBase::isEnabled(v1, 0, 1);
}

uint64_t PSPaint::dirtyPaintCache(PSPaint *this)
{
  uint64_t PaintPType = PSPaint::getPaintPType(this);
  uint64_t v2 = (OZSystemSimulator *)(*(uint64_t (**)(void *))(*(void *)PaintPType + 1344))(PaintPType);

  return OZSystemSimulator::dirtyCache(v2);
}

uint64_t non-virtual thunk to'PSPaint::dirtyPaintCache(PSPaint *this)
{
  uint64_t PaintPType = PSPaint::getPaintPType((PSPaint *)((char *)this - 33720));
  uint64_t v2 = (OZSystemSimulator *)(*(uint64_t (**)(void *))(*(void *)PaintPType + 1344))(PaintPType);

  return OZSystemSimulator::dirtyCache(v2);
}

uint64_t PSPaint::getErrorDisplayName(PSPaint *this)
{
  uint64_t v1 = *((void *)this + 145);
  if (v1) {
    return OZObjectManipulator::getName((OZObjectManipulator *)(v1 + 16));
  }
  else {
    return OZObjectManipulator::getName((PSPaint *)((char *)this + 216));
  }
}

double PSPaint::getPixelAspectRatio(PSPaint *this)
{
  return *((double *)this + 820);
}

void PSPaintPType::PSPaintPType(PSPaintPType *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  PSReplicatorPType::PSReplicatorPType(this, a2, a3, a4);
  *char v5 = &unk_1F11947F8;
  v5[2] = &unk_1F1194E90;
  v5[6] = &unk_1F11950E8;
  v5[136] = &unk_1F1195140;
  v5[139] = &unk_1F1195218;
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Brush Profile");
  OZChannelGradient::OZChannelGradient((PSPaintPType *)((char *)this + 16984), &v7, (OZChannelFolder *)((char *)this + 448), 0xC8u, 0);
  PCString::~PCString(&v7);
  PCString::PCString(&v7, "Hidden Opacity Over Stroke");
  OZChannelPercentOverRange::OZChannelPercentOverRange((PSPaintPType *)((char *)this + 17784), 1.0, &v7, (OZChannelFolder *)((char *)this + 448), 0xC9u, 0, 0, 0);
  PCString::~PCString(&v7);
  *((void *)this + 2245) = 0;
  *(_OWORD *)((char *)this + 17944) = 0u;
  PCMutex::PCMutex((PCMutex *)((char *)this + 17968));
  *((void *)this + 2260) = 0;
  *((_DWORD *)this + 4522) = 0;
  *((unsigned char *)this + 18092) = 0;
  *(_OWORD *)((char *)this + 18040) = 0u;
  *(_OWORD *)((char *)this + 18056) = 0u;
  *((_DWORD *)this + 4518) = 0;
  *((void *)this + 2262) = 0xBFF0000000000000;
  *((void *)this + 2264) = 0;
  *((_DWORD *)this + 4530) = 0;
  OZChannelBase::enable((OZChannelBase *)((char *)this + 11904), 0, 1);
  (*(void (**)(PSPaintPType *))(*(void *)this + 1536))(this);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Align Rotation");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 2184), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Rotation");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 2336), &v7, 0);
  PCString::~PCString(&v7);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 3192), 2, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 3192));
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Rotation Variance");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 4208), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Color Over Stroke");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 6784), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Random Color");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 7584), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Color Repetitions");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 7736), &v7, 0);
  PCString::~PCString(&v7);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 7888), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 7888));
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Scale");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 8040), &v7, 0);
  PCString::~PCString(&v7);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 8632), 2, 0);
  OZChannelFolder::saveStateAsDefault((OZChannelFolder *)((char *)this + 8632));
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Scale Variance");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 9224), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Is Additive Blend");
  OZChannelBase::setName((OZChannelBase *)this + 89, &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Animate Image");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 10120), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Random Source Start Frame");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 10272), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Source Start Frame");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 10424), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Source Start Frame Offset");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 10576), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Source Start Frame OS");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 10728), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Hold Frames");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 10888), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Hold Frames Variance");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 11040), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Shape");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 11344), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Shape Enum");
  OZChannelEnum::setStrings((const PCString *)this + 1418, &v7, 1);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Seed");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 11600), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Point Size");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 11752), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Image Node Ref");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 14392), &v7, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Stroke Range");
  PCString::set((PCString *)this + 525, &v7);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Stroke Range");
  PCString::set((PCString *)this + 1561, &v7);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Stroke Range");
  PCString::set((PCString *)this + 1581, &v7);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Stroke Range");
  PCString::set((PCString *)this + 1798, &v7);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Stroke Range");
  PCString::set((PCString *)this + 2242, &v7);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Stroke Range");
  PCString::set((PCString *)this + 1360, &v7);
  PCString::~PCString(&v7);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 10728), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 10728));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1576), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1576));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1728), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1728));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1880), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 1880));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2032), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 2032));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 5064), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 5064));
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 5216), 2, 0);
  OZChannelBase::saveStateAsDefault((OZChannelBase *)((char *)this + 5216));
  int v8 = 3;
  v7.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = (__CFString *)0x200000001;
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 5368), 1.0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 5368), 0);
  OZChannelEnum::setTags((PSPaintPType *)((char *)this + 5368), (char *)&v7, 3);
  PCURL::PCURL((PCURL *)&v6, @"PPaint PType Color Mode Enum");
  OZChannelEnum::setStrings((const PCString *)this + 671, &v6, 1);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"PPaint PType Color Mode");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 5368), &v6, 0);
  PCString::~PCString(&v6);
  (*(void (**)(PSPaintPType *, uint64_t))(*(void *)this + 1528))(this, 1);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 11192), 1.0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 11192), 0);
  *((_DWORD *)this + 4444) = 3;
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 17112), 2, 1);
  (*(void (**)(char *))(*((void *)this + 2139) + 128))((char *)this + 17112);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 16984), 0);
  *((_WORD *)this + 9062) = 0;
}

void sub_1B7DFF0B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  std::vector<PCPtr<LiMaterialLayer>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  PCMutex::~PCMutex(v13);
  std::vector<PCPtr<LiMaterialLayer>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(v12);
  OZChannelGradient::~OZChannelGradient(v11);
  PSReplicatorPType::~PSReplicatorPType(v10);
  _Unwind_Resume(a1);
}

void PSPaintPType::PSPaintPType(PSPaintPType *this, PSPaintPType *a2, char a3)
{
  PSReplicatorPType::PSReplicatorPType(this, a2, a3);
  *(void *)uint64_t v5 = &unk_1F11947F8;
  *(void *)(v5 + 16) = &unk_1F1194E90;
  *(void *)(v5 + 48) = &unk_1F11950E8;
  *(void *)(v5 + 1088) = &unk_1F1195140;
  *(void *)(v5 + 1112) = &unk_1F1195218;
  PCString v6 = (OZChannelFolder *)(v5 + 448);
  OZChannelGradient::OZChannelGradient((OZChannelGradient *)(v5 + 16984), (PSPaintPType *)((char *)a2 + 16984), (OZChannelFolder *)(v5 + 448));
  OZChannelPercentOverRange::OZChannelPercentOverRange((PSPaintPType *)((char *)this + 17784), (PSPaintPType *)((char *)a2 + 17784), v6);
  *((void *)this + 2245) = 0;
  *(_OWORD *)((char *)this + 17944) = 0u;
  PCMutex::PCMutex((PCMutex *)((char *)this + 17968));
  *((void *)this + 2260) = 0;
  *((_DWORD *)this + 4522) = 0;
  *((unsigned char *)this + 18092) = 0;
  *(_OWORD *)((char *)this + 18040) = 0u;
  *(_OWORD *)((char *)this + 18056) = 0u;
  *((_DWORD *)this + 4518) = 0;
  *((void *)this + 2262) = 0xBFF0000000000000;
  *((void *)this + 2264) = 0;
  *((_DWORD *)this + 4530) = 0;
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Stroke Range");
  PCString::set((PCString *)this + 525, &v7);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Stroke Range");
  PCString::set((PCString *)this + 1561, &v7);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Stroke Range");
  PCString::set((PCString *)this + 1581, &v7);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Stroke Range");
  PCString::set((PCString *)this + 1798, &v7);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Stroke Range");
  PCString::set((PCString *)this + 2242, &v7);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"PPaint PType Stroke Range");
  PCString::set((PCString *)this + 1360, &v7);
  PCString::~PCString(&v7);
  *((_WORD *)this + 9062) = 0;
}

void sub_1B7DFF4F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  std::vector<PCPtr<LiMaterialLayer>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  PCMutex::~PCMutex(v13);
  std::vector<PCPtr<LiMaterialLayer>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(v12);
  OZChannelGradient::~OZChannelGradient(v11);
  PSReplicatorPType::~PSReplicatorPType(v10);
  _Unwind_Resume(a1);
}

void sub_1B7DFF570()
{
}

void sub_1B7DFF578()
{
}

void sub_1B7DFF580()
{
}

void PSPaintPType::~PSPaintPType(PSPaintPType *this)
{
  *(void *)this = &unk_1F11947F8;
  *((void *)this + 2) = &unk_1F1194E90;
  *((void *)this + 6) = &unk_1F11950E8;
  *((void *)this + 136) = &unk_1F1195140;
  *((void *)this + 139) = &unk_1F1195218;
  OZSystemSimulator::flushCache((PSPaintPType *)((char *)this + 15520), 1, 0);
  OZSystemSimulator::flushCache((PSPaintPType *)((char *)this + 15800), 1, 0);
  PGPerThreadSetCurrentContextSentry::PGPerThreadSetCurrentContextSentry((PGPerThreadSetCurrentContextSentry *)v4);
  uint64_t v2 = (void *)*((void *)this + 2243);
  char v3 = (void *)*((void *)this + 2244);
  while (v2 != v3)
  {
    if (!*v2) {
      throw_PCNullPointerException(1);
    }
    (*(void (**)(void))(*(void *)*v2 + 24))(*v2);
    v2 += 2;
  }
  PGPerThreadSetCurrentContextSentry::~PGPerThreadSetCurrentContextSentry((PGPerThreadSetCurrentContextSentry *)v4);
  v4[0] = (void **)((char *)this + 18040);
  std::vector<PCPtr<LiMaterialLayer>>::__destroy_vector::operator()[abi:ne180100](v4);
  PCMutex::~PCMutex((PCMutex *)((char *)this + 17968));
  v4[0] = (void **)((char *)this + 17944);
  std::vector<PCPtr<LiMaterialLayer>>::__destroy_vector::operator()[abi:ne180100](v4);
  *((void *)this + 2223) = &unk_1F110D998;
  *((void *)this + 2225) = &unk_1F110DD48;
  PCString::~PCString((PCString *)this + 2242);
  OZChanObjectRef::~OZChanObjectRef((PSPaintPType *)((char *)this + 17784));
  OZChannelGradient::~OZChannelGradient((PSPaintPType *)((char *)this + 16984));
  PSReplicatorPType::~PSReplicatorPType(this);
}

{
  uint64_t vars8;

  PSPaintPType::~PSPaintPType(this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'PSPaintPType::~PSPaintPType(PSPaintPType *this)
{
}

{
  PSPaintPType::~PSPaintPType((PSPaintPType *)((char *)this - 48));
}

{
  PSPaintPType::~PSPaintPType((PSPaintPType *)((char *)this - 1088));
}

{
  PSPaintPType::~PSPaintPType((PSPaintPType *)((char *)this - 1112));
}

{
  uint64_t vars8;

  PSPaintPType::~PSPaintPType((PSPaintPType *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSPaintPType::~PSPaintPType((PSPaintPType *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSPaintPType::~PSPaintPType((PSPaintPType *)((char *)this - 1088));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSPaintPType::~PSPaintPType((PSPaintPType *)((char *)this - 1112));

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PSPaintPType::createPaintPType(PSPaintPType *this, const PCString *a2)
{
  long long v3 = xmmword_1B8381360;
  return OZApplication::createSceneNode(theApp, (unsigned int *)&v3);
}

void PSPaintPType::getBounds(PSPaintPType *this, uint64_t a2)
{
  unint64_t v4 = (char *)this + 18124;
  __asm { FMOV            V0.2D, #-18.0 }
  *(_OWORD *)a2 = _Q0;
  *(int64x2_t *)(a2 + 16) = vdupq_n_s64(0x4042000000000000uLL);
  if (*((unsigned char *)this + 18125))
  {
    if (!*v4) {
      return;
    }
  }
  else
  {
    unsigned int IsImageBrush = PSPaintPType::getIsImageBrush(this);
    *unint64_t v4 = IsImageBrush;
    v4[1] = 1;
    if (!IsImageBrush) {
      return;
    }
  }

  PSParticleType::getBounds((uint64_t)this, (__n128 *)a2);
}

void non-virtual thunk to'PSPaintPType::getBounds(uint64_t a1, uint64_t a2)
{
}

uint64_t PSPaintPType::calcHashForState(PSPaintPType *a1, void *a2, CMTime *a3, uint64_t **a4)
{
  uint64_t result = (uint64_t)PSPaintPType::getPaint(a1);
  if (result)
  {
    uint64_t result = (uint64_t)PSPaint::getRotoshape((PSPaint *)result);
    if (result)
    {
      uint64_t v9 = result;
      uint64_t result = OZChannelBase::isEnabled((OZChannelBase *)(result + 25776), 0, 1);
      if (result)
      {
        uint64_t result = OZChannelBase::isEnabled((OZChannelBase *)(v9 + 21760), 0, 1);
        if ((result & 1) == 0)
        {
          int v10 = (OZChannel *)(v9 + 25904);
          if (OZChannel::getValueAsInt(v10, MEMORY[0x1E4F1FA48], 0.0) == 1
            || (uint64_t result = OZChannel::getValueAsInt(v10, MEMORY[0x1E4F1FA48], 0.0), result == 2))
          {
            return (uint64_t)PSParticleType::calcHashForState((uint64_t)a1, a2, a3, a4, 1);
          }
        }
      }
    }
  }
  return result;
}

void *PSPaintPType::getPaint(PSPaintPType *this)
{
  uint64_t result = (void *)*((void *)this + 2054);
  if (result) {
  return result;
  }
}

uint64_t non-virtual thunk to'PSPaintPType::calcHashForState(uint64_t a1, void *a2, CMTime *a3, uint64_t **a4)
{
  return PSPaintPType::calcHashForState((PSPaintPType *)(a1 - 16), a2, a3, a4);
}

void PSPaintPType::cacheSourceNode(PSPaintPType *this)
{
  PSParticleType::cacheSourceNode(this);
  if (PSPaintPType::getIsImageBrush(this))
  {
    CMTimeEpoch v2 = *((void *)this + 2057);
    *(_OWORD *)&v17.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)((char *)this + 16440);
    *(_OWORD *)&v18.value = *((_OWORD *)this + 1029);
    CMTimeEpoch v3 = *((void *)this + 2060);
    v17.int64_t var3 = v2;
    v18.CMTimeEpoch epoch = v3;
    OZRenderState::OZRenderState(&v16);
    v16.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v17;
    uint64_t v15 = 0;
    (*(void (**)(void, char *, uint64_t *, OZRenderState *))(**((void **)this + 2061) + 96))(*((void *)this + 2061), (char *)&v15 + 4, &v15, &v16);
    float v4 = *(float *)&v15;
    CMTime time = v18;
    if (CMTimeGetSeconds(&time) > 3.0)
    {
      uint64_t v5 = (const void *)*((void *)this + 2061);
      if (!v5
      {
        long long v12 = 0uLL;
        int64_t v13 = 0;
        CMTime v11 = v18;
        PC_CMTimeHalve(&v11, (uint64_t)&v19);
        CMTime v21 = (CMTime)v17;
        CMTime v20 = v19;
        PC_CMTimeSaferAdd(&v21, &v20, (uint64_t)&v12);
        *(_OWORD *)&v16.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v12;
        v16.var0.int64_t var3 = v13;
        (*(void (**)(void, char *, uint64_t *, OZRenderState *))(**((void **)this + 2061) + 96))(*((void *)this + 2061), (char *)&v15 + 4, &v15, &v16);
        if (v4 < *(float *)&v15) {
          float v4 = *(float *)&v15;
        }
        uint64_t v6 = (*(uint64_t (**)(PSPaintPType *))(*(void *)this + 272))(this);
        OZSceneSettings::getFrameDuration((OZSceneSettings *)(v6 + 336), &v7);
        CMTime v21 = (CMTime)v17;
        CMTime v20 = v18;
        PC_CMTimeSaferAdd(&v21, &v20, (uint64_t)&v19);
        CMTime v21 = v19;
        *(__n128 *)&v20.value = v7;
        v20.CMTimeEpoch epoch = v8;
        PC_CMTimeSaferSubtract(&v21, &v20, (uint64_t)&v9);
        *(_OWORD *)&v16.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v9;
        v16.var0.int64_t var3 = v10;
        (*(void (**)(void, char *, uint64_t *, OZRenderState *))(**((void **)this + 2061) + 96))(*((void *)this + 2061), (char *)&v15 + 4, &v15, &v16);
        if (v4 < *(float *)&v15) {
          float v4 = *(float *)&v15;
        }
      }
    }
    *((float *)this + 4526) = v4;
  }
}

char *PSPaintPType::getIsImageBrush(PSPaintPType *this)
{
  uint64_t result = (char *)PSPaintPType::getPaint(this);
  if (result)
  {
    uint64_t result = (char *)PSPaint::getRotoshape((PSPaint *)result);
    if (result)
    {
      if (*((void *)this + 2061)) {
        return (char *)(OZChannel::getValueAsInt((OZChannel *)(result + 25904), MEMORY[0x1E4F1FA48], 0.0) == 2);
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t PSPaintPType::willGetParticleBounds(PSPaintPType *this)
{
  uint64_t result = (*(uint64_t (**)(PSPaintPType *))(*(void *)this + 1336))(this);
  if (result != *((void *)this + 2061) || *((float *)this + 4526) < 0.0)
  {
    CMTimeEpoch v3 = *(uint64_t (**)(PSPaintPType *))(*(void *)this + 1640);
    return v3(this);
  }
  return result;
}

double PSPaintPType::getParticleBounds(PSPaintPType *this, float64x2_t *a2, OZRenderState *a3, float64x2_t *a4)
{
  CMTimeEpoch v8 = (char *)this + 18124;
  if (*((unsigned char *)this + 18125))
  {
    if (*v8) {
      goto LABEL_3;
    }
  }
  else
  {
    unsigned int IsImageBrush = PSPaintPType::getIsImageBrush(this);
    *CMTimeEpoch v8 = IsImageBrush;
    v8[1] = 1;
    if (IsImageBrush)
    {
LABEL_3:
      if (*((void *)this + 2061))
      {
        *(void *)&double result = *(_OWORD *)&PSParticleType::getImageParticleBounds((uint64_t)this, (uint64_t)a2, a3, a4);
      }
      else
      {
        *(void *)&double result = *(_OWORD *)&PSParticleType::getPointParticleBounds((uint64_t)this, a2, (CMTime *)a3, a4);
      }
      return result;
    }
  }

  *(void *)&double result = *(_OWORD *)&PSPaintPType::getGradientParticleBounds((void **)this, (uint64_t)a2, (long long *)&a3->var0.var0, a4);
  return result;
}

float64x2_t PSPaintPType::getGradientParticleBounds(void **a1, uint64_t a2, long long *a3, float64x2_t *a4)
{
  (*(void (**)(void *))(*a1[2054] + 616))(a1[2054]);
  double v54 = 1.0;
  uint64_t v51 = 0x3FF0000000000000;
  float64_t v48 = 1.0;
  v46[0] = 0x3FF0000000000000;
  long long v8 = 0uLL;
  *(_OWORD *)&v46[1] = 0u;
  long long v47 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v9 = *(const void **)(a2 + 232);
  if (v9)
  {
    long long v8 = 0uLL;
    uint64_t v11 = (uint64_t)v10;
  }
  else
  {
    uint64_t v11 = 0;
  }
  uint64_t v45 = 0x3FF0000000000000;
  uint64_t v42 = 0x3FF0000000000000;
  uint64_t v39 = 0x3FF0000000000000;
  uint64_t v36 = 0x3FF0000000000000;
  long long v37 = v8;
  long long v38 = v8;
  long long v40 = v8;
  long long v41 = v8;
  long long v43 = v8;
  long long v44 = v8;
  PSPaintPType::getRadialParticleMatrix(a1, a3, v11, (double *)a2, (double *)&v36, (uint64_t)v46, 0);
  *(void *)&v13.f64[0] = v46[1];
  *(void *)&v12.f64[0] = v46[0];
  *(void *)&v14.f64[0] = v47;
  *(void *)&v15.f64[0] = v46[0];
  v15.f64[1] = *((float64_t *)&v47 + 1);
  __asm { FMOV            V4.2D, #-0.5 }
  float64x2_t v21 = vmulq_f64(v15, _Q4);
  *(void *)&_Q4.f64[0] = v46[1];
  _Q4.f64[1] = v48;
  __asm { FMOV            V5.2D, #0.5 }
  float64x2_t v23 = vmulq_f64(_Q4, _Q5);
  v14.f64[1] = *((float64_t *)&v49 + 1);
  int8x16_t v24 = (int8x16_t)vdivq_f64(vaddq_f64(v14, vsubq_f64(v21, v23)), (float64x2_t)vdupq_lane_s64(COERCE__INT64(v54 + *((double *)&v52 + 1) * -0.5 - *(double *)&v53 * 0.5), 0));
  v13.f64[1] = *((float64_t *)&v47 + 1);
  v12.f64[1] = v48;
  float64x2_t v25 = vmulq_f64(v13, (float64x2_t)xmmword_1B83832C0);
  float64x2_t v26 = vmulq_f64(v12, (float64x2_t)xmmword_1B8387E30);
  int8x16_t v27 = (int8x16_t)vdivq_f64(vaddq_f64(v14, vaddq_f64(v25, v26)), (float64x2_t)vdupq_lane_s64(COERCE__INT64(v54 + *((double *)&v52 + 1) * 0.5 + *(double *)&v53 * -0.5), 0));
  v26.f64[1] = v25.f64[1];
  int8x16_t v28 = (int8x16_t)vdivq_f64(vaddq_f64(v14, vaddq_f64(v26, v23)), (float64x2_t)vdupq_lane_s64(COERCE__INT64(v54 + *((double *)&v52 + 1) * 0.5 + *(double *)&v53 * 0.5), 0));
  int8x16_t v29 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v27, (float64x2_t)v24), v27, v24);
  int8x16_t v30 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v28, (float64x2_t)v29), v28, v29);
  int8x16_t v31 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v24, (float64x2_t)v27), v27, v24);
  int8x16_t v32 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v31, (float64x2_t)v28), v28, v31);
  int8x16_t v33 = (int8x16_t)vcgtq_f64((float64x2_t)v32, (float64x2_t)v30);
  float64x2_t v34 = (float64x2_t)vbslq_s8(v33, v32, v30);
  float64x2_t result = (float64x2_t)vbslq_s8(v33, v30, v32);
  *a4 = result;
  a4[1] = vsubq_f64(v34, result);
  return result;
}

void PSPaintPType::addProjectedParticleBounds(PSPaintPType *this, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  long long v8 = (char *)this + 18124;
  if (*((unsigned char *)this + 18125))
  {
    if (*v8) {
      goto LABEL_3;
    }
  }
  else
  {
    unsigned int IsImageBrush = PSPaintPType::getIsImageBrush(this);
    *long long v8 = IsImageBrush;
    v8[1] = 1;
    if (IsImageBrush)
    {
LABEL_3:
      if (*((void *)this + 2061))
      {
        PSParticleType::addProjectedImageParticleBounds((uint64_t)this, a2, a3, (uint64_t)a4);
      }
      else
      {
        PSParticleType::addProjectedPointParticleBounds((uint64_t)this, a2, a3, a4);
      }
      return;
    }
  }

  PSPaintPType::addProjectedGradientParticleBounds((void **)this, a2, a3, a4);
}

void PSPaintPType::addProjectedGradientParticleBounds(void **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  long long v8 = *(long long **)(a2 + 8);
  (*(void (**)(void *))(*a1[2054] + 616))(a1[2054]);
  __asm { FMOV            V0.2D, #-0.5 }
  v43[0] = _Q0;
  v43[1] = xmmword_1B8387E40;
  __asm { FMOV            V1.2D, #0.5 }
  v43[2] = xmmword_1B8387E50;
  v43[3] = _Q1;
  v43[4] = xmmword_1B8387E60;
  v43[5] = xmmword_1B7E73B80;
  float64x2_t v15 = *(const void **)(a3 + 232);
  if (v15) {
  else
  }
    OZRenderState v16 = 0;
  uint64_t v42 = 0x3FF0000000000000;
  uint64_t v39 = 0x3FF0000000000000;
  uint64_t v36 = 0x3FF0000000000000;
  double v33 = 1.0;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  if (*(unsigned char *)(a2 + 1498) && (double *)(a2 + 1504) != &v33)
  {
    uint64_t v17 = 0;
    uint64_t v18 = a2 + 1504;
    do
    {
      CMTime v19 = (_OWORD *)((char *)&v33 + v17);
      long long v20 = *(_OWORD *)(v18 + v17 + 16);
      _OWORD *v19 = *(_OWORD *)(v18 + v17);
      v19[1] = v20;
      v17 += 32;
    }
    while (v17 != 128);
  }
  uint64_t v32 = 0x3FF0000000000000;
  uint64_t v29 = 0x3FF0000000000000;
  uint64_t v26 = 0x3FF0000000000000;
  uint64_t v23 = 0x3FF0000000000000;
  long long v24 = 0uLL;
  long long v25 = 0uLL;
  long long v27 = 0uLL;
  long long v28 = 0uLL;
  long long v30 = 0uLL;
  long long v31 = 0uLL;
  PSPaintPType::getRadialParticleMatrix(a1, v8, (uint64_t)v16, (double *)a3, &v33, (uint64_t)&v23, *(unsigned __int8 *)(a2 + 1497));
  PCMatrix44Tmpl<double>::leftMult((uint64_t)&v23, (double *)(a2 + 1632));
  for (uint64_t i = 0; i != 96; i += 24)
  {
    PCMatrix44Tmpl<double>::transform<double>((double *)&v23, (double *)((char *)v43 + i), (double *)((char *)v43 + i));
    float64x2_t v22 = *(float64x2_t *)((char *)v43 + i);
    PCRect<double>::operator|=(a4, &v22);
  }
}

unint64_t PSPaintPType::estimateRenderMemory(PSPaintPType *a1)
{
  if (!PSPaintPType::getIsImageBrush(a1)) {
    return 0;
  }

  return PSParticleType::estimateRenderMemoryImageParticle((uint64_t)a1);
}

unint64_t PSPaintPType::estimateRenderMemoryBallpark(PSPaintPType *this, const OZRenderParams *a2, BOOL *a3)
{
  if (!PSPaintPType::getIsImageBrush(this)) {
    return 0;
  }

  return PSParticleType::estimateRenderMemoryImageBallpark(this, a2, a3);
}

void PSPaintPType::addSprite(PSPaintPType *this, PSEmitter::RenderParams *a2, PSParticle *a3, float64x2_t *a4, PSHeliumNode *a5)
{
  int64_t v10 = (char *)this + 18124;
  if (*((unsigned char *)this + 18125))
  {
    if (*v10)
    {
LABEL_3:
      PSParticleType::addSprite(this, a2, a3, a4, a5);
      return;
    }
  }
  else
  {
    unsigned int IsImageBrush = PSPaintPType::getIsImageBrush(this);
    char *v10 = IsImageBrush;
    v10[1] = 1;
    if (IsImageBrush) {
      goto LABEL_3;
    }
  }

  PSPaintPType::addRadialSprite(this, a2, a3, (OZSimStateElement *)a4, a5);
}

void PSPaintPType::addRadialSprite(PSPaintPType *this, PSEmitter::RenderParams *a2, PSParticle *a3, OZSimStateElement *a4, PSHeliumNode *a5)
{
  uint64_t v38 = 0x3FF0000000000000;
  uint64_t v35 = 0x3FF0000000000000;
  uint64_t v32 = 0x3FF0000000000000;
  uint64_t v29 = 0x3FF0000000000000;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  PSPaintPType::getRadialParticleMatrix((void **)this, *((long long **)a2 + 1), (uint64_t)a3, (double *)a4, (double *)a2 + 188, (uint64_t)&v29, *((unsigned __int8 *)a2 + 1497));
  double v9 = PCMatrix44Tmpl<double>::determinant((double *)&v29);
  if (v9 <= -0.0000001 || v9 >= 0.0000001)
  {
    int64_t v10 = (OZRenderParams *)*((void *)a2 + 1);
    uint64_t v11 = *((void *)v10 + 2);
    long long v27 = *(_OWORD *)v10;
    uint64_t v28 = v11;
    WorkingColorDescription = (OZEaseInInterpolator *)OZRenderParams::getWorkingColorDescription(v10);
    OZEaseInInterpolator::~OZEaseInInterpolator(WorkingColorDescription);
    float64x2_t v14 = v13;
    int DynamicRange = FxColorDescription::getDynamicRange((FxColorDescription *)WorkingColorDescription);
    ToneMapMethod = (PCToneMapMethod *)FxColorDescription::getToneMapMethod((FxColorDescription *)WorkingColorDescription);
    PCWorkingColor::PCWorkingColor((uint64_t)&v25, v14, DynamicRange, ToneMapMethod, 0.0, 0.0, 0.0, 0.0);
    (*(void (**)(PSPaintPType *, long long *, PSParticle *, void, __n128 *))(*(void *)this + 1600))(this, &v27, a3, *(void *)a2, &v25);
    __asm
    {
      FMOV            V0.2D, #-0.5
      FMOV            V1.2D, #1.0
    }
    v24[0] = _Q0;
    v24[1] = _Q1;
    PCWorkingColor::operator=(&v23, &v25);
    PSHeliumNode::addRadialParticle((uint64_t)a5, &v29, (double *)v24, &v23, *((unsigned char *)this + 16528));
    PCCFRef<CGColorSpace *>::~PCCFRef(&v26);
  }
}

void sub_1B7E008A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PSPaintPType::getSourceRender(PSPaintPType *this@<X0>, const OZRenderParams *a2@<X1>, const CMTime *a3@<X2>, int a4@<W3>, PCSharedCount *a5@<X8>)
{
  if (PSPaintPType::getPaint(this)
    && (Paint = (PSPaint *)PSPaintPType::getPaint(this), PSPaint::getRotoshape(Paint))
    && (uint64_t v11 = (PSPaint *)PSPaintPType::getPaint(this),
        Rotoshape = (char *)PSPaint::getRotoshape(v11),
        int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(Rotoshape + 25904), MEMORY[0x1E4F1FA48], 0.0),
        ValueAsInt != 2))
  {
    if (ValueAsInt == 1) {
      operator new();
    }
    if (!ValueAsInt) {
      operator new();
    }
    a5->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0;
    PCSharedCount::PCSharedCount(a5 + 1, 0);
  }
  else
  {
    PSParticleType::getSourceRender(this, a2, a3, a4, a5);
  }
}

void sub_1B7E00A3C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40BAA2190CLL);
  _Unwind_Resume(a1);
}

void PSPaintPType::updateGradientStringName(PSPaintPType *this, char a2)
{
  if ((a2 & 1) == 0)
  {
    if ((*(uint64_t (**)(PSPaintPType *))(*(void *)this + 272))(this))
    {
      uint64_t v4 = *(void *)((*(uint64_t (**)(PSPaintPType *))(*(void *)this + 272))(this) + 1584);
      if (v4)
      {
        uint64_t v5 = *(OZNotificationManager **)(v4 + 168);
        if (!v5 || !OZNotificationManager::wasChannelModified(v5, (const OZChannelBase *)((char *)this + 6784)))
        {
          PCSharedCount::PCSharedCount(&v7);
          OZChannelBase::addToUndo((OZChannelBase *)((char *)this + 6784), (const PCString *)&v7);
          PCString::~PCString((PCString *)&v7);
        }
      }
    }
  }
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 5368), MEMORY[0x1E4F1FA48], 0.0);
  switch(ValueAsInt)
  {
    case 3:
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 6912), 2, a2);
      PCURL::PCURL((PCURL *)&v7, @"PPaint PType Color Range");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 6784), (const PCString *)&v7, 0);
      break;
    case 2:
      PCURL::PCURL((PCURL *)&v7, @"PPaint PType Color Over Stroke");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 6784), (const PCString *)&v7, 0);
      break;
    case 1:
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 6912), 2, a2);
      PCURL::PCURL((PCURL *)&v7, @"PPaint PType Opacity Over Stroke");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 6784), (const PCString *)&v7, 0);
      break;
    default:
      return;
  }
  PCString::~PCString((PCString *)&v7);
}

void sub_1B7E00C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PSPaintPType::updateRotationStringNames(PSPaintPType *this)
{
  uint64_t v2 = *((void *)this + 2054);
  if (v2 && !OZChannel::getValueAsInt((OZChannel *)(v2 + 32792), MEMORY[0x1E4F1FA48], 0.0))
  {
    PCURL::PCURL((PCURL *)&v3, @"PPaint PType Rotation");
    OZChannelBase::setName((OZChannelBase *)((char *)this + 2776), &v3, 0);
    PCString::~PCString(&v3);
    PCURL::PCURL((PCURL *)&v3, @"PPaint PType Rotation Variance");
    OZChannelBase::setName((OZChannelBase *)((char *)this + 4648), &v3, 0);
  }
  else
  {
    PCString::PCString(&v3, "Channel Z", "com.apple.prochannel.framework");
    OZChannelBase::setName((OZChannelBase *)((char *)this + 2776), &v3, 0);
    PCString::~PCString(&v3);
    PCString::PCString(&v3, "Channel Z", "com.apple.prochannel.framework");
    OZChannelBase::setName((OZChannelBase *)((char *)this + 4648), &v3, 0);
  }
  PCString::~PCString(&v3);
}

void sub_1B7E00DC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

double PSPaintPType::getInitialParticleColor(PSPaintPType *this, const CMTime *a2, Float64 *a3, int a4, PCColor *a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 5368), a2, 0.0) == 1)
  {
    uint64_t v10 = (*(uint64_t (**)(void))(**((void **)this + 2054) + 616))(*((void *)this + 2054));
    PCColor::PCColor(&v22);
    (*(void (**)(uint64_t, const CMTime *, PCColor *))(*(void *)(v10 + 26160) + 832))(v10 + 26160, a2, &v22);
    long long v11 = *(_OWORD *)&v22.var0.var1[1];
    *(_OWORD *)&a5->var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)&v22.var0.var0;
    *(_OWORD *)&a5->var0.var1[1] = v11;
    *(_OWORD *)&a5->var0.var1[3] = *(_OWORD *)&v22.var0.var1[3];
    PCCFRef<CGColorSpace *>::operator=(&a5->var1._obj, &v22.var1._obj);
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 27168), a2, 0.0);
    *(float *)&double v12 = v12;
    PCColor::setAlpha(a5, *(float *)&v12);
    OZChannelDoubleOverRange::getValueOverRangeAsDouble((OZChannel *)this + 117, a2, a3[21]);
    double v14 = v13;
    v21[0] = 0;
    v21[1] = 0;
    long long v20 = v21;
    (*(void (**)(char *, const CMTime *, void ***))(*((void *)this + 880) + 728))((char *)this + 7040, a2, &v20);
    (*(void (**)(char *, float *, void ***, Float64))(*((void *)this + 880) + 736))((char *)this + 7040, v23, &v20, a3[21]);
    float v15 = v23[0];
    float v16 = v14 * v15 * PCColor::getAlpha(a5);
    PCColor::setAlpha(a5, v16);
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v20, v21[0]);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v22.var1._obj);
  }
  else
  {
    PSReplicatorPType::getInitialParticleColor(this, a2, (PSParticle *)a3, a4, a5);
    OZChannelDoubleOverRange::getValueOverRangeAsDouble((OZChannel *)this + 117, a2, a3[21]);
    float v19 = v18 * PCColor::getAlpha(a5);
    return PCColor::setAlpha(a5, v19);
  }
  return result;
}

void sub_1B7E010A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

double PSPaintPType::getInitialParticleScale(PSPaintPType *this, const CMTime *a2, uint64_t a3, uint64_t a4, double *a5, double *a6)
{
  long long v11 = (float *)((char *)this + 18104);
  if (*((unsigned char *)this + 18125))
  {
    if (!*((unsigned char *)this + 18124))
    {
      double v12 = 1.0;
      goto LABEL_6;
    }
  }
  else
  {
    unsigned int IsImageBrush = PSPaintPType::getIsImageBrush(this);
    *((unsigned char *)v11 + 20) = IsImageBrush;
    *((unsigned char *)v11 + 21) = 1;
    double v12 = 1.0;
    if (!IsImageBrush) {
      goto LABEL_6;
    }
  }
  double v12 = *v11;
LABEL_6:
  uint64_t v14 = (*(uint64_t (**)(void))(**((void **)this + 2054) + 616))(*((void *)this + 2054));
  OZChannel::getValueAsDouble((OZChannel *)(v14 + 27320), a2, 0.0);
  if (v15 >= 3.0) {
    double v16 = v15;
  }
  else {
    double v16 = 3.0;
  }
  OZChannelDoubleOverRange::getValueOverRangeAsDouble((OZChannel *)((char *)this + 12496), a2, *(Float64 *)(a3 + 168));
  double v18 = v17 * (v16 / v12);
  *a5 = v18;
  a5[1] = v18;
  double result = v17 * v16;
  *a6 = result;
  a6[1] = result;
  return result;
}

void PSPaintPType::getInitialParticleRotation(PSPaintPType *this, const CMTime *a2, Float64 *a3)
{
}

uint64_t PSPaintPType::areParticlesImmortal(PSPaintPType *this)
{
  return OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 11904), 0, 1) ^ 1;
}

void PSPaintPType::applyAllScaleOverLifeBehaviors(uint64_t a1, CMTime *a2, CMTime *a3, CMTime *a4, uint64_t a5)
{
  uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 16432) + 616))(*(void *)(a1 + 16432));
  if (v10)
  {
    uint64_t v11 = v10;
    memset(&v13, 0, sizeof(v13));
    uint64_t v12 = (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 16432) + 200) + 272))();
    OZSceneSettings::getFrameDuration((OZSceneSettings *)(v12 + 336), (__n128 *)&v13);
    PSParticleType::applyScaleOverLifeBehaviors(a1, (uint64_t *)(v11 + 1200), a2, a3, a4, &v13, a5);
  }
}

void PSPaintPType::applyAllSequenceBehaviors(PSPaintPType *this, CMTime *a2, const PSParticle *a3, PSSequencedValues *a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(**((void **)this + 2054) + 616))(*((void *)this + 2054));
  if (v8)
  {
    double v9 = *((double *)a3 + 21);
    PSParticleType::applySequenceBehaviors(v9, (uint64_t)this, (uint64_t *)(v8 + 1200), a2, (uint64_t)this, a4);
  }
}

void PSPaintPType::getAllSequenceBehaviors(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 16432) + 616))(*(void *)(a1 + 16432));
  if (v6)
  {
    PSParticleType::getSequenceBehaviors(a1, (uint64_t *)(v6 + 1200), a2, a3);
  }
}

void *PSPaintPType::disableSourceNode(PSPaintPType *this)
{
  double result = OZChanSceneNodeRef::getNode((OZChannelBase *)((char *)this + 14392));
  if (result)
  {
    uint64_t v2 = *(uint64_t (**)(void))(result[2] + 40);
    return (void *)v2();
  }
  return result;
}

unint64_t PSPaintPType::simAnythingToSimulate(PSPaintPType *this)
{
  return OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 11904), 0, 1);
}

unint64_t non-virtual thunk to'PSPaintPType::simAnythingToSimulate(PSPaintPType *this)
{
  return OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 10792), 0, 1);
}

BOOL PSPaintPType::simShouldCache(PSPaintPType *this)
{
  uint64_t v1 = (*(uint64_t (**)(void))(**((void **)this + 2054) + 616))(*((void *)this + 2054));
  if (v1 && (uint64_t v2 = v1, !OZChannel::getValueAsInt((OZChannel *)(v1 + 33256), MEMORY[0x1E4F1FA48], 0.0))) {
    return OZMoShape::getFreehandPaintVertices((OZMoShape *)(v2 + 18976)) == 0;
  }
  else {
    return 1;
  }
}

BOOL non-virtual thunk to'PSPaintPType::simShouldCache(PSPaintPType *this)
{
  return PSPaintPType::simShouldCache((PSPaintPType *)((char *)this - 1112));
}

uint64_t PSPaintPType::simAddObjects(PSPaintPType *this, OZSystemSimulator *a2, OZSimStateArray *a3, double a4)
{
  uint64_t v7 = (*(uint64_t (**)(void, double))(**((void **)this + 2054) + 616))(*((void *)this + 2054), a4);
  if (!OZChannel::getValueAsInt((OZChannel *)(v7 + 33256), MEMORY[0x1E4F1FA48], 0.0)
    && OZMoShape::getFreehandPaintVertices((OZMoShape *)(v7 + 18976)))
  {
    PSPaintPType::interactiveSimAddObjects(this, a2, a3, v13);
    return 0;
  }
  uint64_t v8 = (unsigned int *)((char *)this + 18072);
  CMTime v42 = *(CMTime *)((unsigned char *)a3 + 1);
  if ((PSPaintPType *)((char *)this + 15520) == a2)
  {
    int v9 = 0;
    unsigned int v12 = 0;
    uint64_t v10 = (PSParticle *)*((void *)this + 2258);
    long long v41 = v10;
    uint64_t v11 = *v8;
    unsigned int v40 = *v8;
  }
  else if ((PSPaintPType *)((char *)this + 15800) == a2)
  {
    uint64_t v10 = (PSParticle *)*((void *)this + 2260);
    long long v41 = v10;
    uint64_t v11 = *((unsigned int *)this + 4522);
    unsigned int v40 = *((_DWORD *)this + 4522);
    int v9 = 1;
    unsigned int v12 = 1;
  }
  else
  {
    int v9 = 0;
    uint64_t v10 = (PSParticle *)*((void *)this + 2258);
    long long v41 = v10;
    uint64_t v11 = *v8;
    unsigned int v40 = *v8;
    unsigned int v12 = 2;
  }
  int v14 = (*(uint64_t (**)(PSPaintPType *))(*(void *)this + 1656))(this);
  char v16 = v14;
  if (!v10)
  {
    CMTime __y = v42;
    if (v14)
    {
      (*(void (**)(CMTime *__return_ptr, PSPaintPType *, CMTime *))(*(void *)this + 1440))(&v43, this, &v42);
      CMTime __y = v43;
      PSPaintPType::initAllEmissionPoints(this, &__y, v24, &v41, &v40);
    }
    else
    {
      PSPaintPType::initAllEmissionPoints(this, &__y, v15, &v41, &v40);
      if (!PSPaintPType::getIsSpacingConstantOverTime(this)
        || (Paint = PSPaintPType::getPaint(this),
            uint64_t v26 = (*(uint64_t (**)(void *))(*(void *)Paint + 616))(Paint),
            (OZShape::isShapeContourAnimated((OZShape *)(v26 + 18976)) & 1) != 0))
      {
        operator new();
      }
    }
    uint64_t v10 = v41;
    if (v9)
    {
      *((void *)this + 2260) = v41;
      uint64_t v11 = v40;
      *((_DWORD *)this + 4522) = v40;
    }
    else
    {
      *((void *)this + 2258) = v41;
      uint64_t v11 = v40;
      *uint64_t v8 = v40;
    }
  }
  if (v11)
  {
    OZChannel::getValueAsDouble((OZChannel *)(v7 + 28952), &v42, 0.0);
    double v18 = v17;
    OZChannel::getValueAsDouble((OZChannel *)(v7 + 29104), &v42, 0.0);
    double v20 = v19;
    OZChannel::getValueAsDouble((OZChannel *)(v7 + 29568), &v42, 0.0);
    if (v18 >= v20) {
      return 0;
    }
    double v22 = v21;
    if (vabdd_f64(v18, v20) < 0.0000001) {
      return 0;
    }
    __y.value = 0;
    modf(v21, (long double *)&__y.value);
    double v27 = v22 - *(double *)&__y.value;
    if (v22 - *(double *)&__y.value < 0.0) {
      double v27 = v27 + 1.0;
    }
    double v28 = v18 + v27;
    double v29 = v20 + v27;
    if (OZChannel::getValueAsInt((OZChannel *)(v7 + 20304), MEMORY[0x1E4F1FA48], 0.0))
    {
      if (v28 > 1.0) {
        double v28 = v28 + -1.0;
      }
      BOOL v30 = v29 <= 1.0;
      double v31 = v29 + -1.0;
    }
    else
    {
      if (v28 > 1.0) {
        return 0;
      }
      double v31 = 1.0;
      BOOL v30 = v29 <= 1.0;
    }
    if (!v30) {
      double v29 = v31;
    }
    if (v16)
    {
      if (*((unsigned char *)this + 18092))
      {
        uint64_t v32 = v12;
      }
      else
      {
        __n128 v38 = 0uLL;
        CMTimeEpoch v39 = 0;
        uint64_t v33 = (*(uint64_t (**)(void))(*(void *)(*((void *)this + 2054) + 200) + 272))();
        OZSceneSettings::getFrameDuration((OZSceneSettings *)(v33 + 336), &v38);
        memset(&v37, 0, sizeof(v37));
        CMTime __y = v42;
        *(__n128 *)&v43.value = v38;
        v43.CMTimeEpoch epoch = v39;
        PC_CMTimeSaferSubtract(&__y, &v43, (uint64_t)&v37);
        OZChannel::getValueAsDouble((OZChannel *)(v7 + 28952), &v37, 0.0);
        double v35 = v34;
        OZChannel::getValueAsDouble((OZChannel *)(v7 + 29104), &v37, 0.0);
        if (v28 <= -0.0000001
          || v28 >= 0.0000001
          || fabs(v29 + -1.0) >= 0.0000001
          || v35 <= -0.0000001
          || v35 >= 0.0000001
          || fabs(v36 + -1.0) >= 0.0000001)
        {
          PSPaintPType::birthParticlesInStroke(this, v28, v29, v35, v36, a3, v10, v11);
        }
        else
        {
          PSPaintPType::birthAllParticles(this, a3, v10, v11);
        }
        uint64_t v32 = v12;
        uint64_t v10 = v41;
      }
      uint64_t v11 = PSPaintPType::addBornParticlesToSim(this, a3, v10, v11);
    }
    else
    {
      if (v28 <= -0.0000001 || v28 >= 0.0000001 || fabs(v29 + -1.0) >= 0.0000001) {
        uint64_t v11 = PSPaintPType::birthAndAddParticlesInStroke(this, v28, v29, a3, v10, v11);
      }
      else {
        PSPaintPType::birthAndAddAllParticles(this, a3, v10, v11);
      }
      uint64_t v32 = v12;
    }
    PSEmitter::initParticles(*((PSEmitter **)this + 2054), v32, this, v11, 0, a3);
  }
  return v11;
}

uint64_t PSPaintPType::interactiveSimAddObjects(PSPaintPType *this, OZSystemSimulator *a2, OZSimStateArray *a3, double a4)
{
  uint64_t v7 = (*(uint64_t (**)(void, double))(**((void **)this + 2054) + 616))(*((void *)this + 2054), a4);
  if ((PSPaintPType *)((char *)this + 15800) == a2) {
    int v8 = 1;
  }
  else {
    int v8 = 2;
  }
  if ((PSPaintPType *)((char *)this + 15520) == a2) {
    unsigned int v9 = 0;
  }
  else {
    unsigned int v9 = v8;
  }
  CMTime v84 = *(CMTime *)((unsigned char *)a3 + 1);
  memset(&v83, 0, sizeof(v83));
  uint64_t v10 = (*(uint64_t (**)(void))(*(void *)(*((void *)this + 2054) + 200) + 272))();
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v10 + 336), (__n128 *)&v83);
  FreehandPaintVertices = (void *)OZMoShape::getFreehandPaintVertices((OZMoShape *)(v7 + 18976));
  if (FreehandPaintVertices[1] != *FreehandPaintVertices)
  {
    unsigned int v12 = FreehandPaintVertices;
    uint64_t v13 = *((void *)this + 2258);
    if (!v13) {
      operator new[]();
    }
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 12184), &v84, 0.0);
    double v15 = v14;
    OZChannel::getValueAsDouble((OZChannel *)(v7 + 27320), &v84, 0.0);
    if (v16 < 3.0) {
      double v16 = 3.0;
    }
    double v17 = v15 * v16;
    if (v17 <= -0.0000001 || v17 >= 0.0000001)
    {
      unsigned int v67 = v9;
      CMTime v68 = (uint64_t *)a3;
      unsigned int v18 = 0;
      uint64_t v19 = v12[1] - *v12;
      uint64_t v20 = *((int *)this + 4530);
      double v21 = *((double *)this + 2264);
      uint64_t v64 = v13;
      unint64_t v65 = (unint64_t)v19 >> 4;
      CMTime v66 = (unsigned int *)((char *)this + 18072);
      if ((int)v20 < (int)((unint64_t)v19 >> 4))
      {
        int v22 = *((_DWORD *)this + 4518);
        if (v22 < 0x4000)
        {
          unsigned int v18 = 0;
          if ((int)v20 <= 1) {
            int v23 = 1;
          }
          else {
            int v23 = *((_DWORD *)this + 4530);
          }
          float64x2_t v24 = *(float64x2_t *)(*v12 + 16 * (v23 - 1));
          __n128 v25 = (OZChannel *)((char *)this + 12336);
          uint64_t v26 = (OZChannel *)((char *)this + 12496);
          uint64_t v27 = (int)(v19 >> 4);
          double v72 = 1.0 / v17;
          uint64_t v69 = v27;
          uint64_t v70 = v12;
          do
          {
            float64x2_t v28 = *(float64x2_t *)(*v12 + 16 * v20);
            float64x2_t v29 = vsubq_f64(v28, v24);
            double v30 = sqrt(vaddvq_f64(vmulq_f64(v29, v29)));
            double v77 = ceil(v30);
            if (v77 <= 0.0)
            {
              ++v20;
            }
            else
            {
              float64x2_t v71 = *(float64x2_t *)(*v12 + 16 * v20);
              float64x2_t v78 = v29;
              float64x2_t v79 = v24;
              int v31 = 0;
              double v76 = (double)(int)v20++;
              BOOL v32 = v30 >= 0.000000100000001 || v30 <= -0.000000100000001;
              double v33 = 1.0;
              if (v32) {
                double v33 = v30;
              }
              double v34 = v29.f64[0] / v33;
              double v35 = 0.0;
              double v36 = -v29.f64[1] / v33;
              do
              {
                double v37 = v35 / v30 + v76;
                OZChannelDoubleOverRange::getValueOverRangeAsDouble(v25, &v84, v37);
                double v39 = v38;
                OZChannelDoubleOverRange::getValueOverRangeAsDouble(v26, &v84, v37);
                if ((v40 <= -0.0000001 || v40 >= 0.0000001) && (v39 <= -0.0000001 || v39 >= 0.0000001))
                {
                  double v41 = v21 + v72 * (1.0 / (v39 * v40));
                  __y.value = 0;
                  modf(v41, (long double *)&__y.value);
                  double v42 = *(double *)&__y.value;
                  __y.value = 0;
                  modf(v21, (long double *)&__y.value);
                  int v43 = (int)(v42 - *(double *)&__y.value);
                  __y.value = 0;
                  modf(v21, (long double *)&__y.value);
                  if (v43 >= 1)
                  {
                    unsigned int v75 = v18;
                    uint64_t v44 = 0;
                    double v73 = v41;
                    double v45 = v41 - v21;
                    double v46 = *(double *)&__y.value - v21;
                    uint64_t v47 = v22;
                    int v48 = v22;
                    int v74 = v22;
                    uint64_t v49 = v13 + 168 + 232 * v22;
                    double v50 = 1.0;
                    do
                    {
                      *(_DWORD *)(v49 + 56) = v20;
                      *(double *)uint64_t v49 = v37;
                      *(double *)(v49 + 8) = (double)(v48 + (int)v44);
                      *(float64x2_t *)(v49 + 24) = vaddq_f64(v79, vmulq_n_f64(v78, (v35 + (v46 + v50) / v45) / v30));
                      int v51 = v44 + 1;
                      *(double *)(v49 + 40) = v36;
                      *(double *)(v49 + 48) = v34;
                      operator*(&v83, &v80, 0.01);
                      CMTime __y = v84;
                      CMTime v85 = v80;
                      PC_CMTimeSaferSubtract(&__y, &v85, (uint64_t)&v81);
                      long long v52 = v81;
                      *(void *)(v49 - 144) = v82;
                      *(_OWORD *)(v49 - 160) = v52;
                      *(unsigned char *)(v49 + 16) = 1;
                      if ((int)v44 + 1 >= v43) {
                        break;
                      }
                      uint64_t v53 = v47 + v44;
                      double v50 = v50 + 1.0;
                      v49 += 232;
                      ++v44;
                    }
                    while (v53 < 0x3FFF);
                    int v22 = v74 + v51;
                    unsigned int v18 = v75 + v51;
                    double v41 = v73;
                    uint64_t v26 = (OZChannel *)((char *)this + 12496);
                    __n128 v25 = (OZChannel *)((char *)this + 12336);
                  }
                }
                else
                {
                  double v41 = v21;
                }
                double v35 = (double)++v31;
                if (v77 <= (double)v31) {
                  break;
                }
                double v21 = v41;
              }
              while (v22 < 0x4000);
              double v21 = v41;
              uint64_t v27 = v69;
              unsigned int v12 = v70;
              float64x2_t v28 = v71;
            }
            if (v20 >= v27) {
              break;
            }
            float64x2_t v24 = v28;
          }
          while (v22 < 0x4000);
        }
      }
      int v54 = (*(uint64_t (**)(PSPaintPType *))(*(void *)this + 1656))(this);
      unsigned int v55 = *v66 + v18;
      if (v54) {
        unsigned int v56 = *v66;
      }
      else {
        unsigned int v56 = 0;
      }
      if (v54) {
        uint64_t v57 = v18;
      }
      else {
        uint64_t v57 = v55;
      }
      *CMTime v66 = v55;
      unint64_t v58 = (unint64_t)(v68[1] - *v68) >> 3;
      unsigned int v59 = -1108378657 * v58;
      std::vector<OZSimStateElement>::resize(v68, (v57 - 1108378657 * v58));
      unsigned int v60 = *v66 - v56;
      if (*v66 > v56)
      {
        uint64_t v61 = v64 + 232 * (int)v56;
        uint64_t v62 = *v68;
        do
        {
          *(void *)(v62 + 248 * v59++ + 232) = v61;
          v61 += 232;
          --v60;
        }
        while (v60);
      }
      PSEmitter::initParticles(*((PSEmitter **)this + 2054), v67, this, v57, 0, (OZSimStateArray *)v68);
      *((double *)this + 2264) = v21;
      *((_DWORD *)this + 4530) = v65;
    }
  }
  return 0;
}

void sub_1B7E02168(_Unwind_Exception *a1)
{
  for (; v1; v1 -= 232)
    PSParticle::~PSParticle((CGColorSpace **)(v2 - 216 + v1));
  MEMORY[0x1BA9BFB70](v2, 0x10A1C80AE952B93);
  _Unwind_Resume(a1);
}

void PSPaintPType::initAllEmissionPoints(PSPaintPType *this, const CMTime *a2, unsigned int a3, PSParticle **a4, unsigned int *a5)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (PSPaintPType::getNumEmissionPointsAndOrders((uint64_t)this, a2))
  {
    OZRenderState::OZRenderState(&v9);
    *(_OWORD *)&v9.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)&a2->value;
    v9.var0.int64_t var3 = a2->epoch;
    uint64_t v7 = (*(uint64_t (**)(void))(**((void **)this + 2054) + 616))(*((void *)this + 2054));
    int v8 = (os_unfair_lock_s *)v7;
    if (v7)
    {
      if (OZShape::isGeometricShape((OZShape *)(v7 + 18976))
        || OZDynamicCurve::getNumberOfValidKeypoints(v8 + 4868, a2))
      {
        operator new[]();
      }
    }
  }
  if (v10)
  {
    uint64_t v11 = v10;
    operator delete(v10);
  }
}

void sub_1B7E024AC(_Unwind_Exception *exception_object)
{
  PCString v3 = *(void **)(v1 - 120);
  if (v3)
  {
    *(void *)(v1 - 112) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t PSPaintPType::getIsSpacingConstantOverTime(PSPaintPType *this)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**((void **)this + 2054) + 616))(*((void *)this + 2054));
  if (OZChannel::hasMoreThanOneKeypoint((OZChannel *)((char *)this + 12184))) {
    return 0;
  }
  PCString v3 = (OZBehavior *)(v2 + 27320);
  if (((*(uint64_t (**)(OZBehavior *))(*(void *)v3 + 560))(v3) & 1) != 0
    || (OZBehavior::IsChannelAffectedByBehaviors((PSPaintPType *)((char *)this + 12184), (const OZChannelBase *)1) & 1) != 0
    || (OZBehavior::IsChannelAffectedByBehaviors(v3, (const OZChannelBase *)1) & 1) != 0)
  {
    return 0;
  }
  else
  {
    return PSPaintPType::getIsWidthSequenced(this, MEMORY[0x1E4F1FA48], 0) ^ 1;
  }
}

uint64_t PSPaintPType::birthAndAddAllParticles(PSPaintPType *this, OZSimStateArray *a2, PSParticle *a3, uint64_t a4)
{
  memset(&v16, 0, sizeof(v16));
  CMTime v18 = *(CMTime *)((unsigned char *)a2 + 1);
  v8.n128_f64[0] = PSParticleType::simGetFirstFrame(this, (uint64_t)&v16);
  memset(&v15, 0, sizeof(v15));
  uint64_t v9 = (*(uint64_t (**)(__n128))(*(void *)(*((void *)this + 2054) + 200) + 272))(v8);
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v9 + 336), (__n128 *)&v18);
  operator*(&v18, &v15, 0.01);
  unsigned int v10 = -1108378657 * ((*((void *)a2 + 1) - *(void *)a2) >> 3);
  std::vector<OZSimStateElement>::resize((uint64_t *)a2, v10 + a4);
  if (a4)
  {
    int v11 = a4;
    do
    {
      CMTime v18 = v16;
      CMTime v17 = v15;
      PC_CMTimeSaferSubtract(&v18, &v17, (uint64_t)&v13);
      *(_OWORD *)((char *)a3 + 8) = v13;
      *((void *)a3 + 3) = v14;
      *((unsigned char *)a3 + 184) = 1;
      *(void *)(*(void *)a2 + 248 * v10++ + 232) = a3;
      a3 = (PSParticle *)((char *)a3 + 232);
      --v11;
    }
    while (v11);
  }
  return a4;
}

uint64_t PSPaintPType::birthAndAddParticlesInStroke(PSPaintPType *this, double a2, double a3, OZSimStateArray *a4, PSParticle *a5, unsigned int a6)
{
  memset(&v43, 0, sizeof(v43));
  CMTime v45 = *(CMTime *)((unsigned char *)a4 + 1);
  v12.n128_f64[0] = PSParticleType::simGetFirstFrame(this, (uint64_t)&v43);
  memset(&v42, 0, sizeof(v42));
  uint64_t v13 = (*(uint64_t (**)(__n128))(*(void *)(*((void *)this + 2054) + 200) + 272))(v12);
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v13 + 336), (__n128 *)&v45);
  operator*(&v45, &v42, 0.01);
  if (a6)
  {
    unint64_t v14 = a6;
    CMTime v15 = a5;
    unint64_t v16 = a6;
    do
    {
      unint64_t v17 = v16 >> 1;
      CMTime v18 = (double *)((char *)v15 + 232 * (v16 >> 1));
      double v19 = v18[21];
      uint64_t v20 = (PSParticle *)(v18 + 29);
      v16 += ~(v16 >> 1);
      if (v19 < a2) {
        CMTime v15 = v20;
      }
      else {
        unint64_t v16 = v17;
      }
    }
    while (v16);
    double v21 = a5;
    do
    {
      unint64_t v22 = v14 >> 1;
      int v23 = (double *)((char *)v21 + 232 * (v14 >> 1));
      double v24 = v23[21];
      __n128 v25 = (PSParticle *)(v23 + 29);
      v14 += ~(v14 >> 1);
      if (v24 < a3) {
        double v21 = v25;
      }
      else {
        unint64_t v14 = v22;
      }
    }
    while (v14);
  }
  else
  {
    CMTime v15 = a5;
    double v21 = a5;
  }
  uint64_t v26 = 0x34F72C234F72C235 * ((v15 - a5) >> 3);
  if (*((double *)a5 + 29 * (int)v26 + 21) >= a2) {
    int v27 = v26;
  }
  else {
    int v27 = v26 + 1;
  }
  if (v27 >= (int)(a6 - 1)) {
    int v28 = a6 - 1;
  }
  else {
    int v28 = v27;
  }
  if ((int)(1332920885 * ((unint64_t)(v21 - a5) >> 3)) >= (int)(a6 - 1)) {
    int v29 = a6 - 1;
  }
  else {
    int v29 = 1332920885 * ((unint64_t)(v21 - a5) >> 3);
  }
  if (v29 >= v28) {
    unsigned int v30 = 0;
  }
  else {
    unsigned int v30 = a6;
  }
  uint64_t v31 = v29 - v28 + v30 + 1;
  uint64_t v32 = (*((void *)a4 + 1) - *(void *)a4) >> 3;
  unsigned int v33 = -1108378657 * v32;
  std::vector<OZSimStateElement>::resize((uint64_t *)a4, (v31 - 1108378657 * v32));
  if (v29 >= v28)
  {
    double v37 = (char *)a5 + 232 * v28;
    int v38 = v29 - v28 + 1;
    do
    {
      CMTime v45 = v43;
      CMTime v44 = v42;
      PC_CMTimeSaferSubtract(&v45, &v44, (uint64_t)&v40);
      *(_OWORD *)(v37 + 8) = v40;
      *((void *)v37 + 3) = v41;
      v37[184] = 1;
      *(void *)(*(void *)a4 + 248 * v33++ + 232) = v37;
      v37 += 232;
      --v38;
    }
    while (v38);
  }
  else
  {
    if (v28 < (int)a6)
    {
      double v34 = (char *)a5 + 232 * v28;
      int v35 = a6 - v28;
      do
      {
        CMTime v45 = v43;
        CMTime v44 = v42;
        PC_CMTimeSaferSubtract(&v45, &v44, (uint64_t)&v40);
        *(_OWORD *)(v34 + 8) = v40;
        *((void *)v34 + 3) = v41;
        v34[184] = 1;
        *(void *)(*(void *)a4 + 248 * v33++ + 232) = v34;
        v34 += 232;
        --v35;
      }
      while (v35);
    }
    if ((v29 & 0x80000000) == 0)
    {
      uint64_t v36 = (v29 + 1);
      do
      {
        CMTime v45 = v43;
        CMTime v44 = v42;
        PC_CMTimeSaferSubtract(&v45, &v44, (uint64_t)&v40);
        *(_OWORD *)((char *)a5 + 8) = v40;
        *((void *)a5 + 3) = v41;
        *((unsigned char *)a5 + 184) = 1;
        *(void *)(*(void *)a4 + 248 * v33++ + 232) = a5;
        a5 = (PSParticle *)((char *)a5 + 232);
        --v36;
      }
      while (v36);
    }
  }
  return v31;
}

void PSPaintPType::birthParticlesInStroke(PSPaintPType *this, double a2, double a3, double a4, double a5, OZSimStateArray *a6, PSParticle *a7, unsigned int a8)
{
  if (vabdd_f64(a2, a3) < 0.0000001) {
    return;
  }
  CMTime v78 = *(CMTime *)((unsigned char *)a6 + 1);
  memset(&v77, 0, sizeof(v77));
  uint64_t v14 = (*(uint64_t (**)(void))(*(void *)(*((void *)this + 2054) + 200) + 272))();
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v14 + 336), (__n128 *)&v77);
  unint64_t v15 = a8;
  unint64_t v16 = (PSParticle *)((char *)a7 + 232 * a8);
  unint64_t v17 = v16;
  CMTime v18 = v16;
  if (a8)
  {
    unint64_t v17 = a7;
    unint64_t v19 = a8;
    do
    {
      unint64_t v20 = v19 >> 1;
      double v21 = (double *)((char *)v17 + 232 * (v19 >> 1));
      double v22 = v21[21];
      int v23 = (PSParticle *)(v21 + 29);
      v19 += ~(v19 >> 1);
      if (v22 < a2) {
        unint64_t v17 = v23;
      }
      else {
        unint64_t v19 = v20;
      }
    }
    while (v19);
    CMTime v18 = a7;
    unint64_t v24 = a8;
    do
    {
      unint64_t v25 = v24 >> 1;
      uint64_t v26 = (double *)((char *)v18 + 232 * (v24 >> 1));
      double v27 = v26[21];
      int v28 = (PSParticle *)(v26 + 29);
      v24 += ~(v24 >> 1);
      if (v27 < a3) {
        CMTime v18 = v28;
      }
      else {
        unint64_t v24 = v25;
      }
    }
    while (v24);
  }
  uint64_t v29 = 0x34F72C234F72C235 * ((v17 - a7) >> 3);
  int v30 = 1332920885 * ((unint64_t)(v18 - a7) >> 3);
  double v31 = *((double *)a7 + 29 * (int)v29 + 21);
  BOOL v32 = v31 < a2;
  if (v31 >= a2) {
    int v33 = v29;
  }
  else {
    int v33 = v29 + 1;
  }
  if (v30 >= (int)(a8 - 1)) {
    int v34 = a8 - 1;
  }
  else {
    int v34 = v30;
  }
  double v35 = 0.0;
  BOOL v36 = a2 < a4;
  double v37 = 0.0;
  int v38 = v33;
  if (v36)
  {
    double v39 = (PSParticle *)((char *)a7 + 232 * a8);
    if (a8)
    {
      double v39 = a7;
      unint64_t v40 = a8;
      do
      {
        unint64_t v41 = v40 >> 1;
        CMTime v42 = (double *)((char *)v39 + 232 * (v40 >> 1));
        double v43 = v42[21];
        CMTime v44 = (PSParticle *)(v42 + 29);
        v40 += ~(v40 >> 1);
        if (v43 < a4) {
          double v39 = v44;
        }
        else {
          unint64_t v40 = v41;
        }
      }
      while (v40);
    }
    uint64_t v45 = 0x34F72C234F72C235 * ((v39 - a7) >> 3);
    if (*((double *)a7 + 29 * (int)v45 + 21) >= a4) {
      int v38 = v45;
    }
    else {
      int v38 = v45 + 1;
    }
    if (v38 <= v33) {
      double v37 = 0.0;
    }
    else {
      double v37 = 1.0 / (double)(v38 - v33);
    }
  }
  if (a3 <= a5)
  {
    int v50 = v34;
  }
  else
  {
    if (a8)
    {
      unint64_t v16 = a7;
      do
      {
        unint64_t v46 = v15 >> 1;
        uint64_t v47 = (double *)((char *)v16 + 232 * (v15 >> 1));
        double v48 = v47[21];
        uint64_t v49 = (PSParticle *)(v47 + 29);
        v15 += ~(v15 >> 1);
        if (v48 < a5) {
          unint64_t v16 = v49;
        }
        else {
          unint64_t v15 = v46;
        }
      }
      while (v15);
    }
    if ((int)(1332920885 * ((unint64_t)(v16 - a7) >> 3)) >= (int)(a8 - 1)) {
      int v50 = a8 - 1;
    }
    else {
      int v50 = 1332920885 * ((unint64_t)(v16 - a7) >> 3);
    }
    if (v34 > v50) {
      double v35 = 1.0 / (double)(v34 - v50);
    }
  }
  if (v34 >= v33)
  {
    uint64_t v63 = v33;
    uint64_t v64 = v50;
    uint64_t v65 = v38;
    uint64_t v66 = v34;
    unsigned int v67 = (char *)a7 + 232 * v33 + 184;
    int v68 = ~v50 + v32 + v29;
    int v69 = ~v33 + v38;
    while (*v67)
    {
LABEL_76:
      v67 += 232;
      ++v68;
      --v69;
      if (v63++ >= v66) {
        return;
      }
    }
    if (v63 >= v65)
    {
      double v71 = 0.01;
      if (v63 <= v64)
      {
LABEL_75:
        operator*(&v77, &v74, v71);
        v80[0] = v78;
        CMTime v79 = v74;
        PC_CMTimeSaferSubtract(v80, &v79, (uint64_t)&v75);
        *((_OWORD *)v67 - 11) = v75;
        *((void *)v67 - 20) = v76;
        *unsigned int v67 = 1;
        goto LABEL_76;
      }
      double v70 = v35 * (double)v68;
    }
    else
    {
      double v70 = v37 * (double)v69;
    }
    double v71 = 1.0 - v70;
    goto LABEL_75;
  }
  int v73 = v34;
  if (v33 < (int)a8)
  {
    uint64_t v51 = v33;
    long long v52 = (char *)a7 + 232 * v33 + 184;
    int v53 = ~v50 + v32 + v29;
    int v54 = ~v33 + v38;
    while (*v52)
    {
LABEL_56:
      ++v51;
      v52 += 232;
      ++v53;
      --v54;
      if (v51 >= (int)a8) {
        goto LABEL_57;
      }
    }
    if (v51 >= v38)
    {
      double v56 = 0.01;
      if (v51 <= v50)
      {
LABEL_55:
        operator*(&v77, &v74, v56);
        v80[0] = v78;
        CMTime v79 = v74;
        PC_CMTimeSaferSubtract(v80, &v79, (uint64_t)&v75);
        *((_OWORD *)v52 - 11) = v75;
        *((void *)v52 - 20) = v76;
        unsigned char *v52 = 1;
        goto LABEL_56;
      }
      double v55 = v35 * (double)v53;
    }
    else
    {
      double v55 = v37 * (double)v54;
    }
    double v56 = 1.0 - v55;
    goto LABEL_55;
  }
LABEL_57:
  if ((v73 & 0x80000000) == 0)
  {
    uint64_t v57 = 0;
    uint64_t v58 = v38;
    int v59 = v38 - 1;
    for (uint64_t i = (char *)a7 + 184; *i; i += 232)
    {
LABEL_66:
      ++v57;
      --v59;
      if (v73 + 1 == v57) {
        return;
      }
    }
    if (v57 <= v50)
    {
      double v62 = 0.01;
      if (v57 >= v58)
      {
LABEL_65:
        operator*(&v77, &v74, v62);
        v80[0] = v78;
        CMTime v79 = v74;
        PC_CMTimeSaferSubtract(v80, &v79, (uint64_t)&v75);
        *((_OWORD *)i - 11) = v75;
        *((void *)i - 20) = v76;
        unsigned char *i = 1;
        goto LABEL_66;
      }
      double v61 = v37 * (double)v59;
    }
    else
    {
      double v61 = v35 * (double)(~v50 + (int)v57);
    }
    double v62 = 1.0 - v61;
    goto LABEL_65;
  }
}

void PSPaintPType::birthAllParticles(PSPaintPType *this, OZSimStateArray *a2, PSParticle *a3, int a4)
{
  memset(&v13, 0, sizeof(v13));
  CMTime v15 = *(CMTime *)((unsigned char *)a2 + 1);
  v7.n128_f64[0] = PSParticleType::simGetFirstFrame(this, (uint64_t)&v13);
  memset(&v12, 0, sizeof(v12));
  uint64_t v8 = (*(uint64_t (**)(__n128))(*(void *)(*((void *)this + 2054) + 200) + 272))(v7);
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v8 + 336), (__n128 *)&v15);
  operator*(&v15, &v12, 0.01);
  if (a4)
  {
    uint64_t v9 = (char *)a3 + 184;
    do
    {
      if (!*v9)
      {
        CMTime v15 = v13;
        CMTime v14 = v12;
        PC_CMTimeSaferSubtract(&v15, &v14, (uint64_t)&v10);
        *((_OWORD *)v9 - 11) = v10;
        *((void *)v9 - 20) = v11;
        *uint64_t v9 = 1;
      }
      v9 += 232;
      --a4;
    }
    while (a4);
  }
  *((unsigned char *)this + 18092) = 1;
}

uint64_t PSPaintPType::addBornParticlesToSim(PSPaintPType *this, OZSimStateArray *a2, PSParticle *a3, int a4)
{
  CMTime v22 = *(CMTime *)((unsigned char *)a2 + 1);
  __n128 v20 = 0uLL;
  uint64_t v8 = *(void *)(*((void *)this + 2054) + 200);
  CMTimeEpoch v21 = 0;
  uint64_t v9 = (*(uint64_t (**)(void))(v8 + 272))();
  OZSceneSettings::getFrameDuration((OZSceneSettings *)(v9 + 336), &v20);
  memset(&v19, 0, sizeof(v19));
  CMTime time1 = v22;
  *(__n128 *)&time2.value = v20;
  time2.CMTimeEpoch epoch = v21;
  PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v19);
  if (a4)
  {
    int v10 = 0;
    uint64_t v11 = 0;
    CMTime v12 = (char *)a3 + 184;
    int v13 = a4;
    CMTime v14 = (char *)a3 + 184;
    do
    {
      int v15 = *v14;
      v14 += 232;
      if (v15)
      {
        ++v10;
        CMTime time1 = *(CMTime *)(v12 - 176);
        CMTime time2 = v22;
        if (CMTimeCompare(&time1, &time2) < 0)
        {
          CMTime time1 = *(CMTime *)(v12 - 176);
          CMTime time2 = v19;
          uint64_t v11 = v11 + (CMTimeCompare(&time1, &time2) >= 0);
        }
      }
      CMTime v12 = v14;
      --v13;
    }
    while (v13);
  }
  else
  {
    uint64_t v11 = 0;
    int v10 = 0;
  }
  if (v10 == a4) {
    *((unsigned char *)this + 18092) = 1;
  }
  uint64_t v16 = (*((void *)a2 + 1) - *(void *)a2) >> 3;
  unsigned int v17 = -1108378657 * v16;
  std::vector<OZSimStateElement>::resize((uint64_t *)a2, (v11 - 1108378657 * v16));
  for (; a4; --a4)
  {
    if (*((unsigned char *)a3 + 184))
    {
      CMTime time1 = *(CMTime *)((char *)a3 + 8);
      CMTime time2 = v22;
      if (CMTimeCompare(&time1, &time2) < 0)
      {
        CMTime time1 = *(CMTime *)((char *)a3 + 8);
        CMTime time2 = v19;
        if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0) {
          *(void *)(*(void *)a2 + 248 * v17++ + 232) = a3;
        }
      }
    }
    a3 = (PSParticle *)((char *)a3 + 232);
  }
  return v11;
}

uint64_t non-virtual thunk to'PSPaintPType::simAddObjects(PSPaintPType *this, OZSystemSimulator *a2, OZSimStateArray *a3, double a4)
{
  return PSPaintPType::simAddObjects((PSPaintPType *)((char *)this - 1112), a2, a3, a4);
}

uint64_t PSPaintPType::getNumEmissionPointsAndOrders(uint64_t a1, const CMTime *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 16432) + 616))(*(void *)(a1 + 16432));
  if (OZChannel::getValueAsInt((OZChannel *)(a1 + 12656), a2, 0.0)
    && PSPaintPType::getIsSpacingConstantOverTime((PSPaintPType *)a1))
  {
    double ReparametrizedContourLength = *(double *)(a1 + 18096);
    if (ReparametrizedContourLength < 0.0)
    {
      (*(void (**)(double **__return_ptr, uint64_t))(*(void *)a1 + 1128))(v19, a1);
      *(_OWORD *)unsigned int v17 = *(_OWORD *)v19;
      int64_t v18 = v20;
      OZRenderState::OZRenderState(&__y);
      *(_OWORD *)&__y.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)v17;
      __y.var0.int64_t var3 = v18;
      double ReparametrizedContourLength = OZRotoshape::getReparametrizedContourLength(v4, (long long *)&__y.var0.var0, 1, 0);
      *(double *)(a1 + 18096) = ReparametrizedContourLength;
    }
  }
  else
  {
    OZRenderState::OZRenderState(&__y);
    *(_OWORD *)&__y.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(_OWORD *)&a2->value;
    __y.var0.int64_t var3 = a2->epoch;
    double ReparametrizedContourLength = OZRotoshape::getReparametrizedContourLength(v4, (long long *)&__y.var0.var0, 1, 0);
  }
  OZChannel::getValueAsDouble((OZChannel *)(a1 + 12184), a2, 0.0);
  double v7 = v6;
  OZChannel::getValueAsDouble((OZChannel *)(v4 + 27320), a2, 0.0);
  if (v8 < 3.0) {
    double v8 = 3.0;
  }
  double v9 = v7 * v8;
  if (v9 > -0.0000001 && v9 < 0.0000001) {
    return 0;
  }
  double v15 = 1.0 / v9;
  if (OZChannel::getValueAsInt((OZChannel *)(a1 + 12808), MEMORY[0x1E4F1FA48], 0.0) != 1
    && !OZChannel::getValueAsInt((OZChannel *)(a1 + 12656), MEMORY[0x1E4F1FA48], 0.0)
    || !PSPaintPType::getIsSpacingEven((PSPaintPType *)a1, a2))
  {
    operator new[]();
  }
  OZChannelDoubleOverRange::getValueOverRangeAsDouble((OZChannel *)(a1 + 12336), a2, 0.0);
  double v12 = v11;
  OZChannelDoubleOverRange::getValueOverRangeAsDouble((OZChannel *)(a1 + 12496), a2, 0.0);
  if ((v12 <= -0.0000001 || v12 >= 0.0000001) && (v13 <= -0.0000001 || v13 >= 0.0000001)) {
    int v14 = (int)(ReparametrizedContourLength * (v15 * (1.0 / v12) * (1.0 / v13))) + 1;
  }
  else {
    int v14 = 0;
  }
  if (v14 >= 100000) {
    return 100000;
  }
  else {
    return v14;
  }
}

uint64_t PSPaintPType::getIsSpacingEven(PSPaintPType *this, const CMTime *a2)
{
  uint64_t v4 = (OZChannel *)((char *)this + 12336);
  double KeyframeMinValue = OZChannel::getKeyframeMinValue((OZChannel *)((char *)this + 12336), 1);
  double KeyframeMaxValue = OZChannel::getKeyframeMaxValue(v4, 1);
  double v7 = OZChannel::getKeyframeMinValue((OZChannel *)((char *)this + 12496), 1);
  double v8 = OZChannel::getKeyframeMaxValue((OZChannel *)((char *)this + 12496), 1);
  if (vabdd_f64(KeyframeMinValue, KeyframeMaxValue) >= 0.0000001
    || vabdd_f64(v7, v8) >= 0.0000001
    || (OZBehavior::IsChannelAffectedByBehaviors((OZBehavior *)v4, (const OZChannelBase *)1) & 1) != 0
    || (OZBehavior::IsChannelAffectedByBehaviors((PSPaintPType *)((char *)this + 12496), (const OZChannelBase *)1) & 1) != 0)
  {
    return 0;
  }
  else
  {
    return PSPaintPType::getIsWidthSequenced(this, a2, 1) ^ 1;
  }
}

uint64_t PSPaintPType::getWidthOverStrokeSamples(uint64_t this, const CMTime *a2, int a3, double *a4)
{
  if (a3)
  {
    (*(void (**)(void))(**(void **)(this + 16432) + 616))(*(void *)(this + 16432));
    operator new[]();
  }
  return this;
}

uint64_t PSPaintPType::simIsFlushingSuppressed(PSPaintPType *this)
{
  uint64_t result = *((void *)this + 2054);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 616))(result);
    if (result)
    {
      uint64_t v2 = result;
      return !OZChannel::getValueAsInt((OZChannel *)(result + 33256), MEMORY[0x1E4F1FA48], 0.0)
          && OZMoShape::getFreehandPaintVertices((OZMoShape *)(v2 + 18976)) != 0;
    }
  }
  return result;
}

uint64_t non-virtual thunk to'PSPaintPType::simIsFlushingSuppressed(PSPaintPType *this)
{
  return PSPaintPType::simIsFlushingSuppressed((PSPaintPType *)((char *)this - 1112));
}

PSEmitter *PSPaintPType::simFlushedCache(PSPaintPType *this, OZSystemSimulator *a2)
{
  uint64_t v4 = (char *)this + 18072;
  if ((PSPaintPType *)((char *)this + 15800) == a2)
  {
    uint64_t v11 = *((void *)this + 2260);
    if (v11)
    {
      uint64_t v12 = v11 - 16;
      uint64_t v13 = *(void *)(v11 - 8);
      if (v13)
      {
        uint64_t v14 = 232 * v13;
        uint64_t v15 = v11 - 232;
        do
        {
          PSParticle::~PSParticle((CGColorSpace **)(v15 + v14));
          v14 -= 232;
        }
        while (v14);
      }
      MEMORY[0x1BA9BFB70](v12, 0x10A1C80AE952B93);
    }
    *((void *)this + 2260) = 0;
    int v10 = v4 + 16;
  }
  else
  {
    uint64_t v5 = *((void *)this + 2258);
    if (v5)
    {
      uint64_t v6 = v5 - 16;
      uint64_t v7 = *(void *)(v5 - 8);
      if (v7)
      {
        uint64_t v8 = 232 * v7;
        uint64_t v9 = v5 - 232;
        do
        {
          PSParticle::~PSParticle((CGColorSpace **)(v9 + v8));
          v8 -= 232;
        }
        while (v8);
      }
      MEMORY[0x1BA9BFB70](v6, 0x10A1C80AE952B93);
    }
    *((void *)this + 2258) = 0;
    int v10 = v4;
  }
  _DWORD *v10 = 0;
  v4[20] = 0;
  *((void *)this + 2262) = 0xBFF0000000000000;
  *((void *)this + 2264) = 0;
  *((_DWORD *)v4 + 12) = 0;

  return PSReplicatorPType::simFlushedCache(this, a2);
}

PSEmitter *non-virtual thunk to'PSPaintPType::simFlushedCache(PSPaintPType *this, OZSystemSimulator *a2)
{
  return PSPaintPType::simFlushedCache((PSPaintPType *)((char *)this - 1112), a2);
}

uint64_t PSPaintPType::performDragOperation(PSPaintPType *this, OZFactoryBase *a2, OZChannelBase *a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, const CMTime *a8)
{
  uint64_t v10 = PSParticleType::performDragOperation(this, a2, a3, a4, a5, a6, a7, a8);
  if (v10 && (OZChannelBase *)((char *)this + 16984) == a3) {
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 17112), 2, 0);
  }
  return v10;
}

uint64_t non-virtual thunk to'PSPaintPType::performDragOperation(PSPaintPType *this, OZFactoryBase *a2, OZChannelBase *a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, const CMTime *a8)
{
  return PSPaintPType::performDragOperation((PSPaintPType *)((char *)this - 16), a2, a3, a4, a5, a6, a7, a8);
}

uint64_t PSPaintPType::parseEnd(PSPaintPType *this, PCSerializerReadStream *a2)
{
  uint64_t v4 = (OZChannelBase *)(*(uint64_t (**)(PSPaintPType *))(*(void *)this + 640))(this);
  OZChannelBase::resetFlag(v4, 1, 1);
  uint64_t v5 = (OZChannelBase *)(*(uint64_t (**)(PSPaintPType *))(*(void *)this + 640))(this);
  OZChannelBase::resetFlag(v5, 0x10000000, 1);
  OZChannel::setDefaultValue((OZChannel *)((char *)this + 11192), 1.0);
  OZChannelBase::reset((OZChannelBase *)((char *)this + 11192), 0);

  return PSParticleType::parseEnd(this, a2);
}

uint64_t non-virtual thunk to'PSPaintPType::parseEnd(PSPaintPType *this, PCSerializerReadStream *a2)
{
  return PSPaintPType::parseEnd((PSPaintPType *)((char *)this - 48), a2);
}

CGColorSpace **PSPaintPType::getRadialParticleMatrix(void **a1, long long *a2, uint64_t a3, double *a4, double *a5, uint64_t a6, int a7)
{
  long long v55 = *a2;
  uint64_t v56 = *((void *)a2 + 2);
  memset(v54, 0, sizeof(v54));
  uint64_t v13 = a3 + 8;
  CMTime v45 = *(CMTime *)a2;
  CMTime v62 = *(CMTime *)(a3 + 8);
  PC_CMTimeSaferSubtract(&v45, &v62, (uint64_t)v54);
  __asm { FMOV            V0.2D, #1.0 }
  float64x2_t v52 = _Q0;
  uint64_t v53 = 0x3FF0000000000000;
  ((void (*)(void **, void *, uint64_t, uint64_t, float64x2_t *))(*a1)[201])(a1, v54, a3 + 32, v13, &v52);
  PSSequencedValues::PSSequencedValues((PSSequencedValues *)&v45);
  ((void (*)(void **, long long *, uint64_t, CMTime *))(*a1)[202])(a1, &v55, a3, &v45);
  float64x2_t v52 = vmulq_f64(vmulq_f64(*(float64x2_t *)(a3 + 56), v52), v48);
  double v19 = (*(double (**)(void *))(*a1[2054] + 352))(a1[2054]);
  float64_t v20 = v52.f64[1];
  double v21 = v52.f64[0] / v19;
  v52.f64[0] = v52.f64[0] / v19;
  double v23 = a4[22];
  double v22 = a4[23];
  double v24 = a4[24];
  double v25 = v50;
  double v26 = v51;
  *(void *)(a6 + 120) = 0x3FF0000000000000;
  *(void *)(a6 + 80) = 0x3FF0000000000000;
  *(void *)(a6 + 40) = 0x3FF0000000000000;
  *(void *)a6 = 0x3FF0000000000000;
  *(_OWORD *)(a6 + 8) = 0u;
  *(_OWORD *)(a6 + 24) = 0u;
  *(_OWORD *)(a6 + 48) = 0u;
  *(_OWORD *)(a6 + 64) = 0u;
  *(_OWORD *)(a6 + 88) = 0u;
  *(_OWORD *)(a6 + 104) = 0u;
  double v27 = v49;
  double v28 = *(double *)&v45.timescale * *(double *)&v45.timescale
      + *(double *)&v45.epoch * *(double *)&v45.epoch
      + v46 * v46;
  double v29 = a4[4];
  if (v28 <= -0.0000001 || v28 >= 0.0000001)
  {
    double v30 = a4[5];
    double v31 = a4[6];
  }
  else
  {
    double v30 = a4[5];
    double v31 = a4[6];
    double v32 = v29 * v29 + v30 * v30 + v31 * v31;
    if (v32 > -0.0000001 && v32 < 0.0000001)
    {
      *(double *)a6 = v21;
      *(float64_t *)(a6 + 40) = v20;
      goto LABEL_10;
    }
  }
  double v40 = v19;
  double v33 = a4[3];
  double v41 = *(double *)&v45.value * v33 - (*(double *)&v45.timescale * v29 + *(double *)&v45.epoch * v30 + v46 * v31);
  double v42 = *(double *)&v45.timescale * v33 + *(double *)&v45.value * v29 + *(double *)&v45.epoch * v31 - v30 * v46;
  double v43 = v33 * *(double *)&v45.epoch + *(double *)&v45.value * v30 + v29 * v46 - *(double *)&v45.timescale * v31;
  double v44 = *(double *)&v45.timescale * v30 - v29 * *(double *)&v45.epoch + v33 * v46 + *(double *)&v45.value * v31;
  if ((a7 & 1) == 0)
  {
    uint64_t v70 = 0x3FF0000000000000;
    uint64_t v67 = 0x3FF0000000000000;
    uint64_t v64 = 0x3FF0000000000000;
    v62.value = 0x3FF0000000000000;
    *(_OWORD *)&v62.timescale = 0u;
    long long v63 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    PCMatrix44Tmpl<double>::setRotationFromQuaternion((uint64_t)&v62, &v41);
    memset(v57, 0, sizeof(v57));
    long long v59 = 0u;
    long long v60 = 0u;
    uint64_t v61 = 0;
    int v58 = 4;
    PCMatrix44Tmpl<double>::getTransformation((long long *)&v62.value, (uint64_t)v57);
    __double2 v34 = __sincos_stret(*(double *)&v60 * 0.5);
    double v35 = v34.__sinval * 0.0 * 0.0;
    double v36 = v34.__sinval * 0.0 + v34.__cosval * 0.0;
    double v43 = v36 + v35 - v34.__sinval * 0.0;
    double v44 = v34.__sinval + v34.__cosval * 0.0 + v35 - v35;
    double v41 = v34.__cosval - (v34.__sinval * 0.0 + v35 + v35);
    double v42 = v36 + v34.__sinval * 0.0 - v35;
  }
  PCMatrix44Tmpl<double>::rightRotate(a6, &v41);
  PCMatrix44Tmpl<double>::rightScale((double *)a6, v52.f64[0], v52.f64[1], 1.0);
  double v19 = v40;
LABEL_10:
  if (v19 != 1.0)
  {
    *(double *)(a6 + 32) = v19 * *(double *)(a6 + 32);
    *(double *)(a6 + 64) = v19 * *(double *)(a6 + 64);
    *(float64x2_t *)(a6 + 8) = vdivq_f64(*(float64x2_t *)(a6 + 8), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v19, 0));
  }
  if (a7) {
    double v37 = v24 + v26;
  }
  else {
    double v37 = 0.0;
  }
  PCMatrix44Tmpl<double>::leftMult(a6, a5);
  v38.f64[0] = v23 + v27;
  PCMatrix44Tmpl<double>::leftTranslate((float64x2_t *)a6, v38, v22 + v25, v37);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v47);
}

void sub_1B7E04508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PSPaintPType::preRenderFrame(PSPaintPType *this, CMTime *a2, PSHeliumNode *a3)
{
  *((_WORD *)this + 9062) = 0;
  PSParticleType::preRenderFrame((uint64_t)this);
  if (!*(_DWORD *)(*(void *)HGRenderJob::GetRenderNodeList((HGRenderJob *)a2) + 8))
  {
    CMTime v14 = *a2;
    PSHeliumNode::initGradient(a3, (PSPaintPType *)((char *)this + 16984), &v14);
  }
  if (LiRenderingTechnology::getEnableMetalRendering((LiRenderingTechnology *)((char *)&a2[54].epoch + 4)))
  {
    WorkingColorSpace = (CGColorSpace *)OZRenderParams::getWorkingColorSpace((FxColorDescription *)a2);
    PSPaintPType::getAvailableMetalBrushGradient(this, WorkingColorSpace, &v12);
    if (!v12.var0) {
      throw_PCNullPointerException(1);
    }
    long long v10 = *(_OWORD *)&a2->value;
    CMTimeEpoch epoch = a2->epoch;
    (*(void (**)(PC_Sp_counted_base *, long long *))(*(void *)v12.var0 + 24))(v12.var0, &v10);
    PSHeliumNode::setMetalGradient((uint64_t)a3, &v12);
  }
  else
  {
    uint64_t v7 = (CGColorSpace *)OZRenderParams::getWorkingColorSpace((FxColorDescription *)a2);
    PSPaintPType::getAvailableBrushGradient(this, v7, &v12);
    if (!v12.var0) {
      throw_PCNullPointerException(1);
    }
    long long v8 = *(_OWORD *)&a2->value;
    CMTimeEpoch v9 = a2->epoch;
    (*(void (**)(PC_Sp_counted_base *, long long *))(*(void *)v12.var0 + 56))(v12.var0, &v8);
    PSHeliumNode::setGradient((uint64_t)a3, &v12);
  }
  PCSharedCount::~PCSharedCount(&v13);
}

void sub_1B7E046AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  PCSharedCount::~PCSharedCount((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

PCMutex *PSPaintPType::getAvailableMetalBrushGradient@<X0>(PSPaintPType *this@<X0>, CGColorSpace *a2@<X1>, PCSharedCount *a3@<X8>)
{
  a3->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0;
  uint64_t v6 = (uint64_t *)&a3[1];
  PCSharedCount::PCSharedCount(a3 + 1);
  uint64_t v11 = (PCMutex *)((char *)this + 17968);
  PCMutex::lock((PCMutex *)((char *)this + 17968));
  char v12 = 1;
  uint64_t v7 = (const PCSharedCount *)*((void *)this + 2255);
  long long v8 = (const PCSharedCount *)*((void *)this + 2256);
  while (1)
  {
    if (v7 == v8) {
      PSPaintPType::createMetalBrushGradient(this, a2);
    }
    if (PCSharedCount::unique((PCSharedCount *)&v7[1])) {
      break;
    }
    v7 += 2;
  }
  a3->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v7->var0;
  PCSharedCount::PCSharedCount(&v10, v7 + 1);
  PCSharedCount::operator=(v6, (uint64_t *)&v10);
  PCSharedCount::~PCSharedCount(&v10);
  uint64_t result = v11;
  if (v11)
  {
    if (v12) {
      return (PCMutex *)PCMutex::unlock(v11);
    }
  }
  return result;
}

void sub_1B7E04830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, PCSharedCount a14)
{
  *(void *)(v15 + 18048) = v16;
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a12);
  PCSharedCount::~PCSharedCount(v14);
  _Unwind_Resume(a1);
}

PCMutex *PSPaintPType::getAvailableBrushGradient@<X0>(PSPaintPType *this@<X0>, CGColorSpace *a2@<X1>, PCSharedCount *a3@<X8>)
{
  a3->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0;
  uint64_t v6 = (uint64_t *)&a3[1];
  PCSharedCount::PCSharedCount(a3 + 1);
  uint64_t v11 = (PCMutex *)((char *)this + 17968);
  PCMutex::lock((PCMutex *)((char *)this + 17968));
  char v12 = 1;
  uint64_t v7 = (const PCSharedCount *)*((void *)this + 2243);
  long long v8 = (const PCSharedCount *)*((void *)this + 2244);
  while (1)
  {
    if (v7 == v8) {
      PSPaintPType::createBrushGradient(this, a2);
    }
    if (PCSharedCount::unique((PCSharedCount *)&v7[1])) {
      break;
    }
    v7 += 2;
  }
  a3->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v7->var0;
  PCSharedCount::PCSharedCount(&v10, v7 + 1);
  PCSharedCount::operator=(v6, (uint64_t *)&v10);
  PCSharedCount::~PCSharedCount(&v10);
  uint64_t result = v11;
  if (v11)
  {
    if (v12) {
      return (PCMutex *)PCMutex::unlock(v11);
    }
  }
  return result;
}

void sub_1B7E04A00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, PCSharedCount a14)
{
  *(void *)(v15 + 17952) = v16;
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a12);
  PCSharedCount::~PCSharedCount(v14);
  _Unwind_Resume(a1);
}

uint64_t PSPaintPType::getIsWidthSequenced(PSPaintPType *this, const CMTime *a2, int a3)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**((void **)this + 2054) + 616))(*((void *)this + 2054));
  uint64_t v5 = v4 + 1200;
  uint64_t v6 = *(void *)(v4 + 1208);
  if (v4 + 1200 == v6) {
    return 0;
  }
  while (1)
  {
    uint64_t v7 = *(void **)(*(void *)v5 + 16);
    unint64_t v8 = v7[1];
    long long v11 = xmmword_1B8387C00;
    if (OZFactory::isKindOfClass(v8, (int32x4_t *)&v11))
    {
      if (((*(unsigned int (**)(void))(*(void *)v9 + 296))() | a3 ^ 1) == 1
        && PSPaintSequenceBehavior::isAffectingWidth(v9))
      {
        break;
      }
    }
    uint64_t v5 = *(void *)v5;
    if (v5 == v6) {
      return 0;
    }
  }
  return 1;
}

void PSPaintPType::createBrushGradient(PSPaintPType *this, CGColorSpace *a2)
{
}

void sub_1B7E04D30(_Unwind_Exception *a1)
{
  PCString v3 = v2;
  PCCFRef<CGColorSpace *>::~PCCFRef(v3);
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void PSPaintPType::createMetalBrushGradient(PSPaintPType *this, CGColorSpace *a2)
{
}

void sub_1B7E04E88(_Unwind_Exception *a1)
{
  PCString v3 = v2;
  PCCFRef<CGColorSpace *>::~PCCFRef(v3);
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void PSOwnedObjectWrapper::~PSOwnedObjectWrapper(PSOwnedObjectWrapper *this)
{
  *(void *)(v1 + 16) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 32) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 24));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 16) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 32) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 24));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'PSOwnedObjectWrapper::~PSOwnedObjectWrapper(PSOwnedObjectWrapper *this)
{
  *(void *)(v1 + 16) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 32) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 24);

  PCWeakCount::~PCWeakCount(v2);
}

{
  PSOwnedObjectWrapper::~PSOwnedObjectWrapper((PSOwnedObjectWrapper *)((char *)this + *(void *)(*(void *)this - 24)));
}

void PSOwnedObjectWrapper::~PSOwnedObjectWrapper(PSOwnedObjectWrapper *this, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v3 - 24)) = a2[3];
  uint64_t v4 = *((void *)this + 1);
  if (v4)
  {
    uint64_t v5 = v4 - 16;
    uint64_t v6 = *(void *)(v4 - 8);
    if (v6)
    {
      uint64_t v7 = 232 * v6;
      uint64_t v8 = v4 - 232;
      do
      {
        PSParticle::~PSParticle((CGColorSpace **)(v8 + v7));
        v7 -= 232;
      }
      while (v7);
    }
    MEMORY[0x1BA9BFB70](v5, 0x10A1C80AE952B93);
  }
  *((void *)this + 1) = 0;
}

uint64_t std::vector<PCPtr<OZGLGradientRadial>>::__push_back_slow_path<PCPtr<OZGLGradientRadial> const&>(uint64_t *a1, const PCSharedCount *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 3 > v5) {
    unint64_t v5 = v8 >> 3;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  unsigned int v17 = a1 + 2;
  if (v9) {
    PCSharedCount v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v7, v9);
  }
  else {
    PCSharedCount v10 = 0;
  }
  long long v11 = (PCSharedCount *)&v10[16 * v4];
  v14[0] = v10;
  v14[1] = v11;
  uint64_t v15 = v11;
  uint64_t v16 = &v10[16 * v9];
  v11->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = a2->var0;
  PCSharedCount::PCSharedCount(v11 + 1, a2 + 1);
  v15 += 2;
  std::vector<PCPtr<OZGLGradientRadial>>::__swap_out_circular_buffer(a1, v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<PCPtr<LiMaterialLayer>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_1B7E0520C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<PCPtr<LiMaterialLayer>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<PCPtr<OZGLGradientRadial>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PCPtr<OZGLGradientRadial>>,std::reverse_iterator<PCPtr<OZGLGradientRadial>*>,std::reverse_iterator<PCPtr<OZGLGradientRadial>*>,std::reverse_iterator<PCPtr<OZGLGradientRadial>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PCPtr<OZGLGradientRadial>>,std::reverse_iterator<PCPtr<OZGLGradientRadial>*>,std::reverse_iterator<PCPtr<OZGLGradientRadial>*>,std::reverse_iterator<PCPtr<OZGLGradientRadial>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  for (uint64_t i = 24; ; i -= 16)
  {
    uint64_t v12 = a3 + i;
    if (a3 + i - 24 == a5) {
      break;
    }
    *(void *)(a7 + i - 40) = *(void *)(v12 - 40);
    PCSharedCount v13 = (PCSharedCount *)(a7 + i - 32);
    PCSharedCount::PCSharedCount(v13, (const PCSharedCount *)(v12 - 32));
  }
  return a6;
}

uint64_t std::vector<PCPtr<OZMetalGradientRadial>>::__push_back_slow_path<PCPtr<OZMetalGradientRadial> const&>(uint64_t *a1, const PCSharedCount *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 3 > v5) {
    unint64_t v5 = v8 >> 3;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  unsigned int v17 = a1 + 2;
  if (v9) {
    PCSharedCount v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v7, v9);
  }
  else {
    PCSharedCount v10 = 0;
  }
  long long v11 = (PCSharedCount *)&v10[16 * v4];
  v14[0] = v10;
  v14[1] = v11;
  uint64_t v15 = v11;
  uint64_t v16 = &v10[16 * v9];
  v11->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = a2->var0;
  PCSharedCount::PCSharedCount(v11 + 1, a2 + 1);
  v15 += 2;
  std::vector<PCPtr<OZMetalGradientRadial>>::__swap_out_circular_buffer(a1, v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<PCPtr<LiMaterialLayer>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_1B7E05414(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<PCPtr<LiMaterialLayer>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<PCPtr<OZMetalGradientRadial>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PCPtr<OZMetalGradientRadial>>,std::reverse_iterator<PCPtr<OZMetalGradientRadial>*>,std::reverse_iterator<PCPtr<OZMetalGradientRadial>*>,std::reverse_iterator<PCPtr<OZMetalGradientRadial>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PCPtr<OZMetalGradientRadial>>,std::reverse_iterator<PCPtr<OZMetalGradientRadial>*>,std::reverse_iterator<PCPtr<OZMetalGradientRadial>*>,std::reverse_iterator<PCPtr<OZMetalGradientRadial>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  for (uint64_t i = 24; ; i -= 16)
  {
    uint64_t v12 = a3 + i;
    if (a3 + i - 24 == a5) {
      break;
    }
    *(void *)(a7 + i - 40) = *(void *)(v12 - 40);
    PCSharedCount v13 = (PCSharedCount *)(a7 + i - 32);
    PCSharedCount::PCSharedCount(v13, (const PCSharedCount *)(v12 - 32));
  }
  return a6;
}

void PSPenPropertyCurveNode::~PSPenPropertyCurveNode(PSPenPropertyCurveNode *this)
{
  OZEaseInInterpolator::~OZEaseInInterpolator(this);

  JUMPOUT(0x1BA9BFBA0);
}

void PSPenPropertyCurveNode::solveNode(OZBehavior **this, const CMTime *a2, double a3, double a4)
{
  __n128 v12 = 0uLL;
  uint64_t v13 = 0;
  OZBehavior::getFrameDuration(this[4], &v12);
  memset(&v11, 0, sizeof(v11));
  PC_CMTimeMakeWithSecondsRoundToNearest(v12.n128_i32[2], &v11, a3);
  uint64_t v8 = this[4];
  CMTime v10 = *a2;
  double Seconds = CMTimeGetSeconds(&v10);
  PSPenPropertyBehavior::solveNode(v8, &v11, Seconds, a4);
}

double PSPenPropertyBehavior::solveNode(PSPenPropertyBehavior *this, const CMTime *a2, double a3, double a4)
{
  if (*((void *)this + 267))
  {
    memset(&v20, 0, sizeof(v20));
    (*(void (**)(CMTime *__return_ptr))(**(void **)(*((void *)this + 47) + 32) + 336))(&v20);
    CMTime v19 = v20;
    if (!(*(unsigned int (**)(PSPenPropertyBehavior *, CMTime *, void, uint64_t, uint64_t))(*(void *)this + 296))(this, &v19, 0, 1, 1))return a4; {
    double v7 = 0.0;
    }
    BOOL v8 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 1960), &v20, 0.0) != 0;
    double v9 = (*(double (**)(PSPenPropertyBehavior *, BOOL, double))(*(void *)this + 680))(this, v8, a3);
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 1200), &v20, 0.0);
    double v11 = v10;
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 1352), &v20, 0.0);
    if (v9 >= v11)
    {
      if (v12 <= v11) {
        double v12 = v11 + 0.01;
      }
      double v13 = (v9 - v11) / (v12 - v11);
      int v14 = *((_DWORD *)this + 529);
      switch(v14)
      {
        case 2:
          uint64_t v16 = (OZChannel *)((char *)this + 1808);
          break;
        case 1:
          uint64_t v16 = (OZChannel *)((char *)this + 1656);
          break;
        case 0:
          OZChannel::getValueAsDouble((OZChannel *)((char *)this + 1504), &v20, 0.0);
          return v13 * (v15 * a4);
        default:
          return v7;
      }
      OZChannel::getValueAsDouble(v16, &v20, 0.0);
      return v13 * v17 + a4;
    }
    return v7;
  }
  return a4;
}

void PSPenPropertyCurveNode::solveNode(OZBehavior **this, OZCurveNodeParam *a2)
{
  uint64_t v4 = *((void *)a2 + 19);
  uint64_t v5 = *((void *)a2 + 10);
  CMTime v14 = *(CMTime *)((unsigned char *)a2 + 5);
  CMTime v13 = *(CMTime *)((unsigned char *)a2 + 4);
  __n128 v11 = 0uLL;
  uint64_t v12 = 0;
  OZBehavior::getFrameDuration(this[4], &v11);
  memset(&v10, 0, sizeof(v10));
  PC_CMTimeMakeWithSecondsRoundToNearest(v11.n128_i32[2], &v10, *((double *)a2 + 1));
  if (*((_DWORD *)a2 + 36))
  {
    unint64_t v6 = 0;
    do
    {
      double v7 = this[4];
      CMTime v9 = v13;
      double Seconds = CMTimeGetSeconds(&v9);
      *(double *)(v4 + 8 * v6) = PSPenPropertyBehavior::solveNode(v7, &v10, Seconds, *(double *)(v5 + 8 * v6));
      CMTime v16 = v13;
      CMTime v15 = v14;
      PC_CMTimeSaferAdd(&v16, &v15, (uint64_t)&v13);
      ++v6;
    }
    while (v6 < *((unsigned int *)a2 + 36));
  }
}

__n128 PSPenPropertyCurveNode::getNeededRange(PSPenPropertyCurveNode *this, OZCurveNodeParam *a2)
{
  *(_OWORD *)((char *)a2 + 24) = *((_OWORD *)a2 + 6);
  *((void *)a2 + 5) = *((void *)a2 + 14);
  __n128 result = *(__n128 *)((char *)a2 + 120);
  *((__n128 *)a2 + 3) = result;
  *((void *)a2 + 8) = *((void *)a2 + 17);
  *((_DWORD *)a2 + 18) = *((_DWORD *)a2 + 36);
  *((unsigned char *)a2 + 88) = 0;
  *((void *)a2 + 10) = *((void *)a2 + 19);
  return result;
}

void PSPenPropertyCurveNode::cloneNode(PSPenPropertyCurveNode *this)
{
}

void sub_1B7E059BC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C409AC7BE1CLL);
  _Unwind_Resume(a1);
}

uint64_t PSPenPropertyCurveNode::compare(PSPenPropertyCurveNode *this, const OZCurveNode *lpsrc)
{
  if (lpsrc) {
  return 0;
  }
}

void PSPenPropertyBehavior::PSPenPropertyBehavior(PSPenPropertyBehavior *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  OZChannelBehavior::OZChannelBehavior(this, a2, a3, a4);
  *uint64_t v5 = &unk_1F11954D8;
  v5[2] = &unk_1F1195798;
  v5[6] = &unk_1F11959F0;
  v5[42] = &unk_1F1195A48;
  PCURL::PCURL((PCURL *)&v7, @"Pen Property Behavior Apply To Enum");
  PCURL::PCURL((PCURL *)&v6, @"Pen Property Behavior Apply To");
  OZChannelEnum::OZChannelEnum((PSPenPropertyBehavior *)((char *)this + 536), 0, &v7, &v6, (OZChannelFolder *)((char *)this + 56), 0xC8u, 0, 0, 0);
  PCString::~PCString(&v6);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"Pen Property Behavior Calc Tilt Enum");
  PCURL::PCURL((PCURL *)&v6, @"Pen Property Behavior Calc Tilt");
  OZChannelEnum::OZChannelEnum((PSPenPropertyBehavior *)((char *)this + 792), 0, &v7, &v6, (OZChannelFolder *)((char *)this + 56), 0xC9u, 2, 0, 0);
  PCString::~PCString(&v6);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"Pen Property Behavior Tilt Axis");
  OZChannelAngle::OZChannelAngle((OZChannelAngle *)((char *)this + 1048), 0.0, &v7, (OZChannelFolder *)((char *)this + 56), 0xCAu, 2, 0, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"Pen Property Behavior Pen Min Input");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 1200), 0.0, &v7, (OZChannelFolder *)((char *)this + 56), 0xCBu, 0, 0, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"Pen Property Behavior Pen Max Input");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 1352), 1.0, &v7, (OZChannelFolder *)((char *)this + 56), 0xCCu, 0, 0, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"Pen Property Behavior Scale Multiply");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 1504), 1.0, &v7, (OZChannelFolder *)((char *)this + 56), 0xCDu, 0, 0, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"Pen Property Behavior Scale Offset");
  OZChannelDouble::OZChannelDouble((PSPenPropertyBehavior *)((char *)this + 1656), 10.0, &v7, (OZChannelFolder *)((char *)this + 56), 0xCEu, 0, 0, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"Pen Property Behavior Scale Angle");
  OZChannelAngle::OZChannelAngle((OZChannelAngle *)((char *)this + 1808), 0.785398163, &v7, (OZChannelFolder *)((char *)this + 56), 0xCFu, 0, 0, 0);
  PCString::~PCString(&v7);
  PCURL::PCURL((PCURL *)&v7, @"Pen Property Behavior Invert");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 1960), &v7, (OZChannelFolder *)((char *)this + 56), 0xD1u, 0, 0, 0);
  PCString::~PCString(&v7);
  *((unsigned char *)this + 2112) = 0;
  *((_DWORD *)this + 529) = 0;
  *((unsigned char *)this + 2120) = 0;
  *((void *)this + 267) = 0;
  OZChannel::setMax((OZChannel *)((char *)this + 1504), 3.40282347e38);
  OZChannel::setSliderMax((OZChannel *)((char *)this + 1504), 4.0);
}

void sub_1B7E05E4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, OZChannelEnum *a10, PCString a11, PCString a12)
{
  PCString::~PCString(&a12);
  OZChannel::~OZChannel(v19);
  OZChannel::~OZChannel(v18);
  OZChannelPercent::~OZChannelPercent(v17);
  OZChannelPercent::~OZChannelPercent(v16);
  OZChannelPercent::~OZChannelPercent(v15);
  OZChannel::~OZChannel(v14);
  OZChannelEnum::~OZChannelEnum(v13);
  OZChannelEnum::~OZChannelEnum(a10);
  OZChannelBehavior::~OZChannelBehavior(v12);
  _Unwind_Resume(a1);
}

void PSPenPropertyBehavior::PSPenPropertyBehavior(PSPenPropertyBehavior *this, const PSPenPropertyBehavior *a2, char a3)
{
  OZChannelBehavior::OZChannelBehavior(this, a2, a3);
  *(void *)uint64_t v5 = &unk_1F11954D8;
  *(void *)(v5 + 16) = &unk_1F1195798;
  *(void *)(v5 + 48) = &unk_1F11959F0;
  *(void *)(v5 + 336) = &unk_1F1195A48;
  PCString v6 = (OZChannelFolder *)(v5 + 56);
  OZChannelEnum::OZChannelEnum((OZChannelEnum *)(v5 + 536), (const PSPenPropertyBehavior *)((char *)a2 + 536), (OZChannelFolder *)(v5 + 56));
  OZChannelEnum::OZChannelEnum((PSPenPropertyBehavior *)((char *)this + 792), (const PSPenPropertyBehavior *)((char *)a2 + 792), v6);
  OZChannel::OZChannel((OZChannel *)((char *)this + 1048), (const OZChannelBase *)((char *)a2 + 1048), v6);
  *((void *)this + 131) = &unk_1F11010C0;
  *((void *)this + 133) = &unk_1F1101420;
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 1200), (const OZChannelBase *)((char *)a2 + 1200), v6);
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 1352), (const OZChannelBase *)((char *)a2 + 1352), v6);
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 1504), (const OZChannelBase *)((char *)a2 + 1504), v6);
  OZChannel::OZChannel((OZChannel *)((char *)this + 1656), (const OZChannelBase *)((char *)a2 + 1656), v6);
  *((void *)this + 207) = &unk_1F1100CF0;
  *((void *)this + 209) = &unk_1F1101050;
  OZChannel::OZChannel((OZChannel *)((char *)this + 1808), (const OZChannelBase *)((char *)a2 + 1808), v6);
  *((void *)this + 226) = &unk_1F11010C0;
  *((void *)this + 228) = &unk_1F1101420;
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 1960), (const OZChannelBase *)((char *)a2 + 1960), v6);
  *((unsigned char *)this + 2112) = 0;
  *((_DWORD *)this + 529) = 0;
  *((unsigned char *)this + 2120) = 0;
  *((void *)this + 267) = 0;
}

void sub_1B7E061F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, OZChannelEnum *a10)
{
  OZChannel::~OZChannel(v11);
  OZChannel::~OZChannel(v17);
  OZChannelPercent::~OZChannelPercent(v16);
  OZChannelPercent::~OZChannelPercent(v15);
  OZChannelPercent::~OZChannelPercent(v14);
  OZChannel::~OZChannel(v13);
  OZChannelEnum::~OZChannelEnum(v12);
  OZChannelEnum::~OZChannelEnum(a10);
  OZChannelBehavior::~OZChannelBehavior(v10);
  _Unwind_Resume(a1);
}

void sub_1B7E06264()
{
}

void sub_1B7E0626C()
{
}

void sub_1B7E06274()
{
}

void sub_1B7E0627C()
{
}

void PSPenPropertyBehavior::~PSPenPropertyBehavior(PSPenPropertyBehavior *this)
{
  *(void *)this = &unk_1F11954D8;
  *((void *)this + 2) = &unk_1F1195798;
  *((void *)this + 6) = &unk_1F11959F0;
  *((void *)this + 42) = &unk_1F1195A48;
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 1960));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1808));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1656));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 1504));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 1352));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 1200));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1048));
  OZChannelEnum::~OZChannelEnum((PSPenPropertyBehavior *)((char *)this + 792));
  OZChannelEnum::~OZChannelEnum((PSPenPropertyBehavior *)((char *)this + 536));

  OZChannelBehavior::~OZChannelBehavior(this);
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior(this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'PSPenPropertyBehavior::~PSPenPropertyBehavior(PSPenPropertyBehavior *this)
{
}

{
  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenPropertyBehavior *)((char *)this - 48));
}

{
  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenPropertyBehavior *)((char *)this - 336));
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenPropertyBehavior *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenPropertyBehavior *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenPropertyBehavior *)((char *)this - 336));

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PSPenPropertyBehavior::operator=(PSPenPropertyBehavior *a1, const void *a2)
{
  OZChannelBehavior::operator=();
  if (!v4) {
    __cxa_bad_cast();
  }
  uint64_t v5 = v4;
  OZChannelBase::operator=((uint64_t)a1 + 536, (uint64_t)v4 + 536);
  OZChannelBase::operator=((uint64_t)a1 + 792, (uint64_t)v5 + 792);
  OZChannelBase::operator=((uint64_t)a1 + 1048, (uint64_t)v5 + 1048);
  OZChannelBase::operator=((uint64_t)a1 + 1200, (uint64_t)v5 + 1200);
  OZChannelBase::operator=((uint64_t)a1 + 1352, (uint64_t)v5 + 1352);
  OZChannelBase::operator=((uint64_t)a1 + 1504, (uint64_t)v5 + 1504);
  OZChannelBase::operator=((uint64_t)a1 + 1656, (uint64_t)v5 + 1656);
  OZChannelBase::operator=((uint64_t)a1 + 1808, (uint64_t)v5 + 1808);
  *((unsigned char *)a1 + 2120) = 0;
  uint64_t result = (*(uint64_t (**)(PSPenPropertyBehavior *))(*(void *)a1 + 336))(a1);
  if (result)
  {
    return PSPenPropertyBehavior::updateApplyTo(a1);
  }
  else
  {
    *((unsigned char *)a1 + 2112) = 0;
    *((_DWORD *)a1 + 529) = 0;
  }
  return result;
}

uint64_t PSPenPropertyBehavior::updateApplyTo(PSPenPropertyBehavior *this)
{
  uint64_t v2 = (*(uint64_t (**)(PSPenPropertyBehavior *))(*(void *)this + 320))(this);
  PCURL::PCURL((PCURL *)&v8, @"Pen Property Behavior Undo Applied To");
  (*(void (**)(char *, PCString *, void))(*((void *)this + 2) + 176))((char *)this + 16, &v8, 0);
  PCString::~PCString(&v8);
  (*(void (**)(PSPenPropertyBehavior *))(*(void *)this + 120))(this);
  uint64_t v3 = v2 + 1000;
  for (uint64_t i = *(void *)(v2 + 1008); i != v3; uint64_t i = *(void *)(i + 8))
  {
    if (*(PSPenPropertyBehavior **)(i + 16) == this) {
      goto LABEL_6;
    }
  }
  uint64_t i = v2 + 1000;
LABEL_6:
  uint64_t v5 = *(void *)(i + 8);
  if (v5 == v3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *(void *)(v5 + 16);
  }
  return (*(uint64_t (**)(PSPenPropertyBehavior *, uint64_t, uint64_t))(*(void *)this + 104))(this, v2, v6);
}

void sub_1B7E06714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t PSPenPropertyBehavior::canAddToSceneNode(PSPenPropertyBehavior *this, OZSceneNode *a2)
{
  uint64_t result = OZBehavior::canAddToSceneNode(this, a2);
  if (result) {
    uint64_t result = a2
  }
  return result;
}

void PSPenPropertyBehavior::addPenPropertyNodes(PSPenPropertyBehavior *this, OZSceneNode *a2)
{
  switch(OZChannel::getValueAsInt((OZChannel *)((char *)this + 536), MEMORY[0x1E4F1FA48], 0.0))
  {
    case 0u:
    case 1u:
    case 2u:
      *((_DWORD *)this + 529) = 0;
      goto LABEL_7;
    case 3u:
      int v10 = 2;
      goto LABEL_6;
    case 4u:
      int v10 = 1;
LABEL_6:
      *((_DWORD *)this + 529) = v10;
LABEL_7:
      operator new();
    default:
      PCPrint("File %s, line %d should not have been reached:\n\t", v3, v4, v5, v6, v7, v8, v9, (char)"/Library/Caches/com.apple.xbs/Sources/MotioniOS/Particles/PSPenPropertyBehavior.cpp");
      pcAbortImpl();
  }
}

void sub_1B7E06A14(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C409AC7BE1CLL);
  _Unwind_Resume(a1);
}

unsigned char *PSPenPropertyBehavior::didAddToNode(PSPenPropertyBehavior *this, OZSceneNode *a2)
{
  OZChannelBehavior::didAddToNode(this, a2);
  if (a2)
  {
    *((void *)this + 267) = v4;
    if (v4)
    {
      uint64_t v5 = (void *)v4[4732];
      if (v5) {
      uint64_t result = PSPaint::getPaintPType((PSPaint *)v5);
      }
      *((void *)this + 268) = result;
      goto LABEL_11;
    }
    uint64_t v8 = (void *)((char *)this + 2136);
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = (void *)((char *)this + 2136);
    *((void *)this + 267) = 0;
  }
  *((void *)this + 268) = PSPaint::getPaintPType(v7);
  uint64_t result = (unsigned char *)*((void *)v7 + 145);
  if (result) {
  *uint64_t v8 = result;
  }
LABEL_11:
  if (!*((unsigned char *)this + 2112))
  {
    uint64_t result = (unsigned char *)(*(uint64_t (**)(OZSceneNode *))(*(void *)a2 + 272))(a2);
    if (result)
    {
      uint64_t result = (unsigned char *)(*(uint64_t (**)(OZSceneNode *))(*(void *)a2 + 272))(a2);
      if (!result[1576]) {
        PSPenPropertyBehavior::addPenPropertyNodes(this, v9);
      }
    }
  }
  return result;
}

void *PSPenPropertyBehavior::didAddSceneNodeToScene(PSPenPropertyBehavior *this, OZScene *a2)
{
  uint64_t result = (void *)OZChannelBehavior::didAddSceneNodeToScene(this, a2);
  if (!*((void *)this + 267))
  {
    uint64_t result = *(void **)(*(void *)(*((void *)this + 268) + 16432) + 1160);
    if (result) {
    *((void *)this + 267) = result;
    }
  }
  if (!*((unsigned char *)this + 2112))
  {
    (*(void (**)(PSPenPropertyBehavior *))(*(void *)this + 320))(this);
    PSPenPropertyBehavior::addPenPropertyNodes(this, v4);
  }
  return result;
}

void PSPenPropertyBehavior::willRemove(PSPenPropertyBehavior *this)
{
  *((unsigned char *)this + 2112) = 0;
}

PSPenPropertyBehavior *PSPenPropertyBehavior::sceneNodeDidLoad(PSPenPropertyBehavior *this)
{
  if (!*((unsigned char *)this + 2112))
  {
    uint64_t v1 = this;
    (*(void (**)(PSPenPropertyBehavior *))(*(void *)this + 320))(this);
    PSPenPropertyBehavior::addPenPropertyNodes(v1, v2);
  }
  return this;
}

BOOL PSPenPropertyBehavior::isRebuildUIChannel(PSPenPropertyBehavior *this, OZChannelBase *a2)
{
  return (OZChannelBase *)((char *)this + 536) == a2;
}

OZChannelBase *PSPenPropertyBehavior::updateHiddenFlags(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  while (1)
  {
    uint64_t v4 = *(void *)(v4 + 8);
    if (v4 == a2) {
      break;
    }
    {
      OZChannelBase::resetFlag((OZChannelBase *)(a1 + 1504), 0x400000, 1);
      OZChannelBase::resetFlag((OZChannelBase *)(a1 + 1656), 0x400000, 1);
      uint64_t v5 = (OZChannelBase *)(a1 + 1808);
      OZChannelBase::resetFlag((OZChannelBase *)(a1 + 1808), 0x400000, 1);
      OZChannelBase::setFlag((OZChannelBase *)(a1 + 1504), 16, 1);
      OZChannelBase::setFlag((OZChannelBase *)(a1 + 1656), 16, 1);
      goto LABEL_11;
    }
  }
  uint64_t v5 = (OZChannelBase *)(a1 + 1504);
  OZChannelBase::setFlag((OZChannelBase *)(a1 + 1504), 0x400000, 1);
  OZChannelBase::setFlag((OZChannelBase *)(a1 + 1656), 0x400000, 1);
  OZChannelBase::setFlag((OZChannelBase *)(a1 + 1808), 0x400000, 1);
  OZChannelBase::resetFlag((OZChannelBase *)(a1 + 1504), 16, 1);
  OZChannelBase::resetFlag((OZChannelBase *)(a1 + 1656), 16, 1);
  uint64_t result = OZChannelBase::resetFlag((OZChannelBase *)(a1 + 1808), 16, 1);
  int v7 = *(_DWORD *)(a1 + 2116);
  if (v7 == 2)
  {
    OZChannelBase::resetFlag((OZChannelBase *)(a1 + 1808), 0x400000, 1);
    uint64_t v5 = (OZChannelBase *)(a1 + 1808);
  }
  else if (v7 == 1)
  {
    OZChannelBase::resetFlag((OZChannelBase *)(a1 + 1656), 0x400000, 1);
    uint64_t v5 = (OZChannelBase *)(a1 + 1656);
  }
  else
  {
    if (v7) {
      return result;
    }
    OZChannelBase::resetFlag((OZChannelBase *)(a1 + 1504), 0x400000, 1);
  }
LABEL_11:

  return OZChannelBase::setFlag(v5, 16, 1);
}

uint64_t PSPenPropertyBehavior::setIsInteractive(PSPenPropertyBehavior *this, int a2)
{
  *((unsigned char *)this + 2120) = a2;
  if (a2) {
    uint64_t result = OZMoShape::getPaintInteractiveValuesLock((OZMoShape *)(*((void *)this + 267) + 18976));
  }
  else {
    uint64_t result = 0;
  }
  *((void *)this + 266) = result;
  return result;
}

void PSPenPressureBehavior::PSPenPressureBehavior(PSPenPressureBehavior *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  PSPenPropertyBehavior::PSPenPropertyBehavior(this, a2, a3, a4);
  *(void *)uint64_t v5 = &unk_1F1195A88;
  *(void *)(v5 + 16) = &unk_1F1195D48;
  *(void *)(v5 + 48) = &unk_1F1195FA0;
  *(void *)(v5 + 336) = &unk_1F1195FF8;
  *(void *)(v5 + 2152) = 0;
  *(unsigned char *)(v5 + 2160) = 1;
  *(void *)(v5 + 2168) = 0;
  *(void *)(v5 + 2176) = 0x3FF0000000000000;
  PCURL::PCURL((PCURL *)&v6, @"Pen Pressure Behavior Min Pressure");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 1200), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Pen Pressure Behavior Max Pressure");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 1352), &v6, 0);
  PCString::~PCString(&v6);
}

void sub_1B7E07114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  PSPenPropertyBehavior::~PSPenPropertyBehavior(v10);
  _Unwind_Resume(a1);
}

void PSPenPressureBehavior::PSPenPressureBehavior(PSPenPressureBehavior *this, const PSPenPressureBehavior *a2, char a3)
{
  PSPenPropertyBehavior::PSPenPropertyBehavior(this, a2, a3);
  *(void *)uint64_t v4 = &unk_1F1195A88;
  *(void *)(v4 + 16) = &unk_1F1195D48;
  *(void *)(v4 + 48) = &unk_1F1195FA0;
  *(void *)(v4 + 336) = &unk_1F1195FF8;
  *(void *)(v4 + 2152) = 0;
  *(unsigned char *)(v4 + 2160) = *((unsigned char *)a2 + 2160);
  *(void *)(v4 + 2168) = *((void *)a2 + 271);
  *(void *)(v4 + 2176) = *((void *)a2 + 272);
}

void non-virtual thunk to'PSPenPressureBehavior::~PSPenPressureBehavior(PSPenPressureBehavior *this)
{
}

{
  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenPressureBehavior *)((char *)this - 48));
}

{
  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenPressureBehavior *)((char *)this - 336));
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenPressureBehavior *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenPressureBehavior *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenPressureBehavior *)((char *)this - 336));

  JUMPOUT(0x1BA9BFBA0);
}

void PSPenPressureBehavior::~PSPenPressureBehavior(PSPenPressureBehavior *this)
{
  PSPenPropertyBehavior::~PSPenPropertyBehavior(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PSPenPressureBehavior::setIsInteractive(PSPenPressureBehavior *this, int a2)
{
  *((unsigned char *)this + 2120) = a2;
  if (a2)
  {
    *((void *)this + 266) = OZMoShape::getPaintInteractiveValuesLock((OZMoShape *)(*((void *)this + 267) + 18976));
    uint64_t result = OZMoShape::getFreehandPaintPressures((OZMoShape *)(*((void *)this + 267) + 18976));
  }
  else
  {
    uint64_t result = 0;
    *((void *)this + 266) = 0;
  }
  *((void *)this + 269) = result;
  return result;
}

double PSPenPressureBehavior::getPenProperty(PSPenPressureBehavior *this, Float64 a2, int a3)
{
  if (*((unsigned char *)this + 2120))
  {
    PCString v6 = (PCMutex *)*((void *)this + 266);
    PCMutex::lock(v6);
    uint64_t v7 = **((void **)this + 269);
    int v8 = ((unint64_t)(*(void *)(*((void *)this + 269) + 8) - v7) >> 3) - 1;
    int v9 = vcvtmd_s64_f64(a2 + 0.0000001);
    if (v9 >= v8) {
      int v9 = ((unint64_t)(*(void *)(*((void *)this + 269) + 8) - v7) >> 3) - 1;
    }
    if (v9 + 1 < v8) {
      int v8 = v9 + 1;
    }
    if (a3) {
      double v10 = 1.0
    }
          - (*(double *)(v7 + 8 * v9)
           + (*(double *)(v7 + 8 * v8) - *(double *)(v7 + 8 * v9)) * (a2 - (double)v9));
    else {
      double v10 = *(double *)(v7 + 8 * v9) + (*(double *)(v7 + 8 * v8) - *(double *)(v7 + 8 * v9)) * (a2 - (double)v9);
    }
    if (v6) {
      PCMutex::unlock(v6);
    }
  }
  else
  {
    __n128 v11 = (OZChannel *)(*((void *)this + 267) + 29720);
    OZChannelAngleOverRange::getValueOverRangeAsDouble(v11, 0.0, a2);
    double v10 = v12;
    if (a3)
    {
      if (*((unsigned char *)this + 2160))
      {
        *((double *)this + 271) = OZChannel::getKeyframeMinValue(v11, 0);
        double KeyframeMaxValue = OZChannel::getKeyframeMaxValue(v11, 0);
        *((double *)this + 272) = KeyframeMaxValue;
        *((unsigned char *)this + 2160) = 0;
      }
      else
      {
        double KeyframeMaxValue = *((double *)this + 272);
      }
      return KeyframeMaxValue - (v10 - *((double *)this + 271));
    }
  }
  return v10;
}

void PSPenSpeedBehavior::PSPenSpeedBehavior(PSPenSpeedBehavior *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  PSPenPropertyBehavior::PSPenPropertyBehavior(this, a2, a3, a4);
  *(void *)uint64_t v5 = &unk_1F1196020;
  *(void *)(v5 + 16) = &unk_1F11962E0;
  *(void *)(v5 + 48) = &unk_1F1196538;
  *(void *)(v5 + 336) = &unk_1F1196590;
  *(_OWORD *)(v5 + 2152) = 0u;
  *(unsigned char *)(v5 + 2168) = 1;
  *(_OWORD *)(v5 + 2176) = xmmword_1B7E733E0;
  PCURL::PCURL((PCURL *)&v6, @"Pen Speed Behavior Min Speed");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 1200), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Pen Speed Behavior Max Speed");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 1352), &v6, 0);
  PCString::~PCString(&v6);
}

void sub_1B7E075CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  PSPenPropertyBehavior::~PSPenPropertyBehavior(v10);
  _Unwind_Resume(a1);
}

void PSPenSpeedBehavior::PSPenSpeedBehavior(PSPenSpeedBehavior *this, const PSPenSpeedBehavior *a2, char a3)
{
  PSPenPropertyBehavior::PSPenPropertyBehavior(this, a2, a3);
  *(void *)uint64_t v4 = &unk_1F1196020;
  *(void *)(v4 + 16) = &unk_1F11962E0;
  *(void *)(v4 + 48) = &unk_1F1196538;
  *(void *)(v4 + 336) = &unk_1F1196590;
  *(_OWORD *)(v4 + 2152) = 0u;
  *(unsigned char *)(v4 + 2168) = *((unsigned char *)a2 + 2168);
  *(_OWORD *)(v4 + 2176) = *((_OWORD *)a2 + 136);
}

void non-virtual thunk to'PSPenSpeedBehavior::~PSPenSpeedBehavior(PSPenSpeedBehavior *this)
{
}

{
  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenSpeedBehavior *)((char *)this - 48));
}

{
  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenSpeedBehavior *)((char *)this - 336));
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenSpeedBehavior *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenSpeedBehavior *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenSpeedBehavior *)((char *)this - 336));

  JUMPOUT(0x1BA9BFBA0);
}

void PSPenSpeedBehavior::~PSPenSpeedBehavior(PSPenSpeedBehavior *this)
{
  PSPenPropertyBehavior::~PSPenPropertyBehavior(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PSPenSpeedBehavior::setIsInteractive(PSPenSpeedBehavior *this, int a2)
{
  *((unsigned char *)this + 2120) = a2;
  if (a2)
  {
    *((void *)this + 266) = OZMoShape::getPaintInteractiveValuesLock((OZMoShape *)(*((void *)this + 267) + 18976));
    *((void *)this + 269) = OZMoShape::getFreehandPaintLengthAccums((OZMoShape *)(*((void *)this + 267) + 18976));
    uint64_t result = OZMoShape::getFreehandPaintTimes((OZMoShape *)(*((void *)this + 267) + 18976));
  }
  else
  {
    uint64_t result = 0;
    *((void *)this + 266) = 0;
    *((void *)this + 269) = 0;
  }
  *((void *)this + 270) = result;
  return result;
}

double PSPenSpeedBehavior::getPenProperty(PSPenSpeedBehavior *this, Float64 a2, int a3)
{
  if (!*((unsigned char *)this + 2120))
  {
    double v21 = (OZChannel *)(*((void *)this + 267) + 30328);
    OZChannelAngleOverRange::getValueOverRangeAsDouble(v21, 0.0, a2);
    double v18 = v22;
    if (a3)
    {
      if (*((unsigned char *)this + 2168))
      {
        *((double *)this + 272) = OZChannel::getKeyframeMinValue(v21, 0);
        double KeyframeMaxValue = OZChannel::getKeyframeMaxValue(v21, 0);
        *((double *)this + 273) = KeyframeMaxValue;
        *((unsigned char *)this + 2168) = 0;
      }
      else
      {
        double KeyframeMaxValue = *((double *)this + 273);
      }
      return KeyframeMaxValue - (v18 - *((double *)this + 272));
    }
    return v18;
  }
  signed int v6 = ((*(void *)(*((void *)this + 270) + 8) - **((void **)this + 270)) >> 3) - 1;
  signed int v7 = vcvtmd_s64_f64(a2 + 0.0000001);
  if (v7 >= v6) {
    int v8 = ((*(void *)(*((void *)this + 270) + 8) - **((void **)this + 270)) >> 3) - 1;
  }
  else {
    int v8 = v7;
  }
  if (v8)
  {
    int v9 = (PCMutex *)*((void *)this + 266);
    PCMutex::lock(v9);
    uint64_t v10 = **((void **)this + 270);
    uint64_t v11 = 8 * v8 - 8;
    uint64_t v12 = **((void **)this + 269);
    double v13 = *(double *)(v10 + 8 * v8) - *(double *)(v10 + v11);
    double v14 = 0.001;
    if (v13 < 0.001) {
      double v13 = 0.001;
    }
    double v15 = (*(double *)(v12 + 8 * v8) - *(double *)(v12 + v11)) / v13;
    if (v15 <= 500.0) {
      double v16 = v15 / 500.0;
    }
    else {
      double v16 = 1.0;
    }
    if (v8 + 1 < v6) {
      int v17 = v8 + 1;
    }
    else {
      int v17 = v6;
    }
    double v18 = 0.0;
    if (v17 == v8 || (double v19 = a2 - (double)v8, v19 > -0.0000001) && v19 < 0.0000001)
    {
      char v20 = 0;
      if (!v9) {
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v24 = 8 * v17 - 8;
      if (*(double *)(v10 + 8 * v17) - *(double *)(v10 + v24) >= 0.001) {
        double v14 = *(double *)(v10 + 8 * v17) - *(double *)(v10 + v24);
      }
      double v25 = (*(double *)(v12 + 8 * v17) - *(double *)(v12 + v24)) / v14;
      if (v25 <= 500.0) {
        double v26 = v25 / 500.0;
      }
      else {
        double v26 = 1.0;
      }
      double v27 = v16 + v19 * (v26 - v16);
      if (a3) {
        double v18 = 1.0 - v27;
      }
      else {
        double v18 = v27;
      }
      char v20 = 1;
      if (!v9)
      {
LABEL_33:
        if ((v20 & 1) == 0) {
          return v16;
        }
        return v18;
      }
    }
    PCMutex::unlock(v9);
    goto LABEL_33;
  }
  return 1.0;
}

void PSPenTiltBehavior::PSPenTiltBehavior(PSPenTiltBehavior *this, OZFactory *a2, const PCString *a3, unsigned int a4)
{
  PSPenPropertyBehavior::PSPenPropertyBehavior(this, a2, a3, a4);
  *uint64_t v5 = &unk_1F11965B8;
  v5[2] = &unk_1F1196878;
  v5[6] = &unk_1F1196AD0;
  v5[42] = &unk_1F1196B28;
  v5[269] = 0;
  PCURL::PCURL((PCURL *)&v6, @"Pen Tilt Behavior Min Tilt");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 1200), &v6, 0);
  PCString::~PCString(&v6);
  PCURL::PCURL((PCURL *)&v6, @"Pen Tilt Behavior Max Tilt");
  OZChannelBase::setName((OZChannelBase *)((char *)this + 1352), &v6, 0);
  PCString::~PCString(&v6);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 792), 2, 0);
  (*(void (**)(char *))(*((void *)this + 99) + 128))((char *)this + 792);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1048), 2, 0);
  (*(void (**)(char *))(*((void *)this + 131) + 128))((char *)this + 1048);
}

void sub_1B7E07BD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  PSPenPropertyBehavior::~PSPenPropertyBehavior(v10);
  _Unwind_Resume(a1);
}

void PSPenTiltBehavior::PSPenTiltBehavior(PSPenTiltBehavior *this, const PSPenTiltBehavior *a2, char a3)
{
  PSPenPropertyBehavior::PSPenPropertyBehavior(this, a2, a3);
  void *v3 = &unk_1F11965B8;
  v3[2] = &unk_1F1196878;
  v3[6] = &unk_1F1196AD0;
  v3[42] = &unk_1F1196B28;
  v3[269] = 0;
}

void non-virtual thunk to'PSPenTiltBehavior::~PSPenTiltBehavior(PSPenTiltBehavior *this)
{
}

{
  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenTiltBehavior *)((char *)this - 48));
}

{
  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenTiltBehavior *)((char *)this - 336));
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenTiltBehavior *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenTiltBehavior *)((char *)this - 48));

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  PSPenPropertyBehavior::~PSPenPropertyBehavior((PSPenTiltBehavior *)((char *)this - 336));

  JUMPOUT(0x1BA9BFBA0);
}

void PSPenTiltBehavior::~PSPenTiltBehavior(PSPenTiltBehavior *this)
{
  PSPenPropertyBehavior::~PSPenPropertyBehavior(this);

  JUMPOUT(0x1BA9BFBA0);
}

BOOL PSPenTiltBehavior::isRebuildUIChannel(PSPenTiltBehavior *this, OZChannelBase *a2)
{
  return (OZChannelBase *)((char *)this + 536) == a2 || (OZChannelBase *)((char *)this + 792) == a2;
}

OZChannelBase *PSPenTiltBehavior::updateHiddenFlags(uint64_t a1, uint64_t a2)
{
  PSPenPropertyBehavior::updateHiddenFlags(a1, a2);
  uint64_t v4 = (const CMTime *)MEMORY[0x1E4F1FA48];
  uint64_t v5 = a2;
  while (1)
  {
    uint64_t v5 = *(void *)(v5 + 8);
    if (v5 == a2) {
      break;
    }
    PCString v6 = *(char **)(v5 + 16);
    if (v6) {
    if (OZChannel::getValueAsInt((OZChannel *)(v6 + 792), v4, 0.0) == 3)
    }
    {
      return OZChannelBase::resetFlag((OZChannelBase *)(a1 + 1048), 0x400000, 1);
    }
  }

  return OZChannelBase::setFlag((OZChannelBase *)(a1 + 1048), 0x400000, 1);
}

uint64_t PSPenTiltBehavior::setIsInteractive(PSPenTiltBehavior *this, int a2)
{
  *((unsigned char *)this + 2120) = a2;
  if (a2)
  {
    *((void *)this + 266) = OZMoShape::getPaintInteractiveValuesLock((OZMoShape *)(*((void *)this + 267) + 18976));
    uint64_t result = OZMoShape::getFreehandPaintTilts((OZMoShape *)(*((void *)this + 267) + 18976));
  }
  else
  {
    uint64_t result = 0;
    *((void *)this + 266) = 0;
  }
  *((void *)this + 269) = result;
  return result;
}

void PSPenTiltBehavior::getPenProperty(PSPenTiltBehavior *this, double a2)
{
  switch(OZChannel::getValueAsInt((OZChannel *)((char *)this + 792), MEMORY[0x1E4F1FA48], 0.0))
  {
    case 0u:
      PSPenTiltBehavior::getAbsoluteTilt(this, a2);
      break;
    case 1u:
    case 2u:
      uint64_t v5 = 0;
      double v6 = 0.0;
      PSPenTiltBehavior::getPenTilt(this, v4, a2, &v6, (double *)&v5);
      break;
    case 3u:
      PSPenTiltBehavior::getTiltAlongAxis(this, a2);
      break;
    case 4u:
      PSPenTiltBehavior::getTiltPolar(this, a2);
      break;
    default:
      return;
  }
}

void PSPenTiltBehavior::getAbsoluteTilt(PSPenTiltBehavior *this, double a2)
{
  double v6 = 0.0;
  long double v7 = 0.0;
  PSPenTiltBehavior::getPenTilt(this, a2, a2, &v7, &v6);
  long double v3 = v6;
  long double v2 = v7;
  if (v7 <= -0.0000001 || v7 >= 0.0000001 || v6 <= -0.0000001 || v6 >= 0.0000001)
  {
    hypot(v7, v6);
    long double v4 = atan2(v3, v2);
    double v5 = fmod(v4, 1.57079633);
    if (v5 > 0.785398163) {
      double v5 = 1.57079633 - v5;
    }
    cos(v5);
  }
}

void PSPenTiltBehavior::getPenTilt(PSPenTiltBehavior *this, double a2, Float64 a3, double *a4, double *a5)
{
  if (*((unsigned char *)this + 2120))
  {
    int v9 = (PCMutex *)*((void *)this + 266);
    PCMutex::lock(v9);
    uint64_t v10 = **((void **)this + 269);
    int v11 = ((unint64_t)(*(void *)(*((void *)this + 269) + 8) - v10) >> 4) - 1;
    int v12 = vcvtmd_s64_f64(a3 + 0.0000001);
    if (v12 >= v11) {
      int v12 = ((unint64_t)(*(void *)(*((void *)this + 269) + 8) - v10) >> 4) - 1;
    }
    if (v12 + 1 < v11) {
      int v11 = v12 + 1;
    }
    double v13 = (double *)(v10 + 16 * v12);
    double v14 = v13[1];
    double v15 = (double *)(v10 + 16 * v11);
    double v16 = v15[1];
    Float64 v17 = a3 - (double)v12;
    *a4 = *v13 + (*v15 - *v13) * v17;
    *a5 = v14 + (v16 - v14) * v17;
    if (v9) {
      PCMutex::unlock(v9);
    }
  }
  else
  {
    double v18 = (OZChannel2DOverRange *)(*((void *)this + 267) + 29880);
    OZChannel2DOverRange::getValueOverRange(v18, 0.0, a3, a4, a5);
  }
}

void PSPenTiltBehavior::getTiltAlongAxis(PSPenTiltBehavior *this, double a2)
{
  double v9 = 0.0;
  long double v10 = 0.0;
  PSPenTiltBehavior::getPenTilt(this, a2, a2, &v10, &v9);
  if (v10 <= -0.0000001 || v10 >= 0.0000001 || v9 <= -0.0000001 || v9 >= 0.0000001)
  {
    OZChannel::getValueAsDouble((OZChannel *)((char *)this + 1048), MEMORY[0x1E4F1FA48], 0.0);
    long double v4 = v3;
    long double v5 = v9;
    long double v6 = v10;
    long double v7 = atan2(v9, v10);
    cos(v7 - v4);
    hypot(v6, v5);
    double v8 = fmod(v4, 1.57079633);
    if (v8 > 0.785398163) {
      double v8 = 1.57079633 - v8;
    }
    cos(v8);
  }
}

double PSPenTiltBehavior::getTiltPolar(PSPenTiltBehavior *this, double a2)
{
  double v5 = 0.0;
  long double v6 = 0.0;
  PSPenTiltBehavior::getPenTilt(this, a2, a2, &v6, &v5);
  double v2 = 0.0;
  if (v6 * v6 + v5 * v5 >= 0.01)
  {
    double v3 = atan2(v5, v6);
    if (v3 < 0.0) {
      double v3 = v3 + 6.28318531;
    }
    return v3 / 6.28318531;
  }
  return v2;
}

uint64_t PSPenPressureBehavior::getDefaultApplyTo(PSPenPressureBehavior *this)
{
  uint64_t v1 = (OZPreferenceManager *)OZPreferenceManager::Instance(this);

  return OZPreferenceManager::getStrokeApplyPenPressureTo(v1);
}

uint64_t PSPenSpeedBehavior::getDefaultApplyTo(PSPenSpeedBehavior *this)
{
  uint64_t v1 = (OZPreferenceManager *)OZPreferenceManager::Instance(this);

  return OZPreferenceManager::getStrokeApplyPenSpeedTo(v1);
}

void PSEmitterRender::PSEmitterRender(PSEmitterRender *this, PSEmitter *a2, const OZRenderParams *a3)
{
  *((void *)this + 184) = &unk_1F1199AC8;
  *((void *)this + 185) = 0;
  *((unsigned char *)this + 1488) = 1;
  LiImageSource::LiImageSource((LiImageSource *)this, (uint64_t *)&off_1F1196C88);
  *(void *)this = &unk_1F1196BA0;
  *((void *)this + 184) = &unk_1F1196C68;
  *((void *)this + 2) = a2;
  OZRenderParams::OZRenderParams((PSEmitterRender *)((char *)this + 24), a3);
  *((void *)this + 182) = 0;
  *((unsigned char *)this + 1464) = 0;
  *((unsigned char *)this + 1448) = OZChannel::getValueAsInt((OZChannel *)(*((void *)this + 2) + 32792), MEMORY[0x1E4F1FA48], 0.0) != 0;
}

void sub_1B7E084C4(_Unwind_Exception *a1)
{
  OZRenderParams::~OZRenderParams(v3);
  OZChannelBase::setRangeName((OZChannelBase *)v1, (const PCString *)&off_1F1196C88);
  *(void *)(v1 + 1472) = v2;
  *(unsigned char *)(v1 + 1488) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 1480));
  _Unwind_Resume(a1);
}

uint64_t PSEmitterRender::getBoundary(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 1448))
  {
    (*(void (**)(unsigned char *__return_ptr))(***(void ***)(a2 + 48) + 280))(v7);
    long long v4 = *(_OWORD *)&v7[16];
    *(_OWORD *)a3 = *(_OWORD *)v7;
    *(_OWORD *)(a3 + 16) = v4;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 16);
    uint64_t v14 = 0x3FF0000000000000;
    uint64_t v11 = 0x3FF0000000000000;
    uint64_t v8 = 0x3FF0000000000000;
    *(void *)long double v7 = 0x3FF0000000000000;
    memset(&v7[8], 0, 32);
    long long v9 = 0u;
    long long v10 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    PSEmitter::getRenderBounds(v5, (float64x2_t *)a3, (CMTime *)(a1 + 24), v7);
  }
  return 1;
}

double PSEmitterRender::fixPixelTransform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 1448) || !OZRenderParams::getDoHighQualityResampling((OZRenderParams *)(a1 + 24)))
  {
    return LiImageSource::fixPixelTransform(a1, a2, a3, a4);
  }
  else
  {
    OZRenderParams::getResolution((OZRenderParams *)(a1 + 24), &v10);
    unint64_t v8 = v10.n128_u64[1];
    *(void *)a3 = v10.n128_u64[0];
    double result = 0.0;
    *(_OWORD *)(a3 + 8) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
    *(void *)(a3 + 40) = v8;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 80) = 0x3FF0000000000000;
    *(_OWORD *)(a3 + 88) = 0u;
    *(_OWORD *)(a3 + 104) = 0u;
    *(void *)(a3 + 120) = 0x3FF0000000000000;
  }
  return result;
}

uint64_t PSEmitterRender::pixelTransformSupport(PSEmitterRender *this, const LiRenderParameters *a2)
{
  uint64_t v2 = 6;
  if (!*((unsigned char *)this + 1448))
  {
    if (OZRenderParams::getDoHighQualityResampling((PSEmitterRender *)((char *)this + 24))) {
      return 0;
    }
    else {
      return 6;
    }
  }
  return v2;
}

CGColorSpace **PSEmitterRender::getHelium@<X0>(PSEmitterRender *this@<X0>, LiAgent *a2@<X1>, PSHeliumNode **a3@<X8>)
{
  RequestedColorDescription = (const FxColorDescription *)LiAgent::getRequestedColorDescription(a2);
  WorkingColorSpace = (CGColorSpace *)OZRenderParams::getWorkingColorSpace((FxColorDescription *)((char *)this + 24));
  FxColorDescription::FxColorDescription(&v9, RequestedColorDescription, WorkingColorSpace);
  OZRenderParams::setWorkingColorDescription((CGColorSpace **)this + 3, &v9);
  PSEmitter::getHelium(*((PSEmitter **)this + 2), (CMTime *)this + 1, a2, a3);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v9._pcColorDesc._colorSpaceRef._obj);
}

void sub_1B7E08760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGColorSpace *a9)
{
}

uint64_t PSEmitterRender::estimateRenderMemory(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1464)) {
    return *(void *)(a1 + 1456);
  }
  uint64_t v12 = 0x3FF0000000000000;
  uint64_t v9 = 0x3FF0000000000000;
  uint64_t v6 = 0x3FF0000000000000;
  uint64_t v3 = 0x3FF0000000000000;
  long long v4 = 0u;
  long long v5 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  uint64_t result = PSEmitter::estimateRenderMemory(*(void *)(a1 + 16), (CMTime *)(a1 + 24), &v3);
  *(void *)(a1 + 1456) = result;
  *(unsigned char *)(a1 + 1464) = 1;
  return result;
}

void PSEmitterRender::~PSEmitterRender(PSEmitterRender *this)
{
  *(void *)this = &unk_1F1196BA0;
  *((void *)this + 184) = &unk_1F1196C68;
  OZRenderParams::~OZRenderParams((PSEmitterRender *)((char *)this + 24));
  OZChannelBase::setRangeName((OZChannelBase *)this, (const PCString *)&off_1F1196C88);
  *((void *)this + 184) = &unk_1F1199AC8;
  *((unsigned char *)this + 1488) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 185);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F1196BA0;
  *((void *)this + 184) = &unk_1F1196C68;
  OZRenderParams::~OZRenderParams((PSEmitterRender *)((char *)this + 24));
  OZChannelBase::setRangeName((OZChannelBase *)this, (const PCString *)&off_1F1196C88);
  *((void *)this + 184) = &unk_1F1199AC8;
  *((unsigned char *)this + 1488) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 185);

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'PSEmitterRender::~PSEmitterRender(PSEmitterRender *this)
{
  uint64_t v1 = (char *)this + *(void *)(*(void *)this - 24);
  *(void *)uint64_t v1 = &unk_1F1196BA0;
  *((void *)v1 + 184) = &unk_1F1196C68;
  OZRenderParams::~OZRenderParams((OZRenderParams *)(v1 + 24));
  OZChannelBase::setRangeName((OZChannelBase *)v1, (const PCString *)&off_1F1196C88);
  *((void *)v1 + 184) = &unk_1F1199AC8;
  v1[1488] = 0;

  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)v1 + 185);
}

{
  char *v1;
  uint64_t vars8;

  uint64_t v1 = (char *)this + *(void *)(*(void *)this - 24);
  *(void *)uint64_t v1 = &unk_1F1196BA0;
  *((void *)v1 + 184) = &unk_1F1196C68;
  OZRenderParams::~OZRenderParams((OZRenderParams *)(v1 + 24));
  OZChannelBase::setRangeName((OZChannelBase *)v1, (const PCString *)&off_1F1196C88);
  *((void *)v1 + 184) = &unk_1F1199AC8;
  v1[1488] = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)v1 + 185);

  JUMPOUT(0x1BA9BFBA0);
}

void PSImageTint::PSImageTint(PSImageTint *this)
{
  *((void *)this + 7) = &unk_1F1199AC8;
  *((void *)this + 8) = 0;
  *((unsigned char *)this + 72) = 1;
  LiImageFilter::LiImageFilter(this, (uint64_t *)&off_1F1196F40);
  *(void *)this = &unk_1F1196E38;
  *((void *)this + 7) = &unk_1F1196F20;
  PCWorkingColorVector::PCWorkingColorVector((PSImageTint *)((char *)this + 36));
}

void sub_1B7E08B90(_Unwind_Exception *a1)
{
  LiImageFilter::~LiImageFilter((PCSharedCount *)v1, (const PCString *)&off_1F1196F40);
  *(void *)(v1 + 56) = v3;
  *(unsigned char *)(v1 + 72) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void PSImageTint::~PSImageTint(PCSharedCount *this)
{
  *(void *)(v1 + 56) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 72) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 64));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 56) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 72) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 64));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'PSImageTint::~PSImageTint(PSImageTint *this)
{
  *(void *)(v1 + 56) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 72) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 64);

  PCWeakCount::~PCWeakCount(v2);
}

{
  PSImageTint::~PSImageTint((PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24)));
}

void PSImageTint::clone(PSImageTint *this)
{
}

void sub_1B7E08E14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
  PCSharedCount::~PCSharedCount(&a12);
  PCSharedCount::~PCSharedCount(v12);
  _Unwind_Resume(a1);
}

void PSImageTint::getHelium(PSImageTint *this@<X0>, LiAgent *a2@<X1>, HgcPSImageTint **a3@<X8>)
{
  *((_DWORD *)a2 + 8) = 2;
  uint64_t v6 = (LiImageSource *)*((void *)this + 2);
  CGColorSpace = (CGColorSpace *)FxColorDescription::getCGColorSpace((FxColorDescription *)(*((void *)a2 + 6) + 160));
  LiAgent::getHeliumInColorSpace(a2, v6, CGColorSpace, &v9);
  if (v9)
  {
    long long v8 = (HgcPSImageTint *)HGObject::operator new(0x200uLL);
    HgcPSImageTint::HgcPSImageTint(v8);
    (*(void (**)(HgcPSImageTint *, void, float, float, float, float))(*(void *)v8 + 96))(v8, 0, *((float *)this + 9), *((float *)this + 10), *((float *)this + 11), *((float *)this + 12));
    (*(void (**)(HgcPSImageTint *, void, uint64_t))(*(void *)v8 + 120))(v8, 0, v9);
    *a3 = v8;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
    }
  }
  else
  {
    *a3 = 0;
  }
}

void sub_1B7E08F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  HGObject::operator delete(v10);
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(a1);
}

PCShared_base **PCPtr<OZGLGradientRadial>::operator=<OZGLGradientRadial>(PCShared_base **a1, PCShared_base *a2)
{
  long long v8 = a2;
  if (a2) {
    a2 = (PCShared_base *)((char *)a2 + *(void *)(*(void *)a2 - 24));
  }
  PCSharedCount::PCSharedCount(&v9, a2);
  uint64_t v3 = v8;
  *a1 = v8;
  if (v3)
  {
    PCSharedCount::PCSharedCount(&v6, &v9);
    long long v4 = &v6;
    PCSharedCount::operator=((uint64_t *)a1 + 1, (uint64_t *)&v6);
  }
  else
  {
    PCSharedCount::PCSharedCount(&v7);
    long long v4 = &v7;
    PCSharedCount::operator=((uint64_t *)a1 + 1, (uint64_t *)&v7);
  }
  PCSharedCount::~PCSharedCount(v4);
  PCSharedCount::~PCSharedCount(&v9);
  return a1;
}

void sub_1B7E090B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCSharedCount::~PCSharedCount((PCSharedCount *)va);
  PCSharedCount::~PCSharedCount(v2);
  _Unwind_Resume(a1);
}

void PSGradDabRender::PSGradDabRender(PSGradDabRender *this, OZChannelGradient *a2, const OZRenderParams *a3)
{
  *((void *)this + 181) = &unk_1F1199AC8;
  *((void *)this + 182) = 0;
  *((unsigned char *)this + 1464) = 1;
  LiImageSource::LiImageSource((LiImageSource *)this, (uint64_t *)&off_1F1197300);
  *(void *)this = &unk_1F1197218;
  *((void *)this + 181) = &unk_1F11972E0;
  OZRenderParams::OZRenderParams((PSGradDabRender *)((char *)this + 16), a3);
  *((void *)this + 180) = 0;
  PCSharedCount v6 = (PSHeliumNode *)HGObject::operator new(0x390uLL);
  PSHeliumNode::PSHeliumNode(v6, a3);
  PCSharedCount v7 = (PSHeliumNode *)*((void *)this + 180);
  if (v7 == v6)
  {
    if (v6) {
      (*(void (**)(PSHeliumNode *))(*(void *)v6 + 24))(v6);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(PSHeliumNode *))(*(void *)v7 + 24))(v7);
    }
    *((void *)this + 180) = v6;
  }
  if (*(_DWORD *)(*(void *)HGRenderJob::GetRenderNodeList((HGRenderJob *)a3) + 8))
  {
    if (LiRenderingTechnology::getEnableMetalRendering((const OZRenderParams *)((char *)a3 + 1316)))
    {
      PCSharedCount::PCSharedCount((PCSharedCount *)&v9);
      operator new();
    }
    PCSharedCount::PCSharedCount((PCSharedCount *)&v9);
    operator new();
  }
  long long v8 = (PSHeliumNode *)*((void *)this + 180);
  CMTime v10 = *(CMTime *)a3;
  PSHeliumNode::initGradient(v8, a2, &v10);
}

void sub_1B7E094C0(_Unwind_Exception *a1)
{
  uint64_t v5 = *(void *)(v1 + 1440);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  OZRenderParams::~OZRenderParams(v3);
  OZChannelBase::setRangeName((OZChannelBase *)v1, (const PCString *)&off_1F1197300);
  *(void *)(v1 + 1448) = v2;
  *(unsigned char *)(v1 + 1464) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 1456));
  _Unwind_Resume(a1);
}

void PSGradDabRender::~PSGradDabRender(OZChannelBase *this, const PCString *a2)
{
  $3CC8671D27C23BF42ADDB32F2B5E48AE var0 = a2->var0;
  this->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = (void **)a2->var0;
  *(PCString *)((char *)&this->var0 + var0[-1].info) = a2[5];
  var12 = this[12].var12;
  if (var12) {
    (*((void (**)(__CFString *))var12->isa + 3))(var12);
  }
  OZRenderParams::~OZRenderParams((OZRenderParams *)&this->var2);

  OZChannelBase::setRangeName(this, a2 + 1);
}

void PSGradDabRender::~PSGradDabRender(OZChannelBase *this)
{
  *(void *)(v1 + 1448) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 1464) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 1456));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 1448) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 1464) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 1456));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'PSGradDabRender::~PSGradDabRender(PSGradDabRender *this)
{
  *(void *)(v1 + 1448) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 1464) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 1456);

  PCWeakCount::~PCWeakCount(v2);
}

{
  PSGradDabRender::~PSGradDabRender((OZChannelBase *)((char *)this + *(void *)(*(void *)this - 24)));
}

uint64_t PSGradDabRender::getBoundary(uint64_t a1, uint64_t a2, double *a3)
{
  BOOL v3 = *(unsigned char *)(a1 + 218) == 0;
  double v4 = 128.0;
  if (*(unsigned char *)(a1 + 218)) {
    double v4 = 18.0;
  }
  double v5 = -v4;
  *a3 = v5;
  a3[1] = v5;
  double v6 = 36.0;
  if (v3) {
    double v6 = 256.0;
  }
  a3[2] = v6;
  a3[3] = v6;
  return 1;
}

uint64_t PSGradDabRender::getHelium@<X0>(PSGradDabRender *this@<X0>, LiAgent *a2@<X1>, void *a3@<X8>)
{
  PSHeliumNode::preRender(*((void *)this + 180));
  uint64_t v6 = *((void *)this + 180);
  *a3 = v6;
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
    uint64_t v7 = *((void *)this + 180);
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
    }
  }
  *((void *)this + 180) = 0;
  CGColorSpace = (CGColorSpace *)FxColorDescription::getCGColorSpace((FxColorDescription *)(*((void *)a2 + 6) + 160));
  return LiAgent::setActualColorSpace(a2, CGColorSpace);
}

void sub_1B7E09930(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t PSGradDabRender::estimateRenderMemory()
{
  return 0;
}

void PSSolidDabRender::PSSolidDabRender(PSSolidDabRender *this, const OZRenderParams *a2)
{
  *((void *)this + 180) = &unk_1F1199AC8;
  *((void *)this + 181) = 0;
  *((unsigned char *)this + 1456) = 1;
  LiImageSource::LiImageSource((LiImageSource *)this, (uint64_t *)&off_1F1197598);
  *(void *)this = &unk_1F11974B0;
  *((void *)this + 180) = &unk_1F1197578;
  OZRenderParams::OZRenderParams((PSSolidDabRender *)((char *)this + 16), a2);
}

void sub_1B7E09A2C(_Unwind_Exception *a1)
{
  OZChannelBase::setRangeName((OZChannelBase *)v1, (const PCString *)&off_1F1197598);
  *(void *)(v1 + 1440) = v2;
  *(unsigned char *)(v1 + 1456) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 1448));
  _Unwind_Resume(a1);
}

void PSSolidDabRender::~PSSolidDabRender(OZChannelBase *this, const PCString *a2)
{
  $3CC8671D27C23BF42ADDB32F2B5E48AE var0 = a2->var0;
  this->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = (void **)a2->var0;
  *(PCString *)((char *)&this->var0 + var0[-1].info) = a2[5];
  OZRenderParams::~OZRenderParams((OZRenderParams *)&this->var2);

  OZChannelBase::setRangeName(this, a2 + 1);
}

void PSSolidDabRender::~PSSolidDabRender(OZChannelBase *this)
{
  *(void *)(v1 + 1440) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 1456) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 1448));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 1440) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 1456) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 1448));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'PSSolidDabRender::~PSSolidDabRender(PSSolidDabRender *this)
{
  *(void *)(v1 + 1440) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 1456) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 1448);

  PCWeakCount::~PCWeakCount(v2);
}

{
  PSSolidDabRender::~PSSolidDabRender((OZChannelBase *)((char *)this + *(void *)(*(void *)this - 24)));
}

uint64_t PSSolidDabRender::getBoundary(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __asm { FMOV            V0.2D, #-18.0 }
  *(_OWORD *)a3 = _Q0;
  *(int64x2_t *)(a3 + 16) = vdupq_n_s64(0x4042000000000000uLL);
  return 1;
}

uint64_t PSSolidDabRender::getHelium@<X0>(PSSolidDabRender *this@<X0>, LiAgent *a2@<X1>, PSHeliumNode **a3@<X8>)
{
  uint64_t v6 = (PSSolidDabRender *)((char *)this + 16);
  uint64_t v7 = (PSHeliumNode *)HGObject::operator new(0x390uLL);
  PSHeliumNode::PSHeliumNode(v7, v6);
  OZRenderParams::getResolution(v6, &v20);
  int v8 = *((unsigned __int8 *)this + 218);
  uint64_t v30 = 0x3FF0000000000000;
  uint64_t v26 = 0;
  uint64_t v27 = 0x3FF0000000000000;
  long long v28 = 0u;
  long long v29 = 0u;
  double v9 = v20.n128_f64[0] * 36.0;
  if (!v8) {
    double v9 = 256.0;
  }
  double v21 = 0.0;
  __n128 v20 = (__n128)0x3FF0000000000000uLL;
  long long v22 = xmmword_1B7E73B80;
  long long v23 = xmmword_1B7E733D0;
  double v24 = 0.5;
  uint64_t v25 = 0;
  if (v9 != 1.0)
  {
    v20.n128_f64[0] = v9;
    v20.n128_f64[1] = v9 * 0.0;
    double v21 = v9 * 0.0;
    *(double *)&long long v22 = v9 * 0.5;
    *((double *)&v22 + 1) = v9 * 0.0;
    *(double *)&long long v23 = v9;
    *((double *)&v23 + 1) = v9 * 0.0;
    double v24 = v9 * 0.5;
  }
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)&v19, 1.0, 1.0, 1.0, 1.0);
  __asm
  {
    FMOV            V0.2D, #-0.5
    FMOV            V1.2D, #1.0
  }
  v18[0] = _Q0;
  v18[1] = _Q1;
  PSHeliumNode::addCircleParticle((uint64_t)v7, (uint64_t *)&v20, (double *)v18, &v19, 0);
  PSHeliumNode::preRender((uint64_t)v7);
  CGColorSpace = (CGColorSpace *)FxColorDescription::getCGColorSpace((FxColorDescription *)(*((void *)a2 + 6) + 160));
  uint64_t result = LiAgent::setActualColorSpace(a2, CGColorSpace);
  *a3 = v7;
  return result;
}

void sub_1B7E09DFC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t PSSolidDabRender::estimateRenderMemory()
{
  return 0;
}

void QuadNode::~QuadNode(QuadNode *this)
{
  for (uint64_t i = 8; i != 40; i += 8)
  {
    BOOL v3 = *(QuadNode **)((char *)this + i);
    if (v3)
    {
      QuadNode::~QuadNode(v3);
      MEMORY[0x1BA9BFBA0]();
    }
    *(void *)((char *)this + i) = 0;
  }
  double v4 = (void *)*((void *)this + 9);
  if (v4)
  {
    *((void *)this + 10) = v4;
    operator delete(v4);
  }
}

void QuadNode::insert(QuadNode *this, PSHeliumNode::Sprite *a2)
{
  double v4 = (double *)((char *)this + 40);
  double v5 = (double *)((char *)a2 + 160);
  if (PCRect<double>::intersects((double *)this + 5, (double *)a2 + 20))
  {
    if (PCRect<double>::contains(v5, v4) || *((double *)this + 7) < 64.0 || *((double *)this + 8) < 64.0)
    {
      unint64_t v6 = *((void *)this + 11);
      uint64_t v7 = (void *)*((void *)this + 10);
      if ((unint64_t)v7 >= v6)
      {
        uint64_t v9 = *((void *)this + 9);
        uint64_t v10 = ((uint64_t)v7 - v9) >> 3;
        if ((unint64_t)(v10 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v11 = v6 - v9;
        uint64_t v12 = v11 >> 2;
        if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
          uint64_t v12 = v10 + 1;
        }
        if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v13 = v12;
        }
        if (v13) {
          uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 88, v13);
        }
        else {
          uint64_t v14 = 0;
        }
        double v15 = &v14[8 * v10];
        double v16 = &v14[8 * v13];
        *(void *)double v15 = a2;
        int v8 = v15 + 8;
        double v18 = (char *)*((void *)this + 9);
        Float64 v17 = (char *)*((void *)this + 10);
        if (v17 != v18)
        {
          do
          {
            uint64_t v19 = *((void *)v17 - 1);
            v17 -= 8;
            *((void *)v15 - 1) = v19;
            v15 -= 8;
          }
          while (v17 != v18);
          Float64 v17 = (char *)*((void *)this + 9);
        }
        *((void *)this + 9) = v15;
        *((void *)this + 10) = v8;
        *((void *)this + 11) = v16;
        if (v17) {
          operator delete(v17);
        }
      }
      else
      {
        *uint64_t v7 = a2;
        int v8 = v7 + 1;
      }
      *((void *)this + 10) = v8;
    }
    else
    {
      if (!*((void *)this + 1)) {
        operator new();
      }
      uint64_t v20 = 0;
      double v21 = (char *)this + 8;
      do
      {
        QuadNode::insert(*(QuadNode **)&v21[v20], a2);
        v20 += 8;
      }
      while (v20 != 32);
    }
  }
}

uint64_t *QuadNode::getSprites(uint64_t a1, double *a2, uint64_t a3)
{
  uint64_t result = (uint64_t *)PCRect<double>::intersects((double *)(a1 + 40), a2);
  if (result)
  {
    uint64_t v7 = *(uint64_t **)(a1 + 72);
    for (uint64_t i = *(uint64_t **)(a1 + 80); v7 != i; ++v7)
      uint64_t result = std::__tree<PSHeliumNode::Sprite *,PSHeliumNode::lessThanSprite,std::allocator<PSHeliumNode::Sprite *>>::__emplace_hint_unique_key_args<PSHeliumNode::Sprite *,PSHeliumNode::Sprite * const&>((uint64_t **)a3, (void *)(a3 + 8), (uint64_t)v7, v7);
    if (*(void *)(a1 + 8))
    {
      uint64_t v9 = 0;
      uint64_t v10 = a1 + 8;
      do
      {
        uint64_t result = (uint64_t *)QuadNode::getSprites(*(void *)(v10 + v9), a2, a3);
        v9 += 8;
      }
      while (v9 != 32);
    }
  }
  return result;
}

void PSHeliumNode::PSHeliumNode(PSHeliumNode *this, const OZRenderParams *a2)
{
  HGNode::HGNode((HGNode *)this);
  v3->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = (PC_Sp_counted_base *)&unk_1F1197740;
  v3[55].$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0;
  PCSharedCount::PCSharedCount(v3 + 56);
  *((void *)this + 57) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 58);
  *((void *)this + 68) = 0;
  *((void *)this + 67) = 0;
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((void *)this + 66) = (char *)this + 536;
  *((void *)this + 71) = 0;
  *((void *)this + 70) = 0;
  *((void *)this + 69) = (char *)this + 560;
  *((void *)this + 74) = 0;
  *((void *)this + 76) = 0;
  *((void *)this + 75) = 0;
  *((void *)this + 73) = (char *)this + 592;
  *((void *)this + 78) = 0;
  *((void *)this + 77) = 0;
  LiClipSet::LiClipSet((PSHeliumNode *)((char *)this + 632));
  *((void *)this + 100) = 0x3FF0000000000000;
  *((void *)this + 95) = 0x3FF0000000000000;
  *((void *)this + 90) = 0x3FF0000000000000;
  *((void *)this + 85) = 0x3FF0000000000000;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *(_OWORD *)((char *)this + 728) = 0u;
  *(_OWORD *)((char *)this + 744) = 0u;
  *((_OWORD *)this + 48) = 0u;
  *((_OWORD *)this + 49) = 0u;
  *(_OWORD *)((char *)this + 808) = 0u;
  *((void *)this + 103) = 0xBFF0000000000000;
  *((void *)this + 104) = 0xBFF0000000000000;
  *((_DWORD *)this + 3) = 72886678;
  (*(void (**)(PSHeliumNode *, uint64_t, uint64_t))(*(void *)this + 136))(this, 0xFFFFFFFFLL, 33);
  (*(void (**)(PSHeliumNode *, uint64_t, uint64_t))(*(void *)this + 136))(this, 0xFFFFFFFFLL, 1024);
  (*(void (**)(PSHeliumNode *, uint64_t, uint64_t))(*(void *)this + 136))(this, 0xFFFFFFFFLL, 512);
  operator new();
}

void sub_1B7E0A424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  a10 = (void **)(v10 + 608);
  std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::__tree<std::shared_ptr<PCImage>>::destroy(v10 + 584, *(void **)(v10 + 592));
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v10 + 552, *(void **)(v10 + 560));
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v10 + 528, *(void **)(v10 + 536));
  uint64_t v14 = *(void **)(v10 + 504);
  if (v14)
  {
    *(void *)(v10 + 512) = v14;
    operator delete(v14);
  }
  a10 = (void **)(v10 + 480);
  std::vector<PSHeliumNode::Sprite>::__destroy_vector::operator()[abi:ne180100](&a10);
  PCSharedCount::~PCSharedCount(v12);
  PCSharedCount::~PCSharedCount(v11);
  HGNode::~HGNode((HGNode *)v10);
  _Unwind_Resume(a1);
}

void PSHeliumNode::~PSHeliumNode(PCSharedCount *this)
{
  this->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = (PC_Sp_counted_base *)&unk_1F1197740;
  $3CC8671D27C23BF42ADDB32F2B5E48AE var0 = this[51].var0;
  if (var0) {
    MEMORY[0x1BA9BFBA0](var0, 0xC400A2AC0F1);
  }
  BOOL v3 = this[59].var0;
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8052888210);
  }
  this[59].$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0;
  double v4 = (QuadNode *)this[105].var0;
  if (v4)
  {
    QuadNode::~QuadNode(v4);
    double v4 = (QuadNode *)MEMORY[0x1BA9BFBA0]();
  }
  this[105].$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = 0;
  double v5 = this[109].var0;
  if (v5) {
    atomic_fetch_add(&gBitmapCacheSize, -(uint64_t)v5);
  }
  uint64_t v6 = PSTextureCache::Instance(v4);
  PSTextureCache::removeTextures(v6, &this[73].var0);
  GLuint v7 = (GLuint)this[110].var0;
  if (v7) {
    glDeleteProgram(v7);
  }
  LiClipSet::~LiClipSet((LiClipSet *)&this[79]);
  uint64_t v9 = this + 76;
  std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v9);
  std::__tree<std::shared_ptr<PCImage>>::destroy((uint64_t)&this[73], this[74].var0);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&this[69], this[70].var0);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&this[66], this[67].var0);
  int v8 = this[63].var0;
  if (v8)
  {
    this[64].$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v8;
    operator delete(v8);
  }
  uint64_t v9 = this + 60;
  std::vector<PSHeliumNode::Sprite>::__destroy_vector::operator()[abi:ne180100]((void ***)&v9);
  PCSharedCount::~PCSharedCount(this + 58);
  PCSharedCount::~PCSharedCount(this + 56);
  HGNode::~HGNode((HGNode *)this);
}

{
  void *v1;
  uint64_t vars8;

  PSHeliumNode::~PSHeliumNode(this);

  HGObject::operator delete(v1);
}

void PSHeliumNode::initProgram(PSHeliumNode *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  GLuint Shader = glCreateShader(0x8B31u);
  glShaderSource(Shader, 1, (const GLchar *const *)vertexShaderSrc, 0);
  glCompileShader(Shader);
  GLuint v3 = glCreateShader(0x8B30u);
  glShaderSource(v3, 1, (const GLchar *const *)&fragmentShaderSrc, 0);
  glCompileShader(v3);
  GLuint Program = glCreateProgram();
  *((_DWORD *)this + 220) = Program;
  glAttachShader(Program, Shader);
  glAttachShader(*((_DWORD *)this + 220), v3);
  glBindAttribLocation(*((_DWORD *)this + 220), 0, "a_position");
  glBindAttribLocation(*((_DWORD *)this + 220), 1u, "a_texCoord");
  glBindAttribLocation(*((_DWORD *)this + 220), 2u, "a_partColor");
  glLinkProgram(*((_DWORD *)this + 220));
  GLsizei length = 0;
  glGetShaderInfoLog(Shader, 2048, &length, infolog);
  if (length) {
    printf("Vert Shader log:%s\n", infolog);
  }
  GLsizei length = 0;
  glGetShaderInfoLog(v3, 2048, &length, infolog);
  if (length) {
    printf("Frag Shader log:%s\n", infolog);
  }
  GLsizei length = 0;
  glGetProgramInfoLog(*((_DWORD *)this + 220), 2048, &length, infolog);
  if (length) {
    printf("Program log:%s\n", infolog);
  }
  glDetachShader(*((_DWORD *)this + 220), Shader);
  glDeleteShader(Shader);
  glDetachShader(*((_DWORD *)this + 220), v3);
  glDeleteShader(v3);
}

uint64_t PSHeliumNode::RenderTile(PSHeliumNode *this, HGTile *a2)
{
  double v5 = (uint64_t *)((char *)a2 + 16);
  double v4 = (char *)*((void *)a2 + 2);
  int v6 = *((_DWORD *)a2 + 2);
  int v7 = *((_DWORD *)a2 + 3);
  int v8 = *(_DWORD *)a2;
  int v9 = *((_DWORD *)a2 + 1);
  int v10 = v6 - *(_DWORD *)a2;
  int v11 = *((_DWORD *)a2 + 6);
  int v12 = v7 - v9;
  if (v7 - v9 >= 1)
  {
    int v13 = 0;
    do
    {
      if (v6 != v8)
      {
        uint64_t v14 = 0;
        do
        {
          double v15 = &v4[16 * v14];
          *(void *)double v15 = 0;
          *((void *)v15 + 1) = 0;
          ++v14;
        }
        while (v10 > (unint64_t)v14);
        int v7 = *((_DWORD *)a2 + 3);
        int v9 = *((_DWORD *)a2 + 1);
      }
      ++v13;
      int v12 = v7 - v9;
      v4 += 16 * v11;
    }
    while (v13 < v7 - v9);
    int v11 = *((_DWORD *)a2 + 6);
    double v4 = (char *)*((void *)a2 + 2);
    int v10 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
  }
  int v16 = v10 * v12;
  Stacuint64_t k = HGExecutionUnit::GetStack(*((char *****)a2 + 42), 0);
  uint64_t v18 = *((void *)a2 + 42);
  if (v4 != Stack)
  {
    HGExecutionUnit::SwapStack(v18);
    uint64_t v19 = (char *)*((void *)a2 + 2);
    if (v19 != HGExecutionUnit::GetStack(*((char *****)a2 + 42), 0)) {
      goto LABEL_13;
    }
    uint64_t v18 = *((void *)a2 + 42);
  }
  HGExecutionUnit::CommitStack(v18, *v5, v11 * v12);
LABEL_13:
  HGExecutionUnit::SwapStack(*((void *)a2 + 42));
  uint64_t v20 = HGExecutionUnit::GetStack(*((char *****)a2 + 42), v16);
  HGExecutionUnit::CommitStack(*((void *)a2 + 42), (uint64_t)v20, v16);
  HGRect v21 = *(HGRect *)v5;
  v34[0] = *(HGRect *)a2;
  v34[1] = v21;
  v34[5] = v21;
  double v35 = v20;
  int v36 = v10;
  HGRect v37 = v34[0];
  HGRect v38 = v34[0];
  uint64_t v39 = *((void *)a2 + 42);
  Effect_toPCRecti((const HGRect *)a2, (uint64_t)&v31);
  v22.i64[0] = (int)v31;
  v22.i64[1] = SHIDWORD(v31);
  float64x2_t v23 = vcvtq_f64_s64(v22);
  v22.i64[0] = SLODWORD(v32[0]);
  v22.i64[1] = SHIDWORD(v32[0]);
  v33[0] = v23;
  v33[1] = vcvtq_f64_s64(v22);
  v32[0] = 0;
  v32[1] = 0;
  double v31 = v32;
  QuadNode::getSprites(*((void *)this + 105), (double *)v33, (uint64_t)&v31);
  double v24 = v31;
  if (v31 != v32)
  {
    do
    {
      uint64_t v25 = (const PSHeliumNode::Sprite *)v24[4];
      switch(*(_DWORD *)v25)
      {
        case 0:
          PSHeliumNode::renderPointParticleTile(this, v34, v25);
          break;
        case 1:
          PSHeliumNode::renderLineParticleTile(this, v34, v25);
          break;
        case 2:
          PSHeliumNode::renderOutlineParticleTile(this, v34, v25);
          break;
        case 3:
        case 4:
          PSHeliumNode::renderImageParticleTile((HGNode *)this, (HGTile *)v34, v25);
          break;
        case 5:
          PSHeliumNode::renderRadialParticleTile((HGNode *)this, (HGTile *)v34, v25);
          break;
        default:
          break;
      }
      uint64_t v26 = (void *)v24[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = (void **)v26;
          uint64_t v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void **)v24[2];
          BOOL v28 = *v27 == v24;
          double v24 = v27;
        }
        while (!v28);
      }
      double v24 = v27;
    }
    while (v27 != v32);
  }
  uint64_t v29 = HGNode::RenderTile((HGNode *)this, a2);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v31, v32[0]);
  return v29;
}

void sub_1B7E0AAB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

void PSHeliumNode::renderPointParticleTile(PSHeliumNode *this, HGRect *a2, const PSHeliumNode::Sprite *a3)
{
  float64x2_t v8 = *((float64x2_t *)a3 + 16);
  uint64_t v9 = *((void *)a3 + 34);
  int v5 = PCMatrix44Tmpl<double>::transform<double>((double *)this + 85, v8.f64, v8.f64);
  __n128 v6 = *(__n128 *)((char *)a3 + 8);
  float64x2_t v7 = v8;
  PSHeliumNode::drawPoint(v5, a2, *((long double *)a3 + 31), v6, &v7);
}

BOOL PSHeliumNode::renderLineParticleTile(PSHeliumNode *this, HGRect *a2, const PSHeliumNode::Sprite *a3)
{
  float64x2_t v13 = *((float64x2_t *)a3 + 16);
  uint64_t v14 = *((void *)a3 + 34);
  long long v11 = *(_OWORD *)((char *)a3 + 280);
  uint64_t v12 = *((void *)a3 + 37);
  int v5 = (double *)((char *)this + 680);
  PCMatrix44Tmpl<double>::transform<double>((double *)this + 85, v13.f64, v13.f64);
  int v6 = PCMatrix44Tmpl<double>::transform<double>(v5, (double *)&v11, (double *)&v11);
  __n128 v7 = *(__n128 *)((char *)a3 + 8);
  long long v9 = v11;
  float64x2_t v10 = v13;
  return PSHeliumNode::drawLine(v6, a2, v7, &v10, &v9);
}

BOOL PSHeliumNode::renderOutlineParticleTile(PSHeliumNode *this, HGRect *a2, const PSHeliumNode::Sprite *a3)
{
  __n128 v4 = *(__n128 *)((char *)a3 + 8);
  double v5 = *((double *)a3 + 27);
  double v6 = *((double *)a3 + 28);
  double v7 = v5 + *((double *)a3 + 29);
  double v8 = v6 + *((double *)a3 + 30);
  long long v9 = *(_OWORD *)((char *)this + 760);
  long long v30 = *(_OWORD *)((char *)this + 744);
  long long v31 = v9;
  long long v10 = *(_OWORD *)((char *)this + 792);
  long long v32 = *(_OWORD *)((char *)this + 776);
  long long v33 = v10;
  long long v11 = *(_OWORD *)((char *)this + 696);
  __n128 v25 = v4;
  long long v26 = *(_OWORD *)((char *)this + 680);
  long long v12 = *(_OWORD *)((char *)this + 712);
  long long v13 = *(_OWORD *)((char *)this + 728);
  long long v27 = v11;
  long long v28 = v12;
  long long v29 = v13;
  PCMatrix44Tmpl<double>::rightMult((uint64_t)&v26, (double *)a3 + 4);
  double v14 = *((double *)&v33 + 1) + v5 * *(double *)&v32 + v6 * *((double *)&v32 + 1);
  v37.f64[0] = (*((double *)&v27 + 1) + v5 * *(double *)&v26 + v6 * *((double *)&v26 + 1)) / v14;
  v37.f64[1] = (*((double *)&v29 + 1) + v5 * *(double *)&v28 + v6 * *((double *)&v28 + 1)) / v14;
  double v15 = *((double *)&v33 + 1) + v7 * *(double *)&v32 + v6 * *((double *)&v32 + 1);
  v36.f64[0] = (*((double *)&v27 + 1) + v7 * *(double *)&v26 + v6 * *((double *)&v26 + 1)) / v15;
  v36.f64[1] = (*((double *)&v29 + 1) + v7 * *(double *)&v28 + v6 * *((double *)&v28 + 1)) / v15;
  double v16 = *((double *)&v33 + 1) + v7 * *(double *)&v32 + v8 * *((double *)&v32 + 1);
  v35.f64[0] = (*((double *)&v27 + 1) + v7 * *(double *)&v26 + v8 * *((double *)&v26 + 1)) / v16;
  v35.f64[1] = (*((double *)&v29 + 1) + v7 * *(double *)&v28 + v8 * *((double *)&v28 + 1)) / v16;
  double v17 = *((double *)&v33 + 1) + v5 * *(double *)&v32 + v8 * *((double *)&v32 + 1);
  v34.f64[0] = (*((double *)&v27 + 1) + v5 * *(double *)&v26 + v8 * *((double *)&v26 + 1)) / v17;
  v34.f64[1] = (*((double *)&v29 + 1) + v5 * *(double *)&v28 + v8 * *((double *)&v28 + 1)) / v17;
  BOOL v19 = PSHeliumNode::drawLine(v18, a2, v25, &v37, (long long *)&v36);
  BOOL v20 = PSHeliumNode::drawLine(v19, a2, v25, &v36, (long long *)&v35);
  BOOL v21 = PSHeliumNode::drawLine(v20, a2, v25, &v35, (long long *)&v34);
  BOOL v22 = PSHeliumNode::drawLine(v21, a2, v25, &v34, (long long *)&v37);
  BOOL v23 = PSHeliumNode::drawLine(v22, a2, v25, &v37, (long long *)&v35);
  return PSHeliumNode::drawLine(v23, a2, v25, &v34, (long long *)&v36);
}

void PSHeliumNode::renderImageParticleTile(HGNode *this, HGTile *a2, const PSHeliumNode::Sprite *a3)
{
  double v6 = *(HGRenderer **)(*((void *)a2 + 42) + 152);
  Input = HGRenderer::GetInput(v6, this, *((_DWORD *)a3 + 50));
  uint64_t ROI = HGRenderer::GetROI(v6, Input);
  unint64_t v10 = v9;
  if (((*(uint64_t (**)(HGNode *, void))(*(void *)this + 152))(this, *((unsigned int *)a3 + 50)) & 2) != 0)
  {
    HGRenderer::RenderInput((uint64_t)v6, *((void *)a2 + 42), (uint64_t)this, *((_DWORD *)a3 + 50), (uint64_t)&v28, ROI, v10, 0);
    uint64_t v14 = v29;
    long long v12 = HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap(v12, ROI, v10, 28, v28, 16 * v14);
  }
  else
  {
    int v11 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)v6 + 128))(v6, 19);
    long long v12 = HGObject::operator new(0x90uLL);
    uint64_t v13 = *((void *)a2 + 42);
    HGBuffer::HGBuffer((uint64_t)v12, ROI, v10, v11, 0);
    *long long v12 = &unk_1F1197A48;
    v12[16] = Input;
    v12[17] = v13;
  }
  PCMatrix44Tmpl<double>::operator*((uint64_t)this + 680, (long long *)a3 + 2, (uint64_t)v38);
  long long v15 = *(_OWORD *)((char *)this + 760);
  long long v34 = *(_OWORD *)((char *)this + 744);
  long long v35 = v15;
  long long v16 = *(_OWORD *)((char *)this + 792);
  long long v36 = *(_OWORD *)((char *)this + 776);
  long long v37 = v16;
  long long v17 = *(_OWORD *)((char *)this + 696);
  long long v30 = *(_OWORD *)((char *)this + 680);
  long long v31 = v17;
  long long v18 = *(_OWORD *)((char *)this + 728);
  long long v32 = *(_OWORD *)((char *)this + 712);
  long long v33 = v18;
  PCMatrix44Tmpl<double>::rightMult((uint64_t)&v30, (double *)a3 + 4);
  if (PCMatrix44Tmpl<double>::planarInverseZ((uint64_t)&v30, v38, 0.0))
  {
    uint64_t v19 = *((void *)&v30 + 1);
    long long v20 = v31;
    uint64_t v21 = *((void *)&v34 + 1);
    *((void *)&v30 + 1) = v32;
    *(void *)&long long v31 = v34;
    uint64_t v22 = *((void *)&v35 + 1);
    *((void *)&v31 + 1) = v36;
    *(void *)&long long v32 = v19;
    uint64_t v23 = *((void *)&v33 + 1);
    *(void *)&long long v34 = v20;
    *((void *)&v34 + 1) = v33;
    *(void *)&long long v33 = v21;
    *((void *)&v33 + 1) = *((void *)&v36 + 1);
    *((void *)&v35 + 1) = v37;
    *(void *)&long long v36 = *((void *)&v20 + 1);
    *((void *)&v36 + 1) = v23;
    *(void *)&long long v37 = v22;
    HGTransform::HGTransform((HGTransform *)&v28);
    double Matrixd = HGTransform::LoadMatrixd((HGTransform *)&v28, (double *)&v30);
    *(_DWORD *)(*((void *)a2 + 42) + 36) = 1;
    int v25 = (*(uint64_t (**)(HGRenderer *, uint64_t, double))(*(void *)v6 + 128))(v6, 4, Matrixd);
    uint64_t v26 = *((void *)a2 + 42);
    *(_DWORD *)(v26 + 112) = v25;
    HGSampler::ReadTile(v26);
    long long v27 = *(_OWORD *)((char *)a3 + 8);
    PCWorkingColorVector::operator*=((float32x2_t *)&v27, *((float *)&v27 + 3));
    OZTileBlend::renderTile((uint64_t)a2, (PCWorkingColor *)&v27, *((unsigned __int8 *)a3 + 24));
    HGTransform::~HGTransform((HGTransform *)&v28);
  }
  if (v12) {
    (*(void (**)(void *))(*v12 + 24))(v12);
  }
}

void sub_1B7E0B090(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  }
  _Unwind_Resume(exception_object);
}

void PSHeliumNode::renderRadialParticleTile(HGNode *this, HGTile *a2, const PSHeliumNode::Sprite *a3)
{
  double v6 = *(HGRenderer **)(*((void *)a2 + 42) + 152);
  Input = HGRenderer::GetInput(v6, this, *((_DWORD *)a3 + 50));
  uint64_t ROI = HGRenderer::GetROI(v6, Input);
  uint64_t v10 = v9;
  int v11 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)v6 + 128))(v6, 19);
  uint64_t v12 = *((void *)a2 + 42);
  HGBuffer::HGBuffer((uint64_t)v48, ROI, v10, v11, 0);
  v48[0] = &unk_1F1197A48;
  v48[16] = Input;
  v48[17] = v12;
  PSHeliumNode::unbindSurface((PSHeliumNode *)this);
  PCMatrix44Tmpl<double>::operator*((uint64_t)this + 680, (long long *)a3 + 2, (uint64_t)v47);
  long long v13 = *(_OWORD *)((char *)this + 760);
  _DWORD v46[4] = *(_OWORD *)((char *)this + 744);
  v46[5] = v13;
  long long v14 = *(_OWORD *)((char *)this + 792);
  v46[6] = *(_OWORD *)((char *)this + 776);
  v46[7] = v14;
  long long v15 = *(_OWORD *)((char *)this + 696);
  v46[0] = *(_OWORD *)((char *)this + 680);
  v46[1] = v15;
  long long v16 = *(_OWORD *)((char *)this + 728);
  v46[2] = *(_OWORD *)((char *)this + 712);
  void v46[3] = v16;
  PCMatrix44Tmpl<double>::rightMult((uint64_t)v46, (double *)a3 + 4);
  PCMatrix44Tmpl<double>::planarInverseZ((uint64_t)v46, v47, 0.0);
  int v17 = *((_DWORD *)a2 + 1);
  int v18 = *((_DWORD *)a2 + 3);
  if (v17 < v18)
  {
    int v19 = *(_DWORD *)a2;
    int v20 = *((_DWORD *)a2 + 2);
    uint64_t v42 = *((int *)a2 + 6);
    uint64_t v21 = *((void *)a2 + 2);
    do
    {
      if (v19 < v20)
      {
        int v22 = v19;
        uint64_t v23 = v21;
        do
        {
          double v43 = (double)v22 + 0.5;
          double v44 = (double)v17 + 0.5;
          double v45 = 0.0;
          PCMatrix44Tmpl<double>::transform<double>((double *)v46, &v43, &v43);
          double v24 = v43 * v43 + v44 * v44 + v45 * v45;
          if (v24 <= 0.25)
          {
            double v25 = sqrt(v24);
            double v26 = (v25 + v25) * 255.0;
            __y[0] = 0.0;
            modf(v26, __y);
            unsigned int v29 = __y[0];
            if ((int)(__y[0] + 1) < 255) {
              int v30 = v29 + 1;
            }
            else {
              int v30 = 255;
            }
            *(double *)v27.i64 = v26 - (float)v29;
            *(float *)v27.i32 = *(double *)v27.i64;
            uint64_t v31 = *((void *)this + 59);
            long long v32 = (float *)(v31 + 16 * v29);
            long long v33 = (float *)(v31 + 4 * (4 * v30));
            float32x2_t v34 = vmul_n_f32(*(float32x2_t *)((char *)a3 + 12), v32[2] + (float)((float)(v33[2] - v32[2]) * *(float *)v27.i32));
            float v35 = (float)(*v32 + (float)((float)(*v33 - *v32) * *(float *)v27.i32)) * *((float *)a3 + 5);
            float v36 = 1.0 - v35;
            float v37 = *(float *)v23;
            if (*((unsigned char *)a3 + 24))
            {
              float32x2_t v38 = vmul_n_f32(v34, v35);
              float32x2_t v39 = *(float32x2_t *)(v23 + 4);
            }
            else
            {
              float v37 = v36 * v37;
              float32x2_t v38 = vmul_n_f32(v34, v35);
              float32x2_t v39 = vmul_n_f32(*(float32x2_t *)(v23 + 4), v36);
            }
            *(float32x2_t *)v28.i8 = vadd_f32(v38, v39);
            *(float *)v27.i32 = (float)((float)((float)(v32[1] + (float)((float)(v33[1] - v32[1]) * *(float *)v27.i32))
                                              * *((float *)a3 + 2))
                                      * v35)
                              + v37;
            float v40 = v35 + (float)(v36 * *(float *)(v23 + 12));
            if (v40 > 1.0) {
              float v40 = 1.0;
            }
            int8x16_t v41 = vextq_s8(vextq_s8(v27, v27, 4uLL), v28, 0xCuLL);
            *(float *)&v41.i32[3] = v40;
            *(int8x16_t *)uint64_t v23 = v41;
          }
          v23 += 16;
          ++v22;
        }
        while (v20 != v22);
      }
      v21 += 16 * v42;
      ++v17;
    }
    while (v17 != v18);
  }
  HGBuffer::~HGBuffer((HGBuffer *)v48);
}

void sub_1B7E0B434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
}

uint64_t PSHeliumNode::SetParameter(PSHeliumNode *this, float a2, float a3, float a4, float a5)
{
  return 0;
}

uint64_t PSHeliumNode::GetROI(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  Input = HGRenderer::GetInput(a2, this, a3);

  return HGRenderer::GetDOD(a2, Input);
}

uint64_t PSHeliumNode::GetDOD(PSHeliumNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return HGRectMake4i(vcvtmd_s64_f64(*((double *)this + 101) + 0.000000999999997 + 0.0000001), vcvtmd_s64_f64(*((double *)this + 102) + 0.000000999999997 + 0.0000001), vcvtpd_s64_f64(*((double *)this + 101) + *((double *)this + 103) + -0.000000999999997), vcvtpd_s64_f64(*((double *)this + 102) + *((double *)this + 104) + -0.000000999999997));
  }
}

uint64_t PSHeliumNode::RenderPage(PSHeliumNode *this, HGPage *a2)
{
  __n128 v4 = *(HGGPURenderer **)a2;
  double v5 = (char *)*((void *)a2 + 1);
  memset((char *)&v39.var8 + 4, 0, 20);
  if (!v5)
  {
    *((void *)a2 + 1) = 0;
LABEL_7:
    unsigned int v14 = *((_DWORD *)this + 4);
    if ((v14 & 0x1000) != 0)
    {
      uint64_t v15 = HGRectMake4i(*((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 4) + ((*((_DWORD *)a2 + 6) + ~*((_DWORD *)a2 + 4)) & 0xFFFFFFE0) + 32, *((_DWORD *)a2 + 5) + ((*((_DWORD *)a2 + 7) + ~*((_DWORD *)a2 + 5)) & 0xFFFFFFE0) + 32);
      *(void *)&v16.var2 = *(void *)&v16.var0;
      *((void *)a2 + 2) = v15;
      *((void *)a2 + 3) = *(void *)&v16.var0;
    }
    else
    {
      uint64_t v15 = *((void *)a2 + 2);
      *(void *)&v16.var2 = *((void *)a2 + 3);
    }
    *(void *)&v16.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v15;
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)v4, v16, *((unsigned int *)a2 + 8), 0, (v14 >> 12) & 1, *((unsigned __int8 *)a2 + 248));
    *((void *)a2 + 1) = Buffer;
    if (!Buffer) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
  (*(void (**)(HGGPURenderer *, char *))(*(void *)v4 + 144))(v4, v5);
  HGGPURenderer::GetCurrentContext(v4, (uint64_t *)&v39.var6);
  CGColorSpace = (_anonymous_namespace_ *)PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v39.var6);
  ProGL::findContext(CGColorSpace, v7, &v39.var1);
  ProGL::ContextHandle::operator=(&v39.var9, (uint64_t *)&v39.var1);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v39.var1);
  PCSharedCount::PCSharedCount((PCSharedCount *)&v39.var6);
  glGetIntegerv(0xBE2u, (GLint *)&v39.var8 + 1);
  glDisable(0xBE2u);
  int var8_high = HIDWORD(v39.var8);
  *((void *)a2 + 1) = v5;
  uint64_t v9 = v5;
  if (var8_high)
  {
    (*(void (**)(HGGPURenderer *, char *))(*(void *)v4 + 144))(v4, v5);
    HGGPURenderer::GetCurrentContext(v4, (uint64_t *)&v39.var6);
    uint64_t v10 = (_anonymous_namespace_ *)PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v39.var6);
    ProGL::findContext(v10, v11, &v39.var1);
    ProGL::ContextHandle::operator=(&v39.var9, (uint64_t *)&v39.var1);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v39.var1);
    PCSharedCount::PCSharedCount((PCSharedCount *)&v39.var6);
    glEnable(0xBE2u);
    uint64_t v9 = (char *)*((void *)a2 + 1);
    if (!v9) {
      goto LABEL_7;
    }
  }
  (*(void (**)(char *))(*(void *)v9 + 16))(v9);
  Buffer = (char *)*((void *)a2 + 1);
  if (!Buffer)
  {
LABEL_5:
    long long v13 = 0;
    goto LABEL_15;
  }
LABEL_11:
  if ((Buffer[12] & 1) != 0
    && (unint64_t)(0x6F96F96F96F96F97 * ((uint64_t)(*((void *)this + 61) - *((void *)this + 60)) >> 3)) >= 0x15)
  {
    long long v13 = HGGPURenderer::CreateBuffer((uint64_t)v4, *(HGRect *)(Buffer + 20), *((unsigned int *)Buffer + 4), 0, 0, *((unsigned __int8 *)a2 + 248));
    *((void *)a2 + 1) = v13;
    double v5 = v13;
  }
  else
  {
    long long v13 = Buffer;
    Buffer = 0;
  }
LABEL_15:
  (*(void (**)(HGGPURenderer *, char *))(*(void *)v4 + 144))(v4, v13);
  HGGPURenderer::GetCurrentContext(v4, (uint64_t *)&v39.var6);
  int v17 = (_anonymous_namespace_ *)PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v39.var6);
  ProGL::findContext(v17, v18, &v39.var1);
  ProGL::ContextHandle::operator=(&v39.var9, (uint64_t *)&v39.var1);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v39.var1);
  PCSharedCount::PCSharedCount((PCSharedCount *)&v39.var6);
  HGGPURenderer::Clear(v4, *((HGRect *)a2 + 1), v19, v20);
  glActiveTexture(0x84C0u);
  uint64_t v21 = (*(uint64_t (**)(HGGPURenderer *, void, PSHeliumNode *))(*(void *)v4 + 368))(v4, *((void *)this + 8), this);
  (*(void (**)(PSHeliumNode *, HGPage *, void, uint64_t))(*(void *)this + 488))(this, a2, 0, v21);
  ProGL::CurrentContextSentry::CurrentContextSentry((ProGL::CurrentContextSentry *)&v39.var6, (const ProGL::ContextHandle *)&v39.var9);
  ProGL::GL::GL((ProGL::GL *)&v39.var1);
  uint64_t v37 = v21;
  PSHeliumNode::initProgram(this);
  float32x2_t v38 = v5;
  uint64_t v22 = *((void *)this + 55);
  if (v22) {
    *(unsigned char *)(v22 + 361) = 0;
  }
  uint64_t v23 = (const PSHeliumNode::Sprite *)*((void *)this + 60);
  for (uint64_t i = (const PSHeliumNode::Sprite *)*((void *)this + 61);
        v23 != i;
        uint64_t v23 = (const PSHeliumNode::Sprite *)((char *)v23 + 312))
  {
    unsigned int v25 = *(_DWORD *)v23 - 3;
    if (v25 > 2)
    {
      glDisable(0xBE2u);
      *((unsigned char *)this + 419) = 0;
    }
    else
    {
      unsigned int v26 = (3u >> (v25 & 7)) & 1;
      if (*((unsigned char *)v23 + 24))
      {
        if (*((unsigned char *)this + 419) && *((unsigned char *)this + 420) && *((unsigned __int8 *)this + 421) == v26) {
          goto LABEL_36;
        }
        if (v26) {
          GLenum v27 = 1;
        }
        else {
          GLenum v27 = 770;
        }
        glBlendFuncSeparate(v27, 1u, 1u, 0x303u);
        glEnable(0xBE2u);
        *(_WORD *)((char *)this + 419) = 257;
      }
      else
      {
        if (*((unsigned char *)this + 419) && !*((unsigned char *)this + 420) && *((unsigned __int8 *)this + 421) == v26) {
          goto LABEL_36;
        }
        if (v26) {
          GLenum v28 = 1;
        }
        else {
          GLenum v28 = 770;
        }
        glBlendFuncSeparate(v28, 0x303u, 1u, 0x303u);
        glEnable(0xBE2u);
        *(_WORD *)((char *)this + 419) = 1;
      }
      *((unsigned char *)this + 421) = v26;
    }
LABEL_36:
    PSHeliumNode::renderParticle(this, (HGGPURenderer **)a2, (ProGL::GL *)&v39.var1, v23);
  }
  glDisable(0xBE2u);
  *((unsigned char *)this + 419) = 0;
  if (*((_DWORD *)this + 106) != -1) {
    *((_DWORD *)this + 106) = -1;
  }
  PSHeliumNode::unbindSurface(this);
  glDisable(0xC11u);
  glFlush();
  ProGL::GL::~GL((ProGL::GL *)&v39.var1);
  ProGL::CurrentContextSentry::~CurrentContextSentry((ProGL::CurrentContextSentry *)&v39.var6);
  if (*((void *)this + 107))
  {
    int v29 = *((_DWORD *)this + 22);
    if (v29 >= 1)
    {
      for (uint64_t j = 0; j < v29; ++j)
      {
        uint64_t v31 = *(void *)(*((void *)this + 107) + 8 * j);
        if (v31)
        {
          (*(void (**)(uint64_t))(*(void *)v31 + 24))(v31);
          int v29 = *((_DWORD *)this + 22);
        }
      }
    }
  }
  uint64_t v32 = *((void *)this + 106);
  if (v32) {
    MEMORY[0x1BA9BFB70](v32, 0x1000C80451B5BE8);
  }
  *((void *)this + 106) = 0;
  uint64_t v33 = *((void *)this + 107);
  if (v33) {
    MEMORY[0x1BA9BFB70](v33, 0x20C8093837F09);
  }
  *((void *)this + 107) = 0;
  (*(void (**)(PSHeliumNode *, HGPage *, void, uint64_t))(*(void *)this + 496))(this, a2, 0, v37);
  if (Buffer)
  {
    HGGPURenderer::BufferCopyOpenGL(v4, (HGBuffer *)Buffer, *(HGRect *)(v38 + 20), (HGBitmap *)v38);
    (*(void (**)(char *))(*(void *)v38 + 24))(v38);
    *((void *)a2 + 1) = Buffer;
    {
      HGGLGetCurrentContext();
      char isObjectRef = OZChannelBase::isObjectRef(&v39);
      PCSharedCount::PCSharedCount((PCSharedCount *)&v39);
      PSHeliumNode::RenderPage(HGPage *)::isIntel = isObjectRef;
    }
    if (PSHeliumNode::RenderPage(HGPage *)::isIntel
      && (*((_DWORD *)Buffer + 8) - *((_DWORD *)Buffer + 6)) * (*((_DWORD *)Buffer + 7) - *((_DWORD *)Buffer + 5)) >= 0x100000)
    {
      glFinish();
    }
  }
  uint64_t v34 = *((void *)a2 + 1);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v39.var9);
  return v34;
}

void sub_1B7E0BBA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, PCSharedCount a18, uint64_t a19, uint64_t a20,char a21)
{
}

void PSHeliumNode::renderParticle(PSHeliumNode *this, HGGPURenderer **a2, ProGL::GL *a3, const PSHeliumNode::Sprite *a4)
{
  long long v10 = *(_OWORD *)((char *)a4 + 8);
  int v8 = *(_DWORD *)a4;
  if ((*(_DWORD *)a4 - 3) <= 1)
  {
    PCWorkingColorVector::operator*=((float32x2_t *)&v10, *((float *)&v10 + 3));
    int v8 = *(_DWORD *)a4;
  }
  switch(v8)
  {
    case 0:
      if (*((_DWORD *)this + 106) != -1) {
        *((_DWORD *)this + 106) = -1;
      }
      PSHeliumNode::unbindSurface(this);
      float v9 = *((double *)a4 + 31);
      if (*((float *)this + 108) != v9) {
        *((float *)this + 108) = v9;
      }
      break;
    case 1:
    case 2:
      if (*((_DWORD *)this + 106) != -1) {
        *((_DWORD *)this + 106) = -1;
      }
      PSHeliumNode::unbindSurface(this);
      break;
    case 3:
      PSHeliumNode::renderImageParticlePage(this, a2, a3, a4);
      break;
    case 4:
      PSHeliumNode::renderBitmapParticlePage(this, a2, a3, a4);
      break;
    case 5:
      PSHeliumNode::renderRadialParticlePage(this, (HGPage *)a2, a3, a4);
      break;
    default:
      return;
  }
}

void PSHeliumNode::unbindSurface(PSHeliumNode *this)
{
  if (*((unsigned char *)this + 428))
  {
    Instance = (os_unfair_lock_s *)OZShaderManager::getInstance(this);
    uint64_t Shader = OZShaderManager::getShader(Instance, "bilinearMaskEdgeAA");
    __n128 v4 = (OZPolygonAA *)(*(uint64_t (**)(uint64_t))(*(void *)Shader + 24))(Shader);
    double v5 = (OZPolygonAA *)OZPolygonAA::getInstance(v4);
    uint64_t EdgeAATexture = OZPolygonAA::getEdgeAATexture(v5);
    if (EdgeAATexture)
    {
      uint64_t v7 = EdgeAATexture;
      glActiveTexture(0x84C2u);
      GLenum Target = ProGL::TextureHandle::getTarget((ProGL::Private::TextureImpl **)(v7 + 64));
      glBindTexture(Target, 0);
    }
    glActiveTexture(0x84C0u);
    *((unsigned char *)this + 428) = 0;
  }
  else if (*((unsigned char *)this + 429))
  {
    uint64_t v9 = *((void *)this + 55);
    if (!v9) {
      throw_PCNullPointerException(1);
    }
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
    *((unsigned char *)this + 429) = 0;
  }
}

uint64_t PSHeliumNode::RenderPageMetal(PSHeliumNode *this, HGPage *a2)
{
  __n128 v4 = *(HGGPURenderer **)a2;
  Buffer = (char *)*((void *)a2 + 1);
  if (Buffer)
  {
    (*(void (**)(void))(*(void *)Buffer + 16))(*((void *)a2 + 1));
  }
  else
  {
    *(void *)&v15.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *((void *)a2 + 2);
    *(void *)&v15.var2 = *((void *)a2 + 3);
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)v4, v15, *((unsigned int *)a2 + 8), 1, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
    *((void *)a2 + 1) = Buffer;
  }
  uint64_t v7 = HGGPURenderer::ClearMetal(v4, (HGBitmap *)Buffer, *((HGRect *)a2 + 1), v6);
  uint64_t v9 = (const void *)(*(uint64_t (**)(HGGPURenderer *, uint64_t *, PSHeliumNode *))(*(void *)v4 + 376))(v4, TextureMetalShaderText, this);
  if (v9)
  {
    if (v10)
    {
      int v11 = v10;
      *((_DWORD *)this + 224) = 4;
      uint64_t v12 = (char *)(*(uint64_t (**)(PSHeliumNode *))(*(void *)this + 48))(this);
      std::string::basic_string[abi:ne180100]<0>(&__p, v12);
      HGMetalHandler::SetDebugLabel(v11, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      HGMetalHandler::BindBuffer((HGMetalHandler *)v11, (HGBitmap *)Buffer);
      (*(void (**)(PSHeliumNode *, HGPage *, void, std::string *))(*(void *)this + 488))(this, a2, 0, v11);
      HGMetalHandler::SetScissorRect((HGMetalHandler *)v11, (__n128 *)a2 + 1);
      HGMetalHandler::SetScissorTest((uint64_t)v11, 1);
      PSHeliumNode::SpriteBatchController::SpriteBatchController((PSHeliumNode::SpriteBatchController *)&__p, a2, (HGMetalHandler *)v11, this);
    }
  }
  return *((void *)a2 + 1);
}

void sub_1B7E0C180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *anonymous namespace'::getTextureMetalShaderText(_anonymous_namespace_ *this)
{
  {
      "                out.color0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy) * hg_Params[0];\n"
      "                return out;\n"
      "            }\n"
      "        ");
  }
  if (byte_1E9EE66BF >= 0) {
  else
  }
}

void sub_1B7E0C254(_Unwind_Exception *a1)
{
}

BOOL PSHeliumNode::SpriteBatchController::add(uint64_t a1, uint64_t a2)
{
  GLuint v3 = *(void **)a1;
  __n128 v4 = *(void **)(a1 + 8);
  if (*(void **)a1 == v4)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (!(*(unsigned int (**)(void, uint64_t))(*(void *)*v3 + 16))(*v3, a2))
    {
      if (++v3 == v4) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *v3;
  }
  uint64_t v7 = *(void *)(a1 + 24);
  if (v7 != v6 && v7 != 0) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  *(void *)(a1 + 24) = v6;
  return v6 != 0;
}

void PSHeliumNode::renderParticleMetal(PSHeliumNode *this, HGGPURenderer **a2, HGMetalHandler *a3, HGBitmap **a4)
{
  if (PSHeliumNode::bindMetalProgramForSprite(this, (HGPage *)a2, a3, (const PSHeliumNode::Sprite *)a4))
  {
    switch(*(_DWORD *)a4)
    {
      case 1:
        PSHeliumNode::renderLineParticlePageMetal(this, v8, a3, (const PSHeliumNode::Sprite *)a4);
        break;
      case 2:
        PSHeliumNode::renderOutlineParticlePageMetal(this, v8, a3, (const PSHeliumNode::Sprite *)a4);
        break;
      case 3:
        PSHeliumNode::commonRenderMetalTexture((uint64_t)this, (int)v8, (HGMetalTexture ***)a3, (uint64_t)a4, a4 + 26);
        break;
      case 4:
        PSHeliumNode::renderBitmapParticlePageMetal(this, a2, (HGMetalTexture ***)a3, (const PSHeliumNode::Sprite *)a4);
        break;
      case 5:
        PSHeliumNode::renderRadialParticlePageMetal(this, a2, a3, (const PSHeliumNode::Sprite *)a4);
        break;
      case 6:
        PSHeliumNode::renderCircleParticlePageMetal(this, v8, a3, (const PSHeliumNode::Sprite *)a4);
        break;
      default:
        return;
    }
  }
}

uint64_t PSHeliumNode::setClip(PSHeliumNode *this, const LiClipSet *a2)
{
  return LiClipSet::operator=((uint64_t)this + 632, (uint64_t)a2);
}

uint64_t PSHeliumNode::setObjectToFilmMatrix(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result + 680;
  if (result + 680 != a2)
  {
    for (uint64_t i = 0; i != 4; ++i)
    {
      for (uint64_t j = 0; j != 32; j += 8)
        *(void *)(v2 + j) = *(void *)(a2 + j);
      v2 += 32;
      a2 += 32;
    }
  }
  return result;
}

void PSHeliumNode::setGradient(uint64_t a1, const PCSharedCount *a2)
{
  *(PCSharedCount *)(a1 + 440) = (PCSharedCount)a2->var0;
  uint64_t v2 = (uint64_t *)(a1 + 448);
  PCSharedCount::PCSharedCount(&v3, a2 + 1);
  PCSharedCount::operator=(v2, (uint64_t *)&v3);
  PCSharedCount::~PCSharedCount(&v3);
}

void sub_1B7E0C55C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void PSHeliumNode::initGradient(PSHeliumNode *this, OZChannelGradient *a2, CMTime *a3)
{
}

void PSHeliumNode::setMetalGradient(uint64_t a1, const PCSharedCount *a2)
{
  PCSharedCount v3 = *(PC_Sp_counted_base **)(a1 + 456);
  $3CC8671D27C23BF42ADDB32F2B5E48AE var0 = a2->var0;
  if (!v3)
  {
    if (!var0) {
      return;
    }
    goto LABEL_9;
  }
  if (var0) {
    BOOL v5 = v3 == var0;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5)
  {
LABEL_9:
    *(void *)(a1 + 456) = var0;
    PCSharedCount::PCSharedCount(&v6, a2 + 1);
    PCSharedCount::operator=((uint64_t *)(a1 + 464), (uint64_t *)&v6);
    PCSharedCount::~PCSharedCount(&v6);
    *(_DWORD *)(a1 + 896) = 0;
  }
}

void sub_1B7E0C684(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void **PSHeliumNode::setNumberOfParticles(PSHeliumNode *this, unsigned int a2)
{
  return std::vector<PSHeliumNode::Sprite>::reserve((uint64_t *)this + 60, a2);
}

void **std::vector<PSHeliumNode::Sprite>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  if (0x6F96F96F96F96F97 * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0xD20D20D20D20D3) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::Sprite>>((uint64_t)result, a2);
    v7[1] = (char *)v7[0] + v5;
    v7[2] = (char *)v7[0] + v5;
    v7[3] = (char *)v7[0] + 312 * v6;
    std::vector<PSHeliumNode::Sprite>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<PSHeliumNode::Sprite>::~__split_buffer(v7);
  }
  return result;
}

void sub_1B7E0C750(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<PSHeliumNode::Sprite>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t PSHeliumNode::addPointParticle(uint64_t a1, long long *a2, __n128 *a3, char a4, float a5)
{
  v56[12] = *(double *)MEMORY[0x1E4F143B8];
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)v33);
  uint64_t v43 = 0x3FF0000000000000;
  int8x16_t v44 = 0uLL;
  uint64_t v40 = 0x3FF0000000000000;
  uint64_t v37 = 0x3FF0000000000000;
  uint64_t v34 = 0x3FF0000000000000;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  __asm { FMOV            V0.2D, #-1.0 }
  float64x2_t v45 = _Q0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v46 = 0;
  float64x2_t v49 = _Q0;
  int v16 = -1762037865 * ((*(void *)(a1 + 488) - *(void *)(a1 + 480)) >> 3);
  v32[0] = 0;
  v32[1] = v16;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  uint64_t v52 = *((void *)a2 + 2);
  uint64_t v53 = 0;
  long long v51 = *a2;
  __n128 v17 = *a3;
  *(__n128 *)long long v10 = *a3;
  v33[16] = a4;
  double v18 = a5;
  double v50 = a5;
  uint64_t v19 = *(unsigned int *)(a1 + 644);
  if ((int)v19 <= 0)
  {
    double v22 = *(double *)a2;
    v17.n128_u64[0] = *((void *)a2 + 1);
    double v23 = *((double *)a2 + 2);
LABEL_9:
    uint64_t v24 = 0;
    double v25 = (float)-a5;
    v56[0] = v22 + v25;
    v56[1] = v17.n128_f64[0] + v25;
    v56[2] = v23 + 0.0;
    v56[3] = v22 + v18;
    v56[4] = v17.n128_f64[0] + v25;
    v56[5] = v23 + 0.0;
    v56[6] = v22 + v18;
    v56[7] = v17.n128_f64[0] + v18;
    v56[8] = v23 + 0.0;
    v56[9] = v22 + v25;
    v56[10] = v17.n128_f64[0] + v18;
    v56[11] = v23 + 0.0;
    do
    {
      PCMatrix44Tmpl<double>::transform<double>((double *)(a1 + 680), &v56[v24], &v56[v24]);
      int8x16_t v31 = *(int8x16_t *)&v56[v24];
      PCRect<double>::operator|=((float64x2_t *)(a1 + 808), (float64x2_t *)&v31);
      v26.f64[0] = v45.f64[0];
      if (v45.f64[0] >= 0.0 && v45.f64[1] >= 0.0)
      {
        v26.f64[1] = v45.f64[1];
        int8x16_t v27 = (int8x16_t)vaddq_f64(v26, (float64x2_t)v44);
        int8x16_t v44 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v44, (float64x2_t)v31), v31, v44);
        float64x2_t v45 = vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v31, (float64x2_t)v27), v31, v27), (float64x2_t)v44);
      }
      else
      {
        int8x16_t v44 = v31;
        float64x2_t v45 = 0uLL;
      }
      v24 += 3;
    }
    while (v24 != 12);
    unint64_t v28 = *(void *)(a1 + 488);
    if (v28 >= *(void *)(a1 + 496))
    {
      uint64_t v29 = std::vector<PSHeliumNode::Sprite>::__push_back_slow_path<PSHeliumNode::Sprite const&>((uint64_t *)(a1 + 480), (uint64_t)v32);
    }
    else
    {
      __n128 v17 = std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(a1 + 496, *(void *)(a1 + 488), (uint64_t)v32);
      uint64_t v29 = v28 + 312;
      *(void *)(a1 + 488) = v28 + 312;
    }
    *(void *)(a1 + 488) = v29;
  }
  else
  {
    uint64_t v20 = 0;
    uint64_t v21 = 16;
    while (1)
    {
      if (v20 >= *(int *)(a1 + 644)) {
        PCArray_base::badIndex(v10);
      }
      double v22 = *(double *)a2;
      v17.n128_u64[0] = *((void *)a2 + 1);
      double v23 = *((double *)a2 + 2);
      if (*(double *)(*(void *)(a1 + 648) + v21 + 8)
         + *(double *)(*(void *)(a1 + 648) + v21 - 16) * *(double *)a2
         + *(double *)(*(void *)(a1 + 648) + v21 - 8) * v17.n128_f64[0]
         + *(double *)(*(void *)(a1 + 648) + v21) * v23 < 0.0)
        break;
      ++v20;
      v21 += 32;
      if (v19 == v20) {
        goto LABEL_9;
      }
    }
  }
  uint64_t result = v46;
  if (v46) {
    return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v46 + 24))(v46, v17);
  }
  return result;
}

void sub_1B7E0CA34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  PSHeliumNode::Sprite::~Sprite((PSHeliumNode::Sprite *)va);
  _Unwind_Resume(a1);
}

void PSHeliumNode::Sprite::~Sprite(PSHeliumNode::Sprite *this)
{
  uint64_t v1 = *((void *)this + 26);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
}

uint64_t PSHeliumNode::addLineParticle(uint64_t a1, double *a2, double *a3, __n128 *a4, char a5)
{
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)&v51);
  uint64_t v62 = 0x3FF0000000000000;
  int8x16_t v63 = 0uLL;
  uint64_t v59 = 0x3FF0000000000000;
  uint64_t v56 = 0x3FF0000000000000;
  uint64_t v53 = 0x3FF0000000000000;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  __asm { FMOV            V0.2D, #-1.0 }
  float64x2_t v64 = _Q0;
  uint64_t v65 = 0;
  uint64_t v66 = 0;
  float64x2_t v68 = _Q0;
  int v16 = -1762037865 * ((*(void *)(a1 + 488) - *(void *)(a1 + 480)) >> 3);
  v50[0] = 1;
  v50[1] = v16;
  uint64_t v17 = *((void *)a2 + 2);
  uint64_t v67 = 0;
  uint64_t v70 = v17;
  long long v69 = *(_OWORD *)a2;
  long long v71 = *(_OWORD *)a3;
  uint64_t v72 = *((void *)a3 + 2);
  __n128 v18 = *a4;
  __n128 v51 = *a4;
  char v52 = a5;
  double v19 = *a2;
  double v20 = a2[1];
  v48.i64[0] = *(uint64_t *)a2;
  *(double *)&v48.i64[1] = v20;
  double v21 = a2[2];
  double v49 = v21;
  double v22 = *a3;
  double v23 = a3[1];
  v46.i64[0] = *(uint64_t *)a3;
  *(double *)&v46.i64[1] = v23;
  double v24 = a3[2];
  double v47 = v24;
  uint64_t v25 = *(unsigned int *)(a1 + 644);
  if ((int)v25 < 1)
  {
LABEL_18:
    PCMatrix44Tmpl<double>::transform<double>((double *)(a1 + 680), (double *)v48.i64, (double *)v48.i64);
    int8x16_t v45 = v48;
    PCRect<double>::operator|=((float64x2_t *)(a1 + 808), (float64x2_t *)&v45);
    v37.f64[0] = v64.f64[0];
    if (v64.f64[0] >= 0.0 && v64.f64[1] >= 0.0)
    {
      v37.f64[1] = v64.f64[1];
      int8x16_t v38 = (int8x16_t)vaddq_f64(v37, (float64x2_t)v63);
      int8x16_t v63 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v63, (float64x2_t)v45), v45, v63);
      float64x2_t v64 = vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v45, (float64x2_t)v38), v45, v38), (float64x2_t)v63);
    }
    else
    {
      int8x16_t v63 = v45;
      float64x2_t v64 = 0uLL;
    }
    PCMatrix44Tmpl<double>::transform<double>((double *)(a1 + 680), (double *)v46.i64, (double *)v46.i64);
    int8x16_t v44 = v46;
    PCRect<double>::operator|=((float64x2_t *)(a1 + 808), (float64x2_t *)&v44);
    v39.f64[0] = v64.f64[0];
    if (v64.f64[0] >= 0.0 && v64.f64[1] >= 0.0)
    {
      v39.f64[1] = v64.f64[1];
      int8x16_t v40 = (int8x16_t)vaddq_f64(v39, (float64x2_t)v63);
      int8x16_t v63 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v63, (float64x2_t)v44), v44, v63);
      float64x2_t v64 = vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v44, (float64x2_t)v40), v44, v40), (float64x2_t)v63);
    }
    else
    {
      int8x16_t v63 = v44;
      float64x2_t v64 = 0uLL;
    }
    unint64_t v41 = *(void *)(a1 + 488);
    if (v41 >= *(void *)(a1 + 496))
    {
      uint64_t v42 = std::vector<PSHeliumNode::Sprite>::__push_back_slow_path<PSHeliumNode::Sprite const&>((uint64_t *)(a1 + 480), (uint64_t)v50);
    }
    else
    {
      __n128 v18 = std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(a1 + 496, *(void *)(a1 + 488), (uint64_t)v50);
      uint64_t v42 = v41 + 312;
      *(void *)(a1 + 488) = v41 + 312;
    }
    *(void *)(a1 + 488) = v42;
  }
  else
  {
    uint64_t v26 = 0;
    uint64_t v27 = 16;
    while (1)
    {
      if (v26 >= *(int *)(a1 + 644)) {
        PCArray_base::badIndex(v10);
      }
      uint64_t v28 = *(void *)(a1 + 648) + v27;
      double v30 = *(double *)(v28 - 16);
      double v29 = *(double *)(v28 - 8);
      double v31 = *(double *)v28;
      v18.n128_u64[0] = *(void *)(v28 + 8);
      double v32 = v30 * v19 + v29 * v20 + *(double *)v28 * v21;
      double v33 = v30 * v22 + v29 * v23 + *(double *)v28 * v24;
      double v34 = v18.n128_f64[0] + v33;
      if (v18.n128_f64[0] + v32 < 0.0 && v34 < 0.0) {
        break;
      }
      if (v18.n128_f64[0] + v32 < 0.0)
      {
        double v36 = v30 * (v19 - v22) + v29 * (v20 - v23) + v31 * (v21 - v24);
        if (v36 > -0.0000001 && v36 < 0.0000001) {
          break;
        }
        v18.n128_f64[0] = (-v33 - v18.n128_f64[0]) / v36;
        if (v18.n128_f64[0] <= 0.0) {
          break;
        }
        double v19 = v22 + (v19 - v22) * v18.n128_f64[0];
        double v20 = v23 + (v20 - v23) * v18.n128_f64[0];
        double v21 = v24 + (v21 - v24) * v18.n128_f64[0];
        *(double *)v48.i64 = v19;
        *(double *)&v48.i64[1] = v20;
        double v49 = v21;
      }
      else if (v34 < 0.0)
      {
        double v35 = v30 * (v22 - v19) + v29 * (v23 - v20) + v31 * (v24 - v21);
        if (v35 > -0.0000001 && v35 < 0.0000001) {
          break;
        }
        v18.n128_f64[0] = (-v32 - v18.n128_f64[0]) / v35;
        if (v18.n128_f64[0] <= 0.0) {
          break;
        }
        double v22 = v19 + (v22 - v19) * v18.n128_f64[0];
        double v23 = v20 + (v23 - v20) * v18.n128_f64[0];
        double v24 = v21 + (v24 - v21) * v18.n128_f64[0];
        *(double *)v46.i64 = v22;
        *(double *)&v46.i64[1] = v23;
        double v47 = v24;
      }
      ++v26;
      v27 += 32;
      if (v25 == v26) {
        goto LABEL_18;
      }
    }
  }
  uint64_t result = v65;
  if (v65) {
    return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v65 + 24))(v65, v18);
  }
  return result;
}

void sub_1B7E0CEC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  *(void *)(v12 + 488) = v13;
  PSHeliumNode::Sprite::~Sprite((PSHeliumNode::Sprite *)va);
  _Unwind_Resume(a1);
}

uint64_t PSHeliumNode::addOutlineParticle(uint64_t a1, uint64_t *a2, double *a3, _OWORD *a4, char a5)
{
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)v44);
  uint64_t v54 = 0x3FF0000000000000;
  int8x16_t v55 = 0uLL;
  uint64_t v51 = 0x3FF0000000000000;
  uint64_t v48 = 0x3FF0000000000000;
  uint64_t v45 = 0x3FF0000000000000;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  __asm { FMOV            V1.2D, #-1.0 }
  float64x2_t v56 = _Q1;
  uint64_t v57 = 0;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  int v16 = -1762037865 * ((*(void *)(a1 + 488) - *(void *)(a1 + 480)) >> 3);
  v43[0] = 2;
  v43[1] = v16;
  if (&v45 != a2)
  {
    for (uint64_t i = 0; i != 16; i += 4)
    {
      __n128 v18 = (_OWORD *)((char *)&v45 + i * 8);
      long long v19 = *(_OWORD *)&a2[i + 2];
      *__n128 v18 = *(_OWORD *)&a2[i];
      v18[1] = v19;
    }
  }
  _OWORD *v10 = *a4;
  v44[16] = a5;
  long long v58 = *(_OWORD *)a3;
  long long v59 = *((_OWORD *)a3 + 1);
  double v20 = *a3;
  double v21 = a3[1];
  double v23 = a3[2];
  double v22 = a3[3];
  LiImagePolygon::LiImagePolygon((LiImagePolygon *)v41);
  std::vector<LiPolygon::PosEdge>::resize(v42, 4uLL);
  uint64_t v25 = v42;
  uint64_t v26 = *v42;
  *(double *)uint64_t v26 = v20;
  *(double *)(v26 + 8) = v21;
  *(void *)(v26 + 16) = 0;
  *(double *)(v26 + 32) = v20 + v23;
  *(double *)(v26 + 40) = v21;
  *(void *)(v26 + 48) = 0;
  *(double *)(v26 + 64) = v20 + v23;
  *(double *)(v26 + 72) = v21 + v22;
  *(void *)(v26 + 80) = 0;
  *(double *)(v26 + 96) = v20;
  *(double *)(v26 + 104) = v21 + v22;
  *(void *)(v26 + 112) = 0;
  uint64_t v27 = *(unsigned int *)(a1 + 644);
  if ((int)v27 >= 1)
  {
    for (uint64_t j = 0; j != v27; ++j)
    {
      memset(v40, 0, 32);
      if (j >= *(int *)(a1 + 644)) {
        PCArray_base::badIndex(v24);
      }
      PCMatrix44Tmpl<double>::transform_row<double>((double *)a2, (double *)(*(void *)(a1 + 648) + 32 * j), v40[0].f64);
      double v24 = (PCArray_base *)LiImagePolygon::clip(v41, v40, 0);
    }
    uint64_t v25 = v42;
    uint64_t v26 = *v42;
  }
  if ((int)((unint64_t)(v25[1] - v26) >> 5) >= 3)
  {
    PCMatrix44Tmpl<double>::operator*(a1 + 680, (long long *)a2, (uint64_t)v40);
    uint64_t v29 = *v42;
    if ((int)((unint64_t)(v42[1] - *v42) >> 5) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      do
      {
        int8x16_t v38 = *(int8x16_t *)(v29 + v30);
        uint64_t v39 = 0;
        PCMatrix44Tmpl<double>::transform<double>(v40[0].f64, (double *)v38.i64, (double *)v38.i64);
        int8x16_t v37 = v38;
        PCRect<double>::operator|=((float64x2_t *)(a1 + 808), (float64x2_t *)&v37);
        v32.f64[0] = v56.f64[0];
        if (v56.f64[0] >= 0.0 && v56.f64[1] >= 0.0)
        {
          v32.f64[1] = v56.f64[1];
          int8x16_t v33 = (int8x16_t)vaddq_f64(v32, (float64x2_t)v55);
          int8x16_t v55 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v55, (float64x2_t)v37), v37, v55);
          float64x2_t v56 = vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v37, (float64x2_t)v33), v37, v33), (float64x2_t)v55);
        }
        else
        {
          int8x16_t v55 = v37;
          float64x2_t v56 = 0uLL;
        }
        ++v31;
        uint64_t v29 = *v42;
        v30 += 32;
      }
      while (v31 < (int)((unint64_t)(v42[1] - *v42) >> 5));
    }
    unint64_t v34 = *(void *)(a1 + 488);
    if (v34 >= *(void *)(a1 + 496))
    {
      uint64_t v35 = std::vector<PSHeliumNode::Sprite>::__push_back_slow_path<PSHeliumNode::Sprite const&>((uint64_t *)(a1 + 480), (uint64_t)v43);
    }
    else
    {
      std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(a1 + 496, *(void *)(a1 + 488), (uint64_t)v43);
      uint64_t v35 = v34 + 312;
      *(void *)(a1 + 488) = v34 + 312;
    }
    *(void *)(a1 + 488) = v35;
  }
  LiImagePolygon::~LiImagePolygon((LiImagePolygon *)v41);
  uint64_t result = v57;
  if (v57) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v57 + 24))(v57);
  }
  return result;
}

void sub_1B7E0D214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
}

void PSHeliumNode::commonImageSpriteSetup(double *a1, uint64_t a2, double *a3, double *a4, _OWORD *a5, char a6)
{
  uint64_t v9 = a1;
  *(_DWORD *)a2 = 3;
  *(_DWORD *)(a2 + 4) = -1762037865 * ((*((void *)a1 + 61) - *((void *)a1 + 60)) >> 3);
  uint64_t v10 = a2 + 32;
  if ((double *)(a2 + 32) != a3)
  {
    uint64_t v11 = 0;
    uint64_t v12 = a3;
    do
    {
      for (uint64_t i = 0; i != 4; ++i)
        *(double *)(v10 + i * 8) = v12[i];
      ++v11;
      v10 += 32;
      v12 += 4;
    }
    while (v11 != 4);
  }
  *(_OWORD *)(a2 + 8) = *a5;
  *(unsigned char *)(a2 + 24) = a6;
  long long v14 = *(_OWORD *)a4;
  *(_OWORD *)(a2 + 232) = *((_OWORD *)a4 + 1);
  *(_OWORD *)(a2 + 216) = v14;
  *(unsigned char *)(a2 + 304) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a2 + 176) = _Q0;
  uint64_t v20 = *((unsigned int *)a1 + 161);
  if ((int)v20 >= 1)
  {
    uint64_t v21 = 0;
    do
    {
      long long v44 = 0u;
      *(_OWORD *)uint64_t v45 = 0u;
      if (v21 >= *((int *)v9 + 161)) {
        PCArray_base::badIndex((PCArray_base *)a1);
      }
      a1 = PCMatrix44Tmpl<double>::transform_row<double>(a3, (double *)(*((void *)v9 + 81) + 32 * v21), (double *)&v44);
      long long v22 = v44;
      double v23 = -0.0;
      double v24 = a4[2];
      if (*(double *)&v44 > 0.0) {
        double v24 = -0.0;
      }
      double v25 = *a4 + v24;
      if (*((double *)&v44 + 1) <= 0.0) {
        double v23 = a4[3];
      }
      double v26 = *(double *)&v44 * v25 + *((double *)&v44 + 1) * (a4[1] + v23);
      double v27 = v45[1];
      double v28 = v45[0] * 0.0;
      if (v45[1] + v45[0] * 0.0 + v26 < 0.0)
      {
        *(unsigned char *)(a2 + 304) = 1;
        double v29 = -0.0;
        double v30 = a4[2];
        if (*(double *)&v22 <= 0.0) {
          double v30 = -0.0;
        }
        double v31 = *a4 + v30;
        if (*((double *)&v22 + 1) > 0.0) {
          double v29 = a4[3];
        }
        if (v27 + v28 + *(double *)&v22 * v31 + *((double *)&v22 + 1) * (a4[1] + v29) <= 0.0) {
          return;
        }
      }
    }
    while (++v21 != v20);
  }
  PCMatrix44Tmpl<double>::operator*((uint64_t)(v9 + 85), (long long *)a3, (uint64_t)&v44);
  if (!*(unsigned char *)(a2 + 304))
  {
    PCMatrix44Tmpl<double>::transformRect<double>((double *)&v44, a4, a2 + 160);
LABEL_34:
    PCRect<double>::operator|=((float64x2_t *)(v9 + 101), (float64x2_t *)(a2 + 160));
    return;
  }
  LiImagePolygon::LiImagePolygon((LiImagePolygon *)v40);
  LiImagePolygon::set((uint64_t)v40, a4, 0);
  if ((int)v20 >= 1)
  {
    for (uint64_t j = 0; j != v20; ++j)
    {
      float64x2_t v38 = 0u;
      long long v39 = 0u;
      if (j >= *((int *)v9 + 161)) {
        PCArray_base::badIndex(v32);
      }
      PCMatrix44Tmpl<double>::transform_row<double>(a3, (double *)(*((void *)v9 + 81) + 32 * j), v38.f64);
      float64x2_t v32 = (PCArray_base *)LiImagePolygon::clip(v40, &v38, 0);
    }
  }
  if ((int)((unint64_t)(v42 - v41) >> 5) >= 1)
  {
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    do
    {
      float64x2_t v38 = 0uLL;
      *(void *)&long long v39 = 0;
      PCMatrix44Tmpl<double>::transform<double>((double *)&v44, (double *)(*v43 + v34), v38.f64);
      float64x2_t v37 = v38;
      PCRect<double>::operator|=((float64x2_t *)(a2 + 160), &v37);
      ++v35;
      v34 += 32;
    }
    while (v35 < (int)((unint64_t)(v42 - v41) >> 5));
  }
  if (*(double *)(a2 + 176) < 0.0)
  {
    LiImagePolygon::~LiImagePolygon((LiImagePolygon *)v40);
    return;
  }
  double v36 = *(double *)(a2 + 184);
  LiImagePolygon::~LiImagePolygon((LiImagePolygon *)v40);
  if (v36 >= 0.0) {
    goto LABEL_34;
  }
}

void sub_1B7E0D564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  LiImagePolygon::~LiImagePolygon((LiImagePolygon *)va);
  _Unwind_Resume(a1);
}

uint64_t PSHeliumNode::addImageParticle(uint64_t a1, double *a2, void *a3, double *a4, _OWORD *a5, char a6)
{
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)v25);
  uint64_t v34 = 0x3FF0000000000000;
  uint64_t v35 = 0;
  uint64_t v31 = 0x3FF0000000000000;
  uint64_t v28 = 0x3FF0000000000000;
  v25[3] = 0x3FF0000000000000;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  uint64_t v36 = 0;
  __asm { FMOV            V1.2D, #-1.0 }
  long long v37 = _Q1;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v39 = 0;
  long long v42 = _Q1;
  long long v45 = 0u;
  long long v44 = 0u;
  long long v43 = 0u;
  PSHeliumNode::commonImageSpriteSetup((double *)a1, (uint64_t)&v24, a2, a4, a5, a6);
  unsigned int Name = ProGL::TextureHandle::getName((HGGLBlendingInfo **)(*a3 + 64));
  uint64_t v17 = (std::__shared_weak_count *)a3[1];
  unint64_t v22 = *a3;
  double v23 = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  std::__tree<std::shared_ptr<PCImage>>::__emplace_unique_key_args<std::shared_ptr<PCImage>,std::shared_ptr<PCImage>>((uint64_t **)(a1 + 584), &v22, (uint64_t)&v22);
  if (v23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v23);
  }
  unint64_t v18 = *(void *)(a1 + 488);
  if (v18 >= *(void *)(a1 + 496))
  {
    uint64_t v20 = std::vector<PSHeliumNode::Sprite>::__push_back_slow_path<PSHeliumNode::Sprite const&>((uint64_t *)(a1 + 480), (uint64_t)&v24);
  }
  else
  {
    __n128 v19 = std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(a1 + 496, *(void *)(a1 + 488), (uint64_t)&v24);
    uint64_t v20 = v18 + 312;
    *(void *)(a1 + 488) = v18 + 312;
  }
  *(void *)(a1 + 488) = v20;
  uint64_t result = v39;
  if (v39) {
    return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v39 + 24))(v39, v19);
  }
  return result;
}

{
  uint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t v20;
  __n128 v21;
  uint64_t v22;
  uint64_t result;
  unint64_t v24;
  std::__shared_weak_count *v25;
  char v26;
  void v27[4];
  long long v28;
  long long v29;
  uint64_t v30;
  long long v31;
  long long v32;
  uint64_t v33;
  long long v34;
  long long v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  long long v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  long long v43;
  long long v44;
  long long v45;
  long long v46;

  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)v27);
  uint64_t v36 = 0x3FF0000000000000;
  long long v37 = 0;
  long long v33 = 0x3FF0000000000000;
  long long v30 = 0x3FF0000000000000;
  v27[3] = 0x3FF0000000000000;
  uint64_t v28 = 0u;
  long long v29 = 0u;
  uint64_t v31 = 0u;
  long long v32 = 0u;
  uint64_t v34 = 0u;
  uint64_t v35 = 0u;
  float64x2_t v38 = 0;
  __asm { FMOV            V1.2D, #-1.0 }
  uint64_t v39 = _Q1;
  uint64_t v41 = 0;
  long long v42 = 0;
  uint64_t v40 = 0;
  long long v43 = _Q1;
  long long v46 = 0u;
  long long v45 = 0u;
  long long v44 = 0u;
  PSHeliumNode::commonImageSpriteSetup((double *)a1, (uint64_t)&v26, a2, a4, a5, a6);
  uint64_t v17 = *(void *)(*a3 + 64);
  if (v17)
  {
    (*(void (**)(void))(*(void *)v17 + 16))(*(void *)(*a3 + 64));
    unint64_t v18 = v40;
    if (v40 == v17)
    {
      (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
      goto LABEL_8;
    }
  }
  else
  {
    unint64_t v18 = v40;
    if (!v40) {
      goto LABEL_8;
    }
  }
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
  }
  uint64_t v40 = v17;
LABEL_8:
  __n128 v19 = (std::__shared_weak_count *)a3[1];
  char v24 = *a3;
  double v25 = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  std::__tree<std::shared_ptr<PCImage>>::__emplace_unique_key_args<std::shared_ptr<PCImage>,std::shared_ptr<PCImage>>((uint64_t **)(a1 + 584), &v24, (uint64_t)&v24);
  if (v25) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v25);
  }
  uint64_t v20 = *(void *)(a1 + 488);
  if (v20 >= *(void *)(a1 + 496))
  {
    unint64_t v22 = std::vector<PSHeliumNode::Sprite>::__push_back_slow_path<PSHeliumNode::Sprite const&>((uint64_t *)(a1 + 480), (uint64_t)&v26);
  }
  else
  {
    uint64_t v21 = std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(a1 + 496, *(void *)(a1 + 488), (uint64_t)&v26);
    unint64_t v22 = v20 + 312;
    *(void *)(a1 + 488) = v20 + 312;
  }
  *(void *)(a1 + 488) = v22;
  uint64_t result = v40;
  if (v40) {
    return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v40 + 24))(v40, v21);
  }
  return result;
}

void sub_1B7E0D704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  uint64_t v6 = v5;
  *(void *)(v4 + 488) = v6;
  PSHeliumNode::Sprite::~Sprite((PSHeliumNode::Sprite *)va);
  _Unwind_Resume(a1);
}

uint64_t PSHeliumNode::addImageParticle(uint64_t a1, double *a2, long long *a3, double *a4, _OWORD *a5, char a6)
{
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)v29);
  uint64_t v38 = 0x3FF0000000000000;
  uint64_t v39 = 0;
  uint64_t v35 = 0x3FF0000000000000;
  uint64_t v32 = 0x3FF0000000000000;
  v29[3] = 0x3FF0000000000000;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  uint64_t v40 = 0;
  __asm { FMOV            V1.2D, #-1.0 }
  long long v41 = _Q1;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v43 = 0;
  long long v46 = _Q1;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v47 = 0u;
  PSHeliumNode::commonImageSpriteSetup((double *)a1, (uint64_t)&v28, a2, a4, a5, a6);
  int v28 = 4;
  int v16 = *(void **)(a1 + 560);
  if (!v16) {
    goto LABEL_12;
  }
  unint64_t v17 = *(void *)a3;
  unint64_t v18 = (void *)(a1 + 560);
  do
  {
    unint64_t v19 = v16[4];
    _CF = v19 >= v17;
    if (v19 >= v17) {
      uint64_t v21 = v16;
    }
    else {
      uint64_t v21 = v16 + 1;
    }
    if (_CF) {
      unint64_t v18 = v16;
    }
    int v16 = (void *)*v21;
  }
  while (*v21);
  if (v18 != (void *)(a1 + 560) && v17 >= v18[4])
  {
    int v42 = *((_DWORD *)v18 + 10);
  }
  else
  {
LABEL_12:
    std::vector<std::shared_ptr<PCBitmap>>::push_back[abi:ne180100]((uint64_t *)(a1 + 608), a3);
    int v22 = *(_DWORD *)(a1 + 576);
    unint64_t v27 = *(void *)a3;
    long long v50 = &v27;
    *((_DWORD *)std::__tree<std::__value_type<ProShade::SamplerNode const*,int>,std::__map_value_compare<ProShade::SamplerNode const*,std::__value_type<ProShade::SamplerNode const*,int>,std::less<ProShade::SamplerNode const*>,true>,std::allocator<std::__value_type<ProShade::SamplerNode const*,int>>>::__emplace_unique_key_args<ProShade::SamplerNode const*,std::piecewise_construct_t const&,std::tuple<ProShade::SamplerNode const*&&>,std::tuple<>>((uint64_t **)(a1 + 552), &v27, (uint64_t)&std::piecewise_construct, &v50)+ 10) = v22;
    int v42 = *(_DWORD *)(a1 + 576);
    *(_DWORD *)(a1 + 576) = v42 + 1;
  }
  unint64_t v23 = *(void *)(a1 + 488);
  if (v23 >= *(void *)(a1 + 496))
  {
    uint64_t v25 = std::vector<PSHeliumNode::Sprite>::__push_back_slow_path<PSHeliumNode::Sprite const&>((uint64_t *)(a1 + 480), (uint64_t)&v28);
  }
  else
  {
    __n128 v24 = std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(a1 + 496, *(void *)(a1 + 488), (uint64_t)&v28);
    uint64_t v25 = v23 + 312;
    *(void *)(a1 + 488) = v23 + 312;
  }
  *(void *)(a1 + 488) = v25;
  uint64_t result = v43;
  if (v43) {
    return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v43 + 24))(v43, v24);
  }
  return result;
}

void sub_1B7E0D914(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v4 = v3;
  *(void *)(v2 + 488) = v4;
  PSHeliumNode::Sprite::~Sprite((PSHeliumNode::Sprite *)va);
  _Unwind_Resume(a1);
}

void **std::vector<std::shared_ptr<PCBitmap>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    long long v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)result, v13);
    HGRect v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)HGRect v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    _OWORD v18[2] = v15 + 16;
    std::vector<std::shared_ptr<PCBitmap>>::__swap_out_circular_buffer(a1, v18);
    uint64_t v9 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::shared_ptr<TXTextObject>>::~__split_buffer(v18);
  }
  else
  {
    *uint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1B7E0DA4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<TXTextObject>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t PSHeliumNode::addImageParticle(uint64_t a1, double *a2, unint64_t *a3, double *a4, _OWORD *a5, char a6)
{
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)v32);
  uint64_t v41 = 0x3FF0000000000000;
  uint64_t v42 = 0;
  uint64_t v38 = 0x3FF0000000000000;
  uint64_t v35 = 0x3FF0000000000000;
  v32[3] = 0x3FF0000000000000;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  uint64_t v43 = 0;
  __asm { FMOV            V1.2D, #-1.0 }
  long long v44 = _Q1;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v46 = 0;
  long long v49 = _Q1;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v50 = 0u;
  PSHeliumNode::commonImageSpriteSetup((double *)a1, (uint64_t)v31, a2, a4, a5, a6);
  unint64_t v16 = *a3;
  long long v17 = *(void **)(a1 + 536);
  if (!v17) {
    goto LABEL_12;
  }
  unint64_t v18 = (void *)(a1 + 536);
  do
  {
    unint64_t v19 = v17[4];
    _CF = v19 >= v16;
    if (v19 >= v16) {
      uint64_t v21 = v17;
    }
    else {
      uint64_t v21 = v17 + 1;
    }
    if (_CF) {
      unint64_t v18 = v17;
    }
    long long v17 = (void *)*v21;
  }
  while (*v21);
  if (v18 != (void *)(a1 + 536) && v16 >= v18[4])
  {
    int v45 = *((_DWORD *)v18 + 10);
  }
  else
  {
LABEL_12:
    (*(void (**)(uint64_t, void, unint64_t))(*(void *)a1 + 120))(a1, *(unsigned int *)(a1 + 576), v16);
    if (*(unsigned char *)(a1 + 416))
    {
      {
        PSHeliumNode::addImageParticle(PCMatrix44Tmpl<double> *,HGRef<HGNode> const&,PCRect<double> const&,PCWorkingColorVector const&,BOOL)::maxBitmapCacheSize = (uint64_t)((double)(unint64_t)getPhysicalMemory() * 0.01);
      }
      unint64_t v22 = vcvtd_n_s64_f64(a4[2] * a4[3] * 4.0, 2uLL);
      unint64_t v23 = atomic_load((unint64_t *)&gBitmapCacheSize);
      if ((uint64_t)(v23 + v22) >= PSHeliumNode::addImageParticle(PCMatrix44Tmpl<double> *,HGRef<HGNode> const&,PCRect<double> const&,PCWorkingColorVector const&,BOOL)::maxBitmapCacheSize)
      {
        uint64_t v24 = 16;
      }
      else
      {
        atomic_fetch_add(&gBitmapCacheSize, v22);
        *(void *)(a1 + 872) += v22;
        uint64_t v24 = 2;
      }
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)a1 + 136))(a1, *(unsigned int *)(a1 + 576), v24);
    }
    int v25 = *(_DWORD *)(a1 + 576);
    unint64_t v30 = *a3;
    long long v53 = &v30;
    *((_DWORD *)std::__tree<std::__value_type<ProShade::SamplerNode const*,int>,std::__map_value_compare<ProShade::SamplerNode const*,std::__value_type<ProShade::SamplerNode const*,int>,std::less<ProShade::SamplerNode const*>,true>,std::allocator<std::__value_type<ProShade::SamplerNode const*,int>>>::__emplace_unique_key_args<ProShade::SamplerNode const*,std::piecewise_construct_t const&,std::tuple<ProShade::SamplerNode const*&&>,std::tuple<>>((uint64_t **)(a1 + 528), &v30, (uint64_t)&std::piecewise_construct, &v53)+ 10) = v25;
    int v45 = *(_DWORD *)(a1 + 576);
    *(_DWORD *)(a1 + 576) = v45 + 1;
  }
  unint64_t v26 = *(void *)(a1 + 488);
  if (v26 >= *(void *)(a1 + 496))
  {
    uint64_t v28 = std::vector<PSHeliumNode::Sprite>::__push_back_slow_path<PSHeliumNode::Sprite const&>((uint64_t *)(a1 + 480), (uint64_t)v31);
  }
  else
  {
    __n128 v27 = std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(a1 + 496, *(void *)(a1 + 488), (uint64_t)v31);
    uint64_t v28 = v26 + 312;
    *(void *)(a1 + 488) = v26 + 312;
  }
  *(void *)(a1 + 488) = v28;
  uint64_t result = v46;
  if (v46) {
    return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v46 + 24))(v46, v27);
  }
  return result;
}

void sub_1B7E0DD1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PSHeliumNode::Sprite::~Sprite((PSHeliumNode::Sprite *)va);
  _Unwind_Resume(a1);
}

uint64_t getPhysicalMemory(void)
{
  uint64_t v2 = 0;
  PCInfo::getMemoryInfo((PCInfo *)&v2, 0, 0, 0, 0, 0, 0, 0, v1);
  return v2;
}

void sub_1B7E0DFC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  PSHeliumNode::Sprite::~Sprite((PSHeliumNode::Sprite *)va);
  _Unwind_Resume(a1);
}

uint64_t PSHeliumNode::addRadialParticle(uint64_t a1, uint64_t *a2, double *a3, _OWORD *a4, char a5)
{
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)v45);
  uint64_t v55 = 0x3FF0000000000000;
  int8x16_t v56 = 0uLL;
  uint64_t v52 = 0x3FF0000000000000;
  uint64_t v49 = 0x3FF0000000000000;
  uint64_t v46 = 0x3FF0000000000000;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  __asm { FMOV            V1.2D, #-1.0 }
  float64x2_t v57 = _Q1;
  uint64_t v58 = 0;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  int v16 = -1762037865 * ((*(void *)(a1 + 488) - *(void *)(a1 + 480)) >> 3);
  v44[0] = 5;
  v44[1] = v16;
  if (&v46 != a2)
  {
    for (uint64_t i = 0; i != 16; i += 4)
    {
      unint64_t v18 = (_OWORD *)((char *)&v46 + i * 8);
      long long v19 = *(_OWORD *)&a2[i + 2];
      *unint64_t v18 = *(_OWORD *)&a2[i];
      v18[1] = v19;
    }
  }
  _OWORD *v10 = *a4;
  v45[16] = a5;
  long long v20 = *((_OWORD *)a3 + 1);
  long long v59 = *(_OWORD *)a3;
  long long v60 = v20;
  *(unsigned char *)(a1 + 418) = 1;
  double v21 = *a3;
  double v22 = a3[1];
  double v24 = a3[2];
  double v23 = a3[3];
  LiImagePolygon::LiImagePolygon((LiImagePolygon *)v42);
  std::vector<LiPolygon::PosEdge>::resize(v43, 4uLL);
  unint64_t v26 = v43;
  uint64_t v27 = *v43;
  *(double *)uint64_t v27 = v21;
  *(double *)(v27 + 8) = v22;
  *(void *)(v27 + 16) = 0;
  *(double *)(v27 + 32) = v21 + v24;
  *(double *)(v27 + 40) = v22;
  *(void *)(v27 + 48) = 0;
  *(double *)(v27 + 64) = v21 + v24;
  *(double *)(v27 + 72) = v22 + v23;
  *(void *)(v27 + 80) = 0;
  *(double *)(v27 + 96) = v21;
  *(double *)(v27 + 104) = v22 + v23;
  *(void *)(v27 + 112) = 0;
  uint64_t v28 = *(unsigned int *)(a1 + 644);
  if ((int)v28 >= 1)
  {
    for (uint64_t j = 0; j != v28; ++j)
    {
      memset(v41, 0, 32);
      if (j >= *(int *)(a1 + 644)) {
        PCArray_base::badIndex(v25);
      }
      PCMatrix44Tmpl<double>::transform_row<double>((double *)a2, (double *)(*(void *)(a1 + 648) + 32 * j), v41[0].f64);
      int v25 = (PCArray_base *)LiImagePolygon::clip(v42, v41, 0);
    }
    unint64_t v26 = v43;
    uint64_t v27 = *v43;
  }
  if ((int)((unint64_t)(v26[1] - v27) >> 5) >= 3)
  {
    PCMatrix44Tmpl<double>::operator*(a1 + 680, (long long *)a2, (uint64_t)v41);
    uint64_t v30 = *v43;
    if ((int)((unint64_t)(v43[1] - *v43) >> 5) >= 1)
    {
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      do
      {
        int8x16_t v39 = *(int8x16_t *)(v30 + v31);
        uint64_t v40 = 0;
        PCMatrix44Tmpl<double>::transform<double>(v41[0].f64, (double *)v39.i64, (double *)v39.i64);
        int8x16_t v38 = v39;
        PCRect<double>::operator|=((float64x2_t *)(a1 + 808), (float64x2_t *)&v38);
        v33.f64[0] = v57.f64[0];
        if (v57.f64[0] >= 0.0 && v57.f64[1] >= 0.0)
        {
          v33.f64[1] = v57.f64[1];
          int8x16_t v34 = (int8x16_t)vaddq_f64(v33, (float64x2_t)v56);
          int8x16_t v56 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v56, (float64x2_t)v38), v38, v56);
          float64x2_t v57 = vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v38, (float64x2_t)v34), v38, v34), (float64x2_t)v56);
        }
        else
        {
          int8x16_t v56 = v38;
          float64x2_t v57 = 0uLL;
        }
        ++v32;
        uint64_t v30 = *v43;
        v31 += 32;
      }
      while (v32 < (int)((unint64_t)(v43[1] - *v43) >> 5));
    }
    unint64_t v35 = *(void *)(a1 + 488);
    if (v35 >= *(void *)(a1 + 496))
    {
      uint64_t v36 = std::vector<PSHeliumNode::Sprite>::__push_back_slow_path<PSHeliumNode::Sprite const&>((uint64_t *)(a1 + 480), (uint64_t)v44);
    }
    else
    {
      std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(a1 + 496, *(void *)(a1 + 488), (uint64_t)v44);
      uint64_t v36 = v35 + 312;
      *(void *)(a1 + 488) = v35 + 312;
    }
    *(void *)(a1 + 488) = v36;
  }
  LiImagePolygon::~LiImagePolygon((LiImagePolygon *)v42);
  uint64_t result = v58;
  if (v58) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v58 + 24))(v58);
  }
  return result;
}

void sub_1B7E0E358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
}

uint64_t PSHeliumNode::addCircleParticle(uint64_t a1, uint64_t *a2, double *a3, _OWORD *a4, char a5)
{
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)v44);
  uint64_t v54 = 0x3FF0000000000000;
  int8x16_t v55 = 0uLL;
  uint64_t v51 = 0x3FF0000000000000;
  uint64_t v48 = 0x3FF0000000000000;
  uint64_t v45 = 0x3FF0000000000000;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  __asm { FMOV            V1.2D, #-1.0 }
  float64x2_t v56 = _Q1;
  uint64_t v57 = 0;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  int v16 = -1762037865 * ((*(void *)(a1 + 488) - *(void *)(a1 + 480)) >> 3);
  v43[0] = 6;
  v43[1] = v16;
  if (&v45 != a2)
  {
    for (uint64_t i = 0; i != 16; i += 4)
    {
      unint64_t v18 = (_OWORD *)((char *)&v45 + i * 8);
      long long v19 = *(_OWORD *)&a2[i + 2];
      *unint64_t v18 = *(_OWORD *)&a2[i];
      v18[1] = v19;
    }
  }
  _OWORD *v10 = *a4;
  v44[16] = a5;
  long long v58 = *(_OWORD *)a3;
  long long v59 = *((_OWORD *)a3 + 1);
  double v20 = *a3;
  double v21 = a3[1];
  double v23 = a3[2];
  double v22 = a3[3];
  LiImagePolygon::LiImagePolygon((LiImagePolygon *)v41);
  std::vector<LiPolygon::PosEdge>::resize(v42, 4uLL);
  int v25 = v42;
  uint64_t v26 = *v42;
  *(double *)uint64_t v26 = v20;
  *(double *)(v26 + 8) = v21;
  *(void *)(v26 + 16) = 0;
  *(double *)(v26 + 32) = v20 + v23;
  *(double *)(v26 + 40) = v21;
  *(void *)(v26 + 48) = 0;
  *(double *)(v26 + 64) = v20 + v23;
  *(double *)(v26 + 72) = v21 + v22;
  *(void *)(v26 + 80) = 0;
  *(double *)(v26 + 96) = v20;
  *(double *)(v26 + 104) = v21 + v22;
  *(void *)(v26 + 112) = 0;
  uint64_t v27 = *(unsigned int *)(a1 + 644);
  if ((int)v27 >= 1)
  {
    for (uint64_t j = 0; j != v27; ++j)
    {
      memset(v40, 0, 32);
      if (j >= *(int *)(a1 + 644)) {
        PCArray_base::badIndex(v24);
      }
      PCMatrix44Tmpl<double>::transform_row<double>((double *)a2, (double *)(*(void *)(a1 + 648) + 32 * j), v40[0].f64);
      double v24 = (PCArray_base *)LiImagePolygon::clip(v41, v40, 0);
    }
    int v25 = v42;
    uint64_t v26 = *v42;
  }
  if ((int)((unint64_t)(v25[1] - v26) >> 5) >= 3)
  {
    PCMatrix44Tmpl<double>::operator*(a1 + 680, (long long *)a2, (uint64_t)v40);
    uint64_t v29 = *v42;
    if ((int)((unint64_t)(v42[1] - *v42) >> 5) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      do
      {
        int8x16_t v38 = *(int8x16_t *)(v29 + v30);
        uint64_t v39 = 0;
        PCMatrix44Tmpl<double>::transform<double>(v40[0].f64, (double *)v38.i64, (double *)v38.i64);
        int8x16_t v37 = v38;
        PCRect<double>::operator|=((float64x2_t *)(a1 + 808), (float64x2_t *)&v37);
        v32.f64[0] = v56.f64[0];
        if (v56.f64[0] >= 0.0 && v56.f64[1] >= 0.0)
        {
          v32.f64[1] = v56.f64[1];
          int8x16_t v33 = (int8x16_t)vaddq_f64(v32, (float64x2_t)v55);
          int8x16_t v55 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v55, (float64x2_t)v37), v37, v55);
          float64x2_t v56 = vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v37, (float64x2_t)v33), v37, v33), (float64x2_t)v55);
        }
        else
        {
          int8x16_t v55 = v37;
          float64x2_t v56 = 0uLL;
        }
        ++v31;
        uint64_t v29 = *v42;
        v30 += 32;
      }
      while (v31 < (int)((unint64_t)(v42[1] - *v42) >> 5));
    }
    unint64_t v34 = *(void *)(a1 + 488);
    if (v34 >= *(void *)(a1 + 496))
    {
      uint64_t v35 = std::vector<PSHeliumNode::Sprite>::__push_back_slow_path<PSHeliumNode::Sprite const&>((uint64_t *)(a1 + 480), (uint64_t)v43);
    }
    else
    {
      std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(a1 + 496, *(void *)(a1 + 488), (uint64_t)v43);
      uint64_t v35 = v34 + 312;
      *(void *)(a1 + 488) = v34 + 312;
    }
    *(void *)(a1 + 488) = v35;
  }
  LiImagePolygon::~LiImagePolygon((LiImagePolygon *)v41);
  uint64_t result = v57;
  if (v57) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v57 + 24))(v57);
  }
  return result;
}

void sub_1B7E0E6C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
}

void PSHeliumNode::convertTexturesToBitmaps(PSHeliumNode *this)
{
  uint64_t v1 = this;
  v24[0] = 0;
  v24[1] = 0;
  v22[1] = 0;
  double v23 = (uint64_t *)v24;
  double v21 = (uint64_t *)v22;
  v22[0] = 0;
  uint64_t v2 = (char *)*((void *)this + 73);
  uint64_t v3 = (char *)this + 592;
  if (v2 != (char *)this + 592)
  {
    do
    {
      long long v20 = 0uLL;
      (*(void (**)(long long *__return_ptr))(**((void **)v2 + 4) + 72))(&v19);
      long long v4 = v19;
      long long v19 = 0uLL;
      unint64_t v5 = (std::__shared_weak_count *)*((void *)&v20 + 1);
      long long v20 = v4;
      if (v5)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v5);
        if (*((void *)&v19 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v19 + 1));
        }
      }
      std::vector<std::shared_ptr<PCBitmap>>::push_back[abi:ne180100]((uint64_t *)v1 + 76, &v20);
      int v6 = *((_DWORD *)v1 + 144);
      unint64_t v17 = v20;
      *(void *)&long long v19 = &v17;
      *((_DWORD *)std::__tree<std::__value_type<ProShade::SamplerNode const*,int>,std::__map_value_compare<ProShade::SamplerNode const*,std::__value_type<ProShade::SamplerNode const*,int>,std::less<ProShade::SamplerNode const*>,true>,std::allocator<std::__value_type<ProShade::SamplerNode const*,int>>>::__emplace_unique_key_args<ProShade::SamplerNode const*,std::piecewise_construct_t const&,std::tuple<ProShade::SamplerNode const*&&>,std::tuple<>>((uint64_t **)v1 + 69, &v17, (uint64_t)&std::piecewise_construct, (void **)&v19)+ 10) = v6;
      uint64_t v7 = *((void *)v2 + 5);
      *(void *)&long long v19 = *((void *)v2 + 4);
      *((void *)&v19 + 1) = v7;
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      PCDynamicCast<PGTexture,PCImage>((uint64_t)&v19, &v17);
      int v8 = *((_DWORD *)v1 + 144);
      if (v17)
      {
        LODWORD(v16) = ProGL::TextureHandle::getName((HGGLBlendingInfo **)(v17 + 64));
        int v25 = &v16;
        *((_DWORD *)std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(&v21, (unsigned int *)&v16, (uint64_t)&std::piecewise_construct, (unsigned int **)&v25)+ 8) = v8;
      }
      else
      {
        unint64_t v16 = v19;
        int v25 = &v16;
        *((_DWORD *)std::__tree<std::__value_type<ProShade::SamplerNode const*,int>,std::__map_value_compare<ProShade::SamplerNode const*,std::__value_type<ProShade::SamplerNode const*,int>,std::less<ProShade::SamplerNode const*>,true>,std::allocator<std::__value_type<ProShade::SamplerNode const*,int>>>::__emplace_unique_key_args<ProShade::SamplerNode const*,std::piecewise_construct_t const&,std::tuple<ProShade::SamplerNode const*&&>,std::tuple<>>(&v23, &v16, (uint64_t)&std::piecewise_construct, &v25)+ 10) = v8;
      }
      ++*((_DWORD *)v1 + 144);
      if (v18) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v18);
      }
      if (*((void *)&v19 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v19 + 1));
      }
      this = (PSHeliumNode *)*((void *)&v20 + 1);
      if (*((void *)&v20 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v20 + 1));
      }
      uint64_t v9 = (char *)*((void *)v2 + 1);
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = *(char **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (char *)*((void *)v2 + 2);
          BOOL v11 = *(void *)v10 == (void)v2;
          uint64_t v2 = v10;
        }
        while (!v11);
      }
      uint64_t v2 = v10;
    }
    while (v10 != v3);
  }
  uint64_t v12 = *((void *)v1 + 60);
  for (uint64_t i = *((void *)v1 + 61); v12 != i; v12 += 312)
  {
    if (*(_DWORD *)v12 == 3)
    {
      *(_DWORD *)uint64_t v12 = 4;
      if (*(void *)(v12 + 208))
      {
        *(void *)&long long v19 = *(void *)(v12 + 208);
        *(void *)&long long v20 = &v19;
        this = (PSHeliumNode *)std::__tree<std::__value_type<ProShade::SamplerNode const*,int>,std::__map_value_compare<ProShade::SamplerNode const*,std::__value_type<ProShade::SamplerNode const*,int>,std::less<ProShade::SamplerNode const*>,true>,std::allocator<std::__value_type<ProShade::SamplerNode const*,int>>>::__emplace_unique_key_args<ProShade::SamplerNode const*,std::piecewise_construct_t const&,std::tuple<ProShade::SamplerNode const*&&>,std::tuple<>>(&v23, (unint64_t *)&v19, (uint64_t)&std::piecewise_construct, (void **)&v20);
        int v14 = *((_DWORD *)this + 10);
      }
      else
      {
        LODWORD(v19) = *(_DWORD *)(v12 + 200);
        *(void *)&long long v20 = &v19;
        this = (PSHeliumNode *)std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(&v21, (unsigned int *)&v19, (uint64_t)&std::piecewise_construct, (unsigned int **)&v20);
        int v14 = *((_DWORD *)this + 8);
      }
      *(_DWORD *)(v12 + 200) = v14;
    }
  }
  uint64_t v15 = PSTextureCache::Instance(this);
  PSTextureCache::removeTextures(v15, (void *)v1 + 73);
  std::__tree<std::shared_ptr<PCImage>>::destroy((uint64_t)v1 + 584, *((void **)v1 + 74));
  *((void *)v1 + 73) = v3;
  *((_OWORD *)v1 + 37) = 0u;
  *((unsigned char *)v1 + 864) = 1;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v21, v22[0]);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v23, v24[0]);
}

void sub_1B7E0E9EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, void *a18, uint64_t a19, char a20,void *a21)
{
}

uint64_t PSHeliumNode::preRender(uint64_t this)
{
  if (*(unsigned char *)(this + 416)) {
    operator new();
  }
  return this;
}

void PSHeliumNode::renderImageParticlePage(PSHeliumNode *this, HGGPURenderer **a2, ProGL::GL *a3, const PSHeliumNode::Sprite *a4)
{
  GLuint v7 = *((_DWORD *)a4 + 50);
  glActiveTexture(0x84C0u);
  if (*((_DWORD *)this + 106) != v7)
  {
    glBindTexture(0xDE1u, v7);
    *((_DWORD *)this + 106) = v7;
  }

  PSHeliumNode::commonRenderTextureParticlePage(this, a2, v8, a4);
}

void PSHeliumNode::renderBitmapParticlePage(PSHeliumNode *this, HGGPURenderer **a2, ProGL::GL *a3, const PSHeliumNode::Sprite *a4)
{
  *((_DWORD *)this + 106) = -1;
  long long v7 = *(_OWORD *)(*((void *)this + 76) + 16 * *((int *)a4 + 50));
  long long v25 = v7;
  if (*((void *)&v7 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v7 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  int v8 = (PCImage *)v7;
  int v9 = (*(uint64_t (**)(void, HGGPURenderer **, ProGL::GL *))(*(void *)v7 + 16))(v7, a2, a3);
  int v10 = (*(uint64_t (**)(PCImage *))(*(void *)v8 + 24))(v8);
  uint64_t v11 = *(void *)((char *)v8 + 36);
  int v12 = (*(uint64_t (**)(void))(**((void **)v8 + 8) + 48))(*((void *)v8 + 8));
  PCImageAttributes::PCImageAttributes((PCImageAttributes *)v19);
  v19[0] = 2;
  v19[1] = v9;
  CMTime v19[2] = v10;
  uint64_t v20 = v11;
  int v21 = v12;
  PCImage::getColorSpace(v8, &v17);
  unint64_t v13 = v17;
  if (space && space != v17)
  {
    PCCFRefTraits<CGColorSpace *>::release(space);
    unint64_t v13 = v17;
  }
  CGColorSpaceRef space = v13;
  unint64_t v17 = 0;
  PCCFRef<CGColorSpace *>::~PCCFRef(&v17);
  int v23 = 3553;
  uint64_t v24 = 0;
  PGCreateImage((const PCImageAttributes *)v19, &v15);
  PCDynamicCast<PGTexture2D,PCImage>((uint64_t)&v15, &v17);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  PGTexture2D::setBitmapRef((ProGL::Private::TextureImpl **)v17, (PCImage **)&v25);
  glActiveTexture(0x84C0u);
  PGTexture::bind((ProGL::Private::TextureImpl **)v17);
  PSHeliumNode::commonRenderTextureParticlePage(this, a2, v14, a4);
  PGTexture::unbind((OZChannelBase **)v17);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  PCCFRef<CGColorSpace *>::~PCCFRef(&space);
  if (*((void *)&v25 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v25 + 1));
  }
}

void sub_1B7E0ED48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  int v6 = va_arg(va1, CGColorSpace *);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va1);
  if (*(void *)(v4 - 88)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)(v4 - 88));
  }
  _Unwind_Resume(a1);
}

unsigned char *PSHeliumNode::renderRadialParticlePage(unsigned char *this, HGPage *a2, ProGL::GL *a3, const PSHeliumNode::Sprite *a4)
{
  if (!this[429])
  {
    uint64_t v4 = this;
    PSHeliumNode::unbindSurface((PSHeliumNode *)this);
    uint64_t v5 = *((void *)v4 + 55);
    if (!v5) {
      throw_PCNullPointerException(1);
    }
    this = (unsigned char *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
    v4[429] = 1;
  }
  return this;
}

void PSHeliumNode::commonRenderTextureParticlePage(PSHeliumNode *this, HGGPURenderer **a2, ProGL::GL *a3, const PSHeliumNode::Sprite *a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  PSHeliumNode::bindImageSurface(this, *((double *)a4 + 24));
  if (!(*((unsigned __int8 *)this + 417) | *((unsigned __int8 *)a4 + 304)))
  {
    int v7 = (int)*((double *)a4 + 30);
    int v8 = (int)*((double *)a4 + 29);
    int v9 = (int)*((double *)a4 + 28);
    int v10 = (int)*((double *)a4 + 27);
    ptr[0] = (float)v10;
    ptr[1] = (float)v9;
    float v30 = (float)(v10 + v8);
    float v31 = (float)v9;
    float v32 = (float)v10;
    float v33 = (float)(v9 + v7);
    float v34 = v30;
    float v35 = v33;
    v28[0] = xmmword_1B8387F90;
    v28[1] = unk_1B8387FA0;
    long long v22 = *(_OWORD *)((char *)a4 + 8);
    if ((*(_DWORD *)a4 - 3) <= 1) {
      PCWorkingColorVector::operator*=((float32x2_t *)&v22, *((float *)&v22 + 3));
    }
    PCWorkingColor::getRGBA((PCWorkingColor *)&v22, &v24, &v25, &v26, v27);
    v27[9] = v24;
    v27[10] = v25;
    v27[5] = v24;
    v27[6] = v25;
    v27[1] = v24;
    CMTime v27[2] = v25;
    v27[11] = v26;
    v27[12] = v27[0];
    v27[7] = v26;
    v27[8] = v27[0];
    v27[3] = v26;
    float v27[4] = v27[0];
    GLuint AttribLocation = glGetAttribLocation(*((_DWORD *)this + 220), "a_position");
    GLuint v12 = glGetAttribLocation(*((_DWORD *)this + 220), "a_texCoord");
    GLuint v13 = glGetAttribLocation(*((_DWORD *)this + 220), "a_partColor");
    GLint UniformLocation = glGetUniformLocation(*((_DWORD *)this + 220), "u_objectToFilmMatrix");
    GLint v15 = glGetUniformLocation(*((_DWORD *)this + 220), "s_texture");
    glUseProgram(*((_DWORD *)this + 220));
    glVertexAttribPointer(AttribLocation, 2, 0x1406u, 0, 0, ptr);
    glEnableVertexAttribArray(AttribLocation);
    glVertexAttribPointer(v12, 2, 0x1406u, 0, 0, v28);
    glEnableVertexAttribArray(v12);
    glVertexAttribPointer(v13, 4, 0x1406u, 0, 0, &v24);
    glEnableVertexAttribArray(v13);
    ProjectionMatrix = (PGHelium *)HGGPURenderer::GetProjectionMatrix(*a2);
    PGHelium::convertHGTransform(ProjectionMatrix, v17, (uint64_t)v21);
    PCMatrix44Tmpl<double>::operator*((uint64_t)v21, (long long *)((char *)this + 680), (uint64_t)value);
    PCMatrix44Tmpl<double>::operator*((uint64_t)value, (long long *)a4 + 2, (uint64_t)v20);
    for (uint64_t i = 0; i != 16; ++i)
    {
      GLfloat v19 = *((double *)&v20[2 * (i & 3)] + (i >> 2));
      value[i] = v19;
    }
    glUniformMatrix4fv(UniformLocation, 1, 0, value);
    glActiveTexture(0x84C0u);
    glUniform1i(v15, 0);
    glDrawArrays(5u, 0, 4);
  }
}

void PSHeliumNode::bindImageSurface(PSHeliumNode *this, double a2)
{
  if (a2 != -1.0 || *((unsigned char *)this + 428) == 0)
  {
    PSHeliumNode::unbindSurface(this);
    Instance = (os_unfair_lock_s *)OZShaderManager::getInstance(v4);
    uint64_t Shader = (PGProgram *)OZShaderManager::getShader(Instance, "bilinearMaskEdgeAA");
    (*(void (**)(PGProgram *))(*(void *)Shader + 16))(Shader);
    if (*((unsigned char *)this + 417))
    {
      PGProgram::setLocalParameter(Shader, 0.0, 0.0, 1.0, 0.0);
      int v8 = (OZPolygonAA *)OZPolygonAA::getInstance(v7);
      uint64_t EdgeAATexture = (ProGL::Private::TextureImpl **)OZPolygonAA::getEdgeAATexture(v8);
      glActiveTexture(0x84C2u);
      EdgeAATexture += 8;
      GLenum Target = ProGL::TextureHandle::getTarget(EdgeAATexture);
      GLuint Name = ProGL::TextureHandle::getName(EdgeAATexture);
      glBindTexture(Target, Name);
      GLenum v12 = ProGL::TextureHandle::getTarget(EdgeAATexture);
      glEnable(v12);
    }
    else
    {
      PGProgram::setLocalParameter(Shader, 1.0, 0.0, 0.0, 0.0);
    }
    *((unsigned char *)this + 428) = 1;
  }
}

void *PCDynamicCast<PGTexture2D,PCImage>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void **)a1;
  if (result
  {
    uint64_t v5 = *(void *)(a1 + 8);
    *a2 = result;
    a2[1] = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return result;
}

void PSHeliumNode::drawPoint(int a1, HGRect *a2, long double a3, __n128 a4, float64x2_t *a5)
{
  Effect_toPCRecti(a2, (uint64_t)&__y);
  v8.i64[0] = SLODWORD(__y.f64[0]);
  v8.i64[1] = SHIDWORD(__y.f64[0]);
  float64x2_t v9 = vcvtq_f64_s64(v8);
  v8.i64[0] = SLODWORD(__y.f64[1]);
  v8.i64[1] = SHIDWORD(__y.f64[1]);
  v36[0] = v9;
  v36[1] = vcvtq_f64_s64(v8);
  __y.f64[0] = 0.0;
  modf(a3, (long double *)__y.f64);
  int v10 = (int)__y.f64[0];
  __asm { FMOV            V2.2D, #0.5 }
  float64x2_t __y = vaddq_f64(vaddq_f64(*a5, _Q2), (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)-vcvtmd_s64_f64(a3 * 0.5 + 0.5 + 0.0000001)), 0));
  double v34 = (double)v10;
  double v35 = (double)v10;
  PCRect<double>::operator&=(&__y, v36);
  double v16 = v34;
  if (v34 >= 0.0)
  {
    double v17 = v35;
    if (v35 >= 0.0)
    {
      uint64_t v18 = *(void *)&a2[1].var0;
      uint64_t var2 = a2[1].var2;
      float64x2_t __x = vsubq_f64(__y, v36[0]);
      float64x2_t __y = __x;
      double v37 = 0.0;
      double v20 = __x.f64[1];
      modf(__x.f64[1], &v37);
      int v21 = (int)v37;
      double v22 = (double)(int)v37;
      double v37 = 0.0;
      modf(__x.f64[1] + v17, &v37);
      if (v37 > v22)
      {
        uint64_t v23 = v21;
        uint64_t v24 = v18 + 16 * (int)var2 * (uint64_t)v21;
        uint64_t v25 = 16 * var2;
        do
        {
          double v37 = 0.0;
          modf(__x.f64[0], &v37);
          int v26 = (int)v37;
          double v27 = (double)(int)v37;
          double v37 = 0.0;
          modf(__x.f64[0] + v16, &v37);
          if (v37 > v27)
          {
            uint64_t v28 = (__n128 *)(v24 + 16 * v26);
            int v29 = v26 + 1;
            do
            {
              *v28++ = a4;
              double v30 = (double)v29;
              double v16 = v34;
              __x.f64[0] = __y.f64[0];
              double v37 = 0.0;
              modf(__y.f64[0] + v34, &v37);
              ++v29;
            }
            while (v37 > v30);
            double v20 = __y.f64[1];
            double v17 = v35;
          }
          ++v23;
          double v37 = 0.0;
          modf(v20 + v17, &v37);
          v24 += v25;
        }
        while (v37 > (double)(int)v23);
      }
    }
  }
}

BOOL PSHeliumNode::drawLine(int a1, HGRect *a2, __n128 a3, float64x2_t *a4, long long *a5)
{
  float64x2_t v6 = *a4;
  long long v45 = *a5;
  float64x2_t v46 = v6;
  Effect_toPCRecti(a2, (uint64_t)v42);
  v7.i64[0] = v42[0];
  v7.i64[1] = v42[1];
  float64x2_t v8 = vcvtq_f64_s64(v7);
  v7.i64[0] = v42[2];
  v7.i64[1] = v42[3];
  float64x2_t v43 = v8;
  float64x2_t v44 = vcvtq_f64_s64(v7);
  BOOL result = PCRect<double>::clipLine(v43.f64, &v46, (double *)&v45);
  if (result)
  {
    double v10 = v46.f64[0] - v43.f64[0];
    double v11 = *(double *)&v45 - v43.f64[0];
    double v12 = v44.f64[0];
    double v13 = vabdd_f64(*(double *)&v45 - v43.f64[0], v46.f64[0] - v43.f64[0]);
    double v14 = vabdd_f64(*((double *)&v45 + 1) - v43.f64[1], v46.f64[1] - v43.f64[1]);
    if (v14 <= v13)
    {
      double v15 = v46.f64[0] - v43.f64[0];
      double v10 = v46.f64[1] - v43.f64[1];
      double v16 = *(double *)&v45 - v43.f64[0];
      double v11 = *((double *)&v45 + 1) - v43.f64[1];
      double v12 = v44.f64[1];
      double v17 = v44.f64[0];
      double v18 = v13;
      double v19 = v14;
    }
    else
    {
      double v15 = v46.f64[1] - v43.f64[1];
      double v16 = *((double *)&v45 + 1) - v43.f64[1];
      double v17 = v44.f64[1];
      double v18 = v14;
      double v19 = v13;
    }
    if (v15 > v16) {
      double v20 = v16;
    }
    else {
      double v20 = v15;
    }
    if (v15 > v16) {
      double v21 = v11;
    }
    else {
      double v21 = v10;
    }
    if (v15 > v16)
    {
      double v16 = v15;
      double v11 = v10;
    }
    double v22 = floor(v20 + 0.0000001);
    double v23 = floor(v16 + 0.0000001);
    double v24 = floor(v17 + 0.0000001) + -1.0;
    if (v20 >= v17) {
      double v22 = v24;
    }
    int v25 = (int)v22;
    if (v16 >= v17) {
      double v26 = v24;
    }
    else {
      double v26 = v23;
    }
    int v27 = (int)v26;
    if (v21 >= v11) {
      double v28 = -1.0;
    }
    else {
      double v28 = 1.0;
    }
    if (v25 <= v27)
    {
      uint64_t var2 = a2[1].var2;
      uint64_t v30 = *(void *)&a2[1].var0;
      double v31 = v19 / v18;
      double v32 = floor(v21 + 0.0000001);
      double v33 = floor(v12 + 0.0000001) + -1.0;
      if (v21 >= v12) {
        double v34 = v33;
      }
      else {
        double v34 = v32;
      }
      int v35 = (int)v34;
      double v36 = v21 - (double)(int)v34 - v31 * (v28 * (v20 - (double)v25));
      if (v28 < 0.0) {
        double v36 = 1.0 - v36;
      }
      uint64_t v37 = v30 + 16 * v25;
      uint64_t v38 = v30 + 16 * (int)var2 * (uint64_t)v25;
      int v39 = v27 - v25 + 1;
      do
      {
        uint64_t v40 = (__n128 *)(v37 + 16 * v35 * (int)var2);
        if (v14 > v13) {
          uint64_t v40 = (__n128 *)(v38 + 16 * v35);
        }
        *uint64_t v40 = a3;
        double v36 = v31 + v36;
        if (v36 >= 1.0)
        {
          double v36 = v36 + -1.0;
          int v35 = (int)(v28 + (double)v35);
        }
        v37 += 16;
        v38 += 16 * var2;
        --v39;
      }
      while (v39);
    }
  }
  return result;
}

BOOL PSHeliumNode::bindMetalProgramForSprite(PSHeliumNode *this, HGPage *a2, HGMetalHandler *a3, const PSHeliumNode::Sprite *a4)
{
  _DWORD v32[2] = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)a4 - 1;
  if (v6 > 5) {
    int v7 = 0;
  }
  else {
    int v7 = dword_1B8388134[v6];
  }
  if (*((_DWORD *)this + 224) == v7) {
    return 1;
  }
  std::string __p = 0;
  long long v29 = 0uLL;
  switch(v7)
  {
    case 1:
      {
        goto LABEL_13;
      }
      HGMetalUtils::stringForMetalHeader((uint64_t)&v31);
      double v10 = std::string::append(&v31, "\n            struct VertexInOut\n            {\n                float4 _position  [[ position ]];\n"
              "            };\n"
              "            struct FragmentOut\n"
              "            {\n"
              "                float4 color0     [[ color(0) ]];\n"
              "            };\n"
              "        \n"
              "            vertex VertexInOut vertexFunc(constant float4x4 *matrices [[ buffer(0) ]],\n"
              "                                          const device float4 *positions [[ buffer(1) ]],\n"
              "                                          uint vid [[ vertex_id ]])\n"
              "            {\n"
              "                constant float4x4 *projectionMatrix = matrices;\n"
              "                VertexInOut vert;\n"
              "                vert._position = *projectionMatrix * positions[vid];\n"
              "                return vert;\n"
              "            }\n"
              "        \n"
              "            fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]],\n"
              "                                              const constant float4* hg_Params [[ buffer(0) ]])\n"
              "            {\n"
              "                FragmentOut out;\n"
              "                out.color0 = hg_Params[0];\n"
              "                return out;\n"
              "            }\n"
              "        ");
      long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      qword_1E9EE66D8 = v10->__r_.__value_.__r.__words[2];
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
      goto LABEL_42;
    case 2:
      HGMetalUtils::stringForMetalHeader((uint64_t)&v30);
      double v14 = std::string::append(&v30, "\n            struct VertexInOut\n            {\n                float4 _position  [[ position ]];\n"
              "                float4 _texCoord0 [[ user(texcoord0) ]];\n"
              "            };\n"
              "            struct FragmentOut\n"
              "            {\n"
              "                float4 color0     [[ color(0) ]];\n"
              "            };\n"
              "        \n"
              "            vertex VertexInOut vertexFunc(constant float4x4 *matrices [[ buffer(0) ]],\n"
              "                                          const device float4 *positions [[ buffer(1) ]],\n"
              "                                          const device float4 *texCoords0 [[ buffer(3) ]],\n"
              "                                          uint vid [[ vertex_id ]])\n"
              "            {\n"
              "                constant float4x4 *projectionMatrix = matrices;\n"
              "                constant float4x4 *textureMatrices = matrices + 1;\n"
              "                VertexInOut vert;\n"
              "                vert._position = *projectionMatrix * positions[vid];\n"
              "                vert._texCoord0 = textureMatrices[0] * texCoords0[vid];\n"
              "                return vert;\n"
              "            }\n"
              "        ");
      long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      v31.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      double v16 = (OZMetalGradientRadial *)*((void *)this + 57);
      if (!v16) {
        throw_PCNullPointerException(1);
      }
      FragmentProgramText = (const std::string::value_type *)OZMetalGradientRadial::getFragmentProgramText(v16);
      int v18 = FragmentProgramText[23];
      if (v18 >= 0) {
        double v19 = FragmentProgramText;
      }
      else {
        double v19 = *(const std::string::value_type **)FragmentProgramText;
      }
      if (v18 >= 0) {
        std::string::size_type v20 = *((unsigned __int8 *)FragmentProgramText + 23);
      }
      else {
        std::string::size_type v20 = *((void *)FragmentProgramText + 1);
      }
      double v21 = std::string::append(&v31, v19, v20);
      double v22 = (void *)v21->__r_.__value_.__r.__words[0];
      v32[0] = v21->__r_.__value_.__l.__size_;
      *(void *)((char *)v32 + 7) = *(std::string::size_type *)((char *)&v21->__r_.__value_.__r.__words[1] + 7);
      int v23 = SHIBYTE(v21->__r_.__value_.__r.__words[2]);
      v21->__r_.__value_.__l.__size_ = 0;
      v21->__r_.__value_.__r.__words[2] = 0;
      v21->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
      std::string __p = v22;
      *(void *)&long long v29 = v32[0];
      *(void *)((char *)&v29 + 7) = *(void *)((char *)v32 + 7);
      HIBYTE(v29) = v23;
      if (v23 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = v22;
      }
      break;
    case 3:
      {
        HGMetalUtils::stringForMetalHeader((uint64_t)&v31);
        double v26 = std::string::append(&v31, "\n            struct VertexInOut\n            {\n                float4 _position  [[ position ]];\n"
                "                float4 _colorFromTexCoord  [[ user(texcoord0) ]];\n"
                "            };\n"
                "            struct FragmentOut\n"
                "            {\n"
                "                float4 color0     [[ color(0) ]];\n"
                "            };\n"
                "        \n"
                "            vertex VertexInOut vertexFunc(constant float4x4 *matrices [[ buffer(0) ]],\n"
                "                                          const device float4 *positions [[ buffer(1) ]],\n"
                "                                          const device float4 *texCoords0 [[ buffer(3) ]],\n"
                "                                          uint vid [[ vertex_id ]])\n"
                "            {\n"
                "                constant float4x4 *projectionMatrix = matrices;\n"
                "                VertexInOut vert;\n"
                "                vert._position = *projectionMatrix * positions[vid];\n"
                "                vert._colorFromTexCoord = texCoords0[vid];\n"
                "                return vert;\n"
                "            }\n"
                "        \n"
                "            fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]],\n"
                "                                              const constant float4* hg_Params [[ buffer(0) ]])\n"
                "            {\n"
                "                FragmentOut out;\n"
                "                out.color0 = frag._colorFromTexCoord;\n"
                "                return out;\n"
                "            }\n"
                "        ");
        long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
        unk_1E9EE66F8 = *((void *)&v26->__r_.__value_.__l + 2);
        v26->__r_.__value_.__l.__size_ = 0;
        v26->__r_.__value_.__r.__words[2] = 0;
        v26->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v31.__r_.__value_.__l.__data_);
        }
LABEL_42:
        __cxa_guard_release(v12);
      }
LABEL_13:
      if (*((char *)v9 + 23) >= 0) {
        p_p = v9;
      }
      else {
        p_p = *(void **)v9;
      }
      break;
    case 4:
      break;
    default:
      p_p = 0;
      break;
  }
  uint64_t v24 = (*(uint64_t (**)(void, void *, PSHeliumNode *))(**(void **)a2 + 376))(*(void *)a2, p_p, this);
  BOOL v8 = v24 != 0;
  if (v24) {
    *((_DWORD *)this + 224) = v7;
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(__p);
  }
  return v8;
}

void sub_1B7E0F9D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

uint64_t PSHeliumNode::renderLineParticlePageMetal(PSHeliumNode *this, HGPage *a2, HGMetalHandler *a3, const PSHeliumNode::Sprite *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  PCMatrix44Tmpl<double>::operator*((uint64_t)this + 680, (long long *)a4 + 2, (uint64_t)v15);
  *(double *)&long long v6 = PCMatrix44Tmpl<double>::toSimdFloat((float64_t *)v15);
  v14[0] = v6;
  v14[1] = v7;
  void v14[2] = v8;
  v14[3] = v9;
  double v10 = (PSHeliumNode *)(*(uint64_t (**)(HGMetalHandler *, _OWORD *))(*(void *)a3 + 176))(a3, v14);
  PSHeliumNode::updateHandlerWithSprite(v10, a3, a4);
  *(float32x2_t *)&long long v11 = vcvt_f32_f64(*((float64x2_t *)a4 + 16));
  *((void *)&v11 + 1) = 0x3F80000000000000;
  *(float32x2_t *)&long long v12 = vcvt_f32_f64(*(float64x2_t *)((char *)a4 + 280));
  *((void *)&v12 + 1) = 0x3F80000000000000;
  v15[0] = v11;
  v15[1] = v12;
  return HGMetalHandler::PrimitivesDraw((uint64_t)a3, 1u, v15, 2u, 0);
}

uint64_t PSHeliumNode::renderOutlineParticlePageMetal(PSHeliumNode *this, HGPage *a2, HGMetalHandler *a3, const PSHeliumNode::Sprite *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  PCMatrix44Tmpl<double>::operator*((uint64_t)this + 680, (long long *)a4 + 2, (uint64_t)v21);
  *(double *)&long long v6 = PCMatrix44Tmpl<double>::toSimdFloat((float64_t *)v21);
  v20[0] = v6;
  v20[1] = v7;
  v20[2] = v8;
  void v20[3] = v9;
  double v10 = (PSHeliumNode *)(*(uint64_t (**)(HGMetalHandler *, _OWORD *))(*(void *)a3 + 176))(a3, v20);
  PSHeliumNode::updateHandlerWithSprite(v10, a3, a4);
  double v11 = *((double *)a4 + 27);
  double v12 = *((double *)a4 + 28);
  float v13 = v11;
  *(float *)&double v11 = v11 + *((double *)a4 + 29);
  float v14 = v12 + *((double *)a4 + 30);
  *(float *)&double v12 = v12;
  long long v15 = xmmword_1B7E734D0;
  long long v16 = xmmword_1B7E734D0;
  *(float *)&long long v16 = v13;
  long long v17 = v16;
  DWORD1(v17) = LODWORD(v12);
  LODWORD(v15) = LODWORD(v11);
  long long v18 = v15;
  DWORD1(v18) = LODWORD(v12);
  *((float *)&v16 + 1) = v14;
  *((float *)&v15 + 1) = v14;
  v21[0] = v17;
  v21[1] = v18;
  double v21[2] = v18;
  v21[3] = v15;
  v21[4] = v15;
  v21[5] = v16;
  v21[6] = v16;
  v21[7] = v17;
  v21[8] = v17;
  v21[9] = v15;
  v21[10] = v18;
  v21[11] = v16;
  return HGMetalHandler::PrimitivesDraw((uint64_t)a3, 1u, v21, 0xCu, 0);
}

void PSHeliumNode::renderBitmapParticlePageMetal(PSHeliumNode *this, HGGPURenderer **a2, HGMetalTexture ***a3, const PSHeliumNode::Sprite *a4)
{
  long long v8 = *(_OWORD *)(*((void *)this + 76) + 16 * *((int *)a4 + 50));
  long long v14 = v8;
  long long v9 = (std::__shared_weak_count *)*((void *)&v8 + 1);
  if (*((void *)&v8 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v8 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  if ((void)v8)
  {
    double v12 = 0;
    FxSupport::pcBitmapToHGBitmap((PCBitmap **)&v14, (unsigned int *)&v12, (HGBitmap **)&v13);
    MetalContext = (HGMetalTexture *)HGGPURenderer::GetMetalContext(*a2);
    *(void *)&v15.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = *(void *)((char *)v13 + 28);
    *(void *)&v15.uint64_t var2 = 0;
    HGMetalTexture::createFromBitmap(MetalContext, v13, *(HGBitmap **)((char *)v13 + 20), v15, 1, (HGMetalContext **)&v12);
    PSHeliumNode::commonRenderMetalTexture((uint64_t)this, v11, a3, (uint64_t)a4, &v12);
    if (v12) {
      (*(void (**)(HGBitmap *))(*(void *)v12 + 24))(v12);
    }
    if (v13) {
      (*(void (**)(HGMetalContext *))(*(void *)v13 + 24))(v13);
    }
    long long v9 = (std::__shared_weak_count *)*((void *)&v14 + 1);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
}

void sub_1B7E0FDD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 24))(a9);
  }
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

HGBitmap *PSHeliumNode::renderRadialParticlePageMetal(PSHeliumNode *this, HGGPURenderer **a2, HGMetalHandler *a3, const PSHeliumNode::Sprite *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  PCMatrix44Tmpl<double>::operator*((uint64_t)this + 680, (long long *)a4 + 2, (uint64_t)v17);
  *(double *)&long long v8 = PCMatrix44Tmpl<double>::toSimdFloat((float64_t *)v17);
  long long v18 = v8;
  long long v19 = v9;
  long long v20 = v10;
  long long v21 = v11;
  (*(void (**)(HGMetalHandler *, long long *))(*(void *)a3 + 176))(a3, &v18);
  (*(void (**)(HGMetalHandler *, void))(*(void *)a3 + 80))(a3, 0);
  double v12 = (PSHeliumNode *)(*(uint64_t (**)(HGMetalHandler *))(*(void *)a3 + 88))(a3);
  PSHeliumNode::updateHandlerWithSprite(v12, a3, a4);
  float v13 = (OZMetalGradientRadial *)*((void *)this + 57);
  if (!v13) {
    throw_PCNullPointerException(1);
  }
  MetalContext = (HGMetalContext *)HGGPURenderer::GetMetalContext(*a2);
  OZMetalGradientRadial::getTexture(v13, MetalContext, (HGMetalContext **)&v16);
  HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 0, v16);
  v17[0] = xmmword_1B8387FF0;
  v17[1] = unk_1B8388000;
  void v17[2] = xmmword_1B8388010;
  double v17[3] = unk_1B8388020;
  long long v18 = xmmword_1B8388030;
  long long v19 = unk_1B8388040;
  long long v20 = xmmword_1B8388050;
  long long v21 = unk_1B8388060;
  HGMetalHandler::PrimitivesDraw((uint64_t)a3, 4u, v17, 4u, &v18);
  BOOL result = v16;
  if (v16) {
    return (HGBitmap *)(*(uint64_t (**)(HGBitmap *))(*(void *)v16 + 24))(v16);
  }
  return result;
}

void sub_1B7E10030(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void PSHeliumNode::renderCircleParticlePageMetal(PSHeliumNode *this, HGPage *a2, HGMetalHandler *a3, const PSHeliumNode::Sprite *a4)
{
  PCMatrix44Tmpl<double>::operator*((uint64_t)this + 680, (long long *)a4 + 2, (uint64_t)&__p);
  *(double *)&long long v6 = PCMatrix44Tmpl<double>::toSimdFloat((float64_t *)&__p);
  long long v203 = v6;
  v204[0] = v7;
  v204[1] = v8;
  v204[2] = v9;
  (*(void (**)(HGMetalHandler *, long long *))(*(void *)a3 + 176))(a3, &v203);
  (*(void (**)(HGMetalHandler *, void))(*(void *)a3 + 80))(a3, 0);
  (*(void (**)(HGMetalHandler *))(*(void *)a3 + 88))(a3);
  double v10 = *((double *)a4 + 22);
  std::string __p = 0;
  unint64_t v201 = 0;
  v202[0] = 0;
  long long v203 = 0uLL;
  *(void *)&v204[0] = 0;
  _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE7reserveEm(&__p, 0x44uLL);
  _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE7reserveEm((void **)&v203, 0x44uLL);
  __asm { FMOV            V0.4S, #1.0 }
  long long v199 = _Q0;
  uint64_t v16 = *((void *)&v203 + 1);
  if (*((void *)&v203 + 1) >= *(void *)&v204[0])
  {
    uint64_t v18 = (uint64_t)(*((void *)&v203 + 1) - v203) >> 4;
    if ((unint64_t)(v18 + 1) >> 60) {
      goto LABEL_260;
    }
    unint64_t v19 = (uint64_t)(*(void *)&v204[0] - v203) >> 3;
    if (v19 <= v18 + 1) {
      unint64_t v19 = v18 + 1;
    }
    if (*(void *)&v204[0] - (void)v203 >= 0x7FFFFFFFFFFFFFF0uLL) {
      unint64_t v20 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v19;
    }
    if (v20) {
      long long v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)v204, v20);
    }
    else {
      long long v21 = 0;
    }
    uint64_t v22 = &v21[16 * v18];
    int v23 = &v21[16 * v20];
    *(_OWORD *)uint64_t v22 = xmmword_1B7E75890;
    long long v17 = v22 + 16;
    uint64_t v24 = (char *)*((void *)&v203 + 1);
    int v25 = (char *)v203;
    if (*((void *)&v203 + 1) != (void)v203)
    {
      do
      {
        long long v26 = *((_OWORD *)v24 - 1);
        v24 -= 16;
        *((_OWORD *)v22 - 1) = v26;
        v22 -= 16;
      }
      while (v24 != v25);
      uint64_t v24 = (char *)v203;
    }
    *(void *)&long long v203 = v22;
    *((void *)&v203 + 1) = v17;
    *(void *)&v204[0] = v23;
    if (v24) {
      operator delete(v24);
    }
  }
  else
  {
    **((_OWORD **)&v203 + 1) = xmmword_1B7E75890;
    long long v17 = (_OWORD *)(v16 + 16);
  }
  double v187 = 1.0 / v10 + 0.375;
  *(float *)&long long v27 = v187;
  DWORD1(v27) = 0;
  DWORD2(v27) = 0;
  HIDWORD(v27) = 1.0;
  *((void *)&v203 + 1) = v17;
  double v28 = v201;
  long long v185 = v27;
  if ((unint64_t)v201 >= v202[0])
  {
    uint64_t v30 = (v201 - (unsigned char *)__p) >> 4;
    if ((unint64_t)(v30 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v31 = (uint64_t)(v202[0] - (void)__p) >> 3;
    if (v31 <= v30 + 1) {
      unint64_t v31 = v30 + 1;
    }
    if (v202[0] - (void)__p >= 0x7FFFFFFFFFFFFFF0uLL) {
      unint64_t v32 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v32 = v31;
    }
    if (v32) {
      double v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)v202, v32);
    }
    else {
      double v33 = 0;
    }
    double v34 = &v33[16 * v30];
    int v35 = &v33[16 * v32];
    *(_OWORD *)double v34 = v185;
    long long v29 = v34 + 16;
    uint64_t v37 = (char *)__p;
    double v36 = v201;
    if (v201 != __p)
    {
      do
      {
        long long v38 = *((_OWORD *)v36 - 1);
        v36 -= 16;
        *((_OWORD *)v34 - 1) = v38;
        v34 -= 16;
      }
      while (v36 != v37);
      double v36 = (char *)__p;
    }
    std::string __p = v34;
    unint64_t v201 = v29;
    v202[0] = v35;
    if (v36) {
      operator delete(v36);
    }
  }
  else
  {
    *(_OWORD *)unint64_t v201 = v27;
    long long v29 = v28 + 16;
  }
  unint64_t v201 = v29;
  uint64_t v39 = *((void *)&v203 + 1);
  if (*((void *)&v203 + 1) >= *(void *)&v204[0])
  {
    uint64_t v41 = (uint64_t)(*((void *)&v203 + 1) - v203) >> 4;
    if ((unint64_t)(v41 + 1) >> 60) {
      goto LABEL_260;
    }
    unint64_t v42 = (uint64_t)(*(void *)&v204[0] - v203) >> 3;
    if (v42 <= v41 + 1) {
      unint64_t v42 = v41 + 1;
    }
    if (*(void *)&v204[0] - (void)v203 >= 0x7FFFFFFFFFFFFFF0uLL) {
      unint64_t v43 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v43 = v42;
    }
    if (v43) {
      float64x2_t v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)v204, v43);
    }
    else {
      float64x2_t v44 = 0;
    }
    long long v45 = &v44[16 * v41];
    float64x2_t v46 = &v44[16 * v43];
    *(_OWORD *)long long v45 = v199;
    uint64_t v40 = v45 + 16;
    long long v47 = (char *)*((void *)&v203 + 1);
    uint64_t v48 = (char *)v203;
    if (*((void *)&v203 + 1) != (void)v203)
    {
      do
      {
        long long v49 = *((_OWORD *)v47 - 1);
        v47 -= 16;
        *((_OWORD *)v45 - 1) = v49;
        v45 -= 16;
      }
      while (v47 != v48);
      long long v47 = (char *)v203;
    }
    *(void *)&long long v203 = v45;
    *((void *)&v203 + 1) = v40;
    *(void *)&v204[0] = v46;
    if (v47) {
      operator delete(v47);
    }
  }
  else
  {
    **((_OWORD **)&v203 + 1) = v199;
    uint64_t v40 = (_OWORD *)(v39 + 16);
  }
  *((void *)&v203 + 1) = v40;
  long long v50 = v201;
  if ((unint64_t)v201 >= v202[0])
  {
    uint64_t v52 = (v201 - (unsigned char *)__p) >> 4;
    if ((unint64_t)(v52 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v53 = (uint64_t)(v202[0] - (void)__p) >> 3;
    if (v53 <= v52 + 1) {
      unint64_t v53 = v52 + 1;
    }
    if (v202[0] - (void)__p >= 0x7FFFFFFFFFFFFFF0uLL) {
      unint64_t v54 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v54 = v53;
    }
    if (v54) {
      int8x16_t v55 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)v202, v54);
    }
    else {
      int8x16_t v55 = 0;
    }
    float64x2_t v56 = &v55[16 * v52];
    uint64_t v57 = &v55[16 * v54];
    *(_OWORD *)float64x2_t v56 = xmmword_1B8387F70;
    uint64_t v51 = v56 + 16;
    long long v59 = (char *)__p;
    long long v58 = v201;
    if (v201 != __p)
    {
      do
      {
        long long v60 = *((_OWORD *)v58 - 1);
        v58 -= 16;
        *((_OWORD *)v56 - 1) = v60;
        v56 -= 16;
      }
      while (v58 != v59);
      long long v58 = (char *)__p;
    }
    std::string __p = v56;
    unint64_t v201 = v51;
    v202[0] = v57;
    if (v58) {
      operator delete(v58);
    }
  }
  else
  {
    *(_OWORD *)unint64_t v201 = xmmword_1B8387F70;
    uint64_t v51 = v50 + 16;
  }
  int v61 = 0;
  unint64_t v201 = v51;
  __asm { FMOV            V0.2D, #0.375 }
  float64x2_t v192 = _Q0;
  do
  {
    uint64_t v63 = *((void *)&v203 + 1);
    if (*((void *)&v203 + 1) >= *(void *)&v204[0])
    {
      uint64_t v65 = (uint64_t)(*((void *)&v203 + 1) - v203) >> 4;
      if ((unint64_t)(v65 + 1) >> 60) {
        goto LABEL_254;
      }
      unint64_t v66 = (uint64_t)(*(void *)&v204[0] - v203) >> 3;
      if (v66 <= v65 + 1) {
        unint64_t v66 = v65 + 1;
      }
      if (*(void *)&v204[0] - (void)v203 >= 0x7FFFFFFFFFFFFFF0uLL) {
        unint64_t v67 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v67 = v66;
      }
      if (v67) {
        float64x2_t v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)v204, v67);
      }
      else {
        float64x2_t v68 = 0;
      }
      long long v69 = &v68[16 * v65];
      *(_OWORD *)long long v69 = xmmword_1B7E75890;
      float64x2_t v64 = v69 + 16;
      uint64_t v70 = (char *)*((void *)&v203 + 1);
      long long v71 = (char *)v203;
      if (*((void *)&v203 + 1) != (void)v203)
      {
        do
        {
          long long v72 = *((_OWORD *)v70 - 1);
          v70 -= 16;
          *((_OWORD *)v69 - 1) = v72;
          v69 -= 16;
        }
        while (v70 != v71);
        uint64_t v70 = (char *)v203;
      }
      *(void *)&long long v203 = v69;
      *((void *)&v203 + 1) = v64;
      *(void *)&v204[0] = &v68[16 * v67];
      if (v70) {
        operator delete(v70);
      }
    }
    else
    {
      **((_OWORD **)&v203 + 1) = xmmword_1B7E75890;
      float64x2_t v64 = (_OWORD *)(v63 + 16);
    }
    *((void *)&v203 + 1) = v64;
    __double2 v74 = __sincos_stret(((double)v61 * 0.03125 + (double)v61 * 0.03125) * 3.14159265);
    v73.f64[0] = v74.__cosval;
    v73.f64[1] = v74.__sinval;
    float64x2_t v190 = v73;
    *(float32x2_t *)&long long v75 = vcvt_f32_f64(vmulq_n_f64(v73, v187));
    *((void *)&v75 + 1) = 0x3F80000000000000;
    uint64_t v76 = v201;
    if ((unint64_t)v201 >= v202[0])
    {
      long long v186 = v75;
      uint64_t v78 = (v201 - (unsigned char *)__p) >> 4;
      if ((unint64_t)(v78 + 1) >> 60) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v79 = (uint64_t)(v202[0] - (void)__p) >> 3;
      if (v79 <= v78 + 1) {
        unint64_t v79 = v78 + 1;
      }
      if (v202[0] - (void)__p >= 0x7FFFFFFFFFFFFFF0uLL) {
        unint64_t v80 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v80 = v79;
      }
      if (v80) {
        long long v81 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)v202, v80);
      }
      else {
        long long v81 = 0;
      }
      uint64_t v82 = &v81[16 * v78];
      *(_OWORD *)uint64_t v82 = v186;
      CMTime v77 = v82 + 16;
      CMTime v84 = (char *)__p;
      CMTime v83 = v201;
      if (v201 != __p)
      {
        do
        {
          long long v85 = *((_OWORD *)v83 - 1);
          v83 -= 16;
          *((_OWORD *)v82 - 1) = v85;
          v82 -= 16;
        }
        while (v83 != v84);
        CMTime v83 = (char *)__p;
      }
      std::string __p = v82;
      unint64_t v201 = v77;
      v202[0] = &v81[16 * v80];
      if (v83) {
        operator delete(v83);
      }
    }
    else
    {
      *(_OWORD *)unint64_t v201 = v75;
      CMTime v77 = v76 + 16;
    }
    unint64_t v201 = v77;
    uint64_t v86 = *((void *)&v203 + 1);
    if (*((void *)&v203 + 1) >= *(void *)&v204[0])
    {
      uint64_t v88 = (uint64_t)(*((void *)&v203 + 1) - v203) >> 4;
      if ((unint64_t)(v88 + 1) >> 60) {
LABEL_254:
      }
        std::vector<double>::__throw_length_error[abi:ne180100]();
      unint64_t v89 = (uint64_t)(*(void *)&v204[0] - v203) >> 3;
      if (v89 <= v88 + 1) {
        unint64_t v89 = v88 + 1;
      }
      if (*(void *)&v204[0] - (void)v203 >= 0x7FFFFFFFFFFFFFF0uLL) {
        unint64_t v90 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v90 = v89;
      }
      if (v90) {
        long long v91 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)v204, v90);
      }
      else {
        long long v91 = 0;
      }
      OZRenderState v92 = &v91[16 * v88];
      *(_OWORD *)OZRenderState v92 = v199;
      unint64_t v87 = v92 + 16;
      uint64_t v93 = (char *)*((void *)&v203 + 1);
      long long v94 = (char *)v203;
      if (*((void *)&v203 + 1) != (void)v203)
      {
        do
        {
          long long v95 = *((_OWORD *)v93 - 1);
          v93 -= 16;
          *((_OWORD *)v92 - 1) = v95;
          v92 -= 16;
        }
        while (v93 != v94);
        uint64_t v93 = (char *)v203;
      }
      *(void *)&long long v203 = v92;
      *((void *)&v203 + 1) = v87;
      *(void *)&v204[0] = &v91[16 * v90];
      if (v93) {
        operator delete(v93);
      }
    }
    else
    {
      **((_OWORD **)&v203 + 1) = v199;
      unint64_t v87 = (_OWORD *)(v86 + 16);
    }
    *((void *)&v203 + 1) = v87;
    *(float32x2_t *)&long long v96 = vcvt_f32_f64(vmulq_f64(v190, v192));
    *((void *)&v96 + 1) = 0x3F80000000000000;
    long long v97 = v201;
    if ((unint64_t)v201 >= v202[0])
    {
      long long v191 = v96;
      uint64_t v99 = (v201 - (unsigned char *)__p) >> 4;
      if ((unint64_t)(v99 + 1) >> 60) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v100 = (uint64_t)(v202[0] - (void)__p) >> 3;
      if (v100 <= v99 + 1) {
        unint64_t v100 = v99 + 1;
      }
      if (v202[0] - (void)__p >= 0x7FFFFFFFFFFFFFF0uLL) {
        unint64_t v101 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v101 = v100;
      }
      if (v101) {
        uint64_t v102 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)v202, v101);
      }
      else {
        uint64_t v102 = 0;
      }
      CMTime v103 = &v102[16 * v99];
      *(_OWORD *)CMTime v103 = v191;
      CMTime v98 = v103 + 16;
      CMTime v105 = (char *)__p;
      CMTime v104 = v201;
      if (v201 != __p)
      {
        do
        {
          long long v106 = *((_OWORD *)v104 - 1);
          v104 -= 16;
          *((_OWORD *)v103 - 1) = v106;
          v103 -= 16;
        }
        while (v104 != v105);
        CMTime v104 = (char *)__p;
      }
      std::string __p = v103;
      unint64_t v201 = v98;
      v202[0] = &v102[16 * v101];
      if (v104) {
        operator delete(v104);
      }
    }
    else
    {
      *(_OWORD *)unint64_t v201 = v96;
      CMTime v98 = v97 + 16;
    }
    unint64_t v201 = v98;
    ++v61;
  }
  while (v61 != 32);
  uint64_t v107 = *((void *)&v203 + 1);
  if (*((void *)&v203 + 1) >= *(void *)&v204[0])
  {
    uint64_t v109 = (uint64_t)(*((void *)&v203 + 1) - v203) >> 4;
    if ((unint64_t)(v109 + 1) >> 60) {
      goto LABEL_260;
    }
    unint64_t v110 = (uint64_t)(*(void *)&v204[0] - v203) >> 3;
    if (v110 <= v109 + 1) {
      unint64_t v110 = v109 + 1;
    }
    if (*(void *)&v204[0] - (void)v203 >= 0x7FFFFFFFFFFFFFF0uLL) {
      unint64_t v111 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v111 = v110;
    }
    if (v111) {
      float64x2_t v112 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)v204, v111);
    }
    else {
      float64x2_t v112 = 0;
    }
    uint64_t v113 = &v112[16 * v109];
    int v114 = &v112[16 * v111];
    *(_OWORD *)uint64_t v113 = xmmword_1B7E75890;
    double v108 = v113 + 16;
    uint64_t v115 = (char *)*((void *)&v203 + 1);
    unint64_t v116 = (char *)v203;
    if (*((void *)&v203 + 1) != (void)v203)
    {
      do
      {
        long long v117 = *((_OWORD *)v115 - 1);
        v115 -= 16;
        *((_OWORD *)v113 - 1) = v117;
        v113 -= 16;
      }
      while (v115 != v116);
      uint64_t v115 = (char *)v203;
    }
    *(void *)&long long v203 = v113;
    *((void *)&v203 + 1) = v108;
    *(void *)&v204[0] = v114;
    if (v115) {
      operator delete(v115);
    }
  }
  else
  {
    **((_OWORD **)&v203 + 1) = xmmword_1B7E75890;
    double v108 = (_OWORD *)(v107 + 16);
  }
  *((void *)&v203 + 1) = v108;
  double v118 = v201;
  if ((unint64_t)v201 >= v202[0])
  {
    uint64_t v120 = (v201 - (unsigned char *)__p) >> 4;
    if ((unint64_t)(v120 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v121 = (uint64_t)(v202[0] - (void)__p) >> 3;
    if (v121 <= v120 + 1) {
      unint64_t v121 = v120 + 1;
    }
    if (v202[0] - (void)__p >= 0x7FFFFFFFFFFFFFF0uLL) {
      unint64_t v122 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v122 = v121;
    }
    if (v122) {
      uint64_t v123 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)v202, v122);
    }
    else {
      uint64_t v123 = 0;
    }
    double v124 = &v123[16 * v120];
    uint64_t v125 = &v123[16 * v122];
    *(_OWORD *)double v124 = v185;
    __n128 v119 = v124 + 16;
    unint64_t v127 = (char *)__p;
    unint64_t v126 = v201;
    if (v201 != __p)
    {
      do
      {
        long long v128 = *((_OWORD *)v126 - 1);
        v126 -= 16;
        *((_OWORD *)v124 - 1) = v128;
        v124 -= 16;
      }
      while (v126 != v127);
      unint64_t v126 = (char *)__p;
    }
    std::string __p = v124;
    unint64_t v201 = v119;
    v202[0] = v125;
    if (v126) {
      operator delete(v126);
    }
  }
  else
  {
    *(_OWORD *)unint64_t v201 = v185;
    __n128 v119 = v118 + 16;
  }
  unint64_t v201 = v119;
  uint64_t v129 = *((void *)&v203 + 1);
  if (*((void *)&v203 + 1) < *(void *)&v204[0])
  {
    **((_OWORD **)&v203 + 1) = v199;
    unsigned int v130 = (_OWORD *)(v129 + 16);
    goto LABEL_179;
  }
  uint64_t v131 = (uint64_t)(*((void *)&v203 + 1) - v203) >> 4;
  if ((unint64_t)(v131 + 1) >> 60) {
LABEL_260:
  }
    std::vector<double>::__throw_length_error[abi:ne180100]();
  unint64_t v132 = (uint64_t)(*(void *)&v204[0] - v203) >> 3;
  if (v132 <= v131 + 1) {
    unint64_t v132 = v131 + 1;
  }
  if (*(void *)&v204[0] - (void)v203 >= 0x7FFFFFFFFFFFFFF0uLL) {
    unint64_t v133 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v133 = v132;
  }
  if (v133) {
    double v134 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)v204, v133);
  }
  else {
    double v134 = 0;
  }
  int v135 = &v134[16 * v131];
  uint64_t v136 = &v134[16 * v133];
  *(_OWORD *)int v135 = v199;
  unsigned int v130 = v135 + 16;
  unint64_t v137 = (char *)*((void *)&v203 + 1);
  unint64_t v138 = (char *)v203;
  if (*((void *)&v203 + 1) != (void)v203)
  {
    do
    {
      long long v139 = *((_OWORD *)v137 - 1);
      v137 -= 16;
      *((_OWORD *)v135 - 1) = v139;
      v135 -= 16;
    }
    while (v137 != v138);
    unint64_t v137 = (char *)v203;
  }
  *(void *)&long long v203 = v135;
  *((void *)&v203 + 1) = v130;
  *(void *)&v204[0] = v136;
  if (v137) {
    operator delete(v137);
  }
LABEL_179:
  *((void *)&v203 + 1) = v130;
  BOOL v140 = v201;
  if ((unint64_t)v201 >= v202[0])
  {
    uint64_t v142 = (v201 - (unsigned char *)__p) >> 4;
    if ((unint64_t)(v142 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v143 = (uint64_t)(v202[0] - (void)__p) >> 3;
    if (v143 <= v142 + 1) {
      unint64_t v143 = v142 + 1;
    }
    if (v202[0] - (void)__p >= 0x7FFFFFFFFFFFFFF0uLL) {
      unint64_t v144 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v144 = v143;
    }
    if (v144) {
      float64_t v145 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)v202, v144);
    }
    else {
      float64_t v145 = 0;
    }
    uint64_t v146 = &v145[16 * v142];
    unint64_t v147 = &v145[16 * v144];
    *(_OWORD *)uint64_t v146 = xmmword_1B8387F70;
    BOOL v141 = v146 + 16;
    uint64_t v149 = (char *)__p;
    unint64_t v148 = v201;
    if (v201 != __p)
    {
      do
      {
        long long v150 = *((_OWORD *)v148 - 1);
        v148 -= 16;
        *((_OWORD *)v146 - 1) = v150;
        v146 -= 16;
      }
      while (v148 != v149);
      unint64_t v148 = (char *)__p;
    }
    std::string __p = v146;
    unint64_t v201 = v141;
    v202[0] = v147;
    if (v148) {
      operator delete(v148);
    }
  }
  else
  {
    *(_OWORD *)unint64_t v201 = xmmword_1B8387F70;
    BOOL v141 = v140 + 16;
  }
  unint64_t v201 = v141;
  HGMetalHandler::PrimitivesDraw((uint64_t)a3, 4u, __p, (unint64_t)(v141 - (unsigned char *)__p) >> 4, (void *)v203);
  uint64_t v196 = 0;
  uint64_t v197 = 0;
  double v198 = 0;
  unint64_t v193 = 0;
  unint64_t v194 = 0;
  uint64_t v195 = 0;
  _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE7reserveEm(&v196, 0x60uLL);
  int v151 = 0;
  double v152 = v197;
  do
  {
    if (v152 >= v198)
    {
      uint64_t v154 = (v152 - (unsigned char *)v196) >> 4;
      if ((unint64_t)(v154 + 1) >> 60) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v155 = (v198 - (unsigned char *)v196) >> 3;
      if (v155 <= v154 + 1) {
        unint64_t v155 = v154 + 1;
      }
      if ((unint64_t)(v198 - (unsigned char *)v196) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v156 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v156 = v155;
      }
      if (v156) {
        uint64_t v157 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v198, v156);
      }
      else {
        uint64_t v157 = 0;
      }
      unint64_t v158 = &v157[16 * v154];
      *(_OWORD *)unint64_t v158 = xmmword_1B7E734D0;
      int v153 = v158 + 16;
      float64_t v160 = (char *)v196;
      unint64_t v159 = v197;
      if (v197 != v196)
      {
        do
        {
          long long v161 = *((_OWORD *)v159 - 1);
          v159 -= 16;
          *((_OWORD *)v158 - 1) = v161;
          v158 -= 16;
        }
        while (v159 != v160);
        unint64_t v159 = (char *)v196;
      }
      uint64_t v196 = v158;
      uint64_t v197 = v153;
      double v198 = &v157[16 * v156];
      if (v159) {
        operator delete(v159);
      }
    }
    else
    {
      *(_OWORD *)double v152 = xmmword_1B7E734D0;
      int v153 = v152 + 16;
    }
    uint64_t v197 = v153;
    __double2 v163 = __sincos_stret(((double)v151 * 0.03125 + (double)v151 * 0.03125) * 3.14159265);
    v162.f64[0] = v163.__cosval;
    v162.f64[1] = v163.__sinval;
    *(float32x2_t *)&long long v164 = vcvt_f32_f64(vmulq_f64(v162, v192));
    *((void *)&v164 + 1) = 0x3F80000000000000;
    if (v153 >= v198)
    {
      long long v188 = v164;
      uint64_t v166 = (v153 - (unsigned char *)v196) >> 4;
      if ((unint64_t)(v166 + 1) >> 60) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v167 = (v198 - (unsigned char *)v196) >> 3;
      if (v167 <= v166 + 1) {
        unint64_t v167 = v166 + 1;
      }
      if ((unint64_t)(v198 - (unsigned char *)v196) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v168 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v168 = v167;
      }
      if (v168) {
        signed int v169 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v198, v168);
      }
      else {
        signed int v169 = 0;
      }
      float64_t v170 = &v169[16 * v166];
      *(_OWORD *)float64_t v170 = v188;
      uint64_t v165 = v170 + 16;
      double v172 = (char *)v196;
      int v171 = v197;
      if (v197 != v196)
      {
        do
        {
          long long v173 = *((_OWORD *)v171 - 1);
          v171 -= 16;
          *((_OWORD *)v170 - 1) = v173;
          v170 -= 16;
        }
        while (v171 != v172);
        int v171 = (char *)v196;
      }
      uint64_t v196 = v170;
      uint64_t v197 = v165;
      double v198 = &v169[16 * v168];
      if (v171) {
        operator delete(v171);
      }
    }
    else
    {
      *(_OWORD *)int v153 = v164;
      uint64_t v165 = v153 + 16;
    }
    ++v151;
    uint64_t v197 = v165;
    __double2 v175 = __sincos_stret(((double)v151 * 0.03125 + (double)v151 * 0.03125) * 3.14159265);
    v174.f64[0] = v175.__cosval;
    v174.f64[1] = v175.__sinval;
    *(float32x2_t *)&long long v176 = vcvt_f32_f64(vmulq_f64(v174, v192));
    *((void *)&v176 + 1) = 0x3F80000000000000;
    if (v165 >= v198)
    {
      long long v189 = v176;
      uint64_t v177 = (v165 - (unsigned char *)v196) >> 4;
      if ((unint64_t)(v177 + 1) >> 60) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v178 = (v198 - (unsigned char *)v196) >> 3;
      if (v178 <= v177 + 1) {
        unint64_t v178 = v177 + 1;
      }
      if ((unint64_t)(v198 - (unsigned char *)v196) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v179 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v179 = v178;
      }
      if (v179) {
        int v180 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v198, v179);
      }
      else {
        int v180 = 0;
      }
      int v181 = &v180[16 * v177];
      *(_OWORD *)int v181 = v189;
      double v152 = v181 + 16;
      uint64_t v183 = (char *)v196;
      float64x2_t v182 = v197;
      if (v197 != v196)
      {
        do
        {
          long long v184 = *((_OWORD *)v182 - 1);
          v182 -= 16;
          *((_OWORD *)v181 - 1) = v184;
          v181 -= 16;
        }
        while (v182 != v183);
        float64x2_t v182 = (char *)v196;
      }
      uint64_t v196 = v181;
      uint64_t v197 = v152;
      double v198 = &v180[16 * v179];
      if (v182) {
        operator delete(v182);
      }
    }
    else
    {
      *(_OWORD *)uint64_t v165 = v176;
      double v152 = v165 + 16;
    }
    uint64_t v197 = v152;
  }
  while (v151 != 32);
  _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE6resizeEmRKS1_((uint64_t)&v193, (v152 - (unsigned char *)v196) >> 4, &v199);
  HGMetalHandler::PrimitivesDraw((uint64_t)a3, 3u, v196, (unint64_t)(v197 - (unsigned char *)v196) >> 4, v193);
  if (v193)
  {
    unint64_t v194 = v193;
    operator delete(v193);
  }
  if (v196)
  {
    uint64_t v197 = (char *)v196;
    operator delete(v196);
  }
  if ((void)v203)
  {
    *((void *)&v203 + 1) = v203;
    operator delete((void *)v203);
  }
  if (__p)
  {
    unint64_t v201 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1B7E10E40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32)
{
  double v34 = *(void **)(v32 - 160);
  if (v34)
  {
    *(void *)(v32 - 152) = v34;
    operator delete(v34);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t PSHeliumNode::updateHandlerWithSprite(PSHeliumNode *this, HGMetalHandler *a2, const PSHeliumNode::Sprite *a3)
{
  unsigned int v5 = *(_DWORD *)a3 - 3;
  if (v5 >= 3)
  {
    HGMetalHandler::DisableBlending((uint64_t)a2);
    v9[0] = *(_OWORD *)((char *)a3 + 8);
  }
  else
  {
    HGMetalHandler::EnableBlending((uint64_t)a2);
    if (v5 == 2) {
      int v6 = 4;
    }
    else {
      int v6 = 1;
    }
    if (*((unsigned char *)a3 + 24)) {
      int v7 = 1;
    }
    else {
      int v7 = 5;
    }
    *(void *)&v9[0] = 0;
    *((void *)&v9[0] + 1) = __PAIR64__(v7, v6);
    v9[1] = xmmword_1B8387F80;
    HGMetalHandler::SetBlendingInfo(a2, (const HGBlendingInfo *)v9);
    v9[0] = *(_OWORD *)((char *)a3 + 8);
    if (v5 != 2) {
      PCWorkingColorVector::operator*=((float32x2_t *)v9, *((float *)v9 + 3));
    }
  }
  return (*(uint64_t (**)(HGMetalHandler *, void, float, float, float, float))(*(void *)a2 + 136))(a2, 0, *(float *)v9, *((float *)v9 + 1), *((float *)v9 + 2), *((float *)v9 + 3));
}

uint64_t PSHeliumNode::commonRenderMetalTexture(uint64_t result, int a2, HGMetalTexture ***this, uint64_t a4, HGBitmap **a5)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (*a5)
  {
    uint64_t v7 = result;
    __n128 v8 = HGMetalHandler::BindTexture(this, 0, *a5);
    ((void (*)(HGMetalTexture ***, void, void, __n128))(*this)[9])(this, 0, 0, v8);
    ((void (*)(HGMetalTexture ***, uint64_t, uint64_t))(*this)[6])(this, 1, 1);
    ((void (*)(HGMetalTexture ***, void))(*this)[10])(this, 0);
    ((void (*)(HGMetalTexture ***))(*this)[11])(this);
    double v9 = *(double *)(a4 + 216);
    double v10 = *(double *)(a4 + 224);
    double v12 = *(double *)(a4 + 232);
    double v11 = *(double *)(a4 + 240);
    PCMatrix44Tmpl<double>::operator*(v7 + 680, (long long *)(a4 + 32), (uint64_t)v26);
    *(double *)&long long v13 = PCMatrix44Tmpl<double>::toSimdFloat((float64_t *)v26);
    long long v27 = v13;
    long long v28 = v14;
    long long v29 = v15;
    long long v30 = v16;
    long long v17 = (PSHeliumNode *)((uint64_t (*)(HGMetalTexture ***, long long *))(*this)[22])(this, &v27);
    PSHeliumNode::updateHandlerWithSprite(v17, (HGMetalHandler *)this, (const PSHeliumNode::Sprite *)a4);
    OZGetCornersFromBounds3d((float)(int)v9, (float)((int)v12 + (int)v9), (float)(int)v10, (float)((int)v11 + (int)v10), (uint64_t)&v20);
    *(void *)&long long v18 = *(void *)v22;
    *((void *)&v18 + 1) = __PAIR64__(1.0, *(unsigned int *)&v22[8]);
    *(void *)&long long v19 = *(void *)&v22[12];
    *((void *)&v19 + 1) = __PAIR64__(1.0, v23);
    v26[0] = v18;
    v26[1] = v19;
    *(void *)&long long v18 = v20;
    DWORD2(v18) = v21;
    *(void *)&long long v19 = v24;
    *((void *)&v19 + 1) = __PAIR64__(1.0, v25);
    v26[2] = v18;
    v26[3] = v19;
    long long v27 = xmmword_1B8387FB0;
    long long v28 = unk_1B8387FC0;
    long long v29 = xmmword_1B8387FD0;
    long long v30 = unk_1B8387FE0;
    return HGMetalHandler::PrimitivesDraw((uint64_t)this, 4u, v26, 4u, &v27);
  }
  return result;
}

void _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE6resizeEmRKS1_(uint64_t a1, unint64_t a2, _OWORD *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE8__appendEmRKS1_((void **)a1, a2 - v3, a3);
  }
}

uint64_t PSHeliumNode::TextureSpriteBatcher::add(PSHeliumNode::TextureSpriteBatcher *this, const PSHeliumNode::Sprite *a2)
{
  uint64_t v131 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a2 != 3 || *(unsigned __int8 *)(*((void *)this + 3) + 417) | *((unsigned __int8 *)a2 + 304)) {
    return 0;
  }
  if (*((unsigned __int8 *)a2 + 24) != *((unsigned __int8 *)this + 40) || *((void *)a2 + 26) != *((void *)this + 4))
  {
    (*(void (**)(PSHeliumNode::TextureSpriteBatcher *))(*(void *)this + 24))(this);
    uint64_t v4 = *((void *)this + 4);
    uint64_t v5 = *((void *)a2 + 26);
    if (v4 != v5)
    {
      if (v4)
      {
        (*(void (**)(void))(*(void *)v4 + 24))(*((void *)this + 4));
        uint64_t v5 = *((void *)a2 + 26);
      }
      *((void *)this + 4) = v5;
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
      }
    }
  }
  *((unsigned char *)this + 40) = *((unsigned char *)a2 + 24);
  PCMatrix44Tmpl<double>::operator*(*((void *)this + 3) + 680, (long long *)a2 + 2, (uint64_t)v128);
  *(double *)&long long v6 = PCMatrix44Tmpl<double>::toSimdFloat((float64_t *)v128);
  long long v123 = v6;
  long long v124 = v7;
  long long v125 = v8;
  long long v126 = v9;
  long long v127 = *(_OWORD *)((char *)a2 + 8);
  PCWorkingColorVector::operator*=((float32x2_t *)&v127, *((float *)&v127 + 3));
  long long v122 = v127;
  OZGetCornersFromBounds3d((float)(int)*((double *)a2 + 27), (float)((int)*((double *)a2 + 29) + (int)*((double *)a2 + 27)), (float)(int)*((double *)a2 + 28), (float)((int)*((double *)a2 + 30) + (int)*((double *)a2 + 28)), (uint64_t)v128);
  *(void *)&long long v10 = *(void *)v128;
  *((void *)&v10 + 1) = __PAIR64__(1.0, LODWORD(v128[2]));
  long long v11 = *(_OWORD *)v129;
  DWORD2(v11) = *(_DWORD *)&v129[8];
  long long v118 = v11;
  long long v12 = *(_OWORD *)&v129[12];
  DWORD2(v12) = *(_DWORD *)&v129[20];
  long long v120 = v12;
  *(void *)&long long v12 = *(void *)&v129[24];
  DWORD2(v12) = v130;
  long long v115 = v10;
  long long v116 = v12;
  unint64_t v13 = *((void *)this + 8);
  long long v14 = (char **)((char *)this + 48);
  long long v15 = (_OWORD *)*((void *)this + 7);
  if ((unint64_t)v15 >= v13)
  {
    uint64_t v18 = 0x6DB6DB6DB6DB6DB7 * (((char *)v15 - *v14) >> 4);
    unint64_t v19 = v18 + 1;
    if ((unint64_t)(v18 + 1) > 0x249249249249249) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v20 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v13 - (void)*v14) >> 4);
    if (2 * v20 > v19) {
      unint64_t v19 = 2 * v20;
    }
    if (v20 >= 0x124924924924924) {
      unint64_t v21 = 0x249249249249249;
    }
    else {
      unint64_t v21 = v19;
    }
    if (v21) {
      uint64_t v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::TextureSpriteBatcher::Vertex>>((uint64_t)this + 64, v21);
    }
    else {
      uint64_t v22 = 0;
    }
    unsigned int v23 = &v22[112 * v18];
    uint64_t v24 = &v22[112 * v21];
    *(_OWORD *)unsigned int v23 = v115;
    *((_OWORD *)v23 + 1) = xmmword_1B7E734D0;
    *((_OWORD *)v23 + 2) = v122;
    *((_OWORD *)v23 + 3) = v123;
    *((_OWORD *)v23 + 4) = v124;
    *((_OWORD *)v23 + 5) = v125;
    *((_OWORD *)v23 + 6) = v126;
    long long v16 = v23 + 112;
    long long v26 = (char *)*((void *)this + 6);
    unsigned int v25 = (char *)*((void *)this + 7);
    if (v25 != v26)
    {
      do
      {
        long long v27 = *((_OWORD *)v25 - 7);
        long long v28 = *((_OWORD *)v25 - 5);
        *((_OWORD *)v23 - 6) = *((_OWORD *)v25 - 6);
        *((_OWORD *)v23 - 5) = v28;
        *((_OWORD *)v23 - 7) = v27;
        long long v29 = *((_OWORD *)v25 - 4);
        long long v30 = *((_OWORD *)v25 - 3);
        long long v31 = *((_OWORD *)v25 - 1);
        *((_OWORD *)v23 - 2) = *((_OWORD *)v25 - 2);
        *((_OWORD *)v23 - 1) = v31;
        *((_OWORD *)v23 - 4) = v29;
        *((_OWORD *)v23 - 3) = v30;
        v23 -= 112;
        v25 -= 112;
      }
      while (v25 != v26);
      unsigned int v25 = *v14;
    }
    *((void *)this + 6) = v23;
    *((void *)this + 7) = v16;
    *((void *)this + 8) = v24;
    if (v25) {
      operator delete(v25);
    }
  }
  else
  {
    _OWORD *v15 = v10;
    v15[1] = xmmword_1B7E734D0;
    v15[2] = v122;
    void v15[3] = v123;
    v15[4] = v124;
    v15[5] = v125;
    v15[6] = v126;
    long long v16 = v15 + 7;
  }
  long long v32 = v118;
  HIDWORD(v32) = 1.0;
  *((void *)this + 7) = v16;
  unint64_t v33 = *((void *)this + 8);
  if ((unint64_t)v16 >= v33)
  {
    long long v119 = v32;
    uint64_t v35 = 0x6DB6DB6DB6DB6DB7 * (((char *)v16 - *v14) >> 4);
    if ((unint64_t)(v35 + 1) > 0x249249249249249) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v36 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v33 - (void)*v14) >> 4);
    uint64_t v37 = 2 * v36;
    if (2 * v36 <= v35 + 1) {
      uint64_t v37 = v35 + 1;
    }
    if (v36 >= 0x124924924924924) {
      unint64_t v38 = 0x249249249249249;
    }
    else {
      unint64_t v38 = v37;
    }
    if (v38) {
      uint64_t v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::TextureSpriteBatcher::Vertex>>((uint64_t)this + 64, v38);
    }
    else {
      uint64_t v39 = 0;
    }
    uint64_t v40 = &v39[112 * v35];
    uint64_t v41 = &v39[112 * v38];
    *(_OWORD *)uint64_t v40 = v119;
    *((_OWORD *)v40 + 1) = xmmword_1B7E73E70;
    *((_OWORD *)v40 + 2) = v122;
    *((_OWORD *)v40 + 3) = v123;
    *((_OWORD *)v40 + 4) = v124;
    *((_OWORD *)v40 + 5) = v125;
    *((_OWORD *)v40 + 6) = v126;
    double v34 = v40 + 112;
    unint64_t v43 = (char *)*((void *)this + 6);
    unint64_t v42 = (char *)*((void *)this + 7);
    if (v42 != v43)
    {
      do
      {
        long long v44 = *((_OWORD *)v42 - 7);
        long long v45 = *((_OWORD *)v42 - 5);
        *((_OWORD *)v40 - 6) = *((_OWORD *)v42 - 6);
        *((_OWORD *)v40 - 5) = v45;
        *((_OWORD *)v40 - 7) = v44;
        long long v46 = *((_OWORD *)v42 - 4);
        long long v47 = *((_OWORD *)v42 - 3);
        long long v48 = *((_OWORD *)v42 - 1);
        *((_OWORD *)v40 - 2) = *((_OWORD *)v42 - 2);
        *((_OWORD *)v40 - 1) = v48;
        *((_OWORD *)v40 - 4) = v46;
        *((_OWORD *)v40 - 3) = v47;
        v40 -= 112;
        v42 -= 112;
      }
      while (v42 != v43);
      unint64_t v42 = *v14;
    }
    *((void *)this + 6) = v40;
    *((void *)this + 7) = v34;
    *((void *)this + 8) = v41;
    if (v42) {
      operator delete(v42);
    }
  }
  else
  {
    _OWORD *v16 = v32;
    v16[1] = xmmword_1B7E73E70;
    v16[2] = v122;
    void v16[3] = v123;
    v16[4] = v124;
    v16[5] = v125;
    v16[6] = v126;
    double v34 = v16 + 7;
  }
  long long v49 = v120;
  HIDWORD(v49) = 1.0;
  *((void *)this + 7) = v34;
  unint64_t v50 = *((void *)this + 8);
  long long v121 = v49;
  if ((unint64_t)v34 >= v50)
  {
    uint64_t v52 = 0x6DB6DB6DB6DB6DB7 * (((char *)v34 - *v14) >> 4);
    if ((unint64_t)(v52 + 1) > 0x249249249249249) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v53 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v50 - (void)*v14) >> 4);
    uint64_t v54 = 2 * v53;
    if (2 * v53 <= v52 + 1) {
      uint64_t v54 = v52 + 1;
    }
    if (v53 >= 0x124924924924924) {
      unint64_t v55 = 0x249249249249249;
    }
    else {
      unint64_t v55 = v54;
    }
    if (v55) {
      float64x2_t v56 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::TextureSpriteBatcher::Vertex>>((uint64_t)this + 64, v55);
    }
    else {
      float64x2_t v56 = 0;
    }
    uint64_t v57 = &v56[112 * v52];
    long long v58 = &v56[112 * v55];
    *(_OWORD *)uint64_t v57 = v121;
    *((_OWORD *)v57 + 1) = xmmword_1B7E75640;
    *((_OWORD *)v57 + 2) = v122;
    *((_OWORD *)v57 + 3) = v123;
    *((_OWORD *)v57 + 4) = v124;
    *((_OWORD *)v57 + 5) = v125;
    *((_OWORD *)v57 + 6) = v126;
    uint64_t v51 = v57 + 112;
    long long v60 = (char *)*((void *)this + 6);
    long long v59 = (char *)*((void *)this + 7);
    if (v59 != v60)
    {
      do
      {
        long long v61 = *((_OWORD *)v59 - 7);
        long long v62 = *((_OWORD *)v59 - 5);
        *((_OWORD *)v57 - 6) = *((_OWORD *)v59 - 6);
        *((_OWORD *)v57 - 5) = v62;
        *((_OWORD *)v57 - 7) = v61;
        long long v63 = *((_OWORD *)v59 - 4);
        long long v64 = *((_OWORD *)v59 - 3);
        long long v65 = *((_OWORD *)v59 - 1);
        *((_OWORD *)v57 - 2) = *((_OWORD *)v59 - 2);
        *((_OWORD *)v57 - 1) = v65;
        *((_OWORD *)v57 - 4) = v63;
        *((_OWORD *)v57 - 3) = v64;
        v57 -= 112;
        v59 -= 112;
      }
      while (v59 != v60);
      long long v59 = *v14;
    }
    *((void *)this + 6) = v57;
    *((void *)this + 7) = v51;
    *((void *)this + 8) = v58;
    if (v59) {
      operator delete(v59);
    }
  }
  else
  {
    *double v34 = v49;
    v34[1] = xmmword_1B7E75640;
    PCString v34[2] = v122;
    v34[3] = v123;
    v34[4] = v124;
    v34[5] = v125;
    HGRect v34[6] = v126;
    uint64_t v51 = v34 + 7;
  }
  *((void *)this + 7) = v51;
  unint64_t v66 = *((void *)this + 8);
  if ((unint64_t)v51 >= v66)
  {
    uint64_t v68 = 0x6DB6DB6DB6DB6DB7 * (((char *)v51 - *v14) >> 4);
    if ((unint64_t)(v68 + 1) > 0x249249249249249) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v69 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v66 - (void)*v14) >> 4);
    uint64_t v70 = 2 * v69;
    if (2 * v69 <= v68 + 1) {
      uint64_t v70 = v68 + 1;
    }
    if (v69 >= 0x124924924924924) {
      unint64_t v71 = 0x249249249249249;
    }
    else {
      unint64_t v71 = v70;
    }
    if (v71) {
      long long v72 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::TextureSpriteBatcher::Vertex>>((uint64_t)this + 64, v71);
    }
    else {
      long long v72 = 0;
    }
    float64x2_t v73 = &v72[112 * v68];
    __double2 v74 = &v72[112 * v71];
    *(_OWORD *)float64x2_t v73 = v115;
    *((_OWORD *)v73 + 1) = xmmword_1B7E734D0;
    *((_OWORD *)v73 + 2) = v122;
    *((_OWORD *)v73 + 3) = v123;
    *((_OWORD *)v73 + 4) = v124;
    *((_OWORD *)v73 + 5) = v125;
    *((_OWORD *)v73 + 6) = v126;
    unint64_t v67 = v73 + 112;
    uint64_t v76 = (char *)*((void *)this + 6);
    long long v75 = (char *)*((void *)this + 7);
    if (v75 != v76)
    {
      do
      {
        long long v77 = *((_OWORD *)v75 - 7);
        long long v78 = *((_OWORD *)v75 - 5);
        *((_OWORD *)v73 - 6) = *((_OWORD *)v75 - 6);
        *((_OWORD *)v73 - 5) = v78;
        *((_OWORD *)v73 - 7) = v77;
        long long v79 = *((_OWORD *)v75 - 4);
        long long v80 = *((_OWORD *)v75 - 3);
        long long v81 = *((_OWORD *)v75 - 1);
        *((_OWORD *)v73 - 2) = *((_OWORD *)v75 - 2);
        *((_OWORD *)v73 - 1) = v81;
        *((_OWORD *)v73 - 4) = v79;
        *((_OWORD *)v73 - 3) = v80;
        v73 -= 112;
        v75 -= 112;
      }
      while (v75 != v76);
      long long v75 = *v14;
    }
    *((void *)this + 6) = v73;
    *((void *)this + 7) = v67;
    *((void *)this + 8) = v74;
    if (v75) {
      operator delete(v75);
    }
  }
  else
  {
    _OWORD *v51 = v115;
    v51[1] = xmmword_1B7E734D0;
    v51[2] = v122;
    _DWORD v51[3] = v123;
    v51[4] = v124;
    v51[5] = v125;
    v51[6] = v126;
    unint64_t v67 = v51 + 7;
  }
  *((void *)this + 7) = v67;
  unint64_t v82 = *((void *)this + 8);
  if ((unint64_t)v67 >= v82)
  {
    uint64_t v84 = 0x6DB6DB6DB6DB6DB7 * (((char *)v67 - *v14) >> 4);
    if ((unint64_t)(v84 + 1) > 0x249249249249249) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v85 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v82 - (void)*v14) >> 4);
    uint64_t v86 = 2 * v85;
    if (2 * v85 <= v84 + 1) {
      uint64_t v86 = v84 + 1;
    }
    if (v85 >= 0x124924924924924) {
      unint64_t v87 = 0x249249249249249;
    }
    else {
      unint64_t v87 = v86;
    }
    if (v87) {
      uint64_t v88 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::TextureSpriteBatcher::Vertex>>((uint64_t)this + 64, v87);
    }
    else {
      uint64_t v88 = 0;
    }
    unint64_t v89 = &v88[112 * v84];
    unint64_t v90 = &v88[112 * v87];
    *(_OWORD *)unint64_t v89 = v121;
    *((_OWORD *)v89 + 1) = xmmword_1B7E75640;
    *((_OWORD *)v89 + 2) = v122;
    *((_OWORD *)v89 + 3) = v123;
    *((_OWORD *)v89 + 4) = v124;
    *((_OWORD *)v89 + 5) = v125;
    *((_OWORD *)v89 + 6) = v126;
    CMTime v83 = v89 + 112;
    OZRenderState v92 = (char *)*((void *)this + 6);
    long long v91 = (char *)*((void *)this + 7);
    if (v91 != v92)
    {
      do
      {
        long long v93 = *((_OWORD *)v91 - 7);
        long long v94 = *((_OWORD *)v91 - 5);
        *((_OWORD *)v89 - 6) = *((_OWORD *)v91 - 6);
        *((_OWORD *)v89 - 5) = v94;
        *((_OWORD *)v89 - 7) = v93;
        long long v95 = *((_OWORD *)v91 - 4);
        long long v96 = *((_OWORD *)v91 - 3);
        long long v97 = *((_OWORD *)v91 - 1);
        *((_OWORD *)v89 - 2) = *((_OWORD *)v91 - 2);
        *((_OWORD *)v89 - 1) = v97;
        *((_OWORD *)v89 - 4) = v95;
        *((_OWORD *)v89 - 3) = v96;
        v89 -= 112;
        v91 -= 112;
      }
      while (v91 != v92);
      long long v91 = *v14;
    }
    *((void *)this + 6) = v89;
    *((void *)this + 7) = v83;
    *((void *)this + 8) = v90;
    if (v91) {
      operator delete(v91);
    }
  }
  else
  {
    *unint64_t v67 = v121;
    v67[1] = xmmword_1B7E75640;
    v67[2] = v122;
    v67[3] = v123;
    v67[4] = v124;
    v67[5] = v125;
    v67[6] = v126;
    CMTime v83 = v67 + 7;
  }
  long long v98 = v116;
  HIDWORD(v98) = 1.0;
  *((void *)this + 7) = v83;
  unint64_t v99 = *((void *)this + 8);
  if ((unint64_t)v83 >= v99)
  {
    long long v117 = v98;
    uint64_t v101 = 0x6DB6DB6DB6DB6DB7 * (((char *)v83 - *v14) >> 4);
    if ((unint64_t)(v101 + 1) > 0x249249249249249) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v102 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v99 - (void)*v14) >> 4);
    uint64_t v103 = 2 * v102;
    if (2 * v102 <= v101 + 1) {
      uint64_t v103 = v101 + 1;
    }
    if (v102 >= 0x124924924924924) {
      unint64_t v104 = 0x249249249249249;
    }
    else {
      unint64_t v104 = v103;
    }
    if (v104) {
      CMTime v105 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::TextureSpriteBatcher::Vertex>>((uint64_t)this + 64, v104);
    }
    else {
      CMTime v105 = 0;
    }
    long long v106 = &v105[112 * v101];
    uint64_t v107 = &v105[112 * v104];
    *(_OWORD *)long long v106 = v117;
    *((_OWORD *)v106 + 1) = xmmword_1B7E74540;
    *((_OWORD *)v106 + 2) = v122;
    *((_OWORD *)v106 + 3) = v123;
    *((_OWORD *)v106 + 4) = v124;
    *((_OWORD *)v106 + 5) = v125;
    *((_OWORD *)v106 + 6) = v126;
    unint64_t v100 = v106 + 112;
    uint64_t v109 = (char *)*((void *)this + 6);
    double v108 = (char *)*((void *)this + 7);
    if (v108 != v109)
    {
      do
      {
        long long v110 = *((_OWORD *)v108 - 7);
        long long v111 = *((_OWORD *)v108 - 5);
        *((_OWORD *)v106 - 6) = *((_OWORD *)v108 - 6);
        *((_OWORD *)v106 - 5) = v111;
        *((_OWORD *)v106 - 7) = v110;
        long long v112 = *((_OWORD *)v108 - 4);
        long long v113 = *((_OWORD *)v108 - 3);
        long long v114 = *((_OWORD *)v108 - 1);
        *((_OWORD *)v106 - 2) = *((_OWORD *)v108 - 2);
        *((_OWORD *)v106 - 1) = v114;
        *((_OWORD *)v106 - 4) = v112;
        *((_OWORD *)v106 - 3) = v113;
        v106 -= 112;
        v108 -= 112;
      }
      while (v108 != v109);
      double v108 = *v14;
    }
    *((void *)this + 6) = v106;
    *((void *)this + 7) = v100;
    *((void *)this + 8) = v107;
    if (v108) {
      operator delete(v108);
    }
  }
  else
  {
    _OWORD *v83 = v98;
    v83[1] = xmmword_1B7E74540;
    v83[2] = v122;
    v83[3] = v123;
    v83[4] = v124;
    v83[5] = v125;
    v83[6] = v126;
    unint64_t v100 = v83 + 7;
  }
  *((void *)this + 7) = v100;
  return 1;
}

void *PSHeliumNode::TextureSpriteBatcher::flush(void *this)
{
  uint64_t v1 = this[6];
  if (v1 != this[7])
  {
    uint64_t v2 = this;
    if (this[4])
    {
      {
        HGMetalUtils::stringForMetalHeader((uint64_t)&__p);
        long long v7 = std::string::append((std::string *)&__p, "\n        struct Vertex\n        {\n            float4 position;\n"
               "            float4 texCoord;\n"
               "            float4 color;\n"
               "            float4x4 mv;\n"
               "        };\n"
               "\n"
               "        struct VertexInOut\n"
               "        {\n"
               "            float4 _position  [[ position ]];\n"
               "            float4 _texCoord;\n"
               "            float4 _color;\n"
               "        };\n"
               "    \n"
               "        struct FragmentOut\n"
               "        {\n"
               "            float4 color0     [[ color(0) ]];\n"
               "        };\n"
               "    \n"
               "        vertex VertexInOut vertexFunc(constant float4x4 *matrices [[ buffer(0) ]],\n"
               "                                      const device Vertex *vertices [[ buffer(1) ]],\n"
               "                                      uint vid [[ vertex_id ]])\n"
               "        {\n"
               "            constant float4x4 *projectionMatrix = matrices;\n"
               "            VertexInOut vert;\n"
               "            vert._position = *projectionMatrix * vertices[vid].mv * vertices[vid].position;\n"
               "            vert._texCoord = vertices[vid].texCoord;\n"
               "            vert._color = vertices[vid].color;\n"
               "            return vert;\n"
               "        }\n"
               "    \n"
               "        fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]],\n"
               "                                          texture2d< float > hg_Texture0 [[ texture(0) ]],\n"
               "                                          sampler hg_Sampler0 [[ sampler(0) ]])\n"
               "        {\n"
               "            FragmentOut out;\n"
               "            out.color0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord.xy) * frag._color;\n"
               "            return out;\n"
               "        }\n"
               "    ");
        long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
        unk_1E9EE6670 = *((void *)&v7->__r_.__value_.__l + 2);
        PSHeliumNode::TextureSpriteBatcher::flush(void)::shaderText = v8;
        v7->__r_.__value_.__l.__size_ = 0;
        v7->__r_.__value_.__r.__words[2] = 0;
        v7->__r_.__value_.__r.__words[0] = 0;
        if (SBYTE7(v12) < 0) {
          operator delete(__p);
        }
        __cxa_atexit(MEMORY[0x1E4FBA210], &PSHeliumNode::TextureSpriteBatcher::flush(void)::shaderText, &dword_1B73F3000);
      }
      if (*(_DWORD *)(v2[3] + 896) != 6)
      {
        if (byte_1E9EE6677 >= 0) {
          unint64_t v3 = &PSHeliumNode::TextureSpriteBatcher::flush(void)::shaderText;
        }
        else {
          unint64_t v3 = (long long *)PSHeliumNode::TextureSpriteBatcher::flush(void)::shaderText;
        }
        (*(void (**)(void, long long *))(**(void **)v2[1] + 376))(*(void *)v2[1], v3);
        *(_DWORD *)(v2[3] + 896) = 6;
      }
      this = (void *)v2[2];
      if (this)
      {
        HGHandler::LoadIdentityModelViewMatrix((HGHandler *)this);
        HGMetalHandler::EnableBlending(v2[2]);
        if (*((unsigned char *)v2 + 40)) {
          int v4 = 1;
        }
        else {
          int v4 = 5;
        }
        uint64_t v5 = (HGMetalHandler *)v2[2];
        std::string __p = 0;
        int v10 = 1;
        int v11 = v4;
        long long v12 = xmmword_1B8387F80;
        HGMetalHandler::SetBlendingInfo(v5, (const HGBlendingInfo *)&__p);
        __n128 v6 = HGMetalHandler::BindTexture((HGMetalTexture ***)v2[2], 0, (HGBitmap *)v2[4]);
        (*(void (**)(void, void, void, __n128))(*(void *)v2[2] + 72))(v2[2], 0, 0, v6);
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)v2[2] + 48))(v2[2], 1, 1);
        (*(void (**)(void, void))(*(void *)v2[2] + 80))(v2[2], 0);
        (*(void (**)(void))(*(void *)v2[2] + 88))(v2[2]);
        HGMetalHandler::SetVertices((HGMetalHandler *)v2[2], (const void *)v2[6], 112, -1227133513 * ((v2[7] - v2[6]) >> 4));
        HGMetalHandler::PrimitivesStart((HGMetalHandler *)v2[2]);
        HGMetalHandler::Primitives(v2[2], 3);
        HGMetalHandler::PrimitivesEnd((HGMetalHandler *)v2[2]);
      }
      uint64_t v1 = v2[6];
    }
    v2[7] = v1;
  }
  return this;
}

void sub_1B7E11EFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL PSHeliumNode::PointSpriteBatcher::add(PSHeliumNode::PointSpriteBatcher *this, const PSHeliumNode::Sprite *a2)
{
  int v2 = *(_DWORD *)a2;
  if (!*(_DWORD *)a2)
  {
    PCMatrix44Tmpl<double>::operator*(*((void *)this + 3) + 680, (long long *)a2 + 2, (uint64_t)v38);
    *(double *)&long long v5 = PCMatrix44Tmpl<double>::toSimdFloat(v38);
    long long v9 = *(_OWORD *)((char *)a2 + 8);
    *(float32x2_t *)&long long v11 = vcvt_f32_f64(*((float64x2_t *)a2 + 16));
    *(float *)&unsigned int v10 = *((double *)a2 + 34);
    *((void *)&v11 + 1) = __PAIR64__(1.0, v10);
    float v12 = *((double *)a2 + 31);
    unint64_t v13 = *((void *)this + 6);
    unint64_t v14 = *((void *)this + 5);
    if (v14 >= v13)
    {
      uint64_t v16 = *((void *)this + 4);
      uint64_t v17 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v14 - v16) >> 4);
      unint64_t v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) > 0x249249249249249) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v19 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v13 - v16) >> 4);
      if (2 * v19 > v18) {
        unint64_t v18 = 2 * v19;
      }
      if (v19 >= 0x124924924924924) {
        unint64_t v20 = 0x249249249249249;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20)
      {
        long long v36 = v7;
        long long v37 = v8;
        long long v34 = v5;
        long long v35 = v6;
        long long v32 = v11;
        long long v33 = *(_OWORD *)((char *)a2 + 8);
        unint64_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::TextureSpriteBatcher::Vertex>>((uint64_t)this + 48, v20);
        long long v11 = v32;
        long long v9 = v33;
        long long v5 = v34;
        long long v6 = v35;
        long long v7 = v36;
        long long v8 = v37;
      }
      else
      {
        unint64_t v21 = 0;
      }
      uint64_t v22 = &v21[112 * v17];
      unsigned int v23 = &v21[112 * v20];
      *(_OWORD *)uint64_t v22 = v11;
      *((_OWORD *)v22 + 1) = v9;
      *((_OWORD *)v22 + 2) = v5;
      *((_OWORD *)v22 + 3) = v6;
      *((_OWORD *)v22 + 4) = v7;
      *((_OWORD *)v22 + 5) = v8;
      *((float *)v22 + 24) = v12;
      *(void *)(v22 + 100) = 0;
      *((_DWORD *)v22 + 27) = 0;
      long long v15 = v22 + 112;
      unsigned int v25 = (char *)*((void *)this + 4);
      uint64_t v24 = (char *)*((void *)this + 5);
      if (v24 != v25)
      {
        do
        {
          long long v26 = *((_OWORD *)v24 - 7);
          long long v27 = *((_OWORD *)v24 - 5);
          *((_OWORD *)v22 - 6) = *((_OWORD *)v24 - 6);
          *((_OWORD *)v22 - 5) = v27;
          *((_OWORD *)v22 - 7) = v26;
          long long v28 = *((_OWORD *)v24 - 4);
          long long v29 = *((_OWORD *)v24 - 3);
          long long v30 = *((_OWORD *)v24 - 1);
          *((_OWORD *)v22 - 2) = *((_OWORD *)v24 - 2);
          *((_OWORD *)v22 - 1) = v30;
          *((_OWORD *)v22 - 4) = v28;
          *((_OWORD *)v22 - 3) = v29;
          v22 -= 112;
          v24 -= 112;
        }
        while (v24 != v25);
        uint64_t v24 = (char *)*((void *)this + 4);
      }
      *((void *)this + 4) = v22;
      *((void *)this + 5) = v15;
      *((void *)this + 6) = v23;
      if (v24) {
        operator delete(v24);
      }
    }
    else
    {
      *(_OWORD *)unint64_t v14 = v11;
      *(_OWORD *)(v14 + 16) = v9;
      *(_OWORD *)(v14 + 32) = v5;
      *(_OWORD *)(v14 + 48) = v6;
      *(_OWORD *)(v14 + 64) = v7;
      *(_OWORD *)(v14 + 80) = v8;
      *(float *)(v14 + 96) = v12;
      *(void *)(v14 + 100) = 0;
      long long v15 = (char *)(v14 + 112);
      *(_DWORD *)(v14 + 108) = 0;
    }
    *((void *)this + 5) = v15;
  }
  return v2 == 0;
}

void *PSHeliumNode::PointSpriteBatcher::flush(void *this)
{
  if (this[4] != this[5])
  {
    uint64_t v1 = this;
    {
      HGMetalUtils::stringForMetalHeader((uint64_t)&v5);
      unint64_t v3 = std::string::append(&v5, "\n        struct Vertex\n        {\n            float4 position;\n"
             "            float4 color;\n"
             "            float4x4 mv;\n"
             "            float pointSize;\n"
             "        };\n"
             "    \n"
             "        struct VertexInOut\n"
             "        {\n"
             "            float4 _position  [[ position ]];\n"
             "            float  _pointSize [[ point_size ]];\n"
             "            float4 _color;\n"
             "        };\n"
             "    \n"
             "        struct FragmentOut\n"
             "        {\n"
             "            float4 color0     [[ color(0) ]];\n"
             "        };\n"
             "    \n"
             "        vertex VertexInOut vertexFunc(constant float4x4 *matrices [[ buffer(0) ]],\n"
             "                                      const device Vertex *vertices [[ buffer(1) ]],\n"
             "                                      uint vid [[ vertex_id ]])\n"
             "        {\n"
             "            constant float4x4 *projectionMatrix = matrices;\n"
             "            VertexInOut vert;\n"
             "            vert._position = *projectionMatrix * vertices[vid].mv * vertices[vid].position;\n"
             "            vert._pointSize = vertices[vid].pointSize;\n"
             "            vert._color = vertices[vid].color;\n"
             "            return vert;\n"
             "        }\n"
             "    \n"
             "        fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]])\n"
             "        {\n"
             "            FragmentOut out;\n"
             "            out.color0 = frag._color;\n"
             "            return out;\n"
             "        }\n"
             "    ");
      long long v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
      unk_1E9EE6690 = *((void *)&v3->__r_.__value_.__l + 2);
      PSHeliumNode::PointSpriteBatcher::flush(void)::shaderText = v4;
      v3->__r_.__value_.__l.__size_ = 0;
      v3->__r_.__value_.__r.__words[2] = 0;
      v3->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v5.__r_.__value_.__l.__data_);
      }
      __cxa_atexit(MEMORY[0x1E4FBA210], &PSHeliumNode::PointSpriteBatcher::flush(void)::shaderText, &dword_1B73F3000);
    }
    if (*(_DWORD *)(v1[3] + 896) != 7)
    {
      if (byte_1E9EE6697 >= 0) {
        int v2 = &PSHeliumNode::PointSpriteBatcher::flush(void)::shaderText;
      }
      else {
        int v2 = (long long *)PSHeliumNode::PointSpriteBatcher::flush(void)::shaderText;
      }
      (*(void (**)(void, long long *))(**(void **)v1[1] + 376))(*(void *)v1[1], v2);
      *(_DWORD *)(v1[3] + 896) = 7;
    }
    this = (void *)v1[2];
    if (this)
    {
      HGHandler::LoadIdentityModelViewMatrix((HGHandler *)this);
      HGMetalHandler::DisableBlending(v1[2]);
      HGMetalHandler::SetVertices((HGMetalHandler *)v1[2], (const void *)v1[4], 112, -1227133513 * ((v1[5] - v1[4]) >> 4));
      HGMetalHandler::PrimitivesStart((HGMetalHandler *)v1[2]);
      HGMetalHandler::Primitives(v1[2], 0);
      HGMetalHandler::PrimitivesEnd((HGMetalHandler *)v1[2]);
    }
    v1[5] = v1[4];
  }
  return this;
}

void sub_1B7E122AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void PSHeliumNode::SpriteBatchController::SpriteBatchController(PSHeliumNode::SpriteBatchController *this, HGPage *a2, HGMetalHandler *a3, PSHeliumNode *a4)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  operator new();
}

void sub_1B7E12518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14)
{
}

void PSHeliumNode::TextureSpriteBatcher::~TextureSpriteBatcher(PSHeliumNode::TextureSpriteBatcher *this)
{
  *(void *)this = &unk_1F11979A8;
  int v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((void *)this + 4);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
}

{
  void *v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F11979A8;
  int v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((void *)this + 4);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void PSHeliumNode::PointSpriteBatcher::~PointSpriteBatcher(PSHeliumNode::PointSpriteBatcher *this)
{
  *(void *)this = &unk_1F1197A00;
  int v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F1197A00;
  int v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void anonymous namespace'::HGNodeBuffer::~HGNodeBuffer(_anonymous_namespace_::HGNodeBuffer *this)
{
  HGBuffer::~HGBuffer(this);

  HGObject::operator delete(v1);
}

void anonymous namespace'::HGNodeBuffer::ReadTile(_anonymous_namespace_::HGNodeBuffer *this, char *a2, HGRect a3, uint64_t a4)
{
  uint64_t v5 = *((void *)this + 17);
  int v6 = *(_DWORD *)(v5 + 36);
  int v7 = *(_DWORD *)(v5 + 112);
  HGExecutionUnit::RenderTile(v5, a2, *(unint64_t *)&a3.var0, *(unint64_t *)&a3.var2, *((void *)this + 16), a4);
  uint64_t v8 = *((void *)this + 17);
  *(_DWORD *)(v8 + 36) = v6;
  *(_DWORD *)(v8 + 112) = v7;
}

uint64_t *std::__tree<PSHeliumNode::Sprite *,PSHeliumNode::lessThanSprite,std::allocator<PSHeliumNode::Sprite *>>::__emplace_hint_unique_key_args<PSHeliumNode::Sprite *,PSHeliumNode::Sprite * const&>(uint64_t **a1, void *a2, uint64_t a3, uint64_t *a4)
{
  int v6 = (uint64_t **)std::__tree<PSHeliumNode::Sprite *,PSHeliumNode::lessThanSprite,std::allocator<PSHeliumNode::Sprite *>>::__find_equal<PSHeliumNode::Sprite *>(a1, a2, &v11, &v10, a3);
  int v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = v6;
    int v7 = (uint64_t *)operator new(0x28uLL);
    v7[4] = *a4;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v11, v8, v7);
  }
  return v7;
}

void *std::__tree<PSHeliumNode::Sprite *,PSHeliumNode::lessThanSprite,std::allocator<PSHeliumNode::Sprite *>>::__find_equal<PSHeliumNode::Sprite *>(void *a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *(_DWORD *)(*(void *)a5 + 4), unsigned int v7 = *(_DWORD *)(a2[4] + 4), v6 < v7))
  {
    uint64_t v8 = *a2;
    if ((void *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      long long v9 = (void *)*a2;
      do
      {
        uint64_t v10 = v9;
        long long v9 = (void *)v9[1];
      }
      while (v9);
    }
    else
    {
      unint64_t v13 = a2;
      do
      {
        uint64_t v10 = (void *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        unint64_t v13 = v10;
      }
      while (v14);
    }
    unsigned int v15 = *(_DWORD *)(*(void *)a5 + 4);
    if (*(_DWORD *)(v10[4] + 4) < v15) {
      goto LABEL_17;
    }
    uint64_t v16 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = v16;
          unsigned int v18 = *(_DWORD *)(v16[4] + 4);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = (void *)*v17;
          uint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        uint64_t v5 = v17 + 1;
        uint64_t v16 = (void *)v17[1];
      }
      while (v16);
    }
    else
    {
      uint64_t v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    float v12 = (void *)a2[1];
    do
    {
      a4 = v12;
      float v12 = (void *)*v12;
    }
    while (v12);
  }
  else
  {
    unint64_t v19 = a2;
    do
    {
      a4 = (void *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      unint64_t v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *(_DWORD *)(a4[4] + 4))
  {
    unint64_t v20 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          unint64_t v21 = v20;
          unsigned int v22 = *(_DWORD *)(v20[4] + 4);
          if (v6 >= v22) {
            break;
          }
          unint64_t v20 = (void *)*v21;
          uint64_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        uint64_t v5 = v21 + 1;
        unint64_t v20 = (void *)v21[1];
      }
      while (v20);
    }
    else
    {
      unint64_t v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void std::vector<PSHeliumNode::Sprite>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 312;
        std::allocator<PSHeliumNode::Sprite>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::allocator<PSHeliumNode::Sprite>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a2 + 208);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
  }
  return result;
}

void std::__tree<std::shared_ptr<PCImage>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::shared_ptr<PCImage>>::destroy(a1, *a2);
    std::__tree<std::shared_ptr<PCImage>>::destroy(a1, a2[1]);
    uint64_t v4 = (std::__shared_weak_count *)a2[5];
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
    operator delete(a2);
  }
}

void std::vector<std::unique_ptr<PSHeliumNode::BatcherBase>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  int v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<PSHeliumNode::BatcherBase>>::__clear[abi:ne180100](v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void *std::vector<std::unique_ptr<PSHeliumNode::BatcherBase>>::__clear[abi:ne180100](void *result)
{
  uint64_t v1 = result;
  int v2 = (void *)*result;
  uint64_t v3 = (void *)result[1];
  while (v3 != v2)
  {
    uint64_t v4 = (void *)*--v3;
    uint64_t result = v4;
    void *v3 = 0;
    if (v4) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  v1[1] = v2;
  return result;
}

uint64_t std::vector<PSHeliumNode::Sprite>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>,std::reverse_iterator<PSHeliumNode::Sprite*>,std::reverse_iterator<PSHeliumNode::Sprite*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::Sprite>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xD20D20D20D20D3) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(312 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>,std::reverse_iterator<PSHeliumNode::Sprite*>,std::reverse_iterator<PSHeliumNode::Sprite*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  char v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      v9 -= 312;
      std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(a1, v7 - 312, v9);
      uint64_t v7 = *((void *)&v16 + 1) - 312;
      *((void *)&v16 + 1) -= 312;
    }
    while (v9 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

void sub_1B7E12D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

__n128 std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a2 = *(_OWORD *)a3;
  long long v5 = *(_OWORD *)(a3 + 16);
  long long v6 = *(_OWORD *)(a3 + 32);
  long long v7 = *(_OWORD *)(a3 + 64);
  *(_OWORD *)(a2 + 48) = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 64) = v7;
  *(_OWORD *)(a2 + 16) = v5;
  *(_OWORD *)(a2 + 32) = v6;
  long long v8 = *(_OWORD *)(a3 + 80);
  long long v9 = *(_OWORD *)(a3 + 96);
  long long v10 = *(_OWORD *)(a3 + 128);
  *(_OWORD *)(a2 + 112) = *(_OWORD *)(a3 + 112);
  *(_OWORD *)(a2 + 128) = v10;
  *(_OWORD *)(a2 + 80) = v8;
  *(_OWORD *)(a2 + 96) = v9;
  long long v11 = *(_OWORD *)(a3 + 144);
  long long v12 = *(_OWORD *)(a3 + 160);
  long long v13 = *(_OWORD *)(a3 + 176);
  *(_OWORD *)(a2 + 188) = *(_OWORD *)(a3 + 188);
  *(_OWORD *)(a2 + 160) = v12;
  *(_OWORD *)(a2 + 176) = v13;
  *(_OWORD *)(a2 + 144) = v11;
  uint64_t v14 = *(void *)(a3 + 208);
  *(void *)(a2 + 208) = v14;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 16))(v14);
  }
  long long v15 = *(_OWORD *)(a3 + 216);
  long long v16 = *(_OWORD *)(a3 + 232);
  *(void *)(a2 + 248) = *(void *)(a3 + 248);
  *(_OWORD *)(a2 + 232) = v16;
  *(_OWORD *)(a2 + 216) = v15;
  *(_OWORD *)(a2 + 256) = *(_OWORD *)(a3 + 256);
  *(_OWORD *)(a2 + 272) = *(_OWORD *)(a3 + 272);
  __n128 result = *(__n128 *)(a3 + 288);
  *(__n128 *)(a2 + 288) = result;
  *(unsigned char *)(a2 + 304) = *(unsigned char *)(a3 + 304);
  return result;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

uint64_t *std::_AllocatorDestroyRangeReverse<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>>::operator()[abi:ne180100](uint64_t *result)
{
  uint64_t v1 = *(void *)(result[2] + 8);
  uint64_t v2 = *(void *)(result[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *result;
    do
    {
      __n128 result = (uint64_t *)std::allocator<PSHeliumNode::Sprite>::destroy[abi:ne180100](v3, v1);
      v1 += 312;
    }
    while (v1 != v2);
  }
  return result;
}

void **std::__split_buffer<PSHeliumNode::Sprite>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

uint64_t std::__split_buffer<PSHeliumNode::Sprite>::clear[abi:ne180100](uint64_t result)
{
  uint64_t v2 = *(void *)(result + 8);
  uint64_t v1 = *(void *)(result + 16);
  if (v1 != v2)
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = *(void *)(v3 + 32);
      *(void *)(v3 + 16) = v1 - 312;
      __n128 result = std::allocator<PSHeliumNode::Sprite>::destroy[abi:ne180100](v4, v1 - 312);
      uint64_t v1 = *(void *)(v3 + 16);
    }
    while (v1 != v2);
  }
  return result;
}

uint64_t std::vector<PSHeliumNode::Sprite>::__push_back_slow_path<PSHeliumNode::Sprite const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = 0x6F96F96F96F96F97 * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0xD20D20D20D20D2) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0xDF2DF2DF2DF2DF2ELL * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0xDF2DF2DF2DF2DF2ELL * ((a1[2] - *a1) >> 3);
  }
  if ((unint64_t)(0x6F96F96F96F96F97 * ((a1[2] - *a1) >> 3)) >= 0x69069069069069) {
    unint64_t v6 = 0xD20D20D20D20D2;
  }
  else {
    unint64_t v6 = v4;
  }
  uint64_t v14 = a1 + 2;
  if (v6) {
    long long v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::Sprite>>((uint64_t)(a1 + 2), v6);
  }
  else {
    long long v7 = 0;
  }
  long long v10 = v7;
  long long v11 = &v7[312 * v3];
  long long v13 = &v7[312 * v6];
  std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  long long v12 = v11 + 312;
  std::vector<PSHeliumNode::Sprite>::__swap_out_circular_buffer(a1, &v10);
  uint64_t v8 = a1[1];
  std::__split_buffer<PSHeliumNode::Sprite>::~__split_buffer(&v10);
  return v8;
}

void sub_1B7E13094(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<PSHeliumNode::Sprite>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::shared_ptr<PCImage>>::__emplace_unique_key_args<std::shared_ptr<PCImage>,std::shared_ptr<PCImage>>(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v6 = a1 + 1;
  long long v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        long long v5 = *v8;
        unint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      long long v5 = v8[1];
      if (!v5)
      {
        unint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    long long v10 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v10 + 2) = *(_OWORD *)a3;
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t std::vector<std::shared_ptr<PCBitmap>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<PCBitmap>>,std::reverse_iterator<std::shared_ptr<PCBitmap>*>,std::reverse_iterator<std::shared_ptr<PCBitmap>*>,std::reverse_iterator<std::shared_ptr<PCBitmap>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<PCBitmap>>,std::reverse_iterator<std::shared_ptr<PCBitmap>*>,std::reverse_iterator<std::shared_ptr<PCBitmap>*>,std::reverse_iterator<std::shared_ptr<PCBitmap>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<PCBitmap>>,std::reverse_iterator<std::shared_ptr<PCBitmap>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<PCBitmap>>,std::reverse_iterator<std::shared_ptr<PCBitmap>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TXTextObject>>,std::reverse_iterator<std::shared_ptr<TXTextObject>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE8__appendEmRKS1_(void **a1, unint64_t a2, _OWORD *a3)
{
  uint64_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = v8;
  long long v9 = *(_OWORD **)(v6 - 8);
  if (a2 <= (v8 - (unsigned char *)v9) >> 4)
  {
    if (a2)
    {
      uint64_t v16 = 16 * a2;
      uint64_t v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 16;
      }
      while (v16);
      long long v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (unsigned char *)*a1;
    unint64_t v11 = a2 + (v10 >> 4);
    if (v11 >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v10 >> 4;
    uint64_t v13 = v7 - (unsigned char *)*a1;
    if (v13 >> 3 > v11) {
      unint64_t v11 = v13 >> 3;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      long long v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v6, v14);
    }
    else {
      long long v15 = 0;
    }
    unsigned int v18 = &v15[16 * v12];
    unint64_t v19 = &v18[16 * a2];
    uint64_t v20 = 16 * a2;
    unint64_t v21 = v18;
    do
    {
      *(_OWORD *)unint64_t v21 = *a3;
      v21 += 16;
      v20 -= 16;
    }
    while (v20);
    unsigned int v22 = &v15[16 * v14];
    uint64_t v24 = (char *)*a1;
    unsigned int v23 = (char *)a1[1];
    if (v23 != *a1)
    {
      do
      {
        long long v25 = *((_OWORD *)v23 - 1);
        v23 -= 16;
        *((_OWORD *)v18 - 1) = v25;
        v18 -= 16;
      }
      while (v23 != v24);
      unsigned int v23 = (char *)*a1;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
    {
      operator delete(v23);
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::TextureSpriteBatcher::Vertex>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(112 * a2);
}

uint64_t std::vector<std::unique_ptr<PSHeliumNode::BatcherBase>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<PSHeliumNode::BatcherBase>>,std::reverse_iterator<std::unique_ptr<PSHeliumNode::BatcherBase>*>,std::reverse_iterator<std::unique_ptr<PSHeliumNode::BatcherBase>*>,std::reverse_iterator<std::unique_ptr<PSHeliumNode::BatcherBase>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<PSHeliumNode::BatcherBase>>,std::reverse_iterator<std::unique_ptr<PSHeliumNode::BatcherBase>*>,std::reverse_iterator<std::unique_ptr<PSHeliumNode::BatcherBase>*>,std::reverse_iterator<std::unique_ptr<PSHeliumNode::BatcherBase>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    long long v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<PSHeliumNode::BatcherBase>>,std::reverse_iterator<std::unique_ptr<PSHeliumNode::BatcherBase>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<PSHeliumNode::BatcherBase>>,std::reverse_iterator<std::unique_ptr<PSHeliumNode::BatcherBase>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<PSHeliumNode::BatcherBase>>,std::reverse_iterator<std::unique_ptr<PSHeliumNode::BatcherBase>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

void *std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<PSHeliumNode::BatcherBase>>,std::reverse_iterator<std::unique_ptr<PSHeliumNode::BatcherBase>*>>::operator()[abi:ne180100](void *result)
{
  uint64_t v1 = *(void ***)(result[2] + 8);
  uint64_t v2 = *(void ***)(result[1] + 8);
  while (v1 != v2)
  {
    uint64_t result = *v1;
    void *v1 = 0;
    if (result) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
    ++v1;
  }
  return result;
}

void **std::__split_buffer<std::unique_ptr<PSHeliumNode::BatcherBase>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *std::__split_buffer<std::unique_ptr<PSHeliumNode::BatcherBase>>::__destruct_at_end[abi:ne180100](void *result, uint64_t a2)
{
  uint64_t v2 = result[2];
  if (v2 != a2)
  {
    unint64_t v4 = result;
    do
    {
      v4[2] = v2 - 8;
      uint64_t result = *(void **)(v2 - 8);
      *(void *)(v2 - 8) = 0;
      if (result) {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
      uint64_t v2 = v4[2];
    }
    while (v2 != a2);
  }
  return result;
}

uint64_t PSTextureCache::Instance(PSTextureCache *this)
{
  if (PSTextureCache::Instance(void)::once != -1) {
    dispatch_once(&PSTextureCache::Instance(void)::once, &__block_literal_global_86);
  }
  return PSTextureCache::_instance;
}

void ___ZN14PSTextureCache8InstanceEv_block_invoke()
{
}

void sub_1B7E13708(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40A9FDA665);
  _Unwind_Resume(a1);
}

void PSTextureCache::addTexture(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = (std::mutex *)(a1 + 8);
  PCSharedMutex::lock((std::mutex *)(a1 + 8));
  unint64_t v14 = *(void *)(*(void *)a3 + 96);
  long long v15 = &v14;
  long long v9 = std::__tree<std::__value_type<OZLocking *,std::set<OZLocking *>>,std::__map_value_compare<OZLocking *,std::__value_type<OZLocking *,std::set<OZLocking *>>,std::less<OZLocking *>,true>,std::allocator<std::__value_type<OZLocking *,std::set<OZLocking *>>>>::__emplace_unique_key_args<OZLocking *,std::piecewise_construct_t const&,std::tuple<OZLocking * const&>,std::tuple<>>((uint64_t **)(a1 + 112), &v14, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15);
  long long v15 = (unint64_t *)a4;
  uint64_t v10 = std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::__emplace_unique_key_args<PCHash128,std::piecewise_construct_t const&,std::tuple<PCHash128 const&>,std::tuple<>>((uint64_t **)v9 + 5, (const PCHash128 *)a4, (uint64_t)&std::piecewise_construct, (_DWORD **)&v15);
  uint64_t v12 = *a2;
  uint64_t v11 = a2[1];
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = (std::__shared_weak_count *)*((void *)v10 + 7);
  *((void *)v10 + 6) = v12;
  *((void *)v10 + 7) = v11;
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  PCSharedMutex::unlock(v8);
}

{
  std::mutex *v8;
  uint64_t *v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t v14;
  unint64_t *v15;

  uint64_t v8 = (std::mutex *)(a1 + 8);
  PCSharedMutex::lock((std::mutex *)(a1 + 8));
  unint64_t v14 = *(void *)(*(void *)a3 + 96);
  long long v15 = &v14;
  long long v9 = std::__tree<std::__value_type<OZLocking *,std::set<OZLocking *>>,std::__map_value_compare<OZLocking *,std::__value_type<OZLocking *,std::set<OZLocking *>>,std::less<OZLocking *>,true>,std::allocator<std::__value_type<OZLocking *,std::set<OZLocking *>>>>::__emplace_unique_key_args<OZLocking *,std::piecewise_construct_t const&,std::tuple<OZLocking * const&>,std::tuple<>>((uint64_t **)(a1 + 112), &v14, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15);
  long long v15 = (unint64_t *)a4;
  uint64_t v10 = std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::__emplace_unique_key_args<PCHash128,std::piecewise_construct_t const&,std::tuple<PCHash128 const&>,std::tuple<>>((uint64_t **)v9 + 5, (const PCHash128 *)a4, (uint64_t)&std::piecewise_construct, (_DWORD **)&v15);
  uint64_t v12 = *a2;
  uint64_t v11 = a2[1];
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = (std::__shared_weak_count *)*((void *)v10 + 9);
  *((void *)v10 + 8) = v12;
  *((void *)v10 + 9) = v11;
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  PCSharedMutex::unlock(v8);
}

void sub_1B7E13800(_Unwind_Exception *a1)
{
  PCSharedMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B7E138F0(_Unwind_Exception *a1)
{
  PCSharedMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void PSTextureCache::getTextureForKey(uint64_t a1@<X0>, uint64_t a2@<X1>, const PCHash128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = (std::mutex *)(a1 + 8);
  PCSharedMutex::lock_shared((std::mutex *)(a1 + 8));
  unint64_t v13 = *(void *)(*(void *)a2 + 96);
  unint64_t v14 = &v13;
  long long v9 = std::__tree<std::__value_type<OZLocking *,std::set<OZLocking *>>,std::__map_value_compare<OZLocking *,std::__value_type<OZLocking *,std::set<OZLocking *>>,std::less<OZLocking *>,true>,std::allocator<std::__value_type<OZLocking *,std::set<OZLocking *>>>>::__emplace_unique_key_args<OZLocking *,std::piecewise_construct_t const&,std::tuple<OZLocking * const&>,std::tuple<>>((uint64_t **)(a1 + 112), &v13, (uint64_t)&std::piecewise_construct, (uint64_t **)&v14);
  uint64_t v10 = std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::find<PCHash128>((uint64_t)(v9 + 5), a3);
  if (v9 + 6 == v10)
  {
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
  }
  else
  {
    uint64_t v11 = v10[7];
    *(void *)a4 = v10[6];
    *(void *)(a4 + 8) = v11;
    if (v11) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v12 = v10[9];
    *(void *)(a4 + 16) = v10[8];
    *(void *)(a4 + 24) = v12;
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    }
  }
  PCSharedMutex::unlock_shared(v8);
}

void sub_1B7E139F0(_Unwind_Exception *a1)
{
  PCSharedMutex::unlock_shared(v1);
  _Unwind_Resume(a1);
}

void PSTextureCache::removeTextureNoLock(uint64_t a1, void *a2)
{
  uint64_t v2 = *(uint64_t ***)(a1 + 112);
  uint64_t v3 = (uint64_t **)(a1 + 120);
  if (v2 != (uint64_t **)(a1 + 120))
  {
    do
    {
      uint64_t v5 = v2[5];
      if (v5 != (uint64_t *)(v2 + 6))
      {
        do
        {
          if (v5[6] == *a2 || v5[8] == *a2)
          {
            uint64_t v7 = std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(v2 + 5, v5);
            std::__destroy_at[abi:ne180100]<std::pair<PCHash128 const,PSTextureCache::CacheEntry>,0>((uint64_t)(v5 + 4));
            operator delete(v5);
          }
          else
          {
            uint64_t v6 = (uint64_t *)v5[1];
            if (v6)
            {
              do
              {
                uint64_t v7 = v6;
                uint64_t v6 = (uint64_t *)*v6;
              }
              while (v6);
            }
            else
            {
              do
              {
                uint64_t v7 = (uint64_t *)v5[2];
                BOOL v8 = *v7 == (void)v5;
                uint64_t v5 = v7;
              }
              while (!v8);
            }
          }
          uint64_t v5 = v7;
        }
        while (v7 != (uint64_t *)(v2 + 6));
      }
      long long v9 = v2[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = (uint64_t **)v9;
          long long v9 = (uint64_t *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (uint64_t **)v2[2];
          BOOL v8 = *v10 == (uint64_t *)v2;
          uint64_t v2 = v10;
        }
        while (!v8);
      }
      uint64_t v2 = v10;
    }
    while (v10 != v3);
  }
}

void PSTextureCache::removeTextures(uint64_t a1, void *a2)
{
  unint64_t v4 = (std::mutex *)(a1 + 8);
  PCSharedMutex::lock((std::mutex *)(a1 + 8));
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      PSTextureCache::removeTextureNoLock(a1, v6 + 4);
      BOOL v8 = (void *)v6[1];
      if (v8)
      {
        do
        {
          long long v9 = v8;
          BOOL v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          long long v9 = (void *)v6[2];
          BOOL v10 = *v9 == (void)v6;
          uint64_t v6 = v9;
        }
        while (!v10);
      }
      uint64_t v6 = v9;
    }
    while (v9 != v5);
  }
  PCSharedMutex::unlock(v4);
}

void PSTextureCache::PSTextureCache(PSTextureCache *this)
{
  PCSingleton::PCSingleton(this, 0);
  void *v2 = &unk_1F1197AF0;
  PCSharedMutex::PCSharedMutex((PCSharedMutex *)(v2 + 1));
  *((void *)this + 16) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 14) = (char *)this + 120;
}

void sub_1B7E13C0C(_Unwind_Exception *a1)
{
  PCSingleton::~PCSingleton(v1);
  _Unwind_Resume(a1);
}

void PSTextureCache::~PSTextureCache(PSTextureCache *this)
{
  *(void *)this = &unk_1F1197AF0;
  std::__tree<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>>>::destroy((uint64_t)this + 112, *((void **)this + 15));
  PCSharedMutex::~PCSharedMutex((std::mutex *)((char *)this + 8));

  PCSingleton::~PCSingleton(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F1197AF0;
  std::__tree<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>>>::destroy((uint64_t)this + 112, *((void **)this + 15));
  PCSharedMutex::~PCSharedMutex((std::mutex *)((char *)this + 8));
  PCSingleton::~PCSingleton(this);

  JUMPOUT(0x1BA9BFBA0);
}

void std::__tree<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>>>::destroy(a1, a2[1]);
    std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::destroy((uint64_t)(a2 + 5), (void *)a2[6]);
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<PCHash128 const,PSTextureCache::CacheEntry>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<PCHash128 const,PSTextureCache::CacheEntry>,0>(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

_DWORD *std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::__emplace_unique_key_args<PCHash128,std::piecewise_construct_t const&,std::tuple<PCHash128 const&>,std::tuple<>>(uint64_t **a1, const PCHash128 *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v6 = (void **)std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::__find_equal<PCHash128>((uint64_t)a1, &v13, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    BOOL v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x50uLL);
    v11[1] = a1 + 1;
    long long v9 = *a4;
    v7[8] = **a4;
    v7[9] = v9[1];
    v7[10] = v9[2];
    v7[11] = v9[3];
    *((_OWORD *)v7 + 3) = 0u;
    *((_OWORD *)v7 + 4) = 0u;
    char v12 = 1;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v13, v8, (uint64_t *)v7);
    v11[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,void *>>>>::reset[abi:ne180100]((uint64_t)v11, 0);
  }
  return v7;
}

void std::unique_ptr<std::__tree_node<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<PCHash128 const,PSTextureCache::CacheEntry>,0>((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

double RetimingMath::reverse(RetimingMath *this, double result, double a3, double a4)
{
  if (result >= a3 && result < a4)
  {
    double v5 = floor(result);
    return result - (v5 + v5) + -1.0 + a3 + a4;
  }
  return result;
}

Float64 RetimingMath::figToFrames(RetimingMath *this, const CMTime *a2, const CMTime *a3)
{
  operator/((long long *)this, (uint64_t)a2, (uint64_t)&time);
  return CMTimeGetSeconds(&time);
}

uint64_t OZChannelShape_Factory::getInstance(OZChannelShape_Factory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZChannelShape_Factory::_instanceOnce, memory_order_acquire) != -1)
  {
    unint64_t v4 = &v2;
    uint64_t v3 = &v4;
    std::__call_once(&OZChannelShape_Factory::_instanceOnce, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelShape_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelShape_Factory::_instance;
}

void OZChannelShape::OZChannelShape(OZChannelShape *this, const PCString *a2, OZChannelFolder *a3, unsigned int a4, int a5)
{
  Instance = (OZFactory *)OZChannelShape_Factory::getInstance(this);
  OZChannelCurve::OZChannelCurve(this, Instance, a2, a3, a4, a5);
  *(void *)this = &unk_1F1197B28;
  *((void *)this + 2) = &unk_1F1197ED8;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  *(_OWORD *)((char *)this + 840) = 0u;
  *((void *)this + 107) = 0;
}

void OZChannelShape::OZChannelShape(OZChannelShape *this, OZShape *a2, const PCString *a3, OZChannelFolder *a4, unsigned int a5, int a6)
{
  Instance = (OZFactory *)OZChannelShape_Factory::getInstance(this);
  OZChannelCurve::OZChannelCurve(this, Instance, a3, a4, a5, a6);
  *(void *)this = &unk_1F1197B28;
  *((void *)this + 2) = &unk_1F1197ED8;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  *(_OWORD *)((char *)this + 840) = 0u;
  *((void *)this + 107) = a2;
}

void OZChannelShape::OZChannelShape(OZChannelShape *this, const OZChannelShape *a2, OZChannelFolder *a3, OZShape *a4)
{
}

void OZChannelShape::~OZChannelShape(OZChannel *this)
{
  this->$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = (void **)&unk_1F1197B28;
  this->uint64_t var2 = (void **)&unk_1F1197ED8;
  var9 = (__CFString *)this[5].var9;
  if (var9)
  {
    this[5].var10 = var9;
    operator delete(var9);
  }
  var6 = this[5].var6;
  if (var6)
  {
    this[5].var7 = (unint64_t)var6;
    operator delete(var6);
  }

  OZChannelCurve::~OZChannelCurve(this);
}

{
  uint64_t vars8;

  OZChannelShape::~OZChannelShape(this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'OZChannelShape::~OZChannelShape(OZChannelShape *this)
{
}

{
  uint64_t vars8;

  OZChannelShape::~OZChannelShape((OZChannel *)((char *)this - 16));

  JUMPOUT(0x1BA9BFBA0);
}

__CFString *OZChannelShape::getObjCWrapperName(OZChannelShape *this)
{
  return @"CHChannelShape";
}

void OZChannelShape::clone(OZChannelShape *this)
{
}

void sub_1B7E1437C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409E4CE797);
  _Unwind_Resume(a1);
}

__CFString *OZChannelShape::copy(OZChannel *this, const OZChannelBase *a2, char a3)
{
  OZChannelCurve::copy(this, a2, a3);
  uint64_t result = this[5].var12;
  if (result)
  {
    double v5 = (uint64_t (*)(void))*((void *)result->isa + 18);
    return (__CFString *)v5();
  }
  return result;
}

__CFString *OZChannelShape::assign(OZChannel *this, const OZChannelBase *a2)
{
  OZChannelCurve::assign(this, a2);
  uint64_t result = this[5].var12;
  if (result)
  {
    unint64_t v4 = (uint64_t (*)(void))*((void *)result->isa + 18);
    return (__CFString *)v4();
  }
  return result;
}

void *OZChannelShape::reset(OZChannelBase *this, uint64_t a2)
{
  OZChannelBase::reset(this, a2);
  uint64_t result = this[7].var9;
  if (result)
  {
    unint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 144);
    return (void *)v4();
  }
  return result;
}

uint64_t OZChannelShape::refreshAnimation(OZChannelShape *this)
{
  OZChannelCurve::refreshAnimation(this);
  uint64_t result = *((void *)this + 107);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 144);
    return v3();
  }
  return result;
}

uint64_t OZChannelShape::didBake(OZChannelShape *this, const PCTimeRange *a2, const CMTime *a3)
{
  CMTime v9 = *(CMTime *)a2;
  uint64_t v6 = (OZChannelFolder *)((char *)this + 152);
  if (OZChannelFolder::hasKeypointAt((OZChannelFolder *)((char *)this + 152), &v9, 0)) {
    (*(void (**)(OZChannelShape *, CMTime *))(*(void *)this + 728))(this, &v9);
  }
  uint64_t result = OZChannelFolder::nextKeypoint(v6, &v9, 0);
  if (result)
  {
    do
    {
      CMTime time1 = *(CMTime *)a2;
      CMTime time2 = *(CMTime *)((unsigned char *)a2 + 1);
      PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v10);
      CMTime time1 = v10;
      CMTime time2 = *a3;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v8);
      CMTime time1 = v9;
      CMTime time2 = v8;
      uint64_t result = CMTimeCompare(&time1, &time2);
      if ((result & 0x80000000) == 0) {
        break;
      }
      if (OZChannelFolder::hasKeypointAt(v6, &v9, 0)) {
        (*(void (**)(OZChannelShape *, CMTime *))(*(void *)this + 728))(this, &v9);
      }
      uint64_t result = OZChannelFolder::nextKeypoint(v6, &v9, 0);
    }
    while ((result & 1) != 0);
  }
  return result;
}

void std::__call_once_param<std::tuple<OZChannelShape_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7E1474C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelShape_Factory::OZChannelShape_Factory(OZChannelShape_Factory *this)
{
  long long v3 = xmmword_1B8378D50;
  long long v4 = xmmword_1B83881A0;
  char v2 = (void *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  void *v2 = &unk_1F10A81A8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(void *)this = &unk_1F1197F48;
  *((void *)this + 16) = &unk_1F1198018;
}

void sub_1B7E1481C(_Unwind_Exception *a1)
{
  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

void OZChannelShape_Factory::create(OZChannelShape_Factory *this, const PCString *a2)
{
}

void sub_1B7E148E0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409E4CE797);
  _Unwind_Resume(a1);
}

void OZChannelShape_Factory::createCopy(OZChannelShape_Factory *this, OZFactoryBase *a2)
{
}

void sub_1B7E149E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409E4CE797);
  _Unwind_Resume(a1);
}

void OZChannelShape_Factory::createChannelCopy(OZChannelShape_Factory *this, OZChannelBase *a2)
{
}

void sub_1B7E14AF0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C409E4CE797);
  _Unwind_Resume(a1);
}

void OZShape::OZShape(OZShape *this, OZChannelFolder *a2)
{
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1F1198070;
  PCMutex::PCMutex((PCMutex *)((char *)this + 8), 1);
  *((void *)this + 1) = &unk_1F10933F0;
  PCString::PCString(v120, "Shape Root", "com.apple.proshapes.framework");
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 80), v120, a2, 0x9Bu, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v4, "Shape Animation", "com.apple.proshapes.framework");
  OZChannelShape::OZChannelShape((OZShape *)((char *)this + 208), this, v120, (OZChannelFolder *)((char *)this + 80), 0x75u, 0);
  PCString::~PCString(v120);
  PCString::PCString(v5, "Shape Interpolation Mode Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v119, "Shape Interpolation Mode", "com.apple.proshapes.framework");
  Instance = (OZChannelImpl *)OZShape::OZShape_interpolationModeImpl::getInstance(v6);
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 1072), 1u, v120, &v119, (OZChannelFolder *)((char *)this + 80), 0x64u, 16, Instance, 0);
  PCString::~PCString(&v119);
  PCString::~PCString(v120);
  PCString::PCString(v8, "Shape Closed", "com.apple.proshapes.framework");
  CMTime v10 = (OZChannelImpl *)OZShape::OZShape_closedImpl::getInstance(v9);
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 1328), 0, v120, (OZChannelFolder *)((char *)this + 80), 0x74u, 0x10000u, v10, 0);
  PCString::~PCString(v120);
  PCString::PCString(v11, "Shape Roundness", "com.apple.proshapes.framework");
  uint64_t v13 = (OZShape::OZShape_roundnessInfo *)OZShape::OZShape_roundnessImpl::getInstance(v12);
  unint64_t v14 = (OZChannelInfo *)OZShape::OZShape_roundnessInfo::getInstance(v13);
  OZChannelUint32::OZChannelUint32((OZChannelUint32 *)((char *)this + 1480), 0.0, v120, (OZChannelFolder *)((char *)this + 80), 0x90u, 0, (OZChannelImpl *)v13, v14);
  PCString::~PCString(v120);
  PCString::PCString(v15, "Shape Preserve Scale", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 1632), 1, v120, (OZChannelFolder *)((char *)this + 80), 0x98u, 0, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v16, "Shape Initial Position", "com.apple.proshapes.framework");
  unsigned int v18 = (OZChannelImpl *)OZShape::OZShape_initialPositionImpl::getInstance(v17);
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 1784), 0.0, 0.0, v120, (OZChannelFolder *)((char *)this + 80), 0x81u, 2u, 2u, v18, 0);
  PCString::~PCString(v120);
  PCString::PCString(v19, "Shape Pixel Aspect Ratio", "com.apple.proshapes.framework");
  unint64_t v21 = (OZChannelImpl *)OZShape::OZShape_pixelAspectRatioImpl::getInstance(v20);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 2488), 1.0, v120, (OZChannelFolder *)((char *)this + 80), 0x99u, 2, v21, 0);
  PCString::~PCString(v120);
  *(_OWORD *)((char *)this + 2648) = 0u;
  *((void *)this + 335) = (char *)this + 2680;
  *((void *)this + 336) = (char *)this + 2680;
  *((void *)this + 337) = 0;
  *((void *)this + 338) = (char *)this + 2704;
  *((void *)this + 339) = (char *)this + 2704;
  *((void *)this + 340) = 0;
  *((void *)this + 341) = (char *)this + 2728;
  *((void *)this + 342) = (char *)this + 2728;
  *((void *)this + 343) = 0;
  *((void *)this + 345) = 0;
  *((_OWORD *)this + 173) = 0u;
  PCString::PCString(v22, "Shape Filled Shape", "com.apple.proshapes.framework");
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 2784), v120, (OZChannelFolder *)((char *)this + 80), 0x71u, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v23, "Shape Fill Mode Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v119, "Shape Fill Mode", "com.apple.proshapes.framework");
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 2912), 0, v120, &v119, (OZChannelFolder *)((char *)this + 2784), 0x72u, 0, 0, 0);
  PCString::~PCString(&v119);
  PCString::~PCString(v120);
  PCString::PCString(v24, "Shape Fill Color", "com.apple.proshapes.framework");
  OZChannelColorNoAlpha::OZChannelColorNoAlpha((OZShape *)((char *)this + 3168), 1.0, 1.0, 1.0, v120, (OZChannelFolder *)((char *)this + 2784), 0x6Fu, 0, 5u);
  PCString::~PCString(v120);
  PCString::PCString(v25, "Shape Fill Opacity", "com.apple.proshapes.framework");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 4176), 1.0, v120, (OZChannelFolder *)((char *)this + 2784), 0x8Du, 0, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v26, "Shape Gradient", "com.apple.proshapes.framework");
  OZChannelGradientPositioned::OZChannelGradientPositioned((OZShape *)((char *)this + 4328), v120, (OZChannelFolder *)((char *)this + 2784), 0x68u, 2u);
  PCString::~PCString(v120);
  PCString::PCString(v27, "Shape Stroked Shape", "com.apple.proshapes.framework");
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 6800), v120, (OZChannelFolder *)((char *)this + 80), 0x6Cu, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v28, "Shape Stroke Mode Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v119, "Shape Stroke Mode", "com.apple.proshapes.framework");
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 6928), 0, v120, &v119, (OZChannelFolder *)((char *)this + 6800), 0x8Bu, 0, 0, 0);
  PCString::~PCString(&v119);
  PCString::~PCString(v120);
  PCString::PCString(v29, "Shape Stroke Color", "com.apple.proshapes.framework");
  OZChannelColorNoAlpha::OZChannelColorNoAlpha((OZShape *)((char *)this + 7184), 1.0, 1.0, 1.0, v120, (OZChannelFolder *)((char *)this + 6800), 0x6Bu, 0, 5u);
  PCString::~PCString(v120);
  PCString::PCString(v30, "Shape Stroke Opacity", "com.apple.proshapes.framework");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 0x2000), 1.0, v120, (OZChannelFolder *)((char *)this + 6800), 0x8Eu, 0, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v31, "Shape Stroke Width", "com.apple.proshapes.framework");
  long long v33 = (OZShape::OZShape_strokeWidthInfo *)OZShape::OZShape_strokeWidthImpl::getInstance(v32);
  long long v34 = (OZChannelInfo *)OZShape::OZShape_strokeWidthInfo::getInstance(v33);
  OZChannelUint32::OZChannelUint32((OZChannelUint32 *)((char *)this + 8344), 2.0, v120, (OZChannelFolder *)((char *)this + 6800), 0x69u, 0, (OZChannelImpl *)v33, v34);
  PCString::~PCString(v120);
  PCString::PCString(v35, "Shape Transform Stroke", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 8496), 0, v120, (OZChannelFolder *)((char *)this + 6800), 0x7Bu, 0, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v36, "Shape Stroke Joint Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v119, "Shape Stroke Joint", "com.apple.proshapes.framework");
  unint64_t v38 = (OZChannelImpl *)OZShape::OZShape_strokeJointImpl::getInstance(v37);
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 8648), 1u, v120, &v119, (OZChannelFolder *)((char *)this + 6800), 0x70u, 0, v38, 0);
  PCString::~PCString(&v119);
  PCString::~PCString(v120);
  PCString::PCString(v39, "Shape Stroke Cap Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v119, "Shape Stroke Left Cap", "com.apple.proshapes.framework");
  uint64_t v41 = (OZChannelImpl *)OZShape::OZShape_strokeLeftCapImpl::getInstance(v40);
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 8904), 1u, v120, &v119, (OZChannelFolder *)((char *)this + 6800), 0x77u, 0, v41, 0);
  PCString::~PCString(&v119);
  PCString::~PCString(v120);
  PCString::PCString(v42, "Shape Stroke Cap Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v119, "Shape Stroke Right Cap", "com.apple.proshapes.framework");
  long long v44 = (OZChannelImpl *)OZShape::OZShape_strokeRightCapImpl::getInstance(v43);
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 9160), 1u, v120, &v119, (OZChannelFolder *)((char *)this + 6800), 0x86u, 0, v44, 0);
  PCString::~PCString(&v119);
  PCString::~PCString(v120);
  PCString::PCString(v45, "Shape Stroke Arrow Length", "com.apple.proshapes.framework");
  long long v47 = (OZShape::OZShape_strokeCapArrowLengthInfo *)OZShape::OZShape_strokeCapArrowLengthImpl::getInstance(v46);
  long long v48 = (OZChannelInfo *)OZShape::OZShape_strokeCapArrowLengthInfo::getInstance(v47);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 9416), 3.0, v120, (OZChannelFolder *)((char *)this + 6800), 0x84u, 0, (OZChannelImpl *)v47, v48);
  PCString::~PCString(v120);
  PCString::PCString(v49, "Shape Stroke Arrow Width", "com.apple.proshapes.framework");
  uint64_t v51 = (OZShape::OZShape_strokeCapArrowWidthInfo *)OZShape::OZShape_strokeCapArrowWidthImpl::getInstance(v50);
  uint64_t v52 = (OZChannelInfo *)OZShape::OZShape_strokeCapArrowWidthInfo::getInstance(v51);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 9568), 3.0, v120, (OZChannelFolder *)((char *)this + 6800), 0x85u, 0, (OZChannelImpl *)v51, v52);
  PCString::~PCString(v120);
  PCString::PCString(v53, "Shape Type Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v119, "Shape Type", "com.apple.proshapes.framework");
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 9720), v120, &v119, (OZChannelFolder *)((char *)this + 6800), 0x6Au, 0, 0, 0);
  PCString::~PCString(&v119);
  PCString::~PCString(v120);
  PCString::PCString(v54, "Shape Stroke In", "com.apple.proshapes.framework");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 9976), 0.0, v120, (OZChannelFolder *)((char *)this + 6800), 0x7Eu, 0, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v55, "Shape Stroke Out", "com.apple.proshapes.framework");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 10128), 1.0, v120, (OZChannelFolder *)((char *)this + 6800), 0x7Fu, 0, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v56, "Hidden Stroke Completion");
  OZChannelPercentOverRange::OZChannelPercentOverRange((OZShape *)((char *)this + 10280), 1.0, v120, (OZChannelFolder *)((char *)this + 6800), 0x87u, 2u, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v57, "Shape Stroke Natural", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 10440), 0, v120, (OZChannelFolder *)((char *)this + 6800), 0x80u, 2u, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v58, "Shape Stroke Offset", "com.apple.proshapes.framework");
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 10592), 0.0, v120, (OZChannelFolder *)((char *)this + 6800), 0x83u, 2, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v59, "Shape Pressure Over Stroke", "com.apple.proshapes.framework");
  OZChannelPercentOverRange::OZChannelPercentOverRange((OZShape *)((char *)this + 10744), 1.0, v120, (OZChannelFolder *)((char *)this + 6800), 0x88u, 2u, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v60, "Shape Tilt Over Stroke", "com.apple.proshapes.framework");
  OZChannel2DOverRange::OZChannel2DOverRange((OZShape *)((char *)this + 10904), 0.0, 0.0, v120, (OZChannelFolder *)((char *)this + 6800), 0x89u, 2u, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v61, "Shape Pen Speed Over Stroke", "com.apple.proshapes.framework");
  OZChannelPercentOverRange::OZChannelPercentOverRange((OZShape *)((char *)this + 11352), 1.0, v120, (OZChannelFolder *)((char *)this + 6800), 0x8Au, 2u, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v62, "Shape Soft Edge Radius", "com.apple.proshapes.framework");
  long long v64 = (OZShape::OZShape_softEdgeRadiusInfo *)OZShape::OZShape_softEdgeRadiusImpl::getInstance(v63);
  long long v65 = (OZChannelInfo *)OZShape::OZShape_softEdgeRadiusInfo::getInstance(v64);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 11512), 0.0, v120, (OZChannelFolder *)((char *)this + 80), 0x66u, 0, (OZChannelImpl *)v64, v65);
  PCString::~PCString(v120);
  PCString::PCString(v66, "Shape Soft Edge Falloff", "com.apple.proshapes.framework");
  uint64_t v68 = (OZShape::OZShape_softEdgeFalloffInfo *)OZShape::OZShape_softEdgeFalloffImpl::getInstance(v67);
  unint64_t v69 = (OZChannelInfo *)OZShape::OZShape_softEdgeFalloffInfo::getInstance(v68);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 11664), 0.0, v120, (OZChannelFolder *)((char *)this + 80), 0x9Eu, 0, (OZChannelImpl *)v68, v69);
  PCString::~PCString(v120);
  PCString::PCString(v70, "Shape Soft Edge Kernel Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v119, "Shape Soft Edge Kernel", "com.apple.proshapes.framework");
  long long v72 = (OZChannelImpl *)OZShape::OZShape_softEdgeKernelImpl::getInstance(v71);
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 11816), 3u, v120, &v119, (OZChannelFolder *)((char *)this + 80), 0xA2u, 2, v72, 0);
  PCString::~PCString(&v119);
  PCString::~PCString(v120);
  PCString::PCString(v73, "Shape Ellipse Curvature", "com.apple.proshapes.framework");
  long long v75 = (OZChannelImpl *)OZShape::OZShape_ellipseCurvatureImpl::getInstance(v74);
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 12072), 0.35, v120, (OZChannelFolder *)((char *)this + 80), 0x9Fu, 2u, v75, 0);
  PCString::~PCString(v120);
  PCString::PCString(v76, "Shape Ellipse Radius", "com.apple.proshapes.framework");
  long long v78 = (OZShape::OZShape_shapeRadiusInfo *)OZShape::OZShape_shapeRadiusImpl::getInstance(v77);
  long long v79 = (OZChannelInfo *)OZShape::OZShape_shapeRadiusInfo::getInstance(v78);
  OZChannel2D::OZChannel2D((OZShape *)((char *)this + 12224), 400.0, 250.0, v120, (OZChannelFolder *)((char *)this + 80), 0xA0u, 2u, 2u, (OZChannelImpl *)v78, v79);
  PCString::~PCString(v120);
  PCString::PCString(v80, "Shape Convert To Bezier", "com.apple.proshapes.framework");
  OZChannelButton::OZChannelButton((OZChannelButton *)((char *)this + 12664), v120, (OZChannelFolder *)((char *)this + 80), 0xA1u, 0xAu);
  PCString::~PCString(v120);
  PCString::PCString(v81, "Shape Is Mask", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 12856), 0, v120, (OZChannelFolder *)((char *)this + 80), 0x9Au, 2u, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v82, "Shape Mask Blend Mode Enum", "com.apple.proshapes.framework");
  PCString::PCString(&v119, "Shape Blending Mode", "com.apple.proshapes.framework");
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 13008), 0, v120, &v119, (OZChannelFolder *)((char *)this + 80), 0x67u, 18, 0, 0);
  PCString::~PCString(&v119);
  PCString::~PCString(v120);
  PCString::PCString(v83, "Shape Invert Mask", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 13264), 0, v120, (OZChannelFolder *)((char *)this + 80), 0x73u, 0x12u, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v84, "Shape Initial Scale X", "com.apple.proshapes.framework");
  uint64_t v86 = (OZChannelImpl *)OZShape::OZShape_initialScaleXImpl::getInstance(v85);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 13416), 1.0, v120, (OZChannelFolder *)((char *)this + 80), 0x78u, 2, v86, 0);
  PCString::~PCString(v120);
  PCString::PCString(v87, "Shape Initial Scale Y", "com.apple.proshapes.framework");
  unint64_t v89 = (OZChannelImpl *)OZShape::OZShape_initialScaleYImpl::getInstance(v88);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 13568), 1.0, v120, (OZChannelFolder *)((char *)this + 80), 0x79u, 2, v89, 0);
  PCString::~PCString(v120);
  PCString::PCString(v90, "Shape Use OldBSpline Model", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 13720), 0, v120, (OZChannelFolder *)((char *)this + 80), 0x82u, 2u, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v91, "Shape Use Old Antialiasing Method", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 13872), 0, v120, (OZChannelFolder *)((char *)this + 80), 0x91u, 2u, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v92, "Shape Mask Color", "com.apple.proshapes.framework");
  OZChannelDiscreteColor::OZChannelDiscreteColor((OZShape *)((char *)this + 14024), 0.0, v120, (OZChannelFolder *)((char *)this + 80), 0x8Fu, 0x12u);
  PCString::~PCString(v120);
  PCString::PCString(v93, "Shape Drawing Completed", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14280), 0, v120, (OZChannelFolder *)((char *)this + 80), 0x9Du, 2u, 0, 0);
  PCString::~PCString(v120);
  PCString::PCString(v94, "Shape Identifier String", "com.apple.proshapes.framework");
  OZChannelText::OZChannelText((OZChannelText *)((char *)this + 14432), v120, (OZChannelFolder *)((char *)this + 80), 0xA3u, 0x1000Au);
  PCString::~PCString(v120);
  PCString::PCString(v95, "Shape Disable Antialiasing iOS", "com.apple.proshapes.framework");
  long long v97 = (OZChannelImpl *)OZShape::OZShape_disableAntialiasingiOSImpl::getInstance(v96);
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14600), 0, v120, (OZChannelFolder *)((char *)this + 80), 0xA4u, 2u, v97, 0);
  PCString::~PCString(v120);
  PCString::PCString(v98, "Shape Fixed Feather Width", "com.apple.proshapes.framework");
  unint64_t v100 = (OZChannelImpl *)OZShape::OZShape_fixedFeatherWidthImpl::getInstance(v99);
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14752), 0, v120, (OZChannelFolder *)((char *)this + 80), 0xA5u, 0x10000u, v100, 0);
  PCString::~PCString(v120);
  PCString::PCString(v101, "Shape Box Transform Top Left", "com.apple.proshapes.framework");
  uint64_t v103 = (OZChannelImpl *)OZShape::OZShape_boxTopLeftImpl::getInstance(v102);
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 14904), 0.0, 0.0, v120, (OZChannelFolder *)((char *)this + 80), 0x92u, 0x1000Au, 2u, v103, 0);
  PCString::~PCString(v120);
  PCString::PCString(v104, "Shape Box Transform Top Right", "com.apple.proshapes.framework");
  long long v106 = (OZChannelImpl *)OZShape::OZShape_boxTopRightImpl::getInstance(v105);
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 15608), 0.0, 0.0, v120, (OZChannelFolder *)((char *)this + 80), 0x93u, 0x1000Au, 2u, v106, 0);
  PCString::~PCString(v120);
  PCString::PCString(v107, "Shape Box Transform Bottom Left", "com.apple.proshapes.framework");
  uint64_t v109 = (OZChannelImpl *)OZShape::OZShape_boxBottomLeftImpl::getInstance(v108);
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 16312), 0.0, 0.0, v120, (OZChannelFolder *)((char *)this + 80), 0x94u, 0x1000Au, 2u, v109, 0);
  PCString::~PCString(v120);
  PCString::PCString(v110, "Shape Box Transform Bottom Right", "com.apple.proshapes.framework");
  long long v112 = (OZChannelImpl *)OZShape::OZShape_boxBottomRightImpl::getInstance(v111);
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 17016), 0.0, 0.0, v120, (OZChannelFolder *)((char *)this + 80), 0x95u, 0x1000Au, 2u, v112, 0);
  PCString::~PCString(v120);
  PCString::PCString(v113, "Shape Box Transform Rotation", "com.apple.proshapes.framework");
  long long v115 = (OZChannelImpl *)OZShape::OZShape_boxRotationImpl::getInstance(v114);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 17720), 0.0, v120, (OZChannelFolder *)((char *)this + 80), 0x96u, 65546, v115, 0);
  PCString::~PCString(v120);
  PCString::PCString(v116, "Shape Box Transform Pivot", "com.apple.proshapes.framework");
  long long v118 = (OZChannelImpl *)OZShape::OZShape_boxPivotImpl::getInstance(v117);
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 17872), 0.0, 0.0, v120, (OZChannelFolder *)((char *)this + 80), 0x97u, 0x1000Au, 2u, v118, 0);
  PCString::~PCString(v120);
  *((void *)this + 2330) = 0;
  *((_OWORD *)this + 1164) = 0u;
  *((unsigned char *)this + 2640) = 0;
  *((_DWORD *)this + 661) = 2;
  OZChannelBase::enable((OZChannelBase *)((char *)this + 6800), 0, 0);
  OZChannelFolder::setFoldFlag((OZChannelFolder *)((char *)this + 6800), 0x20000);
  int v121 = 3;
  *(_OWORD *)&v120[0].$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = xmmword_1B83881E8;
  OZChannelEnum::setTags((OZShape *)((char *)this + 8904), (char *)v120, 5);
  OZChannelEnum::setTags((OZShape *)((char *)this + 9160), (char *)v120, 5);
  OZChannelBase::enable((OZChannelBase *)((char *)this + 2784), 1, 0);
  OZChannelFolder::setFoldFlag((OZChannelFolder *)((char *)this + 2784), 0x20000);
  *((void *)this + 2340) = 0;
  operator new();
}

void sub_1B7E1602C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, OZChannelPosition *a11, OZChannelBool *a12, OZChannelBool *a13, OZChannelText *a14, OZChannelBool *a15, OZChannelBool *a16, OZChannelBool *a17, OZChannel *a18, OZChannel *a19, OZChannelBool *a20,OZChannelEnum *a21,OZChannelBool *a22,OZChannelPercent *a23,OZChannelEnum *a24,OZChannel *a25,OZChannel *a26,OZChannel *a27,OZChannelBool *a28,OZChannelPercent *a29,OZChannelPercent *a30,OZChannelEnum *a31,OZChannel *a32,OZChannel *a33,OZChannelEnum *a34,OZChannelShape *a35,PCMutex *a36,OZChannelEnum *a37,OZChannelBool *a38,OZChannel *a39,OZChannelPercent *a40,OZChannelColorNoAlpha *a41,OZChannelEnum *a42,OZChannelGradientPositioned *a43,OZChannelPercent *a44,OZChannelColorNoAlpha *a45,OZChannelEnum *a46,void *a47,void *a48)
{
  PCString::~PCString((PCString *)(v57 - 136));
  long long v58 = (void *)v51[2328];
  if (v58)
  {
    v51[2329] = v58;
    operator delete(v58);
  }
  OZChannelPosition::~OZChannelPosition(v54);
  OZChannel::~OZChannel(v56);
  OZChannelPosition::~OZChannelPosition(v53);
  OZChannelPosition::~OZChannelPosition(v48);
  OZChannelPosition::~OZChannelPosition(v52);
  OZChannelPosition::~OZChannelPosition(a11);
  OZChannelBool::~OZChannelBool(a12);
  OZChannelBool::~OZChannelBool(a13);
  OZChannelText::~OZChannelText(a14);
  OZChannelBool::~OZChannelBool(a15);
  OZChannelEnum::~OZChannelEnum(v50);
  OZChannelBool::~OZChannelBool(a16);
  OZChannelBool::~OZChannelBool(a17);
  OZChannel::~OZChannel(a18);
  OZChannel::~OZChannel(a19);
  OZChannelBool::~OZChannelBool(a20);
  OZChannelEnum::~OZChannelEnum(a21);
  OZChannelBool::~OZChannelBool(a22);
  OZChannelButton::~OZChannelButton(*(OZChannelButton **)(v57 - 152));
  OZChannel2D::~OZChannel2D(*(OZChannel2D **)(v57 - 208));
  OZChannelPercent::~OZChannelPercent(a23);
  OZChannelEnum::~OZChannelEnum(a24);
  OZChannel::~OZChannel(a25);
  OZChannel::~OZChannel(a26);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(*(PCString **)(v57 - 200));
  OZChannel2DOverRange::~OZChannel2DOverRange(*(PCString **)(v57 - 192));
  OZChannelPercentOverRange::~OZChannelPercentOverRange(*(PCString **)(v57 - 184));
  OZChannel::~OZChannel(a27);
  OZChannelBool::~OZChannelBool(a28);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(*(PCString **)(v57 - 176));
  OZChannelPercent::~OZChannelPercent(a29);
  OZChannelPercent::~OZChannelPercent(a30);
  OZChannelEnum::~OZChannelEnum(a31);
  OZChannel::~OZChannel(a32);
  OZChannel::~OZChannel(a33);
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v57 - 168));
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v57 - 160));
  OZChannelEnum::~OZChannelEnum(a37);
  OZChannelBool::~OZChannelBool(a38);
  OZChannel::~OZChannel(a39);
  OZChannelPercent::~OZChannelPercent(a40);
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha(a41);
  OZChannelEnum::~OZChannelEnum(a42);
  OZChannelFolder::~OZChannelFolder(v55);
  OZChannelGradientPositioned::~OZChannelGradientPositioned(a43);
  OZChannelPercent::~OZChannelPercent(a44);
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha(a45);
  OZChannelEnum::~OZChannelEnum(a46);
  OZChannelFolder::~OZChannelFolder(*(OZChannelFolder **)(v57 - 144));
  long long v59 = (void *)v51[345];
  if (v59)
  {
    v51[346] = v59;
    operator delete(v59);
  }
  std::__list_imp<unsigned int>::clear(a47);
  std::__list_imp<unsigned int>::clear(a48);
  std::__list_imp<unsigned int>::clear(*(void **)(v57 - 256));
  OZChannel::~OZChannel(*(OZChannel **)(v57 - 248));
  OZChannelPosition::~OZChannelPosition(*(OZChannelPosition **)(v57 - 240));
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v57 - 232));
  OZChannel::~OZChannel(*(OZChannel **)(v57 - 224));
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v57 - 216));
  OZChannelEnum::~OZChannelEnum(a34);
  OZChannelShape::~OZChannelShape(a35);
  OZChannelFolder::~OZChannelFolder(v49);
  PCMutex::~PCMutex(a36);
  _Unwind_Resume(a1);
}

void OZShape::OZShape(OZShape *this, const OZShape *a2, OZChannelFolder *a3)
{
  *(void *)this = &unk_1F1198070;
  PCMutex::PCMutex((PCMutex *)((char *)this + 8), 1);
  *((void *)this + 1) = &unk_1F10933F0;
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 80), (const OZChannelFolder *)((char *)a2 + 80), a3);
  OZChannelShape::OZChannelShape((OZShape *)((char *)this + 208), (const OZShape *)((char *)a2 + 208), (OZChannelFolder *)((char *)this + 80), this);
}

void sub_1B7E1739C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, OZChannelPosition *a9, OZChannelPosition *a10, OZChannelBool *a11, OZChannelBool *a12, OZChannelText *a13, OZChannelBool *a14, OZChannelBool *a15, OZChannelBool *a16, OZChannel *a17, OZChannel *a18, OZChannelBool *a19, OZChannelEnum *a20,OZChannelButton *a21,OZChannel2D *a22,OZChannelPercent *a23,OZChannelEnum *a24,OZChannel *a25,OZChannel *a26,PCString *a27,PCString *a28,PCString *a29,OZChannel *a30,OZChannelBool *a31,PCString *a32,OZChannelPercent *a33,OZChannelPercent *a34,OZChannelEnum *a35,OZChannel *a36,OZChannel *a37,OZChannelEnum *a38,OZChannelEnum *a39,OZChannelEnum *a40,OZChannelBool *a41,OZChannel *a42,OZChannelPercent *a43,OZChannelColorNoAlpha *a44)
{
  PCString::~PCString((PCString *)(v52 - 112));
  PCLockSentry<PCMutex>::~PCLockSentry(v52 - 104);
  uint64_t v54 = (void *)v49[2328];
  if (v54)
  {
    v49[2329] = v54;
    operator delete(v54);
  }
  OZChannelPosition::~OZChannelPosition(v47);
  OZChannel::~OZChannel(v46);
  OZChannelPosition::~OZChannelPosition(v44);
  OZChannelPosition::~OZChannelPosition(v50);
  OZChannelPosition::~OZChannelPosition(a9);
  OZChannelPosition::~OZChannelPosition(a10);
  OZChannelBool::~OZChannelBool(a11);
  OZChannelBool::~OZChannelBool(a12);
  OZChannelText::~OZChannelText(a13);
  OZChannelBool::~OZChannelBool(a14);
  OZChannelEnum::~OZChannelEnum(v48);
  OZChannelBool::~OZChannelBool(a15);
  OZChannelBool::~OZChannelBool(a16);
  OZChannel::~OZChannel(a17);
  OZChannel::~OZChannel(a18);
  OZChannelBool::~OZChannelBool(a19);
  OZChannelEnum::~OZChannelEnum(a20);
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v52 - 128));
  OZChannelButton::~OZChannelButton(a21);
  OZChannel2D::~OZChannel2D(a22);
  OZChannelPercent::~OZChannelPercent(a23);
  OZChannelEnum::~OZChannelEnum(a24);
  OZChannel::~OZChannel(a25);
  OZChannel::~OZChannel(a26);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(a27);
  OZChannel2DOverRange::~OZChannel2DOverRange(a28);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(a29);
  OZChannel::~OZChannel(a30);
  OZChannelBool::~OZChannelBool(a31);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(a32);
  OZChannelPercent::~OZChannelPercent(a33);
  OZChannelPercent::~OZChannelPercent(a34);
  OZChannelEnum::~OZChannelEnum(a35);
  OZChannel::~OZChannel(a36);
  OZChannel::~OZChannel(a37);
  OZChannelEnum::~OZChannelEnum(a38);
  OZChannelEnum::~OZChannelEnum(a39);
  OZChannelEnum::~OZChannelEnum(a40);
  OZChannelBool::~OZChannelBool(a41);
  OZChannel::~OZChannel(a42);
  OZChannelPercent::~OZChannelPercent(a43);
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha(a44);
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v52 - 256));
  OZChannelFolder::~OZChannelFolder(v51);
  OZChannelGradientPositioned::~OZChannelGradientPositioned(*(OZChannelGradientPositioned **)(v52 - 248));
  OZChannelPercent::~OZChannelPercent(*(OZChannelPercent **)(v52 - 240));
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha(*(OZChannelColorNoAlpha **)(v52 - 232));
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v52 - 224));
  OZChannelFolder::~OZChannelFolder(*(OZChannelFolder **)(v52 - 216));
  unint64_t v55 = (void *)v49[345];
  if (v55)
  {
    v49[346] = v55;
    operator delete(v55);
  }
  std::__list_imp<unsigned int>::clear(*(void **)(v52 - 208));
  std::__list_imp<unsigned int>::clear(*(void **)(v52 - 200));
  std::__list_imp<unsigned int>::clear(*(void **)(v52 - 192));
  OZChannel::~OZChannel(*(OZChannel **)(v52 - 184));
  OZChannelPosition::~OZChannelPosition(*(OZChannelPosition **)(v52 - 176));
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v52 - 168));
  OZChannel::~OZChannel(*(OZChannel **)(v52 - 160));
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v52 - 152));
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v52 - 144));
  OZChannelShape::~OZChannelShape(*(OZChannelShape **)(v52 - 136));
  OZChannelFolder::~OZChannelFolder(v45);
  PCMutex::~PCMutex(*(PCMutex **)(v52 - 120));
  _Unwind_Resume(a1);
}

void OZShape::~OZShape(OZShape *this)
{
  *(void *)this = &unk_1F1198070;
  char v2 = (PCMutex *)((char *)this + 8);
  PCMutex::lock((PCMutex *)((char *)this + 8));
  uint64_t v3 = *((void *)this + 333);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    *((void *)this + 333) = 0;
  }
  uint64_t v4 = *((void *)this + 334);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    *((void *)this + 334) = 0;
  }
  uint64_t v5 = *((void *)this + 344);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    *((void *)this + 344) = 0;
  }
  *((void *)this + 346) = *((void *)this + 345);
  uint64_t v6 = (OZGradientGroupShader *)*((void *)this + 2340);
  if (v6)
  {
    OZGradientGroupShader::~OZGradientGroupShader(v6);
    MEMORY[0x1BA9BFBA0]();
    *((void *)this + 2340) = 0;
  }
  uint64_t v7 = (char *)this + 2728;
  while (1)
  {
    uint64_t v8 = *((void *)this + 343);
    if (!v8) {
      break;
    }
    uint64_t v9 = *(void *)v7;
    CMTime v10 = *(OZShapeReparametrizedContour **)(*(void *)v7 + 16);
    if (v10)
    {
      OZShapeReparametrizedContour::~OZShapeReparametrizedContour(v10);
      MEMORY[0x1BA9BFBA0]();
      uint64_t v9 = *((void *)this + 341);
      uint64_t v8 = *((void *)this + 343);
    }
    *(void *)(v9 + 16) = 0;
    uint64_t v11 = (uint64_t *)*((void *)this + 341);
    uint64_t v12 = *v11;
    *(void *)(v12 + 8) = v11[1];
    *(void *)v11[1] = v12;
    *((void *)this + 343) = v8 - 1;
    operator delete(v11);
  }
  uint64_t v13 = (char *)this + 2704;
  while (1)
  {
    uint64_t v14 = *((void *)this + 340);
    if (!v14) {
      break;
    }
    uint64_t v15 = *(void *)v13;
    long long v16 = *(OZShapeContour **)(*(void *)v13 + 16);
    if (v16)
    {
      OZShapeContour::~OZShapeContour(v16);
      MEMORY[0x1BA9BFBA0]();
      uint64_t v15 = *((void *)this + 338);
      uint64_t v14 = *((void *)this + 340);
    }
    *(void *)(v15 + 16) = 0;
    uint64_t v17 = (uint64_t *)*((void *)this + 338);
    uint64_t v18 = *v17;
    *(void *)(v18 + 8) = v17[1];
    *(void *)v17[1] = v18;
    *((void *)this + 340) = v14 - 1;
    operator delete(v17);
  }
  unint64_t v19 = (char *)this + 2680;
  while (1)
  {
    uint64_t v20 = *((void *)this + 337);
    if (!v20) {
      break;
    }
    uint64_t v21 = *(void *)v19;
    unsigned int v22 = *(OZShapeContour **)(*(void *)v19 + 16);
    if (v22)
    {
      OZShapeContour::~OZShapeContour(v22);
      MEMORY[0x1BA9BFBA0]();
      uint64_t v21 = *((void *)this + 335);
      uint64_t v20 = *((void *)this + 337);
    }
    *(void *)(v21 + 16) = 0;
    unsigned int v23 = (uint64_t *)*((void *)this + 335);
    uint64_t v24 = *v23;
    *(void *)(v24 + 8) = v23[1];
    *(void *)v23[1] = v24;
    *((void *)this + 337) = v20 - 1;
    operator delete(v23);
  }
  PCMutex::unlock(v2);
  long long v25 = (void *)*((void *)this + 2328);
  if (v25)
  {
    *((void *)this + 2329) = v25;
    operator delete(v25);
  }
  OZChannelPosition::~OZChannelPosition((OZShape *)((char *)this + 17872));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 17720));
  OZChannelPosition::~OZChannelPosition((OZShape *)((char *)this + 17016));
  OZChannelPosition::~OZChannelPosition((OZShape *)((char *)this + 16312));
  OZChannelPosition::~OZChannelPosition((OZShape *)((char *)this + 15608));
  OZChannelPosition::~OZChannelPosition((OZShape *)((char *)this + 14904));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 14752));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 14600));
  OZChannelText::~OZChannelText((OZChannelText *)((char *)this + 14432));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 14280));
  OZChannelEnum::~OZChannelEnum((PCString *)this + 1753);
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 13872));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 13720));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 13568));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 13416));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 13264));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 13008));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 12856));
  OZChannelButton::~OZChannelButton((OZChannelButton *)((char *)this + 12664));
  OZChannel2D::~OZChannel2D((OZShape *)((char *)this + 12224));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 12072));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 11816));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 11664));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 11512));
  *((void *)this + 1419) = &unk_1F110D998;
  *((void *)this + 1421) = &unk_1F110DD48;
  PCString::~PCString((PCString *)this + 1438);
  OZChanObjectRef::~OZChanObjectRef((OZShape *)((char *)this + 11352));
  *((void *)this + 1363) = &unk_1F110DDA0;
  *((void *)this + 1365) = &unk_1F110E118;
  PCString::~PCString((PCString *)this + 1418);
  OZChannel2D::~OZChannel2D((OZShape *)((char *)this + 10904));
  *((void *)this + 1343) = &unk_1F110D998;
  *((void *)this + 1345) = &unk_1F110DD48;
  PCString::~PCString((PCString *)this + 1362);
  OZChanObjectRef::~OZChanObjectRef((OZShape *)((char *)this + 10744));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 10592));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 10440));
  *((void *)this + 1285) = &unk_1F110D998;
  *((void *)this + 1287) = &unk_1F110DD48;
  PCString::~PCString((PCString *)this + 1304);
  OZChanObjectRef::~OZChanObjectRef((OZShape *)((char *)this + 10280));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 10128));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 9976));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 9720));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 9568));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 9416));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 9160));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 8904));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 8648));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 8496));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 8344));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 0x2000));
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha((OZShape *)((char *)this + 7184));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 6928));
  OZChannelFolder::~OZChannelFolder((OZChannelFolder *)((char *)this + 6800));
  OZChannelGradientPositioned::~OZChannelGradientPositioned((OZShape *)((char *)this + 4328));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 4176));
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha((OZShape *)((char *)this + 3168));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 2912));
  OZChannelFolder::~OZChannelFolder((OZChannelFolder *)((char *)this + 2784));
  long long v26 = (void *)*((void *)this + 345);
  if (v26)
  {
    *((void *)this + 346) = v26;
    operator delete(v26);
  }
  std::__list_imp<unsigned int>::clear((void *)this + 341);
  std::__list_imp<unsigned int>::clear((void *)this + 338);
  std::__list_imp<unsigned int>::clear((void *)this + 335);
  OZChannel::~OZChannel((OZChannel *)((char *)this + 2488));
  OZChannelPosition::~OZChannelPosition((OZShape *)((char *)this + 1784));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 1632));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1480));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 1328));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 1072));
  OZChannelShape::~OZChannelShape((OZShape *)((char *)this + 208));
  OZChannelFolder::~OZChannelFolder((OZChannelFolder *)((char *)this + 80));
  PCMutex::~PCMutex(v2);
}

{
  uint64_t vars8;

  OZShape::~OZShape(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t OZShape::operator=(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (OZGradientGroupShader *)a1[2340];
  if (v4)
  {
    OZGradientGroupShader::~OZGradientGroupShader(v4);
    MEMORY[0x1BA9BFBA0]();
    a1[2340] = 0;
  }
  while (1)
  {
    uint64_t v5 = a1[343];
    if (!v5) {
      break;
    }
    uint64_t v6 = a1[341];
    uint64_t v7 = *(OZShapeReparametrizedContour **)(v6 + 16);
    if (v7)
    {
      OZShapeReparametrizedContour::~OZShapeReparametrizedContour(v7);
      MEMORY[0x1BA9BFBA0]();
      uint64_t v6 = a1[341];
      uint64_t v5 = a1[343];
    }
    *(void *)(v6 + 16) = 0;
    uint64_t v8 = (uint64_t *)a1[341];
    uint64_t v9 = *v8;
    *(void *)(v9 + 8) = v8[1];
    *(void *)v8[1] = v9;
    a1[343] = v5 - 1;
    operator delete(v8);
  }
  while (1)
  {
    uint64_t v12 = a1[337];
    if (!v12) {
      break;
    }
    uint64_t v10 = a1[335];
    uint64_t v11 = *(OZShapeContour **)(v10 + 16);
    if (v11)
    {
      OZShapeContour::~OZShapeContour(v11);
      MEMORY[0x1BA9BFBA0]();
      uint64_t v10 = a1[335];
      uint64_t v12 = a1[337];
    }
    *(void *)(v10 + 16) = 0;
    uint64_t v13 = (uint64_t *)a1[335];
    uint64_t v14 = *v13;
    *(void *)(v14 + 8) = v13[1];
    *(void *)v13[1] = v14;
    a1[337] = v12 - 1;
    operator delete(v13);
  }
  while (1)
  {
    uint64_t v15 = a1[340];
    if (!v15) {
      break;
    }
    uint64_t v16 = a1[338];
    uint64_t v17 = *(OZShapeContour **)(v16 + 16);
    if (v17)
    {
      OZShapeContour::~OZShapeContour(v17);
      MEMORY[0x1BA9BFBA0]();
      uint64_t v16 = a1[338];
      uint64_t v15 = a1[340];
    }
    *(void *)(v16 + 16) = 0;
    uint64_t v18 = (uint64_t *)a1[338];
    uint64_t v19 = *v18;
    *(void *)(v19 + 8) = v18[1];
    *(void *)v18[1] = v19;
    a1[340] = v15 - 1;
    operator delete(v18);
  }
  uint64_t v20 = a1[344];
  if (v20)
  {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
    a1[344] = 0;
  }
  a1[346] = a1[345];
  OZChannelBase::operator=((uint64_t)(a1 + 1785), a2 + 14280);
  OZChannelBase::operator=((uint64_t)(a1 + 1804), a2 + 14432);
  PCString::set((PCString *)a1 + 1823, (const PCString *)(a2 + 14584));
  *((unsigned char *)a1 + 14592) = *(unsigned char *)(a2 + 14592);
  OZChannelBase::operator=((uint64_t)(a1 + 1439), a2 + 11512);
  OZChannelBase::operator=((uint64_t)(a1 + 1458), a2 + 11664);
  OZChannelBase::operator=((uint64_t)(a1 + 1477), a2 + 11816);
  OZChannelBase::operator=((uint64_t)(a1 + 1509), a2 + 12072);
  OZChannelFolder::operator=((uint64_t)(a1 + 1528));
  OZChannelBase::operator=((uint64_t)(a1 + 1545), a2 + 12360);
  OZChannelBase::operator=((uint64_t)(a1 + 1564), a2 + 12512);
  OZChannelBase::operator=((uint64_t)(a1 + 1626), a2 + 13008);
  OZChannelBase::operator=((uint64_t)(a1 + 1658), a2 + 13264);
  OZChannelBase::operator=((uint64_t)(a1 + 1215), a2 + 9720);
  OZChannelBase::operator=((uint64_t)(a1 + 1062), a2 + 8496);
  OZChannelFolder::operator=((uint64_t)(a1 + 850));
  OZChannelBase::operator=((uint64_t)(a1 + 1043), a2 + 8344);
  OZChannelBase::operator=((uint64_t)(a1 + 1081), a2 + 8648);
  OZChannelBase::operator=((uint64_t)(a1 + 1113), a2 + 8904);
  OZChannelBase::operator=((uint64_t)(a1 + 1145), a2 + 9160);
  OZChannelBase::operator=((uint64_t)(a1 + 1177), a2 + 9416);
  OZChannelBase::operator=((uint64_t)(a1 + 1196), a2 + 9568);
  OZChannelBase::operator=((uint64_t)(a1 + 1247), a2 + 9976);
  OZChannelBase::operator=((uint64_t)(a1 + 1266), a2 + 10128);
  OZChannelBase::operator=((uint64_t)(a1 + 1285), a2 + 10280);
  PCString::set((PCString *)a1 + 1304, (const PCString *)(a2 + 10432));
  OZChannelBase::operator=((uint64_t)(a1 + 1305), a2 + 10440);
  OZChannelBase::operator=((uint64_t)(a1 + 1324), a2 + 10592);
  OZChannelFolder::operator=((uint64_t)(a1 + 898));
  OZChannelBase::operator=((uint64_t)(a1 + 915), a2 + 7320);
  OZChannelBase::operator=((uint64_t)(a1 + 934), a2 + 7472);
  OZChannelBase::operator=((uint64_t)(a1 + 953), a2 + 7624);
  OZChannelBase::operator=((uint64_t)(a1 + 972), a2 + 7776);
  OZChannelBase::operator=((uint64_t)(a1 + 991), a2 + 7928);
  *((unsigned char *)a1 + 8184) = *(unsigned char *)(a2 + 8184);
  OZChannelBase::operator=((uint64_t)(a1 + 1024), a2 + 0x2000);
  OZChannelFolder::operator=((uint64_t)(a1 + 348));
  OZChannelBase::operator=((uint64_t)(a1 + 364), a2 + 2912);
  OZChannelFolder::operator=((uint64_t)(a1 + 396));
  OZChannelBase::operator=((uint64_t)(a1 + 413), a2 + 3304);
  OZChannelBase::operator=((uint64_t)(a1 + 432), a2 + 3456);
  OZChannelBase::operator=((uint64_t)(a1 + 451), a2 + 3608);
  OZChannelBase::operator=((uint64_t)(a1 + 470), a2 + 3760);
  OZChannelBase::operator=((uint64_t)(a1 + 489), a2 + 3912);
  *((unsigned char *)a1 + 4168) = *(unsigned char *)(a2 + 4168);
  OZChannelBase::operator=((uint64_t)(a1 + 522), a2 + 4176);
  OZChannelBase::operator=((uint64_t)(a1 + 134), a2 + 1072);
  OZChannelGradientPositioned::operator=((uint64_t)(a1 + 541), a2 + 4328);
  *((unsigned char *)a1 + 2640) = *(unsigned char *)(a2 + 2640);
  *((_DWORD *)a1 + 661) = *(_DWORD *)(a2 + 2644);
  OZChannelBase::operator=((uint64_t)(a1 + 166), a2 + 1328);
  OZChannelPosition::operator=((uint64_t)(a1 + 223), a2 + 1784);
  OZChannelBase::operator=((uint64_t)(a1 + 26), a2 + 208);
  OZChannelBase::operator=((uint64_t)(a1 + 1677), a2 + 13416);
  OZChannelBase::operator=((uint64_t)(a1 + 1696), a2 + 13568);
  OZChannelBase::operator=((uint64_t)(a1 + 185), a2 + 1480);
  OZChannelBase::operator=((uint64_t)(a1 + 204), a2 + 1632);
  OZChannelBase::operator=((uint64_t)(a1 + 1583), a2 + 12664);
  a1[1602] = *(void *)(a2 + 12816);
  PCString::set((PCString *)a1 + 1603, (const PCString *)(a2 + 12824));
  a1[1604] = *(void *)(a2 + 12832);
  PCString::set((PCString *)a1 + 1605, (const PCString *)(a2 + 12840));
  *((unsigned char *)a1 + 12848) = *(unsigned char *)(a2 + 12848);
  OZChannelBase::operator=((uint64_t)(a1 + 1844), a2 + 14752);
  OZChannelPosition::operator=((uint64_t)(a1 + 1863), a2 + 14904);
  OZChannelPosition::operator=((uint64_t)(a1 + 1951), a2 + 15608);
  OZChannelPosition::operator=((uint64_t)(a1 + 2039), a2 + 16312);
  OZChannelPosition::operator=((uint64_t)(a1 + 2127), a2 + 17016);
  OZChannelBase::operator=((uint64_t)(a1 + 2215), a2 + 17720);
  OZChannelPosition::operator=((uint64_t)(a1 + 2234), a2 + 17872);
  uint64_t v21 = *(void *)(a2 + 18592);
  *((_OWORD *)a1 + 1161) = *(_OWORD *)(a2 + 18576);
  a1[2324] = v21;
  OZChannelBase::operator=((uint64_t)(a1 + 1607), a2 + 12856);
  PCMutex::lock((PCMutex *)(a1 + 1));
  OZShapeRenderParams::operator=(a1[333], *(void *)(a2 + 2664));
  OZShapeRenderParams::operator=(a1[334], *(void *)(a2 + 2672));
  PCMutex::unlock((PCMutex *)(a1 + 1));
  OZChannelBase::operator=((uint64_t)(a1 + 1753), a2 + 14024);
  OZChannelBase::operator=((uint64_t)(a1 + 1715), a2 + 13720);
  OZChannelBase::operator=((uint64_t)(a1 + 1734), a2 + 13872);
  OZChannelBase::operator=((uint64_t)(a1 + 1825), a2 + 14600);
  *(_OWORD *)(a1 + 331) = *(_OWORD *)(a2 + 2648);
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 1607), MEMORY[0x1E4F1FA48], 0.0);
  v23.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = (__CFString *)*a1;
  if (ValueAsInt) {
    p_GLsizei length = (uint64_t (**)(uint64_t *))&v23.var0[10].length;
  }
  else {
    p_GLsizei length = (uint64_t (**)(uint64_t *))&v23.var0[11];
  }
  uint64_t result = (*p_length)(a1);
  a1[2340] = 0;
  return result;
}

void sub_1B7E1851C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t OZShape::setIsMask(OZShape *this)
{
  char v2 = (OZChannelBase *)((char *)this + 2784);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 2784), 2, 0);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 6800), 2, 0);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 13008), 2, 0);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 13264), 2, 0);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 14024), 2, 0);
  OZChannelBase::enable(v2, 1, 0);
  OZChannelBase::enable((OZChannelBase *)((char *)this + 6800), 0, 0);
  OZChannelBase::enable((OZChannelBase *)((char *)this + 11512), 1, 0);
  OZChannelBase::enable((OZChannelBase *)((char *)this + 11664), 1, 0);
  OZChannel::setValue((OZChannel *)((char *)this + 12856), MEMORY[0x1E4F1FA48], 1.0, 0);
  uint64_t v3 = *(uint64_t (**)(OZShape *, uint64_t, uint64_t))(*(void *)this + 144);

  return v3(this, 1, 1);
}

uint64_t OZShape::clearIsMask(OZShape *this)
{
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2784), 2, 0);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 6800), 2, 0);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 13008), 2, 0);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 13264), 2, 0);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 14024), 2, 0);
  OZChannel::setValue((OZChannel *)((char *)this + 12856), MEMORY[0x1E4F1FA48], 0.0, 0);
  char v2 = *(uint64_t (**)(OZShape *, uint64_t, uint64_t))(*(void *)this + 144);

  return v2(this, 1, 1);
}

BOOL OZShape::isMask(OZShape *this)
{
  return OZChannel::getValueAsInt((OZChannel *)((char *)this + 12856), MEMORY[0x1E4F1FA48], 0.0) != 0;
}

void OZShape::validateChannels(OZShape *this, const OZShapeRenderState *a2, OZShapeRenderParams *a3)
{
  uint64_t v3 = MEMORY[0x1F4188790](this);
  int v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = v4;
  uint64_t v10 = v3;
  v82[520] = *(int8x8_t *)MEMORY[0x1E4F143B8];
  double v79 = 0.0;
  double v80 = 0.0;
  if (!*((unsigned char *)v4 + 24))
  {
    (*(void (**)(uint64_t, double *, double *, long long *))(*(void *)v3 + 368))(v3, &v80, &v79, v4);
    if (vabdd_f64(v80, *(double *)(v8 + 248)) >= 0.0000001 || vabdd_f64(v79, *(double *)(v8 + 256)) >= 0.0000001)
    {
      if (v6)
      {
        double v11 = v79;
        *(double *)(v8 + 248) = v80;
        *(double *)(v8 + 256) = v11;
      }
      *(_WORD *)(v8 + 1193) = 257;
      *(unsigned char *)(v8 + 1195) = 1;
    }
    (*(void (**)(uint64_t, double *, double *, long long *))(*(void *)v10 + 376))(v10, &v80, &v79, v9);
    if (vabdd_f64(v80, *(double *)(v8 + 264)) >= 0.0000001 || vabdd_f64(v79, *(double *)(v8 + 272)) >= 0.0000001)
    {
      if (v6)
      {
        double v12 = v79;
        *(double *)(v8 + 264) = v80;
        *(double *)(v8 + 272) = v12;
      }
      *(_WORD *)(v8 + 1193) = 257;
      *(unsigned char *)(v8 + 1195) = 1;
    }
  }
  PCHashWriteStream::PCHashWriteStream((PCHashWriteStream *)v82);
  OZChannelCurve::calcHashForAnimationOnly((OZChannel *)(v10 + 208), (PCSerializerWriteStream *)v82, (const CMTime *)v9);
  Hash = (int32x4_t *)PCHashWriteStream::getHash(v82);
  int32x4_t v14 = *Hash;
  if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(*(int32x4_t *)(v8 + 280), *Hash)))))
  {
    *(unsigned char *)(v8 + 1192) = 1;
    *(int32x4_t *)(v8 + 280) = v14;
  }
  OZChannelBase::getTimeOffset((OZChannelBase *)(v10 + 80), (uint64_t)&v77);
  *(_OWORD *)&time1.var0.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v77;
  time1.var0.var1[1] = v78;
  CMTime time2 = *(CMTime *)(v8 + 1168);
  if (CMTimeCompare((CMTime *)&time1, &time2)
    && (OZChannel::hasMoreThanOneKeypoint((OZChannel *)(v10 + 208))
     || ((*(uint64_t (**)(uint64_t))(*(void *)v10 + 152))(v10) & 1) != 0))
  {
    *(unsigned char *)(v8 + 1192) = 1;
  }
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(v10 + 10440), MEMORY[0x1E4F1FA48], 0.0);
  if (ValueAsInt != *(unsigned __int8 *)(v8 + 112))
  {
    *(unsigned char *)(v8 + 112) = ValueAsInt != 0;
    *(_WORD *)(v8 + 1192) = 257;
    *(unsigned char *)(v8 + 1194) = 1;
  }
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 11664), (const CMTime *)v9, 0.0);
  _ZF = vabdd_f64(v16, *(double *)(v8 + 232)) < 0.0000001 || v6 == 0;
  if (!_ZF) {
    *(double *)(v8 + 232) = v16;
  }
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 12072), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v18, *(double *)(v8 + 192)) >= 0.0000001)
  {
    if (v6) {
      *(double *)(v8 + 192) = v18;
    }
    *(_WORD *)(v8 + 1192) = 257;
    *(unsigned char *)(v8 + 1194) = 1;
  }
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 12360), (const CMTime *)v9, 0.0);
  double v20 = v19;
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 12512), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v20, *(double *)(v8 + 200)) >= 0.0000001 || vabdd_f64(v21, *(double *)(v8 + 208)) >= 0.0000001)
  {
    if (v6)
    {
      *(double *)(v8 + 200) = v20;
      *(double *)(v8 + 208) = v21;
    }
    *(_WORD *)(v8 + 1192) = 257;
    *(unsigned char *)(v8 + 1194) = 1;
  }
  int v22 = OZChannel::getValueAsInt((OZChannel *)(v10 + 14752), MEMORY[0x1E4F1FA48], 0.0) != 0;
  if (*(unsigned __int8 *)(v8 + 242) != v22)
  {
    if (v6) {
      *(unsigned char *)(v8 + 242) = v22;
    }
    *(_WORD *)(v8 + 1192) = 257;
    *(unsigned char *)(v8 + 1194) = 1;
  }
  int v23 = OZChannel::getValueAsInt((OZChannel *)(v10 + 1072), (const CMTime *)v9, 0.0);
  if (*(_DWORD *)(v8 + 172) != v23)
  {
    switch(v23)
    {
      case 0:
      case 1:
      case 2:
      case 4:
        if (v6) {
          goto LABEL_41;
        }
        break;
      case 5:
        if (v6) {
LABEL_41:
        }
          *(_DWORD *)(v8 + 172) = v23;
        break;
      default:
        break;
    }
    *(_WORD *)(v8 + 1192) = 257;
    *(unsigned char *)(v8 + 1194) = 1;
  }
  double v24 = *((double *)v9 + 4);
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 11512), (const CMTime *)v9, 0.0);
  double v26 = v25;
  int isEnabled = OZChannelBase::isEnabled((OZChannelBase *)(v10 + 2784), 0, 1);
  if (vabdd_f64(*(double *)(v8 + 224), v24 * v26) >= 0.0000001
    || *(_DWORD *)(v8 + 120) != isEnabled
    || *(unsigned char *)(v8 + 1192))
  {
    if (v6)
    {
      *(_DWORD *)(v8 + 120) = isEnabled;
      *(double *)(v8 + 224) = v24 * v26;
    }
    *(_WORD *)(v8 + 1192) = 257;
    *(unsigned char *)(v8 + 1194) = 1;
  }
  int v28 = OZChannel::getValueAsInt((OZChannel *)(v10 + 6928), (const CMTime *)v9, 0.0);
  int v29 = OZChannelBase::isEnabled((OZChannelBase *)(v10 + 6800), 0, 1);
  if (v28) {
    int v30 = 0;
  }
  else {
    int v30 = v29;
  }
  if ((v28 - 1) < 2) {
    int v31 = v29;
  }
  else {
    int v31 = 0;
  }
  int v32 = *(unsigned __int8 *)(v8 + 12);
  if (v32 == v31 && *(_DWORD *)(v8 + 36) == v28)
  {
    int v33 = v30;
    _ZF = *(_DWORD *)(v8 + 8) == v30;
    int v30 = *(_DWORD *)(v8 + 8);
    if (!_ZF)
    {
LABEL_77:
      int v30 = v33;
      if (!v6) {
        goto LABEL_79;
      }
      goto LABEL_78;
    }
  }
  else
  {
    if (v6) {
      *(_DWORD *)(v8 + 36) = v28;
    }
    *(_WORD *)(v8 + 1192) = 257;
    *(unsigned char *)(v8 + 1194) = 1;
    if (v32 != v31) {
      goto LABEL_76;
    }
    int v33 = v30;
    if (*(_DWORD *)(v8 + 8) != v30) {
      goto LABEL_77;
    }
  }
  double v34 = *(double *)(v8 + 72);
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 9976), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v34, v35) >= 0.0000001) {
    goto LABEL_76;
  }
  double v36 = *(double *)(v8 + 80);
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 10128), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v36, v37) >= 0.0000001) {
    goto LABEL_76;
  }
  double v38 = *(double *)(v8 + 88);
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 10592), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v38, v39) >= 0.0000001) {
    goto LABEL_76;
  }
  double v40 = *(double *)(v8 + 104);
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 9568), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v40, v41) >= 0.0000001
    || (double v42 = *(double *)(v8 + 96),
        OZChannel::getValueAsDouble((OZChannel *)(v10 + 9416), (const CMTime *)v9, 0.0),
        vabdd_f64(v42, v43) >= 0.0000001)
    || (int v44 = *(_DWORD *)(v8 + 24),
        v44 != OZChannel::getValueAsInt((OZChannel *)(v10 + 8648), (const CMTime *)v9, 0.0))
    || (int v45 = *(_DWORD *)(v8 + 28),
        v45 != OZChannel::getValueAsInt((OZChannel *)(v10 + 8904), (const CMTime *)v9, 0.0))
    || (int v46 = *(_DWORD *)(v8 + 32),
        v46 != OZChannel::getValueAsInt((OZChannel *)(v10 + 9160), (const CMTime *)v9, 0.0))
    || (int v47 = *(_DWORD *)(v8 + 116),
        v47 != OZChannel::getValueAsInt((OZChannel *)(v10 + 9720), (const CMTime *)v9, 0.0))
    || (int v48 = *(unsigned __int8 *)(v8 + 13),
        OZChannel::getValueAsInt((OZChannel *)(v10 + 8496), (const CMTime *)v9, 0.0) != v48))
  {
LABEL_76:
    int v33 = v30;
    goto LABEL_77;
  }
  if (*(unsigned char *)(v8 + 1192) && (v6 & 1) != 0)
  {
LABEL_78:
    *(_DWORD *)(v8 + 8) = v30;
    *(unsigned char *)(v8 + 12) = v31;
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 9976), (const CMTime *)v9, 0.0);
    *(void *)(v8 + 72) = v49;
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 10128), (const CMTime *)v9, 0.0);
    *(void *)(v8 + 80) = v50;
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 10592), (const CMTime *)v9, 0.0);
    *(void *)(v8 + 88) = v51;
    *(_DWORD *)(v8 + 24) = OZChannel::getValueAsInt((OZChannel *)(v10 + 8648), (const CMTime *)v9, 0.0);
    *(_DWORD *)(v8 + 28) = OZChannel::getValueAsInt((OZChannel *)(v10 + 8904), (const CMTime *)v9, 0.0);
    *(_DWORD *)(v8 + 32) = OZChannel::getValueAsInt((OZChannel *)(v10 + 9160), (const CMTime *)v9, 0.0);
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 9416), (const CMTime *)v9, 0.0);
    *(void *)(v8 + 96) = v52;
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 9568), (const CMTime *)v9, 0.0);
    *(void *)(v8 + 104) = v53;
    *(_DWORD *)(v8 + 116) = OZChannel::getValueAsInt((OZChannel *)(v10 + 9720), (const CMTime *)v9, 0.0);
    *(unsigned char *)(v8 + 13) = OZChannel::getValueAsInt((OZChannel *)(v10 + 8496), (const CMTime *)v9, 0.0) != 0;
    *(unsigned char *)(v8 + 1195) = 1;
  }
LABEL_79:
  double v54 = *(double *)(v8 + 16);
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 8344), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v54, v55) >= 0.0000001)
  {
    if (!v6) {
      goto LABEL_90;
    }
  }
  else if (!*(unsigned char *)(v8 + 1192) || (v6 & 1) == 0)
  {
    goto LABEL_90;
  }
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 8344), (const CMTime *)v9, 0.0);
  if (v56 < 1.0 && v56 > 0.0) {
    double v56 = 1.0;
  }
  *(double *)(v8 + 16) = v56;
  *(_WORD *)(v8 + 1192) = 257;
  *(unsigned char *)(v8 + 1194) = 1;
LABEL_90:
  if (!OZChannel::getValueAsInt((OZChannel *)(v10 + 1328), (const CMTime *)v9, 0.0))
  {
    int isGeometricShape = OZShape::isGeometricShape((OZShape *)v10);
    long long v58 = (_DWORD *)(v8 + 168);
    if (*(_DWORD *)(v8 + 168) == isGeometricShape) {
      goto LABEL_98;
    }
    if (!isGeometricShape)
    {
      if (v6)
      {
        *long long v58 = 0;
        OZChannelCurve::openCurve((OZChannelCurve *)(v10 + 208));
      }
      goto LABEL_97;
    }
LABEL_95:
    if (v6)
    {
      *long long v58 = 1;
      OZChannelCurve::closeCurve((OZChannelCurve *)(v10 + 208));
    }
LABEL_97:
    *(_WORD *)(v8 + 1192) = 257;
    *(unsigned char *)(v8 + 1194) = 1;
    goto LABEL_98;
  }
  long long v58 = (_DWORD *)(v8 + 168);
  if (*(_DWORD *)(v8 + 168) != 1) {
    goto LABEL_95;
  }
LABEL_98:
  if (v6)
  {
    PCColor::PCColor(&time1);
    OZChannelColorNoAlpha::getColor((OZChannelColorNoAlpha *)(v10 + 3168), (const CMTime *)v9, &time1);
    LODWORD(time2.value) = 0;
    LODWORD(v77) = 0;
    float v75 = 0.0;
    PCColor::getRGB(&time1, (float *)&time2, (float *)&v77, &v75, (const PCColorSpaceHandle *)(v9 + 5));
    double v60 = *(float *)&v77;
    *(double *)(v8 + 128) = *(float *)&time2.value;
    *(double *)(v8 + 136) = v60;
    *(double *)(v8 + 144) = v75;
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 4176), (const CMTime *)v9, 0.0);
    *(void *)(v8 + 152) = v61;
    OZChannelColorNoAlpha::getColor((OZChannelColorNoAlpha *)(v10 + 7184), (const CMTime *)v9, &time1);
    PCColor::getRGB(&time1, (float *)&time2, (float *)&v77, &v75, (const PCColorSpaceHandle *)(v9 + 5));
    double v62 = *(float *)&v77;
    *(double *)(v8 + 40) = *(float *)&time2.value;
    *(double *)(v8 + 48) = v62;
    *(double *)(v8 + 56) = v75;
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 0x2000), (const CMTime *)v9, 0.0);
    *(void *)(v8 + 64) = v63;
    PCCFRef<CGColorSpace *>::~PCCFRef(&time1.var1._obj);
  }
  int v64 = OZChannel::getValueAsInt((OZChannel *)(v10 + 2912), (const CMTime *)v9, 0.0);
  if (*(_DWORD *)(v8 + 124) != v64 && v6) {
    *(_DWORD *)(v8 + 124) = v64;
  }
  if (OZChannel::getValueAsInt((OZChannel *)(v10 + 1480), (const CMTime *)v9, 0.0)) {
    int v65 = *((_DWORD *)v9 + 12);
  }
  else {
    int v65 = 2;
  }
  int v66 = *(_DWORD *)(v8 + 180);
  if (v66 != OZChannel::getValueAsInt((OZChannel *)(v10 + 1480), (const CMTime *)v9, 0.0)
    || *(_DWORD *)(v8 + 184) != v65
    || (int v67 = *(unsigned __int8 *)(v8 + 216),
        OZChannel::getValueAsInt((OZChannel *)(v10 + 1632), (const CMTime *)v9, 0.0) != v67))
  {
    if (v6)
    {
      *(_DWORD *)(v8 + 180) = OZChannel::getValueAsInt((OZChannel *)(v10 + 1480), (const CMTime *)v9, 0.0);
      *(_DWORD *)(v8 + 184) = v65;
      *(unsigned char *)(v8 + 216) = OZChannel::getValueAsInt((OZChannel *)(v10 + 1632), (const CMTime *)v9, 0.0) != 0;
    }
    *(_WORD *)(v8 + 1192) = 257;
    *(unsigned char *)(v8 + 1194) = 1;
  }
  int isRect = OZShape::isRect(v10, (CMTime *)v9);
  int v69 = *(unsigned __int8 *)(v8 + 241);
  if (v69 != isRect && v6) {
    *(unsigned char *)(v8 + 241) = v69 ^ 1;
  }
  if (OZChannel::getValueAsInt((OZChannel *)(v10 + 12856), MEMORY[0x1E4F1FA48], 0.0))
  {
    *(_DWORD *)(v8 + 8) = 0;
    *(void *)(v8 + 120) = 1;
    __asm { FMOV            V0.2D, #1.0 }
    *(_OWORD *)(v8 + 128) = _Q0;
    *(_OWORD *)(v8 + 144) = _Q0;
  }
  long long v74 = *v9;
  *(void *)(v8 + 1160) = *((void *)v9 + 2);
  *(_OWORD *)(v8 + 1144) = v74;
  OZChannelBase::getTimeOffset((OZChannelBase *)(v10 + 80), (uint64_t)&time1);
  *(_OWORD *)(v8 + 1168) = *(_OWORD *)&time1.var0.var0;
  *(double *)(v8 + 1184) = time1.var0.var1[1];
  if (*(unsigned char *)(v8 + 1192) || *(unsigned char *)(v8 + 1193) || *(unsigned char *)(v8 + 1194)) {
    *(unsigned char *)(v8 + 1195) = 1;
  }
  PCHashWriteStream::~PCHashWriteStream((PCHashWriteStream *)v82);
}

void sub_1B7E192A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CGColorSpace *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t OZShape::OZShape_interpolationModeImpl::getInstance(OZShape::OZShape_interpolationModeImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_interpolationModeImpl::getInstance(void)::OZShape_interpolationModeImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    uint64_t v3 = &v4;
    std::__call_once(&OZShape::OZShape_interpolationModeImpl::getInstance(void)::OZShape_interpolationModeImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_interpolationModeImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_interpolationModeImpl::_OZShape_interpolationMode;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_interpolationModeImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_interpolationModeImpl::_OZShape_interpolationMode) {
    operator new();
  }
}

void sub_1B7E193F8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_interpolationModeImpl::OZShape_interpolationModeImpl(OZShape::OZShape_interpolationModeImpl *this)
{
}

void sub_1B7E194CC(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZCurveEnumSplineState::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7E19564(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C401D9FA3FDLL);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_closedImpl::getInstance(OZShape::OZShape_closedImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_closedImpl::getInstance(void)::OZShape_closedImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    uint64_t v3 = &v4;
    std::__call_once(&OZShape::OZShape_closedImpl::getInstance(void)::OZShape_closedImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_closedImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_closedImpl::_OZShape_closed;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_closedImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_closedImpl::_OZShape_closed) {
    operator new();
  }
}

void sub_1B7E19640(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_closedImpl::OZShape_closedImpl(OZChannelBool *this)
{
}

void sub_1B7E19710(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZCurveBoolSplineState::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7E197A8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C401D9FA3FDLL);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_roundnessImpl::getInstance(OZShape::OZShape_roundnessImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_roundnessImpl::getInstance(void)::OZShape_roundnessImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    uint64_t v3 = &v4;
    std::__call_once(&OZShape::OZShape_roundnessImpl::getInstance(void)::OZShape_roundnessImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_roundnessImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_roundnessImpl::_OZShape_roundness;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_roundnessImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_roundnessImpl::_OZShape_roundness) {
    operator new();
  }
}

void sub_1B7E19884(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_roundnessImpl::OZShape_roundnessImpl(OZShape::OZShape_roundnessImpl *this)
{
}

void sub_1B7E19958(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_roundnessInfo::getInstance(OZShape::OZShape_roundnessInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_roundnessInfo::getInstance(void)::OZShape_roundnessInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    uint64_t v3 = &v4;
    std::__call_once(&OZShape::OZShape_roundnessInfo::getInstance(void)::OZShape_roundnessInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_roundnessInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_roundnessInfo::_OZShape_roundnessInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_roundnessInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_roundnessInfo::_OZShape_roundnessInfo) {
    operator new();
  }
}

void sub_1B7E19A34(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZShape::OZShape_roundnessInfo *OZShape::OZShape_roundnessInfo::OZShape_roundnessInfo(OZShape::OZShape_roundnessInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 50.0, 1.0, 1.0, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((OZShape::OZShape_roundnessInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F1198388;
  *((void *)this + 10) = &unk_1F11983A8;
  return this;
}

void sub_1B7E19B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelUint32::createOZChannelUint32Info(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZChannelUint32::_OZChannelUint32Info) {
    operator new();
  }
}

void sub_1B7E19B78(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelUint32Info::OZChannelUint32Info(OZChannelUint32Info *this)
{
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 4294967300.0, 1.0, 1.0, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(void *)this = &unk_1F1198400;
  *((void *)this + 10) = &unk_1F1198420;
}

void sub_1B7E19C28(_Unwind_Exception *a1)
{
  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void OZChannelUint32Info::~OZChannelUint32Info(OZChannelUint32Info *this)
{
  PCSingleton::~PCSingleton((OZChannelUint32Info *)((char *)this + 80));

  OZChannelInfo::~OZChannelInfo((OZChannelInfo *)this);
}

{
  uint64_t vars8;

  PCSingleton::~PCSingleton((OZChannelUint32Info *)((char *)this + 80));
  OZChannelInfo::~OZChannelInfo((OZChannelInfo *)this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'OZChannelUint32Info::~OZChannelUint32Info(OZChannelUint32Info *this)
{
  uint64_t v1 = (OZChannelInfo *)((char *)this - 80);
  PCSingleton::~PCSingleton(this);

  OZChannelInfo::~OZChannelInfo(v1);
}

{
  OZChannelInfo *v1;
  uint64_t vars8;

  uint64_t v1 = (OZChannelInfo *)((char *)this - 80);
  PCSingleton::~PCSingleton(this);
  OZChannelInfo::~OZChannelInfo(v1);

  JUMPOUT(0x1BA9BFBA0);
}

void OZChannelUint32Impl::~OZChannelUint32Impl(OZChannelUint32Impl *this)
{
  PCSingleton::~PCSingleton((OZChannelUint32Impl *)((char *)this + 40));

  OZChannelImpl::~OZChannelImpl((OZChannelImpl *)this);
}

{
  uint64_t vars8;

  PCSingleton::~PCSingleton((OZChannelUint32Impl *)((char *)this + 40));
  OZChannelImpl::~OZChannelImpl((OZChannelImpl *)this);

  JUMPOUT(0x1BA9BFBA0);
}

void non-virtual thunk to'OZChannelUint32Impl::~OZChannelUint32Impl(OZChannelUint32Impl *this)
{
  uint64_t v1 = (OZChannelImpl *)((char *)this - 40);
  PCSingleton::~PCSingleton(this);

  OZChannelImpl::~OZChannelImpl(v1);
}

{
  OZChannelImpl *v1;
  uint64_t vars8;

  uint64_t v1 = (OZChannelImpl *)((char *)this - 40);
  PCSingleton::~PCSingleton(this);
  OZChannelImpl::~OZChannelImpl(v1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::__call_once_param<std::tuple<OZCurveIntSplineState::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7E19ED0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C401D9FA3FDLL);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_initialPositionImpl::getInstance(OZShape::OZShape_initialPositionImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_initialPositionImpl::getInstance(void)::OZShape_initialPositionImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_initialPositionImpl::getInstance(void)::OZShape_initialPositionImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_initialPositionImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_initialPositionImpl::_OZShape_initialPosition;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_initialPositionImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_initialPositionImpl::_OZShape_initialPosition) {
    operator new();
  }
}

void sub_1B7E19FAC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_initialPositionImpl::OZShape_initialPositionImpl(OZShape::OZShape_initialPositionImpl *this)
{
}

void sub_1B7E1A084(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_pixelAspectRatioImpl::getInstance(OZShape::OZShape_pixelAspectRatioImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_pixelAspectRatioImpl::getInstance(void)::OZShape_pixelAspectRatioImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_pixelAspectRatioImpl::getInstance(void)::OZShape_pixelAspectRatioImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_pixelAspectRatioImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_pixelAspectRatioImpl::_OZShape_pixelAspectRatio;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_pixelAspectRatioImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_pixelAspectRatioImpl::_OZShape_pixelAspectRatio) {
    operator new();
  }
}

void sub_1B7E1A160(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_pixelAspectRatioImpl::OZShape_pixelAspectRatioImpl(OZShape::OZShape_pixelAspectRatioImpl *this)
{
}

void sub_1B7E1A238(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeWidthImpl::getInstance(OZShape::OZShape_strokeWidthImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_strokeWidthImpl::getInstance(void)::OZShape_strokeWidthImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_strokeWidthImpl::getInstance(void)::OZShape_strokeWidthImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeWidthImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeWidthImpl::_OZShape_strokeWidth;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeWidthImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_strokeWidthImpl::_OZShape_strokeWidth) {
    operator new();
  }
}

void sub_1B7E1A314(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_strokeWidthImpl::OZShape_strokeWidthImpl(OZChannelUint32 *this)
{
}

void sub_1B7E1A3E8(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeWidthInfo::getInstance(OZShape::OZShape_strokeWidthInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_strokeWidthInfo::getInstance(void)::OZShape_strokeWidthInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_strokeWidthInfo::getInstance(void)::OZShape_strokeWidthInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeWidthInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeWidthInfo::_OZShape_strokeWidthInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeWidthInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_strokeWidthInfo::_OZShape_strokeWidthInfo) {
    operator new();
  }
}

void sub_1B7E1A4C4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZShape::OZShape_strokeWidthInfo *OZShape::OZShape_strokeWidthInfo::OZShape_strokeWidthInfo(OZShape::OZShape_strokeWidthInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 1.0, 100.0, 1.0, 1.0, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((OZShape::OZShape_strokeWidthInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F11985E8;
  *((void *)this + 10) = &unk_1F1198608;
  return this;
}

void sub_1B7E1A594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeJointImpl::getInstance(OZShape::OZShape_strokeJointImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_strokeJointImpl::getInstance(void)::OZShape_strokeJointImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_strokeJointImpl::getInstance(void)::OZShape_strokeJointImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeJointImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeJointImpl::_OZShape_strokeJoint;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeJointImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_strokeJointImpl::_OZShape_strokeJoint) {
    operator new();
  }
}

void sub_1B7E1A670(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_strokeJointImpl::OZShape_strokeJointImpl(OZShape::OZShape_strokeJointImpl *this)
{
}

void sub_1B7E1A744(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeLeftCapImpl::getInstance(OZShape::OZShape_strokeLeftCapImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_strokeLeftCapImpl::getInstance(void)::OZShape_strokeLeftCapImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_strokeLeftCapImpl::getInstance(void)::OZShape_strokeLeftCapImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeLeftCapImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeLeftCapImpl::_OZShape_strokeLeftCap;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeLeftCapImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_strokeLeftCapImpl::_OZShape_strokeLeftCap) {
    operator new();
  }
}

void sub_1B7E1A820(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_strokeLeftCapImpl::OZShape_strokeLeftCapImpl(OZShape::OZShape_strokeLeftCapImpl *this)
{
}

void sub_1B7E1A8F4(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeRightCapImpl::getInstance(OZShape::OZShape_strokeRightCapImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_strokeRightCapImpl::getInstance(void)::OZShape_strokeRightCapImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_strokeRightCapImpl::getInstance(void)::OZShape_strokeRightCapImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeRightCapImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeRightCapImpl::_OZShape_strokeRightCap;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeRightCapImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_strokeRightCapImpl::_OZShape_strokeRightCap) {
    operator new();
  }
}

void sub_1B7E1A9D0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_strokeRightCapImpl::OZShape_strokeRightCapImpl(OZShape::OZShape_strokeRightCapImpl *this)
{
}

void sub_1B7E1AAA4(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeCapArrowLengthImpl::getInstance(OZShape::OZShape_strokeCapArrowLengthImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_strokeCapArrowLengthImpl::getInstance(void)::OZShape_strokeCapArrowLengthImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_strokeCapArrowLengthImpl::getInstance(void)::OZShape_strokeCapArrowLengthImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeCapArrowLengthImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeCapArrowLengthImpl::_OZShape_strokeCapArrowLength;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeCapArrowLengthImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_strokeCapArrowLengthImpl::_OZShape_strokeCapArrowLength) {
    operator new();
  }
}

void sub_1B7E1AB80(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_strokeCapArrowLengthImpl::OZShape_strokeCapArrowLengthImpl(OZShape::OZShape_strokeCapArrowLengthImpl *this)
{
}

void sub_1B7E1AC54(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeCapArrowLengthInfo::getInstance(OZShape::OZShape_strokeCapArrowLengthInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_strokeCapArrowLengthInfo::getInstance(void)::OZShape_strokeCapArrowLengthInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_strokeCapArrowLengthInfo::getInstance(void)::OZShape_strokeCapArrowLengthInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeCapArrowLengthInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeCapArrowLengthInfo::_OZShape_strokeCapArrowLengthInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeCapArrowLengthInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_strokeCapArrowLengthInfo::_OZShape_strokeCapArrowLengthInfo) {
    operator new();
  }
}

void sub_1B7E1AD30(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZChannelInfo *OZShape::OZShape_strokeCapArrowLengthInfo::OZShape_strokeCapArrowLengthInfo(OZChannelInfo *this)
{
  OZChannelInfo::OZChannelInfo(this, 0.0, 3.0, 0.01, 0.0001, 100.0, "%");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(void *)this = &unk_1F1198840;
  *((void *)this + 10) = &unk_1F1198860;
  return this;
}

void sub_1B7E1ADE8(_Unwind_Exception *a1)
{
  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeCapArrowWidthImpl::getInstance(OZShape::OZShape_strokeCapArrowWidthImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_strokeCapArrowWidthImpl::getInstance(void)::OZShape_strokeCapArrowWidthImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_strokeCapArrowWidthImpl::getInstance(void)::OZShape_strokeCapArrowWidthImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeCapArrowWidthImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeCapArrowWidthImpl::_OZShape_strokeCapArrowWidth;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeCapArrowWidthImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_strokeCapArrowWidthImpl::_OZShape_strokeCapArrowWidth) {
    operator new();
  }
}

void sub_1B7E1AEB4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_strokeCapArrowWidthImpl::OZShape_strokeCapArrowWidthImpl(OZShape::OZShape_strokeCapArrowWidthImpl *this)
{
}

void sub_1B7E1AF88(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeCapArrowWidthInfo::getInstance(OZShape::OZShape_strokeCapArrowWidthInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_strokeCapArrowWidthInfo::getInstance(void)::OZShape_strokeCapArrowWidthInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_strokeCapArrowWidthInfo::getInstance(void)::OZShape_strokeCapArrowWidthInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeCapArrowWidthInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeCapArrowWidthInfo::_OZShape_strokeCapArrowWidthInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeCapArrowWidthInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_strokeCapArrowWidthInfo::_OZShape_strokeCapArrowWidthInfo) {
    operator new();
  }
}

void sub_1B7E1B064(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZChannelInfo *OZShape::OZShape_strokeCapArrowWidthInfo::OZShape_strokeCapArrowWidthInfo(OZChannelInfo *this)
{
  OZChannelInfo::OZChannelInfo(this, 0.0, 3.0, 0.01, 0.0001, 100.0, "%");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(void *)this = &unk_1F1198930;
  *((void *)this + 10) = &unk_1F1198950;
  return this;
}

void sub_1B7E1B11C(_Unwind_Exception *a1)
{
  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_softEdgeRadiusImpl::getInstance(OZShape::OZShape_softEdgeRadiusImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_softEdgeRadiusImpl::getInstance(void)::OZShape_softEdgeRadiusImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_softEdgeRadiusImpl::getInstance(void)::OZShape_softEdgeRadiusImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_softEdgeRadiusImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_softEdgeRadiusImpl::_OZShape_softEdgeRadius;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_softEdgeRadiusImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_softEdgeRadiusImpl::_OZShape_softEdgeRadius) {
    operator new();
  }
}

void sub_1B7E1B1E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_softEdgeRadiusImpl::OZShape_softEdgeRadiusImpl(OZShape::OZShape_softEdgeRadiusImpl *this)
{
}

void sub_1B7E1B2C0(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_softEdgeRadiusInfo::getInstance(OZShape::OZShape_softEdgeRadiusInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_softEdgeRadiusInfo::getInstance(void)::OZShape_softEdgeRadiusInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_softEdgeRadiusInfo::getInstance(void)::OZShape_softEdgeRadiusInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_softEdgeRadiusInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_softEdgeRadiusInfo::_OZShape_softEdgeRadiusInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_softEdgeRadiusInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_softEdgeRadiusInfo::_OZShape_softEdgeRadiusInfo) {
    operator new();
  }
}

void sub_1B7E1B39C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZShape::OZShape_softEdgeRadiusInfo *OZShape::OZShape_softEdgeRadiusInfo::OZShape_softEdgeRadiusInfo(OZShape::OZShape_softEdgeRadiusInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -100.0, 100.0, 1.0, 0.001, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((OZShape::OZShape_softEdgeRadiusInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F1198A20;
  *((void *)this + 10) = &unk_1F1198A40;
  return this;
}

void sub_1B7E1B474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_softEdgeFalloffImpl::getInstance(OZShape::OZShape_softEdgeFalloffImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_softEdgeFalloffImpl::getInstance(void)::OZShape_softEdgeFalloffImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_softEdgeFalloffImpl::getInstance(void)::OZShape_softEdgeFalloffImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_softEdgeFalloffImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_softEdgeFalloffImpl::_OZShape_softEdgeFalloff;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_softEdgeFalloffImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_softEdgeFalloffImpl::_OZShape_softEdgeFalloff) {
    operator new();
  }
}

void sub_1B7E1B550(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_softEdgeFalloffImpl::OZShape_softEdgeFalloffImpl(OZShape::OZShape_softEdgeFalloffImpl *this)
{
}

void sub_1B7E1B628(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_softEdgeFalloffInfo::getInstance(OZShape::OZShape_softEdgeFalloffInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_softEdgeFalloffInfo::getInstance(void)::OZShape_softEdgeFalloffInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_softEdgeFalloffInfo::getInstance(void)::OZShape_softEdgeFalloffInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_softEdgeFalloffInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_softEdgeFalloffInfo::_OZShape_softEdgeFalloffInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_softEdgeFalloffInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_softEdgeFalloffInfo::_OZShape_softEdgeFalloffInfo) {
    operator new();
  }
}

void sub_1B7E1B704(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZShape::OZShape_softEdgeFalloffInfo *OZShape::OZShape_softEdgeFalloffInfo::OZShape_softEdgeFalloffInfo(OZShape::OZShape_softEdgeFalloffInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -100.0, 100.0, 1.0, 0.001, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((OZShape::OZShape_softEdgeFalloffInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F1198B10;
  *((void *)this + 10) = &unk_1F1198B30;
  return this;
}

void sub_1B7E1B7DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_softEdgeKernelImpl::getInstance(OZShape::OZShape_softEdgeKernelImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_softEdgeKernelImpl::getInstance(void)::OZShape_softEdgeKernelImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_softEdgeKernelImpl::getInstance(void)::OZShape_softEdgeKernelImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_softEdgeKernelImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_softEdgeKernelImpl::_OZShape_softEdgeKernel;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_softEdgeKernelImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_softEdgeKernelImpl::_OZShape_softEdgeKernel) {
    operator new();
  }
}

void sub_1B7E1B8B8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_softEdgeKernelImpl::OZShape_softEdgeKernelImpl(OZShape::OZShape_softEdgeKernelImpl *this)
{
}

void sub_1B7E1B98C(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_ellipseCurvatureImpl::getInstance(OZShape::OZShape_ellipseCurvatureImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_ellipseCurvatureImpl::getInstance(void)::OZShape_ellipseCurvatureImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_ellipseCurvatureImpl::getInstance(void)::OZShape_ellipseCurvatureImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_ellipseCurvatureImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_ellipseCurvatureImpl::_OZShape_ellipseCurvature;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_ellipseCurvatureImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_ellipseCurvatureImpl::_OZShape_ellipseCurvature) {
    operator new();
  }
}

void sub_1B7E1BA68(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_ellipseCurvatureImpl::OZShape_ellipseCurvatureImpl(OZChannelPercent *this)
{
}

void sub_1B7E1BB38(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZCurvePercentSplineState::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
}

void sub_1B7E1BBD0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C401D9FA3FDLL);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_shapeRadiusImpl::getInstance(OZShape::OZShape_shapeRadiusImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_shapeRadiusImpl::getInstance(void)::OZShape_shapeRadiusImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_shapeRadiusImpl::getInstance(void)::OZShape_shapeRadiusImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_shapeRadiusImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_shapeRadiusImpl::_OZShape_shapeRadius;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_shapeRadiusImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_shapeRadiusImpl::_OZShape_shapeRadius) {
    operator new();
  }
}

void sub_1B7E1BCAC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_shapeRadiusImpl::OZShape_shapeRadiusImpl(OZShape::OZShape_shapeRadiusImpl *this)
{
}

void sub_1B7E1BD80(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_shapeRadiusInfo::getInstance(OZShape::OZShape_shapeRadiusInfo *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_shapeRadiusInfo::getInstance(void)::OZShape_shapeRadiusInfo_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_shapeRadiusInfo::getInstance(void)::OZShape_shapeRadiusInfo_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_shapeRadiusInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_shapeRadiusInfo::_OZShape_shapeRadiusInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_shapeRadiusInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_shapeRadiusInfo::_OZShape_shapeRadiusInfo) {
    operator new();
  }
}

void sub_1B7E1BE5C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZShape::OZShape_shapeRadiusInfo *OZShape::OZShape_shapeRadiusInfo::OZShape_shapeRadiusInfo(OZShape::OZShape_shapeRadiusInfo *this)
{
  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 1000.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((OZShape::OZShape_shapeRadiusInfo *)((char *)this + 80), 100);
  *(void *)this = &unk_1F1198CF0;
  *((void *)this + 10) = &unk_1F1198D10;
  return this;
}

void sub_1B7E1BF30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_initialScaleXImpl::getInstance(OZShape::OZShape_initialScaleXImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_initialScaleXImpl::getInstance(void)::OZShape_initialScaleXImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_initialScaleXImpl::getInstance(void)::OZShape_initialScaleXImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_initialScaleXImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_initialScaleXImpl::_OZShape_initialScaleX;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_initialScaleXImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_initialScaleXImpl::_OZShape_initialScaleX) {
    operator new();
  }
}

void sub_1B7E1C00C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_initialScaleXImpl::OZShape_initialScaleXImpl(OZShape::OZShape_initialScaleXImpl *this)
{
}

void sub_1B7E1C0E4(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_initialScaleYImpl::getInstance(OZShape::OZShape_initialScaleYImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_initialScaleYImpl::getInstance(void)::OZShape_initialScaleYImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_initialScaleYImpl::getInstance(void)::OZShape_initialScaleYImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_initialScaleYImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_initialScaleYImpl::_OZShape_initialScaleY;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_initialScaleYImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_initialScaleYImpl::_OZShape_initialScaleY) {
    operator new();
  }
}

void sub_1B7E1C1C0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_initialScaleYImpl::OZShape_initialScaleYImpl(OZShape::OZShape_initialScaleYImpl *this)
{
}

void sub_1B7E1C298(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_disableAntialiasingiOSImpl::getInstance(OZShape::OZShape_disableAntialiasingiOSImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_disableAntialiasingiOSImpl::getInstance(void)::OZShape_disableAntialiasingiOSImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_disableAntialiasingiOSImpl::getInstance(void)::OZShape_disableAntialiasingiOSImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_disableAntialiasingiOSImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_disableAntialiasingiOSImpl::_OZShape_disableAntialiasingiOS;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_disableAntialiasingiOSImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_disableAntialiasingiOSImpl::_OZShape_disableAntialiasingiOS) {
    operator new();
  }
}

void sub_1B7E1C374(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_disableAntialiasingiOSImpl::OZShape_disableAntialiasingiOSImpl(OZChannelBool *this)
{
}

void sub_1B7E1C448(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_fixedFeatherWidthImpl::getInstance(OZShape::OZShape_fixedFeatherWidthImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_fixedFeatherWidthImpl::getInstance(void)::OZShape_fixedFeatherWidthImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_fixedFeatherWidthImpl::getInstance(void)::OZShape_fixedFeatherWidthImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_fixedFeatherWidthImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_fixedFeatherWidthImpl::_OZShape_fixedFeatherWidth;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_fixedFeatherWidthImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_fixedFeatherWidthImpl::_OZShape_fixedFeatherWidth) {
    operator new();
  }
}

void sub_1B7E1C524(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_fixedFeatherWidthImpl::OZShape_fixedFeatherWidthImpl(OZChannelBool *this)
{
}

void sub_1B7E1C5F8(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_boxTopLeftImpl::getInstance(OZShape::OZShape_boxTopLeftImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_boxTopLeftImpl::getInstance(void)::OZShape_boxTopLeftImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_boxTopLeftImpl::getInstance(void)::OZShape_boxTopLeftImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_boxTopLeftImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_boxTopLeftImpl::_OZShape_boxTopLeft;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_boxTopLeftImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_boxTopLeftImpl::_OZShape_boxTopLeft) {
    operator new();
  }
}

void sub_1B7E1C6D4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_boxTopLeftImpl::OZShape_boxTopLeftImpl(OZShape::OZShape_boxTopLeftImpl *this)
{
}

void sub_1B7E1C7AC(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_boxTopRightImpl::getInstance(OZShape::OZShape_boxTopRightImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_boxTopRightImpl::getInstance(void)::OZShape_boxTopRightImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_boxTopRightImpl::getInstance(void)::OZShape_boxTopRightImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_boxTopRightImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_boxTopRightImpl::_OZShape_boxTopRight;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_boxTopRightImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_boxTopRightImpl::_OZShape_boxTopRight) {
    operator new();
  }
}

void sub_1B7E1C888(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_boxTopRightImpl::OZShape_boxTopRightImpl(OZShape::OZShape_boxTopRightImpl *this)
{
}

void sub_1B7E1C960(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_boxBottomLeftImpl::getInstance(OZShape::OZShape_boxBottomLeftImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_boxBottomLeftImpl::getInstance(void)::OZShape_boxBottomLeftImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_boxBottomLeftImpl::getInstance(void)::OZShape_boxBottomLeftImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_boxBottomLeftImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_boxBottomLeftImpl::_OZShape_boxBottomLeft;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_boxBottomLeftImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_boxBottomLeftImpl::_OZShape_boxBottomLeft) {
    operator new();
  }
}

void sub_1B7E1CA3C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_boxBottomLeftImpl::OZShape_boxBottomLeftImpl(OZShape::OZShape_boxBottomLeftImpl *this)
{
}

void sub_1B7E1CB14(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_boxBottomRightImpl::getInstance(OZShape::OZShape_boxBottomRightImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_boxBottomRightImpl::getInstance(void)::OZShape_boxBottomRightImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_boxBottomRightImpl::getInstance(void)::OZShape_boxBottomRightImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_boxBottomRightImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_boxBottomRightImpl::_OZShape_boxBottomRight;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_boxBottomRightImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_boxBottomRightImpl::_OZShape_boxBottomRight) {
    operator new();
  }
}

void sub_1B7E1CBF0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_boxBottomRightImpl::OZShape_boxBottomRightImpl(OZShape::OZShape_boxBottomRightImpl *this)
{
}

void sub_1B7E1CCC8(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_boxRotationImpl::getInstance(OZShape::OZShape_boxRotationImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_boxRotationImpl::getInstance(void)::OZShape_boxRotationImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_boxRotationImpl::getInstance(void)::OZShape_boxRotationImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_boxRotationImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_boxRotationImpl::_OZShape_boxRotation;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_boxRotationImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_boxRotationImpl::_OZShape_boxRotation) {
    operator new();
  }
}

void sub_1B7E1CDA4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_boxRotationImpl::OZShape_boxRotationImpl(OZShape::OZShape_boxRotationImpl *this)
{
}

void sub_1B7E1CE7C(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_boxPivotImpl::getInstance(OZShape::OZShape_boxPivotImpl *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&OZShape::OZShape_boxPivotImpl::getInstance(void)::OZShape_boxPivotImpl_once, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    PCString v3 = &v4;
    std::__call_once(&OZShape::OZShape_boxPivotImpl::getInstance(void)::OZShape_boxPivotImpl_once, &v3, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_boxPivotImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_boxPivotImpl::_OZShape_boxPivot;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_boxPivotImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  if (!OZShape::OZShape_boxPivotImpl::_OZShape_boxPivot) {
    operator new();
  }
}

void sub_1B7E1CF58(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShape::OZShape_boxPivotImpl::OZShape_boxPivotImpl(OZShape::OZShape_boxPivotImpl *this)
{
}

void sub_1B7E1D030(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

void OZShapeReparametrizedContour::~OZShapeReparametrizedContour(OZShapeReparametrizedContour *this)
{
  uint64_t v2 = *((void *)this + 48);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    *((void *)this + 48) = 0;
  }
  PCString v3 = (void *)*((void *)this + 56);
  if (v3)
  {
    *((void *)this + 57) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 53);
  if (v4)
  {
    *((void *)this + 54) = v4;
    operator delete(v4);
  }
  int v5 = (void *)*((void *)this + 50);
  if (v5)
  {
    *((void *)this + 51) = v5;
    operator delete(v5);
  }

  OZShapeContour::~OZShapeContour(this);
}

void OZShapeContour::~OZShapeContour(OZShapeContour *this)
{
  uint64_t v2 = (void *)*((void *)this + 45);
  if (v2)
  {
    *((void *)this + 46) = v2;
    operator delete(v2);
  }
  PCString v3 = (void *)*((void *)this + 42);
  if (v3)
  {
    *((void *)this + 43) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 39);
  if (v4)
  {
    *((void *)this + 40) = v4;
    operator delete(v4);
  }
  int v5 = (void *)*((void *)this + 36);
  if (v5)
  {
    *((void *)this + 37) = v5;
    operator delete(v5);
  }
  int v6 = (void *)*((void *)this + 33);
  if (v6)
  {
    *((void *)this + 34) = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)*((void *)this + 30);
  if (v7)
  {
    *((void *)this + 31) = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void *)*((void *)this + 27);
  if (v8)
  {
    *((void *)this + 28) = v8;
    operator delete(v8);
  }
  uint64_t v9 = (void *)*((void *)this + 24);
  if (v9)
  {
    *((void *)this + 25) = v9;
    operator delete(v9);
  }
}

uint64_t OZShape::didAddVertex(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 128))();
}

void OZShape::addVertex(OZShape *this, CMTime *a2, double a3, double a4)
{
}

uint64_t OZShape::addVertices(uint64_t a1, const CMTime *a2, uint64_t a3)
{
  OZChannelCurve::addVertices(a1 + 208, a2, a3);
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 144);

  return v4(a1, 1, 1);
}

uint64_t OZShape::openCurve(uint64_t a1, void **a2)
{
  PCString v3 = (OZChannelShape *)(a1 + 208);
  if (a2)
  {
    OZChannelCurve::openCurve(a1 + 208, *a2, a2[1]);
    OZChannelShape::refreshAnimation(v3);
  }
  else
  {
    OZChannelCurve::openCurve((OZChannelCurve *)(a1 + 208));
  }
  OZChannel::setValue((OZChannel *)(a1 + 1328), MEMORY[0x1E4F1FA48], 0.0, 0);
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 144);

  return v4(a1, 1, 1);
}

uint64_t OZShape::deleteAll(OZShape *this)
{
  (*(void (**)(OZShape *))(*(void *)this + 104))(this);
  OZChannelCurve::deleteAllVertices((OZShape *)((char *)this + 208));
  OZShape::openCurve((uint64_t)this, 0);
  OZChannel::setValue((OZChannel *)((char *)this + 14280), MEMORY[0x1E4F1FA48], 0.0, 0);
  uint64_t v2 = *(uint64_t (**)(OZShape *, uint64_t, uint64_t))(*(void *)this + 144);

  return v2(this, 1, 1);
}

CGColorSpace **OZShape::closeCurve(OZShape *this, const CMTime *a2)
{
  OZShapeRenderState::OZShapeRenderState((OZShapeRenderState *)&v11);
  long long v11 = *(_OWORD *)&a2->value;
  *(void *)&long long v12 = a2->epoch;
  OZChannelCurve::closeCurve((OZShape *)((char *)this + 208));
  uint64_t v4 = (void *)*((void *)this + 59);
  if (v4 && (int)((v4[1] - *v4) >> 3) >= 6)
  {
    v8[2] = v13;
    v8[3] = v14;
    v8[4] = v15;
    v8[0] = v11;
    v8[1] = v12;
    CGColorSpaceRef v9 = space;
    if (space) {
      PCCFRefTraits<CGColorSpace *>::retain(space);
    }
    int v10 = v17;
    uint64_t CurrentRenderParams = OZShape::getCurrentRenderParams((uint64_t)this, (uint64_t)v8);
    double v6 = OZShape::calculatePolygonArea((uint64_t)this, (CMTime *)&v11, CurrentRenderParams, 0);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v9);
    if (v6 > 0.0) {
      OZChannelCurve::reverseWindingOrder((OZShape *)((char *)this + 208));
    }
  }
  OZChannel::setValue((OZChannel *)((char *)this + 1328), MEMORY[0x1E4F1FA48], 1.0, 0);
  (*(void (**)(OZShape *, uint64_t, uint64_t))(*(void *)this + 144))(this, 1, 1);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&space);
}

void sub_1B7E1D554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,CGColorSpace *a31)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v31);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a31);
  _Unwind_Resume(a1);
}

CGColorSpace **OZShape::finishCurve(OZShape *this, const CMTime *a2, int a3)
{
  OZShapeRenderState::OZShapeRenderState((OZShapeRenderState *)&v32);
  long long v32 = *(_OWORD *)&a2->value;
  *(void *)&long long v33 = a2->epoch;
  OZChannel::setValue((OZChannel *)((char *)this + 14280), MEMORY[0x1E4F1FA48], 1.0, 0);
  int v30 = (char *)this + 8;
  PCMutex::lock((PCMutex *)((char *)this + 8));
  char v31 = 1;
  CMTime v27[2] = v34;
  v27[3] = v35;
  float v27[4] = v36;
  v27[0] = v32;
  v27[1] = v33;
  int v28 = v37;
  if (v37) {
    PCCFRefTraits<CGColorSpace *>::retain(v37);
  }
  int v29 = v38;
  uint64_t CurrentRenderParams = OZShape::getCurrentRenderParams((uint64_t)this, (uint64_t)v27);
  (*(void (**)(OZShape *, long long *, uint64_t, void, uint64_t))(*(void *)this + 64))(this, &v32, CurrentRenderParams, 0, 1);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v28);
  OZShape::calculateBounds(this, (const OZShapeRenderState *)&v32);
  if (a3)
  {
    if (!OZShape::isGeometricShape(this))
    {
      _OWORD v24[2] = v34;
      v24[3] = v35;
      v24[4] = v36;
      v24[0] = v32;
      v24[1] = v33;
      double v25 = v37;
      if (v37) {
        PCCFRefTraits<CGColorSpace *>::retain(v37);
      }
      int v26 = v38;
      uint64_t v7 = (OZShapeRenderParams *)OZShape::getCurrentRenderParams((uint64_t)this, (uint64_t)v24);
      uint64_t Contour = OZShape::getContour(this, (const OZShapeRenderState *)&v32, v7);
      PCCFRef<CGColorSpace *>::~PCCFRef(&v25);
      __asm { FMOV            V2.2D, #0.5 }
      float64x2_t v14 = vaddq_f64(*(float64x2_t *)(Contour + 24), vmulq_f64(*(float64x2_t *)(Contour + 40), _Q2));
      *(float64x2_t *)((char *)this + 2648) = v14;
      OZChannelCurve::offsetCurve((OZShape *)((char *)this + 208), a2, -v14.f64[0], -v14.f64[1]);
    }
    *((unsigned char *)this + 2640) = 1;
    if ((*(uint64_t (**)(OZShape *))(*(void *)this + 312))(this))
    {
      long long v22 = *(_OWORD *)&a2->value;
      CMTimeEpoch epoch = a2->epoch;
      (*(void (**)(OZShape *, long long *, double, double))(*(void *)this + 232))(this, &v22, *((double *)this + 331), *((double *)this + 332));
    }
    else
    {
      (*(void (**)(OZShape *, const CMTime *, double, double))(*(void *)this + 384))(this, a2, *((double *)this + 331), *((double *)this + 332));
    }
    if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 1328), a2, 0.0))
    {
      long long v15 = (void *)*((void *)this + 59);
      if (v15)
      {
        if ((int)((v15[1] - *v15) >> 3) >= 6)
        {
          CMTime v19[2] = v34;
          _DWORD v19[3] = v35;
          v19[4] = v36;
          v19[0] = v32;
          v19[1] = v33;
          double v20 = v37;
          if (v37) {
            PCCFRefTraits<CGColorSpace *>::retain(v37);
          }
          int v21 = v38;
          uint64_t v16 = OZShape::getCurrentRenderParams((uint64_t)this, (uint64_t)v19);
          double v17 = OZShape::calculatePolygonArea((uint64_t)this, (CMTime *)&v32, v16, 0);
          PCCFRef<CGColorSpace *>::~PCCFRef(&v20);
          if (v17 > 0.0) {
            OZChannelCurve::reverseWindingOrder((OZShape *)((char *)this + 208));
          }
        }
      }
    }
    if (!OZChannel::getValueAsInt((OZChannel *)((char *)this + 1328), a2, 0.0))
    {
      OZChannelBase::enable((OZChannelBase *)((char *)this + 2784), 0, 0);
      OZChannelBase::enable((OZChannelBase *)((char *)this + 6800), 1, 0);
    }
  }
  if (OZChannelCurve::isCurveFlattened((OZShape *)((char *)this + 208))
    && OZChannel::getValueAsInt((OZChannel *)((char *)this + 1072), MEMORY[0x1E4F1FA48], 0.0) == 1)
  {
    OZChannel::setInitialValue((OZChannel *)((char *)this + 1072), 0.0, 1);
  }
  OZChannelCurve::setDefaultAtCurrentTime((OZShape *)((char *)this + 208), a2);
  (*(void (**)(OZShape *, uint64_t, uint64_t))(*(void *)this + 144))(this, 1, 1);
  PCMutex::unlock((PCMutex *)((char *)this + 8));
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v37);
}

void sub_1B7E1D974(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  PCLockSentry<PCMutex>::~PCLockSentry(v2 - 176);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v2 - 80));
  _Unwind_Resume(a1);
}

uint64_t OZShape::completeCurve(OZShape *this)
{
  return OZChannel::setValue((OZChannel *)((char *)this + 14280), MEMORY[0x1E4F1FA48], 1.0, 0);
}

void OZShape::didSetInterpolation(OZShape *this)
{
  uint64_t v2 = (OZChannelBase *)((char *)this + 1072);
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 1072), MEMORY[0x1E4F1FA48], 0.0);
  if (ValueAsInt == 2)
  {
    int v6 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 13720), MEMORY[0x1E4F1FA48], 0.0);
    uint64_t v4 = (OZShape *)((char *)this + 208);
    if (v6) {
      uint64_t v5 = 10;
    }
    else {
      uint64_t v5 = 12;
    }
  }
  else if (ValueAsInt == 1)
  {
    uint64_t v4 = (OZShape *)((char *)this + 208);
    uint64_t v5 = 4;
  }
  else
  {
    if (ValueAsInt) {
      goto LABEL_10;
    }
    uint64_t v4 = (OZShape *)((char *)this + 208);
    uint64_t v5 = 1;
  }
  OZChannelCurve::setCurveInterpolation(v4, v5);
LABEL_10:
  if (OZChannel::getValueAsInt((OZChannel *)v2, MEMORY[0x1E4F1FA48], 0.0) == 4)
  {
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 1328), 2, 0);
    OZChannelBase::setFlag(v2, 2, 0);
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 1480), 2, 0);
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 1632), 2, 0);
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 208), 2, 0);
    OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12072), 2, 0);
    OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12224), 2, 0);
    OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12664), 2, 0);
  }
  else
  {
    int v7 = OZChannel::getValueAsInt((OZChannel *)v2, MEMORY[0x1E4F1FA48], 0.0);
    uint64_t v8 = (OZChannelBase *)((char *)this + 1328);
    if (v7 == 5)
    {
      OZChannelBase::setFlag(v8, 2, 0);
      OZChannelBase::setFlag(v2, 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1480), 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1632), 2, 0);
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 208), 2, 0);
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 12072), 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12224), 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12664), 2, 0);
      PCString::PCString(&v9, "Shape Size", "com.apple.proshapes.framework");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 12224), &v9, 0);
      PCString::~PCString(&v9);
      PCString::PCString(&v9, "Shape Size Width", "com.apple.proshapes.framework");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 12360), &v9, 0);
      PCString::~PCString(&v9);
      PCString::PCString(&v9, "Shape Size Height", "com.apple.proshapes.framework");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 12512), &v9, 0);
      PCString::~PCString(&v9);
    }
    else
    {
      OZChannelBase::resetFlag(v8, 2, 0);
      OZChannelBase::resetFlag(v2, 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1480), 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1632), 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 208), 2, 0);
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 12072), 2, 0);
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 12224), 2, 0);
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 12664), 2, 0);
    }
  }
}

void sub_1B7E1DD70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t OZShape::setInterpolation(OZShape *this, unsigned int a2)
{
  OZChannel::setValue((OZChannel *)((char *)this + 1072), MEMORY[0x1E4F1FA48], (double)a2, 0);
  if (a2 == 1) {
    OZChannelCurve::flattenCurve((OZShape *)((char *)this + 208));
  }
  uint64_t v4 = *(uint64_t (**)(OZShape *))(*(void *)this + 120);

  return v4(this);
}

void OZShapeRenderState::OZShapeRenderState(OZShapeRenderState *this)
{
  long long v2 = *MEMORY[0x1E4F1FA48];
  *((void *)this + 2) = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  *(_OWORD *)this = v2;
  *((_WORD *)this + 12) = 0;
  *((unsigned char *)this + 26) = 0;
  __asm { FMOV            V0.2D, #1.0 }
  *((_OWORD *)this + 2) = _Q0;
  *((_DWORD *)this + 12) = 2;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 7) = 0;
  PCColorSpaceCache::rec709Linear((CGColorSpace **)this + 10);
  *((float *)this + 22) = PCRenderModel::getDefaultBlendingGamma(v8);
}

void sub_1B7E1DE7C(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

long double OZShapeEdgeTexture::smoothStep(OZShapeEdgeTexture *this, double a2, double a3)
{
  long double result = 1.0;
  if (a2 >= 0.0)
  {
    long double result = 0.0;
    if (a2 <= 2.0)
    {
      long double v5 = (2.0 - a2) * 0.5;
      long double v6 = v5 + (pow(v5, 1.5) - v5) * ((1.0 - v5) * 0.5 + -0.5 + 1.0);
      return (v5 * 0.5 + -0.5 + 1.0) * (1.0 - pow(1.0 - v5, 1.5) - v5) + v6;
    }
  }
  return result;
}

double OZShapeEdgeTexture::eval(LiEdgeTexture *a1, double a2, double a3)
{
  double result = 1.0;
  if (a2 > 0.0)
  {
    if (a2 >= a3)
    {
      return 0.0;
    }
    else
    {
      switch((int)a1)
      {
        case 0:
          if (a2 >= 0.5)
          {
            double result = 0.0;
            if (a2 <= 1.5) {
              double result = 1.5 - a2;
            }
          }
          break;
        case 1:
          double v5 = exp(a3 * a3 * -1.5);
          double result = (exp(fabs(a2 * a2) * -1.5) - v5) / (1.0 - v5);
          break;
        case 2:
          double result = 0.0;
          if (a2 < 2.0) {
            double result = (cos(a2 * 3.14159265 * 0.5) + 1.0) * 0.5;
          }
          break;
        case 3:
          double result = LiEdgeTexture::erfc_filter(a1, a2, a3);
          break;
        case 4:
          double result = 0.0;
          if (a2 < 2.0) {
            double result = sin(a2 * -0.96875 * 3.14159265 * 0.25) + 1.0;
          }
          break;
        case 5:
          double result = 0.0;
          if (a2 < 2.0)
          {
            float v6 = 2.0 - a2;
            double v7 = v6 * 0.96875 * 3.14159265 * 0.25;
            double result = sin(v7);
          }
          break;
        case 6:
          double result = OZShapeEdgeTexture::smoothStep(a1, a2, a3);
          break;
        default:
          exception = (PCIllegalArgumentException *)__cxa_allocate_exception(0x40uLL);
          PCIllegalArgumentException::PCIllegalArgumentException(exception);
      }
    }
  }
  return result;
}

void sub_1B7E1E160(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void OZShapeEdgeTexture::createHeliumBitmap(int a1@<W0>, LiEdgeTexture *a2@<X1>, uint64_t a3@<X2>, int32x4_t ***a4@<X8>, double a5@<D0>)
{
  if (a1) {
    uint64_t v10 = 28;
  }
  else {
    uint64_t v10 = 24;
  }
  uint64_t v11 = HGRectMake4i(0, 0, a3, a3);
  uint64_t v13 = v12;
  float64x2_t v14 = (int32x4_t **)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v14, v11, v13, v10);
  *a4 = v14;
  long long v15 = v14[10];
  if (a1) {
    evalBitmap<float>(v15, a5, a3, a2);
  }
  else {
    evalBitmap<unsigned char>(v15, a5, a3, a2);
  }
}

void sub_1B7E1E254(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void evalBitmap<float>(int32x4_t *a1, double a2, uint64_t a3, LiEdgeTexture *a4)
{
  float v6 = a1;
  v20[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1);
  PCString v9 = (char *)v20 - v8;
  uint64_t v10 = (v7 - 1);
  if (v7 >= 1)
  {
    double v11 = a2 / (double)(v7 - 3);
    uint64_t v12 = 8 * (v7 - 1);
    int v13 = v7 - 2;
    do
    {
      *(double *)&v9[v12] = OZShapeEdgeTexture::eval(a4, v11 * (double)v13, a2);
      v12 -= 8;
      --v13;
    }
    while (v12 != -8);
    int v14 = v10;
    do
    {
      int v15 = v14--;
      double v16 = OZShapeEdgeTexture::eval(a4, v11 * (double)v14, a2);
      uint64_t v17 = v10;
      do
      {
        double v18 = v16 * *(double *)&v9[8 * v17];
        *(float *)&double v18 = v18;
        *(float *)&double v18 = fminf(fmaxf(*(float *)&v18, 0.0), 1.0);
        *v6++ = vdupq_lane_s32(*(int32x2_t *)&v18, 0);
      }
      while (v17-- > 0);
    }
    while (v15 >= 1);
  }
}

void evalBitmap<unsigned char>(_DWORD *a1, double a2, uint64_t a3, LiEdgeTexture *a4)
{
  float v6 = a1;
  v21[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1);
  PCString v9 = (char *)v21 - v8;
  uint64_t v10 = (v7 - 1);
  if (v7 >= 1)
  {
    double v11 = a2 / (double)(v7 - 3);
    uint64_t v12 = 8 * (v7 - 1);
    int v13 = v7 - 2;
    do
    {
      *(double *)&v9[v12] = OZShapeEdgeTexture::eval(a4, v11 * (double)v13, a2);
      v12 -= 8;
      --v13;
    }
    while (v12 != -8);
    int v14 = v10;
    do
    {
      int v15 = v14--;
      double v16 = OZShapeEdgeTexture::eval(a4, v11 * (double)v14, a2);
      uint64_t v17 = v10;
      do
      {
        int v18 = vcvtmd_s64_f64(v16 * *(double *)&v9[8 * v17] * 255.0 + 0.5 + 0.0000001);
        int v19 = v18 & ~(v18 >> 31);
        if (v19 >= 255) {
          int v19 = 255;
        }
        *v6++ = 16843009 * v19;
      }
      while (v17-- > 0);
    }
    while (v15 >= 1);
  }
}

HGBitmapLoader *OZShapeEdgeTexture::createBitmapNode@<X0>(uint64_t *a1@<X0>, HGBitmapLoader **a2@<X8>)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (HGTexture *)HGObject::operator new(0x80uLL);
  HGTexture::HGTexture(v4, *(HGRect *)(v3 + 20), (HGBitmap *)v3);
  double v5 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  double result = HGBitmapLoader::HGBitmapLoader(v5, (HGBitmap *)v4);
  *a2 = v5;
  if (v4) {
    return (HGBitmapLoader *)(*(uint64_t (**)(HGTexture *))(*(void *)v4 + 24))(v4);
  }
  return result;
}

void sub_1B7E1E5F4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(a1);
}

int32x4_t **OZShapeEdgeTexture::createHeliumNode@<X0>(LiEdgeTexture *a1@<X1>, HGBitmapLoader **a2@<X8>)
{
  OZShapeEdgeTexture::createHeliumBitmap(1, a1, 64, &v4, 2.0);
  OZShapeEdgeTexture::createBitmapNode((uint64_t *)&v4, a2);
  double result = v4;
  if (v4) {
    return (int32x4_t **)((uint64_t (*)(int32x4_t **))(*v4)[1].i64[1])(v4);
  }
  return result;
}

void sub_1B7E1E6C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *HGArray<float,(HGFormat)7>::resize(uint64_t *result, int a2)
{
  uint64_t v3 = *result;
  if (*result)
  {
    if (*(_DWORD *)(v3 + 12) < a2) {
      double result = (uint64_t *)HGArrayData::allocate(*result, a2);
    }
    *(_DWORD *)(v3 + 8) = a2;
  }
  else if (a2 > 0)
  {
    HGArrayDataRef::allocate((HGArrayDataRef *)result);
  }
  return result;
}

void getOZShapeEdgeTextureLock(void)
{
  {
    PCMutex::PCMutex(&getOZShapeEdgeTextureLock(void)::sOZShapeEdgeTextureLock, 1);
    getOZShapeEdgeTextureLock(void)::sOZShapeEdgeTextureLock._vptr$PCMutex = (void **)&unk_1F10933F0;
    __cxa_atexit((void (*)(void *))PCRecursiveMutex::~PCRecursiveMutex, &getOZShapeEdgeTextureLock(void)::sOZShapeEdgeTextureLock, &dword_1B73F3000);
  }
}

void sub_1B7E1E828(_Unwind_Exception *a1)
{
}

uint64_t OZShapeEdgeTexture::getHeliumNode@<X0>(LiEdgeTexture *a1@<X1>, HGBitmapLoader **a2@<X8>)
{
  return PCMutex::unlock(&getOZShapeEdgeTextureLock(void)::sOZShapeEdgeTextureLock);
}

void sub_1B7E1E8A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

const void **PCCFRef<__CFArray const*>::~PCCFRef(const void **a1)
{
  long long v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void HGArray<float,(HGFormat)7>::HGArray(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 7;
  HGArrayDataRef::allocate((HGArrayDataRef *)a1);
}

void sub_1B7E1E92C(_Unwind_Exception *exception_object)
{
  if (*v1) {
    HGArrayData::Release(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OZShape::hitCheck(uint64_t a1, const CMTime *a2)
{
  if (OZChannelBase::isEnabled((OZChannelBase *)(a1 + 6800), 0, 1)) {
    OZChannel::getValueAsInt((OZChannel *)(a1 + 1328), a2, 0.0);
  }
  return 0;
}

unint64_t OZShape::getCurveSamplesForOSC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X8>)
{
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  uint64_t v10 = (PCMutex *)(a1 + 8);
  uint64_t v48 = a1 + 8;
  PCMutex::lock((PCMutex *)(a1 + 8));
  char v49 = 1;
  long long v11 = *(_OWORD *)(a3 + 80);
  v47[4] = *(_OWORD *)(a3 + 64);
  v47[5] = v11;
  long long v12 = *(_OWORD *)(a3 + 112);
  v47[6] = *(_OWORD *)(a3 + 96);
  v47[7] = v12;
  long long v13 = *(_OWORD *)(a3 + 16);
  v47[0] = *(_OWORD *)a3;
  v47[1] = v13;
  long long v14 = *(_OWORD *)(a3 + 48);
  v47[2] = *(_OWORD *)(a3 + 32);
  v47[3] = v14;
  long long v15 = *(_OWORD *)a2;
  long long v16 = *(_OWORD *)(a2 + 16);
  long long v17 = *(_OWORD *)(a2 + 64);
  v44[3] = *(_OWORD *)(a2 + 48);
  v44[4] = v17;
  long long v18 = *(_OWORD *)(a2 + 32);
  v44[1] = v16;
  _DWORD v44[2] = v18;
  v44[0] = v15;
  int v19 = *(CGColorSpace **)(a2 + 80);
  int v45 = v19;
  if (v19) {
    PCCFRefTraits<CGColorSpace *>::retain(v19);
  }
  int v46 = *(_DWORD *)(a2 + 88);
  uint64_t CurrentRenderParams = OZShape::getCurrentRenderParams(a1, (uint64_t)v44);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v45);
  (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)a1 + 64))(a1, a2, CurrentRenderParams, 0, 1);
  OSCuint64_t Contour = (void *)OZShape::getOSCContour(a1, a2, CurrentRenderParams, v47);
  long long v22 = OSCContour;
  uint64_t v23 = OSCContour[27];
  uint64_t v24 = OSCContour[28];
  if (v23 == v24 || OSCContour[30] == OSCContour[31] || OSCContour[24] == OSCContour[25]) {
    return PCMutex::unlock(v10);
  }
  unint64_t v25 = (unint64_t)(v24 - v23) >> 3;
  int v26 = *(_DWORD *)(CurrentRenderParams + 168) ? v25 + 1 : (unint64_t)(v24 - v23) >> 3;
  if (v26 < 1) {
    return PCMutex::unlock(v10);
  }
  unint64_t result = 0;
  for (int i = 0; i != v26; ++i)
  {
    double v39 = 0.0;
    double v40 = 0.0;
    long long v42 = 0u;
    long long v43 = 0u;
    double v29 = *(double *)(v22[27] + 8 * (i % (int)v25));
    double v30 = *(double *)(v22[30] + 8 * (i % (int)v25));
    double v31 = *(double *)(a3 + 120) + v29 * *(double *)(a3 + 96) + v30 * *(double *)(a3 + 104);
    double v32 = (*(double *)(a3 + 24) + v29 * *(double *)a3 + v30 * *(double *)(a3 + 8)) / v31;
    double v33 = (*(double *)(a3 + 56) + v29 * *(double *)(a3 + 32) + v30 * *(double *)(a3 + 40)) / v31;
    double v39 = v32;
    double v40 = v33;
    uint64_t v34 = *(void *)(v22[24] + 8 * (i % (int)v25));
    uint64_t v35 = *a4;
    uint64_t v36 = a4[1];
    uint64_t v37 = a4[2];
    uint64_t v38 = a4[3];
    uint64_t v41 = v34;
    *(void *)&long long v42 = v35;
    *((void *)&v42 + 1) = v36;
    *(void *)&long long v43 = v37;
    *((void *)&v43 + 1) = v38;
    if (result >= a5[2])
    {
      unint64_t result = std::vector<OZShapeOSCCurveSample>::__push_back_slow_path<OZShapeOSCCurveSample const&>(a5, (uint64_t)&v39);
    }
    else
    {
      *(double *)unint64_t result = v32;
      *(double *)(result + 8) = v33;
      *(void *)(result + 16) = v34;
      *(void *)(result + 24) = v35;
      *(void *)(result + 32) = v36;
      *(void *)(result + 40) = v37;
      *(void *)(result + 48) = v38;
      result += 56;
    }
    a5[1] = result;
  }
  if (v49) {
    return PCMutex::unlock(v10);
  }
  return result;
}

void sub_1B7E1EC08(_Unwind_Exception *a1)
{
  PCLockSentry<PCMutex>::~PCLockSentry(v2 - 96);
  uint64_t v4 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t std::vector<OZShapeOSCCurveSample>::__push_back_slow_path<OZShapeOSCCurveSample const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x492492492492492) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x249249249249249) {
    unint64_t v9 = 0x492492492492492;
  }
  else {
    unint64_t v9 = v5;
  }
  int v19 = a1 + 2;
  uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSParticleType::SourceBoundsCacheEntry>>(v7, v9);
  long long v11 = &v10[56 * v4];
  std::string __p = v10;
  long long v16 = v11;
  long long v18 = &v10[56 * v12];
  *(_OWORD *)long long v11 = *(_OWORD *)a2;
  *((_OWORD *)v11 + 1) = *(_OWORD *)(a2 + 16);
  *((_OWORD *)v11 + 2) = *(_OWORD *)(a2 + 32);
  *((void *)v11 + 6) = *(void *)(a2 + 48);
  long long v17 = v11 + 56;
  std::vector<OZShapeOSCCurveSample>::__swap_out_circular_buffer(a1, &__p);
  uint64_t v13 = a1[1];
  if (v17 != v16) {
    long long v17 = &v16[(v17 - v16 - 56) % 0x38uLL];
  }
  if (__p) {
    operator delete(__p);
  }
  return v13;
}

void sub_1B7E1ED94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::vector<OZShapeOSCCurveSample>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    long long v5 = *(_OWORD *)(v2 - 56);
    v2 -= 56;
    *(_OWORD *)(v4 - 56) = v5;
    v4 -= 56;
    *(_OWORD *)(v4 + 16) = *(_OWORD *)(v2 + 16);
    *(_OWORD *)(v4 + 32) = *(_OWORD *)(v2 + 32);
    *(void *)(v4 + 48) = *(void *)(v2 + 48);
  }
  a2[1] = v4;
  uint64_t v6 = *result;
  *unint64_t result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

BOOL OZShape::checkWindingOrder(OZShape *this, CMTime *a2, uint64_t a3, double *a4, int a5)
{
  uint64_t v10 = (void *)*((void *)this + 59);
  int v11 = *(_DWORD *)(a3 + 168);
  if (!v10)
  {
    if (v11) {
      goto LABEL_6;
    }
    return 0;
  }
  if (!v11) {
    return 0;
  }
  if (((int)((v10[1] - *v10) >> 3) / 2) > 2) {
    goto LABEL_7;
  }
LABEL_6:
  if (!OZShape::isGeometricShape(this)) {
    return 0;
  }
LABEL_7:
  double v12 = OZShape::calculatePolygonArea((uint64_t)this, a2, a3, a4);
  BOOL v13 = v12 > 0.0;
  if (v12 > 0.0 && a5)
  {
    OZChannelCurve::reverseWindingOrder((OZShape *)((char *)this + 208));
    BOOL v13 = 1;
    (*(void (**)(OZShape *, uint64_t, uint64_t))(*(void *)this + 144))(this, 1, 1);
  }
  return v13;
}

double OZShape::calculatePolygonArea(uint64_t a1, CMTime *a2, uint64_t a3, double *a4)
{
  double v445 = 0.0;
  v446[0] = 0.0;
  double v443 = 0.0;
  double v444 = 0.0;
  v440 = 0;
  uint64_t v441 = 0;
  uint64_t v442 = 0;
  std::string __p = 0;
  unint64_t v438 = 0;
  v439 = 0;
  unint64_t v434 = 0;
  v435 = 0;
  uint64_t v436 = 0;
  uint64_t v7 = (OZChannel *)(a1 + 1072);
  float64x2_t v432 = 0u;
  long long v433 = 0u;
  if (OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E4F1FA48], 0.0) == 4)
  {
    std::vector<double>::reserve((void **)&v440, 5uLL);
    std::vector<double>::reserve(&__p, 5uLL);
    std::vector<double>::reserve(&v434, 5uLL);
    double v8 = -*(double *)(a3 + 200);
    v432.f64[0] = v8;
    v432.f64[1] = 0.0;
    *(void *)&long long v433 = 0;
    *((void *)&v433 + 1) = 0x3FF0000000000000;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      double v9 = *((double *)&v433 + 1);
      double v8 = v432.f64[0];
    }
    else
    {
      double v9 = 1.0;
    }
    int v121 = v441;
    if (v441 >= (double *)v442)
    {
      long long v123 = v440;
      uint64_t v124 = v441 - v440;
      unint64_t v125 = v124 + 1;
      if ((unint64_t)(v124 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v126 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v125) {
        unint64_t v125 = v126 >> 2;
      }
      if ((unint64_t)v126 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v127 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v127 = v125;
      }
      if (v127)
      {
        long long v128 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v127);
        long long v123 = v440;
        int v121 = v441;
      }
      else
      {
        long long v128 = 0;
      }
      unint64_t v137 = (double *)&v128[8 * v124];
      unint64_t v138 = &v128[8 * v127];
      double *v137 = v8;
      uint64_t v122 = v137 + 1;
      while (v121 != v123)
      {
        uint64_t v139 = *((void *)v121-- - 1);
        *((void *)v137-- - 1) = v139;
      }
      v440 = v137;
      uint64_t v441 = v122;
      uint64_t v442 = v138;
      if (v123) {
        operator delete(v123);
      }
    }
    else
    {
      *uint64_t v441 = v8;
      uint64_t v122 = v121 + 1;
    }
    uint64_t v441 = v122;
    float64_t v140 = v432.f64[1];
    BOOL v141 = v438;
    if (v438 >= v439)
    {
      unint64_t v143 = (char *)__p;
      uint64_t v144 = (v438 - (unsigned char *)__p) >> 3;
      unint64_t v145 = v144 + 1;
      if ((unint64_t)(v144 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v146 = v439 - (unsigned char *)__p;
      if ((v439 - (unsigned char *)__p) >> 2 > v145) {
        unint64_t v145 = v146 >> 2;
      }
      if ((unint64_t)v146 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v147 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v147 = v145;
      }
      if (v147)
      {
        unint64_t v148 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v147);
        unint64_t v143 = (char *)__p;
        BOOL v141 = v438;
      }
      else
      {
        unint64_t v148 = 0;
      }
      uint64_t v149 = &v148[8 * v144];
      long long v150 = &v148[8 * v147];
      *(float64_t *)uint64_t v149 = v140;
      uint64_t v142 = v149 + 8;
      while (v141 != v143)
      {
        uint64_t v151 = *((void *)v141 - 1);
        v141 -= 8;
        *((void *)v149 - 1) = v151;
        v149 -= 8;
      }
      std::string __p = v149;
      unint64_t v438 = v142;
      v439 = v150;
      if (v143) {
        operator delete(v143);
      }
    }
    else
    {
      *(float64_t *)unint64_t v438 = v432.f64[1];
      uint64_t v142 = v141 + 8;
    }
    unint64_t v438 = v142;
    uint64_t v152 = *((void *)&v433 + 1);
    int v153 = v435;
    if (v435 >= (double *)v436)
    {
      unint64_t v155 = (double *)v434;
      uint64_t v156 = ((char *)v435 - (unsigned char *)v434) >> 3;
      unint64_t v157 = v156 + 1;
      if ((unint64_t)(v156 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v158 = v436 - (unsigned char *)v434;
      if ((v436 - (unsigned char *)v434) >> 2 > v157) {
        unint64_t v157 = v158 >> 2;
      }
      if ((unint64_t)v158 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v159 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v159 = v157;
      }
      if (v159)
      {
        float64_t v160 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v159);
        unint64_t v155 = (double *)v434;
        int v153 = v435;
      }
      else
      {
        float64_t v160 = 0;
      }
      long long v161 = &v160[8 * v156];
      float64x2_t v162 = &v160[8 * v159];
      *(void *)long long v161 = v152;
      uint64_t v154 = (double *)(v161 + 8);
      while (v153 != v155)
      {
        uint64_t v163 = *((void *)v153-- - 1);
        *((void *)v161 - 1) = v163;
        v161 -= 8;
      }
      unint64_t v434 = v161;
      v435 = v154;
      uint64_t v436 = v162;
      if (v155) {
        operator delete(v155);
      }
    }
    else
    {
      double *v435 = *((double *)&v433 + 1);
      uint64_t v154 = v153 + 1;
    }
    v435 = v154;
    float64_t v164 = *(double *)(a3 + 208);
    v432.f64[0] = 0.0;
    v432.f64[1] = v164;
    long long v433 = xmmword_1B7E733E0;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      double v165 = *((double *)&v433 + 1);
      float64_t v166 = v432.f64[0];
    }
    else
    {
      double v165 = 1.0;
      float64_t v166 = 0.0;
    }
    BOOL v167 = v165 > 0.0 && v9 > 0.0;
    unint64_t v168 = v441;
    if (v441 >= (double *)v442)
    {
      float64_t v170 = v440;
      uint64_t v171 = v441 - v440;
      unint64_t v172 = v171 + 1;
      if ((unint64_t)(v171 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v173 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v172) {
        unint64_t v172 = v173 >> 2;
      }
      if ((unint64_t)v173 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v174 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v174 = v172;
      }
      if (v174)
      {
        __double2 v175 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v174);
        float64_t v170 = v440;
        unint64_t v168 = v441;
      }
      else
      {
        __double2 v175 = 0;
      }
      long long v176 = (double *)&v175[8 * v171];
      uint64_t v177 = &v175[8 * v174];
      double *v176 = v166;
      signed int v169 = v176 + 1;
      while (v168 != v170)
      {
        uint64_t v178 = *((void *)v168-- - 1);
        *((void *)v176-- - 1) = v178;
      }
      v440 = v176;
      uint64_t v441 = v169;
      uint64_t v442 = v177;
      if (v170) {
        operator delete(v170);
      }
    }
    else
    {
      *uint64_t v441 = v166;
      signed int v169 = v168 + 1;
    }
    uint64_t v441 = v169;
    float64_t v179 = v432.f64[1];
    int v180 = v438;
    if (v438 >= v439)
    {
      float64x2_t v182 = (char *)__p;
      uint64_t v183 = (v438 - (unsigned char *)__p) >> 3;
      unint64_t v184 = v183 + 1;
      if ((unint64_t)(v183 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v185 = v439 - (unsigned char *)__p;
      if ((v439 - (unsigned char *)__p) >> 2 > v184) {
        unint64_t v184 = v185 >> 2;
      }
      if ((unint64_t)v185 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v186 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v186 = v184;
      }
      if (v186)
      {
        double v187 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v186);
        float64x2_t v182 = (char *)__p;
        int v180 = v438;
      }
      else
      {
        double v187 = 0;
      }
      long long v188 = &v187[8 * v183];
      long long v189 = &v187[8 * v186];
      *(float64_t *)long long v188 = v179;
      int v181 = v188 + 8;
      while (v180 != v182)
      {
        uint64_t v190 = *((void *)v180 - 1);
        v180 -= 8;
        *((void *)v188 - 1) = v190;
        v188 -= 8;
      }
      std::string __p = v188;
      unint64_t v438 = v181;
      v439 = v189;
      if (v182) {
        operator delete(v182);
      }
    }
    else
    {
      *(float64_t *)unint64_t v438 = v432.f64[1];
      int v181 = v180 + 8;
    }
    unint64_t v438 = v181;
    uint64_t v191 = *((void *)&v433 + 1);
    float64x2_t v192 = v435;
    if (v435 >= (double *)v436)
    {
      unint64_t v194 = (double *)v434;
      uint64_t v195 = ((char *)v435 - (unsigned char *)v434) >> 3;
      unint64_t v196 = v195 + 1;
      if ((unint64_t)(v195 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v197 = v436 - (unsigned char *)v434;
      if ((v436 - (unsigned char *)v434) >> 2 > v196) {
        unint64_t v196 = v197 >> 2;
      }
      if ((unint64_t)v197 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v198 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v198 = v196;
      }
      if (v198)
      {
        long long v199 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v198);
        unint64_t v194 = (double *)v434;
        float64x2_t v192 = v435;
      }
      else
      {
        long long v199 = 0;
      }
      uint64_t v200 = &v199[8 * v195];
      unint64_t v201 = &v199[8 * v198];
      *(void *)uint64_t v200 = v191;
      unint64_t v193 = (double *)(v200 + 8);
      while (v192 != v194)
      {
        uint64_t v202 = *((void *)v192-- - 1);
        *((void *)v200 - 1) = v202;
        v200 -= 8;
      }
      unint64_t v434 = v200;
      v435 = v193;
      uint64_t v436 = v201;
      if (v194) {
        operator delete(v194);
      }
    }
    else
    {
      double *v435 = *((double *)&v433 + 1);
      unint64_t v193 = v192 + 1;
    }
    v435 = v193;
    float64x2_t v432 = (float64x2_t)*(unint64_t *)(a3 + 200);
    *(void *)&long long v433 = 0;
    *((void *)&v433 + 1) = 0x3FF0000000000000;
    if (a4) {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
    }
    if (v167) {
      BOOL v167 = *((double *)&v433 + 1) > 0.0;
    }
    float64_t v203 = v432.f64[0];
    unint64_t v204 = v441;
    if (v441 >= (double *)v442)
    {
      long long v206 = v440;
      uint64_t v207 = v441 - v440;
      unint64_t v208 = v207 + 1;
      if ((unint64_t)(v207 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v209 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v208) {
        unint64_t v208 = v209 >> 2;
      }
      if ((unint64_t)v209 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v210 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v210 = v208;
      }
      if (v210)
      {
        uint64_t v211 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v210);
        long long v206 = v440;
        unint64_t v204 = v441;
      }
      else
      {
        uint64_t v211 = 0;
      }
      uint64_t v212 = (double *)&v211[8 * v207];
      unint64_t v213 = &v211[8 * v210];
      double *v212 = v203;
      unint64_t v205 = v212 + 1;
      while (v204 != v206)
      {
        uint64_t v214 = *((void *)v204-- - 1);
        *((void *)v212-- - 1) = v214;
      }
      v440 = v212;
      uint64_t v441 = v205;
      uint64_t v442 = v213;
      if (v206) {
        operator delete(v206);
      }
    }
    else
    {
      *uint64_t v441 = v432.f64[0];
      unint64_t v205 = v204 + 1;
    }
    uint64_t v441 = v205;
    float64_t v215 = v432.f64[1];
    float64x2_t v216 = v438;
    if (v438 >= v439)
    {
      float64x2_t v218 = (char *)__p;
      uint64_t v219 = (v438 - (unsigned char *)__p) >> 3;
      unint64_t v220 = v219 + 1;
      if ((unint64_t)(v219 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v221 = v439 - (unsigned char *)__p;
      if ((v439 - (unsigned char *)__p) >> 2 > v220) {
        unint64_t v220 = v221 >> 2;
      }
      if ((unint64_t)v221 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v222 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v222 = v220;
      }
      if (v222)
      {
        unint64_t v223 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v222);
        float64x2_t v218 = (char *)__p;
        float64x2_t v216 = v438;
      }
      else
      {
        unint64_t v223 = 0;
      }
      unint64_t v224 = &v223[8 * v219];
      double v225 = &v223[8 * v222];
      *(float64_t *)unint64_t v224 = v215;
      float64x2_t v217 = v224 + 8;
      while (v216 != v218)
      {
        uint64_t v226 = *((void *)v216 - 1);
        v216 -= 8;
        *((void *)v224 - 1) = v226;
        v224 -= 8;
      }
      std::string __p = v224;
      unint64_t v438 = v217;
      v439 = v225;
      if (v218) {
        operator delete(v218);
      }
    }
    else
    {
      *(float64_t *)unint64_t v438 = v432.f64[1];
      float64x2_t v217 = v216 + 8;
    }
    unint64_t v438 = v217;
    uint64_t v227 = *((void *)&v433 + 1);
    uint64_t v228 = v435;
    if (v435 >= (double *)v436)
    {
      unint64_t v230 = (double *)v434;
      uint64_t v231 = ((char *)v435 - (unsigned char *)v434) >> 3;
      unint64_t v232 = v231 + 1;
      if ((unint64_t)(v231 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v233 = v436 - (unsigned char *)v434;
      if ((v436 - (unsigned char *)v434) >> 2 > v232) {
        unint64_t v232 = v233 >> 2;
      }
      if ((unint64_t)v233 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v234 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v234 = v232;
      }
      if (v234)
      {
        uint64_t v235 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v234);
        unint64_t v230 = (double *)v434;
        uint64_t v228 = v435;
      }
      else
      {
        uint64_t v235 = 0;
      }
      unint64_t v236 = &v235[8 * v231];
      unint64_t v237 = &v235[8 * v234];
      *(void *)unint64_t v236 = v227;
      PCSharedCount v229 = (double *)(v236 + 8);
      while (v228 != v230)
      {
        uint64_t v238 = *((void *)v228-- - 1);
        *((void *)v236 - 1) = v238;
        v236 -= 8;
      }
      unint64_t v434 = v236;
      v435 = v229;
      uint64_t v436 = v237;
      if (v230) {
        operator delete(v230);
      }
    }
    else
    {
      double *v435 = *((double *)&v433 + 1);
      PCSharedCount v229 = v228 + 1;
    }
    v435 = v229;
    double v239 = -*(double *)(a3 + 208);
    v432.f64[0] = 0.0;
    v432.f64[1] = v239;
    long long v433 = xmmword_1B7E733E0;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      double v240 = *((double *)&v433 + 1);
      float64_t v241 = v432.f64[0];
    }
    else
    {
      double v240 = 1.0;
      float64_t v241 = 0.0;
    }
    int v17 = v240 > 0.0 && v167;
    unsigned int v242 = v441;
    if (v441 >= (double *)v442)
    {
      unint64_t v244 = v440;
      uint64_t v245 = v441 - v440;
      unint64_t v246 = v245 + 1;
      if ((unint64_t)(v245 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v247 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v246) {
        unint64_t v246 = v247 >> 2;
      }
      if ((unint64_t)v247 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v248 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v248 = v246;
      }
      if (v248)
      {
        double v249 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v248);
        unint64_t v244 = v440;
        unsigned int v242 = v441;
      }
      else
      {
        double v249 = 0;
      }
      float64x2_t v250 = (double *)&v249[8 * v245];
      uint64_t v251 = &v249[8 * v248];
      *float64x2_t v250 = v241;
      uint64_t v243 = v250 + 1;
      while (v242 != v244)
      {
        uint64_t v252 = *((void *)v242-- - 1);
        *((void *)v250-- - 1) = v252;
      }
      v440 = v250;
      uint64_t v441 = v243;
      uint64_t v442 = v251;
      if (v244) {
        operator delete(v244);
      }
    }
    else
    {
      *uint64_t v441 = v241;
      uint64_t v243 = v242 + 1;
    }
    uint64_t v441 = v243;
    float64_t v253 = v432.f64[1];
    unint64_t v254 = v438;
    if (v438 >= v439)
    {
      BOOL v256 = (char *)__p;
      uint64_t v257 = (v438 - (unsigned char *)__p) >> 3;
      unint64_t v258 = v257 + 1;
      if ((unint64_t)(v257 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v259 = v439 - (unsigned char *)__p;
      if ((v439 - (unsigned char *)__p) >> 2 > v258) {
        unint64_t v258 = v259 >> 2;
      }
      if ((unint64_t)v259 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v260 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v260 = v258;
      }
      if (v260)
      {
        uint64_t v261 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v260);
        BOOL v256 = (char *)__p;
        unint64_t v254 = v438;
      }
      else
      {
        uint64_t v261 = 0;
      }
      BOOL v262 = &v261[8 * v257];
      uint64_t v263 = &v261[8 * v260];
      *(float64_t *)BOOL v262 = v253;
      unint64_t v255 = v262 + 8;
      while (v254 != v256)
      {
        uint64_t v264 = *((void *)v254 - 1);
        v254 -= 8;
        *((void *)v262 - 1) = v264;
        v262 -= 8;
      }
      std::string __p = v262;
      unint64_t v438 = v255;
      v439 = v263;
      if (v256) {
        operator delete(v256);
      }
    }
    else
    {
      *(float64_t *)unint64_t v438 = v432.f64[1];
      unint64_t v255 = v254 + 8;
    }
    unint64_t v438 = v255;
    uint64_t v265 = *((void *)&v433 + 1);
    uint64_t v266 = (char *)v435;
    if (v435 >= (double *)v436)
    {
      long long v14 = (char *)v434;
      uint64_t v267 = ((char *)v435 - (unsigned char *)v434) >> 3;
      unint64_t v268 = v267 + 1;
      if ((unint64_t)(v267 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v269 = v436 - (unsigned char *)v434;
      if ((v436 - (unsigned char *)v434) >> 2 > v268) {
        unint64_t v268 = v269 >> 2;
      }
      if ((unint64_t)v269 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v270 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v270 = v268;
      }
      if (v270)
      {
        uint64_t v271 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v270);
        long long v14 = (char *)v434;
        uint64_t v266 = (char *)v435;
      }
      else
      {
        uint64_t v271 = 0;
      }
      unint64_t v272 = &v271[8 * v267];
      unint64_t v273 = &v271[8 * v270];
      *(void *)unint64_t v272 = v265;
      double v274 = (double *)(v272 + 8);
      while (v266 != v14)
      {
        uint64_t v275 = *((void *)v266 - 1);
        v266 -= 8;
        *((void *)v272 - 1) = v275;
        v272 -= 8;
      }
      goto LABEL_589;
    }
    goto LABEL_576;
  }
  if (OZChannel::getValueAsInt(v7, MEMORY[0x1E4F1FA48], 0.0) == 5)
  {
    std::vector<double>::reserve((void **)&v440, 5uLL);
    std::vector<double>::reserve(&__p, 5uLL);
    std::vector<double>::reserve(&v434, 5uLL);
    float64x2_t v10 = vmulq_f64(*(float64x2_t *)(a3 + 200), (float64x2_t)xmmword_1B83832C0);
    float64x2_t v432 = v10;
    long long v433 = xmmword_1B7E733E0;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      double v11 = *((double *)&v433 + 1);
      float64_t v426 = v432.f64[0];
    }
    else
    {
      float64_t v426 = v10.f64[0];
      double v11 = 1.0;
    }
    uint64_t v129 = v441;
    if (v441 >= (double *)v442)
    {
      uint64_t v131 = v440;
      uint64_t v132 = v441 - v440;
      unint64_t v133 = v132 + 1;
      if ((unint64_t)(v132 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v134 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v133) {
        unint64_t v133 = v134 >> 2;
      }
      if ((unint64_t)v134 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v135 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v135 = v133;
      }
      if (v135)
      {
        uint64_t v136 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v135);
        uint64_t v131 = v440;
        uint64_t v129 = v441;
      }
      else
      {
        uint64_t v136 = 0;
      }
      double v276 = (double *)&v136[8 * v132];
      double v277 = &v136[8 * v135];
      double *v276 = v426;
      int v130 = v276 + 1;
      while (v129 != v131)
      {
        uint64_t v278 = *((void *)v129-- - 1);
        *((void *)v276-- - 1) = v278;
      }
      v440 = v276;
      uint64_t v441 = v130;
      uint64_t v442 = v277;
      if (v131) {
        operator delete(v131);
      }
    }
    else
    {
      *uint64_t v441 = v426;
      int v130 = v129 + 1;
    }
    uint64_t v441 = v130;
    float64_t v279 = v432.f64[1];
    double v280 = v438;
    if (v438 >= v439)
    {
      unint64_t v282 = (char *)__p;
      uint64_t v283 = (v438 - (unsigned char *)__p) >> 3;
      unint64_t v284 = v283 + 1;
      if ((unint64_t)(v283 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v285 = v439 - (unsigned char *)__p;
      if ((v439 - (unsigned char *)__p) >> 2 > v284) {
        unint64_t v284 = v285 >> 2;
      }
      if ((unint64_t)v285 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v286 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v286 = v284;
      }
      if (v286)
      {
        CMTimeEpoch v287 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v286);
        unint64_t v282 = (char *)__p;
        double v280 = v438;
      }
      else
      {
        CMTimeEpoch v287 = 0;
      }
      uint64_t v288 = &v287[8 * v283];
      uint64_t v289 = &v287[8 * v286];
      *(float64_t *)uint64_t v288 = v279;
      uint64_t v281 = v288 + 8;
      while (v280 != v282)
      {
        uint64_t v290 = *((void *)v280 - 1);
        v280 -= 8;
        *((void *)v288 - 1) = v290;
        v288 -= 8;
      }
      std::string __p = v288;
      unint64_t v438 = v281;
      v439 = v289;
      if (v282) {
        operator delete(v282);
      }
    }
    else
    {
      *(float64_t *)unint64_t v438 = v432.f64[1];
      uint64_t v281 = v280 + 8;
    }
    unint64_t v438 = v281;
    uint64_t v291 = *((void *)&v433 + 1);
    unint64_t v292 = v435;
    if (v435 >= (double *)v436)
    {
      uint64_t v294 = (double *)v434;
      uint64_t v295 = ((char *)v435 - (unsigned char *)v434) >> 3;
      unint64_t v296 = v295 + 1;
      if ((unint64_t)(v295 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v297 = v436 - (unsigned char *)v434;
      if ((v436 - (unsigned char *)v434) >> 2 > v296) {
        unint64_t v296 = v297 >> 2;
      }
      if ((unint64_t)v297 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v298 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v298 = v296;
      }
      if (v298)
      {
        long long v299 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v298);
        uint64_t v294 = (double *)v434;
        unint64_t v292 = v435;
      }
      else
      {
        long long v299 = 0;
      }
      unsigned int v300 = &v299[8 * v295];
      unint64_t v301 = &v299[8 * v298];
      *(void *)unsigned int v300 = v291;
      unint64_t v293 = (double *)(v300 + 8);
      while (v292 != v294)
      {
        uint64_t v302 = *((void *)v292-- - 1);
        *((void *)v300 - 1) = v302;
        v300 -= 8;
      }
      unint64_t v434 = v300;
      v435 = v293;
      uint64_t v436 = v301;
      if (v294) {
        operator delete(v294);
      }
    }
    else
    {
      double *v435 = *((double *)&v433 + 1);
      unint64_t v293 = v292 + 1;
    }
    v435 = v293;
    __asm { FMOV            V1.2D, #0.5 }
    float64x2_t v307 = vmulq_f64(*(float64x2_t *)(a3 + 200), _Q1);
    float64x2_t v432 = v307;
    long long v433 = xmmword_1B7E733E0;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      double v308 = *((double *)&v433 + 1);
      float64_t v427 = v432.f64[0];
    }
    else
    {
      float64_t v427 = v307.f64[0];
      double v308 = 1.0;
    }
    BOOL v309 = v308 > 0.0 && v11 > 0.0;
    double v310 = v441;
    if (v441 >= (double *)v442)
    {
      unint64_t v312 = v440;
      uint64_t v313 = v441 - v440;
      unint64_t v314 = v313 + 1;
      if ((unint64_t)(v313 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v315 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v314) {
        unint64_t v314 = v315 >> 2;
      }
      if ((unint64_t)v315 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v316 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v316 = v314;
      }
      if (v316)
      {
        unint64_t v317 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v316);
        unint64_t v312 = v440;
        double v310 = v441;
      }
      else
      {
        unint64_t v317 = 0;
      }
      double v318 = (double *)&v317[8 * v313];
      uint64_t v319 = &v317[8 * v316];
      *double v318 = v427;
      uint64_t v311 = v318 + 1;
      while (v310 != v312)
      {
        uint64_t v320 = *((void *)v310-- - 1);
        *((void *)v318-- - 1) = v320;
      }
      v440 = v318;
      uint64_t v441 = v311;
      uint64_t v442 = v319;
      if (v312) {
        operator delete(v312);
      }
    }
    else
    {
      *uint64_t v441 = v427;
      uint64_t v311 = v310 + 1;
    }
    uint64_t v441 = v311;
    float64_t v321 = v432.f64[1];
    double v322 = v438;
    if (v438 >= v439)
    {
      unint64_t v324 = (char *)__p;
      uint64_t v325 = (v438 - (unsigned char *)__p) >> 3;
      unint64_t v326 = v325 + 1;
      if ((unint64_t)(v325 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v327 = v439 - (unsigned char *)__p;
      if ((v439 - (unsigned char *)__p) >> 2 > v326) {
        unint64_t v326 = v327 >> 2;
      }
      if ((unint64_t)v327 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v328 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v328 = v326;
      }
      if (v328)
      {
        unint64_t v329 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v328);
        unint64_t v324 = (char *)__p;
        double v322 = v438;
      }
      else
      {
        unint64_t v329 = 0;
      }
      CMTime v330 = &v329[8 * v325];
      uint64_t v331 = &v329[8 * v328];
      *(float64_t *)CMTime v330 = v321;
      uint64_t v323 = v330 + 8;
      while (v322 != v324)
      {
        uint64_t v332 = *((void *)v322 - 1);
        v322 -= 8;
        *((void *)v330 - 1) = v332;
        v330 -= 8;
      }
      std::string __p = v330;
      unint64_t v438 = v323;
      v439 = v331;
      if (v324) {
        operator delete(v324);
      }
    }
    else
    {
      *(float64_t *)unint64_t v438 = v432.f64[1];
      uint64_t v323 = v322 + 8;
    }
    unint64_t v438 = v323;
    uint64_t v333 = *((void *)&v433 + 1);
    v334 = v435;
    if (v435 >= (double *)v436)
    {
      unint64_t v336 = (double *)v434;
      uint64_t v337 = ((char *)v435 - (unsigned char *)v434) >> 3;
      unint64_t v338 = v337 + 1;
      if ((unint64_t)(v337 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v339 = v436 - (unsigned char *)v434;
      if ((v436 - (unsigned char *)v434) >> 2 > v338) {
        unint64_t v338 = v339 >> 2;
      }
      if ((unint64_t)v339 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v340 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v340 = v338;
      }
      if (v340)
      {
        unint64_t v341 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v340);
        unint64_t v336 = (double *)v434;
        v334 = v435;
      }
      else
      {
        unint64_t v341 = 0;
      }
      unint64_t v342 = &v341[8 * v337];
      v343 = &v341[8 * v340];
      *(void *)unint64_t v342 = v333;
      uint64_t v335 = (double *)(v342 + 8);
      while (v334 != v336)
      {
        uint64_t v344 = *((void *)v334-- - 1);
        *((void *)v342 - 1) = v344;
        v342 -= 8;
      }
      unint64_t v434 = v342;
      v435 = v335;
      uint64_t v436 = v343;
      if (v336) {
        operator delete(v336);
      }
    }
    else
    {
      double *v435 = *((double *)&v433 + 1);
      uint64_t v335 = v334 + 1;
    }
    v435 = v335;
    float64x2_t v432 = vmulq_f64(*(float64x2_t *)(a3 + 200), (float64x2_t)xmmword_1B8387E30);
    long long v433 = xmmword_1B7E733E0;
    if (a4) {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
    }
    if (v309) {
      BOOL v309 = *((double *)&v433 + 1) > 0.0;
    }
    float64_t v345 = v432.f64[0];
    v346 = v441;
    if (v441 >= (double *)v442)
    {
      uint64_t v348 = v440;
      uint64_t v349 = v441 - v440;
      unint64_t v350 = v349 + 1;
      if ((unint64_t)(v349 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v351 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v350) {
        unint64_t v350 = v351 >> 2;
      }
      if ((unint64_t)v351 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v352 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v352 = v350;
      }
      if (v352)
      {
        unint64_t v353 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v352);
        uint64_t v348 = v440;
        v346 = v441;
      }
      else
      {
        unint64_t v353 = 0;
      }
      v354 = (double *)&v353[8 * v349];
      v355 = &v353[8 * v352];
      double *v354 = v345;
      uint64_t v347 = v354 + 1;
      while (v346 != v348)
      {
        uint64_t v356 = *((void *)v346-- - 1);
        *((void *)v354-- - 1) = v356;
      }
      v440 = v354;
      uint64_t v441 = v347;
      uint64_t v442 = v355;
      if (v348) {
        operator delete(v348);
      }
    }
    else
    {
      *uint64_t v441 = v432.f64[0];
      uint64_t v347 = v346 + 1;
    }
    uint64_t v441 = v347;
    float64_t v357 = v432.f64[1];
    unint64_t v358 = v438;
    if (v438 >= v439)
    {
      v360 = (char *)__p;
      uint64_t v361 = (v438 - (unsigned char *)__p) >> 3;
      unint64_t v362 = v361 + 1;
      if ((unint64_t)(v361 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v363 = v439 - (unsigned char *)__p;
      if ((v439 - (unsigned char *)__p) >> 2 > v362) {
        unint64_t v362 = v363 >> 2;
      }
      if ((unint64_t)v363 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v364 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v364 = v362;
      }
      if (v364)
      {
        uint64_t v365 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v364);
        v360 = (char *)__p;
        unint64_t v358 = v438;
      }
      else
      {
        uint64_t v365 = 0;
      }
      v366 = &v365[8 * v361];
      uint64_t v367 = &v365[8 * v364];
      *(float64_t *)v366 = v357;
      unint64_t v359 = v366 + 8;
      while (v358 != v360)
      {
        uint64_t v368 = *((void *)v358 - 1);
        v358 -= 8;
        *((void *)v366 - 1) = v368;
        v366 -= 8;
      }
      std::string __p = v366;
      unint64_t v438 = v359;
      v439 = v367;
      if (v360) {
        operator delete(v360);
      }
    }
    else
    {
      *(float64_t *)unint64_t v438 = v432.f64[1];
      unint64_t v359 = v358 + 8;
    }
    unint64_t v438 = v359;
    uint64_t v369 = *((void *)&v433 + 1);
    unint64_t v370 = v435;
    if (v435 >= (double *)v436)
    {
      unint64_t v372 = (double *)v434;
      uint64_t v373 = ((char *)v435 - (unsigned char *)v434) >> 3;
      unint64_t v374 = v373 + 1;
      if ((unint64_t)(v373 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v375 = v436 - (unsigned char *)v434;
      if ((v436 - (unsigned char *)v434) >> 2 > v374) {
        unint64_t v374 = v375 >> 2;
      }
      if ((unint64_t)v375 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v376 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v376 = v374;
      }
      if (v376)
      {
        v377 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v376);
        unint64_t v372 = (double *)v434;
        unint64_t v370 = v435;
      }
      else
      {
        v377 = 0;
      }
      uint64_t v378 = &v377[8 * v373];
      unint64_t v379 = &v377[8 * v376];
      *(void *)uint64_t v378 = v369;
      uint64_t v371 = (double *)(v378 + 8);
      while (v370 != v372)
      {
        uint64_t v380 = *((void *)v370-- - 1);
        *((void *)v378 - 1) = v380;
        v378 -= 8;
      }
      unint64_t v434 = v378;
      v435 = v371;
      uint64_t v436 = v379;
      if (v372) {
        operator delete(v372);
      }
    }
    else
    {
      double *v435 = *((double *)&v433 + 1);
      uint64_t v371 = v370 + 1;
    }
    v435 = v371;
    __asm { FMOV            V1.2D, #-0.5 }
    float64x2_t v382 = vmulq_f64(*(float64x2_t *)(a3 + 200), _Q1);
    float64x2_t v432 = v382;
    long long v433 = xmmword_1B7E733E0;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      double v383 = *((double *)&v433 + 1);
      float64_t v429 = v432.f64[0];
    }
    else
    {
      float64_t v429 = v382.f64[0];
      double v383 = 1.0;
    }
    int v17 = v383 > 0.0 && v309;
    v384 = v441;
    if (v441 >= (double *)v442)
    {
      uint64_t v386 = v440;
      uint64_t v387 = v441 - v440;
      unint64_t v388 = v387 + 1;
      if ((unint64_t)(v387 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v389 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v388) {
        unint64_t v388 = v389 >> 2;
      }
      if ((unint64_t)v389 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v390 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v390 = v388;
      }
      if (v390)
      {
        v391 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v390);
        uint64_t v386 = v440;
        v384 = v441;
      }
      else
      {
        v391 = 0;
      }
      uint64_t v392 = (double *)&v391[8 * v387];
      v393 = &v391[8 * v390];
      *uint64_t v392 = v429;
      v385 = v392 + 1;
      while (v384 != v386)
      {
        uint64_t v394 = *((void *)v384-- - 1);
        *((void *)v392-- - 1) = v394;
      }
      v440 = v392;
      uint64_t v441 = v385;
      uint64_t v442 = v393;
      if (v386) {
        operator delete(v386);
      }
    }
    else
    {
      *uint64_t v441 = v429;
      v385 = v384 + 1;
    }
    uint64_t v441 = v385;
    float64_t v395 = v432.f64[1];
    v396 = v438;
    if (v438 >= v439)
    {
      uint64_t v398 = (char *)__p;
      uint64_t v399 = (v438 - (unsigned char *)__p) >> 3;
      unint64_t v400 = v399 + 1;
      if ((unint64_t)(v399 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v401 = v439 - (unsigned char *)__p;
      if ((v439 - (unsigned char *)__p) >> 2 > v400) {
        unint64_t v400 = v401 >> 2;
      }
      if ((unint64_t)v401 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v402 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v402 = v400;
      }
      if (v402)
      {
        uint64_t v403 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v402);
        uint64_t v398 = (char *)__p;
        v396 = v438;
      }
      else
      {
        uint64_t v403 = 0;
      }
      v404 = &v403[8 * v399];
      uint64_t v405 = &v403[8 * v402];
      *(float64_t *)v404 = v395;
      uint64_t v397 = v404 + 8;
      while (v396 != v398)
      {
        uint64_t v406 = *((void *)v396 - 1);
        v396 -= 8;
        *((void *)v404 - 1) = v406;
        v404 -= 8;
      }
      std::string __p = v404;
      unint64_t v438 = v397;
      v439 = v405;
      if (v398) {
        operator delete(v398);
      }
    }
    else
    {
      *(float64_t *)unint64_t v438 = v432.f64[1];
      uint64_t v397 = v396 + 8;
    }
    unint64_t v438 = v397;
    uint64_t v265 = *((void *)&v433 + 1);
    uint64_t v266 = (char *)v435;
    if (v435 >= (double *)v436)
    {
      long long v14 = (char *)v434;
      uint64_t v407 = ((char *)v435 - (unsigned char *)v434) >> 3;
      unint64_t v408 = v407 + 1;
      if ((unint64_t)(v407 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v409 = v436 - (unsigned char *)v434;
      if ((v436 - (unsigned char *)v434) >> 2 > v408) {
        unint64_t v408 = v409 >> 2;
      }
      if ((unint64_t)v409 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v410 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v410 = v408;
      }
      if (v410)
      {
        v411 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v410);
        long long v14 = (char *)v434;
        uint64_t v266 = (char *)v435;
      }
      else
      {
        v411 = 0;
      }
      unint64_t v272 = &v411[8 * v407];
      unint64_t v273 = &v411[8 * v410];
      *(void *)unint64_t v272 = v265;
      double v274 = (double *)(v272 + 8);
      while (v266 != v14)
      {
        uint64_t v412 = *((void *)v266 - 1);
        v266 -= 8;
        *((void *)v272 - 1) = v412;
        v272 -= 8;
      }
LABEL_589:
      unint64_t v434 = v272;
      v435 = v274;
      uint64_t v436 = v273;
      if (!v14) {
        goto LABEL_591;
      }
      goto LABEL_590;
    }
LABEL_576:
    *(void *)uint64_t v266 = v265;
    goto LABEL_591;
  }
  double v12 = (os_unfair_lock_s *)(a1 + 208);
  OZChannelCurve::getEnabledVerticesList(v12, a2, &v430);
  unint64_t v13 = ((unint64_t)(v431 - v430) >> 4);
  std::vector<double>::reserve((void **)&v440, v13);
  std::vector<double>::reserve(&__p, v13);
  std::vector<double>::reserve(&v434, v13);
  long long v14 = v431;
  if (v431 == v430)
  {
    int v17 = 1;
    if (!v431) {
      goto LABEL_591;
    }
    goto LABEL_213;
  }
  uint64_t v15 = 0;
  unsigned int v16 = 0;
  int v17 = 1;
  long long v14 = v430;
  do
  {
    OZChannelCurve::getVertexValue((uint64_t)v12, *(char **)&v14[16 * v15], *(char **)&v14[16 * v15 + 8], a2, &v444, &v443);
    if (*(_DWORD *)(a3 + 172) != 2)
    {
      OZChannelCurve::getInputTangents((uint64_t)v12, *(char **)&v430[16 * v15], *(char **)&v430[16 * v15 + 8], a2, v446, &v445);
      if (fabs(v446[0]) >= 0.0000001 || fabs(v445) >= 0.0000001)
      {
        double v18 = v446[0] + v444;
        v432.f64[0] = v446[0] + v444;
        v432.f64[1] = v443 + v445;
        long long v433 = xmmword_1B7E733E0;
        if (a4)
        {
          PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
          double v19 = *((double *)&v433 + 1);
          double v18 = v432.f64[0];
        }
        else
        {
          double v19 = 1.0;
        }
        BOOL v20 = v19 > 0.0;
        int v21 = v441;
        if (v441 >= (double *)v442)
        {
          uint64_t v23 = v440;
          uint64_t v24 = v441 - v440;
          unint64_t v25 = v24 + 1;
          if ((unint64_t)(v24 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v26 = v442 - (char *)v440;
          if ((v442 - (char *)v440) >> 2 > v25) {
            unint64_t v25 = v26 >> 2;
          }
          if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v27 = v25;
          }
          if (v27)
          {
            int v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v27);
            uint64_t v23 = v440;
            int v21 = v441;
          }
          else
          {
            int v28 = 0;
          }
          double v29 = (double *)&v28[8 * v24];
          *double v29 = v18;
          long long v22 = v29 + 1;
          while (v21 != v23)
          {
            uint64_t v30 = *((void *)v21-- - 1);
            *((void *)v29-- - 1) = v30;
          }
          v440 = v29;
          uint64_t v441 = v22;
          uint64_t v442 = &v28[8 * v27];
          if (v23) {
            operator delete(v23);
          }
        }
        else
        {
          *uint64_t v441 = v18;
          long long v22 = v21 + 1;
        }
        uint64_t v441 = v22;
        float64_t v31 = v432.f64[1];
        double v32 = v438;
        if (v438 >= v439)
        {
          uint64_t v34 = (char *)__p;
          uint64_t v35 = (v438 - (unsigned char *)__p) >> 3;
          unint64_t v36 = v35 + 1;
          if ((unint64_t)(v35 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v37 = v439 - (unsigned char *)__p;
          if ((v439 - (unsigned char *)__p) >> 2 > v36) {
            unint64_t v36 = v37 >> 2;
          }
          if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v38 = v36;
          }
          if (v38)
          {
            double v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v38);
            uint64_t v34 = (char *)__p;
            double v32 = v438;
          }
          else
          {
            double v39 = 0;
          }
          double v40 = &v39[8 * v35];
          *(float64_t *)double v40 = v31;
          double v33 = v40 + 8;
          while (v32 != v34)
          {
            uint64_t v41 = *((void *)v32 - 1);
            v32 -= 8;
            *((void *)v40 - 1) = v41;
            v40 -= 8;
          }
          std::string __p = v40;
          unint64_t v438 = v33;
          v439 = &v39[8 * v38];
          if (v34) {
            operator delete(v34);
          }
        }
        else
        {
          *(float64_t *)unint64_t v438 = v432.f64[1];
          double v33 = v32 + 8;
        }
        unint64_t v438 = v33;
        uint64_t v42 = *((void *)&v433 + 1);
        long long v43 = v435;
        if (v435 >= (double *)v436)
        {
          int v45 = (double *)v434;
          uint64_t v46 = ((char *)v435 - (unsigned char *)v434) >> 3;
          unint64_t v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v48 = v436 - (unsigned char *)v434;
          if ((v436 - (unsigned char *)v434) >> 2 > v47) {
            unint64_t v47 = v48 >> 2;
          }
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v49 = v47;
          }
          if (v49)
          {
            uint64_t v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v49);
            int v45 = (double *)v434;
            long long v43 = v435;
          }
          else
          {
            uint64_t v50 = 0;
          }
          uint64_t v51 = &v50[8 * v46];
          *(void *)uint64_t v51 = v42;
          int v44 = (double *)(v51 + 8);
          while (v43 != v45)
          {
            uint64_t v52 = *((void *)v43-- - 1);
            *((void *)v51 - 1) = v52;
            v51 -= 8;
          }
          unint64_t v434 = v51;
          v435 = v44;
          uint64_t v436 = &v50[8 * v49];
          if (v45) {
            operator delete(v45);
          }
        }
        else
        {
          double *v435 = *((double *)&v433 + 1);
          int v44 = v43 + 1;
        }
        v17 &= v20;
        v435 = v44;
      }
    }
    double v53 = v444;
    v432.f64[0] = v444;
    v432.f64[1] = v443;
    long long v433 = xmmword_1B7E733E0;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      double v54 = *((double *)&v433 + 1);
      double v53 = v432.f64[0];
    }
    else
    {
      double v54 = 1.0;
    }
    BOOL v55 = v54 > 0.0;
    double v56 = v441;
    if (v441 >= (double *)v442)
    {
      long long v58 = v440;
      uint64_t v59 = v441 - v440;
      unint64_t v60 = v59 + 1;
      if ((unint64_t)(v59 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v61 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v60) {
        unint64_t v60 = v61 >> 2;
      }
      if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v62 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v62 = v60;
      }
      if (v62)
      {
        uint64_t v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v62);
        long long v58 = v440;
        double v56 = v441;
      }
      else
      {
        uint64_t v63 = 0;
      }
      int v64 = (double *)&v63[8 * v59];
      double *v64 = v53;
      uint64_t v57 = v64 + 1;
      while (v56 != v58)
      {
        uint64_t v65 = *((void *)v56-- - 1);
        *((void *)v64-- - 1) = v65;
      }
      v440 = v64;
      uint64_t v441 = v57;
      uint64_t v442 = &v63[8 * v62];
      if (v58) {
        operator delete(v58);
      }
    }
    else
    {
      *uint64_t v441 = v53;
      uint64_t v57 = v56 + 1;
    }
    uint64_t v441 = v57;
    float64_t v66 = v432.f64[1];
    int v67 = v438;
    if (v438 >= v439)
    {
      int v69 = (char *)__p;
      uint64_t v70 = (v438 - (unsigned char *)__p) >> 3;
      unint64_t v71 = v70 + 1;
      if ((unint64_t)(v70 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v72 = v439 - (unsigned char *)__p;
      if ((v439 - (unsigned char *)__p) >> 2 > v71) {
        unint64_t v71 = v72 >> 2;
      }
      if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v73 = v71;
      }
      if (v73)
      {
        long long v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v73);
        int v69 = (char *)__p;
        int v67 = v438;
      }
      else
      {
        long long v74 = 0;
      }
      float v75 = &v74[8 * v70];
      *(float64_t *)float v75 = v66;
      uint64_t v68 = v75 + 8;
      while (v67 != v69)
      {
        uint64_t v76 = *((void *)v67 - 1);
        v67 -= 8;
        *((void *)v75 - 1) = v76;
        v75 -= 8;
      }
      std::string __p = v75;
      unint64_t v438 = v68;
      v439 = &v74[8 * v73];
      if (v69) {
        operator delete(v69);
      }
    }
    else
    {
      *(float64_t *)unint64_t v438 = v432.f64[1];
      uint64_t v68 = v67 + 8;
    }
    unint64_t v438 = v68;
    uint64_t v77 = *((void *)&v433 + 1);
    double v78 = v435;
    if (v435 >= (double *)v436)
    {
      double v80 = (double *)v434;
      uint64_t v81 = ((char *)v435 - (unsigned char *)v434) >> 3;
      unint64_t v82 = v81 + 1;
      if ((unint64_t)(v81 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v83 = v436 - (unsigned char *)v434;
      if ((v436 - (unsigned char *)v434) >> 2 > v82) {
        unint64_t v82 = v83 >> 2;
      }
      if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v84 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v84 = v82;
      }
      if (v84)
      {
        unint64_t v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v84);
        double v80 = (double *)v434;
        double v78 = v435;
      }
      else
      {
        unint64_t v85 = 0;
      }
      uint64_t v86 = &v85[8 * v81];
      *(void *)uint64_t v86 = v77;
      double v79 = (double *)(v86 + 8);
      while (v78 != v80)
      {
        uint64_t v87 = *((void *)v78-- - 1);
        *((void *)v86 - 1) = v87;
        v86 -= 8;
      }
      unint64_t v434 = v86;
      v435 = v79;
      uint64_t v436 = &v85[8 * v84];
      if (v80) {
        operator delete(v80);
      }
    }
    else
    {
      double *v435 = *((double *)&v433 + 1);
      double v79 = v78 + 1;
    }
    v17 &= v55;
    v435 = v79;
    if (*(_DWORD *)(a3 + 172) != 2)
    {
      OZChannelCurve::getOutputTangents((uint64_t)v12, *(char **)&v430[16 * v15], *(char **)&v430[16 * v15 + 8], a2, v446, &v445);
      if (fabs(v446[0]) >= 0.0000001 || fabs(v445) >= 0.0000001)
      {
        v432.f64[0] = v446[0] + v444;
        v432.f64[1] = v443 + v445;
        long long v433 = xmmword_1B7E733E0;
        if (a4) {
          PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
        }
        if (v17) {
          int v17 = *((double *)&v433 + 1) > 0.0;
        }
        float64_t v88 = v432.f64[0];
        unint64_t v89 = v441;
        if (v441 >= (double *)v442)
        {
          long long v91 = v440;
          uint64_t v92 = v441 - v440;
          unint64_t v93 = v92 + 1;
          if ((unint64_t)(v92 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v94 = v442 - (char *)v440;
          if ((v442 - (char *)v440) >> 2 > v93) {
            unint64_t v93 = v94 >> 2;
          }
          if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v95 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v95 = v93;
          }
          if (v95)
          {
            long long v96 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v95);
            long long v91 = v440;
            unint64_t v89 = v441;
          }
          else
          {
            long long v96 = 0;
          }
          long long v97 = (double *)&v96[8 * v92];
          *long long v97 = v88;
          unint64_t v90 = v97 + 1;
          while (v89 != v91)
          {
            uint64_t v98 = *((void *)v89-- - 1);
            *((void *)v97-- - 1) = v98;
          }
          v440 = v97;
          uint64_t v441 = v90;
          uint64_t v442 = &v96[8 * v95];
          if (v91) {
            operator delete(v91);
          }
        }
        else
        {
          *uint64_t v441 = v432.f64[0];
          unint64_t v90 = v89 + 1;
        }
        uint64_t v441 = v90;
        float64_t v99 = v432.f64[1];
        unint64_t v100 = v438;
        if (v438 >= v439)
        {
          unint64_t v102 = (char *)__p;
          uint64_t v103 = (v438 - (unsigned char *)__p) >> 3;
          unint64_t v104 = v103 + 1;
          if ((unint64_t)(v103 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v105 = v439 - (unsigned char *)__p;
          if ((v439 - (unsigned char *)__p) >> 2 > v104) {
            unint64_t v104 = v105 >> 2;
          }
          if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v106 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v106 = v104;
          }
          if (v106)
          {
            uint64_t v107 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v106);
            unint64_t v102 = (char *)__p;
            unint64_t v100 = v438;
          }
          else
          {
            uint64_t v107 = 0;
          }
          double v108 = &v107[8 * v103];
          *(float64_t *)double v108 = v99;
          uint64_t v101 = v108 + 8;
          while (v100 != v102)
          {
            uint64_t v109 = *((void *)v100 - 1);
            v100 -= 8;
            *((void *)v108 - 1) = v109;
            v108 -= 8;
          }
          std::string __p = v108;
          unint64_t v438 = v101;
          v439 = &v107[8 * v106];
          if (v102) {
            operator delete(v102);
          }
        }
        else
        {
          *(float64_t *)unint64_t v438 = v432.f64[1];
          uint64_t v101 = v100 + 8;
        }
        unint64_t v438 = v101;
        uint64_t v110 = *((void *)&v433 + 1);
        long long v111 = v435;
        if (v435 >= (double *)v436)
        {
          long long v113 = (double *)v434;
          uint64_t v114 = ((char *)v435 - (unsigned char *)v434) >> 3;
          unint64_t v115 = v114 + 1;
          if ((unint64_t)(v114 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v116 = v436 - (unsigned char *)v434;
          if ((v436 - (unsigned char *)v434) >> 2 > v115) {
            unint64_t v115 = v116 >> 2;
          }
          if ((unint64_t)v116 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v117 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v117 = v115;
          }
          if (v117)
          {
            long long v118 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v117);
            long long v113 = (double *)v434;
            long long v111 = v435;
          }
          else
          {
            long long v118 = 0;
          }
          PCString v119 = &v118[8 * v114];
          *(void *)PCString v119 = v110;
          long long v112 = (double *)(v119 + 8);
          while (v111 != v113)
          {
            uint64_t v120 = *((void *)v111-- - 1);
            *((void *)v119 - 1) = v120;
            v119 -= 8;
          }
          unint64_t v434 = v119;
          v435 = v112;
          uint64_t v436 = &v118[8 * v117];
          if (v113) {
            operator delete(v113);
          }
        }
        else
        {
          double *v435 = *((double *)&v433 + 1);
          long long v112 = v111 + 1;
        }
        v435 = v112;
      }
    }
    long long v14 = v430;
    uint64_t v15 = ++v16;
  }
  while (v16 < (unint64_t)((v431 - v430) >> 4));
  if (v430)
  {
LABEL_213:
    uint64_t v431 = v14;
LABEL_590:
    operator delete(v14);
  }
LABEL_591:
  v413 = v440;
  uint64_t v414 = (char *)v441 - (char *)v440;
  if ((unint64_t)((char *)v441 - (char *)v440) <= 0x17) {
    double v415 = 0.0;
  }
  else {
    double v415 = 1.0;
  }
  v416 = (double *)v434;
  if ((unint64_t)v414 >= 0x18 && v17 != 0)
  {
    uint64_t v418 = v414 >> 3;
    unint64_t v419 = (double *)__p;
    _CF = v414 >> 3 != 0;
    uint64_t v420 = (v414 >> 3) - 1;
    if (v420 == 0 || !_CF) {
      uint64_t v418 = 1;
    }
    v421 = v440;
    uint64_t v422 = v418;
    do
    {
      if (vabdd_f64(0.0, *v416) >= 0.0000001)
      {
        double *v421 = *v421 / *v416;
        double *v419 = *v419 / *v416;
      }
      ++v416;
      ++v421;
      ++v419;
      --v422;
    }
    while (v422);
    uint64_t v423 = 0;
    double v415 = 0.0;
    do
    {
      if (v420 == v423) {
        uint64_t v424 = 0;
      }
      else {
        uint64_t v424 = v423 + 1;
      }
      double v415 = v415 + (v413[v423] * *((double *)__p + v424) - v413[v424] * *((double *)__p + v423)) * 0.5;
      ++v423;
    }
    while (v418 != v423);
    v416 = (double *)v434;
  }
  if (v416)
  {
    v435 = v416;
    operator delete(v416);
  }
  if (__p)
  {
    unint64_t v438 = (char *)__p;
    operator delete(__p);
  }
  if (v440)
  {
    uint64_t v441 = v440;
    operator delete(v440);
  }
  return v415;
}

void sub_1B7E20CE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,void *a28,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }
  if (a28) {
    operator delete(a28);
  }
  float64_t v31 = *(void **)(v29 - 160);
  if (v31)
  {
    *(void *)(v29 - 152) = v31;
    operator delete(v31);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OZShape::setDirty(uint64_t this, char a2, int a3)
{
  uint64_t v5 = this;
  uint64_t v6 = (PCMutex *)(this + 8);
  if (a3) {
    this = PCMutex::lock((PCMutex *)(this + 8));
  }
  uint64_t v7 = *(unsigned char **)(v5 + 2672);
  v7[1192] = a2;
  v7[1193] = a2;
  v7[1194] = a2;
  double v8 = *(unsigned char **)(v5 + 2664);
  v8[1192] = a2;
  v8[1193] = a2;
  v8[1194] = a2;
  if (a3) {
    return PCMutex::unlock(v6);
  }
  return this;
}

BOOL OZShape::checkConvexity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 1;
  *(unsigned char *)(a4 + 185) = 1;
  if (!OZShape::isGeometricShape((OZShape *)a1))
  {
    if (*(_DWORD *)(a3 + 168)
      && OZChannel::getValueAsInt((OZChannel *)(a1 + 14280), MEMORY[0x1E4F1FA48], 0.0)
      && (uint64_t v8 = *(void *)(a4 + 264), v9 = *(void *)(a4 + 272) - v8, (unint64_t)v9 >= 0x30))
    {
      uint64_t v10 = 0;
      unint64_t v11 = v9 >> 4;
      while (v11 != v10)
      {
        unint64_t v12 = (v10 + 2) % v11;
        if (v11 - 1 == v10) {
          uint64_t v13 = 0;
        }
        else {
          uint64_t v13 = v10 + 1;
        }
        float64x2_t v14 = *(float64x2_t *)(v8 + 16 * v10++);
        float64x2_t v15 = *(float64x2_t *)(v8 + 16 * v13);
        int8x16_t v16 = (int8x16_t)vsubq_f64(v14, v15);
        float64x2_t v17 = vmulq_f64(vsubq_f64(*(float64x2_t *)(v8 + 16 * v12), v15), (float64x2_t)vextq_s8(v16, v16, 8uLL));
        if (vsubq_f64(v17, (float64x2_t)vdupq_laneq_s64((int64x2_t)v17, 1)).f64[0] >= 0.0) {
          goto LABEL_11;
        }
      }
      return *(unsigned char *)(a4 + 185) != 0;
    }
    else
    {
LABEL_11:
      uint64_t v7 = 0;
      *(unsigned char *)(a4 + 185) = 0;
    }
  }
  return v7;
}

uint64_t OZShape::checkSelfIntersection(OZShape *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = 0;
  *(unsigned char *)(a4 + 186) = 0;
  if (*(void *)(a4 + 272) - *(void *)(a4 + 264) >= 0x31uLL)
  {
    if (OZShape::isGeometricShape(this))
    {
      return *(unsigned char *)(a4 + 186) != 0;
    }
    else
    {
      uint64_t result = isSimplePolygon((uint64_t *)(a4 + 264)) ^ 1;
      *(unsigned char *)(a4 + 186) = result;
    }
  }
  return result;
}

uint64_t OZShape::transformShape(uint64_t a1, const CMTime *a2, double *a3, double *a4)
{
  OZChannelCurve::transformCurve(a1 + 208, a2, a3, a4);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 144);

  return v5(a1, 1, 1);
}

uint64_t OZShape::offsetShape(OZShape *this, CMTime *a2, double a3, double a4)
{
  OZChannelCurve::offsetCurve((OZShape *)((char *)this + 208), a2, a3, a4);
  uint64_t v5 = *(uint64_t (**)(OZShape *, uint64_t, uint64_t))(*(void *)this + 144);

  return v5(this, 1, 1);
}

uint64_t OZShape::getRenderContourWithRoundness(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v29 = (PCMutex *)(a1 + 8);
  PCMutex::lock((PCMutex *)(a1 + 8));
  char isShapeContourAnimated = OZShape::isShapeContourAnimated((OZShape *)a1);
  uint64_t v9 = (uint64_t *)(a1 + 2704);
  if (*(unsigned char *)(a3 + 1194))
  {
    while (1)
    {
      uint64_t v10 = *(void *)(a1 + 2720);
      if (!v10) {
        break;
      }
      uint64_t v11 = *v9;
      unint64_t v12 = *(OZShapeContour **)(*v9 + 16);
      if (v12)
      {
        OZShapeContour::~OZShapeContour(v12);
        MEMORY[0x1BA9BFBA0]();
        uint64_t v11 = *(void *)(a1 + 2704);
        uint64_t v10 = *(void *)(a1 + 2720);
      }
      *(void *)(v11 + 16) = 0;
      uint64_t v13 = *(uint64_t **)(a1 + 2704);
      uint64_t v14 = *v13;
      *(void *)(v14 + 8) = v13[1];
      *(void *)v13[1] = v14;
      *(void *)(a1 + 2720) = v10 - 1;
      operator delete(v13);
    }
LABEL_24:
    OZShape::getReparametrizedContour(a1, a2, a3, 0);
    operator new();
  }
  float64x2_t v15 = *(uint64_t **)(a1 + 2712);
  if (v15 == v9) {
    goto LABEL_24;
  }
  char v16 = isShapeContourAnimated;
  while (1)
  {
    uint64_t v17 = v15[2];
    CMTime time1 = *(CMTime *)a2;
    CMTimeEpoch v18 = *(void *)(v17 + 16);
    *(_OWORD *)&time2.value = *(_OWORD *)v17;
    time2.CMTimeEpoch epoch = v18;
    char v19 = CMTimeCompare(&time1, &time2) ? v16 : 0;
    if ((v19 & 1) == 0 && *(unsigned __int8 *)(a2 + 24) == *(unsigned __int8 *)(v17 + 184)) {
      break;
    }
LABEL_23:
    float64x2_t v15 = (uint64_t *)v15[1];
    if (v15 == v9) {
      goto LABEL_24;
    }
  }
  BOOL v20 = (double *)(v17 + 56);
  if (!a4)
  {
    if (PCMatrix44Tmpl<double>::isIdentity(v20)) {
      goto LABEL_25;
    }
    goto LABEL_23;
  }
  unint64_t v21 = 0;
  BOOL v22 = 0;
  uint64_t v23 = a4;
LABEL_15:
  uint64_t v24 = 0;
  while (vabdd_f64(*(double *)(v23 + v24 * 8), v20[v24]) < 0.0000001)
  {
    if (++v24 == 4)
    {
      BOOL v22 = v21 > 2;
      v20 += 4;
      v23 += 32;
      if (++v21 == 4) {
        goto LABEL_25;
      }
      goto LABEL_15;
    }
  }
  if (!v22) {
    goto LABEL_23;
  }
LABEL_25:
  uint64_t v25 = *v15;
  *(void *)(v25 + 8) = v15[1];
  *(void *)v15[1] = v25;
  --*(void *)(a1 + 2720);
  operator delete(v15);
  uint64_t v26 = operator new(0x18uLL);
  unint64_t v27 = *(void **)(a1 + 2712);
  *uint64_t v26 = v9;
  v26[1] = v27;
  v26[2] = v17;
  void *v27 = v26;
  *(void *)(a1 + 2712) = v26;
  ++*(void *)(a1 + 2720);
  if (v29) {
    PCMutex::unlock(v29);
  }
  return v17;
}

void sub_1B7E21B78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t OZShape::isShapeContourAnimated(OZShape *this)
{
  uint64_t v2 = (OZChannel *)((char *)this + 1072);
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 1072), MEMORY[0x1E4F1FA48], 0.0) == 4)
  {
    uint64_t v3 = (OZChannel *)((char *)this + 12072);
    goto LABEL_5;
  }
  if (OZChannel::getValueAsInt(v2, MEMORY[0x1E4F1FA48], 0.0) == 5)
  {
    uint64_t v3 = (OZChannel *)((char *)this + 1480);
LABEL_5:
    if (!OZChannel::hasMoreThanOneKeypoint(v3))
    {
      return OZChannelFolder::hasMoreThanOneKeypoint((OZChannelFolder *)((char *)this + 12224));
    }
    return 1;
  }
  if (OZChannel::hasMoreThanOneKeypoint((OZChannel *)((char *)this + 208))) {
    return 1;
  }
  uint64_t v5 = *(uint64_t (**)(OZShape *))(*(void *)this + 152);

  return v5(this);
}

BOOL PCMatrix44Tmpl<double>::isIdentity(double *a1)
{
  double v1 = a1[15];
  return fabs(v1) >= 0.0000001
      && vabdd_f64(*a1, v1) < 0.0000001
      && vabdd_f64(a1[5], v1) < 0.0000001
      && vabdd_f64(a1[10], v1) < 0.0000001
      && fabs(a1[1]) < 0.0000001
      && fabs(a1[2]) < 0.0000001
      && fabs(a1[3]) < 0.0000001
      && fabs(a1[4]) < 0.0000001
      && fabs(a1[6]) < 0.0000001
      && fabs(a1[7]) < 0.0000001
      && fabs(a1[8]) < 0.0000001
      && fabs(a1[9]) < 0.0000001
      && fabs(a1[11]) < 0.0000001
      && fabs(a1[12]) < 0.0000001
      && fabs(a1[13]) < 0.0000001
      && fabs(a1[14]) < 0.0000001;
}

uint64_t OZShape::getReparametrizedContour(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  char v19 = (PCMutex *)(a1 + 8);
  PCMutex::lock((PCMutex *)(a1 + 8));
  char isShapeContourAnimated = OZShape::isShapeContourAnimated((OZShape *)a1);
  if (*(unsigned char *)(a3 + 1193)
    || (v10 = (uint64_t *)(a1 + 2728), uint64_t v11 = *(uint64_t **)(a1 + 2736), v11 == (uint64_t *)(a1 + 2728)))
  {
LABEL_2:
    OZShape::updateReparametrizedContour(a1, a2, a3, a4);
  }
  char v12 = isShapeContourAnimated;
  while (1)
  {
    uint64_t v13 = v11[2];
    CMTime time1 = *(CMTime *)a2;
    CMTimeEpoch v14 = *(void *)(v13 + 16);
    *(_OWORD *)&time2.value = *(_OWORD *)v13;
    time2.CMTimeEpoch epoch = v14;
    char v15 = CMTimeCompare(&time1, &time2) ? v12 : 0;
    if ((v15 & 1) == 0 && *(unsigned __int8 *)(a2 + 24) == *(unsigned __int8 *)(v13 + 184)) {
      break;
    }
    uint64_t v11 = (uint64_t *)v11[1];
    if (v11 == v10) {
      goto LABEL_2;
    }
  }
  uint64_t v16 = *v11;
  *(void *)(v16 + 8) = v11[1];
  *(void *)v11[1] = v16;
  --*(void *)(a1 + 2744);
  operator delete(v11);
  uint64_t v17 = operator new(0x18uLL);
  CMTimeEpoch v18 = *(void **)(a1 + 2736);
  void *v17 = v10;
  v17[1] = v18;
  void v17[2] = v13;
  *CMTimeEpoch v18 = v17;
  *(void *)(a1 + 2736) = v17;
  ++*(void *)(a1 + 2744);
  if (v19) {
    PCMutex::unlock(v19);
  }
  return v13;
}

void sub_1B7E21F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void OZShape::updateReparametrizedContour(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  if (*(unsigned char *)(a3 + 1193))
  {
    while (1)
    {
      uint64_t v7 = *(void *)(a1 + 2744);
      if (!v7) {
        break;
      }
      uint64_t v8 = *(void *)(a1 + 2728);
      uint64_t v9 = *(OZShapeReparametrizedContour **)(v8 + 16);
      if (v9)
      {
        OZShapeReparametrizedContour::~OZShapeReparametrizedContour(v9);
        MEMORY[0x1BA9BFBA0]();
        uint64_t v8 = *(void *)(a1 + 2728);
        uint64_t v7 = *(void *)(a1 + 2744);
      }
      *(void *)(v8 + 16) = 0;
      uint64_t v10 = *(uint64_t **)(a1 + 2728);
      uint64_t v11 = *v10;
      *(void *)(v11 + 8) = v10[1];
      *(void *)v10[1] = v11;
      *(void *)(a1 + 2744) = v7 - 1;
      operator delete(v10);
    }
  }
  uint64_t v23 = 0x3FF0000000000000;
  uint64_t v20 = 0x3FF0000000000000;
  *(void *)&v17[40] = 0x3FF0000000000000;
  *(void *)uint64_t v17 = 0x3FF0000000000000;
  memset(&v17[8], 0, 32);
  float64x2_t v18 = 0u;
  long long v19 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  if (*(unsigned char *)(a3 + 216))
  {
    if (a4 && v17 != (unsigned char *)a4)
    {
      for (uint64_t i = 0; i != 16; i += 4)
      {
        uint64_t v13 = &v17[i * 8];
        long long v14 = *(_OWORD *)&a4[i + 2];
        *uint64_t v13 = *(_OWORD *)&a4[i];
        v13[1] = v14;
      }
    }
  }
  else
  {
    PCMatrix44Tmpl<double>::leftShear((double *)v17, *(double *)(a3 + 264), *(long double *)(a3 + 272));
    double v16 = *(double *)(a3 + 248);
    double v15 = *(double *)(a3 + 256);
    if (v16 != 1.0)
    {
      *(float64x2_t *)uint64_t v17 = vmulq_n_f64(*(float64x2_t *)v17, v16);
      *(float64x2_t *)&v17[16] = vmulq_n_f64(*(float64x2_t *)&v17[16], v16);
    }
    if (v15 != 1.0)
    {
      *(float64x2_t *)&unsigned char v17[32] = vmulq_n_f64(*(float64x2_t *)&v17[32], v15);
      float64x2_t v18 = vmulq_n_f64(v18, v15);
    }
    if (a4) {
      PCMatrix44Tmpl<double>::rightMult((uint64_t)v17, a4);
    }
  }
  operator new();
}

void sub_1B7E242C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42)
{
}

uint64_t OZShape::getOSCContour(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  uint64_t v8 = (PCMutex *)(a1 + 8);
  PCMutex::lock((PCMutex *)(a1 + 8));
  Cacheduint64_t Contour = OZShape::getCachedContour((OZShape *)a1, a2, a3, a4);
  if (!CachedContour) {
    OZShape::updateContour();
  }
  PCMutex::unlock(v8);
  return CachedContour;
}

void sub_1B7E244C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t OZShape::getCachedContour(OZShape *this, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    long long v7 = a4[5];
    long long v41 = a4[4];
    *(_OWORD *)uint64_t v42 = v7;
    long long v8 = a4[7];
    *(_OWORD *)&v42[16] = a4[6];
    *(_OWORD *)&v42[32] = v8;
    long long v9 = a4[1];
    *(_OWORD *)double v39 = *a4;
    *(_OWORD *)&v39[16] = v9;
    long long v10 = a4[3];
    *(_OWORD *)&unsigned char v39[32] = a4[2];
    long long v40 = v10;
  }
  else
  {
    *(void *)&v42[40] = 0x3FF0000000000000;
    *(void *)uint64_t v42 = 0x3FF0000000000000;
    *(void *)&v39[40] = 0x3FF0000000000000;
    *(void *)double v39 = 0x3FF0000000000000;
    memset(&v39[8], 0, 32);
    long long v40 = 0u;
    long long v41 = 0u;
    memset(&v42[8], 0, 32);
  }
  char isShapeContourAnimated = OZShape::isShapeContourAnimated(this);
  char v12 = (char *)this + 2680;
  if (*(unsigned char *)(a3 + 1192))
  {
    while (1)
    {
      uint64_t v13 = *((void *)this + 337);
      if (!v13) {
        break;
      }
      uint64_t v14 = *(void *)v12;
      double v15 = *(OZShapeContour **)(*(void *)v12 + 16);
      if (v15)
      {
        OZShapeContour::~OZShapeContour(v15);
        MEMORY[0x1BA9BFBA0](v16, 0x10A0C409674A9C3, v17, v18, v19, v20, v21, v22, *(void *)v39, *(void *)&v39[8], *(void *)&v39[16], *(void *)&v39[24], *(void *)&v39[32], *(void *)&v39[40], v40, *((void *)&v40 + 1));
        uint64_t v14 = *((void *)this + 335);
        uint64_t v13 = *((void *)this + 337);
      }
      *(void *)(v14 + 16) = 0;
      uint64_t v23 = (uint64_t *)*((void *)this + 335);
      uint64_t v24 = *v23;
      *(void *)(v24 + 8) = v23[1];
      *(void *)v23[1] = v24;
      *((void *)this + 337) = v13 - 1;
      operator delete(v23);
    }
    return 0;
  }
  uint64_t v25 = (uint64_t *)*((void *)this + 336);
  if (v25 == (uint64_t *)v12) {
    return 0;
  }
  char v26 = isShapeContourAnimated;
  while (1)
  {
    uint64_t v27 = v25[2];
    CMTime time1 = *(CMTime *)a2;
    CMTimeEpoch v28 = *(void *)(v27 + 16);
    *(_OWORD *)&time2.value = *(_OWORD *)v27;
    time2.CMTimeEpoch epoch = v28;
    char v29 = CMTimeCompare(&time1, &time2) ? v26 : 0;
    if ((v29 & 1) == 0)
    {
      unint64_t v30 = 0;
      BOOL v31 = 0;
      uint64_t v32 = v27 + 56;
      double v33 = v39;
LABEL_16:
      uint64_t v34 = 0;
      while (vabdd_f64(*(double *)(v32 + v34), *(double *)&v33[v34]) < 0.0000001)
      {
        v34 += 8;
        if (v34 == 32)
        {
          BOOL v31 = v30 > 2;
          v33 += 32;
          v32 += 32;
          if (++v30 != 4) {
            goto LABEL_16;
          }
          goto LABEL_22;
        }
      }
      if (!v31) {
        goto LABEL_23;
      }
LABEL_22:
      if (*(unsigned __int8 *)(a2 + 24) == *(unsigned __int8 *)(v27 + 184)) {
        break;
      }
    }
LABEL_23:
    uint64_t v25 = (uint64_t *)v25[1];
    if (v25 == (uint64_t *)v12) {
      return 0;
    }
  }
  uint64_t v36 = *v25;
  *(void *)(v36 + 8) = v25[1];
  *(void *)v25[1] = v36;
  --*((void *)this + 337);
  operator delete(v25);
  uint64_t v37 = operator new(0x18uLL);
  unint64_t v38 = (void *)*((void *)this + 336);
  void *v37 = v12;
  v37[1] = v38;
  v37[2] = v27;
  *unint64_t v38 = v37;
  *((void *)this + 336) = v37;
  ++*((void *)this + 337);
  return v27;
}

void OZShape::updateContour()
{
}

void sub_1B7E26CD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  PCString::~PCString((PCString *)&__p);
  MEMORY[0x1BA9BFBA0](v20, 0x10E1C409E4CE797);
  _Unwind_Resume(a1);
}

uint64_t OZShape::getContour(OZShape *this, const OZShapeRenderState *a2, OZShapeRenderParams *a3)
{
  uint64_t v6 = (PCMutex *)((char *)this + 8);
  PCMutex::lock((PCMutex *)((char *)this + 8));
  Cacheduint64_t Contour = OZShape::getCachedContour(this, (uint64_t)a2, (uint64_t)a3, 0);
  if (!CachedContour) {
    OZShape::updateContour();
  }
  PCMutex::unlock(v6);
  return CachedContour;
}

void sub_1B7E26E40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t OZShape::getRenderContour(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  long long v8 = (PCMutex *)(a1 + 8);
  PCMutex::lock((PCMutex *)(a1 + 8));
  Cacheduint64_t Contour = OZShape::getCachedContour((OZShape *)a1, a2, a3, a4);
  if (!CachedContour) {
    OZShape::updateContour();
  }
  PCMutex::unlock(v8);
  return CachedContour;
}

void sub_1B7E26EF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double OZShape::getReparametrizedContourLength(uint64_t a1, uint64_t a2, int a3, double *a4)
{
  long long v8 = (PCMutex *)(a1 + 8);
  uint64_t v19 = a1 + 8;
  char v20 = 0;
  if (a3)
  {
    PCMutex::lock((PCMutex *)(a1 + 8));
    char v20 = 1;
  }
  long long v9 = *(_OWORD *)(a2 + 48);
  v16[2] = *(_OWORD *)(a2 + 32);
  void v16[3] = v9;
  v16[4] = *(_OWORD *)(a2 + 64);
  long long v10 = *(_OWORD *)(a2 + 16);
  v16[0] = *(_OWORD *)a2;
  v16[1] = v10;
  uint64_t v11 = *(CGColorSpace **)(a2 + 80);
  uint64_t v17 = v11;
  if (v11) {
    PCCFRefTraits<CGColorSpace *>::retain(v11);
  }
  int v18 = *(_DWORD *)(a2 + 88);
  uint64_t CurrentRenderParams = OZShape::getCurrentRenderParams(a1, (uint64_t)v16);
  Reparametrizeduint64_t Contour = OZShape::getReparametrizedContour(a1, a2, CurrentRenderParams, a4);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v17);
  if (ReparametrizedContour)
  {
    double v14 = *(double *)(ReparametrizedContour + 392);
    if (!a3) {
      return v14;
    }
    goto LABEL_9;
  }
  double v14 = 0.0;
  if (a3) {
LABEL_9:
  }
    PCMutex::unlock(v8);
  return v14;
}

void sub_1B7E27000(_Unwind_Exception *a1)
{
  PCLockSentry<PCMutex>::~PCLockSentry(v1 - 80);
  _Unwind_Resume(a1);
}

void OZShape::getReparametrizedPointOnContour(uint64_t a1, uint64_t a2, double *a3, double *a4, double *a5, double *a6, int a7, double *a8, long double a9, char a10)
{
  uint64_t v19 = (PCMutex *)(a1 + 8);
  uint64_t v73 = a1 + 8;
  char v74 = 0;
  if (a7)
  {
    PCMutex::lock((PCMutex *)(a1 + 8));
    char v74 = 1;
  }
  int v69 = a3;
  long long v20 = *(_OWORD *)(a2 + 48);
  v70[2] = *(_OWORD *)(a2 + 32);
  v70[3] = v20;
  v70[4] = *(_OWORD *)(a2 + 64);
  long long v21 = *(_OWORD *)(a2 + 16);
  v70[0] = *(_OWORD *)a2;
  v70[1] = v21;
  uint64_t v22 = *(CGColorSpace **)(a2 + 80);
  unint64_t v71 = v22;
  if (v22) {
    PCCFRefTraits<CGColorSpace *>::retain(v22);
  }
  int v72 = *(_DWORD *)(a2 + 88);
  uint64_t CurrentRenderParams = OZShape::getCurrentRenderParams(a1, (uint64_t)v70);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v71);
  Reparametrizeduint64_t Contour = OZShape::getReparametrizedContour(a1, a2, CurrentRenderParams, a8);
  uint64_t v25 = ReparametrizedContour;
  if (!ReparametrizedContour) {
    goto LABEL_43;
  }
  int v67 = a4;
  uint64_t v68 = a5;
  double v26 = *(double *)(ReparametrizedContour + 392);
  if (v26 <= 0.0
    || (CMTimeEpoch v28 = *(double **)(ReparametrizedContour + 216),
        uint64_t v27 = *(void *)(ReparametrizedContour + 224),
        (unint64_t)(v27 - (void)v28) < 9))
  {
    Renderuint64_t Contour = OZShape::getRenderContour(a1, a2, CurrentRenderParams, a8);
    uint64_t v42 = *(double **)(RenderContour + 216);
    if (*(double **)(RenderContour + 224) != v42)
    {
      double v39 = a6;
      if (v69) {
        *int v69 = *v42;
      }
      if (v67) {
        *int v67 = **(double **)(RenderContour + 240);
      }
      if (v68) {
        *uint64_t v68 = 0.0;
      }
      double v43 = 0.0;
      if (a6) {
        goto LABEL_42;
      }
    }
    goto LABEL_43;
  }
  unint64_t v29 = (v27 - (uint64_t)v28) >> 3;
  if (!*(_DWORD *)(CurrentRenderParams + 168))
  {
    unint64_t v44 = v29 - 1;
    if (a9 <= 1.0)
    {
      double v39 = a6;
      if (a9 >= 0.0)
      {
        double v60 = (double)v44 * a9;
        uint64_t v61 = (int)v60;
        if (v44 == v61)
        {
          unsigned int v62 = v61 - 1;
          double v33 = v28[v62];
          uint64_t v63 = *(void *)(ReparametrizedContour + 240);
          double v35 = *(double *)(v63 + 8 * v62);
          double v49 = v28[v44];
          double v50 = *(double *)(v63 + 8 * v44);
          double v37 = v49;
          double v46 = v50;
        }
        else
        {
          double v33 = v28[v61];
          uint64_t v64 = *(void *)(ReparametrizedContour + 240);
          double v35 = *(double *)(v64 + 8 * v61);
          unsigned int v65 = v61 + 1;
          double v37 = v28[v65];
          double v46 = *(double *)(v64 + 8 * v65);
          long double v66 = fmod(v60, 1.0);
          double v49 = v33 + v66 * (v37 - v33);
          double v50 = v35 + v66 * (v46 - v35);
        }
      }
      else
      {
        BOOL v55 = *(double **)(ReparametrizedContour + 240);
        double v33 = *v28;
        double v37 = v28[1];
        double v35 = *v55;
        double v46 = v55[1];
        double v56 = v37 - *v28;
        double v57 = v46 - *v55;
        double v58 = sqrt(v56 * v56 + v57 * v57);
        long double v59 = v26 * a9;
        double v49 = v37 + v59 * (v56 / v58);
        double v50 = v46 + v59 * (v57 / v58);
      }
      goto LABEL_30;
    }
    double v37 = v28[v44];
    uint64_t v45 = *(void *)(ReparametrizedContour + 248);
    double v33 = *(double *)((char *)v28 + v45 - *(void *)(ReparametrizedContour + 240) - 16);
    double v35 = *(double *)(v45 - 16);
    double v46 = *(double *)(v45 - 8);
    double v47 = sqrt((v37 - v33) * (v37 - v33) + (v46 - v35) * (v46 - v35));
    long double v48 = (a9 + -1.0) * v26;
    double v49 = v37 + v48 * ((v37 - v33) / v47);
    double v50 = v46 + v48 * ((v46 - v35) / v47);
LABEL_29:
    double v39 = a6;
LABEL_30:
    long long v40 = v69;
    goto LABEL_33;
  }
  double v30 = fmod(a9, 1.0);
  if (v30 < 0.0) {
    double v30 = v30 + 1.0;
  }
  if ((a10 & 1) == 0) {
    unint64_t v29 = (__PAIR128__(v29, COERCE_UNSIGNED_INT64(fabs(sqrt((*v28 - *(double *)(v27 - 8)) * (*v28 - *(double *)(v27 - 8))+ (**(double **)(v25 + 240) - *(double *)(*(void *)(v25 + 248) - 8))* (**(double **)(v25 + 240) - *(double *)(*(void *)(v25 + 248) - 8))))))- COERCE_UNSIGNED_INT64(0.001)) >> 64;
  }
  if (!v29)
  {
    double v33 = 0.0;
    double v35 = 0.0;
    double v49 = 0.0;
    double v50 = 0.0;
    double v37 = 0.0;
    double v46 = 0.0;
    goto LABEL_29;
  }
  double v31 = v30 * (double)v29;
  unint64_t v32 = (int)v31;
  double v33 = v28[v32 % v29];
  uint64_t v34 = *(void *)(v25 + 240);
  double v35 = *(double *)(v34 + 8 * (v32 % v29));
  unint64_t v36 = (v32 + 1) % v29;
  double v37 = v28[v36];
  double v38 = v37 - v33;
  double v39 = a6;
  if (vabdd_f64(v37, v33) >= 0.0000001)
  {
    long long v40 = v69;
  }
  else
  {
    long long v40 = v69;
    if (vabdd_f64(*(double *)(v34 + 8 * v36), v35) < 0.0000001)
    {
      unint64_t v36 = (v32 + 2) % v29;
      double v37 = v28[v36];
      double v38 = v37 - v33;
    }
  }
  double v46 = *(double *)(v34 + 8 * v36);
  long double v51 = fmod(v31, 1.0);
  double v49 = v33 + v51 * v38;
  double v50 = v35 + v51 * (v46 - v35);
LABEL_33:
  double v52 = v37 - v33;
  double v53 = v46 - v35;
  if (v40) {
    *long long v40 = v49;
  }
  double v54 = sqrt(v52 * v52 + v53 * v53);
  if (v67) {
    *int v67 = v50;
  }
  if (fabs(v54) >= 0.0000001)
  {
    if (v68) {
      *uint64_t v68 = -v53 / v54;
    }
    if (v39)
    {
      double v43 = v52 / v54;
LABEL_42:
      *double v39 = v43;
    }
  }
LABEL_43:
  if (a7) {
    PCMutex::unlock(v19);
  }
}

void sub_1B7E27478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

double PCMatrix44Tmpl<double>::rightMult(uint64_t a1, double *a2)
{
  for (uint64_t i = 0; i != 128; i += 32)
  {
    uint64_t v3 = (double *)(a1 + i);
    double v4 = *(double *)(a1 + i);
    double v5 = *(double *)(a1 + i + 8);
    double v6 = *(double *)(a1 + i + 16);
    double v7 = *(double *)(a1 + i + 24);
    double *v3 = v4 * *a2 + v5 * a2[4] + v6 * a2[8] + v7 * a2[12];
    v3[1] = v4 * a2[1] + v5 * a2[5] + v6 * a2[9] + v7 * a2[13];
    v3[2] = v4 * a2[2] + v5 * a2[6] + v6 * a2[10] + v7 * a2[14];
    double result = v4 * a2[3] + v5 * a2[7] + v6 * a2[11] + v7 * a2[15];
    v3[3] = result;
  }
  return result;
}

uint64_t OZShape::getRectangleFromCircleReparametrizedContour(OZShape *a1, CMTime *a2, uint64_t a3, uint64_t a4, double *a5, double *a6, double a7)
{
  double v15 = *(double *)(a3 + 200);
  double v14 = *(double *)(a3 + 208);
  long long v16 = *((_OWORD *)a5 + 5);
  long long v524 = *((_OWORD *)a5 + 4);
  long long v525 = v16;
  long long v17 = *((_OWORD *)a5 + 7);
  long long v526 = *((_OWORD *)a5 + 6);
  long long v527 = v17;
  long long v18 = *((_OWORD *)a5 + 1);
  long long v520 = *(_OWORD *)a5;
  long long v521 = v18;
  long long v19 = *((_OWORD *)a5 + 3);
  long long v522 = *((_OWORD *)a5 + 2);
  long long v523 = v19;
  PCMatrix44Tmpl<double>::invert((double *)&v520, (double *)&v520, 0.0);
  double v20 = a5[12];
  double v21 = a5[13];
  double v22 = -(v15 * v20);
  double v23 = a5[15];
  double v24 = v23 + v14 * v21 - v15 * v20;
  double v25 = a5[1];
  double v26 = a5[3];
  double v27 = a5[4];
  double v28 = (v26 + v14 * v25 - v15 * *a5) / v24;
  double v29 = v14 * a5[5];
  double v30 = a5[7];
  double v31 = (v30 + v29 - v15 * v27) / v24;
  double v32 = v15 * v20;
  double v33 = v23 + v32 + v14 * v21;
  double v34 = v15 * *a5;
  double v35 = (v26 + v34 + v14 * v25) / v33;
  double v36 = (v30 + v15 * v27 + v29) / v33;
  double v37 = -(v14 * v21);
  double v38 = v23 + v32 + v37;
  double v39 = -(v14 * v25);
  double v40 = (v26 + v34 - v14 * v25) / v38;
  double v41 = (v30 + v15 * v27 - v29) / v38;
  double v42 = v23 + v22 + v37;
  double v43 = (v26 + v39 - v34) / v42;
  double v44 = (v30 + -(v15 * v27) - v29) / v42;
  double v517 = v35 - v28;
  double v518 = v36 - v31;
  double v45 = sqrt(v517 * v517 + v518 * v518);
  double v502 = v36;
  double v503 = v35;
  double v514 = v40 - v35;
  double v515 = v41 - v36;
  double v500 = v41;
  double v501 = v40;
  double v512 = v43 - v40;
  double v513 = v44 - v41;
  double v504 = v31;
  double v505 = v28;
  double v46 = v28 - v43;
  double v47 = v31 - v44;
  double v516 = sqrt(v514 * v514 + v515 * v515);
  double v519 = sqrt(v512 * v512 + v513 * v513);
  double v48 = sqrt(v46 * v46 + v47 * v47);
  unint64_t v49 = *(void *)(a4 + 232);
  *(double *)(a4 + 392) = v48 + v519 + v45 + v516;
  double v50 = (void **)(a4 + 216);
  double v51 = v43 + (v28 - v43) * 0.5;
  double v52 = *(double **)(a4 + 224);
  v497 = a1;
  if ((unint64_t)v52 >= v49)
  {
    double v54 = (double *)*v50;
    uint64_t v55 = ((char *)v52 - (unsigned char *)*v50) >> 3;
    unint64_t v56 = v55 + 1;
    if ((unint64_t)(v55 + 1) >> 61) {
      goto LABEL_562;
    }
    uint64_t v57 = v49 - (void)v54;
    if (v57 >> 2 > v56) {
      unint64_t v56 = v57 >> 2;
    }
    if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v58 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v58 = v56;
    }
    if (v58)
    {
      long double v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v58);
      double v54 = *(double **)(a4 + 216);
      double v52 = *(double **)(a4 + 224);
    }
    else
    {
      long double v59 = 0;
    }
    double v60 = (double *)&v59[8 * v55];
    uint64_t v61 = &v59[8 * v58];
    *double v60 = v51;
    double v53 = v60 + 1;
    while (v52 != v54)
    {
      uint64_t v62 = *((void *)v52-- - 1);
      *((void *)v60-- - 1) = v62;
    }
    *(void *)(a4 + 216) = v60;
    *(void *)(a4 + 224) = v53;
    *(void *)(a4 + 232) = v61;
    if (v54) {
      operator delete(v54);
    }
  }
  else
  {
    double *v52 = v51;
    double v53 = v52 + 1;
  }
  *(void *)(a4 + 224) = v53;
  uint64_t v63 = (void **)(a4 + 240);
  double v64 = v44 + v47 * 0.5;
  long double v66 = *(double **)(a4 + 248);
  unint64_t v65 = *(void *)(a4 + 256);
  v506 = a5;
  v507 = a6;
  if ((unint64_t)v66 >= v65)
  {
    uint64_t v68 = (double *)*v63;
    uint64_t v69 = ((char *)v66 - (unsigned char *)*v63) >> 3;
    unint64_t v70 = v69 + 1;
    if ((unint64_t)(v69 + 1) >> 61) {
      goto LABEL_563;
    }
    uint64_t v71 = v65 - (void)v68;
    if (v71 >> 2 > v70) {
      unint64_t v70 = v71 >> 2;
    }
    if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v72 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v72 = v70;
    }
    if (v72)
    {
      uint64_t v73 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v72);
      uint64_t v68 = *(double **)(a4 + 240);
      long double v66 = *(double **)(a4 + 248);
    }
    else
    {
      uint64_t v73 = 0;
    }
    char v74 = (double *)&v73[8 * v69];
    float v75 = &v73[8 * v72];
    *char v74 = v64;
    int v67 = v74 + 1;
    while (v66 != v68)
    {
      uint64_t v76 = *((void *)v66-- - 1);
      *((void *)v74-- - 1) = v76;
    }
    *(void *)(a4 + 240) = v74;
    *(void *)(a4 + 248) = v67;
    *(void *)(a4 + 256) = v75;
    if (v68) {
      operator delete(v68);
    }
  }
  else
  {
    *long double v66 = v64;
    int v67 = v66 + 1;
  }
  unint64_t v77 = *(void *)(a4 + 208);
  *(void *)(a4 + 248) = v67;
  double v78 = (void **)(a4 + 192);
  double v79 = *(char **)(a4 + 200);
  double v498 = v44;
  double v499 = v43;
  if ((unint64_t)v79 >= v77)
  {
    uint64_t v81 = (char *)*v78;
    uint64_t v82 = (v79 - (unsigned char *)*v78) >> 3;
    unint64_t v83 = v82 + 1;
    if ((unint64_t)(v82 + 1) >> 61) {
      goto LABEL_564;
    }
    uint64_t v84 = v77 - (void)v81;
    if (v84 >> 2 > v83) {
      unint64_t v83 = v84 >> 2;
    }
    if ((unint64_t)v84 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v85 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v85 = v83;
    }
    if (v85)
    {
      uint64_t v86 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v85);
      uint64_t v81 = *(char **)(a4 + 192);
      double v79 = *(char **)(a4 + 200);
    }
    else
    {
      uint64_t v86 = 0;
    }
    uint64_t v87 = &v86[8 * v82];
    float64_t v88 = &v86[8 * v85];
    *(void *)uint64_t v87 = 0;
    double v80 = v87 + 8;
    while (v79 != v81)
    {
      uint64_t v89 = *((void *)v79 - 1);
      v79 -= 8;
      *((void *)v87 - 1) = v89;
      v87 -= 8;
    }
    *(void *)(a4 + 192) = v87;
    *(void *)(a4 + 200) = v80;
    *(void *)(a4 + 208) = v88;
    if (v81) {
      operator delete(v81);
    }
  }
  else
  {
    *(void *)double v79 = 0;
    double v80 = v79 + 8;
  }
  double v90 = v46 / v48 * a7;
  double v91 = v47 / v48 * a7;
  double v92 = 2.0 / v48 * a7;
  *(void *)(a4 + 200) = v80;
  double v93 = v48;
  double v94 = a7 + 0.0;
  double v511 = v93;
  for (i = v93 * 0.5; v94 <= i; double v94 = v94 + a7)
  {
    long long v97 = *(double **)(a4 + 224);
    unint64_t v96 = *(void *)(a4 + 232);
    double v98 = v90 + *(v97 - 1);
    if ((unint64_t)v97 >= v96)
    {
      unint64_t v100 = (double *)*v50;
      uint64_t v101 = ((char *)v97 - (unsigned char *)*v50) >> 3;
      unint64_t v102 = v101 + 1;
      if ((unint64_t)(v101 + 1) >> 61) {
        goto LABEL_562;
      }
      uint64_t v103 = v96 - (void)v100;
      if (v103 >> 2 > v102) {
        unint64_t v102 = v103 >> 2;
      }
      if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v104 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v104 = v102;
      }
      if (v104)
      {
        uint64_t v105 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v104);
        unint64_t v100 = *(double **)(a4 + 216);
        long long v97 = *(double **)(a4 + 224);
      }
      else
      {
        uint64_t v105 = 0;
      }
      unint64_t v106 = (double *)&v105[8 * v101];
      *unint64_t v106 = v98;
      float64_t v99 = v106 + 1;
      while (v97 != v100)
      {
        uint64_t v107 = *((void *)v97-- - 1);
        *((void *)v106-- - 1) = v107;
      }
      *(void *)(a4 + 216) = v106;
      *(void *)(a4 + 224) = v99;
      *(void *)(a4 + 232) = &v105[8 * v104];
      if (v100) {
        operator delete(v100);
      }
    }
    else
    {
      *long long v97 = v98;
      float64_t v99 = v97 + 1;
    }
    *(void *)(a4 + 224) = v99;
    uint64_t v109 = *(double **)(a4 + 248);
    unint64_t v108 = *(void *)(a4 + 256);
    double v110 = v91 + *(v109 - 1);
    if ((unint64_t)v109 >= v108)
    {
      long long v112 = (double *)*v63;
      uint64_t v113 = ((char *)v109 - (unsigned char *)*v63) >> 3;
      unint64_t v114 = v113 + 1;
      if ((unint64_t)(v113 + 1) >> 61) {
        goto LABEL_563;
      }
      uint64_t v115 = v108 - (void)v112;
      if (v115 >> 2 > v114) {
        unint64_t v114 = v115 >> 2;
      }
      if ((unint64_t)v115 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v116 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v116 = v114;
      }
      if (v116)
      {
        unint64_t v117 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v116);
        long long v112 = *(double **)(a4 + 240);
        uint64_t v109 = *(double **)(a4 + 248);
      }
      else
      {
        unint64_t v117 = 0;
      }
      long long v118 = (double *)&v117[8 * v113];
      *long long v118 = v110;
      long long v111 = v118 + 1;
      while (v109 != v112)
      {
        uint64_t v119 = *((void *)v109-- - 1);
        *((void *)v118-- - 1) = v119;
      }
      *(void *)(a4 + 240) = v118;
      *(void *)(a4 + 248) = v111;
      *(void *)(a4 + 256) = &v117[8 * v116];
      if (v112) {
        operator delete(v112);
      }
    }
    else
    {
      *uint64_t v109 = v110;
      long long v111 = v109 + 1;
    }
    *(void *)(a4 + 248) = v111;
    int v121 = *(double **)(a4 + 200);
    unint64_t v120 = *(void *)(a4 + 208);
    double v122 = v92 + *(v121 - 1);
    if ((unint64_t)v121 >= v120)
    {
      uint64_t v124 = (double *)*v78;
      uint64_t v125 = ((char *)v121 - (unsigned char *)*v78) >> 3;
      unint64_t v126 = v125 + 1;
      if ((unint64_t)(v125 + 1) >> 61) {
        goto LABEL_564;
      }
      uint64_t v127 = v120 - (void)v124;
      if (v127 >> 2 > v126) {
        unint64_t v126 = v127 >> 2;
      }
      if ((unint64_t)v127 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v128 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v128 = v126;
      }
      if (v128)
      {
        uint64_t v129 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v128);
        uint64_t v124 = *(double **)(a4 + 192);
        int v121 = *(double **)(a4 + 200);
      }
      else
      {
        uint64_t v129 = 0;
      }
      int v130 = (double *)&v129[8 * v125];
      *int v130 = v122;
      long long v123 = v130 + 1;
      while (v121 != v124)
      {
        uint64_t v131 = *((void *)v121-- - 1);
        *((void *)v130-- - 1) = v131;
      }
      *(void *)(a4 + 192) = v130;
      *(void *)(a4 + 200) = v123;
      *(void *)(a4 + 208) = &v129[8 * v128];
      if (v124) {
        operator delete(v124);
      }
    }
    else
    {
      *int v121 = v122;
      long long v123 = v121 + 1;
    }
    *(void *)(a4 + 200) = v123;
  }
  double v508 = v92;
  double v509 = v91;
  double v510 = v90;
  double v132 = v94 - i;
  double v133 = v517 / v45 * a7;
  double v134 = v518 / v45 * a7;
  double v135 = 1.0 / v45 * a7;
  if (vabdd_f64(v94, i) >= 0.0000001)
  {
    double v136 = v505 + v133 * v132 / v45;
    unint64_t v138 = *(double **)(a4 + 224);
    unint64_t v137 = *(void *)(a4 + 232);
    if ((unint64_t)v138 >= v137)
    {
      float64_t v140 = (double *)*v50;
      uint64_t v141 = ((char *)v138 - (unsigned char *)*v50) >> 3;
      unint64_t v142 = v141 + 1;
      if ((unint64_t)(v141 + 1) >> 61) {
        goto LABEL_562;
      }
      uint64_t v143 = v137 - (void)v140;
      if (v143 >> 2 > v142) {
        unint64_t v142 = v143 >> 2;
      }
      if ((unint64_t)v143 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v144 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v144 = v142;
      }
      if (v144)
      {
        unint64_t v145 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v144);
        float64_t v140 = *(double **)(a4 + 216);
        unint64_t v138 = *(double **)(a4 + 224);
      }
      else
      {
        unint64_t v145 = 0;
      }
      uint64_t v146 = (double *)&v145[8 * v141];
      unint64_t v147 = &v145[8 * v144];
      double *v146 = v136;
      uint64_t v139 = v146 + 1;
      while (v138 != v140)
      {
        uint64_t v148 = *((void *)v138-- - 1);
        *((void *)v146-- - 1) = v148;
      }
      *(void *)(a4 + 216) = v146;
      *(void *)(a4 + 224) = v139;
      *(void *)(a4 + 232) = v147;
      if (v140) {
        operator delete(v140);
      }
    }
    else
    {
      double *v138 = v136;
      uint64_t v139 = v138 + 1;
    }
    *(void *)(a4 + 224) = v139;
    double v149 = v504 + v134 * v132 / v45;
    uint64_t v151 = *(double **)(a4 + 248);
    unint64_t v150 = *(void *)(a4 + 256);
    if ((unint64_t)v151 >= v150)
    {
      int v153 = (double *)*v63;
      uint64_t v154 = ((char *)v151 - (unsigned char *)*v63) >> 3;
      unint64_t v155 = v154 + 1;
      if ((unint64_t)(v154 + 1) >> 61) {
        goto LABEL_563;
      }
      uint64_t v156 = v150 - (void)v153;
      if (v156 >> 2 > v155) {
        unint64_t v155 = v156 >> 2;
      }
      if ((unint64_t)v156 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v157 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v157 = v155;
      }
      if (v157)
      {
        uint64_t v158 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v157);
        int v153 = *(double **)(a4 + 240);
        uint64_t v151 = *(double **)(a4 + 248);
      }
      else
      {
        uint64_t v158 = 0;
      }
      unint64_t v159 = (double *)&v158[8 * v154];
      float64_t v160 = &v158[8 * v157];
      *unint64_t v159 = v149;
      uint64_t v152 = v159 + 1;
      while (v151 != v153)
      {
        uint64_t v161 = *((void *)v151-- - 1);
        *((void *)v159-- - 1) = v161;
      }
      *(void *)(a4 + 240) = v159;
      *(void *)(a4 + 248) = v152;
      *(void *)(a4 + 256) = v160;
      if (v153) {
        operator delete(v153);
      }
    }
    else
    {
      double *v151 = v149;
      uint64_t v152 = v151 + 1;
    }
    *(void *)(a4 + 248) = v152;
    double v162 = v135 * v132 / v45 + 1.0;
    float64_t v164 = *(double **)(a4 + 200);
    unint64_t v163 = *(void *)(a4 + 208);
    if ((unint64_t)v164 >= v163)
    {
      float64_t v166 = (double *)*v78;
      uint64_t v167 = ((char *)v164 - (unsigned char *)*v78) >> 3;
      unint64_t v168 = v167 + 1;
      if ((unint64_t)(v167 + 1) >> 61) {
        goto LABEL_564;
      }
      uint64_t v169 = v163 - (void)v166;
      if (v169 >> 2 > v168) {
        unint64_t v168 = v169 >> 2;
      }
      if ((unint64_t)v169 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v170 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v170 = v168;
      }
      if (v170)
      {
        uint64_t v171 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v170);
        float64_t v166 = *(double **)(a4 + 192);
        float64_t v164 = *(double **)(a4 + 200);
      }
      else
      {
        uint64_t v171 = 0;
      }
      unint64_t v172 = (double *)&v171[8 * v167];
      uint64_t v173 = &v171[8 * v170];
      *unint64_t v172 = v162;
      double v165 = v172 + 1;
      while (v164 != v166)
      {
        uint64_t v174 = *((void *)v164-- - 1);
        *((void *)v172-- - 1) = v174;
      }
      *(void *)(a4 + 192) = v172;
      *(void *)(a4 + 200) = v165;
      *(void *)(a4 + 208) = v173;
      if (v166) {
        operator delete(v166);
      }
    }
    else
    {
      *float64_t v164 = v162;
      double v165 = v164 + 1;
    }
    *(void *)(a4 + 200) = v165;
    double v132 = v132 + a7;
  }
  for (; v132 <= v45; double v132 = v132 + a7)
  {
    long long v176 = *(double **)(a4 + 224);
    unint64_t v175 = *(void *)(a4 + 232);
    double v177 = v133 + *(v176 - 1);
    if ((unint64_t)v176 >= v175)
    {
      float64_t v179 = (double *)*v50;
      uint64_t v180 = ((char *)v176 - (unsigned char *)*v50) >> 3;
      unint64_t v181 = v180 + 1;
      if ((unint64_t)(v180 + 1) >> 61) {
        goto LABEL_562;
      }
      uint64_t v182 = v175 - (void)v179;
      if (v182 >> 2 > v181) {
        unint64_t v181 = v182 >> 2;
      }
      if ((unint64_t)v182 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v183 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v183 = v181;
      }
      if (v183)
      {
        unint64_t v184 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v183);
        float64_t v179 = *(double **)(a4 + 216);
        long long v176 = *(double **)(a4 + 224);
      }
      else
      {
        unint64_t v184 = 0;
      }
      uint64_t v185 = (double *)&v184[8 * v180];
      double *v185 = v177;
      uint64_t v178 = v185 + 1;
      while (v176 != v179)
      {
        uint64_t v186 = *((void *)v176-- - 1);
        *((void *)v185-- - 1) = v186;
      }
      *(void *)(a4 + 216) = v185;
      *(void *)(a4 + 224) = v178;
      *(void *)(a4 + 232) = &v184[8 * v183];
      if (v179) {
        operator delete(v179);
      }
    }
    else
    {
      double *v176 = v177;
      uint64_t v178 = v176 + 1;
    }
    *(void *)(a4 + 224) = v178;
    long long v188 = *(double **)(a4 + 248);
    unint64_t v187 = *(void *)(a4 + 256);
    double v189 = v134 + *(v188 - 1);
    if ((unint64_t)v188 >= v187)
    {
      uint64_t v191 = (double *)*v63;
      uint64_t v192 = ((char *)v188 - (unsigned char *)*v63) >> 3;
      unint64_t v193 = v192 + 1;
      if ((unint64_t)(v192 + 1) >> 61) {
        goto LABEL_563;
      }
      uint64_t v194 = v187 - (void)v191;
      if (v194 >> 2 > v193) {
        unint64_t v193 = v194 >> 2;
      }
      if ((unint64_t)v194 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v195 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v195 = v193;
      }
      if (v195)
      {
        unint64_t v196 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v195);
        uint64_t v191 = *(double **)(a4 + 240);
        long long v188 = *(double **)(a4 + 248);
      }
      else
      {
        unint64_t v196 = 0;
      }
      uint64_t v197 = (double *)&v196[8 * v192];
      double *v197 = v189;
      uint64_t v190 = v197 + 1;
      while (v188 != v191)
      {
        uint64_t v198 = *((void *)v188-- - 1);
        *((void *)v197-- - 1) = v198;
      }
      *(void *)(a4 + 240) = v197;
      *(void *)(a4 + 248) = v190;
      *(void *)(a4 + 256) = &v196[8 * v195];
      if (v191) {
        operator delete(v191);
      }
    }
    else
    {
      double *v188 = v189;
      uint64_t v190 = v188 + 1;
    }
    *(void *)(a4 + 248) = v190;
    uint64_t v200 = *(double **)(a4 + 200);
    unint64_t v199 = *(void *)(a4 + 208);
    double v201 = v135 + *(v200 - 1);
    if ((unint64_t)v200 >= v199)
    {
      float64_t v203 = (double *)*v78;
      uint64_t v204 = ((char *)v200 - (unsigned char *)*v78) >> 3;
      unint64_t v205 = v204 + 1;
      if ((unint64_t)(v204 + 1) >> 61) {
        goto LABEL_564;
      }
      uint64_t v206 = v199 - (void)v203;
      if (v206 >> 2 > v205) {
        unint64_t v205 = v206 >> 2;
      }
      if ((unint64_t)v206 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v207 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v207 = v205;
      }
      if (v207)
      {
        unint64_t v208 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v207);
        float64_t v203 = *(double **)(a4 + 192);
        uint64_t v200 = *(double **)(a4 + 200);
      }
      else
      {
        unint64_t v208 = 0;
      }
      uint64_t v209 = (double *)&v208[8 * v204];
      *uint64_t v209 = v201;
      uint64_t v202 = v209 + 1;
      while (v200 != v203)
      {
        uint64_t v210 = *((void *)v200-- - 1);
        *((void *)v209-- - 1) = v210;
      }
      *(void *)(a4 + 192) = v209;
      *(void *)(a4 + 200) = v202;
      *(void *)(a4 + 208) = &v208[8 * v207];
      if (v203) {
        operator delete(v203);
      }
    }
    else
    {
      *uint64_t v200 = v201;
      uint64_t v202 = v200 + 1;
    }
    *(void *)(a4 + 200) = v202;
  }
  double v211 = v132 - v45;
  double v212 = v514 / v516 * a7;
  double v213 = v515 / v516 * a7;
  double v214 = 1.0 / v516 * a7;
  if (vabdd_f64(v132, v45) >= 0.0000001)
  {
    double v216 = v503 + v212 * v211 / v516;
    float64x2_t v218 = *(double **)(a4 + 224);
    unint64_t v217 = *(void *)(a4 + 232);
    double v215 = v516;
    if ((unint64_t)v218 >= v217)
    {
      unint64_t v220 = (double *)*v50;
      uint64_t v221 = ((char *)v218 - (unsigned char *)*v50) >> 3;
      unint64_t v222 = v221 + 1;
      if ((unint64_t)(v221 + 1) >> 61) {
        goto LABEL_562;
      }
      uint64_t v223 = v217 - (void)v220;
      if (v223 >> 2 > v222) {
        unint64_t v222 = v223 >> 2;
      }
      if ((unint64_t)v223 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v224 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v224 = v222;
      }
      if (v224)
      {
        double v225 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v224);
        unint64_t v220 = *(double **)(a4 + 216);
        float64x2_t v218 = *(double **)(a4 + 224);
      }
      else
      {
        double v225 = 0;
      }
      uint64_t v226 = (double *)&v225[8 * v221];
      uint64_t v227 = &v225[8 * v224];
      *uint64_t v226 = v216;
      uint64_t v219 = v226 + 1;
      while (v218 != v220)
      {
        uint64_t v228 = *((void *)v218-- - 1);
        *((void *)v226-- - 1) = v228;
      }
      *(void *)(a4 + 216) = v226;
      *(void *)(a4 + 224) = v219;
      *(void *)(a4 + 232) = v227;
      if (v220) {
        operator delete(v220);
      }
    }
    else
    {
      *float64x2_t v218 = v216;
      uint64_t v219 = v218 + 1;
    }
    *(void *)(a4 + 224) = v219;
    double v229 = v502 + v213 * v211 / v516;
    uint64_t v231 = *(double **)(a4 + 248);
    unint64_t v230 = *(void *)(a4 + 256);
    if ((unint64_t)v231 >= v230)
    {
      uint64_t v233 = (double *)*v63;
      uint64_t v234 = ((char *)v231 - (unsigned char *)*v63) >> 3;
      unint64_t v235 = v234 + 1;
      if ((unint64_t)(v234 + 1) >> 61) {
        goto LABEL_563;
      }
      uint64_t v236 = v230 - (void)v233;
      if (v236 >> 2 > v235) {
        unint64_t v235 = v236 >> 2;
      }
      if ((unint64_t)v236 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v237 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v237 = v235;
      }
      if (v237)
      {
        uint64_t v238 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v237);
        uint64_t v233 = *(double **)(a4 + 240);
        uint64_t v231 = *(double **)(a4 + 248);
      }
      else
      {
        uint64_t v238 = 0;
      }
      double v239 = (double *)&v238[8 * v234];
      double v240 = &v238[8 * v237];
      *double v239 = v229;
      unint64_t v232 = v239 + 1;
      while (v231 != v233)
      {
        uint64_t v241 = *((void *)v231-- - 1);
        *((void *)v239-- - 1) = v241;
      }
      *(void *)(a4 + 240) = v239;
      *(void *)(a4 + 248) = v232;
      *(void *)(a4 + 256) = v240;
      if (v233) {
        operator delete(v233);
      }
    }
    else
    {
      *uint64_t v231 = v229;
      unint64_t v232 = v231 + 1;
    }
    *(void *)(a4 + 248) = v232;
    double v242 = v214 * v211 / v516 + 2.0;
    unint64_t v244 = *(double **)(a4 + 200);
    unint64_t v243 = *(void *)(a4 + 208);
    if ((unint64_t)v244 >= v243)
    {
      unint64_t v246 = (double *)*v78;
      uint64_t v247 = ((char *)v244 - (unsigned char *)*v78) >> 3;
      unint64_t v248 = v247 + 1;
      if ((unint64_t)(v247 + 1) >> 61) {
        goto LABEL_564;
      }
      uint64_t v249 = v243 - (void)v246;
      if (v249 >> 2 > v248) {
        unint64_t v248 = v249 >> 2;
      }
      if ((unint64_t)v249 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v250 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v250 = v248;
      }
      if (v250)
      {
        uint64_t v251 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v250);
        unint64_t v246 = *(double **)(a4 + 192);
        unint64_t v244 = *(double **)(a4 + 200);
      }
      else
      {
        uint64_t v251 = 0;
      }
      uint64_t v252 = (double *)&v251[8 * v247];
      float64_t v253 = &v251[8 * v250];
      *uint64_t v252 = v242;
      uint64_t v245 = v252 + 1;
      while (v244 != v246)
      {
        uint64_t v254 = *((void *)v244-- - 1);
        *((void *)v252-- - 1) = v254;
      }
      *(void *)(a4 + 192) = v252;
      *(void *)(a4 + 200) = v245;
      *(void *)(a4 + 208) = v253;
      if (v246) {
        operator delete(v246);
      }
    }
    else
    {
      double *v244 = v242;
      uint64_t v245 = v244 + 1;
    }
    *(void *)(a4 + 200) = v245;
    double v211 = v211 + a7;
  }
  else
  {
    double v215 = v516;
  }
  for (; v211 <= v215; double v211 = v211 + a7)
  {
    BOOL v256 = *(double **)(a4 + 224);
    unint64_t v255 = *(void *)(a4 + 232);
    double v257 = v212 + *(v256 - 1);
    if ((unint64_t)v256 >= v255)
    {
      uint64_t v259 = (double *)*v50;
      uint64_t v260 = ((char *)v256 - (unsigned char *)*v50) >> 3;
      unint64_t v261 = v260 + 1;
      if ((unint64_t)(v260 + 1) >> 61) {
        goto LABEL_562;
      }
      uint64_t v262 = v255 - (void)v259;
      if (v262 >> 2 > v261) {
        unint64_t v261 = v262 >> 2;
      }
      if ((unint64_t)v262 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v263 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v263 = v261;
      }
      if (v263)
      {
        uint64_t v264 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v263);
        uint64_t v259 = *(double **)(a4 + 216);
        BOOL v256 = *(double **)(a4 + 224);
      }
      else
      {
        uint64_t v264 = 0;
      }
      uint64_t v265 = (double *)&v264[8 * v260];
      double *v265 = v257;
      unint64_t v258 = v265 + 1;
      while (v256 != v259)
      {
        uint64_t v266 = *((void *)v256-- - 1);
        *((void *)v265-- - 1) = v266;
      }
      *(void *)(a4 + 216) = v265;
      *(void *)(a4 + 224) = v258;
      *(void *)(a4 + 232) = &v264[8 * v263];
      if (v259) {
        operator delete(v259);
      }
    }
    else
    {
      double *v256 = v257;
      unint64_t v258 = v256 + 1;
    }
    *(void *)(a4 + 224) = v258;
    unint64_t v268 = *(double **)(a4 + 248);
    unint64_t v267 = *(void *)(a4 + 256);
    double v269 = v213 + *(v268 - 1);
    if ((unint64_t)v268 >= v267)
    {
      uint64_t v271 = (double *)*v63;
      uint64_t v272 = ((char *)v268 - (unsigned char *)*v63) >> 3;
      unint64_t v273 = v272 + 1;
      if ((unint64_t)(v272 + 1) >> 61) {
        goto LABEL_563;
      }
      uint64_t v274 = v267 - (void)v271;
      if (v274 >> 2 > v273) {
        unint64_t v273 = v274 >> 2;
      }
      if ((unint64_t)v274 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v275 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v275 = v273;
      }
      if (v275)
      {
        double v276 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v275);
        uint64_t v271 = *(double **)(a4 + 240);
        unint64_t v268 = *(double **)(a4 + 248);
      }
      else
      {
        double v276 = 0;
      }
      double v277 = (double *)&v276[8 * v272];
      double *v277 = v269;
      unint64_t v270 = v277 + 1;
      while (v268 != v271)
      {
        uint64_t v278 = *((void *)v268-- - 1);
        *((void *)v277-- - 1) = v278;
      }
      *(void *)(a4 + 240) = v277;
      *(void *)(a4 + 248) = v270;
      *(void *)(a4 + 256) = &v276[8 * v275];
      if (v271) {
        operator delete(v271);
      }
    }
    else
    {
      double *v268 = v269;
      unint64_t v270 = v268 + 1;
    }
    *(void *)(a4 + 248) = v270;
    double v280 = *(double **)(a4 + 200);
    unint64_t v279 = *(void *)(a4 + 208);
    double v281 = v214 + *(v280 - 1);
    if ((unint64_t)v280 >= v279)
    {
      uint64_t v283 = (double *)*v78;
      uint64_t v284 = ((char *)v280 - (unsigned char *)*v78) >> 3;
      unint64_t v285 = v284 + 1;
      if ((unint64_t)(v284 + 1) >> 61) {
        goto LABEL_564;
      }
      uint64_t v286 = v279 - (void)v283;
      if (v286 >> 2 > v285) {
        unint64_t v285 = v286 >> 2;
      }
      if ((unint64_t)v286 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v287 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v287 = v285;
      }
      if (v287)
      {
        uint64_t v288 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v287);
        uint64_t v283 = *(double **)(a4 + 192);
        double v280 = *(double **)(a4 + 200);
      }
      else
      {
        uint64_t v288 = 0;
      }
      uint64_t v289 = (double *)&v288[8 * v284];
      double *v289 = v281;
      unint64_t v282 = v289 + 1;
      while (v280 != v283)
      {
        uint64_t v290 = *((void *)v280-- - 1);
        *((void *)v289-- - 1) = v290;
      }
      *(void *)(a4 + 192) = v289;
      *(void *)(a4 + 200) = v282;
      *(void *)(a4 + 208) = &v288[8 * v287];
      if (v283) {
        operator delete(v283);
      }
    }
    else
    {
      *double v280 = v281;
      unint64_t v282 = v280 + 1;
    }
    *(void *)(a4 + 200) = v282;
  }
  double v291 = v211 - v215;
  double v292 = v512 / v519 * a7;
  double v293 = v513 / v519 * a7;
  double v294 = v215;
  double v295 = 1.0 / v519 * a7;
  if (vabdd_f64(v211, v294) >= 0.0000001)
  {
    double v297 = v501 + v292 * v291 / v519;
    long long v299 = *(double **)(a4 + 224);
    unint64_t v298 = *(void *)(a4 + 232);
    double v296 = v511;
    if ((unint64_t)v299 >= v298)
    {
      unint64_t v301 = (double *)*v50;
      uint64_t v302 = ((char *)v299 - (unsigned char *)*v50) >> 3;
      unint64_t v303 = v302 + 1;
      if ((unint64_t)(v302 + 1) >> 61) {
        goto LABEL_562;
      }
      uint64_t v304 = v298 - (void)v301;
      if (v304 >> 2 > v303) {
        unint64_t v303 = v304 >> 2;
      }
      if ((unint64_t)v304 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v305 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v305 = v303;
      }
      if (v305)
      {
        long long v306 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v305);
        unint64_t v301 = *(double **)(a4 + 216);
        long long v299 = *(double **)(a4 + 224);
      }
      else
      {
        long long v306 = 0;
      }
      float64x2_t v307 = (double *)&v306[8 * v302];
      double v308 = &v306[8 * v305];
      *float64x2_t v307 = v297;
      unsigned int v300 = v307 + 1;
      while (v299 != v301)
      {
        uint64_t v309 = *((void *)v299-- - 1);
        *((void *)v307-- - 1) = v309;
      }
      *(void *)(a4 + 216) = v307;
      *(void *)(a4 + 224) = v300;
      *(void *)(a4 + 232) = v308;
      if (v301) {
        operator delete(v301);
      }
    }
    else
    {
      *long long v299 = v297;
      unsigned int v300 = v299 + 1;
    }
    *(void *)(a4 + 224) = v300;
    double v310 = v500 + v293 * v291 / v519;
    unint64_t v312 = *(double **)(a4 + 248);
    unint64_t v311 = *(void *)(a4 + 256);
    if ((unint64_t)v312 >= v311)
    {
      unint64_t v314 = (double *)*v63;
      uint64_t v315 = ((char *)v312 - (unsigned char *)*v63) >> 3;
      unint64_t v316 = v315 + 1;
      if ((unint64_t)(v315 + 1) >> 61) {
        goto LABEL_563;
      }
      uint64_t v317 = v311 - (void)v314;
      if (v317 >> 2 > v316) {
        unint64_t v316 = v317 >> 2;
      }
      if ((unint64_t)v317 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v318 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v318 = v316;
      }
      if (v318)
      {
        uint64_t v319 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v318);
        unint64_t v314 = *(double **)(a4 + 240);
        unint64_t v312 = *(double **)(a4 + 248);
      }
      else
      {
        uint64_t v319 = 0;
      }
      uint64_t v320 = (double *)&v319[8 * v315];
      float64_t v321 = &v319[8 * v318];
      *uint64_t v320 = v310;
      uint64_t v313 = v320 + 1;
      while (v312 != v314)
      {
        uint64_t v322 = *((void *)v312-- - 1);
        *((void *)v320-- - 1) = v322;
      }
      *(void *)(a4 + 240) = v320;
      *(void *)(a4 + 248) = v313;
      *(void *)(a4 + 256) = v321;
      if (v314) {
        operator delete(v314);
      }
    }
    else
    {
      *unint64_t v312 = v310;
      uint64_t v313 = v312 + 1;
    }
    *(void *)(a4 + 248) = v313;
    double v323 = v295 * v291 / v519 + 3.0;
    uint64_t v325 = *(double **)(a4 + 200);
    unint64_t v324 = *(void *)(a4 + 208);
    if ((unint64_t)v325 >= v324)
    {
      uint64_t v327 = (double *)*v78;
      uint64_t v328 = ((char *)v325 - (unsigned char *)*v78) >> 3;
      unint64_t v329 = v328 + 1;
      if ((unint64_t)(v328 + 1) >> 61) {
        goto LABEL_564;
      }
      uint64_t v330 = v324 - (void)v327;
      if (v330 >> 2 > v329) {
        unint64_t v329 = v330 >> 2;
      }
      if ((unint64_t)v330 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v331 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v331 = v329;
      }
      if (v331)
      {
        uint64_t v332 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v331);
        uint64_t v327 = *(double **)(a4 + 192);
        uint64_t v325 = *(double **)(a4 + 200);
      }
      else
      {
        uint64_t v332 = 0;
      }
      uint64_t v333 = (double *)&v332[8 * v328];
      v334 = &v332[8 * v331];
      double *v333 = v323;
      unint64_t v326 = v333 + 1;
      while (v325 != v327)
      {
        uint64_t v335 = *((void *)v325-- - 1);
        *((void *)v333-- - 1) = v335;
      }
      *(void *)(a4 + 192) = v333;
      *(void *)(a4 + 200) = v326;
      *(void *)(a4 + 208) = v334;
      if (v327) {
        operator delete(v327);
      }
    }
    else
    {
      double *v325 = v323;
      unint64_t v326 = v325 + 1;
    }
    *(void *)(a4 + 200) = v326;
    double v291 = v291 + a7;
  }
  else
  {
    double v296 = v511;
  }
  for (; v291 <= v519; double v291 = v291 + a7)
  {
    uint64_t v337 = *(double **)(a4 + 224);
    unint64_t v336 = *(void *)(a4 + 232);
    double v338 = v292 + *(v337 - 1);
    if ((unint64_t)v337 >= v336)
    {
      unint64_t v340 = (double *)*v50;
      uint64_t v341 = ((char *)v337 - (unsigned char *)*v50) >> 3;
      unint64_t v342 = v341 + 1;
      if ((unint64_t)(v341 + 1) >> 61) {
        goto LABEL_562;
      }
      uint64_t v343 = v336 - (void)v340;
      if (v343 >> 2 > v342) {
        unint64_t v342 = v343 >> 2;
      }
      if ((unint64_t)v343 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v344 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v344 = v342;
      }
      if (v344)
      {
        float64_t v345 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v344);
        unint64_t v340 = *(double **)(a4 + 216);
        uint64_t v337 = *(double **)(a4 + 224);
      }
      else
      {
        float64_t v345 = 0;
      }
      v346 = (double *)&v345[8 * v341];
      double *v346 = v338;
      uint64_t v339 = v346 + 1;
      while (v337 != v340)
      {
        uint64_t v347 = *((void *)v337-- - 1);
        *((void *)v346-- - 1) = v347;
      }
      *(void *)(a4 + 216) = v346;
      *(void *)(a4 + 224) = v339;
      *(void *)(a4 + 232) = &v345[8 * v344];
      if (v340) {
        operator delete(v340);
      }
    }
    else
    {
      double *v337 = v338;
      uint64_t v339 = v337 + 1;
    }
    *(void *)(a4 + 224) = v339;
    uint64_t v349 = *(double **)(a4 + 248);
    unint64_t v348 = *(void *)(a4 + 256);
    double v350 = v293 + *(v349 - 1);
    if ((unint64_t)v349 >= v348)
    {
      unint64_t v352 = (double *)*v63;
      uint64_t v353 = ((char *)v349 - (unsigned char *)*v63) >> 3;
      unint64_t v354 = v353 + 1;
      if ((unint64_t)(v353 + 1) >> 61) {
        goto LABEL_563;
      }
      uint64_t v355 = v348 - (void)v352;
      if (v355 >> 2 > v354) {
        unint64_t v354 = v355 >> 2;
      }
      if ((unint64_t)v355 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v356 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v356 = v354;
      }
      if (v356)
      {
        float64_t v357 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v356);
        unint64_t v352 = *(double **)(a4 + 240);
        uint64_t v349 = *(double **)(a4 + 248);
      }
      else
      {
        float64_t v357 = 0;
      }
      unint64_t v358 = (double *)&v357[8 * v353];
      double *v358 = v350;
      uint64_t v351 = v358 + 1;
      while (v349 != v352)
      {
        uint64_t v359 = *((void *)v349-- - 1);
        *((void *)v358-- - 1) = v359;
      }
      *(void *)(a4 + 240) = v358;
      *(void *)(a4 + 248) = v351;
      *(void *)(a4 + 256) = &v357[8 * v356];
      if (v352) {
        operator delete(v352);
      }
    }
    else
    {
      double *v349 = v350;
      uint64_t v351 = v349 + 1;
    }
    *(void *)(a4 + 248) = v351;
    uint64_t v361 = *(double **)(a4 + 200);
    unint64_t v360 = *(void *)(a4 + 208);
    double v362 = v295 + *(v361 - 1);
    if ((unint64_t)v361 >= v360)
    {
      unint64_t v364 = (double *)*v78;
      uint64_t v365 = ((char *)v361 - (unsigned char *)*v78) >> 3;
      unint64_t v366 = v365 + 1;
      if ((unint64_t)(v365 + 1) >> 61) {
        goto LABEL_564;
      }
      uint64_t v367 = v360 - (void)v364;
      if (v367 >> 2 > v366) {
        unint64_t v366 = v367 >> 2;
      }
      if ((unint64_t)v367 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v368 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v368 = v366;
      }
      if (v368)
      {
        uint64_t v369 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v368);
        unint64_t v364 = *(double **)(a4 + 192);
        uint64_t v361 = *(double **)(a4 + 200);
      }
      else
      {
        uint64_t v369 = 0;
      }
      unint64_t v370 = (double *)&v369[8 * v365];
      double *v370 = v362;
      uint64_t v363 = v370 + 1;
      while (v361 != v364)
      {
        uint64_t v371 = *((void *)v361-- - 1);
        *((void *)v370-- - 1) = v371;
      }
      *(void *)(a4 + 192) = v370;
      *(void *)(a4 + 200) = v363;
      *(void *)(a4 + 208) = &v369[8 * v368];
      if (v364) {
        operator delete(v364);
      }
    }
    else
    {
      *uint64_t v361 = v362;
      uint64_t v363 = v361 + 1;
    }
    *(void *)(a4 + 200) = v363;
  }
  double v372 = v291 - v519;
  if (vabdd_f64(v291, v519) >= 0.0000001)
  {
    double v374 = v509;
    double v373 = v510;
    double v376 = v499 + v510 * v372 / v296;
    uint64_t v378 = *(double **)(a4 + 224);
    unint64_t v377 = *(void *)(a4 + 232);
    double v375 = v508;
    if ((unint64_t)v378 >= v377)
    {
      uint64_t v380 = (double *)*v50;
      uint64_t v381 = ((char *)v378 - (unsigned char *)*v50) >> 3;
      unint64_t v382 = v381 + 1;
      if ((unint64_t)(v381 + 1) >> 61) {
        goto LABEL_562;
      }
      uint64_t v383 = v377 - (void)v380;
      if (v383 >> 2 > v382) {
        unint64_t v382 = v383 >> 2;
      }
      if ((unint64_t)v383 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v384 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v384 = v382;
      }
      if (v384)
      {
        v385 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v384);
        uint64_t v380 = *(double **)(a4 + 216);
        uint64_t v378 = *(double **)(a4 + 224);
      }
      else
      {
        v385 = 0;
      }
      uint64_t v386 = (double *)&v385[8 * v381];
      uint64_t v387 = &v385[8 * v384];
      *uint64_t v386 = v376;
      unint64_t v379 = v386 + 1;
      while (v378 != v380)
      {
        uint64_t v388 = *((void *)v378-- - 1);
        *((void *)v386-- - 1) = v388;
      }
      *(void *)(a4 + 216) = v386;
      *(void *)(a4 + 224) = v379;
      *(void *)(a4 + 232) = v387;
      if (v380) {
        operator delete(v380);
      }
    }
    else
    {
      double *v378 = v376;
      unint64_t v379 = v378 + 1;
    }
    *(void *)(a4 + 224) = v379;
    double v389 = v498 + v509 * v372 / v296;
    v391 = *(double **)(a4 + 248);
    unint64_t v390 = *(void *)(a4 + 256);
    if ((unint64_t)v391 >= v390)
    {
      v393 = (double *)*v63;
      uint64_t v394 = ((char *)v391 - (unsigned char *)*v63) >> 3;
      unint64_t v395 = v394 + 1;
      if ((unint64_t)(v394 + 1) >> 61) {
        goto LABEL_563;
      }
      uint64_t v396 = v390 - (void)v393;
      if (v396 >> 2 > v395) {
        unint64_t v395 = v396 >> 2;
      }
      if ((unint64_t)v396 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v397 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v397 = v395;
      }
      if (v397)
      {
        uint64_t v398 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v397);
        v393 = *(double **)(a4 + 240);
        v391 = *(double **)(a4 + 248);
      }
      else
      {
        uint64_t v398 = 0;
      }
      uint64_t v399 = (double *)&v398[8 * v394];
      unint64_t v400 = &v398[8 * v397];
      *uint64_t v399 = v389;
      uint64_t v392 = v399 + 1;
      while (v391 != v393)
      {
        uint64_t v401 = *((void *)v391-- - 1);
        *((void *)v399-- - 1) = v401;
      }
      *(void *)(a4 + 240) = v399;
      *(void *)(a4 + 248) = v392;
      *(void *)(a4 + 256) = v400;
      if (v393) {
        operator delete(v393);
      }
    }
    else
    {
      double *v391 = v389;
      uint64_t v392 = v391 + 1;
    }
    *(void *)(a4 + 248) = v392;
    double v402 = v508 * v372 / v296 + 4.0;
    v404 = *(double **)(a4 + 200);
    unint64_t v403 = *(void *)(a4 + 208);
    if ((unint64_t)v404 >= v403)
    {
      uint64_t v406 = (double *)*v78;
      uint64_t v407 = ((char *)v404 - (unsigned char *)*v78) >> 3;
      unint64_t v408 = v407 + 1;
      if ((unint64_t)(v407 + 1) >> 61) {
        goto LABEL_564;
      }
      uint64_t v409 = v403 - (void)v406;
      if (v409 >> 2 > v408) {
        unint64_t v408 = v409 >> 2;
      }
      if ((unint64_t)v409 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v410 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v410 = v408;
      }
      if (v410)
      {
        v411 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v410);
        uint64_t v406 = *(double **)(a4 + 192);
        v404 = *(double **)(a4 + 200);
      }
      else
      {
        v411 = 0;
      }
      uint64_t v412 = (double *)&v411[8 * v407];
      v413 = &v411[8 * v410];
      double *v412 = v402;
      uint64_t v405 = v412 + 1;
      while (v404 != v406)
      {
        uint64_t v414 = *((void *)v404-- - 1);
        *((void *)v412-- - 1) = v414;
      }
      *(void *)(a4 + 192) = v412;
      *(void *)(a4 + 200) = v405;
      *(void *)(a4 + 208) = v413;
      if (v406) {
        operator delete(v406);
      }
    }
    else
    {
      double *v404 = v402;
      uint64_t v405 = v404 + 1;
    }
    *(void *)(a4 + 200) = v405;
    double v372 = v372 + a7;
  }
  else
  {
    double v374 = v509;
    double v373 = v510;
    double v375 = v508;
  }
  for (; v372 <= i; double v372 = v372 + a7)
  {
    v416 = *(double **)(a4 + 224);
    unint64_t v415 = *(void *)(a4 + 232);
    double v417 = v373 + *(v416 - 1);
    if ((unint64_t)v416 >= v415)
    {
      unint64_t v419 = (double *)*v50;
      uint64_t v420 = ((char *)v416 - (unsigned char *)*v50) >> 3;
      unint64_t v421 = v420 + 1;
      if ((unint64_t)(v420 + 1) >> 61) {
        goto LABEL_562;
      }
      uint64_t v422 = v415 - (void)v419;
      if (v422 >> 2 > v421) {
        unint64_t v421 = v422 >> 2;
      }
      if ((unint64_t)v422 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v423 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v423 = v421;
      }
      if (v423)
      {
        uint64_t v424 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v423);
        unint64_t v419 = *(double **)(a4 + 216);
        v416 = *(double **)(a4 + 224);
      }
      else
      {
        uint64_t v424 = 0;
      }
      v425 = (double *)&v424[8 * v420];
      double *v425 = v417;
      uint64_t v418 = v425 + 1;
      while (v416 != v419)
      {
        uint64_t v426 = *((void *)v416-- - 1);
        *((void *)v425-- - 1) = v426;
      }
      *(void *)(a4 + 216) = v425;
      *(void *)(a4 + 224) = v418;
      *(void *)(a4 + 232) = &v424[8 * v423];
      if (v419) {
        operator delete(v419);
      }
    }
    else
    {
      double *v416 = v417;
      uint64_t v418 = v416 + 1;
    }
    *(void *)(a4 + 224) = v418;
    uint64_t v428 = *(double **)(a4 + 248);
    unint64_t v427 = *(void *)(a4 + 256);
    double v429 = v374 + *(v428 - 1);
    if ((unint64_t)v428 >= v427)
    {
      uint64_t v431 = (double *)*v63;
      uint64_t v432 = ((char *)v428 - (unsigned char *)*v63) >> 3;
      unint64_t v433 = v432 + 1;
      if ((unint64_t)(v432 + 1) >> 61) {
        goto LABEL_563;
      }
      uint64_t v434 = v427 - (void)v431;
      if (v434 >> 2 > v433) {
        unint64_t v433 = v434 >> 2;
      }
      if ((unint64_t)v434 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v435 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v435 = v433;
      }
      if (v435)
      {
        uint64_t v436 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v435);
        uint64_t v431 = *(double **)(a4 + 240);
        uint64_t v428 = *(double **)(a4 + 248);
      }
      else
      {
        uint64_t v436 = 0;
      }
      unint64_t v437 = (double *)&v436[8 * v432];
      double *v437 = v429;
      uint64_t v430 = v437 + 1;
      while (v428 != v431)
      {
        uint64_t v438 = *((void *)v428-- - 1);
        *((void *)v437-- - 1) = v438;
      }
      *(void *)(a4 + 240) = v437;
      *(void *)(a4 + 248) = v430;
      *(void *)(a4 + 256) = &v436[8 * v435];
      if (v431) {
        operator delete(v431);
      }
    }
    else
    {
      double *v428 = v429;
      uint64_t v430 = v428 + 1;
    }
    *(void *)(a4 + 248) = v430;
    v440 = *(double **)(a4 + 200);
    unint64_t v439 = *(void *)(a4 + 208);
    double v441 = v375 + *(v440 - 1);
    if ((unint64_t)v440 >= v439)
    {
      double v443 = (double *)*v78;
      uint64_t v444 = ((char *)v440 - (unsigned char *)*v78) >> 3;
      unint64_t v445 = v444 + 1;
      if ((unint64_t)(v444 + 1) >> 61) {
        goto LABEL_564;
      }
      uint64_t v446 = v439 - (void)v443;
      if (v446 >> 2 > v445) {
        unint64_t v445 = v446 >> 2;
      }
      if ((unint64_t)v446 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v447 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v447 = v445;
      }
      if (v447)
      {
        uint64_t v448 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v447);
        double v443 = *(double **)(a4 + 192);
        v440 = *(double **)(a4 + 200);
      }
      else
      {
        uint64_t v448 = 0;
      }
      unint64_t v449 = (double *)&v448[8 * v444];
      double *v449 = v441;
      uint64_t v442 = v449 + 1;
      while (v440 != v443)
      {
        uint64_t v450 = *((void *)v440-- - 1);
        *((void *)v449-- - 1) = v450;
      }
      *(void *)(a4 + 192) = v449;
      *(void *)(a4 + 200) = v442;
      *(void *)(a4 + 208) = &v448[8 * v447];
      if (v443) {
        operator delete(v443);
      }
    }
    else
    {
      double *v440 = v441;
      uint64_t v442 = v440 + 1;
    }
    *(void *)(a4 + 200) = v442;
  }
  if (vabdd_f64(v372, i) >= 0.0000001)
  {
    unint64_t v452 = *(void **)(a4 + 216);
    uint64_t v451 = *(void **)(a4 + 224);
    unint64_t v453 = *(void *)(a4 + 232);
    if ((unint64_t)v451 < v453)
    {
      *uint64_t v451 = *v452;
      v454 = v451 + 1;
LABEL_519:
      *(void *)(a4 + 224) = v454;
      v465 = *(void **)(a4 + 240);
      v464 = *(void **)(a4 + 248);
      unint64_t v466 = *(void *)(a4 + 256);
      if ((unint64_t)v464 < v466)
      {
        void *v464 = *v465;
        uint64_t v467 = v464 + 1;
LABEL_535:
        *(void *)(a4 + 248) = v467;
        v478 = *(char **)(a4 + 200);
        unint64_t v477 = *(void *)(a4 + 208);
        if ((unint64_t)v478 < v477)
        {
          *(void *)v478 = 0x4014000000000000;
          uint64_t v479 = v478 + 8;
LABEL_551:
          *(void *)(a4 + 200) = v479;
          goto LABEL_552;
        }
        uint64_t v480 = (char *)*v78;
        uint64_t v481 = (v478 - (unsigned char *)*v78) >> 3;
        unint64_t v482 = v481 + 1;
        if (!((unint64_t)(v481 + 1) >> 61))
        {
          uint64_t v483 = v477 - (void)v480;
          if (v483 >> 2 > v482) {
            unint64_t v482 = v483 >> 2;
          }
          if ((unint64_t)v483 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v484 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v484 = v482;
          }
          if (v484)
          {
            v485 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v484);
            uint64_t v480 = *(char **)(a4 + 192);
            v478 = *(char **)(a4 + 200);
          }
          else
          {
            v485 = 0;
          }
          v486 = &v485[8 * v481];
          v487 = &v485[8 * v484];
          *(void *)v486 = 0x4014000000000000;
          uint64_t v479 = v486 + 8;
          while (v478 != v480)
          {
            uint64_t v488 = *((void *)v478 - 1);
            v478 -= 8;
            *((void *)v486 - 1) = v488;
            v486 -= 8;
          }
          *(void *)(a4 + 192) = v486;
          *(void *)(a4 + 200) = v479;
          *(void *)(a4 + 208) = v487;
          if (v480) {
            operator delete(v480);
          }
          goto LABEL_551;
        }
LABEL_564:
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v468 = v464 - v465;
      unint64_t v469 = v468 + 1;
      if (!((unint64_t)(v468 + 1) >> 61))
      {
        uint64_t v470 = v466 - (void)v465;
        if (v470 >> 2 > v469) {
          unint64_t v469 = v470 >> 2;
        }
        if ((unint64_t)v470 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v471 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v471 = v469;
        }
        if (v471)
        {
          unint64_t v472 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v471);
          unint64_t v473 = *(void **)(a4 + 240);
          v464 = *(void **)(a4 + 248);
        }
        else
        {
          unint64_t v472 = 0;
          unint64_t v473 = *(void **)(a4 + 240);
        }
        v474 = &v472[8 * v468];
        uint64_t v475 = &v472[8 * v471];
        *(void *)v474 = *v465;
        uint64_t v467 = v474 + 8;
        while (v464 != v473)
        {
          uint64_t v476 = *--v464;
          *((void *)v474 - 1) = v476;
          v474 -= 8;
        }
        *(void *)(a4 + 240) = v474;
        *(void *)(a4 + 248) = v467;
        *(void *)(a4 + 256) = v475;
        if (v473) {
          operator delete(v473);
        }
        goto LABEL_535;
      }
LABEL_563:
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v455 = v451 - v452;
    unint64_t v456 = v455 + 1;
    if (!((unint64_t)(v455 + 1) >> 61))
    {
      uint64_t v457 = v453 - (void)v452;
      if (v457 >> 2 > v456) {
        unint64_t v456 = v457 >> 2;
      }
      if ((unint64_t)v457 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v458 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v458 = v456;
      }
      if (v458)
      {
        unint64_t v459 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v458);
        v460 = *(void **)(a4 + 216);
        uint64_t v451 = *(void **)(a4 + 224);
      }
      else
      {
        unint64_t v459 = 0;
        v460 = *(void **)(a4 + 216);
      }
      uint64_t v461 = &v459[8 * v455];
      unint64_t v462 = &v459[8 * v458];
      *(void *)uint64_t v461 = *v452;
      v454 = v461 + 8;
      while (v451 != v460)
      {
        uint64_t v463 = *--v451;
        *((void *)v461 - 1) = v463;
        v461 -= 8;
      }
      *(void *)(a4 + 216) = v461;
      *(void *)(a4 + 224) = v454;
      *(void *)(a4 + 232) = v462;
      if (v460) {
        operator delete(v460);
      }
      goto LABEL_519;
    }
LABEL_562:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
LABEL_552:
  if (!PCMatrix44Tmpl<double>::isIdentity(v506))
  {
    uint64_t v489 = *(double **)(a4 + 216);
    uint64_t v490 = *(void *)(a4 + 224) - (void)v489;
    if (v490)
    {
      unint64_t v491 = v490 >> 3;
      uint64_t v492 = (double *)*v63;
      if (v491 <= 1) {
        unint64_t v491 = 1;
      }
      do
      {
        double v493 = *((double *)&v527 + 1) + *v489 * *(double *)&v526 + *v492 * *((double *)&v526 + 1);
        double v494 = (*((double *)&v523 + 1) + *v489 * *(double *)&v522 + *v492 * *((double *)&v522 + 1)) / v493;
        *uint64_t v489 = (*((double *)&v521 + 1) + *v489 * *(double *)&v520 + *v492 * *((double *)&v520 + 1)) / v493;
        ++v489;
        *v492++ = v494;
        --v491;
      }
      while (v491);
    }
  }
  BOOL v495 = 1;
  *(_WORD *)(a4 + 185) = 1;
  if (v507) {
    BOOL v495 = PCMatrix44Tmpl<double>::isIdentity(v507) || !OZShape::checkWindingOrder(v497, a2, a3, v507, 0);
  }
  *(unsigned char *)(a4 + 187) = v495;
  return a4;
}

uint64_t OZShape::getRectangleReparametrizedContour(OZShape *a1, CMTime *a2, uint64_t a3, uint64_t a4, double *a5, double *a6, double a7)
{
  double v14 = *(double *)(a3 + 200) * 0.5;
  double v15 = *(double *)(a3 + 208) * 0.5;
  long long v16 = *((_OWORD *)a5 + 5);
  long long v434 = *((_OWORD *)a5 + 4);
  long long v435 = v16;
  long long v17 = *((_OWORD *)a5 + 7);
  long long v436 = *((_OWORD *)a5 + 6);
  long long v437 = v17;
  long long v18 = *((_OWORD *)a5 + 1);
  long long v430 = *(_OWORD *)a5;
  long long v431 = v18;
  long long v19 = *((_OWORD *)a5 + 3);
  long long v432 = *((_OWORD *)a5 + 2);
  long long v433 = v19;
  PCMatrix44Tmpl<double>::invert((double *)&v430, (double *)&v430, 0.0);
  double v20 = a5[12];
  double v21 = a5[13];
  double v22 = -(v14 * v20);
  double v23 = a5[15];
  double v24 = v23 + v15 * v21 - v14 * v20;
  double v25 = a5[1];
  double v26 = a5[3];
  double v27 = a5[4];
  double v28 = (v26 + v15 * v25 - v14 * *a5) / v24;
  double v29 = v15 * a5[5];
  double v30 = a5[7];
  double v31 = (v30 + v29 - v14 * v27) / v24;
  double v32 = v14 * v20;
  double v33 = v23 + v32 + v15 * v21;
  double v34 = v14 * *a5;
  double v35 = (v26 + v34 + v15 * v25) / v33;
  double v36 = (v30 + v14 * v27 + v29) / v33;
  double v37 = -(v15 * v21);
  double v38 = v23 + v32 + v37;
  double v39 = -(v15 * v25);
  double v40 = (v26 + v34 - v15 * v25) / v38;
  double v41 = (v30 + v14 * v27 - v29) / v38;
  double v42 = v23 + v22 + v37;
  double v43 = (v26 + v39 - v34) / v42;
  double v44 = (v30 + -(v14 * v27) - v29) / v42;
  double v45 = v35 - v28;
  double v46 = v36 - v31;
  double v47 = sqrt(v45 * v45 + v46 * v46);
  double v418 = v36;
  double v419 = v35;
  double v428 = v40 - v35;
  double v429 = v41 - v36;
  double v48 = sqrt(v428 * v428 + v429 * v429);
  double v416 = v41;
  double v417 = v40;
  double v425 = v43 - v40;
  double v426 = v44 - v41;
  double v414 = v44;
  double v415 = v43;
  double v422 = v28 - v43;
  double v423 = v31 - v44;
  double v427 = sqrt(v425 * v425 + v426 * v426);
  double v424 = sqrt(v422 * v422 + v423 * v423);
  unint64_t v49 = *(void *)(a4 + 232);
  *(double *)(a4 + 392) = v424 + v427 + v47 + v48;
  double v50 = (void **)(a4 + 216);
  double v51 = *(double **)(a4 + 224);
  v413 = a1;
  if ((unint64_t)v51 >= v49)
  {
    double v53 = (double *)*v50;
    uint64_t v54 = ((char *)v51 - (unsigned char *)*v50) >> 3;
    unint64_t v55 = v54 + 1;
    if ((unint64_t)(v54 + 1) >> 61) {
      goto LABEL_469;
    }
    uint64_t v56 = v49 - (void)v53;
    if (v56 >> 2 > v55) {
      unint64_t v55 = v56 >> 2;
    }
    if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v57 = v55;
    }
    if (v57)
    {
      unint64_t v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v57);
      double v53 = *(double **)(a4 + 216);
      double v51 = *(double **)(a4 + 224);
    }
    else
    {
      unint64_t v58 = 0;
    }
    long double v59 = (double *)&v58[8 * v54];
    double v60 = &v58[8 * v57];
    *long double v59 = v28;
    double v52 = v59 + 1;
    while (v51 != v53)
    {
      uint64_t v61 = *((void *)v51-- - 1);
      *((void *)v59-- - 1) = v61;
    }
    *(void *)(a4 + 216) = v59;
    *(void *)(a4 + 224) = v52;
    *(void *)(a4 + 232) = v60;
    if (v53) {
      operator delete(v53);
    }
  }
  else
  {
    double *v51 = v28;
    double v52 = v51 + 1;
  }
  *(void *)(a4 + 224) = v52;
  uint64_t v62 = (void **)(a4 + 240);
  double v64 = *(double **)(a4 + 248);
  unint64_t v63 = *(void *)(a4 + 256);
  uint64_t v420 = a5;
  unint64_t v421 = a6;
  if ((unint64_t)v64 >= v63)
  {
    long double v66 = (double *)*v62;
    uint64_t v67 = ((char *)v64 - (unsigned char *)*v62) >> 3;
    unint64_t v68 = v67 + 1;
    if ((unint64_t)(v67 + 1) >> 61) {
      goto LABEL_470;
    }
    uint64_t v69 = v63 - (void)v66;
    if (v69 >> 2 > v68) {
      unint64_t v68 = v69 >> 2;
    }
    if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v70 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v70 = v68;
    }
    if (v70)
    {
      uint64_t v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v70);
      long double v66 = *(double **)(a4 + 240);
      double v64 = *(double **)(a4 + 248);
    }
    else
    {
      uint64_t v71 = 0;
    }
    unint64_t v72 = (double *)&v71[8 * v67];
    uint64_t v73 = &v71[8 * v70];
    double *v72 = v31;
    unint64_t v65 = v72 + 1;
    while (v64 != v66)
    {
      uint64_t v74 = *((void *)v64-- - 1);
      *((void *)v72-- - 1) = v74;
    }
    *(void *)(a4 + 240) = v72;
    *(void *)(a4 + 248) = v65;
    *(void *)(a4 + 256) = v73;
    if (v66) {
      operator delete(v66);
    }
  }
  else
  {
    double *v64 = v31;
    unint64_t v65 = v64 + 1;
  }
  unint64_t v75 = *(void *)(a4 + 208);
  *(void *)(a4 + 248) = v65;
  uint64_t v76 = (void **)(a4 + 192);
  unint64_t v77 = *(char **)(a4 + 200);
  if ((unint64_t)v77 >= v75)
  {
    double v79 = (char *)*v76;
    uint64_t v80 = (v77 - (unsigned char *)*v76) >> 3;
    unint64_t v81 = v80 + 1;
    if ((unint64_t)(v80 + 1) >> 61) {
      goto LABEL_471;
    }
    uint64_t v82 = v75 - (void)v79;
    if (v82 >> 2 > v81) {
      unint64_t v81 = v82 >> 2;
    }
    if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v83 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v83 = v81;
    }
    if (v83)
    {
      uint64_t v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v83);
      double v79 = *(char **)(a4 + 192);
      unint64_t v77 = *(char **)(a4 + 200);
    }
    else
    {
      uint64_t v84 = 0;
    }
    unint64_t v85 = &v84[8 * v80];
    uint64_t v86 = &v84[8 * v83];
    *(void *)unint64_t v85 = 0;
    double v78 = v85 + 8;
    while (v77 != v79)
    {
      uint64_t v87 = *((void *)v77 - 1);
      v77 -= 8;
      *((void *)v85 - 1) = v87;
      v85 -= 8;
    }
    *(void *)(a4 + 192) = v85;
    *(void *)(a4 + 200) = v78;
    *(void *)(a4 + 208) = v86;
    if (v79) {
      operator delete(v79);
    }
  }
  else
  {
    *(void *)unint64_t v77 = 0;
    double v78 = v77 + 8;
  }
  *(void *)(a4 + 200) = v78;
  double v88 = a7 + 0.0;
  if (a7 + 0.0 <= v47)
  {
    double v89 = v45 / v47 * a7;
    double v90 = v46 / v47 * a7;
    do
    {
      double v92 = *(double **)(a4 + 224);
      unint64_t v91 = *(void *)(a4 + 232);
      double v93 = v89 + *(v92 - 1);
      if ((unint64_t)v92 >= v91)
      {
        unint64_t v95 = (double *)*v50;
        uint64_t v96 = ((char *)v92 - (unsigned char *)*v50) >> 3;
        unint64_t v97 = v96 + 1;
        if ((unint64_t)(v96 + 1) >> 61) {
          goto LABEL_469;
        }
        uint64_t v98 = v91 - (void)v95;
        if (v98 >> 2 > v97) {
          unint64_t v97 = v98 >> 2;
        }
        if ((unint64_t)v98 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v99 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v99 = v97;
        }
        if (v99)
        {
          unint64_t v100 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v99);
          unint64_t v95 = *(double **)(a4 + 216);
          double v92 = *(double **)(a4 + 224);
        }
        else
        {
          unint64_t v100 = 0;
        }
        uint64_t v101 = (double *)&v100[8 * v96];
        double *v101 = v93;
        double v94 = v101 + 1;
        while (v92 != v95)
        {
          uint64_t v102 = *((void *)v92-- - 1);
          *((void *)v101-- - 1) = v102;
        }
        *(void *)(a4 + 216) = v101;
        *(void *)(a4 + 224) = v94;
        *(void *)(a4 + 232) = &v100[8 * v99];
        if (v95) {
          operator delete(v95);
        }
      }
      else
      {
        double *v92 = v93;
        double v94 = v92 + 1;
      }
      *(void *)(a4 + 224) = v94;
      unint64_t v104 = *(double **)(a4 + 248);
      unint64_t v103 = *(void *)(a4 + 256);
      double v105 = v90 + *(v104 - 1);
      if ((unint64_t)v104 >= v103)
      {
        uint64_t v107 = (double *)*v62;
        uint64_t v108 = ((char *)v104 - (unsigned char *)*v62) >> 3;
        unint64_t v109 = v108 + 1;
        if ((unint64_t)(v108 + 1) >> 61) {
          goto LABEL_470;
        }
        uint64_t v110 = v103 - (void)v107;
        if (v110 >> 2 > v109) {
          unint64_t v109 = v110 >> 2;
        }
        if ((unint64_t)v110 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v111 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v111 = v109;
        }
        if (v111)
        {
          long long v112 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v111);
          uint64_t v107 = *(double **)(a4 + 240);
          unint64_t v104 = *(double **)(a4 + 248);
        }
        else
        {
          long long v112 = 0;
        }
        uint64_t v113 = (double *)&v112[8 * v108];
        *uint64_t v113 = v105;
        unint64_t v106 = v113 + 1;
        while (v104 != v107)
        {
          uint64_t v114 = *((void *)v104-- - 1);
          *((void *)v113-- - 1) = v114;
        }
        *(void *)(a4 + 240) = v113;
        *(void *)(a4 + 248) = v106;
        *(void *)(a4 + 256) = &v112[8 * v111];
        if (v107) {
          operator delete(v107);
        }
      }
      else
      {
        *unint64_t v104 = v105;
        unint64_t v106 = v104 + 1;
      }
      *(void *)(a4 + 248) = v106;
      unint64_t v116 = *(double **)(a4 + 200);
      unint64_t v115 = *(void *)(a4 + 208);
      double v117 = 1.0 / v47 * a7 + *(v116 - 1);
      if ((unint64_t)v116 >= v115)
      {
        uint64_t v119 = (double *)*v76;
        uint64_t v120 = ((char *)v116 - (unsigned char *)*v76) >> 3;
        unint64_t v121 = v120 + 1;
        if ((unint64_t)(v120 + 1) >> 61) {
          goto LABEL_471;
        }
        uint64_t v122 = v115 - (void)v119;
        if (v122 >> 2 > v121) {
          unint64_t v121 = v122 >> 2;
        }
        if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v123 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v123 = v121;
        }
        if (v123)
        {
          uint64_t v124 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v123);
          uint64_t v119 = *(double **)(a4 + 192);
          unint64_t v116 = *(double **)(a4 + 200);
        }
        else
        {
          uint64_t v124 = 0;
        }
        uint64_t v125 = (double *)&v124[8 * v120];
        *uint64_t v125 = v117;
        long long v118 = v125 + 1;
        while (v116 != v119)
        {
          uint64_t v126 = *((void *)v116-- - 1);
          *((void *)v125-- - 1) = v126;
        }
        *(void *)(a4 + 192) = v125;
        *(void *)(a4 + 200) = v118;
        *(void *)(a4 + 208) = &v124[8 * v123];
        if (v119) {
          operator delete(v119);
        }
      }
      else
      {
        *unint64_t v116 = v117;
        long long v118 = v116 + 1;
      }
      *(void *)(a4 + 200) = v118;
      double v88 = v88 + a7;
    }
    while (v88 <= v47);
  }
  double v127 = v88 - v47;
  double v128 = v428 / v48 * a7;
  double v129 = v429 / v48 * a7;
  double v130 = 1.0 / v48 * a7;
  if (v127 != 0.0 && v127 < v48)
  {
    double v131 = v419 + v128 * v127 / v48;
    double v133 = *(double **)(a4 + 224);
    unint64_t v132 = *(void *)(a4 + 232);
    if ((unint64_t)v133 >= v132)
    {
      double v136 = (double *)*v50;
      uint64_t v137 = ((char *)v133 - (unsigned char *)*v50) >> 3;
      unint64_t v138 = v137 + 1;
      if ((unint64_t)(v137 + 1) >> 61) {
        goto LABEL_469;
      }
      uint64_t v139 = v132 - (void)v136;
      if (v139 >> 2 > v138) {
        unint64_t v138 = v139 >> 2;
      }
      if ((unint64_t)v139 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v140 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v140 = v138;
      }
      if (v140)
      {
        uint64_t v141 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v140);
        double v136 = *(double **)(a4 + 216);
        double v133 = *(double **)(a4 + 224);
      }
      else
      {
        uint64_t v141 = 0;
      }
      unint64_t v142 = (double *)&v141[8 * v137];
      uint64_t v143 = &v141[8 * v140];
      *unint64_t v142 = v131;
      double v134 = v142 + 1;
      if (v133 == v136)
      {
        double v135 = v418;
      }
      else
      {
        double v135 = v418;
        do
        {
          uint64_t v144 = *((void *)v133-- - 1);
          *((void *)v142-- - 1) = v144;
        }
        while (v133 != v136);
      }
      *(void *)(a4 + 216) = v142;
      *(void *)(a4 + 224) = v134;
      *(void *)(a4 + 232) = v143;
      if (v136) {
        operator delete(v136);
      }
    }
    else
    {
      *double v133 = v131;
      double v134 = v133 + 1;
      double v135 = v418;
    }
    *(void *)(a4 + 224) = v134;
    double v145 = v135 + v129 * v127 / v48;
    unint64_t v147 = *(double **)(a4 + 248);
    unint64_t v146 = *(void *)(a4 + 256);
    if ((unint64_t)v147 >= v146)
    {
      double v149 = (double *)*v62;
      uint64_t v150 = ((char *)v147 - (unsigned char *)*v62) >> 3;
      unint64_t v151 = v150 + 1;
      if ((unint64_t)(v150 + 1) >> 61) {
        goto LABEL_470;
      }
      uint64_t v152 = v146 - (void)v149;
      if (v152 >> 2 > v151) {
        unint64_t v151 = v152 >> 2;
      }
      if ((unint64_t)v152 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v153 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v153 = v151;
      }
      if (v153)
      {
        uint64_t v154 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v153);
        double v149 = *(double **)(a4 + 240);
        unint64_t v147 = *(double **)(a4 + 248);
      }
      else
      {
        uint64_t v154 = 0;
      }
      unint64_t v155 = (double *)&v154[8 * v150];
      uint64_t v156 = &v154[8 * v153];
      *unint64_t v155 = v145;
      uint64_t v148 = v155 + 1;
      while (v147 != v149)
      {
        uint64_t v157 = *((void *)v147-- - 1);
        *((void *)v155-- - 1) = v157;
      }
      *(void *)(a4 + 240) = v155;
      *(void *)(a4 + 248) = v148;
      *(void *)(a4 + 256) = v156;
      if (v149) {
        operator delete(v149);
      }
    }
    else
    {
      double *v147 = v145;
      uint64_t v148 = v147 + 1;
    }
    *(void *)(a4 + 248) = v148;
    double v158 = v130 * v127 / v48 + 1.0;
    float64_t v160 = *(double **)(a4 + 200);
    unint64_t v159 = *(void *)(a4 + 208);
    if ((unint64_t)v160 >= v159)
    {
      double v162 = (double *)*v76;
      uint64_t v163 = ((char *)v160 - (unsigned char *)*v76) >> 3;
      unint64_t v164 = v163 + 1;
      if ((unint64_t)(v163 + 1) >> 61) {
        goto LABEL_471;
      }
      uint64_t v165 = v159 - (void)v162;
      if (v165 >> 2 > v164) {
        unint64_t v164 = v165 >> 2;
      }
      if ((unint64_t)v165 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v166 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v166 = v164;
      }
      if (v166)
      {
        uint64_t v167 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v166);
        double v162 = *(double **)(a4 + 192);
        float64_t v160 = *(double **)(a4 + 200);
      }
      else
      {
        uint64_t v167 = 0;
      }
      unint64_t v168 = (double *)&v167[8 * v163];
      uint64_t v169 = &v167[8 * v166];
      *unint64_t v168 = v158;
      uint64_t v161 = v168 + 1;
      while (v160 != v162)
      {
        uint64_t v170 = *((void *)v160-- - 1);
        *((void *)v168-- - 1) = v170;
      }
      *(void *)(a4 + 192) = v168;
      *(void *)(a4 + 200) = v161;
      *(void *)(a4 + 208) = v169;
      if (v162) {
        operator delete(v162);
      }
    }
    else
    {
      *float64_t v160 = v158;
      uint64_t v161 = v160 + 1;
    }
    *(void *)(a4 + 200) = v161;
    double v127 = v127 + a7;
  }
  for (; v127 <= v48; double v127 = v127 + a7)
  {
    unint64_t v172 = *(double **)(a4 + 224);
    unint64_t v171 = *(void *)(a4 + 232);
    double v173 = v128 + *(v172 - 1);
    if ((unint64_t)v172 >= v171)
    {
      unint64_t v175 = (double *)*v50;
      uint64_t v176 = ((char *)v172 - (unsigned char *)*v50) >> 3;
      unint64_t v177 = v176 + 1;
      if ((unint64_t)(v176 + 1) >> 61) {
        goto LABEL_469;
      }
      uint64_t v178 = v171 - (void)v175;
      if (v178 >> 2 > v177) {
        unint64_t v177 = v178 >> 2;
      }
      if ((unint64_t)v178 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v179 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v179 = v177;
      }
      if (v179)
      {
        uint64_t v180 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v179);
        unint64_t v175 = *(double **)(a4 + 216);
        unint64_t v172 = *(double **)(a4 + 224);
      }
      else
      {
        uint64_t v180 = 0;
      }
      unint64_t v181 = (double *)&v180[8 * v176];
      *unint64_t v181 = v173;
      uint64_t v174 = v181 + 1;
      while (v172 != v175)
      {
        uint64_t v182 = *((void *)v172-- - 1);
        *((void *)v181-- - 1) = v182;
      }
      *(void *)(a4 + 216) = v181;
      *(void *)(a4 + 224) = v174;
      *(void *)(a4 + 232) = &v180[8 * v179];
      if (v175) {
        operator delete(v175);
      }
    }
    else
    {
      *unint64_t v172 = v173;
      uint64_t v174 = v172 + 1;
    }
    *(void *)(a4 + 224) = v174;
    unint64_t v184 = *(double **)(a4 + 248);
    unint64_t v183 = *(void *)(a4 + 256);
    double v185 = v129 + *(v184 - 1);
    if ((unint64_t)v184 >= v183)
    {
      unint64_t v187 = (double *)*v62;
      uint64_t v188 = ((char *)v184 - (unsigned char *)*v62) >> 3;
      unint64_t v189 = v188 + 1;
      if ((unint64_t)(v188 + 1) >> 61) {
        goto LABEL_470;
      }
      uint64_t v190 = v183 - (void)v187;
      if (v190 >> 2 > v189) {
        unint64_t v189 = v190 >> 2;
      }
      if ((unint64_t)v190 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v191 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v191 = v189;
      }
      if (v191)
      {
        uint64_t v192 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v191);
        unint64_t v187 = *(double **)(a4 + 240);
        unint64_t v184 = *(double **)(a4 + 248);
      }
      else
      {
        uint64_t v192 = 0;
      }
      unint64_t v193 = (double *)&v192[8 * v188];
      *unint64_t v193 = v185;
      uint64_t v186 = v193 + 1;
      while (v184 != v187)
      {
        uint64_t v194 = *((void *)v184-- - 1);
        *((void *)v193-- - 1) = v194;
      }
      *(void *)(a4 + 240) = v193;
      *(void *)(a4 + 248) = v186;
      *(void *)(a4 + 256) = &v192[8 * v191];
      if (v187) {
        operator delete(v187);
      }
    }
    else
    {
      double *v184 = v185;
      uint64_t v186 = v184 + 1;
    }
    *(void *)(a4 + 248) = v186;
    unint64_t v196 = *(double **)(a4 + 200);
    unint64_t v195 = *(void *)(a4 + 208);
    double v197 = v130 + *(v196 - 1);
    if ((unint64_t)v196 >= v195)
    {
      unint64_t v199 = (double *)*v76;
      uint64_t v200 = ((char *)v196 - (unsigned char *)*v76) >> 3;
      unint64_t v201 = v200 + 1;
      if ((unint64_t)(v200 + 1) >> 61) {
        goto LABEL_471;
      }
      uint64_t v202 = v195 - (void)v199;
      if (v202 >> 2 > v201) {
        unint64_t v201 = v202 >> 2;
      }
      if ((unint64_t)v202 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v203 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v203 = v201;
      }
      if (v203)
      {
        uint64_t v204 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v203);
        unint64_t v199 = *(double **)(a4 + 192);
        unint64_t v196 = *(double **)(a4 + 200);
      }
      else
      {
        uint64_t v204 = 0;
      }
      unint64_t v205 = (double *)&v204[8 * v200];
      double *v205 = v197;
      uint64_t v198 = v205 + 1;
      while (v196 != v199)
      {
        uint64_t v206 = *((void *)v196-- - 1);
        *((void *)v205-- - 1) = v206;
      }
      *(void *)(a4 + 192) = v205;
      *(void *)(a4 + 200) = v198;
      *(void *)(a4 + 208) = &v204[8 * v203];
      if (v199) {
        operator delete(v199);
      }
    }
    else
    {
      double *v196 = v197;
      uint64_t v198 = v196 + 1;
    }
    *(void *)(a4 + 200) = v198;
  }
  double v207 = v127 - v48;
  double v208 = v425 / v427 * a7;
  double v209 = v426 / v427 * a7;
  double v210 = 1.0 / v427 * a7;
  if (v207 != 0.0 && v207 < v427)
  {
    double v211 = v417 + v208 * v207 / v427;
    double v213 = *(double **)(a4 + 224);
    unint64_t v212 = *(void *)(a4 + 232);
    if ((unint64_t)v213 >= v212)
    {
      double v216 = (double *)*v50;
      uint64_t v217 = ((char *)v213 - (unsigned char *)*v50) >> 3;
      unint64_t v218 = v217 + 1;
      if ((unint64_t)(v217 + 1) >> 61) {
        goto LABEL_469;
      }
      uint64_t v219 = v212 - (void)v216;
      if (v219 >> 2 > v218) {
        unint64_t v218 = v219 >> 2;
      }
      if ((unint64_t)v219 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v220 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v220 = v218;
      }
      if (v220)
      {
        uint64_t v221 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v220);
        double v216 = *(double **)(a4 + 216);
        double v213 = *(double **)(a4 + 224);
      }
      else
      {
        uint64_t v221 = 0;
      }
      unint64_t v222 = (double *)&v221[8 * v217];
      uint64_t v223 = &v221[8 * v220];
      double *v222 = v211;
      double v214 = v222 + 1;
      if (v213 == v216)
      {
        double v215 = v416;
      }
      else
      {
        double v215 = v416;
        do
        {
          uint64_t v224 = *((void *)v213-- - 1);
          *((void *)v222-- - 1) = v224;
        }
        while (v213 != v216);
      }
      *(void *)(a4 + 216) = v222;
      *(void *)(a4 + 224) = v214;
      *(void *)(a4 + 232) = v223;
      if (v216) {
        operator delete(v216);
      }
    }
    else
    {
      *double v213 = v211;
      double v214 = v213 + 1;
      double v215 = v416;
    }
    *(void *)(a4 + 224) = v214;
    double v225 = v215 + v209 * v207 / v427;
    uint64_t v227 = *(double **)(a4 + 248);
    unint64_t v226 = *(void *)(a4 + 256);
    if ((unint64_t)v227 >= v226)
    {
      double v229 = (double *)*v62;
      uint64_t v230 = ((char *)v227 - (unsigned char *)*v62) >> 3;
      unint64_t v231 = v230 + 1;
      if ((unint64_t)(v230 + 1) >> 61) {
        goto LABEL_470;
      }
      uint64_t v232 = v226 - (void)v229;
      if (v232 >> 2 > v231) {
        unint64_t v231 = v232 >> 2;
      }
      if ((unint64_t)v232 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v233 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v233 = v231;
      }
      if (v233)
      {
        uint64_t v234 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v233);
        double v229 = *(double **)(a4 + 240);
        uint64_t v227 = *(double **)(a4 + 248);
      }
      else
      {
        uint64_t v234 = 0;
      }
      unint64_t v235 = (double *)&v234[8 * v230];
      uint64_t v236 = &v234[8 * v233];
      double *v235 = v225;
      uint64_t v228 = v235 + 1;
      while (v227 != v229)
      {
        uint64_t v237 = *((void *)v227-- - 1);
        *((void *)v235-- - 1) = v237;
      }
      *(void *)(a4 + 240) = v235;
      *(void *)(a4 + 248) = v228;
      *(void *)(a4 + 256) = v236;
      if (v229) {
        operator delete(v229);
      }
    }
    else
    {
      *uint64_t v227 = v225;
      uint64_t v228 = v227 + 1;
    }
    *(void *)(a4 + 248) = v228;
    double v238 = v210 * v207 / v427 + 2.0;
    double v240 = *(double **)(a4 + 200);
    unint64_t v239 = *(void *)(a4 + 208);
    if ((unint64_t)v240 >= v239)
    {
      double v242 = (double *)*v76;
      uint64_t v243 = ((char *)v240 - (unsigned char *)*v76) >> 3;
      unint64_t v244 = v243 + 1;
      if ((unint64_t)(v243 + 1) >> 61) {
        goto LABEL_471;
      }
      uint64_t v245 = v239 - (void)v242;
      if (v245 >> 2 > v244) {
        unint64_t v244 = v245 >> 2;
      }
      if ((unint64_t)v245 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v246 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v246 = v244;
      }
      if (v246)
      {
        uint64_t v247 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v246);
        double v242 = *(double **)(a4 + 192);
        double v240 = *(double **)(a4 + 200);
      }
      else
      {
        uint64_t v247 = 0;
      }
      unint64_t v248 = (double *)&v247[8 * v243];
      uint64_t v249 = &v247[8 * v246];
      double *v248 = v238;
      uint64_t v241 = v248 + 1;
      while (v240 != v242)
      {
        uint64_t v250 = *((void *)v240-- - 1);
        *((void *)v248-- - 1) = v250;
      }
      *(void *)(a4 + 192) = v248;
      *(void *)(a4 + 200) = v241;
      *(void *)(a4 + 208) = v249;
      if (v242) {
        operator delete(v242);
      }
    }
    else
    {
      double *v240 = v238;
      uint64_t v241 = v240 + 1;
    }
    *(void *)(a4 + 200) = v241;
    double v207 = v207 + a7;
  }
  for (; v207 <= v427; double v207 = v207 + a7)
  {
    uint64_t v252 = *(double **)(a4 + 224);
    unint64_t v251 = *(void *)(a4 + 232);
    double v253 = v208 + *(v252 - 1);
    if ((unint64_t)v252 >= v251)
    {
      unint64_t v255 = (double *)*v50;
      uint64_t v256 = ((char *)v252 - (unsigned char *)*v50) >> 3;
      unint64_t v257 = v256 + 1;
      if ((unint64_t)(v256 + 1) >> 61) {
        goto LABEL_469;
      }
      uint64_t v258 = v251 - (void)v255;
      if (v258 >> 2 > v257) {
        unint64_t v257 = v258 >> 2;
      }
      if ((unint64_t)v258 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v259 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v259 = v257;
      }
      if (v259)
      {
        uint64_t v260 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v259);
        unint64_t v255 = *(double **)(a4 + 216);
        uint64_t v252 = *(double **)(a4 + 224);
      }
      else
      {
        uint64_t v260 = 0;
      }
      unint64_t v261 = (double *)&v260[8 * v256];
      double *v261 = v253;
      uint64_t v254 = v261 + 1;
      while (v252 != v255)
      {
        uint64_t v262 = *((void *)v252-- - 1);
        *((void *)v261-- - 1) = v262;
      }
      *(void *)(a4 + 216) = v261;
      *(void *)(a4 + 224) = v254;
      *(void *)(a4 + 232) = &v260[8 * v259];
      if (v255) {
        operator delete(v255);
      }
    }
    else
    {
      *uint64_t v252 = v253;
      uint64_t v254 = v252 + 1;
    }
    *(void *)(a4 + 224) = v254;
    uint64_t v264 = *(double **)(a4 + 248);
    unint64_t v263 = *(void *)(a4 + 256);
    double v265 = v209 + *(v264 - 1);
    if ((unint64_t)v264 >= v263)
    {
      unint64_t v267 = (double *)*v62;
      uint64_t v268 = ((char *)v264 - (unsigned char *)*v62) >> 3;
      unint64_t v269 = v268 + 1;
      if ((unint64_t)(v268 + 1) >> 61) {
        goto LABEL_470;
      }
      uint64_t v270 = v263 - (void)v267;
      if (v270 >> 2 > v269) {
        unint64_t v269 = v270 >> 2;
      }
      if ((unint64_t)v270 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v271 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v271 = v269;
      }
      if (v271)
      {
        uint64_t v272 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v271);
        unint64_t v267 = *(double **)(a4 + 240);
        uint64_t v264 = *(double **)(a4 + 248);
      }
      else
      {
        uint64_t v272 = 0;
      }
      unint64_t v273 = (double *)&v272[8 * v268];
      *unint64_t v273 = v265;
      uint64_t v266 = v273 + 1;
      while (v264 != v267)
      {
        uint64_t v274 = *((void *)v264-- - 1);
        *((void *)v273-- - 1) = v274;
      }
      *(void *)(a4 + 240) = v273;
      *(void *)(a4 + 248) = v266;
      *(void *)(a4 + 256) = &v272[8 * v271];
      if (v267) {
        operator delete(v267);
      }
    }
    else
    {
      *uint64_t v264 = v265;
      uint64_t v266 = v264 + 1;
    }
    *(void *)(a4 + 248) = v266;
    double v276 = *(double **)(a4 + 200);
    unint64_t v275 = *(void *)(a4 + 208);
    double v277 = v210 + *(v276 - 1);
    if ((unint64_t)v276 >= v275)
    {
      unint64_t v279 = (double *)*v76;
      uint64_t v280 = ((char *)v276 - (unsigned char *)*v76) >> 3;
      unint64_t v281 = v280 + 1;
      if ((unint64_t)(v280 + 1) >> 61) {
        goto LABEL_471;
      }
      uint64_t v282 = v275 - (void)v279;
      if (v282 >> 2 > v281) {
        unint64_t v281 = v282 >> 2;
      }
      if ((unint64_t)v282 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v283 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v283 = v281;
      }
      if (v283)
      {
        uint64_t v284 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v283);
        unint64_t v279 = *(double **)(a4 + 192);
        double v276 = *(double **)(a4 + 200);
      }
      else
      {
        uint64_t v284 = 0;
      }
      unint64_t v285 = (double *)&v284[8 * v280];
      *unint64_t v285 = v277;
      uint64_t v278 = v285 + 1;
      while (v276 != v279)
      {
        uint64_t v286 = *((void *)v276-- - 1);
        *((void *)v285-- - 1) = v286;
      }
      *(void *)(a4 + 192) = v285;
      *(void *)(a4 + 200) = v278;
      *(void *)(a4 + 208) = &v284[8 * v283];
      if (v279) {
        operator delete(v279);
      }
    }
    else
    {
      double *v276 = v277;
      uint64_t v278 = v276 + 1;
    }
    *(void *)(a4 + 200) = v278;
  }
  double v287 = v207 - v427;
  double v288 = v422 / v424 * a7;
  double v289 = v423 / v424 * a7;
  double v290 = 1.0 / v424 * a7;
  if (v287 != 0.0 && v287 < v424)
  {
    double v291 = v415 + v288 * v287 / v424;
    double v293 = *(double **)(a4 + 224);
    unint64_t v292 = *(void *)(a4 + 232);
    if ((unint64_t)v293 >= v292)
    {
      double v296 = (double *)*v50;
      uint64_t v297 = ((char *)v293 - (unsigned char *)*v50) >> 3;
      unint64_t v298 = v297 + 1;
      if ((unint64_t)(v297 + 1) >> 61) {
        goto LABEL_469;
      }
      uint64_t v299 = v292 - (void)v296;
      if (v299 >> 2 > v298) {
        unint64_t v298 = v299 >> 2;
      }
      if ((unint64_t)v299 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v300 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v300 = v298;
      }
      if (v300)
      {
        unint64_t v301 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v300);
        double v296 = *(double **)(a4 + 216);
        double v293 = *(double **)(a4 + 224);
      }
      else
      {
        unint64_t v301 = 0;
      }
      uint64_t v302 = (double *)&v301[8 * v297];
      unint64_t v303 = &v301[8 * v300];
      double *v302 = v291;
      double v294 = v302 + 1;
      if (v293 == v296)
      {
        double v295 = v414;
      }
      else
      {
        double v295 = v414;
        do
        {
          uint64_t v304 = *((void *)v293-- - 1);
          *((void *)v302-- - 1) = v304;
        }
        while (v293 != v296);
      }
      *(void *)(a4 + 216) = v302;
      *(void *)(a4 + 224) = v294;
      *(void *)(a4 + 232) = v303;
      if (v296) {
        operator delete(v296);
      }
    }
    else
    {
      double *v293 = v291;
      double v294 = v293 + 1;
      double v295 = v414;
    }
    *(void *)(a4 + 224) = v294;
    double v305 = v295 + v289 * v287 / v424;
    float64x2_t v307 = *(double **)(a4 + 248);
    unint64_t v306 = *(void *)(a4 + 256);
    if ((unint64_t)v307 >= v306)
    {
      uint64_t v309 = (double *)*v62;
      uint64_t v310 = ((char *)v307 - (unsigned char *)*v62) >> 3;
      unint64_t v311 = v310 + 1;
      if ((unint64_t)(v310 + 1) >> 61) {
        goto LABEL_470;
      }
      uint64_t v312 = v306 - (void)v309;
      if (v312 >> 2 > v311) {
        unint64_t v311 = v312 >> 2;
      }
      if ((unint64_t)v312 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v313 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v313 = v311;
      }
      if (v313)
      {
        unint64_t v314 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v313);
        uint64_t v309 = *(double **)(a4 + 240);
        float64x2_t v307 = *(double **)(a4 + 248);
      }
      else
      {
        unint64_t v314 = 0;
      }
      uint64_t v315 = (double *)&v314[8 * v310];
      unint64_t v316 = &v314[8 * v313];
      double *v315 = v305;
      double v308 = v315 + 1;
      while (v307 != v309)
      {
        uint64_t v317 = *((void *)v307-- - 1);
        *((void *)v315-- - 1) = v317;
      }
      *(void *)(a4 + 240) = v315;
      *(void *)(a4 + 248) = v308;
      *(void *)(a4 + 256) = v316;
      if (v309) {
        operator delete(v309);
      }
    }
    else
    {
      *float64x2_t v307 = v305;
      double v308 = v307 + 1;
    }
    *(void *)(a4 + 248) = v308;
    double v318 = v290 * v287 / v424 + 3.0;
    uint64_t v320 = *(double **)(a4 + 200);
    unint64_t v319 = *(void *)(a4 + 208);
    if ((unint64_t)v320 >= v319)
    {
      uint64_t v322 = (double *)*v76;
      uint64_t v323 = ((char *)v320 - (unsigned char *)*v76) >> 3;
      unint64_t v324 = v323 + 1;
      if ((unint64_t)(v323 + 1) >> 61) {
        goto LABEL_471;
      }
      uint64_t v325 = v319 - (void)v322;
      if (v325 >> 2 > v324) {
        unint64_t v324 = v325 >> 2;
      }
      if ((unint64_t)v325 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v326 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v326 = v324;
      }
      if (v326)
      {
        uint64_t v327 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v326);
        uint64_t v322 = *(double **)(a4 + 192);
        uint64_t v320 = *(double **)(a4 + 200);
      }
      else
      {
        uint64_t v327 = 0;
      }
      uint64_t v328 = (double *)&v327[8 * v323];
      unint64_t v329 = &v327[8 * v326];
      *uint64_t v328 = v318;
      float64_t v321 = v328 + 1;
      while (v320 != v322)
      {
        uint64_t v330 = *((void *)v320-- - 1);
        *((void *)v328-- - 1) = v330;
      }
      *(void *)(a4 + 192) = v328;
      *(void *)(a4 + 200) = v321;
      *(void *)(a4 + 208) = v329;
      if (v322) {
        operator delete(v322);
      }
    }
    else
    {
      *uint64_t v320 = v318;
      float64_t v321 = v320 + 1;
    }
    *(void *)(a4 + 200) = v321;
    double v287 = v287 + a7;
  }
  for (; v287 <= v424; double v287 = v287 + a7)
  {
    uint64_t v332 = *(double **)(a4 + 224);
    unint64_t v331 = *(void *)(a4 + 232);
    double v333 = v288 + *(v332 - 1);
    if ((unint64_t)v332 >= v331)
    {
      uint64_t v335 = (double *)*v50;
      uint64_t v336 = ((char *)v332 - (unsigned char *)*v50) >> 3;
      unint64_t v337 = v336 + 1;
      if ((unint64_t)(v336 + 1) >> 61) {
        goto LABEL_469;
      }
      uint64_t v338 = v331 - (void)v335;
      if (v338 >> 2 > v337) {
        unint64_t v337 = v338 >> 2;
      }
      if ((unint64_t)v338 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v339 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v339 = v337;
      }
      if (v339)
      {
        unint64_t v340 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v339);
        uint64_t v335 = *(double **)(a4 + 216);
        uint64_t v332 = *(double **)(a4 + 224);
      }
      else
      {
        unint64_t v340 = 0;
      }
      uint64_t v341 = (double *)&v340[8 * v336];
      *uint64_t v341 = v333;
      v334 = v341 + 1;
      while (v332 != v335)
      {
        uint64_t v342 = *((void *)v332-- - 1);
        *((void *)v341-- - 1) = v342;
      }
      *(void *)(a4 + 216) = v341;
      *(void *)(a4 + 224) = v334;
      *(void *)(a4 + 232) = &v340[8 * v339];
      if (v335) {
        operator delete(v335);
      }
    }
    else
    {
      *uint64_t v332 = v333;
      v334 = v332 + 1;
    }
    *(void *)(a4 + 224) = v334;
    unint64_t v344 = *(double **)(a4 + 248);
    unint64_t v343 = *(void *)(a4 + 256);
    double v345 = v289 + *(v344 - 1);
    if ((unint64_t)v344 >= v343)
    {
      uint64_t v347 = (double *)*v62;
      uint64_t v348 = ((char *)v344 - (unsigned char *)*v62) >> 3;
      unint64_t v349 = v348 + 1;
      if ((unint64_t)(v348 + 1) >> 61) {
        goto LABEL_470;
      }
      uint64_t v350 = v343 - (void)v347;
      if (v350 >> 2 > v349) {
        unint64_t v349 = v350 >> 2;
      }
      if ((unint64_t)v350 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v351 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v351 = v349;
      }
      if (v351)
      {
        unint64_t v352 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v351);
        uint64_t v347 = *(double **)(a4 + 240);
        unint64_t v344 = *(double **)(a4 + 248);
      }
      else
      {
        unint64_t v352 = 0;
      }
      uint64_t v353 = (double *)&v352[8 * v348];
      *uint64_t v353 = v345;
      v346 = v353 + 1;
      while (v344 != v347)
      {
        uint64_t v354 = *((void *)v344-- - 1);
        *((void *)v353-- - 1) = v354;
      }
      *(void *)(a4 + 240) = v353;
      *(void *)(a4 + 248) = v346;
      *(void *)(a4 + 256) = &v352[8 * v351];
      if (v347) {
        operator delete(v347);
      }
    }
    else
    {
      double *v344 = v345;
      v346 = v344 + 1;
    }
    *(void *)(a4 + 248) = v346;
    unint64_t v356 = *(double **)(a4 + 200);
    unint64_t v355 = *(void *)(a4 + 208);
    double v357 = v290 + *(v356 - 1);
    if ((unint64_t)v356 >= v355)
    {
      uint64_t v359 = (double *)*v76;
      uint64_t v360 = ((char *)v356 - (unsigned char *)*v76) >> 3;
      unint64_t v361 = v360 + 1;
      if ((unint64_t)(v360 + 1) >> 61) {
        goto LABEL_471;
      }
      uint64_t v362 = v355 - (void)v359;
      if (v362 >> 2 > v361) {
        unint64_t v361 = v362 >> 2;
      }
      if ((unint64_t)v362 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v363 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v363 = v361;
      }
      if (v363)
      {
        unint64_t v364 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v363);
        uint64_t v359 = *(double **)(a4 + 192);
        unint64_t v356 = *(double **)(a4 + 200);
      }
      else
      {
        unint64_t v364 = 0;
      }
      uint64_t v365 = (double *)&v364[8 * v360];
      double *v365 = v357;
      unint64_t v358 = v365 + 1;
      while (v356 != v359)
      {
        uint64_t v366 = *((void *)v356-- - 1);
        *((void *)v365-- - 1) = v366;
      }
      *(void *)(a4 + 192) = v365;
      *(void *)(a4 + 200) = v358;
      *(void *)(a4 + 208) = &v364[8 * v363];
      if (v359) {
        operator delete(v359);
      }
    }
    else
    {
      double *v356 = v357;
      unint64_t v358 = v356 + 1;
    }
    *(void *)(a4 + 200) = v358;
  }
  if (vabdd_f64(v287, v424) >= 0.0000001)
  {
    unint64_t v368 = *(void **)(a4 + 216);
    uint64_t v367 = *(void **)(a4 + 224);
    unint64_t v369 = *(void *)(a4 + 232);
    if ((unint64_t)v367 < v369)
    {
      void *v367 = *v368;
      unint64_t v370 = v367 + 1;
LABEL_426:
      *(void *)(a4 + 224) = v370;
      uint64_t v381 = *(void **)(a4 + 240);
      uint64_t v380 = *(void **)(a4 + 248);
      unint64_t v382 = *(void *)(a4 + 256);
      if ((unint64_t)v380 < v382)
      {
        void *v380 = *v381;
        uint64_t v383 = v380 + 1;
LABEL_442:
        *(void *)(a4 + 248) = v383;
        uint64_t v394 = *(char **)(a4 + 200);
        unint64_t v393 = *(void *)(a4 + 208);
        if ((unint64_t)v394 < v393)
        {
          *(void *)uint64_t v394 = 0x4010000000000000;
          unint64_t v395 = v394 + 8;
LABEL_458:
          *(void *)(a4 + 200) = v395;
          goto LABEL_459;
        }
        uint64_t v396 = (char *)*v76;
        uint64_t v397 = (v394 - (unsigned char *)*v76) >> 3;
        unint64_t v398 = v397 + 1;
        if (!((unint64_t)(v397 + 1) >> 61))
        {
          uint64_t v399 = v393 - (void)v396;
          if (v399 >> 2 > v398) {
            unint64_t v398 = v399 >> 2;
          }
          if ((unint64_t)v399 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v400 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v400 = v398;
          }
          if (v400)
          {
            uint64_t v401 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v400);
            uint64_t v396 = *(char **)(a4 + 192);
            uint64_t v394 = *(char **)(a4 + 200);
          }
          else
          {
            uint64_t v401 = 0;
          }
          double v402 = &v401[8 * v397];
          unint64_t v403 = &v401[8 * v400];
          *(void *)double v402 = 0x4010000000000000;
          unint64_t v395 = v402 + 8;
          while (v394 != v396)
          {
            uint64_t v404 = *((void *)v394 - 1);
            v394 -= 8;
            *((void *)v402 - 1) = v404;
            v402 -= 8;
          }
          *(void *)(a4 + 192) = v402;
          *(void *)(a4 + 200) = v395;
          *(void *)(a4 + 208) = v403;
          if (v396) {
            operator delete(v396);
          }
          goto LABEL_458;
        }
LABEL_471:
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v384 = v380 - v381;
      unint64_t v385 = v384 + 1;
      if (!((unint64_t)(v384 + 1) >> 61))
      {
        uint64_t v386 = v382 - (void)v381;
        if (v386 >> 2 > v385) {
          unint64_t v385 = v386 >> 2;
        }
        if ((unint64_t)v386 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v387 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v387 = v385;
        }
        if (v387)
        {
          uint64_t v388 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v387);
          double v389 = *(void **)(a4 + 240);
          uint64_t v380 = *(void **)(a4 + 248);
        }
        else
        {
          uint64_t v388 = 0;
          double v389 = *(void **)(a4 + 240);
        }
        unint64_t v390 = &v388[8 * v384];
        v391 = &v388[8 * v387];
        *(void *)unint64_t v390 = *v381;
        uint64_t v383 = v390 + 8;
        while (v380 != v389)
        {
          uint64_t v392 = *--v380;
          *((void *)v390 - 1) = v392;
          v390 -= 8;
        }
        *(void *)(a4 + 240) = v390;
        *(void *)(a4 + 248) = v383;
        *(void *)(a4 + 256) = v391;
        if (v389) {
          operator delete(v389);
        }
        goto LABEL_442;
      }
LABEL_470:
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v371 = v367 - v368;
    unint64_t v372 = v371 + 1;
    if (!((unint64_t)(v371 + 1) >> 61))
    {
      uint64_t v373 = v369 - (void)v368;
      if (v373 >> 2 > v372) {
        unint64_t v372 = v373 >> 2;
      }
      if ((unint64_t)v373 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v374 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v374 = v372;
      }
      if (v374)
      {
        double v375 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v374);
        double v376 = *(void **)(a4 + 216);
        uint64_t v367 = *(void **)(a4 + 224);
      }
      else
      {
        double v375 = 0;
        double v376 = *(void **)(a4 + 216);
      }
      unint64_t v377 = &v375[8 * v371];
      uint64_t v378 = &v375[8 * v374];
      *(void *)unint64_t v377 = *v368;
      unint64_t v370 = v377 + 8;
      while (v367 != v376)
      {
        uint64_t v379 = *--v367;
        *((void *)v377 - 1) = v379;
        v377 -= 8;
      }
      *(void *)(a4 + 216) = v377;
      *(void *)(a4 + 224) = v370;
      *(void *)(a4 + 232) = v378;
      if (v376) {
        operator delete(v376);
      }
      goto LABEL_426;
    }
LABEL_469:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
LABEL_459:
  if (!PCMatrix44Tmpl<double>::isIdentity(v420))
  {
    uint64_t v405 = *(double **)(a4 + 216);
    uint64_t v406 = *(void *)(a4 + 224) - (void)v405;
    if (v406)
    {
      unint64_t v407 = v406 >> 3;
      unint64_t v408 = (double *)*v62;
      if (v407 <= 1) {
        unint64_t v407 = 1;
      }
      do
      {
        double v409 = *((double *)&v437 + 1) + *v405 * *(double *)&v436 + *v408 * *((double *)&v436 + 1);
        double v410 = (*((double *)&v433 + 1) + *v405 * *(double *)&v432 + *v408 * *((double *)&v432 + 1)) / v409;
        *uint64_t v405 = (*((double *)&v431 + 1) + *v405 * *(double *)&v430 + *v408 * *((double *)&v430 + 1)) / v409;
        ++v405;
        *v408++ = v410;
        --v407;
      }
      while (v407);
    }
  }
  BOOL v411 = 1;
  *(_WORD *)(a4 + 185) = 1;
  if (v421) {
    BOOL v411 = PCMatrix44Tmpl<double>::isIdentity(v421) || !OZShape::checkWindingOrder(v413, a2, a3, v421, 0);
  }
  *(unsigned char *)(a4 + 187) = v411;
  return a4;
}

uint64_t OZShape::isRect(uint64_t a1, CMTime *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)(a1 + 472);
  if (!v2) {
    return 0;
  }
  if (((v2[1] - *v2) & 0x7FFFFFFF0) != 0x40) {
    return 0;
  }
  double v4 = (OZChannelCurve *)(a1 + 208);
  if (!OZChannelCurve::isCurveFlattened((OZChannelCurve *)(a1 + 208))) {
    return 0;
  }
  long long v17 = 0u;
  *(_OWORD *)long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  OZChannelCurve::getVerticesList(v4, &v13);
  double v5 = v14;
  if (v14 == v13)
  {
    double v8 = 0.0;
    double v9 = 0.0;
  }
  else
  {
    unint64_t v6 = 0;
    unsigned int v7 = 1;
    double v5 = v13;
    do
    {
      OZChannelCurve::getVertexValue((uint64_t)v4, *(char **)&v5[16 * v6], *(char **)&v5[16 * v6 + 8], a2, &v18[v6 - 2], (double *)&v15 + v6);
      unint64_t v6 = v7;
      double v5 = v13;
      ++v7;
    }
    while (v6 < (v14 - v13) >> 4);
    double v8 = *((double *)&v17 + 1);
    double v9 = *(double *)&v17;
  }
  if (vabdd_f64(v9, v8) >= 0.0000001)
  {
    if (vabdd_f64(v9, v18[1]) >= 0.0000001
      || vabdd_f64(v8, v18[0]) >= 0.0000001
      || vabdd_f64(*(double *)&v15, *((double *)&v15 + 1)) >= 0.0000001)
    {
      goto LABEL_21;
    }
    double v12 = *(double *)&v16;
  }
  else
  {
    if (vabdd_f64(v18[0], v18[1]) >= 0.0000001 || vabdd_f64(*((double *)&v15 + 1), *(double *)&v16) >= 0.0000001) {
      goto LABEL_21;
    }
    double v12 = *(double *)&v15;
  }
  if (vabdd_f64(v12, *((double *)&v16 + 1)) < 0.0000001)
  {
    uint64_t v10 = 1;
    goto LABEL_22;
  }
LABEL_21:
  uint64_t v10 = 0;
LABEL_22:
  if (v5)
  {
    double v14 = v5;
    operator delete(v5);
  }
  return v10;
}

void sub_1B7E2A92C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

uint64_t OZShape::getSamples(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  double v8 = (PCMutex *)(a1 + 8);
  uint64_t v19 = a1 + 8;
  PCMutex::lock((PCMutex *)(a1 + 8));
  char v20 = 1;
  long long v9 = *(_OWORD *)(a2 + 48);
  v16[2] = *(_OWORD *)(a2 + 32);
  void v16[3] = v9;
  v16[4] = *(_OWORD *)(a2 + 64);
  long long v10 = *(_OWORD *)(a2 + 16);
  v16[0] = *(_OWORD *)a2;
  v16[1] = v10;
  uint64_t v11 = *(CGColorSpace **)(a2 + 80);
  long long v17 = v11;
  if (v11) {
    PCCFRefTraits<CGColorSpace *>::retain(v11);
  }
  int v18 = *(_DWORD *)(a2 + 88);
  uint64_t CurrentRenderParams = (int *)OZShape::getCurrentRenderParams(a1, (uint64_t)v16);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v17);
  if (OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E4F1FA48], 0.0) == 4
    || fabs((double)CurrentRenderParams[45]) < 0.0000001)
  {
    uint64_t Contour = OZShape::getContour((OZShape *)a1, (const OZShapeRenderState *)a2, (OZShapeRenderParams *)CurrentRenderParams);
  }
  else
  {
    uint64_t Contour = OZShape::getRenderContourWithRoundness(a1, a2, (uint64_t)CurrentRenderParams, 0);
  }
  uint64_t v14 = Contour;
  if ((char *)(Contour + 216) != a3) {
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(a3, *(char **)(Contour + 216), *(void *)(Contour + 224), (uint64_t)(*(void *)(Contour + 224) - *(void *)(Contour + 216)) >> 3);
  }
  if ((char *)(v14 + 240) != a4) {
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(a4, *(char **)(v14 + 240), *(void *)(v14 + 248), (uint64_t)(*(void *)(v14 + 248) - *(void *)(v14 + 240)) >> 3);
  }
  return PCMutex::unlock(v8);
}

void sub_1B7E2AAB4(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  PCLockSentry<PCMutex>::~PCLockSentry(v2 - 80);
  _Unwind_Resume(a1);
}

void std::vector<OZVertex2D>::push_back[abi:ne180100](void **a1, _OWORD *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unsigned int v7 = *(_OWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = ((char *)v7 - (unsigned char *)*a1) >> 4;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - (void)*a1;
    if (v11 >> 3 > v10) {
      unint64_t v10 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v4, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[16 * v9];
    long long v15 = &v13[16 * v12];
    *(_OWORD *)uint64_t v14 = *a2;
    double v8 = v14 + 16;
    long long v17 = (char *)*a1;
    long long v16 = (char *)a1[1];
    if (v16 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v16 - 1);
        v14 -= 16;
        v16 -= 16;
      }
      while (v16 != v17);
      long long v16 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v8;
    a1[2] = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *unsigned int v7 = *a2;
    double v8 = v7 + 1;
  }
  a1[1] = v8;
}

void OZShapeContour::OZShapeContour(OZShapeContour *this, CMTime *a2)
{
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)((char *)this + 40) = _Q0;
  *((void *)this + 22) = 0x3FF0000000000000;
  *((void *)this + 17) = 0x3FF0000000000000;
  *((void *)this + 12) = 0x3FF0000000000000;
  *((void *)this + 7) = 0x3FF0000000000000;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  long long v7 = *(_OWORD *)&a2->value;
  *((void *)this + 2) = a2->epoch;
  *(_OWORD *)this = v7;
  *((void *)this + 22) = 0x3FF0000000000000;
  *((void *)this + 17) = 0x3FF0000000000000;
  *((void *)this + 12) = 0x3FF0000000000000;
  *((void *)this + 7) = 0x3FF0000000000000;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_DWORD *)this + 46) = 0x1000000;
}

void OZShapeReparametrizedContour::OZShapeReparametrizedContour(OZShapeReparametrizedContour *this, CMTime *a2)
{
  CMTime v3 = *a2;
  OZShapeContour::OZShapeContour(this, &v3);
  *(void *)(v2 + 464) = 0;
  *(_OWORD *)(v2 + 432) = 0u;
  *(_OWORD *)(v2 + 448) = 0u;
  *(_OWORD *)(v2 + 400) = 0u;
  *(_OWORD *)(v2 + 416) = 0u;
  operator new();
}

void sub_1B7E2AD14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  MEMORY[0x1BA9BFBA0](v11, 0x10E1C4011F1C4E7);
  uint64_t v13 = v10[56];
  if (v13)
  {
    v10[57] = v13;
    operator delete(v13);
  }
  uint64_t v14 = v10 + 50;
  long long v15 = v10[53];
  if (v15)
  {
    v10[54] = v15;
    operator delete(v15);
  }
  long long v16 = *v14;
  if (*v14)
  {
    v10[51] = v16;
    operator delete(v16);
  }
  OZShapeContour::~OZShapeContour((OZShapeContour *)v10);
  _Unwind_Resume(a1);
}

uint64_t OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl::getInstance(OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl *this)
{
  if (!OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl::_OZShapeReparametrizedContour_contour) {
    operator new();
  }
  return OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl::_OZShapeReparametrizedContour_contour;
}

void sub_1B7E2ADE0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

void OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl::OZShapeReparametrizedContour_contourImpl(OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl *this)
{
}

void sub_1B7E2AECC(_Unwind_Exception *a1)
{
  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

_OWORD *std::vector<PCVector2<double>>::__assign_with_size[abi:ne180100]<PCVector2<double>*,PCVector2<double>*>(void *a1, long long *a2, long long *a3, unint64_t a4)
{
  unint64_t v6 = a2;
  uint64_t v8 = a1[2];
  double result = (_OWORD *)*a1;
  if (a4 > (v8 - (uint64_t)result) >> 4)
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__vallocate[abi:ne180100](a1, v11);
    uint64_t v13 = (_OWORD *)a1[1];
    unint64_t v12 = (_OWORD **)(a1 + 1);
    double result = v13;
    uint64_t v14 = (char *)v13;
    if (v6 != a3)
    {
      uint64_t v14 = (char *)result;
      do
      {
        long long v15 = *v6++;
        *(_OWORD *)uint64_t v14 = v15;
        v14 += 16;
      }
      while (v6 != a3);
    }
LABEL_26:
    int64_t v25 = v14 - (char *)result;
    goto LABEL_27;
  }
  long long v17 = (_OWORD *)a1[1];
  unint64_t v12 = (_OWORD **)(a1 + 1);
  long long v16 = v17;
  unint64_t v18 = v17 - result;
  if (v18 >= a4)
  {
    uint64_t v14 = (char *)result;
    if (a2 != a3)
    {
      double v26 = result;
      do
      {
        long long v27 = *v6++;
        *v26++ = v27;
        v14 += 16;
      }
      while (v6 != a3);
    }
    goto LABEL_26;
  }
  uint64_t v19 = &a2[v18];
  if (v16 != result)
  {
    uint64_t v20 = 16 * v18;
    do
    {
      long long v21 = *v6++;
      *result++ = v21;
      v20 -= 16;
    }
    while (v20);
    double result = *v12;
  }
  double v22 = (char *)result;
  if (v19 != a3)
  {
    double v22 = (char *)result;
    double v23 = result;
    do
    {
      long long v24 = *v19++;
      *v23++ = v24;
      v22 += 16;
    }
    while (v19 != a3);
  }
  int64_t v25 = v22 - (char *)result;
LABEL_27:
  *unint64_t v12 = (_OWORD *)((char *)result + v25);
  return result;
}

long double PCMatrix44Tmpl<double>::leftShear(double *a1, double a2, long double a3)
{
  double v4 = a2;
  if (a2 != 0.0)
  {
    if (a2 < 0.0)
    {
      do
        double v4 = v4 + 3.14159265;
      while (v4 < 0.0);
    }
    for (; v4 > 3.14159265; double v4 = v4 + -3.14159265)
      ;
    double v6 = 1.56556034;
    if (v4 >= 1.57603231 || v4 <= 1.56556034) {
      double v6 = v4;
    }
    double v4 = tan(v6);
  }
  if (a3 != 0.0)
  {
    for (; a3 < 0.0; a3 = a3 + 3.14159265)
      ;
    for (; a3 > 3.14159265; a3 = a3 + -3.14159265)
      ;
    double v8 = 1.56556034;
    if (a3 >= 1.57603231 || a3 <= 1.56556034) {
      double v8 = a3;
    }
    a3 = tan(v8);
  }
  double v10 = a1[4];
  double v11 = a1[5];
  double v12 = a1[1];
  double v13 = *a1 + v4 * v10;
  double v14 = a1[6];
  double v15 = a1[7];
  double v16 = a1[2];
  double v17 = a1[3];
  a1[4] = v10 + a3 * *a1;
  a1[5] = v11 + a3 * v12;
  long double result = v14 + a3 * v16;
  a1[6] = result;
  a1[7] = v15 + a3 * v17;
  *a1 = v13;
  a1[1] = v12 + v4 * v11;
  a1[2] = v16 + v4 * v14;
  a1[3] = v17 + v4 * v15;
  return result;
}

BOOL PCMatrix44Tmpl<double>::invert(double *a1, double *a2, double a3)
{
  double v3 = a2[14];
  double v4 = a2[15];
  double v5 = a2[10];
  double v6 = a2[11];
  double v7 = v5 * v4 - v3 * v6;
  double v9 = a2[8];
  double v8 = a2[9];
  double v10 = a2[12];
  double v11 = a2[13];
  double v12 = v4 * v8 - v6 * v11;
  double v13 = v3 * v8 - v5 * v11;
  double v14 = v4 * v9 - v6 * v10;
  double v15 = v3 * v9 - v5 * v10;
  double v16 = v11 * v9 - v8 * v10;
  double v17 = a2[4];
  double v18 = a2[5];
  double v19 = a2[6];
  double v20 = a2[7];
  double v21 = v7 * v18 - v12 * v19 + v13 * v20;
  double v22 = v15 * v20 + v7 * v17 - v19 * v14;
  double v23 = v16 * v20 + v12 * v17 - v18 * v14;
  double v24 = v19 * v16 + v13 * v17 - v18 * v15;
  double v25 = *a2;
  double v26 = a2[1];
  double v27 = a2[2];
  double v28 = a2[3];
  double v29 = v23 * v27 + v21 * *a2 - v26 * v22;
  double v30 = v29 - v24 * v28;
  BOOL v31 = vabdd_f64(v29, v24 * v28) >= a3 && v30 != 0.0;
  if (v31)
  {
    double v32 = v4 * v19 - v3 * v20;
    double v33 = v4 * v18 - v11 * v20;
    double v45 = v3 * v18 - v11 * v19;
    double v34 = v4 * v17 - v10 * v20;
    double v35 = v3 * v17 - v10 * v19;
    double v36 = v11 * v17 - v10 * v18;
    double v37 = v6 * v19 - v5 * v20;
    double v38 = v6 * v18 - v8 * v20;
    double v39 = v5 * v18 - v8 * v19;
    double v40 = v6 * v17 - v9 * v20;
    double v41 = v5 * v17 - v9 * v19;
    double v42 = v8 * v17 - v9 * v18;
    double v43 = 1.0 / v30;
    *a1 = v21 * v43;
    a1[1] = -((v7 * v26 - v12 * v27 + v13 * v28) * v43);
    a1[2] = (v32 * v26 - v33 * v27 + v45 * v28) * v43;
    a1[3] = -((v37 * v26 - v38 * v27 + v39 * v28) * v43);
    a1[4] = -(v22 * v43);
    a1[5] = (v7 * v25 - v14 * v27 + v15 * v28) * v43;
    a1[6] = -((v25 * v32 - v34 * v27 + v35 * v28) * v43);
    a1[7] = (v25 * v37 - v40 * v27 + v41 * v28) * v43;
    a1[8] = v23 * v43;
    a1[9] = -((v12 * v25 - v14 * v26 + v16 * v28) * v43);
    a1[10] = (v25 * v33 - v26 * v34 + v36 * v28) * v43;
    a1[11] = -((v25 * v38 - v26 * v40 + v42 * v28) * v43);
    a1[12] = -(v24 * v43);
    a1[13] = (v13 * v25 - v15 * v26 + v16 * v27) * v43;
    a1[14] = -((v45 * v25 - v26 * v35 + v36 * v27) * v43);
    a1[15] = (v39 * v25 - v26 * v41 + v42 * v27) * v43;
  }
  return v31;
}

void OZShape::calcIntersectionForOutlineAtPoint(uint64_t a1, CMTime *a2, _DWORD *a3, float64x2_t *a4, double a5, double a6)
{
  double v11 = a5 + -0.025;
  double v122 = 0.0;
  double v123 = 0.0;
  double v120 = 0.0;
  double v121 = 0.0;
  double v118 = 0.0;
  double v119 = 0.0;
  CMTime v117 = *a2;
  double v12 = (OZChannelCurve *)(a1 + 208);
  double MaxParametricValue = OZChannelCurve::getMaxParametricValue((OZChannelCurve *)(a1 + 208), &v117);
  double v14 = vabdd_f64(a5, OZChannelCurve::getMinParametricValue(v12, &v117));
  if (v14 < 0.0000001 && a3[42]) {
    double v11 = MaxParametricValue + 0.975;
  }
  double v15 = vabdd_f64(a5, MaxParametricValue);
  double v16 = a5;
  if (v15 < 0.0000001)
  {
    if (a3[42]) {
      double v16 = MaxParametricValue;
    }
    else {
      double v16 = a5;
    }
  }
  Float64 v17 = v16 + 0.025;
  OZChannelCurve::getCurveValueWithParameter(v12, &v117, v11, &v123, &v122);
  OZChannelCurve::getCurveValueWithParameter(v12, &v117, a5, &v121, &v120);
  OZChannelCurve::getCurveValueWithParameter(v12, &v117, v17, &v119, &v118);
  double v18 = v121 - v123;
  double v19 = v18 * (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
  double v20 = v120 - v122;
  double v21 = v119 - v121;
  double v22 = v21 * (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
  double v23 = sqrt(v19 * v19 + v20 * v20);
  double v24 = -v20 / v23;
  double v94 = v23;
  double v95 = v20;
  double v25 = v19 / v23;
  double v26 = sqrt(v22 * v22 + (v118 - v120) * (v118 - v120));
  double v99 = v25;
  double v101 = -(v118 - v120) / v26;
  double v97 = v26;
  double v102 = v22 / v26;
  if ((a3[6] | 2) == 2)
  {
    double v91 = v15;
    double v92 = v14;
    double v93 = v22;
    double v27 = v123;
    double v98 = v24;
    double v28 = v24 * a6;
    double v29 = v27 + v24 * a6 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
    double v30 = v121;
    double v31 = v99 * a6;
    double v32 = v99 * a6 + v122;
    v116.f64[0] = v29;
    v116.f64[1] = v32;
    double v33 = v30 + v28 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1) - v29;
    double v34 = v99 * a6 + v120 - v32;
    double v114 = v33;
    double v115 = v34;
    double v35 = sqrt(v33 * v33 + v34 * v34);
    if (v35 <= -0.000000100000001 || v35 >= 0.000000100000001)
    {
      double v114 = v33 / v35;
      double v115 = v34 / v35;
    }
    double v36 = v121;
    double v37 = v101 * a6;
    double v38 = v36 + v101 * a6 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
    double v39 = v119;
    double v90 = a6;
    double v40 = v102 * a6;
    double v41 = v40 + v120;
    v113[0] = v38;
    v113[1] = v40 + v120;
    double v88 = v40;
    double v89 = v37;
    double v42 = v39 + v37 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1) - v38;
    double v43 = v40 + v118 - v41;
    double v111 = v42;
    double v112 = v43;
    double v44 = sqrt(v42 * v42 + v43 * v43);
    if (v44 <= -0.000000100000001 || v44 >= 0.000000100000001)
    {
      double v111 = v42 / v44;
      double v112 = v43 / v44;
    }
    float64x2_t v110 = 0uLL;
    if (a3[6] || !PCAlgorithm::findIntersection(v116.f64, &v114, v113, &v111, v110.f64))
    {
      a6 = v90;
      double v45 = v20 / v94 * v90;
      double v46 = v121;
      v109.f64[0] = v46 + v31 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
      v109.f64[1] = v45 + v120;
      float64x2_t v47 = PCRect<double>::operator|=(a4, &v109);
      double v48 = v121;
      v109.f64[0] = v48
                  + (v28 + v31) / (*(double (**)(uint64_t, float64x2_t))(*(void *)a1 + 176))(a1, v47);
      v109.f64[1] = v45 + v31 + v120;
      float64x2_t v49 = PCRect<double>::operator|=(a4, &v109);
      double v50 = v121;
      v109.f64[0] = v50
                  + (v31 - v28) / (*(double (**)(uint64_t, float64x2_t))(*(void *)a1 + 176))(a1, v49);
      v109.f64[1] = v45 + v120 - v31;
      PCRect<double>::operator|=(a4, &v109);
    }
    else
    {
      PCRect<double>::operator|=(a4, &v110);
      a6 = v90;
    }
    double v51 = -a6;
    double v52 = v123;
    double v53 = -(a6 * v98);
    double v54 = v52 + v53 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
    double v55 = v121;
    double v56 = v122 - a6 * v99;
    v109.f64[0] = v54;
    v109.f64[1] = v56;
    double v57 = v55 + v53 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1) - v54;
    double v58 = v120 - a6 * v99 - v56;
    double v107 = v57;
    double v108 = v58;
    double v59 = sqrt(v57 * v57 + v58 * v58);
    if (v59 <= -0.000000100000001 || v59 >= 0.000000100000001)
    {
      double v107 = v57 / v59;
      double v108 = v58 / v59;
    }
    double v60 = v121;
    double v61 = v101 * v51;
    double v62 = v60 + v101 * v51 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
    double v63 = v119;
    double v64 = v102 * v51 + v120;
    v106[0] = v62;
    v106[1] = v64;
    double v65 = v63 + v101 * v51 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1) - v62;
    double v66 = v102 * v51 + v118 - v64;
    double v104 = v65;
    double v105 = v66;
    double v67 = sqrt(v65 * v65 + v66 * v66);
    if (v67 <= -0.000000100000001 || v67 >= 0.000000100000001)
    {
      double v104 = v65 / v67;
      double v105 = v66 / v67;
    }
    double v22 = v93;
    if (a3[6] || !PCAlgorithm::findIntersection(v109.f64, &v107, v106, &v104, v110.f64))
    {
      double v69 = -v93 / v97 * v51;
      double v70 = v121;
      v103.f64[0] = v70 + v69 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
      v103.f64[1] = v61 + v120;
      float64x2_t v71 = PCRect<double>::operator|=(a4, &v103);
      double v72 = v121;
      v103.f64[0] = v72
                  + (v61 + v69) / (*(double (**)(uint64_t, float64x2_t))(*(void *)a1 + 176))(a1, v71);
      v103.f64[1] = v61 + v102 * v51 + v120;
      PCRect<double>::operator|=(a4, &v103);
      double v73 = v121;
      v103.f64[0] = v73 + (v89 + v69) / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
      v103.f64[1] = v61 + v88 + v120;
      unint64_t v68 = &v103;
    }
    else
    {
      unint64_t v68 = &v110;
    }
    PCRect<double>::operator|=(a4, v68);
    double v14 = v92;
    double v15 = v91;
    double v24 = v98;
  }
  if ((a3[7] | 2) == 2 || (a3[8] | 2) == 2)
  {
    double v74 = fabs(a6);
    if (v15 < 0.0000001 && !a3[42])
    {
      double v75 = v74 * v99;
      double v76 = v121;
      double v100 = v74 * (v95 / v94);
      v116.f64[0] = v76 + v75 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
      v116.f64[1] = v100 + v120;
      PCRect<double>::operator|=(a4, &v116);
      double v96 = v121;
      double v77 = v74 * v24;
      v116.f64[0] = v96 + (v74 * v24 + v75) / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
      v116.f64[1] = v100 + v75 + v120;
      float64x2_t v78 = PCRect<double>::operator|=(a4, &v116);
      double v79 = v121;
      v116.f64[0] = v79
                  + (v75 - v77) / (*(double (**)(uint64_t, float64x2_t))(*(void *)a1 + 176))(a1, v78);
      v116.f64[1] = v100 + v120 - v75;
      PCRect<double>::operator|=(a4, &v116);
    }
    if (v14 < 0.0000001 && !a3[42])
    {
      double v80 = v74 * (-v22 / v97);
      double v81 = v74 * v101;
      double v82 = v121;
      v116.f64[0] = v82 + v80 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
      v116.f64[1] = v74 * v101 + v120;
      float64x2_t v83 = PCRect<double>::operator|=(a4, &v116);
      double v84 = v121;
      double v85 = v74 * v102;
      v116.f64[0] = v84
                  + (v81 + v80) / (*(double (**)(uint64_t, float64x2_t))(*(void *)a1 + 176))(a1, v83);
      v116.f64[1] = v81 + v85 + v120;
      float64x2_t v86 = PCRect<double>::operator|=(a4, &v116);
      double v87 = v121;
      v116.f64[0] = v87
                  + (v80 - v81) / (*(double (**)(uint64_t, float64x2_t))(*(void *)a1 + 176))(a1, v86);
      v116.f64[1] = v81 + v120 - v85;
      PCRect<double>::operator|=(a4, &v116);
    }
  }
}

void OZShape::drawOutlinePolygonsToHeliumNode(OZShape *this@<X0>, OZShapeRenderParams *a2@<X3>, uint64_t *a3@<X1>, int a4@<W2>, uint64_t a5@<X4>, int a6@<W5>, int a7@<W6>, int a8@<W7>, HGGLNode **a9@<X8>, double a10@<D0>, HGGLNode **a11, void *a12, double *a13, uint64_t *a14)
{
  double v22 = *a11;
  *a9 = *a11;
  if (v22) {
    (*(void (**)(HGGLNode *))(*(void *)v22 + 16))(v22);
  }
  if (OZShape::shouldRenderInPlace(this, a2))
  {
    HGGLNode::enableInplaceBlending(*a11);
  }
  else
  {
    if ((a6 & 1) == 0 && *((_DWORD *)a2 + 30))
    {
      if (a10 >= 0.0 && a8) {
        HGGLNode::hglEnableBlending((uint64_t)*a11, 3, 1);
      }
      goto LABEL_13;
    }
    HGGLNode::hglEnableBlending((uint64_t)*a11, 3, 1);
  }
  if (a6)
  {
    double v23 = 0;
    a3 = (uint64_t *)(a5 + 360);
    a7 = 1;
    goto LABEL_28;
  }
LABEL_13:
  double v23 = a13;
  if (a10 < 0.0)
  {
    double v24 = (HGGLNode *)HGObject::operator new(0x1B0uLL);
    HGGLNode::HGGLNode(v24, 0);
    (*(void (**)(HGGLNode *, void, void))(*(void *)v24 + 120))(v24, 0, *a12);
    (*(void (**)(void, uint64_t, uint64_t))(*(void *)*a12 + 136))(*a12, 0xFFFFFFFFLL, 4);
    HGGLNode::hglTexParameteri((char **)v24, (const char *)0xDE1, (char *)0x2801, 9729.0);
    HGGLNode::hglTexParameteri((char **)v24, (const char *)0xDE1, (char *)0x2800, 9729.0);
    HGGLNode::hglTexParameteri((char **)v24, (const char *)0xDE1, (char *)0x2802, 33071.0);
    HGGLNode::hglTexParameteri((char **)v24, (const char *)0xDE1, (char *)0x2803, 33071.0);
    HGGLNode::hglActiveTexture(v24, 192);
    double v25 = *((double *)a2 + 19);
    float v26 = *((double *)a2 + 16) * v25;
    float v27 = v25 * *((double *)a2 + 17);
    float v28 = v25 * *((double *)a2 + 18);
    BOOL v29 = v26 < 0.0;
    if (v27 < 0.0) {
      BOOL v29 = 1;
    }
    if (v28 < 0.0) {
      BOOL v29 = 1;
    }
    if (v26 > 1.0) {
      BOOL v29 = 1;
    }
    if (v27 > 1.0) {
      BOOL v29 = 1;
    }
    int v30 = v28 > 1.0 || v29;
    double v31 = (HgcShapeSoftEdgeClr *)HGObject::operator new(0x1B0uLL);
    HgcShapeSoftEdgeClr::HgcShapeSoftEdgeClr(v31);
    HGGLNode::addFragmentShader(v24, v31);
    BOOL shouldDrawSecondPassGradientInHelium = OZShape::shouldDrawSecondPassGradientInHelium(this, a4, a2);
    v33.n128_u32[0] = 1.0;
    v34.n128_u32[0] = 1.0;
    v35.n128_u32[0] = 1.0;
    v36.n128_u32[0] = 1.0;
    if (((shouldDrawSecondPassGradientInHelium | v30) & 1) == 0)
    {
      v36.n128_f32[0] = v25;
      v33.n128_f32[0] = v26;
      v34.n128_f32[0] = v27;
      v35.n128_f32[0] = v28;
    }
    (*(void (**)(HgcShapeSoftEdgeClr *, void, __n128, __n128, __n128, __n128))(*(void *)v31 + 96))(v31, 0, v33, v34, v35, v36);
    HGGLNode::hglClearToBlack(v24);
    HGGLNode::hglEnableBlending((uint64_t)v24, 3, 1);
    HGArray<__simd128_float32_t,(HGFormat)28>::HGArray((uint64_t)&v38);
  }
LABEL_28:
}

void sub_1B7E2C724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, HGArrayData *a15)
{
  HGObject::operator delete(v18);
  OZShapeVertexArrayData::~OZShapeVertexArrayData((OZShapeVertexArrayData *)&__p);
  (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
  (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
  }
  _Unwind_Resume(a1);
}

void anonymous namespace'::fillEdgeVertexArray(uint64_t *a1, double *a2, uint64_t *a3, int a4, int a5)
{
  double v11 = (HGArrayDataRef *)(a3 + 3);
  uint64_t v10 = a3[3];
  double v12 = a3 + 5;
  if (v10) {
    LODWORD(v10) = *(_DWORD *)(v10 + 8);
  }
  HGArray<__simd128_float32_t,(HGFormat)28>::reserve(a3 + 3, v10 - 1010580540 * ((unint64_t)(a1[1] - *a1) >> 3));
  uint64_t v13 = *v12;
  if (*v12) {
    LODWORD(v13) = *(_DWORD *)(v13 + 8);
  }
  HGArray<__simd128_float32_t,(HGFormat)28>::reserve(v12, v13 - 1010580540 * ((unint64_t)(a1[1] - *a1) >> 3));
  if (*(void *)v11) {
    uint64_t v16 = (OZShapeVertexArrayData *)*(unsigned int *)(*(void *)v11 + 8);
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v18 = *a1;
  uint64_t v17 = a1[1];
  if ((int)(-252645135 * ((unint64_t)(v17 - *a1) >> 3)) >= 1)
  {
    int v82 = a5;
    uint64_t v19 = 0;
    v14.i32[0] = 1115422720;
    float v20 = 0.0;
    LODWORD(v15) = vdup_lane_s32(v14, 0).u32[0];
    if (a4) {
      float v20 = 63.0;
    }
    LODWORD(v21) = 1115422720;
    *((float *)&v21 + 1) = v20;
    DWORD2(v21) = 0;
    HIDWORD(v21) = 1.0;
    *((float *)&v15 + 1) = v20;
    float v22 = 0.0;
    float v23 = 0.0;
    uint64_t v24 = 120;
    float v25 = 0.0;
    float v26 = 0.0;
    float v27 = 0.0;
    float v28 = 0.0;
    float v29 = 0.0;
    float v30 = 0.0;
    while (1)
    {
      if ((*(void *)(v18 + v24 - 120) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v31 = *(double *)(v18 + v24 - 112);
        if ((*(void *)&v31 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          double v32 = *(double *)(v18 + v24 - 104);
          if ((*(void *)&v32 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            double v33 = *(double *)(v18 + v24 - 96);
            if ((*(void *)&v33 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
            {
              double v34 = *(double *)(v18 + v24 - 88);
              if ((*(void *)&v34 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                double v35 = *(double *)(v18 + v24 - 80);
                if ((*(void *)&v35 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                {
                  double v36 = *(double *)(v18 + v24 - 72);
                  if ((*(void *)&v36 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    double v37 = *(double *)(v18 + v24 - 64);
                    if ((*(void *)&v37 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                    {
                      double v38 = *(double *)(v18 + v24 - 56);
                      if ((*(void *)&v38 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                      {
                        double v39 = *(double *)(v18 + v24 - 48);
                        if ((*(void *)&v39 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                        {
                          double v40 = *(double *)(v18 + v24 - 40);
                          if ((*(void *)&v40 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                          {
                            double v41 = *(double *)(v18 + v24 - 32);
                            if ((*(void *)&v41 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                            {
                              double v42 = *(double *)(v18 + v24 - 24);
                              if ((*(void *)&v42 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                              {
                                double v43 = *(double *)(v18 + v24 - 16);
                                if ((*(void *)&v43 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL) {
                                  break;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      float v54 = v30;
      float v55 = v29;
      float v56 = v28;
      float v57 = v27;
      float v50 = v26;
      float v51 = v25;
      float v52 = v23;
      float v53 = v22;
LABEL_41:
      ++v19;
      v24 += 136;
      float v22 = v53;
      float v23 = v52;
      float v25 = v51;
      float v26 = v50;
      float v27 = v57;
      float v28 = v56;
      float v29 = v55;
      float v30 = v54;
      if (v19 >= (int)(-252645135 * ((unint64_t)(v17 - v18) >> 3))) {
        goto LABEL_59;
      }
    }
    long long v81 = v21;
    double v44 = *(double *)(v18 + v24 - 8);
    if ((*(void *)&v44 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      float v54 = v30;
      float v55 = v29;
      float v56 = v28;
      float v57 = v27;
      float v50 = v26;
      float v51 = v25;
      float v52 = v23;
      float v53 = v22;
LABEL_58:
      long long v21 = v81;
      goto LABEL_41;
    }
    long long v80 = v15;
    double v45 = *(double *)(v18 + v24);
    if ((*(void *)&v45 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      float v54 = v30;
      float v55 = v29;
      float v56 = v28;
      float v57 = v27;
      float v50 = v26;
      float v51 = v25;
      float v52 = v23;
      float v53 = v22;
LABEL_57:
      long long v15 = v80;
      goto LABEL_58;
    }
    *(float *)&unsigned int v46 = *(double *)(v18 + v24 - 120);
    float v47 = v31;
    *(void *)&v86[0] = __PAIR64__(LODWORD(v47), v46);
    float v48 = v32;
    *(float *)&unsigned int v49 = v33;
    *((void *)&v86[0] + 1) = __PAIR64__(v49, LODWORD(v48));
    float v74 = *(float *)&v49;
    float v50 = v34;
    float v51 = v35;
    *(void *)&long long v85 = __PAIR64__(LODWORD(v51), LODWORD(v50));
    float v52 = v36;
    float v53 = v37;
    *((void *)&v85 + 1) = __PAIR64__(LODWORD(v53), LODWORD(v52));
    float v54 = v38;
    float v55 = v39;
    *(void *)&long long v84 = __PAIR64__(LODWORD(v55), LODWORD(v54));
    float v56 = v40;
    float v57 = v41;
    *((void *)&v84 + 1) = __PAIR64__(LODWORD(v57), LODWORD(v56));
    float v58 = v42;
    float v59 = v43;
    *(void *)&long long v83 = __PAIR64__(LODWORD(v59), LODWORD(v58));
    float v60 = v44;
    float v61 = v45;
    *((void *)&v83 + 1) = __PAIR64__(LODWORD(v61), LODWORD(v60));
    if (v26 == *(float *)&v46
      && v25 == v47
      && v23 == v48
      && v22 == v74
      && v30 == v58
      && v29 == v59
      && v28 == v60
      && v27 == v61)
    {
      if (a2)
      {
        PCMatrix44Tmpl<double>::transform<float>(a2, (float *)&v85, (uint64_t)&v85);
        PCMatrix44Tmpl<double>::transform<float>(a2, (float *)&v84, (uint64_t)&v84);
      }
      long long v75 = v85;
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v75;
      if (v82)
      {
        float v62 = *((float *)&v85 + 3);
LABEL_53:
        *(float *)&long long v68 = v62 * 63.0;
        *((float *)&v68 + 1) = v62 * 63.0;
        *((float *)&v68 + 2) = v62 * 0.0;
        *((float *)&v68 + 3) = v62;
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12) = v68;
        long long v77 = v84;
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v77;
        *(float32x2_t *)&long long v69 = vmul_n_f32(*(float32x2_t *)&v80, *((float *)&v84 + 3));
        *((float *)&v69 + 2) = *((float *)&v84 + 3) * 0.0;
        HIDWORD(v69) = HIDWORD(v84);
        long long v78 = v69;
LABEL_56:
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12) = v78;
        uint64_t v18 = *a1;
        uint64_t v17 = a1[1];
        goto LABEL_57;
      }
      double v64 = (long long *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12);
      long long v65 = xmmword_1B83887C0;
    }
    else
    {
      uint64_t v63 = a3[3];
      if (v63) {
        uint64_t v16 = (OZShapeVertexArrayData *)*(unsigned int *)(v63 + 8);
      }
      else {
        uint64_t v16 = 0;
      }
      if (a2)
      {
        PCMatrix44Tmpl<double>::transform<float>(a2, (float *)v86, (uint64_t)v86);
        PCMatrix44Tmpl<double>::transform<float>(a2, (float *)&v85, (uint64_t)&v85);
        PCMatrix44Tmpl<double>::transform<float>(a2, (float *)&v84, (uint64_t)&v84);
        PCMatrix44Tmpl<double>::transform<float>(a2, (float *)&v83, (uint64_t)&v83);
      }
      long long v76 = v86[0];
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v76;
      if (v82)
      {
        *(float *)&long long v66 = *((float *)v86 + 3) * 63.0;
        *((float *)&v66 + 1) = *((float *)v86 + 3) * 63.0;
        *((float *)&v66 + 2) = *((float *)v86 + 3) * 0.0;
        HIDWORD(v66) = HIDWORD(v86[0]);
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12) = v66;
        long long v70 = v83;
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v70;
        *(float32x2_t *)&long long v67 = vmul_n_f32(*(float32x2_t *)&v80, *((float *)&v83 + 3));
        *((float *)&v67 + 2) = *((float *)&v83 + 3) * 0.0;
        HIDWORD(v67) = HIDWORD(v83);
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12) = v67;
        long long v71 = v85;
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v71;
        float v62 = *((float *)&v85 + 3);
        goto LABEL_53;
      }
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12) = xmmword_1B83887C0;
      long long v72 = v83;
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v72;
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12) = v81;
      long long v73 = v85;
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v73;
      double v64 = (long long *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12);
      long long v65 = xmmword_1B83887C0;
    }
    long long *v64 = v65;
    long long v79 = v84;
    *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v79;
    long long v78 = v81;
    goto LABEL_56;
  }
LABEL_59:
}

void OZShapeVertexArrayData::~OZShapeVertexArrayData(OZShapeVertexArrayData *this)
{
  uint64_t v2 = *((void *)this + 5);
  if (v2) {
    HGArrayData::Release(v2);
  }
  uint64_t v3 = *((void *)this + 3);
  if (v3) {
    HGArrayData::Release(v3);
  }
  double v4 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v4;
    operator delete(v4);
  }
}

void OZShape::computeOpenStroke(uint64_t a1, const CMTime *a2, uint64_t a3, void *a4, double *a5, int a6, int a7, double a8)
{
  uint64_t v202 = 0x3FF0000000000000;
  uint64_t v199 = 0x3FF0000000000000;
  uint64_t v196 = 0x3FF0000000000000;
  double v193 = 1.0;
  long long v194 = 0u;
  long long v195 = 0u;
  long long v197 = 0u;
  long long v198 = 0u;
  long long v200 = 0u;
  long long v201 = 0u;
  *(void *)&v192[40] = 0x3FF0000000000000;
  *(void *)uint64_t v192 = 0x3FF0000000000000;
  *(void *)&v189[40] = 0x3FF0000000000000;
  *(void *)unint64_t v189 = 0x3FF0000000000000;
  memset(&v189[8], 0, 32);
  float64x2_t v190 = 0u;
  long long v191 = 0u;
  memset(&v192[8], 0, 32);
  double v9 = a8 * 0.5;
  BOOL v10 = a8 * 0.5 < 4.0;
  BOOL v11 = a8 * 0.5 <= 4.0;
  double v12 = a8 * 0.5 * 0.25 + 1.0;
  double v13 = a8 * 0.5 * 0.4375 + 0.25;
  if (v10 || v9 == 4.0) {
    double v14 = v12;
  }
  else {
    double v14 = 2.0;
  }
  if (v11) {
    double v15 = v13;
  }
  else {
    double v15 = v9 + -2.0;
  }
  if (a4[28] == a4[27])
  {
    a4[43] = a4[42];
  }
  else
  {
    if (*(unsigned char *)(a3 + 1195))
    {
      a4[43] = a4[42];
      a4[46] = a4[45];
    }
    if (*(unsigned char *)(a3 + 13))
    {
      PCMatrix44Tmpl<double>::leftShear((double *)v189, *(double *)(a3 + 264), *(long double *)(a3 + 272));
      double v23 = *(double *)(a3 + 248);
      double v22 = *(double *)(a3 + 256);
      if (v23 != 1.0)
      {
        *(float64x2_t *)unint64_t v189 = vmulq_n_f64(*(float64x2_t *)v189, v23);
        *(float64x2_t *)&v189[16] = vmulq_n_f64(*(float64x2_t *)&v189[16], v23);
      }
      if (v22 != 1.0)
      {
        *(float64x2_t *)&v189[32] = vmulq_n_f64(*(float64x2_t *)&v189[32], v22);
        float64x2_t v190 = vmulq_n_f64(v190, v22);
      }
      v184[4] = v191;
      v184[5] = *(_OWORD *)v192;
      v184[6] = *(_OWORD *)&v192[16];
      v184[7] = *(_OWORD *)&v192[32];
      v184[0] = *(_OWORD *)v189;
      v184[1] = *(_OWORD *)&v189[16];
      v184[2] = *(_OWORD *)&v189[32];
      v184[3] = v190;
      PCMatrix44Tmpl<double>::invert((double *)v184, (double *)v184, 0.0);
      if (&v193 != a5)
      {
        for (uint64_t i = 0; i != 16; i += 4)
        {
          float v25 = (_OWORD *)((char *)&v193 + i * 8);
          long long v26 = *(_OWORD *)&a5[i + 2];
          *float v25 = *(_OWORD *)&a5[i];
          v25[1] = v26;
        }
      }
      PCMatrix44Tmpl<double>::rightMult((uint64_t)&v193, (double *)v184);
    }
    else
    {
      if (&v193 != a5)
      {
        for (uint64_t j = 0; j != 16; j += 4)
        {
          float v28 = (_OWORD *)((char *)&v193 + j * 8);
          long long v29 = *(_OWORD *)&a5[j + 2];
          *float v28 = *(_OWORD *)&a5[j];
          v28[1] = v29;
        }
      }
      *(void *)&v192[40] = 0x3FF0000000000000;
      *(void *)uint64_t v192 = 0x3FF0000000000000;
      *(void *)&v189[40] = 0x3FF0000000000000;
      *(void *)unint64_t v189 = 0x3FF0000000000000;
      memset(&v189[8], 0, 32);
      float64x2_t v190 = 0u;
      long long v191 = 0u;
      memset(&v192[8], 0, 32);
    }
    OZShape::computeOutlinePolygons(a1, a4 + 42, (uint64_t)a4, a2, a3, (double *)v189, a6, a7, v9, 1, 1, 1u);
    unint64_t v187 = 0;
    std::string __p = 0;
    uint64_t v188 = 0;
    OZShape::computeOutlinePolygons(a1, (uint64_t *)&__p, (uint64_t)a4, a2, a3, (double *)v189, a6, a7, v9, 1, -1, 1u);
    uint64_t v32 = a4[42];
    uint64_t v31 = a4[43];
    double v33 = __p;
    if (v31 != v32)
    {
      double v34 = v187;
      if (v187 != __p)
      {
        for (unint64_t k = 0; k != 128; k += 64)
        {
          long long v36 = *(_OWORD *)(v32 + k);
          long long v37 = *(_OWORD *)(v32 + k + 16);
          long long v38 = *(_OWORD *)(v32 + k + 48);
          double v39 = &v184[k / 0x10];
          v39[2] = *(_OWORD *)(v32 + k + 32);
          PCSharedCount v39[3] = v38;
          *double v39 = v36;
          v39[1] = v37;
        }
        uint64_t v40 = 0;
        uint64_t v185 = *(void *)(v32 + 128);
        uint64_t v41 = v31 - 136;
        do
        {
          long long v42 = *(_OWORD *)(v41 + v40);
          long long v43 = *(_OWORD *)(v41 + v40 + 16);
          long long v44 = *(_OWORD *)(v41 + v40 + 48);
          double v45 = &v182[v40];
          v45[2] = *(_OWORD *)(v41 + v40 + 32);
          v45[3] = v44;
          _OWORD *v45 = v42;
          v45[1] = v43;
          v40 += 64;
        }
        while (v40 != 128);
        unint64_t v46 = 0;
        uint64_t v183 = *(void *)(v31 - 8);
        do
        {
          long long v47 = *(_OWORD *)&v33[v46 / 8];
          long long v48 = *(_OWORD *)&v33[v46 / 8 + 2];
          long long v49 = *(_OWORD *)&v33[v46 / 8 + 6];
          float v50 = &v180[v46 / 0x10];
          _DWORD v50[2] = *(_OWORD *)&v33[v46 / 8 + 4];
          v50[3] = v49;
          *float v50 = v47;
          v50[1] = v48;
          v46 += 64;
        }
        while (v46 != 128);
        uint64_t v51 = 0;
        uint64_t v181 = v33[16];
        float v52 = (char *)(v34 - 17);
        do
        {
          long long v53 = *(_OWORD *)&v52[v51];
          long long v54 = *(_OWORD *)&v52[v51 + 16];
          long long v55 = *(_OWORD *)&v52[v51 + 48];
          float v56 = &v178[v51];
          v56[2] = *(_OWORD *)&v52[v51 + 32];
          v56[3] = v55;
          *float v56 = v53;
          v56[1] = v54;
          v51 += 64;
        }
        while (v51 != 128);
        uint64_t v179 = *(v34 - 1);
        if (*(_DWORD *)(a3 + 32) == 1) {
          OZShape::computeRoundCaps(a1, a4 + 42, (uint64_t *)&__p, (uint64_t)a2, a3, (uint64_t)v184, (uint64_t)v182, (uint64_t)v180, v15, (uint64_t)v178, &v193, 0);
        }
        if (*(_DWORD *)(a3 + 28) == 1) {
          OZShape::computeRoundCaps(a1, a4 + 42, (uint64_t *)&__p, (uint64_t)a2, a3, (uint64_t)v184, (uint64_t)v182, (uint64_t)v180, v15, (uint64_t)v178, &v193, 1);
        }
        if (*(_DWORD *)(a3 + 32) == 2) {
          double v33 = (void *)OZShape::computeBevelCaps(v15, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, (double *)v184, (uint64_t)v182, (double *)v180, (uint64_t)v178, 0);
        }
        if (*(_DWORD *)(a3 + 28) == 2) {
          double v33 = (void *)OZShape::computeBevelCaps(v15, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, (double *)v184, (uint64_t)v182, (double *)v180, (uint64_t)v178, 1);
        }
        if (*(_DWORD *)(a3 + 32) == 3) {
          double v33 = (void *)OZShape::computeArrowCaps(v15, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, a3, (double *)v184, (uint64_t)v182, v180, (uint64_t)v178, 0);
        }
        if (*(_DWORD *)(a3 + 28) == 3) {
          double v33 = (void *)OZShape::computeArrowCaps(v15, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, a3, (double *)v184, (uint64_t)v182, v180, (uint64_t)v178, 1);
        }
        if (!*(_DWORD *)(a3 + 32)) {
          double v33 = (void *)OZShape::computeNormalCaps(v15, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, (double *)v184, (uint64_t)v182, (double *)v180, (uint64_t)v178, 0, 0);
        }
        if (!*(_DWORD *)(a3 + 28)) {
          double v33 = (void *)OZShape::computeNormalCaps(v15, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, (double *)v184, (uint64_t)v182, (double *)v180, (uint64_t)v178, 1, 0);
        }
        if (*(_DWORD *)(a3 + 32) == 4) {
          double v33 = (void *)OZShape::computeNormalCaps(0.05, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, (double *)v184, (uint64_t)v182, (double *)v180, (uint64_t)v178, 0, 1);
        }
        if (*(_DWORD *)(a3 + 28) == 4) {
          OZShape::computeNormalCaps(0.05, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, (double *)v184, (uint64_t)v182, (double *)v180, (uint64_t)v178, 1, 1);
        }
        float v57 = __p;
        uint64_t v58 = (uint64_t)v187;
        *((unsigned char *)__p + 131) = 0;
        std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a4 + 42, a4[43], (uint64_t)v57, v58, 0xF0F0F0F0F0F0F0F1 * ((v58 - (uint64_t)v57) >> 3));
        unint64_t v155 = a4 + 42;
        uint64_t v59 = a4[42];
        uint64_t v157 = a3;
        if (a4[43] == v59)
        {
          uint64_t v156 = a4 + 45;
          float v61 = a4 + 46;
          unint64_t v91 = a4[46];
        }
        else
        {
          uint64_t v152 = a1;
          uint64_t v60 = 0;
          unsigned int v153 = 0;
          uint64_t v156 = a4 + 45;
          float v61 = a4 + 46;
          uint64_t v154 = a4 + 47;
          unsigned int v62 = 1;
          do
          {
            OZShapeEdgePolygon::transformPoints((double *)(v59 + 136 * v60), &v193);
            if (*(unsigned char *)(a3 + 176))
            {
              double v63 = v14;
              long long v174 = 0u;
              memset(v175, 0, sizeof(v175));
              long long v172 = 0u;
              long long v173 = 0u;
              long long v170 = 0u;
              long long v171 = 0u;
              long long v168 = 0u;
              long long v169 = 0u;
              char v176 = 1;
              int v177 = 0;
              uint64_t v64 = *v155 + 136 * v60;
              LOBYTE(v177) = *(unsigned char *)(v64 + 132);
              HIBYTE(v177) = *(unsigned char *)(v64 + 135);
              long long v65 = *(_OWORD *)(v64 + 112);
              long long v168 = *(_OWORD *)(v64 + 96);
              long long v169 = v65;
              long long v66 = *(_OWORD *)(v64 + 80);
              long long v170 = *(_OWORD *)(v64 + 64);
              long long v171 = v66;
              double v67 = *(double *)(v64 + 120);
              double v68 = *(double *)(v64 + 88);
              double v69 = *(double *)(v64 + 96);
              double v70 = *(double *)(v64 + 64);
              double v71 = *(double *)(v64 + 72);
              double v72 = *(double *)(v64 + 104);
              BOOL v73 = OZShapeEdgePolygon::checkWindingOrder((OZShapeEdgePolygon *)v64);
              double v74 = (v67 * v71 - v68 * v72) / (v68 * v67);
              if (v68 * v67 < 0.0) {
                double v74 = -v74;
              }
              double v75 = (v67 * v70 - v68 * v69) / (v68 * v67);
              if (v68 * v67 < 0.0) {
                double v75 = -v75;
              }
              double v76 = -1.0;
              if (v73) {
                double v76 = 1.0;
              }
              double v14 = v63;
              double v77 = v63 / sqrt(v75 * v75 + v74 * v74);
              uint64_t v78 = *v155;
              uint64_t v79 = *v155 + 136 * v60;
              long long v80 = *(_OWORD *)(v79 + 80);
              long long v172 = *(_OWORD *)(v79 + 64);
              long long v173 = v80;
              double v81 = -(v74 * v76) * v77;
              double v82 = fabs(*(double *)(v79 + 88));
              *(double *)&long long v172 = *(double *)(v79 + 64) + v81 * v82;
              double v83 = v76 * v75 * v77;
              *((double *)&v172 + 1) = *(double *)(v79 + 72) + v83 * v82;
              long long v84 = *(_OWORD *)(v79 + 112);
              long long v174 = *(_OWORD *)(v79 + 96);
              *(_OWORD *)unint64_t v175 = v84;
              double v85 = fabs(*(double *)(v79 + 120));
              *(double *)&long long v174 = *(double *)(v79 + 96) + v81 * v85;
              *((double *)&v174 + 1) = *(double *)(v79 + 104) + v83 * v85;
              if (v62 != 1 && *(unsigned char *)(v78 + 136 * v60 + 131))
              {
                char v166 = 1;
                int v167 = v177;
                long long v158 = v168;
                long long v159 = v169;
                long long v160 = v168;
                long long v161 = v169;
                long long v164 = 0u;
                memset(v165, 0, sizeof(v165));
                long long v162 = v174;
                long long v163 = *(_OWORD *)v175;
                unint64_t v86 = *v61;
                long long v87 = *(_OWORD *)(*v61 - 56);
                long long v164 = *(_OWORD *)(*v61 - 72);
                *(_OWORD *)uint64_t v165 = v87;
                if (*(unsigned char *)(v78 + 136 * v60 + 133))
                {
                  OZShape::subdivideTriangle(v152, 1, (uint64_t)a2, a3, v156, (unint64_t)&v158, (long long *)(v86 - 136), (double *)&v168, v63, &v193, v177 == 0, 1u);
                }
                else
                {
                  if (v86 >= *v154)
                  {
                    uint64_t v88 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v158);
                  }
                  else
                  {
                    std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v154, v86, (uint64_t)&v158);
                    uint64_t v88 = v86 + 136;
                    unint64_t *v61 = v86 + 136;
                  }
                  unint64_t *v61 = v88;
                }
                uint64_t v78 = *v155;
              }
              unint64_t v89 = *v61;
              if (!*(unsigned char *)(v78 + 136 * v60 + 131)) {
                unsigned int v153 = -252645135 * ((v89 - *v156) >> 3);
              }
              if (v89 >= *v154)
              {
                uint64_t v90 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v168);
              }
              else
              {
                std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v154, v89, (uint64_t)&v168);
                uint64_t v90 = v89 + 136;
                unint64_t *v61 = v89 + 136;
              }
              unint64_t *v61 = v90;
            }
            uint64_t v60 = v62;
            uint64_t v59 = a4[42];
            BOOL v11 = 0xF0F0F0F0F0F0F0F1 * ((a4[43] - v59) >> 3) > v62++;
          }
          while (v11);
          unint64_t v91 = *v61;
          double v92 = (long long *)*v156;
          if (*v61 != *v156 && v153)
          {
            double v93 = (char *)v92 + 136 * v153;
            long long v174 = 0u;
            memset(v175, 0, sizeof(v175));
            long long v172 = 0u;
            long long v173 = 0u;
            long long v170 = 0u;
            long long v171 = 0u;
            long long v168 = 0u;
            long long v169 = 0u;
            char v176 = 1;
            int v177 = 0;
            long long v164 = 0u;
            memset(v165, 0, sizeof(v165));
            long long v162 = 0u;
            long long v163 = 0u;
            long long v160 = 0u;
            long long v161 = 0u;
            long long v158 = 0u;
            long long v159 = 0u;
            char v166 = 1;
            int v167 = 0;
            long long v94 = v92[1];
            long long v168 = *v92;
            long long v169 = v94;
            long long v95 = v92[1];
            long long v170 = *v92;
            long long v171 = v95;
            long long v96 = v92[7];
            long long v172 = v92[6];
            long long v173 = v96;
            long long v97 = *((_OWORD *)v93 + 7);
            long long v174 = *((_OWORD *)v93 + 6);
            *(_OWORD *)unint64_t v175 = v97;
            long long v98 = *(_OWORD *)(v93 - 88);
            long long v158 = *(_OWORD *)(v93 - 104);
            long long v159 = v98;
            long long v99 = *(_OWORD *)(v93 - 88);
            long long v160 = *(_OWORD *)(v93 - 104);
            long long v161 = v99;
            long long v100 = *(_OWORD *)(v91 - 56);
            long long v162 = *(_OWORD *)(v91 - 72);
            long long v163 = v100;
            long long v101 = *(_OWORD *)(v93 - 56);
            long long v164 = *(_OWORD *)(v93 - 72);
            *(_OWORD *)uint64_t v165 = v101;
            if (v91 >= *v154)
            {
              unint64_t v102 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v168);
            }
            else
            {
              std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v154, v91, (uint64_t)&v168);
              unint64_t v102 = v91 + 136;
              unint64_t *v61 = v102;
            }
            unint64_t *v61 = v102;
            if (v102 >= *v154)
            {
              unint64_t v91 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v158);
            }
            else
            {
              std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v154, v102, (uint64_t)&v158);
              unint64_t v91 = v102 + 136;
              unint64_t *v61 = v91;
            }
            unint64_t *v61 = v91;
          }
        }
        if (*(unsigned char *)(a3 + 176))
        {
          if (*(_DWORD *)(a3 + 28) != 4) {
            goto LABEL_137;
          }
          uint64_t v104 = a4[42];
          uint64_t v103 = a4[43];
          if (v103 == v104) {
            goto LABEL_137;
          }
          uint64_t v105 = 0;
          unint64_t v106 = a4 + 47;
          unsigned int v107 = 1;
          do
          {
            if (*(unsigned char *)(v104 + 136 * v105 + 134))
            {
              double v108 = (long long *)(v104 + 136 * v105);
              long long v174 = 0u;
              memset(v175, 0, sizeof(v175));
              long long v172 = 0u;
              long long v173 = 0u;
              long long v170 = 0u;
              long long v171 = 0u;
              long long v168 = 0u;
              long long v169 = 0u;
              char v176 = 1;
              int v177 = 0;
              HIBYTE(v177) = *((unsigned char *)v108 + 135);
              long long v109 = v108[1];
              long long v168 = *v108;
              long long v169 = v109;
              long long v110 = v108[7];
              long long v170 = v108[6];
              long long v171 = v110;
              double v111 = *((double *)v108 + 3);
              *(void *)&long long v110 = *((void *)v108 + 15);
              double v112 = v111 * *(double *)&v110;
              double v113 = (v111 * *((double *)v108 + 12) - *(double *)&v110 * *(double *)v108) / (v111 * *(double *)&v110);
              double v114 = (v111 * *((double *)v108 + 13) - *(double *)&v110 * *((double *)v108 + 1))
                   / (v111
                    * *(double *)&v110);
              if (v112 >= 0.0) {
                double v115 = v113;
              }
              else {
                double v115 = -v113;
              }
              if (v112 >= 0.0) {
                double v116 = v114;
              }
              else {
                double v116 = -v114;
              }
              double v117 = v14 / sqrt(v115 * v115 + v116 * v116);
              long long v118 = v108[7];
              long long v172 = v108[6];
              long long v173 = v118;
              double v119 = fabs(*((double *)v108 + 15));
              *(double *)&long long v172 = *((double *)v108 + 12) + v119 * (v116 * v117);
              double v120 = -(v115 * v117);
              *((double *)&v172 + 1) = *((double *)v108 + 13) + v119 * v120;
              long long v121 = v108[1];
              long long v174 = *v108;
              *(_OWORD *)unint64_t v175 = v121;
              *(double *)&long long v121 = fabs(*((double *)v108 + 3));
              *(double *)&long long v174 = *(double *)v108 + v116 * v117 * *(double *)&v121;
              *((double *)&v174 + 1) = *((double *)v108 + 1) + v120 * *(double *)&v121;
              if (v91 >= *v106)
              {
                unint64_t v91 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v168);
              }
              else
              {
                std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 47), v91, (uint64_t)&v168);
                v91 += 136;
                unint64_t *v61 = v91;
              }
              unint64_t *v61 = v91;
              if (HIBYTE(v177))
              {
                uint64_t v122 = *v155 + 136 * v105;
                long long v123 = *(_OWORD *)(v122 + 112);
                long long v172 = *(_OWORD *)(v122 + 96);
                long long v173 = v123;
                double v124 = v117 * -v116;
                double v125 = fabs(*(double *)(v122 + 120));
                *(double *)&long long v172 = *(double *)(v122 + 96) + v124 * v125;
                *((double *)&v172 + 1) = *(double *)(v122 + 104) + v115 * v117 * v125;
                long long v126 = *(_OWORD *)(v122 + 16);
                long long v174 = *(_OWORD *)v122;
                *(_OWORD *)unint64_t v175 = v126;
                double v127 = fabs(*(double *)(v122 + 24));
                *(double *)&long long v174 = *(double *)v122 + v124 * v127;
                *((double *)&v174 + 1) = *(double *)(v122 + 8) + v115 * v117 * v127;
                if (v91 >= *v106)
                {
                  unint64_t v91 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v168);
                }
                else
                {
                  std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 47), v91, (uint64_t)&v168);
                  v91 += 136;
                  unint64_t *v61 = v91;
                }
                unint64_t *v61 = v91;
              }
              uint64_t v104 = a4[42];
              uint64_t v103 = a4[43];
            }
            uint64_t v105 = v107;
            BOOL v11 = 0xF0F0F0F0F0F0F0F1 * ((v103 - v104) >> 3) > v107++;
          }
          while (v11);
          if (*(unsigned char *)(v157 + 176))
          {
LABEL_137:
            if (*(_DWORD *)(v157 + 32) == 4)
            {
              uint64_t v129 = a4[42];
              uint64_t v128 = a4[43];
              if (v128 != v129)
              {
                uint64_t v130 = 0;
                double v131 = a4 + 47;
                unsigned int v132 = 1;
                do
                {
                  if (*(unsigned char *)(v129 + 136 * v130 + 134))
                  {
                    uint64_t v133 = v129 + 136 * v130;
                    long long v174 = 0u;
                    memset(v175, 0, sizeof(v175));
                    long long v172 = 0u;
                    long long v173 = 0u;
                    long long v170 = 0u;
                    long long v171 = 0u;
                    long long v168 = 0u;
                    long long v169 = 0u;
                    char v176 = 1;
                    int v177 = 0;
                    HIBYTE(v177) = *(unsigned char *)(v133 + 135);
                    long long v134 = *(_OWORD *)(v133 + 80);
                    long long v168 = *(_OWORD *)(v133 + 64);
                    long long v169 = v134;
                    long long v135 = *(_OWORD *)(v133 + 48);
                    long long v170 = *(_OWORD *)(v133 + 32);
                    long long v171 = v135;
                    double v136 = *(double *)(v133 + 88);
                    *(void *)&long long v135 = *(void *)(v133 + 56);
                    double v137 = v136 * *(double *)&v135;
                    double v138 = (*(double *)&v135 * *(double *)(v133 + 64) - v136 * *(double *)(v133 + 32))
                         / (v136
                          * *(double *)&v135);
                    double v139 = (*(double *)&v135 * *(double *)(v133 + 72) - v136 * *(double *)(v133 + 40))
                         / (v136
                          * *(double *)&v135);
                    if (v137 >= 0.0) {
                      double v140 = v138;
                    }
                    else {
                      double v140 = -v138;
                    }
                    if (v137 >= 0.0) {
                      double v141 = v139;
                    }
                    else {
                      double v141 = -v139;
                    }
                    double v142 = v14 / sqrt(v140 * v140 + v141 * v141);
                    long long v143 = *(_OWORD *)(v133 + 48);
                    long long v172 = *(_OWORD *)(v133 + 32);
                    long long v173 = v143;
                    *(double *)&long long v143 = -(v141 * v142);
                    double v144 = fabs(*(double *)(v133 + 56));
                    *(double *)&long long v172 = *(double *)(v133 + 32) + v144 * *(double *)&v143;
                    *((double *)&v172 + 1) = *(double *)(v133 + 40) + v144 * (v140 * v142);
                    long long v145 = *(_OWORD *)(v133 + 80);
                    long long v174 = *(_OWORD *)(v133 + 64);
                    *(_OWORD *)unint64_t v175 = v145;
                    *(double *)&long long v145 = fabs(*(double *)(v133 + 88));
                    *(double *)&long long v174 = *(double *)(v133 + 64) + *(double *)&v143 * *(double *)&v145;
                    *((double *)&v174 + 1) = *(double *)(v133 + 72) + v140 * v142 * *(double *)&v145;
                    if (v91 >= *v131)
                    {
                      unint64_t v91 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v168);
                    }
                    else
                    {
                      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 47), v91, (uint64_t)&v168);
                      v91 += 136;
                      unint64_t *v61 = v91;
                    }
                    unint64_t *v61 = v91;
                    if (HIBYTE(v177))
                    {
                      uint64_t v146 = *v155 + 136 * v130;
                      long long v147 = *(_OWORD *)(v146 + 48);
                      long long v172 = *(_OWORD *)(v146 + 32);
                      long long v173 = v147;
                      double v148 = fabs(*(double *)(v146 + 56));
                      *(double *)&long long v172 = *(double *)(v146 + 32) + v141 * v142 * v148;
                      double v149 = -(v140 * v142);
                      *((double *)&v172 + 1) = *(double *)(v146 + 40) + v149 * v148;
                      long long v150 = *(_OWORD *)(v146 + 80);
                      long long v174 = *(_OWORD *)(v146 + 64);
                      *(_OWORD *)unint64_t v175 = v150;
                      double v151 = fabs(*(double *)(v146 + 88));
                      *(double *)&long long v174 = *(double *)(v146 + 64) + v141 * v142 * v151;
                      *((double *)&v174 + 1) = *(double *)(v146 + 72) + v149 * v151;
                      if (v91 >= *v131)
                      {
                        unint64_t v91 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v168);
                      }
                      else
                      {
                        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 47), v91, (uint64_t)&v168);
                        v91 += 136;
                        unint64_t *v61 = v91;
                      }
                      unint64_t *v61 = v91;
                    }
                    uint64_t v129 = a4[42];
                    uint64_t v128 = a4[43];
                  }
                  uint64_t v130 = v132;
                  BOOL v11 = 0xF0F0F0F0F0F0F0F1 * ((v128 - v129) >> 3) > v132++;
                }
                while (v11);
              }
            }
          }
        }
        *(unsigned char *)(v157 + 1195) = 0;
        double v33 = __p;
      }
    }
    if (v33)
    {
      unint64_t v187 = v33;
      operator delete(v33);
    }
  }
}

void sub_1B7E2DFA8(_Unwind_Exception *a1)
{
  void *v2 = v1;
  double v4 = (void *)STACK[0x398];
  if (STACK[0x398])
  {
    STACK[0x3A0] = (unint64_t)v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

void OZShape::computeOutlinePolygons(uint64_t a1, uint64_t *a2, uint64_t a3, const CMTime *a4, uint64_t a5, double *a6, int a7, int a8, double a9, char a10, int a11, unsigned __int8 a12)
{
  *(void *)&v380[40] = 0x3FF0000000000000;
  *(void *)uint64_t v380 = 0x3FF0000000000000;
  *(void *)&v377[40] = 0x3FF0000000000000;
  *(void *)unint64_t v377 = 0x3FF0000000000000;
  memset(&v377[8], 0, 32);
  float64x2_t v378 = 0u;
  long long v379 = 0u;
  memset(&v380[8], 0, 32);
  uint64_t v376 = 0x3FF0000000000000;
  uint64_t v373 = 0x3FF0000000000000;
  uint64_t v370 = 0x3FF0000000000000;
  double v367 = 1.0;
  long long v368 = 0u;
  long long v369 = 0u;
  long long v371 = 0u;
  long long v372 = 0u;
  long long v374 = 0u;
  long long v375 = 0u;
  long long v365 = 0uLL;
  *(void *)&long long v366 = 0;
  *((void *)&v366 + 1) = 0x3FF0000000000000;
  long long v363 = 0uLL;
  *(void *)&long long v364 = 0;
  *((void *)&v364 + 1) = 0x3FF0000000000000;
  long long v361 = 0uLL;
  *(void *)&long long v362 = 0;
  *((void *)&v362 + 1) = 0x3FF0000000000000;
  uint64_t v359 = 0;
  double v358 = 0.0;
  *(void *)&long long v360 = 0;
  *((void *)&v360 + 1) = 0x3FF0000000000000;
  double v19 = (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
  uint64_t v294 = a1;
  uint64_t ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E4F1FA48], 0.0);
  int v293 = ValueAsInt;
  unint64_t v356 = 0;
  std::string __p = 0;
  unint64_t v357 = 0;
  uint64_t v353 = 0;
  unint64_t v352 = 0;
  unint64_t v354 = 0;
  uint64_t v350 = 0;
  unint64_t v349 = 0;
  unint64_t v351 = 0;
  uint64_t v348 = 0;
  uint64_t v347 = 0;
  v346 = 0;
  uint64_t v291 = a3;
  if (!*(_DWORD *)(a5 + 120) || *(_DWORD *)(a5 + 168) || (a12 & 1) != 0)
  {
    p_p = (void **)(a3 + 216);
    uint64_t v348 = (void **)(a3 + 216);
    uint64_t v347 = (void **)(a3 + 240);
    long long v29 = (void **)(a3 + 192);
    goto LABEL_158;
  }
  unint64_t v292 = a4;
  double v22 = (void **)(a3 + 216);
  if (&__p != (void **)(a3 + 216)) {
    uint64_t ValueAsInt = (uint64_t)std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)&__p, *(char **)(a3 + 216), *(void *)(a3 + 224), (uint64_t)(*(void *)(a3 + 224) - *(void *)(a3 + 216)) >> 3);
  }
  double v23 = (void **)(a3 + 240);
  if (&v352 != (void **)(a3 + 240)) {
    uint64_t ValueAsInt = (uint64_t)std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)&v352, *(char **)(a3 + 240), *(void *)(a3 + 248), (uint64_t)(*(void *)(a3 + 248) - *(void *)(a3 + 240)) >> 3);
  }
  uint64_t v24 = (void **)(a3 + 192);
  if (&v349 != (void **)(v291 + 192)) {
    uint64_t ValueAsInt = (uint64_t)std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)&v349, *(char **)(v291 + 192), *(void *)(v291 + 200), (uint64_t)(*(void *)(v291 + 200) - *(void *)(v291 + 192)) >> 3);
  }
  float v25 = *v22;
  long long v26 = v356;
  if ((unint64_t)v356 >= v357)
  {
    uint64_t ValueAsInt = (uint64_t)__p;
    uint64_t v30 = (v356 - (unsigned char *)__p) >> 3;
    unint64_t v31 = v30 + 1;
    if ((unint64_t)(v30 + 1) >> 61) {
      goto LABEL_358;
    }
    uint64_t v32 = v357 - (void)__p;
    if ((uint64_t)(v357 - (void)__p) >> 2 > v31) {
      unint64_t v31 = v32 >> 2;
    }
    if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v33 = v31;
    }
    if (v33)
    {
      double v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v357, v33);
      long long v26 = v356;
      uint64_t ValueAsInt = (uint64_t)__p;
    }
    else
    {
      double v34 = 0;
    }
    double v35 = &v34[8 * v30];
    long long v36 = &v34[8 * v33];
    *(void *)double v35 = *v25;
    float v27 = v35 + 8;
    while (v26 != (char *)ValueAsInt)
    {
      uint64_t v37 = *((void *)v26 - 1);
      v26 -= 8;
      *((void *)v35 - 1) = v37;
      v35 -= 8;
    }
    std::string __p = v35;
    unint64_t v356 = v27;
    unint64_t v357 = (unint64_t)v36;
    if (ValueAsInt) {
      operator delete((void *)ValueAsInt);
    }
  }
  else
  {
    *(void *)unint64_t v356 = *v25;
    float v27 = v26 + 8;
  }
  unint64_t v356 = v27;
  long long v38 = *v23;
  double v39 = v353;
  if ((unint64_t)v353 >= v354)
  {
    uint64_t ValueAsInt = (uint64_t)v352;
    uint64_t v41 = (v353 - (unsigned char *)v352) >> 3;
    unint64_t v42 = v41 + 1;
    if ((unint64_t)(v41 + 1) >> 61) {
      goto LABEL_358;
    }
    uint64_t v43 = v354 - (void)v352;
    if ((uint64_t)(v354 - (void)v352) >> 2 > v42) {
      unint64_t v42 = v43 >> 2;
    }
    if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v44 = v42;
    }
    if (v44)
    {
      double v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v354, v44);
      double v39 = v353;
      uint64_t ValueAsInt = (uint64_t)v352;
    }
    else
    {
      double v45 = 0;
    }
    unint64_t v46 = &v45[8 * v41];
    long long v47 = &v45[8 * v44];
    *(void *)unint64_t v46 = *v38;
    uint64_t v40 = v46 + 8;
    while (v39 != (char *)ValueAsInt)
    {
      uint64_t v48 = *((void *)v39 - 1);
      v39 -= 8;
      *((void *)v46 - 1) = v48;
      v46 -= 8;
    }
    unint64_t v352 = v46;
    uint64_t v353 = v40;
    unint64_t v354 = (unint64_t)v47;
    if (ValueAsInt) {
      operator delete((void *)ValueAsInt);
    }
  }
  else
  {
    *(void *)uint64_t v353 = *v38;
    uint64_t v40 = v39 + 8;
  }
  uint64_t v353 = v40;
  long long v49 = *v24;
  float v50 = v350;
  if ((unint64_t)v350 >= v351)
  {
    uint64_t ValueAsInt = (uint64_t)v349;
    uint64_t v52 = (v350 - (unsigned char *)v349) >> 3;
    unint64_t v53 = v52 + 1;
    if ((unint64_t)(v52 + 1) >> 61) {
      goto LABEL_358;
    }
    uint64_t v54 = v351 - (void)v349;
    if ((uint64_t)(v351 - (void)v349) >> 2 > v53) {
      unint64_t v53 = v54 >> 2;
    }
    if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v55 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v55 = v53;
    }
    if (v55)
    {
      float v56 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v351, v55);
      float v50 = v350;
      uint64_t ValueAsInt = (uint64_t)v349;
    }
    else
    {
      float v56 = 0;
    }
    float v57 = &v56[8 * v52];
    uint64_t v58 = &v56[8 * v55];
    *(void *)float v57 = *v49;
    uint64_t v51 = v57 + 8;
    while (v50 != (char *)ValueAsInt)
    {
      uint64_t v59 = *((void *)v50 - 1);
      v50 -= 8;
      *((void *)v57 - 1) = v59;
      v57 -= 8;
    }
    unint64_t v349 = v57;
    uint64_t v350 = v51;
    unint64_t v351 = (unint64_t)v58;
    if (ValueAsInt) {
      operator delete((void *)ValueAsInt);
    }
  }
  else
  {
    *(void *)uint64_t v350 = *v49;
    uint64_t v51 = v50 + 8;
  }
  uint64_t v350 = v51;
  uint64_t v60 = *v22;
  float v61 = v356;
  if ((unint64_t)v356 >= v357)
  {
    uint64_t ValueAsInt = (uint64_t)__p;
    uint64_t v63 = (v356 - (unsigned char *)__p) >> 3;
    unint64_t v64 = v63 + 1;
    if ((unint64_t)(v63 + 1) >> 61) {
      goto LABEL_358;
    }
    uint64_t v65 = v357 - (void)__p;
    if ((uint64_t)(v357 - (void)__p) >> 2 > v64) {
      unint64_t v64 = v65 >> 2;
    }
    if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v66 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v66 = v64;
    }
    if (v66)
    {
      double v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v357, v66);
      float v61 = v356;
      uint64_t ValueAsInt = (uint64_t)__p;
    }
    else
    {
      double v67 = 0;
    }
    double v68 = &v67[8 * v63];
    double v69 = &v67[8 * v66];
    *(void *)double v68 = v60[1];
    unsigned int v62 = v68 + 8;
    while (v61 != (char *)ValueAsInt)
    {
      uint64_t v70 = *((void *)v61 - 1);
      v61 -= 8;
      *((void *)v68 - 1) = v70;
      v68 -= 8;
    }
    std::string __p = v68;
    unint64_t v356 = v62;
    unint64_t v357 = (unint64_t)v69;
    if (ValueAsInt) {
      operator delete((void *)ValueAsInt);
    }
  }
  else
  {
    *(void *)unint64_t v356 = v60[1];
    unsigned int v62 = v61 + 8;
  }
  unint64_t v356 = v62;
  double v71 = *v23;
  double v72 = v353;
  if ((unint64_t)v353 >= v354)
  {
    uint64_t ValueAsInt = (uint64_t)v352;
    uint64_t v74 = (v353 - (unsigned char *)v352) >> 3;
    unint64_t v75 = v74 + 1;
    if ((unint64_t)(v74 + 1) >> 61) {
      goto LABEL_358;
    }
    uint64_t v76 = v354 - (void)v352;
    if ((uint64_t)(v354 - (void)v352) >> 2 > v75) {
      unint64_t v75 = v76 >> 2;
    }
    if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v77 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v77 = v75;
    }
    if (v77)
    {
      uint64_t v78 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v354, v77);
      double v72 = v353;
      uint64_t ValueAsInt = (uint64_t)v352;
    }
    else
    {
      uint64_t v78 = 0;
    }
    uint64_t v79 = &v78[8 * v74];
    long long v80 = &v78[8 * v77];
    *(void *)uint64_t v79 = v71[1];
    BOOL v73 = v79 + 8;
    while (v72 != (char *)ValueAsInt)
    {
      uint64_t v81 = *((void *)v72 - 1);
      v72 -= 8;
      *((void *)v79 - 1) = v81;
      v79 -= 8;
    }
    unint64_t v352 = v79;
    uint64_t v353 = v73;
    unint64_t v354 = (unint64_t)v80;
    if (ValueAsInt) {
      operator delete((void *)ValueAsInt);
    }
  }
  else
  {
    *(void *)uint64_t v353 = v71[1];
    BOOL v73 = v72 + 8;
  }
  uint64_t v353 = v73;
  double v82 = *v24;
  double v83 = v350;
  if ((unint64_t)v350 >= v351)
  {
    uint64_t ValueAsInt = (uint64_t)v349;
    uint64_t v85 = (v350 - (unsigned char *)v349) >> 3;
    unint64_t v86 = v85 + 1;
    if ((unint64_t)(v85 + 1) >> 61) {
      goto LABEL_358;
    }
    uint64_t v87 = v351 - (void)v349;
    if ((uint64_t)(v351 - (void)v349) >> 2 > v86) {
      unint64_t v86 = v87 >> 2;
    }
    if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v88 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v88 = v86;
    }
    if (v88)
    {
      unint64_t v89 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v351, v88);
      double v83 = v350;
      uint64_t ValueAsInt = (uint64_t)v349;
    }
    else
    {
      unint64_t v89 = 0;
    }
    uint64_t v90 = &v89[8 * v85];
    unint64_t v91 = &v89[8 * v88];
    *(void *)uint64_t v90 = v82[1];
    long long v84 = v90 + 8;
    while (v83 != (char *)ValueAsInt)
    {
      uint64_t v92 = *((void *)v83 - 1);
      v83 -= 8;
      *((void *)v90 - 1) = v92;
      v90 -= 8;
    }
    unint64_t v349 = v90;
    uint64_t v350 = v84;
    unint64_t v351 = (unint64_t)v91;
    if (ValueAsInt) {
      operator delete((void *)ValueAsInt);
    }
  }
  else
  {
    *(void *)uint64_t v350 = v82[1];
    long long v84 = v83 + 8;
  }
  uint64_t v350 = v84;
  uint64_t v93 = *(void *)(v291 + 216);
  if ((unint64_t)(*(void *)(v291 + 224) - v93) >= 0x11)
  {
    long long v94 = v356;
    if ((unint64_t)v356 >= v357)
    {
      uint64_t ValueAsInt = (uint64_t)__p;
      uint64_t v96 = (v356 - (unsigned char *)__p) >> 3;
      unint64_t v97 = v96 + 1;
      if ((unint64_t)(v96 + 1) >> 61) {
        goto LABEL_358;
      }
      uint64_t v98 = v357 - (void)__p;
      if ((uint64_t)(v357 - (void)__p) >> 2 > v97) {
        unint64_t v97 = v98 >> 2;
      }
      if ((unint64_t)v98 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v99 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v99 = v97;
      }
      if (v99)
      {
        long long v100 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v357, v99);
        long long v94 = v356;
        uint64_t ValueAsInt = (uint64_t)__p;
      }
      else
      {
        long long v100 = 0;
      }
      long long v101 = &v100[8 * v96];
      unint64_t v102 = &v100[8 * v99];
      *(void *)long long v101 = *(void *)(v93 + 16);
      long long v95 = v101 + 8;
      while (v94 != (char *)ValueAsInt)
      {
        uint64_t v103 = *((void *)v94 - 1);
        v94 -= 8;
        *((void *)v101 - 1) = v103;
        v101 -= 8;
      }
      std::string __p = v101;
      unint64_t v356 = v95;
      unint64_t v357 = (unint64_t)v102;
      if (ValueAsInt) {
        operator delete((void *)ValueAsInt);
      }
    }
    else
    {
      *(void *)unint64_t v356 = *(void *)(v93 + 16);
      long long v95 = v94 + 8;
    }
    unint64_t v356 = v95;
    uint64_t v104 = *v23;
    uint64_t v105 = v353;
    if ((unint64_t)v353 >= v354)
    {
      uint64_t ValueAsInt = (uint64_t)v352;
      uint64_t v107 = (v353 - (unsigned char *)v352) >> 3;
      unint64_t v108 = v107 + 1;
      if ((unint64_t)(v107 + 1) >> 61) {
        goto LABEL_358;
      }
      uint64_t v109 = v354 - (void)v352;
      if ((uint64_t)(v354 - (void)v352) >> 2 > v108) {
        unint64_t v108 = v109 >> 2;
      }
      if ((unint64_t)v109 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v110 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v110 = v108;
      }
      if (v110)
      {
        double v111 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v354, v110);
        uint64_t v105 = v353;
        uint64_t ValueAsInt = (uint64_t)v352;
      }
      else
      {
        double v111 = 0;
      }
      double v112 = &v111[8 * v107];
      double v113 = &v111[8 * v110];
      *(void *)double v112 = v104[2];
      unint64_t v106 = v112 + 8;
      while (v105 != (char *)ValueAsInt)
      {
        uint64_t v114 = *((void *)v105 - 1);
        v105 -= 8;
        *((void *)v112 - 1) = v114;
        v112 -= 8;
      }
      unint64_t v352 = v112;
      uint64_t v353 = v106;
      unint64_t v354 = (unint64_t)v113;
      if (ValueAsInt) {
        operator delete((void *)ValueAsInt);
      }
    }
    else
    {
      *(void *)uint64_t v353 = v104[2];
      unint64_t v106 = v105 + 8;
    }
    uint64_t v353 = v106;
    double v115 = *v24;
    double v116 = v350;
    if ((unint64_t)v350 < v351)
    {
      *(void *)uint64_t v350 = v115[2];
      double v117 = v116 + 8;
LABEL_156:
      uint64_t v350 = v117;
      goto LABEL_157;
    }
    uint64_t ValueAsInt = (uint64_t)v349;
    uint64_t v118 = (v350 - (unsigned char *)v349) >> 3;
    unint64_t v119 = v118 + 1;
    if (!((unint64_t)(v118 + 1) >> 61))
    {
      uint64_t v120 = v351 - (void)v349;
      if ((uint64_t)(v351 - (void)v349) >> 2 > v119) {
        unint64_t v119 = v120 >> 2;
      }
      if ((unint64_t)v120 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v121 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v121 = v119;
      }
      if (v121)
      {
        uint64_t v122 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v351, v121);
        double v116 = v350;
        uint64_t ValueAsInt = (uint64_t)v349;
      }
      else
      {
        uint64_t v122 = 0;
      }
      long long v123 = &v122[8 * v118];
      double v124 = &v122[8 * v121];
      *(void *)long long v123 = v115[2];
      double v117 = v123 + 8;
      while (v116 != (char *)ValueAsInt)
      {
        uint64_t v125 = *((void *)v116 - 1);
        v116 -= 8;
        *((void *)v123 - 1) = v125;
        v123 -= 8;
      }
      unint64_t v349 = v123;
      uint64_t v350 = v117;
      unint64_t v351 = (unint64_t)v124;
      if (ValueAsInt) {
        operator delete((void *)ValueAsInt);
      }
      goto LABEL_156;
    }
LABEL_358:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
LABEL_157:
  p_p = &__p;
  uint64_t v348 = &__p;
  uint64_t v347 = &v352;
  long long v29 = &v349;
  a3 = v291;
  a4 = v292;
LABEL_158:
  v346 = v29;
  int v345 = 0;
  int v344 = ((unint64_t)((unsigned char *)p_p[1] - (unsigned char *)*p_p) >> 3) - 1;
  if (a12)
  {
    double v126 = a9 * 0.25 + 1.0;
    if (a9 > 4.0) {
      double v126 = 2.0;
    }
    double v287 = v126;
    if (a9 > 4.0) {
      a9 = a9 + -2.0;
    }
    else {
      a9 = a9 * 0.4375 + 0.25;
    }
    uint64_t ValueAsInt = OZShape::isWriteOnEffectEnabled(v294, a5);
    if (ValueAsInt) {
      OZShape::getWriteOnEffect(v294, a4, a5, v21, &v345, &v344, &v348, &v347, &v346);
    }
  }
  else if (a9 < 0.0 || a9 >= 2.0)
  {
    double v287 = 0.0;
    if (a9 < 0.0 && a9 > -2.0)
    {
      if (*(_DWORD *)(a5 + 8) && *(double *)(a5 + 16) < 2.0 && !*(_DWORD *)(a5 + 116)) {
        a9 = -1.0;
      }
      else {
        a9 = -2.0;
      }
    }
  }
  else
  {
    if (*(_DWORD *)(a5 + 8) && *(double *)(a5 + 16) < 2.0 && !*(_DWORD *)(a5 + 116)) {
      a9 = 1.0;
    }
    else {
      a9 = 2.0;
    }
    double v287 = 0.0;
  }
  uint64_t v127 = a3;
  uint64_t v128 = *(void *)(a3 + 368);
  uint64_t v129 = *(void *)(v127 + 360);
  if (*(_DWORD *)(a5 + 8))
  {
    double v130 = 1.0;
    double v131 = 1.0;
  }
  else
  {
    double v131 = 1.0;
    double v130 = 1.0;
    if (fabs(*(double *)(a5 + 224)) < 0.0000001) {
      goto LABEL_193;
    }
    OZChannel::getValueAsDouble((OZChannel *)(v294 + 13416), MEMORY[0x1E4F1FA48], 0.0);
    double v130 = v132;
    OZChannel::getValueAsDouble((OZChannel *)(v294 + 13568), MEMORY[0x1E4F1FA48], 0.0);
    double v131 = v133;
    if (!*(_DWORD *)(a5 + 8)) {
      goto LABEL_193;
    }
  }
  if (a12)
  {
    if (*(unsigned char *)(a5 + 13))
    {
      PCMatrix44Tmpl<double>::leftShear((double *)v377, *(double *)(a5 + 264), *(long double *)(a5 + 272));
      double v135 = *(double *)(a5 + 248);
      double v134 = *(double *)(a5 + 256);
      if (v135 != 1.0)
      {
        *(float64x2_t *)unint64_t v377 = vmulq_n_f64(*(float64x2_t *)v377, v135);
        *(float64x2_t *)&v377[16] = vmulq_n_f64(*(float64x2_t *)&v377[16], v135);
      }
      if (v134 != 1.0)
      {
        *(float64x2_t *)&v377[32] = vmulq_n_f64(*(float64x2_t *)&v377[32], v134);
        float64x2_t v378 = vmulq_n_f64(v378, v134);
      }
      long long v338 = v379;
      long long v339 = *(_OWORD *)v380;
      long long v340 = *(_OWORD *)&v380[16];
      *(_OWORD *)uint64_t v341 = *(_OWORD *)&v380[32];
      long long v334 = *(_OWORD *)v377;
      long long v335 = *(_OWORD *)&v377[16];
      long long v336 = *(_OWORD *)&v377[32];
      float64x2_t v337 = v378;
      PCMatrix44Tmpl<double>::invert((double *)&v334, (double *)&v334, 0.0);
      if (&v367 != a6)
      {
        for (uint64_t i = 0; i != 16; i += 4)
        {
          double v137 = (_OWORD *)((char *)&v367 + i * 8);
          long long v138 = *(_OWORD *)&a6[i + 2];
          _OWORD *v137 = *(_OWORD *)&a6[i];
          v137[1] = v138;
        }
      }
      PCMatrix44Tmpl<double>::rightMult((uint64_t)&v367, (double *)&v334);
      int v288 = 1;
LABEL_198:
      double v142 = v19;
      goto LABEL_216;
    }
    if (&v367 != a6)
    {
      for (uint64_t j = 0; j != 16; j += 4)
      {
        long long v147 = (_OWORD *)((char *)&v367 + j * 8);
        long long v148 = *(_OWORD *)&a6[j + 2];
        _OWORD *v147 = *(_OWORD *)&a6[j];
        v147[1] = v148;
      }
    }
    *(void *)&v380[40] = 0x3FF0000000000000;
    *(void *)uint64_t v380 = 0x3FF0000000000000;
    *(void *)&v377[40] = 0x3FF0000000000000;
    *(void *)unint64_t v377 = 0x3FF0000000000000;
    memset(&v377[8], 0, 32);
    float64x2_t v378 = 0u;
    long long v379 = 0u;
    int v288 = 1;
    double v142 = v19;
    memset(&v380[8], 0, 32);
    goto LABEL_216;
  }
LABEL_193:
  if (a8)
  {
    *(void *)&v380[40] = 0x3FF0000000000000;
    *(void *)uint64_t v380 = 0x3FF0000000000000;
    *(void *)&v377[40] = 0x3FF0000000000000;
    *(void *)unint64_t v377 = 0x3FF0000000000000;
    memset(&v377[8], 0, 32);
    float64x2_t v378 = 0u;
    long long v379 = 0u;
    memset(&v380[8], 0, 32);
    if (&v367 != a6)
    {
      for (uint64_t k = 0; k != 16; k += 4)
      {
        double v140 = (_OWORD *)((char *)&v367 + k * 8);
        long long v141 = *(_OWORD *)&a6[k + 2];
        *double v140 = *(_OWORD *)&a6[k];
        v140[1] = v141;
      }
    }
    int v288 = 0;
    goto LABEL_198;
  }
  uint64_t ValueAsInt = (*(uint64_t (**)(uint64_t))(*(void *)v294 + 184))(v294);
  if (ValueAsInt)
  {
    uint64_t v376 = 0x3FF0000000000000;
    uint64_t v373 = 0x3FF0000000000000;
    long long v368 = 0u;
    long long v369 = 0u;
    long long v371 = 0u;
    long long v372 = 0u;
    long long v374 = 0u;
    long long v375 = 0u;
    double v142 = 1.0;
    uint64_t v370 = 0x3FF0000000000000;
    double v367 = 1.0;
    if (v377 != (unsigned char *)a6)
    {
      for (uint64_t m = 0; m != 16; m += 4)
      {
        double v144 = &v377[m * 8];
        long long v145 = *(_OWORD *)&a6[m + 2];
        *double v144 = *(_OWORD *)&a6[m];
        v144[1] = v145;
      }
    }
    int v288 = 0;
  }
  else
  {
    double v149 = fabs(*(double *)(a5 + 248));
    double v150 = fabs(*(double *)(a5 + 256));
    if (v149 != 1.0)
    {
      *(float64x2_t *)unint64_t v377 = vmulq_n_f64(*(float64x2_t *)v377, v149);
      *(float64x2_t *)&v377[16] = vmulq_n_f64(*(float64x2_t *)&v377[16], v149);
    }
    if (v150 != 1.0)
    {
      *(float64x2_t *)&v377[32] = vmulq_n_f64(*(float64x2_t *)&v377[32], v150);
      float64x2_t v378 = vmulq_n_f64(v378, v150);
    }
    long long v338 = v379;
    long long v339 = *(_OWORD *)v380;
    long long v340 = *(_OWORD *)&v380[16];
    *(_OWORD *)uint64_t v341 = *(_OWORD *)&v380[32];
    long long v334 = *(_OWORD *)v377;
    long long v335 = *(_OWORD *)&v377[16];
    long long v336 = *(_OWORD *)&v377[32];
    float64x2_t v337 = v378;
    PCMatrix44Tmpl<double>::invert((double *)&v334, (double *)&v334, 0.0);
    if (&v367 != a6)
    {
      for (uint64_t n = 0; n != 16; n += 4)
      {
        uint64_t v152 = (_OWORD *)((char *)&v367 + n * 8);
        long long v153 = *(_OWORD *)&a6[n + 2];
        _OWORD *v152 = *(_OWORD *)&a6[n];
        v152[1] = v153;
      }
    }
    PCMatrix44Tmpl<double>::rightMult((uint64_t)&v367, (double *)&v334);
    int v288 = 0;
    double v142 = 1.0;
  }
LABEL_216:
  int v290 = a11;
  if (a10)
  {
    a2[1] = *a2;
    if (a12) {
      *(void *)(v291 + 368) = *(void *)(v291 + 360);
    }
  }
  if (a9 < 0.0)
  {
    int v154 = *(_DWORD *)(a5 + 8);
    int v155 = a11;
    if (a11 == -1) {
      int v156 = 1;
    }
    else {
      int v156 = -1;
    }
    if (!v154) {
      int v155 = v156;
    }
    int v290 = v155;
    if (!v154) {
      a9 = -a9;
    }
  }
  unint64_t v276 = 0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 3);
  uint64_t v157 = v348[1];
  if (v157 != *v348) {
    std::vector<OZShapeEdgePolygon>::reserve(a2, v276 + ((v157 - (unsigned char *)*v348) >> 2) - 2);
  }
  if (a9 < 0.0)
  {
    OZShape::computeInsideFeatheringPolygons(v294, a2, (void *)v291, -a9, v21, a5, (double *)v377);
    goto LABEL_344;
  }
  uint64_t v158 = v345;
  if (v345 <= v344)
  {
    uint64_t v280 = (uint64_t *)(v291 + 360);
    unint64_t v275 = 0xF0F0F0F0F0F0F0F1 * ((v128 - v129) >> 3);
    unint64_t v284 = ((unsigned char *)v348[1] - (unsigned char *)*v348) >> 3;
    double v159 = (double)v290;
    unint64_t v283 = (unint64_t *)(a2 + 2);
    BOOL v161 = a7 == 1 || v293 != 1;
    BOOL v282 = v161;
    long long v162 = (OZChannelCurve *)(v294 + 208);
    unint64_t v279 = (unint64_t *)(v291 + 376);
    if (v293 == 2) {
      int v163 = 1;
    }
    else {
      int v163 = a7;
    }
    int v281 = v163;
    while (1)
    {
      uint64_t v164 = a2[1];
      uint64_t v289 = *a2;
      *(double *)&long long v365 = v142 * *((double *)*v348 + v158);
      *((void *)&v365 + 1) = *((void *)*v347 + v158);
      long long v366 = xmmword_1B7E733E0;
      PCMatrix44Tmpl<double>::transform<double>((double *)v377, (double *)&v365, (double *)&v365);
      if (*(_DWORD *)(a5 + 168) && (OZShape::isWriteOnEffectEnabled(v294, a5) & a12 & 1) == 0)
      {
        unint64_t v175 = v284 - 1;
        if (v158) {
          unint64_t v175 = (v158 - 1) % v284;
        }
        *(double *)&long long v363 = v142 * *((double *)*v348 + v175);
        *((void *)&v363 + 1) = *((void *)*v347 + v175);
        long long v364 = xmmword_1B7E733E0;
        PCMatrix44Tmpl<double>::transform<double>((double *)v377, (double *)&v363, (double *)&v363);
        unint64_t v176 = (v158 + 1) % v284;
        *(double *)&long long v361 = v142 * *((double *)*v348 + v176);
        *((void *)&v361 + 1) = *((void *)*v347 + v176);
        long long v362 = xmmword_1B7E733E0;
        PCMatrix44Tmpl<double>::transform<double>((double *)v377, (double *)&v361, (double *)&v361);
        unint64_t v177 = (v158 + 2) % v284;
        double v358 = v142 * *((double *)*v348 + v177);
        uint64_t v359 = *((void *)*v347 + v177);
        long long v360 = xmmword_1B7E733E0;
        PCMatrix44Tmpl<double>::transform<double>((double *)v377, &v358, &v358);
        uint64_t v285 = v164;
        double v178 = -((*((double *)&v364 + 1) * *((double *)&v365 + 1) - *((double *)&v366 + 1) * *((double *)&v363 + 1))
               / (*((double *)&v364 + 1)
                * *((double *)&v366 + 1)));
        if (*((double *)&v364 + 1) * *((double *)&v366 + 1) < 0.0)
        {
          double v179 = -((*(double *)&v365 * *((double *)&v364 + 1) - *(double *)&v363 * *((double *)&v366 + 1))
                 / (*((double *)&v364 + 1)
                  * *((double *)&v366 + 1)));
        }
        else
        {
          double v178 = (*((double *)&v364 + 1) * *((double *)&v365 + 1) - *((double *)&v366 + 1) * *((double *)&v363 + 1))
               / (*((double *)&v364 + 1)
                * *((double *)&v366 + 1));
          double v179 = (*(double *)&v365 * *((double *)&v364 + 1) - *(double *)&v363 * *((double *)&v366 + 1))
               / (*((double *)&v364 + 1)
                * *((double *)&v366 + 1));
        }
        double v180 = (*((double *)&v366 + 1) * *(double *)&v361 - *(double *)&v365 * *((double *)&v362 + 1))
             / (*((double *)&v366 + 1)
              * *((double *)&v362 + 1));
        double v181 = -((*((double *)&v366 + 1) * *((double *)&v361 + 1) - *((double *)&v365 + 1) * *((double *)&v362 + 1))
               / (*((double *)&v366 + 1)
                * *((double *)&v362 + 1)));
        if (*((double *)&v366 + 1) * *((double *)&v362 + 1) < 0.0) {
          double v180 = -v180;
        }
        else {
          double v181 = (*((double *)&v366 + 1) * *((double *)&v361 + 1) - *((double *)&v365 + 1) * *((double *)&v362 + 1))
        }
               / (*((double *)&v366 + 1)
                * *((double *)&v362 + 1));
        double v182 = sqrt(v180 * v180 + v181 * v181);
        *((void *)&v334 + 1) = *((void *)&v365 + 1);
        long long v335 = v366;
        *((void *)&v336 + 1) = *((void *)&v361 + 1);
        float64x2_t v337 = (float64x2_t)v362;
        *(double *)&long long v334 = *(double *)&v365 / v142;
        *(double *)&long long v336 = *(double *)&v361 / v142;
        long long v339 = v362;
        double v183 = -(v181 * a9) / v182 * v159;
        *(_OWORD *)uint64_t v341 = v366;
        double v184 = fabs(*((double *)&v362 + 1));
        double v185 = a9 * v180 / v182 * v159;
        *(double *)&long long v338 = *(double *)&v361 / v142 + v183 * v184 / v19 / v130;
        *((double *)&v338 + 1) = *((double *)&v361 + 1) + v185 * v184 / v131;
        double v186 = fabs(*((double *)&v366 + 1));
        double v187 = sqrt(v179 * v179 + v178 * v178);
        char v342 = 1;
        LOBYTE(v343) = v290 < 0;
        *(_WORD *)((char *)&v343 + 1) = 0;
        HIBYTE(v343) = 0;
        v341[18] = 0;
        *(_WORD *)&v341[16] = 0;
        *(double *)&long long v340 = *(double *)&v365 / v142 + v183 * v186 / v19 / v130;
        *((double *)&v340 + 1) = *((double *)&v365 + 1) + v185 * v186 / v131;
        char v332 = 1;
        LOBYTE(v333) = v290 < 0;
        *(_WORD *)((char *)&v333 + 1) = 0;
        HIBYTE(v333) = 0;
        *((void *)&v324 + 1) = *((void *)&v363 + 1);
        long long v325 = v364;
        *((void *)&v326 + 1) = *((void *)&v365 + 1);
        long long v327 = v366;
        *(double *)&long long v324 = *(double *)&v363 / v142;
        *(double *)&long long v326 = *(double *)&v365 / v142;
        long long v329 = v366;
        double v188 = -(v178 * a9) / v187 * v159;
        *(_OWORD *)unint64_t v331 = v364;
        double v189 = a9 * v179 / v187 * v159;
        *(double *)&long long v328 = *(double *)&v365 / v142 + v188 * v186 / v19 / v130;
        *((double *)&v328 + 1) = *((double *)&v365 + 1) + v189 * v186 / v131;
        v331[18] = 0;
        *(_WORD *)&v331[16] = 0;
        double v190 = fabs(*((double *)&v364 + 1));
        *(double *)&long long v330 = *(double *)&v363 / v142 + v188 * v190 / v19 / v130;
        *((double *)&v330 + 1) = *((double *)&v363 + 1) + v189 * v190 / v131;
        unint64_t v191 = a2[1];
        if (v191 >= a2[2])
        {
          uint64_t v192 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a2, (uint64_t)&v324);
        }
        else
        {
          std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v283, a2[1], (uint64_t)&v324);
          uint64_t v192 = v191 + 136;
          a2[1] = v191 + 136;
        }
        a2[1] = v192;
        char v322 = 1;
        LOBYTE(v323) = v290 < 0;
        *(_WORD *)((char *)&v323 + 1) = 0;
        HIBYTE(v323) = 0;
        *((void *)&v314 + 1) = *((void *)&v365 + 1);
        long long v315 = v366;
        *(double *)&long long v314 = *(double *)&v365 / v142;
        long long v316 = v314;
        long long v317 = v366;
        long long v319 = v366;
        double v213 = fabs(*((double *)&v366 + 1));
        *(double *)&long long v318 = *(double *)&v365 / v142 + v183 * v213 / v19 / v130;
        *((double *)&v318 + 1) = *((double *)&v365 + 1) + v185 * v213 / v131;
        v321[18] = 0;
        *(_WORD *)&v321[16] = 0;
        long long v320 = v328;
        *(_OWORD *)float64_t v321 = v329;
        int v214 = v281;
        if (!v282)
        {
          Vertex = (char *)OZChannelCurve::getVertex(v162, a4, (double)(int)vcvtmd_s64_f64(*((double *)*v346 + v158) + 0.5 + 0.0000001));
          uint64_t v217 = v216;
          unint64_t v218 = OZChannelCurve::getVertex(v162, a4, *((Float64 *)*v346 + v158));
          uint64_t v219 = (uint64_t)v162;
          uint64_t v221 = v220;
          BOOL isVertexFlattened = OZChannelCurve::isVertexFlattened(v219, Vertex, v217);
          if (v218) {
            BOOL v223 = isVertexFlattened;
          }
          else {
            BOOL v223 = 0;
          }
          if (v223 && v221 != 0) {
            int v214 = a7;
          }
          else {
            int v214 = 1;
          }
        }
        OZShape::subdivideTriangle(v294, v214, (uint64_t)a4, a5, a2, (unint64_t)&v314, &v324, (double *)&v334, a9, &v367, v290 > 0, a12);
        uint64_t v164 = v285;
      }
      else if (v158)
      {
        uint64_t v165 = 8 * v158;
        uint64_t v166 = 8 * v158 - 8;
        *(double *)&long long v363 = v142 * *(double *)((char *)*v348 + v166);
        *((void *)&v363 + 1) = *(void *)((char *)*v347 + v166);
        long long v364 = xmmword_1B7E733E0;
        PCMatrix44Tmpl<double>::transform<double>((double *)v377, (double *)&v363, (double *)&v363);
        double v167 = (*(double *)&v365 * *((double *)&v364 + 1) - *(double *)&v363 * *((double *)&v366 + 1))
             / (*((double *)&v364 + 1)
              * *((double *)&v366 + 1));
        if (*((double *)&v364 + 1) * *((double *)&v366 + 1) >= 0.0) {
          double v168 = (*((double *)&v364 + 1) * *((double *)&v365 + 1) - *((double *)&v366 + 1) * *((double *)&v363 + 1))
        }
               / (*((double *)&v364 + 1)
                * *((double *)&v366 + 1));
        else {
          double v168 = -((*((double *)&v364 + 1) * *((double *)&v365 + 1) - *((double *)&v366 + 1) * *((double *)&v363 + 1))
        }
                 / (*((double *)&v364 + 1)
                  * *((double *)&v366 + 1)));
        if (*((double *)&v364 + 1) * *((double *)&v366 + 1) < 0.0) {
          double v167 = -v167;
        }
        double v169 = sqrt(v167 * v167 + v168 * v168);
        *((void *)&v334 + 1) = *((void *)&v363 + 1);
        long long v335 = v364;
        *((void *)&v336 + 1) = *((void *)&v365 + 1);
        float64x2_t v337 = (float64x2_t)v366;
        *(double *)&long long v334 = *(double *)&v363 / v142;
        *(double *)&long long v336 = *(double *)&v365 / v142;
        long long v339 = v366;
        double v170 = -(v168 * a9) / v169 * v159;
        double v171 = fabs(*((double *)&v366 + 1));
        char v342 = 1;
        LOBYTE(v343) = v290 < 0;
        *(_WORD *)((char *)&v343 + 1) = 0;
        HIBYTE(v343) = 0;
        long long v340 = 0u;
        memset(v341, 0, sizeof(v341));
        double v172 = a9 * v167 / v169 * v159;
        *(double *)&long long v338 = *(double *)&v365 / v142 + v170 * v171 / v19 / v130;
        *((double *)&v338 + 1) = *((double *)&v365 + 1) + v172 * v171 / v131;
        if (v158 <= v345 + 1)
        {
          *(_OWORD *)uint64_t v341 = v335;
          double v193 = fabs(*((double *)&v335 + 1));
          *(double *)&long long v340 = *(double *)&v363 / v142 + v170 * v193 / v19 / v130;
          *((double *)&v340 + 1) = *((double *)&v334 + 1) + v172 * v193 / v131;
          unint64_t v173 = a2[1];
        }
        else
        {
          unint64_t v173 = a2[1];
          long long v174 = *(_OWORD *)(v173 - 56);
          long long v340 = *(_OWORD *)(v173 - 72);
          *(_OWORD *)uint64_t v341 = v174;
        }
        if (v173 >= *v283)
        {
          uint64_t v194 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a2, (uint64_t)&v334);
        }
        else
        {
          std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v283, v173, (uint64_t)&v334);
          uint64_t v194 = v173 + 136;
          a2[1] = v173 + 136;
        }
        a2[1] = v194;
        if (v344 != v158)
        {
          uint64_t v286 = v164;
          long long v330 = 0u;
          memset(v331, 0, sizeof(v331));
          long long v328 = 0u;
          long long v329 = 0u;
          long long v326 = 0u;
          long long v327 = 0u;
          long long v324 = 0u;
          long long v325 = 0u;
          char v332 = 1;
          LOBYTE(v333) = v290 < 0;
          *(_WORD *)((char *)&v333 + 1) = 0;
          HIBYTE(v333) = 0;
          *(double *)&long long v361 = v142 * *(double *)((char *)*v348 + v165 + 8);
          *((void *)&v361 + 1) = *(void *)((char *)*v347 + v165 + 8);
          long long v362 = xmmword_1B7E733E0;
          PCMatrix44Tmpl<double>::transform<double>((double *)v377, (double *)&v361, (double *)&v361);
          double v195 = (*(double *)&v361 * *((double *)&v366 + 1) - *(double *)&v365 * *((double *)&v362 + 1))
               / (*((double *)&v366 + 1)
                * *((double *)&v362 + 1));
          double v196 = (*((double *)&v366 + 1) * *((double *)&v361 + 1) - *((double *)&v362 + 1) * *((double *)&v365 + 1))
               / (*((double *)&v366 + 1)
                * *((double *)&v362 + 1));
          if (*((double *)&v366 + 1) * *((double *)&v362 + 1) < 0.0)
          {
            double v196 = -v196;
            double v195 = -v195;
          }
          *((void *)&v324 + 1) = *((void *)&v365 + 1);
          long long v325 = v366;
          *(double *)&long long v324 = *(double *)&v365 / v142;
          long long v326 = v324;
          long long v327 = v366;
          long long v329 = v366;
          double v197 = sqrt(v195 * v195 + v196 * v196);
          double v198 = *((double *)&v366 + 1) * (-(v196 * a9) / v197 * v159) / v19 / v130;
          double v199 = *((double *)&v366 + 1) * (a9 * v195 / v197 * v159) / v131;
          *(double *)&long long v328 = *(double *)&v365 / v142 + v198;
          *((double *)&v328 + 1) = *((double *)&v365 + 1) + v199;
          uint64_t v200 = a2[1];
          long long v201 = *(_OWORD *)(v200 - 56);
          long long v330 = *(_OWORD *)(v200 - 72);
          *(_OWORD *)unint64_t v331 = v201;
          char v322 = 1;
          LOBYTE(v323) = v290 < 0;
          *(_WORD *)((char *)&v323 + 1) = 0;
          HIBYTE(v323) = 0;
          *((void *)&v314 + 1) = *((void *)&v365 + 1);
          long long v315 = v366;
          *((void *)&v316 + 1) = *((void *)&v361 + 1);
          long long v317 = v362;
          *(double *)&long long v314 = *(double *)&v365 / v142;
          *(double *)&long long v316 = *(double *)&v361 / v142;
          long long v319 = v362;
          *(double *)&long long v318 = *(double *)&v361 / v142 + v198;
          *((double *)&v318 + 1) = v199 + *((double *)&v361 + 1);
          v321[18] = 0;
          *(_WORD *)&v321[16] = 0;
          long long v320 = v328;
          *(_OWORD *)float64_t v321 = v366;
          int v202 = v281;
          if (!v282)
          {
            unint64_t v203 = (char *)OZChannelCurve::getVertex(v162, a4, (double)(int)vcvtmd_s64_f64(*((double *)*v346 + v158) + 0.5 + 0.0000001));
            unint64_t v205 = v204;
            FirstVertex = (char *)OZChannelCurve::getFirstVertex(v162, a4, 1);
            double v207 = a4;
            double v209 = v208;
            double v210 = v207;
            LastVertex = (char *)OZChannelCurve::getLastVertex(v162, v207, 1);
            if (v203 == FirstVertex && v205 == v209 || v203 == LastVertex && v205 == v212)
            {
              int v202 = 1;
              a4 = v210;
            }
            else
            {
              uint64_t v224 = (uint64_t)v162;
              a4 = v210;
              double v225 = OZChannelCurve::getVertex(v162, v210, *((Float64 *)*v346 + v158));
              uint64_t v227 = v226;
              BOOL v228 = OZChannelCurve::isVertexFlattened(v224, v203, v205);
              if (v225) {
                BOOL v229 = v228;
              }
              else {
                BOOL v229 = 0;
              }
              if (v229 && v227 != 0) {
                int v202 = a7;
              }
              else {
                int v202 = 1;
              }
            }
          }
          uint64_t v230 = a2[1];
          long long v231 = *(_OWORD *)(v230 - 56);
          long long v232 = *(_OWORD *)(v230 - 24);
          long long v311 = *(_OWORD *)(v230 - 40);
          long long v312 = v232;
          uint64_t v313 = *(void *)(v230 - 8);
          long long v233 = *(_OWORD *)(v230 - 120);
          long long v234 = *(_OWORD *)(v230 - 88);
          long long v307 = *(_OWORD *)(v230 - 104);
          long long v308 = v234;
          long long v309 = *(_OWORD *)(v230 - 72);
          long long v310 = v231;
          long long v305 = *(_OWORD *)(v230 - 136);
          long long v306 = v233;
          OZShape::subdivideTriangle(v294, v202, (uint64_t)a4, a5, a2, (unint64_t)&v324, &v305, (double *)&v314, a9, &v367, v290 > 0, a12);
          uint64_t v164 = v286;
        }
      }
      uint64_t ValueAsInt = (*(uint64_t (**)(uint64_t))(*(void *)v294 + 184))(v294);
      if ((v288 | ValueAsInt ^ 1) == 1) {
        break;
      }
LABEL_343:
      BOOL v273 = v158++ < v344;
      long long v162 = (OZChannelCurve *)(v294 + 208);
      if (!v273) {
        goto LABEL_344;
      }
    }
    int v236 = *(double *)(a5 + 224) > 0.0 && v290 > 0 && *(_DWORD *)(a5 + 120) == 0;
    unint64_t v237 = 0xF0F0F0F0F0F0F0F1 * ((v164 - v289) >> 3);
    uint64_t v238 = *a2;
    for (iuint64_t i = 0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 3); ; iuint64_t i = 0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 3))
    {
      if (v237 >= ii) {
        goto LABEL_343;
      }
      unint64_t v240 = v238 + 136 * v237;
      uint64_t ValueAsInt = (uint64_t)OZShapeEdgePolygon::transformPoints((double *)v240, &v367);
      if (*(_DWORD *)(a5 + 168))
      {
        uint64_t ValueAsInt = OZShape::isWriteOnEffectEnabled(v294, a5);
        if ((ValueAsInt & 1) == 0 && ((*(unsigned char *)(a5 + 176) == 0) & ~v236) == 0)
        {
          long long v340 = 0u;
          memset(v341, 0, sizeof(v341));
          long long v338 = 0u;
          long long v339 = 0u;
          long long v336 = 0u;
          float64x2_t v337 = 0u;
          long long v334 = 0u;
          long long v335 = 0u;
          char v342 = 1;
          int v343 = 0;
          LOBYTE(v343) = *(unsigned char *)(v238 + 136 * v237 + 132);
          long long v241 = *(_OWORD *)(v240 + 112);
          long long v334 = *(_OWORD *)(v240 + 96);
          long long v335 = v241;
          float64x2_t v242 = *(float64x2_t *)(v240 + 80);
          long long v336 = *(_OWORD *)(v240 + 64);
          float64x2_t v337 = v242;
          double v243 = *(double *)(v240 + 120);
          double v244 = *(double *)(v240 + 88);
          double v245 = v244 * v243;
          double v246 = (v243 * *(double *)(v240 + 64) - v244 * *(double *)(v240 + 96)) / (v244 * v243);
          double v247 = (v243 * *(double *)(v240 + 72) - v244 * *(double *)(v240 + 104)) / (v244 * v243);
          if (v245 >= 0.0) {
            double v248 = v246;
          }
          else {
            double v248 = -v246;
          }
          if (v245 >= 0.0) {
            double v249 = v247;
          }
          else {
            double v249 = -v247;
          }
          uint64_t ValueAsInt = OZShapeEdgePolygon::checkWindingOrder((OZShapeEdgePolygon *)(v238 + 136 * v237));
          double v250 = -1.0;
          if (ValueAsInt) {
            double v250 = 1.0;
          }
          double v251 = sqrt(v248 * v248 + v249 * v249);
          if (v251 <= -0.0000001 || v251 >= 0.0000001) {
            break;
          }
        }
      }
LABEL_338:
      ++v237;
      uint64_t v238 = *a2;
    }
    if (v236) {
      double v287 = *(double *)(a5 + 224);
    }
    double v252 = v287 / v251;
    long long v253 = *(_OWORD *)(v240 + 80);
    long long v338 = *(_OWORD *)(v240 + 64);
    long long v339 = v253;
    double v254 = v250 * -v249 * v252;
    *(double *)&long long v253 = fabs(*(double *)(v240 + 88));
    *(double *)&long long v338 = *(double *)(v240 + 64) + v254 * *(double *)&v253;
    double v255 = v250 * v248 * v252;
    *((double *)&v338 + 1) = *(double *)(v240 + 72) + v255 * *(double *)&v253;
    long long v256 = *(_OWORD *)(v240 + 112);
    long long v340 = *(_OWORD *)(v240 + 96);
    *(_OWORD *)uint64_t v341 = v256;
    *(double *)&long long v256 = fabs(*(double *)(v240 + 120));
    *(double *)&long long v340 = *(double *)(v240 + 96) + v254 * *(double *)&v256;
    *((double *)&v340 + 1) = *(double *)(v240 + 104) + v255 * *(double *)&v256;
    if (!v237) {
      goto LABEL_332;
    }
    if (!*(unsigned char *)(v238 + 136 * v237 + 131)) {
      goto LABEL_332;
    }
    unint64_t v257 = *(void *)(v291 + 368);
    if (v257 == *(void *)(v291 + 360)) {
      goto LABEL_332;
    }
    long long v324 = v334;
    long long v325 = v335;
    long long v330 = 0u;
    memset(v331, 0, sizeof(v331));
    char v332 = 1;
    uint64_t v304 = 0x3FF0000000000000;
    uint64_t v301 = 0x3FF0000000000000;
    uint64_t v298 = 0x3FF0000000000000;
    uint64_t v295 = 0x3FF0000000000000;
    long long v296 = 0u;
    long long v297 = 0u;
    long long v299 = 0u;
    long long v300 = 0u;
    long long v302 = 0u;
    long long v303 = 0u;
    int v333 = v343;
    long long v326 = v334;
    long long v327 = v335;
    long long v328 = v340;
    long long v329 = *(_OWORD *)v341;
    if (v236)
    {
      long long v258 = *(_OWORD *)(v257 - 56);
      long long v330 = *(_OWORD *)(v257 - 72);
      *(_OWORD *)unint64_t v331 = v258;
      OZShape::subdivideTriangle(v294, 1, (uint64_t)a4, a5, v280, (unint64_t)&v324, (long long *)(v257 - 136), (double *)&v334, v287, (double *)&v295, v290 < 1, 0);
    }
    else
    {
      long long v259 = *(_OWORD *)(v257 - 56);
      long long v330 = *(_OWORD *)(v257 - 72);
      *(_OWORD *)unint64_t v331 = v259;
      if (v257 >= *v279)
      {
        uint64_t v260 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v280, (uint64_t)&v324);
        uint64_t v261 = v291;
      }
      else
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v279, v257, (uint64_t)&v324);
        uint64_t v260 = v257 + 136;
        uint64_t v261 = v291;
        *(void *)(v291 + 368) = v257 + 136;
      }
      *(void *)(v261 + 368) = v260;
    }
    if (v344 == v158 && v237 == 0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 3) - 1)
    {
      uint64_t v262 = 0;
      long long v320 = 0u;
      memset(v321, 0, sizeof(v321));
      long long v318 = 0u;
      long long v319 = 0u;
      long long v316 = 0u;
      long long v317 = 0u;
      long long v314 = 0u;
      long long v315 = 0u;
      char v322 = 1;
      uint64_t v263 = *v280;
      uint64_t v264 = *v280 + 136 * v275;
      int v323 = 0;
      do
      {
        long long v265 = *(_OWORD *)(v264 + v262);
        long long v266 = *(_OWORD *)(v264 + v262 + 16);
        long long v267 = *(_OWORD *)(v264 + v262 + 48);
        uint64_t v268 = (long long *)((char *)&v305 + v262);
        v268[2] = *(_OWORD *)(v264 + v262 + 32);
        v268[3] = v267;
        _OWORD *v268 = v265;
        v268[1] = v266;
        v262 += 64;
      }
      while (v262 != 128);
      uint64_t v313 = *(void *)(v263 + 136 * v275 + 128);
      LOBYTE(v323) = v333;
      long long v314 = v336;
      long long v315 = (__int128)v337;
      long long v316 = v305;
      long long v317 = v306;
      long long v318 = v311;
      long long v319 = v312;
      long long v320 = v338;
      *(_OWORD *)float64_t v321 = v339;
      unint64_t v269 = *(void *)(v291 + 368);
      if (v269 >= *(void *)(v291 + 376))
      {
        unint64_t v270 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v280, (uint64_t)&v334);
        uint64_t v271 = v291;
      }
      else
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v279, *(void *)(v291 + 368), (uint64_t)&v334);
        unint64_t v270 = v269 + 136;
        uint64_t v271 = v291;
        *(void *)(v291 + 368) = v270;
      }
      *(void *)(v271 + 368) = v270;
      if (v270 < *(void *)(v271 + 376))
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v279, v270, (uint64_t)&v314);
        goto LABEL_334;
      }
      uint64_t ValueAsInt = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v280, (uint64_t)&v314);
    }
    else
    {
LABEL_332:
      unint64_t v270 = *(void *)(v291 + 368);
      if (v270 < *(void *)(v291 + 376))
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v279, *(void *)(v291 + 368), (uint64_t)&v334);
LABEL_334:
        uint64_t ValueAsInt = v270 + 136;
        uint64_t v272 = v291;
        *(void *)(v291 + 368) = v270 + 136;
LABEL_337:
        *(void *)(v272 + 368) = ValueAsInt;
        goto LABEL_338;
      }
      uint64_t ValueAsInt = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v280, (uint64_t)&v334);
    }
    uint64_t v272 = v291;
    goto LABEL_337;
  }
LABEL_344:
  if (a8)
  {
    char v274 = v288;
    if (!*(_DWORD *)(a5 + 168)) {
      char v274 = 1;
    }
    if ((v274 & 1) == 0) {
      OZShape::transformOutlinePolygonList(ValueAsInt, a2, v276, &v367);
    }
  }
  if (v349)
  {
    uint64_t v350 = (char *)v349;
    operator delete(v349);
  }
  if (v352)
  {
    uint64_t v353 = (char *)v352;
    operator delete(v352);
  }
  if (__p)
  {
    unint64_t v356 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1B7E300E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43)
{
  *(void *)(a43 + 368) = v43;
  double v45 = (void *)STACK[0x418];
  if (STACK[0x418])
  {
    STACK[0x420] = (unint64_t)v45;
    operator delete(v45);
  }
  unint64_t v46 = (void *)STACK[0x430];
  if (STACK[0x430])
  {
    STACK[0x438] = (unint64_t)v46;
    operator delete(v46);
  }
  long long v47 = (void *)STACK[0x448];
  if (STACK[0x448])
  {
    STACK[0x450] = (unint64_t)v47;
    operator delete(v47);
  }
  _Unwind_Resume(a1);
}

void OZShape::computeRoundCaps(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, uint64_t a10, double *a11, char a12)
{
  float64x2_t v88 = 0u;
  memset(v89, 0, 19);
  float64x2_t v86 = 0u;
  long long v87 = 0u;
  float64x2_t v84 = 0u;
  long long v85 = 0u;
  float64x2_t v82 = 0u;
  long long v83 = 0u;
  v89[19] = 1;
  *(_DWORD *)&v89[20] = 0;
  if (a12)
  {
    long long v22 = *(_OWORD *)(a6 + 16);
    float64x2_t v82 = *(float64x2_t *)a6;
    long long v83 = v22;
    float64x2_t v84 = v82;
    long long v85 = v22;
    double v23 = *(double *)(a6 + 56);
    *(void *)&long long v22 = *(void *)(a6 + 24);
    double v24 = *(double *)&v22 * *(double *)(a6 + 32) - v23 * *(double *)a6;
    double v25 = *(double *)&v22 * *(double *)(a6 + 40);
    *(double *)&long long v22 = v23 * *(double *)&v22;
    double v26 = v24 / *(double *)&v22;
    double v27 = (v25 - v23 * *(double *)(a6 + 8)) / *(double *)&v22;
    BOOL v28 = *(double *)&v22 < 0.0;
    if (*(double *)&v22 >= 0.0) {
      double v29 = v26;
    }
    else {
      double v29 = -v26;
    }
    if (v28) {
      double v30 = -v27;
    }
    else {
      double v30 = v27;
    }
    double v31 = sqrt(v29 * v29 + v30 * v30);
    double v32 = -v29 / v31 * a9;
    double v33 = (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
    unint64_t v34 = 0;
    v35.f64[0] = v32 / v33;
    *(_WORD *)&v89[20] = 256;
    long long v36 = *(_OWORD *)(a6 + 112);
    float64x2_t v86 = *(float64x2_t *)(a6 + 96);
    long long v87 = v36;
    v35.f64[1] = -v30 / v31 * a9;
    long long v37 = *(_OWORD *)(a6 + 16);
    float64x2_t v73 = v35;
    float64x2_t v88 = vaddq_f64(*(float64x2_t *)a6, vmulq_n_f64(v35, fabs(*(double *)(a6 + 24))));
    *(_OWORD *)unint64_t v89 = v37;
    do
    {
      long long v38 = *(long long *)((char *)&v82 + v34);
      long long v39 = *(long long *)((char *)&v82 + v34 + 16);
      long long v40 = *(long long *)((char *)&v85 + v34);
      uint64_t v41 = &v76[v34 / 0x10];
      v41[2] = *(long long *)((char *)&v84 + v34);
      v41[3] = v40;
      long long *v41 = v38;
      v41[1] = v39;
      v34 += 64;
    }
    while (v34 != 128);
    uint64_t v81 = *(void *)&v89[16];
    float64x2_t v77 = v88;
    long long v78 = *(_OWORD *)v89;
    OZShape::subdivideTriangle(a1, 1, a4, a5, a2, (unint64_t)&v82, v76, (double *)a6, a9, a11, 257, 1u);
    v89[20] = 1;
    long long v42 = *(_OWORD *)(a8 + 16);
    float64x2_t v82 = *(float64x2_t *)a8;
    long long v83 = v42;
    float64x2_t v84 = v82;
    long long v85 = v42;
    long long v43 = *(_OWORD *)(a8 + 112);
    float64x2_t v86 = *(float64x2_t *)(a8 + 96);
    long long v87 = v43;
    float64x2_t v88 = v82;
    *(_OWORD *)unint64_t v89 = v42;
    float64x2_t v88 = vaddq_f64(v82, vmulq_n_f64(v73, fabs(*(double *)(a8 + 24))));
    v76[2] = (__int128)v82;
    v76[3] = v42;
    v76[0] = (__int128)v82;
    v76[1] = v42;
    uint64_t v81 = *(void *)&v89[16];
    float64x2_t v79 = v88;
    long long v80 = v42;
    float64x2_t v77 = v88;
    long long v78 = v42;
    OZShape::subdivideTriangle(a1, 1, a4, a5, a3, (unint64_t)&v82, v76, (double *)a8, a9, a11, 256, 1u);
    *(unsigned char *)(a6 + 133) = 1;
    *(unsigned char *)(a8 + 133) = 1;
  }
  else
  {
    long long v45 = *(_OWORD *)(a7 + 48);
    float64x2_t v82 = *(float64x2_t *)(a7 + 32);
    long long v83 = v45;
    float64x2_t v84 = v82;
    long long v85 = v45;
    double v46 = *(double *)(a7 + 56);
    *(void *)&long long v45 = *(void *)(a7 + 24);
    double v47 = *(double *)(a7 + 40);
    double v48 = *(double *)(a7 + 8);
    double v49 = *(double *)&v45 * *(double *)(a7 + 32) - v46 * *(double *)a7;
    *(_WORD *)&v89[20] = 256;
    double v50 = *(double *)&v45 * v47;
    double v51 = v46 * *(double *)&v45;
    double v52 = v49 / v51;
    double v53 = (v50 - v46 * v48) / v51;
    if (v51 >= 0.0) {
      double v54 = v53;
    }
    else {
      double v54 = -v53;
    }
    if (v51 >= 0.0) {
      double v55 = v52;
    }
    else {
      double v55 = -v52;
    }
    double v56 = sqrt(v55 * v55 + v54 * v54);
    v57.f64[0] = v55 / v56 * a9 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
    v57.f64[1] = v54 / v56 * a9;
    long long v58 = *(_OWORD *)(a7 + 48);
    float64x2_t v86 = vaddq_f64(*(float64x2_t *)(a7 + 32), vmulq_n_f64(v57, fabs(*(double *)(a7 + 56))));
    long long v87 = v58;
    long long v59 = *(_OWORD *)(a7 + 80);
    float64x2_t v88 = *(float64x2_t *)(a7 + 64);
    *(_OWORD *)unint64_t v89 = v59;
    OZShape::subdivideTriangle(a1, 1, a4, a5, a2, (unint64_t)&v82, (long long *)a7, (double *)a7, a9, a11, 1, 1u);
    double v60 = *(double *)(a10 + 56);
    double v61 = *(double *)(a10 + 24);
    double v62 = v61 * *(double *)(a10 + 32) - v60 * *(double *)a10;
    double v63 = v61 * *(double *)(a10 + 40);
    double v64 = v60 * v61;
    double v65 = v62 / v64;
    double v66 = (v63 - v60 * *(double *)(a10 + 8)) / v64;
    if (v64 >= 0.0) {
      double v67 = v66;
    }
    else {
      double v67 = -v66;
    }
    if (v64 >= 0.0) {
      double v68 = v65;
    }
    else {
      double v68 = -v65;
    }
    double v69 = sqrt(v68 * v68 + v67 * v67);
    v70.f64[0] = v68 / v69 * a9 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
    v89[20] = 1;
    long long v71 = *(_OWORD *)(a10 + 48);
    float64x2_t v82 = *(float64x2_t *)(a10 + 32);
    long long v83 = v71;
    float64x2_t v84 = v82;
    long long v85 = v71;
    v70.f64[1] = v67 / v69 * a9;
    float64x2_t v86 = vaddq_f64(v82, vmulq_n_f64(v70, fabs(*(double *)(a10 + 56))));
    long long v87 = v71;
    long long v72 = *(_OWORD *)(a10 + 80);
    float64x2_t v88 = *(float64x2_t *)(a10 + 64);
    *(_OWORD *)unint64_t v89 = v72;
    OZShape::subdivideTriangle(a1, 1, a4, a5, a3, (unint64_t)&v82, (long long *)a10, (double *)a10, a9, a11, 0, 1u);
    *(unsigned char *)(a7 + 133) = 1;
    *(unsigned char *)(a10 + 133) = 1;
  }
}

unint64_t OZShape::computeBevelCaps(double a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, double *a6, uint64_t a7, double *a8, uint64_t a9, char a10)
{
  long long v61 = 0u;
  memset(v62, 0, sizeof(v62));
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  char v63 = 1;
  int v64 = 0;
  if (a10)
  {
    double v13 = a8[15];
    double v14 = a8[11];
    double v15 = v14 * v13;
    double v16 = (v13 * a8[8] - v14 * a8[12]) / (v14 * v13);
    double v17 = (v13 * a8[9] - v14 * a8[13]) / (v14 * v13);
    if (v15 < 0.0)
    {
      double v17 = -v17;
      double v16 = -v16;
    }
    double v18 = sqrt(v16 * v16 + v17 * v17);
    double v19 = -v16 / v18 * a1;
    double v20 = -v17 / v18 * a1;
    LOWORD(v64) = 257;
    long long v21 = *((_OWORD *)a8 + 1);
    long long v55 = *(_OWORD *)a8;
    long long v56 = v21;
    long long v57 = v55;
    long long v58 = v21;
    long long v22 = *((_OWORD *)a8 + 7);
    long long v59 = *((_OWORD *)a8 + 6);
    long long v60 = v22;
    long long v23 = *((_OWORD *)a8 + 1);
    long long v61 = *(_OWORD *)a8;
    *(_OWORD *)double v62 = v23;
    *(double *)&long long v22 = fabs(a8[3]);
    *(double *)&long long v23 = *a8 + v19 * *(double *)&v22;
    *(double *)&long long v22 = a8[1] + v20 * *(double *)&v22;
    *(void *)&long long v61 = v23;
    *((void *)&v61 + 1) = v22;
    uint64_t v24 = *a4;
    *(unsigned char *)(v24 + 133) = 1;
    std::vector<OZShapeEdgePolygon>::insert(a4, v24, (unint64_t)&v55);
    LOBYTE(v64) = 0;
    long long v25 = *((_OWORD *)a6 + 1);
    long long v55 = *(_OWORD *)a6;
    long long v56 = v25;
    long long v57 = v55;
    long long v58 = v25;
    long long v26 = *((_OWORD *)a6 + 7);
    long long v59 = *((_OWORD *)a6 + 6);
    long long v60 = v26;
    long long v61 = v55;
    *(_OWORD *)double v62 = v25;
    double v27 = fabs(a6[3]);
    *(double *)&long long v25 = *a6 + v19 * v27;
    double v28 = a6[1] + v20 * v27;
    *(void *)&long long v61 = v25;
    *((double *)&v61 + 1) = v28;
    uint64_t v29 = *a3;
    *(unsigned char *)(v29 + 133) = 1;
    return std::vector<OZShapeEdgePolygon>::insert(a3, v29, (unint64_t)&v55);
  }
  else
  {
    double v32 = *(double *)(a7 + 56);
    double v33 = *(double *)(a7 + 24);
    double v34 = *(double *)(a7 + 32);
    double v35 = v32 * v33;
    double v36 = (v33 * v34 - v32 * *(double *)a7) / (v32 * v33);
    double v37 = *(double *)(a7 + 40);
    double v38 = (v33 * v37 - v32 * *(double *)(a7 + 8)) / (v32 * v33);
    if (v35 >= 0.0)
    {
      double v39 = v36;
    }
    else
    {
      double v38 = -v38;
      double v39 = -v36;
    }
    double v40 = sqrt(v39 * v39 + v38 * v38);
    double v41 = v39 / v40 * a1;
    double v42 = v38 / v40 * a1;
    LOWORD(v64) = 256;
    long long v43 = *(_OWORD *)(a7 + 48);
    long long v55 = *(_OWORD *)(a7 + 32);
    long long v56 = v43;
    long long v57 = v55;
    long long v58 = v43;
    long long v60 = v43;
    double v44 = fabs(v32);
    *(double *)&long long v59 = v34 + v44 * v41;
    *((double *)&v59 + 1) = v37 + v44 * v42;
    long long v45 = *(_OWORD *)(a7 + 80);
    long long v61 = *(_OWORD *)(a7 + 64);
    *(_OWORD *)double v62 = v45;
    unint64_t v46 = a3[2];
    unint64_t v47 = a3[1];
    *(unsigned char *)(v47 - 3) = 1;
    if (v47 >= v46)
    {
      uint64_t v48 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a3, (uint64_t)&v55);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a3 + 2), v47, (uint64_t)&v55);
      uint64_t v48 = v47 + 136;
      a3[1] = v47 + 136;
    }
    a3[1] = v48;
    long long v49 = *(_OWORD *)(a9 + 48);
    long long v55 = *(_OWORD *)(a9 + 32);
    long long v56 = v49;
    long long v57 = v55;
    long long v58 = v49;
    long long v59 = v55;
    long long v60 = v49;
    double v50 = fabs(*(double *)(a9 + 56));
    double v51 = *(double *)(a9 + 32);
    double v52 = *(double *)(a9 + 40);
    LOBYTE(v64) = 1;
    *(double *)&long long v59 = v51 + v41 * v50;
    *((double *)&v59 + 1) = v52 + v42 * v50;
    long long v53 = *(_OWORD *)(a9 + 80);
    long long v61 = *(_OWORD *)(a9 + 64);
    *(_OWORD *)double v62 = v53;
    unint64_t v54 = a4[1];
    *(unsigned char *)(v54 - 3) = 1;
    if (v54 >= a4[2])
    {
      unint64_t result = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a4, (uint64_t)&v55);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 2), v54, (uint64_t)&v55);
      unint64_t result = v54 + 136;
      a4[1] = v54 + 136;
    }
    a4[1] = result;
  }
  return result;
}

void sub_1B7E30978(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1B7E30980(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

unint64_t OZShape::computeArrowCaps(double a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, double *a7, uint64_t a8, long long *a9, uint64_t a10, char a11)
{
  long long v155 = 0u;
  memset(v156, 0, sizeof(v156));
  long long v153 = 0u;
  long long v154 = 0u;
  long long v151 = 0u;
  long long v152 = 0u;
  long long v149 = 0u;
  long long v150 = 0u;
  char v157 = 1;
  int v158 = 0;
  if ((a11 & 1) == 0)
  {
    double v39 = *(double *)(a8 + 56);
    double v40 = *(double *)(a8 + 24);
    double v41 = (long long *)(a8 + 32);
    double v42 = *(double *)(a8 + 32);
    double v43 = v39 * v40;
    double v44 = (v40 * v42 - v39 * *(double *)a8) / (v39 * v40);
    double v45 = *(double *)(a8 + 40);
    double v46 = (v40 * v45 - v39 * *(double *)(a8 + 8)) / (v39 * v40);
    if (v43 >= 0.0)
    {
      double v47 = v44;
    }
    else
    {
      double v46 = -v46;
      double v47 = -v44;
    }
    double v48 = sqrt(v47 * v47 + v46 * v46);
    double v49 = *(double *)(a6 + 104);
    double v50 = *(double *)(a6 + 96) + 1.0;
    double v51 = v50 * (v47 / v48 * a1);
    double v52 = v50 * (v46 / v48 * a1);
    double v53 = *(double *)(a8 + 88);
    unint64_t v54 = (long long *)(a8 + 64);
    double v55 = *(double *)(a8 + 64);
    double v56 = *(double *)(a8 + 72);
    double v57 = v49 + 1.0;
    LOWORD(v158) = 256;
    if (fabs(v49) >= 0.0000001)
    {
      double v89 = (v39 * v55 - v42 * v53) / (v39 * v53);
      BOOL v90 = v39 * v53 < 0.0;
      if (v39 * v53 < 0.0) {
        double v89 = -v89;
      }
      double v91 = (v39 * v56 - v45 * v53) / (v39 * v53);
      if (v90) {
        double v91 = -v91;
      }
      long long v92 = *(_OWORD *)(a8 + 48);
      long long v149 = *v41;
      long long v150 = v92;
      long long v152 = v92;
      double v93 = fabs(v39);
      *(double *)&long long v151 = v42 + v93 * (v51 * 0.5);
      *((double *)&v151 + 1) = v45 + v93 * (v52 * 0.5);
      long long v154 = v92;
      double v94 = v57 * v89;
      double v95 = v57 * v91;
      *(double *)&long long v153 = v42 + v93 * (v57 * v89);
      *((double *)&v153 + 1) = v45 + v93 * (v57 * v91);
      long long v96 = *(_OWORD *)(a8 + 80);
      long long v155 = *v54;
      *(_OWORD *)int v156 = v96;
      unint64_t v97 = a3[1];
      if (v97 >= a3[2])
      {
        unint64_t v98 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a3, (uint64_t)&v149);
      }
      else
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a3 + 2), a3[1], (uint64_t)&v149);
        unint64_t v98 = v97 + 136;
        a3[1] = v98;
      }
      a3[1] = v98;
      long long v117 = v41[1];
      long long v149 = *v41;
      long long v150 = v117;
      double v118 = fabs(*(double *)(a8 + 56));
      double v119 = *(double *)(a8 + 32);
      double v120 = *(double *)(a8 + 40);
      *(double *)&long long v149 = v119 + v51 * 0.5 * v118;
      *((double *)&v149 + 1) = v120 + v52 * 0.5 * v118;
      long long v152 = v117;
      long long v151 = v149;
      long long v154 = v117;
      *(double *)&long long v153 = v119 + v51 * v118;
      *((double *)&v153 + 1) = v120 + v52 * v118;
      *(_OWORD *)int v156 = v41[1];
      *(double *)&long long v155 = v119 + v94 * v118;
      *((double *)&v155 + 1) = v120 + v95 * v118;
      *(unsigned char *)(v98 - 3) = 1;
      if (v98 < a3[2])
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a3 + 2), v98, (uint64_t)&v149);
        uint64_t v63 = v98 + 136;
        goto LABEL_35;
      }
    }
    else
    {
      long long v58 = *(_OWORD *)(a8 + 48);
      long long v149 = *v41;
      long long v150 = v58;
      long long v151 = v149;
      long long v152 = v58;
      long long v154 = v58;
      double v59 = fabs(v39);
      *(double *)&long long v153 = v42 + v59 * v51;
      *((double *)&v153 + 1) = v45 + v59 * v52;
      long long v60 = *(_OWORD *)(a8 + 80);
      long long v155 = *v54;
      *(_OWORD *)int v156 = v60;
      unint64_t v61 = a3[2];
      unint64_t v62 = a3[1];
      *(unsigned char *)(v62 - 3) = 1;
      if (v62 < v61)
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a3 + 2), v62, (uint64_t)&v149);
        uint64_t v63 = v62 + 136;
LABEL_35:
        a3[1] = v63;
        goto LABEL_37;
      }
    }
    uint64_t v63 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a3, (uint64_t)&v149);
LABEL_37:
    a3[1] = v63;
    unint64_t v121 = (long long *)(a10 + 64);
    double v122 = *(double *)(a10 + 64);
    double v123 = *(double *)(a10 + 88);
    double v124 = *(double *)(a10 + 56);
    uint64_t v125 = (long long *)(a10 + 32);
    double v126 = *(double *)(a10 + 32);
    double v127 = *(double *)(a10 + 72);
    double v128 = *(double *)(a10 + 40);
    LOBYTE(v158) = 1;
    if (fabs(*(double *)(a6 + 104)) >= 0.0000001)
    {
      double v134 = (v124 * v122 - v123 * v126) / (v123 * v124);
      BOOL v135 = v123 * v124 < 0.0;
      if (v123 * v124 < 0.0) {
        double v134 = -v134;
      }
      double v136 = (v124 * v127 - v123 * v128) / (v123 * v124);
      if (v135) {
        double v136 = -v136;
      }
      long long v137 = *(_OWORD *)(a10 + 48);
      long long v149 = *v125;
      long long v150 = v137;
      long long v152 = v137;
      double v138 = fabs(v124);
      *(double *)&long long v151 = v126 + v51 * 0.5 * v138;
      *((double *)&v151 + 1) = v52 * 0.5 * v138 + v128;
      long long v154 = v137;
      double v139 = v57 * v134;
      double v140 = v138 * (v57 * v134);
      double v141 = v57 * v136;
      *(double *)&long long v153 = v126 + v140;
      *((double *)&v153 + 1) = v128 + v138 * v141;
      long long v142 = *(_OWORD *)(a10 + 80);
      long long v155 = *v121;
      *(_OWORD *)int v156 = v142;
      unint64_t v143 = a4[1];
      if (v143 >= a4[2])
      {
        unint64_t v144 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a4, (uint64_t)&v149);
      }
      else
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 2), a4[1], (uint64_t)&v149);
        unint64_t v144 = v143 + 136;
        a4[1] = v144;
      }
      a4[1] = v144;
      long long v145 = *(_OWORD *)(a10 + 48);
      long long v149 = *v125;
      long long v150 = v145;
      double v146 = fabs(*(double *)(a10 + 56));
      double v147 = *(double *)(a10 + 32);
      double v148 = *(double *)(a10 + 40);
      *(double *)&long long v149 = v147 + v51 * 0.5 * v146;
      *((double *)&v149 + 1) = v148 + v52 * 0.5 * v146;
      long long v152 = v145;
      long long v151 = v149;
      long long v154 = v145;
      *(double *)&long long v153 = v147 + v51 * v146;
      *((double *)&v153 + 1) = v148 + v52 * v146;
      *(_OWORD *)int v156 = *(_OWORD *)(a10 + 48);
      *(double *)&long long v155 = v147 + v139 * v146;
      *((double *)&v155 + 1) = v148 + v141 * v146;
      *(unsigned char *)(v144 - 3) = 1;
      if (v144 < a4[2])
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 2), v144, (uint64_t)&v149);
        unint64_t result = v144 + 136;
        goto LABEL_49;
      }
    }
    else
    {
      long long v129 = *(_OWORD *)(a10 + 48);
      long long v149 = *v125;
      long long v150 = v129;
      long long v151 = v149;
      long long v152 = v129;
      long long v154 = v129;
      double v130 = fabs(v124);
      *(double *)&long long v153 = v126 + v51 * v130;
      *((double *)&v153 + 1) = v52 * v130 + v128;
      long long v131 = *(_OWORD *)(a10 + 80);
      long long v155 = *v121;
      *(_OWORD *)int v156 = v131;
      unint64_t v132 = a4[2];
      unint64_t v133 = a4[1];
      *(unsigned char *)(v133 - 3) = 1;
      if (v133 < v132)
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 2), v133, (uint64_t)&v149);
        unint64_t result = v133 + 136;
LABEL_49:
        a4[1] = result;
LABEL_51:
        a4[1] = result;
        return result;
      }
    }
    unint64_t result = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a4, (uint64_t)&v149);
    goto LABEL_51;
  }
  double v16 = a9 + 6;
  double v17 = *((double *)a9 + 11);
  double v18 = *((double *)a9 + 15);
  double v19 = v17 * v18;
  double v21 = *((double *)a9 + 7);
  double v20 = *((double *)a9 + 8);
  double v22 = (v18 * v20 - v17 * *((double *)a9 + 12)) / (v17 * v18);
  double v23 = *((double *)a9 + 9);
  double v24 = (v18 * v23 - v17 * *((double *)a9 + 13)) / (v17 * v18);
  if (v19 >= 0.0)
  {
    double v25 = v22;
  }
  else
  {
    double v24 = -v24;
    double v25 = -v22;
  }
  double v26 = sqrt(v25 * v25 + v24 * v24);
  double v27 = *(double *)(a6 + 104);
  double v28 = *(double *)(a6 + 96) + 1.0;
  double v29 = v28 * (-v25 / v26 * a1);
  double v30 = v28 * (-v24 / v26 * a1);
  double v31 = *((double *)a9 + 4);
  double v32 = *((double *)a9 + 5);
  double v33 = v27 + 1.0;
  LOWORD(v158) = 257;
  if (fabs(v27) >= 0.0000001)
  {
    double v64 = (v23 * v21 - v17 * v32) / (v17 * v21);
    if (v17 * v21 < 0.0) {
      double v64 = -v64;
    }
    double v65 = (v20 * v21 - v17 * v31) / (v17 * v21);
    if (v17 * v21 < 0.0) {
      double v65 = -v65;
    }
    long long v67 = a9[1];
    long long v149 = *a9;
    long long v66 = v149;
    long long v150 = v67;
    double v68 = fabs(*((double *)a9 + 3));
    double v69 = *(double *)a9;
    double v70 = *((double *)a9 + 1);
    *(double *)&long long v149 = *(double *)a9 + v29 * 0.5 * v68;
    *((double *)&v149 + 1) = v70 + v30 * 0.5 * v68;
    long long v151 = v66;
    long long v152 = v67;
    long long v71 = a9[7];
    long long v153 = *v16;
    long long v154 = v71;
    *(_OWORD *)int v156 = v67;
    double v72 = v33 * v65;
    double v73 = v33 * v64;
    *(double *)&long long v155 = v69 + v33 * v65 * v68;
    *((double *)&v155 + 1) = v70 + v33 * v64 * v68;
    std::vector<OZShapeEdgePolygon>::insert(a4, *a4, (unint64_t)&v149);
    long long v74 = a9[1];
    long long v149 = *a9;
    long long v150 = v74;
    double v75 = fabs(*((double *)a9 + 3));
    double v76 = *(double *)a9;
    double v77 = *((double *)a9 + 1);
    *(double *)&long long v149 = *(double *)a9 + v29 * 0.5 * v75;
    *((double *)&v149 + 1) = v77 + v30 * 0.5 * v75;
    long long v152 = v74;
    long long v151 = v149;
    long long v154 = v74;
    *(double *)&long long v153 = v76 + v72 * v75;
    *((double *)&v153 + 1) = v77 + v73 * v75;
    *(_OWORD *)int v156 = v74;
    *(double *)&long long v155 = v76 + v29 * v75;
    *((double *)&v155 + 1) = v77 + v30 * v75;
  }
  else
  {
    long long v34 = a9[1];
    long long v149 = *a9;
    long long v150 = v34;
    long long v151 = v149;
    long long v152 = v34;
    long long v35 = a9[7];
    long long v153 = *v16;
    long long v154 = v35;
    long long v155 = v149;
    *(_OWORD *)int v156 = v34;
    double v36 = fabs(*((double *)a9 + 3));
    *(double *)&long long v34 = *(double *)a9 + v29 * v36;
    double v37 = *((double *)a9 + 1) + v30 * v36;
    *(void *)&long long v155 = v34;
    *((double *)&v155 + 1) = v37;
  }
  uint64_t v78 = *a4;
  *(unsigned char *)(v78 + 133) = 1;
  std::vector<OZShapeEdgePolygon>::insert(a4, v78, (unint64_t)&v149);
  double v79 = a7[11];
  double v80 = a7[7];
  double v81 = a7[8];
  double v82 = a7[9];
  double v83 = a7[4];
  double v84 = a7[5];
  LOBYTE(v158) = 0;
  if (fabs(*(double *)(a6 + 104)) >= 0.0000001)
  {
    double v99 = (v80 * v82 - v79 * v84) / (v79 * v80);
    BOOL v100 = v79 * v80 < 0.0;
    if (v79 * v80 < 0.0) {
      double v99 = -v99;
    }
    double v101 = (v80 * v81 - v79 * v83) / (v79 * v80);
    if (v100) {
      double v101 = -v101;
    }
    long long v103 = *((_OWORD *)a7 + 1);
    long long v149 = *(_OWORD *)a7;
    long long v102 = v149;
    long long v150 = v103;
    double v104 = fabs(a7[3]);
    double v105 = *a7;
    double v106 = a7[1];
    *(double *)&long long v149 = *a7 + v29 * 0.5 * v104;
    *((double *)&v149 + 1) = v106 + v30 * 0.5 * v104;
    long long v151 = v102;
    long long v152 = v103;
    long long v107 = *((_OWORD *)a7 + 7);
    long long v153 = *((_OWORD *)a7 + 6);
    long long v154 = v107;
    *(_OWORD *)int v156 = v103;
    double v108 = v33 * v101;
    double v109 = v105 + v33 * v101 * v104;
    double v110 = v33 * v99;
    *(double *)&long long v155 = v109;
    *((double *)&v155 + 1) = v106 + v110 * v104;
    std::vector<OZShapeEdgePolygon>::insert(a3, *a3, (unint64_t)&v149);
    long long v111 = *((_OWORD *)a7 + 1);
    long long v149 = *(_OWORD *)a7;
    long long v150 = v111;
    double v112 = fabs(a7[3]);
    double v113 = *a7;
    double v114 = a7[1];
    *(double *)&long long v149 = *a7 + v29 * 0.5 * v112;
    *((double *)&v149 + 1) = v114 + v30 * 0.5 * v112;
    long long v152 = v111;
    long long v151 = v149;
    long long v154 = v111;
    *(double *)&long long v153 = v113 + v108 * v112;
    *((double *)&v153 + 1) = v114 + v110 * v112;
    *(_OWORD *)int v156 = v111;
    *(double *)&long long v155 = v113 + v29 * v112;
    *((double *)&v155 + 1) = v114 + v30 * v112;
  }
  else
  {
    long long v85 = *((_OWORD *)a7 + 1);
    long long v149 = *(_OWORD *)a7;
    long long v150 = v85;
    long long v151 = v149;
    long long v152 = v85;
    long long v86 = *((_OWORD *)a7 + 7);
    long long v153 = *((_OWORD *)a7 + 6);
    long long v154 = v86;
    long long v155 = v149;
    *(_OWORD *)int v156 = v85;
    double v87 = fabs(a7[3]);
    *(double *)&long long v85 = *a7 + v29 * v87;
    double v88 = a7[1] + v30 * v87;
    *(void *)&long long v155 = v85;
    *((double *)&v155 + 1) = v88;
  }
  uint64_t v115 = *a3;
  *(unsigned char *)(v115 + 133) = 1;
  return std::vector<OZShapeEdgePolygon>::insert(a3, v115, (unint64_t)&v149);
}

void sub_1B7E31270(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1B7E3127C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1B7E31284(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1B7E31290(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

unint64_t OZShape::computeNormalCaps(double a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, double *a6, uint64_t a7, double *a8, uint64_t a9, char a10, char a11)
{
  long long v128 = 0u;
  memset(v129, 0, sizeof(v129));
  long long v126 = 0u;
  long long v127 = 0u;
  long long v124 = 0u;
  long long v125 = 0u;
  long long v122 = 0u;
  long long v123 = 0u;
  char v130 = 1;
  int v131 = 0;
  long long v118 = 0u;
  memset(v119, 0, sizeof(v119));
  long long v116 = 0u;
  long long v117 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  long long v112 = 0u;
  long long v113 = 0u;
  char v120 = 1;
  int v121 = 0;
  long long v108 = 0u;
  memset(v109, 0, sizeof(v109));
  long long v106 = 0u;
  long long v107 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  char v110 = 1;
  int v111 = 0;
  long long v98 = 0u;
  memset(v99, 0, sizeof(v99));
  long long v96 = 0u;
  long long v97 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  char v100 = 1;
  int v101 = 0;
  if (a10)
  {
    double v13 = a8[15];
    double v14 = a8[11];
    double v15 = a8[12];
    double v16 = v14 * v13;
    double v17 = (v13 * a8[8] - v14 * v15) / (v14 * v13);
    double v18 = a8[13];
    double v19 = (v13 * a8[9] - v14 * v18) / (v14 * v13);
    BOOL v20 = v16 < 0.0;
    if (v16 >= 0.0) {
      double v21 = v17;
    }
    else {
      double v21 = -v17;
    }
    if (v20) {
      double v22 = -v19;
    }
    else {
      double v22 = v19;
    }
    LOWORD(v131) = 257;
    long long v23 = *((_OWORD *)a8 + 1);
    long long v122 = *(_OWORD *)a8;
    long long v123 = v23;
    long long v124 = v122;
    long long v125 = v23;
    double v24 = sqrt(v21 * v21 + v22 * v22);
    double v25 = -v21 / v24 * a1;
    long long v26 = *((_OWORD *)a8 + 7);
    long long v126 = *((_OWORD *)a8 + 6);
    long long v127 = v26;
    *(_OWORD *)long long v129 = *((_OWORD *)a8 + 7);
    double v27 = -v22 / v24 * a1;
    double v28 = fabs(v13);
    *(double *)&long long v128 = v15 + v28 * v25;
    *((double *)&v128 + 1) = v18 + v28 * v27;
    LOWORD(v121) = 257;
    long long v29 = *((_OWORD *)a8 + 1);
    long long v112 = *(_OWORD *)a8;
    long long v113 = v29;
    long long v114 = v112;
    long long v115 = v29;
    long long v117 = *(_OWORD *)v129;
    long long v116 = v128;
    long long v118 = v112;
    *(_OWORD *)double v119 = v29;
    double v30 = fabs(a8[3]);
    double v31 = *a8 + v25 * v30;
    double v32 = a8[1] + v27 * v30;
    *(double *)&long long v118 = v31;
    *((double *)&v118 + 1) = v32;
    BYTE1(v111) = 1;
    long long v33 = *((_OWORD *)a6 + 1);
    long long v102 = *(_OWORD *)a6;
    long long v103 = v33;
    long long v104 = v102;
    long long v105 = v33;
    long long v34 = *((_OWORD *)a6 + 7);
    long long v106 = *((_OWORD *)a6 + 6);
    long long v107 = v34;
    long long v108 = v106;
    *(_OWORD *)double v109 = v34;
    double v35 = fabs(a6[15]);
    *(double *)&long long v34 = a6[12] + v25 * v35;
    double v36 = a6[13] + v27 * v35;
    *(void *)&long long v108 = v34;
    *((double *)&v108 + 1) = v36;
    BYTE1(v101) = 1;
    long long v37 = *((_OWORD *)a6 + 1);
    long long v92 = *(_OWORD *)a6;
    long long v93 = v37;
    long long v38 = *((_OWORD *)a6 + 1);
    long long v94 = *(_OWORD *)a6;
    long long v95 = v38;
    long long v97 = *((_OWORD *)a6 + 7);
    *(void *)&long long v96 = v34;
    *((double *)&v96 + 1) = v36;
    long long v39 = *((_OWORD *)a6 + 1);
    long long v98 = *(_OWORD *)a6;
    *(_OWORD *)double v99 = v39;
    *(double *)&long long v34 = fabs(a6[3]);
    double v40 = a6[1] + v27 * *(double *)&v34;
    *(double *)&long long v98 = *a6 + v25 * *(double *)&v34;
    *((double *)&v98 + 1) = v40;
    if (a11)
    {
      unint64_t v41 = (a3[1] - *a3) / 136;
      if (v41 >= 0x28) {
        unint64_t v41 = 40;
      }
      if (v41)
      {
        double v42 = (unsigned char *)(*a3 + 134);
        do
        {
          unsigned char *v42 = 1;
          v42 += 136;
          --v41;
        }
        while (v41);
      }
      uint64_t v43 = *a4;
      uint64_t v44 = 40;
      if ((unint64_t)((a4[1] - *a4) / 136) < 0x28) {
        uint64_t v44 = (a4[1] - *a4) / 136;
      }
      if (v44)
      {
        uint64_t v45 = 0;
        uint64_t v46 = 136 * v44;
        do
        {
          *(unsigned char *)(v43 + v45 + 134) = 1;
          v45 += 136;
        }
        while (v46 != v45);
      }
    }
    else
    {
      uint64_t v43 = *a4;
    }
    *(unsigned char *)(v43 + 133) = 1;
    std::vector<OZShapeEdgePolygon>::insert(a4, v43, (unint64_t)&v122);
    std::vector<OZShapeEdgePolygon>::insert(a4, *a4, (unint64_t)&v112);
    uint64_t v86 = *a3;
    *(unsigned char *)(v86 + 133) = 1;
    std::vector<OZShapeEdgePolygon>::insert(a3, v86, (unint64_t)&v102);
    return std::vector<OZShapeEdgePolygon>::insert(a3, *a3, (unint64_t)&v92);
  }
  else
  {
    double v47 = *(double *)(a7 + 56);
    double v48 = *(double *)(a7 + 24);
    double v49 = *(double *)(a7 + 32);
    double v50 = v47 * v48;
    double v51 = (v48 * v49 - v47 * *(double *)a7) / (v47 * v48);
    double v52 = *(double *)(a7 + 40);
    double v53 = (v48 * v52 - v47 * *(double *)(a7 + 8)) / (v47 * v48);
    if (v50 >= 0.0)
    {
      double v54 = v51;
    }
    else
    {
      double v53 = -v53;
      double v54 = -v51;
    }
    BYTE1(v131) = 1;
    long long v55 = *(_OWORD *)(a7 + 48);
    long long v122 = *(_OWORD *)(a7 + 32);
    long long v123 = v55;
    long long v124 = v122;
    long long v125 = v55;
    long long v56 = *(_OWORD *)(a7 + 80);
    long long v126 = *(_OWORD *)(a7 + 64);
    long long v127 = v56;
    double v57 = sqrt(v54 * v54 + v53 * v53);
    double v58 = v54 / v57;
    double v59 = v53 / v57;
    double v60 = v58 * a1;
    double v61 = v59 * a1;
    double v62 = fabs(*(double *)(a7 + 88));
    double v63 = *(double *)(a7 + 64) + v62 * v60;
    double v64 = *(double *)(a7 + 72) + v62 * v61;
    *(double *)&long long v126 = v63;
    *((double *)&v126 + 1) = v64;
    long long v65 = *(_OWORD *)(a7 + 80);
    long long v128 = *(_OWORD *)(a7 + 64);
    *(_OWORD *)long long v129 = v65;
    BYTE1(v121) = 1;
    long long v66 = *(_OWORD *)(a7 + 48);
    long long v112 = *(_OWORD *)(a7 + 32);
    long long v113 = v66;
    long long v114 = v112;
    long long v115 = v66;
    long long v117 = v66;
    double v67 = fabs(v47);
    *(double *)&long long v116 = v49 + v67 * v60;
    *((double *)&v116 + 1) = v52 + v67 * v61;
    *(_OWORD *)double v119 = *(_OWORD *)(a7 + 80);
    *(double *)&long long v118 = v63;
    *((double *)&v118 + 1) = v64;
    LOWORD(v111) = 257;
    long long v68 = *(_OWORD *)(a9 + 48);
    long long v102 = *(_OWORD *)(a9 + 32);
    long long v103 = v68;
    long long v104 = v102;
    long long v105 = v68;
    long long v69 = *(_OWORD *)(a9 + 80);
    long long v106 = *(_OWORD *)(a9 + 64);
    long long v107 = v69;
    double v70 = fabs(*(double *)(a9 + 88));
    *(double *)&long long v69 = *(double *)(a9 + 64) + v60 * v70;
    double v71 = *(double *)(a9 + 72) + v61 * v70;
    *(void *)&long long v106 = v69;
    *((double *)&v106 + 1) = v71;
    long long v72 = *(_OWORD *)(a9 + 80);
    long long v108 = *(_OWORD *)(a9 + 64);
    *(_OWORD *)double v109 = v72;
    LOWORD(v101) = 257;
    long long v73 = *(_OWORD *)(a9 + 48);
    long long v92 = *(_OWORD *)(a9 + 32);
    long long v93 = v73;
    long long v74 = *(_OWORD *)(a9 + 48);
    long long v94 = *(_OWORD *)(a9 + 32);
    long long v95 = v74;
    long long v75 = *(_OWORD *)(a9 + 48);
    long long v96 = *(_OWORD *)(a9 + 32);
    long long v97 = v75;
    double v76 = fabs(*(double *)(a9 + 56));
    double v77 = *(double *)(a9 + 40);
    *(double *)&long long v96 = *(double *)(a9 + 32) + v60 * v76;
    *((double *)&v96 + 1) = v77 + v61 * v76;
    *(_OWORD *)double v99 = *(_OWORD *)(a9 + 80);
    *(void *)&long long v98 = v69;
    *((double *)&v98 + 1) = v71;
    unint64_t v78 = a3[1];
    if (a11)
    {
      unint64_t v79 = (uint64_t)(v78 - *a3) / 136;
      uint64_t v80 = 40;
      if (v79 < 0x28) {
        uint64_t v80 = (uint64_t)(v78 - *a3) / 136;
      }
      if (v80)
      {
        double v81 = (unsigned char *)(*a3 + 136 * v79 - 2);
        do
        {
          unsigned char *v81 = 1;
          v81 -= 136;
          --v80;
        }
        while (v80);
      }
      unint64_t v82 = (a4[1] - *a4) / 136;
      uint64_t v83 = 40;
      if (v82 < 0x28) {
        uint64_t v83 = (a4[1] - *a4) / 136;
      }
      if (v83)
      {
        double v84 = (unsigned char *)(*a4 + 136 * v82 - 2);
        do
        {
          *double v84 = 1;
          v84 -= 136;
          --v83;
        }
        while (v83);
      }
    }
    *(unsigned char *)(v78 - 3) = 1;
    if (v78 >= a3[2])
    {
      unint64_t v85 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a3, (uint64_t)&v122);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a3 + 2), v78, (uint64_t)&v122);
      unint64_t v85 = v78 + 136;
      a3[1] = v85;
    }
    a3[1] = v85;
    if (v85 >= a3[2])
    {
      uint64_t v88 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a3, (uint64_t)&v112);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a3 + 2), v85, (uint64_t)&v112);
      uint64_t v88 = v85 + 136;
      a3[1] = v85 + 136;
    }
    a3[1] = v88;
    unint64_t v89 = a4[2];
    unint64_t v90 = a4[1];
    *(unsigned char *)(v90 - 3) = 1;
    if (v90 >= v89)
    {
      unint64_t v91 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a4, (uint64_t)&v102);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 2), v90, (uint64_t)&v102);
      unint64_t v91 = v90 + 136;
      a4[1] = v91;
    }
    a4[1] = v91;
    if (v91 >= a4[2])
    {
      unint64_t result = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a4, (uint64_t)&v92);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 2), v91, (uint64_t)&v92);
      unint64_t result = v91 + 136;
      a4[1] = v91 + 136;
    }
    a4[1] = result;
  }
  return result;
}

void sub_1B7E318B4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1B7E318C0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void OZShape::subdivideTriangle(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t *a5, unint64_t a6, long long *a7, double *a8, double a9, double *a10, __int16 a11, unsigned __int8 a12)
{
  uint64_t v214 = *MEMORY[0x1E4F143B8];
  char v19 = *(unsigned char *)(a6 + 132);
  long long v195 = 0u;
  long long v196 = 0u;
  long long v197 = 0u;
  long long v198 = 0u;
  long long v199 = 0u;
  long long v200 = 0u;
  memset(v201, 0, sizeof(v201));
  char v202 = 1;
  char v203 = v19;
  __int16 v204 = 0;
  char v205 = 0;
  long long v212 = 0u;
  memset(v213, 0, sizeof(v213));
  long long v210 = 0u;
  long long v211 = 0u;
  long long v208 = 0u;
  long long v209 = 0u;
  long long v206 = 0u;
  long long v207 = 0u;
  double v183 = (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
  if (!OZShapeEdgePolygon::isValid((OZShapeEdgePolygon *)a6)) {
    return;
  }
  double v20 = 4.0 / a9;
  if (((4.0 / a9 <= 0.174532925) & a12) == 0) {
    double v20 = 0.174532925;
  }
  double v180 = v20;
  double v21 = 1.0;
  if (*(_DWORD *)(a4 + 8))
  {
    double v22 = 1.0;
  }
  else
  {
    double v22 = 1.0;
    if (fabs(*(double *)(a4 + 224)) >= 0.0000001)
    {
      long long v23 = (const CMTime *)MEMORY[0x1E4F1FA48];
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 13416), MEMORY[0x1E4F1FA48], 0.0);
      double v22 = v24;
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 13568), v23, 0.0);
    }
  }
  double v25 = *(double *)(a6 + 120);
  double v26 = *(double *)(a6 + 24);
  double v27 = *(double *)(a6 + 96);
  unint64_t v176 = (_OWORD *)(a6 + 96);
  double v174 = *(double *)(a6 + 8);
  double v175 = *(double *)a6;
  double v28 = (v26 * v27 - v25 * *(double *)a6) / (v25 * v26);
  double v29 = *(double *)(a6 + 104);
  if (v25 * v26 >= 0.0) {
    double v30 = (v26 * v29 - v25 * v174) / (v25 * v26);
  }
  else {
    double v30 = -((v26 * v29 - v25 * v174) / (v25 * v26));
  }
  if (v25 * v26 < 0.0) {
    double v28 = -v28;
  }
  double v31 = *(double *)(a6 + 88);
  double v32 = *(double *)(a6 + 56);
  double v33 = v31 * v32;
  double v179 = (long long *)(a6 + 64);
  long long v34 = (long long *)(a6 + 32);
  double v35 = (v32 * *(double *)(a6 + 64) - v31 * *(double *)(a6 + 32)) / (v31 * v32);
  double v36 = (v32 * *(double *)(a6 + 72) - v31 * *(double *)(a6 + 40)) / (v31 * v32);
  if (v33 >= 0.0)
  {
    double v37 = v35;
  }
  else
  {
    double v36 = -v36;
    double v37 = -v35;
  }
  double v177 = v22;
  double v178 = v21;
  double v38 = v183 * v22 * v28;
  double v39 = v21 * v30;
  double v40 = v183 * v22 * v37;
  double v41 = v21 * v36;
  double v42 = fabs(v38) >= 0.0000001 ? v38 : 0.0;
  double v43 = fabs(v40) >= 0.0000001 ? v40 : 0.0;
  double v44 = fabs(v39) >= 0.0000001 ? v39 : 0.0;
  double v45 = fabs(v41) >= 0.0000001 ? v41 : 0.0;
  if (a9 == 0.0) {
    return;
  }
  double v46 = sqrt(v42 * v42 + v44 * v44);
  if (v46 == 0.0) {
    return;
  }
  double v47 = sqrt(v43 * v43 + v45 * v45);
  if (v47 == 0.0) {
    return;
  }
  double v173 = *(double *)(a6 + 24);
  double v169 = a9;
  double v48 = (v42 * a9 + v44 * 0.0) / (v46 * a9);
  double v49 = (v42 * v43 + v44 * v45) / (v46 * v47);
  long double v50 = 1.0;
  long double v51 = 1.0;
  if (v48 <= 1.0)
  {
    long double v51 = v48;
    if (v48 < -1.0) {
      long double v51 = -1.0;
    }
  }
  double v170 = v43;
  double v171 = *(double *)(a6 + 72);
  double v172 = *(double *)(a6 + 64);
  double v52 = *(double *)(a6 + 120);
  if (v49 <= 1.0)
  {
    long double v50 = v49;
    if (v49 < -1.0) {
      long double v50 = -1.0;
    }
  }
  double v53 = acos(v51);
  if (v44 < 0.0) {
    double v53 = -v53;
  }
  double v168 = v53;
  double v54 = v53;
  double v55 = acos(v50);
  if ((*(void *)&v54 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*(void *)&v55 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || vabdd_f64(0.0, v55) < 0.0000001)
  {
    return;
  }
  double v56 = v52;
  double v57 = v42 * v45 - v44 * v170;
  if (!(_BYTE)a11)
  {
    double v58 = v168;
    if (v57 >= 0.0 || a2 != 1 || fabs(v57) < 0.0000001)
    {
      double v59 = v168 + v55;
      goto LABEL_55;
    }
LABEL_50:
    double v60 = a5;
    uint64_t v61 = a5[1];
    if (v61 != *a5 && fabs(v55) > v180)
    {
      *(unsigned char *)(v61 - 1) = 1;
      *(unsigned char *)(a6 + 135) = 1;
    }
LABEL_118:
    std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100](v60, a6);
    return;
  }
  double v58 = v168;
  if (v57 > 0.0 && a2 == 1 && fabs(v57) >= 0.0000001) {
    goto LABEL_50;
  }
  double v59 = v168 - v55;
LABEL_55:
  double v62 = v59 - v58;
  if (a2 == 2 || (double v63 = fabs(v62), !a2) && v63 <= v180)
  {
    if (v56 * v31 >= 0.0) {
      double v64 = (v56 * v171 - v29 * v31) / (v56 * v31);
    }
    else {
      double v64 = -((v56 * v171 - v29 * v31) / (v56 * v31));
    }
    if (v56 * v31 >= 0.0) {
      double v65 = (v56 * v172 - v27 * v31) / (v56 * v31);
    }
    else {
      double v65 = -((v56 * v172 - v27 * v31) / (v56 * v31));
    }
    BOOL v66 = v57 <= 0.0;
    if (!(_BYTE)a11) {
      BOOL v66 = v57 >= 0.0;
    }
    if (v66)
    {
      long long v191 = 0uLL;
      __double2 v67 = __sincos_stret(v168 + v62 * 0.5);
      *(double *)&long long v194 = v175 + v173 * (v67.__cosval * v169 / v183 / v177);
      *((double *)&v194 + 1) = v174 + v173 * (v67.__sinval * v169 / v178);
      long long v68 = *(_OWORD *)(a6 + 16);
      long long v195 = *(_OWORD *)a6;
      long long v196 = v68;
      long long v69 = *(_OWORD *)(a6 + 48);
      long long v197 = *v34;
      long long v198 = v69;
      long long v70 = *(_OWORD *)(a6 + 80);
      long long v199 = *v179;
      long long v200 = v70;
      long long v71 = *(_OWORD *)(a6 + 112);
      *(_OWORD *)long long v201 = *v176;
      *(_OWORD *)&v201[16] = v71;
      *(void *)&long long v71 = *((void *)a7 + 15);
      double v72 = *((double *)a7 + 11);
      double v73 = *(double *)&v71 * v72;
      double v74 = *((double *)a7 + 13);
      *(void *)&long long v184 = *((void *)a7 + 12);
      *((double *)&v184 + 1) = v74;
      double v75 = *(double *)&v71 * *((double *)a7 + 8) - v72 * *(double *)&v184 / (*(double *)&v71 * v72);
      double v76 = *(double *)&v71 * *((double *)a7 + 9) - v72 * v74 / (*(double *)&v71 * v72);
      *(double *)&double v188 = v75;
      double v189 = v76;
      if (v73 < 0.0)
      {
        double v75 = -v75;
        double v76 = -v76;
        *(double *)&double v188 = v75;
        double v189 = v76;
      }
      double v77 = sqrt(v75 * v75 + v76 * v76);
      if (v77 <= -0.000000100000001 || v77 >= 0.000000100000001)
      {
        *(double *)&double v188 = v75 / v77;
        double v189 = v76 / v77;
      }
      double v192 = -v65;
      double v193 = -v64;
      double v78 = sqrt(v65 * v65 + v64 * v64);
      BOOL v79 = v78 >= 0.000000100000001 || v78 <= -0.000000100000001;
      if (v79)
      {
        double v192 = -v65 / v78;
        double v193 = -v64 / v78;
      }
      __p[0] = 0;
      __p[1] = 0;
      *(void *)&long long v187 = 0;
      if (PCAlgorithm::findIntersection((double *)&v184, (double *)&v188, (double *)&v194, &v192, (double *)&v191))
      {
        long long v80 = *v176;
        long long v199 = v191;
        *(_OWORD *)long long v201 = v80;
        v201[32] = 1;
        v201[34] = 0;
        std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)__p, (uint64_t)&v195);
        *(_OWORD *)long long v201 = v191;
        long long v199 = v194;
        std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)__p, (uint64_t)&v195);
        double v81 = a8[15];
        double v82 = a8[11];
        double v83 = v81 * v82;
        double v84 = a8[9];
        double v85 = v81 * a8[8] - v82 * a8[12] / (v81 * v82);
        double v86 = a8[13];
        *(double *)&long long v184 = a8[12];
        *((double *)&v184 + 1) = v86;
        double v87 = v81 * v84 - v82 * v86 / (v81 * v82);
        *(double *)&double v188 = v85;
        double v189 = v87;
        if (v83 < 0.0)
        {
          double v85 = -v85;
          double v87 = -v87;
          *(double *)&double v188 = v85;
          double v189 = v87;
        }
        double v88 = sqrt(v85 * v85 + v87 * v87);
        if (v88 <= -0.000000100000001 || v88 >= 0.000000100000001)
        {
          *(double *)&double v188 = v85 / v88;
          double v189 = v87 / v88;
        }
        double v192 = v65;
        double v193 = v64;
        if (v79)
        {
          double v192 = v65 / v78;
          double v193 = v64 / v78;
        }
        if (PCAlgorithm::findIntersection((double *)&v184, (double *)&v188, (double *)&v194, &v192, (double *)&v191))
        {
          long long v199 = v191;
          *(_OWORD *)long long v201 = v194;
          std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)__p, (uint64_t)&v195);
          long long v89 = *v179;
          *(_OWORD *)long long v201 = v191;
          long long v199 = v89;
          v201[34] = 1;
          std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)__p, (uint64_t)&v195);
          if (__p[1] != __p[0])
          {
            uint64_t v90 = 0xF0F0F0F0F0F0F0F1 * (((char *)__p[1] - (char *)__p[0]) >> 3);
            if (HIBYTE(a11))
            {
LABEL_88:
              std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a5, *a5, (uint64_t)__p[0], (uint64_t)__p[1], v90);
              goto LABEL_138;
            }
LABEL_173:
            std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a5, a5[1], (uint64_t)__p[0], (uint64_t)__p[1], v90);
            goto LABEL_138;
          }
          goto LABEL_138;
        }
        if (!HIBYTE(a11))
        {
LABEL_137:
          std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100](a5, a6);
          goto LABEL_138;
        }
      }
      else if (!HIBYTE(a11))
      {
        goto LABEL_137;
      }
      std::vector<OZShapeEdgePolygon>::insert(a5, *a5, a6);
      goto LABEL_138;
    }
    if (HIBYTE(a11))
    {
      double v60 = a5;
LABEL_91:
      uint64_t v91 = *v60;
      std::vector<OZShapeEdgePolygon>::insert(v60, v91, a6);
      return;
    }
    double v60 = a5;
    goto LABEL_118;
  }
  if (!a2)
  {
    long long v191 = 0uLL;
    double v115 = *((double *)a7 + 15);
    double v116 = *((double *)a7 + 11);
    double v117 = v115 * v116;
    double v118 = *((double *)a7 + 9);
    double v119 = v115 * *((double *)a7 + 8) - v116 * *((double *)a7 + 12) / (v115 * v116);
    double v120 = *((double *)a7 + 13);
    *(void *)&long long v184 = *((void *)a7 + 12);
    *((double *)&v184 + 1) = v120;
    double v121 = v115 * v118 - v116 * v120 / (v115 * v116);
    *(double *)&double v188 = v119;
    double v189 = v121;
    if (v117 < 0.0)
    {
      double v119 = -v119;
      double v121 = -v121;
      *(double *)&double v188 = v119;
      double v189 = v121;
    }
    double v122 = sqrt(v119 * v119 + v121 * v121);
    if (v122 <= -0.000000100000001 || v122 >= 0.000000100000001)
    {
      double v119 = v119 / v122;
      double v121 = v121 / v122;
      *(double *)&double v188 = v119;
      double v189 = v121;
    }
    double v123 = a8[15];
    double v124 = a8[11];
    double v125 = v123 * v124;
    double v126 = a8[9];
    double v127 = v123 * a8[8] - v124 * a8[12] / (v123 * v124);
    double v128 = a8[13];
    *(double *)&long long v194 = a8[12];
    *((double *)&v194 + 1) = v128;
    double v129 = v123 * v126 - v124 * v128 / (v123 * v124);
    double v192 = v127;
    double v193 = v129;
    if (v125 < 0.0)
    {
      *(double *)&double v188 = -v119;
      double v189 = -v121;
    }
    double v130 = sqrt(v127 * v127 + v129 * v129);
    if (v130 <= -0.000000100000001 || v130 >= 0.000000100000001)
    {
      double v192 = v127 / v130;
      double v193 = v129 / v130;
    }
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v187 = 0;
    if (PCAlgorithm::findIntersection((double *)&v184, (double *)&v188, (double *)&v194, &v192, (double *)&v191))
    {
      long long v131 = *(_OWORD *)(a6 + 16);
      long long v195 = *(_OWORD *)a6;
      long long v196 = v131;
      long long v132 = *(_OWORD *)(a6 + 48);
      long long v197 = *v34;
      long long v198 = v132;
      long long v133 = *(_OWORD *)(a6 + 80);
      long long v134 = *(_OWORD *)(a6 + 112);
      *(_OWORD *)long long v201 = *v176;
      *(_OWORD *)&v201[16] = v134;
      long long v199 = v191;
      long long v200 = v133;
      *(_OWORD *)long long v201 = *(_OWORD *)(a6 + 96);
      v201[32] = 1;
      v201[34] = 0;
      std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)__p, (uint64_t)&v195);
      long long v135 = *(_OWORD *)(a6 + 80);
      long long v199 = *v179;
      long long v200 = v135;
      *(_OWORD *)long long v201 = v191;
      v201[34] = 1;
      std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)__p, (uint64_t)&v195);
      if (HIBYTE(a11)) {
        std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a5, *a5, (uint64_t)__p[0], (uint64_t)__p[1], 0xF0F0F0F0F0F0F0F1 * (((char *)__p[1] - (char *)__p[0]) >> 3));
      }
      else {
        std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a5, a5[1], (uint64_t)__p[0], (uint64_t)__p[1], 0xF0F0F0F0F0F0F0F1 * (((char *)__p[1] - (char *)__p[0]) >> 3));
      }
      goto LABEL_138;
    }
    BYTE2(v167) = a12;
    LOWORD(v167) = a11;
    OZShape::subdivideTriangle(a1, 2, a3, a4, __p, a6, a7, a8, v169, a10, v167);
    if (__p[1] != __p[0])
    {
      uint64_t v90 = 0xF0F0F0F0F0F0F0F1 * (((char *)__p[1] - (char *)__p[0]) >> 3);
      if (HIBYTE(a11)) {
        goto LABEL_88;
      }
      goto LABEL_173;
    }
LABEL_138:
    double v136 = (OZShapeEdgePolygon *)__p[0];
    if (!__p[0]) {
      return;
    }
    __p[1] = __p[0];
    goto LABEL_140;
  }
  if (v63 <= v180)
  {
    double v60 = a5;
    if (HIBYTE(a11)) {
      goto LABEL_91;
    }
    goto LABEL_118;
  }
  *(double *)&double v188 = 0.0;
  double v189 = 0.0;
  uint64_t v190 = 0;
  std::vector<OZShapeEdgePolygon>::reserve((uint64_t *)&v188, 0x14uLL);
  long long v92 = a7[7];
  long long v212 = a7[6];
  *(_OWORD *)double v213 = v92;
  *(_DWORD *)&v213[15] = *(_DWORD *)((char *)a7 + 127);
  double v93 = v62 / (v63 / v180);
  long long v94 = a7[3];
  long long v208 = a7[2];
  long long v209 = v94;
  long long v95 = a7[5];
  long long v210 = a7[4];
  long long v211 = v95;
  long long v96 = a7[1];
  long long v206 = *a7;
  long long v207 = v96;
  double v97 = v168;
  if (v168 <= v59)
  {
    if (v168 < v59)
    {
      do
      {
        long long v137 = *(_OWORD *)(a6 + 16);
        long long v195 = *(_OWORD *)a6;
        long long v196 = v137;
        long long v197 = v195;
        long long v198 = v137;
        double v97 = v93 + v97;
        __double2 v138 = __sincos_stret(v97);
        if ((_BYTE)a11)
        {
          long long v199 = v212;
          long long v200 = *(_OWORD *)v213;
          double v139 = (double *)v201;
          double v140 = (char *)&v196 + 8;
          double v141 = (double *)&v201[8];
        }
        else
        {
          *(_OWORD *)long long v201 = v210;
          *(_OWORD *)&v201[16] = v211;
          double v139 = (double *)&v199;
          double v140 = (char *)&v198 + 8;
          double v141 = (double *)&v199 + 1;
        }
        long long v142 = *(_OWORD *)(a6 + 16);
        *(_OWORD *)double v139 = *(_OWORD *)a6;
        *((_OWORD *)v139 + 1) = v142;
        *(void *)&long long v142 = *(void *)v140;
        double *v139 = *v139 + v138.__cosval * v169 * *(double *)v140 / v183 / v177;
        double *v141 = *v141 + v138.__sinval * v169 * *(double *)&v142 / v178;
        if (OZShapeEdgePolygon::isValid((OZShapeEdgePolygon *)&v195))
        {
          if (*(OZShapeEdgePolygon **)&v189 == v188) {
            goto LABEL_165;
          }
          *(_OWORD *)std::string __p = *(_OWORD *)(*(void *)&v189 - 72);
          long long v187 = *(_OWORD *)(*(void *)&v189 - 56);
          long long v184 = v199;
          long long v185 = v200;
          PCMatrix44Tmpl<double>::transform<double>(a10, (double *)__p, (double *)__p);
          PCMatrix44Tmpl<double>::transform<double>(a10, (double *)&v184, (double *)&v184);
          double v143 = *((double *)&v185 + 1);
          double v144 = *((double *)&v187 + 1) * *((double *)&v185 + 1);
          if (vabdd_f64(0.0, *((double *)&v187 + 1) * *((double *)&v185 + 1)) < 0.0000001) {
            goto LABEL_165;
          }
          if ((_BYTE)a11)
          {
            double v145 = *((double *)&v187 + 1) * *(double *)&v184 - *((double *)&v185 + 1) * *(double *)__p;
            double v146 = (double *)&v184 + 1;
            double v147 = (double *)&__p[1];
            double v148 = *((double *)&v187 + 1);
          }
          else
          {
            double v145 = *((double *)&v185 + 1) * *(double *)__p - *((double *)&v187 + 1) * *(double *)&v184;
            double v147 = (double *)&v184 + 1;
            double v146 = (double *)&__p[1];
            double v148 = *((double *)&v185 + 1);
            double v143 = *((double *)&v187 + 1);
          }
          double v149 = (v148 * *v146 - v143 * *v147) / v144;
          double v150 = v145 / v144;
          double v151 = -(v145 / v144);
          BOOL v152 = v144 < 0.0;
          if (v144 >= 0.0) {
            double v153 = v150;
          }
          else {
            double v153 = v151;
          }
          if (v152) {
            double v149 = -v149;
          }
          if (sqrt(v153 * v153 + v149 * v149) >= 1.0)
          {
LABEL_165:
            std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)&v188, (uint64_t)&v195);
            long long v212 = *(_OWORD *)v201;
            *(_OWORD *)double v213 = *(_OWORD *)&v201[16];
            *(_DWORD *)&v213[15] = *(_DWORD *)&v201[31];
            long long v208 = v197;
            long long v209 = v198;
            long long v210 = v199;
            long long v211 = v200;
            long long v206 = v195;
            long long v207 = v196;
          }
        }
      }
      while (v97 < v59);
    }
    double v136 = v188;
    double v154 = v189;
    if (*(OZShapeEdgePolygon **)&v189 != v188)
    {
      if ((_BYTE)a11)
      {
        long long v155 = *v176;
        *(_OWORD *)(*(void *)&v189 - 24) = *(_OWORD *)(a6 + 112);
        *(_OWORD *)(*(void *)&v154 - 40) = v155;
      }
      else
      {
        long long v158 = *v179;
        *(_OWORD *)(*(void *)&v189 - 56) = *(_OWORD *)(a6 + 80);
        *(_OWORD *)(*(void *)&v154 - 72) = v158;
      }
      if (!OZShapeEdgePolygon::isValid((OZShapeEdgePolygon *)(*(void *)&v154 - 136))) {
        *(void *)&v189 -= 136;
      }
      if (!OZShapeEdgePolygon::isValid(v188))
      {
        double v159 = v188;
        if ((OZShapeEdgePolygon *)((char *)v188 + 136) != *(OZShapeEdgePolygon **)&v189)
        {
          unint64_t v160 = *(void *)&v189 - (void)v188 - 272;
          memmove(v188, (char *)v188 + 136, 136 * (v160 / 0x88) + 136);
          double v159 = (OZShapeEdgePolygon *)((char *)v159 + 136 * (v160 / 0x88) + 136);
        }
        double v189 = *(double *)&v159;
      }
      if ((a11 & 0x100) == 0)
      {
        double v136 = v188;
        if (*(OZShapeEdgePolygon **)&v189 == v188) {
          goto LABEL_199;
        }
        uint64_t v161 = 0;
        unsigned int v162 = 1;
        do
        {
          std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100](a5, (uint64_t)v136 + 136 * v161);
          uint64_t v161 = v162;
          double v136 = v188;
        }
        while (0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)&v189 - (void)v188) >> 3) > v162++);
        goto LABEL_198;
      }
      goto LABEL_184;
    }
  }
  else
  {
    while (v97 > v59 || vabdd_f64(v97, v59) < 0.0000001)
    {
      long long v98 = *(_OWORD *)(a6 + 16);
      long long v195 = *(_OWORD *)a6;
      long long v196 = v98;
      long long v197 = v195;
      long long v198 = v98;
      double v97 = v93 + v97;
      __double2 v99 = __sincos_stret(v97);
      if ((_BYTE)a11)
      {
        *(_OWORD *)long long v201 = v210;
        *(_OWORD *)&v201[16] = v211;
        char v100 = (double *)&v199;
        int v101 = (char *)&v198 + 8;
        long long v102 = (double *)&v199 + 1;
      }
      else
      {
        long long v199 = v212;
        long long v200 = *(_OWORD *)v213;
        char v100 = (double *)v201;
        int v101 = (char *)&v196 + 8;
        long long v102 = (double *)&v201[8];
      }
      long long v103 = *(_OWORD *)(a6 + 16);
      *(_OWORD *)char v100 = *(_OWORD *)a6;
      *((_OWORD *)v100 + 1) = v103;
      *(void *)&long long v103 = *(void *)v101;
      double *v100 = *v100 + v99.__cosval * v169 * *(double *)v101 / v183 / v177;
      double *v102 = *v102 + v99.__sinval * v169 * *(double *)&v103 / v178;
      if (OZShapeEdgePolygon::isValid((OZShapeEdgePolygon *)&v195))
      {
        if (*(OZShapeEdgePolygon **)&v189 == v188) {
          goto LABEL_116;
        }
        *(_OWORD *)std::string __p = *(_OWORD *)(*(void *)&v189 - 72);
        long long v187 = *(_OWORD *)(*(void *)&v189 - 56);
        long long v184 = v199;
        long long v185 = v200;
        PCMatrix44Tmpl<double>::transform<double>(a10, (double *)__p, (double *)__p);
        PCMatrix44Tmpl<double>::transform<double>(a10, (double *)&v184, (double *)&v184);
        double v104 = *((double *)&v187 + 1);
        double v105 = *((double *)&v187 + 1) * *((double *)&v185 + 1);
        if (vabdd_f64(0.0, *((double *)&v187 + 1) * *((double *)&v185 + 1)) < 0.0000001) {
          goto LABEL_116;
        }
        if ((_BYTE)a11)
        {
          double v106 = *((double *)&v185 + 1) * *(double *)__p - *((double *)&v187 + 1) * *(double *)&v184;
          long long v108 = (double *)&v184 + 1;
          long long v107 = (double *)&__p[1];
          double v109 = *((double *)&v185 + 1);
        }
        else
        {
          double v106 = *((double *)&v187 + 1) * *(double *)&v184 - *((double *)&v185 + 1) * *(double *)__p;
          long long v107 = (double *)&v184 + 1;
          long long v108 = (double *)&__p[1];
          double v109 = *((double *)&v187 + 1);
          double v104 = *((double *)&v185 + 1);
        }
        double v110 = (v109 * *v107 - v104 * *v108) / v105;
        double v111 = v106 / v105;
        double v112 = -(v106 / v105);
        BOOL v113 = v105 < 0.0;
        if (v105 >= 0.0) {
          double v114 = v111;
        }
        else {
          double v114 = v112;
        }
        if (v113) {
          double v110 = -v110;
        }
        if (sqrt(v114 * v114 + v110 * v110) >= 1.0)
        {
LABEL_116:
          std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)&v188, (uint64_t)&v195);
          long long v212 = *(_OWORD *)v201;
          *(_OWORD *)double v213 = *(_OWORD *)&v201[16];
          *(_DWORD *)&v213[15] = *(_DWORD *)&v201[31];
          long long v208 = v197;
          long long v209 = v198;
          long long v210 = v199;
          long long v211 = v200;
          long long v206 = v195;
          long long v207 = v196;
        }
      }
    }
    double v136 = v188;
    double v156 = v189;
    if (*(OZShapeEdgePolygon **)&v189 != v188)
    {
      if ((_BYTE)a11)
      {
        long long v157 = *v179;
        *(_OWORD *)(*(void *)&v189 - 56) = *(_OWORD *)(a6 + 80);
        *(_OWORD *)(*(void *)&v156 - 72) = v157;
      }
      else
      {
        long long v164 = *v176;
        *(_OWORD *)(*(void *)&v189 - 24) = *(_OWORD *)(a6 + 112);
        *(_OWORD *)(*(void *)&v156 - 40) = v164;
      }
      if (!OZShapeEdgePolygon::isValid((OZShapeEdgePolygon *)(*(void *)&v156 - 136))) {
        *(void *)&v189 -= 136;
      }
      if (!OZShapeEdgePolygon::isValid(v188))
      {
        uint64_t v165 = v188;
        if ((OZShapeEdgePolygon *)((char *)v188 + 136) != *(OZShapeEdgePolygon **)&v189)
        {
          unint64_t v166 = *(void *)&v189 - (void)v188 - 272;
          memmove(v188, (char *)v188 + 136, 136 * (v166 / 0x88) + 136);
          uint64_t v165 = (OZShapeEdgePolygon *)((char *)v165 + 136 * (v166 / 0x88) + 136);
        }
        double v189 = *(double *)&v165;
      }
      if (!HIBYTE(a11))
      {
        std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a5, a5[1], (uint64_t)v188, *(uint64_t *)&v189, 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)&v189 - (void)v188) >> 3));
        goto LABEL_198;
      }
LABEL_184:
      std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a5, *a5, (uint64_t)v188, *(uint64_t *)&v189, 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)&v189 - (void)v188) >> 3));
LABEL_198:
      double v136 = v188;
    }
  }
LABEL_199:
  if (*(double *)&v136 != 0.0)
  {
    double v189 = *(double *)&v136;
LABEL_140:
    operator delete(v136);
  }
}

void sub_1B7E32BE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  unint64_t v5 = *(void *)(v3 - 8);
  if (v5 >= v4)
  {
    uint64_t result = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a1, a2);
  }
  else
  {
    std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(v3, *(void *)(v3 - 8), a2);
    uint64_t result = v5 + 136;
    a1[1] = v5 + 136;
  }
  a1[1] = result;
  return result;
}

void sub_1B7E32CC4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

unint64_t std::vector<OZShapeEdgePolygon>::insert(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  unint64_t v4 = a2;
  unint64_t v6 = a1[1];
  unint64_t v9 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = v9;
  if (v6 >= v9)
  {
    uint64_t v16 = *a1;
    unint64_t v17 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v6 - *a1) >> 3) + 1;
    if (v17 > 0x1E1E1E1E1E1E1E1) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v18 = 0xF0F0F0F0F0F0F0F1 * ((a2 - v16) >> 3);
    unint64_t v19 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v8 - v16) >> 3);
    unint64_t v20 = 2 * v19;
    if (2 * v19 <= v17) {
      unint64_t v20 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v6 - *a1) >> 3) + 1;
    }
    if (v19 >= 0xF0F0F0F0F0F0F0) {
      unint64_t v21 = 0x1E1E1E1E1E1E1E1;
    }
    else {
      unint64_t v21 = v20;
    }
    uint64_t v28 = v7;
    if (v21) {
      double v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LightingStyleLight>>(v7, v21);
    }
    else {
      double v22 = 0;
    }
    std::string __p = v22;
    double v25 = &v22[136 * v18];
    double v26 = v25;
    double v27 = &v22[136 * v21];
    std::__split_buffer<OZShapeEdgePolygon>::push_back[abi:ne180100](&__p, a3);
    unint64_t v4 = std::vector<OZShapeEdgePolygon>::__swap_out_circular_buffer(a1, &__p, v4);
    if (v26 != v25) {
      double v26 = &v25[(v26 - v25 - 136) % 0x88uLL];
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (a2 == v6)
  {
    std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(v7, a2, a3);
    a1[1] = v4 + 136;
  }
  else
  {
    std::vector<OZShapeEdgePolygon>::__move_range((uint64_t)a1, a2, v6, a2 + 136);
    if (v4 <= a3) {
      a3 += 136 * (a1[1] > a3);
    }
    *(_OWORD *)unint64_t v4 = *(_OWORD *)a3;
    long long v10 = *(_OWORD *)(a3 + 16);
    long long v11 = *(_OWORD *)(a3 + 32);
    long long v12 = *(_OWORD *)(a3 + 64);
    *(_OWORD *)(v4 + 48) = *(_OWORD *)(a3 + 48);
    *(_OWORD *)(v4 + 64) = v12;
    *(_OWORD *)(v4 + 16) = v10;
    *(_OWORD *)(v4 + 32) = v11;
    long long v13 = *(_OWORD *)(a3 + 80);
    long long v14 = *(_OWORD *)(a3 + 96);
    long long v15 = *(_OWORD *)(a3 + 112);
    *(void *)(v4 + 128) = *(void *)(a3 + 128);
    *(_OWORD *)(v4 + 96) = v14;
    *(_OWORD *)(v4 + 112) = v15;
    *(_OWORD *)(v4 + 80) = v13;
  }
  return v4;
}

void sub_1B7E32E90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  *(void *)(v13 + 8) = v12;
  _Unwind_Resume(exception_object);
}

void OZShape::computeSoftEdges(uint64_t a1, const CMTime *a2, uint64_t a3, uint64_t a4, int a5, char a6, int a7, double a8)
{
  uint64_t v17 = 0x3FF0000000000000;
  uint64_t v14 = 0x3FF0000000000000;
  uint64_t v11 = 0x3FF0000000000000;
  uint64_t v8 = 0x3FF0000000000000;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  OZShape::computeOutlinePolygons(a1, (uint64_t *)(a4 + 312), a4, a2, a3, (double *)&v8, 1, a5, a8, a6, a7, 0);
}

void OZShape::computeOutline(uint64_t a1, const CMTime *a2, uint64_t a3, uint64_t *a4, double *a5, int a6, int a7, double a8)
{
  if (*(unsigned char *)(a3 + 1195))
  {
    a4[43] = a4[42];
    a4[46] = a4[45];
  }
  double v15 = a8 * 0.5;
  OZShape::computeOutlinePolygons(a1, a4 + 42, (uint64_t)a4, a2, a3, a5, a6, a7, a8 * 0.5, 1, 1, 1u);
  OZShape::computeOutlinePolygons(a1, a4 + 42, (uint64_t)a4, a2, a3, a5, a6, a7, v15, 0, -1, 1u);
  *(unsigned char *)(a3 + 1195) = 0;
}

void OZShape::computeAntialiasedBorders(uint64_t a1, const CMTime *a2, uint64_t a3, uint64_t a4, double *a5, int a6, char a7, int a8, double a9)
{
}

uint64_t OZShape::isWriteOnEffectEnabled(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 8)) {
    return 0;
  }
  double v3 = *(double *)(a2 + 72);
  if (!*(_DWORD *)(a2 + 168)
    || (uint64_t result = 0, v5 = vabdd_f64(*(double *)(a2 + 80), v3), v5 <= 1.0) && fabs(v5 + -1.0) >= 0.0000001)
  {
    if (fabs(v3) >= 0.0000001
      || fabs(*(double *)(a2 + 80) + -1.0) >= 0.0000001
      || fabs(*(double *)(a2 + 88)) >= 0.0000001
      || OZChannel::hasKeypoints((OZChannel *)(a1 + 9976))
      || OZChannel::hasKeypoints((OZChannel *)(a1 + 10128))
      || OZChannel::hasKeypoints((OZChannel *)(a1 + 10592)))
    {
      return 1;
    }
    else
    {
      unint64_t v6 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 160);
      return v6(a1);
    }
  }
  return result;
}

void OZShape::getWriteOnEffect(uint64_t a1, const CMTime *a2, uint64_t a3, uint64_t a4, _DWORD *a5, _DWORD *a6, void *a7, void *a8, void *a9)
{
  double v9 = *(double *)(a3 + 72);
  double v10 = *(double *)(a3 + 80);
  if (vabdd_f64(v9, v10) < 0.0000001 || v9 > v10)
  {
    if (a5) {
      *a5 = 0;
    }
    if (a6)
    {
      int v12 = 0;
LABEL_1501:
      *a6 = v12;
      return;
    }
    return;
  }
  v865 = a6;
  uint64_t v14 = *(void *)(a3 + 752);
  uint64_t v15 = v14 + 192;
  if (*(unsigned char *)(a3 + 112)) {
    uint64_t v16 = 400;
  }
  else {
    uint64_t v16 = 192;
  }
  if (*(unsigned char *)(a3 + 112)) {
    uint64_t v15 = v14 + 400;
  }
  uint64_t v17 = 448;
  if (!*(unsigned char *)(a3 + 112)) {
    uint64_t v17 = 240;
  }
  uint64_t v887 = v17;
  uint64_t v18 = 424;
  if (!*(unsigned char *)(a3 + 112)) {
    uint64_t v18 = 216;
  }
  uint64_t v886 = v18;
  if (*(unsigned char *)(a3 + 112)) {
    uint64_t v19 = v14 + 424;
  }
  else {
    uint64_t v19 = v14 + 216;
  }
  uint64_t v866 = v15;
  if (*(void *)(v15 + 8) != *(void *)(v14 + v16))
  {
    if (*(_DWORD *)(a3 + 180)) {
      uint64_t v22 = a3 + 760;
    }
    else {
      uint64_t v22 = a3 + 368;
    }
    uint64_t v873 = v22;
    double v23 = v10 - v9;
    double v24 = v9 + *(double *)(a3 + 88);
    double v25 = v10 - v9 + v24;
    if (*(_DWORD *)(a3 + 168))
    {
      double v26 = 1.0;
      double v27 = fmod(v9 + *(double *)(a3 + 88), 1.0);
      double v28 = 0.0;
      if (v24 >= 1.0 || v24 < 0.0) {
        double v24 = v27;
      }
      if (v25 > 1.0 || v25 <= 0.0) {
        double v25 = fmod(v25, 1.0);
      }
    }
    else
    {
      double v30 = 1.0;
      if (v24 <= 1.0) {
        double v31 = v24;
      }
      else {
        double v31 = 1.0;
      }
      if (v24 >= 0.0) {
        double v28 = v31;
      }
      else {
        double v28 = 0.0;
      }
      if (v25 <= 1.0) {
        double v30 = v25;
      }
      if (v25 >= 0.0) {
        double v26 = v30;
      }
      else {
        double v26 = 0.0;
      }
      double v25 = v26;
      double v24 = v28;
    }
    double v32 = fabs(v23);
    BOOL v33 = v32 > 1.0;
    if (fabs(v32 + -1.0) < 0.0000001) {
      BOOL v33 = 1;
    }
    if (v33)
    {
      double v25 = v26;
      double v24 = v28;
    }
    *(void *)(a3 + 328) = *(void *)(a3 + 320);
    *(void *)(a3 + 352) = *(void *)(a3 + 344);
    *(void *)(a3 + 304) = *(void *)(a3 + 296);
    BOOL v35 = !OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E4F1FA48], 0.0)
       || OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E4F1FA48], 0.0) == 4
       && (OZChannel::getValueAsDouble((OZChannel *)(a1 + 12072), a2, 0.0), v34 < 0.01)
       || OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E4F1FA48], 0.0) == 5;
    BOOL v880 = v35;
    v877 = (OZChannel *)(a1 + 1072);
    if (OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E4F1FA48], 0.0) == 4)
    {
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 12072), a2, 0.0);
      BOOL v876 = v36 > 0.99;
    }
    else
    {
      BOOL v876 = 0;
    }
    char v37 = 0;
    v874 = (double **)(a3 + 320);
    v885 = (char **)(a3 + 344);
    v883 = (char **)(a3 + 296);
    v888 = (void *)(a3 + 336);
    uint64_t v881 = a3 + 312;
    uint64_t v882 = a3 + 360;
    double v859 = fabs(v25 + -1.0);
    double v38 = 0.5;
    uint64_t v875 = v19;
    uint64_t v860 = v16;
    uint64_t v861 = v14;
    while (1)
    {
      uint64_t v39 = (uint64_t)(*(void *)(v19 + 8) - *(void *)(v14 + v886)) >> 3;
      signed int v40 = vcvtmd_s64_f64(v24 * (double)(unint64_t)v39 + v38 + 0.0000001);
      unsigned int v41 = vcvtmd_s64_f64(v25 * (double)(unint64_t)v39 + v38 + 0.0000001);
      int v42 = v24 <= v25 ? v41 : (uint64_t)(*(void *)(v19 + 8) - *(void *)(v14 + v886)) >> 3;
      BOOL v43 = v42 == v39;
      int v44 = v42 == v39 ? -1 : 0;
      unsigned int v45 = v42 - v43;
      unsigned int v46 = v40 - (v40 == v39);
      if (v42 - v43 != v46) {
        break;
      }
LABEL_1479:
      if (v24 > v25)
      {
        char v37 = 1;
        double v24 = 0.0;
        if (*(_DWORD *)(a3 + 168)) {
          continue;
        }
      }
      goto LABEL_1491;
    }
    char v878 = v37;
    int ValueAsInt = OZChannel::getValueAsInt(v877, MEMORY[0x1E4F1FA48], 0.0);
    int v48 = v880;
    if (ValueAsInt != 4) {
      int v48 = 1;
    }
    if (((v48 | v876) & 1) == 0)
    {
      while (v46 <= v45)
      {
        double v86 = *(char **)(a3 + 320);
        double v87 = *(char **)(a3 + 328);
        uint64_t v88 = *(void *)(v14 + v886);
        uint64_t v89 = v87 - v86;
        if (v87 == v86
          || vabdd_f64(*((double *)v87 - 1), *(double *)(v88 + 8 * v46)) >= 0.0000001
          || vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *(double *)(*(void *)(v14 + v887) + 8 * v46)) >= 0.0000001)
        {
          if ((unint64_t)v87 >= *v888)
          {
            uint64_t v91 = v89 >> 3;
            unint64_t v92 = (v89 >> 3) + 1;
            if (v92 >> 61) {
              goto LABEL_1505;
            }
            uint64_t v93 = *v888 - (void)v86;
            if (v93 >> 2 > v92) {
              unint64_t v92 = v93 >> 2;
            }
            if ((unint64_t)v93 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v94 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v94 = v92;
            }
            if (v94)
            {
              long long v95 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v94);
              double v86 = *(char **)(a3 + 320);
              double v87 = *(char **)(a3 + 328);
            }
            else
            {
              long long v95 = 0;
            }
            long long v96 = &v95[8 * v91];
            *(void *)long long v96 = *(void *)(v88 + 8 * v46);
            uint64_t v90 = v96 + 8;
            while (v87 != v86)
            {
              uint64_t v97 = *((void *)v87 - 1);
              v87 -= 8;
              *((void *)v96 - 1) = v97;
              v96 -= 8;
            }
            *(void *)(a3 + 320) = v96;
            *(void *)(a3 + 328) = v90;
            *(void *)(a3 + 336) = &v95[8 * v94];
            if (v86) {
              operator delete(v86);
            }
          }
          else
          {
            *(void *)double v87 = *(void *)(v88 + 8 * v46);
            uint64_t v90 = v87 + 8;
          }
          *(void *)(a3 + 328) = v90;
          uint64_t v98 = *(void *)(v14 + v887);
          char v100 = *(char **)(a3 + 352);
          unint64_t v99 = *(void *)(a3 + 360);
          if ((unint64_t)v100 >= v99)
          {
            long long v102 = *v885;
            uint64_t v103 = (v100 - *v885) >> 3;
            unint64_t v104 = v103 + 1;
            if ((unint64_t)(v103 + 1) >> 61) {
              goto LABEL_1503;
            }
            uint64_t v105 = v99 - (void)v102;
            if (v105 >> 2 > v104) {
              unint64_t v104 = v105 >> 2;
            }
            if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v106 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v106 = v104;
            }
            if (v106)
            {
              long long v107 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v106);
              long long v102 = *(char **)(a3 + 344);
              char v100 = *(char **)(a3 + 352);
            }
            else
            {
              long long v107 = 0;
            }
            long long v108 = &v107[8 * v103];
            *(void *)long long v108 = *(void *)(v98 + 8 * v46);
            int v101 = v108 + 8;
            while (v100 != v102)
            {
              uint64_t v109 = *((void *)v100 - 1);
              v100 -= 8;
              *((void *)v108 - 1) = v109;
              v108 -= 8;
            }
            *(void *)(a3 + 344) = v108;
            *(void *)(a3 + 352) = v101;
            *(void *)(a3 + 360) = &v107[8 * v106];
            if (v102) {
              operator delete(v102);
            }
          }
          else
          {
            *(void *)char v100 = *(void *)(v98 + 8 * v46);
            int v101 = v100 + 8;
          }
          *(void *)(a3 + 352) = v101;
          uint64_t v110 = *(void *)(v14 + v16);
          double v112 = *(char **)(a3 + 304);
          unint64_t v111 = *(void *)(a3 + 312);
          if ((unint64_t)v112 >= v111)
          {
            double v114 = *v883;
            uint64_t v115 = (v112 - *v883) >> 3;
            unint64_t v116 = v115 + 1;
            if ((unint64_t)(v115 + 1) >> 61) {
              goto LABEL_1504;
            }
            uint64_t v117 = v111 - (void)v114;
            if (v117 >> 2 > v116) {
              unint64_t v116 = v117 >> 2;
            }
            if ((unint64_t)v117 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v118 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v118 = v116;
            }
            if (v118)
            {
              double v119 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v118);
              double v114 = *(char **)(a3 + 296);
              double v112 = *(char **)(a3 + 304);
            }
            else
            {
              double v119 = 0;
            }
            double v120 = &v119[8 * v115];
            *(void *)double v120 = *(void *)(v110 + 8 * v46);
            BOOL v113 = v120 + 8;
            while (v112 != v114)
            {
              uint64_t v121 = *((void *)v112 - 1);
              v112 -= 8;
              *((void *)v120 - 1) = v121;
              v120 -= 8;
            }
            *(void *)(a3 + 296) = v120;
            *(void *)(a3 + 304) = v113;
            *(void *)(a3 + 312) = &v119[8 * v118];
            if (v114) {
              operator delete(v114);
            }
          }
          else
          {
            *(void *)double v112 = *(void *)(v110 + 8 * v46);
            BOOL v113 = v112 + 8;
          }
          *(void *)(a3 + 304) = v113;
        }
        ++v46;
      }
      goto LABEL_1463;
    }
    if (*(_DWORD *)(a3 + 180))
    {
      if ((int)v46 <= (int)v45)
      {
        unint64_t v49 = v40 - (unint64_t)(v40 == v39);
        do
        {
          long double v50 = *(char **)(a3 + 320);
          long double v51 = *(char **)(a3 + 328);
          uint64_t v52 = *(void *)(v14 + v886);
          uint64_t v53 = v51 - v50;
          if (v51 == v50
            || vabdd_f64(*((double *)v51 - 1), *(double *)(v52 + 8 * v49)) >= 0.0000001
            || vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *(double *)(*(void *)(v14 + v887) + 8 * v49)) >= 0.0000001)
          {
            if ((unint64_t)v51 >= *v888)
            {
              uint64_t v55 = v53 >> 3;
              unint64_t v56 = (v53 >> 3) + 1;
              if (v56 >> 61) {
                goto LABEL_1505;
              }
              uint64_t v57 = *v888 - (void)v50;
              if (v57 >> 2 > v56) {
                unint64_t v56 = v57 >> 2;
              }
              if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v58 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v58 = v56;
              }
              if (v58)
              {
                double v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v58);
                long double v50 = *(char **)(a3 + 320);
                long double v51 = *(char **)(a3 + 328);
              }
              else
              {
                double v59 = 0;
              }
              double v60 = &v59[8 * v55];
              *(void *)double v60 = *(void *)(v52 + 8 * v49);
              double v54 = v60 + 8;
              while (v51 != v50)
              {
                uint64_t v61 = *((void *)v51 - 1);
                v51 -= 8;
                *((void *)v60 - 1) = v61;
                v60 -= 8;
              }
              *(void *)(a3 + 320) = v60;
              *(void *)(a3 + 328) = v54;
              *(void *)(a3 + 336) = &v59[8 * v58];
              if (v50) {
                operator delete(v50);
              }
            }
            else
            {
              *(void *)long double v51 = *(void *)(v52 + 8 * v49);
              double v54 = v51 + 8;
            }
            *(void *)(a3 + 328) = v54;
            uint64_t v62 = *(void *)(v14 + v887);
            double v64 = *(char **)(a3 + 352);
            unint64_t v63 = *(void *)(a3 + 360);
            if ((unint64_t)v64 >= v63)
            {
              BOOL v66 = *v885;
              uint64_t v67 = (v64 - *v885) >> 3;
              unint64_t v68 = v67 + 1;
              if ((unint64_t)(v67 + 1) >> 61) {
                goto LABEL_1503;
              }
              uint64_t v69 = v63 - (void)v66;
              if (v69 >> 2 > v68) {
                unint64_t v68 = v69 >> 2;
              }
              if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v70 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v70 = v68;
              }
              if (v70)
              {
                long long v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v70);
                BOOL v66 = *(char **)(a3 + 344);
                double v64 = *(char **)(a3 + 352);
              }
              else
              {
                long long v71 = 0;
              }
              double v72 = &v71[8 * v67];
              *(void *)double v72 = *(void *)(v62 + 8 * v49);
              double v65 = v72 + 8;
              while (v64 != v66)
              {
                uint64_t v73 = *((void *)v64 - 1);
                v64 -= 8;
                *((void *)v72 - 1) = v73;
                v72 -= 8;
              }
              *(void *)(a3 + 344) = v72;
              *(void *)(a3 + 352) = v65;
              *(void *)(a3 + 360) = &v71[8 * v70];
              if (v66) {
                operator delete(v66);
              }
            }
            else
            {
              *(void *)double v64 = *(void *)(v62 + 8 * v49);
              double v65 = v64 + 8;
            }
            *(void *)(a3 + 352) = v65;
            uint64_t v74 = *(void *)(v14 + v16);
            double v76 = *(char **)(a3 + 304);
            unint64_t v75 = *(void *)(a3 + 312);
            if ((unint64_t)v76 >= v75)
            {
              double v78 = *v883;
              uint64_t v79 = (v76 - *v883) >> 3;
              unint64_t v80 = v79 + 1;
              if ((unint64_t)(v79 + 1) >> 61) {
                goto LABEL_1504;
              }
              uint64_t v81 = v75 - (void)v78;
              if (v81 >> 2 > v80) {
                unint64_t v80 = v81 >> 2;
              }
              if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v82 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v82 = v80;
              }
              if (v82)
              {
                double v83 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v82);
                double v78 = *(char **)(a3 + 296);
                double v76 = *(char **)(a3 + 304);
              }
              else
              {
                double v83 = 0;
              }
              double v84 = &v83[8 * v79];
              *(void *)double v84 = *(void *)(v74 + 8 * v49);
              double v77 = v84 + 8;
              while (v76 != v78)
              {
                uint64_t v85 = *((void *)v76 - 1);
                v76 -= 8;
                *((void *)v84 - 1) = v85;
                v84 -= 8;
              }
              *(void *)(a3 + 296) = v84;
              *(void *)(a3 + 304) = v77;
              *(void *)(a3 + 312) = &v83[8 * v82];
              if (v78) {
                operator delete(v78);
              }
            }
            else
            {
              *(void *)double v76 = *(void *)(v74 + 8 * v49);
              double v77 = v76 + 8;
            }
            *(void *)(a3 + 304) = v77;
          }
          ++v49;
        }
        while (v42 + v44 + 1 != v49);
      }
      goto LABEL_1463;
    }
    double v122 = *(double **)(v14 + v16);
    double v123 = v122[v45];
    double v124 = *(double **)(v866 + 8);
    BOOL v125 = v859 >= 0.0000001 || v124 == v122;
    double v126 = v122[v45];
    if (!v125) {
      double v126 = ceil(*(v124 - 1));
    }
    double v127 = v122[v46];
    double v128 = *(double **)(v14 + v886);
    double v129 = *(double **)(v14 + v887);
    double v130 = *(double **)(v873 + 216);
    long long v131 = *(double **)(v873 + 240);
    long long v133 = *(double **)(v873 + 192);
    long long v132 = *(double **)(v873 + 200);
    v884 = *(double **)(v866 + 8);
    v879 = v132;
    if (v126 - v127 < 1.0 && vabdd_f64(floor(v127), floor(v126)) < 0.0000001)
    {
      if (v133 != v132)
      {
        while (*v133 < v127)
        {
          ++v133;
          ++v130;
          ++v131;
          if (v133 == v132)
          {
            long long v133 = *(double **)(v873 + 200);
            break;
          }
        }
      }
      if (v124 == v122)
      {
        if (!v880) {
          goto LABEL_1044;
        }
        goto LABEL_1463;
      }
      int v134 = 0;
      double v135 = 0.0;
      double v136 = 0.0;
      double v137 = 0.0;
      while (1)
      {
        double v138 = *v122;
        if (*v122 > v126) {
          goto LABEL_506;
        }
        if (v138 < v127)
        {
          ++v128;
          ++v129;
          ++v122;
          goto LABEL_504;
        }
        if (v880)
        {
          if ((v134 & 1) == 0)
          {
            double v139 = *(char **)(a3 + 320);
            double v140 = *(char **)(a3 + 328);
            uint64_t v141 = v140 - v139;
            if (v140 == v139
              || vabdd_f64(*((double *)v140 - 1), *v128) >= 0.0000001
              || vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v129) >= 0.0000001)
            {
              long long v142 = v131;
              if ((unint64_t)v140 >= *v888)
              {
                uint64_t v188 = v141 >> 3;
                unint64_t v189 = (v141 >> 3) + 1;
                if (v189 >> 61) {
                  goto LABEL_1505;
                }
                uint64_t v190 = *v888 - (void)v139;
                if (v190 >> 2 > v189) {
                  unint64_t v189 = v190 >> 2;
                }
                if ((unint64_t)v190 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v191 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v191 = v189;
                }
                if (v191)
                {
                  double v192 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v191);
                  double v139 = *(char **)(a3 + 320);
                  double v140 = *(char **)(a3 + 328);
                }
                else
                {
                  double v192 = 0;
                }
                unint64_t v257 = &v192[8 * v188];
                *(double *)unint64_t v257 = *v128;
                double v143 = v257 + 8;
                while (v140 != v139)
                {
                  uint64_t v258 = *((void *)v140 - 1);
                  v140 -= 8;
                  *((void *)v257 - 1) = v258;
                  v257 -= 8;
                }
                *(void *)(a3 + 320) = v257;
                *(void *)(a3 + 328) = v143;
                *(void *)(a3 + 336) = &v192[8 * v191];
                if (v139) {
                  operator delete(v139);
                }
              }
              else
              {
                *(double *)double v140 = *v128;
                double v143 = v140 + 8;
              }
              *(void *)(a3 + 328) = v143;
              uint64_t v260 = *(char **)(a3 + 352);
              unint64_t v259 = *(void *)(a3 + 360);
              if ((unint64_t)v260 >= v259)
              {
                uint64_t v262 = *v885;
                uint64_t v263 = (v260 - *v885) >> 3;
                unint64_t v264 = v263 + 1;
                if ((unint64_t)(v263 + 1) >> 61) {
                  goto LABEL_1503;
                }
                uint64_t v265 = v259 - (void)v262;
                if (v265 >> 2 > v264) {
                  unint64_t v264 = v265 >> 2;
                }
                if ((unint64_t)v265 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v266 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v266 = v264;
                }
                if (v266)
                {
                  long long v267 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v266);
                  uint64_t v262 = *(char **)(a3 + 344);
                  uint64_t v260 = *(char **)(a3 + 352);
                }
                else
                {
                  long long v267 = 0;
                }
                uint64_t v268 = &v267[8 * v263];
                *(double *)uint64_t v268 = *v129;
                uint64_t v261 = v268 + 8;
                while (v260 != v262)
                {
                  uint64_t v269 = *((void *)v260 - 1);
                  v260 -= 8;
                  *((void *)v268 - 1) = v269;
                  v268 -= 8;
                }
                *(void *)(a3 + 344) = v268;
                *(void *)(a3 + 352) = v261;
                *(void *)(a3 + 360) = &v267[8 * v266];
                if (v262) {
                  operator delete(v262);
                }
              }
              else
              {
                *(double *)uint64_t v260 = *v129;
                uint64_t v261 = v260 + 8;
              }
              *(void *)(a3 + 352) = v261;
              uint64_t v271 = *(char **)(a3 + 304);
              unint64_t v270 = *(void *)(a3 + 312);
              if ((unint64_t)v271 >= v270)
              {
                BOOL v273 = *v883;
                uint64_t v274 = (v271 - *v883) >> 3;
                unint64_t v275 = v274 + 1;
                if ((unint64_t)(v274 + 1) >> 61) {
                  goto LABEL_1504;
                }
                uint64_t v276 = v270 - (void)v273;
                if (v276 >> 2 > v275) {
                  unint64_t v275 = v276 >> 2;
                }
                if ((unint64_t)v276 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v277 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v277 = v275;
                }
                if (v277)
                {
                  uint64_t v278 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v277);
                  BOOL v273 = *(char **)(a3 + 296);
                  uint64_t v271 = *(char **)(a3 + 304);
                }
                else
                {
                  uint64_t v278 = 0;
                }
                unint64_t v279 = &v278[8 * v274];
                *(double *)unint64_t v279 = *v122;
                uint64_t v272 = v279 + 8;
                while (v271 != v273)
                {
                  uint64_t v280 = *((void *)v271 - 1);
                  v271 -= 8;
                  *((void *)v279 - 1) = v280;
                  v279 -= 8;
                }
                *(void *)(a3 + 296) = v279;
                *(void *)(a3 + 304) = v272;
                *(void *)(a3 + 312) = &v278[8 * v277];
                if (v273) {
                  operator delete(v273);
                }
              }
              else
              {
                *(double *)uint64_t v271 = *v122;
                uint64_t v272 = v271 + 8;
              }
              *(void *)(a3 + 304) = v272;
              double v138 = *v122;
              long long v131 = v142;
              long long v132 = v879;
            }
          }
          double v281 = *v128++;
          double v135 = v281;
          double v282 = *v129++;
          double v136 = v282;
          ++v122;
          int v134 = 1;
          double v137 = v138;
          double v124 = v884;
          goto LABEL_504;
        }
        if (v133 == v132)
        {
          if ((v134 & 1) == 0) {
            goto LABEL_222;
          }
        }
        else
        {
          if (((*v133 < v126) & v134) == 1)
          {
            double v144 = *(char **)(a3 + 320);
            double v145 = *(char **)(a3 + 328);
            uint64_t v146 = v145 - v144;
            if (v145 == v144
              || vabdd_f64(*((double *)v145 - 1), *v130) >= 0.0000001
              || vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v131) >= 0.0000001)
            {
              double v147 = v131;
              if ((unint64_t)v145 >= *v888)
              {
                uint64_t v193 = v146 >> 3;
                unint64_t v194 = (v146 >> 3) + 1;
                if (v194 >> 61) {
                  goto LABEL_1505;
                }
                uint64_t v195 = *v888 - (void)v144;
                if (v195 >> 2 > v194) {
                  unint64_t v194 = v195 >> 2;
                }
                if ((unint64_t)v195 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v196 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v196 = v194;
                }
                if (v196)
                {
                  long long v197 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v196);
                  double v144 = *(char **)(a3 + 320);
                  double v145 = *(char **)(a3 + 328);
                }
                else
                {
                  long long v197 = 0;
                }
                unint64_t v283 = &v197[8 * v193];
                *(double *)unint64_t v283 = *v130;
                double v148 = v283 + 8;
                while (v145 != v144)
                {
                  uint64_t v284 = *((void *)v145 - 1);
                  v145 -= 8;
                  *((void *)v283 - 1) = v284;
                  v283 -= 8;
                }
                *(void *)(a3 + 320) = v283;
                *(void *)(a3 + 328) = v148;
                *(void *)(a3 + 336) = &v197[8 * v196];
                if (v144) {
                  operator delete(v144);
                }
              }
              else
              {
                *(double *)double v145 = *v130;
                double v148 = v145 + 8;
              }
              *(void *)(a3 + 328) = v148;
              uint64_t v286 = *(char **)(a3 + 352);
              unint64_t v285 = *(void *)(a3 + 360);
              if ((unint64_t)v286 >= v285)
              {
                int v288 = *v885;
                uint64_t v289 = (v286 - *v885) >> 3;
                unint64_t v290 = v289 + 1;
                if ((unint64_t)(v289 + 1) >> 61) {
                  goto LABEL_1503;
                }
                uint64_t v291 = v285 - (void)v288;
                if (v291 >> 2 > v290) {
                  unint64_t v290 = v291 >> 2;
                }
                if ((unint64_t)v291 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v292 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v292 = v290;
                }
                if (v292)
                {
                  int v293 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v292);
                  int v288 = *(char **)(a3 + 344);
                  uint64_t v286 = *(char **)(a3 + 352);
                }
                else
                {
                  int v293 = 0;
                }
                uint64_t v294 = &v293[8 * v289];
                *(double *)uint64_t v294 = *v147;
                double v287 = v294 + 8;
                while (v286 != v288)
                {
                  uint64_t v295 = *((void *)v286 - 1);
                  v286 -= 8;
                  *((void *)v294 - 1) = v295;
                  v294 -= 8;
                }
                *(void *)(a3 + 344) = v294;
                *(void *)(a3 + 352) = v287;
                *(void *)(a3 + 360) = &v293[8 * v292];
                if (v288) {
                  operator delete(v288);
                }
              }
              else
              {
                *(double *)uint64_t v286 = *v147;
                double v287 = v286 + 8;
              }
              *(void *)(a3 + 352) = v287;
              long long v297 = *(char **)(a3 + 304);
              unint64_t v296 = *(void *)(a3 + 312);
              if ((unint64_t)v297 >= v296)
              {
                long long v299 = *v883;
                uint64_t v300 = (v297 - *v883) >> 3;
                unint64_t v301 = v300 + 1;
                if ((unint64_t)(v300 + 1) >> 61) {
                  goto LABEL_1504;
                }
                uint64_t v302 = v296 - (void)v299;
                if (v302 >> 2 > v301) {
                  unint64_t v301 = v302 >> 2;
                }
                if ((unint64_t)v302 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v303 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v303 = v301;
                }
                if (v303)
                {
                  uint64_t v304 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v303);
                  long long v299 = *(char **)(a3 + 296);
                  long long v297 = *(char **)(a3 + 304);
                }
                else
                {
                  uint64_t v304 = 0;
                }
                long long v305 = &v304[8 * v300];
                *(double *)long long v305 = *v133;
                uint64_t v298 = v305 + 8;
                while (v297 != v299)
                {
                  uint64_t v306 = *((void *)v297 - 1);
                  v297 -= 8;
                  *((void *)v305 - 1) = v306;
                  v305 -= 8;
                }
                *(void *)(a3 + 296) = v305;
                *(void *)(a3 + 304) = v298;
                *(void *)(a3 + 312) = &v304[8 * v303];
                if (v299) {
                  operator delete(v299);
                }
              }
              else
              {
                *(double *)long long v297 = *v133;
                uint64_t v298 = v297 + 8;
              }
              *(void *)(a3 + 304) = v298;
              long long v131 = v147;
              long long v132 = v879;
            }
            double v124 = v884;
            if (v122 == v884)
            {
LABEL_501:
              double v122 = v884;
            }
            else
            {
              while (*v122 < *v133)
              {
                ++v128;
                ++v129;
                if (++v122 == v884) {
                  goto LABEL_501;
                }
              }
            }
            ++v133;
            ++v130;
            ++v131;
            goto LABEL_503;
          }
          if (((vabdd_f64(*v133, v126) < 0.0000001) & v134) == 0)
          {
LABEL_222:
            v870 = v131;
            if (v122 == v124)
            {
              double v122 = v124;
            }
            else
            {
              unsigned int v154 = 0;
              while (*v122 <= v126)
              {
                long long v155 = *(char **)(a3 + 320);
                double v156 = *(char **)(a3 + 328);
                uint64_t v157 = v156 - v155;
                if (v156 == v155
                  || vabdd_f64(*((double *)v156 - 1), *v128) >= 0.0000001
                  || vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v129) >= 0.0000001)
                {
                  if ((unint64_t)v156 >= *v888)
                  {
                    uint64_t v159 = v157 >> 3;
                    unint64_t v160 = (v157 >> 3) + 1;
                    if (v160 >> 61) {
                      goto LABEL_1505;
                    }
                    uint64_t v161 = *v888 - (void)v155;
                    if (v161 >> 2 > v160) {
                      unint64_t v160 = v161 >> 2;
                    }
                    if ((unint64_t)v161 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v162 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v162 = v160;
                    }
                    if (v162)
                    {
                      int v163 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v162);
                      long long v155 = *(char **)(a3 + 320);
                      double v156 = *(char **)(a3 + 328);
                    }
                    else
                    {
                      int v163 = 0;
                    }
                    long long v164 = &v163[8 * v159];
                    *(double *)long long v164 = *v128;
                    long long v158 = v164 + 8;
                    while (v156 != v155)
                    {
                      uint64_t v165 = *((void *)v156 - 1);
                      v156 -= 8;
                      *((void *)v164 - 1) = v165;
                      v164 -= 8;
                    }
                    *(void *)(a3 + 320) = v164;
                    *(void *)(a3 + 328) = v158;
                    *(void *)(a3 + 336) = &v163[8 * v162];
                    if (v155) {
                      operator delete(v155);
                    }
                  }
                  else
                  {
                    *(double *)double v156 = *v128;
                    long long v158 = v156 + 8;
                  }
                  *(void *)(a3 + 328) = v158;
                  int v167 = *(char **)(a3 + 352);
                  unint64_t v166 = *(void *)(a3 + 360);
                  if ((unint64_t)v167 >= v166)
                  {
                    double v169 = *v885;
                    uint64_t v170 = (v167 - *v885) >> 3;
                    unint64_t v171 = v170 + 1;
                    if ((unint64_t)(v170 + 1) >> 61) {
                      goto LABEL_1503;
                    }
                    uint64_t v172 = v166 - (void)v169;
                    if (v172 >> 2 > v171) {
                      unint64_t v171 = v172 >> 2;
                    }
                    if ((unint64_t)v172 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v173 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v173 = v171;
                    }
                    if (v173)
                    {
                      double v174 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v173);
                      double v169 = *(char **)(a3 + 344);
                      int v167 = *(char **)(a3 + 352);
                    }
                    else
                    {
                      double v174 = 0;
                    }
                    double v175 = &v174[8 * v170];
                    *(double *)double v175 = *v129;
                    double v168 = v175 + 8;
                    while (v167 != v169)
                    {
                      uint64_t v176 = *((void *)v167 - 1);
                      v167 -= 8;
                      *((void *)v175 - 1) = v176;
                      v175 -= 8;
                    }
                    *(void *)(a3 + 344) = v175;
                    *(void *)(a3 + 352) = v168;
                    *(void *)(a3 + 360) = &v174[8 * v173];
                    if (v169) {
                      operator delete(v169);
                    }
                  }
                  else
                  {
                    *(double *)int v167 = *v129;
                    double v168 = v167 + 8;
                  }
                  *(void *)(a3 + 352) = v168;
                  double v178 = *(char **)(a3 + 304);
                  unint64_t v177 = *(void *)(a3 + 312);
                  if ((unint64_t)v178 >= v177)
                  {
                    double v180 = *v883;
                    uint64_t v181 = (v178 - *v883) >> 3;
                    unint64_t v182 = v181 + 1;
                    if ((unint64_t)(v181 + 1) >> 61) {
                      goto LABEL_1504;
                    }
                    uint64_t v183 = v177 - (void)v180;
                    if (v183 >> 2 > v182) {
                      unint64_t v182 = v183 >> 2;
                    }
                    if ((unint64_t)v183 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v184 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v184 = v182;
                    }
                    if (v184)
                    {
                      long long v185 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v184);
                      double v180 = *(char **)(a3 + 296);
                      double v178 = *(char **)(a3 + 304);
                    }
                    else
                    {
                      long long v185 = 0;
                    }
                    double v186 = &v185[8 * v181];
                    *(double *)double v186 = *v122;
                    double v179 = v186 + 8;
                    while (v178 != v180)
                    {
                      uint64_t v187 = *((void *)v178 - 1);
                      v178 -= 8;
                      *((void *)v186 - 1) = v187;
                      v186 -= 8;
                    }
                    *(void *)(a3 + 296) = v186;
                    *(void *)(a3 + 304) = v179;
                    *(void *)(a3 + 312) = &v185[8 * v184];
                    if (v180) {
                      operator delete(v180);
                    }
                  }
                  else
                  {
                    *(double *)double v178 = *v122;
                    double v179 = v178 + 8;
                  }
                  *(void *)(a3 + 304) = v179;
                  LOBYTE(v134) = 1;
                }
                ++v128;
                ++v129;
                ++v122;
                if (v154 > 1)
                {
                  double v124 = v884;
                  if (v134) {
                    goto LABEL_299;
                  }
                  goto LABEL_458;
                }
                ++v154;
                double v124 = v884;
                if (v122 == v884) {
                  break;
                }
              }
            }
            if ((v134 & 1) == 0)
            {
LABEL_458:
              int v134 = 0;
              long long v131 = v870;
              long long v132 = v879;
              goto LABEL_504;
            }
LABEL_299:
            long long v132 = v879;
            long long v131 = v870;
            if (v133 == v879)
            {
              int v134 = 1;
LABEL_456:
              long long v133 = v879;
              goto LABEL_504;
            }
            while (*v133 <= *(double *)(*(void *)(a3 + 304) - 8))
            {
              ++v133;
              ++v130;
              ++v131;
              int v134 = 1;
              if (v133 == v879) {
                goto LABEL_456;
              }
            }
LABEL_503:
            int v134 = 1;
            goto LABEL_504;
          }
        }
        v869 = v131;
        int v867 = v134;
        if (v122 == v124)
        {
LABEL_214:
          double v122 = v124;
        }
        else
        {
          while (*v122 < v126)
          {
            ++v128;
            ++v129;
            if (++v122 == v124) {
              goto LABEL_214;
            }
          }
        }
        unsigned int v149 = 0;
        double v150 = *(double **)(v14 + v16);
        double v151 = v122 - 3;
        BOOL v152 = v129 - 3;
        double v153 = v128 - 3;
        while (1)
        {
          if (v122 == v150)
          {
            double v151 = v150;
            goto LABEL_304;
          }
          if (v122 != v124 && *v122 <= v127) {
            break;
          }
          --v128;
          --v129;
          --v122;
          if (++v149 == 3) {
            goto LABEL_305;
          }
        }
        double v151 = v122;
LABEL_304:
        BOOL v152 = v129;
        double v153 = v128;
LABEL_305:
        if (v149 && v151 != v124) {
          break;
        }
LABEL_413:
        if (v151 == v124)
        {
          double v122 = v124;
          double v129 = v152;
          double v128 = v153;
          uint64_t v16 = v860;
          uint64_t v14 = v861;
          LOBYTE(v134) = v867;
LABEL_506:
          if (v880)
          {
            if ((v134 & 1) == 0) {
              goto LABEL_1463;
            }
            long long v307 = *(char **)(a3 + 320);
            long long v308 = *(char **)(a3 + 328);
            uint64_t v309 = v308 - v307;
            if (v308 != v307
              && vabdd_f64(*((double *)v308 - 1), v135) < 0.0000001
              && vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), v136) < 0.0000001)
            {
              goto LABEL_1463;
            }
            if ((unint64_t)v308 >= *v888)
            {
              uint64_t v793 = v309 >> 3;
              unint64_t v794 = (v309 >> 3) + 1;
              if (v794 >> 61) {
LABEL_1505:
              }
                std::vector<double>::__throw_length_error[abi:ne180100]();
              uint64_t v795 = *v888 - (void)v307;
              if (v795 >> 2 > v794) {
                unint64_t v794 = v795 >> 2;
              }
              if ((unint64_t)v795 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v796 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v796 = v794;
              }
              if (v796)
              {
                uint64_t v797 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v796);
                long long v307 = *(char **)(a3 + 320);
                long long v308 = *(char **)(a3 + 328);
              }
              else
              {
                uint64_t v797 = 0;
              }
              unint64_t v819 = (double *)&v797[8 * v793];
              *unint64_t v819 = v135;
              long long v310 = v819 + 1;
              while (v308 != v307)
              {
                uint64_t v820 = *((void *)v308 - 1);
                v308 -= 8;
                *((void *)v819-- - 1) = v820;
              }
              *(void *)(a3 + 320) = v819;
              *(void *)(a3 + 328) = v310;
              *(void *)(a3 + 336) = &v797[8 * v796];
              if (v307) {
                operator delete(v307);
              }
            }
            else
            {
              *(double *)long long v308 = v135;
              long long v310 = v308 + 8;
            }
            *(void *)(a3 + 328) = v310;
            uint64_t v822 = *(char **)(a3 + 352);
            unint64_t v821 = *(void *)(a3 + 360);
            if ((unint64_t)v822 >= v821)
            {
              v824 = *v885;
              uint64_t v825 = (v822 - *v885) >> 3;
              unint64_t v826 = v825 + 1;
              if ((unint64_t)(v825 + 1) >> 61) {
LABEL_1503:
              }
                std::vector<double>::__throw_length_error[abi:ne180100]();
              uint64_t v827 = v821 - (void)v824;
              if (v827 >> 2 > v826) {
                unint64_t v826 = v827 >> 2;
              }
              if ((unint64_t)v827 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v828 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v828 = v826;
              }
              if (v828)
              {
                unint64_t v829 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v828);
                v824 = *(char **)(a3 + 344);
                uint64_t v822 = *(char **)(a3 + 352);
              }
              else
              {
                unint64_t v829 = 0;
              }
              unint64_t v830 = (double *)&v829[8 * v825];
              *unint64_t v830 = v136;
              v823 = v830 + 1;
              while (v822 != v824)
              {
                uint64_t v831 = *((void *)v822 - 1);
                v822 -= 8;
                *((void *)v830-- - 1) = v831;
              }
              *(void *)(a3 + 344) = v830;
              *(void *)(a3 + 352) = v823;
              *(void *)(a3 + 360) = &v829[8 * v828];
              if (v824) {
                operator delete(v824);
              }
            }
            else
            {
              *(double *)uint64_t v822 = v136;
              v823 = v822 + 8;
            }
            *(void *)(a3 + 352) = v823;
            v833 = *(char **)(a3 + 304);
            unint64_t v832 = *(void *)(a3 + 312);
            if ((unint64_t)v833 < v832)
            {
              *(double *)v833 = v137;
              uint64_t v783 = (double *)(v833 + 8);
              goto LABEL_1447;
            }
            unint64_t v784 = (double *)*v883;
            uint64_t v834 = (v833 - *v883) >> 3;
            unint64_t v835 = v834 + 1;
            if ((unint64_t)(v834 + 1) >> 61) {
LABEL_1504:
            }
              std::vector<double>::__throw_length_error[abi:ne180100]();
            uint64_t v836 = v832 - (void)v784;
            if (v836 >> 2 > v835) {
              unint64_t v835 = v836 >> 2;
            }
            if ((unint64_t)v836 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v788 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v788 = v835;
            }
            if (v788)
            {
              v789 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v788);
              unint64_t v784 = *(double **)(a3 + 296);
              v833 = *(char **)(a3 + 304);
            }
            else
            {
              v789 = 0;
            }
            v790 = (double *)&v789[8 * v834];
            double *v790 = v137;
            v791 = v790 + 1;
            while (v833 != (char *)v784)
            {
              uint64_t v837 = *((void *)v833 - 1);
              v833 -= 8;
              *((void *)v790-- - 1) = v837;
            }
LABEL_1460:
            *(void *)(a3 + 296) = v790;
            *(void *)(a3 + 304) = v791;
            *(void *)(a3 + 312) = &v789[8 * v788];
            if (v784) {
              operator delete(v784);
            }
            goto LABEL_1462;
          }
          if ((v134 & 1) == 0)
          {
LABEL_1044:
            while (v122 != v124)
            {
              if (*v122 >= v126) {
                goto LABEL_1172;
              }
              ++v128;
              ++v129;
              ++v122;
            }
            double v122 = v124;
LABEL_1172:
            int v676 = 0;
            uint64_t v677 = v122 - 3;
            unint64_t v678 = v129 - 3;
            unint64_t v679 = v128 - 3;
            while (1)
            {
              if (v122 == *(double **)(v14 + v16))
              {
                uint64_t v677 = *(double **)(v14 + v16);
                goto LABEL_1211;
              }
              if (v122 != v124 && *v122 <= v127) {
                break;
              }
              --v128;
              --v129;
              --v122;
              if (--v676 == -3)
              {
                unsigned int v680 = 3;
                goto LABEL_1213;
              }
            }
            uint64_t v677 = v122;
LABEL_1211:
            if (v676)
            {
              unsigned int v680 = -v676;
              unint64_t v679 = v128;
              unint64_t v678 = v129;
LABEL_1213:
              v702 = *(double **)(a3 + 296);
              v703 = *(double **)(a3 + 304);
              if (v703 != v702)
              {
                double v704 = *v677;
                v705 = v703 - 1;
                do
                {
                  if (*v705 < v704) {
                    break;
                  }
                  *(void *)(a3 + 328) -= 8;
                  *(void *)(a3 + 352) -= 8;
                  *(void *)(a3 + 304) = v705;
                  BOOL v125 = v705-- == v702;
                }
                while (!v125);
              }
              if (v680 && v677 != v124)
              {
                int v706 = 0;
                uint64_t v707 = *(double **)(a3 + 304);
                while (1)
                {
                  unint64_t v708 = *(double **)(a3 + 328);
                  if (v707 == *(double **)(a3 + 296))
                  {
                    if ((unint64_t)v708 >= *v888)
                    {
                      v712 = *v874;
                      uint64_t v713 = v708 - *v874;
                      unint64_t v714 = v713 + 1;
                      if ((unint64_t)(v713 + 1) >> 61) {
                        goto LABEL_1507;
                      }
                      uint64_t v715 = *v888 - (void)v712;
                      if (v715 >> 2 > v714) {
                        unint64_t v714 = v715 >> 2;
                      }
                      if ((unint64_t)v715 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v716 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v716 = v714;
                      }
                      if (v716)
                      {
                        uint64_t v717 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v716);
                        v712 = *(double **)(a3 + 320);
                        unint64_t v708 = *(double **)(a3 + 328);
                      }
                      else
                      {
                        uint64_t v717 = 0;
                      }
                      v724 = &v717[8 * v713];
                      *(double *)v724 = *v679;
                      v711 = v724 + 8;
                      while (v708 != v712)
                      {
                        uint64_t v725 = *((void *)v708-- - 1);
                        *((void *)v724 - 1) = v725;
                        v724 -= 8;
                      }
                      *(void *)(a3 + 320) = v724;
                      *(void *)(a3 + 328) = v711;
                      *(void *)(a3 + 336) = &v717[8 * v716];
                      if (v712) {
                        operator delete(v712);
                      }
                      double v124 = v884;
                    }
                    else
                    {
                      *unint64_t v708 = *v679;
                      v711 = v708 + 1;
                    }
                    *(void *)(a3 + 328) = v711;
                    uint64_t v727 = *(char **)(a3 + 352);
                    unint64_t v726 = *(void *)(a3 + 360);
                    if ((unint64_t)v727 >= v726)
                    {
                      uint64_t v729 = *v885;
                      uint64_t v730 = (v727 - *v885) >> 3;
                      unint64_t v731 = v730 + 1;
                      if ((unint64_t)(v730 + 1) >> 61) {
                        goto LABEL_1503;
                      }
                      uint64_t v732 = v726 - (void)v729;
                      if (v732 >> 2 > v731) {
                        unint64_t v731 = v732 >> 2;
                      }
                      if ((unint64_t)v732 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v733 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v733 = v731;
                      }
                      if (v733)
                      {
                        uint64_t v734 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v733);
                        uint64_t v729 = *(char **)(a3 + 344);
                        uint64_t v727 = *(char **)(a3 + 352);
                      }
                      else
                      {
                        uint64_t v734 = 0;
                      }
                      v735 = &v734[8 * v730];
                      *(double *)v735 = *v678;
                      v728 = v735 + 8;
                      while (v727 != v729)
                      {
                        uint64_t v736 = *((void *)v727 - 1);
                        v727 -= 8;
                        *((void *)v735 - 1) = v736;
                        v735 -= 8;
                      }
                      *(void *)(a3 + 344) = v735;
                      *(void *)(a3 + 352) = v728;
                      *(void *)(a3 + 360) = &v734[8 * v733];
                      if (v729) {
                        operator delete(v729);
                      }
                      double v124 = v884;
                    }
                    else
                    {
                      *(double *)uint64_t v727 = *v678;
                      v728 = v727 + 8;
                    }
                    *(void *)(a3 + 352) = v728;
                    uint64_t v738 = *(char **)(a3 + 304);
                    unint64_t v737 = *(void *)(a3 + 312);
                    if ((unint64_t)v738 >= v737)
                    {
                      unint64_t v739 = *v883;
                      uint64_t v740 = (v738 - *v883) >> 3;
                      unint64_t v741 = v740 + 1;
                      if ((unint64_t)(v740 + 1) >> 61) {
                        goto LABEL_1504;
                      }
                      uint64_t v742 = v737 - (void)v739;
                      if (v742 >> 2 > v741) {
                        unint64_t v741 = v742 >> 2;
                      }
                      if ((unint64_t)v742 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v743 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v743 = v741;
                      }
                      if (v743)
                      {
                        v744 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v743);
                        unint64_t v739 = *(char **)(a3 + 296);
                        uint64_t v738 = *(char **)(a3 + 304);
                      }
                      else
                      {
                        v744 = 0;
                      }
                      v745 = &v744[8 * v740];
                      *(double *)v745 = *v677;
                      uint64_t v707 = (double *)(v745 + 8);
                      while (v738 != v739)
                      {
                        uint64_t v746 = *((void *)v738 - 1);
                        v738 -= 8;
                        *((void *)v745 - 1) = v746;
                        v745 -= 8;
                      }
LABEL_1320:
                      *(void *)(a3 + 296) = v745;
                      *(void *)(a3 + 304) = v707;
                      *(void *)(a3 + 312) = &v744[8 * v743];
                      if (v739) {
                        operator delete(v739);
                      }
                      double v124 = v884;
                      goto LABEL_1323;
                    }
                  }
                  else
                  {
                    double v709 = *v679;
                    if (vabdd_f64(*(v708 - 1), *v679) < 0.0000001
                      && vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v678) < 0.0000001
                      || *(v707 - 1) >= *v677)
                    {
                      goto LABEL_1324;
                    }
                    if ((unint64_t)v708 >= *v888)
                    {
                      unint64_t v718 = *v874;
                      uint64_t v719 = v708 - *v874;
                      unint64_t v720 = v719 + 1;
                      if ((unint64_t)(v719 + 1) >> 61) {
LABEL_1507:
                      }
                        std::vector<double>::__throw_length_error[abi:ne180100]();
                      uint64_t v721 = *v888 - (void)v718;
                      if (v721 >> 2 > v720) {
                        unint64_t v720 = v721 >> 2;
                      }
                      if ((unint64_t)v721 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v722 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v722 = v720;
                      }
                      if (v722)
                      {
                        v723 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v722);
                        unint64_t v718 = *(double **)(a3 + 320);
                        unint64_t v708 = *(double **)(a3 + 328);
                        double v709 = *v679;
                      }
                      else
                      {
                        v723 = 0;
                      }
                      v747 = (double *)&v723[8 * v719];
                      double *v747 = v709;
                      v710 = v747 + 1;
                      while (v708 != v718)
                      {
                        uint64_t v748 = *((void *)v708-- - 1);
                        *((void *)v747-- - 1) = v748;
                      }
                      *(void *)(a3 + 320) = v747;
                      *(void *)(a3 + 328) = v710;
                      *(void *)(a3 + 336) = &v723[8 * v722];
                      if (v718) {
                        operator delete(v718);
                      }
                      double v124 = v884;
                    }
                    else
                    {
                      *unint64_t v708 = v709;
                      v710 = v708 + 1;
                    }
                    *(void *)(a3 + 328) = v710;
                    v750 = *(char **)(a3 + 352);
                    unint64_t v749 = *(void *)(a3 + 360);
                    if ((unint64_t)v750 >= v749)
                    {
                      v752 = *v885;
                      uint64_t v753 = (v750 - *v885) >> 3;
                      unint64_t v754 = v753 + 1;
                      if ((unint64_t)(v753 + 1) >> 61) {
                        goto LABEL_1503;
                      }
                      uint64_t v755 = v749 - (void)v752;
                      if (v755 >> 2 > v754) {
                        unint64_t v754 = v755 >> 2;
                      }
                      if ((unint64_t)v755 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v756 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v756 = v754;
                      }
                      if (v756)
                      {
                        v757 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v756);
                        v752 = *(char **)(a3 + 344);
                        v750 = *(char **)(a3 + 352);
                      }
                      else
                      {
                        v757 = 0;
                      }
                      uint64_t v758 = &v757[8 * v753];
                      *(double *)uint64_t v758 = *v678;
                      BOOL v751 = v758 + 8;
                      while (v750 != v752)
                      {
                        uint64_t v759 = *((void *)v750 - 1);
                        v750 -= 8;
                        *((void *)v758 - 1) = v759;
                        v758 -= 8;
                      }
                      *(void *)(a3 + 344) = v758;
                      *(void *)(a3 + 352) = v751;
                      *(void *)(a3 + 360) = &v757[8 * v756];
                      if (v752) {
                        operator delete(v752);
                      }
                      double v124 = v884;
                    }
                    else
                    {
                      *(double *)v750 = *v678;
                      BOOL v751 = v750 + 8;
                    }
                    *(void *)(a3 + 352) = v751;
                    uint64_t v738 = *(char **)(a3 + 304);
                    unint64_t v760 = *(void *)(a3 + 312);
                    if ((unint64_t)v738 >= v760)
                    {
                      unint64_t v739 = *v883;
                      uint64_t v761 = (v738 - *v883) >> 3;
                      unint64_t v762 = v761 + 1;
                      if ((unint64_t)(v761 + 1) >> 61) {
                        goto LABEL_1504;
                      }
                      uint64_t v763 = v760 - (void)v739;
                      if (v763 >> 2 > v762) {
                        unint64_t v762 = v763 >> 2;
                      }
                      if ((unint64_t)v763 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v743 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v743 = v762;
                      }
                      if (v743)
                      {
                        v744 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v743);
                        unint64_t v739 = *(char **)(a3 + 296);
                        uint64_t v738 = *(char **)(a3 + 304);
                      }
                      else
                      {
                        v744 = 0;
                      }
                      v745 = &v744[8 * v761];
                      *(double *)v745 = *v677;
                      uint64_t v707 = (double *)(v745 + 8);
                      while (v738 != v739)
                      {
                        uint64_t v764 = *((void *)v738 - 1);
                        v738 -= 8;
                        *((void *)v745 - 1) = v764;
                        v745 -= 8;
                      }
                      goto LABEL_1320;
                    }
                  }
                  *(double *)uint64_t v738 = *v677;
                  uint64_t v707 = (double *)(v738 + 8);
LABEL_1323:
                  *(void *)(a3 + 304) = v707;
LABEL_1324:
                  ++v677;
                  if (++v706 < v680)
                  {
                    ++v679;
                    ++v678;
                    if (v677 != v124) {
                      continue;
                    }
                  }
                  break;
                }
              }
            }
            double v122 = v677 + 1;
          }
          if (*(_DWORD *)(a3 + 168))
          {
            if (v122 != v124) {
              goto LABEL_1463;
            }
            uint64_t v765 = *(void *)(a3 + 328);
            v673 = *(double **)(v873 + 216);
            if (v765 != *(void *)(a3 + 320)
              && vabdd_f64(*(double *)(v765 - 8), *v673) < 0.0000001
              && vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), **(double **)(v873 + 240)) < 0.0000001)
            {
              goto LABEL_1463;
            }
            goto LABEL_1332;
          }
          goto LABEL_1334;
        }
        double v128 = v153 + 1;
        double v129 = v152 + 1;
        double v122 = v151 + 1;
        uint64_t v16 = v860;
        uint64_t v14 = v861;
        long long v131 = v869;
        long long v132 = v879;
        int v134 = v867;
LABEL_504:
        if (v122 == v124)
        {
          double v122 = v124;
          goto LABEL_506;
        }
      }
      int v198 = 0;
      long long v199 = *(double **)(a3 + 304);
      while (1)
      {
        long long v200 = *(double **)(a3 + 328);
        if (v199 == *(double **)(a3 + 296))
        {
          if ((unint64_t)v200 >= *v888)
          {
            __int16 v204 = *v874;
            uint64_t v205 = v200 - *v874;
            unint64_t v206 = v205 + 1;
            if ((unint64_t)(v205 + 1) >> 61) {
              goto LABEL_1506;
            }
            uint64_t v207 = *v888 - (void)v204;
            if (v207 >> 2 > v206) {
              unint64_t v206 = v207 >> 2;
            }
            if ((unint64_t)v207 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v208 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v208 = v206;
            }
            if (v208)
            {
              long long v209 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v208);
              __int16 v204 = *(double **)(a3 + 320);
              long long v200 = *(double **)(a3 + 328);
            }
            else
            {
              long long v209 = 0;
            }
            double v216 = &v209[8 * v205];
            *(double *)double v216 = *v153;
            char v203 = v216 + 8;
            while (v200 != v204)
            {
              uint64_t v217 = *((void *)v200-- - 1);
              *((void *)v216 - 1) = v217;
              v216 -= 8;
            }
            *(void *)(a3 + 320) = v216;
            *(void *)(a3 + 328) = v203;
            *(void *)(a3 + 336) = &v209[8 * v208];
            if (v204) {
              operator delete(v204);
            }
            double v124 = v884;
          }
          else
          {
            *long long v200 = *v153;
            char v203 = v200 + 1;
          }
          *(void *)(a3 + 328) = v203;
          uint64_t v219 = *(char **)(a3 + 352);
          unint64_t v218 = *(void *)(a3 + 360);
          if ((unint64_t)v219 >= v218)
          {
            uint64_t v221 = *v885;
            uint64_t v222 = (v219 - *v885) >> 3;
            unint64_t v223 = v222 + 1;
            if ((unint64_t)(v222 + 1) >> 61) {
              goto LABEL_1503;
            }
            uint64_t v224 = v218 - (void)v221;
            if (v224 >> 2 > v223) {
              unint64_t v223 = v224 >> 2;
            }
            if ((unint64_t)v224 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v225 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v225 = v223;
            }
            if (v225)
            {
              uint64_t v226 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v225);
              uint64_t v221 = *(char **)(a3 + 344);
              uint64_t v219 = *(char **)(a3 + 352);
            }
            else
            {
              uint64_t v226 = 0;
            }
            uint64_t v227 = &v226[8 * v222];
            *(double *)uint64_t v227 = *v152;
            uint64_t v220 = v227 + 8;
            while (v219 != v221)
            {
              uint64_t v228 = *((void *)v219 - 1);
              v219 -= 8;
              *((void *)v227 - 1) = v228;
              v227 -= 8;
            }
            *(void *)(a3 + 344) = v227;
            *(void *)(a3 + 352) = v220;
            *(void *)(a3 + 360) = &v226[8 * v225];
            if (v221) {
              operator delete(v221);
            }
            double v124 = v884;
          }
          else
          {
            *(double *)uint64_t v219 = *v152;
            uint64_t v220 = v219 + 8;
          }
          *(void *)(a3 + 352) = v220;
          uint64_t v230 = *(char **)(a3 + 304);
          unint64_t v229 = *(void *)(a3 + 312);
          if ((unint64_t)v230 >= v229)
          {
            long long v231 = *v883;
            uint64_t v232 = (v230 - *v883) >> 3;
            unint64_t v233 = v232 + 1;
            if ((unint64_t)(v232 + 1) >> 61) {
              goto LABEL_1504;
            }
            uint64_t v234 = v229 - (void)v231;
            if (v234 >> 2 > v233) {
              unint64_t v233 = v234 >> 2;
            }
            if ((unint64_t)v234 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v235 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v235 = v233;
            }
            if (v235)
            {
              int v236 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v235);
              long long v231 = *(char **)(a3 + 296);
              uint64_t v230 = *(char **)(a3 + 304);
            }
            else
            {
              int v236 = 0;
            }
            unint64_t v237 = &v236[8 * v232];
            *(double *)unint64_t v237 = *v151;
            long long v199 = (double *)(v237 + 8);
            while (v230 != v231)
            {
              uint64_t v238 = *((void *)v230 - 1);
              v230 -= 8;
              *((void *)v237 - 1) = v238;
              v237 -= 8;
            }
LABEL_407:
            *(void *)(a3 + 296) = v237;
            *(void *)(a3 + 304) = v199;
            *(void *)(a3 + 312) = &v236[8 * v235];
            if (v231) {
              operator delete(v231);
            }
            double v124 = v884;
            goto LABEL_410;
          }
        }
        else
        {
          double v201 = *v153;
          if (vabdd_f64(*(v200 - 1), *v153) < 0.0000001
            && vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v152) < 0.0000001
            || *(v199 - 1) >= *v151)
          {
            goto LABEL_411;
          }
          if ((unint64_t)v200 >= *v888)
          {
            long long v210 = *v874;
            uint64_t v211 = v200 - *v874;
            unint64_t v212 = v211 + 1;
            if ((unint64_t)(v211 + 1) >> 61) {
              goto LABEL_1506;
            }
            uint64_t v213 = *v888 - (void)v210;
            if (v213 >> 2 > v212) {
              unint64_t v212 = v213 >> 2;
            }
            if ((unint64_t)v213 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v214 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v214 = v212;
            }
            if (v214)
            {
              double v215 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v214);
              long long v210 = *(double **)(a3 + 320);
              long long v200 = *(double **)(a3 + 328);
              double v201 = *v153;
            }
            else
            {
              double v215 = 0;
            }
            unint64_t v239 = (double *)&v215[8 * v211];
            *unint64_t v239 = v201;
            char v202 = v239 + 1;
            while (v200 != v210)
            {
              uint64_t v240 = *((void *)v200-- - 1);
              *((void *)v239-- - 1) = v240;
            }
            *(void *)(a3 + 320) = v239;
            *(void *)(a3 + 328) = v202;
            *(void *)(a3 + 336) = &v215[8 * v214];
            if (v210) {
              operator delete(v210);
            }
            double v124 = v884;
          }
          else
          {
            *long long v200 = v201;
            char v202 = v200 + 1;
          }
          *(void *)(a3 + 328) = v202;
          float64x2_t v242 = *(char **)(a3 + 352);
          unint64_t v241 = *(void *)(a3 + 360);
          if ((unint64_t)v242 >= v241)
          {
            double v244 = *v885;
            uint64_t v245 = (v242 - *v885) >> 3;
            unint64_t v246 = v245 + 1;
            if ((unint64_t)(v245 + 1) >> 61) {
              goto LABEL_1503;
            }
            uint64_t v247 = v241 - (void)v244;
            if (v247 >> 2 > v246) {
              unint64_t v246 = v247 >> 2;
            }
            if ((unint64_t)v247 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v248 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v248 = v246;
            }
            if (v248)
            {
              double v249 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v248);
              double v244 = *(char **)(a3 + 344);
              float64x2_t v242 = *(char **)(a3 + 352);
            }
            else
            {
              double v249 = 0;
            }
            double v250 = &v249[8 * v245];
            *(double *)double v250 = *v152;
            double v243 = v250 + 8;
            while (v242 != v244)
            {
              uint64_t v251 = *((void *)v242 - 1);
              v242 -= 8;
              *((void *)v250 - 1) = v251;
              v250 -= 8;
            }
            *(void *)(a3 + 344) = v250;
            *(void *)(a3 + 352) = v243;
            *(void *)(a3 + 360) = &v249[8 * v248];
            if (v244) {
              operator delete(v244);
            }
            double v124 = v884;
          }
          else
          {
            *(double *)float64x2_t v242 = *v152;
            double v243 = v242 + 8;
          }
          *(void *)(a3 + 352) = v243;
          uint64_t v230 = *(char **)(a3 + 304);
          unint64_t v252 = *(void *)(a3 + 312);
          if ((unint64_t)v230 >= v252)
          {
            long long v231 = *v883;
            uint64_t v253 = (v230 - *v883) >> 3;
            unint64_t v254 = v253 + 1;
            if ((unint64_t)(v253 + 1) >> 61) {
              goto LABEL_1504;
            }
            uint64_t v255 = v252 - (void)v231;
            if (v255 >> 2 > v254) {
              unint64_t v254 = v255 >> 2;
            }
            if ((unint64_t)v255 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v235 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v235 = v254;
            }
            if (v235)
            {
              int v236 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v235);
              long long v231 = *(char **)(a3 + 296);
              uint64_t v230 = *(char **)(a3 + 304);
            }
            else
            {
              int v236 = 0;
            }
            unint64_t v237 = &v236[8 * v253];
            *(double *)unint64_t v237 = *v151;
            long long v199 = (double *)(v237 + 8);
            while (v230 != v231)
            {
              uint64_t v256 = *((void *)v230 - 1);
              v230 -= 8;
              *((void *)v237 - 1) = v256;
              v237 -= 8;
            }
            goto LABEL_407;
          }
        }
        *(double *)uint64_t v230 = *v151;
        long long v199 = (double *)(v230 + 8);
LABEL_410:
        *(void *)(a3 + 304) = v199;
LABEL_411:
        ++v153;
        ++v152;
        ++v151;
        if (++v198 >= v149 || v151 == v124) {
          goto LABEL_413;
        }
      }
    }
    if (v133 != v132)
    {
      while (*v133 < v127)
      {
        ++v133;
        ++v130;
        ++v131;
        if (v133 == v132)
        {
          long long v133 = *(double **)(v873 + 200);
          break;
        }
      }
    }
    double v311 = ceil(v127);
    if (v124 != v122)
    {
      char v312 = 0;
      while (*v122 <= v311)
      {
        if (*v122 >= v127)
        {
          if (v880)
          {
            if ((v312 & 1) == 0)
            {
              uint64_t v313 = *(char **)(a3 + 320);
              long long v314 = *(char **)(a3 + 328);
              uint64_t v315 = v314 - v313;
              if (v314 == v313
                || vabdd_f64(*((double *)v314 - 1), *v128) >= 0.0000001
                || vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v129) >= 0.0000001)
              {
                long long v316 = v131;
                if ((unint64_t)v314 >= *v888)
                {
                  uint64_t v358 = v315 >> 3;
                  unint64_t v359 = (v315 >> 3) + 1;
                  if (v359 >> 61) {
                    goto LABEL_1505;
                  }
                  uint64_t v360 = *v888 - (void)v313;
                  if (v360 >> 2 > v359) {
                    unint64_t v359 = v360 >> 2;
                  }
                  if ((unint64_t)v360 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v361 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v361 = v359;
                  }
                  if (v361)
                  {
                    long long v362 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v361);
                    uint64_t v313 = *(char **)(a3 + 320);
                    long long v314 = *(char **)(a3 + 328);
                  }
                  else
                  {
                    long long v362 = 0;
                  }
                  long long v368 = &v362[8 * v358];
                  *(double *)long long v368 = *v128;
                  long long v317 = v368 + 8;
                  while (v314 != v313)
                  {
                    uint64_t v369 = *((void *)v314 - 1);
                    v314 -= 8;
                    *((void *)v368 - 1) = v369;
                    v368 -= 8;
                  }
                  *(void *)(a3 + 320) = v368;
                  *(void *)(a3 + 328) = v317;
                  *(void *)(a3 + 336) = &v362[8 * v361];
                  if (v313) {
                    operator delete(v313);
                  }
                }
                else
                {
                  *(double *)long long v314 = *v128;
                  long long v317 = v314 + 8;
                }
                *(void *)(a3 + 328) = v317;
                long long v371 = *(char **)(a3 + 352);
                unint64_t v370 = *(void *)(a3 + 360);
                if ((unint64_t)v371 >= v370)
                {
                  uint64_t v373 = *v885;
                  uint64_t v374 = (v371 - *v885) >> 3;
                  unint64_t v375 = v374 + 1;
                  if ((unint64_t)(v374 + 1) >> 61) {
                    goto LABEL_1503;
                  }
                  uint64_t v376 = v370 - (void)v373;
                  if (v376 >> 2 > v375) {
                    unint64_t v375 = v376 >> 2;
                  }
                  if ((unint64_t)v376 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v377 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v377 = v375;
                  }
                  if (v377)
                  {
                    float64x2_t v378 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v377);
                    uint64_t v373 = *(char **)(a3 + 344);
                    long long v371 = *(char **)(a3 + 352);
                  }
                  else
                  {
                    float64x2_t v378 = 0;
                  }
                  long long v379 = &v378[8 * v374];
                  *(double *)long long v379 = *v129;
                  long long v372 = v379 + 8;
                  while (v371 != v373)
                  {
                    uint64_t v380 = *((void *)v371 - 1);
                    v371 -= 8;
                    *((void *)v379 - 1) = v380;
                    v379 -= 8;
                  }
                  *(void *)(a3 + 344) = v379;
                  *(void *)(a3 + 352) = v372;
                  *(void *)(a3 + 360) = &v378[8 * v377];
                  if (v373) {
                    operator delete(v373);
                  }
                }
                else
                {
                  *(double *)long long v371 = *v129;
                  long long v372 = v371 + 8;
                }
                *(void *)(a3 + 352) = v372;
                unint64_t v382 = *(char **)(a3 + 304);
                unint64_t v381 = *(void *)(a3 + 312);
                if ((unint64_t)v382 >= v381)
                {
                  uint64_t v384 = *v883;
                  uint64_t v385 = (v382 - *v883) >> 3;
                  unint64_t v386 = v385 + 1;
                  if ((unint64_t)(v385 + 1) >> 61) {
                    goto LABEL_1504;
                  }
                  uint64_t v387 = v381 - (void)v384;
                  if (v387 >> 2 > v386) {
                    unint64_t v386 = v387 >> 2;
                  }
                  if ((unint64_t)v387 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v388 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v388 = v386;
                  }
                  if (v388)
                  {
                    double v389 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v388);
                    uint64_t v384 = *(char **)(a3 + 296);
                    unint64_t v382 = *(char **)(a3 + 304);
                  }
                  else
                  {
                    double v389 = 0;
                  }
                  unint64_t v390 = &v389[8 * v385];
                  *(double *)unint64_t v390 = *v122;
                  uint64_t v383 = v390 + 8;
                  while (v382 != v384)
                  {
                    uint64_t v391 = *((void *)v382 - 1);
                    v382 -= 8;
                    *((void *)v390 - 1) = v391;
                    v390 -= 8;
                  }
                  *(void *)(a3 + 296) = v390;
                  *(void *)(a3 + 304) = v383;
                  *(void *)(a3 + 312) = &v389[8 * v388];
                  if (v384) {
                    operator delete(v384);
                  }
                }
                else
                {
                  *(double *)unint64_t v382 = *v122;
                  uint64_t v383 = v382 + 8;
                }
                *(void *)(a3 + 304) = v383;
                long long v131 = v316;
                long long v132 = v879;
              }
            }
            ++v128;
            ++v129;
            ++v122;
            char v312 = 1;
            double v124 = v884;
            goto LABEL_703;
          }
          if (v133 != v132 && ((*v133 <= v311) & v312) == 1)
          {
            long long v318 = *(char **)(a3 + 320);
            long long v319 = *(char **)(a3 + 328);
            uint64_t v320 = v319 - v318;
            if (v319 == v318
              || vabdd_f64(*((double *)v319 - 1), *v130) >= 0.0000001
              || vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v131) >= 0.0000001)
            {
              float64_t v321 = v131;
              if ((unint64_t)v319 >= *v888)
              {
                uint64_t v363 = v320 >> 3;
                unint64_t v364 = (v320 >> 3) + 1;
                if (v364 >> 61) {
                  goto LABEL_1505;
                }
                uint64_t v365 = *v888 - (void)v318;
                if (v365 >> 2 > v364) {
                  unint64_t v364 = v365 >> 2;
                }
                if ((unint64_t)v365 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v366 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v366 = v364;
                }
                if (v366)
                {
                  double v367 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v366);
                  long long v318 = *(char **)(a3 + 320);
                  long long v319 = *(char **)(a3 + 328);
                }
                else
                {
                  double v367 = 0;
                }
                uint64_t v392 = &v367[8 * v363];
                *(double *)uint64_t v392 = *v130;
                char v322 = v392 + 8;
                while (v319 != v318)
                {
                  uint64_t v393 = *((void *)v319 - 1);
                  v319 -= 8;
                  *((void *)v392 - 1) = v393;
                  v392 -= 8;
                }
                *(void *)(a3 + 320) = v392;
                *(void *)(a3 + 328) = v322;
                *(void *)(a3 + 336) = &v367[8 * v366];
                if (v318) {
                  operator delete(v318);
                }
              }
              else
              {
                *(double *)long long v319 = *v130;
                char v322 = v319 + 8;
              }
              *(void *)(a3 + 328) = v322;
              unint64_t v395 = *(char **)(a3 + 352);
              unint64_t v394 = *(void *)(a3 + 360);
              if ((unint64_t)v395 >= v394)
              {
                uint64_t v397 = *v885;
                uint64_t v398 = (v395 - *v885) >> 3;
                unint64_t v399 = v398 + 1;
                if ((unint64_t)(v398 + 1) >> 61) {
                  goto LABEL_1503;
                }
                uint64_t v400 = v394 - (void)v397;
                if (v400 >> 2 > v399) {
                  unint64_t v399 = v400 >> 2;
                }
                if ((unint64_t)v400 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v401 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v401 = v399;
                }
                if (v401)
                {
                  double v402 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v401);
                  uint64_t v397 = *(char **)(a3 + 344);
                  unint64_t v395 = *(char **)(a3 + 352);
                }
                else
                {
                  double v402 = 0;
                }
                unint64_t v403 = &v402[8 * v398];
                *(double *)unint64_t v403 = *v321;
                uint64_t v396 = v403 + 8;
                while (v395 != v397)
                {
                  uint64_t v404 = *((void *)v395 - 1);
                  v395 -= 8;
                  *((void *)v403 - 1) = v404;
                  v403 -= 8;
                }
                *(void *)(a3 + 344) = v403;
                *(void *)(a3 + 352) = v396;
                *(void *)(a3 + 360) = &v402[8 * v401];
                if (v397) {
                  operator delete(v397);
                }
              }
              else
              {
                *(double *)unint64_t v395 = *v321;
                uint64_t v396 = v395 + 8;
              }
              *(void *)(a3 + 352) = v396;
              uint64_t v406 = *(char **)(a3 + 304);
              unint64_t v405 = *(void *)(a3 + 312);
              if ((unint64_t)v406 >= v405)
              {
                unint64_t v408 = *v883;
                uint64_t v409 = (v406 - *v883) >> 3;
                unint64_t v410 = v409 + 1;
                if ((unint64_t)(v409 + 1) >> 61) {
                  goto LABEL_1504;
                }
                uint64_t v411 = v405 - (void)v408;
                if (v411 >> 2 > v410) {
                  unint64_t v410 = v411 >> 2;
                }
                if ((unint64_t)v411 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v412 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v412 = v410;
                }
                if (v412)
                {
                  v413 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v412);
                  unint64_t v408 = *(char **)(a3 + 296);
                  uint64_t v406 = *(char **)(a3 + 304);
                }
                else
                {
                  v413 = 0;
                }
                double v414 = &v413[8 * v409];
                *(double *)double v414 = *v133;
                unint64_t v407 = v414 + 8;
                while (v406 != v408)
                {
                  uint64_t v415 = *((void *)v406 - 1);
                  v406 -= 8;
                  *((void *)v414 - 1) = v415;
                  v414 -= 8;
                }
                *(void *)(a3 + 296) = v414;
                *(void *)(a3 + 304) = v407;
                *(void *)(a3 + 312) = &v413[8 * v412];
                if (v408) {
                  operator delete(v408);
                }
              }
              else
              {
                *(double *)uint64_t v406 = *v133;
                unint64_t v407 = v406 + 8;
              }
              *(void *)(a3 + 304) = v407;
              long long v131 = v321;
              long long v132 = v879;
            }
            double v124 = v884;
            if (v122 == v884)
            {
LABEL_700:
              double v122 = v884;
            }
            else
            {
              while (*v122 < *v133)
              {
                ++v128;
                ++v129;
                if (++v122 == v884) {
                  goto LABEL_700;
                }
              }
            }
            ++v133;
            ++v130;
            ++v131;
            goto LABEL_702;
          }
          if (v312)
          {
            ++v128;
            ++v129;
            ++v122;
LABEL_702:
            char v312 = 1;
            goto LABEL_703;
          }
          if (v122 == v124) {
            goto LABEL_704;
          }
          v871 = v131;
          unsigned int v323 = 0;
          char v324 = 0;
          do
          {
            long long v325 = *(char **)(a3 + 320);
            long long v326 = *(char **)(a3 + 328);
            uint64_t v327 = v326 - v325;
            if (v326 == v325
              || vabdd_f64(*((double *)v326 - 1), *v128) >= 0.0000001
              || vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v129) >= 0.0000001)
            {
              if ((unint64_t)v326 >= *v888)
              {
                uint64_t v329 = v327 >> 3;
                unint64_t v330 = (v327 >> 3) + 1;
                if (v330 >> 61) {
                  goto LABEL_1505;
                }
                uint64_t v331 = *v888 - (void)v325;
                if (v331 >> 2 > v330) {
                  unint64_t v330 = v331 >> 2;
                }
                if ((unint64_t)v331 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v332 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v332 = v330;
                }
                if (v332)
                {
                  int v333 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v332);
                  long long v325 = *(char **)(a3 + 320);
                  long long v326 = *(char **)(a3 + 328);
                }
                else
                {
                  int v333 = 0;
                }
                long long v334 = &v333[8 * v329];
                *(double *)long long v334 = *v128;
                long long v328 = v334 + 8;
                while (v326 != v325)
                {
                  uint64_t v335 = *((void *)v326 - 1);
                  v326 -= 8;
                  *((void *)v334 - 1) = v335;
                  v334 -= 8;
                }
                *(void *)(a3 + 320) = v334;
                *(void *)(a3 + 328) = v328;
                *(void *)(a3 + 336) = &v333[8 * v332];
                if (v325) {
                  operator delete(v325);
                }
              }
              else
              {
                *(double *)long long v326 = *v128;
                long long v328 = v326 + 8;
              }
              *(void *)(a3 + 328) = v328;
              float64x2_t v337 = *(char **)(a3 + 352);
              unint64_t v336 = *(void *)(a3 + 360);
              if ((unint64_t)v337 >= v336)
              {
                long long v339 = *v885;
                uint64_t v340 = (v337 - *v885) >> 3;
                unint64_t v341 = v340 + 1;
                if ((unint64_t)(v340 + 1) >> 61) {
                  goto LABEL_1503;
                }
                uint64_t v342 = v336 - (void)v339;
                if (v342 >> 2 > v341) {
                  unint64_t v341 = v342 >> 2;
                }
                if ((unint64_t)v342 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v343 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v343 = v341;
                }
                if (v343)
                {
                  int v344 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v343);
                  long long v339 = *(char **)(a3 + 344);
                  float64x2_t v337 = *(char **)(a3 + 352);
                }
                else
                {
                  int v344 = 0;
                }
                int v345 = &v344[8 * v340];
                *(double *)int v345 = *v129;
                long long v338 = v345 + 8;
                while (v337 != v339)
                {
                  uint64_t v346 = *((void *)v337 - 1);
                  v337 -= 8;
                  *((void *)v345 - 1) = v346;
                  v345 -= 8;
                }
                *(void *)(a3 + 344) = v345;
                *(void *)(a3 + 352) = v338;
                *(void *)(a3 + 360) = &v344[8 * v343];
                if (v339) {
                  operator delete(v339);
                }
              }
              else
              {
                *(double *)float64x2_t v337 = *v129;
                long long v338 = v337 + 8;
              }
              *(void *)(a3 + 352) = v338;
              uint64_t v348 = *(char **)(a3 + 304);
              unint64_t v347 = *(void *)(a3 + 312);
              if ((unint64_t)v348 >= v347)
              {
                uint64_t v350 = *v883;
                uint64_t v351 = (v348 - *v883) >> 3;
                unint64_t v352 = v351 + 1;
                if ((unint64_t)(v351 + 1) >> 61) {
                  goto LABEL_1504;
                }
                uint64_t v353 = v347 - (void)v350;
                if (v353 >> 2 > v352) {
                  unint64_t v352 = v353 >> 2;
                }
                if ((unint64_t)v353 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v354 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v354 = v352;
                }
                if (v354)
                {
                  unint64_t v355 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v354);
                  uint64_t v350 = *(char **)(a3 + 296);
                  uint64_t v348 = *(char **)(a3 + 304);
                }
                else
                {
                  unint64_t v355 = 0;
                }
                unint64_t v356 = &v355[8 * v351];
                *(double *)unint64_t v356 = *v122;
                unint64_t v349 = v356 + 8;
                while (v348 != v350)
                {
                  uint64_t v357 = *((void *)v348 - 1);
                  v348 -= 8;
                  *((void *)v356 - 1) = v357;
                  v356 -= 8;
                }
                *(void *)(a3 + 296) = v356;
                *(void *)(a3 + 304) = v349;
                *(void *)(a3 + 312) = &v355[8 * v354];
                if (v350) {
                  operator delete(v350);
                }
              }
              else
              {
                *(double *)uint64_t v348 = *v122;
                unint64_t v349 = v348 + 8;
              }
              *(void *)(a3 + 304) = v349;
              char v324 = 1;
            }
            ++v128;
            ++v129;
            ++v122;
            double v124 = v884;
            if (v323 > 1) {
              break;
            }
            ++v323;
          }
          while (v122 != v884);
          if (v324)
          {
            long long v132 = v879;
            long long v131 = v871;
            if (v133 == v879)
            {
              char v312 = 1;
LABEL_657:
              long long v133 = v879;
              goto LABEL_703;
            }
            while (*v133 <= *(double *)(*(void *)(a3 + 304) - 8))
            {
              ++v133;
              ++v130;
              ++v131;
              char v312 = 1;
              if (v133 == v879) {
                goto LABEL_657;
              }
            }
            goto LABEL_702;
          }
          char v312 = 0;
          long long v131 = v871;
          long long v132 = v879;
        }
        else
        {
          ++v128;
          ++v129;
          ++v122;
        }
LABEL_703:
        if (v122 == v124)
        {
LABEL_704:
          double v122 = v124;
          break;
        }
      }
    }
    double v416 = floor(v123);
    if (v133 == v132)
    {
LABEL_761:
      long long v133 = v132;
    }
    else
    {
      while (*v133 <= v416)
      {
        if (*v133 >= v311)
        {
          double v417 = *(char **)(a3 + 320);
          double v418 = *(char **)(a3 + 328);
          uint64_t v419 = v418 - v417;
          if (v418 == v417
            || vabdd_f64(*((double *)v418 - 1), *v130) >= 0.0000001
            || vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v131) >= 0.0000001)
          {
            uint64_t v420 = v131;
            if ((unint64_t)v418 >= *v888)
            {
              uint64_t v422 = v419 >> 3;
              unint64_t v423 = (v419 >> 3) + 1;
              if (v423 >> 61) {
                goto LABEL_1505;
              }
              uint64_t v424 = *v888 - (void)v417;
              if (v424 >> 2 > v423) {
                unint64_t v423 = v424 >> 2;
              }
              if ((unint64_t)v424 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v425 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v425 = v423;
              }
              if (v425)
              {
                double v426 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v425);
                double v417 = *(char **)(a3 + 320);
                double v418 = *(char **)(a3 + 328);
              }
              else
              {
                double v426 = 0;
              }
              double v427 = &v426[8 * v422];
              *(double *)double v427 = *v130;
              unint64_t v421 = v427 + 8;
              while (v418 != v417)
              {
                uint64_t v428 = *((void *)v418 - 1);
                v418 -= 8;
                *((void *)v427 - 1) = v428;
                v427 -= 8;
              }
              *(void *)(a3 + 320) = v427;
              *(void *)(a3 + 328) = v421;
              *(void *)(a3 + 336) = &v426[8 * v425];
              if (v417) {
                operator delete(v417);
              }
            }
            else
            {
              *(double *)double v418 = *v130;
              unint64_t v421 = v418 + 8;
            }
            *(void *)(a3 + 328) = v421;
            long long v430 = *(char **)(a3 + 352);
            unint64_t v429 = *(void *)(a3 + 360);
            if ((unint64_t)v430 >= v429)
            {
              long long v432 = *v885;
              uint64_t v433 = (v430 - *v885) >> 3;
              unint64_t v434 = v433 + 1;
              if ((unint64_t)(v433 + 1) >> 61) {
                goto LABEL_1503;
              }
              uint64_t v435 = v429 - (void)v432;
              if (v435 >> 2 > v434) {
                unint64_t v434 = v435 >> 2;
              }
              if ((unint64_t)v435 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v436 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v436 = v434;
              }
              if (v436)
              {
                long long v437 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v436);
                long long v432 = *(char **)(a3 + 344);
                long long v430 = *(char **)(a3 + 352);
              }
              else
              {
                long long v437 = 0;
              }
              uint64_t v438 = &v437[8 * v433];
              *(double *)uint64_t v438 = *v420;
              long long v431 = v438 + 8;
              while (v430 != v432)
              {
                uint64_t v439 = *((void *)v430 - 1);
                v430 -= 8;
                *((void *)v438 - 1) = v439;
                v438 -= 8;
              }
              *(void *)(a3 + 344) = v438;
              *(void *)(a3 + 352) = v431;
              *(void *)(a3 + 360) = &v437[8 * v436];
              if (v432) {
                operator delete(v432);
              }
            }
            else
            {
              *(double *)long long v430 = *v420;
              long long v431 = v430 + 8;
            }
            *(void *)(a3 + 352) = v431;
            double v441 = *(char **)(a3 + 304);
            unint64_t v440 = *(void *)(a3 + 312);
            if ((unint64_t)v441 >= v440)
            {
              double v443 = *v883;
              uint64_t v444 = (v441 - *v883) >> 3;
              unint64_t v445 = v444 + 1;
              if ((unint64_t)(v444 + 1) >> 61) {
                goto LABEL_1504;
              }
              uint64_t v446 = v440 - (void)v443;
              if (v446 >> 2 > v445) {
                unint64_t v445 = v446 >> 2;
              }
              if ((unint64_t)v446 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v447 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v447 = v445;
              }
              if (v447)
              {
                uint64_t v448 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v447);
                double v443 = *(char **)(a3 + 296);
                double v441 = *(char **)(a3 + 304);
              }
              else
              {
                uint64_t v448 = 0;
              }
              unint64_t v449 = &v448[8 * v444];
              *(double *)unint64_t v449 = *v133;
              uint64_t v442 = v449 + 8;
              while (v441 != v443)
              {
                uint64_t v450 = *((void *)v441 - 1);
                v441 -= 8;
                *((void *)v449 - 1) = v450;
                v449 -= 8;
              }
              *(void *)(a3 + 296) = v449;
              *(void *)(a3 + 304) = v442;
              *(void *)(a3 + 312) = &v448[8 * v447];
              if (v443) {
                operator delete(v443);
              }
            }
            else
            {
              *(double *)double v441 = *v133;
              uint64_t v442 = v441 + 8;
            }
            *(void *)(a3 + 304) = v442;
            long long v131 = v420;
            long long v132 = v879;
          }
        }
        ++v130;
        ++v131;
        ++v133;
        double v124 = v884;
        if (v133 == v132) {
          goto LABEL_761;
        }
      }
    }
    if (v122 == v124)
    {
      double v122 = v124;
      if (v880) {
        goto LABEL_1021;
      }
      goto LABEL_1035;
    }
    char v451 = 0;
    double v868 = 0.0;
    double v452 = 0.0;
    double v453 = 0.0;
    while (1)
    {
      double v454 = *v122;
      if (*v122 > v126) {
        goto LABEL_1015;
      }
      if (v454 <= v416)
      {
        ++v128;
        ++v129;
        ++v122;
        goto LABEL_1013;
      }
      if (v880)
      {
        double v455 = *v128++;
        double v868 = v455;
        double v456 = *v129++;
        double v452 = v456;
        ++v122;
        char v451 = 1;
        double v453 = v454;
        goto LABEL_1013;
      }
      if (v133 == v132) {
        goto LABEL_783;
      }
      if (*v133 < v126)
      {
        uint64_t v457 = *(char **)(a3 + 320);
        unint64_t v458 = *(char **)(a3 + 328);
        uint64_t v459 = v458 - v457;
        if (v458 == v457
          || vabdd_f64(*((double *)v458 - 1), *v130) >= 0.0000001
          || vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v131) >= 0.0000001)
        {
          v460 = v131;
          if ((unint64_t)v458 >= *v888)
          {
            uint64_t v536 = v459 >> 3;
            unint64_t v537 = (v459 >> 3) + 1;
            if (v537 >> 61) {
              goto LABEL_1505;
            }
            uint64_t v538 = *v888 - (void)v457;
            if (v538 >> 2 > v537) {
              unint64_t v537 = v538 >> 2;
            }
            if ((unint64_t)v538 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v539 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v539 = v537;
            }
            if (v539)
            {
              v540 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v539);
              uint64_t v457 = *(char **)(a3 + 320);
              unint64_t v458 = *(char **)(a3 + 328);
            }
            else
            {
              v540 = 0;
            }
            unint64_t v546 = &v540[8 * v536];
            *(double *)unint64_t v546 = *v130;
            uint64_t v461 = v546 + 8;
            while (v458 != v457)
            {
              uint64_t v547 = *((void *)v458 - 1);
              v458 -= 8;
              *((void *)v546 - 1) = v547;
              v546 -= 8;
            }
            *(void *)(a3 + 320) = v546;
            *(void *)(a3 + 328) = v461;
            *(void *)(a3 + 336) = &v540[8 * v539];
            if (v457) {
              operator delete(v457);
            }
          }
          else
          {
            *(double *)unint64_t v458 = *v130;
            uint64_t v461 = v458 + 8;
          }
          *(void *)(a3 + 328) = v461;
          v549 = *(char **)(a3 + 352);
          unint64_t v548 = *(void *)(a3 + 360);
          if ((unint64_t)v549 >= v548)
          {
            uint64_t v551 = *v885;
            uint64_t v552 = (v549 - *v885) >> 3;
            unint64_t v553 = v552 + 1;
            if ((unint64_t)(v552 + 1) >> 61) {
              goto LABEL_1503;
            }
            uint64_t v554 = v548 - (void)v551;
            if (v554 >> 2 > v553) {
              unint64_t v553 = v554 >> 2;
            }
            if ((unint64_t)v554 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v555 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v555 = v553;
            }
            if (v555)
            {
              uint64_t v556 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v555);
              uint64_t v551 = *(char **)(a3 + 344);
              v549 = *(char **)(a3 + 352);
            }
            else
            {
              uint64_t v556 = 0;
            }
            uint64_t v557 = &v556[8 * v552];
            *(double *)uint64_t v557 = *v460;
            v550 = v557 + 8;
            while (v549 != v551)
            {
              uint64_t v558 = *((void *)v549 - 1);
              v549 -= 8;
              *((void *)v557 - 1) = v558;
              v557 -= 8;
            }
            *(void *)(a3 + 344) = v557;
            *(void *)(a3 + 352) = v550;
            *(void *)(a3 + 360) = &v556[8 * v555];
            if (v551) {
              operator delete(v551);
            }
          }
          else
          {
            *(double *)v549 = *v460;
            v550 = v549 + 8;
          }
          *(void *)(a3 + 352) = v550;
          uint64_t v560 = *(char **)(a3 + 304);
          unint64_t v559 = *(void *)(a3 + 312);
          if ((unint64_t)v560 >= v559)
          {
            v562 = *v883;
            uint64_t v563 = (v560 - *v883) >> 3;
            unint64_t v564 = v563 + 1;
            if ((unint64_t)(v563 + 1) >> 61) {
              goto LABEL_1504;
            }
            uint64_t v565 = v559 - (void)v562;
            if (v565 >> 2 > v564) {
              unint64_t v564 = v565 >> 2;
            }
            if ((unint64_t)v565 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v566 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v566 = v564;
            }
            if (v566)
            {
              uint64_t v567 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v566);
              v562 = *(char **)(a3 + 296);
              uint64_t v560 = *(char **)(a3 + 304);
            }
            else
            {
              uint64_t v567 = 0;
            }
            unint64_t v568 = &v567[8 * v563];
            *(double *)unint64_t v568 = *v133;
            v561 = v568 + 8;
            while (v560 != v562)
            {
              uint64_t v569 = *((void *)v560 - 1);
              v560 -= 8;
              *((void *)v568 - 1) = v569;
              v568 -= 8;
            }
            *(void *)(a3 + 296) = v568;
            *(void *)(a3 + 304) = v561;
            *(void *)(a3 + 312) = &v567[8 * v566];
            if (v562) {
              operator delete(v562);
            }
          }
          else
          {
            *(double *)uint64_t v560 = *v133;
            v561 = v560 + 8;
          }
          *(void *)(a3 + 304) = v561;
          char v451 = 1;
          long long v131 = v460;
          long long v132 = v879;
        }
        double v124 = v884;
        if (v122 == v884)
        {
LABEL_971:
          double v122 = v884;
        }
        else
        {
          while (*v122 < *v133)
          {
            ++v128;
            ++v129;
            if (++v122 == v884) {
              goto LABEL_971;
            }
          }
        }
        ++v133;
        ++v130;
        ++v131;
        goto LABEL_1013;
      }
      if (vabdd_f64(*v133, v126) >= 0.0000001)
      {
        unint64_t v462 = *(char **)(a3 + 320);
        uint64_t v463 = *(char **)(a3 + 328);
        uint64_t v464 = v463 - v462;
        if (v463 == v462
          || vabdd_f64(*((double *)v463 - 1), *v128) >= 0.0000001
          || vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v129) >= 0.0000001)
        {
          v465 = v131;
          if ((unint64_t)v463 >= *v888)
          {
            uint64_t v541 = v464 >> 3;
            unint64_t v542 = (v464 >> 3) + 1;
            if (v542 >> 61) {
              goto LABEL_1505;
            }
            uint64_t v543 = *v888 - (void)v462;
            if (v543 >> 2 > v542) {
              unint64_t v542 = v543 >> 2;
            }
            if ((unint64_t)v543 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v544 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v544 = v542;
            }
            if (v544)
            {
              uint64_t v545 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v544);
              unint64_t v462 = *(char **)(a3 + 320);
              uint64_t v463 = *(char **)(a3 + 328);
            }
            else
            {
              uint64_t v545 = 0;
            }
            uint64_t v570 = &v545[8 * v541];
            *(double *)uint64_t v570 = *v128;
            unint64_t v466 = v570 + 8;
            while (v463 != v462)
            {
              uint64_t v571 = *((void *)v463 - 1);
              v463 -= 8;
              *((void *)v570 - 1) = v571;
              v570 -= 8;
            }
            *(void *)(a3 + 320) = v570;
            *(void *)(a3 + 328) = v466;
            *(void *)(a3 + 336) = &v545[8 * v544];
            if (v462) {
              operator delete(v462);
            }
          }
          else
          {
            *(double *)uint64_t v463 = *v128;
            unint64_t v466 = v463 + 8;
          }
          *(void *)(a3 + 328) = v466;
          unint64_t v573 = *(char **)(a3 + 352);
          unint64_t v572 = *(void *)(a3 + 360);
          if ((unint64_t)v573 >= v572)
          {
            uint64_t v575 = *v885;
            uint64_t v576 = (v573 - *v885) >> 3;
            unint64_t v577 = v576 + 1;
            if ((unint64_t)(v576 + 1) >> 61) {
              goto LABEL_1503;
            }
            uint64_t v578 = v572 - (void)v575;
            if (v578 >> 2 > v577) {
              unint64_t v577 = v578 >> 2;
            }
            if ((unint64_t)v578 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v579 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v579 = v577;
            }
            if (v579)
            {
              uint64_t v580 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v579);
              uint64_t v575 = *(char **)(a3 + 344);
              unint64_t v573 = *(char **)(a3 + 352);
            }
            else
            {
              uint64_t v580 = 0;
            }
            v581 = &v580[8 * v576];
            *(double *)v581 = *v129;
            unint64_t v574 = v581 + 8;
            while (v573 != v575)
            {
              uint64_t v582 = *((void *)v573 - 1);
              v573 -= 8;
              *((void *)v581 - 1) = v582;
              v581 -= 8;
            }
            *(void *)(a3 + 344) = v581;
            *(void *)(a3 + 352) = v574;
            *(void *)(a3 + 360) = &v580[8 * v579];
            if (v575) {
              operator delete(v575);
            }
          }
          else
          {
            *(double *)unint64_t v573 = *v129;
            unint64_t v574 = v573 + 8;
          }
          *(void *)(a3 + 352) = v574;
          uint64_t v584 = *(char **)(a3 + 304);
          unint64_t v583 = *(void *)(a3 + 312);
          if ((unint64_t)v584 >= v583)
          {
            uint64_t v586 = *v883;
            uint64_t v587 = (v584 - *v883) >> 3;
            unint64_t v588 = v587 + 1;
            if ((unint64_t)(v587 + 1) >> 61) {
              goto LABEL_1504;
            }
            uint64_t v589 = v583 - (void)v586;
            if (v589 >> 2 > v588) {
              unint64_t v588 = v589 >> 2;
            }
            if ((unint64_t)v589 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v590 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v590 = v588;
            }
            if (v590)
            {
              int v591 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v590);
              uint64_t v586 = *(char **)(a3 + 296);
              uint64_t v584 = *(char **)(a3 + 304);
            }
            else
            {
              int v591 = 0;
            }
            v592 = &v591[8 * v587];
            *(double *)v592 = *v122;
            v585 = v592 + 8;
            while (v584 != v586)
            {
              uint64_t v593 = *((void *)v584 - 1);
              v584 -= 8;
              *((void *)v592 - 1) = v593;
              v592 -= 8;
            }
            *(void *)(a3 + 296) = v592;
            *(void *)(a3 + 304) = v585;
            *(void *)(a3 + 312) = &v591[8 * v590];
            if (v586) {
              operator delete(v586);
            }
          }
          else
          {
            *(double *)uint64_t v584 = *v122;
            v585 = v584 + 8;
          }
          *(void *)(a3 + 304) = v585;
          char v451 = 1;
          long long v131 = v465;
          long long v132 = v879;
        }
        ++v128;
        ++v129;
        ++v122;
        double v124 = v884;
        goto LABEL_1013;
      }
LABEL_783:
      while (v122 != v124)
      {
        if (*v122 >= v126) {
          goto LABEL_787;
        }
        ++v128;
        ++v129;
        ++v122;
      }
      double v122 = v124;
LABEL_787:
      int v467 = 0;
      uint64_t v468 = *(double **)(v14 + v16);
      unint64_t v469 = v122 - 3;
      uint64_t v470 = v129 - 3;
      unint64_t v471 = v128 - 3;
      v872 = v131;
      while (1)
      {
        if (v122 == v468)
        {
          unint64_t v469 = v468;
          if (!v467) {
            goto LABEL_918;
          }
          goto LABEL_794;
        }
        if (v122 != v124 && *v122 <= v127) {
          break;
        }
        --v128;
        --v129;
        --v122;
        if (--v467 == -3)
        {
          unsigned int v472 = 3;
          goto LABEL_795;
        }
      }
      unint64_t v469 = v122;
      if (!v467)
      {
LABEL_918:
        uint64_t v470 = v129;
        unint64_t v471 = v128;
        goto LABEL_919;
      }
LABEL_794:
      unsigned int v472 = -v467;
      unint64_t v471 = v128;
      uint64_t v470 = v129;
LABEL_795:
      unint64_t v473 = *(double **)(a3 + 296);
      v474 = *(double **)(a3 + 304);
      if (v474 != v473)
      {
        double v475 = *v469;
        uint64_t v476 = v474 - 1;
        do
        {
          if (*v476 < v475) {
            break;
          }
          *(void *)(a3 + 328) -= 8;
          *(void *)(a3 + 352) -= 8;
          *(void *)(a3 + 304) = v476;
          BOOL v125 = v476-- == v473;
        }
        while (!v125);
      }
      if (v472 && v469 != v124) {
        break;
      }
LABEL_919:
      if (v469 == v124)
      {
        double v122 = v124;
        double v129 = v470;
        double v128 = v471;
        uint64_t v16 = v860;
        uint64_t v14 = v861;
        goto LABEL_1015;
      }
      double v128 = v471 + 1;
      double v129 = v470 + 1;
      double v122 = v469 + 1;
      uint64_t v16 = v860;
      uint64_t v14 = v861;
      long long v131 = v872;
      long long v132 = v879;
LABEL_1013:
      if (v122 == v124)
      {
        double v122 = v124;
LABEL_1015:
        if (v880)
        {
          if (v451)
          {
            double v594 = v868;
            if (v859 < 0.0000001)
            {
              double v453 = *(double *)(*(void *)(v873 + 200) - 8);
              if (*(_DWORD *)(a3 + 168))
              {
                double v453 = v453 + 1.0;
                uint64_t v595 = *(double **)(v873 + 216);
                v596 = *(double **)(v873 + 240);
              }
              else
              {
                uint64_t v595 = (double *)(*(void *)(v873 + 224) - 8);
                v596 = (double *)(*(void *)(v873 + 248) - 8);
              }
              double v594 = *v595;
              double v452 = *v596;
            }
            v693 = *(char **)(a3 + 320);
            v694 = *(char **)(a3 + 328);
            uint64_t v695 = v694 - v693;
            if (v694 != v693
              && vabdd_f64(*((double *)v694 - 1), v594) < 0.0000001
              && vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), v452) < 0.0000001)
            {
              goto LABEL_1463;
            }
            if ((unint64_t)v694 >= *v888)
            {
              uint64_t v697 = v695 >> 3;
              unint64_t v698 = (v695 >> 3) + 1;
              if (v698 >> 61) {
                goto LABEL_1505;
              }
              uint64_t v699 = *v888 - (void)v693;
              if (v699 >> 2 > v698) {
                unint64_t v698 = v699 >> 2;
              }
              if ((unint64_t)v699 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v700 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v700 = v698;
              }
              if (v700)
              {
                v701 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v700);
                v693 = *(char **)(a3 + 320);
                v694 = *(char **)(a3 + 328);
              }
              else
              {
                v701 = 0;
              }
              v768 = (double *)&v701[8 * v697];
              double *v768 = v594;
              uint64_t v696 = v768 + 1;
              while (v694 != v693)
              {
                uint64_t v769 = *((void *)v694 - 1);
                v694 -= 8;
                *((void *)v768-- - 1) = v769;
              }
              *(void *)(a3 + 320) = v768;
              *(void *)(a3 + 328) = v696;
              *(void *)(a3 + 336) = &v701[8 * v700];
              if (v693) {
                operator delete(v693);
              }
            }
            else
            {
              *(double *)v694 = v594;
              uint64_t v696 = v694 + 8;
            }
            *(void *)(a3 + 328) = v696;
            v771 = *(char **)(a3 + 352);
            unint64_t v770 = *(void *)(a3 + 360);
            if ((unint64_t)v771 >= v770)
            {
              uint64_t v773 = *v885;
              uint64_t v774 = (v771 - *v885) >> 3;
              unint64_t v775 = v774 + 1;
              if ((unint64_t)(v774 + 1) >> 61) {
                goto LABEL_1503;
              }
              uint64_t v776 = v770 - (void)v773;
              if (v776 >> 2 > v775) {
                unint64_t v775 = v776 >> 2;
              }
              if ((unint64_t)v776 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v777 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v777 = v775;
              }
              if (v777)
              {
                v778 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v777);
                uint64_t v773 = *(char **)(a3 + 344);
                v771 = *(char **)(a3 + 352);
              }
              else
              {
                v778 = 0;
              }
              v779 = (double *)&v778[8 * v774];
              double *v779 = v452;
              uint64_t v772 = v779 + 1;
              while (v771 != v773)
              {
                uint64_t v780 = *((void *)v771 - 1);
                v771 -= 8;
                *((void *)v779-- - 1) = v780;
              }
              *(void *)(a3 + 344) = v779;
              *(void *)(a3 + 352) = v772;
              *(void *)(a3 + 360) = &v778[8 * v777];
              if (v773) {
                operator delete(v773);
              }
            }
            else
            {
              *(double *)v771 = v452;
              uint64_t v772 = v771 + 8;
            }
            *(void *)(a3 + 352) = v772;
            v782 = *(double **)(a3 + 304);
            unint64_t v781 = *(void *)(a3 + 312);
            if ((unint64_t)v782 >= v781)
            {
              unint64_t v784 = (double *)*v883;
              uint64_t v785 = ((char *)v782 - *v883) >> 3;
              unint64_t v786 = v785 + 1;
              if ((unint64_t)(v785 + 1) >> 61) {
                goto LABEL_1504;
              }
              uint64_t v787 = v781 - (void)v784;
              if (v787 >> 2 > v786) {
                unint64_t v786 = v787 >> 2;
              }
              if ((unint64_t)v787 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v788 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v788 = v786;
              }
              if (v788)
              {
                v789 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v788);
                unint64_t v784 = *(double **)(a3 + 296);
                v782 = *(double **)(a3 + 304);
              }
              else
              {
                v789 = 0;
              }
              v790 = (double *)&v789[8 * v785];
              double *v790 = v453;
              v791 = v790 + 1;
              while (v782 != v784)
              {
                uint64_t v792 = *((void *)v782-- - 1);
                *((void *)v790-- - 1) = v792;
              }
              goto LABEL_1460;
            }
            double *v782 = v453;
            uint64_t v783 = v782 + 1;
            goto LABEL_1447;
          }
LABEL_1021:
          if (!*(_DWORD *)(a3 + 168))
          {
LABEL_1334:
            if (v122 != v124) {
              goto LABEL_1463;
            }
            uint64_t v766 = *(void *)(a3 + 328);
            uint64_t v767 = *(void *)(v873 + 224);
            if (v766 != *(void *)(a3 + 320)
              && vabdd_f64(*(double *)(v766 - 8), *(double *)(v767 - 8)) < 0.0000001
              && vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *(double *)(*(void *)(v873 + 248) - 8)) < 0.0000001)
            {
              goto LABEL_1463;
            }
            v683 = (void *)(v767 - 8);
            goto LABEL_1339;
          }
          if (v122 != v124) {
            goto LABEL_1463;
          }
          uint64_t v597 = *(char **)(a3 + 320);
          unint64_t v598 = *(char **)(a3 + 328);
          unint64_t v599 = *(double **)(v873 + 216);
          uint64_t v600 = v598 - v597;
          if (v598 != v597
            && vabdd_f64(*((double *)v598 - 1), *v599) < 0.0000001
            && vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), **(double **)(v873 + 240)) < 0.0000001)
          {
            goto LABEL_1463;
          }
          if ((unint64_t)v598 >= *v888)
          {
            uint64_t v688 = v600 >> 3;
            unint64_t v689 = (v600 >> 3) + 1;
            if (v689 >> 61) {
              goto LABEL_1505;
            }
            uint64_t v690 = *v888 - (void)v597;
            if (v690 >> 2 > v689) {
              unint64_t v689 = v690 >> 2;
            }
            if ((unint64_t)v690 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v691 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v691 = v689;
            }
            if (v691)
            {
              v692 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v691);
              uint64_t v597 = *(char **)(a3 + 320);
              unint64_t v598 = *(char **)(a3 + 328);
            }
            else
            {
              v692 = 0;
            }
            uint64_t v602 = v873;
            unint64_t v798 = &v692[8 * v688];
            *(double *)unint64_t v798 = *v599;
            v601 = v798 + 8;
            while (v598 != v597)
            {
              uint64_t v799 = *((void *)v598 - 1);
              v598 -= 8;
              *((void *)v798 - 1) = v799;
              v798 -= 8;
            }
            *(void *)(a3 + 320) = v798;
            *(void *)(a3 + 328) = v601;
            *(void *)(a3 + 336) = &v692[8 * v691];
            if (v597) {
              operator delete(v597);
            }
          }
          else
          {
            *(double *)unint64_t v598 = *v599;
            v601 = v598 + 8;
            uint64_t v602 = v873;
          }
          *(void *)(a3 + 328) = v601;
          v800 = *(void **)(v602 + 240);
          v802 = *(char **)(a3 + 352);
          unint64_t v801 = *(void *)(a3 + 360);
          if ((unint64_t)v802 >= v801)
          {
            v804 = *v885;
            uint64_t v805 = (v802 - *v885) >> 3;
            unint64_t v806 = v805 + 1;
            if ((unint64_t)(v805 + 1) >> 61) {
              goto LABEL_1503;
            }
            uint64_t v807 = v801 - (void)v804;
            if (v807 >> 2 > v806) {
              unint64_t v806 = v807 >> 2;
            }
            if ((unint64_t)v807 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v808 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v808 = v806;
            }
            if (v808)
            {
              unint64_t v809 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v808);
              v804 = *(char **)(a3 + 344);
              v802 = *(char **)(a3 + 352);
            }
            else
            {
              unint64_t v809 = 0;
            }
            v810 = &v809[8 * v805];
            *(void *)v810 = *v800;
            v803 = v810 + 8;
            while (v802 != v804)
            {
              uint64_t v811 = *((void *)v802 - 1);
              v802 -= 8;
              *((void *)v810 - 1) = v811;
              v810 -= 8;
            }
            *(void *)(a3 + 344) = v810;
            *(void *)(a3 + 352) = v803;
            *(void *)(a3 + 360) = &v809[8 * v808];
            if (v804) {
              operator delete(v804);
            }
          }
          else
          {
            *(void *)v802 = *v800;
            v803 = v802 + 8;
          }
          *(void *)(a3 + 352) = v803;
          double v812 = *(double *)(*(void *)(v602 + 200) - 8) + 1.0;
          v814 = *(double **)(a3 + 304);
          unint64_t v813 = *(void *)(a3 + 312);
          if ((unint64_t)v814 >= v813)
          {
            unint64_t v784 = (double *)*v883;
            uint64_t v815 = ((char *)v814 - *v883) >> 3;
            unint64_t v816 = v815 + 1;
            if ((unint64_t)(v815 + 1) >> 61) {
              goto LABEL_1504;
            }
            uint64_t v817 = v813 - (void)v784;
            if (v817 >> 2 > v816) {
              unint64_t v816 = v817 >> 2;
            }
            if ((unint64_t)v817 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v788 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v788 = v816;
            }
            if (v788)
            {
              v789 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v788);
              unint64_t v784 = *(double **)(a3 + 296);
              v814 = *(double **)(a3 + 304);
            }
            else
            {
              v789 = 0;
            }
            v790 = (double *)&v789[8 * v815];
            double *v790 = v812;
            v791 = v790 + 1;
            while (v814 != v784)
            {
              uint64_t v818 = *((void *)v814-- - 1);
              *((void *)v790-- - 1) = v818;
            }
            goto LABEL_1460;
          }
          double *v814 = v812;
          uint64_t v783 = v814 + 1;
LABEL_1447:
          v791 = v783;
LABEL_1462:
          *(void *)(a3 + 304) = v791;
LABEL_1463:
          uint64_t v838 = *(double **)(a3 + 320);
          if (*(void *)(a3 + 328) - (void)v838 < 0x11uLL || (fabs(v24) >= 0.0000001) | v878 & 1)
          {
            uint64_t v19 = v875;
            double v38 = 0.5;
          }
          else
          {
            v853 = *(char **)(v873 + 216);
            if (vabdd_f64(*v838, *(double *)v853) >= 0.00001
              || vabdd_f64(*(double *)*v885, **(double **)(v873 + 240)) >= 0.00001)
            {
              std::vector<double>::insert((uint64_t)v874, *(char **)(a3 + 320), v853);
              std::vector<double>::insert((uint64_t)v885, *v885, *(char **)(v873 + 240));
              std::vector<double>::insert((uint64_t)v883, *v883, *(char **)(v873 + 192));
            }
            int v854 = OZChannel::getValueAsInt(v877, MEMORY[0x1E4F1FA48], 0.0);
            uint64_t v838 = *v874;
            uint64_t v19 = v875;
            double v38 = 0.5;
            if (v854 != 4)
            {
              uint64_t v855 = *(void *)(v873 + 216);
              double v857 = *(double *)(v855 + 8);
              v856 = (char *)(v855 + 8);
              if (vabdd_f64(*v838, v857) >= 0.00001
                || vabdd_f64(*(double *)*v885, *(double *)(*(void *)(v873 + 240) + 8)) >= 0.00001)
              {
                double v858 = *(double *)(*(void *)(v873 + 192) + 8);
                if (*((double *)*v883 + 1) > v858 && *(double *)*v883 < v858)
                {
                  std::vector<double>::insert((uint64_t)v874, (char *)v838 + 8, v856);
                  std::vector<double>::insert((uint64_t)v885, *v885 + 8, (char *)(*(void *)(v873 + 240) + 8));
                  std::vector<double>::insert((uint64_t)v883, *v883 + 8, (char *)(*(void *)(v873 + 192) + 8));
                  uint64_t v838 = *v874;
                }
              }
            }
          }
          v839 = *(double **)(a3 + 328);
          if ((unint64_t)((char *)v839 - (char *)v838) >= 0x11)
          {
            v840 = v839 - 1;
            uint64_t v841 = v839 - v838 - 2;
            if (vabdd_f64(*(v839 - 1), v838[v841]) >= 0.00001
              || (uint64_t v842 = *(void *)(a3 + 352),
                  double v844 = *(double *)(v842 - 8),
                  uint64_t v843 = v842 - 8,
                  vabdd_f64(v844, *(double *)(*(void *)(a3 + 344) + 8 * v841)) >= 0.00001)
              || (*(void *)(a3 + 328) = v840,
                  *(void *)(a3 + 352) = v843,
                  *(void *)(a3 + 304) -= 8,
                  --v839,
                  (unint64_t)((char *)v840 - (char *)v838) >= 0x11))
            {
              v845 = v838 + 1;
              if (vabdd_f64(*v838, v838[1]) < 0.00001)
              {
                v846 = *v885;
                if (vabdd_f64(*(double *)*v885, *((double *)*v885 + 1)) < 0.00001)
                {
                  int64_t v847 = (char *)v839 - (char *)v845;
                  if (v839 != v845)
                  {
                    memmove(v838, v845, (char *)v839 - (char *)v845);
                    v846 = *v885;
                  }
                  *(void *)(a3 + 328) = (char *)v838 + v847;
                  v848 = *(char **)(a3 + 352);
                  int64_t v849 = v848 - (v846 + 8);
                  if (v848 != v846 + 8) {
                    memmove(v846, v846 + 8, v848 - (v846 + 8));
                  }
                  *(void *)(a3 + 352) = &v846[v849];
                  uint64_t v851 = *(void *)(a3 + 296);
                  uint64_t v850 = *(void *)(a3 + 304);
                  uint64_t v852 = v850 - (v851 + 8);
                  if (v850 != v851 + 8) {
                    memmove(*(void **)(a3 + 296), (const void *)(v851 + 8), v850 - (v851 + 8));
                  }
                  *(void *)(a3 + 304) = v851 + v852;
                }
              }
            }
          }
          goto LABEL_1479;
        }
        if (v451) {
          goto LABEL_1163;
        }
        while (v122 != v124)
        {
          if (*v122 >= v126) {
            goto LABEL_1035;
          }
          ++v128;
          ++v129;
          ++v122;
        }
        double v122 = v124;
LABEL_1035:
        int v603 = 0;
        v604 = v122 - 3;
        v605 = v129 - 3;
        uint64_t v606 = v128 - 3;
        while (1)
        {
          if (v122 == *(double **)(v14 + v16))
          {
            v604 = *(double **)(v14 + v16);
            if (v603) {
              goto LABEL_1048;
            }
            goto LABEL_1162;
          }
          if (v122 != v124 && *v122 <= v127) {
            break;
          }
          --v128;
          --v129;
          --v122;
          if (--v603 == -3)
          {
            unsigned int v607 = 3;
            goto LABEL_1049;
          }
        }
        v604 = v122;
        if (v603)
        {
LABEL_1048:
          unsigned int v607 = -v603;
          uint64_t v606 = v128;
          v605 = v129;
LABEL_1049:
          unint64_t v608 = *(double **)(a3 + 296);
          v609 = *(double **)(a3 + 304);
          if (v609 != v608)
          {
            double v610 = *v604;
            uint64_t v611 = v609 - 1;
            do
            {
              if (*v611 < v610) {
                break;
              }
              *(void *)(a3 + 328) -= 8;
              *(void *)(a3 + 352) -= 8;
              *(void *)(a3 + 304) = v611;
              BOOL v125 = v611-- == v608;
            }
            while (!v125);
          }
          if (v607 && v604 != v124)
          {
            int v612 = 0;
            v613 = *(double **)(a3 + 304);
            while (1)
            {
              v614 = *(double **)(a3 + 328);
              if (v613 == *(double **)(a3 + 296))
              {
                if ((unint64_t)v614 >= *v888)
                {
                  uint64_t v618 = *v874;
                  uint64_t v619 = v614 - *v874;
                  unint64_t v620 = v619 + 1;
                  if ((unint64_t)(v619 + 1) >> 61) {
                    goto LABEL_1506;
                  }
                  uint64_t v621 = *v888 - (void)v618;
                  if (v621 >> 2 > v620) {
                    unint64_t v620 = v621 >> 2;
                  }
                  if ((unint64_t)v621 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v622 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v622 = v620;
                  }
                  if (v622)
                  {
                    v623 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v622);
                    uint64_t v618 = *(double **)(a3 + 320);
                    v614 = *(double **)(a3 + 328);
                  }
                  else
                  {
                    v623 = 0;
                  }
                  unint64_t v630 = &v623[8 * v619];
                  *(double *)unint64_t v630 = *v606;
                  v617 = v630 + 8;
                  while (v614 != v618)
                  {
                    uint64_t v631 = *((void *)v614-- - 1);
                    *((void *)v630 - 1) = v631;
                    v630 -= 8;
                  }
                  *(void *)(a3 + 320) = v630;
                  *(void *)(a3 + 328) = v617;
                  *(void *)(a3 + 336) = &v623[8 * v622];
                  if (v618) {
                    operator delete(v618);
                  }
                  double v124 = v884;
                }
                else
                {
                  double *v614 = *v606;
                  v617 = v614 + 1;
                }
                *(void *)(a3 + 328) = v617;
                v633 = *(char **)(a3 + 352);
                unint64_t v632 = *(void *)(a3 + 360);
                if ((unint64_t)v633 >= v632)
                {
                  v635 = *v885;
                  uint64_t v636 = (v633 - *v885) >> 3;
                  unint64_t v637 = v636 + 1;
                  if ((unint64_t)(v636 + 1) >> 61) {
                    goto LABEL_1503;
                  }
                  uint64_t v638 = v632 - (void)v635;
                  if (v638 >> 2 > v637) {
                    unint64_t v637 = v638 >> 2;
                  }
                  if ((unint64_t)v638 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v639 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v639 = v637;
                  }
                  if (v639)
                  {
                    v640 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v639);
                    v635 = *(char **)(a3 + 344);
                    v633 = *(char **)(a3 + 352);
                  }
                  else
                  {
                    v640 = 0;
                  }
                  v641 = &v640[8 * v636];
                  *(double *)v641 = *v605;
                  v634 = v641 + 8;
                  while (v633 != v635)
                  {
                    uint64_t v642 = *((void *)v633 - 1);
                    v633 -= 8;
                    *((void *)v641 - 1) = v642;
                    v641 -= 8;
                  }
                  *(void *)(a3 + 344) = v641;
                  *(void *)(a3 + 352) = v634;
                  *(void *)(a3 + 360) = &v640[8 * v639];
                  if (v635) {
                    operator delete(v635);
                  }
                  double v124 = v884;
                }
                else
                {
                  *(double *)v633 = *v605;
                  v634 = v633 + 8;
                }
                *(void *)(a3 + 352) = v634;
                v644 = *(char **)(a3 + 304);
                unint64_t v643 = *(void *)(a3 + 312);
                if ((unint64_t)v644 >= v643)
                {
                  v645 = *v883;
                  uint64_t v646 = (v644 - *v883) >> 3;
                  unint64_t v647 = v646 + 1;
                  if ((unint64_t)(v646 + 1) >> 61) {
                    goto LABEL_1504;
                  }
                  uint64_t v648 = v643 - (void)v645;
                  if (v648 >> 2 > v647) {
                    unint64_t v647 = v648 >> 2;
                  }
                  if ((unint64_t)v648 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v649 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v649 = v647;
                  }
                  if (v649)
                  {
                    unint64_t v650 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v649);
                    v645 = *(char **)(a3 + 296);
                    v644 = *(char **)(a3 + 304);
                  }
                  else
                  {
                    unint64_t v650 = 0;
                  }
                  v651 = &v650[8 * v646];
                  *(double *)v651 = *v604;
                  v613 = (double *)(v651 + 8);
                  while (v644 != v645)
                  {
                    uint64_t v652 = *((void *)v644 - 1);
                    v644 -= 8;
                    *((void *)v651 - 1) = v652;
                    v651 -= 8;
                  }
LABEL_1156:
                  *(void *)(a3 + 296) = v651;
                  *(void *)(a3 + 304) = v613;
                  *(void *)(a3 + 312) = &v650[8 * v649];
                  if (v645) {
                    operator delete(v645);
                  }
                  double v124 = v884;
                  goto LABEL_1159;
                }
              }
              else
              {
                double v615 = *v606;
                if (vabdd_f64(*(v614 - 1), *v606) < 0.0000001
                  && vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v605) < 0.0000001
                  || *(v613 - 1) >= *v604)
                {
                  goto LABEL_1160;
                }
                if ((unint64_t)v614 >= *v888)
                {
                  v624 = *v874;
                  uint64_t v625 = v614 - *v874;
                  unint64_t v626 = v625 + 1;
                  if ((unint64_t)(v625 + 1) >> 61) {
                    goto LABEL_1506;
                  }
                  uint64_t v627 = *v888 - (void)v624;
                  if (v627 >> 2 > v626) {
                    unint64_t v626 = v627 >> 2;
                  }
                  if ((unint64_t)v627 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v628 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v628 = v626;
                  }
                  if (v628)
                  {
                    unint64_t v629 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v628);
                    v624 = *(double **)(a3 + 320);
                    v614 = *(double **)(a3 + 328);
                    double v615 = *v606;
                  }
                  else
                  {
                    unint64_t v629 = 0;
                  }
                  v653 = (double *)&v629[8 * v625];
                  double *v653 = v615;
                  uint64_t v616 = v653 + 1;
                  while (v614 != v624)
                  {
                    uint64_t v654 = *((void *)v614-- - 1);
                    *((void *)v653-- - 1) = v654;
                  }
                  *(void *)(a3 + 320) = v653;
                  *(void *)(a3 + 328) = v616;
                  *(void *)(a3 + 336) = &v629[8 * v628];
                  if (v624) {
                    operator delete(v624);
                  }
                  double v124 = v884;
                }
                else
                {
                  double *v614 = v615;
                  uint64_t v616 = v614 + 1;
                }
                *(void *)(a3 + 328) = v616;
                uint64_t v656 = *(char **)(a3 + 352);
                unint64_t v655 = *(void *)(a3 + 360);
                if ((unint64_t)v656 >= v655)
                {
                  uint64_t v658 = *v885;
                  uint64_t v659 = (v656 - *v885) >> 3;
                  unint64_t v660 = v659 + 1;
                  if ((unint64_t)(v659 + 1) >> 61) {
                    goto LABEL_1503;
                  }
                  uint64_t v661 = v655 - (void)v658;
                  if (v661 >> 2 > v660) {
                    unint64_t v660 = v661 >> 2;
                  }
                  if ((unint64_t)v661 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v662 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v662 = v660;
                  }
                  if (v662)
                  {
                    v663 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v662);
                    uint64_t v658 = *(char **)(a3 + 344);
                    uint64_t v656 = *(char **)(a3 + 352);
                  }
                  else
                  {
                    v663 = 0;
                  }
                  v664 = &v663[8 * v659];
                  *(double *)v664 = *v605;
                  v657 = v664 + 8;
                  while (v656 != v658)
                  {
                    uint64_t v665 = *((void *)v656 - 1);
                    v656 -= 8;
                    *((void *)v664 - 1) = v665;
                    v664 -= 8;
                  }
                  *(void *)(a3 + 344) = v664;
                  *(void *)(a3 + 352) = v657;
                  *(void *)(a3 + 360) = &v663[8 * v662];
                  if (v658) {
                    operator delete(v658);
                  }
                  double v124 = v884;
                }
                else
                {
                  *(double *)uint64_t v656 = *v605;
                  v657 = v656 + 8;
                }
                *(void *)(a3 + 352) = v657;
                v644 = *(char **)(a3 + 304);
                unint64_t v666 = *(void *)(a3 + 312);
                if ((unint64_t)v644 >= v666)
                {
                  v645 = *v883;
                  uint64_t v667 = (v644 - *v883) >> 3;
                  unint64_t v668 = v667 + 1;
                  if ((unint64_t)(v667 + 1) >> 61) {
                    goto LABEL_1504;
                  }
                  uint64_t v669 = v666 - (void)v645;
                  if (v669 >> 2 > v668) {
                    unint64_t v668 = v669 >> 2;
                  }
                  if ((unint64_t)v669 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v649 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v649 = v668;
                  }
                  if (v649)
                  {
                    unint64_t v650 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v649);
                    v645 = *(char **)(a3 + 296);
                    v644 = *(char **)(a3 + 304);
                  }
                  else
                  {
                    unint64_t v650 = 0;
                  }
                  v651 = &v650[8 * v667];
                  *(double *)v651 = *v604;
                  v613 = (double *)(v651 + 8);
                  while (v644 != v645)
                  {
                    uint64_t v670 = *((void *)v644 - 1);
                    v644 -= 8;
                    *((void *)v651 - 1) = v670;
                    v651 -= 8;
                  }
                  goto LABEL_1156;
                }
              }
              *(double *)v644 = *v604;
              v613 = (double *)(v644 + 8);
LABEL_1159:
              *(void *)(a3 + 304) = v613;
LABEL_1160:
              ++v604;
              if (++v612 < v607)
              {
                ++v606;
                ++v605;
                if (v604 != v124) {
                  continue;
                }
              }
              break;
            }
          }
        }
LABEL_1162:
        double v122 = &v604[v604 != v124];
LABEL_1163:
        if (v122 != v124) {
          goto LABEL_1463;
        }
        uint64_t v672 = *(void *)(a3 + 296);
        uint64_t v671 = *(void *)(a3 + 304);
        if (*(_DWORD *)(a3 + 168))
        {
          if (v671 == v672)
          {
            std::vector<double>::push_back[abi:ne180100]((uint64_t)v874, *(void **)(v873 + 216));
            unint64_t v687 = *(void **)(v873 + 240);
LABEL_1333:
            std::vector<double>::push_back[abi:ne180100]((uint64_t)v885, v687);
            v889[0] = ceil(*(double *)(*(void *)(v866 + 8) - 8));
            std::vector<double>::push_back[abi:ne180100]((uint64_t)v883, v889);
            goto LABEL_1463;
          }
          v673 = *(double **)(v873 + 216);
          if (vabdd_f64(*(double *)(*(void *)(a3 + 328) - 8), *v673) < 0.0000001
            && vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), **(double **)(v873 + 240)) < 0.0000001)
          {
            goto LABEL_1463;
          }
          double v674 = *(double *)(v671 - 8);
          double v675 = ceil(*(double *)(*(void *)(v866 + 8) - 8));
          if (v674 >= v675 || vabdd_f64(v674, v675) < 0.00001) {
            goto LABEL_1463;
          }
LABEL_1332:
          std::vector<double>::push_back[abi:ne180100]((uint64_t)v874, v673);
          unint64_t v687 = *(void **)(v873 + 240);
          goto LABEL_1333;
        }
        uint64_t v681 = v873;
        if (v671 == v672)
        {
          std::vector<double>::push_back[abi:ne180100]((uint64_t)v874, (void *)(*(void *)(v873 + 224) - 8));
          goto LABEL_1341;
        }
        uint64_t v682 = *(void *)(v873 + 224);
        double v684 = *(double *)(v682 - 8);
        v683 = (void *)(v682 - 8);
        if (vabdd_f64(*(double *)(*(void *)(a3 + 328) - 8), v684) < 0.0000001
          && vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *(double *)(*(void *)(v873 + 248) - 8)) < 0.0000001)
        {
          goto LABEL_1463;
        }
        double v685 = *(double *)(v671 - 8);
        double v686 = *(double *)(*(void *)(v873 + 200) - 8);
        if (v685 >= v686 || vabdd_f64(v685, v686) < 0.00001) {
          goto LABEL_1463;
        }
LABEL_1339:
        std::vector<double>::push_back[abi:ne180100]((uint64_t)v874, v683);
        uint64_t v681 = v873;
LABEL_1341:
        std::vector<double>::push_back[abi:ne180100]((uint64_t)v885, (void *)(*(void *)(v681 + 248) - 8));
        std::vector<double>::push_back[abi:ne180100]((uint64_t)v883, (void *)(*(void *)(v681 + 200) - 8));
        goto LABEL_1463;
      }
    }
    int v477 = 0;
    v478 = *(double **)(a3 + 304);
    while (1)
    {
      uint64_t v479 = *(double **)(a3 + 328);
      if (v478 == *(double **)(a3 + 296))
      {
        if ((unint64_t)v479 >= *v888)
        {
          uint64_t v483 = *v874;
          uint64_t v484 = v479 - *v874;
          unint64_t v485 = v484 + 1;
          if ((unint64_t)(v484 + 1) >> 61) {
            goto LABEL_1506;
          }
          uint64_t v486 = *v888 - (void)v483;
          if (v486 >> 2 > v485) {
            unint64_t v485 = v486 >> 2;
          }
          if ((unint64_t)v486 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v487 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v487 = v485;
          }
          if (v487)
          {
            uint64_t v488 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v487);
            uint64_t v483 = *(double **)(a3 + 320);
            uint64_t v479 = *(double **)(a3 + 328);
          }
          else
          {
            uint64_t v488 = 0;
          }
          BOOL v495 = &v488[8 * v484];
          *(double *)BOOL v495 = *v471;
          unint64_t v482 = v495 + 8;
          while (v479 != v483)
          {
            uint64_t v496 = *((void *)v479-- - 1);
            *((void *)v495 - 1) = v496;
            v495 -= 8;
          }
          *(void *)(a3 + 320) = v495;
          *(void *)(a3 + 328) = v482;
          *(void *)(a3 + 336) = &v488[8 * v487];
          if (v483) {
            operator delete(v483);
          }
          double v124 = v884;
        }
        else
        {
          *uint64_t v479 = *v471;
          unint64_t v482 = v479 + 1;
        }
        *(void *)(a3 + 328) = v482;
        double v498 = *(char **)(a3 + 352);
        unint64_t v497 = *(void *)(a3 + 360);
        if ((unint64_t)v498 >= v497)
        {
          double v500 = *v885;
          uint64_t v501 = (v498 - *v885) >> 3;
          unint64_t v502 = v501 + 1;
          if ((unint64_t)(v501 + 1) >> 61) {
            goto LABEL_1503;
          }
          uint64_t v503 = v497 - (void)v500;
          if (v503 >> 2 > v502) {
            unint64_t v502 = v503 >> 2;
          }
          if ((unint64_t)v503 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v504 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v504 = v502;
          }
          if (v504)
          {
            double v505 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v504);
            double v500 = *(char **)(a3 + 344);
            double v498 = *(char **)(a3 + 352);
          }
          else
          {
            double v505 = 0;
          }
          v506 = &v505[8 * v501];
          *(double *)v506 = *v470;
          double v499 = v506 + 8;
          while (v498 != v500)
          {
            uint64_t v507 = *((void *)v498 - 1);
            v498 -= 8;
            *((void *)v506 - 1) = v507;
            v506 -= 8;
          }
          *(void *)(a3 + 344) = v506;
          *(void *)(a3 + 352) = v499;
          *(void *)(a3 + 360) = &v505[8 * v504];
          if (v500) {
            operator delete(v500);
          }
          double v124 = v884;
        }
        else
        {
          *(double *)double v498 = *v470;
          double v499 = v498 + 8;
        }
        *(void *)(a3 + 352) = v499;
        double v509 = *(char **)(a3 + 304);
        unint64_t v508 = *(void *)(a3 + 312);
        if ((unint64_t)v509 >= v508)
        {
          double v510 = *v883;
          uint64_t v511 = (v509 - *v883) >> 3;
          unint64_t v512 = v511 + 1;
          if ((unint64_t)(v511 + 1) >> 61) {
            goto LABEL_1504;
          }
          uint64_t v513 = v508 - (void)v510;
          if (v513 >> 2 > v512) {
            unint64_t v512 = v513 >> 2;
          }
          if ((unint64_t)v513 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v514 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v514 = v512;
          }
          if (v514)
          {
            double v515 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v514);
            double v510 = *(char **)(a3 + 296);
            double v509 = *(char **)(a3 + 304);
          }
          else
          {
            double v515 = 0;
          }
          double v516 = &v515[8 * v511];
          *(double *)double v516 = *v469;
          v478 = (double *)(v516 + 8);
          while (v509 != v510)
          {
            uint64_t v517 = *((void *)v509 - 1);
            v509 -= 8;
            *((void *)v516 - 1) = v517;
            v516 -= 8;
          }
LABEL_902:
          *(void *)(a3 + 296) = v516;
          *(void *)(a3 + 304) = v478;
          *(void *)(a3 + 312) = &v515[8 * v514];
          if (v510) {
            operator delete(v510);
          }
          double v124 = v884;
          goto LABEL_905;
        }
      }
      else
      {
        double v480 = *v471;
        if (vabdd_f64(*(v479 - 1), *v471) < 0.0000001
          && vabdd_f64(*(double *)(*(void *)(a3 + 352) - 8), *v470) < 0.0000001
          || *(v478 - 1) >= *v469)
        {
          goto LABEL_906;
        }
        if ((unint64_t)v479 >= *v888)
        {
          uint64_t v489 = *v874;
          uint64_t v490 = v479 - *v874;
          unint64_t v491 = v490 + 1;
          if ((unint64_t)(v490 + 1) >> 61) {
LABEL_1506:
          }
            std::vector<double>::__throw_length_error[abi:ne180100]();
          uint64_t v492 = *v888 - (void)v489;
          if (v492 >> 2 > v491) {
            unint64_t v491 = v492 >> 2;
          }
          if ((unint64_t)v492 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v493 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v493 = v491;
          }
          if (v493)
          {
            double v494 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v493);
            uint64_t v489 = *(double **)(a3 + 320);
            uint64_t v479 = *(double **)(a3 + 328);
            double v480 = *v471;
          }
          else
          {
            double v494 = 0;
          }
          double v518 = (double *)&v494[8 * v490];
          double *v518 = v480;
          uint64_t v481 = v518 + 1;
          while (v479 != v489)
          {
            uint64_t v519 = *((void *)v479-- - 1);
            *((void *)v518-- - 1) = v519;
          }
          *(void *)(a3 + 320) = v518;
          *(void *)(a3 + 328) = v481;
          *(void *)(a3 + 336) = &v494[8 * v493];
          if (v489) {
            operator delete(v489);
          }
          double v124 = v884;
        }
        else
        {
          *uint64_t v479 = v480;
          uint64_t v481 = v479 + 1;
        }
        *(void *)(a3 + 328) = v481;
        long long v521 = *(char **)(a3 + 352);
        unint64_t v520 = *(void *)(a3 + 360);
        if ((unint64_t)v521 >= v520)
        {
          long long v523 = *v885;
          uint64_t v524 = (v521 - *v885) >> 3;
          unint64_t v525 = v524 + 1;
          if ((unint64_t)(v524 + 1) >> 61) {
            goto LABEL_1503;
          }
          uint64_t v526 = v520 - (void)v523;
          if (v526 >> 2 > v525) {
            unint64_t v525 = v526 >> 2;
          }
          if ((unint64_t)v526 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v527 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v527 = v525;
          }
          if (v527)
          {
            v528 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v527);
            long long v523 = *(char **)(a3 + 344);
            long long v521 = *(char **)(a3 + 352);
          }
          else
          {
            v528 = 0;
          }
          v529 = &v528[8 * v524];
          *(double *)v529 = *v470;
          long long v522 = v529 + 8;
          while (v521 != v523)
          {
            uint64_t v530 = *((void *)v521 - 1);
            v521 -= 8;
            *((void *)v529 - 1) = v530;
            v529 -= 8;
          }
          *(void *)(a3 + 344) = v529;
          *(void *)(a3 + 352) = v522;
          *(void *)(a3 + 360) = &v528[8 * v527];
          if (v523) {
            operator delete(v523);
          }
          double v124 = v884;
        }
        else
        {
          *(double *)long long v521 = *v470;
          long long v522 = v521 + 8;
        }
        *(void *)(a3 + 352) = v522;
        double v509 = *(char **)(a3 + 304);
        unint64_t v531 = *(void *)(a3 + 312);
        if ((unint64_t)v509 >= v531)
        {
          double v510 = *v883;
          uint64_t v532 = (v509 - *v883) >> 3;
          unint64_t v533 = v532 + 1;
          if ((unint64_t)(v532 + 1) >> 61) {
            goto LABEL_1504;
          }
          uint64_t v534 = v531 - (void)v510;
          if (v534 >> 2 > v533) {
            unint64_t v533 = v534 >> 2;
          }
          if ((unint64_t)v534 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v514 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v514 = v533;
          }
          if (v514)
          {
            double v515 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v514);
            double v510 = *(char **)(a3 + 296);
            double v509 = *(char **)(a3 + 304);
          }
          else
          {
            double v515 = 0;
          }
          double v516 = &v515[8 * v532];
          *(double *)double v516 = *v469;
          v478 = (double *)(v516 + 8);
          while (v509 != v510)
          {
            uint64_t v535 = *((void *)v509 - 1);
            v509 -= 8;
            *((void *)v516 - 1) = v535;
            v516 -= 8;
          }
          goto LABEL_902;
        }
      }
      *(double *)double v509 = *v469;
      v478 = (double *)(v509 + 8);
LABEL_905:
      *(void *)(a3 + 304) = v478;
      char v451 = 1;
LABEL_906:
      ++v471;
      ++v470;
      ++v469;
      if (++v477 >= v472 || v469 == v124) {
        goto LABEL_919;
      }
    }
  }
LABEL_1491:
  if (a7) {
    *a7 = a3 + 320;
  }
  a6 = v865;
  if (a8) {
    *a8 = a3 + 344;
  }
  if (a9) {
    *a9 = a3 + 296;
  }
  if (a5) {
    *a5 = 0;
  }
  if (v865)
  {
    int v12 = ((*(void *)(a3 + 328) - *(void *)(a3 + 320)) >> 3) - 1;
    goto LABEL_1501;
  }
}

void std::vector<OZShapeEdgePolygon>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0xF0F0F0F0F0F0F0F1 * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x1E1E1E1E1E1E1E2) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v11 = v3;
    std::string __p = std::__allocate_at_least[abi:ne180100]<std::allocator<LightingStyleLight>>(v3, a2);
    uint64_t v8 = (char *)__p + v5;
    double v9 = (char *)__p + v5;
    double v10 = (char *)__p + 136 * v6;
    std::vector<OZShapeEdgePolygon>::__swap_out_circular_buffer(a1, &__p);
    if (v9 != v8) {
      double v9 = &v8[(v9 - v8 - 136) % 0x88uLL];
    }
    if (__p) {
      operator delete(__p);
    }
  }
}

void sub_1B7E37784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void OZShape::computeInsideFeatheringPolygons(uint64_t a1, uint64_t *a2, void *a3, double a4, uint64_t a5, uint64_t a6, double *a7)
{
  double v13 = (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
  double v145 = 0;
  uint64_t v146 = 0;
  double v147 = 0;
  double v14 = 1.0;
  if (*(_DWORD *)(a6 + 8))
  {
    double v15 = 1.0;
  }
  else
  {
    double v15 = 1.0;
    if (fabs(*(double *)(a6 + 224)) >= 0.0000001)
    {
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 13416), MEMORY[0x1E4F1FA48], 0.0);
      double v14 = v16;
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 13568), MEMORY[0x1E4F1FA48], 0.0);
    }
  }
  uint64_t v17 = a3[28] - a3[27];
  if (v17)
  {
    uint64_t v18 = 0;
    unint64_t v19 = v17 >> 3;
    uint64_t v20 = (v17 >> 3) - 1;
    double v21 = v15 * v15;
    double v22 = v14 * (v13 * v13 * v14);
    if ((unint64_t)(v17 >> 3) <= 1) {
      uint64_t v23 = 1;
    }
    else {
      uint64_t v23 = v17 >> 3;
    }
    do
    {
      uint64_t v24 = a3[27];
      double v25 = *(double *)(v24 + 8 * v18);
      uint64_t v26 = a3[30];
      double v27 = *(double *)(v26 + 8 * v18);
      double v28 = a7[12];
      double v29 = a7[13];
      double v30 = a7[15];
      double v31 = v30 + v25 * v28 + v27 * v29;
      double v32 = *a7;
      double v33 = a7[1];
      double v34 = a7[3];
      double v35 = a7[4];
      double v36 = (v34 + v25 * *a7 + v27 * v33) / v31;
      double v37 = a7[5];
      double v38 = v25 * v35 + v27 * v37;
      double v39 = a7[7];
      double v40 = (v39 + v38) / v31;
      unint64_t v41 = (v18 - 1) % v19;
      if (!v18) {
        unint64_t v41 = v20;
      }
      double v42 = *(double *)(v24 + 8 * v41);
      double v43 = *(double *)(v26 + 8 * v41);
      double v44 = v30 + v28 * v42 + v29 * v43;
      double v45 = (v34 + v32 * v42 + v33 * v43) / v44;
      double v46 = v39 + v35 * v42 + v37 * v43;
      unint64_t v47 = ++v18 % v19;
      double v48 = *(double *)(v24 + 8 * v47);
      double v49 = v46 / v44;
      double v50 = *(double *)(v26 + 8 * v47);
      double v51 = v30 + v28 * v48 + v29 * v50;
      double v52 = (v39 + v35 * v48 + v37 * v50) / v51;
      double v53 = (v34 + v32 * v48 + v33 * v50) / v51 - v45;
      double v54 = v52 - v49;
      double v55 = sqrt(v53 * v53 / v21 + v54 * v54 / v22);
      double v56 = v36 + v54 * a4 / v55 / v22;
      double v57 = v40 - v53 * a4 / v55 / v21;
      unint64_t v58 = v146;
      if (v146 >= v147)
      {
        double v60 = v145;
        uint64_t v61 = ((char *)v146 - (char *)v145) >> 4;
        unint64_t v62 = v61 + 1;
        if ((unint64_t)(v61 + 1) >> 60) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v63 = (char *)v147 - (char *)v145;
        if (v147 - v145 > v62) {
          unint64_t v62 = v63 >> 3;
        }
        if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v64 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v64 = v62;
        }
        if (v64)
        {
          double v65 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v147, v64);
          double v60 = v145;
          unint64_t v58 = v146;
        }
        else
        {
          double v65 = 0;
        }
        BOOL v66 = (double *)&v65[16 * v61];
        *BOOL v66 = v56;
        v66[1] = v57;
        uint64_t v67 = v66;
        if (v58 != v60)
        {
          do
          {
            *((_OWORD *)v67 - 1) = *((_OWORD *)v58 - 1);
            v67 -= 2;
            v58 -= 2;
          }
          while (v58 != v60);
          double v60 = v145;
        }
        double v59 = v66 + 2;
        double v145 = v67;
        uint64_t v146 = v66 + 2;
        double v147 = (double *)&v65[16 * v64];
        if (v60) {
          operator delete(v60);
        }
      }
      else
      {
        double *v146 = v56;
        v58[1] = v57;
        double v59 = v58 + 2;
      }
      uint64_t v146 = v59;
    }
    while (v18 != v23);
  }
  else
  {
    double v59 = v146;
  }
  unint64_t v68 = v145;
  if ((int)((unint64_t)((char *)v59 - (char *)v145) >> 4) < 2)
  {
    uint64_t v69 = 0;
  }
  else
  {
    uint64_t v69 = 0;
    do
    {
      long long v141 = 0u;
      memset(v142, 0, sizeof(v142));
      long long v139 = 0u;
      long long v140 = 0u;
      float64x2_t v137 = 0u;
      long long v138 = 0u;
      float64x2_t v135 = 0u;
      long long v136 = 0u;
      int v143 = 257;
      char v144 = 0;
      unint64_t v70 = (float64x2_t *)&v68[2 * v69];
      float64x2_t v71 = *v70;
      float64x2_t v135 = v71;
      *((void *)&v136 + 1) = 0x3FF0000000000000;
      float64x2_t v72 = v70[1];
      float64x2_t v137 = v72;
      *((void *)&v138 + 1) = 0x3FF0000000000000;
      uint64_t v73 = (double *)(a3[27] + 8 * v69);
      double v74 = v73[1];
      unint64_t v75 = (double *)(a3[30] + 8 * v69);
      double v76 = v75[1];
      double v77 = a7[12];
      double v78 = a7[13];
      double v79 = a7[15];
      double v80 = v79 + v74 * v77 + v76 * v78;
      double v81 = *a7;
      double v82 = a7[1];
      double v83 = a7[3];
      double v84 = a7[4];
      double v85 = (v83 + v74 * *a7 + v76 * v82) / v80;
      double v86 = a7[5];
      double v87 = v74 * v84 + v76 * v86;
      double v88 = a7[7];
      *(double *)&long long v139 = v85;
      *((double *)&v139 + 1) = (v88 + v87) / v80;
      long long v140 = xmmword_1B7E733E0;
      double v89 = v79 + v77 * *v73 + v78 * *v75;
      double v90 = v84 * *v73 + v86 * *v75;
      *(double *)&long long v141 = (v83 + v81 * *v73 + v82 * *v75) / v89;
      *((double *)&v141 + 1) = (v88 + v90) / v89;
      *(_OWORD *)long long v142 = xmmword_1B7E733E0;
      float64x2_t v91 = vsubq_f64(v72, v71);
      float64x2_t v92 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v91.f64[0], 0);
      v92.f64[0] = v85 - *(double *)&v141;
      v91.f64[0] = *((double *)&v139 + 1) - *((double *)&v141 + 1);
      int32x2_t v93 = vmovn_s64(vcltzq_f64(vdivq_f64(v92, v91)));
      if (v93.i8[4]) {
        double v94 = -1.0;
      }
      else {
        double v94 = 1.0;
      }
      if (v93.i8[0]) {
        double v95 = -1.0;
      }
      else {
        double v95 = 1.0;
      }
      if (vabdd_f64(v94, v95) >= 0.0000001)
      {
        float64x2_t v135 = v72;
        float64x2_t v137 = v71;
      }
      unint64_t v96 = a2[1];
      if (v96 >= a2[2])
      {
        uint64_t v97 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a2, (uint64_t)&v135);
      }
      else
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a2 + 2), a2[1], (uint64_t)&v135);
        uint64_t v97 = v96 + 136;
        a2[1] = v96 + 136;
      }
      ++v69;
      a2[1] = v97;
      unint64_t v68 = v145;
    }
    while (v69 < ((((char *)v146 - (char *)v145) << 28) - 0x100000000) >> 32);
  }
  if (*(_DWORD *)(a6 + 168))
  {
    v142[18] = 0;
    *(_WORD *)&v142[16] = 0;
    int v143 = 257;
    char v144 = 0;
    float64x2_t v98 = *(float64x2_t *)&v68[2 * v69];
    float64x2_t v135 = v98;
    long long v136 = xmmword_1B7E733E0;
    double v99 = *v68;
    double v100 = v68[1];
    v137.f64[0] = v99;
    v137.f64[1] = v100;
    long long v138 = xmmword_1B7E733E0;
    int v101 = (double *)a3[27];
    long long v102 = (double *)a3[30];
    double v103 = a7[12];
    double v104 = a7[13];
    double v105 = a7[15];
    double v106 = v105 + *v101 * v103 + *v102 * v104;
    double v107 = *a7;
    double v108 = a7[1];
    double v109 = a7[3];
    double v110 = a7[4];
    double v111 = a7[5];
    double v112 = a7[7];
    double v113 = (v112 + *v101 * v110 + *v102 * v111) / v106;
    *(double *)&long long v139 = (v109 + *v101 * *a7 + *v102 * v108) / v106;
    *((double *)&v139 + 1) = v113;
    long long v140 = xmmword_1B7E733E0;
    double v114 = v101[v69];
    double v115 = v102[v69];
    double v116 = v105 + v103 * v114 + v104 * v115;
    *(double *)&long long v141 = (v109 + v107 * v114 + v108 * v115) / v116;
    *((double *)&v141 + 1) = (v112 + v110 * v114 + v111 * v115) / v116;
    *(_OWORD *)long long v142 = xmmword_1B7E733E0;
    double v117 = (*(double *)&v139 - *(double *)&v141) / (v113 - *((double *)&v141 + 1));
    double v118 = 1.0;
    if ((v99 - v98.f64[0]) / (v100 - v98.f64[1]) >= 0.0) {
      double v119 = 1.0;
    }
    else {
      double v119 = -1.0;
    }
    if (v117 < 0.0) {
      double v118 = -1.0;
    }
    if (vabdd_f64(v119, v118) >= 0.0000001)
    {
      v135.f64[0] = v99;
      v135.f64[1] = v100;
      float64x2_t v137 = v98;
    }
    unint64_t v120 = a2[1];
    if (v120 >= a2[2])
    {
      uint64_t v121 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a2, (uint64_t)&v135);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a2 + 2), a2[1], (uint64_t)&v135);
      uint64_t v121 = v120 + 136;
      a2[1] = v120 + 136;
    }
    a2[1] = v121;
  }
  else
  {
    uint64_t v121 = a2[1];
  }
  double v122 = (_OWORD *)*a2;
  if ((int)(-252645135 * ((unint64_t)(v121 - *a2) >> 3)) < 2)
  {
    uint64_t v124 = 0;
  }
  else
  {
    uint64_t v123 = 0;
    uint64_t v124 = 0;
    do
    {
      BOOL v125 = (_OWORD *)((char *)v122 + v123);
      long long v126 = v125[3];
      *(_OWORD *)((char *)v125 + 136) = v125[2];
      *(_OWORD *)((char *)v125 + 152) = v126;
      double v127 = (_OWORD *)(*a2 + v123);
      long long v128 = v127[5];
      *(_OWORD *)((char *)v127 + 232) = v127[4];
      ++v124;
      *(_OWORD *)((char *)v127 + 248) = v128;
      double v122 = (_OWORD *)*a2;
      v123 += 136;
    }
    while (v124 < (int)(-1 - 252645135 * ((unint64_t)(a2[1] - *a2) >> 3)));
  }
  if (*(_DWORD *)(a6 + 168))
  {
    uint64_t v129 = 17 * v124;
    double v130 = (char *)v122 + 8 * v129;
    long long v131 = *((_OWORD *)v130 + 3);
    *double v122 = *((_OWORD *)v130 + 2);
    v122[1] = v131;
    uint64_t v132 = *a2;
    uint64_t v133 = *a2 + 8 * v129;
    long long v134 = *(_OWORD *)(v133 + 80);
    *(_OWORD *)(v132 + 96) = *(_OWORD *)(v133 + 64);
    *(_OWORD *)(v132 + 112) = v134;
  }
  if (v145)
  {
    uint64_t v146 = v145;
    operator delete(v145);
  }
}

void sub_1B7E37F58(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 - 168);
  if (v3)
  {
    *(void *)(v1 - 160) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double *OZShape::transformOutlinePolygonList(uint64_t a1, uint64_t *a2, unsigned int a3, double *a4)
{
  uint64_t v4 = *a2;
  if (0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 3) > a3)
  {
    uint64_t v7 = a3;
    unsigned int v8 = a3 + 1;
    do
    {
      uint64_t result = OZShapeEdgePolygon::transformPoints((double *)(v4 + 136 * v7), a4);
      uint64_t v7 = v8;
      uint64_t v4 = *a2;
    }
    while (0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 3) > v8++);
  }
  return result;
}

uint64_t *HGArray<__simd128_float32_t,(HGFormat)28>::reserve(uint64_t *result, int a2)
{
  if (*result)
  {
    if (*(_DWORD *)(*result + 12) < a2) {
      return (uint64_t *)HGArrayData::allocate(*result, a2);
    }
  }
  else if (a2 > 0)
  {
    HGArrayDataRef::allocate((HGArrayDataRef *)result);
  }
  return result;
}

void anonymous namespace'::addTriangleStripSequenceToArray(_anonymous_namespace_ *this, OZShapeVertexArrayData *a2)
{
  int v2 = (int)a2;
  uint64_t v4 = *((void *)this + 3);
  if (v4) {
    LODWORD(v4) = *(_DWORD *)(v4 + 8);
  }
  int v5 = v4 - a2;
  if ((int)v4 - (int)a2 >= 1)
  {
    unint64_t v6 = *((void *)this + 2);
    uint64_t v7 = (_DWORD *)*((void *)this + 1);
    if ((unint64_t)v7 >= v6)
    {
      double v9 = *(_DWORD **)this;
      unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *(void *)this) >> 2);
      unint64_t v11 = v10 + 1;
      if (v10 + 1 > 0x1555555555555555) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - (void)v9) >> 2);
      if (2 * v12 > v11) {
        unint64_t v11 = 2 * v12;
      }
      if (v12 >= 0xAAAAAAAAAAAAAAALL) {
        unint64_t v13 = 0x1555555555555555;
      }
      else {
        unint64_t v13 = v11;
      }
      if (v13)
      {
        double v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Vec3f>>((uint64_t)this + 16, v13);
        double v9 = *(_DWORD **)this;
        uint64_t v7 = (_DWORD *)*((void *)this + 1);
      }
      else
      {
        double v14 = 0;
      }
      double v15 = &v14[12 * v10];
      double v16 = &v14[12 * v13];
      *(_DWORD *)double v15 = 5;
      *((_DWORD *)v15 + 1) = v2;
      *((_DWORD *)v15 + 2) = v5;
      unsigned int v8 = v15 + 12;
      if (v7 != v9)
      {
        do
        {
          uint64_t v17 = *(void *)(v7 - 3);
          v7 -= 3;
          int v18 = v7[2];
          *(void *)(v15 - 12) = v17;
          v15 -= 12;
          *((_DWORD *)v15 + 2) = v18;
        }
        while (v7 != v9);
        double v9 = *(_DWORD **)this;
      }
      *(void *)this = v15;
      *((void *)this + 1) = v8;
      *((void *)this + 2) = v16;
      if (v9) {
        operator delete(v9);
      }
    }
    else
    {
      *uint64_t v7 = 5;
      v7[1] = a2;
      v7[2] = v5;
      unsigned int v8 = v7 + 3;
    }
    *((void *)this + 1) = v8;
  }
}

uint64_t *HGArray<__simd128_float32_t,(HGFormat)28>::resize(uint64_t *result, int a2)
{
  uint64_t v3 = *result;
  if (*result)
  {
    if (*(_DWORD *)(v3 + 12) < a2) {
      uint64_t result = (uint64_t *)HGArrayData::allocate(*result, a2);
    }
    *(_DWORD *)(v3 + 8) = a2;
  }
  else if (a2 > 0)
  {
    HGArrayDataRef::allocate((HGArrayDataRef *)result);
  }
  return result;
}

void HGArray<__simd128_float32_t,(HGFormat)28>::HGArray(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 28;
  HGArrayDataRef::allocate((HGArrayDataRef *)a1);
}

void sub_1B7E38318(_Unwind_Exception *exception_object)
{
  if (*v1) {
    HGArrayData::Release(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a2;
  if (a5 >= 1)
  {
    uint64_t v7 = a3;
    uint64_t v11 = a1[2];
    uint64_t v9 = (uint64_t)(a1 + 2);
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if ((uint64_t)(0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v11 - v12) >> 3)) >= a5)
    {
      uint64_t v20 = v12 - a2;
      if (a5 <= (uint64_t)(0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v12 - a2) >> 3)))
      {
        uint64_t v21 = a3 + 136 * a5;
      }
      else
      {
        uint64_t v21 = a3 + 8 * ((uint64_t)(v12 - a2) >> 3);
        std::vector<OZShapeEdgePolygon>::__construct_at_end<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>((uint64_t)a1, v21, a4);
        if (v20 < 1) {
          return v5;
        }
      }
      std::vector<OZShapeEdgePolygon>::__move_range((uint64_t)a1, v5, v12, v5 + 136 * a5);
      if (v21 != v7)
      {
        uint64_t v22 = v5;
        do
        {
          *(_OWORD *)uint64_t v22 = *(_OWORD *)v7;
          long long v23 = *(_OWORD *)(v7 + 16);
          long long v24 = *(_OWORD *)(v7 + 32);
          long long v25 = *(_OWORD *)(v7 + 64);
          *(_OWORD *)(v22 + 48) = *(_OWORD *)(v7 + 48);
          *(_OWORD *)(v22 + 64) = v25;
          *(_OWORD *)(v22 + 16) = v23;
          *(_OWORD *)(v22 + 32) = v24;
          long long v26 = *(_OWORD *)(v7 + 80);
          long long v27 = *(_OWORD *)(v7 + 96);
          long long v28 = *(_OWORD *)(v7 + 112);
          *(void *)(v22 + 128) = *(void *)(v7 + 128);
          *(_OWORD *)(v22 + 96) = v27;
          *(_OWORD *)(v22 + 112) = v28;
          *(_OWORD *)(v22 + 80) = v26;
          v7 += 136;
          v22 += 136;
        }
        while (v7 != v21);
      }
    }
    else
    {
      uint64_t v13 = *a1;
      unint64_t v14 = a5 - 0xF0F0F0F0F0F0F0FLL * ((uint64_t)(v12 - *a1) >> 3);
      if (v14 > 0x1E1E1E1E1E1E1E1) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v15 = 0xF0F0F0F0F0F0F0F1 * ((a2 - v13) >> 3);
      unint64_t v16 = 0xF0F0F0F0F0F0F0F1 * ((v10 - v13) >> 3);
      uint64_t v17 = 2 * v16;
      if (2 * v16 <= v14) {
        uint64_t v17 = a5 - 0xF0F0F0F0F0F0F0FLL * ((uint64_t)(v12 - *a1) >> 3);
      }
      if (v16 >= 0xF0F0F0F0F0F0F0) {
        unint64_t v18 = 0x1E1E1E1E1E1E1E1;
      }
      else {
        unint64_t v18 = v17;
      }
      uint64_t v38 = v9;
      if (v18) {
        unint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LightingStyleLight>>(v9, v18);
      }
      else {
        unint64_t v19 = 0;
      }
      uint64_t v29 = (uint64_t)&v19[136 * v15];
      std::string __p = v19;
      uint64_t v35 = v29;
      uint64_t v36 = v29;
      double v37 = &v19[136 * v18];
      uint64_t v30 = 17 * a5;
      uint64_t v31 = v29 + 136 * a5;
      uint64_t v32 = 8 * v30;
      do
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(v38, v29, v7);
        v29 += 136;
        v7 += 136;
        v32 -= 136;
      }
      while (v32);
      uint64_t v36 = v31;
      uint64_t v5 = std::vector<OZShapeEdgePolygon>::__swap_out_circular_buffer(a1, &__p, v5);
      if (v36 != v35) {
        uint64_t v36 = (v36 - v35 - 136) % 0x88uLL + v35;
      }
      if (__p) {
        operator delete(__p);
      }
    }
  }
  return v5;
}

void sub_1B7E38570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<OZShapeEdgePolygon>::__construct_at_end<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(a1 + 16, v4 + v7, a2 + v7);
      v7 += 136;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  *(void *)(a1 + 8) = v4;
}

void sub_1B7E38640(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

__n128 std::vector<OZShapeEdgePolygon>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = v7 - a4;
  unint64_t v9 = a2 + v7 - a4;
  if (v9 >= a3)
  {
    uint64_t v11 = *(void *)(a1 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 8);
    do
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(a1 + 16, v11, v9);
      v9 += 136;
      v11 += 136;
    }
    while (v9 < a3);
  }
  *(void *)(a1 + 8) = v11;
  if (v7 != a4)
  {
    uint64_t v13 = v7 - 136;
    uint64_t v14 = 8 * (v8 >> 3);
    uint64_t v15 = a2 - 136;
    do
    {
      *(_OWORD *)uint64_t v13 = *(_OWORD *)(v15 + v14);
      long long v16 = *(_OWORD *)(v15 + v14 + 16);
      long long v17 = *(_OWORD *)(v15 + v14 + 32);
      long long v18 = *(_OWORD *)(v15 + v14 + 64);
      *(_OWORD *)(v13 + 48) = *(_OWORD *)(v15 + v14 + 48);
      *(_OWORD *)(v13 + 64) = v18;
      *(_OWORD *)(v13 + 16) = v16;
      *(_OWORD *)(v13 + 32) = v17;
      __n128 result = *(__n128 *)(v15 + v14 + 80);
      long long v19 = *(_OWORD *)(v15 + v14 + 96);
      long long v20 = *(_OWORD *)(v15 + v14 + 112);
      *(void *)(v13 + 128) = *(void *)(v15 + v14 + 128);
      *(_OWORD *)(v13 + 96) = v19;
      *(_OWORD *)(v13 + 112) = v20;
      *(__n128 *)(v13 + 80) = result;
      v13 -= 136;
      v14 -= 136;
    }
    while (v14);
  }
  return result;
}

void sub_1B7E38744(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<OZShapeEdgePolygon>::__swap_out_circular_buffer(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = a2[1];
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = *a1;
  uint64_t v9 = v6;
  if (*a1 != a3)
  {
    uint64_t v10 = a3;
    uint64_t v9 = a2[1];
    do
    {
      v9 -= 136;
      v10 -= 136;
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(v7, v9, v10);
    }
    while (v10 != v8);
  }
  a2[1] = v9;
  uint64_t v11 = a1[1];
  uint64_t v12 = a2[2];
  if (v11 != v3)
  {
    do
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(v7, v12, v3);
      v3 += 136;
      v12 += 136;
    }
    while (v3 != v11);
    uint64_t v9 = a2[1];
  }
  a2[2] = v12;
  uint64_t v13 = *a1;
  *a1 = v9;
  a2[1] = v13;
  uint64_t v14 = a1[1];
  a1[1] = a2[2];
  a2[2] = v14;
  uint64_t v15 = a1[2];
  a1[2] = a2[3];
  a2[3] = v15;
  *a2 = a2[1];
  return v6;
}

void std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = 0; i != 128; i += 32)
  {
    uint64_t v4 = (_OWORD *)(a2 + i);
    *uint64_t v4 = *(_OWORD *)(a3 + i);
    v4[1] = *(_OWORD *)(a3 + i + 16);
  }
  *(void *)(a2 + 128) = *(void *)(a3 + 128);
}

uint64_t std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = 0xF0F0F0F0F0F0F0F1 * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x1E1E1E1E1E1E1E1) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0xE1E1E1E1E1E1E1E2 * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0xE1E1E1E1E1E1E1E2 * ((a1[2] - *a1) >> 3);
  }
  if (0xF0F0F0F0F0F0F0F1 * ((a1[2] - *a1) >> 3) >= 0xF0F0F0F0F0F0F0) {
    unint64_t v6 = 0x1E1E1E1E1E1E1E1;
  }
  else {
    unint64_t v6 = v4;
  }
  uint64_t v14 = a1 + 2;
  if (v6) {
    uint64_t v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LightingStyleLight>>((uint64_t)(a1 + 2), v6);
  }
  else {
    uint64_t v7 = 0;
  }
  std::string __p = v7;
  uint64_t v11 = &v7[136 * v3];
  uint64_t v13 = &v7[136 * v6];
  std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  uint64_t v12 = v11 + 136;
  std::vector<OZShapeEdgePolygon>::__swap_out_circular_buffer(a1, &__p);
  uint64_t v8 = a1[1];
  if (v12 != v11) {
    uint64_t v12 = &v11[(v12 - v11 - 136) % 0x88uLL];
  }
  if (__p) {
    operator delete(__p);
  }
  return v8;
}

void sub_1B7E389A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<OZShapeEdgePolygon>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  if (v4 != *a1)
  {
    do
    {
      v6 -= 136;
      v4 -= 136;
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a1 + 2), v6, v4);
    }
    while (v4 != v5);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

void std::__split_buffer<OZShapeEdgePolygon>::push_back[abi:ne180100](void **a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t)a1[2];
  if ((void *)v4 == a1[3])
  {
    uint64_t v6 = *a1;
    uint64_t v5 = (char *)a1[1];
    if (v5 <= *a1)
    {
      if ((void *)v4 == v6) {
        unint64_t v17 = 1;
      }
      else {
        unint64_t v17 = 0xE1E1E1E1E1E1E1E2 * ((v4 - (uint64_t)v6) >> 3);
      }
      unint64_t v18 = v17 >> 2;
      uint64_t v19 = (uint64_t)a1[4];
      long long v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LightingStyleLight>>(v19, v17);
      uint64_t v22 = v21;
      long long v23 = &v20[136 * v18];
      uint64_t v24 = (uint64_t)a1[1];
      uint64_t v4 = (uint64_t)v23;
      uint64_t v25 = (uint64_t)a1[2] - v24;
      if (v25)
      {
        uint64_t v26 = v25 / 136;
        uint64_t v4 = (uint64_t)&v23[136 * v26];
        uint64_t v27 = 136 * v26;
        uint64_t v28 = (uint64_t)v23;
        do
        {
          std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(v19, v28, v24);
          v28 += 136;
          v24 += 136;
          v27 -= 136;
        }
        while (v27);
      }
      uint64_t v29 = *a1;
      *a1 = v20;
      a1[1] = v23;
      a1[2] = (void *)v4;
      a1[3] = &v20[136 * v22];
      if (v29)
      {
        operator delete(v29);
        uint64_t v4 = (uint64_t)a1[2];
      }
    }
    else
    {
      int64_t v7 = 0xF0F0F0F0F0F0F0F1 * ((v5 - (unsigned char *)*a1) >> 3);
      uint64_t v8 = v7 + 2;
      if (v7 >= -1) {
        uint64_t v8 = v7 + 1;
      }
      if (v5 == (char *)v4)
      {
        uint64_t v16 = (uint64_t)&v5[-136 * (v8 >> 1)];
      }
      else
      {
        do
        {
          uint64_t v9 = &v5[-136 * (v8 >> 1)];
          *(_OWORD *)uint64_t v9 = *(_OWORD *)v5;
          long long v10 = *((_OWORD *)v5 + 1);
          long long v11 = *((_OWORD *)v5 + 2);
          long long v12 = *((_OWORD *)v5 + 4);
          *((_OWORD *)v9 + 3) = *((_OWORD *)v5 + 3);
          *((_OWORD *)v9 + 4) = v12;
          *((_OWORD *)v9 + 1) = v10;
          *((_OWORD *)v9 + 2) = v11;
          long long v13 = *((_OWORD *)v5 + 5);
          long long v14 = *((_OWORD *)v5 + 6);
          long long v15 = *((_OWORD *)v5 + 7);
          *((void *)v9 + 16) = *((void *)v5 + 16);
          *((_OWORD *)v9 + 6) = v14;
          *((_OWORD *)v9 + 7) = v15;
          *((_OWORD *)v9 + 5) = v13;
          v5 += 136;
        }
        while (v5 != (char *)v4);
        uint64_t v4 = (uint64_t)a1[1];
        uint64_t v16 = (uint64_t)&v5[-136 * (v8 >> 1)];
      }
      a1[1] = (void *)(v4 - 136 * (v8 >> 1));
      a1[2] = (void *)v16;
      uint64_t v4 = v16;
    }
  }
  std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)a1[4], v4, a2);
  a1[2] = (char *)a1[2] + 136;
}

void sub_1B7E38C5C(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

double *OZShapeEdgePolygon::transformPoints(double *a1, double *a2)
{
  PCMatrix44Tmpl<double>::transform<double>(a2, a1, a1);
  PCMatrix44Tmpl<double>::transform<double>(a2, a1 + 4, a1 + 4);
  PCMatrix44Tmpl<double>::transform<double>(a2, a1 + 8, a1 + 8);

  return PCMatrix44Tmpl<double>::transform<double>(a2, a1 + 12, a1 + 12);
}

BOOL OZShapeEdgePolygon::isValid(OZShapeEdgePolygon *this)
{
  return vabdd_f64(*((double *)this + 8), *((double *)this + 12)) >= 0.0000001
      || vabdd_f64(*((double *)this + 9), *((double *)this + 13)) >= 0.0000001
      || vabdd_f64(*((double *)this + 10), *((double *)this + 14)) >= 0.0000001
      || vabdd_f64(*((double *)this + 11), *((double *)this + 15)) >= 0.0000001
      || vabdd_f64(*(double *)this, *((double *)this + 4)) >= 0.0000001
      || vabdd_f64(*((double *)this + 1), *((double *)this + 5)) >= 0.0000001
      || vabdd_f64(*((double *)this + 2), *((double *)this + 6)) >= 0.0000001
      || vabdd_f64(*((double *)this + 3), *((double *)this + 7)) >= 0.0000001;
}

BOOL OZShapeEdgePolygon::checkWindingOrder(OZShapeEdgePolygon *this)
{
  uint64_t v1 = 0;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = this;
  do
  {
    double v3 = *((double *)v2 + 3);
    if (v3 <= 0.0) {
      return 1;
    }
    uint64_t v4 = *(void *)v2;
    uint64_t v5 = *((void *)v2 + 1);
    uint64_t v2 = (OZShapeEdgePolygon *)((char *)v2 + 32);
    *(void *)&v25[v1] = v4;
    *(void *)&v23[v1] = v5;
    *(double *)&v21[v1] = v3;
    v1 += 8;
  }
  while (v1 != 32);
  uint64_t v6 = 0;
  uint64_t v7 = *((void *)this + 1);
  uint64_t v26 = *(void *)this;
  uint64_t v24 = v7;
  uint64_t v22 = *((void *)this + 3);
  do
  {
    double v8 = *(double *)&v21[v6];
    if (vabdd_f64(0.0, v8) >= 0.0000001)
    {
      *(double *)&v25[v6] = *(double *)&v25[v6] / v8;
      *(double *)&v23[v6] = *(double *)&v23[v6] / v8;
    }
    v6 += 8;
  }
  while (v6 != 40);
  uint64_t v9 = 0;
  long long v10 = (const double *)v23;
  int8x16_t v12 = (int8x16_t)vld1q_dup_f64(v10);
  long long v11 = v10 + 1;
  long long v13 = (const double *)v25;
  int8x16_t v15 = (int8x16_t)vld1q_dup_f64(v13);
  long long v14 = v13 + 1;
  double v16 = 0.0;
  do
  {
    float64x2_t v17 = *(float64x2_t *)&v11[v9];
    float64x2_t v18 = *(float64x2_t *)&v14[v9];
    float64x2_t v19 = vsubq_f64(vmulq_f64((float64x2_t)vextq_s8(v15, (int8x16_t)v18, 8uLL), v17), vmulq_f64(v18, (float64x2_t)vextq_s8(v12, (int8x16_t)v17, 8uLL)));
    double v16 = v16 + v19.f64[0] + v19.f64[1];
    v9 += 2;
    int8x16_t v12 = (int8x16_t)v17;
    int8x16_t v15 = (int8x16_t)v18;
  }
  while (v9 != 4);
  return v16 > 0.0;
}

void OZShapeRenderParams::OZShapeRenderParams(OZShapeRenderParams *this)
{
  *(void *)this = &unk_1F11992D0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  PCWorkingColorVector::PCWorkingColorVector((OZShapeRenderParams *)((char *)this + 280));
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *((void *)this + 45) = 0;
  *((void *)this + 50) = 0;
  *((void *)this + 51) = 0xBFF0000000000000;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  uint64_t v2 = MEMORY[0x1E4F1FA48];
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *((void *)this + 48) = *(void *)(v2 + 16);
  *((void *)this + 49) = 0;
  *((_OWORD *)this + 23) = *(_OWORD *)v2;
  *((void *)this + 68) = 0x3FF0000000000000;
  *((void *)this + 63) = 0x3FF0000000000000;
  *((void *)this + 58) = 0x3FF0000000000000;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 26) = xmmword_1B7E73BA0;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_DWORD *)this + 138) = 0x1000000;
  *((void *)this + 94) = 0;
  *((void *)this + 98) = 0;
  *((void *)this + 99) = 0;
  __asm { FMOV            V2.2D, #-1.0 }
  *((_OWORD *)this + 50) = _Q2;
  *(_OWORD *)((char *)this + 952) = 0u;
  *(_OWORD *)((char *)this + 968) = 0u;
  *(_OWORD *)((char *)this + 984) = 0u;
  *(_OWORD *)((char *)this + 1000) = 0u;
  *(_OWORD *)((char *)this + 1016) = 0u;
  *(_OWORD *)((char *)this + 1032) = 0u;
  *(_OWORD *)((char *)this + 1048) = 0u;
  *(_OWORD *)((char *)this + 1064) = 0u;
  *(_OWORD *)((char *)this + 1080) = 0u;
  *(_OWORD *)((char *)this + 1096) = 0u;
  *(_OWORD *)((char *)this + 1112) = 0u;
  *(_OWORD *)((char *)this + 1128) = 0u;
  *(_OWORD *)((char *)this + 760) = *(_OWORD *)v2;
  *((void *)this + 97) = *(void *)(v2 + 16);
  *((void *)this + 117) = 0x3FF0000000000000;
  *((void *)this + 112) = 0x3FF0000000000000;
  *((void *)this + 107) = 0x3FF0000000000000;
  *((void *)this + 102) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 824) = 0u;
  *(_OWORD *)((char *)this + 840) = 0u;
  *((_OWORD *)this + 54) = 0u;
  *((_OWORD *)this + 55) = 0u;
  *(_OWORD *)((char *)this + 904) = 0u;
  *(_OWORD *)((char *)this + 920) = 0u;
  *((_DWORD *)this + 236) = 0x1000000;
  *((void *)this + 165) = 0x3FF0000000000000;
  *((void *)this + 160) = 0x3FF0000000000000;
  *((void *)this + 155) = 0x3FF0000000000000;
  *((void *)this + 150) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1208) = 0u;
  *(_OWORD *)((char *)this + 1224) = 0u;
  *((_OWORD *)this + 78) = 0u;
  *((_OWORD *)this + 79) = 0u;
  *(_OWORD *)((char *)this + 1304) = 0u;
  *(_OWORD *)((char *)this + 1288) = 0u;
  *((_DWORD *)this + 2) = -1;
  *((void *)this + 2) = 0xC08F400000000000;
  *(_OWORD *)((char *)this + 72) = xmmword_1B7E733E0;
  *((unsigned char *)this + 112) = 0;
  *(void *)&long long v8 = -1;
  *((void *)&v8 + 1) = -1;
  *(void *)((char *)this + 116) = -1;
  *((void *)this + 21) = 0xFFFFFFFF00000000;
  *((int64x2_t *)this + 14) = vdupq_n_s64(0xC08F400000000000);
  *(_OWORD *)((char *)this + 24) = v8;
  *((void *)this + 24) = 0;
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)((char *)this + 40) = _Q0;
  *(_OWORD *)((char *)this + 56) = _Q0;
  *((_OWORD *)this + 8) = _Q0;
  *((_OWORD *)this + 9) = _Q0;
  *(_OWORD *)((char *)this + 88) = xmmword_1B7E7E030;
  *((void *)this + 13) = 0xBFF0000000000000;
  *((void *)this + 20) = 0x3FF0000000000000;
  *((_DWORD *)this + 31) = -1;
  long long v10 = (long long *)MEMORY[0x1E4F1FA08];
  long long v11 = *MEMORY[0x1E4F1FA08];
  *((void *)this + 145) = *(void *)(MEMORY[0x1E4F1FA08] + 16);
  *(_OWORD *)((char *)this + 1144) = v11;
  long long v12 = *v10;
  *((void *)this + 148) = *((void *)v10 + 2);
  *((_OWORD *)this + 73) = v12;
  *(_OWORD *)((char *)this + 248) = _Q0;
  *((void *)this + 33) = 0;
  *((void *)this + 34) = 0;
  *((_WORD *)this + 120) = 0;
  *((_WORD *)this + 6) = 0;
  *((_DWORD *)this + 298) = 16843009;
  *((unsigned char *)this + 176) = 1;
  *(void *)((char *)this + 180) = 0x100000000;
  *((unsigned char *)this + 216) = 0;
  *((unsigned char *)this + 242) = 0;
}

void OZShapeRenderParams::OZShapeRenderParams(OZShapeRenderParams *this, OZShapeRenderParams *a2, int a3)
{
  *(void *)this = &unk_1F11992D0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  PCWorkingColorVector::PCWorkingColorVector((OZShapeRenderParams *)((char *)this + 280));
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *((void *)this + 45) = 0;
  *((void *)this + 50) = 0;
  *((void *)this + 51) = 0xBFF0000000000000;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  uint64_t v6 = MEMORY[0x1E4F1FA48];
  *((void *)this + 48) = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  *((void *)this + 49) = 0;
  *((_OWORD *)this + 23) = *(_OWORD *)v6;
  *((void *)this + 68) = 0x3FF0000000000000;
  *((void *)this + 63) = 0x3FF0000000000000;
  *((void *)this + 58) = 0x3FF0000000000000;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 26) = xmmword_1B7E73BA0;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_DWORD *)this + 138) = 0x1000000;
  *((void *)this + 94) = 0;
  *((void *)this + 98) = 0;
  *((void *)this + 99) = 0;
  __asm { FMOV            V2.2D, #-1.0 }
  *((_OWORD *)this + 50) = _Q2;
  *(_OWORD *)((char *)this + 952) = 0u;
  *(_OWORD *)((char *)this + 968) = 0u;
  *(_OWORD *)((char *)this + 984) = 0u;
  *(_OWORD *)((char *)this + 1000) = 0u;
  *(_OWORD *)((char *)this + 1016) = 0u;
  *(_OWORD *)((char *)this + 1032) = 0u;
  *(_OWORD *)((char *)this + 1048) = 0u;
  *(_OWORD *)((char *)this + 1064) = 0u;
  *(_OWORD *)((char *)this + 1080) = 0u;
  *(_OWORD *)((char *)this + 1096) = 0u;
  *(_OWORD *)((char *)this + 1112) = 0u;
  *(_OWORD *)((char *)this + 1128) = 0u;
  *(_OWORD *)((char *)this + 760) = *(_OWORD *)v6;
  *((void *)this + 97) = *(void *)(v6 + 16);
  *((void *)this + 117) = 0x3FF0000000000000;
  *((void *)this + 112) = 0x3FF0000000000000;
  *((void *)this + 107) = 0x3FF0000000000000;
  *((void *)this + 102) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 824) = 0u;
  *(_OWORD *)((char *)this + 840) = 0u;
  *((_OWORD *)this + 54) = 0u;
  *((_OWORD *)this + 55) = 0u;
  *(_OWORD *)((char *)this + 904) = 0u;
  *(_OWORD *)((char *)this + 920) = 0u;
  *((_DWORD *)this + 236) = 0x1000000;
  long long v12 = (char *)this + 1200;
  *((void *)this + 165) = 0x3FF0000000000000;
  *((void *)this + 160) = 0x3FF0000000000000;
  *((void *)this + 155) = 0x3FF0000000000000;
  *((void *)this + 150) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1208) = 0u;
  *(_OWORD *)((char *)this + 1224) = 0u;
  *((_OWORD *)this + 78) = 0u;
  *((_OWORD *)this + 79) = 0u;
  *(_OWORD *)((char *)this + 1304) = 0u;
  *(_OWORD *)((char *)this + 1288) = 0u;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((void *)this + 2) = *((void *)a2 + 2);
  *((unsigned char *)this + 13) = *((unsigned char *)a2 + 13);
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)a2 + 72);
  *((void *)this + 11) = *((void *)a2 + 11);
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)a2 + 24);
  *((unsigned char *)this + 112) = *((unsigned char *)a2 + 112);
  *(void *)((char *)this + 116) = *(void *)((char *)a2 + 116);
  *((void *)this + 21) = *((void *)a2 + 21);
  *((_OWORD *)this + 14) = *((_OWORD *)a2 + 14);
  *((void *)this + 24) = *((void *)a2 + 24);
  *(_OWORD *)((char *)this + 200) = *(_OWORD *)((char *)a2 + 200);
  *((void *)this + 5) = *((void *)a2 + 5);
  *((void *)this + 6) = *((void *)a2 + 6);
  *((void *)this + 7) = *((void *)a2 + 7);
  *((void *)this + 8) = *((void *)a2 + 8);
  *((void *)this + 16) = *((void *)a2 + 16);
  *((void *)this + 17) = *((void *)a2 + 17);
  *((void *)this + 18) = *((void *)a2 + 18);
  *((void *)this + 19) = *((void *)a2 + 19);
  *((_DWORD *)this + 31) = *((_DWORD *)a2 + 31);
  *long long v13 = *(_OWORD *)((char *)a2 + 280);
  *(_WORD *)((char *)this + 1193) = *(_WORD *)((char *)a2 + 1193);
  long long v14 = *(_OWORD *)((char *)a2 + 1144);
  *((void *)this + 145) = *((void *)a2 + 145);
  *(_OWORD *)((char *)this + 1144) = v14;
  long long v15 = *((_OWORD *)a2 + 73);
  *((void *)this + 148) = *((void *)a2 + 148);
  *((_OWORD *)this + 73) = v15;
  *(_OWORD *)((char *)this + 248) = *(_OWORD *)((char *)a2 + 248);
  uint64_t v16 = *((void *)a2 + 34);
  *((void *)this + 33) = *((void *)a2 + 33);
  *((void *)this + 34) = v16;
  *((unsigned char *)this + 1192) = 1;
  *((unsigned char *)this + 241) = *((unsigned char *)a2 + 241);
  *((void *)this + 20) = *((void *)a2 + 20);
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
  *((unsigned char *)this + 12) = *((unsigned char *)a2 + 12);
  *((unsigned char *)this + 176) = *((unsigned char *)a2 + 176);
  *((unsigned char *)this + 240) = *((unsigned char *)a2 + 240);
  *(void *)((char *)this + 180) = *(void *)((char *)a2 + 180);
  *((unsigned char *)this + 216) = *((unsigned char *)a2 + 216);
  if (a2 != this)
  {
    uint64_t v17 = 0;
    float64x2_t v18 = (char *)a2 + 1200;
    do
    {
      for (uint64_t i = 0; i != 32; i += 8)
        *(void *)&v12[i] = *(void *)&v18[i];
      ++v17;
      v12 += 32;
      v18 += 32;
    }
    while (v17 != 4);
  }
  *((unsigned char *)this + 242) = *((unsigned char *)a2 + 242);
  if (a3)
  {
    OZShapeContour::operator=((uint64_t)this + 368, (long long *)a2 + 23);
    if (*((void *)a2 + 94)) {
      operator new();
    }
    OZShapeContour::operator=((uint64_t)this + 760, (long long *)((char *)a2 + 760));
  }
}

void sub_1B7E39470(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v5, 0x10A0C401050895ELL);
  OZShapeContour::~OZShapeContour(v3);
  std::unique_ptr<OZShapeReparametrizedContour>::reset[abi:ne180100](v4, 0);
  OZShapeContour::~OZShapeContour(v2);
  long long v8 = (void *)v1[43];
  if (v8)
  {
    v1[44] = v8;
    operator delete(v8);
  }
  uint64_t v9 = (void *)v1[40];
  if (v9)
  {
    v1[41] = v9;
    operator delete(v9);
  }
  long long v10 = *v6;
  if (*v6)
  {
    v1[38] = v10;
    operator delete(v10);
  }
  _Unwind_Resume(a1);
}

void OZShapeContour::operator=(uint64_t a1, long long *a2)
{
  *(_WORD *)(a1 + 185) = *(_WORD *)((char *)a2 + 185);
  *(unsigned char *)(a1 + 187) = *((unsigned char *)a2 + 187);
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  long long v5 = *(long long *)((char *)a2 + 24);
  *(_OWORD *)(a1 + 40) = *(long long *)((char *)a2 + 40);
  *(_OWORD *)(a1 + 24) = v5;
  if (a2 == (long long *)a1)
  {
    *(unsigned char *)(a1 + 184) = *((unsigned char *)a2 + 184);
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v7 = (uint64_t)a2 + 56;
    uint64_t v8 = a1 + 56;
    do
    {
      for (uint64_t i = 0; i != 32; i += 8)
        *(void *)(v8 + i) = *(void *)(v7 + i);
      ++v6;
      v8 += 32;
      v7 += 32;
    }
    while (v6 != 4);
    *(unsigned char *)(a1 + 184) = *((unsigned char *)a2 + 184);
    if (a2 != (long long *)a1)
    {
      std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a1 + 192), *((char **)a2 + 24), *((void *)a2 + 25), (uint64_t)(*((void *)a2 + 25) - *((void *)a2 + 24)) >> 3);
      std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a1 + 216), *((char **)a2 + 27), *((void *)a2 + 28), (uint64_t)(*((void *)a2 + 28) - *((void *)a2 + 27)) >> 3);
      std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a1 + 240), *((char **)a2 + 30), *((void *)a2 + 31), (uint64_t)(*((void *)a2 + 31) - *((void *)a2 + 30)) >> 3);
      std::vector<PCVector2<double>>::__assign_with_size[abi:ne180100]<PCVector2<double>*,PCVector2<double>*>((void *)(a1 + 264), *((long long **)a2 + 33), *((long long **)a2 + 34), (uint64_t)(*((void *)a2 + 34) - *((void *)a2 + 33)) >> 4);
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)(a1 + 288), *((void *)a2 + 36), *((void *)a2 + 37), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((void *)a2 + 37) - *((void *)a2 + 36)) >> 3));
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)(a1 + 312), *((void *)a2 + 39), *((void *)a2 + 40), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((void *)a2 + 40) - *((void *)a2 + 39)) >> 3));
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)(a1 + 336), *((void *)a2 + 42), *((void *)a2 + 43), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((void *)a2 + 43) - *((void *)a2 + 42)) >> 3));
      uint64_t v10 = *((void *)a2 + 45);
      uint64_t v11 = *((void *)a2 + 46);
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)(a1 + 360), v10, v11, 0xF0F0F0F0F0F0F0F1 * ((v11 - v10) >> 3));
    }
  }
}

void OZShapeRenderParams::assign(OZShapeRenderParams *this, OZShapeRenderParams *a2, int a3)
{
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((void *)this + 2) = *((void *)a2 + 2);
  *((unsigned char *)this + 13) = *((unsigned char *)a2 + 13);
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)a2 + 72);
  *((void *)this + 11) = *((void *)a2 + 11);
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)a2 + 24);
  *((unsigned char *)this + 112) = *((unsigned char *)a2 + 112);
  *(void *)((char *)this + 116) = *(void *)((char *)a2 + 116);
  *((void *)this + 21) = *((void *)a2 + 21);
  *((_OWORD *)this + 14) = *((_OWORD *)a2 + 14);
  *((void *)this + 24) = *((void *)a2 + 24);
  *(_OWORD *)((char *)this + 200) = *(_OWORD *)((char *)a2 + 200);
  *((void *)this + 5) = *((void *)a2 + 5);
  *((void *)this + 6) = *((void *)a2 + 6);
  *((void *)this + 7) = *((void *)a2 + 7);
  *((void *)this + 8) = *((void *)a2 + 8);
  *((void *)this + 16) = *((void *)a2 + 16);
  *((void *)this + 17) = *((void *)a2 + 17);
  *((void *)this + 18) = *((void *)a2 + 18);
  *((void *)this + 19) = *((void *)a2 + 19);
  *((_DWORD *)this + 31) = *((_DWORD *)a2 + 31);
  *(_OWORD *)((char *)this + 280) = *(_OWORD *)((char *)a2 + 280);
  *(_WORD *)((char *)this + 1193) = *(_WORD *)((char *)a2 + 1193);
  long long v5 = *(_OWORD *)((char *)a2 + 1144);
  *((void *)this + 145) = *((void *)a2 + 145);
  *(_OWORD *)((char *)this + 1144) = v5;
  long long v6 = *((_OWORD *)a2 + 73);
  *((void *)this + 148) = *((void *)a2 + 148);
  *((_OWORD *)this + 73) = v6;
  *(_OWORD *)((char *)this + 248) = *(_OWORD *)((char *)a2 + 248);
  uint64_t v7 = *((void *)a2 + 34);
  *((void *)this + 33) = *((void *)a2 + 33);
  *((void *)this + 34) = v7;
  *((unsigned char *)this + 1192) = *((unsigned char *)a2 + 1192);
  *((unsigned char *)this + 241) = *((unsigned char *)a2 + 241);
  *((void *)this + 20) = *((void *)a2 + 20);
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
  *((unsigned char *)this + 12) = *((unsigned char *)a2 + 12);
  *((unsigned char *)this + 1195) = *((unsigned char *)a2 + 1195);
  *((unsigned char *)this + 176) = *((unsigned char *)a2 + 176);
  *((unsigned char *)this + 240) = *((unsigned char *)a2 + 240);
  *(void *)((char *)this + 180) = *(void *)((char *)a2 + 180);
  *((unsigned char *)this + 216) = *((unsigned char *)a2 + 216);
  if (a2 != this)
  {
    uint64_t v8 = 0;
    uint64_t v9 = (char *)a2 + 1200;
    uint64_t v10 = (char *)this + 1200;
    do
    {
      for (uint64_t i = 0; i != 32; i += 8)
        *(void *)&v10[i] = *(void *)&v9[i];
      ++v8;
      v10 += 32;
      v9 += 32;
    }
    while (v8 != 4);
  }
  *((unsigned char *)this + 242) = *((unsigned char *)a2 + 242);
  if (a3)
  {
    OZShapeContour::operator=((uint64_t)this + 368, (long long *)a2 + 23);
    if (*((void *)a2 + 94)) {
      operator new();
    }
    OZShapeContour::operator=((uint64_t)this + 760, (long long *)((char *)a2 + 760));
  }
}

void sub_1B7E398AC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A0C401050895ELL);
  _Unwind_Resume(a1);
}

void OZShapeRenderParams::~OZShapeRenderParams(OZShapeReparametrizedContour **this)
{
  *this = (OZShapeReparametrizedContour *)&unk_1F11992D0;
  OZShapeContour::~OZShapeContour((OZShapeContour *)(this + 95));
  std::unique_ptr<OZShapeReparametrizedContour>::reset[abi:ne180100](this + 94, 0);
  OZShapeContour::~OZShapeContour((OZShapeContour *)(this + 46));
  uint64_t v2 = this[43];
  if (v2)
  {
    this[44] = v2;
    operator delete(v2);
  }
  double v3 = this[40];
  if (v3)
  {
    this[41] = v3;
    operator delete(v3);
  }
  long long v4 = this[37];
  if (v4)
  {
    this[38] = v4;
    operator delete(v4);
  }
}

{
  uint64_t vars8;

  OZShapeRenderParams::~OZShapeRenderParams(this);

  JUMPOUT(0x1BA9BFBA0);
}

void OZShapeRenderParams::operator=(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(unsigned char *)(a1 + 13) = *(unsigned char *)(a2 + 13);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(unsigned char *)(a1 + 112) = *(unsigned char *)(a2 + 112);
  *(void *)(a1 + 116) = *(void *)(a2 + 116);
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 200);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(void *)(a1 + 160) = *(void *)(a2 + 160);
  *(_OWORD *)(a1 + 280) = *(_OWORD *)(a2 + 280);
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(a2 + 124);
  *(void *)(a1 + 180) = *(void *)(a2 + 180);
  *(unsigned char *)(a1 + 216) = *(unsigned char *)(a2 + 216);
  *(_WORD *)(a1 + 1193) = *(_WORD *)(a2 + 1193);
  long long v4 = *(_OWORD *)(a2 + 1144);
  *(void *)(a1 + 1160) = *(void *)(a2 + 1160);
  *(_OWORD *)(a1 + 1144) = v4;
  long long v5 = *(_OWORD *)(a2 + 1168);
  *(void *)(a1 + 1184) = *(void *)(a2 + 1184);
  *(_OWORD *)(a1 + 1168) = v5;
  *(_OWORD *)(a1 + 248) = *(_OWORD *)(a2 + 248);
  uint64_t v6 = *(void *)(a2 + 272);
  *(void *)(a1 + 264) = *(void *)(a2 + 264);
  *(void *)(a1 + 272) = v6;
  *(unsigned char *)(a1 + 1192) = *(unsigned char *)(a2 + 1192);
  *(unsigned char *)(a1 + 1195) = *(unsigned char *)(a2 + 1195);
  *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
  *(_WORD *)(a1 + 240) = *(_WORD *)(a2 + 240);
  uint64_t v7 = *(void *)(a2 + 104);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a1 + 104) = v7;
  *(unsigned char *)(a1 + 12) = *(unsigned char *)(a2 + 12);
  if (a2 != a1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a2 + 1200;
    uint64_t v10 = a1 + 1200;
    do
    {
      for (uint64_t i = 0; i != 32; i += 8)
        *(void *)(v10 + i) = *(void *)(v9 + i);
      ++v8;
      v10 += 32;
      v9 += 32;
    }
    while (v8 != 4);
  }
  OZShapeContour::operator=(a1 + 368, (long long *)(a2 + 368));
  *(unsigned char *)(a1 + 242) = *(unsigned char *)(a2 + 242);
  if (*(void *)(a2 + 752)) {
    operator new();
  }
  OZShapeContour::operator=(a1 + 760, (long long *)(a2 + 760));
  if (a2 != a1)
  {
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a1 + 296), *(char **)(a2 + 296), *(void *)(a2 + 304), (uint64_t)(*(void *)(a2 + 304) - *(void *)(a2 + 296)) >> 3);
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a1 + 320), *(char **)(a2 + 320), *(void *)(a2 + 328), (uint64_t)(*(void *)(a2 + 328) - *(void *)(a2 + 320)) >> 3);
    long long v12 = *(char **)(a2 + 344);
    uint64_t v13 = *(void *)(a2 + 352);
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a1 + 344), v12, v13, (v13 - (uint64_t)v12) >> 3);
  }
}

void sub_1B7E39C04(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A0C401050895ELL);
  _Unwind_Resume(a1);
}

void std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>(char **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  uint64_t v8 = (uint64_t)a1[2];
  uint64_t v9 = *a1;
  if (0xF0F0F0F0F0F0F0F1 * ((v8 - (uint64_t)v9) >> 3) < a4)
  {
    if (v9)
    {
      a1[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0x1E1E1E1E1E1E1E1) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xF0F0F0F0F0F0F0F1 * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0xF0F0F0F0F0F0F0) {
      unint64_t v12 = 0x1E1E1E1E1E1E1E1;
    }
    else {
      unint64_t v12 = v11;
    }
    std::vector<OZShapeEdgePolygon>::__vallocate[abi:ne180100](a1, v12);
    uint64_t v13 = (uint64_t)a1;
    uint64_t v14 = v6;
    a3 = v5;
LABEL_21:
    std::vector<OZShapeEdgePolygon>::__construct_at_end<OZShapeEdgePolygon*,OZShapeEdgePolygon*>(v13, v14, a3);
    return;
  }
  long long v15 = a1[1];
  if (0xF0F0F0F0F0F0F0F1 * ((v15 - v9) >> 3) < a4)
  {
    uint64_t v14 = a2 + 8 * ((v15 - v9) >> 3);
    if (v15 != v9)
    {
      uint64_t v16 = 8 * ((v15 - v9) >> 3);
      do
      {
        *(_OWORD *)uint64_t v9 = *(_OWORD *)v6;
        long long v17 = *(_OWORD *)(v6 + 16);
        long long v18 = *(_OWORD *)(v6 + 32);
        long long v19 = *(_OWORD *)(v6 + 64);
        *((_OWORD *)v9 + 3) = *(_OWORD *)(v6 + 48);
        *((_OWORD *)v9 + 4) = v19;
        *((_OWORD *)v9 + 1) = v17;
        *((_OWORD *)v9 + 2) = v18;
        long long v20 = *(_OWORD *)(v6 + 80);
        long long v21 = *(_OWORD *)(v6 + 96);
        long long v22 = *(_OWORD *)(v6 + 112);
        *((void *)v9 + 16) = *(void *)(v6 + 128);
        *((_OWORD *)v9 + 6) = v21;
        *((_OWORD *)v9 + 7) = v22;
        *((_OWORD *)v9 + 5) = v20;
        v6 += 136;
        v9 += 136;
        v16 -= 136;
      }
      while (v16);
    }
    uint64_t v13 = (uint64_t)a1;
    goto LABEL_21;
  }
  if (a2 == a3)
  {
    long long v23 = v9;
  }
  else
  {
    long long v23 = v9;
    do
    {
      *(_OWORD *)uint64_t v9 = *(_OWORD *)v6;
      long long v24 = *(_OWORD *)(v6 + 16);
      long long v25 = *(_OWORD *)(v6 + 32);
      long long v26 = *(_OWORD *)(v6 + 64);
      *((_OWORD *)v9 + 3) = *(_OWORD *)(v6 + 48);
      *((_OWORD *)v9 + 4) = v26;
      *((_OWORD *)v9 + 1) = v24;
      *((_OWORD *)v9 + 2) = v25;
      long long v27 = *(_OWORD *)(v6 + 80);
      long long v28 = *(_OWORD *)(v6 + 96);
      long long v29 = *(_OWORD *)(v6 + 112);
      *((void *)v9 + 16) = *(void *)(v6 + 128);
      *((_OWORD *)v9 + 6) = v28;
      *((_OWORD *)v9 + 7) = v29;
      *((_OWORD *)v9 + 5) = v27;
      v6 += 136;
      v9 += 136;
      long long v23 = (_OWORD *)((char *)v23 + 136);
    }
    while (v6 != a3);
  }
  a1[1] = (char *)v23;
}

void std::vector<OZShapeEdgePolygon>::__construct_at_end<OZShapeEdgePolygon*,OZShapeEdgePolygon*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(a1 + 16, v4 + v7, a2 + v7);
      v7 += 136;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  *(void *)(a1 + 8) = v4;
}

void sub_1B7E39E7C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

char *std::vector<OZShapeEdgePolygon>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x1E1E1E1E1E1E1E2) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LightingStyleLight>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[136 * v4];
  return result;
}

OZShapeReparametrizedContour *std::unique_ptr<OZShapeReparametrizedContour>::reset[abi:ne180100](OZShapeReparametrizedContour **a1, OZShapeReparametrizedContour *a2)
{
  __n128 result = *a1;
  *a1 = a2;
  if (result)
  {
    OZShapeReparametrizedContour::~OZShapeReparametrizedContour(result);
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

void OZShapeReparametrizedContour::OZShapeReparametrizedContour(OZShapeReparametrizedContour *this, const OZShapeReparametrizedContour *a2)
{
  OZShapeContour::OZShapeContour(this, a2);
  uint64_t v5 = (char *)(v4 + 400);
  uint64_t v6 = (char *)(v4 + 424);
  uint64_t v7 = (char *)(v4 + 448);
  *(void *)(v4 + 464) = 0;
  *(_OWORD *)(v4 + 432) = 0u;
  *(_OWORD *)(v4 + 448) = 0u;
  *(_OWORD *)(v4 + 400) = 0u;
  *(_OWORD *)(v4 + 416) = 0u;
  uint64_t v8 = *((void *)a2 + 48);
  if (v8)
  {
    uint64_t v9 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 248))(v8);
    if (v9) {
    *((void *)this + 48) = v9;
    }
  }
  *((void *)this + 49) = *((void *)a2 + 49);
  if (this != a2)
  {
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v5, *((char **)a2 + 50), *((void *)a2 + 51), (uint64_t)(*((void *)a2 + 51) - *((void *)a2 + 50)) >> 3);
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v6, *((char **)a2 + 53), *((void *)a2 + 54), (uint64_t)(*((void *)a2 + 54) - *((void *)a2 + 53)) >> 3);
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v7, *((char **)a2 + 56), *((void *)a2 + 57), (uint64_t)(*((void *)a2 + 57) - *((void *)a2 + 56)) >> 3);
  }
}

void sub_1B7E3A040(_Unwind_Exception *a1)
{
  uint64_t v6 = *v4;
  if (*v4)
  {
    *((void *)v1 + 57) = v6;
    operator delete(v6);
  }
  OZShapeReparametrizedContour::OZShapeReparametrizedContour(v3, v2, (uint64_t)v1);
  OZShapeContour::~OZShapeContour(v1);
  _Unwind_Resume(a1);
}

void OZShapeContour::OZShapeContour(OZShapeContour *this, const OZShapeContour *a2)
{
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)((char *)this + 40) = _Q0;
  *((void *)this + 7) = 0x3FF0000000000000;
  uint64_t v9 = (char *)this + 56;
  *((void *)this + 22) = 0x3FF0000000000000;
  *((void *)this + 17) = 0x3FF0000000000000;
  *((void *)this + 12) = 0x3FF0000000000000;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 15) = 0u;
  unint64_t v10 = (char *)this + 240;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *(_WORD *)((char *)this + 185) = *(_WORD *)((char *)a2 + 185);
  *((unsigned char *)this + 187) = *((unsigned char *)a2 + 187);
  long long v11 = *(_OWORD *)a2;
  *((void *)this + 2) = *((void *)a2 + 2);
  *(_OWORD *)this = v11;
  long long v12 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 40) = *(_OWORD *)((char *)a2 + 40);
  *(_OWORD *)((char *)this + 24) = v12;
  if (a2 == this)
  {
    *((unsigned char *)this + 184) = *((unsigned char *)a2 + 184);
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v16 = (char *)this + 216;
    uint64_t v14 = (char *)a2 + 56;
    do
    {
      for (uint64_t i = 0; i != 32; i += 8)
        *(void *)&v9[i] = *(void *)&v14[i];
      ++v13;
      v9 += 32;
      v14 += 32;
    }
    while (v13 != 4);
    *((unsigned char *)this + 184) = *((unsigned char *)a2 + 184);
    if (a2 != this)
    {
      std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)this + 192, *((char **)a2 + 24), *((void *)a2 + 25), (uint64_t)(*((void *)a2 + 25) - *((void *)a2 + 24)) >> 3);
      std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v16, *((char **)a2 + 27), *((void *)a2 + 28), (uint64_t)(*((void *)a2 + 28) - *((void *)a2 + 27)) >> 3);
      std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v10, *((char **)a2 + 30), *((void *)a2 + 31), (uint64_t)(*((void *)a2 + 31) - *((void *)a2 + 30)) >> 3);
      std::vector<PCVector2<double>>::__assign_with_size[abi:ne180100]<PCVector2<double>*,PCVector2<double>*>((void *)this + 33, *((long long **)a2 + 33), *((long long **)a2 + 34), (uint64_t)(*((void *)a2 + 34) - *((void *)a2 + 33)) >> 4);
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)this + 36, *((void *)a2 + 36), *((void *)a2 + 37), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((void *)a2 + 37) - *((void *)a2 + 36)) >> 3));
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)this + 39, *((void *)a2 + 39), *((void *)a2 + 40), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((void *)a2 + 40) - *((void *)a2 + 39)) >> 3));
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)this + 42, *((void *)a2 + 42), *((void *)a2 + 43), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((void *)a2 + 43) - *((void *)a2 + 42)) >> 3));
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)this + 45, *((void *)a2 + 45), *((void *)a2 + 46), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((void *)a2 + 46) - *((void *)a2 + 45)) >> 3));
    }
  }
}

void sub_1B7E3A27C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  long long v19 = *v17;
  if (*v17)
  {
    v10[46] = v19;
    operator delete(v19);
  }
  long long v20 = *v16;
  if (*v16)
  {
    v10[43] = v20;
    operator delete(v20);
  }
  long long v21 = *v15;
  if (*v15)
  {
    v10[40] = v21;
    operator delete(v21);
  }
  long long v22 = *v14;
  if (*v14)
  {
    v10[37] = v22;
    operator delete(v22);
  }
  long long v23 = *v13;
  if (*v13)
  {
    v10[34] = v23;
    operator delete(v23);
  }
  long long v24 = *v12;
  if (*v12)
  {
    v10[31] = v24;
    operator delete(v24);
  }
  long long v25 = *a10;
  if (*a10)
  {
    v10[28] = v25;
    operator delete(v25);
  }
  long long v26 = *v11;
  if (*v11)
  {
    v10[25] = v26;
    operator delete(v26);
  }
  _Unwind_Resume(exception_object);
}

void OZShapeReparametrizedContour::OZShapeReparametrizedContour(void **a1, void **a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  if (v5)
  {
    *(void *)(a3 + 432) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *a2;
  if (*a2)
  {
    *(void *)(a3 + 408) = v6;
    operator delete(v6);
  }
}

void heShapeTesselationCallback(double *a1, double **a2, float *a3, double **a4, void **a5)
{
  unint64_t v10 = (double *)malloc_type_malloc(0x30uLL, 0x100004000313F17uLL);
  double *v10 = *a1;
  v10[1] = a1[1];
  v10[2] = a1[2];
  double v11 = *a3;
  uint64_t v12 = (uint64_t)*a2;
  uint64_t v13 = a2[1];
  double v14 = a3[1];
  v10[3] = **a2 * v11 + *v13 * v14;
  v10[4] = *(double *)(v12 + 8) * v11 + v13[1] * v14;
  v10[5] = *(double *)(v12 + 16) * v11 + v13[2] * v14;
  unint64_t v15 = (unint64_t)a5[2];
  uint64_t v16 = (double **)a5[1];
  if ((unint64_t)v16 >= v15)
  {
    uint64_t v18 = ((char *)v16 - (unsigned char *)*a5) >> 3;
    if ((unint64_t)(v18 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v19 = v15 - (void)*a5;
    uint64_t v20 = v19 >> 2;
    if (v19 >> 2 <= (unint64_t)(v18 + 1)) {
      uint64_t v20 = v18 + 1;
    }
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v21 = v20;
    }
    if (v21) {
      long long v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a5 + 2), v21);
    }
    else {
      long long v22 = 0;
    }
    long long v23 = (double **)&v22[8 * v18];
    long long v24 = &v22[8 * v21];
    *long long v23 = v10;
    long long v17 = v23 + 1;
    long long v26 = (char *)*a5;
    long long v25 = (char *)a5[1];
    if (v25 != *a5)
    {
      do
      {
        long long v27 = (double *)*((void *)v25 - 1);
        v25 -= 8;
        *--long long v23 = v27;
      }
      while (v25 != v26);
      long long v25 = (char *)*a5;
    }
    *a5 = v23;
    a5[1] = v17;
    a5[2] = v24;
    if (v25) {
      operator delete(v25);
    }
  }
  else
  {
    char *v16 = v10;
    long long v17 = v16 + 1;
  }
  a5[1] = v17;
  *a4 = v10;
}

void heShapeTesselationEndCallback(uint64_t *a1)
{
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    unint64_t v3 = 0;
    unsigned int v4 = 1;
    uint64_t v2 = *a1;
    do
    {
      free(*(void **)(v2 + 8 * v3));
      unint64_t v3 = v4;
      uint64_t v2 = *a1;
      ++v4;
    }
    while (v3 < (a1[1] - *a1) >> 3);
  }
  a1[1] = v2;
  uint64_t v5 = a1[19];
  if (v5)
  {
    uint64_t v6 = *(void *)(v5 + 24);
    if (v6) {
      int v7 = *(_DWORD *)(v6 + 8);
    }
    else {
      int v7 = 0;
    }
    unint64_t v8 = *(void *)(v5 + 16);
    uint64_t v9 = *(_DWORD **)(v5 + 8);
    if ((unint64_t)v9 >= v8)
    {
      double v11 = *(_DWORD **)v5;
      unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - *(void *)v5) >> 2);
      unint64_t v13 = v12 + 1;
      if (v12 + 1 > 0x1555555555555555) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - (void)v11) >> 2);
      if (2 * v14 > v13) {
        unint64_t v13 = 2 * v14;
      }
      if (v14 >= 0xAAAAAAAAAAAAAAALL) {
        unint64_t v15 = 0x1555555555555555;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Vec3f>>(v5 + 16, v15);
        double v11 = *(_DWORD **)v5;
        uint64_t v9 = *(_DWORD **)(v5 + 8);
      }
      else
      {
        uint64_t v16 = 0;
      }
      long long v17 = &v16[12 * v12];
      uint64_t v18 = &v16[12 * v15];
      *(void *)long long v17 = 4;
      *((_DWORD *)v17 + 2) = v7;
      unint64_t v10 = v17 + 12;
      if (v9 != v11)
      {
        do
        {
          uint64_t v19 = *(void *)(v9 - 3);
          v9 -= 3;
          int v20 = v9[2];
          *(void *)(v17 - 12) = v19;
          v17 -= 12;
          *((_DWORD *)v17 + 2) = v20;
        }
        while (v9 != v11);
        double v11 = *(_DWORD **)v5;
      }
      *(void *)uint64_t v5 = v17;
      *(void *)(v5 + 8) = v10;
      *(void *)(v5 + 16) = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *(void *)uint64_t v9 = 4;
      _OWORD v9[2] = v7;
      unint64_t v10 = (char *)(v9 + 3);
    }
    *(void *)(v5 + 8) = v10;
  }
}

double heVertexCallback(float64x2_t *a1, double *a2)
{
  if (*((void *)a2 + 19))
  {
    *(float32x2_t *)&long long v6 = vcvt_f32_f64(*a1);
    *((void *)&v6 + 1) = 0x3F80000000000000;
    PCMatrix44Tmpl<double>::transform<float>(a2 + 3, (float *)&v6, (uint64_t)&v6);
    long long v5 = v6;
    *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(*((void *)a2 + 19) + 24)) = v5;
    unint64_t v3 = (_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(*((void *)a2 + 19) + 40));
    double result = 1.92414562e12;
    _OWORD *v3 = xmmword_1B83887C0;
  }
  return result;
}

uint64_t OZShape::calcHashForState(OZShape *this, PCSerializerWriteStream *a2, const CMTime *a3)
{
  OZChannelCurve::calcHashForState((OZShape *)((char *)this + 208), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 1072), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 1328), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 1480), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 1632), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 14752), a2, a3);
  unint64_t isEnabled = OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 2784), 0, 1);
  (*(void (**)(PCSerializerWriteStream *, unint64_t))(*(void *)a2 + 48))(a2, isEnabled);
  if (OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 2784), 0, 1))
  {
    OZChannelFolder::calcHashForState((OZChannelFolder *)((char *)this + 2784), a2, a3);
    OZChannel::calcHashForState((OZChannel *)((char *)this + 2912), a2, a3);
    if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 2912), MEMORY[0x1E4F1FA48], 0.0))
    {
      OZChannelFolder::calcHashForState((OZChannelFolder *)((char *)this + 4328), a2, a3);
    }
    else
    {
      OZChannelFolder::calcHashForState((OZChannelFolder *)((char *)this + 3168), a2, a3);
      OZChannel::calcHashForState((OZChannel *)((char *)this + 4176), a2, a3);
    }
  }
  unint64_t v7 = OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 6800), 0, 1);
  (*(void (**)(PCSerializerWriteStream *, unint64_t))(*(void *)a2 + 48))(a2, v7);
  if (OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 6800), 0, 1)) {
    OZChannelFolder::calcHashForState((OZChannelFolder *)((char *)this + 6800), a2, a3);
  }
  OZChannel::calcHashForState((OZChannel *)((char *)this + 11512), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 11664), a2, a3);
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 12856), MEMORY[0x1E4F1FA48], 0.0))
  {
    OZChannel::calcHashForState((OZChannel *)((char *)this + 13008), a2, a3);
    OZChannel::calcHashForState((OZChannel *)((char *)this + 13264), a2, a3);
  }
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 1072), MEMORY[0x1E4F1FA48], 0.0) == 4)
  {
    OZChannel::calcHashForState((OZChannel *)((char *)this + 12072), a2, a3);
    OZChannelFolder::calcHashForState((OZChannelFolder *)((char *)this + 12224), a2, a3);
  }
  uint64_t result = OZChannel::getValueAsInt((OZChannel *)((char *)this + 1072), MEMORY[0x1E4F1FA48], 0.0);
  if (result == 5)
  {
    return OZChannelFolder::calcHashForState((OZChannelFolder *)((char *)this + 12224), a2, a3);
  }
  return result;
}

double OZShape::getBorderSize(uint64_t a1, uint64_t a2, void *a3, double *a4)
{
  long long v14 = *(_OWORD *)(a2 + 16);
  unint64_t v8 = *(CGColorSpace **)(a2 + 80);
  unint64_t v15 = v8;
  if (v8) {
    PCCFRefTraits<CGColorSpace *>::retain(v8);
  }
  int v16 = *(_DWORD *)(a2 + 88);
  uint64_t v9 = 2664;
  if (!BYTE8(v14)) {
    uint64_t v9 = 2672;
  }
  uint64_t v10 = *(void *)(a1 + v9);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v15);
  int v11 = *(_DWORD *)(v10 + 8);
  if (v11 && *(double *)(v10 + 16) > 2.0
    || (double v12 = *(double *)(v10 + 224), v12 > 0.0) && *(_DWORD *)(v10 + 120)
    || v12 < 0.0 && *(_DWORD *)(v10 + 120))
  {
    if (a3) {
      *a3 = 0;
    }
    double result = 0.0;
    if (a4) {
LABEL_14:
    }
      *a4 = result;
  }
  else
  {
    double result = fabs(v12);
    if (result < 0.0000001 && *(_DWORD *)(v10 + 120) || v11 && (double result = *(double *)(v10 + 16), result <= 2.0))
    {
      if (a3) {
        *a3 = 0x4000000000000000;
      }
      double result = 2.0;
      if (a4) {
        goto LABEL_14;
      }
    }
  }
  return result;
}

uint64_t OZShape::getCurrentRenderParams(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 2664;
  if (!*(unsigned char *)(a2 + 24)) {
    uint64_t v2 = 2672;
  }
  return *(void *)(a1 + v2);
}

void OZShape::getShapeBounds(uint64_t a1, float64x2_t *a2, double *a3, uint64_t a4)
{
  (*(void (**)(uint64_t, double *, uint64_t, void, uint64_t))(*(void *)a1 + 64))(a1, a3, a4, 0, 1);
  uint64_t Contour = OZShape::getContour((OZShape *)a1, (const OZShapeRenderState *)a3, (OZShapeRenderParams *)a4);
  float64x2_t v9 = *(float64x2_t *)(Contour + 40);
  *a2 = *(float64x2_t *)(Contour + 24);
  a2[1] = v9;
  if (a2[1].f64[0] < 0.0 || a2[1].f64[1] < 0.0) {
    return;
  }
  int v10 = *(_DWORD *)(a4 + 8);
  if (!v10 || (double v11 = *(double *)(a4 + 16), v11 <= 2.0))
  {
    double v23 = *(double *)(a4 + 224);
    if (v23 > 0.0 && *(_DWORD *)(a4 + 120))
    {
      float v24 = v23;
      long long v25 = (const CMTime *)MEMORY[0x1E4F1FA48];
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 13416), MEMORY[0x1E4F1FA48], 0.0);
      double v27 = v26;
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 13568), v25, 0.0);
      float v29 = v24;
      if (v27 != 0.0) {
        float v29 = v24 / fabs(v27);
      }
      if (v28 != 0.0) {
        float v24 = v24 / fabs(v28);
      }
      double v30 = v29;
      double v31 = v24;
    }
    else
    {
      if (v23 < 0.0 && *(_DWORD *)(a4 + 120)
        || (fabs(v23) >= 0.0000001 || !*(_DWORD *)(a4 + 120)) && (!v10 || *(double *)(a4 + 16) > 2.0))
      {
        return;
      }
      float v32 = 2.0 / a3[4];
      double v33 = *(double *)(a4 + 248);
      if (v33 != 0.0) {
        float v32 = v32 / fabs(v33);
      }
      float v34 = 2.0 / a3[5];
      double v35 = *(double *)(a4 + 256);
      if (v35 != 0.0) {
        float v34 = v34 / fabs(v35);
      }
      if (v23 <= 0.0 && *(_DWORD *)(a4 + 120))
      {
        uint64_t v36 = (const CMTime *)MEMORY[0x1E4F1FA48];
        OZChannel::getValueAsDouble((OZChannel *)(a1 + 13416), MEMORY[0x1E4F1FA48], 0.0);
        double v38 = v37;
        OZChannel::getValueAsDouble((OZChannel *)(a1 + 13568), v36, 0.0);
        if (v38 != 0.0) {
          float v32 = v32 / fabs(v38);
        }
        if (v39 != 0.0) {
          float v34 = v34 / fabs(v39);
        }
      }
      double v30 = v32;
      double v31 = v34;
    }
    float64_t v40 = a2->f64[1] - v31;
    a2->f64[0] = a2->f64[0] - v30;
    a2->f64[1] = v40;
    float64_t v41 = a2[1].f64[1] - (-v31 - v31);
    a2[1].f64[0] = a2[1].f64[0] - (-v30 - v30);
    a2[1].f64[1] = v41;
    return;
  }
  float v12 = v11 * 0.5;
  if (*(_DWORD *)(a4 + 28) == 3 || *(_DWORD *)(a4 + 32) == 3)
  {
    __asm { FMOV            V1.2D, #0.5 }
    float64x2_t v18 = vmulq_f64(vmulq_n_f64(*(float64x2_t *)(a4 + 96), v11), _Q1);
    if (v18.f64[1] >= v18.f64[0]) {
      v18.f64[0] = v18.f64[1];
    }
    float v12 = v18.f64[0] + v12;
  }
  if (*(unsigned char *)(a4 + 13))
  {
    double v51 = 1.0;
    double v53 = 1.0;
    (*(void (**)(uint64_t, double *, double *, double *))(*(void *)a1 + 368))(a1, &v51, &v53, a3);
    double v19 = fabs(v51);
    float v20 = 0.0;
    float v21 = 0.0;
    if (v19 >= 0.0000001) {
      float v21 = v12 / v19;
    }
    double v22 = fabs(v53);
    if (v22 >= 0.0000001) {
      float v20 = v12 / v22;
    }
    float v12 = v20;
  }
  else
  {
    float v21 = v12;
  }
  v42.f64[0] = v21 / (*(double (**)(uint64_t))(*(void *)a1 + 176))(a1);
  float64_t v43 = a2->f64[1] - v12;
  a2->f64[0] = a2->f64[0] - v42.f64[0];
  a2->f64[1] = v43;
  v42.f64[1] = v12;
  a2[1] = vsubq_f64(a2[1], vsubq_f64(vnegq_f64(v42), v42));
  int v44 = *(_DWORD *)(a4 + 24);
  if (!v44
    || (int v45 = *(_DWORD *)(a4 + 28)) == 0
    || (int v46 = *(_DWORD *)(a4 + 32), v46 == 2)
    || v45 == 2
    || v44 == 2
    || !v46)
  {
    if (v21 >= v12) {
      float v12 = v21;
    }
    double v53 = 0.0;
    OZChannelCurve::getVerticesList((OZChannelCurve *)(a1 + 208), (char **)&v51);
    unint64_t v47 = v52;
    if (v52 != *(char **)&v51)
    {
      uint64_t v48 = 0;
      double v49 = v12;
      unsigned int v50 = 1;
      unint64_t v47 = *(char **)&v51;
      do
      {
        OZChannelCurve::getVertexParametricValue(a1 + 208, *(char **)&v47[16 * v48], *(void *)&v47[16 * v48 + 8], (CMTime *)a3, &v53);
        OZShape::calcIntersectionForOutlineAtPoint(a1, (CMTime *)a3, (_DWORD *)a4, a2, v53, v49);
        uint64_t v48 = v50;
        unint64_t v47 = *(char **)&v51;
        ++v50;
      }
      while (v48 != (uint64_t)&v52[-*(void *)&v51] >> 4);
    }
    if (v47)
    {
      double v52 = v47;
      operator delete(v47);
    }
  }
}

void sub_1B7E3AFD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void OZShape::calculateBounds(OZShape *this, const OZShapeRenderState *a2)
{
  long long v4 = *((_OWORD *)a2 + 3);
  long long v21 = *((_OWORD *)a2 + 2);
  long long v22 = v4;
  long long v23 = *((_OWORD *)a2 + 4);
  long long v5 = *((_OWORD *)a2 + 1);
  v19[1] = *(float64x2_t *)a2;
  long long v20 = v5;
  long long v6 = (CGColorSpace *)*((void *)a2 + 10);
  float v24 = v6;
  if (v6) {
    PCCFRefTraits<CGColorSpace *>::retain(v6);
  }
  int v25 = *((_DWORD *)a2 + 22);
  uint64_t v7 = 2664;
  if (!BYTE8(v20)) {
    uint64_t v7 = 2672;
  }
  unint64_t v8 = *(OZShapeRenderParams **)((char *)this + v7);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v24);
  uint64_t Contour = OZShape::getContour(this, a2, v8);
  if (OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 6800), 0, 1)) {
    OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 2784), 0, 1);
  }
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(Contour + 40) = _Q0;
  uint64_t v15 = *(void *)(Contour + 216);
  if (*(void *)(Contour + 224) != v15)
  {
    uint64_t v16 = 0;
    unsigned int v17 = 1;
    do
    {
      float64_t v18 = *(double *)(*(void *)(Contour + 240) + 8 * v16);
      v19[0].f64[0] = *(float64_t *)(v15 + 8 * v16);
      v19[0].f64[1] = v18;
      PCRect<double>::operator|=((float64x2_t *)(Contour + 24), v19);
      uint64_t v16 = v17;
      uint64_t v15 = *(void *)(Contour + 216);
      ++v17;
    }
    while (v16 != (*(void *)(Contour + 224) - v15) >> 3);
  }
  *((unsigned char *)v8 + 1192) = 0;
}

BOOL OZShape::shouldDrawSoftEdges(OZShape *this, const OZShapeRenderParams *a2)
{
  BOOL result = 1;
  if (*((_DWORD *)a2 + 2))
  {
    if ((OZShape::isWriteOnEffectEnabled((uint64_t)this, (uint64_t)a2) & 1) == 0)
    {
      int v3 = *((_DWORD *)a2 + 29);
      if (v3 != 1
        && (v3
         || *((double *)a2 + 2) >= 2.0
         && fabs(*((double *)a2 + 8) + -1.0) < 0.0000001
         && (*((_DWORD *)a2 + 42) || !*((_DWORD *)a2 + 30))))
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t OZShape::shouldDrawAntialiasingOnFill(OZShape *this, const OZShapeRenderParams *a2)
{
  int v3 = *((_DWORD *)a2 + 30);
  if (*((_DWORD *)a2 + 2))
  {
    if (v3)
    {
      if (OZShape::isWriteOnEffectEnabled((uint64_t)this, (uint64_t)a2)) {
        return 1;
      }
      int v4 = *((_DWORD *)a2 + 29);
      if (v4 == 1 || !v4 && (*((double *)a2 + 2) < 2.0 || fabs(*((double *)a2 + 8) + -1.0) >= 0.0000001)) {
        return 1;
      }
      if (!*((_DWORD *)a2 + 42)) {
        return 1;
      }
    }
  }
  else if (v3 && fabs(*((double *)a2 + 28)) < 0.0000001)
  {
    return 1;
  }
  return 0;
}

BOOL OZShape::shouldDrawSecondPassOutline(OZShape *this, const OZShapeRenderParams *a2)
{
  return *((_DWORD *)a2 + 2) != 0;
}

uint64_t OZShape::shouldDrawParticles(uint64_t a1, CMTime *a2)
{
  CMTime v5 = *a2;
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 6928), &v5, 0.0);
  LODWORD(result) = OZChannelBase::isEnabled((OZChannelBase *)(a1 + 6800), 0, 1);
  if ((ValueAsInt - 1) < 2) {
    return result;
  }
  else {
    return 0;
  }
}

BOOL OZShape::shouldDrawOnlyParticles(uint64_t a1, CMTime *a2)
{
  CMTime v6 = *a2;
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 6928), &v6, 0.0);
  int isEnabled = OZChannelBase::isEnabled((OZChannelBase *)(a1 + 6800), 0, 1);
  BOOL result = 0;
  if (isEnabled) {
    return (OZChannelBase::isEnabled((OZChannelBase *)(a1 + 2784), 0, 1) & 1) == 0 && (ValueAsInt - 1) < 2;
  }
  return result;
}

BOOL OZShape::shouldDrawFillAndParticles(uint64_t a1, CMTime *a2)
{
  CMTime v6 = *a2;
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 6928), &v6, 0.0);
  int isEnabled = OZChannelBase::isEnabled((OZChannelBase *)(a1 + 6800), 0, 1);
  BOOL result = 0;
  if (isEnabled) {
    return OZChannelBase::isEnabled((OZChannelBase *)(a1 + 2784), 0, 1)
  }
        && (ValueAsInt - 1) < 2;
  return result;
}

BOOL OZShape::shouldRenderInPlace(OZShape *this, OZShapeRenderParams *a2)
{
  int v2 = *((_DWORD *)a2 + 30);
  if (!*((_DWORD *)a2 + 2))
  {
    if (!v2) {
      goto LABEL_8;
    }
    int v3 = (double *)((char *)a2 + 152);
LABEL_7:
    int v2 = fabs(*((double *)a2 + 20) * *v3 + -1.0) < 0.0000001;
    goto LABEL_8;
  }
  if (!v2)
  {
    int v3 = (double *)((char *)a2 + 64);
    goto LABEL_7;
  }
  int v2 = 0;
  if (!*((unsigned char *)a2 + 553)) {
    return 0;
  }
LABEL_8:
  if (!*((_DWORD *)a2 + 42)) {
    int v2 = 0;
  }
  return v2 == 1 && !*((unsigned char *)a2 + 176);
}

uint64_t OZShape::getHeliumParameters(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, char a5, uint64_t a6)
{
  double v11 = (PCMutex *)(a1 + 8);
  uint64_t v29 = a1 + 8;
  PCMutex::lock((PCMutex *)(a1 + 8));
  char v30 = 1;
  BOOL isGeometricShape = OZShape::isGeometricShape((OZShape *)a1);
  if (!isGeometricShape
    && (int)OZDynamicCurve::getNumberOfValidKeypoints((os_unfair_lock_s *)(a1 + 496), (const CMTime *)a2) < 2)
  {
    goto LABEL_12;
  }
  long long v26 = *(_OWORD *)(a2 + 16);
  unint64_t v13 = *(CGColorSpace **)(a2 + 80);
  double v27 = v13;
  if (v13) {
    PCCFRefTraits<CGColorSpace *>::retain(v13);
  }
  int v28 = *(_DWORD *)(a2 + 88);
  uint64_t v14 = 2664;
  if (!BYTE8(v26)) {
    uint64_t v14 = 2672;
  }
  uint64_t v15 = *(void *)(a1 + v14);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v27);
  char v16 = OZChannel::getValueAsInt((OZChannel *)(a1 + 14600), MEMORY[0x1E4F1FA48], 0.0) == 1 ? 0 : a5;
  *(unsigned char *)(v15 + 176) = v16;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)a1 + 64))(a1, a2, v15, 0, 1);
  if (fabs(*(double *)(v15 + 248)) < 0.0000001 || fabs(*(double *)(v15 + 256)) < 0.0000001) {
    goto LABEL_12;
  }
  if (!*(void *)(a1 + 18720) && *(_DWORD *)(v15 + 124) == 1) {
    operator new();
  }
  if (isGeometricShape)
  {
    if (fabs(*(double *)(v15 + 200)) < 0.0000001)
    {
      if (fabs(*(double *)(v15 + 224)) < 0.0000001 && *(_DWORD *)(v15 + 120) && !*(_DWORD *)(v15 + 8)) {
        goto LABEL_12;
      }
      *(void *)(v15 + 200) = 0x3FF0000000000000;
    }
    if (fabs(*(double *)(v15 + 208)) < 0.0000001)
    {
      if (fabs(*(double *)(v15 + 224)) >= 0.0000001 || !*(_DWORD *)(v15 + 120) || *(_DWORD *)(v15 + 8))
      {
        *(void *)(v15 + 208) = 0x3FF0000000000000;
        goto LABEL_28;
      }
LABEL_12:
      uint64_t v17 = 0;
      goto LABEL_13;
    }
  }
LABEL_28:
  uint64_t v19 = v15 + 1200;
  if ((_OWORD *)(v15 + 1200) != a3)
  {
    uint64_t v20 = 0;
    long long v21 = a3;
    do
    {
      for (uint64_t i = 0; i != 32; i += 8)
        *(void *)(v19 + i) = *(void *)((char *)v21 + i);
      ++v20;
      v19 += 32;
      v21 += 2;
    }
    while (v20 != 4);
  }
  OZShapeRenderParams::assign((OZShapeRenderParams *)a6, (OZShapeRenderParams *)v15, 0);
  Renderuint64_t Contour = (long long *)OZShape::getRenderContour(a1, a2, a6, a3);
  OZShapeContour::operator=(a6 + 368, RenderContour);
  *(unsigned char *)(a6 + 1192) = 0;
  if (*(_DWORD *)(a6 + 8) && OZShape::isWriteOnEffectEnabled(a1, a6))
  {
    OZShape::getReparametrizedContour(a1, a2, a6, 0);
    operator new();
  }
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E4F1FA48], 0.0);
  uint64_t v17 = 1;
  if (*(int *)(a6 + 180) >= 1 && ValueAsInt != 4)
  {
    RenderContourWithRoundness = (long long *)OZShape::getRenderContourWithRoundness(a1, a2, a6, (uint64_t)a3);
    OZShapeContour::operator=(a6 + 760, RenderContourWithRoundness);
    *(unsigned char *)(a6 + 1194) = 0;
  }
LABEL_13:
  PCMutex::unlock(v11);
  return v17;
}

void sub_1B7E3B7F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  MEMORY[0x1BA9BFBA0](v13, 0x10A0C401050895ELL);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t OZShape::getHeliumRender@<X0>(uint64_t a1@<X0>, const CMTime *a2@<X1>, double *a3@<X2>, _OWORD *a4@<X3>, uint64_t a5@<X4>, HGHWMultiBlend **a6@<X8>)
{
  uint64_t result = OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E4F1FA48], 0.0);
  int v13 = result;
  if (*(_DWORD *)(a5 + 120))
  {
    BOOL v14 = result == 4 || *(_DWORD *)(a5 + 180) == 0;
    uint64_t v15 = 760;
    if (v14) {
      uint64_t v15 = 368;
    }
    uint64_t v16 = a5 + v15;
    if (*(void *)(a5 + v15 + 216) == *(void *)(a5 + v15 + 224)
      || *(void *)(v16 + 240) == *(void *)(v16 + 248)
      || *(void *)(v16 + 192) == *(void *)(v16 + 200))
    {
      goto LABEL_47;
    }
    if (OZShape::shouldDrawSoftEdges((OZShape *)a1, (const OZShapeRenderParams *)a5)
      && (OZShape::shouldDrawAntialiasingOnFill((OZShape *)a1, (const OZShapeRenderParams *)a5) & 1) == 0
      && *(void *)(v16 + 312) == *(void *)(v16 + 320))
    {
      OZShape::computeSoftEdges(a1, a2, a5, v16, 0, 1, 1, *(double *)(a5 + 224));
      if (!*(unsigned char *)(v16 + 185) || *(unsigned char *)(v16 + 186) || !*(unsigned char *)(v16 + 187)) {
        OZShape::computeSoftEdges(a1, a2, a5, v16, 0, 0, -1, *(double *)(a5 + 224));
      }
    }
  }
  int v17 = *(_DWORD *)(a5 + 8);
  if (*(double *)(a5 + 16) <= 0.0 || v17 == 0) {
    goto LABEL_21;
  }
  uint64_t result = OZShape::isWriteOnEffectEnabled(a1, a5);
  if (!*(_DWORD *)(a5 + 180) || v13 == 4)
  {
    if (*(_DWORD *)(a5 + 168) || !result) {
      uint64_t v20 = (uint64_t *)(a5 + 368);
    }
    else {
      uint64_t v20 = *(uint64_t **)(a5 + 752);
    }
  }
  else
  {
    uint64_t v20 = (uint64_t *)(a5 + 760);
  }
  if (v20[27] == v20[28] || v20[30] == v20[31] || v20[24] == v20[25])
  {
LABEL_47:
    int v25 = 0;
    goto LABEL_54;
  }
  if (*(unsigned char *)(a5 + 1195) || v20[43] == v20[42])
  {
    if (*(_DWORD *)(a5 + 168)) {
      char v21 = result;
    }
    else {
      char v21 = 1;
    }
    int v22 = *(_DWORD *)(a5 + 24);
    double v23 = *(double *)(a5 + 16);
    BOOL v24 = !PCMatrix44Tmpl<double>::isIdentity(a3);
    if (v21) {
      OZShape::computeOpenStroke(a1, a2, a5, v20, a3, v22, v24, v23);
    }
    else {
      OZShape::computeOutline(a1, a2, a5, v20, a3, v22, v24, v23);
    }
  }
  int v17 = *(_DWORD *)(a5 + 8);
LABEL_21:
  if (*(_DWORD *)(a5 + 124) != 1 || *(_DWORD *)(a5 + 120) == 0)
  {
    if (!v17) {
      goto LABEL_49;
    }
LABEL_27:
    uint64_t result = (uint64_t)OZShape::getSecondPassOutlineHeliumNode((OZShape *)a1, a2, a5, &v27);
    goto LABEL_50;
  }
  if (v17 || OZShape::shouldDrawSoftEdges((OZShape *)a1, (const OZShapeRenderParams *)a5))
  {
    uint64_t result = OZShape::getSecondPassGradientToHeliumNode((OZShape *)a1, a2, a4, a5, &v27);
    goto LABEL_50;
  }
  if (*(_DWORD *)(a5 + 8)) {
    goto LABEL_27;
  }
LABEL_49:
  uint64_t result = OZShape::drawToHeliumNode(a1, a2, a5, (uint64_t *)&v27);
LABEL_50:
  int v25 = v27;
  if (v27)
  {
    long long v26 = (HGCrop *)HGObject::operator new(0x1A0uLL);
    HGCrop::HGCrop(v26);
    (*(void (**)(HGCrop *, void, float, float, float, float))(*(void *)v26 + 96))(v26, 0, -1000000.0, -1000000.0, 1000000.0, 1000000.0);
    (*(void (**)(HGCrop *, void, HGHWMultiBlend *))(*(void *)v26 + 120))(v26, 0, v25);
    if (v25 != v26)
    {
      (*(void (**)(HGHWMultiBlend *))(*(void *)v25 + 24))(v25);
      int v25 = v26;
      (*(void (**)(HGCrop *))(*(void *)v26 + 16))(v26);
    }
    uint64_t result = (*(uint64_t (**)(HGCrop *))(*(void *)v26 + 24))(v26);
  }
LABEL_54:
  *a6 = v25;
  return result;
}

void sub_1B7E3BC30(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

BOOL OZShape::shouldDrawSecondPassGradientInHelium(OZShape *a1, int a2, OZShapeRenderParams *a3)
{
  return *((_DWORD *)a3 + 31) == 1
      && *((_DWORD *)a3 + 30)
      && (*((_DWORD *)a3 + 2) || OZShape::shouldDrawSoftEdges(a1, a3));
}

uint64_t OZShape::getSecondPassGradientToHeliumNode@<X0>(OZShape *a1@<X0>, const CMTime *a2@<X1>, _OWORD *a3@<X3>, uint64_t a4@<X4>, void *a5@<X8>)
{
  *a5 = 0;
  int v10 = *(_DWORD *)(a4 + 8);
  double v11 = (PCMutex *)((char *)a1 + 8);
  int v25 = (OZShape *)((char *)a1 + 8);
  PCMutex::lock((PCMutex *)((char *)a1 + 8));
  char v26 = 1;
  uint64_t v12 = *((void *)a1 + 2340);
  double v13 = (*(double (**)(OZShape *))(*(void *)a1 + 176))(a1);
  *(double *)(*(void *)(v12 + 16) + 176) = v13;
  *(double *)(*(void *)(v12 + 8) + 176) = v13;
  BOOL v14 = (void *)*((void *)a1 + 2340);
  CMTime v24 = *a2;
  OZGradientGroupShader::updateWithXForm(v14, &v24, a3);
  uint64_t v15 = *(void *)(*((void *)a1 + 2340) + 24);
  uint64_t CGColorSpace = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&a2[3].timescale);
  (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass **__return_ptr, uint64_t, uint64_t))(*(void *)v15 + 48))(&v23, v15, CGColorSpace);
  int v17 = v23;
  uint64_t result = PCMutex::unlock(v11);
  int v19 = *(_DWORD *)(a4 + 120);
  if (v10)
  {
    if (v19)
    {
      OZShape::drawToHeliumNode((uint64_t)a1, a2, a4, (uint64_t *)&v25);
      uint64_t result = (uint64_t)OZShape::getOutlineHeliumNode(a1, (uint64_t)a2, (double *)a4, &v23);
      if (v25)
      {
        uint64_t v20 = (HgcShapeGradientBlend *)HGObject::operator new(0x1A0uLL);
        *((_OWORD *)v20 + 24) = 0u;
        *((_OWORD *)v20 + 25) = 0u;
        *((_OWORD *)v20 + 22) = 0u;
        *((_OWORD *)v20 + 23) = 0u;
        *((_OWORD *)v20 + 20) = 0u;
        *((_OWORD *)v20 + 21) = 0u;
        *((_OWORD *)v20 + 18) = 0u;
        *((_OWORD *)v20 + 19) = 0u;
        *((_OWORD *)v20 + 16) = 0u;
        *((_OWORD *)v20 + 17) = 0u;
        *((_OWORD *)v20 + 14) = 0u;
        *((_OWORD *)v20 + 15) = 0u;
        *((_OWORD *)v20 + 12) = 0u;
        *((_OWORD *)v20 + 13) = 0u;
        *((_OWORD *)v20 + 10) = 0u;
        *((_OWORD *)v20 + 11) = 0u;
        *((_OWORD *)v20 + 8) = 0u;
        *((_OWORD *)v20 + 9) = 0u;
        *((_OWORD *)v20 + 6) = 0u;
        *((_OWORD *)v20 + 7) = 0u;
        *((_OWORD *)v20 + 4) = 0u;
        *((_OWORD *)v20 + 5) = 0u;
        *((_OWORD *)v20 + 2) = 0u;
        *((_OWORD *)v20 + 3) = 0u;
        *(_OWORD *)uint64_t v20 = 0u;
        *((_OWORD *)v20 + 1) = 0u;
        HgcShapeGradientBlend::HgcShapeGradientBlend(v20);
      }
      int v22 = v23;
      if (v23)
      {
        *a5 = v23;
        (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v22 + 16))(v22);
        uint64_t result = (*(uint64_t (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v22 + 24))(v22);
      }
    }
    else
    {
      uint64_t result = (uint64_t)OZShape::getOutlineHeliumNode(a1, (uint64_t)a2, (double *)a4, &v25);
      if (v25) {
        *a5 = v25;
      }
    }
  }
  else if (v19)
  {
    uint64_t result = OZShape::drawToHeliumNode((uint64_t)a1, a2, a4, (uint64_t *)&v25);
    if (v25)
    {
      char v21 = (HgcShapeGradientBlend *)HGObject::operator new(0x1A0uLL);
      *((_OWORD *)v21 + 24) = 0u;
      *((_OWORD *)v21 + 25) = 0u;
      *((_OWORD *)v21 + 22) = 0u;
      *((_OWORD *)v21 + 23) = 0u;
      *((_OWORD *)v21 + 20) = 0u;
      *((_OWORD *)v21 + 21) = 0u;
      *((_OWORD *)v21 + 18) = 0u;
      *((_OWORD *)v21 + 19) = 0u;
      *((_OWORD *)v21 + 16) = 0u;
      *((_OWORD *)v21 + 17) = 0u;
      *((_OWORD *)v21 + 14) = 0u;
      *((_OWORD *)v21 + 15) = 0u;
      *((_OWORD *)v21 + 12) = 0u;
      *((_OWORD *)v21 + 13) = 0u;
      *((_OWORD *)v21 + 10) = 0u;
      *((_OWORD *)v21 + 11) = 0u;
      *((_OWORD *)v21 + 8) = 0u;
      *((_OWORD *)v21 + 9) = 0u;
      *((_OWORD *)v21 + 6) = 0u;
      *((_OWORD *)v21 + 7) = 0u;
      *((_OWORD *)v21 + 4) = 0u;
      *((_OWORD *)v21 + 5) = 0u;
      *((_OWORD *)v21 + 2) = 0u;
      *((_OWORD *)v21 + 3) = 0u;
      *(_OWORD *)char v21 = 0u;
      *((_OWORD *)v21 + 1) = 0u;
      HgcShapeGradientBlend::HgcShapeGradientBlend(v21);
    }
  }
  if (v17) {
    return (*(uint64_t (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v17 + 24))(v17);
  }
  return result;
}

void sub_1B7E3C2F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
  }
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
  }
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
  }
  _Unwind_Resume(exception_object);
}

HGGLNode *OZShape::getSecondPassOutlineHeliumNode@<X0>(OZShape *a1@<X0>, const CMTime *a2@<X1>, uint64_t a3@<X4>, HGHWMultiBlend **a4@<X8>)
{
  *a4 = 0;
  if (*(_DWORD *)(a3 + 120))
  {
    OZShape::drawToHeliumNode((uint64_t)a1, a2, a3, (uint64_t *)&v14);
    uint64_t result = OZShape::getOutlineHeliumNode(a1, (uint64_t)a2, (double *)a3, &v13);
    float64x2_t v9 = v14;
    if (v14)
    {
      int v10 = (HGHWMultiBlend *)HGObject::operator new(0x280uLL);
      HGHWMultiBlend::HGHWMultiBlend(v10);
      (*(void (**)(HGHWMultiBlend *, void, float, double, double, double))(*(void *)v10 + 96))(v10, 0, 9.0, 0.0, 0.0, 0.0);
      if (*(_DWORD *)(a3 + 116) == 1)
      {
        double v11 = v13;
        (*(void (**)(HGHWMultiBlend *, void, HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v10 + 120))(v10, 0, v13);
        (*(void (**)(HGHWMultiBlend *, uint64_t, HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v10 + 120))(v10, 1, v9);
      }
      else
      {
        (*(void (**)(HGHWMultiBlend *, void, HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v10 + 120))(v10, 0, v9);
        double v11 = v13;
        (*(void (**)(HGHWMultiBlend *, uint64_t, HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v10 + 120))(v10, 1, v13);
      }
      *a4 = v10;
      (*(void (**)(HGHWMultiBlend *))(*(void *)v10 + 16))(v10);
      (*(void (**)(HGHWMultiBlend *))(*(void *)v10 + 24))(v10);
      if (!v11) {
        return (HGGLNode *)(*(uint64_t (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v9 + 24))(v9);
      }
    }
    else
    {
      uint64_t v12 = v13;
      if (!v13) {
        return result;
      }
      *a4 = v13;
      (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v12 + 16))(v12);
      double v11 = v12;
    }
    uint64_t result = (HGGLNode *)(*(uint64_t (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v11 + 24))(v11);
    if (!v9) {
      return result;
    }
    return (HGGLNode *)(*(uint64_t (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v9 + 24))(v9);
  }
  uint64_t result = OZShape::getOutlineHeliumNode(a1, (uint64_t)a2, (double *)a3, &v14);
  if (v14) {
    *a4 = v14;
  }
  return result;
}

void sub_1B7E3C818(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 24))(a9);
  }
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  }
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  }
  _Unwind_Resume(exception_object);
}

HGGLNode *OZShape::getOutlineHeliumNode@<X0>(OZShape *a1@<X0>, uint64_t a2@<X1>, double *a3@<X4>, HgcShapeSoftEdgeColorizeSecondPass **a4@<X8>)
{
  unint64_t v8 = (HGGLNode *)HGObject::operator new(0x1B0uLL);
  HGGLNode::HGGLNode(v8, 0);
  uint64_t v29 = v8;
  *a4 = 0;
  HGGLNode::hglTexParameteri((char **)v8, (const char *)0xDE1, (char *)0x2801, 9729.0);
  HGGLNode::hglTexParameteri((char **)v29, (const char *)0xDE1, (char *)0x2800, 9729.0);
  HGGLNode::hglTexParameteri((char **)v29, (const char *)0xDE1, (char *)0x2802, 33071.0);
  HGGLNode::hglTexParameteri((char **)v29, (const char *)0xDE1, (char *)0x2803, 33071.0);
  active = (OZShape *)HGGLNode::hglActiveTexture(v29, 192);
  double v10 = a3[8];
  float v11 = a3[5] * v10;
  float v12 = v10 * a3[6];
  float v13 = v10 * a3[7];
  if (OZShape::shouldRenderInPlace(active, (OZShapeRenderParams *)a3))
  {
    BOOL v14 = (HgcShapeSoftEdgeClrInPlace *)HGObject::operator new(0x1B0uLL);
    HgcShapeSoftEdgeClrInPlace::HgcShapeSoftEdgeClrInPlace(v14);
    int v15 = 0;
    uint64_t v16 = 1;
  }
  else
  {
    uint64_t v17 = (HgcShapeSoftEdgeClr *)HGObject::operator new(0x1B0uLL);
    BOOL v14 = v17;
    BOOL v18 = v11 < 0.0;
    if (v12 < 0.0) {
      BOOL v18 = 1;
    }
    if (v13 < 0.0) {
      BOOL v18 = 1;
    }
    if (v11 > 1.0) {
      BOOL v18 = 1;
    }
    if (v12 > 1.0) {
      BOOL v18 = 1;
    }
    int v15 = v13 > 1.0 || v18;
    HgcShapeSoftEdgeClr::HgcShapeSoftEdgeClr(v17);
    uint64_t v16 = 0;
  }
  HGGLNode::addFragmentShader(v29, v14);
  float v22 = v10;
  if (v15) {
    v19.n128_f32[0] = 1.0;
  }
  else {
    v19.n128_f32[0] = v11;
  }
  if (v15) {
    v20.n128_f32[0] = 1.0;
  }
  else {
    v20.n128_f32[0] = v12;
  }
  if (v15) {
    v21.n128_f32[0] = 1.0;
  }
  else {
    v21.n128_f32[0] = v13;
  }
  (*(void (**)(HgcShapeSoftEdgeClrInPlace *, uint64_t, __n128, __n128, __n128))(*(void *)v14 + 96))(v14, v16, v19, v20, v21);
  HGGLNode::hglClearToBlack(v29);
  OZShape::drawShapeOutlineToHeliumNode((uint64_t)a1, (uint64_t)a3, (uint64_t *)&v29, (uint64_t *)&v28);
  uint64_t v23 = (uint64_t)v28;
  if (v28) {
    *a4 = v28;
  }
  uint64_t v24 = *(void *)(a2 + 56);
  uint64_t EdgeTextureKernelType = OZShape::getEdgeTextureKernelType(a1, 1.0);
  (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass **__return_ptr, OZShape *, uint64_t, uint64_t))(*(void *)a1 + 392))(&v28, a1, v24, EdgeTextureKernelType);
  (*(void (**)(HGGLNode *, void, HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v29 + 120))(v29, 0, v28);
  (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *, uint64_t, uint64_t))(*(void *)v28 + 136))(v28, 0xFFFFFFFFLL, 4);
  if (v15)
  {
    char v26 = (HgcShapeSoftEdgeColorizeSecondPass *)HGObject::operator new(0x200uLL);
    HgcShapeSoftEdgeColorizeSecondPass::HgcShapeSoftEdgeColorizeSecondPass(v26);
    (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *, void, uint64_t))(*(void *)v26 + 120))(v26, 0, v23);
    (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *, uint64_t, float, float, float, float))(*(void *)v26 + 96))(v26, v16, v11, v12, v13, v22);
    if ((HgcShapeSoftEdgeColorizeSecondPass *)v23 != v26)
    {
      if (v23) {
        (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
      }
      *a4 = v26;
      (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v26 + 16))(v26);
    }
    (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v26 + 24))(v26);
  }
  if (v28) {
    (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(void *)v28 + 24))(v28);
  }
  (*(void (**)(HgcShapeSoftEdgeClrInPlace *))(*(void *)v14 + 24))(v14);
  uint64_t result = v29;
  if (v29) {
    return (HGGLNode *)(*(uint64_t (**)(HGGLNode *))(*(void *)v29 + 24))(v29);
  }
  return result;
}

void sub_1B7E3CD58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  HGObject::operator delete(v12);
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 24))(a9);
  }
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  }
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t OZShape::drawToHeliumNode@<X0>(uint64_t a1@<X0>, const CMTime *a2@<X1>, uint64_t a3@<X4>, uint64_t *a4@<X8>)
{
  *a4 = 0;
  uint64_t result = OZShape::isGeometricShape((OZShape *)a1);
  if ((result & 1) == 0)
  {
    uint64_t result = OZDynamicCurve::getNumberOfValidKeypoints((os_unfair_lock_s *)(a1 + 496), a2);
    if ((int)result < 2) {
      return result;
    }
  }
  int v9 = *(_DWORD *)(a3 + 8);
  int v10 = *(_DWORD *)(a3 + 120);
  unsigned int v11 = *(double *)(a3 + 16);
  BOOL v12 = v9 && v10 == 0;
  if (v12 && v11 - 1 < 2) {
    return result;
  }
  if (*(_DWORD *)(a3 + 168)) {
    goto LABEL_12;
  }
  uint64_t result = OZChannel::getValueAsInt((OZChannel *)(a1 + 12856), MEMORY[0x1E4F1FA48], 0.0);
  if (result
    || (uint64_t result = OZChannel::getValueAsInt((OZChannel *)(a1 + 14280), MEMORY[0x1E4F1FA48], 0.0), !result))
  {
    BOOL v14 = 0;
  }
  else
  {
    if (v10)
    {
LABEL_12:
      uint64_t result = OZShape::drawCurveToHeliumNode(a1, (uint64_t)a2, a3, 0, &v18);
      goto LABEL_13;
    }
    BOOL v14 = 0;
    if (v9 && !v11)
    {
      uint64_t result = OZShape::drawCurveToHeliumNode(a1, (uint64_t)a2, a3, 1, &v18);
LABEL_13:
      BOOL v14 = v18;
      if (v18) {
        *a4 = (uint64_t)v18;
      }
    }
  }
  double v15 = *(double *)(a3 + 232);
  if (v15 <= -0.0000001 || v15 >= 0.0000001)
  {
    uint64_t v16 = (HgcShapeAlphaBias *)HGObject::operator new(0x1A0uLL);
    HgcShapeAlphaBias::HgcShapeAlphaBias(v16);
    (*(void (**)(HgcShapeAlphaBias *, void, HGGLNode *))(*(void *)v16 + 120))(v16, 0, v14);
    float v17 = exp(v15 / 100.0 * 0.693147181);
    (*(void (**)(HgcShapeAlphaBias *, void, float, double, double, double))(*(void *)v16 + 96))(v16, 0, v17, 0.0, 0.0, 0.0);
    BOOL v14 = v16;
  }
  else
  {
    if (!v14) {
      return result;
    }
    (*(void (**)(HGGLNode *))(*(void *)v14 + 16))(v14);
  }
  uint64_t result = *a4;
  if ((HGGLNode *)*a4 == v14) {
    return (*(uint64_t (**)(HGGLNode *))(*(void *)v14 + 24))(v14);
  }
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
  }
  *a4 = (uint64_t)v14;
  return result;
}

void sub_1B7E3D180(_Unwind_Exception *exception_object)
{
  if (*v1) {
    (*(void (**)(void))(*(void *)*v1 + 24))(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OZShape::drawCurveToHeliumNode@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W5>, HGGLNode **a5@<X8>)
{
  unint64_t v8 = (OZShape *)result;
  *a5 = 0;
  if (*(_DWORD *)(a3 + 180)
    && (uint64_t result = OZChannel::getValueAsInt((OZChannel *)(result + 1072), MEMORY[0x1E4F1FA48], 0.0), result != 4))
  {
    int v10 = (void *)(a3 + 760);
  }
  else
  {
    int v10 = (void *)(a3 + 368);
  }
  if (v10[27] != v10[28] && v10[30] != v10[31] && !a4 && v10[24] != v10[25] && *(_DWORD *)(a3 + 120))
  {
    unsigned int v11 = (HGGLNode *)HGObject::operator new(0x1B0uLL);
    HGGLNode::HGGLNode(v11, 0);
    uint64_t v16 = v11;
    if (v11)
    {
      *a5 = v11;
      (*(void (**)(HGGLNode *))(*(void *)v11 + 16))(v11);
    }
    uint64_t v12 = *(void *)(a2 + 56);
    uint64_t EdgeTextureKernelType = OZShape::getEdgeTextureKernelType(v8, *(double *)(a3 + 224));
    (*(void (**)(uint64_t *__return_ptr, OZShape *, uint64_t, uint64_t))(*(void *)v8 + 392))(&v15, v8, v12, EdgeTextureKernelType);
    (*(void (**)(HGGLNode *, void, uint64_t))(*(void *)v16 + 120))(v16, 0, v15);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15 + 136))(v15, 0xFFFFFFFFLL, 4);
    HGArray<__simd128_float32_t,(HGFormat)28>::HGArray((uint64_t)&v14);
  }
  return result;
}

void sub_1B7E3DF24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (__p) {
    (*(void (**)(void *))(*(void *)__p + 24))(__p);
  }
  if (a16) {
    (*(void (**)(uint64_t))(*(void *)a16 + 24))(a16);
  }
  OZShapeVertexArrayData::~OZShapeVertexArrayData((OZShapeVertexArrayData *)(v20 - 208));
  uint64_t v22 = *(void *)(v20 - 152);
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
  }
  uint64_t v23 = *(void *)(v20 - 144);
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
  }
  if (*a15) {
    (*(void (**)(void))(*(void *)*a15 + 24))(*a15);
  }
  _Unwind_Resume(a1);
}

uint64_t OZShape::getEdgeTextureHeliumNode@<X0>(LiEdgeTexture *a1@<X2>, HGBitmapLoader **a2@<X8>)
{
  return OZShapeEdgeTexture::getHeliumNode(a1, a2);
}

uint64_t OZShape::getEdgeTextureKernelType(OZShape *this, double a2)
{
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 13872), MEMORY[0x1E4F1FA48], 0.0))
  {
    if (a2 <= 0.0) {
      return 5;
    }
    else {
      return 4;
    }
  }
  else if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 11816), MEMORY[0x1E4F1FA48], 0.0) == 2)
  {
    return 6;
  }
  else
  {
    return 3;
  }
}

uint64_t OZShape::drawAntialiasedBordersToHeliumNode@<X0>(OZShapeRenderParams *a1@<X2>, OZShape *a2@<X0>, int a3@<W1>, uint64_t a4@<X3>, int a5@<W4>, HGGLNode **a6@<X5>, uint64_t *a7@<X6>, HGGLNode **a8@<X8>)
{
  uint64_t v9 = 0;
  OZShape::drawOutlinePolygonsToHeliumNode(a2, a1, (uint64_t *)(a4 + 288), a3, a4, 0, 1, a5, a8, 2.0, a6, &v9, 0, a7);
  uint64_t result = v9;
  if (v9) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  return result;
}

void sub_1B7E3E2E0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 - 24);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  _Unwind_Resume(exception_object);
}

char *OZShape::drawVertexArrayList(OZShape *this, char **a2, OZShapeVertexArrayData *a3)
{
  HGGLNode::hglEnableClientState(a2, 32884);
  HGGLNode::hglEnableClientState(a2, 32888);
  HGGLNode::hglTexCoordArray((const char **)a2, (OZShapeVertexArrayData *)((char *)a3 + 40));
  HGGLNode::hglVertexArray((HGGLNode *)a2, (OZShapeVertexArrayData *)((char *)a3 + 24), v5);
  uint64_t v6 = *(void *)a3;
  if ((int)(-1431655765 * ((*((void *)a3 + 1) - *(void *)a3) >> 2)) >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    do
    {
      HGGLNode::hglDrawArrays((HGRasterizer **)a2, *(_DWORD *)(v6 + v7), *(_DWORD *)(v6 + v7 + 4), *(_DWORD *)(v6 + v7 + 8));
      ++v8;
      uint64_t v6 = *(void *)a3;
      v7 += 12;
    }
    while (v8 < (int)(-1431655765 * ((*((void *)a3 + 1) - *(void *)a3) >> 2)));
  }
  HGGLNode::hglDisableClientState(a2, 32884);

  return HGGLNode::hglDisableClientState(a2, 32888);
}

void OZShape::drawOutlineToHeliumNode()
{
  std::string __p = 0;
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  HGArray<__simd128_float32_t,(HGFormat)28>::HGArray((uint64_t)&v3);
}

void sub_1B7E3E578(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, HGArrayData *a19)
{
  if (a19) {
    HGArrayData::Release((uint64_t)a19);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double OZShape::drawShapeOutlineToHeliumNode@<D0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t *a3@<X4>, uint64_t *a4@<X8>)
{
  uint64_t v6 = *a3;
  *a4 = *a3;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
  }
  if ((!*(_DWORD *)(a2 + 180)
     || OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E4F1FA48], 0.0) == 4)
    && !*(_DWORD *)(a2 + 168))
  {
    OZShape::isWriteOnEffectEnabled(a1, a2);
  }
  double result = *(double *)(a2 + 16);
  if (result > 0.0)
  {
    if (*(_DWORD *)(a2 + 8)) {
      OZShape::drawOutlineToHeliumNode();
    }
  }
  return result;
}

void sub_1B7E3E774(_Unwind_Exception *exception_object)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::HRotoshapeGradientBlend::~HRotoshapeGradientBlend(HGNode *this)
{
  HgcShapeGradientBlend::~HgcShapeGradientBlend(this);

  HGObject::operator delete(v1);
}

uint64_t anonymous namespace'::HRotoshapeGradientBlend::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  uint64_t v10 = v9;
  unsigned int v11 = HGRenderer::GetInput(a2, this, 1u);
  uint64_t v12 = HGRenderer::GetDOD(a2, v11);
  return HGRectIntersection(DOD, v10, v12, v13);
}

uint64_t anonymous namespace'::HRotoshapeGradientBlend::GetROI(_anonymous_namespace_::HRotoshapeGradientBlend *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 <= 1) {
    return *(void *)&a4.var0;
  }
  else {
    return 0;
  }
}

void sub_1B7E3E9D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  MEMORY[0x1BA9BFBA0](v10, 0x10E1C409E4CE797);
  _Unwind_Resume(a1);
}

void OZGradientData::OZGradientData(OZGradientData *this, int a2)
{
  HGObject::HGObject(this);
  *(void *)uint64_t v4 = &unk_1F1199568;
  *(_DWORD *)(v4 + 12) = a2;
  *((void *)this + 3) = HGMemory::allocate((HGMemory *)(4 * a2), (unint64_t *)this + 2, v5);
}

void sub_1B7E3EAB8(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void OZGradientData::~OZGradientData(HGMemory **this, void *a2)
{
  *this = (HGMemory *)&unk_1F1199568;
  HGMemory::release(this[3], a2);

  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;
  uint64_t vars8;

  OZGradientData::~OZGradientData(this, a2);

  HGObject::operator delete(v2);
}

void OZGradient::OZGradient(OZGradient *this, OZChannelGradient *a2, uint64_t a3, CGColorSpace *a4, uint64_t a5)
{
  int v6 = (int)a4;
  uint64_t v8 = *((void *)a2 + 1);
  *(void *)this = v8;
  *(void *)((char *)this + *(void *)(v8 - 24)) = *((void *)a2 + 2);
  uint64_t v9 = *(void *)a2;
  *(void *)this = *(void *)a2;
  *(void *)((char *)this + *(void *)(v9 - 24)) = *((void *)a2 + 3);
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  uint64_t v10 = (OZGradientData **)((char *)this + 8);
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 7) = 1120403456;
  *((void *)this + 4) = a3;
  *((unsigned char *)this + 40) = 0;
  *((void *)this + 21) = 0x3FF0000000000000;
  *((void *)this + 16) = 0x3FF0000000000000;
  *((void *)this + 11) = 0x3FF0000000000000;
  *((void *)this + 6) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  PCWorkingColorVector::PCWorkingColorVector((OZGradient *)((char *)this + 184));
  *((void *)this + 25) = a5;
  unsigned int v11 = (OZGradientData *)HGObject::operator new(0x20uLL);
  OZGradientData::OZGradientData(v11, 4 * v6);
  uint64_t v12 = *v10;
  if (*v10 == v11)
  {
    if (v11) {
      (*(void (**)(OZGradientData *))(*(void *)v11 + 24))(v11);
    }
  }
  else
  {
    if (v12) {
      (*(void (**)(OZGradientData *))(*(void *)v12 + 24))(v12);
    }
    void *v10 = v11;
  }
  *((void *)this + 22) = 0x3FF0000000000000;
}

void sub_1B7E3ED5C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  if (*v2) {
    (*(void (**)(void))(*(void *)*v2 + 24))(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OZGradient::OZGradient(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v5 = a2[1];
  *(void *)a1 = v5;
  *(void *)(a1 + *(void *)(v5 - 24)) = a2[2];
  uint64_t v6 = *a2;
  *(void *)a1 = *a2;
  *(void *)(a1 + *(void *)(v6 - 24)) = a2[3];
  uint64_t v7 = a3[1];
  *(void *)(a1 + 8) = v7;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
  }
  *(void *)(a1 + 16) = a3[2];
  *(void *)(a1 + 24) = a3[3];
  *(void *)(a1 + 32) = a3[4];
  *(unsigned char *)(a1 + 40) = 0;
  *(void *)(a1 + 168) = 0x3FF0000000000000;
  *(void *)(a1 + 128) = 0x3FF0000000000000;
  *(void *)(a1 + 88) = 0x3FF0000000000000;
  *(void *)(a1 + 48) = 0x3FF0000000000000;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 176) = a3[22];
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)(a1 + 184));
  *(void *)(a1 + 200) = a3[25];
  return a1;
}

void sub_1B7E3EF9C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 8);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  _Unwind_Resume(exception_object);
}

void OZGradient::~OZGradient(OZGradient *this, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v2 - 24)) = a2[3];
  uint64_t v3 = *((void *)this + 1);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
}

void OZGradient::~OZGradient(OZGradient *this)
{
  *(void *)(v1 + 208) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 224) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 216));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 208) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 224) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 216));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'OZGradient::~OZGradient(OZGradient *this)
{
  *(void *)(v1 + 208) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 224) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 216);

  PCWeakCount::~PCWeakCount(v2);
}

{
  OZGradient::~OZGradient((OZGradient *)((char *)this + *(void *)(*(void *)this - 24)));
}

void OZGradient::init(OZGradient *this, CGColorSpace *a2)
{
  *((void *)this + 25) = a2;
  OZChannelGradient::getGradient(*((uint64_t ***)this + 4), MEMORY[0x1E4F1FA48], 1, a2, *(void *)(*((void *)this + 1) + 24), ((double)*(int *)(*((void *)this + 1) + 12) * 0.25), 0, (PCToneMapMethod *)&kPCNoToneMapMethod);
}

void OZGradient::getHash(OZGradient *this, CMTime *a2)
{
}

uint64_t OZGradient::update(OZGradient *this, CMTime *a2)
{
  (*(void (**)(int32x4_t *__return_ptr))(*(void *)this + 40))(&v6);
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v6, *(int32x4_t *)((char *)this + 184))))) & 1) == 0
    && *((unsigned char *)this + 40))
  {
    return 0;
  }
  uint64_t v4 = 1;
  OZChannelGradient::getGradient(*((uint64_t ***)this + 4), a2, 1, *((CGColorSpace **)this + 25), *(void *)(*((void *)this + 1) + 24), ((double)*(int *)(*((void *)this + 1) + 12) * 0.25), 0, (PCToneMapMethod *)&kPCNoToneMapMethod);
  *((unsigned char *)this + 40) = 1;
  *(int32x4_t *)((char *)this + 184) = v6;
  return v4;
}

void OZGradient1D::OZGradient1D(OZGradient1D *this, OZChannelGradient *a2, uint64_t a3, CGColorSpace *a4, uint64_t a5)
{
  OZGradient::OZGradient(this, (OZChannelGradient *)((char *)a2 + 8), a3, a4, a5);
  uint64_t v7 = *(void *)a2;
  *uint64_t v8 = *(void *)a2;
  *(void *)((char *)this + *(void *)(v7 - 2OZChannelGradient::getGradientHash(*((void *)this + 4)) = *((void *)a2 + 5);
  (*(void (**)(OZGradient1D *, void))(*(void *)this + 16))(this, *((void *)this + 25));
}

void sub_1B7E3F460(_Unwind_Exception *a1)
{
  OZGradient::~OZGradient(v1, v2);
  _Unwind_Resume(a1);
}

void OZGradient1D::OZGradient1D(OZGradient1D *this, OZChannelGradient *a2, CGColorSpace *a3, CGColorSpace *a4)
{
  *((void *)this + 26) = &unk_1F1199AC8;
  *((void *)this + 27) = 0;
  *((unsigned char *)this + 224) = 1;
  OZGradient::OZGradient(this, (OZChannelGradient *)off_1F11996C0, (uint64_t)a2, a3, (uint64_t)a4);
  *(void *)this = &unk_1F1199648;
  *((void *)this + 26) = &unk_1F11996A0;
  OZChannelGradient::getGradient(*((uint64_t ***)this + 4), MEMORY[0x1E4F1FA48], 1, *((CGColorSpace **)this + 25), *(void *)(*((void *)this + 1) + 24), ((double)*(int *)(*((void *)this + 1) + 12) * 0.25), 0, (PCToneMapMethod *)&kPCNoToneMapMethod);
}

void sub_1B7E3F568(_Unwind_Exception *a1)
{
  OZGradient::~OZGradient((OZGradient *)v1, (uint64_t *)off_1F11996C0);
  *(void *)(v1 + 208) = v3;
  *(unsigned char *)(v1 + 224) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void *OZGradient1D::OZGradient1D(void *a1, uint64_t *a2, void *a3)
{
  uint64_t v5 = (void *)OZGradient::OZGradient((uint64_t)a1, a2 + 1, a3);
  uint64_t v6 = *a2;
  *uint64_t v5 = *a2;
  *(void *)((char *)a1 + *(void *)(v6 - 2OZChannelGradient::getGradientHash(*((void *)this + 4)) = a2[5];
  (*(void (**)(void *, void))(*a1 + 16))(a1, a1[25]);
  return a1;
}

void sub_1B7E3F688(_Unwind_Exception *a1)
{
  OZGradient::~OZGradient(v1, v2);
  _Unwind_Resume(a1);
}

void OZGradient1D::~OZGradient1D(OZGradient1D *this)
{
  OZGradient::~OZGradient(this, (uint64_t *)off_1F11996C0);
  *(void *)(v1 + 208) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 224) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 216));
}

{
  uint64_t v1;
  uint64_t vars8;

  OZGradient::~OZGradient(this, (uint64_t *)off_1F11996C0);
  *(void *)(v1 + 208) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 224) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 216));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'OZGradient1D::~OZGradient1D(OZGradient1D *this)
{
  OZGradient::~OZGradient((OZGradient1D *)((char *)this + *(void *)(*(void *)this - 24)), (uint64_t *)off_1F11996C0);
  *(void *)(v1 + 208) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 224) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 216);

  PCWeakCount::~PCWeakCount(v2);
}

{
  OZGradient1D::~OZGradient1D((OZGradient1D *)((char *)this + *(void *)(*(void *)this - 24)));
}

HGColorConform *OZGradient1D::getHeliumLUT@<X0>(OZGradient1D *this@<X0>, CGColorSpace *a2@<X1>, HGColorConform **a3@<X8>)
{
  uint64_t v6 = HGRectMake4i(0, 0, ((double)*(int *)(*((void *)this + 1) + 12) * 0.25), 1u);
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(*((void *)this + 1) + 24);
  uint64_t v10 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGTexture::HGTexture((uint64_t)v10, v6, v8, 28, v9);
  HGBitmap::SetStorage(v10, *((HGObject **)this + 1));
  unsigned int v11 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v11, v10);
  *a3 = v11;
  uint64_t v13 = v14;
  if (v11 == v14)
  {
    if (v11) {
      double result = (HGColorConform *)(*(uint64_t (**)(HGBitmapLoader *))(*(void *)v11 + 24))(v11);
    }
  }
  else
  {
    if (v11) {
      double result = (HGColorConform *)(*(uint64_t (**)(HGBitmapLoader *))(*(void *)v11 + 24))(v11);
    }
    *a3 = v13;
  }
  if (v10) {
    return (HGColorConform *)(*(uint64_t (**)(HGBitmap *))(*(void *)v10 + 24))(v10);
  }
  return result;
}

void sub_1B7E3F980(_Unwind_Exception *a1)
{
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(a1);
}

HGColorConform *anonymous namespace'::colorCorrectIfNecessary@<X0>(CGColorSpaceRef space@<X1>, CGColorSpace *a2@<X2>, HGColorConform **a3@<X0>, HGColorConform **a4@<X8>)
{
  if (PCColorSpaceHandle::isSameColorSpace(space, a2, a2))
  {
    double result = *a3;
    *a4 = *a3;
    if (result)
    {
      uint64_t v9 = *(uint64_t (**)(void))(*(void *)result + 16);
      return (HGColorConform *)v9();
    }
  }
  else
  {
    uint64_t v10 = (HGColorConform *)HGObject::operator new(0x320uLL);
    HGColorConform::HGColorConform(v10);
    HGColorConform::SetConversion((HGNode *)v10, space, a2);
    double result = (HGColorConform *)(*(uint64_t (**)(HGColorConform *, void, HGColorConform *))(*(void *)v10 + 120))(v10, 0, *a3);
    *a4 = v10;
  }
  return result;
}

void sub_1B7E3FB4C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t OZGradient1D::getHeliumGradientTexture(float32x4_t *a1, float32x4_t *a2, uint64_t *a3, float64x2_t *a4, float64x2_t *a5, uint64_t a6)
{
  uint64_t v6 = a1 + 3;
  if (&a1[3] != a2)
  {
    for (uint64_t i = 0; i != 4; ++i)
    {
      for (uint64_t j = 0; j != 4; ++j)
        v6->i64[j] = a2->i64[j];
      v6 += 2;
      a2 += 2;
    }
  }
  a1[11].i64[0] = *a3;
  a1[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*a4), *a5);
  return (*(uint64_t (**)(float32x4_t *, uint64_t))(a1->i64[0] + 48))(a1, a6);
}

uint64_t OZGradient1D::getHeliumGradientTexture@<X0>(OZGradient1D *this@<X0>, CGColorSpace *a2@<X1>, HGGradient **a3@<X8>)
{
  uint64_t v6 = (HGGradient *)HGObject::operator new(0x210uLL);
  HGGradient::HGGradient(v6);
  HGGradient::SetGradientMode((uint64_t)v6, 0);
  float v7 = *((double *)this + 22);
  (*(void (**)(HGGradient *, void, float, float, float, float))(*(void *)v6 + 96))(v6, 0, v7, 1.0, 1.0, 1.0);
  (*(void (**)(HGGradient *, uint64_t, float, float, double, double))(*(void *)v6 + 96))(v6, 1, *((float *)this + 4), *((float *)this + 5), 0.0, 0.0);
  (*(void (**)(HGGradient *, uint64_t, float, float, double, double))(*(void *)v6 + 96))(v6, 2, *((float *)this + 6), *((float *)this + 7), 0.0, 0.0);
  float v8 = *((double *)this + 6);
  float v9 = *((double *)this + 7);
  float v10 = *((double *)this + 9);
  (*(void (**)(HGGradient *, uint64_t, float, float, double, float))(*(void *)v6 + 96))(v6, 3, v8, v9, 0.0, v10);
  float v11 = *((double *)this + 10);
  float v12 = *((double *)this + 11);
  float v13 = *((double *)this + 13);
  (*(void (**)(HGGradient *, uint64_t, float, float, double, float))(*(void *)v6 + 96))(v6, 4, v11, v12, 0.0, v13);
  float v14 = *((double *)this + 18);
  float v15 = *((double *)this + 19);
  float v16 = *((double *)this + 21);
  (*(void (**)(HGGradient *, uint64_t, float, float, double, float))(*(void *)v6 + 96))(v6, 5, v14, v15, 0.0, v16);
  OZGradient1D::getHeliumLUT(this, a2, &v19);
  float v17 = v19;
  uint64_t result = (*(uint64_t (**)(HGGradient *, void, HGColorConform *))(*(void *)v6 + 120))(v6, 0, v19);
  *a3 = v6;
  if (v17) {
    return (*(uint64_t (**)(HGColorConform *))(*(void *)v17 + 24))(v17);
  }
  return result;
}

void sub_1B7E3FE78(_Unwind_Exception *a1)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void OZGradientRadial::OZGradientRadial(OZGradientRadial *this, OZChannelGradient *a2, CGColorSpace *a3, CGColorSpace *a4)
{
  *((void *)this + 34) = &unk_1F1199AC8;
  *((void *)this + 35) = 0;
  *((unsigned char *)this + 288) = 1;
  OZGradient1D::OZGradient1D(this, (OZChannelGradient *)off_1F1199778, (uint64_t)a2, a3, (uint64_t)a4);
  *(void *)this = &unk_1F1199700;
  *((void *)this + 34) = &unk_1F1199758;
  *((_WORD *)this + 104) = 0;
  PCColor::PCColor((PCColor *)((char *)this + 216));
}

void sub_1B7E3FFBC(_Unwind_Exception *a1)
{
  OZGradient::~OZGradient((OZGradient *)v1, (uint64_t *)off_1F1199780);
  *(void *)(v1 + 272) = v2;
  *(unsigned char *)(v1 + 288) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 280));
  _Unwind_Resume(a1);
}

uint64_t OZGradientRadial::OZGradientRadial(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 272) = &unk_1F1199AC8;
  *(void *)(a1 + 280) = 0;
  *(unsigned char *)(a1 + 288) = 1;
  OZGradient1D::OZGradient1D((void *)a1, (uint64_t *)off_1F1199778, (void *)a2);
  *(void *)a1 = &unk_1F1199700;
  *(void *)(a1 + 272) = &unk_1F1199758;
  *(_WORD *)(a1 + 208) = *(_WORD *)(a2 + 208);
  long long v4 = *(_OWORD *)(a2 + 216);
  long long v5 = *(_OWORD *)(a2 + 232);
  *(_OWORD *)(a1 + 248) = *(_OWORD *)(a2 + 248);
  *(_OWORD *)(a1 + 232) = v5;
  *(_OWORD *)(a1 + 216) = v4;
  uint64_t v6 = *(CGColorSpace **)(a2 + 264);
  *(void *)(a1 + 264) = v6;
  if (v6) {
    PCCFRefTraits<CGColorSpace *>::retain(v6);
  }
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  return a1;
}

void sub_1B7E400CC(_Unwind_Exception *a1)
{
  OZGradient::~OZGradient((OZGradient *)v1, (uint64_t *)off_1F1199780);
  *(void *)(v1 + 272) = v2;
  *(unsigned char *)(v1 + 288) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 280));
  _Unwind_Resume(a1);
}

void OZGradientRadial::~OZGradientRadial(CGColorSpace **this, void *a2)
{
  long long v4 = (CGColorSpace *)*a2;
  *this = (CGColorSpace *)*a2;
  *(CGColorSpace **)((char *)this + *((void *)v4 - 3)) = (CGColorSpace *)a2[7];
  PCCFRef<CGColorSpace *>::~PCCFRef(this + 33);

  OZGradient::~OZGradient((OZGradient *)this, a2 + 2);
}

void OZGradientRadial::~OZGradientRadial(CGColorSpace **this)
{
  *(void *)(v1 + 272) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 288) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 280));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 272) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 288) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 280));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'OZGradientRadial::~OZGradientRadial(OZGradientRadial *this)
{
  *(void *)(v1 + 272) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 288) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 280);

  PCWeakCount::~PCWeakCount(v2);
}

{
  OZGradientRadial::~OZGradientRadial((CGColorSpace **)((char *)this + *(void *)(*(void *)this - 24)));
}

void OZGradientRadial::getHash(OZGradientRadial *this, CMTime *a2)
{
  MEMORY[0x1F4188790](this);
  uint64_t v3 = v2;
  long long v5 = v4;
  v7[520] = *(int8x8_t *)MEMORY[0x1E4F143B8];
  OZChannelGradient::getGradientHash(*(void *)(v2 + 32));
  PCHashWriteStream::PCHashWriteStream((PCHashWriteStream *)v7);
  PCHashWriteStream::writeValue(v7, *(unsigned char *)(v3 + 208));
  PCHashWriteStream::writeValue(v7, *(unsigned char *)(v3 + 209));
  Hash = PCHashWriteStream::getHash(v7);
  PCHash128::operator+=(v5, (int *)Hash);
  PCHashWriteStream::~PCHashWriteStream((PCHashWriteStream *)v7);
}

void sub_1B7E4041C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t OZGradientRadial::update(OZGradientRadial *this, CMTime *a2)
{
  CMTime v16 = *a2;
  uint64_t v3 = OZGradient::update(this, &v16);
  if (v3)
  {
    if (*((unsigned char *)this + 208))
    {
      uint64_t v4 = *((void *)this + 1);
      unsigned int v5 = ((double)*(int *)(v4 + 12) * 0.25);
      if (v5)
      {
        uint64_t v6 = (_DWORD *)(*(void *)(v4 + 24) + 12);
        __asm { FMOV            V0.2S, #1.0 }
        do
        {
          *((void *)v6 - 1) = _D0;
          *uint64_t v6 = 1065353216;
          v6 += 4;
          --v5;
        }
        while (v5);
      }
    }
    if (*((unsigned char *)this + 209))
    {
      float v12 = (_DWORD *)(*(void *)(*((void *)this + 1) + 24)
                     + 4 * (4 * ((double)*(int *)(*((void *)this + 1) + 12) * 0.25) - 4));
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      PCColor::getRGBA((PCColor *)((char *)this + 216), (float *)&v15 + 1, (float *)&v15, (float *)&v14 + 1, (float *)&v14, *((CGColorSpace **)this + 25));
      *float v12 = HIDWORD(v15);
      v12[1] = v15;
      v12[2] = HIDWORD(v14);
      void v12[3] = v14;
    }
  }
  return v3;
}

uint64_t OZGradientRadial::getHeliumGradientTexture@<X0>(OZGradientRadial *this@<X0>, CGColorSpace *a2@<X1>, HGGradient **a3@<X8>)
{
  double v6 = *((double *)this + 22);
  float v8 = *((float *)this + 6);
  float v7 = *((float *)this + 7);
  float v10 = *((float *)this + 4);
  float v9 = *((float *)this + 5);
  float v11 = (HGGradient *)HGObject::operator new(0x210uLL);
  HGGradient::HGGradient(v11);
  HGGradient::SetGradientMode((uint64_t)v11, 1);
  float v12 = *((double *)this + 22);
  (*(void (**)(HGGradient *, void, float, float, float, float))(*(void *)v11 + 96))(v11, 0, v12, 1.0, 1.0, 1.0);
  float v13 = *((double *)this + 22) * *((float *)this + 4);
  (*(void (**)(HGGradient *, uint64_t, float, float, double, double))(*(void *)v11 + 96))(v11, 1, v13, *((float *)this + 5), 0.0, 0.0);
  float v14 = sqrt(v6 * (float)(v8 - v10) * (v6 * (float)(v8 - v10)) + (float)(v7 - v9) * (float)(v7 - v9));
  (*(void (**)(HGGradient *, uint64_t, float, double, double, double))(*(void *)v11 + 96))(v11, 2, fabsf(v14), 0.0, 0.0, 0.0);
  float v15 = *((double *)this + 6);
  float v16 = *((double *)this + 7);
  float v17 = *((double *)this + 9);
  (*(void (**)(HGGradient *, uint64_t, float, float, double, float))(*(void *)v11 + 96))(v11, 3, v15, v16, 0.0, v17);
  float v18 = *((double *)this + 10);
  float v19 = *((double *)this + 11);
  float v20 = *((double *)this + 13);
  (*(void (**)(HGGradient *, uint64_t, float, float, double, float))(*(void *)v11 + 96))(v11, 4, v18, v19, 0.0, v20);
  float v21 = *((double *)this + 18);
  float v22 = *((double *)this + 19);
  float v23 = *((double *)this + 21);
  (*(void (**)(HGGradient *, uint64_t, float, float, double, float))(*(void *)v11 + 96))(v11, 5, v21, v22, 0.0, v23);
  uint64_t v24 = HGRectMake4i(0, 0, ((double)*(int *)(*((void *)this + 1) + 12) * 0.25), 1u);
  uint64_t v26 = v25;
  uint64_t v27 = *((void *)this + 1);
  uint64_t v28 = *(void *)(v27 + 24);
  uint64_t v29 = *(unsigned int *)(v27 + 16);
  char v30 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v30, v24, v26, 28, v28, v29, v29);
  HGBitmap::SetStorage(v30, *((HGObject **)this + 1));
  double v31 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v31, v30);
  double v35 = v31;
  float v32 = v34;
  if (v31 == v34)
  {
    if (v31)
    {
      (*(void (**)(HGBitmapLoader *))(*(void *)v31 + 24))(v31);
      float v32 = v31;
    }
    else
    {
      float v32 = 0;
    }
  }
  else
  {
    if (v31) {
      (*(void (**)(HGBitmapLoader *))(*(void *)v31 + 24))(v31);
    }
    float v34 = 0;
    double v35 = v32;
  }
  uint64_t result = (*(uint64_t (**)(HGGradient *, void, HGColorConform *))(*(void *)v11 + 120))(v11, 0, v32);
  *a3 = v11;
  if (v32) {
    uint64_t result = (*(uint64_t (**)(HGColorConform *))(*(void *)v32 + 24))(v32);
  }
  if (v30) {
    return (*(uint64_t (**)(HGBitmap *))(*(void *)v30 + 24))(v30);
  }
  return result;
}

void sub_1B7E40934(_Unwind_Exception *a1)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void OZGradientGroupShader::OZGradientGroupShader(OZGradientGroupShader *this, OZChannelGradientExtras *a2, CGColorSpace *a3, double a4)
{
  *(void *)this = a2;
  operator new();
}

void sub_1B7E40B1C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C406B4B8A35);
  _Unwind_Resume(a1);
}

void OZGradientGroupShader::~OZGradientGroupShader(OZGradientGroupShader *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 1) = 0;
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *((void *)this + 2) = 0;
}

uint64_t OZGradientGroupShader::update(OZGradientGroupShader *this, CMTime *a2)
{
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(*(void *)this + 800), a2, 0.0);
  uint64_t v5 = 16;
  if (!ValueAsInt) {
    uint64_t v5 = 8;
  }
  uint64_t v6 = *(void *)((char *)this + v5);
  *((void *)this + 3) = v6;
  long long v8 = *(_OWORD *)&a2->value;
  CMTimeEpoch epoch = a2->epoch;
  return (*(uint64_t (**)(uint64_t, long long *))(*(void *)v6 + 24))(v6, &v8);
}

uint64_t OZGradientGroupShader::updateWithXForm(void *a1, const CMTime *a2, _OWORD *a3)
{
  int ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(*a1 + 800), a2, 0.0);
  uint64_t v7 = 2;
  if (!ValueAsInt) {
    uint64_t v7 = 1;
  }
  long long v8 = (float *)a1[v7];
  a1[3] = v8;
  if (*a1)
  {
    if (v9)
    {
      float v10 = v9;
      OZChannel::getValueAsDouble((OZChannel *)(v9 + 1192), a2, 0.0);
      double v12 = v11;
      OZChannel::getValueAsDouble((OZChannel *)(v10 + 1344), a2, 0.0);
      double v14 = v13;
      OZChannel::getValueAsDouble((OZChannel *)(v10 + 1896), a2, 0.0);
      double v16 = v15;
      OZChannel::getValueAsDouble((OZChannel *)(v10 + 2048), a2, 0.0);
      long long v8 = (float *)a1[3];
      if (a3)
      {
        long long v18 = a3[5];
        long long v34 = a3[4];
        *(_OWORD *)double v35 = v18;
        long long v19 = a3[7];
        *(_OWORD *)&v35[16] = a3[6];
        *(_OWORD *)&v35[32] = v19;
        long long v20 = a3[1];
        *(_OWORD *)float v32 = *a3;
        *(_OWORD *)&v32[16] = v20;
        long long v21 = a3[3];
        *(_OWORD *)&v32[32] = a3[2];
        long long v33 = v21;
      }
      else
      {
        *(void *)&v35[40] = 0x3FF0000000000000;
        *(void *)double v35 = 0x3FF0000000000000;
        *(void *)&v32[40] = 0x3FF0000000000000;
        *(void *)float v32 = 0x3FF0000000000000;
        memset(&v32[8], 0, 32);
        long long v33 = 0u;
        long long v34 = 0u;
        memset(&v35[8], 0, 32);
      }
      for (uint64_t i = 0; i != 32; i += 8)
      {
        float v23 = &v8[i];
        long long v24 = *(_OWORD *)&v32[i * 4 + 16];
        *((_OWORD *)v23 + 3) = *(_OWORD *)&v32[i * 4];
        *((_OWORD *)v23 + 4) = v24;
      }
      float v25 = v12;
      float v26 = v14;
      v8[4] = v25;
      _OWORD v8[5] = v26;
      float v27 = v16;
      float v28 = v17;
      v8[6] = v27;
      v8[7] = v28;
    }
  }
  long long v30 = *(_OWORD *)&a2->value;
  CMTimeEpoch epoch = a2->epoch;
  return (*(uint64_t (**)(float *, long long *))(*(void *)v8 + 24))(v8, &v30);
}

void PCShared::~PCShared(PCShared *this)
{
  *((void *)this + 1) = &unk_1F1199AC8;
  *((unsigned char *)this + 24) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 2);
}

{
  uint64_t vars8;

  *((void *)this + 1) = &unk_1F1199AC8;
  *((unsigned char *)this + 24) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 2);

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'PCShared::~PCShared(PCShared *this)
{
  uint64_t v1 = (char *)this + *(void *)(*(void *)this - 24);
  *((void *)v1 + 1) = &unk_1F1199AC8;
  v1[24] = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)v1 + 2);
}

{
  char *v1;
  uint64_t vars8;

  uint64_t v1 = (char *)this + *(void *)(*(void *)this - 24);
  *((void *)v1 + 1) = &unk_1F1199AC8;
  v1[24] = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)v1 + 2);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PCShared_base::dispose(uint64_t this)
{
  if (this) {
    return (*(uint64_t (**)(void))(*(void *)this + 8))();
  }
  return this;
}

void PCShared_base::~PCShared_base(PCShared_base *this)
{
  *(void *)this = &unk_1F1199AC8;
  *((unsigned char *)this + 16) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 1);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F1199AC8;
  *((unsigned char *)this + 16) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 1);

  JUMPOUT(0x1BA9BFBA0);
}

void PCWeakCount::~PCWeakCount(PC_Sp_counted_base **this)
{
  uint64_t v1 = *this;
  if (v1) {
    PC_Sp_counted_base::weak_release(v1);
  }
}

const char *HgcShapeSoftEdgeColorizeSecondPass::GetProgram(HgcShapeSoftEdgeColorizeSecondPass *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000023e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    output.color0 = float4(r0.xxxx)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=7dc50da6:bd1ed7f1:a3dcbc7d:50cc653d\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000231\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    output.color0 = r0.xxxx*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=0bc76ed3:09c436ca:6d851111:8bb685f7\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001ff\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    gl_FragColor = r0.xxxx*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=b131b046:6e0ac2f3:4508da6a:0c8907d8\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcShapeSoftEdgeColorizeSecondPass::InitProgramDescriptor(HgcShapeSoftEdgeColorizeSecondPass *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcShapeSoftEdgeColorizeSecondPass_hgc_visible", "//Metal1.0     \n//LEN=000000011d\n[[ visible ]] FragmentOut HgcShapeSoftEdgeColorizeSecondPass_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = color0.x;\n"
    "    output.color0 = r0.xxxx*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcShapeSoftEdgeColorizeSecondPass");
}

void sub_1B7E41200(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75770;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  long long v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7E41300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7E41340()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7E41338);
}

void *HgcShapeSoftEdgeColorizeSecondPass::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcShapeSoftEdgeColorizeSecondPass [hgc1]");
}

uint64_t HgcShapeSoftEdgeColorizeSecondPass::BindTexture(HgcShapeSoftEdgeColorizeSecondPass *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcShapeSoftEdgeColorizeSecondPass::Bind(HgcShapeSoftEdgeColorizeSecondPass *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcShapeSoftEdgeColorizeSecondPass::RenderTile(HgcShapeSoftEdgeColorizeSecondPass *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 22);
    uint64_t v8 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v16) = 0;
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = 32;
        do
        {
          float32x4_t v11 = *(float32x4_t *)*((void *)this + 62);
          float32x4_t v12 = vmulq_n_f32(v11, COERCE_FLOAT(*(_OWORD *)(v6 + v10 - 16)));
          float32x4_t v13 = vmulq_n_f32(v11, COERCE_FLOAT(*(_OWORD *)(v6 + v10)));
          float32x4_t v14 = vmulq_n_f32(v11, COERCE_FLOAT(*(_OWORD *)(v6 + v10 + 16)));
          double v15 = (float32x4_t *)(v5 + v10);
          v15[-2] = vmulq_n_f32(v11, COERCE_FLOAT(*(_OWORD *)(v6 + v10 - 32)));
          v15[-1] = v12;
          float32x4_t *v15 = v13;
          v15[1] = v14;
          v9 -= 4;
          v10 += 64;
        }
        while (v4 + v9 > 3);
        LODWORD(v16) = -v9;
      }
      if ((int)v16 < v4)
      {
        uint64_t v16 = v16;
        do
        {
          *(float32x4_t *)(v5 + 16 * v16) = vmulq_n_f32(*(float32x4_t *)*((void *)this + 62), COERCE_FLOAT(*(_OWORD *)(v6 + 16 * v16)));
          ++v16;
        }
        while (v16 < v4);
      }
      ++v3;
      v6 += v7;
      v5 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcShapeSoftEdgeColorizeSecondPass::GetDOD(HgcShapeSoftEdgeColorizeSecondPass *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcShapeSoftEdgeColorizeSecondPass::GetROI(HgcShapeSoftEdgeColorizeSecondPass *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcShapeSoftEdgeColorizeSecondPass::HgcShapeSoftEdgeColorizeSecondPass(HgcShapeSoftEdgeColorizeSecondPass *this)
{
}

void sub_1B7E416C0(_Unwind_Exception *a1)
{
  HGColorMatrix::~HGColorMatrix(v1);
  _Unwind_Resume(a1);
}

void HgcShapeSoftEdgeColorizeSecondPass::~HgcShapeSoftEdgeColorizeSecondPass(HgcShapeSoftEdgeColorizeSecondPass *this)
{
  *(void *)this = &unk_1F1199AF0;
  uint64_t v2 = *((void *)this + 62);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40265AC83CLL);
  }

  HGColorMatrix::~HGColorMatrix(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcShapeSoftEdgeColorizeSecondPass::~HgcShapeSoftEdgeColorizeSecondPass(this);

  HGObject::operator delete(v1);
}

uint64_t HgcShapeSoftEdgeColorizeSecondPass::SetParameter(HgcShapeSoftEdgeColorizeSecondPass *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 62);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  uint64_t v7 = 1;
  *((_DWORD *)this + 126) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return v7;
}

float HgcShapeSoftEdgeColorizeSecondPass::GetParameter(HgcShapeSoftEdgeColorizeSecondPass *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 62);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

HGNode *HgcShapeSoftEdgeColorizeSecondPass::GetOutput(__n128 *this, HGRenderer *a2, __n128 a3, __n128 a4, int32x2_t a5)
{
  if (this[31].n128_u32[2])
  {
    unint64_t v5 = this[31].n128_u64[0];
    *(double *)&a5 = 0.0;
    a4 = (__n128)vmulq_f32(*(float32x4_t *)v5, (float32x4_t)0);
    *(float32x4_t *)(v5 + 16) = vmulq_n_f32(*(float32x4_t *)v5, COERCE_FLOAT(*(_OWORD *)(v5 + 80)));
    *(__n128 *)(this[31].n128_u64[0] + 32) = a4;
    *(__n128 *)(this[31].n128_u64[0] + 48) = a4;
    *(__n128 *)(this[31].n128_u64[0] + 64) = a4;
    uint64_t v6 = (__n128 *)this[31].n128_u64[0];
    this[27] = v6[1];
    this[28] = v6[2];
    this[29] = v6[3];
    a3 = v6[4];
    this[30] = a3;
    this[31].n128_u32[2] = 0;
  }
  return HGColorMatrix::GetOutput((HGColorMatrix *)this, a2, a3.n128_f64[0], a4.n128_f64[0], a5);
}

const char *HgcShapeSoftEdgeSubtractAlpha::GetProgram(HgcShapeSoftEdgeSubtractAlpha *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000030a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1.w = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).w;\n"
             "    r0.w = r0.w - r1.w;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8e212562:2be34449:a55b7522:a773cb44\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002f6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1.w = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).w;\n"
             "    r0.w = r0.w - r1.w;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2ccb5981:f6d6baf5:874983b9:e721a7c3\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000274\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1.w = texture2D(hg_Texture0, hg_TexCoord0.xy).w;\n"
           "    r0.w = r0.w - r1.w;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=97b858b6:94e2926a:b6feeb87:128df125\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcShapeSoftEdgeSubtractAlpha::InitProgramDescriptor(HgcShapeSoftEdgeSubtractAlpha *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcShapeSoftEdgeSubtractAlpha_hgc_visible", "//Metal1.0     \n//LEN=0000000162\n[[ visible ]] FragmentOut HgcShapeSoftEdgeSubtractAlpha_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r1.w = color0.w;\n"
    "    r0.w = r0.w - r1.w;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcShapeSoftEdgeSubtractAlpha");
}

void sub_1B7E419A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E757E0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  long long v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7E41AE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7E41B28()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7E41B20);
}

void *HgcShapeSoftEdgeSubtractAlpha::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcShapeSoftEdgeSubtractAlpha [hgc1]");
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::BindTexture(HgcShapeSoftEdgeSubtractAlpha *this, HGHandler *a2, int a3)
{
  if (a3)
  {
    if (a3 != 1) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::Bind(HgcShapeSoftEdgeSubtractAlpha *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::RenderTile(HgcShapeSoftEdgeSubtractAlpha *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 26);
    uint64_t v8 = *((void *)a2 + 12);
    uint64_t v9 = 16 * *((int *)a2 + 22);
    uint64_t v10 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v27) = 0;
      }
      else
      {
        int v11 = 0;
        uint64_t v12 = 32;
        do
        {
          float32x4_t v13 = *(float32x4_t *)(v8 + v12 - 32);
          float32x4_t v14 = *(float32x4_t *)(v8 + v12 - 16);
          float32x4_t v15 = *(float32x4_t *)(v8 + v12);
          float32x4_t v16 = *(float32x4_t *)(v8 + v12 + 16);
          int8x16_t v17 = (int8x16_t)vsubq_f32(v13, *(float32x4_t *)(v6 + v12 - 32));
          int8x16_t v18 = (int8x16_t)vsubq_f32(v14, *(float32x4_t *)(v6 + v12 - 16));
          int8x16_t v19 = (int8x16_t)vsubq_f32(v15, *(float32x4_t *)(v6 + v12));
          int8x16_t v20 = (int8x16_t)vsubq_f32(v16, *(float32x4_t *)(v6 + v12 + 16));
          int8x16_t v21 = *(int8x16_t *)*((void *)this + 51);
          float32x4_t v22 = (float32x4_t)vbslq_s8(v21, v17, (int8x16_t)v13);
          float32x4_t v23 = (float32x4_t)vbslq_s8(v21, v18, (int8x16_t)v14);
          float32x4_t v24 = (float32x4_t)vbslq_s8(v21, v19, (int8x16_t)v15);
          float32x4_t v25 = (float32x4_t)vbslq_s8(v21, v20, (int8x16_t)v16);
          float v26 = (int8x16_t *)(v5 + v12);
          v26[-2] = vbslq_s8(v21, v17, (int8x16_t)vmulq_laneq_f32(v22, v22, 3));
          v26[-1] = vbslq_s8(v21, v18, (int8x16_t)vmulq_laneq_f32(v23, v23, 3));
          *float v26 = vbslq_s8(v21, v19, (int8x16_t)vmulq_laneq_f32(v24, v24, 3));
          v26[1] = vbslq_s8(v21, v20, (int8x16_t)vmulq_laneq_f32(v25, v25, 3));
          v11 -= 4;
          v12 += 64;
        }
        while (v4 + v11 > 3);
        LODWORD(v27) = -v11;
      }
      if ((int)v27 < v4)
      {
        uint64_t v27 = v27;
        do
        {
          float32x4_t v28 = *(float32x4_t *)(v8 + 16 * v27);
          int8x16_t v29 = (int8x16_t)vsubq_f32(v28, *(float32x4_t *)(v6 + 16 * v27));
          int8x16_t v30 = *(int8x16_t *)*((void *)this + 51);
          float32x4_t v31 = (float32x4_t)vbslq_s8(v30, v29, (int8x16_t)v28);
          *(int8x16_t *)(v5 + 16 * v27++) = vbslq_s8(v30, v29, (int8x16_t)vmulq_laneq_f32(v31, v31, 3));
        }
        while (v27 < v4);
      }
      ++v3;
      v8 += v7;
      v6 += v9;
      v5 += v10;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::GetDOD(HgcShapeSoftEdgeSubtractAlpha *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::GetROI(HgcShapeSoftEdgeSubtractAlpha *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcShapeSoftEdgeSubtractAlpha::HgcShapeSoftEdgeSubtractAlpha(HgcShapeSoftEdgeSubtractAlpha *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F1199D68;
  operator new();
}

void sub_1B7E41EF8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcShapeSoftEdgeSubtractAlpha::~HgcShapeSoftEdgeSubtractAlpha(HGNode *this)
{
  *(void *)this = &unk_1F1199D68;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcShapeSoftEdgeSubtractAlpha::~HgcShapeSoftEdgeSubtractAlpha(this);

  HGObject::operator delete(v1);
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::SetParameter(HgcShapeSoftEdgeSubtractAlpha *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::GetParameter(HgcShapeSoftEdgeSubtractAlpha *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcShapeSoftEdgeClr::GetProgram(HgcShapeSoftEdgeClr *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002d0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = half2(frag._texCoord0.xy)/half2(frag._texCoord0.ww);\n"
             "    r0.xy = r0.xy + half2(hg_Params[5].xy);\n"
             "    r0.xy = r0.xy*half2(hg_Params[5].zw);\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, float2(r0.xy)).x;\n"
             "    output.color0 = float4(r0.xxxx)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=fa47e8dc:4e19468c:97518949:b262ea97\n"
             "//SIG=02400000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000029f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy/frag._texCoord0.ww;\n"
             "    r0.xy = r0.xy + hg_Params[5].xy;\n"
             "    r0.xy = r0.xy*hg_Params[5].zw;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, r0.xy).x;\n"
             "    output.color0 = r0.xxxx*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=f2684eb6:17faaf05:9b5c2070:8c3af7e8\n"
             "//SIG=02000000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000325\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy/hg_TexCoord0.ww;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal5.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal5.zw;\n"
           "    r0.x = texture2D(hg_Texture0, r0.xy).x;\n"
           "    gl_FragColor = r0.xxxx*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=e4d40c06:c2e5521c:3841fc93:3af28a0f\n"
           "//SIG=02000000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcShapeSoftEdgeClr::InitProgramDescriptor(HgcShapeSoftEdgeClr *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcShapeSoftEdgeClr_hgc_visible", "//Metal1.0     \n//LEN=00000001df\n[[ visible ]] FragmentOut HgcShapeSoftEdgeClr_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy/texCoord0.ww;\n"
    "    r0.xy = r0.xy + hg_Params[5].xy;\n"
    "    r0.xy = r0.xy*hg_Params[5].zw;\n"
    "    r0.x = hg_Texture0.sample(hg_Sampler0, r0.xy).x;\n"
    "    output.color0 = r0.xxxx*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcShapeSoftEdgeClr");
}

void sub_1B7E420CC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E76910;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  long long v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7E4224C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7E4229C()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7E42294);
}

void *HgcShapeSoftEdgeClr::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcShapeSoftEdgeClr [hgc1]");
}

uint64_t HgcShapeSoftEdgeClr::BindTexture(HgcShapeSoftEdgeClr *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 5, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcShapeSoftEdgeClr::Bind(HgcShapeSoftEdgeClr *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcShapeSoftEdgeClr::RenderFragment(uint64_t a1, float32x4_t *a2, int32x2_t *a3)
{
  *(float32x2_t *)v3.f32 = vadd_f32(vcvt_f32_s32(*a3), (float32x2_t)0x3F0000003F000000);
  v3.i64[1] = 0x3F80000000000000;
  float32x4_t v4 = a2[1];
  float32x4_t v5 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 3);
  __n128 v6 = *(float32x4_t **)(a1 + 408);
  float32x4_t v7 = v6[9];
  float32x4_t v8 = v6[10];
  float32x4_t v9 = vminq_f32(vmaxq_f32(vrecpeq_f32(v5), v7), v8);
  float32x4_t v10 = vminq_f32(vmaxq_f32(vmulq_f32(v9, vrecpsq_f32(v5, v9)), v7), v8);
  uint64_t v11 = a3[11].i32[0];
  float32x4_t v12 = vsubq_f32(vmulq_f32(v4, vmulq_f32(v10, vrecpsq_f32(v5, v10))), v3);
  int32x4_t v13 = vaddq_s32(vcvtq_s32_f32(v12), vcltzq_f32(v12));
  v12.i64[0] = vsubq_f32(v12, vcvtq_f32_s32(v13)).u64[0];
  float32x4_t v14 = (float32x4_t *)(*(void *)&a3[10] + 16 * (v13.i32[0] + v13.i32[1] * (int)v11));
  float32x4_t v15 = vaddq_f32(*v14, vmulq_n_f32(vsubq_f32(v14[1], *v14), v12.f32[0]));
  *(float32x4_t *)*(void *)&a3[2] = vmulq_n_f32(*v6, vaddq_f32(v15, vmulq_lane_f32(vsubq_f32(vaddq_f32(v14[v11], vmulq_n_f32(vsubq_f32(v14[(int)v11 + 1], v14[v11]), v12.f32[0])), v15), *(float32x2_t *)v12.f32, 1)).f32[0]);
  return 0;
}

uint64_t HgcShapeSoftEdgeClr::RenderTile(HgcShapeSoftEdgeClr *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    int32x2_t v7 = a2[2];
    uint64_t v8 = 16 * a2[3].i32[0];
    float32x4_t v9 = v5;
    do
    {
      if (v6 >= 1)
      {
        uint64_t v10 = 0;
        float32x4_t v11 = v9;
        do
        {
          float32x4_t v12 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3);
          int32x4_t v13 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v14 = v13[9];
          float32x4_t v15 = v13[10];
          float32x4_t v16 = vminq_f32(vmaxq_f32(vrecpeq_f32(v12), v14), v15);
          float32x4_t v17 = vminq_f32(vmaxq_f32(vmulq_f32(v16, vrecpsq_f32(v12, v16)), v14), v15);
          uint64_t v18 = a2[11].i32[0];
          float32x4_t v19 = vsubq_f32(vmulq_f32(v11, vmulq_f32(v17, vrecpsq_f32(v12, v17))), v5);
          int32x4_t v20 = vaddq_s32(vcvtq_s32_f32(v19), vcltzq_f32(v19));
          v19.i64[0] = vsubq_f32(v19, vcvtq_f32_s32(v20)).u64[0];
          int8x16_t v21 = (float32x4_t *)(*(void *)&a2[10] + 16 * (v20.i32[0] + v20.i32[1] * (int)v18));
          float32x4_t v22 = vaddq_f32(*v21, vmulq_n_f32(vsubq_f32(v21[1], *v21), v19.f32[0]));
          *(float32x4_t *)(*(void *)&v7 + v10) = vmulq_n_f32(*v13, vaddq_f32(v22, vmulq_lane_f32(vsubq_f32(vaddq_f32(v21[v18], vmulq_n_f32(vsubq_f32(v21[(int)v18 + 1], v21[v18]), v19.f32[0])), v22), *(float32x2_t *)v19.f32, 1)).f32[0]);
          float32x4_t v11 = vaddq_f32(v11, (float32x4_t)xmmword_1B7E736B0);
          v10 += 16;
        }
        while (16 * v6 != v10);
      }
      float32x4_t v9 = vaddq_f32(v9, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      *(void *)&v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t HgcShapeSoftEdgeClr::GetDOD(HgcShapeSoftEdgeClr *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v8 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  float32x4_t v9 = (const HGTransform *)HGRectGrow(v6, v5, v8);
  uint64_t v11 = v10;
  HGTransform::HGTransform((HGTransform *)v17);
  HGTransform::LoadMatrixf(v17, (float32x2_t *)(*((void *)this + 51) + 16));
  HGTransform::Invert2D((HGTransform *)v17);
  float v13 = HGTransformUtils::MinW(v12);
  *(void *)&v18.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v11;
  uint64_t DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v17, v9, v18, 0.5, v13);
  uint64_t v4 = HGRectUnion(0, 0, DOD, v15);
  HGTransform::~HGTransform((HGTransform *)v17);
  return v4;
}

void sub_1B7E42864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HgcShapeSoftEdgeClr::GetROI(HgcShapeSoftEdgeClr *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = 0;
  if (!a3)
  {
    uint64_t v5 = *(void *)&a4.var2;
    unint64_t v6 = *(void *)&a4.var0;
    HGTransform::HGTransform((HGTransform *)v17);
    HGTransform::LoadMatrixf(v17, (float32x2_t *)(*((void *)this + 51) + 16));
    float v9 = HGTransformUtils::MinW(v8);
    *(void *)&v18.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v5;
    uint64_t ROI = HGTransformUtils::GetROI((HGTransformUtils *)v17, v6, v18, 0.5, v9);
    uint64_t v12 = HGRectUnion(0, 0, ROI, v11);
    uint64_t v14 = v13;
    HGTransform::~HGTransform((HGTransform *)v17);
    uint64_t v15 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    return HGRectGrow(v12, v14, v15);
  }
  return v4;
}

void sub_1B7E4295C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HgcShapeSoftEdgeClr::HgcShapeSoftEdgeClr(HgcShapeSoftEdgeClr *this)
{
  HGNode3D::HGNode3D(this);
  *(void *)uint64_t v1 = &unk_1F1199FD0;
  *(_DWORD *)(v1 + 416) = 1;
  operator new();
}

void sub_1B7E42A64(_Unwind_Exception *a1)
{
  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HgcShapeSoftEdgeClr::~HgcShapeSoftEdgeClr(HgcShapeSoftEdgeClr *this)
{
  *(void *)this = &unk_1F1199FD0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40C3A7E6FCLL);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcShapeSoftEdgeClr::~HgcShapeSoftEdgeClr(this);

  HGObject::operator delete(v1);
}

uint64_t HgcShapeSoftEdgeClr::SetParameter(HgcShapeSoftEdgeClr *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  *uint64_t v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  uint64_t v7 = 1;
  *((_DWORD *)this + 104) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return v7;
}

float HgcShapeSoftEdgeClr::GetParameter(HgcShapeSoftEdgeClr *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

double HgcShapeSoftEdgeClr::GetOutput(HgcShapeSoftEdgeClr *this, HGRenderer *a2)
{
  if (*((_DWORD *)this + 104))
  {
    uint64_t v2 = *((void *)this + 51);
    long long v3 = *(_OWORD *)(v2 + 96);
    *(_OWORD *)(v2 + 16) = *(unint64_t *)(v2 + 80);
    *(_OWORD *)(*((void *)this + 51) + 32) = (unint64_t)v3;
    *(_OWORD *)(*((void *)this + 51) + 48) = xmmword_1B7E736D0;
    double result = 0.0;
    *(_OWORD *)(*((void *)this + 51) + 64) = xmmword_1B7E734D0;
    *((_DWORD *)this + 104) = 0;
  }
  return result;
}

const char *HgcShapeAlphaBias::GetProgram(HgcShapeAlphaBias *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000331\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(9.999999975e-07, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = pow(r0.w, half(hg_Params[0].w));\n"
             "    r1.xyz = r0.xyz*r1.www;\n"
             "    r1.xyz = r1.xyz/r0.www;\n"
             "    r2.x = c0.x - r0.w;\n"
             "    output.color0 = select(float4(r0), float4(r1), float4(r2.xxxx) < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=036b020b:04d95457:27ac6026:fc832375\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000030f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(9.999999975e-07, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = pow(r0.w, hg_Params[0].w);\n"
             "    r1.xyz = r0.xyz*r1.www;\n"
             "    r1.xyz = r1.xyz/r0.www;\n"
             "    r2.x = c0.x - r0.w;\n"
             "    output.color0 = select(r0, r1, r2.xxxx < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=3faf21c0:d38a8a3c:f5168635:aedd7782\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000339\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(9.999999975e-07, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.w = pow(r0.w, hg_ProgramLocal0.w);\n"
           "    r1.xyz = r0.xyz*r1.www;\n"
           "    r1.xyz = r1.xyz/r0.www;\n"
           "    r2.x = c0.x - r0.w;\n"
           "    gl_FragColor = vec4(r2.x < 0.00000 ? r1.x : r0.x, r2.x < 0.00000 ? r1.y : r0.y, r2.x < 0.00000 ? r1.z : r"
           "0.z, r2.x < 0.00000 ? r1.w : r0.w);\n"
           "}\n"
           "//MD5=c47dd433:0bd6ec29:e56572fa:825df2b7\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcShapeAlphaBias::InitProgramDescriptor(HgcShapeAlphaBias *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcShapeAlphaBias_hgc_visible", "//Metal1.0     \n//LEN=00000001ea\n[[ visible ]] FragmentOut HgcShapeAlphaBias_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(9.999999975e-07, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.w = pow(r0.w, hg_Params[0].w);\n"
    "    r1.xyz = r0.xyz*r1.www;\n"
    "    r1.xyz = r1.xyz/r0.www;\n"
    "    r2.x = c0.x - r0.w;\n"
    "    output.color0 = select(r0, r1, r2.xxxx < 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcShapeAlphaBias");
}

void sub_1B7E42D2C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75770;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  long long v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7E42E2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7E42E6C()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7E42E64);
}

void *HgcShapeAlphaBias::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcShapeAlphaBias [hgc1]");
}

uint64_t HgcShapeAlphaBias::BindTexture(HgcShapeAlphaBias *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcShapeAlphaBias::Bind(HgcShapeAlphaBias *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcShapeAlphaBias::RenderTile(HgcShapeAlphaBias *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    do
    {
      if (v4 < 2)
      {
        unsigned int v64 = 0;
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = 16;
        do
        {
          float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
          float32x4_t v11 = *(float32x4_t *)(v6 + v10);
          uint64_t v13 = *((void *)this + 51);
          int8x16_t v14 = *(int8x16_t *)(v13 + 16);
          float32x4_t v15 = *(float32x4_t *)(v13 + 32);
          float32x4_t v16 = *(float32x4_t *)(v13 + 48);
          float32x4_t v17 = (float32x4_t)vorrq_s8(vandq_s8(v14, (int8x16_t)v12), (int8x16_t)v15);
          float32x4_t v18 = (float32x4_t)vorrq_s8(vandq_s8(v14, (int8x16_t)v11), (int8x16_t)v15);
          int8x16_t v19 = (int8x16_t)vcgtq_f32(v16, v12);
          int8x16_t v20 = *(int8x16_t *)(v13 + 64);
          float32x4_t v21 = *(float32x4_t *)(v13 + 80);
          float32x4_t v22 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v11, 0x17uLL)), (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v16, v11)));
          float32x4_t v23 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v12, 0x17uLL)), (float32x4_t)vandq_s8(v20, v19)), v21);
          float32x4_t v24 = *(float32x4_t *)(v13 + 96);
          float32x4_t v25 = *(float32x4_t *)(v13 + 112);
          float32x4_t v26 = vsubq_f32(v22, v21);
          float32x4_t v27 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v17, v24));
          float32x4_t v28 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v18, v24));
          float32x4_t v29 = vaddq_f32(v23, v27);
          float32x4_t v30 = vsubq_f32(vsubq_f32(v17, v15), vmulq_f32(vmulq_f32(v25, v27), v17));
          float32x4_t v31 = vsubq_f32(vsubq_f32(v18, v15), vmulq_f32(vmulq_f32(v25, v28), v18));
          float32x4_t v32 = *(float32x4_t *)(v13 + 128);
          float32x4_t v33 = *(float32x4_t *)(v13 + 144);
          float32x4_t v34 = vaddq_f32(v32, vmulq_f32(v33, v30));
          float32x4_t v35 = vaddq_f32(v32, vmulq_f32(v33, v31));
          float32x4_t v36 = *(float32x4_t *)(v13 + 160);
          float32x4_t v37 = *(float32x4_t *)(v13 + 176);
          float32x4_t v38 = vmulq_f32(*(float32x4_t *)v13, vaddq_f32(vaddq_f32(v26, v28), vmulq_f32(v31, vaddq_f32(vaddq_f32(v36, vmulq_f32(v31, v37)), vmulq_f32(vmulq_f32(v31, v31), v35)))));
          float32x4_t v39 = *(float32x4_t *)(v13 + 192);
          float32x4_t v40 = *(float32x4_t *)(v13 + 208);
          float32x4_t v41 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v13, vaddq_f32(v29, vmulq_f32(v30, vaddq_f32(vaddq_f32(v36, vmulq_f32(v30, v37)), vmulq_f32(vmulq_f32(v30, v30), v34))))), v39);
          float32x4_t v42 = vmaxq_f32(v38, v39);
          float32x4_t v43 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
          float32x4_t v44 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
          float32x4_t v45 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v43, v41)));
          float32x4_t v46 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v44, v42)));
          float32x4_t v47 = vsubq_f32(v41, v45);
          float32x4_t v48 = *(float32x4_t *)(v13 + 224);
          float32x4_t v49 = *(float32x4_t *)(v13 + 240);
          float32x4_t v50 = vsubq_f32(v42, v46);
          int32x4_t v51 = *(int32x4_t *)(v13 + 256);
          int8x16_t v52 = *(int8x16_t *)(v13 + 272);
          float32x4_t v53 = vmulq_f32(vaddq_f32(v15, vmulq_f32(v47, vaddq_f32(v49, vmulq_f32(v47, vaddq_f32(v40, vmulq_f32(v48, v47)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v51, vcvtq_s32_f32(v45)), 0x17uLL));
          float32x4_t v54 = vmulq_f32(vaddq_f32(v15, vmulq_f32(v50, vaddq_f32(v49, vmulq_f32(v50, vaddq_f32(v40, vmulq_f32(v48, v50)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v51, vcvtq_s32_f32(v46)), 0x17uLL));
          float32x4_t v55 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3);
          float32x4_t v56 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3);
          float32x4_t v57 = vmaxq_f32(vmulq_f32(v49, vrecpeq_f32(v55)), v48);
          float32x4_t v58 = vmaxq_f32(vmulq_f32(v49, vrecpeq_f32(v56)), v48);
          float32x4_t v59 = *(float32x4_t *)(v13 + 288);
          float32x4_t v60 = *(float32x4_t *)(v13 + 304);
          float32x4_t v61 = vminq_f32(v57, v59);
          float32x4_t v62 = vminq_f32(v58, v59);
          uint64_t v63 = (int8x16_t *)(v5 + v10);
          v63[-1] = vbslq_s8((int8x16_t)vcgtq_f32(v60, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(v40, v55), 0)), vbslq_s8(v52, (int8x16_t)v53, (int8x16_t)vmulq_f32(vmulq_f32(v61, vrecpsq_f32(v55, v61)), (float32x4_t)vbslq_s8(v52, (int8x16_t)v53, (int8x16_t)vmulq_laneq_f32(v12, v53, 3)))), (int8x16_t)v12);
          int8x16_t *v63 = vbslq_s8((int8x16_t)vcgtq_f32(v60, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(v40, v56), 0)), vbslq_s8(v52, (int8x16_t)v54, (int8x16_t)vmulq_f32(vmulq_f32(v62, vrecpsq_f32(v56, v62)), (float32x4_t)vbslq_s8(v52, (int8x16_t)v54, (int8x16_t)vmulq_laneq_f32(v11, v54, 3)))), (int8x16_t)v11);
          v9 -= 2;
          v10 += 32;
        }
        while (v4 + v9 > 1);
        unsigned int v64 = -v9;
      }
      if ((int)v64 < v4)
      {
        float32x4_t v65 = *(float32x4_t *)(v6 + 16 * v64);
        uint64_t v66 = *((void *)this + 51);
        float32x4_t v67 = *(float32x4_t *)(v66 + 32);
        float32x4_t v68 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v66 + 16), (int8x16_t)v65), (int8x16_t)v67);
        float32x4_t v69 = (float32x4_t)vandq_s8((int8x16_t)v67, (int8x16_t)vcgtq_f32(v68, *(float32x4_t *)(v66 + 96)));
        float32x4_t v70 = vsubq_f32(vsubq_f32(v68, v67), vmulq_f32(vmulq_f32(*(float32x4_t *)(v66 + 112), v69), v68));
        float32x4_t v71 = *(float32x4_t *)(v66 + 208);
        float32x4_t v72 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v66, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v65, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v66 + 64), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v66 + 48), v65))), *(float32x4_t *)(v66 + 80)), v69), vmulq_f32(v70, vaddq_f32(vaddq_f32(*(float32x4_t *)(v66 + 160), vmulq_f32(v70, *(float32x4_t *)(v66 + 176))), vmulq_f32(vmulq_f32(v70, v70), vaddq_f32(*(float32x4_t *)(v66 + 128), vmulq_f32(*(float32x4_t *)(v66 + 144), v70))))))),
                *(float32x4_t *)(v66 + 192));
        float32x4_t v73 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
        float32x4_t v74 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v67, (int8x16_t)vcgtq_f32(v73, v72)));
        float32x4_t v75 = vsubq_f32(v72, v74);
        float32x4_t v76 = *(float32x4_t *)(v66 + 224);
        float32x4_t v77 = *(float32x4_t *)(v66 + 240);
        float32x4_t v78 = vmulq_f32(vaddq_f32(v67, vmulq_f32(v75, vaddq_f32(v77, vmulq_f32(v75, vaddq_f32(v71, vmulq_f32(v76, v75)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v66 + 256), vcvtq_s32_f32(v74)), 0x17uLL));
        float32x4_t v79 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 3);
        float32x4_t v80 = vminq_f32(vmaxq_f32(vmulq_f32(v77, vrecpeq_f32(v79)), v76), *(float32x4_t *)(v66 + 288));
        *(int8x16_t *)(v5 + 16 * v64) = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(v66 + 304), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(v71, v79), 0)), vbslq_s8(*(int8x16_t *)(v66 + 272), (int8x16_t)v78, (int8x16_t)vmulq_f32(vmulq_f32(v80, vrecpsq_f32(v79, v80)), (float32x4_t)vbslq_s8(*(int8x16_t *)(v66 + 272), (int8x16_t)v78, (int8x16_t)vmulq_laneq_f32(v65, v78, 3)))), (int8x16_t)v65);
      }
      v6 += v8;
      v5 += v7;
      ++v3;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcShapeAlphaBias::GetDOD(HgcShapeAlphaBias *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcShapeAlphaBias::GetROI(HgcShapeAlphaBias *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcShapeAlphaBias::HgcShapeAlphaBias(HgcShapeAlphaBias *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F119A248;
  operator new();
}

void sub_1B7E43534(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcShapeAlphaBias::~HgcShapeAlphaBias(HGNode *this)
{
  *(void *)this = &unk_1F119A248;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4055B0EC01);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcShapeAlphaBias::~HgcShapeAlphaBias(this);

  HGObject::operator delete(v1);
}

uint64_t HgcShapeAlphaBias::SetParameter(HgcShapeAlphaBias *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (__n128 *)*((void *)this + 51);
  if (v8->n128_f32[0] == 0.0 && v8->n128_f32[1] == 0.0 && v8->n128_f32[2] == 0.0 && v8->n128_f32[3] == a3.n128_f32[0]) {
    return 0;
  }
  v8->n128_u64[0] = 0;
  v8->n128_u32[3] = a3.n128_u32[0];
  a3.n128_f32[1] = a4;
  v8->n128_u32[2] = 0;
  a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
  v8[20] = a3;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcShapeAlphaBias::GetParameter(HgcShapeAlphaBias *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = v3[80];
    a3[1] = v3[81];
    a3[2] = v3[82];
    float result = v3[83];
    a3[3] = result;
  }
  return result;
}

const char *HgcShapeSoftEdgeClrInPlace::GetProgram(HgcShapeSoftEdgeClrInPlace *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = half2(frag._texCoord0.xy)/half2(frag._texCoord0.ww);\n"
             "    r0.xy = r0.xy + half2(hg_Params[6].xy);\n"
             "    r0.xy = r0.xy*half2(hg_Params[6].zw);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, float2(r0.xy));\n"
             "    r0 = half4(hg_Params[0])*r0;\n"
             "    output.color0 = float4(r0)*hg_Params[1];\n"
             "    return output;\n"
             "}\n"
             "//MD5=20355668:a4f824fd:5c70d0dc:40dc3ff8\n"
             "//SIG=02400000:00000000:00000000:00000000:0000:0007:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002b0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy/frag._texCoord0.ww;\n"
             "    r0.xy = r0.xy + hg_Params[6].xy;\n"
             "    r0.xy = r0.xy*hg_Params[6].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r0 = hg_Params[0]*r0;\n"
             "    output.color0 = r0*hg_Params[1];\n"
             "    return output;\n"
             "}\n"
             "//MD5=cd0af800:73edd9a1:f1cd8bb5:754f2b15\n"
             "//SIG=02000000:00000000:00000000:00000000:0000:0007:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000035f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy/hg_TexCoord0.ww;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal6.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal6.zw;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r0 = hg_ProgramLocal0*r0;\n"
           "    gl_FragColor = r0*hg_ProgramLocal1;\n"
           "}\n"
           "//MD5=52d75abf:59af0be7:83a946b0:42b4e3ef\n"
           "//SIG=02000000:00000000:00000000:00000000:0000:0007:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcShapeSoftEdgeClrInPlace::InitProgramDescriptor(HgcShapeSoftEdgeClrInPlace *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcShapeSoftEdgeClrInPlace_hgc_visible", "//Metal1.0     \n//LEN=00000001f7\n[[ visible ]] FragmentOut HgcShapeSoftEdgeClrInPlace_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy/texCoord0.ww;\n"
    "    r0.xy = r0.xy + hg_Params[6].xy;\n"
    "    r0.xy = r0.xy*hg_Params[6].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r0 = hg_Params[0]*r0;\n"
    "    output.color0 = r0*hg_Params[1];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcShapeSoftEdgeClrInPlace");
}

void sub_1B7E437B8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E753B0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7E43938(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7E43988()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7E43980);
}

void *HgcShapeSoftEdgeClrInPlace::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcShapeSoftEdgeClrInPlace [hgc1]");
}

uint64_t HgcShapeSoftEdgeClrInPlace::BindTexture(HgcShapeSoftEdgeClrInPlace *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 6, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcShapeSoftEdgeClrInPlace::Bind(HgcShapeSoftEdgeClrInPlace *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcShapeSoftEdgeClrInPlace::RenderFragment(uint64_t a1, float32x4_t *a2, int32x2_t *a3)
{
  *(float32x2_t *)v3.f32 = vadd_f32(vcvt_f32_s32(*a3), (float32x2_t)0x3F0000003F000000);
  v3.i64[1] = 0x3F80000000000000;
  float32x4_t v4 = a2[1];
  float32x4_t v5 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 3);
  __n128 v6 = *(float32x4_t **)(a1 + 408);
  float32x4_t v7 = v6[10];
  float32x4_t v8 = v6[11];
  float32x4_t v9 = vminq_f32(vmaxq_f32(vrecpeq_f32(v5), v7), v8);
  float32x4_t v10 = vminq_f32(vmaxq_f32(vmulq_f32(v9, vrecpsq_f32(v5, v9)), v7), v8);
  uint64_t v11 = a3[11].i32[0];
  float32x4_t v12 = vsubq_f32(vmulq_f32(v4, vmulq_f32(v10, vrecpsq_f32(v5, v10))), v3);
  int32x4_t v13 = vaddq_s32(vcvtq_s32_f32(v12), vcltzq_f32(v12));
  v12.i64[0] = vsubq_f32(v12, vcvtq_f32_s32(v13)).u64[0];
  int8x16_t v14 = (float32x4_t *)(*(void *)&a3[10] + 16 * (v13.i32[0] + v13.i32[1] * (int)v11));
  float32x4_t v15 = vaddq_f32(*v14, vmulq_n_f32(vsubq_f32(v14[1], *v14), v12.f32[0]));
  *(float32x4_t *)*(void *)&a3[2] = vmulq_f32(v6[1], vmulq_f32(*v6, vaddq_f32(v15, vmulq_lane_f32(vsubq_f32(vaddq_f32(v14[v11], vmulq_n_f32(vsubq_f32(v14[(int)v11 + 1], v14[v11]), v12.f32[0])), v15), *(float32x2_t *)v12.f32, 1))));
  return 0;
}

uint64_t HgcShapeSoftEdgeClrInPlace::RenderTile(HgcShapeSoftEdgeClrInPlace *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    int32x2_t v7 = a2[2];
    uint64_t v8 = 16 * a2[3].i32[0];
    float32x4_t v9 = v5;
    do
    {
      if (v6 >= 1)
      {
        uint64_t v10 = 0;
        float32x4_t v11 = v9;
        do
        {
          float32x4_t v12 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3);
          int32x4_t v13 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v14 = v13[10];
          float32x4_t v15 = v13[11];
          float32x4_t v16 = vminq_f32(vmaxq_f32(vrecpeq_f32(v12), v14), v15);
          float32x4_t v17 = vminq_f32(vmaxq_f32(vmulq_f32(v16, vrecpsq_f32(v12, v16)), v14), v15);
          uint64_t v18 = a2[11].i32[0];
          float32x4_t v19 = vsubq_f32(vmulq_f32(v11, vmulq_f32(v17, vrecpsq_f32(v12, v17))), v5);
          int32x4_t v20 = vaddq_s32(vcvtq_s32_f32(v19), vcltzq_f32(v19));
          v19.i64[0] = vsubq_f32(v19, vcvtq_f32_s32(v20)).u64[0];
          float32x4_t v21 = (float32x4_t *)(*(void *)&a2[10] + 16 * (v20.i32[0] + v20.i32[1] * (int)v18));
          float32x4_t v22 = vaddq_f32(*v21, vmulq_n_f32(vsubq_f32(v21[1], *v21), v19.f32[0]));
          *(float32x4_t *)(*(void *)&v7 + v10) = vmulq_f32(v13[1], vmulq_f32(*v13, vaddq_f32(v22, vmulq_lane_f32(vsubq_f32(vaddq_f32(v21[v18], vmulq_n_f32(vsubq_f32(v21[(int)v18 + 1], v21[v18]), v19.f32[0])), v22), *(float32x2_t *)v19.f32, 1))));
          float32x4_t v11 = vaddq_f32(v11, (float32x4_t)xmmword_1B7E736B0);
          v10 += 16;
        }
        while (16 * v6 != v10);
      }
      float32x4_t v9 = vaddq_f32(v9, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      *(void *)&v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t HgcShapeSoftEdgeClrInPlace::GetDOD(HgcShapeSoftEdgeClrInPlace *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v8 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  float32x4_t v9 = (const HGTransform *)HGRectGrow(v6, v5, v8);
  uint64_t v11 = v10;
  HGTransform::HGTransform((HGTransform *)v17);
  HGTransform::LoadMatrixf(v17, (float32x2_t *)(*((void *)this + 51) + 32));
  HGTransform::Invert2D((HGTransform *)v17);
  float v13 = HGTransformUtils::MinW(v12);
  *(void *)&v18.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v11;
  uint64_t DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v17, v9, v18, 0.5, v13);
  uint64_t v4 = HGRectUnion(0, 0, DOD, v15);
  HGTransform::~HGTransform((HGTransform *)v17);
  return v4;
}

void sub_1B7E43F90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HgcShapeSoftEdgeClrInPlace::GetROI(HgcShapeSoftEdgeClrInPlace *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = 0;
  if (!a3)
  {
    uint64_t v5 = *(void *)&a4.var2;
    unint64_t v6 = *(void *)&a4.var0;
    HGTransform::HGTransform((HGTransform *)v17);
    HGTransform::LoadMatrixf(v17, (float32x2_t *)(*((void *)this + 51) + 32));
    float v9 = HGTransformUtils::MinW(v8);
    *(void *)&v18.$3CC8671D27C23BF42ADDB32F2B5E48AE var0 = v5;
    uint64_t ROI = HGTransformUtils::GetROI((HGTransformUtils *)v17, v6, v18, 0.5, v9);
    uint64_t v12 = HGRectUnion(0, 0, ROI, v11);
    uint64_t v14 = v13;
    HGTransform::~HGTransform((HGTransform *)v17);
    uint64_t v15 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    return HGRectGrow(v12, v14, v15);
  }
  return v4;
}

void sub_1B7E44088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HgcShapeSoftEdgeClrInPlace::HgcShapeSoftEdgeClrInPlace(HgcShapeSoftEdgeClrInPlace *this)
{
  HGNode3D::HGNode3D(this);
  *(void *)uint64_t v1 = &unk_1F119A4B0;
  *(_DWORD *)(v1 + 416) = 1;
  operator new();
}

void sub_1B7E44194(_Unwind_Exception *a1)
{
  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HgcShapeSoftEdgeClrInPlace::~HgcShapeSoftEdgeClrInPlace(HgcShapeSoftEdgeClrInPlace *this)
{
  *(void *)this = &unk_1F119A4B0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcShapeSoftEdgeClrInPlace::~HgcShapeSoftEdgeClrInPlace(this);

  HGObject::operator delete(v1);
}

uint64_t HgcShapeSoftEdgeClrInPlace::SetParameter(HgcShapeSoftEdgeClrInPlace *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *uint64_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  uint64_t v11 = 1;
  *((_DWORD *)this + 104) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return v11;
}

uint64_t HgcShapeSoftEdgeClrInPlace::GetParameter(HgcShapeSoftEdgeClrInPlace *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

double HgcShapeSoftEdgeClrInPlace::GetOutput(HgcShapeSoftEdgeClrInPlace *this, HGRenderer *a2)
{
  if (*((_DWORD *)this + 104))
  {
    uint64_t v2 = *((void *)this + 51);
    long long v3 = *(_OWORD *)(v2 + 112);
    *(_OWORD *)(v2 + 32) = *(unint64_t *)(v2 + 96);
    *(_OWORD *)(*((void *)this + 51) + 48) = (unint64_t)v3;
    *(_OWORD *)(*((void *)this + 51) + 64) = xmmword_1B7E736D0;
    double result = 0.0;
    *(_OWORD *)(*((void *)this + 51) + 80) = xmmword_1B7E734D0;
    *((_DWORD *)this + 104) = 0;
  }
  return result;
}

const char *HgcShapeGradientBlend::GetProgram(HgcShapeGradientBlend *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002de\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    output.color0 = float4(r0)*float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0df246b2:91c6b5d4:f02b9e9b:5bc3bb86\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002c1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    output.color0 = r0*r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=8c316191:1aca7ae1:745f6a82:ec814054\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000023f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    gl_FragColor = r0*r1;\n"
           "}\n"
           "//MD5=f3072827:20dc9050:204f7dc4:c2f25be5\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcShapeGradientBlend::InitProgramDescriptor(HgcShapeGradientBlend *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcShapeGradientBlend_hgc_visible", "//Metal1.0     \n//LEN=0000000125\n[[ visible ]] FragmentOut HgcShapeGradientBlend_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    output.color0 = r0*r1;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcShapeGradientBlend");
}

void sub_1B7E44480(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E757E0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7E445C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7E44608()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7E44600);
}

void *HgcShapeGradientBlend::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcShapeGradientBlend [hgc1]");
}

uint64_t HgcShapeGradientBlend::BindTexture(HgcShapeGradientBlend *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 1;
  }
  else
  {
    if (a3) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}