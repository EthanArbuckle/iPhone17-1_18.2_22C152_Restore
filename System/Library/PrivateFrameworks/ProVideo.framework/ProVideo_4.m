uint64_t HGMemory::allocate(HGMemory *this, unint64_t *a2, unint64_t *a3)
{
  char v6;
  char **v7;
  char *v8;

  if (atomic_load_explicit((atomic_ullong *volatile)&HGMemoryManager::INSTANCE(void)::flag, memory_order_acquire) != -1)
  {
    v8 = &v6;
    v7 = &v8;
    std::__call_once(&HGMemoryManager::INSTANCE(void)::flag, &v7, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>);
  }
  return HGMemoryManager::allocate((HGMemoryManager *)HGMemoryManager::INSTANCE(void)::mm, (unint64_t)this, a2);
}

uint64_t HGMemoryManager::allocate(HGMemoryManager *this, unint64_t a2, unint64_t *a3)
{
  v6 = (pthread_mutex_t *)((char *)this + 64);
  pthread_mutex_lock((pthread_mutex_t *)this + 1);
  HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(&v33, *((uint64_t **)this + 4));
  if (!*(void *)(*((void *)this + 3) + 40)) {
    goto LABEL_36;
  }
  unint64_t v7 = (*(uint64_t (**)(void, unint64_t))(**((void **)this + 1) + 24))(*((void *)this + 1), a2);
  if (v7 >= a2) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = 0;
  }
  if (v7 >= a2) {
    unint64_t v9 = a2;
  }
  else {
    unint64_t v9 = 0;
  }
  v10 = (void *)*((void *)this + 3);
  uint64_t v11 = v10[1];
  unint64_t v12 = v10[4];
  uint64_t v13 = v10[5];
  v14 = (char *)(v11 + 8 * (v12 >> 9));
  v15 = *(char **)v14;
  v16 = (char *)(*(void *)v14 + 8 * (v12 & 0x1FF));
  uint64_t v17 = *(void *)(v11 + (((v13 + v12) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v13 + v12) & 0x1FF);
  if (v16 != (char *)v17)
  {
    v18 = v14;
    v19 = v16 + 8;
    if (v16 + 8 - v15 != 4096) {
      goto LABEL_11;
    }
LABEL_10:
    v20 = (char *)*((void *)v18 + 1);
    v18 += 8;
    v15 = v20;
    v19 = v20;
LABEL_11:
    while (v19 != (char *)v17)
    {
      unint64_t v21 = *(void *)(*(void *)v16 + 16);
      if (v8 < v21 || v9 > v21) {
        unsigned int v23 = 0;
      }
      else {
        unsigned int v23 = v8 - v21;
      }
      unint64_t v24 = *(void *)(*(void *)v19 + 16);
      BOOL v26 = v9 <= v24 && v8 >= v24;
      if (v26 && v23 < (int)v8 - (int)v24)
      {
        v14 = v18;
        v16 = v19;
      }
      v19 += 8;
      if (v19 - v15 == 4096) {
        goto LABEL_10;
      }
    }
  }
  unint64_t v27 = *(void *)(*(void *)v16 + 16);
  BOOL v28 = v9 <= v27 && v8 >= v27;
  BOOL v29 = !v28 || v8 - v27 == 0;
  if (v29 || (uint64_t v30 = HGMemoryManager::_reuse((uint64_t)this, v14, v16, a2)) == 0) {
LABEL_36:
  }
    HGMemoryManager::_allocate(this);
  if (a3) {
    *a3 = *(void *)(v30 + 16);
  }
  uint64_t v31 = *(void *)(v30 + 8);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard(&v33);
  pthread_mutex_unlock(v6);
  return v31;
}

void sub_1B7701380(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard((void **)va);
  pthread_mutex_unlock(v2);
  _Unwind_Resume(a1);
}

pthread_mutex_t *HGMemory::release(HGMemory *this, void *a2)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&HGMemoryManager::INSTANCE(void)::flag, memory_order_acquire) != -1)
  {
    v6 = &v4;
    v5 = &v6;
    std::__call_once(&HGMemoryManager::INSTANCE(void)::flag, &v5, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>);
  }
  return HGMemoryManager::release((pthread_mutex_t *)HGMemoryManager::INSTANCE(void)::mm, this);
}

pthread_mutex_t *HGMemoryManager::release(pthread_mutex_t *this, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (uint64_t)this;
    char v4 = this + 1;
    pthread_mutex_lock(this + 1);
    ++*(void *)(v3 + 56);
    HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(&v28, *(uint64_t **)(v3 + 32));
    unint64_t v7 = *(void **)(v3 + 16);
    uint64_t v8 = v7[1];
    if (v7[2] == v8) {
      goto LABEL_12;
    }
    unint64_t v9 = v7[4];
    uint64_t v5 = v8 + 8 * (v9 >> 9);
    v6 = (char *)(*(void *)v5 + 8 * (v9 & 0x1FF));
    unint64_t v10 = v7[5] + v9;
    unint64_t v11 = v10 >> 9;
    uint64_t v12 = *(void *)(v8 + 8 * (v10 >> 9));
    uint64_t v13 = v10 & 0x1FF;
    v14 = (char *)(v12 + 8 * v13);
    if (v6 != v14)
    {
      while (*(void **)(*(void *)v6 + 8) != a2)
      {
        v6 += 8;
        if (&v6[-*(void *)v5] == (char *)4096)
        {
          v15 = *(char **)(v5 + 8);
          v5 += 8;
          v6 = v15;
        }
        if (v6 == v14)
        {
          v6 = v14;
          break;
        }
      }
    }
    if (v6 == (char *)(*(void *)(v8 + 8 * v11) + 8 * v13))
    {
LABEL_12:
      v16 = *(void **)(v3 + 24);
      uint64_t v17 = v16[1];
      if (v16[2] == v17) {
        goto LABEL_22;
      }
      unint64_t v18 = v16[4];
      v19 = (void *)(v17 + 8 * (v18 >> 9));
      uint64_t v20 = *v19 + 8 * (v18 & 0x1FF);
      unint64_t v21 = v16[5] + v18;
      unint64_t v22 = v21 >> 9;
      uint64_t v23 = *(void *)(v17 + 8 * (v21 >> 9));
      uint64_t v24 = v21 & 0x1FF;
      uint64_t v25 = v23 + 8 * v24;
      if (v20 != v25)
      {
        while (*(void **)(*(void *)v20 + 8) != a2)
        {
          v20 += 8;
          if (v20 - *v19 == 4096)
          {
            uint64_t v26 = v19[1];
            ++v19;
            uint64_t v20 = v26;
          }
          if (v20 == v25)
          {
            uint64_t v20 = v25;
            break;
          }
        }
      }
      if (v20 == *(void *)(v17 + 8 * v22) + 8 * v24) {
LABEL_22:
      }
        unint64_t v27 = "HGMemoryManager::release() - Attempting to release an unmanaged buffer: <%p>";
      else {
        unint64_t v27 = "HGMemoryManager::release() - Attempting to double-release a free buffer: <%p>";
      }
      HGLogger::warning((HGLogger *)v27, (const char *)v5, v6, a2);
    }
    else
    {
      HGMemoryManager::_recycle(v3, (char *)v5, v6);
    }
    HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard(&v28);
    HGMemoryManager::cleanup((uint64_t **)v3);
    return (pthread_mutex_t *)pthread_mutex_unlock(v4);
  }
  return this;
}

void sub_1B77015F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  pthread_mutex_unlock(v10);
  _Unwind_Resume(a1);
}

uint64_t HGMemory::renderEnd(HGMemory *this)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&HGMemoryManager::INSTANCE(void)::flag, memory_order_acquire) != -1)
  {
    v6 = &v4;
    uint64_t v5 = &v6;
    std::__call_once(&HGMemoryManager::INSTANCE(void)::flag, &v5, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>);
  }
  v1 = (uint64_t **)HGMemoryManager::INSTANCE(void)::mm;
  v2 = (pthread_mutex_t *)((char *)HGMemoryManager::INSTANCE(void)::mm + 64);
  pthread_mutex_lock((pthread_mutex_t *)HGMemoryManager::INSTANCE(void)::mm + 1);
  v1[7] = (uint64_t *)((char *)v1[7] + 1);
  HGMemoryManager::cleanup(v1);
  return pthread_mutex_unlock(v2);
}

uint64_t HGMemoryManager::cleanup(uint64_t **this)
{
  if (*((unsigned char *)this + 128))
  {
    HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(&v64, this[4]);
    unint64_t v2 = (*(uint64_t (**)(uint64_t *))(*this[1] + 32))(this[1]);
    uint64_t v3 = this[3];
    for (unint64_t i = v3[5]; i > v2; unint64_t i = v3[5])
    {
      uint64_t v5 = v3[4] + i;
      uint64_t v6 = v3[1];
      uint64_t v7 = v3[2];
      uint64_t v8 = (void *)(v6 + 8 * (v5 >> 9));
      uint64_t v9 = *v8 + 8 * (v5 & 0x1FF);
      if (v7 == v6) {
        uint64_t v9 = 0;
      }
      uint64_t v10 = v9 - *v8;
      uint64_t v11 = v10 >> 3;
      if (v10 < 9)
      {
        unint64_t v16 = 512 - v11;
        uint64_t v13 = (char *)&v8[-(v16 >> 9)];
        uint64_t v14 = *(void *)v13;
        uint64_t v15 = ~v16 & 0x1FFLL;
      }
      else
      {
        unint64_t v12 = v11 - 1;
        uint64_t v13 = (char *)&v8[v12 >> 9];
        uint64_t v14 = *(void *)v13;
        uint64_t v15 = v12 & 0x1FF;
      }
      HGMemoryManager::_release((uint64_t)this, v13, (char *)(v14 + 8 * v15));
      uint64_t v3 = this[3];
    }
    uint64_t v17 = (*(uint64_t (**)(uint64_t *))(*this[1] + 40))(this[1]);
    unint64_t v18 = this[3];
    uint64_t v19 = v18[5];
    if (v19)
    {
      unint64_t v20 = v17;
      do
      {
        uint64_t v21 = v18[4] + v19;
        uint64_t v22 = v18[1];
        uint64_t v23 = v18[2];
        uint64_t v24 = (void *)(v22 + 8 * (v21 >> 9));
        uint64_t v25 = *v24 + 8 * (v21 & 0x1FF);
        if (v23 == v22) {
          uint64_t v25 = 0;
        }
        uint64_t v26 = v25 - *v24;
        uint64_t v27 = v26 >> 3;
        if (v26 < 9)
        {
          unint64_t v32 = 512 - v27;
          BOOL v29 = (char *)&v24[-(v32 >> 9)];
          uint64_t v30 = *(void *)v29;
          uint64_t v31 = ~v32 & 0x1FFLL;
        }
        else
        {
          unint64_t v28 = v27 - 1;
          BOOL v29 = (char *)&v24[v28 >> 9];
          uint64_t v30 = *(void *)v29;
          uint64_t v31 = v28 & 0x1FF;
        }
        v33 = (char *)(v30 + 8 * v31);
        if ((unint64_t)this[7] - *(void *)(*(void *)v33 + 48) <= v20) {
          break;
        }
        HGMemoryManager::_release((uint64_t)this, v29, v33);
        unint64_t v18 = this[3];
        uint64_t v19 = v18[5];
      }
      while (v19);
    }
    unint64_t v34 = (*(uint64_t (**)(uint64_t *))(*this[1] + 48))(this[1]);
    while (this[6][10] > v34)
    {
      v35 = this[3];
      uint64_t v36 = v35[4] + v35[5];
      uint64_t v37 = v35[1];
      uint64_t v38 = v35[2];
      v39 = (void *)(v37 + 8 * (v36 >> 9));
      uint64_t v40 = *v39 + 8 * (v36 & 0x1FF);
      if (v38 == v37) {
        uint64_t v40 = 0;
      }
      uint64_t v41 = v40 - *v39;
      uint64_t v42 = v41 >> 3;
      if (v41 < 9)
      {
        unint64_t v47 = 512 - v42;
        v44 = (char *)&v39[-(v47 >> 9)];
        uint64_t v45 = *(void *)v44;
        uint64_t v46 = ~v47 & 0x1FFLL;
      }
      else
      {
        unint64_t v43 = v42 - 1;
        v44 = (char *)&v39[v43 >> 9];
        uint64_t v45 = *(void *)v44;
        uint64_t v46 = v43 & 0x1FF;
      }
      HGMemoryManager::_release((uint64_t)this, v44, (char *)(v45 + 8 * v46));
    }
  }
  else
  {
    HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(&v64, this[4]);
    v48 = this[3];
    for (uint64_t j = v48[5]; j; uint64_t j = v48[5])
    {
      uint64_t v50 = v48[4] + j;
      uint64_t v51 = v48[1];
      uint64_t v52 = v48[2];
      v53 = (void *)(v51 + 8 * (v50 >> 9));
      uint64_t v54 = *v53 + 8 * (v50 & 0x1FF);
      if (v52 == v51) {
        uint64_t v54 = 0;
      }
      uint64_t v55 = v54 - *v53;
      uint64_t v56 = v55 >> 3;
      if (v55 < 9)
      {
        unint64_t v61 = 512 - v56;
        v58 = (char *)&v53[-(v61 >> 9)];
        uint64_t v59 = *(void *)v58;
        uint64_t v60 = ~v61 & 0x1FFLL;
      }
      else
      {
        unint64_t v57 = v56 - 1;
        v58 = (char *)&v53[v57 >> 9];
        uint64_t v59 = *(void *)v58;
        uint64_t v60 = v57 & 0x1FF;
      }
      HGMemoryManager::_release((uint64_t)this, v58, (char *)(v59 + 8 * v60));
      v48 = this[3];
    }
  }
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard(&v64);
  return HGMemoryManager::dump((HGMemoryManager::Stats **)this, v62);
}

void sub_1B7701A08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard((void **)va);
  _Unwind_Resume(a1);
}

void sub_1B7701A1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard((void **)va);
  _Unwind_Resume(a1);
}

void sub_1B7701A30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard((void **)va);
  _Unwind_Resume(a1);
}

void sub_1B7701A44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard((void **)va);
  _Unwind_Resume(a1);
}

void sub_1B7701A58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard((void **)va);
  _Unwind_Resume(a1);
}

HGMemory::StorageObject *HGMemory::StorageObject::StorageObject(HGMemory::StorageObject *this, unint64_t a2)
{
  HGObject::HGObject(this);
  *char v4 = &unk_1F10CA6E8;
  uint64_t v5 = v4 + 3;
  if (atomic_load_explicit((atomic_ullong *volatile)&HGMemoryManager::INSTANCE(void)::flag, memory_order_acquire) != -1)
  {
    uint64_t v9 = &v7;
    uint64_t v8 = &v9;
    std::__call_once(&HGMemoryManager::INSTANCE(void)::flag, &v8, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>);
  }
  *((void *)this + 2) = HGMemoryManager::allocate((HGMemoryManager *)HGMemoryManager::INSTANCE(void)::mm, a2, v5);
  return this;
}

void sub_1B7701B24(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGMemory::StorageObject::~StorageObject(HGMemory::StorageObject *this)
{
  *(void *)this = &unk_1F10CA6E8;
  unint64_t v2 = (void *)*((void *)this + 2);
  if (atomic_load_explicit((atomic_ullong *volatile)&HGMemoryManager::INSTANCE(void)::flag, memory_order_acquire) != -1)
  {
    uint64_t v5 = &v3;
    char v4 = &v5;
    std::__call_once(&HGMemoryManager::INSTANCE(void)::flag, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>);
  }
  HGMemoryManager::release((pthread_mutex_t *)HGMemoryManager::INSTANCE(void)::mm, v2);
  HGObject::~HGObject(this);
}

{
  void *v2;
  void *v3;
  char v4;
  char **v5;
  char *v6;

  *(void *)this = &unk_1F10CA6E8;
  unint64_t v2 = (void *)*((void *)this + 2);
  if (atomic_load_explicit((atomic_ullong *volatile)&HGMemoryManager::INSTANCE(void)::flag, memory_order_acquire) != -1)
  {
    uint64_t v6 = &v4;
    uint64_t v5 = &v6;
    std::__call_once(&HGMemoryManager::INSTANCE(void)::flag, &v5, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>);
  }
  HGMemoryManager::release((pthread_mutex_t *)HGMemoryManager::INSTANCE(void)::mm, v2);
  HGObject::~HGObject(this);
  HGObject::operator delete(v3);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>()
{
}

void sub_1B7701CD0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1020C40F2D2F845);
  _Unwind_Resume(a1);
}

void HGMemoryManager::HGMemoryManager(HGMemoryManager *this)
{
}

void HGMemoryManager::PageSizePolicy::~PageSizePolicy(HGMemoryManager::PageSizePolicy *this)
{
}

uint64_t HGMemoryManager::PageSizePolicy::padBlockSizeForAlloc(HGMemoryManager::PageSizePolicy *this, uint64_t a2)
{
  int v3 = getpagesize();
  return (a2 + v3 - 1) & -(uint64_t)v3;
}

uint64_t HGMemoryManager::PageSizePolicy::maxBlockSizeForReUsage(HGMemoryManager::PageSizePolicy *this, uint64_t a2)
{
  return 2 * a2;
}

uint64_t HGMemoryManager::PageSizePolicy::maxFreeBlockNumber(HGMemoryManager::PageSizePolicy *this)
{
  return 10;
}

uint64_t HGMemoryManager::PageSizePolicy::maxFreeBlockAge(HGMemoryManager::PageSizePolicy *this)
{
  return 200;
}

uint64_t HGMemoryManager::PageSizePolicy::maxFreeBlockTotalUsage(HGMemoryManager::PageSizePolicy *this)
{
  return -1;
}

uint64_t HGMemoryManager::_reuse(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  uint64_t v8 = *(void **)(a1 + 16);
  uint64_t v9 = v8[2];
  uint64_t v10 = v8[1];
  uint64_t v11 = ((v9 - v10) << 6) - 1;
  BOOL v12 = v9 == v10;
  uint64_t v13 = *(void *)a3;
  *(void *)(v13 + 48) = *(void *)(a1 + 56);
  uint64_t v14 = *(void *)(v13 + 32) + a4;
  *(void *)(v13 + 24) = a4;
  *(void *)(v13 + 32) = v14;
  ++*(_DWORD *)(v13 + 40);
  if (v12) {
    uint64_t v15 = 0;
  }
  else {
    uint64_t v15 = v11;
  }
  uint64_t v16 = v8[5];
  unint64_t v17 = v16 + v8[4];
  if (v15 == v17)
  {
    std::deque<HGMemoryManager::Block *>::__add_back_capacity((uint64_t)v8);
    uint64_t v10 = v8[1];
    uint64_t v16 = v8[5];
    unint64_t v17 = v8[4] + v16;
  }
  *(void *)(*(void *)(v10 + ((v17 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v17 & 0x1FF)) = v13;
  v8[5] = v16 + 1;
  std::deque<Pipeline *>::erase(*(int64x2_t **)(a1 + 24), a2, a3);
  unint64_t v18 = *(void **)(a1 + 48);
  uint64_t v19 = *(void *)(v13 + 16);
  ++v18[2];
  v18[6] += v19;
  uint64_t v20 = v18[8];
  unint64_t v21 = v20 + v19;
  uint64_t v22 = v18[9] + a4;
  v18[8] = v20 + v19;
  v18[9] = v22;
  uint64_t v23 = v18[10];
  unint64_t v24 = v18[11];
  unint64_t v25 = v23 - v19;
  v18[10] = v25;
  if (v24 < v21)
  {
    v18[11] = v21;
    if (v18[12] >= v25)
    {
LABEL_8:
      unint64_t v26 = v21 - v22;
      if (v18[13] >= v26) {
        goto LABEL_9;
      }
LABEL_14:
      v18[13] = v26;
      unint64_t v27 = v23 + v20;
      if (v18[14] >= v27) {
        return v13;
      }
      goto LABEL_10;
    }
  }
  else if (v18[12] >= v25)
  {
    goto LABEL_8;
  }
  v18[12] = v25;
  unint64_t v26 = v21 - v22;
  if (v18[13] < v26) {
    goto LABEL_14;
  }
LABEL_9:
  unint64_t v27 = v23 + v20;
  if (v18[14] < v27) {
LABEL_10:
  }
    v18[14] = v27;
  return v13;
}

void HGMemoryManager::_allocate(HGMemoryManager *this)
{
  (*(void (**)(void))(**((void **)this + 1) + 16))(*((void *)this + 1));
  HGProfilerGuard<(HGProfilerGuardMode)1>::HGProfilerGuard(&v3, *((void **)this + 4));
  HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(&v2, *((uint64_t **)this + 5));
  operator new();
}

void sub_1B7702248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t *a10)
{
  MEMORY[0x1BA9BFBA0](v10, 0x10E0C40D70D0186);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard(&a9);
  HGProfilerGuard<(HGProfilerGuardMode)1>::~HGProfilerGuard(&a10);
  _Unwind_Resume(a1);
}

void sub_1B7702284(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)1>::~HGProfilerGuard((uint64_t **)va);
  _Unwind_Resume(a1);
}

void std::deque<HGMemoryManager::Block *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    char v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        unint64_t v34 = (char *)operator new(8 * v31);
        v35 = &v34[8 * v32];
        uint64_t v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            v74 = &v34[8 * v32];
            uint64_t v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v40 = &v35[v76];
              v7 += v76;
              v77 = (long long *)(v6 + 3);
              v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                _OWORD *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    uint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      char v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    char v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        unint64_t v34 = (char *)operator new(8 * v42);
        v35 = &v34[8 * v43];
        uint64_t v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            unint64_t v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v47 = &v35[v84];
              v7 += v84;
              v85 = (long long *)(v41 + 3);
              v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                _OWORD *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            unint64_t v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  unint64_t v25 = (char *)operator new(8 * v24);
  unint64_t v26 = operator new(0x1000uLL);
  unint64_t v27 = &v25[8 * v21];
  unint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      v49 = (char *)operator new(8 * v48);
      unint64_t v27 = &v49[8 * (v48 >> 2)];
      unint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      unint64_t v25 = v49;
      *(void *)unint64_t v27 = v90;
      BOOL v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)unint64_t v27 = v26;
      BOOL v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v60 = (char *)operator new(8 * v59);
          unint64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          BOOL v29 = v53;
          if (!v37)
          {
            BOOL v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            v64 = &v60[8 * v61];
            v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            v64 = &v60[8 * v61];
            v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            v65 = &v27[v68];
            v69 = (long long *)(v27 + 16);
            v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          unint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          unint64_t v57 = &v29[8 * (v56 >> 1)];
          v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          BOOL v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          unint64_t v25 = v27;
        }
      }
      else
      {
        v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      uint64_t v51 = v53 - 8;
      unint64_t v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)unint64_t v27 = v26;
  BOOL v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  uint64_t v51 = v27;
LABEL_46:
  uint64_t v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B7702808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B7702824(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7702838(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7702850(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGMemoryManager::_recycle(uint64_t a1, char *a2, char *a3)
{
  uint64_t v6 = *(int64x2_t **)a3;
  *(void *)(*(void *)a3 + 48) = *(void *)(a1 + 56);
  char v7 = *(void **)(a1 + 24);
  unint64_t v8 = v7[4];
  if (!v8)
  {
    std::deque<HGMemoryManager::Block *>::__add_front_capacity(*(void *)(a1 + 24));
    unint64_t v8 = v7[4];
  }
  uint64_t v9 = v7[1];
  uint64_t v10 = (void *)(v9 + 8 * (v8 >> 9));
  if (v7[2] == v9) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *v10 + 8 * (v8 & 0x1FF);
  }
  if (v11 == *v10) {
    uint64_t v11 = *(v10 - 1) + 4096;
  }
  *(void *)(v11 - 8) = v6;
  uint64_t v12 = v7[5] + 1;
  v7[4] = v8 - 1;
  v7[5] = v12;
  std::deque<Pipeline *>::erase(*(int64x2_t **)(a1 + 16), a2, a3);
  uint64_t v13 = *(int64x2_t **)(a1 + 48);
  ++v13->i64[1];
  int64x2_t v14 = v13[4];
  int64x2_t v15 = vsubq_s64(v14, v6[1]);
  uint64_t v16 = v6[1].i64[0];
  v13[2].i64[1] += v16;
  v13[4] = v15;
  uint64_t v17 = v13[5].i64[0];
  unint64_t v18 = v13[5].u64[1];
  unint64_t v19 = v17 + v16;
  v13[5].i64[0] = v17 + v16;
  if (v18 < v15.i64[0])
  {
    v13[5].i64[1] = v15.i64[0];
    if (v13[6].i64[0] >= v19)
    {
LABEL_10:
      uint64_t v20 = v15.i64[0] - v15.i64[1];
      if (v13[6].i64[1] >= (unint64_t)(v15.i64[0] - v15.i64[1])) {
        goto LABEL_11;
      }
LABEL_16:
      v13[6].i64[1] = v20;
      unint64_t v21 = v17 + v14.i64[0];
      if (v13[7].i64[0] >= v21) {
        return v6->i64[1];
      }
      goto LABEL_12;
    }
  }
  else if (v13[6].i64[0] >= v19)
  {
    goto LABEL_10;
  }
  v13[6].i64[0] = v19;
  uint64_t v20 = v15.i64[0] - v15.i64[1];
  if (v13[6].i64[1] < (unint64_t)(v15.i64[0] - v15.i64[1])) {
    goto LABEL_16;
  }
LABEL_11:
  unint64_t v21 = v17 + v14.i64[0];
  if (v13[7].i64[0] < v21) {
LABEL_12:
  }
    v13[7].i64[0] = v21;
  return v6->i64[1];
}

void std::deque<HGMemoryManager::Block *>::__add_front_capacity(uint64_t a1)
{
  BOOL v3 = *(char **)(a1 + 8);
  unint64_t v2 = *(char **)(a1 + 16);
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = ((v2 - v3) << 6) - 1;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if ((unint64_t)(v4 - (*(void *)(a1 + 40) + v5)) >= 0x200)
  {
    *(void *)(a1 + 32) = v5 + 512;
    unint64_t v47 = (void *)*((void *)v2 - 1);
    *(void *)(a1 + 16) = v2 - 8;
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
    return;
  }
  uint64_t v6 = *(char **)(a1 + 24);
  char v7 = *(char **)a1;
  uint64_t v8 = (uint64_t)&v6[-*(void *)a1];
  if (v2 - v3 < (unint64_t)v8)
  {
    if (v3 == v7)
    {
      unint64_t v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v47);
      uint64_t v17 = *(void *)(a1 + 16);
      unint64_t v47 = *(void **)(v17 - 8);
      *(void *)(a1 + 16) = v17 - 8;
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8) {
        goto LABEL_9;
      }
    }
    else
    {
      unint64_t v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8)
      {
LABEL_9:
        uint64_t v9 = 256;
LABEL_19:
        *(void *)(a1 + 32) = v9;
        return;
      }
    }
    uint64_t v9 = *(void *)(a1 + 32) + 512;
    goto LABEL_19;
  }
  if (v6 == v7) {
    unint64_t v10 = 1;
  }
  else {
    unint64_t v10 = v8 >> 2;
  }
  if (v10 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v11 = (char *)operator new(8 * v10);
  uint64_t v12 = operator new(0x1000uLL);
  uint64_t v13 = v12;
  if (v10)
  {
    int64x2_t v14 = &v11[8 * v10];
    *(void *)uint64_t v11 = v12;
    int64x2_t v15 = v11 + 8;
    uint64_t v16 = v11;
    if (v3 != v2) {
      goto LABEL_29;
    }
    goto LABEL_21;
  }
  unint64_t v18 = (char *)operator new(8uLL);
  int64x2_t v14 = v18 + 8;
  operator delete(v11);
  BOOL v3 = *(char **)(a1 + 8);
  unint64_t v19 = *(char **)(a1 + 16);
  uint64_t v11 = v18;
  *(void *)unint64_t v18 = v13;
  int64x2_t v15 = v18 + 8;
  uint64_t v16 = v18;
  if (v3 != v19)
  {
    while (1)
    {
LABEL_29:
      if (v15 == v14)
      {
        if (v11 <= v16)
        {
          if (v15 == v16) {
            unint64_t v31 = 1;
          }
          else {
            unint64_t v31 = (v15 - v16) >> 2;
          }
          if (v31 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          unint64_t v32 = (char *)operator new(8 * v31);
          uint64_t v33 = v32;
          unint64_t v34 = v31 >> 2;
          uint64_t v20 = &v32[8 * (v31 >> 2)];
          uint64_t v23 = v20;
          int64_t v35 = v15 - v11;
          if (v15 != v11)
          {
            uint64_t v23 = &v20[v35 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v36 = v35 - 8;
            if (v36 < 0x38 || (uint64_t v37 = 8 * v34, (unint64_t)(&v32[8 * v34] - v11) < 0x20))
            {
              int64_t v38 = &v32[8 * (v31 >> 2)];
              unint64_t v39 = v11;
              goto LABEL_45;
            }
            uint64_t v41 = (v36 >> 3) + 1;
            uint64_t v42 = 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
            int64_t v38 = &v20[v42];
            unint64_t v39 = &v11[v42];
            unint64_t v43 = (long long *)(v11 + 16);
            uint64_t v44 = &v32[v37 + 16];
            uint64_t v45 = v41 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v46 = *v43;
              *((_OWORD *)v44 - 1) = *(v43 - 1);
              *(_OWORD *)uint64_t v44 = v46;
              v43 += 2;
              v44 += 32;
              v45 -= 4;
            }
            while (v45);
            if (v41 != (v41 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_45:
                uint64_t v40 = *(void *)v39;
                v39 += 8;
                *(void *)int64_t v38 = v40;
                v38 += 8;
              }
              while (v38 != v23);
            }
          }
          int64x2_t v15 = &v32[8 * v31];
          if (v16) {
            operator delete(v16);
          }
          uint64_t v16 = v33;
          goto LABEL_28;
        }
        uint64_t v25 = (v11 - v16) >> 3;
        if (v25 >= -1) {
          uint64_t v26 = v25 + 1;
        }
        else {
          uint64_t v26 = v25 + 2;
        }
        uint64_t v27 = v26 >> 1;
        unint64_t v28 = &v11[-8 * (v26 >> 1)];
        BOOL v29 = v15;
        if (v15 != v11)
        {
          memmove(v28, v11, v15 - v11);
          BOOL v29 = v11;
        }
        uint64_t v30 = -v27;
        uint64_t v23 = &v28[v15 - v11];
        uint64_t v20 = &v29[8 * v30];
      }
      else
      {
        uint64_t v20 = v11;
        uint64_t v23 = v15;
        int64x2_t v15 = v14;
      }
LABEL_28:
      int64x2_t v14 = v15;
      uint64_t v24 = *(void *)v3;
      v3 += 8;
      *(void *)uint64_t v23 = v24;
      unint64_t v21 = v23 + 8;
      int64x2_t v15 = v21;
      uint64_t v11 = v20;
      if (v3 == *(char **)(a1 + 16)) {
        goto LABEL_22;
      }
    }
  }
LABEL_21:
  uint64_t v20 = v11;
  unint64_t v21 = v15;
LABEL_22:
  uint64_t v22 = *(void **)a1;
  *(void *)a1 = v16;
  *(void *)(a1 + 8) = v20;
  *(void *)(a1 + 16) = v21;
  *(void *)(a1 + 24) = v14;
  if (v21 - v20 == 8)
  {
    *(void *)(a1 + 32) = 256;
    if (!v22) {
      return;
    }
  }
  else
  {
    *(void *)(a1 + 32) += 512;
    if (!v22) {
      return;
    }
  }

  operator delete(v22);
}

void sub_1B7702D6C(_Unwind_Exception *a1)
{
  operator delete(v1);
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t HGMemoryManager::dump(HGMemoryManager::Stats **this, const char *a2)
{
  unsigned __int8 v3 = atomic_load(HGLogger::_enabled);
  if ((v3 & 1) != 0 && (int)HGLogger::getLevel((HGLogger *)"alloc", a2) >= 1)
  {
    HGMemoryManager::Stats::dump(this[6], (const char *)1);
    HGMemoryManager::dumpToLogger((HGMemoryManager *)this, (char *)1);
  }
  if (this[4] && this[5])
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v13, "alloc", 1, "Time Profile");
    double Time = HGProfiler::getTime(this[4]);
    double v7 = HGProfiler::getTime(this[5]);
    unint64_t v8 = *((void *)this[6] + 2) + *(void *)this[6];
    unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
    if (v9) {
      HGLogger::log((HGLogger *)"alloc", (const char *)1, (HGLogger *)"time doing manager stuff   : %f ms / %zu ops (avg : %f ms)\n", v5, v6, *(void *)&Time, v8, Time / (double)v8);
    }
    unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
    if (v10) {
      HGLogger::log((HGLogger *)"alloc", (const char *)1, (HGLogger *)"time doing real memory ops : %f ms / %zu ops (avg : %f ms)\n", v5, v6, *(void *)&v7, v8, v7 / (double)v8);
    }
    unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
    if (v11) {
      HGLogger::log((HGLogger *)"alloc", (const char *)1, (HGLogger *)"total time in mem manager  : %f ms / %zu ops (avg : %f ms)\n", v5, v6, Time + v7, v8, (Time + v7) / (double)v8);
    }
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v13);
  }
  return 0;
}

void sub_1B7702F40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7702F54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7702F68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t **HGMemoryManager::_release(uint64_t a1, char *a2, char *a3)
{
  uint64_t v4 = *(void *)a3;
  std::deque<Pipeline *>::erase(*(int64x2_t **)(a1 + 24), a2, a3);
  uint64_t v5 = *(void **)(a1 + 48);
  uint64_t v6 = *(void *)(v4 + 16);
  ++v5[3];
  unint64_t v7 = v5[8];
  v5[7] += v6;
  unint64_t v8 = v5[11];
  unint64_t v9 = v5[10] - v6;
  v5[10] = v9;
  if (v8 < v7)
  {
    v5[11] = v7;
    if (v5[12] >= v9)
    {
LABEL_3:
      unint64_t v10 = v7 - v5[9];
      if (v5[13] >= v10) {
        goto LABEL_4;
      }
LABEL_9:
      v5[13] = v10;
      unint64_t v11 = v7 + v9;
      if (v5[14] >= v11) {
        goto LABEL_6;
      }
      goto LABEL_5;
    }
  }
  else if (v5[12] >= v9)
  {
    goto LABEL_3;
  }
  v5[12] = v9;
  unint64_t v10 = v7 - v5[9];
  if (v5[13] < v10) {
    goto LABEL_9;
  }
LABEL_4:
  unint64_t v11 = v7 + v9;
  if (v5[14] < v11) {
LABEL_5:
  }
    v5[14] = v11;
LABEL_6:
  HGProfilerGuard<(HGProfilerGuardMode)1>::HGProfilerGuard(&v14, *(void **)(a1 + 32));
  HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(&v13, *(uint64_t **)(a1 + 40));
  free(*(void **)(v4 + 8));
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  MEMORY[0x1BA9BFBA0](v4, 0x10E0C40D70D0186);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard(&v13);
  return HGProfilerGuard<(HGProfilerGuardMode)1>::~HGProfilerGuard(&v14);
}

void sub_1B77030B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)1>::~HGProfilerGuard((uint64_t **)va);
  _Unwind_Resume(a1);
}

void HGMemoryManager::Stats::dump(HGMemoryManager::Stats *this, const char *a2)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v27, "alloc", (int)a2, "Memory Manager Stats");
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  }
  unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
  if (v7) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  numAllocs           : %zu \n", v4, v5, *(void *)this);
  }
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  numFrees            : %zu \n", v4, v5, *((void *)this + 3));
  }
  unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
  if (v9) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  numReused           : %zu \n", v4, v5, *((void *)this + 2));
  }
  unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
  if (v10) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  numRecycled         : %zu \n", v4, v5, *((void *)this + 1));
  }
  unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
  if (v11) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  }
  unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
  if (v12) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  totalAllocated      : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 4) * 0.00000095367));
  }
  unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
  if (v13) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  totalReleased       : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 7) * 0.00000095367));
  }
  unsigned __int8 v14 = atomic_load(HGLogger::_enabled);
  if (v14) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  totalReused         : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 6) * 0.00000095367));
  }
  unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
  if (v15) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  totalRecycled       : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 5) * 0.00000095367));
  }
  unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
  if (v16) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  }
  unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
  if (v17) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  allocMem            : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 8) * 0.00000095367));
  }
  unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
  if (v18) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  usedMem             : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 9) * 0.00000095367));
  }
  unsigned __int8 v19 = atomic_load(HGLogger::_enabled);
  if (v19) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  freeMem             : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 10) * 0.00000095367));
  }
  unsigned __int8 v20 = atomic_load(HGLogger::_enabled);
  if (v20) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  totalMem            : %5.1f mb \n", v4, v5, (float)((float)(unint64_t)(*((void *)this + 10) + *((void *)this + 8)) * 0.00000095367));
  }
  unsigned __int8 v21 = atomic_load(HGLogger::_enabled);
  if (v21) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  }
  unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
  if (v22) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  peakAllocMem        : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 11) * 0.00000095367));
  }
  unsigned __int8 v23 = atomic_load(HGLogger::_enabled);
  if (v23) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  peakFreeMem         : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 12) * 0.00000095367));
  }
  unsigned __int8 v24 = atomic_load(HGLogger::_enabled);
  if (v24) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  peakUnusedMem       : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 13) * 0.00000095367));
  }
  unsigned __int8 v25 = atomic_load(HGLogger::_enabled);
  if (v25) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  peakTotalMem        : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 14) * 0.00000095367));
  }
  unsigned __int8 v26 = atomic_load(HGLogger::_enabled);
  if (v26) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v27);
}

void sub_1B7703544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGMemoryManager::dumpToLogger(HGMemoryManager *this, char *a2)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v33, "alloc", (int)a2, "Dump Memory Blocks");
  uint64_t v6 = *((void *)this + 7);
  unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
  if (v7) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  }
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"used blocks:\n", v4, v5);
  }
  unsigned __int8 v9 = (void *)*((void *)this + 2);
  uint64_t v10 = v9[1];
  if (v9[2] != v10)
  {
    unint64_t v11 = v9[4];
    unsigned __int8 v12 = (void *)(v10 + 8 * (v11 >> 9));
    unsigned __int8 v13 = (HGMemoryManager::Block **)(*v12 + 8 * (v11 & 0x1FF));
    uint64_t v14 = *(void *)(v10 + (((v9[5] + v11) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v9[5] + v11) & 0x1FF);
    while (v13 != (HGMemoryManager::Block **)v14)
    {
      HGMemoryManager::Block::dump(*v13++, v6, a2, v4, v5);
      if ((HGMemoryManager::Block **)((char *)v13 - *v12) == (HGMemoryManager::Block **)4096)
      {
        unsigned __int8 v15 = (HGMemoryManager::Block **)v12[1];
        ++v12;
        unsigned __int8 v13 = v15;
      }
    }
  }
  uint64_t v16 = *((void *)this + 6);
  float v17 = (float)*(unint64_t *)(v16 + 64) * 0.00000095367;
  float v18 = (float)*(unint64_t *)(v16 + 72) * 0.00000095367;
  if (v17 <= 0.0)
  {
    uint64_t v19 = 0;
    unsigned __int8 v21 = atomic_load(HGLogger::_enabled);
    if ((v21 & 1) == 0) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  uint64_t v19 = (int)(float)((float)(v18 * 100.0) / v17);
  unsigned __int8 v20 = atomic_load(HGLogger::_enabled);
  if (v20) {
LABEL_14:
  }
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)" total : %5.1f mb(using : %5.1f mb or %3d%%)\n", v4, v5, v17, v18, v19);
LABEL_15:
  unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
  if (v22) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  }
  unsigned __int8 v23 = atomic_load(HGLogger::_enabled);
  if (v23) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"free blocks:\n", v4, v5);
  }
  unsigned __int8 v24 = (void *)*((void *)this + 3);
  uint64_t v25 = v24[1];
  if (v24[2] != v25)
  {
    unint64_t v26 = v24[4];
    uint64_t v27 = (void *)(v25 + 8 * (v26 >> 9));
    unint64_t v28 = (HGMemoryManager::Block **)(*v27 + 8 * (v26 & 0x1FF));
    uint64_t v29 = *(void *)(v25 + (((v24[5] + v26) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v24[5] + v26) & 0x1FF);
    while (v28 != (HGMemoryManager::Block **)v29)
    {
      HGMemoryManager::Block::dump(*v28++, v6, a2, v4, v5);
      if ((HGMemoryManager::Block **)((char *)v28 - *v27) == (HGMemoryManager::Block **)4096)
      {
        uint64_t v30 = (HGMemoryManager::Block **)v27[1];
        ++v27;
        unint64_t v28 = v30;
      }
    }
  }
  unsigned __int8 v31 = atomic_load(HGLogger::_enabled);
  if (v31) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)" total : %5.1f mb\n", v4, v5, (float)((float)*(unint64_t *)(*((void *)this + 6) + 80) * 0.00000095367));
  }
  unsigned __int8 v32 = atomic_load(HGLogger::_enabled);
  if (v32) {
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v33);
}

void sub_1B7703810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7703824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7703838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B770384C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7703860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGMemoryManager::Block::dump(HGMemoryManager::Block *this, uint64_t a2, char *a3, const char *a4, char *a5)
{
  unint64_t v5 = *((void *)this + 2);
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v5 <= 0x100000)
  {
    if (v6) {
      HGLogger::log((HGLogger *)"alloc", a3, (HGLogger *)"  %p : %8lu bytes (%7.1f kb) (using %7.1f kb) (age : %4lu) (total usage : %4d for %7.1f kb, average : %7.1f kb)\n", a4, a5, *((void *)this + 1), *((void *)this + 2), (float)((float)*((unint64_t *)this + 2) * 0.00097656), (float)((float)*((unint64_t *)this + 3) * 0.00097656), a2 - *((void *)this + 6), *((unsigned int *)this + 10), (float)((float)*((unint64_t *)this + 4) * 0.00097656), (float)((float)((float)*((unint64_t *)this + 4) * 0.00097656) / (float)*((unsigned int *)this + 10)));
    }
  }
  else if (v6)
  {
    HGLogger::log((HGLogger *)"alloc", a3, (HGLogger *)"  %p : %8lu bytes (%7.1f mb) (using %7.1f mb) (age : %4lu) (total usage : %4d for %7.1f mb, average : %7.1f mb)\n", a4, a5, *((void *)this + 1), *((void *)this + 2), (float)((float)*((unint64_t *)this + 2) * 0.00000095367), (float)((float)*((unint64_t *)this + 3) * 0.00000095367), a2 - *((void *)this + 6), *((unsigned int *)this + 10), (float)((float)*((unint64_t *)this + 4) * 0.00000095367), (float)((float)((float)*((unint64_t *)this + 4) * 0.00000095367) / (float)*((unsigned int *)this + 10)));
  }
}

void HGMetalContext::HGMetalContext(HGMetalContext *this, const HGMetalDeviceInfo *a2)
{
  HGObject::HGObject(this);
  *uint64_t v4 = &unk_1F10CA7A8;
  v4[2] = a2;
  DeviceResources = HGGPUResources::getDeviceResources(a2, v5);
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = DeviceResources;
  *((unsigned char *)this + 52) = 1;
  *((_DWORD *)this + 14) = 64;
  *((_DWORD *)this + 16) = 1;
  *((void *)this + 9) = -1;
  *((void *)this + 10) = 0x100000000;
  *((void *)this + 11) = -1;
  *((void *)this + 12) = 0x101010100000020;
  *((void *)this + 4) = [*(id *)(*((void *)this + 2) + 16) newCommandQueue];
  *((_DWORD *)this + 12) = 29;
  unint64_t v7 = (unint64_t)(float)((float)*(unint64_t *)(*((void *)this + 2) + 40) * 0.1);
  *((void *)this + 10) = 0x500000002;
  if (v7 >= 0x40000000) {
    unint64_t v7 = 0x40000000;
  }
  *((void *)this + 11) = v7;
}

void sub_1B7703A78(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B7703A8C(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGMetalContext::~HGMetalContext(id *this)
{
  *this = &unk_1F10CA7A8;

  this[4] = 0;

  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;
  uint64_t vars8;

  *this = &unk_1F10CA7A8;

  this[4] = 0;
  HGObject::~HGObject((HGObject *)this);

  HGObject::operator delete(v2);
}

void HGMetalContext::setLabel(HGMetalContext *this, const char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  unint64_t v5 = (void *)v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    unsigned __int8 v6 = (void **)operator new(v7 + 1);
    __dst[1] = v5;
    int64_t v21 = v8 | 0x8000000000000000;
    __dst[0] = v6;
    goto LABEL_8;
  }
  HIBYTE(v21) = v4;
  unsigned __int8 v6 = __dst;
  if (v4) {
LABEL_8:
  }
    memcpy(v6, __s, (size_t)v5);
  *((unsigned char *)v5 + (void)v6) = 0;
  size_t v9 = strlen(__s);
  if (v9 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v10 = v9;
  if (v9 >= 0x17)
  {
    uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v12 = v9 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_p = (std::string *)operator new(v12 + 1);
    __p.__r_.__value_.__l.__size_ = v10;
    __p.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    goto LABEL_16;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = v9;
  p_p = &__p;
  if (v9) {
LABEL_16:
  }
    memcpy(p_p, __s, v10);
  p_p->__r_.__value_.__s.__data_[v10] = 0;
  uint64_t v14 = std::string::append(&__p, " Frame");
  unsigned __int8 v15 = (void *)v14->__r_.__value_.__r.__words[0];
  int v16 = SHIBYTE(v14->__r_.__value_.__r.__words[2]);
  v14->__r_.__value_.__r.__words[0] = 0;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  float v17 = (void *)*((void *)this + 4);
  if (v21 >= 0) {
    float v18 = __dst;
  }
  else {
    float v18 = (void **)__dst[0];
  }
  objc_msgSend(v17, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", v18, __p.__r_.__value_.__r.__words[0], __p.__r_.__value_.__l.__size_, __p.__r_.__value_.__r.__words[2]));
  if ((v16 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v21) & 0x80000000) == 0) {
      return;
    }
LABEL_26:
    operator delete(__dst[0]);
    return;
  }
  operator delete(v15);
  if (SHIBYTE(v21) < 0) {
    goto LABEL_26;
  }
}

void sub_1B7703D38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void HGMetalContext::synchronizeCommandQueue(id *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v3, "metal", 1, "HGMetalContext::synchronizeCommandQueue()");
  unint64_t v2 = (void *)[this[4] commandBuffer];
  [v2 setLabel:@"HG synchronizeCommandQueue"];
  objc_msgSend((id)objc_msgSend(v2, "blitCommandEncoder"), "endEncoding");
  [v2 commit];
  [v2 waitUntilCompleted];
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v3);
}

void sub_1B7703DFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7703E10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGMetalContext::bufferPool(HGMetalContext *this)
{
  if (*((unsigned char *)this + 100)) {
    return *(void *)(*((void *)this + 3) + 32);
  }
  else {
    return 0;
  }
}

uint64_t HGMetalContext::texturePool(HGMetalContext *this)
{
  if (*((unsigned char *)this + 101)) {
    return *(void *)(*((void *)this + 3) + 40);
  }
  else {
    return 0;
  }
}

uint64_t HGMetalContext::bufferInfiniPool(HGMetalContext *this)
{
  if (*((unsigned char *)this + 102)) {
    return *(void *)(*((void *)this + 3) + 48);
  }
  else {
    return 0;
  }
}

uint64_t HGMetalContext::getCVTextureCacheRetainedRef(HGGPUResources **this)
{
  return HGGPUResources::getCVTextureCacheRetainedRef(this[3]);
}

uint64_t HGMetalContext::setCommandBufferLimits(uint64_t this, int a2, uint64_t a3)
{
  *(_DWORD *)(this + 64) = a2;
  *(void *)(this + 72) = a3;
  return this;
}

uint64_t HGMetalContext::setCommandQueueLimits(uint64_t this, int a2, int a3, uint64_t a4)
{
  *(_DWORD *)(this + 80) = a2;
  *(_DWORD *)(this + 84) = a3;
  *(void *)(this + 88) = a4;
  return this;
}

void HGObject::~HGObject(HGObject *this)
{
  *(void *)this = &unk_1F10CA7F8;
}

{
  *(void *)this = &unk_1F10CA7F8;
}

void HGObject::~HGObject(void *this)
{
  *(void *)this = &unk_1F10CA7F8;
  operator delete(this);
}

uint64_t HGObject::Retain(uint64_t this)
{
  return this;
}

atomic_uint *HGObject::Release(atomic_uint *this)
{
  if (atomic_fetch_add(this + 2, 0xFFFFFFFF) == 1)
  {
    atomic_fetch_add(this + 2, 1u);
    if (this) {
      return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)this + 8))();
    }
  }
  return this;
}

void HGObject::debugDescription(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

unint64_t HGMalloc(uint64_t a1)
{
  unint64_t v2 = (unint64_t)malloc_type_malloc(a1 + 144, 0x7092249BuLL);
  unint64_t v3 = v2 & 0xFFFFFFFFFFFFFF80;
  *(void *)(v3 + 112) = a1;
  *(void *)(v3 + 120) = v2;
  return (v2 & 0xFFFFFFFFFFFFFF80) + 128;
}

void HGFree(uint64_t a1)
{
}

const void *HGRealloc(const void *a1, unint64_t a2)
{
  unint64_t v3 = a1;
  if (!a1 || *((void *)a1 - 2) < a2)
  {
    unint64_t v4 = (unint64_t)malloc_type_malloc(a2 + 144, 0xE5E6AEA1uLL);
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFF80;
    unint64_t v6 = (v4 & 0xFFFFFFFFFFFFFF80) + 128;
    *(void *)(v5 + 112) = a2;
    *(void *)(v5 + 120) = v4;
    if (v3)
    {
      memcpy((void *)((v4 & 0xFFFFFFFFFFFFFF80) + 128), v3, *((void *)v3 - 2));
      free(*((void **)v3 - 1));
    }
    return (const void *)v6;
  }
  return v3;
}

unint64_t HGGetTBCFrequency()
{
  unint64_t result = qword_1EB9A0AC0;
  if (!qword_1EB9A0AC0)
  {
    mach_timebase_info((mach_timebase_info_t)&_MergedGlobals_3);
    unint64_t result = 1000000000 * (unint64_t)*(unsigned int *)algn_1EB9A0ABC / _MergedGlobals_3;
    qword_1EB9A0AC0 = result;
  }
  return result;
}

uint64_t HGGetActiveCPU()
{
  unsigned int v2 = 0;
  size_t v1 = 4;
  if (sysctlbyname("hw.physicalcpu", &v2, &v1, 0, 0) && sysctlbyname("hw.ncpu", &v2, &v1, 0, 0)) {
    return 1;
  }
  return v2;
}

uint64_t GLPBO::GLPBO(uint64_t a1, PC_Sp_counted_base **a2)
{
  *(_DWORD *)a1 = 0;
  unint64_t v3 = *a2;
  *(void *)(a1 + 8) = *a2;
  *(void *)(a1 + 16) = 0;
  unint64_t v4 = (GLuint *)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 29) = 0;
  *(void *)(a1 + 24) = 0;
  v6.var0 = v3;
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v7, &v6.var0);
  PCSharedCount::PCSharedCount(&v6);
  glGenFramebuffers(1, v4);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v7);
  return a1;
}

void sub_1B7704178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  PCSharedCount::PCSharedCount(v3);
  _Unwind_Resume(a1);
}

void sub_1B7704194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  PCSharedCount::PCSharedCount(v10);
  _Unwind_Resume(a1);
}

void GLPBO::_delete(GLPBO *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  if (*((_DWORD *)this + 7))
  {
    unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
    if (v6) {
      HGLogger::log((HGLogger *)"pbo", (const char *)1, (HGLogger *)"GLPBO::_delete()\n", a4, a5);
    }
    if (*((void *)this + 5))
    {
      GLPBO::_unmap(this);
      *((void *)this + 5) = 0;
    }
    v7.var0 = (PC_Sp_counted_base *)*((void *)this + 1);
    HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v8, &v7.var0);
    PCSharedCount::PCSharedCount(&v7);
    glDeleteBuffers(1, (const GLuint *)this + 5);
    *((_DWORD *)this + 5) = 0;
    *((_DWORD *)this + 7) = 0;
    HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v8);
  }
}

void sub_1B770425C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void sub_1B7704270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t GLPBO::_setup(GLPBO *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  if (a2 && *((_DWORD *)this + 7) == a2) {
    return 1;
  }
  GLPBO::_delete(this, a2, a3, a4, a5);
  unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
  if (v10) {
    HGLogger::log((HGLogger *)"pbo", (const char *)1, (HGLogger *)"GLPBO::_setup( size = %d)\n", v8, v9, a2);
  }
  *((_DWORD *)this + 7) = a2;
  v11.var0 = (PC_Sp_counted_base *)*((void *)this + 1);
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v12, &v11.var0);
  PCSharedCount::PCSharedCount(&v11);
  glGenBuffers(1, (GLuint *)this + 5);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v12);
  return 1;
}

void sub_1B7704350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void sub_1B7704364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  _Unwind_Resume(a1);
}

void GLPBO::_map(GLPBO *this)
{
  if (GLPBO::m_ForcePostReadPixelsFinish)
  {
    v4.var0 = (PC_Sp_counted_base *)*((void *)this + 1);
    HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v5, &v4.var0);
    PCSharedCount::PCSharedCount(&v4);
    glFinish();
    HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v5);
  }
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v5, "pbo", 1, "GLPBO::_map()");
  v2.var0 = (PC_Sp_counted_base *)*((void *)this + 1);
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v3, &v2.var0);
  PCSharedCount::PCSharedCount(&v2);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v5);
}

void sub_1B7704424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7704438(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
}

void sub_1B770444C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va1);
  _Unwind_Resume(a1);
}

void sub_1B7704468(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

void sub_1B7704484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t GLPBO::_unmap(GLPBO *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v5, "pbo", 1, "GLPBO::_unmap()");
  v3.var0 = (PC_Sp_counted_base *)*((void *)this + 1);
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v4, &v3.var0);
  PCSharedCount::PCSharedCount(&v3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v4);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v5);
  return 0;
}

void sub_1B7704514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va1);
  _Unwind_Resume(a1);
}

void sub_1B7704530(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10, uint64_t a11, uint64_t a12, char a13)
{
}

void sub_1B770454C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void GLPBO::ReadPixels(PC_Sp_counted_base **this, int a2, uint64_t a3, const char *a4, char *a5, int a6, unsigned int a7, unsigned int a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  int v12 = (int)a5;
  if (this[5])
  {
    GLPBO::_unmap((GLPBO *)this);
    this[5] = 0;
  }
  *((_DWORD *)this + 6) = a6;
  uint64_t v14 = (a6 * v12);
  if (*(_DWORD *)this) {
    uint64_t v14 = (float)(ceilf((float)v14 / (float)*(unsigned int *)this)
  }
                              * (float)*(unsigned int *)this);
  GLPBO::_setup((GLPBO *)this, v14, a3, a4, a5);
  v15.var0 = this[1];
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v16, &v15.var0);
  PCSharedCount::PCSharedCount(&v15);
  *((unsigned char *)this + 36) = 1;
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v16);
}

void sub_1B7704610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7704624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

uint64_t GLPBO::forcePostReadPixelsFinish(uint64_t this)
{
  GLPBO::m_ForcePostReadPixelsFinish = this;
  return this;
}

uint64_t GLPBO::forcePostReadPixelsFence(uint64_t this)
{
  GLPBO::m_ForcePostReadPixelsFence = this;
  return this;
}

void HGPixelBufferObj::HGPixelBufferObj(HGObject *a1)
{
  HGObject::HGObject(a1);
  *(void *)uint64_t v1 = &unk_1F10CA840;
  *(void *)(v1 + 48) = 0;
  *(unsigned char *)(v1 + 56) = 0;
  operator new();
}

void sub_1B77046E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  MEMORY[0x1BA9BFBA0](v11, 0x1080C404AC29809);
  HGObject::~HGObject(v10);
  _Unwind_Resume(a1);
}

void sub_1B770471C(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGPixelBufferObj::~HGPixelBufferObj(HGPixelBufferObj *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  *(void *)this = &unk_1F10CA840;
  uint64_t v6 = (HGRenderUtils::BufferCopier *)*((void *)this + 6);
  if (v6)
  {
    HGRenderUtils::BufferCopier::~BufferCopier(v6);
    MEMORY[0x1BA9BFBA0]();
  }
  uint64_t v7 = *((void *)this + 2);
  if (v7)
  {
    GLPBO::_delete(*((GLPBO **)this + 2), a2, a3, a4, a5);
    v8.var0 = *(PC_Sp_counted_base **)(v7 + 8);
    HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v9, &v8.var0);
    PCSharedCount::PCSharedCount(&v8);
    glDeleteFramebuffers(1, (const GLuint *)(v7 + 16));
    HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v9);
    PCSharedCount::PCSharedCount((PCSharedCount *)(v7 + 8));
    MEMORY[0x1BA9BFBA0](v7, 0x1080C404AC29809);
  }
  HGObject::~HGObject(this);
}

{
  void *v5;
  uint64_t vars8;

  HGPixelBufferObj::~HGPixelBufferObj(this, a2, a3, a4, a5);

  HGObject::operator delete(v5);
}

uint64_t HGPixelBufferObj::rect(HGPixelBufferObj *this)
{
  return *((void *)this + 3);
}

uint64_t HGPixelBufferObj::format(HGPixelBufferObj *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t HGPixelBufferObj::rowBytes(HGPixelBufferObj *this)
{
  return *(unsigned int *)(*((void *)this + 2) + 24);
}

uint64_t HGPixelBufferObj::padding(uint64_t this, int a2)
{
  **(_DWORD **)(this + 16) = a2;
  return this;
}

void HGPixelBufferObj::ReadPixels(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v27, "pbo", 1, "HGPixelBufferObj::ReadPixels()");
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  *(_DWORD *)(a1 + 40) = a8;
  HGFormatUtils::toGLType(a8);
  HGFormatUtils::toGLFormat(*(_DWORD *)(a1 + 40));
  int v12 = HGFormatUtils::bytesPerPixel(*(_DWORD *)(a1 + 40));
  int v18 = *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 24);
  int v19 = *(_DWORD *)(a1 + 40);
  unsigned int v20 = v19 - 14;
  unsigned int v21 = (v18 + 1) >> 1;
  BOOL v22 = v19 == 31;
  int v23 = ((2863311531u * (unint64_t)(v18 + 5)) >> 32) & 0xFFFFFFFC;
  if (!v22) {
    int v23 = *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 24);
  }
  if (v20 >= 3) {
    int v24 = v12;
  }
  else {
    int v24 = 2 * v12;
  }
  if (v20 < 3) {
    int v23 = v21;
  }
  GLPBO::ReadPixels(*(PC_Sp_counted_base ***)(a1 + 16), v13, v14, v15, (char *)(*(_DWORD *)(a1 + 36) - *(_DWORD *)(a1 + 28)), v23 * v24, v16, v17, v25, HIDWORD(v25), v26);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v27);
}

void sub_1B7704950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7704964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7704978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B770498C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77049A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGPixelBufferObj::GetDataPtr(HGPixelBufferObj *this)
{
  uint64_t v1 = *((void *)this + 2);
  uint64_t result = *(void *)(v1 + 40);
  if (!result)
  {
    GLPBO::_map((GLPBO *)v1);
    uint64_t result = *(void *)(v1 + 40);
  }
  *(unsigned char *)(v1 + 36) = 0;
  return result;
}

uint64_t HGPixelBufferObj::ReleaseDataPtr(HGPixelBufferObj *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (*(void *)(v1 + 40))
  {
    GLPBO::_unmap(*((GLPBO **)this + 2));
    *(void *)(v1 + 40) = 0;
  }
  return 0;
}

void HGPixelBufferObj::StartCopyBitmap(HGPixelBufferObj *this, HGBitmap *a2)
{
  uint64_t v4 = HGRectIntersection(*(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28), *((void *)this + 3), *((void *)this + 4));
  BOOL v7 = v5 == v4 || HIDWORD(v5) == HIDWORD(v4);
  if (v7 || (uint64_t v8 = *((unsigned int *)a2 + 4), v8 != *((_DWORD *)this + 10)))
  {
    HGLogger::warning((HGLogger *)"incompatible formats", v5, v6);
  }
  else
  {
    uint64_t v9 = *((void *)this + 2);
    uint64_t v10 = *(void *)(v9 + 40);
    if (v10)
    {
      uint64_t v11 = *((void *)this + 2);
    }
    else
    {
      GLPBO::_map(*((GLPBO **)this + 2));
      uint64_t v10 = *(void *)(v9 + 40);
      uint64_t v11 = *((void *)this + 2);
      uint64_t v8 = *((unsigned int *)this + 10);
    }
    *(unsigned char *)(v9 + 36) = 0;
    HGBitmap::HGBitmap(v14, *((void *)this + 3), *((void *)this + 4), v8, v10, *(unsigned int *)(v11 + 24));
    int v12 = (dispatch_group_t **)*((void *)this + 6);
    if (!v12) {
      operator new();
    }
    HGRenderUtils::BufferCopier::start(v12, a2, (HGBitmap *)v14);
    *((unsigned char *)this + 56) = 1;
    HGBitmap::~HGBitmap((HGBitmap *)v14, v13);
  }
}

void sub_1B7704B3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  MEMORY[0x1BA9BFBA0](v9, 0x20C4093837F09);
  HGBitmap::~HGBitmap((HGBitmap *)&a9, v11);
  _Unwind_Resume(a1);
}

void sub_1B7704B68(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

intptr_t HGPixelBufferObj::FinishCopyBitmap(intptr_t this)
{
  intptr_t v1 = this;
  if (*(unsigned char *)(this + 56))
  {
    this = HGRenderUtils::BufferCopier::finish(*(void *)(this + 48));
    *(unsigned char *)(v1 + 56) = 0;
  }
  return this;
}

void HGPixelBufferObj::CopyBitmap(intptr_t *this, HGBitmap *a2)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v4, "pbo", 1, "HGPixelBufferObj::CopyBitmap()");
  HGPixelBufferObj::StartCopyBitmap((HGPixelBufferObj *)this, a2);
  if (*((unsigned char *)this + 56))
  {
    HGRenderUtils::BufferCopier::finish(this[6]);
    *((unsigned char *)this + 56) = 0;
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v4);
}

void sub_1B7704C38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

HGBitmap *HGPixelBufferObj::CreateBitmap(HGPixelBufferObj *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v4, "pbo", 1, "HGPixelBufferObj::CreateBitmap()");
  PCSharedCount v2 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v2, *((void *)this + 3), *((void *)this + 4), *((unsigned int *)this + 10));
  HGPixelBufferObj::CopyBitmap((intptr_t *)this, v2);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v4);
  return v2;
}

void sub_1B7704CC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGObject::operator delete(v9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B7704CE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7704CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGGPURenderContext::HGGPURenderContext(HGRenderContext *a1)
{
}

void sub_1B7705028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10, uint64_t a11, PCSharedCount a12, PCSharedCount a13, uint64_t a14)
{
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 24))(a11);
  }
  PCSharedCount::PCSharedCount(&a10);
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 24))(a14);
  }
  uint64_t v17 = *((void *)v14 + 23);
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
  }
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v15);
  HGRenderContext::~HGRenderContext(v14);
  _Unwind_Resume(a1);
}

void HGGPURenderContext::~HGGPURenderContext(HGGPURenderContext *this)
{
  *(void *)this = &unk_1F10CA890;
  PCSharedCount v2 = (HGGPURenderer *)*((void *)this + 19);
  if (v2)
  {
    HGGPURenderer::FinishMetalCommandBuffer(v2);
    (*(void (**)(void))(**((void **)this + 19) + 24))(*((void *)this + 19));
  }
  uint64_t v3 = *((void *)this + 23);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = this;
  }
  else
  {
    uint64_t v5 = this;
  }
  HGRenderContext::~HGRenderContext(v5);
}

{
  void *v1;
  uint64_t vars8;

  HGGPURenderContext::~HGGPURenderContext(this);

  HGObject::operator delete(v1);
}

uint64_t HGGPURenderContext::DumpContext(HGGPURenderContext *this)
{
  puts("-----------------------------------------");
  printf("Dumping HGGPURenderContext: %p\n", this);
  printf("    _state                    : %d\n", *((_DWORD *)this + 8));
  printf("    _type                     : %d\n", *((_DWORD *)this + 9));
  printf("    _renderer                 : %p\n", *((const void **)this + 9));
  printf("    _renderQueue              : %p\n", *((const void **)this + 6));
  printf("    _renderGraphDumpLevel     : %d\n", *((_DWORD *)this + 22));
  printf("    _intermediateBufferFormat : %d\n", *((_DWORD *)this + 20));
  printf("    _defaultFilteringMode     : %d\n", *((_DWORD *)this + 21));
  printf("    _concatenationFlag        : %d\n", *((unsigned __int8 *)this + 176));
  printf("    _renderStatsFlag          : %d\n", *((unsigned __int8 *)this + 92));
  printf("    _renderStatsWarmUp        : %lu\n", *((void *)this + 12));
  printf("    _renderStatsMaxVals       : %lu\n", *((void *)this + 13));

  return puts("-----------------------------------------");
}

uint64_t HGGPURenderContext::GetGPURenderer(HGGPURenderContext *this)
{
  return *((void *)this + 19);
}

void HGGPURenderContext::GetGLContext(HGGLContext **this@<X0>, HGGLContextPtr *a2@<X8>)
{
  uint64_t v3 = (void *)HGGLContext::ptr(this[23]);

  HGGLContextPtr::HGGLContextPtr(a2, v3);
}

uint64_t HGGPURenderContext::GetGLContextPriority(HGGLContext **this)
{
  return HGGLContext::getPriority(this[23]);
}

void HGGPURenderContext::SetGLContextPriority(uint64_t a1)
{
  uint64_t v3 = *(HGSynchronizable **)(a1 + 56);
  char v4 = 0;
  HGSynchronizable::Lock(v3);
  HGGPURenderer::GetContext(*(void *)(a1 + 72), 24, (uint64_t *)&v2);
  HGGLContext::Share();
}

void sub_1B7705580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11, uint64_t a12, HGSynchronizable *a13)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 24))(a12);
  }
  HGSynchronizer::~HGSynchronizer(&a13);
  _Unwind_Resume(a1);
}

HGSynchronizable *HGGPURenderContext::SetGLTexturePoolingPolicy(uint64_t a1, uint64_t *a2)
{
  char v4 = *(HGSynchronizable **)(a1 + 56);
  v8[1] = v4;
  char v9 = 0;
  HGSynchronizable::Lock(v4);
  uint64_t v5 = *(void *)(*(void *)(a1 + 152) + 1472);
  if (v5)
  {
    uint64_t v6 = *a2;
    v8[0] = v6;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
    }
    HGTextureManager::setTexturePoolingPolicy(v5, v8);
    if (v8[0]) {
      (*(void (**)(void))(*(void *)v8[0] + 24))(v8[0]);
    }
  }
  return HGSynchronizable::Unlock(v4);
}

void sub_1B7705704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7705718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (a3) {
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
  }
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

HGSynchronizable *HGGPURenderContext::SetGLTexturePaddingPolicy(uint64_t a1, void **a2)
{
  char v4 = *(HGSynchronizable **)(a1 + 56);
  v8[1] = &v4->var0;
  char v9 = 0;
  HGSynchronizable::Lock(v4);
  uint64_t v5 = *(void **)(*(void *)(a1 + 152) + 1472);
  if (v5)
  {
    uint64_t v6 = *a2;
    v8[0] = v6;
    if (v6) {
      (*(void (**)(void *))(*v6 + 16))(v6);
    }
    HGTextureManager::setTexturePaddingPolicy(v5, v8);
    if (v8[0]) {
      (*(void (**)(void *))(*v8[0] + 24))(v8[0]);
    }
  }
  return HGSynchronizable::Unlock(v4);
}

void sub_1B7705828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B770583C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (a3) {
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
  }
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void HRasterizerTextureNoColor::HRasterizerTextureNoColor(HRasterizerTextureNoColor *this)
{
}

void sub_1B77058EC(_Unwind_Exception *a1)
{
  HgcRasterizerTextureNoColor::~HgcRasterizerTextureNoColor(v1);
  _Unwind_Resume(a1);
}

void HRasterizerTextureNoColor::~HRasterizerTextureNoColor(HRasterizerTextureNoColor *this)
{
  HgcRasterizerTextureNoColor::~HgcRasterizerTextureNoColor(this);

  HGObject::operator delete(v1);
}

HGRect *HGRect::Init(HGRect *this, int a2, int a3, int a4, int a5)
{
  if (a2 >= a4) {
    int v5 = a4;
  }
  else {
    int v5 = a2;
  }
  if (a2 <= a4) {
    int v6 = a4;
  }
  else {
    int v6 = a2;
  }
  if (a3 >= a5) {
    int v7 = a5;
  }
  else {
    int v7 = a3;
  }
  this->var0 = v5;
  this->var1 = v7;
  if (a3 <= a5) {
    int v8 = a5;
  }
  else {
    int v8 = a3;
  }
  this->var2 = v6;
  this->var3 = v8;
  return this;
}

float HGRectf::Init(HGRectf *this, float a2, float a3, float a4, float a5)
{
  float v5 = fminf(a2, a4);
  float result = fmaxf(a2, a4);
  *(float *)this = v5;
  *((float *)this + 1) = fminf(a3, a5);
  *((float *)this + 2) = result;
  *((float *)this + 3) = fmaxf(a3, a5);
  return result;
}

int32x2_t HGRect::Init(void *a1, double a2, float a3, double a4, float a5)
{
  if (*(float *)&a4 < *(float *)&a2 || a5 < a3)
  {
    int32x2_t result = 0;
    *a1 = 0;
    a1[1] = 0;
  }
  else
  {
    *((float *)&a2 + 1) = a3;
    int32x2_t result = vcvt_s32_f32(vrndm_f32(vmaxnm_f32(*(float32x2_t *)&a2, (float32x2_t)0xCF000000CF000000)));
    *((float *)&a4 + 1) = a5;
    float32x2_t v7 = vrndp_f32(vminnm_f32(*(float32x2_t *)&a4, (float32x2_t)0x4F0000004F000000));
    int8x8_t v8 = (int8x8_t)vcge_f32(v7, (float32x2_t)0x4F0000004F000000);
    *a1 = result;
    a1[1] = vorr_s8((int8x8_t)(*(void *)&v8 & 0x7FFFFFFF7FFFFFFFLL), vbic_s8((int8x8_t)vcvt_s32_f32(v7), v8));
  }
  return result;
}

HGRect *HGRect::Grow(HGRect *this, HGRect a2)
{
  int var1 = this->var1;
  if (this->var0 >= (a2.var0 ^ 0x7FFFFFFF)) {
    int v3 = 0x7FFFFFFF;
  }
  else {
    int v3 = this->var0 + a2.var0;
  }
  if (this->var0 <= (signed int)(0x80000000 - a2.var0)) {
    int v4 = 0x80000000;
  }
  else {
    int v4 = this->var0 + a2.var0;
  }
  if (a2.var0 > 0) {
    int v4 = v3;
  }
  if (var1 >= (a2.var1 ^ 0x7FFFFFFF)) {
    int v5 = 0x7FFFFFFF;
  }
  else {
    int v5 = var1 + a2.var1;
  }
  if (var1 <= (int)(0x80000000 - a2.var1)) {
    unsigned int v6 = 0x80000000;
  }
  else {
    unsigned int v6 = var1 + a2.var1;
  }
  if (a2.var1 <= 0) {
    int v7 = v6;
  }
  else {
    int v7 = v5;
  }
  int var2 = this->var2;
  int var3 = this->var3;
  int v10 = var2 + a2.var2;
  if (var2 >= (a2.var2 ^ 0x7FFFFFFF)) {
    int v11 = 0x7FFFFFFF;
  }
  else {
    int v11 = var2 + a2.var2;
  }
  if (var2 <= (int)(0x80000000 - a2.var2)) {
    int v10 = 0x80000000;
  }
  if (a2.var2 > 0) {
    int v10 = v11;
  }
  if (var3 >= (a2.var3 ^ 0x7FFFFFFF)) {
    int v12 = 0x7FFFFFFF;
  }
  else {
    int v12 = var3 + a2.var3;
  }
  if (var3 <= (int)(0x80000000 - a2.var3)) {
    unsigned int v13 = 0x80000000;
  }
  else {
    unsigned int v13 = var3 + a2.var3;
  }
  this->var0 = v4;
  this->int var1 = v7;
  if (a2.var3 <= 0) {
    int v14 = v13;
  }
  else {
    int v14 = v12;
  }
  this->int var2 = v10;
  this->int var3 = v14;
  return this;
}

BOOL HGRect::IsEqual(HGRect *this, HGRect a2)
{
  return this->var0 == a2.var0 && this->var1 == a2.var1 && this->var2 == a2.var2 && this->var3 == a2.var3;
}

BOOL HGRect::IsInfinite(HGRect *this)
{
  if (this->var0 == 0x80000000) {
    return 1;
  }
  if (this->var1 == 0x80000000) {
    return 1;
  }
  if (this->var2 == 0x7FFFFFFF) {
    return 1;
  }
  return this->var3 == 0x7FFFFFFF;
}

BOOL HGRect::IsNull(HGRect *this)
{
  return this->var2 <= this->var0 || this->var3 <= this->var1;
}

BOOL HGRect::IsZero(HGRect *this)
{
  if (this->var0) {
    return 0;
  }
  if (this->var1) {
    return 0;
  }
  if (this->var2) {
    return 0;
  }
  return this->var3 == 0;
}

BOOL HGRect::ContainsRect(HGRect *this, HGRect a2)
{
  if (this->var0 > a2.var0) {
    return 0;
  }
  if (this->var1 > a2.var1) {
    return 0;
  }
  if (this->var2 >= a2.var2) {
    return this->var3 >= a2.var3;
  }
  return 0;
}

HGRect *HGRect::Intersection(HGRect *this, HGRect a2)
{
  int var2 = this->var2;
  int var0 = this->var0;
  if (var2 <= this->var0) {
    goto LABEL_21;
  }
  int var1 = a2.var1;
  int var3 = a2.var3;
  int v6 = this->var3;
  int v7 = this->var1;
  BOOL v8 = v6 <= v7 || a2.var2 <= a2.var0;
  BOOL v9 = v8 || a2.var3 <= a2.var1;
  BOOL v10 = v9 || var2 <= a2.var0;
  BOOL v11 = v10 || v6 <= a2.var1;
  BOOL v12 = !v11 && var0 < a2.var2;
  if (v12 && v7 < a2.var3)
  {
    if (var0 <= a2.var0) {
      int var0 = a2.var0;
    }
    if (v7 > a2.var1) {
      int var1 = this->var1;
    }
    this->int var0 = var0;
    this->int var1 = var1;
    if (var2 >= a2.var2) {
      int var2 = a2.var2;
    }
    if (v6 < a2.var3) {
      int var3 = v6;
    }
    this->int var2 = var2;
    this->int var3 = var3;
  }
  else
  {
LABEL_21:
    *(void *)&this->int var0 = 0;
    *(void *)&this->int var2 = 0;
  }
  return this;
}

uint64_t HGRectMake4i(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if ((int)a1 >= (int)a3) {
    uint64_t v4 = a3;
  }
  else {
    uint64_t v4 = a1;
  }
  if ((int)a2 >= (int)a4) {
    uint64_t v5 = a4;
  }
  else {
    uint64_t v5 = a2;
  }
  return v4 | (v5 << 32);
}

HGRect *HGRect::Union(HGRect *this, HGRect a2)
{
  if (a2.var2 > a2.var0)
  {
    int var1 = a2.var1;
    int var3 = a2.var3;
    if (a2.var3 > a2.var1)
    {
      int var0 = this->var0;
      if (this->var0 >= a2.var0) {
        int var0 = a2.var0;
      }
      if (this->var1 < a2.var1) {
        int var1 = this->var1;
      }
      this->int var0 = var0;
      this->int var1 = var1;
      int var2 = this->var2;
      if (var2 <= a2.var2) {
        int var2 = a2.var2;
      }
      if (this->var3 > a2.var3) {
        int var3 = this->var3;
      }
      this->int var2 = var2;
      this->int var3 = var3;
    }
  }
  return this;
}

float HGRectFloat(int a1)
{
  return (float)a1;
}

uint64_t HGRectGrow(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v3) = a3 + a1;
  if ((int)(a3 ^ 0x7FFFFFFF) <= (int)a1) {
    unsigned int v4 = 0x7FFFFFFF;
  }
  else {
    unsigned int v4 = a3 + a1;
  }
  if ((int)(0x80000000 - a3) >= (int)a1) {
    LODWORD(v3) = 0x80000000;
  }
  if ((int)a3 <= 0) {
    uint64_t v3 = v3;
  }
  else {
    uint64_t v3 = v4;
  }
  if ((HIDWORD(a3) ^ 0x7FFFFFFF) <= SHIDWORD(a1)) {
    unsigned int v5 = 0x7FFFFFFF;
  }
  else {
    unsigned int v5 = HIDWORD(a3) + HIDWORD(a1);
  }
  if ((int)(0x80000000 - HIDWORD(a3)) >= SHIDWORD(a1)) {
    LODWORD(v6) = 0x80000000;
  }
  else {
    LODWORD(v6) = HIDWORD(a3) + HIDWORD(a1);
  }
  if (SHIDWORD(a3) <= 0) {
    uint64_t v6 = v6;
  }
  else {
    uint64_t v6 = v5;
  }
  return v3 | (v6 << 32);
}

BOOL HGRectIsEqual(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 == a3 && a2 == a4 && HIDWORD(a2) == HIDWORD(a4);
}

BOOL HGRectIsEqualSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 - a1 == a4 - a3 && HIDWORD(a2) - HIDWORD(a1) == HIDWORD(a4) - HIDWORD(a3);
}

BOOL HGRectIsInfinite(unint64_t a1, unint64_t a2)
{
  return a1 == 0x80000000 || HIDWORD(a1) == 0x80000000 || a2 == 0x7FFFFFFF || HIDWORD(a2) == 0x7FFFFFFF;
}

BOOL HGRectIsNull(uint64_t a1, uint64_t a2)
{
  return (int)a2 <= (int)a1 || SHIDWORD(a2) <= SHIDWORD(a1);
}

BOOL HGRectContainsRect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (int)a1 <= (int)a3 && SHIDWORD(a1) <= SHIDWORD(a3) && (int)a2 >= (int)a4 && SHIDWORD(a2) >= SHIDWORD(a4);
}

BOOL HGRectExcludesRect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (int)a1 > (int)a4 || SHIDWORD(a1) > SHIDWORD(a4) || (int)a2 < (int)a3 || SHIDWORD(a2) < SHIDWORD(a3);
}

uint64_t HGRectIntegral@<X0>(uint64_t a1@<X8>, float a2@<S0>, float a3@<S1>, float a4@<S2>, float a5@<S3>)
{
  if (a4 < a2 || a5 < a3) {
    return 0;
  }
  LODWORD(a1) = vcvtms_s32_f32(fmaxf(a2, -2147500000.0));
  LODWORD(v5) = vcvtms_s32_f32(fmaxf(a3, -2147500000.0));
  return a1 | (v5 << 32);
}

uint64_t HGRectIntersection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((int)a2 <= (int)a1) {
    return 0;
  }
  uint64_t v4 = 0;
  if (SHIDWORD(a2) <= SHIDWORD(a1)
    || (int)a4 <= (int)a3
    || SHIDWORD(a4) <= SHIDWORD(a3)
    || (int)a2 <= (int)a3
    || SHIDWORD(a2) <= SHIDWORD(a3)
    || (int)a1 >= (int)a4)
  {
    return 0;
  }
  uint64_t v5 = 0;
  if (SHIDWORD(a1) < SHIDWORD(a4))
  {
    if ((int)a1 <= (int)a3) {
      uint64_t v4 = a3;
    }
    else {
      uint64_t v4 = a1;
    }
    if (SHIDWORD(a1) <= SHIDWORD(a3)) {
      uint64_t v6 = HIDWORD(a3);
    }
    else {
      uint64_t v6 = HIDWORD(a1);
    }
    uint64_t v5 = v6 << 32;
  }
  return v5 | v4;
}

uint64_t HGRectMake4f@<X0>(uint64_t a1@<X8>, float a2@<S0>, float a3@<S1>, float a4@<S2>, float a5@<S3>)
{
  float v6 = fminf(a2, a4);
  float v7 = fmaxf(a2, a4);
  float v8 = fminf(a3, a5);
  float v9 = fmaxf(a3, a5);
  if (v7 < v6 || v9 < v8) {
    return 0;
  }
  LODWORD(a1) = vcvtms_s32_f32(fmaxf(v6, -2147500000.0));
  LODWORD(v5) = vcvtms_s32_f32(fmaxf(v8, -2147500000.0));
  return a1 | (v5 << 32);
}

float HGRectfMake4f(float a1, double a2, float a3)
{
  return fminf(a1, a3);
}

float HGRectTranslate(float a1, double a2, float a3, double a4, float a5)
{
  return fminf(a1 + a5, a3 + a5);
}

float HGRectScale(float a1, double a2, float a3, double a4, float a5)
{
  float v5 = a1 * a5;
  float v6 = a3 * a5;
  float v7 = fminf(v5, v6);
  float v8 = fminf(v6, v5);
  if (a5 < 0.0) {
    return v8;
  }
  else {
    return v7;
  }
}

uint64_t HGRectUnion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((int)a2 > (int)a1 && SHIDWORD(a2) > SHIDWORD(a1))
  {
    if ((int)a1 >= (int)a3) {
      uint64_t v4 = a3;
    }
    else {
      uint64_t v4 = a1;
    }
    if (SHIDWORD(a1) >= SHIDWORD(a3)) {
      uint64_t v5 = HIDWORD(a3);
    }
    else {
      uint64_t v5 = HIDWORD(a1);
    }
    uint64_t v6 = v4 | (v5 << 32);
    if (SHIDWORD(a4) <= SHIDWORD(a3)) {
      uint64_t v6 = a1;
    }
    if ((int)a4 > (int)a3) {
      return v6;
    }
    else {
      return a1;
    }
  }
  return a3;
}

void HGRenderUtils::BufferCopierImpl::~BufferCopierImpl(dispatch_group_t *this)
{
  if (*((unsigned char *)this + 72))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((unsigned char *)this + 72) = 0;
  }
  dispatch_release(*this);
}

{
  if (*((unsigned char *)this + 72))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((unsigned char *)this + 72) = 0;
  }
  dispatch_release(*this);
}

intptr_t HGRenderUtils::BufferCopierImpl::finish_dispatch(intptr_t this)
{
  if (*(unsigned char *)(this + 72))
  {
    intptr_t v1 = this;
    this = dispatch_group_wait(*(dispatch_group_t *)this, 0xFFFFFFFFFFFFFFFFLL);
    *(unsigned char *)(v1 + 72) = 0;
  }
  return this;
}

uint64_t HGRenderUtils::BufferCopierImpl::_build_context@<X0>(HGRenderUtils::BufferCopierImpl *this@<X0>, HGBitmap *a2@<X1>, HGBitmap *a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = HGRectIntersection(*(void *)((char *)a3 + 20), *(void *)((char *)a3 + 28), *(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28));
  v9.i32[0] = *((_DWORD *)a3 + 5);
  v9.i32[1] = *((_DWORD *)a2 + 5);
  int32x2_t v10 = vsub_s32(vdup_n_s32(v7), v9);
  v11.i64[0] = v10.i32[0];
  v11.i64[1] = v10.i32[1];
  uint64x2_t v12 = v11;
  uint64_t v14 = (v13 - v7);
  uint64_t v15 = *((void *)a3 + 7);
  if (*((_DWORD *)a3 + 4) == 31)
  {
    unint64_t v16 = 4 * v15 * ((v14 + 5) / 6uLL);
    float64x2_t v17 = vcvtq_f64_u64(v12);
    __asm { FMOV            V1.2D, #3.0 }
    uint64x2_t v12 = vcvtq_u64_f64(vdivq_f64(vaddq_f64(v17, v17), _Q1));
  }
  else
  {
    unint64_t v16 = v15 * v14;
  }
  uint64_t v23 = *((void *)a3 + 8);
  uint64_t v25 = *((void *)a2 + 7);
  uint64_t v24 = *((void *)a2 + 8);
  unint64_t v26 = (v8 - HIDWORD(v7));
  uint64_t result = v7 >> 32;
  uint64_t v28 = *((void *)a2 + 10) + v24 * (result - *((int *)a2 + 6));
  *a4 = *((void *)a3 + 10) + v23 * (result - *((int *)a3 + 6)) + v12.i64[0] * v15;
  a4[1] = v28 + v25 * v12.i64[1];
  uint64_t v29 = 4;
  if (v23 != v16 || v24 != v16) {
    uint64_t v29 = v26 >> 2;
  }
  a4[2] = v23;
  a4[3] = v24;
  if (v26 < 0x40) {
    uint64_t v29 = v26;
  }
  a4[4] = v16;
  a4[5] = v26;
  a4[6] = v29;
  a4[7] = 0;
  *((unsigned char *)a4 + 56) = v23 == v16 && v24 == v16;
  return result;
}

void *HGRenderUtils::BufferCopierImpl::plain_copy(HGRenderUtils::BufferCopierImpl *this, HGBitmap *a2, HGBitmap *a3)
{
  uint64_t result = (void *)HGRenderUtils::BufferCopierImpl::_build_context(this, a2, a3, v16);
  long long v5 = v16[1];
  *(_OWORD *)((char *)this + 8) = v16[0];
  *(_OWORD *)((char *)this + 24) = v5;
  long long v6 = v16[3];
  *(_OWORD *)((char *)this + 40) = v16[2];
  *(_OWORD *)((char *)this + 56) = v6;
  if (*((unsigned char *)this + 64)) {
    return memcpy(*((void **)this + 2), *((const void **)this + 1), *((void *)this + 6) * *((void *)this + 5));
  }
  unint64_t v7 = *((void *)this + 6);
  if (v7)
  {
    uint64_t v8 = *((void *)this + 3);
    uint64_t v9 = *((void *)this + 4);
    size_t v10 = *((void *)this + 5);
    unsigned int v11 = 1;
    uint64_t v14 = (char *)this + 8;
    uint64x2_t v12 = (char *)*((void *)this + 1);
    int v13 = (char *)*((void *)v14 + 1);
    do
    {
      uint64_t result = memcpy(v13, v12, v10);
      v12 += v8;
      v13 += v9;
    }
    while (v7 > v11++);
  }
  return result;
}

void HGRenderUtils::BufferCopierImpl::start_dispatch(dispatch_group_t *this, HGBitmap *a2, HGBitmap *a3)
{
  long long v5 = this;
  if (*((unsigned char *)this + 72))
  {
    this = (dispatch_group_t *)dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((unsigned char *)v5 + 72) = 0;
  }
  HGRenderUtils::BufferCopierImpl::_build_context((HGRenderUtils::BufferCopierImpl *)this, a2, a3, v12);
  long long v6 = v12[1];
  *(_OWORD *)(v5 + 1) = v12[0];
  *(_OWORD *)(v5 + 3) = v6;
  long long v7 = v12[3];
  *(_OWORD *)(v5 + 5) = v12[2];
  *(_OWORD *)(v5 + 7) = v7;
  int v8 = *((unsigned __int8 *)v5 + 64);
  uint64_t v9 = *v5;
  global_queue = dispatch_get_global_queue(0, 0);
  if (v8) {
  else
  }
  dispatch_group_async_f(v9, global_queue, v5 + 1, v11);
  *((unsigned char *)v5 + 72) = 1;
}

void anonymous namespace'::block_single_copy_dispatch(_anonymous_namespace_ *this, void *a2)
{
  size_t v3 = *((void *)this + 6);
  global_queue = dispatch_get_global_queue(0, 0);
}

void anonymous namespace'::block_copy_dispatch(_anonymous_namespace_ *this, void *a2)
{
  size_t v3 = *((void *)this + 6);
  global_queue = dispatch_get_global_queue(0, 0);
}

void HGRenderUtils::BufferReformatterImpl::~BufferReformatterImpl(dispatch_group_t *this)
{
  if (*((unsigned char *)this + 32))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((unsigned char *)this + 32) = 0;
  }
  dispatch_release(*this);
}

{
  if (*((unsigned char *)this + 32))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((unsigned char *)this + 32) = 0;
  }
  dispatch_release(*this);
}

intptr_t HGRenderUtils::BufferReformatterImpl::finish_dispatch(intptr_t this)
{
  if (*(unsigned char *)(this + 32))
  {
    intptr_t v1 = this;
    this = dispatch_group_wait(*(dispatch_group_t *)this, 0xFFFFFFFFFFFFFFFFLL);
    *(unsigned char *)(v1 + 32) = 0;
  }
  return this;
}

pthread_mutex_t *HGRenderUtils::BufferReformatterImpl::plain_reformat(HGRenderUtils::BufferReformatterImpl *this, HGBitmap *a2, HGBitmap *a3)
{
  uint64_t v5 = *(void *)((char *)a2 + 20);
  uint64_t v6 = *(void *)((char *)a2 + 28);
  long long v7 = (HGMemory *)HGMemory::allocate((HGMemory *)(16 * (v6 - v5) * (HIDWORD(v6) - HIDWORD(v5))), 0, (unint64_t *)a3);
  (*(void (**)(HGBitmap *, HGMemory *, uint64_t, uint64_t, void))(*(void *)a3 + 72))(a3, v7, v5, v6, 0);
  (*(void (**)(HGBitmap *, HGMemory *, uint64_t, uint64_t))(*(void *)a2 + 80))(a2, v7, v5, v6);
  return HGMemory::release(v7, v8);
}

void HGRenderUtils::BufferReformatterImpl::start_dispatch(dispatch_group_t *this, HGBitmap *a2, NSObject *a3)
{
  if (*((unsigned char *)this + 32))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((unsigned char *)this + 32) = 0;
  }
  unint64_t v6 = (*((_DWORD *)a2 + 8) - *((_DWORD *)a2 + 6));
  if (v6 >= 0x40) {
    v6 >>= 2;
  }
  this[1] = a3;
  this[2] = (dispatch_group_t)a2;
  this[3] = (dispatch_group_t)v6;
  long long v7 = *this;
  global_queue = dispatch_get_global_queue(0, 0);
  *((unsigned char *)this + 32) = 1;
}

void anonymous namespace'::block_reformat_dispatch(_anonymous_namespace_ *this, void *a2)
{
  size_t v3 = *((void *)this + 2);
  global_queue = dispatch_get_global_queue(0, 0);
}

void HGRenderUtils::BufferFillerImpl::~BufferFillerImpl(dispatch_group_t *this)
{
  if (*((unsigned char *)this + 240))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((unsigned char *)this + 240) = 0;
  }
  dispatch_release(*this);
  dispatch_group_t v2 = this[29];
  if (v2) {
    MEMORY[0x1BA9BFB70](v2, 0x1000C8077774924);
  }
}

{
  dispatch_group_t v2;

  if (*((unsigned char *)this + 240))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((unsigned char *)this + 240) = 0;
  }
  dispatch_release(*this);
  dispatch_group_t v2 = this[29];
  if (v2) {
    MEMORY[0x1BA9BFB70](v2, 0x1000C8077774924);
  }
}

intptr_t HGRenderUtils::BufferFillerImpl::finish_dispatch(intptr_t this)
{
  if (*(unsigned char *)(this + 240))
  {
    intptr_t v1 = this;
    this = dispatch_group_wait(*(dispatch_group_t *)this, 0xFFFFFFFFFFFFFFFFLL);
    *(unsigned char *)(v1 + 240) = 0;
  }
  return this;
}

void HGRenderUtils::BufferFillerImpl::plain_fill(HGRenderUtils::BufferFillerImpl *this, HGBitmap *a2, HGRect a3, unsigned __int8 *a4)
{
  uint64_t v4 = *(void *)&a3.var2;
  uint64_t v5 = *(void *)&a3.var0;
  int v8 = (_OWORD *)((char *)a2 + 20);
  uint64_t v9 = HGRectIntersection(*(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28), *(uint64_t *)&a3.var0, *(uint64_t *)&a3.var2);
  unint64_t v11 = v10;
  std::string __p = 0;
  BOOL v22 = 0;
  uint64_t v23 = 0;
  if (HGRectIsNull(v5, v4))
  {
    uint64x2_t v12 = 0;
    int v13 = 0;
  }
  else
  {
    if (!HGRectIsNull(v9, v11))
    {
      goto LABEL_16;
    }
    uint64x2_t v12 = v22;
    int v13 = v23;
  }
  uint64_t v14 = (v12 - (unsigned char *)__p) >> 4;
  unint64_t v15 = v14 + 1;
  if ((unint64_t)(v14 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v16 = v13 - (unsigned char *)__p;
  if (v16 >> 3 > v15) {
    unint64_t v15 = v16 >> 3;
  }
  if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v17 = v15;
  }
  if (v17)
  {
    if (v17 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int v18 = (char *)operator new(16 * v17);
  }
  else
  {
    int v18 = 0;
  }
  int v19 = &v18[16 * v14];
  *(_OWORD *)int v19 = *v8;
  std::string __p = v19;
  uint64_t v23 = &v18[16 * v17];
  BOOL v22 = v19 + 16;
LABEL_16:
  uint64_t v20 = *((void *)this + 29);
  if (v20) {
    MEMORY[0x1BA9BFB70](v20, 0x1000C8077774924);
  }
  operator new[]();
}

void sub_1B7706C28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::subdivideRect(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t **a5)
{
  signed int v7 = a3;
  unint64_t v8 = a2;
  signed int v9 = a1;
  unint64_t v10 = HIDWORD(a3);
  unint64_t v75 = HIDWORD(a3);
  if (SHIDWORD(a3) > SHIDWORD(a1))
  {
    uint64_t v11 = HGRectMake4i(a1, HIDWORD(a1), a2, HIDWORD(a3));
    uint64_t v13 = v11;
    uint64_t v14 = v12;
    uint64_t v16 = a5[1];
    unint64_t v15 = (unint64_t)a5[2];
    if ((unint64_t)v16 < v15)
    {
      uint64_t *v16 = v11;
      v16[1] = v12;
      uint64_t v17 = (uint64_t)(v16 + 2);
LABEL_17:
      a5[1] = (uint64_t *)v17;
      goto LABEL_18;
    }
    unint64_t v73 = a4;
    int v18 = *a5;
    uint64_t v19 = ((char *)v16 - (char *)*a5) >> 4;
    unint64_t v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 60) {
      goto LABEL_80;
    }
    uint64_t v21 = v15 - (void)v18;
    if (v21 >> 3 > v20) {
      unint64_t v20 = v21 >> 3;
    }
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v22 = v20;
    }
    if (v22)
    {
      if (v22 >> 60) {
        goto LABEL_81;
      }
      uint64_t v23 = (char *)operator new(16 * v22);
      uint64_t v24 = (uint64_t *)&v23[16 * v19];
      uint64_t v25 = (uint64_t *)&v23[16 * v22];
      *uint64_t v24 = v13;
      v24[1] = v14;
      uint64_t v17 = (uint64_t)(v24 + 2);
      if (v16 != v18)
      {
LABEL_13:
        a4 = v73;
        do
        {
          *((_OWORD *)v24 - 1) = *((_OWORD *)v16 - 1);
          v24 -= 2;
          v16 -= 2;
        }
        while (v16 != v18);
        uint64_t v16 = *a5;
        *a5 = v24;
        a5[1] = (uint64_t *)v17;
        a5[2] = v25;
        LODWORD(v10) = v75;
        if (!v16) {
          goto LABEL_17;
        }
LABEL_16:
        operator delete(v16);
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v24 = (uint64_t *)(16 * v19);
      uint64_t v25 = 0;
      *uint64_t v24 = v11;
      v24[1] = v12;
      uint64_t v17 = 16 * v19 + 16;
      if (v16 != v18) {
        goto LABEL_13;
      }
    }
    a4 = v73;
    LODWORD(v10) = v75;
    *a5 = v24;
    a5[1] = (uint64_t *)v17;
    a5[2] = v25;
    if (!v16) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_18:
  unint64_t v26 = HIDWORD(a4);
  if (SHIDWORD(a4) >= SHIDWORD(v8)) {
    goto LABEL_35;
  }
  uint64_t v27 = HGRectMake4i(v9, HIDWORD(a4), v8, HIDWORD(v8));
  uint64_t v29 = v27;
  uint64_t v30 = v28;
  unsigned __int8 v32 = a5[1];
  unint64_t v31 = (unint64_t)a5[2];
  if ((unint64_t)v32 >= v31)
  {
    int v72 = v8;
    int v74 = a4;
    unint64_t v34 = *a5;
    uint64_t v35 = ((char *)v32 - (char *)*a5) >> 4;
    unint64_t v36 = v35 + 1;
    if ((unint64_t)(v35 + 1) >> 60) {
      goto LABEL_80;
    }
    uint64_t v37 = v31 - (void)v34;
    if (v37 >> 3 > v36) {
      unint64_t v36 = v37 >> 3;
    }
    if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v38 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v38 = v36;
    }
    if (v38)
    {
      if (v38 >> 60) {
        goto LABEL_81;
      }
      unint64_t v39 = (char *)operator new(16 * v38);
      uint64_t v40 = (uint64_t *)&v39[16 * v35];
      uint64_t v41 = (uint64_t *)&v39[16 * v38];
      *uint64_t v40 = v29;
      v40[1] = v30;
      uint64_t v33 = (uint64_t)(v40 + 2);
      if (v32 != v34)
      {
LABEL_30:
        LODWORD(v8) = v72;
        LODWORD(a4) = v74;
        LODWORD(v10) = v75;
        do
        {
          *((_OWORD *)v40 - 1) = *((_OWORD *)v32 - 1);
          v40 -= 2;
          v32 -= 2;
        }
        while (v32 != v34);
        unsigned __int8 v32 = *a5;
        *a5 = v40;
        a5[1] = (uint64_t *)v33;
        a5[2] = v41;
        if (!v32) {
          goto LABEL_34;
        }
LABEL_33:
        operator delete(v32);
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v40 = (uint64_t *)(16 * v35);
      uint64_t v41 = 0;
      *uint64_t v40 = v27;
      v40[1] = v28;
      uint64_t v33 = 16 * v35 + 16;
      if (v32 != v34) {
        goto LABEL_30;
      }
    }
    LODWORD(v8) = v72;
    LODWORD(a4) = v74;
    LODWORD(v10) = v75;
    *a5 = v40;
    a5[1] = (uint64_t *)v33;
    a5[2] = v41;
    if (!v32) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
  *unsigned __int8 v32 = v27;
  v32[1] = v28;
  uint64_t v33 = (uint64_t)(v32 + 2);
  LODWORD(v10) = v75;
LABEL_34:
  a5[1] = (uint64_t *)v33;
LABEL_35:
  if (v7 > v9)
  {
    uint64_t v42 = HGRectMake4i(v9, v10, v7, v26);
    uint64_t v44 = v42;
    uint64_t v45 = v43;
    unint64_t v47 = a5[1];
    unint64_t v46 = (unint64_t)a5[2];
    if ((unint64_t)v47 >= v46)
    {
      int v49 = a4;
      uint64_t v50 = *a5;
      a4 = ((char *)v47 - (char *)*a5) >> 4;
      unint64_t v51 = a4 + 1;
      if ((a4 + 1) >> 60) {
        goto LABEL_80;
      }
      int v52 = v8;
      uint64_t v53 = v46 - (void)v50;
      if (v53 >> 3 > v51) {
        unint64_t v51 = v53 >> 3;
      }
      if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v8 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v8 = v51;
      }
      if (v8)
      {
        if (v8 >> 60) {
          goto LABEL_81;
        }
        uint64_t v54 = (char *)operator new(16 * v8);
      }
      else
      {
        uint64_t v54 = 0;
      }
      uint64_t v55 = (uint64_t *)&v54[16 * a4];
      unint64_t v56 = (uint64_t *)&v54[16 * v8];
      *uint64_t v55 = v44;
      v55[1] = v45;
      unint64_t v48 = v55 + 2;
      LODWORD(v8) = v52;
      LODWORD(a4) = v49;
      if (v47 != v50)
      {
        do
        {
          *((_OWORD *)v55 - 1) = *((_OWORD *)v47 - 1);
          v55 -= 2;
          v47 -= 2;
        }
        while (v47 != v50);
        unint64_t v47 = *a5;
      }
      LODWORD(v10) = v75;
      *a5 = v55;
      a5[1] = v48;
      a5[2] = v56;
      if (v47) {
        operator delete(v47);
      }
    }
    else
    {
      *unint64_t v47 = v42;
      v47[1] = v43;
      unint64_t v48 = v47 + 2;
    }
    a5[1] = v48;
  }
  if ((int)a4 >= (int)v8) {
    return;
  }
  uint64_t v57 = HGRectMake4i(a4, v10, v8, v26);
  uint64_t v59 = v57;
  uint64_t v60 = v58;
  int64_t v62 = a5[1];
  unint64_t v61 = (unint64_t)a5[2];
  if ((unint64_t)v62 >= v61)
  {
    v64 = *a5;
    uint64_t v65 = ((char *)v62 - (char *)*a5) >> 4;
    unint64_t v66 = v65 + 1;
    if (!((unint64_t)(v65 + 1) >> 60))
    {
      uint64_t v67 = v61 - (void)v64;
      if (v67 >> 3 > v66) {
        unint64_t v66 = v67 >> 3;
      }
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v68 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v68 = v66;
      }
      if (!v68)
      {
        v70 = (uint64_t *)(16 * v65);
        uint64_t v71 = 0;
        uint64_t *v70 = v57;
        v70[1] = v58;
        uint64_t v63 = 16 * v65 + 16;
        if (v62 == v64) {
          goto LABEL_76;
        }
        goto LABEL_74;
      }
      if (!(v68 >> 60))
      {
        v69 = (char *)operator new(16 * v68);
        v70 = (uint64_t *)&v69[16 * v65];
        uint64_t v71 = (uint64_t *)&v69[16 * v68];
        uint64_t *v70 = v59;
        v70[1] = v60;
        uint64_t v63 = (uint64_t)(v70 + 2);
        if (v62 == v64)
        {
LABEL_76:
          *a5 = v70;
          a5[1] = (uint64_t *)v63;
          a5[2] = v71;
          if (v62) {
            operator delete(v62);
          }
          goto LABEL_78;
        }
        do
        {
LABEL_74:
          *((_OWORD *)v70 - 1) = *((_OWORD *)v62 - 1);
          v70 -= 2;
          v62 -= 2;
        }
        while (v62 != v64);
        int64_t v62 = *a5;
        goto LABEL_76;
      }
LABEL_81:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_80:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t *v62 = v57;
  v62[1] = v58;
  uint64_t v63 = (uint64_t)(v62 + 2);
LABEL_78:
  a5[1] = (uint64_t *)v63;
}

void HGRenderUtils::BufferFillerImpl::start_dispatch(dispatch_group_t *this, HGBitmap *a2, HGRect a3, unsigned __int8 *a4)
{
  uint64_t v4 = *(void *)&a3.var2;
  uint64_t v5 = *(void *)&a3.var0;
  if (*((unsigned char *)this + 240))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((unsigned char *)this + 240) = 0;
  }
  uint64_t v8 = HGRectIntersection(*(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28), v5, v4);
  unint64_t v10 = v9;
  std::string __p = 0;
  uint64_t v19 = 0;
  unint64_t v20 = 0;
  if (HGRectIsNull(v5, v4) || HGRectIsNull(v8, v10))
  {
    uint64_t v11 = (v19 - (unsigned char *)__p) >> 4;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v13 = v20 - (unsigned char *)__p;
    if ((v20 - (unsigned char *)__p) >> 3 > v12) {
      unint64_t v12 = v13 >> 3;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v15 = (char *)operator new(16 * v14);
    }
    else
    {
      unint64_t v15 = 0;
    }
    uint64_t v16 = &v15[16 * v11];
    *(_OWORD *)uint64_t v16 = *(_OWORD *)((char *)a2 + 20);
    std::string __p = v16;
    unint64_t v20 = &v15[16 * v14];
    uint64_t v19 = v16 + 16;
  }
  else
  {
  }
  dispatch_group_t v17 = this[29];
  if (v17) {
    MEMORY[0x1BA9BFB70](v17, 0x1000C8077774924);
  }
  operator new[]();
}

void sub_1B77073E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::block_fill_dispatch(_anonymous_namespace_ *this, void *a2)
{
  size_t v3 = *((void *)this + 6);
  global_queue = dispatch_get_global_queue(0, 0);
}

void HGRenderUtils::BufferCopier::BufferCopier(HGRenderUtils::BufferCopier *this)
{
}

void HGRenderUtils::BufferCopier::~BufferCopier(HGRenderUtils::BufferCopier *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    if (*(unsigned char *)(v1 + 72))
    {
      dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
      *(unsigned char *)(v1 + 72) = 0;
    }
    dispatch_release(*(dispatch_object_t *)v1);
    MEMORY[0x1BA9BFBA0](v1, 0x1030C400C955606);
  }
}

{
  uint64_t v1;

  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    if (*(unsigned char *)(v1 + 72))
    {
      dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
      *(unsigned char *)(v1 + 72) = 0;
    }
    dispatch_release(*(dispatch_object_t *)v1);
    MEMORY[0x1BA9BFBA0](v1, 0x1030C400C955606);
  }
}

void HGRenderUtils::BufferCopier::execute(dispatch_group_t **this, HGBitmap *a2, HGBitmap *a3)
{
  if (*((_DWORD *)a2 + 4) == *((_DWORD *)a3 + 4)) {
    HGRenderUtils::BufferCopierImpl::start_dispatch(*this, a2, a3);
  }
  uint64_t v4 = *this;
  if (*((unsigned char *)v4 + 72))
  {
    dispatch_group_wait(*v4, 0xFFFFFFFFFFFFFFFFLL);
    *((unsigned char *)v4 + 72) = 0;
  }
}

void HGRenderUtils::BufferCopier::start(dispatch_group_t **this, HGBitmap *a2, HGBitmap *a3)
{
  if (*((_DWORD *)a2 + 4) == *((_DWORD *)a3 + 4)) {
    HGRenderUtils::BufferCopierImpl::start_dispatch(*this, a2, a3);
  }
}

intptr_t HGRenderUtils::BufferCopier::finish(intptr_t this)
{
  uint64_t v1 = *(void *)this;
  if (*(unsigned char *)(*(void *)this + 72))
  {
    this = dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
    *(unsigned char *)(v1 + 72) = 0;
  }
  return this;
}

void HGRenderUtils::BufferReformatter::BufferReformatter(HGRenderUtils::BufferReformatter *this)
{
}

void HGRenderUtils::BufferReformatter::~BufferReformatter(HGRenderUtils::BufferReformatter *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    if (*(unsigned char *)(v1 + 32))
    {
      dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
      *(unsigned char *)(v1 + 32) = 0;
    }
    dispatch_release(*(dispatch_object_t *)v1);
    MEMORY[0x1BA9BFBA0](v1, 0x1020C409C40F318);
  }
}

{
  uint64_t v1;

  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    if (*(unsigned char *)(v1 + 32))
    {
      dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
      *(unsigned char *)(v1 + 32) = 0;
    }
    dispatch_release(*(dispatch_object_t *)v1);
    MEMORY[0x1BA9BFBA0](v1, 0x1020C409C40F318);
  }
}

void HGRenderUtils::BufferReformatter::execute(HGRenderUtils::BufferReformatter *this, HGBitmap *a2, HGBitmap *a3)
{
  HGRenderUtils::BufferReformatter::start(this, a2, a3);
  uint64_t v4 = *(void *)this;
  if (*(unsigned char *)(v4 + 32))
  {
    dispatch_group_wait(*(dispatch_group_t *)v4, 0xFFFFFFFFFFFFFFFFLL);
    *(unsigned char *)(v4 + 32) = 0;
  }
}

void HGRenderUtils::BufferReformatter::start(HGRenderUtils::BufferReformatter *this, HGBitmap *a2, HGBitmap *a3)
{
  if (*((_DWORD *)a2 + 4) != *((_DWORD *)a3 + 4))
  {
    uint64_t v5 = *(void *)this;
    if (*(unsigned char *)(*(void *)this + 32))
    {
      dispatch_group_wait(*(dispatch_group_t *)v5, 0xFFFFFFFFFFFFFFFFLL);
      *(unsigned char *)(v5 + 32) = 0;
    }
    unint64_t v6 = (*((_DWORD *)a2 + 8) - *((_DWORD *)a2 + 6));
    if (v6 >= 0x40) {
      v6 >>= 2;
    }
    *(void *)(v5 + 8) = a3;
    *(void *)(v5 + 16) = a2;
    *(void *)(v5 + 24) = v6;
    signed int v7 = *(NSObject **)v5;
    global_queue = dispatch_get_global_queue(0, 0);
    *(unsigned char *)(v5 + 32) = 1;
  }
}

intptr_t HGRenderUtils::BufferReformatter::finish(intptr_t this)
{
  uint64_t v1 = *(void *)this;
  if (*(unsigned char *)(*(void *)this + 32))
  {
    this = dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
    *(unsigned char *)(v1 + 32) = 0;
  }
  return this;
}

void HGRenderUtils::BufferFiller::BufferFiller(HGRenderUtils::BufferFiller *this)
{
}

void HGRenderUtils::BufferFiller::~BufferFiller(HGRenderUtils::BufferFiller *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    if (*(unsigned char *)(v1 + 240))
    {
      dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
      *(unsigned char *)(v1 + 240) = 0;
    }
    dispatch_release(*(dispatch_object_t *)v1);
    uint64_t v2 = *(void *)(v1 + 232);
    if (v2) {
      MEMORY[0x1BA9BFB70](v2, 0x1000C8077774924);
    }
    MEMORY[0x1BA9BFBA0](v1, 0x1030C40855A15F8);
  }
}

dispatch_group_t **HGRenderUtils::BufferFiller::execute(dispatch_group_t **this, HGBitmap *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (*((void *)a2 + 7) == a4)
  {
    *(void *)&v6.int var0 = 0;
    *(void *)&v6.int var2 = 0;
    HGRenderUtils::BufferFillerImpl::start_dispatch(*this, a2, v6, a3);
  }
  uint64_t v5 = *this;
  if (*((unsigned char *)*this + 240))
  {
    this = (dispatch_group_t **)dispatch_group_wait(*v5, 0xFFFFFFFFFFFFFFFFLL);
    *((unsigned char *)v5 + 240) = 0;
  }
  return this;
}

dispatch_group_t **HGRenderUtils::BufferFiller::execute(dispatch_group_t **this, HGBitmap *a2, HGRect a3, unsigned __int8 *a4, uint64_t a5)
{
  if (*((void *)a2 + 7) == a5) {
    HGRenderUtils::BufferFillerImpl::start_dispatch(*this, a2, a3, a4);
  }
  uint64_t v5 = *this;
  if (*((unsigned char *)*this + 240))
  {
    this = (dispatch_group_t **)dispatch_group_wait(*v5, 0xFFFFFFFFFFFFFFFFLL);
    *((unsigned char *)v5 + 240) = 0;
  }
  return this;
}

dispatch_group_t **HGRenderUtils::BufferFiller::start(dispatch_group_t **this, HGBitmap *a2, HGRect a3, unsigned __int8 *a4, uint64_t a5)
{
  if (*((void *)a2 + 7) == a5) {
    HGRenderUtils::BufferFillerImpl::start_dispatch(*this, a2, a3, a4);
  }
  return this;
}

intptr_t HGRenderUtils::BufferFiller::finish(intptr_t this)
{
  uint64_t v1 = *(void *)this;
  if (*(unsigned char *)(*(void *)this + 240))
  {
    this = dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
    *(unsigned char *)(v1 + 240) = 0;
  }
  return this;
}

dispatch_group_t **HGRenderUtils::BufferFiller::start(dispatch_group_t **this, HGBitmap *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (*((void *)a2 + 7) == a4)
  {
    *(void *)&v5.int var0 = 0;
    *(void *)&v5.int var2 = 0;
    HGRenderUtils::BufferFillerImpl::start_dispatch(*this, a2, v5, a3);
  }
  return this;
}

void *anonymous namespace'::block_single_copy(_anonymous_namespace_ *this, void *a2)
{
  unint64_t v3 = *((void *)this + 5);
  unint64_t v2 = *((void *)this + 6);
  unint64_t v4 = v3 / v2;
  unint64_t v5 = v3 % v2;
  if ((void *)(v2 - 1) == a2) {
    unint64_t v6 = v5;
  }
  else {
    unint64_t v6 = 0;
  }
  return memcpy((void *)(*((void *)this + 1) + *((void *)this + 3) * v4 * (void)a2), (const void *)(*(void *)this + *((void *)this + 2) * v4 * (void)a2), *((void *)this + 4) * (v6 + v4));
}

void *anonymous namespace'::block_copy(void *this, void *a2)
{
  unint64_t v2 = this[5];
  unint64_t v3 = this[6];
  unint64_t v4 = v2 / v3;
  unint64_t v5 = v2 % v3;
  if ((void *)(v3 - 1) != a2) {
    unint64_t v5 = 0;
  }
  unint64_t v6 = v5 + v4;
  if (v5 + v4)
  {
    uint64_t v7 = this[2];
    uint64_t v8 = this[3];
    size_t v9 = this[4];
    uint64_t v10 = v4 * (void)a2;
    uint64_t v11 = (char *)(this[1] + v8 * v10);
    unint64_t v12 = (char *)(*this + v7 * v10);
    unsigned int v13 = 1;
    do
    {
      this = memcpy(v11, v12, v9);
      v12 += v7;
      v11 += v8;
    }
    while (v6 > v13++);
  }
  return this;
}

pthread_mutex_t *anonymous namespace'::block_reformat(_anonymous_namespace_ *this, void *a2)
{
  unint64_t v3 = (_DWORD *)*((void *)this + 1);
  unint64_t v4 = *((void *)this + 2);
  unsigned int v5 = v3[5];
  int v6 = v3[6];
  unsigned int v7 = v3[7];
  unint64_t v8 = (v3[8] - v6);
  unint64_t v9 = v8 / v4;
  int v10 = v8 % v4;
  if ((void *)(v4 - 1) != a2) {
    int v10 = 0;
  }
  uint64_t v11 = HGRectMake4i(v5, v6 + (int)v9 * (int)a2, v7, v6 + (int)v9 * (int)a2 + (int)v9 + v10);
  uint64_t v13 = v12;
  uint64_t v16 = this;
  uint64_t v14 = *(void *)this;
  uint64_t v15 = *((void *)v16 + 1);
  int v18 = (HGMemory *)HGMemory::allocate((HGMemory *)(16 * (v12 - v11) * (HIDWORD(v12) - HIDWORD(v11))), 0, v17);
  (*(void (**)(uint64_t, HGMemory *, uint64_t, uint64_t, void))(*(void *)v14 + 72))(v14, v18, v11, v13, 0);
  (*(void (**)(uint64_t, HGMemory *, uint64_t, uint64_t))(*(void *)v15 + 80))(v15, v18, v11, v13);

  return HGMemory::release(v18, v19);
}

void *anonymous namespace'::block_fill(void *this, void *a2)
{
  unint64_t v2 = this[5];
  unint64_t v3 = this[6];
  unint64_t v4 = v2 / v3;
  unint64_t v5 = v2 % v3;
  if ((void *)(v3 - 1) != a2) {
    unint64_t v5 = 0;
  }
  unint64_t v6 = v5 + v4;
  if (v5 + v4)
  {
    unsigned int v7 = (const void *)this[2];
    size_t v8 = this[3];
    uint64_t v9 = this[1];
    int v10 = (char *)(*this + v4 * (void)a2 * v9);
    unsigned int v11 = 1;
    do
    {
      this = memcpy(v10, v7, v8);
      v10 += v9;
    }
    while (v6 > v11++);
  }
  return this;
}

void HGMetalBufferPool::HGMetalBufferPool(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = operator new(0x28uLL);
  v3[1] = 0;
  v3[2] = 0;
  *unint64_t v3 = &unk_1F10CAB60;
  v3[3] = &unk_1F10CABB0;
  v3[4] = a2;
  operator new();
}

void sub_1B7707F54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  MEMORY[0x1BA9BFBA0](v11, 0x10B3C40C3EE8A59);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1B7707F88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

std::string *HGMetalBufferPool::setLabel(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(*(void *)a1 + 320), a2);
}

void HGMetalBufferPool::setServicingPolicy(std::mutex **a1, uint64_t *a2)
{
  unint64_t v3 = *a1;
  unint64_t v4 = *a1 + 4;
  std::mutex::lock(v4);
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned int v7 = *(std::__shared_weak_count **)&v3[2].__m_.__opaque[40];
  *(void *)&v3[2].__m_.__opaque[32] = v6;
  *(void *)&v3[2].__m_.__opaque[40] = v5;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    size_t v8 = v4;
  }
  else
  {
    size_t v8 = v4;
  }
  std::mutex::unlock(v8);
}

void HGMetalBufferPool::setAllocationPolicy(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 40);
  *(void *)(v2 + 32) = v4;
  *(void *)(v2 + 40) = v3;
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

uint64_t HGMetalBufferPool::newBuffer(uint64_t *a1, uint64_t *a2)
{
  return HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::newObjectWithRecovery(*a1, a2, 0);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::newObjectWithRecovery(uint64_t a1, uint64_t *a2, char a3)
{
  uint64_t result = HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::newObject(a1, a2, a3);
  if (!result)
  {
    while (1)
    {
      std::mutex::lock((std::mutex *)(a1 + 256));
      if (!*(void *)(a1 + 224)) {
        break;
      }
      HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152));
      std::mutex::unlock((std::mutex *)(a1 + 256));
      uint64_t result = HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::newObject(a1, a2, a3);
      if (result) {
        return result;
      }
    }
    std::mutex::unlock((std::mutex *)(a1 + 256));
    unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
    if (v9)
    {
      int v10 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0) {
        int v10 = *(HGLogger **)v10;
      }
      HGLogger::log(v10, (const char *)1, (HGLogger *)"HGPool::newObjectWithRecovery() - Failed to recycle or allocate object! Oops.", v7, v8);
    }
    return 0;
  }
  return result;
}

void HGMetalBufferPool::releaseBuffer(uint64_t *a1, uint64_t a2)
{
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::releaseObject(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = a2;
  uint64_t v3 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,true>::retrieveObject((int64x2_t *)(a1 + 48), &v26, (uint64_t)&v24);
  if ((void)v24)
  {
    v25[24] = 0;
    *(std::chrono::steady_clock::time_point *)&v25[8] = std::chrono::steady_clock::now();
    kdebug_trace();
    uint64_t v4 = *(void *)(a1 + 200);
    uint64_t v5 = *(void *)(a1 + 192);
    uint64_t v6 = 85 * ((v4 - v5) >> 3) - 1;
    if (v4 == v5) {
      uint64_t v6 = 0;
    }
    unint64_t v7 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
    if (v6 == v7)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::__add_back_capacity(a1 + 184);
      uint64_t v5 = *(void *)(a1 + 192);
      unint64_t v7 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
    }
    size_t v8 = (_OWORD *)(*(void *)(v5 + 8 * (v7 / 0x55)) + 48 * (v7 % 0x55));
    long long v9 = v24;
    long long v10 = *(_OWORD *)&v25[16];
    v8[1] = *(_OWORD *)v25;
    void v8[2] = v10;
    *size_t v8 = v9;
    ++*(void *)(a1 + 224);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 232), 1uLL);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 240), *(unint64_t *)v25);
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1);
  }
  else
  {
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v26, (uint64_t)&v22);
    long long v24 = v22;
    *(_OWORD *)uint64_t v25 = v23[0];
    *(_OWORD *)&v25[9] = *(_OWORD *)((char *)v23 + 9);
    uint64_t v13 = v22;
    if ((void)v22)
    {
      uint64_t v14 = *(void *)(a1 + 200);
      uint64_t v15 = *(void *)(a1 + 192);
      uint64_t v16 = 85 * ((v14 - v15) >> 3) - 1;
      if (v14 == v15) {
        uint64_t v16 = 0;
      }
      unint64_t v17 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
      if (v16 == v17)
      {
        std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::__add_back_capacity(a1 + 184);
        uint64_t v15 = *(void *)(a1 + 192);
        unint64_t v17 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
      }
      int v18 = (_OWORD *)(*(void *)(v15 + 8 * (v17 / 0x55)) + 48 * (v17 % 0x55));
      long long v19 = v24;
      long long v20 = *(_OWORD *)&v25[16];
      v18[1] = *(_OWORD *)v25;
      v18[2] = v20;
      _OWORD *v18 = v19;
      ++*(void *)(a1 + 224);
      atomic_fetch_add((atomic_ullong *volatile)(a1 + 232), 1uLL);
      atomic_fetch_add((atomic_ullong *volatile)(a1 + 240), *(unint64_t *)v25);
      uint64_t v21 = "HGPool::releaseObject() - Attempting to double-release a free object: <%p>";
      uint64_t v13 = v24;
    }
    else
    {
      uint64_t v21 = "HGPool::releaseObject() - Attempting to release an unmanaged object: <%p>";
    }
    HGLogger::warning((HGLogger *)v21, v11, v12, v13);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  kdebug_trace();
  std::mutex::unlock(v3);
}

void sub_1B77084E4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B77084F8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGMetalBufferPool::clear(HGMetalBufferPool *this)
{
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::clear(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (*(void *)(a1 + 224))
  {
    uint64_t v3 = 0;
    do
    {
      HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152));
      --v3;
    }
    while (*(void *)(a1 + 224));
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
      (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
      kdebug_trace();
    }
  }

  std::mutex::unlock(v2);
}

void sub_1B770862C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B7708640(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGMetalBufferWrapperInfinipool::HGMetalBufferWrapperInfinipool(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = operator new(0x28uLL);
  v3[1] = 0;
  v3[2] = 0;
  *uint64_t v3 = &unk_1F10CAE20;
  v3[3] = &unk_1F10CAE70;
  v3[4] = a2;
  operator new();
}

void sub_1B7708A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B7708A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1B7708A54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B7708A68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B7708A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  MEMORY[0x1BA9BFBA0](v3, 0x10B3C40C3EE8A59);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1B7708AB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGMetalBufferWrapperInfinipool::newBuffer(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (void *)HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::newObject(*a1, a2, 0);
  uint64_t v4 = (uint64_t)v3;
  if (v3)
  {
    id v5 = v3;
    HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::releaseObject(v2, v4);
  }
  return v4;
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::newObject(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) != 0 || (uint64_t v4 = *(void *)(a1 + 32)) == 0)
  {
    long long v48 = *(_OWORD *)a2;
    unint64_t v49 = *(void *)(a2 + 16);
  }
  else
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v4 + 16))(&v48);
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v48, (uint64_t)&v44);
  std::mutex::unlock((std::mutex *)(a1 + 256));
  if ((void)v44)
  {
    BYTE8(v47) = 1;
    *((std::chrono::steady_clock::time_point *)&v46 + 1) = std::chrono::steady_clock::now();
    *(void *)&long long v47 = v47 + 1;
    char v51 = 0;
    LOBYTE(v50[0]) = 0;
    unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
    if (v7)
    {
      size_t v8 = v50;
      if (v51 < 0) {
        size_t v8 = (void **)v50[0];
      }
      HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry reused : %p (%s)\n", (const char *)v5.__d_.__rep_, (char *)v6.__d_.__rep_, (void)v44, v8);
    }
    if (v51 < 0) {
      operator delete(v50[0]);
    }
    kdebug_trace();
    int v11 = *(_DWORD *)(a1 + 368);
    if (v11 == 1)
    {
      kdebug_trace();
      uint64_t v25 = v44;
      uint64_t v29 = (*(uint64_t (**)(void, long long *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), &v48);
      char v51 = 0;
      LOBYTE(v50[0]) = 0;
      unsigned __int8 v30 = atomic_load(HGLogger::_enabled);
      if (v30)
      {
        unint64_t v31 = v50;
        if (v51 < 0) {
          unint64_t v31 = (void **)v50[0];
        }
        HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry deleted : %p (%s)\n", v27, v28, (void)v44, v31);
      }
      uint64_t v32 = *((void *)&v45 + 1);
      if (v51 < 0) {
        operator delete(v50[0]);
      }
      *(void *)&long long v44 = v29;
      long long v45 = v48;
      *(void *)&long long v46 = v49;
      HGPool::EntryEventHandler<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::allocated(&v44, v32, v26, v27, v28);
      kdebug_trace();
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16), v25);
      kdebug_trace();
    }
    else if (v11 == 2)
    {
      kdebug_trace();
      long long v12 = v44;
      uint64_t v16 = (*(uint64_t (**)(void, long long *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), &v48);
      char v51 = 0;
      LOBYTE(v50[0]) = 0;
      unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
      if (v17)
      {
        int v18 = v50;
        if (v51 < 0) {
          int v18 = (void **)v50[0];
        }
        HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry deleted : %p (%s)\n", v14, v15, (void)v44, v18);
      }
      uint64_t v19 = *((void *)&v45 + 1);
      if (v51 < 0) {
        operator delete(v50[0]);
      }
      *(void *)&long long v44 = v16;
      *((void *)&v44 + 1) = v12;
      long long v45 = v48;
      *(void *)&long long v46 = v49;
      HGPool::EntryEventHandler<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::allocated(&v44, v19, v13, v14, v15);
      kdebug_trace();
      (*(void (**)(void, void))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16), *((void *)&v12 + 1));
      kdebug_trace();
    }
  }
  else
  {
    kdebug_trace();
    uint64_t v20 = (*(uint64_t (**)(void, long long *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), &v48);
    long long v45 = v48;
    *(void *)&long long v47 = 0;
    long long v46 = v49;
    long long v44 = (unint64_t)v20;
    BYTE8(v47) = 1;
    *((std::chrono::steady_clock::time_point *)&v46 + 1) = std::chrono::steady_clock::now();
    *(void *)&long long v47 = v47 + 1;
    char v51 = 0;
    LOBYTE(v50[0]) = 0;
    unsigned __int8 v23 = atomic_load(HGLogger::_enabled);
    if (v23)
    {
      long long v24 = v50;
      if (v51 < 0) {
        long long v24 = (void **)v50[0];
      }
      HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry allocated : %p (%s)\n", (const char *)v21.__d_.__rep_, (char *)v22.__d_.__rep_, (void)v44, v24);
    }
    if (v51 < 0) {
      operator delete(v50[0]);
    }
    kdebug_trace();
    kdebug_trace();
  }
  if ((void)v44)
  {
    std::mutex::lock((std::mutex *)(a1 + 256));
    uint64_t v33 = *(void *)(a1 + 96);
    uint64_t v34 = *(void *)(a1 + 88);
    uint64_t v35 = 8 * (v33 - v34) - 1;
    if (v33 == v34) {
      uint64_t v35 = 0;
    }
    unint64_t v36 = *(void *)(a1 + 120) + *(void *)(a1 + 112);
    if (v35 == v36)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>>::__add_back_capacity(a1 + 80);
      uint64_t v34 = *(void *)(a1 + 88);
      unint64_t v36 = *(void *)(a1 + 120) + *(void *)(a1 + 112);
    }
    uint64_t v37 = (_OWORD *)(*(void *)(v34 + ((v36 >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((v36 & 0x3F) << 6));
    long long v38 = v44;
    long long v39 = v45;
    long long v40 = v47;
    v37[2] = v46;
    v37[3] = v40;
    *uint64_t v37 = v38;
    v37[1] = v39;
    ++*(void *)(a1 + 120);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 128), 1uLL);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 136), *((unint64_t *)&v45 + 1));
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    kdebug_trace();
    std::mutex::unlock((std::mutex *)(a1 + 256));
  }
  else
  {
    unsigned __int8 v41 = atomic_load(HGLogger::_enabled);
    if (v41)
    {
      uint64_t v42 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0) {
        uint64_t v42 = *(HGLogger **)v42;
      }
      HGLogger::log(v42, (const char *)1, (HGLogger *)"HGPool::newObject() - Failed to recycle or allocate object! Oops.", v9, v10);
    }
  }
  return v44;
}

void sub_1B7709244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  if (*(char *)(v13 - 65) < 0)
  {
    operator delete(*(void **)(v13 - 88));
    HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
    _Unwind_Resume(a1);
  }
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B7709294(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 65) < 0) {
    operator delete(*(void **)(v1 - 88));
  }
  _Unwind_Resume(exception_object);
}

void sub_1B77092B0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::releaseObject(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = a2;
  uint64_t v3 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,true>::retrieveObject((int64x2_t *)(a1 + 48), &v34, (uint64_t)&v31);
  if ((void)v31)
  {
    v33[24] = 0;
    *(std::chrono::steady_clock::time_point *)&v33[8] = std::chrono::steady_clock::now();
    BYTE7(v29) = 0;
    LOBYTE(__p[0]) = 0;
    unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
    if (v6)
    {
      unsigned __int8 v7 = __p;
      if (SBYTE7(v29) < 0) {
        unsigned __int8 v7 = (void **)__p[0];
      }
      HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry recycled : %p (%s)\n", (const char *)v4.__d_.__rep_, (char *)v5.__d_.__rep_, (void)v31, v7);
    }
    if (SBYTE7(v29) < 0) {
      operator delete(__p[0]);
    }
    kdebug_trace();
    uint64_t v8 = *(void *)(a1 + 200);
    uint64_t v9 = *(void *)(a1 + 192);
    uint64_t v10 = 8 * (v8 - v9) - 1;
    if (v8 == v9) {
      uint64_t v10 = 0;
    }
    unint64_t v11 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
    if (v10 == v11)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>>::__add_back_capacity(a1 + 184);
      uint64_t v9 = *(void *)(a1 + 192);
      unint64_t v11 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
    }
    long long v12 = (_OWORD *)(*(void *)(v9 + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((v11 & 0x3F) << 6));
    long long v13 = v31;
    long long v14 = v32;
    long long v15 = *(_OWORD *)&v33[16];
    v12[2] = *(_OWORD *)v33;
    v12[3] = v15;
    *long long v12 = v13;
    v12[1] = v14;
    ++*(void *)(a1 + 224);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 232), 1uLL);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 240), *((unint64_t *)&v32 + 1));
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::service(a1 + 152, a1);
  }
  else
  {
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v34, (uint64_t)__p);
    long long v31 = *(_OWORD *)__p;
    long long v32 = v29;
    *(_OWORD *)uint64_t v33 = v30[0];
    *(_OWORD *)&v33[9] = *(_OWORD *)((char *)v30 + 9);
    int v18 = __p[0];
    if (__p[0])
    {
      uint64_t v19 = *(void *)(a1 + 200);
      uint64_t v20 = *(void *)(a1 + 192);
      uint64_t v21 = 8 * (v19 - v20) - 1;
      if (v19 == v20) {
        uint64_t v21 = 0;
      }
      unint64_t v22 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
      if (v21 == v22)
      {
        std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>>::__add_back_capacity(a1 + 184);
        uint64_t v20 = *(void *)(a1 + 192);
        unint64_t v22 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
      }
      unsigned __int8 v23 = (_OWORD *)(*(void *)(v20 + ((v22 >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((v22 & 0x3F) << 6));
      long long v24 = v31;
      long long v25 = v32;
      long long v26 = *(_OWORD *)&v33[16];
      _OWORD v23[2] = *(_OWORD *)v33;
      v23[3] = v26;
      *unsigned __int8 v23 = v24;
      v23[1] = v25;
      ++*(void *)(a1 + 224);
      atomic_fetch_add((atomic_ullong *volatile)(a1 + 232), 1uLL);
      atomic_fetch_add((atomic_ullong *volatile)(a1 + 240), *((unint64_t *)&v32 + 1));
      uint64_t v27 = "HGPool::releaseObject() - Attempting to double-release a free object: <%p>";
      int v18 = (void *)v31;
    }
    else
    {
      uint64_t v27 = "HGPool::releaseObject() - Attempting to release an unmanaged object: <%p>";
    }
    HGLogger::warning((HGLogger *)v27, v16, v17, v18);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  kdebug_trace();
  std::mutex::unlock(v3);
}

void sub_1B77095E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  std::mutex::unlock(v16);
  _Unwind_Resume(a1);
}

void HGMetalBufferWrapperInfinipool::clear(HGMetalBufferWrapperInfinipool *this)
{
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::clear(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (*(void *)(a1 + 224))
  {
    uint64_t v6 = 0;
    do
    {
      HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152), 1, v3, v4, v5);
      --v6;
    }
    while (*(void *)(a1 + 224));
    if (v6)
    {
      (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
      (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
      kdebug_trace();
    }
  }

  std::mutex::unlock(v2);
}

void sub_1B7709740(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B7709754(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<anonymous namespace'::BufferAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CAB60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<anonymous namespace'::BufferAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CAB60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<anonymous namespace'::BufferAllocator>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void anonymous namespace'::BufferAllocator::~BufferAllocator(_anonymous_namespace_::BufferAllocator *this)
{
}

uint64_t anonymous namespace'::BufferAllocator::allocate(uint64_t a1, void *a2)
{
  return [*(id *)(a1 + 8) newBufferWithLength:*a2 options:0];
}

void anonymous namespace'::BufferAllocator::release(uint64_t a1, void *a2)
{
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::~Pool(a1, a2);

  JUMPOUT(0x1BA9BFBA0);
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::usedObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 128));
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::usedTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 136));
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::freeObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 232));
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::freeTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 240));
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::service(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1))
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    kdebug_trace();
  }

  std::mutex::unlock(v2);
}

void sub_1B7709A10(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::trace(std::mutex *a1)
{
  uint64_t v2 = a1 + 4;
  std::mutex::lock(a1 + 4);
  sig = a1 + 5;
  if (a1[5].__m_.__opaque[15] < 0) {
    sig = (std::mutex *)sig->__m_.__sig;
  }
  (*(void (**)(std::mutex *, std::mutex *))(a1->__m_.__sig + 24))(a1, sig);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 16))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 40))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 32))(a1);
  std::mutex::unlock(v2);
}

void sub_1B7709C88(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B7709C9C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B7709CB0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B7709CC4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::log(uint64_t a1, const char *a2)
{
  uint64_t v3 = (HGLogger *)(a1 + 344);
  if (*(char *)(a1 + 367) < 0)
  {
    uint64_t v3 = *(HGLogger **)v3;
    if ((int)HGLogger::getLevel(v3, a2) < 2) {
      return;
    }
  }
  else if ((int)HGLogger::getLevel((HGLogger *)(a1 + 344), a2) < 2)
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6)
  {
    unsigned __int8 v7 = (void *)(a1 + 320);
    if (*(char *)(a1 + 343) < 0) {
      unsigned __int8 v7 = (void *)*v7;
    }
    HGLogger::log(v3, (const char *)2, (HGLogger *)"pool '%s' (%p)\n", v4, v5, v7, a1);
  }
  HGLogger::indent(1);
  unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
  if (v10) {
    HGLogger::log(v3, (const char *)2, (HGLogger *)"live objects:\n", v8, v9);
  }
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,true>::log((void *)(a1 + 48), v3);
  unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
  if (v13) {
    HGLogger::log(v3, (const char *)2, (HGLogger *)"free objects:\n", v11, v12);
  }
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::log((void *)(a1 + 152), v3);
  HGLogger::indent(0xFFFFFFFFLL);

  std::mutex::unlock((std::mutex *)(a1 + 256));
}

void sub_1B7709E04(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::canService(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 372);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::canTrace(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 373);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::canLog(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 374);
}

int64x2_t *HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::~List(int64x2_t *a1)
{
  while (a1[4].i64[1])
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_pop_front(a1);
  std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::~deque[abi:ne180100]((uint64_t)a1[2].i64);
  uint64_t v2 = (std::__shared_weak_count *)a1[1].i64[1];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1->i64[1];
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_pop_front(int64x2_t *a1)
{
  uint64_t v2 = (uint64_t *)(*(void *)(a1[2].i64[1] + 8 * (a1[4].i64[0] / 0x55uLL)) + 48 * (a1[4].i64[0] % 0x55uLL));
  uint64_t v4 = *v2;
  uint64_t v3 = v2[1];
  uint64_t v5 = v2[2];
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -v5);
  unsigned __int8 v6 = (void **)a1[2].i64[1];
  int64x2_t v7 = vaddq_s64(a1[4], (int64x2_t)xmmword_1B7E73580);
  a1[4] = v7;
  if (v7.i64[0] >= 0xAAuLL)
  {
    operator delete(*v6);
    a1[2].i64[1] += 8;
    a1[4].i64[0] -= 85;
  }
  kdebug_trace();
  kdebug_trace();
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1->i64[0] + 24))(a1->i64[0], v4);
  if (v3) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1->i64[0] + 24))(a1->i64[0], v3);
  }
  return kdebug_trace();
}

void sub_1B770A0B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

uint64_t std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::~deque[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 42;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 85;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      int64x2_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  *(void *)a1 = &unk_1F10CAC08;
  HGPool::unregisterPool((HGPool *)a1, a2);
  if (*(char *)(a1 + 367) < 0)
  {
    operator delete(*(void **)(a1 + 344));
    if ((*(char *)(a1 + 343) & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_16:
    operator delete(*(void **)(a1 + 320));
    goto LABEL_3;
  }
  if (*(char *)(a1 + 343) < 0) {
    goto LABEL_16;
  }
LABEL_3:
  std::mutex::~mutex((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::~List((int64x2_t *)(a1 + 152));
  std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::~deque[abi:ne180100](a1 + 80);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v6 || atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
  std::__shared_weak_count::__release_weak(v6);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::service(int64x2_t *a1, uint64_t a2)
{
  if (!a1[1].i64[0] || !a1[4].i64[1]) {
    return 0;
  }
  uint64_t v4 = 0;
  do
  {
    unint64_t v5 = atomic_load((unint64_t *)&a1[5]);
    if (v5 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[1].i64[0] + 16))(a1[1].i64[0], a2))
    {
      unint64_t v6 = atomic_load(&a1[5].u64[1]);
      if (v6 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[1].i64[0] + 24))(a1[1].i64[0], a2))
      {
        unint64_t v7 = a1[4].u64[0];
        uint64_t v8 = *(void *)(a1[2].i64[1] + 8 * (v7 / 0x55));
        unint64_t v9 = std::chrono::steady_clock::now().__d_.__rep_ - *(void *)(v8 + 48 * (v7 % 0x55) + 24);
        if (v9 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[1].i64[0] + 32))(a1[1].i64[0], a2)) {
          break;
        }
      }
    }
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_pop_front(a1);
    ++v4;
  }
  while (a1[4].i64[1]);
  return v4;
}

void HGPool::EntryTrace<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::trace(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 40)) {
    std::chrono::steady_clock::now();
  }
}

void sub_1B770A54C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,true>::log(void *a1, HGLogger *a2)
{
  if (a1[9])
  {
    HGLogger::indent(1);
    uint64_t v4 = a1[5];
    if (a1[6] != v4)
    {
      unint64_t v5 = a1[8];
      unint64_t v6 = (void *)(v4 + 8 * (v5 / 0x55));
      unint64_t v7 = (long long *)(*v6 + 48 * (v5 % 0x55));
      unint64_t v8 = *(void *)(v4 + 8 * ((a1[9] + v5) / 0x55)) + 48 * ((a1[9] + v5) % 0x55);
      while (v7 != (long long *)v8)
      {
        long long v9 = *v7;
        long long v10 = v7[2];
        long long v19 = v7[1];
        long long v20 = v10;
        *(_OWORD *)std::string __p = v9;
        HGPool::EntryLog<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 3;
        if ((long long *)((char *)v7 - *v6) == (long long *)4080)
        {
          unint64_t v11 = (long long *)v6[1];
          ++v6;
          unint64_t v7 = v11;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    long long v12 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v12);
    unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
    if (v15)
    {
      if ((SBYTE7(v19) & 0x80u) == 0) {
        uint64_t v16 = __p;
      }
      else {
        uint64_t v16 = (void **)__p[0];
      }
      unint64_t v17 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v13, v14, v16, v17);
    }
    if (SBYTE7(v19) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1B770A6CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::log(void *a1, HGLogger *a2)
{
  if (a1[9])
  {
    HGLogger::indent(1);
    uint64_t v4 = a1[5];
    if (a1[6] != v4)
    {
      unint64_t v5 = a1[8];
      unint64_t v6 = (void *)(v4 + 8 * (v5 / 0x55));
      unint64_t v7 = (long long *)(*v6 + 48 * (v5 % 0x55));
      unint64_t v8 = *(void *)(v4 + 8 * ((a1[9] + v5) / 0x55)) + 48 * ((a1[9] + v5) % 0x55);
      while (v7 != (long long *)v8)
      {
        long long v9 = *v7;
        long long v10 = v7[2];
        long long v19 = v7[1];
        long long v20 = v10;
        *(_OWORD *)std::string __p = v9;
        HGPool::EntryLog<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 3;
        if ((long long *)((char *)v7 - *v6) == (long long *)4080)
        {
          unint64_t v11 = (long long *)v6[1];
          ++v6;
          unint64_t v7 = v11;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    long long v12 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v12);
    unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
    if (v15)
    {
      if ((SBYTE7(v19) & 0x80u) == 0) {
        uint64_t v16 = __p;
      }
      else {
        uint64_t v16 = (void **)__p[0];
      }
      unint64_t v17 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v13, v14, v16, v17);
    }
    if (SBYTE7(v19) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1B770A84C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::EntryLog<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::log(uint64_t *a1, HGLogger *a2, const char *a3)
{
  uint64_t v6 = *a1;
  HGLoggerUtils::bytesPrettyString((HGLoggerUtils *)a1[2]);
  char v22 = 0;
  LOBYTE(v21[0]) = 0;
  if (*((unsigned char *)a1 + 40))
  {
    unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
    if (v9)
    {
      long long v10 = v23;
      if (v24 < 0) {
        long long v10 = (void **)v23[0];
      }
      unint64_t v11 = v21;
      if (v22 < 0) {
        unint64_t v11 = (void **)v21[0];
      }
      HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu   %s\n", v7, v8, v6, v10, a1[4], v11);
    }
    goto LABEL_17;
  }
  v12.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  HGLoggerUtils::timePrettyString((HGLoggerUtils *)(v12.__d_.__rep_ - a1[3]));
  unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
  if (v15)
  {
    uint64_t v16 = v23;
    if (v24 < 0) {
      uint64_t v16 = (void **)v23[0];
    }
    p_p = &__p;
    if (v20 < 0) {
      p_p = __p;
    }
    int v18 = v21;
    if (v22 < 0) {
      int v18 = (void **)v21[0];
    }
    HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu  %10s   %s\n", v13, v14, v6, v16, a1[4], p_p, v18);
  }
  if ((v20 & 0x80000000) == 0)
  {
LABEL_17:
    if ((v22 & 0x80000000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_21;
  }
  operator delete(__p);
  if ((v22 & 0x80000000) == 0)
  {
LABEL_18:
    if ((v24 & 0x80000000) == 0) {
      return;
    }
LABEL_22:
    operator delete(v23[0]);
    return;
  }
LABEL_21:
  operator delete(v21[0]);
  if (v24 < 0) {
    goto LABEL_22;
  }
}

void sub_1B770A9F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v25 - 33) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);
  if ((*(char *)(v25 - 33) & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*(void **)(v25 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::newObject(uint64_t a1, uint64_t *a2, char a3)
{
  if ((a3 & 1) != 0 || (uint64_t v4 = *(void *)(a1 + 32)) == 0) {
    uint64_t v5 = *a2;
  }
  else {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
  unint64_t v25 = v5;
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), (uint64_t *)&v25, (uint64_t)&v22);
  std::mutex::unlock((std::mutex *)(a1 + 256));
  if ((void)v22)
  {
    BYTE8(v24) = 1;
    *((std::chrono::steady_clock::time_point *)&v23 + 1) = std::chrono::steady_clock::now();
    *(void *)&long long v24 = v24 + 1;
    kdebug_trace();
    int v8 = *(_DWORD *)(a1 + 368);
    if (v8 == 1)
    {
      kdebug_trace();
      uint64_t v11 = v22;
      *(void *)&long long v22 = (*(uint64_t (**)(void, unint64_t *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), &v25);
      *(void *)&long long v23 = v25;
      kdebug_trace();
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16), v11);
      kdebug_trace();
    }
    else if (v8 == 2)
    {
      kdebug_trace();
      long long v9 = v22;
      *(void *)&long long v22 = (*(uint64_t (**)(void, unint64_t *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), &v25);
      *((void *)&v22 + 1) = v9;
      *(void *)&long long v23 = v25;
      kdebug_trace();
      (*(void (**)(void, void))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16), *((void *)&v9 + 1));
      kdebug_trace();
    }
  }
  else
  {
    kdebug_trace();
    uint64_t v10 = (*(uint64_t (**)(void, unint64_t *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), &v25);
    *(void *)&long long v24 = 0;
    long long v22 = (unint64_t)v10;
    long long v23 = v25;
    BYTE8(v24) = 1;
    *((std::chrono::steady_clock::time_point *)&v23 + 1) = std::chrono::steady_clock::now();
    *(void *)&long long v24 = v24 + 1;
    kdebug_trace();
    kdebug_trace();
  }
  if ((void)v22)
  {
    std::mutex::lock((std::mutex *)(a1 + 256));
    uint64_t v12 = *(void *)(a1 + 96);
    uint64_t v13 = *(void *)(a1 + 88);
    uint64_t v14 = 85 * ((v12 - v13) >> 3) - 1;
    if (v12 == v13) {
      uint64_t v14 = 0;
    }
    unint64_t v15 = *(void *)(a1 + 120) + *(void *)(a1 + 112);
    if (v14 == v15)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::__add_back_capacity(a1 + 80);
      uint64_t v13 = *(void *)(a1 + 88);
      unint64_t v15 = *(void *)(a1 + 120) + *(void *)(a1 + 112);
    }
    uint64_t v16 = (_OWORD *)(*(void *)(v13 + 8 * (v15 / 0x55)) + 48 * (v15 % 0x55));
    long long v17 = v22;
    long long v18 = v24;
    v16[1] = v23;
    v16[2] = v18;
    _OWORD *v16 = v17;
    ++*(void *)(a1 + 120);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 128), 1uLL);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 136), v23);
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    kdebug_trace();
    std::mutex::unlock((std::mutex *)(a1 + 256));
  }
  else
  {
    unsigned __int8 v19 = atomic_load(HGLogger::_enabled);
    if (v19)
    {
      char v20 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0) {
        char v20 = *(HGLogger **)v20;
      }
      HGLogger::log(v20, (const char *)1, (HGLogger *)"HGPool::newObject() - Failed to recycle or allocate object! Oops.", v6, v7);
    }
  }
  return v22;
}

void sub_1B770AFF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
}

void sub_1B770B00C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
}

void sub_1B770B020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
}

void sub_1B770B034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
}

void sub_1B770B048(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  unint64_t v15 = 0;
  uint64_t v16 = v5;
  uint64_t v10 = 0;
  uint64_t v11 = v5;
  uint64_t v6 = operator new(0x30uLL);
  void *v6 = &unk_1F10CAC90;
  v6[4] = 0;
  v6[5] = v5;
  uint64_t v13 = v6;
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_retrieve(a1, v12, a3);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
    unint64_t v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v13) {
      (*(void (**)(void))(*v13 + 40))();
    }
    unint64_t v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v15;
      if (v15 != v14) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

{
  uint64_t v5;
  void *v6;
  void *v7;
  uint64_t result;
  void v9[3];
  void *v10;
  uint64_t v11;
  void v12[3];
  void *v13;
  void v14[3];
  void *v15;
  uint64_t v16;
  uint64_t v17;

  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  unint64_t v15 = 0;
  uint64_t v16 = v5;
  uint64_t v10 = 0;
  uint64_t v11 = v5;
  uint64_t v6 = operator new(0x30uLL);
  void *v6 = &unk_1F10CAD98;
  v6[4] = 0;
  v6[5] = v5;
  uint64_t v13 = v6;
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_retrieve(a1, v12, a3);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
    unint64_t v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v13) {
      (*(void (**)(void))(*v13 + 40))();
    }
    unint64_t v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v15;
      if (v15 != v14) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B770B250(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va1);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B770B274(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void **HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_retrieve@<X0>(int64x2_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  *(void *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(unsigned char *)(a3 + 40) = 1;
  unint64_t v5 = a1[4].u64[0];
  unint64_t v6 = v5 + a1[4].i64[1];
  unint64_t v7 = v6 / 0x55;
  uint64_t v8 = a1[2].i64[1];
  if (a1[3].i64[0] != v8)
  {
    unint64_t v9 = *(void *)(v8 + 8 * v7) + 48 * (v6 % 0x55);
    unint64_t v10 = *(void *)(v8 + 8 * (v5 / 0x55)) + 48 * (v5 % 0x55);
    uint64_t v11 = (void *)a2[3];
    if (v11) {
      goto LABEL_3;
    }
LABEL_6:
    long long v26 = 0;
    goto LABEL_8;
  }
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  uint64_t v11 = (void *)a2[3];
  if (!v11) {
    goto LABEL_6;
  }
LABEL_3:
  if (v11 == a2)
  {
    long long v26 = (void **)v25;
    (*(void (**)(void *, void *))(*a2 + 24))(a2, v25);
  }
  else
  {
    long long v26 = (void **)(*(uint64_t (**)(void *))(*v11 + 16))(v11);
  }
LABEL_8:
  uint64_t v12 = (uint64_t *)(v8 + 8 * v7);
  if (v9 != v10)
  {
    uint64_t v13 = *v12;
    while (1)
    {
      uint64_t v14 = v9;
      if (v9 == v13) {
        uint64_t v14 = *(v12 - 1) + 4080;
      }
      if (!v26) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      if ((*((uint64_t (**)(void **, uint64_t))*v26 + 6))(v26, v14 - 48)) {
        break;
      }
      uint64_t v13 = *v12;
      if (v9 == *v12)
      {
        uint64_t v15 = *--v12;
        uint64_t v13 = v15;
        unint64_t v9 = v15 + 4080;
      }
      v9 -= 48;
      if (v9 == v10)
      {
        unint64_t v9 = v10;
        break;
      }
    }
  }
  uint64_t result = v26;
  if (v26 == v25)
  {
    uint64_t result = (void **)(*(uint64_t (**)(void *))(v25[0] + 32))(v25);
    uint64_t v17 = a1[2].i64[1];
    if (a1[3].i64[0] != v17) {
      goto LABEL_22;
    }
LABEL_25:
    if (!v9) {
      return result;
    }
    goto LABEL_26;
  }
  if (v26) {
    uint64_t result = (void **)(*((uint64_t (**)(void))*v26 + 5))();
  }
  uint64_t v17 = a1[2].i64[1];
  if (a1[3].i64[0] == v17) {
    goto LABEL_25;
  }
LABEL_22:
  if (v9 == *(void *)(v17 + 8 * (a1[4].i64[0] / 0x55uLL)) + 48 * (a1[4].i64[0] % 0x55uLL)) {
    return result;
  }
LABEL_26:
  uint64_t v18 = v9 - *v12;
  unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * (v18 >> 4);
  if (v18 < 49)
  {
    unint64_t v23 = 85 - v19;
    uint64_t v21 = &v12[-(v23 / 0x55)];
    unint64_t v22 = *v21 + 48 * (85 * (v23 / 0x55) - v23) + 4032;
  }
  else
  {
    unint64_t v20 = v19 - 1;
    uint64_t v21 = &v12[v20 / 0x55];
    unint64_t v22 = *v21 + 48 * (v20 % 0x55);
  }
  long long v24 = *(_OWORD *)(v22 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v22;
  *(_OWORD *)(a3 + 16) = v24;
  *(_OWORD *)(a3 + 25) = *(_OWORD *)(v22 + 25);
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -*(void *)(a3 + 16));
  return std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::erase(a1 + 2, v21, (char *)v22);
}

void sub_1B770B5E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B770B5F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    return a1;
  }
  else
  {
    if (v2) {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    return a1;
  }
}

void **std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::erase(int64x2_t *a1, void *a2, char *a3)
{
  unint64_t v6 = a1[2].u64[0];
  uint64_t v7 = a1->i64[1];
  uint64_t v8 = a1[1].i64[0];
  unint64_t v9 = (const void **)(v7 + 8 * (v6 / 0x55));
  if (v8 != v7)
  {
    unint64_t v10 = (char *)*v9 + 48 * (v6 % 0x55);
    if (a3 != v10) {
      goto LABEL_3;
    }
LABEL_9:
    unint64_t v13 = 0;
    uint64_t v12 = *v9;
    goto LABEL_10;
  }
  unint64_t v10 = 0;
  if (!a3) {
    goto LABEL_9;
  }
LABEL_3:
  uint64_t v11 = 85 * ((const void **)a2 - v9) - 0x5555555555555555 * ((uint64_t)&a3[-*a2] >> 4);
  uint64_t v12 = *v9;
  unint64_t v13 = v11 + 0x5555555555555555 * ((v10 - (unsigned char *)*v9) >> 4);
  if (!v13)
  {
LABEL_10:
    char v22 = 1;
    uint64_t v14 = (const void **)(v7 + 8 * (v6 / 0x55));
    uint64_t v15 = (const void **)v10;
    goto LABEL_13;
  }
  if (v11 < 1)
  {
    uint64_t v14 = &v9[-((84 - v11) / 0x55uLL)];
    uint64_t v12 = *v14;
    uint64_t v15 = (const void **)((char *)*v14 + 48 * (85 * ((84 - v11) / 0x55uLL) - (84 - v11)) + 4032);
    uint64_t v16 = a1[2].i64[1];
    if (v13 > (unint64_t)(v16 - 1) >> 1) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v14 = &v9[v11 / 0x55uLL];
    uint64_t v12 = *v14;
    uint64_t v15 = (const void **)((char *)*v14 + 48 * (v11 % 0x55uLL));
    uint64_t v16 = a1[2].i64[1];
    if (v13 > (unint64_t)(v16 - 1) >> 1)
    {
LABEL_6:
      uint64_t v17 = (char *)v15 - v12;
      unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (((char *)v15 - v12) >> 4);
      if (v17 < -47)
      {
        unint64_t v35 = 83 - v18;
        unint64_t v20 = &v14[-(v35 / 0x55)];
        uint64_t v21 = (char *)*v20 + 48 * (85 * (v35 / 0x55) - v35) + 4032;
      }
      else
      {
        unint64_t v19 = v18 + 1;
        unint64_t v20 = &v14[v19 / 0x55];
        uint64_t v21 = (char *)*v20 + 48 * (v19 % 0x55);
      }
      unint64_t v36 = v16 + v6;
      unint64_t v37 = (v16 + v6) / 0x55;
      long long v38 = (const void **)(v7 + 8 * v37);
      if (v8 == v7) {
        long long v39 = 0;
      }
      else {
        long long v39 = (char *)*v38 + 48 * (v36 - 85 * v37);
      }
      v43[0] = v14;
      v43[1] = v15;
      std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,HGMetalBufferPool::Descriptor*,HGMetalBufferPool::Descriptor&,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,long,85l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*>>(v20, v21, v38, v39, (uint64_t)v43);
      long long v31 = (void **)a1->i64[1];
      long long v40 = (void **)a1[1].i64[0];
      uint64_t v41 = 85 * (v40 - v31) - 1;
      unint64_t v30 = a1[2].u64[0];
      uint64_t v42 = a1[2].i64[1];
      a1[2].i64[1] = v42 - 1;
      if (v40 == v31) {
        uint64_t v41 = 0;
      }
      if (v41 - (v42 + v30) + 1 >= 0xAA)
      {
        operator delete(*(v40 - 1));
        char v22 = 0;
        long long v31 = (void **)a1->i64[1];
        a1[1].i64[0] -= 8;
        unint64_t v30 = a1[2].u64[0];
      }
      else
      {
        char v22 = 0;
      }
      goto LABEL_18;
    }
  }
  char v22 = 0;
LABEL_13:
  uint64_t v23 = (char *)v15 - v12;
  unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * (((char *)v15 - v12) >> 4);
  if (v23 < -47)
  {
    unint64_t v28 = 83 - v24;
    long long v26 = &v14[-(v28 / 0x55)];
    uint64_t v27 = (char *)*v26 + 48 * (85 * (v28 / 0x55) - v28) + 4032;
  }
  else
  {
    unint64_t v25 = v24 + 1;
    long long v26 = &v14[v25 / 0x55];
    uint64_t v27 = (char *)*v26 + 48 * (v25 % 0x55);
  }
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,HGMetalBufferPool::Descriptor*,HGMetalBufferPool::Descriptor&,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,long,85l>,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,0>(v9, v10, v14, (char *)v15, v26, v27, v43);
  int64x2_t v29 = vaddq_s64(a1[2], (int64x2_t)xmmword_1B7E73580);
  a1[2] = v29;
  unint64_t v30 = v29.i64[0];
  long long v31 = (void **)a1->i64[1];
  if (v29.i64[0] >= 0xAAuLL)
  {
    operator delete(*v31);
    long long v31 = (void **)(a1->i64[1] + 8);
    a1->i64[1] = (uint64_t)v31;
    unint64_t v30 = a1[2].i64[0] - 85;
    a1[2].i64[0] = v30;
  }
LABEL_18:
  uint64_t result = &v31[v30 / 0x55];
  if ((void **)a1[1].i64[0] == v31)
  {
    unint64_t v33 = 0;
    if (v22) {
      return result;
    }
  }
  else
  {
    unint64_t v33 = (unint64_t)*result + 48 * (v30 % 0x55);
    if (v22) {
      return result;
    }
  }
  uint64_t v34 = v13 - 0x5555555555555555 * ((uint64_t)(v33 - (void)*result) >> 4);
  if (v34 < 1) {
    result -= (84 - v34) / 0x55uLL;
  }
  else {
    result += v34 / 0x55uLL;
  }
  return result;
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,HGMetalBufferPool::Descriptor*,HGMetalBufferPool::Descriptor&,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,long,85l>,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,0>@<X0>(const void **a1@<X1>, char *a2@<X2>, const void **a3@<X3>, char *a4@<X4>, const void **a5@<X5>, char *a6@<X6>, const void ***a7@<X8>)
{
  uint64_t v8 = a5;
  unint64_t v9 = (const void **)a4;
  unint64_t v10 = a3;
  uint64_t v12 = a7;
  if (a1 == a3)
  {
    if (a2 != a4)
    {
      uint64_t v34 = (uint64_t)*a5;
      unint64_t v35 = a4;
      while (1)
      {
        int64_t v36 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&a6[-v34] >> 4);
        if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v35 - a2) >> 4)) < v36) {
          int64_t v36 = 0xAAAAAAAAAAAAAAABLL * ((v35 - a2) >> 4);
        }
        v35 -= 48 * v36;
        a6 -= 48 * v36;
        if (v36) {
          uint64_t result = memmove(a6, v35, 48 * v36 - 7);
        }
        if (v35 == a2) {
          break;
        }
        uint64_t v37 = (uint64_t)*--v8;
        uint64_t v34 = v37;
        a6 = (char *)(v37 + 4080);
      }
      if ((char *)*v8 + 4080 == a6)
      {
        long long v38 = (char *)v8[1];
        ++v8;
        a6 = v38;
      }
      unint64_t v10 = a3;
    }
  }
  else
  {
    uint64_t v14 = *a3;
    if (*a3 != a4)
    {
      uint64_t v15 = (uint64_t)*a5;
      uint64_t v16 = a4;
      while (1)
      {
        int64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&a6[-v15] >> 4);
        if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v16 - v14) >> 4)) < v17) {
          int64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v16 - v14) >> 4);
        }
        v16 -= 48 * v17;
        a6 -= 48 * v17;
        if (v17) {
          uint64_t result = memmove(a6, v16, 48 * v17 - 7);
        }
        if (v16 == v14) {
          break;
        }
        uint64_t v19 = (uint64_t)*--v8;
        uint64_t v15 = v19;
        a6 = (char *)(v19 + 4080);
      }
      if ((char *)*v8 + 4080 == a6)
      {
        unint64_t v20 = (char *)v8[1];
        ++v8;
        a6 = v20;
      }
      unint64_t v10 = a3;
    }
    uint64_t v21 = v10 - 1;
    if (v10 - 1 != a1)
    {
      char v22 = (char *)*v8;
      do
      {
        while (1)
        {
          uint64_t v23 = *v21;
          unint64_t v24 = (char *)*v21 + 4080;
          while (1)
          {
            int64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((a6 - v22) >> 4);
            if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 4)) < v25) {
              int64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 4);
            }
            v24 -= 48 * v25;
            a6 -= 48 * v25;
            if (v25) {
              uint64_t result = memmove(a6, v24, 48 * v25 - 7);
            }
            if (v24 == v23) {
              break;
            }
            long long v26 = (char *)*--v8;
            char v22 = v26;
            a6 = v26 + 4080;
          }
          char v22 = (char *)*v8;
          if ((char *)*v8 + 4080 == a6) {
            break;
          }
          if (--v21 == a1) {
            goto LABEL_25;
          }
        }
        uint64_t v27 = (char *)v8[1];
        ++v8;
        char v22 = v27;
        a6 = v27;
        --v21;
      }
      while (v21 != a1);
LABEL_25:
      unint64_t v10 = a3;
    }
    unint64_t v28 = (char *)*a1 + 4080;
    unint64_t v9 = (const void **)a4;
    if (v28 != a2)
    {
      uint64_t v29 = (uint64_t)*v8;
      while (1)
      {
        int64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&a6[-v29] >> 4);
        if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v28 - a2) >> 4)) < v30) {
          int64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((v28 - a2) >> 4);
        }
        v28 -= 48 * v30;
        a6 -= 48 * v30;
        if (v30) {
          uint64_t result = memmove(a6, v28, 48 * v30 - 7);
        }
        if (v28 == a2) {
          break;
        }
        uint64_t v31 = (uint64_t)*--v8;
        uint64_t v29 = v31;
        a6 = (char *)(v31 + 4080);
      }
      if ((char *)*v8 + 4080 == a6)
      {
        long long v32 = (char *)v8[1];
        ++v8;
        a6 = v32;
      }
    }
    uint64_t v12 = a7;
  }
  *uint64_t v12 = v10;
  v12[1] = v9;
  v12[2] = v8;
  void v12[3] = (const void **)a6;
  return result;
}

const void **std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,HGMetalBufferPool::Descriptor*,HGMetalBufferPool::Descriptor&,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,long,85l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*>>(const void **result, unsigned char *__src, const void **a3, unsigned char *a4, uint64_t a5)
{
  unint64_t v6 = __src;
  uint64_t v8 = *(void ***)a5;
  uint64_t v7 = *(char **)(a5 + 8);
  if (result == a3)
  {
    if (__src == a4) {
      goto LABEL_48;
    }
    long long v32 = (char *)*v8++;
    uint64_t v31 = v32;
    while (1)
    {
      int64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((v31 - v7 + 4080) >> 4);
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((a4 - v6) >> 4)) >= v33) {
        unint64_t v34 = v33;
      }
      else {
        unint64_t v34 = 0xAAAAAAAAAAAAAAABLL * ((a4 - v6) >> 4);
      }
      if (v34) {
        uint64_t result = (const void **)memmove(v7, v6, 48 * v34 - 7);
      }
      v6 += 48 * v34;
      if (v6 == a4) {
        break;
      }
      unint64_t v35 = (char *)*v8++;
      uint64_t v31 = v35;
      uint64_t v7 = v35;
    }
    v7 += 48 * v34;
    int64_t v30 = v8 - 1;
    if ((char *)*(v8 - 1) + 4080 != v7) {
      goto LABEL_36;
    }
    goto LABEL_47;
  }
  unint64_t v9 = result;
  unint64_t v10 = (char *)*result + 4080;
  if (v10 != __src)
  {
    uint64_t v12 = (char *)*v8++;
    uint64_t v11 = v12;
    while (1)
    {
      int64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v7 + 4080) >> 4);
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v10 - v6) >> 4)) >= v13) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v6) >> 4);
      }
      if (v14) {
        uint64_t result = (const void **)memmove(v7, v6, 48 * v14 - 7);
      }
      v6 += 48 * v14;
      if (v6 == v10) {
        break;
      }
      uint64_t v15 = (char *)*v8++;
      uint64_t v11 = v15;
      uint64_t v7 = v15;
    }
    v7 += 48 * v14;
    if ((char *)*(v8 - 1) + 4080 == v7)
    {
      uint64_t v7 = (char *)*v8;
      *(void *)a5 = v8;
      *(void *)(a5 + 8) = v7;
      uint64_t v16 = v9 + 1;
      if (v9 + 1 != a3) {
        goto LABEL_16;
      }
      goto LABEL_26;
    }
    --v8;
  }
  *(void *)a5 = v8;
  *(void *)(a5 + 8) = v7;
  uint64_t v16 = v9 + 1;
  if (v9 + 1 != a3)
  {
    do
    {
LABEL_16:
      while (1)
      {
        uint64_t v17 = 0;
        long long v38 = v16;
        uint64_t v18 = *v16;
        unint64_t v20 = (char *)*v8++;
        uint64_t v19 = v20;
        while (1)
        {
          int64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((v19 - v7 + 4080) >> 4);
          if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((4080 - 48 * v17) >> 4)) >= v21) {
            unint64_t v22 = v21;
          }
          else {
            unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((4080 - 48 * v17) >> 4);
          }
          if (v22) {
            uint64_t result = (const void **)memmove(v7, (const void *)(v18 + 48 * v17), 48 * v22 - 7);
          }
          v17 += v22;
          if (v17 == 85) {
            break;
          }
          uint64_t v23 = (char *)*v8++;
          uint64_t v19 = v23;
          uint64_t v7 = v23;
        }
        v7 += 48 * v22;
        if ((char *)*(v8 - 1) + 4080 != v7) {
          break;
        }
        uint64_t v7 = (char *)*v8;
        *(void *)a5 = v8;
        *(void *)(a5 + 8) = v7;
        uint64_t v16 = v38 + 1;
        if (v38 + 1 == a3) {
          goto LABEL_26;
        }
      }
      *(void *)a5 = --v8;
      *(void *)(a5 + 8) = v7;
      uint64_t v16 = v38 + 1;
    }
    while (v38 + 1 != a3);
  }
LABEL_26:
  unint64_t v24 = *a3;
  if (*a3 != a4)
  {
    long long v26 = (char *)*v8++;
    int64_t v25 = v26;
    while (1)
    {
      int64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v25 - v7 + 4080) >> 4);
      unint64_t v28 = (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((a4 - v24) >> 4)) >= v27 ? v27 : 0xAAAAAAAAAAAAAAABLL * ((a4 - v24) >> 4);
      if (v28) {
        uint64_t result = (const void **)memmove(v7, v24, 48 * v28 - 7);
      }
      v24 += 48 * v28;
      if (v24 == a4) {
        break;
      }
      uint64_t v29 = (char *)*v8++;
      int64_t v25 = v29;
      uint64_t v7 = v29;
    }
    v7 += 48 * v28;
    int64_t v30 = v8 - 1;
    if ((char *)*(v8 - 1) + 4080 != v7)
    {
LABEL_36:
      uint64_t v8 = v30;
      goto LABEL_48;
    }
LABEL_47:
    uint64_t v7 = (char *)*v8;
  }
LABEL_48:
  *(void *)a5 = v8;
  *(void *)(a5 + 8) = v7;
  return result;
}

void *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10CAC90;
  uint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    return a1;
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    return a1;
  }
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10CAC90;
  uint64_t v1 = a1 + 1;
  uint64_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  void *v2 = &unk_1F10CAC90;
  uint64_t v3 = v2 + 1;
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4) {
    goto LABEL_4;
  }
  if (v4 != a1 + 8)
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 16))(v4, v3);
LABEL_4:
    uint64_t v5 = *(void *)(a1 + 40);
    v2[4] = v4;
    v2[5] = v5;
    return v2;
  }
  v2[4] = v3;
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  v2[5] = *(void *)(a1 + 40);
  return v2;
}

void sub_1B770C378(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F10CAC90;
  uint64_t v4 = a2 + 1;
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 16))(result, v4);
      a2[4] = result;
    }
    a2[5] = *(void *)(a1 + 40);
  }
  else
  {
    a2[4] = 0;
    a2[5] = *(void *)(a1 + 40);
  }
  return result;
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::destroy_deallocate(char *__p)
{
  uint64_t v2 = __p + 8;
  uint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    uint64_t v4 = __p;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = __p;
  }
  operator delete(v4);
}

BOOL std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 40) == *(void *)(a2 + 16);
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE"))return 0; {
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  }
  return 0;
}

void *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::target_type()
{
}

void std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x55;
  unint64_t v4 = v2 - 85;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    unint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        unint64_t v34 = (char *)operator new(8 * v31);
        unint64_t v35 = &v34[8 * v32];
        int64_t v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            int v74 = &v34[8 * v32];
            long long v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              long long v40 = &v35[v76];
              v7 += v76;
              v77 = (long long *)(v6 + 3);
              v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                _OWORD *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            long long v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)long long v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    uint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0xFF0uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0xFF0uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        unint64_t v34 = (char *)operator new(8 * v42);
        unint64_t v35 = &v34[8 * v43];
        int64_t v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            long long v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              long long v47 = &v35[v84];
              v7 += v84;
              v85 = (long long *)(v41 + 3);
              v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                _OWORD *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            long long v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)long long v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  int64_t v25 = (char *)operator new(8 * v24);
  long long v26 = operator new(0xFF0uLL);
  int64_t v27 = &v25[8 * v21];
  unint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v49 = (char *)operator new(8 * v48);
      int64_t v27 = &v49[8 * (v48 >> 2)];
      unint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      int64_t v25 = v49;
      *(void *)int64_t v27 = v90;
      uint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)int64_t v27 = v26;
      uint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v60 = (char *)operator new(8 * v59);
          int64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          uint64_t v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v53;
          if (!v37)
          {
            uint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            v64 = &v60[8 * v61];
            uint64_t v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            v64 = &v60[8 * v61];
            uint64_t v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            uint64_t v65 = &v27[v68];
            v69 = (long long *)(v27 + 16);
            v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          unint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          uint64_t v57 = &v29[8 * (v56 >> 1)];
          uint64_t v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          int64_t v25 = v27;
        }
      }
      else
      {
        uint64_t v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      char v51 = v53 - 8;
      int64_t v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)int64_t v27 = v26;
  uint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  char v51 = v27;
LABEL_46:
  int v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B770CB80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B770CB9C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B770CBB0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B770CBC8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,true>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v15 = 0;
  uint64_t v16 = v5;
  uint64_t v10 = 0;
  uint64_t v11 = v5;
  unint64_t v6 = operator new(0x30uLL);
  void *v6 = &unk_1F10CAD98;
  v6[4] = 0;
  v6[5] = v5;
  uint64_t v13 = v6;
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,true>::_retrieve(a1, v12, a3);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
    uint64_t v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v13) {
      (*(void (**)(void))(*v13 + 40))();
    }
    uint64_t v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v15;
      if (v15 != v14) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B770CDD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va1);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B770CDF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void sub_1B770D008(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va1);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B770D02C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void **HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,true>::_retrieve@<X0>(int64x2_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  *(void *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(unsigned char *)(a3 + 40) = 1;
  unint64_t v5 = a1[4].u64[0];
  unint64_t v6 = v5 + a1[4].i64[1];
  unint64_t v7 = v6 / 0x55;
  uint64_t v8 = a1[2].i64[1];
  if (a1[3].i64[0] != v8)
  {
    unint64_t v9 = *(void *)(v8 + 8 * v7) + 48 * (v6 % 0x55);
    unint64_t v10 = *(void *)(v8 + 8 * (v5 / 0x55)) + 48 * (v5 % 0x55);
    uint64_t v11 = (void *)a2[3];
    if (v11) {
      goto LABEL_3;
    }
LABEL_6:
    long long v26 = 0;
    goto LABEL_8;
  }
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  uint64_t v11 = (void *)a2[3];
  if (!v11) {
    goto LABEL_6;
  }
LABEL_3:
  if (v11 == a2)
  {
    long long v26 = (void **)v25;
    (*(void (**)(void *, void *))(*a2 + 24))(a2, v25);
  }
  else
  {
    long long v26 = (void **)(*(uint64_t (**)(void *))(*v11 + 16))(v11);
  }
LABEL_8:
  uint64_t v12 = (uint64_t *)(v8 + 8 * v7);
  if (v9 != v10)
  {
    uint64_t v13 = *v12;
    while (1)
    {
      uint64_t v14 = v9;
      if (v9 == v13) {
        uint64_t v14 = *(v12 - 1) + 4080;
      }
      if (!v26) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      if ((*((uint64_t (**)(void **, uint64_t))*v26 + 6))(v26, v14 - 48)) {
        break;
      }
      uint64_t v13 = *v12;
      if (v9 == *v12)
      {
        uint64_t v15 = *--v12;
        uint64_t v13 = v15;
        unint64_t v9 = v15 + 4080;
      }
      v9 -= 48;
      if (v9 == v10)
      {
        unint64_t v9 = v10;
        break;
      }
    }
  }
  uint64_t result = v26;
  if (v26 == v25)
  {
    uint64_t result = (void **)(*(uint64_t (**)(void *))(v25[0] + 32))(v25);
    uint64_t v17 = a1[2].i64[1];
    if (a1[3].i64[0] != v17) {
      goto LABEL_22;
    }
LABEL_25:
    if (!v9) {
      return result;
    }
    goto LABEL_26;
  }
  if (v26) {
    uint64_t result = (void **)(*((uint64_t (**)(void))*v26 + 5))();
  }
  uint64_t v17 = a1[2].i64[1];
  if (a1[3].i64[0] == v17) {
    goto LABEL_25;
  }
LABEL_22:
  if (v9 == *(void *)(v17 + 8 * (a1[4].i64[0] / 0x55uLL)) + 48 * (a1[4].i64[0] % 0x55uLL)) {
    return result;
  }
LABEL_26:
  uint64_t v18 = v9 - *v12;
  unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * (v18 >> 4);
  if (v18 < 49)
  {
    unint64_t v23 = 85 - v19;
    uint64_t v21 = &v12[-(v23 / 0x55)];
    unint64_t v22 = *v21 + 48 * (85 * (v23 / 0x55) - v23) + 4032;
  }
  else
  {
    unint64_t v20 = v19 - 1;
    uint64_t v21 = &v12[v20 / 0x55];
    unint64_t v22 = *v21 + 48 * (v20 % 0x55);
  }
  long long v24 = *(_OWORD *)(v22 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v22;
  *(_OWORD *)(a3 + 16) = v24;
  *(_OWORD *)(a3 + 25) = *(_OWORD *)(v22 + 25);
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -*(void *)(a3 + 16));
  return std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::erase(a1 + 2, v21, (char *)v22);
}

void sub_1B770D39C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B770D3B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10CAD98;
  unint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    return a1;
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    return a1;
  }
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10CAD98;
  uint64_t v1 = a1 + 1;
  unint64_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::__clone(uint64_t a1)
{
  unint64_t v2 = operator new(0x30uLL);
  void *v2 = &unk_1F10CAD98;
  uint64_t v3 = v2 + 1;
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4) {
    goto LABEL_4;
  }
  if (v4 != a1 + 8)
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 16))(v4, v3);
LABEL_4:
    uint64_t v5 = *(void *)(a1 + 40);
    v2[4] = v4;
    v2[5] = v5;
    return v2;
  }
  v2[4] = v3;
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  v2[5] = *(void *)(a1 + 40);
  return v2;
}

void sub_1B770D608(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F10CAD98;
  uint64_t v4 = a2 + 1;
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 16))(result, v4);
      a2[4] = result;
    }
    a2[5] = *(void *)(a1 + 40);
  }
  else
  {
    a2[4] = 0;
    a2[5] = *(void *)(a1 + 40);
  }
  return result;
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::destroy_deallocate(char *__p)
{
  unint64_t v2 = __p + 8;
  uint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    uint64_t v4 = __p;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = __p;
  }
  operator delete(v4);
}

BOOL std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::operator()(uint64_t a1, void *a2)
{
  return *a2 == *(void *)(a1 + 40);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE"))return 0; {
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  }
  return 0;
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::target_type()
{
}

void std::__shared_ptr_emplace<anonymous namespace'::BufferWrapperAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CAE20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<anonymous namespace'::BufferWrapperAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CAE20;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<anonymous namespace'::BufferWrapperAllocator>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void anonymous namespace'::BufferWrapperAllocator::~BufferWrapperAllocator(_anonymous_namespace_::BufferWrapperAllocator *this)
{
}

uint64_t anonymous namespace'::BufferWrapperAllocator::allocate(uint64_t a1, void *a2)
{
  return [*(id *)(a1 + 8) newBufferWithBytesNoCopy:*a2 length:a2[1] options:a2[2] deallocator:0];
}

void anonymous namespace'::BufferWrapperAllocator::release(uint64_t a1, void *a2)
{
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::~Pool(a1, a2);

  JUMPOUT(0x1BA9BFBA0);
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::usedObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 128));
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::usedTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 136));
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::freeObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 232));
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::freeTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 240));
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::service(std::mutex *a1)
{
  unint64_t v2 = a1 + 4;
  std::mutex::lock(a1 + 4);
  if (HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::service((uint64_t)&a1[2].__m_.__opaque[16], (uint64_t)a1))
  {
    (*(void (**)(std::mutex *))(a1->__m_.__sig + 24))(a1);
    (*(void (**)(std::mutex *))(a1->__m_.__sig + 40))(a1);
    kdebug_trace();
  }

  std::mutex::unlock(v2);
}

void sub_1B770DB4C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::trace(std::mutex *a1)
{
  unint64_t v2 = a1 + 4;
  std::mutex::lock(a1 + 4);
  sig = a1 + 5;
  if (a1[5].__m_.__opaque[15] < 0) {
    sig = (std::mutex *)sig->__m_.__sig;
  }
  (*(void (**)(std::mutex *, std::mutex *))(a1->__m_.__sig + 24))(a1, sig);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 16))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 40))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 32))(a1);
  std::mutex::unlock(v2);
}

void sub_1B770DD9C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B770DDB0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B770DDC4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B770DDD8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::log(uint64_t a1, const char *a2)
{
  unint64_t v3 = (HGLogger *)(a1 + 344);
  if (*(char *)(a1 + 367) < 0)
  {
    unint64_t v3 = *(HGLogger **)v3;
    if ((int)HGLogger::getLevel(v3, a2) < 2) {
      return;
    }
  }
  else if ((int)HGLogger::getLevel((HGLogger *)(a1 + 344), a2) < 2)
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6)
  {
    unint64_t v7 = (void *)(a1 + 320);
    if (*(char *)(a1 + 343) < 0) {
      unint64_t v7 = (void *)*v7;
    }
    HGLogger::log(v3, (const char *)2, (HGLogger *)"pool '%s' (%p)\n", v4, v5, v7, a1);
  }
  HGLogger::indent(1);
  unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
  if (v10) {
    HGLogger::log(v3, (const char *)2, (HGLogger *)"live objects:\n", v8, v9);
  }
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,true>::log((void *)(a1 + 48), v3);
  unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
  if (v13) {
    HGLogger::log(v3, (const char *)2, (HGLogger *)"free objects:\n", v11, v12);
  }
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::log((void *)(a1 + 152), v3);
  HGLogger::indent(0xFFFFFFFFLL);

  std::mutex::unlock((std::mutex *)(a1 + 256));
}

void sub_1B770DF18(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::canService(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 372);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::canTrace(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 373);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::canLog(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 374);
}

int64x2_t *HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::~List(int64x2_t *a1, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  while (a1[4].i64[1])
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_pop_front(a1, 1, a3, a4, a5);
  std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::~deque[abi:ne180100]((uint64_t)a1[2].i64);
  unsigned __int8 v6 = (std::__shared_weak_count *)a1[1].i64[1];
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  unint64_t v7 = (std::__shared_weak_count *)a1->i64[1];
  if (!v7 || atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
  std::__shared_weak_count::__release_weak(v7);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_pop_front(int64x2_t *a1, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v6 = (uint64_t *)(*(void *)(a1[2].i64[1] + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8))
                 + ((a1[4].i64[0] & 0x3F) << 6));
  uint64_t v8 = *v6;
  uint64_t v7 = v6[1];
  uint64_t v9 = v6[3];
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -v9);
  unsigned __int8 v10 = (void **)a1[2].i64[1];
  int64x2_t v11 = vaddq_s64(a1[4], (int64x2_t)xmmword_1B7E73580);
  a1[4] = v11;
  if (v11.i64[0] >= 0x80uLL)
  {
    operator delete(*v10);
    a1[2].i64[1] += 8;
    a1[4].i64[0] -= 64;
  }
  char v16 = 0;
  LOBYTE(__p) = 0;
  unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
  if (v12)
  {
    p_p = &__p;
    if (v16 < 0) {
      p_p = __p;
    }
    HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry deleted : %p (%s)\n", a4, a5, v8, p_p);
  }
  if (v16 < 0) {
    operator delete(__p);
  }
  kdebug_trace();
  LODWORD(__p) = 4164;
  kdebug_trace();
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1->i64[0] + 24))(a1->i64[0], v8);
  if (v7) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1->i64[0] + 24))(a1->i64[0], v7);
  }
  return kdebug_trace();
}

void sub_1B770E214(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B770E230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  *(void *)a1 = &unk_1F10CAEC8;
  HGPool::unregisterPool((HGPool *)a1, a2);
  if (*(char *)(a1 + 367) < 0)
  {
    operator delete(*(void **)(a1 + 344));
    if ((*(char *)(a1 + 343) & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_16:
    operator delete(*(void **)(a1 + 320));
    goto LABEL_3;
  }
  if (*(char *)(a1 + 343) < 0) {
    goto LABEL_16;
  }
LABEL_3:
  std::mutex::~mutex((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::~List((int64x2_t *)(a1 + 152), v3, v4, v5, v6);
  std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::~deque[abi:ne180100](a1 + 80);
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 56);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 40);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  unsigned __int8 v10 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v10 || atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
  std::__shared_weak_count::__release_weak(v10);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::service(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 16))
  {
    if (*(void *)(a1 + 72))
    {
      uint64_t v4 = 0;
      while (1)
      {
        unint64_t v6 = atomic_load((unint64_t *)(a1 + 80));
        if (v6 > (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), a2))
        {
          uint64_t v5 = 4;
        }
        else
        {
          unint64_t v10 = atomic_load((unint64_t *)(a1 + 88));
          if (v10 <= (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16), a2))
          {
            unint64_t v11 = *(void *)(a1 + 64);
            uint64_t v12 = *(void *)(*(void *)(a1 + 40) + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8));
            unint64_t v13 = std::chrono::steady_clock::now().__d_.__rep_ - *(void *)(v12 + ((v11 & 0x3F) << 6) + 40);
            if (v13 <= (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16), a2))return v4; {
            uint64_t v5 = 6;
            }
          }
          else
          {
            uint64_t v5 = 5;
          }
        }
        HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_pop_front((int64x2_t *)a1, v5, v7, v8, v9);
        ++v4;
        if (!*(void *)(a1 + 72)) {
          return v4;
        }
      }
    }
    return 0;
  }
  else
  {
    return 0;
  }
}

void HGPool::EntryTrace<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::trace(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 56)) {
    std::chrono::steady_clock::now();
  }
}

void sub_1B770E600(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,true>::log(void *a1, HGLogger *a2)
{
  if (a1[9])
  {
    HGLogger::indent(1);
    uint64_t v4 = a1[5];
    if (a1[6] != v4)
    {
      unint64_t v5 = a1[8];
      unint64_t v6 = (void *)(v4 + 8 * (v5 >> 6));
      uint64_t v7 = (long long *)(*v6 + ((v5 & 0x3F) << 6));
      uint64_t v8 = *(void *)(v4 + (((a1[9] + v5) >> 3) & 0x1FFFFFFFFFFFFFF8)) + (((a1[9] + v5) & 0x3F) << 6);
      while (v7 != (long long *)v8)
      {
        long long v9 = *v7;
        long long v10 = v7[1];
        long long v11 = v7[3];
        long long v21 = v7[2];
        long long v22 = v11;
        *(_OWORD *)std::string __p = v9;
        long long v20 = v10;
        HGPool::EntryLog<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 4;
        if ((long long *)((char *)v7 - *v6) == (long long *)4096)
        {
          uint64_t v12 = (long long *)v6[1];
          ++v6;
          uint64_t v7 = v12;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    unint64_t v13 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v13);
    unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
    if (v16)
    {
      if ((SBYTE7(v20) & 0x80u) == 0) {
        uint64_t v17 = __p;
      }
      else {
        uint64_t v17 = (void **)__p[0];
      }
      unint64_t v18 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v14, v15, v17, v18);
    }
    if (SBYTE7(v20) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1B770E76C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::log(void *a1, HGLogger *a2)
{
  if (a1[9])
  {
    HGLogger::indent(1);
    uint64_t v4 = a1[5];
    if (a1[6] != v4)
    {
      unint64_t v5 = a1[8];
      unint64_t v6 = (void *)(v4 + 8 * (v5 >> 6));
      uint64_t v7 = (long long *)(*v6 + ((v5 & 0x3F) << 6));
      uint64_t v8 = *(void *)(v4 + (((a1[9] + v5) >> 3) & 0x1FFFFFFFFFFFFFF8)) + (((a1[9] + v5) & 0x3F) << 6);
      while (v7 != (long long *)v8)
      {
        long long v9 = *v7;
        long long v10 = v7[1];
        long long v11 = v7[3];
        long long v21 = v7[2];
        long long v22 = v11;
        *(_OWORD *)std::string __p = v9;
        long long v20 = v10;
        HGPool::EntryLog<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 4;
        if ((long long *)((char *)v7 - *v6) == (long long *)4096)
        {
          uint64_t v12 = (long long *)v6[1];
          ++v6;
          uint64_t v7 = v12;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    unint64_t v13 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v13);
    unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
    if (v16)
    {
      if ((SBYTE7(v20) & 0x80u) == 0) {
        uint64_t v17 = __p;
      }
      else {
        uint64_t v17 = (void **)__p[0];
      }
      unint64_t v18 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v14, v15, v17, v18);
    }
    if (SBYTE7(v20) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1B770E8D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::EntryLog<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::log(uint64_t *a1, HGLogger *a2, const char *a3)
{
  uint64_t v6 = *a1;
  HGLoggerUtils::bytesPrettyString((HGLoggerUtils *)a1[3]);
  char v22 = 0;
  LOBYTE(v21[0]) = 0;
  if (*((unsigned char *)a1 + 56))
  {
    unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
    if (v9)
    {
      long long v10 = v23;
      if (v24 < 0) {
        long long v10 = (void **)v23[0];
      }
      long long v11 = v21;
      if (v22 < 0) {
        long long v11 = (void **)v21[0];
      }
      HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu   %s\n", v7, v8, v6, v10, a1[6], v11);
    }
    goto LABEL_17;
  }
  v12.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  HGLoggerUtils::timePrettyString((HGLoggerUtils *)(v12.__d_.__rep_ - a1[5]));
  unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
  if (v15)
  {
    unsigned __int8 v16 = v23;
    if (v24 < 0) {
      unsigned __int8 v16 = (void **)v23[0];
    }
    p_p = &__p;
    if (v20 < 0) {
      p_p = __p;
    }
    unint64_t v18 = v21;
    if (v22 < 0) {
      unint64_t v18 = (void **)v21[0];
    }
    HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu  %10s   %s\n", v13, v14, v6, v16, a1[6], p_p, v18);
  }
  if ((v20 & 0x80000000) == 0)
  {
LABEL_17:
    if ((v22 & 0x80000000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_21;
  }
  operator delete(__p);
  if ((v22 & 0x80000000) == 0)
  {
LABEL_18:
    if ((v24 & 0x80000000) == 0) {
      return;
    }
LABEL_22:
    operator delete(v23[0]);
    return;
  }
LABEL_21:
  operator delete(v21[0]);
  if (v24 < 0) {
    goto LABEL_22;
  }
}

void sub_1B770EA80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v25 - 33) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);
  if ((*(char *)(v25 - 33) & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*(void **)(v25 - 56));
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<anonymous namespace'::InfinipoolServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CAF50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10D67C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<anonymous namespace'::InfinipoolServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CAF50;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

{
  uint64_t vars8;

  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10D67C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<anonymous namespace'::InfinipoolServicingPolicy>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void anonymous namespace'::InfinipoolServicingPolicy::~InfinipoolServicingPolicy(_anonymous_namespace_::InfinipoolServicingPolicy *this)
{
}

{
  JUMPOUT(0x1BA9BFBA0);
}

uint64_t HGPool::ServicingPolicy::maxObjectsCount(HGPool::ServicingPolicy *this, const BasePool *a2)
{
  return -1;
}

uint64_t anonymous namespace'::InfinipoolServicingPolicy::maxObjectAgeNS(_anonymous_namespace_::InfinipoolServicingPolicy *this, const BasePool *a2)
{
  return 2000000000;
}

{
  return 2000000000;
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v16 = 0;
  long long v17 = *a2;
  uint64_t v18 = *((void *)a2 + 2);
  long long v10 = 0;
  long long v11 = v17;
  uint64_t v12 = v18;
  uint64_t v14 = 0;
  uint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v6 = &unk_1F10CAFF0;
  *((void *)v6 + 4) = 0;
  *(_OWORD *)(v6 + 40) = *a2;
  *((void *)v6 + 7) = *((void *)a2 + 2);
  uint64_t v14 = v6;
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_retrieve(a1, v13, a3);
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
    uint64_t v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v14) {
      (*(void (**)(void))(*v14 + 40))();
    }
    uint64_t v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v16;
      if (v16 != v15) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v15[0] + 32))(v15);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v16;
  if (v16 == v15) {
    return (*(uint64_t (**)(void *))(v15[0] + 32))(v15);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B770EDCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va1);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B770EDF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void **HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_retrieve@<X0>(int64x2_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  *(void *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(unsigned char *)(a3 + 56) = 1;
  unint64_t v5 = a1[4].i64[0] + a1[4].i64[1];
  uint64_t v6 = a1[2].i64[1];
  uint64_t v7 = (uint64_t *)(v6 + 8 * (v5 >> 6));
  if (a1[3].i64[0] != v6)
  {
    uint64_t v8 = *v7 + ((v5 & 0x3F) << 6);
    uint64_t v9 = *(void *)(v6 + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((a1[4].i64[0] & 0x3F) << 6);
    uint64_t v10 = (void *)a2[3];
    if (v10) {
      goto LABEL_3;
    }
LABEL_6:
    char v24 = 0;
    goto LABEL_8;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = (void *)a2[3];
  if (!v10) {
    goto LABEL_6;
  }
LABEL_3:
  if (v10 == a2)
  {
    char v24 = (void **)v23;
    (*(void (**)(void *, void *))(*a2 + 24))(a2, v23);
  }
  else
  {
    char v24 = (void **)(*(uint64_t (**)(void *))(*v10 + 16))(v10);
  }
LABEL_8:
  if (v8 != v9)
  {
    uint64_t v11 = *v7;
    while (1)
    {
      uint64_t v12 = v8;
      if (v8 == v11) {
        uint64_t v12 = *(v7 - 1) + 4096;
      }
      if (!v24) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      if ((*((uint64_t (**)(void **, uint64_t))*v24 + 6))(v24, v12 - 64)) {
        break;
      }
      uint64_t v11 = *v7;
      if (v8 == *v7)
      {
        uint64_t v13 = *--v7;
        uint64_t v11 = v13;
        uint64_t v8 = v13 + 4096;
      }
      v8 -= 64;
      if (v8 == v9)
      {
        uint64_t v8 = v9;
        break;
      }
    }
  }
  uint64_t result = v24;
  if (v24 == v23)
  {
    uint64_t result = (void **)(*(uint64_t (**)(void *))(v23[0] + 32))(v23);
    uint64_t v15 = a1[2].i64[1];
    if (a1[3].i64[0] != v15) {
      goto LABEL_22;
    }
LABEL_25:
    if (!v8) {
      return result;
    }
    goto LABEL_26;
  }
  if (v24) {
    uint64_t result = (void **)(*((uint64_t (**)(void))*v24 + 5))();
  }
  uint64_t v15 = a1[2].i64[1];
  if (a1[3].i64[0] == v15) {
    goto LABEL_25;
  }
LABEL_22:
  if (v8 == *(void *)(v15 + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8))
           + ((a1[4].i64[0] & 0x3F) << 6))
    return result;
LABEL_26:
  uint64_t v16 = v8 - *v7;
  uint64_t v17 = v16 >> 6;
  if (v16 < 65)
  {
    unint64_t v21 = 64 - v17;
    uint64_t v19 = (char *)&v7[-(v21 >> 6)];
    unint64_t v20 = *(void *)v19 + ((unint64_t)(~(_BYTE)v21 & 0x3F) << 6);
  }
  else
  {
    unint64_t v18 = v17 - 1;
    uint64_t v19 = (char *)&v7[v18 >> 6];
    unint64_t v20 = *(void *)v19 + ((v18 & 0x3F) << 6);
  }
  long long v22 = *(_OWORD *)(v20 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v20;
  *(_OWORD *)(a3 + 16) = v22;
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v20 + 32);
  *(_OWORD *)(a3 + 41) = *(_OWORD *)(v20 + 41);
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -*(void *)(a3 + 24));
  return std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::erase(a1 + 2, v19, (char *)v20);
}

void sub_1B770F114(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B770F128(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function(void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    return a1;
  }
  else
  {
    if (v2) {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    return a1;
  }
}

void *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10CAFF0;
  unint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    return a1;
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    return a1;
  }
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10CAFF0;
  uint64_t v1 = a1 + 1;
  unint64_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

char *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)unint64_t v2 = &unk_1F10CAFF0;
  uint64_t v3 = v2 + 8;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    if (v4 == a1 + 8)
    {
      *((void *)v2 + 4) = v3;
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      goto LABEL_6;
    }
    uint64_t v4 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v4 + 16))(v4, v3);
  }
  *((void *)v2 + 4) = v4;
LABEL_6:
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return v2;
}

void sub_1B770F408(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F10CAFF0;
  uint64_t v4 = a2 + 8;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    if (v5 == a1 + 8)
    {
      *(void *)(a2 + 32) = v4;
      (*(void (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
    }
    else
    {
      *(void *)(a2 + 32) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 16))(v5, v4);
    }
  }
  else
  {
    *(void *)(a2 + 32) = 0;
  }
  __n128 result = *(__n128 *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::destroy_deallocate(char *__p)
{
  unint64_t v2 = __p + 8;
  uint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    uint64_t v4 = __p;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = __p;
  }
  operator delete(v4);
}

BOOL std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::operator()(void *a1, void *a2)
{
  return a1[5] == a2[2] && a1[6] == a2[3] && a1[7] == a2[4];
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinipool10DescriptorEEE") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperIn"
                                "finipool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinipool10DescriptorEEE"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinipool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::target_type()
{
}

void HGPool::EntryEventHandler<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::allocated(void *a1, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  char v8 = 0;
  LOBYTE(__p) = 0;
  unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
  if (v5)
  {
    p_p = &__p;
    if (v8 < 0) {
      p_p = __p;
    }
    HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry allocated : %p (%s)\n", a4, a5, *a1, p_p);
  }
  if (v8 < 0) {
    operator delete(__p);
  }
}

void sub_1B770F750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x40;
  unint64_t v4 = v2 - 64;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    unsigned __int8 v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)unsigned __int8 v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        unint64_t v34 = (char *)operator new(8 * v31);
        unint64_t v35 = &v34[8 * v32];
        int64_t v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        unsigned __int8 v5 = v35;
        if (!v37)
        {
          unsigned __int8 v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            int v74 = &v34[8 * v32];
            long long v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              long long v40 = &v35[v76];
              v7 += v76;
              v77 = (long long *)(v6 + 3);
              v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                _OWORD *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            long long v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)long long v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    uint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    unsigned __int8 v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    unsigned __int8 v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        unint64_t v34 = (char *)operator new(8 * v42);
        unint64_t v35 = &v34[8 * v43];
        int64_t v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        unsigned __int8 v5 = v35;
        if (!v37)
        {
          unsigned __int8 v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            long long v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              long long v47 = &v35[v84];
              v7 += v84;
              v85 = (long long *)(v41 + 3);
              v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                _OWORD *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            long long v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)long long v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          unsigned __int8 v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  long long v26 = operator new(0x1000uLL);
  uint64_t v27 = &v25[8 * v21];
  unint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v49 = (char *)operator new(8 * v48);
      uint64_t v27 = &v49[8 * (v48 >> 2)];
      unint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v25 = v49;
      *(void *)uint64_t v27 = v90;
      uint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)uint64_t v27 = v26;
      uint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v60 = (char *)operator new(8 * v59);
          uint64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          uint64_t v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v53;
          if (!v37)
          {
            uint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            v64 = &v60[8 * v61];
            uint64_t v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            v64 = &v60[8 * v61];
            uint64_t v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            uint64_t v65 = &v27[v68];
            v69 = (long long *)(v27 + 16);
            v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          unint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          uint64_t v57 = &v29[8 * (v56 >> 1)];
          uint64_t v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          uint64_t v25 = v27;
        }
      }
      else
      {
        uint64_t v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      char v51 = v53 - 8;
      uint64_t v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)uint64_t v27 = v26;
  uint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  char v51 = v27;
LABEL_46:
  int v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B770FCDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B770FCF8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B770FD0C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B770FD24(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,true>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v15 = 0;
  uint64_t v16 = v5;
  uint64_t v10 = 0;
  uint64_t v11 = v5;
  uint64_t v6 = operator new(0x30uLL);
  void *v6 = &unk_1F10CB0F8;
  v6[4] = 0;
  v6[5] = v5;
  uint64_t v13 = v6;
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,true>::_retrieve(a1, v12, a3);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
    uint64_t v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v13) {
      (*(void (**)(void))(*v13 + 40))();
    }
    uint64_t v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v15;
      if (v15 != v14) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B770FF30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va1);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B770FF54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v15 = 0;
  uint64_t v16 = v5;
  uint64_t v10 = 0;
  uint64_t v11 = v5;
  uint64_t v6 = operator new(0x30uLL);
  void *v6 = &unk_1F10CB0F8;
  v6[4] = 0;
  v6[5] = v5;
  uint64_t v13 = v6;
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_retrieve(a1, v12, a3);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
    uint64_t v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v13) {
      (*(void (**)(void))(*v13 + 40))();
    }
    uint64_t v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v15;
      if (v15 != v14) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B7710164(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va1);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B7710188(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void **HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,true>::_retrieve@<X0>(int64x2_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  *(void *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(unsigned char *)(a3 + 56) = 1;
  unint64_t v5 = a1[4].i64[0] + a1[4].i64[1];
  uint64_t v6 = a1[2].i64[1];
  uint64_t v7 = (uint64_t *)(v6 + 8 * (v5 >> 6));
  if (a1[3].i64[0] != v6)
  {
    uint64_t v8 = *v7 + ((v5 & 0x3F) << 6);
    uint64_t v9 = *(void *)(v6 + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((a1[4].i64[0] & 0x3F) << 6);
    uint64_t v10 = (void *)a2[3];
    if (v10) {
      goto LABEL_3;
    }
LABEL_6:
    unint64_t v24 = 0;
    goto LABEL_8;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = (void *)a2[3];
  if (!v10) {
    goto LABEL_6;
  }
LABEL_3:
  if (v10 == a2)
  {
    unint64_t v24 = (void **)v23;
    (*(void (**)(void *, void *))(*a2 + 24))(a2, v23);
  }
  else
  {
    unint64_t v24 = (void **)(*(uint64_t (**)(void *))(*v10 + 16))(v10);
  }
LABEL_8:
  if (v8 != v9)
  {
    uint64_t v11 = *v7;
    while (1)
    {
      uint64_t v12 = v8;
      if (v8 == v11) {
        uint64_t v12 = *(v7 - 1) + 4096;
      }
      if (!v24) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      if ((*((uint64_t (**)(void **, uint64_t))*v24 + 6))(v24, v12 - 64)) {
        break;
      }
      uint64_t v11 = *v7;
      if (v8 == *v7)
      {
        uint64_t v13 = *--v7;
        uint64_t v11 = v13;
        uint64_t v8 = v13 + 4096;
      }
      v8 -= 64;
      if (v8 == v9)
      {
        uint64_t v8 = v9;
        break;
      }
    }
  }
  uint64_t result = v24;
  if (v24 == v23)
  {
    uint64_t result = (void **)(*(uint64_t (**)(void *))(v23[0] + 32))(v23);
    uint64_t v15 = a1[2].i64[1];
    if (a1[3].i64[0] != v15) {
      goto LABEL_22;
    }
LABEL_25:
    if (!v8) {
      return result;
    }
    goto LABEL_26;
  }
  if (v24) {
    uint64_t result = (void **)(*((uint64_t (**)(void))*v24 + 5))();
  }
  uint64_t v15 = a1[2].i64[1];
  if (a1[3].i64[0] == v15) {
    goto LABEL_25;
  }
LABEL_22:
  if (v8 == *(void *)(v15 + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8))
           + ((a1[4].i64[0] & 0x3F) << 6))
    return result;
LABEL_26:
  uint64_t v16 = v8 - *v7;
  uint64_t v17 = v16 >> 6;
  if (v16 < 65)
  {
    unint64_t v21 = 64 - v17;
    uint64_t v19 = (char *)&v7[-(v21 >> 6)];
    unint64_t v20 = *(void *)v19 + ((unint64_t)(~(_BYTE)v21 & 0x3F) << 6);
  }
  else
  {
    unint64_t v18 = v17 - 1;
    uint64_t v19 = (char *)&v7[v18 >> 6];
    unint64_t v20 = *(void *)v19 + ((v18 & 0x3F) << 6);
  }
  long long v22 = *(_OWORD *)(v20 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v20;
  *(_OWORD *)(a3 + 16) = v22;
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v20 + 32);
  *(_OWORD *)(a3 + 41) = *(_OWORD *)(v20 + 41);
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -*(void *)(a3 + 24));
  return std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::erase(a1 + 2, v19, (char *)v20);
}

void sub_1B77104AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B77104C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10CB0F8;
  unint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    return a1;
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    return a1;
  }
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10CB0F8;
  uint64_t v1 = a1 + 1;
  unint64_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::__clone(uint64_t a1)
{
  unint64_t v2 = operator new(0x30uLL);
  void *v2 = &unk_1F10CB0F8;
  uint64_t v3 = v2 + 1;
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4) {
    goto LABEL_4;
  }
  if (v4 != a1 + 8)
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 16))(v4, v3);
LABEL_4:
    uint64_t v5 = *(void *)(a1 + 40);
    v2[4] = v4;
    v2[5] = v5;
    return v2;
  }
  v2[4] = v3;
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  v2[5] = *(void *)(a1 + 40);
  return v2;
}

void sub_1B7710718(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F10CB0F8;
  uint64_t v4 = a2 + 1;
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 16))(result, v4);
      a2[4] = result;
    }
    a2[5] = *(void *)(a1 + 40);
  }
  else
  {
    a2[4] = 0;
    a2[5] = *(void *)(a1 + 40);
  }
  return result;
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::destroy_deallocate(char *__p)
{
  unint64_t v2 = __p + 8;
  uint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    uint64_t v4 = __p;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = __p;
  }
  operator delete(v4);
}

BOOL std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::operator()(uint64_t a1, void *a2)
{
  return *a2 == *(void *)(a1 + 40);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinipool10DescriptorEEE") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinip"
                                "ool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinipool10DescriptorEEE"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinipool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::target_type()
{
}

void HGPQ::EOTF::EOTF(HGNode *this, double a2)
{
  HGNode::HGNode(this);
  void *v2 = &unk_1F10CB180;
  unint64_t v3 = (HgcST2084_EOTF *)HGObject::operator new(0x1A0uLL);
  HgcST2084_EOTF::HgcST2084_EOTF(v3);
}

void sub_1B7710A34(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7710A50(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPQ::EOTF::~EOTF(HGNode *this)
{
  *(void *)this = &unk_1F10CB180;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CB180;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGPQ::EOTF::GetOutput(HGPQ::EOTF *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  (*(void (**)(void, void, float, float, double, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, 6.2774, 0.012683, 0.0, 0.0);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, 0.83594, 18.852, -18.688, *((float *)this + 104));
  return *((void *)this + 51);
}

void HGPQ::InverseEOTF::InverseEOTF(HGNode *this, double a2)
{
  HGNode::HGNode(this);
  void *v2 = &unk_1F10CB3D0;
  uint64_t v3 = (HgcST2084_InverseEOTF *)HGObject::operator new(0x1A0uLL);
  HgcST2084_InverseEOTF::HgcST2084_InverseEOTF(v3);
}

void sub_1B7710D0C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7710D28(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPQ::InverseEOTF::~InverseEOTF(HGNode *this)
{
  *(void *)this = &unk_1F10CB3D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CB3D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGPQ::InverseEOTF::GetOutput(HGPQ::InverseEOTF *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  (*(void (**)(void, void, float, float, double, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, 0.1593, 78.844, 0.0, 0.0);
  (*(void (**)(void, uint64_t, float, float, float, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, 0.83594, *((float *)this + 104), *((float *)this + 105), 0.0);
  return *((void *)this + 51);
}

void HGPQ::OOTF::OOTF(HGNode *this, int a2, double a3, double a4)
{
  HGNode::HGNode(this);
  *uint64_t v5 = &unk_1F10CB620;
  if (a2)
  {
    uint64_t v6 = (HgcBT2100_PQ_OOTF_qtApprox *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_OOTF_qtApprox::HgcBT2100_PQ_OOTF_qtApprox(v6);
  }
  uint64_t v7 = (HgcBT2100_PQ_OOTF *)HGObject::operator new(0x1A0uLL);
  HgcBT2100_PQ_OOTF::HgcBT2100_PQ_OOTF(v7);
}

void sub_1B7711000(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7711020(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPQ::OOTF::~OOTF(HGNode *this)
{
  *(void *)this = &unk_1F10CB620;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CB620;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGPQ::OOTF::GetOutput(HGPQ::OOTF *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  uint64_t v5 = (const void *)*((void *)this + 51);
  if (v5)
  {
    if (v6)
    {
      uint64_t v7 = v6;
      (*(void (**)(void *, void, float, float, float, float))(*(void *)v6 + 96))(v6, 0, *((float *)this + 104), *((float *)this + 105), *((float *)this + 106), 0.018);
      (*(void (**)(void *, uint64_t, float, float, double, double))(*(void *)v7 + 96))(v7, 1, 0.45, 2.4, 0.0, 0.0);
      return *((void *)this + 51);
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  (*(void (**)(void *, void, float, float, float, double))(*(void *)v9 + 96))(v9, 0, 1.0, 1.227, *((float *)this + 107), 0.0);
  return *((void *)this + 51);
}

void HGPQ::InverseOOTF::InverseOOTF(HGNode *this, int a2, double a3, double a4)
{
  HGNode::HGNode(this);
  *uint64_t v5 = &unk_1F10CB870;
  if (a2)
  {
    uint64_t v6 = (HgcBT2100_PQ_OOTF_qtApprox *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_OOTF_qtApprox::HgcBT2100_PQ_OOTF_qtApprox(v6);
  }
  uint64_t v7 = (HgcBT2100_PQ_InverseOOTF *)HGObject::operator new(0x1A0uLL);
  HgcBT2100_PQ_InverseOOTF::HgcBT2100_PQ_InverseOOTF(v7);
}

void sub_1B77113E0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7711400(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPQ::InverseOOTF::~InverseOOTF(HGNode *this)
{
  *(void *)this = &unk_1F10CB870;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CB870;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGPQ::InverseOOTF::GetOutput(HGPQ::InverseOOTF *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  uint64_t v5 = (const void *)*((void *)this + 51);
  if (v5)
  {
    if (v6)
    {
      uint64_t v7 = v6;
      (*(void (**)(void *, void, float, float, float, float))(*(void *)v6 + 96))(v6, 0, *((float *)this + 104), 0.090082, *((float *)this + 105), *((float *)this + 106));
      (*(void (**)(void *, uint64_t, float, float, double, double))(*(void *)v7 + 96))(v7, 1, 0.41667, 2.2222, 0.0, 0.0);
      return *((void *)this + 51);
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  (*(void (**)(void *, void, float, float, float, double))(*(void *)v9 + 96))(v9, 0, *((float *)this + 107), 0.815, 1.0, 0.0);
  return *((void *)this + 51);
}

HGNode *HGPQ::OETF::OETF(HGNode *this, int a2, double a3)
{
  HGNode::HGNode(this);
  void *v6 = &unk_1F10CBAC0;
  *((float32x2_t *)this + 52) = vcvt_f32_f64(vmulq_n_f64((float64x2_t)xmmword_1B7EC0EB0, pow(a3 / 10000.0, 0.159301758)));
  if (!a2)
  {
    uint64_t v8 = (HgcBT2100_PQ_OETF *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_OETF::HgcBT2100_PQ_OETF(v8);
  }
  uint64_t v7 = (HgcBT2100_PQ_OETF_qtApprox *)HGObject::operator new(0x1A0uLL);
  HgcBT2100_PQ_OETF_qtApprox::HgcBT2100_PQ_OETF_qtApprox(v7);
  *((void *)this + 51) = v7;
  return this;
}

void sub_1B77117A8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B77117C8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPQ::OETF::~OETF(HGNode *this)
{
  *(void *)this = &unk_1F10CBAC0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CBAC0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGPQ::OETF::GetOutput(HGPQ::OETF *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  uint64_t v5 = (const void *)*((void *)this + 51);
  if (v5)
  {
    if (v6)
    {
      uint64_t v7 = v6;
      (*(void (**)(void *, void, float, float, float, float))(*(void *)v6 + 96))(v6, 0, 1.099, -0.099, 4.5, 0.018);
      (*(void (**)(void *, uint64_t, float, float, float, double))(*(void *)v7 + 96))(v7, 1, 0.45, 0.38232, 78.844, 0.0);
      (*(void (**)(void *, uint64_t, float, float, float, double))(*(void *)v7 + 96))(v7, 2, 0.83594, *((float *)this + 104), *((float *)this + 105), 0.0);
      return *((void *)this + 51);
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  (*(void (**)(void *, void, float, float, double, double))(*(void *)v9 + 96))(v9, 0, 0.19546, 78.844, 0.0, 0.0);
  (*(void (**)(void *, uint64_t, float, float, float, double))(*(void *)v9 + 96))(v9, 1, 0.83594, *((float *)this + 104), *((float *)this + 105), 0.0);
  return *((void *)this + 51);
}

HGNode *HGPQ::InverseOETF::InverseOETF(HGNode *this, int a2, double a3)
{
  HGNode::HGNode(this);
  void *v6 = &unk_1F10CBD10;
  if (a2)
  {
    uint64_t v7 = (HgcBT2100_PQ_InverseOETF_qtApprox *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_InverseOETF_qtApprox::HgcBT2100_PQ_InverseOETF_qtApprox(v7);
  }
  else
  {
    uint64_t v7 = (HgcBT2100_PQ_InverseOETF_qtApprox *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_InverseOETF::HgcBT2100_PQ_InverseOETF(v7);
  }
  *((void *)this + 51) = v7;
  long double v8 = 10000.0 / a3;
  long double v9 = pow(v8, 0.416666667);
  *((float32x2_t *)this + 52) = vcvt_f32_f64(vdivq_f64((float64x2_t)vdupq_lane_s64(*(uint64_t *)&v9, 0), (float64x2_t)xmmword_1B7EC0ED0));
  *(float *)&long double v9 = 0.081 / v9;
  *((_DWORD *)this + 106) = LODWORD(v9);
  float v10 = pow(v8, 0.815);
  *((float *)this + 107) = v10;
  return this;
}

void sub_1B7711C48(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7711C68(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPQ::InverseOETF::~InverseOETF(HGNode *this)
{
  *(void *)this = &unk_1F10CBD10;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CBD10;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGPQ::InverseOETF::GetOutput(HGPQ::InverseOETF *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  uint64_t v5 = (const void *)*((void *)this + 51);
  if (v5)
  {
    if (v6)
    {
      uint64_t v7 = v6;
      (*(void (**)(void *, void, float, float, float, double))(*(void *)v6 + 96))(v6, 0, 0.83594, 18.852, -18.688, 0.0);
      (*(void (**)(void *, uint64_t, float, float, float, double))(*(void *)v7 + 96))(v7, 1, 2.6156, 0.012683, 2.2222, 0.0);
      (*(void (**)(void *, uint64_t, float, float, float, float))(*(void *)v7 + 96))(v7, 2, *((float *)this + 104), 0.090082, *((float *)this + 105), *((float *)this + 106));
      return *((void *)this + 51);
    }
  }
  else
  {
    long double v9 = 0;
  }
  (*(void (**)(void *, void, float, float, float, double))(*(void *)v9 + 96))(v9, 0, 0.83594, 18.852, -18.688, 0.0);
  (*(void (**)(void *, uint64_t, float, float, float, double))(*(void *)v9 + 96))(v9, 1, 5.1161, 0.012683, *((float *)this + 107), 0.0);
  return *((void *)this + 51);
}

void HGHLG::OETF::OETF(HGNode *this)
{
  HGNode::HGNode(this);
  void *v1 = &unk_1F10CBF60;
  uint64_t v2 = (HgcBT2100_HLG_OETF *)HGObject::operator new(0x1A0uLL);
  HgcBT2100_HLG_OETF::HgcBT2100_HLG_OETF(v2);
}

void sub_1B7712180(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B771219C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGHLG::OETF::~OETF(HGNode *this)
{
  *(void *)this = &unk_1F10CBF60;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CBF60;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGHLG::OETF::GetOutput(HGHLG::OETF *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  (*(void (**)(void, void, float, double, double, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, 1.0, 0.0, 0.0, 0.0);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, *((float *)this + 104), *((float *)this + 105), 0.28467, *((float *)this + 106));
  return *((void *)this + 51);
}

void HGHLG::InverseOETF::InverseOETF(HGNode *this)
{
  HGNode::HGNode(this);
  void *v1 = &unk_1F10CC1B0;
  uint64_t v2 = (HgcBT2100_HLG_InverseOETF *)HGObject::operator new(0x1A0uLL);
  HgcBT2100_HLG_InverseOETF::HgcBT2100_HLG_InverseOETF(v2);
}

void sub_1B77124DC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B77124F8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGHLG::InverseOETF::~InverseOETF(HGNode *this)
{
  *(void *)this = &unk_1F10CC1B0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CC1B0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGHLG::InverseOETF::GetOutput(HGHLG::InverseOETF *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  (*(void (**)(void, void, float, float, double, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, 0.5, 4.0, 0.0, 0.0);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, *((float *)this + 104), *((float *)this + 105), 1.0, 0.28467);
  return *((void *)this + 51);
}

float HGHLG::OOTF::setPeakDisplayLuminance(HGHLG::OOTF *this, double a2)
{
  double v4 = a2 / 1000.0;
  if (a2 < 400.0 || a2 > 2000.0)
  {
    long double v6 = log2(v4);
    long double v5 = pow(1.111, v6) * 1.2;
  }
  else
  {
    long double v5 = log10(v4) * 0.42 + 1.2;
  }
  float v7 = v5 + -1.0;
  *((float *)this + 108) = v7;
  float result = pow(0.0833333333, v5) * a2 / *((double *)this + 53);
  *((float *)this + 109) = result;
  return result;
}

void HGHLG::OOTF::OOTF(HGNode *a1)
{
  HGNode::HGNode(a1);
  void *v1 = &unk_1F10CC400;
  uint64_t v2 = (HgcBT2100_HLG_OOTF_InverseOOTF *)HGObject::operator new(0x1A0uLL);
  HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(v2);
}

void sub_1B771287C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7712898(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGHLG::OOTF::~OOTF(HGNode *this)
{
  *(void *)this = &unk_1F10CC400;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CC400;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGHLG::OOTF::GetOutput(HGHLG::OOTF *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  (*(void (**)(void, void, float, float, float, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, **((float **)this + 52), *(float *)(*((void *)this + 52) + 4), *(float *)(*((void *)this + 52) + 8), 0.0);
  (*(void (**)(void, uint64_t, float, float, double, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, *((float *)this + 108), *((float *)this + 109), 0.0, 0.0);
  return *((void *)this + 51);
}

float HGHLG::InverseOOTF::setPeakDisplayLuminance(HGHLG::InverseOOTF *this, double a2)
{
  double v4 = a2 / 1000.0;
  if (a2 < 400.0 || a2 > 2000.0)
  {
    long double v6 = log2(v4);
    double v5 = pow(1.111, v6) * 1.2;
  }
  else
  {
    double v5 = log10(v4) * 0.42 + 1.2;
  }
  long double v7 = 1.0 / v5;
  float v8 = 1.0 / v5 + -1.0;
  *((float *)this + 108) = v8;
  float result = pow(*((double *)this + 53) / a2, v7) * 12.0;
  *((float *)this + 109) = result;
  return result;
}

void HGHLG::InverseOOTF::InverseOOTF(HGNode *a1)
{
  HGNode::HGNode(a1);
  void *v1 = &unk_1F10CC650;
  uint64_t v2 = (HgcBT2100_HLG_OOTF_InverseOOTF *)HGObject::operator new(0x1A0uLL);
  HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(v2);
}

void sub_1B7712C24(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7712C40(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGHLG::InverseOOTF::~InverseOOTF(HGNode *this)
{
  *(void *)this = &unk_1F10CC650;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CC650;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGHLG::InverseOOTF::GetOutput(HGHLG::InverseOOTF *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  (*(void (**)(void, void, float, float, float, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, **((float **)this + 52), *(float *)(*((void *)this + 52) + 4), *(float *)(*((void *)this + 52) + 8), 0.0);
  (*(void (**)(void, uint64_t, float, float, double, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, *((float *)this + 108), *((float *)this + 109), 0.0, 0.0);
  return *((void *)this + 51);
}

uint64_t HGHLG::HLGToSDR::HLGToSDR(uint64_t a1, int a2)
{
  HGNode::HGNode((HGNode *)a1);
  *(void *)uint64_t v4 = &unk_1F10CC8A0;
  *(void *)(v4 + 408) = 0;
  *(_WORD *)(v4 + 416) = 0;
  *(_DWORD *)(v4 + 420) = a2;
  *(_DWORD *)(a1 + 424) = TXParagraphStyleFolder_Factory::version((TXParagraphStyleFolder_Factory *)v4);
  return a1;
}

void sub_1B7712E90(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGHLG::HLGToSDR::~HLGToSDR(HGNode *this)
{
  *(void *)this = &unk_1F10CC8A0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CC8A0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGHLG::HLGToSDR::SetOutputIsRec709Gamma(uint64_t this, char a2)
{
  *(unsigned char *)(this + 416) = a2;
  return this;
}

uint64_t HGHLG::HLGToSDR::SetToneQualityMode(uint64_t result, int a2)
{
  *(_DWORD *)(result + 424) = a2;
  return result;
}

uint64_t HGHLG::HLGToSDR::SetMinimumInputValueZero(uint64_t this, char a2)
{
  *(unsigned char *)(this + 417) = a2;
  return this;
}

uint64_t HGHLG::HLGToSDR::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGRenderer::GetInput(a2, this, 0);
  unsigned int v3 = *((_DWORD *)this + 105);
  if (v3 < 2)
  {
    uint64_t v4 = (HGNode *)HGObject::operator new(0x1C0uLL);
    HGNode::HGNode(v4);
    *(void *)uint64_t v4 = &unk_1F10CC400;
    double v5 = (HgcBT2100_HLG_OOTF_InverseOOTF *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(v5);
  }
  if (v3 == 2)
  {
    long double v6 = (HGNode *)HGObject::operator new(0x1C0uLL);
    HGNode::HGNode(v6);
    *(void *)long double v6 = &unk_1F10CC400;
    long double v7 = (HgcBT2100_HLG_OOTF_InverseOOTF *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(v7);
  }
  return *((void *)this + 51);
}

void sub_1B77136E0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGHLG::SDRToHLG::SDRToHLG(uint64_t a1, int a2, int a3)
{
  HGNode::HGNode((HGNode *)a1);
  *(void *)uint64_t v6 = &unk_1F10CCAF0;
  *(void *)(v6 + 408) = 0;
  *(_DWORD *)(v6 + 416) = a2;
  *(_DWORD *)(v6 + 420) = a3;
  *(_DWORD *)(a1 + 424) = TXParagraphStyleFolder_Factory::version((TXParagraphStyleFolder_Factory *)v6);
  return a1;
}

void sub_1B7713A3C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGHLG::SDRToHLG::~SDRToHLG(HGNode *this)
{
  *(void *)this = &unk_1F10CCAF0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CCAF0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGHLG::SDRToHLG::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, 0);
  int v4 = *((_DWORD *)this + 105);
  if (v4 == 2)
  {
    uint64_t v17 = (HGColorConform *)HGObject::operator new(0x320uLL);
    HGColorConform::HGColorConform(v17);
    (*(void (**)(HGColorConform *, void, HGNode *))(*(void *)v17 + 120))(v17, 0, Input);
    HGColorConform::SetToneQualityMode((HGNode *)v17, *((unsigned int *)this + 106), v18);
    HGColorConform::SetAntiSymmetricToneCurves((HGNode *)v17, 1, v19);
    int v20 = *((_DWORD *)this + 104);
    if (v20 == 1) {
      int v21 = 5;
    }
    else {
      int v21 = 3;
    }
    if (v20) {
      int v22 = v21;
    }
    else {
      int v22 = 0;
    }
    HGColorConform::SetConversion((uint64_t)v17, v22, 13, 0, 3, 8, 0);
    HGColorConform::SetToneQualityMode((HGNode *)v17, 2, v23);
    HGColorConform::SetPremultiplyState((HGNode *)v17, 0, 0);
    unint64_t v24 = (HGNode *)HGObject::operator new(0x1C0uLL);
    HGNode::HGNode(v24);
    *(void *)unint64_t v24 = &unk_1F10CC650;
    uint64_t v25 = (HgcBT2100_HLG_OOTF_InverseOOTF *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(v25);
  }
  if (v4 == 1)
  {
    long double v9 = (HGColorConform *)HGObject::operator new(0x320uLL);
    HGColorConform::HGColorConform(v9);
    (*(void (**)(HGColorConform *, void, HGNode *))(*(void *)v9 + 120))(v9, 0, Input);
    HGColorConform::SetToneQualityMode((HGNode *)v9, *((unsigned int *)this + 106), v10);
    int v11 = *((_DWORD *)this + 104);
    if (v11 == 1) {
      int v12 = 5;
    }
    else {
      int v12 = 3;
    }
    if (v11) {
      int v13 = v12;
    }
    else {
      int v13 = 0;
    }
    HGColorConform::SetConversion((uint64_t)v9, v13, 1, 0, 3, 1, 3);
    HGColorConform::SetPremultiplyState((HGNode *)v9, 0, 0);
    uint64_t v14 = (HgcBT2446_Method_A_ITMO *)HGObject::operator new(0x1A0uLL);
    HgcBT2446_Method_A_ITMO::HgcBT2446_Method_A_ITMO(v14);
    (*(void (**)(HgcBT2446_Method_A_ITMO *, void, HGColorConform *))(*(void *)v14 + 120))(v14, 0, v9);
    uint64_t v15 = (HGNode *)HGObject::operator new(0x1C0uLL);
    HGNode::HGNode(v15);
    *(void *)uint64_t v15 = &unk_1F10CC650;
    uint64_t v16 = (HgcBT2100_HLG_OOTF_InverseOOTF *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(v16);
  }
  if (v4) {
    return *((void *)this + 51);
  }
  double v5 = (HGGamma *)HGObject::operator new(0x1B0uLL);
  HGGamma::HGGamma(v5);
  (*(void (**)(HGGamma *, void, HGNode *))(*(void *)v5 + 120))(v5, 0, Input);
  (*(void (**)(HGGamma *, void, float, float, float, float))(*(void *)v5 + 96))(v5, 0, 2.0, 2.0, 2.0, 1.0);
  HGGamma::SetPremultiplyState((uint64_t)v5, 0);
  (*(void (**)(HGGamma *))(*(void *)v5 + 16))(v5);
  int v6 = *((_DWORD *)this + 104);
  if (v6 == 1)
  {
    uint64_t v27 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
    HGColorGamma::HGColorGamma(v27);
    (*(void (**)(HGColorGamma *, void, HGGamma *))(*(void *)v27 + 120))(v27, 0, v5);
    HGColorGamma::SetToneQualityMode((uint64_t)v27, *((unsigned int *)this + 106), v28);
    HGColorGamma::SetConversion((uint64_t)v27, 5, (char *)8, 0, 3u, 8, 0);
    HGColorGamma::SetPremultiplyState(v27, 0, 0);
    long double v7 = v5;
    if (v5 != v27)
    {
      (*(void (**)(HGGamma *))(*(void *)v5 + 24))(v5);
      long double v7 = v27;
      (*(void (**)(HGColorGamma *))(*(void *)v27 + 16))(v27);
    }
    (*(void (**)(HGColorGamma *))(*(void *)v27 + 24))(v27);
  }
  else
  {
    long double v7 = v5;
    if (!v6)
    {
      float v8 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
      HGColorMatrix::HGColorMatrix(v8);
    }
  }
  uint64_t v29 = (HgcBT2390_Gain_Sat_ToneAdj *)HGObject::operator new(0x1A0uLL);
  HgcBT2390_Gain_Sat_ToneAdj::HgcBT2390_Gain_Sat_ToneAdj(v29);
  (*(void (**)(HgcBT2390_Gain_Sat_ToneAdj *, void, HGGamma *))(*(void *)v29 + 120))(v29, 0, v7);
  (*(void (**)(HgcBT2390_Gain_Sat_ToneAdj *))(*(void *)v29 + 16))(v29);
  *((void *)this + 51) = v29;
  (*(void (**)(HGGamma *))(*(void *)v7 + 24))(v7);
  (*(void (**)(HGGamma *))(*(void *)v5 + 24))(v5);
  uint64_t v30 = *((void *)this + 51);
  (*(void (**)(HgcBT2390_Gain_Sat_ToneAdj *))(*(void *)v29 + 24))(v29);
  return v30;
}

void sub_1B7714388(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void HGACEScct::Encode::Encode(HGNode *this)
{
  HGNode::HGNode(this);
  void *v1 = &unk_1F10CCD40;
  uint64_t v2 = (HgcLogVideo_encode *)HGObject::operator new(0x1A0uLL);
  HgcLogVideo_encode::HgcLogVideo_encode(v2);
}

void sub_1B7714850(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B771486C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGACEScct::Encode::~Encode(HGNode *this)
{
  *(void *)this = &unk_1F10CCD40;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CCD40;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGACEScct::Encode::GetOutput(HGACEScct::Encode *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  (*(void (**)(void, void, float, double, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, 1.0, 0.0, 0.057078, *((float *)this + 105));
  (*(void (**)(void, uint64_t, float, float, float, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, *((float *)this + 106), *((float *)this + 104), 0.0086806, 0.0);
  return *((void *)this + 51);
}

void HGACEScct::Decode::Decode(HGNode *this)
{
  HGNode::HGNode(this);
  void *v1 = &unk_1F10CCF90;
  uint64_t v2 = (HgcLogVideo_decode *)HGObject::operator new(0x1A0uLL);
  HgcLogVideo_decode::HgcLogVideo_decode(v2);
}

void sub_1B7714C68(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7714C84(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGACEScct::Decode::~Decode(HGNode *this)
{
  *(void *)this = &unk_1F10CCF90;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CCF90;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGACEScct::Decode::GetOutput(HGACEScct::Decode *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  (*(void (**)(void, void, float, double, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, 1.0, 0.0, 17.52, *((float *)this + 104));
  (*(void (**)(void, uint64_t, float, float, float, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, *((float *)this + 105), *((float *)this + 106), 0.15525, 0.0);
  return *((void *)this + 51);
}

void HGCanonLog2CinemaGamut::Encode::Encode(HGNode *a1)
{
  HGNode::HGNode(a1);
  void *v1 = &unk_1F10CD1E0;
  uint64_t v2 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
  HGColorMatrix::HGColorMatrix(v2);
}

void sub_1B7714F20(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7714F40(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGCanonLog2CinemaGamut::Encode::~Encode(HGNode *this)
{
  *(void *)this = &unk_1F10CD1E0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10CD1E0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

uint64_t HGCanonLog2CinemaGamut::Encode::GetOutput(HGCanonLog2CinemaGamut::Encode *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  HGColorMatrix::LoadMatrix(*((_OWORD **)this + 51), *((_OWORD **)this + 53), 1);
  if (*((_DWORD *)this + 108)) {
    float v5 = 0.072657;
  }
  else {
    float v5 = 0.084849;
  }
  if (*((_DWORD *)this + 108)) {
    float v6 = 0.092864;
  }
  else {
    float v6 = 0.035388;
  }
  (*(void (**)(void, void, void))(**((void **)this + 52) + 120))(*((void *)this + 52), 0, *((void *)this + 51));
  (*(void (**)(void, void, float, float, float, double))(**((void **)this + 52) + 96))(*((void *)this + 52), 0, v5, v6, 87.099, 0.0);
  return *((void *)this + 52);
}

void HGDJIDLog::Encode::Encode(HGNode *a1)
{
  HGNode::HGNode(a1);
  void *v1 = &unk_1F10CD430;
  uint64_t v2 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
  HGColorMatrix::HGColorMatrix(v2);
}

void sub_1B7715268(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7715288(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGDJIDLog::Encode::~Encode(HGNode *this)
{
  *(void *)this = &unk_1F10CD430;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10CD430;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

uint64_t HGDJIDLog::Encode::GetOutput(HGDJIDLog::Encode *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  HGColorMatrix::LoadMatrix(*((_OWORD **)this + 51), *((_OWORD **)this + 53), 1);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0BD8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0BD8))
  {
    dword_1EB9A0AF0 = 1033780275;
    __cxa_guard_release(&qword_1EB9A0BD8);
  }
  (*(void (**)(void, void, void))(**((void **)this + 52) + 120))(*((void *)this + 52), 0, *((void *)this + 51));
  (*(void (**)(void, void, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 0, 0.89028, 0.0108, *(float *)&dword_1EB9A0AF0, 0.58455);
  (*(void (**)(void, uint64_t, float, float, float, double))(**((void **)this + 52) + 96))(*((void *)this + 52), 1, 5.4225, 0.0929, 0.0086667, 0.0);
  return *((void *)this + 52);
}

void HGFujifilmFLog2::Encode::~Encode(HGNode *this)
{
  *(void *)this = &unk_1F10CD680;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10CD680;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

uint64_t HGFujifilmFLog2::Encode::GetOutput(HGFujifilmFLog2::Encode *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  if (v3)
  {
    (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
    HGColorMatrix::LoadMatrix(*((_OWORD **)this + 51), *((_OWORD **)this + 53), 1);
    Input = (HGNode *)*((void *)this + 51);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0BE0, memory_order_acquire) & 1) == 0)
  {
    float v6 = Input;
    int v7 = __cxa_guard_acquire(&qword_1EB9A0BE0);
    Input = v6;
    if (v7)
    {
      dword_1EB9A0AF4 = 1033320402;
      __cxa_guard_release(&qword_1EB9A0BE0);
      Input = v6;
    }
  }
  (*(void (**)(void, void, HGNode *))(**((void **)this + 52) + 120))(*((void *)this + 52), 0, Input);
  (*(void (**)(void, void, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 0, 5.0, 0.064829, *(float *)&dword_1EB9A0AF4, 0.38432);
  (*(void (**)(void, uint64_t, float, float, float, double))(**((void **)this + 52) + 96))(*((void *)this + 52), 1, 7.9195, 0.092864, 0.00098778, 0.0);
  return *((void *)this + 52);
}

void HGNikonNLog::Encode::Encode(HGNode *a1)
{
  HGNode::HGNode(a1);
  void *v1 = &unk_1F10CD8D0;
  v1[51] = 0;
  uint64_t v2 = (HgcNikonLog_encode *)HGObject::operator new(0x1A0uLL);
  HgcNikonLog_encode::HgcNikonLog_encode(v2);
}

void sub_1B7715994(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B77159B4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGNikonNLog::Encode::~Encode(HGNode *this)
{
  *(void *)this = &unk_1F10CD8D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10CD8D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

uint64_t HGNikonNLog::Encode::GetOutput(HGNikonNLog::Encode *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  if (v3)
  {
    (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
    HGColorMatrix::LoadMatrix(*((_OWORD **)this + 51), *((_OWORD **)this + 53), 1);
    Input = (HGNode *)*((void *)this + 51);
  }
  (*(void (**)(void, void, HGNode *))(**((void **)this + 52) + 120))(*((void *)this + 52), 0, Input);
  (*(void (**)(void, void, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 0, 0.23086, 0.0019239, 0.33333, 0.36444);
  (*(void (**)(void, uint64_t, float, float, double, double))(**((void **)this + 52) + 96))(*((void *)this + 52), 1, *((float *)this + 108), *((float *)this + 109), 0.0, 0.0);
  return *((void *)this + 52);
}

void HGPanasonicVLog::Encode::Encode(HGNode *a1)
{
  HGNode::HGNode(a1);
  void *v1 = &unk_1F10CDB20;
  uint64_t v2 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
  HGColorMatrix::HGColorMatrix(v2);
}

void sub_1B7715CF0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7715D10(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPanasonicVLog::Encode::~Encode(HGNode *this)
{
  *(void *)this = &unk_1F10CDB20;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10CDB20;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

uint64_t HGPanasonicVLog::Encode::GetOutput(HGPanasonicVLog::Encode *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  HGColorMatrix::LoadMatrix(*((_OWORD **)this + 51), *((_OWORD **)this + 53), 1);
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_1EB9A0BF8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(qword_1EB9A0BF8))
  {
    dword_1EB9A0B00 = 1033168202;
    __cxa_guard_release(qword_1EB9A0BF8);
  }
  (*(void (**)(void, void, void))(**((void **)this + 52) + 120))(*((void *)this + 52), 0, *((void *)this + 51));
  (*(void (**)(void, void, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 0, 0.9, 0.00873, *(float *)&dword_1EB9A0B00, 0.59821);
  (*(void (**)(void, uint64_t, float, float, float, double))(**((void **)this + 52) + 96))(*((void *)this + 52), 1, 5.04, 0.125, 0.011111, 0.0);
  return *((void *)this + 52);
}

void HGSonySLog3::Encode::Encode(HGNode *a1)
{
  HGNode::HGNode(a1);
  void *v1 = &unk_1F10CDD70;
  uint64_t v2 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
  HGColorMatrix::HGColorMatrix(v2);
}

void sub_1B77160EC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B771610C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGSonySLog3::Encode::~Encode(HGNode *this)
{
  *(void *)this = &unk_1F10CDD70;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10CDD70;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

uint64_t HGSonySLog3::Encode::GetOutput(HGSonySLog3::Encode *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  HGColorMatrix::LoadMatrix(*((_OWORD **)this + 51), *((_OWORD **)this + 53), 1);
  (*(void (**)(void, void, void))(**((void **)this + 52) + 120))(*((void *)this + 52), 0, *((void *)this + 51));
  (*(void (**)(void, void, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 0, *((float *)this + 108), *((float *)this + 109), *((float *)this + 110), *((float *)this + 111));
  (*(void (**)(void, uint64_t, float, float, float, double))(**((void **)this + 52) + 96))(*((void *)this + 52), 1, *((float *)this + 112), *((float *)this + 113), 0.0125, 0.0);
  return *((void *)this + 52);
}

void HGSony709_800_MLUT::HGSony709_800_MLUT(HGSony709_800_MLUT *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10CDFC0;
  uint64_t v2 = (HgcSony709_800_MLUT *)HGObject::operator new(0x1A0uLL);
  HgcSony709_800_MLUT::HgcSony709_800_MLUT(v2);
}

void sub_1B7716400(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B771641C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGSony709_800_MLUT::~HGSony709_800_MLUT(HGNode *this)
{
  *(void *)this = &unk_1F10CDFC0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CDFC0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGSony709_800_MLUT::GetOutput(HGSony709_800_MLUT *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  (*(void (**)(void, void, float, float, float, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, 0.0066667, 0.018, 0.379, 0.0);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, 4.5, 1.099, -0.099, 0.45);
  (*(void (**)(void, uint64_t, float, float, float, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 2, 0.125, 1.09, 28.966, 0.0);
  return *((void *)this + 51);
}

void HGCameraLogEncode::HGCameraLogEncode(HGNode *a1, int a2)
{
  HGNode::HGNode(a1);
  *(void *)uint64_t v3 = &unk_1F10CE210;
  *(void *)(v3 + 408) = 0;
  *(_DWORD *)(v3 + 416) = a2;
}

void HGCameraLogEncode::~HGCameraLogEncode(HGNode *this)
{
  *(void *)this = &unk_1F10CE210;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CE210;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGCameraLogEncode::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, 0);
  *((void *)this + 51) = Input;
  switch(*((_DWORD *)this + 104))
  {
    case 1:
      int v4 = (HGNode *)HGObject::operator new(0x1C0uLL);
      HGCanonLog2CinemaGamut::Encode::Encode(v4);
    case 2:
      float v10 = (HGNode *)HGObject::operator new(0x1C0uLL);
      HGCanonLog2CinemaGamut::Encode::Encode(v10);
    case 3:
      float v5 = (HGNode *)HGObject::operator new(0x1B0uLL);
      HGDJIDLog::Encode::Encode(v5);
    case 4:
      float v6 = (HGNode *)HGObject::operator new(0x1B0uLL);
      HGNode::HGNode(v6);
      *(void *)float v6 = &unk_1F10CD680;
      *((void *)v6 + 51) = 0;
      int v7 = (HgcLogVideo_encode *)HGObject::operator new(0x1A0uLL);
      HgcLogVideo_encode::HgcLogVideo_encode(v7);
    case 5:
      float v8 = (HGNode *)HGObject::operator new(0x1C0uLL);
      HGNikonNLog::Encode::Encode(v8);
    case 6:
      int v11 = (HGNode *)HGObject::operator new(0x1B0uLL);
      HGPanasonicVLog::Encode::Encode(v11);
    case 7:
      int v12 = (HGNode *)HGObject::operator new(0x1D0uLL);
      HGSonySLog3::Encode::Encode(v12);
    case 8:
      int v13 = (HGNode *)HGObject::operator new(0x1D0uLL);
      HGSonySLog3::Encode::Encode(v13);
    case 9:
      uint64_t v14 = (HGNode *)HGObject::operator new(0x1D0uLL);
      HGSonySLog3::Encode::Encode(v14);
    case 0xA:
      long double v9 = (HGNode *)HGObject::operator new(0x1D0uLL);
      HGSonySLog3::Encode::Encode(v9);
    default:
      (*(void (**)(HGNode *))(*(void *)Input + 16))(Input);
      return *((void *)this + 51);
  }
}

void sub_1B7716A10(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7716A24(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7716A38(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7716A4C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7716A60(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7716A74(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7716A88(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7716A9C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  HGObject::operator delete(v4);
  _Unwind_Resume(a1);
}

void sub_1B7716AC4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7716AD8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7716AEC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGComicBilateralFilter::HGComicBilateralFilter(HGComicBilateralFilter *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10CE670;
  *(_OWORD *)(v1 + 408) = xmmword_1B7E75890;
  *(_DWORD *)(v1 + 424) = 1065353216;
  *(_DWORD *)(v1 + 16) |= 0x620u;
}

void HGComicBilateralFilter::~HGComicBilateralFilter(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGComicBilateralFilter::SetParameter(HGComicBilateralFilter *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2 == 2)
  {
    if (*((float *)this + 106) != a3)
    {
      *((float *)this + 106) = a3;
      return 1;
    }
    return 0;
  }
  if (a2 != 1)
  {
    if (a2) {
      return 0xFFFFFFFFLL;
    }
    if (*((float *)this + 102) != a3)
    {
      *((float *)this + 102) = a3;
      float v6 = *((float *)this + 103);
      goto LABEL_13;
    }
    float v6 = *((float *)this + 103);
    if (v6 != a4)
    {
LABEL_13:
      if (v6 != a4)
      {
        *((float *)this + 103) = a4;
        return 1;
      }
      return 1;
    }
    return 0;
  }
  if (*((float *)this + 104) == a3)
  {
    float v8 = *((float *)this + 105);
    if (v8 != a4) {
      goto LABEL_16;
    }
    return 0;
  }
  *((float *)this + 104) = a3;
  float v8 = *((float *)this + 105);
LABEL_16:
  if (v8 == a4) {
    return 1;
  }
  *((float *)this + 105) = a4;
  return 1;
}

uint64_t HGComicBilateralFilter::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicBilateralFilter::GetDOD(HGComicBilateralFilter *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGRect v13 = a4;
  if (a3) {
    return 0;
  }
  if (HGRect::IsInfinite(&v13)) {
    return *(void *)&v13.var0;
  }
  double v6 = *((float *)this + 106);
  HGTransform::HGTransform((HGTransform *)v12);
  HGTransform::Scale((HGTransform *)v12, v6, v6, 1.0);
  int v7 = *(const HGTransform **)&v13.var0;
  uint64_t v8 = *(void *)&v13.var2;
  float v10 = HGTransformUtils::MinW(v9);
  *(void *)&v14.int var0 = v8;
  uint64_t DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v12, v7, v14, 0.5, v10);
  HGTransform::~HGTransform((HGTransform *)v12);
  return DOD;
}

void sub_1B7716D1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7716D30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGComicBilateralFilter::GetROI(HGComicBilateralFilter *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  unint64_t v5 = *(void *)&a4.var0;
  if (a3 == 1)
  {
    HGRect v19 = a4;
    uint64_t v14 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    uint64_t v16 = v15;
    *(void *)&v22.int var0 = v14;
    *(void *)&v22.int var2 = v16;
    HGRect::Grow(&v19, v22);
  }
  else if (a3)
  {
    HGRect v19 = (HGRect)HGRectNull;
  }
  else
  {
    double v7 = 1.0 / *((float *)this + 106);
    HGTransform::HGTransform((HGTransform *)v18);
    HGTransform::Scale((HGTransform *)v18, v7, v7, 1.0);
    *(void *)&v19.int var0 = 0;
    *(void *)&v19.int var2 = 0;
    float v9 = HGTransformUtils::MinW(v8);
    *(void *)&v23.int var0 = v4;
    *(void *)&v19.int var0 = HGTransformUtils::GetROI((HGTransformUtils *)v18, v5, v23, 0.5, v9);
    *(void *)&v19.int var2 = *(void *)&v20.var0;
    LODWORD(v10) = vcvtps_s32_f32(*((float *)this + 102) + *((float *)this + 102));
    *(void *)&v20.int var2 = v10 | (v10 << 32);
    v20.int var0 = -(int)v10;
    v20.int var1 = -(int)v10;
    HGRect::Grow(&v19, v20);
    uint64_t v11 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    uint64_t v13 = v12;
    *(void *)&v21.int var0 = v11;
    *(void *)&v21.int var2 = v13;
    HGRect::Grow(&v19, v21);
    HGTransform::~HGTransform((HGTransform *)v18);
  }
  return *(void *)&v19.var0;
}

void sub_1B7716E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7716E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7716EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGComicBilateralFilter::RenderTile(HGComicBilateralFilter *this, HGTile *a2)
{
  float v4 = *((float *)this + 105);
  if (*((float *)this + 104) == 1.0)
  {
    if (v4 == 1.0) {
      return 0xFFFFFFFFLL;
    }
  }
  else if (v4 != 1.0)
  {
    return 0xFFFFFFFFLL;
  }
  float v6 = *((float *)this + 106);
  uint64_t v7 = HGTile::Renderer(a2);
  int v8 = (*(uint64_t (**)(HGComicBilateralFilter *, uint64_t))(*(void *)this + 312))(this, v7);
  int32x2_t v11 = *(int32x2_t *)a2;
  int v86 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v86 >= 1)
  {
    uint64_t v12 = (*((_DWORD *)a2 + 2) - v11.i32[0]);
    if ((int)v12 >= 1)
    {
      int v13 = v8;
      int v14 = 0;
      *(float32x2_t *)v15.f32 = vadd_f32(vcvt_f32_s32(v11), (float32x2_t)0x3F0000003F000000);
      v15.i64[1] = 0x3F80000000000000;
      float v16 = *((float *)this + 102);
      float v17 = v16 + v16;
      float v18 = 1.0 / (float)(v16 * (float)(v16 + v16));
      float v19 = 1.0 / (float)(*((float *)this + 103) * (float)(*((float *)this + 103) + *((float *)this + 103)));
      uint64_t v20 = *((void *)a2 + 2);
      __asm { FMOV            V0.4S, #1.0 }
      float32x4_t v89 = _Q0;
      float v88 = 1.0 / v6;
      float32x4_t v26 = v15;
      float32x4_t v91 = v15;
      do
      {
        uint64_t v27 = 0;
        float32x4_t v87 = v26;
        float32x4_t v28 = v26;
        do
        {
          uint64_t v30 = *((void *)a2 + 12);
          uint64_t v31 = *((int *)a2 + 26);
          float32x4_t v32 = vsubq_f32(v28, v15);
          float32x4_t v90 = v28;
          if (v13)
          {
            int32x4_t v33 = vaddq_s32(vcvtq_s32_f32(v32), vcltzq_f32(v32));
            float32x2_t v34 = (float32x2_t)vsubq_f32(v32, vcvtq_f32_s32(v33)).u64[0];
            unint64_t v35 = (float32x4_t *)(v30 + 16 * (v33.i32[0] + v33.i32[1] * (int)v31));
            float32x4_t v36 = vaddq_f32(*v35, vmulq_n_f32(vsubq_f32(v35[1], *v35), v34.f32[0]));
            int8x16_t v37 = (int8x16_t)vaddq_f32(v36, vmulq_lane_f32(vsubq_f32(vaddq_f32(v35[v31], vmulq_n_f32(vsubq_f32(v35[(int)v31 + 1], v35[v31]), v34.f32[0])), v36), v34, 1));
          }
          else
          {
            v38.i64[0] = 0x3F0000003F000000;
            v38.i64[1] = 0x3F0000003F000000;
            float32x4_t v39 = vaddq_f32(v32, v38);
            int32x4_t v40 = vcvtq_s32_f32(v39);
            v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
            int8x16_t v37 = *(int8x16_t *)(v30 + 16 * (v39.i32[0] + v39.i32[1] * (int)v31));
          }
          float32x4_t v41 = vmulq_n_f32(v90, v88);
          uint64_t v42 = *((void *)a2 + 10);
          uint64_t v43 = *((int *)a2 + 22);
          float32x4_t v44 = vsubq_f32(v41, v15);
          if (v13)
          {
            int32x4_t v45 = vaddq_s32(vcvtq_s32_f32(v44), vcltzq_f32(v44));
            float32x2_t v46 = (float32x2_t)vsubq_f32(v44, vcvtq_f32_s32(v45)).u64[0];
            long long v47 = (float32x4_t *)(v42 + 16 * (v45.i32[0] + v45.i32[1] * (int)v43));
            float32x4_t v48 = vaddq_f32(*v47, vmulq_n_f32(vsubq_f32(v47[1], *v47), v46.f32[0]));
            float32x4_t v49 = v47[v43];
            float32x4_t v9 = vmulq_n_f32(vsubq_f32(v47[(int)v43 + 1], v49), v46.f32[0]);
            float32x4_t v94 = vaddq_f32(v48, vmulq_lane_f32(vsubq_f32(vaddq_f32(v49, v9), v48), v46, 1));
            float32x4_t v50 = v94;
            float32x4_t v51 = v89;
            if (v17 < 1.0) {
              goto LABEL_10;
            }
          }
          else
          {
            v52.i64[0] = 0x3F0000003F000000;
            v52.i64[1] = 0x3F0000003F000000;
            float32x4_t v53 = vaddq_f32(v44, v52);
            int32x4_t v54 = vcvtq_s32_f32(v53);
            v53.i64[0] = vaddq_s32(v54, vcgtq_f32(vcvtq_f32_s32(v54), v53)).u64[0];
            float32x4_t v94 = *(float32x4_t *)(v42 + 16 * (v53.i32[0] + v53.i32[1] * (int)v43));
            float32x4_t v50 = v94;
            float32x4_t v51 = v89;
            if (v17 < 1.0) {
              goto LABEL_10;
            }
          }
          float32x4_t v55 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.i8, 1);
          v51.i64[0] = 0;
          int8x16_t v56 = v37;
          v56.i32[1] = 0;
          int8x16_t v57 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v51, v55), (int8x16_t)vcgeq_f32(v55, v51))), 0), v56, v37);
          float32x4_t v58 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 2);
          int8x16_t v59 = v57;
          v59.i32[2] = 0;
          float32x4_t v60 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v51, v58), (int8x16_t)vcgeq_f32(v58, v51))), 0), v59, v57);
          v58.i32[0] = *((_DWORD *)this + 104);
          *(float *)v59.i32 = vmuls_lane_f32(v58.f32[0], v60, 2);
          uint64_t v61 = *((unsigned int *)this + 105);
          v9.f32[0] = vmuls_lane_f32(*(float *)&v61, *(float32x2_t *)v60.f32, 1);
          v9.f32[0] = (float)((float)(*(float *)v59.i32 + v9.f32[0]) + (float)(*(float *)v59.i32 + v9.f32[0])) + -1.0;
          *(float *)v59.i32 = vmuls_lane_f32(v58.f32[0], *(float32x2_t *)v60.f32, 1);
          v60.f32[0] = vmuls_lane_f32(*(float *)&v61, v60, 2);
          v9.f32[1] = (float)(*(float *)&v61 - v58.f32[0])
                    * (float)((float)((float)(*(float *)v59.i32 + v60.f32[0]) + (float)(*(float *)v59.i32 + v60.f32[0]))
                            + -1.0);
          float32x4_t v92 = v9;
          float32x4_t v93 = v41;
          uint64_t v62 = (int)v43 + 1;
          LODWORD(v10) = 1.0;
          float32x4_t v51 = v89;
          float32x4_t v50 = v94;
          do
          {
            float32x4_t v76 = (float32x4_t)vmulq_n_f32(v92, *(float *)&v10).u64[0];
            float32x4_t v77 = vsubq_f32(vaddq_f32(v41, (float32x4_t)v76.u64[0]), v15);
            float32x4_t v99 = v51;
            float32x4_t v100 = v50;
            if (v13)
            {
              int32x4_t v78 = vaddq_s32(vcvtq_s32_f32(v77), vcltzq_f32(v77));
              float32x2_t v79 = (float32x2_t)vsubq_f32(v77, vcvtq_f32_s32(v78)).u64[0];
              long long v80 = (float32x4_t *)(v42 + 16 * (v78.i32[0] + v78.i32[1] * (int)v43));
              float32x4_t v81 = vaddq_f32(*v80, vmulq_n_f32(vsubq_f32(v80[1], *v80), v79.f32[0]));
              float32x4_t v102 = vaddq_f32(v81, vmulq_lane_f32(vsubq_f32(vaddq_f32(v80[v43], vmulq_n_f32(vsubq_f32(v80[v62], v80[v43]), v79.f32[0])), v81), v79, 1));
              float32x4_t v82 = vsubq_f32(vsubq_f32(v41, v76), v15);
              int32x4_t v83 = vaddq_s32(vcvtq_s32_f32(v82), vcltzq_f32(v82));
              v82.i64[0] = vsubq_f32(v82, vcvtq_f32_s32(v83)).u64[0];
              uint64_t v84 = (float32x4_t *)(v42 + 16 * (v83.i32[0] + v83.i32[1] * (int)v43));
              float32x4_t v85 = vaddq_f32(*v84, vmulq_n_f32(vsubq_f32(v84[1], *v84), v82.f32[0]));
              float32x4_t v68 = vaddq_f32(v85, vmulq_lane_f32(vsubq_f32(vaddq_f32(v84[v43], vmulq_n_f32(vsubq_f32(v84[v62], v84[v43]), v82.f32[0])), v85), *(float32x2_t *)v82.f32, 1));
            }
            else
            {
              v63.i64[0] = 0x3F0000003F000000;
              v63.i64[1] = 0x3F0000003F000000;
              float32x4_t v64 = vaddq_f32(v77, v63);
              int32x4_t v65 = vcvtq_s32_f32(v64);
              v64.i64[0] = vaddq_s32(v65, vcgtq_f32(vcvtq_f32_s32(v65), v64)).u64[0];
              float32x4_t v102 = *(float32x4_t *)(v42 + 16 * (v64.i32[0] + v64.i32[1] * (int)v43));
              float32x4_t v66 = vaddq_f32(vsubq_f32(vsubq_f32(v41, v76), v15), v63);
              int32x4_t v67 = vcvtq_s32_f32(v66);
              v66.i64[0] = vaddq_s32(v67, vcgtq_f32(vcvtq_f32_s32(v67), v66)).u64[0];
              float32x4_t v68 = *(float32x4_t *)(v42 + 16 * (v66.i32[0] + v66.i32[1] * (int)v43));
            }
            float32x4_t v101 = v68;
            long long v98 = v10;
            float v97 = expf(v18 * (float)-(float)(*(float *)&v10 * *(float *)&v10));
            float32x4_t v69 = vsubq_f32(v102, v94);
            float32x4_t v70 = vsubq_f32(v101, v94);
            int8x16_t v71 = (int8x16_t)vmulq_f32(v69, v69);
            int8x16_t v72 = (int8x16_t)vmulq_f32(v70, v70);
            float v73 = vaddv_f32(vadd_f32(*(float32x2_t *)v72.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v72, v72, 8uLL)));
            *(float *)v74.i32 = expf(-(float)(vaddv_f32(vadd_f32(*(float32x2_t *)v71.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v71, v71, 8uLL)))* v19));
            float v96 = *(float *)v74.i32;
            float32x4_t v95 = (float32x4_t)vdupq_lane_s32(v74, 0);
            *(float *)v75.i32 = expf(-(float)(v73 * v19));
            long long v10 = v98;
            float32x4_t v51 = vaddq_f32(v99, vmulq_n_f32(vaddq_f32(v95, (float32x4_t)vdupq_lane_s32(v75, 0)), v97));
            v9.i64[1] = v101.i64[1];
            float32x4_t v50 = vaddq_f32(v100, vmulq_n_f32(vaddq_f32(vmulq_n_f32(v102, v96), vmulq_n_f32(v101, *(float *)v75.i32)), v97));
            *(float *)&long long v10 = *(float *)&v98 + 1.0;
            float32x4_t v15 = v91;
            float32x4_t v41 = v93;
          }
          while ((float)(*(float *)&v98 + 1.0) <= v17);
LABEL_10:
          float32x4_t v29 = vdivq_f32(v50, v51);
          v29.i32[3] = v94.i32[3];
          *(float32x4_t *)(v20 + 16 * v27) = vmaxnmq_f32(vminnmq_f32(v29, v89), (float32x4_t)0);
          float32x4_t v28 = vaddq_f32(v90, (float32x4_t)xmmword_1B7E736B0);
          ++v27;
        }
        while (v27 != v12);
        float32x4_t v26 = vaddq_f32(v87, (float32x4_t)xmmword_1B7E736C0);
        v20 += 16 * *((int *)a2 + 6);
        ++v14;
      }
      while (v14 != v86);
    }
  }
  return 0;
}

HGComicBilateralFilter *HGComicBilateralFilter::GetOutput(HGComicBilateralFilter *this, HGRenderer *a2, char *a3)
{
  HGNode::SetParameter((HGNode *)this, 0, *((float *)this + 102), *((float *)this + 103), 0.0, 0.0, a3);
  HGNode::SetParameter((HGNode *)this, 1, *((float *)this + 104), *((float *)this + 105), 0.0, 0.0, v4);
  return this;
}

const char *HGComicBilateralFilter::GetProgram(HGComicBilateralFilter *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) > 0x60B0F) {
    return "//Metal1.0     \n"
  }
           "//LEN=00000009bb\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >     hg_Texture0 [[ texture(0) ]],\n"
           "                                  texture2d< half >     hg_Texture1 [[ texture(1) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]],\n"
           "                                  sampler                hg_Sampler1 [[ sampler(1) ]])\n"
           "{\n"
           "    const half sigma {static_cast<half>(hg_Params[0].x)};\n"
           "    const half sigmacolor {static_cast<half>(hg_Params[0].y)};\n"
           "    const half xAxis {static_cast<half>(hg_Params[1].x)};\n"
           "    const half yAxis {static_cast<half>(hg_Params[1].y)};\n"
           "    \n"
           "    const half sigma22 {1.0h / (2.0h * sigma * sigma)};\n"
           "    const half sigmacolor22 {1.0h / (2.0h * sigmacolor * sigmacolor)};\n"
           "    const half sigmax2 {2.0h * sigma};\n"
           "\n"
           "    half2 gradient = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).yz;\n"
           "    gradient = \n"
           "        half2( (gradient.y * xAxis + gradient.x * yAxis) * 2.0h - 1.0h,\n"
           "             ((gradient.x * xAxis + gradient.y * yAxis) * 2.0h - 1.0h) *\n"
           "               (-1.0h * xAxis + 1.0h * yAxis));\n"
           "    \n"
           "    const half alpha = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).a;\n"
           "    const half3 current = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).rgb;\n"
           "    half3 acc = current;\n"
           "    half norm {1.0h};\n"
           "\n"
           "    for (half i {1.0h}; i <= sigmax2; i += 1.0h)\n"
           "    {\n"
           "        const float2 uPos = frag._texCoord0.xy + float2(i * gradient);\n"
           "        const float2 uNeg = frag._texCoord0.xy - float2(i * gradient);\n"
           "        \n"
           "        const half3 right = hg_Texture0.sample(hg_Sampler0, uPos).rgb;\n"
           "        const half3 left = hg_Texture0.sample(hg_Sampler0, uNeg).rgb;\n"
           "\n"
           "        const half coeff = exp(-i * i * sigma22);\n"
           "        const half coeffr = exp(-dot((right - current), (right - current)) * sigmacolor22);\n"
           "        const half coeffl = exp(-dot((left - current), (left - current)) * sigmacolor22);\n"
           "\n"
           "        norm += coeff * (coeffr + coeffl);\n"
           "        acc += coeff * (coeffr * right+coeffl * left);\n"
           "    }\n"
           "    \n"
           "    acc = acc / norm;\n"
           "    \n"
           "    FragmentOut out {float4(float3(acc), alpha)};\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "    \n"
           "    return out;\n"
           " }\n"
           "//MD5=63de27e4:0c23b7b0:cc01e232:e534b9f2\n"
           "//SIG=00000000:00000000:00000000:00000003:0010:0002:0000:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)) {
    return "//GLfs1.0      \n"
  }
           "//LEN=0000000898\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#define precision\n"
           "#define defaultp mediump\n"
           "#endif\n"
           "\n"
           "precision highp float;\n"
           "precision highp int;\n"
           "\n"
           "uniform defaultp sampler2DRect hg_Texture0;\n"
           "uniform defaultp sampler2DRect hg_Texture1;\n"
           "\n"
           ""uniform highp vec4 hg_ProgramLocal0;
           ""uniform highp vec4 hg_ProgramLocal1;
           "\n"
           "void main (void) \n"
           "{\n"
           "    float sigma = hg_ProgramLocal0.x;\n"
           "    float sigmacolor = hg_ProgramLocal0.y;\n"
           "    float xAxis = hg_ProgramLocal1.x;\n"
           "    float yAxis = hg_ProgramLocal1.y;\n"
           "    \n"
           "    float sigma22 = 1.0 / (2.0 * sigma  * sigma);\n"
           "    float sigmacolor22 = 1.0 / (2.0 * sigmacolor * sigmacolor);\n"
           "    float sigmax2 = 2.0 * sigma;\n"
           "    \n"
           "    float alpha = texture2DRect(hg_Texture0, gl_TexCoord[0].xy).a;\n"
           "    vec3 current = texture2DRect(hg_Texture0, gl_TexCoord[0].xy).rgb;\n"
           "    vec3 acc = current;\n"
           "    float norm = 1.0;\n"
           "    \n"
           "    vec2 gradient = texture2DRect(hg_Texture1, gl_TexCoord[1].xy).yz;\n"
           "    gradient = \n"
           "        vec2( (gradient.y * xAxis + gradient.x * yAxis)*2.0 - 1.0,\n"
           "             ((gradient.x * xAxis + gradient.y * yAxis)*2.0 - 1.0) * \n"
           "             (-1.0 * xAxis + 1.0 * yAxis));\n"
           "\n"
           "    for (float unint64_t i = 1.0; i <= sigmax2; i += 1.0) \n"
           "    {\n"
           "        vec2 uPos = gl_TexCoord[0].xy + i * gradient;\n"
           "        vec2 uNeg = gl_TexCoord[0].xy - i * gradient;\n"
           "        \n"
           "        vec3 right = texture2DRect(hg_Texture0, uPos).rgb;\n"
           "        vec3 left = texture2DRect(hg_Texture0, uNeg).rgb;\n"
           "\n"
           "        float coeff = exp( -i * i * sigma22);\n"
           "        float coeffr = exp( -dot((right - current), (right - current)) * sigmacolor22); //(ri-cun).r*(rig-cu)"
           ".r + (ri-cu).g*(ri-cur).g ... = dist*dist\n"
           "        float coeffl = exp( -dot((left - current), (left - current)) * sigmacolor22);\n"
           "\n"
           "        norm += coeff * (coeffr + coeffl);\n"
           "        acc += coeff * (coeffr * right+coeffl * left);\n"
           "    }\n"
           "    \n"
           "    acc = acc / norm;\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    gl_FragColor = clamp(vec4(acc, alpha), 0.0, 1.0);\n"
           " }\n"
           "//MD5=26dc515d:0940174b:2c779b1c:584e541e\n"
           "//SIG=00000000:00000000:00000000:00000000:0020:0002:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  return 0;
}

uint64_t HGComicBilateralFilter::BindTexture(HGComicBilateralFilter *this, HGHandler *a2, uint64_t a3)
{
  if (a3 == 1)
  {
    HGHandler::TexCoord(a2, 1, 0, 0, 0);
  }
  else if (!a3)
  {
    float v5 = 1.0 / *((float *)this + 106);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, v5, v5, 1.0);
  }
  (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(void *)a2 + 48))(a2, 1, 1);
  return 0;
}

void HRasterizerGenerator::HRasterizerGenerator(HRasterizerGenerator *this)
{
}

void sub_1B7717724(_Unwind_Exception *a1)
{
  HgcRasterizerGenerator::~HgcRasterizerGenerator(v1);
  _Unwind_Resume(a1);
}

void HRasterizerGenerator::~HRasterizerGenerator(HRasterizerGenerator *this)
{
  HgcRasterizerGenerator::~HgcRasterizerGenerator(this);

  HGObject::operator delete(v1);
}

const HGMetalDeviceInfo *HGGPUResources::getDeviceResources(HGGPUResources *this, const HGMetalDeviceInfo *a2)
{
  uint64_t v2 = this;
  if (this)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C48, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A0C48))
    {
      operator new();
    }
    uint64_t v3 = (std::mutex *)_MergedGlobals_5;
    std::mutex::lock((std::mutex *)_MergedGlobals_5);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C58, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A0C58))
    {
      operator new();
    }
    float v4 = *(void **)(qword_1EB9A0C50 + 8);
    if (!v4) {
      goto LABEL_15;
    }
    uint64_t v5 = qword_1EB9A0C50 + 8;
    do
    {
      unint64_t v6 = v4[4];
      BOOL v7 = v6 >= (unint64_t)v2;
      if (v6 >= (unint64_t)v2) {
        int v8 = v4;
      }
      else {
        int v8 = v4 + 1;
      }
      if (v7) {
        uint64_t v5 = (uint64_t)v4;
      }
      float v4 = (void *)*v8;
    }
    while (*v8);
    if (v5 == qword_1EB9A0C50 + 8 || *(void *)(v5 + 32) > (unint64_t)v2) {
LABEL_15:
    }
      uint64_t v5 = qword_1EB9A0C50 + 8;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C58, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A0C58))
    {
      operator new();
    }
    if (v5 == qword_1EB9A0C50 + 8)
    {
      float32x4_t v9 = (HGGPUResources *)HGObject::operator new(0xB0uLL);
      HGGPUResources::HGGPUResources(v9, v2);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C58, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A0C58))
    {
      operator new();
    }
    uint64_t v10 = qword_1EB9A0C50;
    uint64_t v12 = (uint64_t **)(qword_1EB9A0C50 + 8);
    int32x2_t v11 = *(uint64_t **)(qword_1EB9A0C50 + 8);
    if (v11)
    {
      while (1)
      {
        while (1)
        {
          int v13 = (uint64_t **)v11;
          unint64_t v14 = v11[4];
          if (v14 <= (unint64_t)v2) {
            break;
          }
          int32x2_t v11 = *v13;
          uint64_t v12 = v13;
          if (!*v13) {
            goto LABEL_27;
          }
        }
        if (v14 >= (unint64_t)v2) {
          break;
        }
        int32x2_t v11 = v13[1];
        if (!v11)
        {
          uint64_t v12 = v13 + 1;
          goto LABEL_27;
        }
      }
      float32x4_t v15 = (uint64_t *)v13;
    }
    else
    {
      int v13 = (uint64_t **)(qword_1EB9A0C50 + 8);
LABEL_27:
      float32x4_t v15 = (uint64_t *)operator new(0x30uLL);
      v15[4] = (uint64_t)v2;
      v15[5] = 0;
      uint64_t *v15 = 0;
      v15[1] = 0;
      v15[2] = (uint64_t)v13;
      *uint64_t v12 = v15;
      uint64_t v16 = **(void **)v10;
      float v17 = v15;
      if (v16)
      {
        *(void *)uint64_t v10 = v16;
        float v17 = *v12;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v10 + 8), v17);
      ++*(void *)(v10 + 16);
    }
    uint64_t v2 = (const HGMetalDeviceInfo *)v15[5];
    std::mutex::unlock(v3);
  }
  return v2;
}

void sub_1B7717B38(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1EB9A0C58);
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B7717B64(_Unwind_Exception *a1)
{
}

void sub_1B7717B7C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B7717B98(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGGPUResources::HGGPUResources(HGGPUResources *this, const HGMetalDeviceInfo *a2)
{
  HGObject::HGObject(this);
  *(void *)uint64_t v3 = &unk_1F10CEB50;
  *(_OWORD *)(v3 + 24) = 0u;
  float v4 = (HGCVPixelBufferPool **)(v3 + 24);
  *(void *)(v3 + 16) = a2;
  *(void *)(v3 + 64) = 850045863;
  *(_OWORD *)(v3 + 40) = 0u;
  *(void *)(v3 + 56) = 0;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_OWORD *)(v3 + 88) = 0u;
  *(_OWORD *)(v3 + 104) = 0u;
  *(_OWORD *)(v3 + 120) = 0u;
  *(_DWORD *)(v3 + 136) = 1065353216;
  *(_OWORD *)(v3 + 144) = 0u;
  *(_OWORD *)(v3 + 160) = 0u;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v11);
  uint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v12, (uint64_t)"(device:0x", 10);
  *(_DWORD *)((char *)v5 + *(void *)(*v5 - 24) + 8) = *(_DWORD *)((unsigned char *)v5 + *(void *)(*v5 - 24) + 8) & 0xFFFFFFB5 | 8;
  unint64_t v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)")", 1);
  BOOL v7 = (HGCVPixelBufferPool *)HGObject::operator new(0x18uLL);
  HGCVPixelBufferPool::HGCVPixelBufferPool(v7);
  *float v4 = v7;
  std::stringbuf::str();
  int v8 = std::string::insert(&v10, 0, "HGCV pool ");
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v13.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  HGCVPixelBufferPool::setLabel((uint64_t)v7, &v13);
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v13.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v10.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((SHIBYTE(v10.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v10.__r_.__value_.__l.__data_);
LABEL_3:
  operator new();
}

void sub_1B77183E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v17 - 240);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&__p);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
  std::mutex::~mutex(v16);
  HGObject::~HGObject(v15);
  _Unwind_Resume(a1);
}

void HGGPUResources::forceResetCVTextureCache(std::mutex *this)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)(*(void *)&this->__m_.__opaque[8] + 16);
  int valuePtr = *(_DWORD *)this[2].__m_.__opaque;
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  float v4 = (void *)*MEMORY[0x1E4F24C78];
  values = v3;
  keys[0] = v4;
  CFDictionaryRef v5 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CVMetalTextureCacheRef cacheOut = 0;
  uint64_t v6 = CVMetalTextureCacheCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, v2, 0, &cacheOut);
  CFRelease(v3);
  CFRelease(v5);
  if (v6) {
    HGLogger::warning((HGLogger *)"could not create CVMetalTextureCache! (%d)\n", v7, v8, v6);
  }
  CVMetalTextureCacheRef v9 = cacheOut;
  std::mutex::lock(this + 1);
  sig = (const void *)this[2].__m_.__sig;
  if (sig) {
    CFRelease(sig);
  }
  this[2].__m_.__sig = (uint64_t)v9;
  std::mutex::unlock(this + 1);
}

void sub_1B7718674(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGGPUResources::~HGGPUResources(std::mutex *this)
{
  this->__m_.__sig = (uint64_t)&unk_1F10CEB50;
  std::mutex::~mutex(this + 1);

  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;
  uint64_t vars8;

  this->__m_.__sig = (uint64_t)&unk_1F10CEB50;
  std::mutex::~mutex(this + 1);
  HGObject::~HGObject((HGObject *)this);

  HGObject::operator delete(v2);
}

uint64_t HGGPUResources::getCVTextureCacheRetainedRef(HGGPUResources *this)
{
  uint64_t v2 = (std::mutex *)((char *)this + 64);
  std::mutex::lock((std::mutex *)this + 1);
  CFRetain(*((CFTypeRef *)this + 16));
  uint64_t v3 = *((void *)this + 16);
  std::mutex::unlock(v2);
  return v3;
}

void sub_1B771877C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGGPUResources::setCVTextureCacheMaximumTextureAge(uint64_t this, float a2)
{
  *(float *)(this + 136) = a2;
  return this;
}

void HGGPUResources::flushFreeObjects(HGGPUResources *this)
{
  uint64_t v2 = (HGMetalBufferPool *)*((void *)this + 4);
  if (v2) {
    HGMetalBufferPool::clear(v2);
  }
  uint64_t v3 = (HGMetalTexturePool *)*((void *)this + 5);
  if (v3) {
    HGMetalTexturePool::clear(v3);
  }
  float v4 = (__CVMetalTextureCache *)*((void *)this + 16);
  if (v4)
  {
    CVMetalTextureCacheFlush(v4, 0);
  }
}

void HGGPUResources::releaseFreeObjects(HGGPUResources *this)
{
  uint64_t v2 = (HGCVPixelBufferPool *)*((void *)this + 3);
  if (v2) {
    HGCVPixelBufferPool::clear(v2);
  }
  uint64_t v3 = (HGMetalBufferPool *)*((void *)this + 4);
  if (v3) {
    HGMetalBufferPool::clear(v3);
  }
  float v4 = (HGMetalTexturePool *)*((void *)this + 5);
  if (v4) {
    HGMetalTexturePool::clear(v4);
  }
  CFDictionaryRef v5 = (HGMetalBufferWrapperInfinipool *)*((void *)this + 6);
  if (v5) {
    HGMetalBufferWrapperInfinipool::clear(v5);
  }
  uint64_t v6 = (HGMetalTextureWrapperInfinipool *)*((void *)this + 7);
  if (v6) {
    HGMetalTextureWrapperInfinipool::clear(v6);
  }
  BOOL v7 = (__CVMetalTextureCache *)*((void *)this + 16);
  if (v7)
  {
    CVMetalTextureCacheFlush(v7, 0);
  }
}

void HGGPUResources::forceResetAllCVTextureCaches(HGGPUResources *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C48, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0C48))
  {
    operator new();
  }
  uint64_t v1 = (std::mutex *)_MergedGlobals_5;
  std::mutex::lock((std::mutex *)_MergedGlobals_5);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C58, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0C58))
  {
    operator new();
  }
  uint64_t v2 = *(void **)qword_1EB9A0C50;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C58, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0C58))
  {
    operator new();
  }
  uint64_t v3 = qword_1EB9A0C50 + 8;
  if (v2 != (void *)(qword_1EB9A0C50 + 8))
  {
    do
    {
      HGGPUResources::forceResetCVTextureCache((std::mutex *)v2[5]);
      float v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          CFDictionaryRef v5 = v4;
          float v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          CFDictionaryRef v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          uint64_t v2 = v5;
        }
        while (!v6);
      }
      uint64_t v2 = v5;
    }
    while (v5 != (void *)v3);
  }

  std::mutex::unlock(v1);
}

void sub_1B7718A44(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1EB9A0C58);
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B7718A68(_Unwind_Exception *a1)
{
}

void sub_1B7718A80(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGGPUResources::setupGroupTotalUsagePolicies(uint64_t a1, uint64_t a2)
{
  float v4 = operator new(0x48uLL);
  v4[1] = 0;
  v4[2] = 0;
  *float v4 = &unk_1F10CECD0;
  uint64_t v5 = *(void *)(a2 + 32);
  v4[3] = &unk_1F10CED20;
  long long v6 = *(_OWORD *)(a2 + 16);
  *((_OWORD *)v4 + 2) = *(_OWORD *)a2;
  *((_OWORD *)v4 + 3) = v6;
  v4[8] = v5;
  float32x4_t v41 = (char *)(v4 + 3);
  uint64_t v42 = (std::__shared_weak_count *)v4;
  BOOL v7 = operator new(0x48uLL);
  v7[1] = 0;
  v7[2] = 0;
  *BOOL v7 = &unk_1F10CECD0;
  uint64_t v8 = *(void *)(a2 + 72);
  v7[3] = &unk_1F10CED20;
  long long v9 = *(_OWORD *)(a2 + 56);
  *((_OWORD *)v7 + 2) = *(_OWORD *)(a2 + 40);
  *((_OWORD *)v7 + 3) = v9;
  v7[8] = v8;
  float32x4_t v39 = v7 + 3;
  int32x4_t v40 = (std::__shared_weak_count *)v7;
  std::string v10 = operator new(0x48uLL);
  v10[1] = 0;
  v10[2] = 0;
  void *v10 = &unk_1F10CECD0;
  uint64_t v11 = *(void *)(a2 + 112);
  v10[3] = &unk_1F10CED20;
  long long v12 = *(_OWORD *)(a2 + 96);
  *((_OWORD *)v10 + 2) = *(_OWORD *)(a2 + 80);
  *((_OWORD *)v10 + 3) = v12;
  v10[8] = v11;
  int8x16_t v37 = v10 + 3;
  float32x4_t v38 = (std::__shared_weak_count *)v10;
  std::string v13 = (char *)operator new(0x58uLL);
  *((void *)v13 + 1) = 0;
  *((void *)v13 + 2) = 0;
  *(void *)std::string v13 = &unk_1F10CED90;
  uint64_t v14 = (uint64_t)(v13 + 24);
  *((void *)v13 + 5) = 0;
  *((void *)v13 + 6) = 0;
  *((void *)v13 + 3) = &unk_1F10CEDE0;
  *((void *)v13 + 4) = v13 + 40;
  *(_OWORD *)(v13 + 56) = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(v13 + 72) = *(_OWORD *)(a2 + 136);
  unint64_t v35 = (uint64_t *)(v13 + 24);
  float32x4_t v36 = (std::__shared_weak_count *)v13;
  LUTEnd = (uint64_t *)PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 24));
  int32x4_t v33 = v4 + 3;
  float32x2_t v34 = (std::__shared_weak_count *)v4;
  atomic_fetch_add_explicit(v4 + 1, 1uLL, memory_order_relaxed);
  HGPool::GroupServicingPolicy::addPool(v14, LUTEnd, &v33);
  uint64_t v16 = v34;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  uint64_t v17 = (uint64_t)v35;
  float v18 = **(uint64_t ***)(a1 + 32);
  int32x4_t v33 = v39;
  float32x2_t v34 = v40;
  if (v40) {
    atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HGPool::GroupServicingPolicy::addPool(v17, v18, &v33);
  float v19 = v34;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  uint64_t v20 = (uint64_t)v35;
  HGRect v21 = **(uint64_t ***)(a1 + 40);
  int32x4_t v33 = v37;
  float32x2_t v34 = v38;
  if (v38) {
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HGPool::GroupServicingPolicy::addPool(v20, v21, &v33);
  HGRect v22 = v34;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = *(void *)(a1 + 24);
  int32x4_t v33 = v35;
  float32x2_t v34 = v36;
  if (v36) {
    atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HGCVPixelBufferPool::setServicingPolicy(v23, (uint64_t *)&v33);
  unint64_t v24 = v34;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  uint64_t v25 = *(std::mutex ***)(a1 + 32);
  int32x4_t v33 = v35;
  float32x2_t v34 = v36;
  if (v36) {
    atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HGMetalBufferPool::setServicingPolicy(v25, (uint64_t *)&v33);
  float32x4_t v26 = v34;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  uint64_t v27 = *(std::mutex ***)(a1 + 40);
  int32x4_t v33 = v35;
  float32x2_t v34 = v36;
  if (v36) {
    atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HGMetalBufferPool::setServicingPolicy(v27, (uint64_t *)&v33);
  float32x4_t v28 = v34;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  float32x4_t v29 = v36;
  if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  uint64_t v30 = v38;
  if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  uint64_t v31 = v40;
  if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  float32x4_t v32 = v42;
  if (v42)
  {
    if (!atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
}

void sub_1B7719028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
}

void sub_1B7719070()
{
}

void sub_1B7719078()
{
}

void sub_1B7719080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1B771909C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<anonymous namespace'::BufferPoolFixedAllocationPolicy<0,1024>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CEBA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<anonymous namespace'::BufferPoolFixedAllocationPolicy<0,1024>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CEBA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<anonymous namespace'::BufferPoolFixedAllocationPolicy<0,1024>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void anonymous namespace'::BufferPoolFixedAllocationPolicy<0,1024>::~BufferPoolFixedAllocationPolicy()
{
}

unint64_t anonymous namespace'::BufferPoolFixedAllocationPolicy<0,1024>::pad(uint64_t a1, void *a2)
{
  return ((*a2 - 1) & 0xFFFFFFFFFFFFFC00) + 1024;
}

void std::__shared_ptr_emplace<anonymous namespace'::TexturePoolFixedAllocationPolicy<16,64>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CEC40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<anonymous namespace'::TexturePoolFixedAllocationPolicy<16,64>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CEC40;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<anonymous namespace'::TexturePoolFixedAllocationPolicy<16,64>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void anonymous namespace'::TexturePoolFixedAllocationPolicy<16,64>::~TexturePoolFixedAllocationPolicy()
{
}

__n128 anonymous namespace'::TexturePoolFixedAllocationPolicy<16,64>::pad@<Q0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)(a1 + 32);
  __n128 result = *(__n128 *)(a1 + 16);
  v4.i64[0] = -1;
  v4.i64[1] = -1;
  int8x16_t v5 = vbslq_s8((int8x16_t)vcgtq_u64(*(uint64x2_t *)a1, (uint64x2_t)vdupq_n_s64(0x10uLL)), (int8x16_t)vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vaddq_s64(*(int64x2_t *)a1, v4), (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFFC0)), vdupq_n_s64(0x40uLL)), *(int8x16_t *)a1);
  *(__n128 *)(a2 + 16) = result;
  *(_OWORD *)(a2 + 32) = v2;
  *(int8x16_t *)a2 = v5;
  return result;
}

void std::__shared_ptr_emplace<HGPool::FixedTotalUsageServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CECD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HGPool::FixedTotalUsageServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CECD0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<HGPool::FixedTotalUsageServicingPolicy>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t HGPool::FixedTotalUsageServicingPolicy::maxObjectAgeNS(HGPool::FixedTotalUsageServicingPolicy *this, const BasePool *a2)
{
  return *((void *)this + 5);
}

void std::__shared_ptr_emplace<HGPool::FixedGroupServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CED90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HGPool::FixedGroupServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10CED90;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<HGPool::FixedGroupServicingPolicy>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void HGPool::FixedGroupServicingPolicy::~FixedGroupServicingPolicy(HGPool::FixedGroupServicingPolicy *this)
{
  *(void *)this = &unk_1F10DE8A8;
  std::__tree<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::__map_value_compare<HGPool::BasePool const*,std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::less<HGPool::BasePool const*>,true>,std::allocator<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>>>::destroy((uint64_t)this + 8, *((void **)this + 2));
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F10DE8A8;
  std::__tree<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::__map_value_compare<HGPool::BasePool const*,std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::less<HGPool::BasePool const*>,true>,std::allocator<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>>>::destroy((uint64_t)this + 8, *((void **)this + 2));

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t HGPool::FixedGroupServicingPolicy::maxTotalGroupBytesUsage(HGPool::FixedGroupServicingPolicy *this, const BasePool *a2)
{
  return *((void *)this + 7);
}

void std::__tree<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::__map_value_compare<HGPool::BasePool const*,std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::less<HGPool::BasePool const*>,true>,std::allocator<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::__map_value_compare<HGPool::BasePool const*,std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::less<HGPool::BasePool const*>,true>,std::allocator<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::__map_value_compare<HGPool::BasePool const*,std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::less<HGPool::BasePool const*>,true>,std::allocator<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>>>::destroy(a1, a2[1]);
    int64x2_t v4 = (std::__shared_weak_count *)a2[6];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
      int8x16_t v5 = a2;
    }
    else
    {
      int8x16_t v5 = a2;
    }
    operator delete(v5);
  }
}

void HGHWBlendFlipped::HGHWBlendFlipped(HGHWBlendFlipped *this)
{
}

void sub_1B7719618(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  int8x16_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 456) = v5;
    operator delete(v5);
  }
  HGLegacyBlend::~HGLegacyBlend((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGHWBlendFlipped::~HGHWBlendFlipped(HGHWBlendFlipped *this)
{
  *(void *)this = &unk_1F10CEE50;
  long long v2 = (HGHWBlendFlipped *)*((void *)this + 64);
  if (v2 != this)
  {
    (*(void (**)(HGHWBlendFlipped *))(*(void *)v2 + 24))(v2);
    *((void *)this + 64) = this;
  }
  HGHWBlendFlipped::DeleteStates((uint64_t)this);
  uint64_t v3 = (void *)*((void *)this + 56);
  if (v3)
  {
    *((void *)this + 57) = v3;
    operator delete(v3);
  }

  HGLegacyBlend::~HGLegacyBlend((HGNode *)this);
}

{
  HGHWBlendFlipped *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10CEE50;
  long long v2 = (HGHWBlendFlipped *)*((void *)this + 64);
  if (v2 != this)
  {
    (*(void (**)(HGHWBlendFlipped *))(*(void *)v2 + 24))(v2);
    *((void *)this + 64) = this;
  }
  HGHWBlendFlipped::DeleteStates((uint64_t)this);
  uint64_t v3 = (void *)*((void *)this + 56);
  if (v3)
  {
    *((void *)this + 57) = v3;
    operator delete(v3);
  }

  HGLegacyBlend::~HGLegacyBlend((HGNode *)this);
}

{
  HGHWBlendFlipped *v2;
  void *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10CEE50;
  long long v2 = (HGHWBlendFlipped *)*((void *)this + 64);
  if (v2 != this)
  {
    (*(void (**)(HGHWBlendFlipped *))(*(void *)v2 + 24))(v2);
    *((void *)this + 64) = this;
  }
  HGHWBlendFlipped::DeleteStates((uint64_t)this);
  uint64_t v3 = (void *)*((void *)this + 56);
  if (v3)
  {
    *((void *)this + 57) = v3;
    operator delete(v3);
  }
  HGLegacyBlend::~HGLegacyBlend((HGNode *)this);

  HGObject::operator delete(v4);
}

const char *HGHWBlendFlipped::label_B(HGHWBlendFlipped *this)
{
  uint64_t v1 = *((unsigned int *)this + 106);
  if (v1 > 0x29) {
    return "(invalid)";
  }
  else {
    return s_label_table[v1];
  }
}

const char *HGHWBlendFlipped::GetBlendModeLabel(HGHWBlendFlipped *this)
{
  if (this > 0x29) {
    return "(invalid)";
  }
  else {
    return s_label_table[this];
  }
}

uint64_t HGHWBlendFlipped::SetParameter(__n128 *this, uint64_t a2, __n128 a3, double a4, float a5, float a6, char *a7)
{
  switch((int)a2)
  {
    case 0:
      unsigned int v7 = vcvtms_s32_f32(a3.n128_f32[0]);
      if (v7 - 9 > 0x20)
      {
        a2 = 0;
        goto LABEL_24;
      }
      if (this[26].n128_u32[2] == v7) {
        goto LABEL_22;
      }
      this[26].n128_u32[2] = v7;
      uint64_t result = 1;
      break;
    case 3:
      unsigned int v9 = vcvtms_u32_f32(a3.n128_f32[0]);
      if (v9 > 2)
      {
        uint64_t result = 0xFFFFFFFFLL;
      }
      else
      {
        this[29].n128_u32[2] = v9;
        uint64_t result = 0;
      }
      break;
    case 4:
      unsigned int v10 = vcvtms_s32_f32(a3.n128_f32[0]);
      unsigned __int32 v11 = v10 != 0;
      if (this[29].n128_u32[3] == v11) {
        goto LABEL_22;
      }
      this[29].n128_u32[3] = v11;
      unsigned __int32 v12 = this[1].n128_u32[0];
      if (v10) {
        unsigned int v13 = v12 | 0x20;
      }
      else {
        unsigned int v13 = v12 & 0xFFFFFFDF;
      }
      this[1].n128_u32[0] = v13;
      uint64_t result = 1;
      break;
    case 6:
      if (this[31].n128_f32[0] == a3.n128_f32[0]
        && this[31].n128_f32[1] == *(float *)&a4
        && this[31].n128_f32[2] == a5
        && this[31].n128_f32[3] == a6)
      {
LABEL_22:
        uint64_t result = 0;
      }
      else
      {
        a3.n128_u32[1] = LODWORD(a4);
        a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
        this[31] = a3;
        uint64_t result = 1;
      }
      break;
    default:
LABEL_24:
      uint64_t result = HGLegacyBlend::SetParameter((HGLegacyBlend *)this, a2, a3.n128_f64[0], a4, a5, a6, a7);
      break;
  }
  return result;
}

uint64_t HGHWBlendFlipped::SetState(HGHWBlendFlipped *this, HGRenderer *a2, int a3)
{
  if (a3 == 1) {
    HGHWBlendFlipped::AllocateStates(this, a2);
  }

  return HGNode::SetState((uint64_t)this, (uint64_t)a2, a3);
}

void HGHWBlendFlipped::Clone(HGHWBlendFlipped *this)
{
  uint64_t v1 = (HGHWBlendFlipped *)HGObject::operator new(0x220uLL);
  HGHWBlendFlipped::HGHWBlendFlipped(v1);
}

void sub_1B7719BDC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGHWBlendFlipped::UpdateHWBlendStatus(HGHWBlendFlipped *this, HGRenderer *a2)
{
  uint64_t result = (*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2);
  if ((result & 1) == 0)
  {
    int v5 = *((_DWORD *)this + 118);
    switch(v5)
    {
      case 2:
        *((unsigned char *)this + 480) = 1;
        break;
      case 1:
        uint64_t result = (uint64_t)HGRenderer::GetInput(a2, (HGNode *)this, *((_DWORD *)this + 108));
        if (result) {
          uint64_t result = HGNode::DoInplaceHardwareBlending((HGNode *)result, a2, (HGNode *)this, *((float *)this + 104));
        }
        *((unsigned char *)this + 480) = result;
        break;
      case 0:
        *((unsigned char *)this + 480) = 0;
        break;
    }
  }
  return result;
}

HGNode *HGHWBlendFlipped::GetOutput(HGHWBlendFlipped *this, HGRenderer *a2)
{
  if (*((int *)this + 106) >= 38) {
    *((_DWORD *)this + 104) = 1065353216;
  }
  (*(void (**)(HGHWBlendFlipped *, HGRenderer *))(*(void *)this + 592))(this, a2);
  int64x2_t v4 = (HGHWBlendFlipped *)*((void *)this + 64);
  if (v4 != this)
  {
    (*(void (**)(HGHWBlendFlipped *))(*(void *)v4 + 24))(v4);
    *((void *)this + 64) = this;
  }
  if ((*(unsigned int (**)(HGRenderer *))(*(void *)a2 + 304))(a2)
    && (*((_DWORD *)this + 119) || *((_DWORD *)this + 106) == 41))
  {
    int v5 = (HGOverwrite *)HGObject::operator new(0x1A0uLL);
    HGOverwrite::HGOverwrite(v5);
    Input = HGRenderer::GetInput(a2, (HGNode *)this, *((_DWORD *)this + 107));
    (*(void (**)(HGOverwrite *, void, HGNode *))(*(void *)v5 + 120))(v5, 0, Input);
    unsigned int v7 = HGRenderer::GetInput(a2, (HGNode *)this, *((_DWORD *)this + 108));
    (*(void (**)(HGOverwrite *, uint64_t, HGNode *))(*(void *)v5 + 120))(v5, 1, v7);
    *((void *)this + 64) = v5;
    return (HGNode *)v5;
  }
  else if (*((unsigned char *)this + 520))
  {
    unsigned int v9 = (HGLightWrapBlend *)HGObject::operator new(0x1D0uLL);
    HGLightWrapBlend::HGLightWrapBlend(v9);
    unsigned int v10 = HGRenderer::GetInput(a2, (HGNode *)this, 0);
    (*(void (**)(HGLightWrapBlend *, void, HGNode *))(*(void *)v9 + 120))(v9, 0, v10);
    unsigned __int32 v11 = HGRenderer::GetInput(a2, (HGNode *)this, 1u);
    (*(void (**)(HGLightWrapBlend *, uint64_t, HGNode *))(*(void *)v9 + 120))(v9, 1, v11);
    (*(void (**)(HGLightWrapBlend *, void, float, double, double, double))(*(void *)v9 + 96))(v9, 0, (float)*((int *)this + 106), 0.0, 0.0, 0.0);
    (*(void (**)(HGLightWrapBlend *, uint64_t, float, double, double, double))(*(void *)v9 + 96))(v9, 1, *((float *)this + 104), 0.0, 0.0, 0.0);
    HGLightWrapBlend::SetLightWrapParams((uint64_t)v9, *((_DWORD *)this + 131), *((float *)this + 132), *((float *)this + 133), *((float *)this + 134), *((float *)this + 135));
    *((void *)this + 64) = v9;
    return (HGNode *)v9;
  }
  else
  {
    if ((*((_DWORD *)this + 106) - 9) <= 0x20)
    {
      if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) == 0
        && (*((_DWORD *)this + 119)
         || (unsigned __int32 v12 = (HGBlendingInfo *)*((unsigned int *)this + 106), v12 == 41)
         || (v12 > 0x29 || *((float *)this + 105) == 1.0 || !s_gamma_support_blend_table[(void)v12])
         && (unsigned int v13 = (void *)HGBlendingInfo::Get(v12), *((unsigned char *)this + 480))
         && (*v13 & 1) != 0)
        || *((int *)this + 106) >= 38)
      {
        (*(void (**)(HGHWBlendFlipped *, uint64_t, uint64_t))(*(void *)this + 136))(this, 0xFFFFFFFFLL, 32);
        (*(void (**)(HGHWBlendFlipped *, void, uint64_t))(*(void *)this + 136))(this, 0, 32);
        (*(void (**)(HGHWBlendFlipped *, uint64_t, uint64_t))(*(void *)this + 136))(this, 1, 32);
      }
    }
    return HGLegacyBlend::GetOutput((HGNode *)this, a2);
  }
}

void sub_1B771A0E4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B771A0F8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGHWBlendFlipped::IsHardwareBlendSupported(HGHWBlendFlipped *this, HGRenderer *a2)
{
  if ((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2)) {
    return 0;
  }
  if (*((_DWORD *)this + 119)) {
    return 1;
  }
  int64x2_t v4 = (HGBlendingInfo *)*((unsigned int *)this + 106);
  if (v4 == 41) {
    return 1;
  }
  if (v4 <= 0x29 && *((float *)this + 105) != 1.0 && s_gamma_support_blend_table[(void)v4] != 0) {
    return 0;
  }
  return (*((unsigned char *)this + 480) != 0) & *(unsigned char *)HGBlendingInfo::Get(v4);
}

uint64_t HGHWBlendFlipped::BindTexture(HGHWBlendFlipped *this, HGHandler *a2, int a3)
{
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  return 0;
}

uint64_t HGHWBlendFlipped::GetGammaBlendMode(HGHWBlendFlipped *this, unsigned int a2, float a3)
{
  if (a2 > 0x29) {
    return 0;
  }
  if (a3 > 1.9756 || a3 < 1.9364) {
    unsigned int v5 = 1;
  }
  else {
    unsigned int v5 = 2;
  }
  if (s_gamma_support_blend_table[a2]) {
    BOOL v6 = a3 == 1.0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    return 0;
  }
  else {
    return v5;
  }
}

uint64_t HGHWBlendFlipped::GetDOD(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  switch(s_dod_policy_table[*((int *)this + 106)])
  {
    case 0:
      if (a3 >= 2) {
        goto LABEL_10;
      }
      goto LABEL_3;
    case 1:
      if (a3 > 1) {
        goto LABEL_10;
      }
      Input = HGRenderer::GetInput(a2, this, 0);
      uint64_t DOD = HGRenderer::GetDOD(a2, Input);
      uint64_t v10 = v9;
      unsigned __int32 v11 = HGRenderer::GetInput(a2, this, 1u);
      uint64_t v12 = HGRenderer::GetDOD(a2, v11);
      uint64_t result = HGRectIntersection(DOD, v10, v12, v13);
      break;
    case 2:
      if (!a3) {
        goto LABEL_3;
      }
      goto LABEL_10;
    case 3:
      if (a3 != 1) {
        goto LABEL_10;
      }
LABEL_3:
      uint64_t result = *(void *)&a4.var0;
      break;
    default:
LABEL_10:
      uint64_t result = 0;
      break;
  }
  return result;
}

HGBitmap *HGHWBlendFlipped::RenderPageDispatcher<(HGGPURenderAPI)0>(uint64_t a1, HGPage *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t, void))(*(void *)a1 + 616))(a1, 0);
  uint64_t v4 = *(void *)a2;
  unsigned int v5 = HGHWBlendFlipped::RenderSingleInput((HGHWBlendFlipped *)a1, a2);
  if (!v5)
  {
    BOOL v6 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
    snprintf(__str, 0x100uLL, "%s::%s( [%d %d %d %d])", v6, "RenderPage", *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v11, "gpu", 1, __str);
    if ((*(_DWORD *)(a1 + 424) - 9) >= 0x21)
    {
      uint64_t v7 = HGLegacyBlend::RenderPage((HGLegacyBlend *)a1, a2);
    }
    else if (((*(uint64_t (**)(uint64_t))(*(void *)v4 + 304))(v4) & 1) == 0 {
           && (*(_DWORD *)(a1 + 476)
    }
            || (uint64_t v8 = (HGBlendingInfo *)*(unsigned int *)(a1 + 424), v8 == 41)
            || (v8 > 0x29 || *(float *)(a1 + 420) == 1.0 || !s_gamma_support_blend_table[(void)v8])
            && (uint64_t v9 = (void *)HGBlendingInfo::Get(v8), *(unsigned char *)(a1 + 480))
            && (*v9 & 1) != 0))
    {
      uint64_t v7 = (uint64_t)HGHWBlendFlipped::RenderPageHWBlending<(HGGPURenderAPI)0>(a1, a2);
    }
    else
    {
      uint64_t v7 = HGNode::RenderPage((HGNode *)a1, (HGRect *)a2);
    }
    unsigned int v5 = (HGBitmap *)v7;
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v11);
  }
  return v5;
}

void sub_1B771A5F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

HGBitmap *HGHWBlendFlipped::RenderPageDispatcher<(HGGPURenderAPI)1>(uint64_t a1, HGPage *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t, void))(*(void *)a1 + 616))(a1, 0);
  uint64_t v4 = *(void *)a2;
  unsigned int v5 = HGHWBlendFlipped::RenderSingleInput((HGHWBlendFlipped *)a1, a2);
  if (!v5)
  {
    BOOL v6 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
    snprintf(__str, 0x100uLL, "%s::%s( [%d %d %d %d])", v6, "RenderPageMetal", *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v11, "gpu", 1, __str);
    if ((*(_DWORD *)(a1 + 424) - 9) >= 0x21)
    {
      uint64_t v7 = (char *)HGLegacyBlend::RenderPageMetal((HGLegacyBlend *)a1, a2);
    }
    else if (((*(uint64_t (**)(uint64_t))(*(void *)v4 + 304))(v4) & 1) == 0 {
           && (*(_DWORD *)(a1 + 476)
    }
            || (uint64_t v8 = (HGBlendingInfo *)*(unsigned int *)(a1 + 424), v8 == 41)
            || (v8 > 0x29 || *(float *)(a1 + 420) == 1.0 || !s_gamma_support_blend_table[(void)v8])
            && (uint64_t v9 = (void *)HGBlendingInfo::Get(v8), *(unsigned char *)(a1 + 480))
            && (*v9 & 1) != 0))
    {
      uint64_t v7 = HGHWBlendFlipped::RenderPageHWBlending<(HGGPURenderAPI)1>(a1, a2);
    }
    else
    {
      uint64_t v7 = (char *)HGNode::RenderPageMetal((HGNode *)a1, a2);
    }
    unsigned int v5 = (HGBitmap *)v7;
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v11);
  }
  return v5;
}

void sub_1B771A808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

HGBitmap *HGHWBlendFlipped::RenderSingleInput(HGHWBlendFlipped *this, HGPage *a2)
{
  uint64_t v4 = *(HGRenderer **)a2;
  Input = HGRenderer::GetInput(*(HGRenderer **)a2, (HGNode *)this, *((_DWORD *)this + 107));
  BOOL v6 = HGRenderer::GetInput(v4, (HGNode *)this, *((_DWORD *)this + 108));
  *(void *)&v16.int var0 = (*(uint64_t (**)(HGHWBlendFlipped *, HGRenderer *, void, void, void))(*(void *)this + 400))(this, v4, *((unsigned int *)this + 107), *((void *)a2 + 2), *((void *)a2 + 3));
  *(void *)&v16.int var2 = v7;
  *(void *)&v15.int var0 = (*(uint64_t (**)(HGHWBlendFlipped *, HGRenderer *, void, void, void))(*(void *)this + 400))(this, v4, *((unsigned int *)this + 108), *((void *)a2 + 2), *((void *)a2 + 3));
  *(void *)&v15.int var2 = v8;
  uint64_t DOD = HGRenderer::GetDOD(v4, v6);
  uint64_t v11 = v10;
  if (HGRect::IsNull(&v15))
  {
    BOOL v6 = Input;
  }
  else if ((HGNode::DoInplaceHardwareBlending(v6, v4, (HGNode *)this, *((float *)this + 104)) & 1) != 0 {
         || *((float *)this + 104) != 1.0
  }
         || !HGRect::IsNull(&v16))
  {
    if (!*((_DWORD *)this + 119) && *((_DWORD *)this + 106) != 41) {
      return 0;
    }
    uint64_t v12 = HGRectIntersection(DOD, v11, *((void *)a2 + 2), *((void *)a2 + 3));
    if (!HGRectIsEqual(v12, v13, *((void *)a2 + 2), *((void *)a2 + 3))) {
      return 0;
    }
  }
  return HGGPURenderer::GetNodeBitmap(v4, v6, *((HGRect *)a2 + 1), *((HGBuffer **)a2 + 1), 1u);
}

void HGHWBlendFlipped::ComputeSubPageRects(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  Input = HGRenderer::GetInput(*(HGRenderer **)a2, (HGNode *)a1, *(_DWORD *)(a1 + 432));
  uint64_t v7 = HGRenderer::GetInput(*(HGRenderer **)a2, (HGNode *)a1, *(_DWORD *)(a1 + 428));
  uint64_t DOD = HGRenderer::GetDOD(*(HGRenderer **)a2, v7);
  uint64_t v10 = v9;
  uint64_t v11 = HGRenderer::GetDOD(*(HGRenderer **)a2, Input);
  uint64_t v13 = v12;
  *(void *)&v113.int var0 = HGRectIntersection(DOD, v10, *(void *)(a2 + 16), *(void *)(a2 + 24));
  *(void *)&v113.unsigned int var2 = v14;
  *(void *)&v112.int var0 = HGRectIntersection(v11, v13, *(void *)(a2 + 16), *(void *)(a2 + 24));
  *(void *)&v112.unsigned int var2 = v15;
  if (!HGRect::IsNull(&v113)
    && !HGRect::IsNull(&v112)
    && !HGRectIsEqual(*(uint64_t *)&v113.var0, *(uint64_t *)&v113.var2, *(uint64_t *)&v112.var0, *(uint64_t *)&v112.var2))
  {
    unsigned int v16 = *(_DWORD *)(a2 + 16);
    unsigned int v17 = *(_DWORD *)(a2 + 24);
    unsigned int v111 = *(_DWORD *)(a2 + 28);
    if (v112.var3 >= v113.var3) {
      unsigned int var3 = v113.var3;
    }
    else {
      unsigned int var3 = v112.var3;
    }
    int var0 = v113.var0;
    int v20 = v112.var0;
    if (v113.var0 <= v112.var0) {
      unsigned int v21 = v112.var0;
    }
    else {
      unsigned int v21 = v113.var0;
    }
    if (v112.var2 >= v113.var2) {
      unsigned int var2 = v113.var2;
    }
    else {
      unsigned int var2 = v112.var2;
    }
    if (v113.var1 <= v112.var1) {
      unsigned int var1 = v112.var1;
    }
    else {
      unsigned int var1 = v113.var1;
    }
    if (v113.var1 != v112.var1)
    {
      unsigned int v24 = *(_DWORD *)(a2 + 16);
      uint64_t v25 = HGRectMake4i(v16, *(_DWORD *)(a2 + 20), v17, var1);
      uint64_t v27 = v25;
      uint64_t v28 = v26;
      uint64_t v30 = a3[1];
      unint64_t v29 = (unint64_t)a3[2];
      if ((unint64_t)v30 >= v29)
      {
        unsigned int v104 = v21;
        unsigned int v106 = var2;
        unsigned int v108 = v17;
        float32x4_t v32 = *a3;
        uint64_t v33 = ((char *)v30 - (char *)*a3) >> 4;
        unint64_t v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 60) {
          goto LABEL_123;
        }
        uint64_t v35 = v29 - (void)v32;
        if (v35 >> 3 > v34) {
          unint64_t v34 = v35 >> 3;
        }
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v36 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v36 = v34;
        }
        if (v36)
        {
          if (v36 >> 60) {
            goto LABEL_124;
          }
          int8x16_t v37 = (char *)operator new(16 * v36);
        }
        else
        {
          int8x16_t v37 = 0;
        }
        float32x4_t v38 = (uint64_t *)&v37[16 * v33];
        float32x4_t v39 = (uint64_t *)&v37[16 * v36];
        *float32x4_t v38 = v27;
        v38[1] = v28;
        uint64_t v31 = v38 + 2;
        unsigned int v16 = v24;
        if (v30 == v32)
        {
          unsigned int var2 = v106;
          unsigned int v17 = v108;
        }
        else
        {
          unsigned int var2 = v106;
          unsigned int v17 = v108;
          do
          {
            *((_OWORD *)v38 - 1) = *((_OWORD *)v30 - 1);
            v38 -= 2;
            v30 -= 2;
          }
          while (v30 != v32);
          uint64_t v30 = *a3;
        }
        *a3 = v38;
        a3[1] = v31;
        a3[2] = v39;
        unsigned int v21 = v104;
        if (v30) {
          operator delete(v30);
        }
      }
      else
      {
        *uint64_t v30 = v25;
        v30[1] = v26;
        uint64_t v31 = v30 + 2;
        unsigned int v16 = v24;
      }
      a3[1] = v31;
      int var0 = v113.var0;
      int v20 = v112.var0;
    }
    if (var0 != v20)
    {
      if (var0 <= v20) {
        unsigned int v40 = v20;
      }
      else {
        unsigned int v40 = var0;
      }
      unsigned int v41 = v16;
      uint64_t v42 = HGRectMake4i(v16, var1, v40, var3);
      uint64_t v44 = v42;
      uint64_t v45 = v43;
      long long v47 = a3[1];
      unint64_t v46 = (unint64_t)a3[2];
      if ((unint64_t)v47 >= v46)
      {
        unsigned int v105 = v21;
        unsigned int v107 = var2;
        unsigned int v109 = v17;
        float32x4_t v49 = *a3;
        uint64_t v50 = ((char *)v47 - (char *)*a3) >> 4;
        unint64_t v51 = v50 + 1;
        if ((unint64_t)(v50 + 1) >> 60) {
          goto LABEL_123;
        }
        uint64_t v52 = v46 - (void)v49;
        if (v52 >> 3 > v51) {
          unint64_t v51 = v52 >> 3;
        }
        if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v53 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v53 = v51;
        }
        if (v53)
        {
          if (v53 >> 60) {
            goto LABEL_124;
          }
          int32x4_t v54 = (char *)operator new(16 * v53);
        }
        else
        {
          int32x4_t v54 = 0;
        }
        float32x4_t v55 = (uint64_t *)&v54[16 * v50];
        int8x16_t v56 = (uint64_t *)&v54[16 * v53];
        *float32x4_t v55 = v44;
        v55[1] = v45;
        float32x4_t v48 = v55 + 2;
        unsigned int v16 = v41;
        if (v47 == v49)
        {
          unsigned int var2 = v107;
          unsigned int v17 = v109;
        }
        else
        {
          unsigned int var2 = v107;
          unsigned int v17 = v109;
          do
          {
            *((_OWORD *)v55 - 1) = *((_OWORD *)v47 - 1);
            v55 -= 2;
            v47 -= 2;
          }
          while (v47 != v49);
          long long v47 = *a3;
        }
        *a3 = v55;
        a3[1] = v48;
        a3[2] = v56;
        unsigned int v21 = v105;
        if (v47) {
          operator delete(v47);
        }
      }
      else
      {
        *long long v47 = v42;
        v47[1] = v43;
        float32x4_t v48 = v47 + 2;
        unsigned int v16 = v41;
      }
      a3[1] = v48;
    }
    uint64_t v57 = HGRectMake4i(v21, var1, var2, var3);
    uint64_t v59 = v57;
    uint64_t v60 = v58;
    uint64_t v62 = a3[1];
    unint64_t v61 = (unint64_t)a3[2];
    if ((unint64_t)v62 >= v61)
    {
      unsigned int v110 = var1;
      unsigned int v64 = var3;
      unsigned int v65 = v17;
      float32x4_t v66 = *a3;
      uint64_t v67 = ((char *)v62 - (char *)*a3) >> 4;
      unint64_t v68 = v67 + 1;
      if ((unint64_t)(v67 + 1) >> 60) {
        goto LABEL_123;
      }
      uint64_t v69 = v61 - (void)v66;
      if (v69 >> 3 > v68) {
        unint64_t v68 = v69 >> 3;
      }
      if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v70 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v70 = v68;
      }
      if (v70)
      {
        if (v70 >> 60) {
          goto LABEL_124;
        }
        int8x16_t v71 = (char *)operator new(16 * v70);
      }
      else
      {
        int8x16_t v71 = 0;
      }
      int8x16_t v72 = (uint64_t *)&v71[16 * v67];
      *int8x16_t v72 = v59;
      v72[1] = v60;
      float32x4_t v63 = v72 + 2;
      unsigned int v17 = v65;
      if (v62 != v66)
      {
        do
        {
          *((_OWORD *)v72 - 1) = *((_OWORD *)v62 - 1);
          v72 -= 2;
          v62 -= 2;
        }
        while (v62 != v66);
        uint64_t v62 = *a3;
      }
      unsigned int var3 = v64;
      *a3 = v72;
      a3[1] = v63;
      a3[2] = (uint64_t *)&v71[16 * v70];
      unsigned int var1 = v110;
      if (v62) {
        operator delete(v62);
      }
    }
    else
    {
      uint64_t *v62 = v57;
      v62[1] = v58;
      float32x4_t v63 = v62 + 2;
    }
    a3[1] = v63;
    if (v113.var2 != v112.var2)
    {
      if (v112.var2 >= v113.var2) {
        unsigned int v73 = v113.var2;
      }
      else {
        unsigned int v73 = v112.var2;
      }
      uint64_t v74 = HGRectMake4i(v73, var1, v17, var3);
      uint64_t v76 = v74;
      uint64_t v77 = v75;
      float32x2_t v79 = a3[1];
      unint64_t v78 = (unint64_t)a3[2];
      if ((unint64_t)v79 >= v78)
      {
        unsigned int v81 = v17;
        float32x4_t v82 = *a3;
        uint64_t v83 = ((char *)v79 - (char *)*a3) >> 4;
        unint64_t v84 = v83 + 1;
        if ((unint64_t)(v83 + 1) >> 60) {
          goto LABEL_123;
        }
        uint64_t v85 = v78 - (void)v82;
        if (v85 >> 3 > v84) {
          unint64_t v84 = v85 >> 3;
        }
        if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v86 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v86 = v84;
        }
        if (v86)
        {
          if (v86 >> 60) {
            goto LABEL_124;
          }
          float32x4_t v87 = (char *)operator new(16 * v86);
        }
        else
        {
          float32x4_t v87 = 0;
        }
        float v88 = (uint64_t *)&v87[16 * v83];
        *float v88 = v76;
        v88[1] = v77;
        long long v80 = v88 + 2;
        unsigned int v17 = v81;
        if (v79 != v82)
        {
          do
          {
            *((_OWORD *)v88 - 1) = *((_OWORD *)v79 - 1);
            v88 -= 2;
            v79 -= 2;
          }
          while (v79 != v82);
          float32x2_t v79 = *a3;
        }
        *a3 = v88;
        a3[1] = v80;
        a3[2] = (uint64_t *)&v87[16 * v86];
        if (v79) {
          operator delete(v79);
        }
      }
      else
      {
        *float32x2_t v79 = v74;
        v79[1] = v75;
        long long v80 = v79 + 2;
      }
      a3[1] = v80;
    }
    if (v113.var3 == v112.var3) {
      return;
    }
    if (v112.var3 >= v113.var3) {
      unsigned int v89 = v113.var3;
    }
    else {
      unsigned int v89 = v112.var3;
    }
    uint64_t v90 = HGRectMake4i(v16, v89, v17, v111);
    uint64_t v92 = v90;
    uint64_t v93 = v91;
    float32x4_t v95 = a3[1];
    unint64_t v94 = (unint64_t)a3[2];
    if ((unint64_t)v95 < v94)
    {
      *float32x4_t v95 = v90;
      v95[1] = v91;
      float v96 = v95 + 2;
LABEL_121:
      a3[1] = v96;
      return;
    }
    float v97 = *a3;
    uint64_t v98 = ((char *)v95 - (char *)*a3) >> 4;
    unint64_t v99 = v98 + 1;
    if (!((unint64_t)(v98 + 1) >> 60))
    {
      uint64_t v100 = v94 - (void)v97;
      if (v100 >> 3 > v99) {
        unint64_t v99 = v100 >> 3;
      }
      if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v101 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v101 = v99;
      }
      if (!v101)
      {
        float32x4_t v102 = 0;
        goto LABEL_116;
      }
      if (!(v101 >> 60))
      {
        float32x4_t v102 = (char *)operator new(16 * v101);
LABEL_116:
        v103 = (uint64_t *)&v102[16 * v98];
        uint64_t *v103 = v92;
        v103[1] = v93;
        float v96 = v103 + 2;
        if (v95 != v97)
        {
          do
          {
            *((_OWORD *)v103 - 1) = *((_OWORD *)v95 - 1);
            v103 -= 2;
            v95 -= 2;
          }
          while (v95 != v97);
          float32x4_t v95 = *a3;
        }
        *a3 = v103;
        a3[1] = v96;
        a3[2] = (uint64_t *)&v102[16 * v101];
        if (v95) {
          operator delete(v95);
        }
        goto LABEL_121;
      }
LABEL_124:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_123:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
}

BOOL HGHWBlendFlipped::RenderSubPages(HGHWBlendFlipped *this, HGPage *a2)
{
  uint64_t v31 = 0;
  float32x4_t v32 = 0;
  uint64_t v33 = 0;
  HGHWBlendFlipped::ComputeSubPageRects((uint64_t)this, (uint64_t)a2, &v31);
  uint64_t v4 = v31;
  uint64_t v14 = v32;
  if (v31 == v32)
  {
    uint64_t v7 = v31;
    if (!v31) {
      return v4 != v14;
    }
    goto LABEL_5;
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  uint64_t v7 = v31;
  do
  {
    char v30 = 1;
    long long v8 = *(_OWORD *)((char *)a2 + 116);
    long long v21 = *(_OWORD *)((char *)a2 + 100);
    long long v22 = v8;
    long long v9 = *(_OWORD *)((char *)a2 + 148);
    long long v23 = *(_OWORD *)((char *)a2 + 132);
    long long v24 = v9;
    long long v10 = *(_OWORD *)((char *)a2 + 52);
    long long v17 = *(_OWORD *)((char *)a2 + 36);
    long long v18 = v10;
    long long v11 = *(_OWORD *)((char *)a2 + 84);
    long long v19 = *(_OWORD *)((char *)a2 + 68);
    long long v20 = v11;
    long long v25 = *(_OWORD *)((char *)a2 + 168);
    long long v26 = *(_OWORD *)((char *)a2 + 184);
    long long v27 = *(_OWORD *)((char *)a2 + 200);
    long long v28 = *(_OWORD *)((char *)a2 + 216);
    v15[0] = *(_OWORD *)a2;
    int v16 = *((_DWORD *)a2 + 8);
    long long v29 = *(_OWORD *)((char *)a2 + 232);
    v15[1] = *(_OWORD *)&v7[v5];
    uint64_t v12 = (*(uint64_t (**)(HGHWBlendFlipped *, _OWORD *))(*(void *)this + 456))(this, v15);
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
    ++v6;
    uint64_t v7 = v31;
    v5 += 2;
  }
  while (v6 < ((char *)v32 - (char *)v31) >> 4);
  if (v31)
  {
LABEL_5:
    float32x4_t v32 = v7;
    operator delete(v7);
  }
  return v4 != v14;
}

void sub_1B771B174(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 - 120);
  if (v3)
  {
    *(void *)(v1 - 112) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGHWBlendFlipped::SetLightWrapParams(uint64_t result, int a2, float a3, float a4, float a5, float a6)
{
  *(unsigned char *)(result + 520) = 1;
  *(float *)(result + 528) = a3;
  *(float *)(result + 532) = a4;
  *(float *)(result + 536) = a5;
  *(_DWORD *)(result + 524) = a2;
  *(float *)(result + 540) = a6;
  return result;
}

char *HGHWBlendFlipped::RenderPageHWBlending<(HGGPURenderAPI)0>(uint64_t a1, void *a2)
{
  uint64_t v4 = (HGRenderer *)*a2;
  Buffer = (char *)a2[1];
  unint64_t v6 = (unsigned int *)(Buffer + 16);
  if (!Buffer) {
    unint64_t v6 = (unsigned int *)(a2 + 4);
  }
  uint64_t v7 = *v6;
  Input = HGRenderer::GetInput((HGRenderer *)*a2, (HGNode *)a1, *(_DWORD *)(a1 + 432));
  long long v9 = HGRenderer::GetInput(v4, (HGNode *)a1, *(_DWORD *)(a1 + 428));
  if (Buffer)
  {
    (*(void (**)(char *))(*(void *)Buffer + 16))(Buffer);
    if (*(_DWORD *)(a1 + 476)) {
      goto LABEL_8;
    }
  }
  else
  {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)v4, *((HGRect *)a2 + 1), v7, 0, (*(_DWORD *)(a1 + 16) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
    if (*(_DWORD *)(a1 + 476)) {
      goto LABEL_8;
    }
  }
  if (*(_DWORD *)(a1 + 424) != 41)
  {
LABEL_9:
    NodeBitmap = HGGPURenderer::GetNodeBitmap(v4, v9, *((HGRect *)a2 + 1), (HGBuffer *)Buffer, 1u);
    long long v11 = NodeBitmap;
    if (NodeBitmap && NodeBitmap == (HGBitmap *)Buffer) {
      HGRenderer::DotLogInplaceRendering(v4, v9);
    }
    if (!v11 || v11 == (HGBitmap *)Buffer)
    {
      if (!v11)
      {
        (*(void (**)(void, char *))(*(void *)*a2 + 144))(*a2, Buffer);
        HGGPURenderer::Clear(v4, *((HGRect *)a2 + 1), v14, v15);
LABEL_18:
        uint64_t v16 = a2[2];
        uint64_t v17 = a2[3];
        uint64_t DOD = HGRenderer::GetDOD(v4, Input);
        uint64_t v20 = HGRectIntersection(v16, v17, DOD, v19);
        uint64_t v22 = v21;
        float v23 = *(float *)(a1 + 416);
        if (HGNode::DoInplaceHardwareBlending(Input, v4, (HGNode *)a1, v23))
        {
          if (*(_DWORD *)(a1 + 476)) {
            uint64_t v24 = 41;
          }
          else {
            uint64_t v24 = *(unsigned int *)(a1 + 424);
          }
          uint64_t v27 = HGBlendingInfo::Get((HGBlendingInfo *)v24);
          (*(void (**)(HGNode *))(*(void *)Input + 240))(Input);
          (*(void (**)(HGNode *, uint64_t))(*(void *)Input + 248))(Input, v27);
          v28.n128_u32[0] = *(_DWORD *)(a1 + 416);
          (*(void (**)(HGNode *, __n128))(*(void *)Input + 280))(Input, v28);
          (*(void (**)(HGNode *, uint64_t))(*(void *)Input + 264))(Input, a1 + 496);
          *(void *)&v37.int var0 = v20;
          *(void *)&v37.unsigned int var2 = v22;
          long long v26 = HGGPURenderer::GetNodeBitmap(v4, Input, v37, (HGBuffer *)Buffer, 1u);
          HGNode::DisableInplaceHardwareBlending(Input);
          HGRenderer::DotLogHWBlending(v4, Input, (HGNode *)a1, 1);
          BOOL v25 = 0;
          if (!v26) {
            goto LABEL_28;
          }
        }
        else
        {
          BOOL v25 = v23 != 1.0;
          *(void *)&v36.int var0 = v20;
          *(void *)&v36.unsigned int var2 = v22;
          long long v26 = HGGPURenderer::GetNodeBitmap(v4, Input, v36, 0, 1u);
          if (!v26) {
            goto LABEL_28;
          }
        }
        if (v26 != (HGBitmap *)Buffer)
        {
          uint64_t v29 = HGGPURenderer::ConvertToGLTexture(v4, *((HGRect *)a2 + 1), v26);
          (*(void (**)(HGRenderer *, char *))(*(void *)v4 + 144))(v4, Buffer);
          (*(void (**)(HGRenderer *, void, uint64_t, void, void))(*(void *)v4 + 152))(v4, 0, v29, 0, 0);
          if (v25)
          {
            uint64_t v30 = (*(uint64_t (**)(uint64_t, HGRenderer *))(*(void *)a1 + 600))(a1, v4);
            uint64_t v31 = (HGHandler *)(*(uint64_t (**)(HGRenderer *, uint64_t, uint64_t))(*(void *)v4 + 376))(v4, v30, a1);
            *(unsigned char *)(a1 + 481) = 1;
            a2[21] = v29;
            (*(void (**)(uint64_t, void *, void, HGHandler *))(*(void *)a1 + 488))(a1, a2, 0, v31);
            *(unsigned char *)(a1 + 481) = 0;
          }
          else
          {
            uint64_t v31 = 0;
          }
          (*(void (**)(uint64_t))(*(void *)a1 + 240))(a1);
          if (*(_DWORD *)(a1 + 476)) {
            uint64_t v32 = 41;
          }
          else {
            uint64_t v32 = *(unsigned int *)(a1 + 424);
          }
          uint64_t v33 = HGBlendingInfo::Get((HGBlendingInfo *)v32);
          (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 248))(a1, v33);
          (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 264))(a1, a1 + 496);
          (*(void (**)(uint64_t))(*(void *)a1 + 344))(a1);
          if (v31) {
            HGGPURenderer::Rect(v4, v31, *((HGRect *)a2 + 1), 1);
          }
          else {
            HGGPURenderer::Copy(v4, *((HGRect *)a2 + 1), 0, v34);
          }
          (*(void (**)(uint64_t))(*(void *)a1 + 352))(a1);
          HGNode::DisableInplaceHardwareBlending((HGNode *)a1);
          if (v31) {
            (*(void (**)(uint64_t, void *, void, HGHandler *))(*(void *)a1 + 496))(a1, a2, 0, v31);
          }
          (*(void (**)(uint64_t))(*(void *)v29 + 24))(v29);
          HGRenderer::DotLogHWBlending(v4, Input, (HGNode *)a1, 0);
LABEL_40:
          (*(void (**)(HGBitmap *))(*(void *)v26 + 24))(v26);
          return Buffer;
        }
LABEL_28:
        if (!v26) {
          return Buffer;
        }
        goto LABEL_40;
      }
    }
    else
    {
      uint64_t v12 = HGGPURenderer::ConvertToGLTexture(v4, *((HGRect *)a2 + 1), v11);
      (*(void (**)(HGRenderer *, char *))(*(void *)v4 + 144))(v4, Buffer);
      (*(void (**)(HGRenderer *, void, uint64_t, void, void))(*(void *)v4 + 152))(v4, 0, v12, 0, 0);
      HGGPURenderer::Copy(v4, *((HGRect *)a2 + 1), 0, v13);
      (*(void (**)(HGRenderer *, void, void, void, void))(*(void *)v4 + 152))(v4, 0, 0, 0, 0);
      (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
    }
    (*(void (**)(HGBitmap *))(*(void *)v11 + 24))(v11);
    goto LABEL_18;
  }
LABEL_8:
  if (!HGHWBlendFlipped::RenderSubPages((HGHWBlendFlipped *)a1, (HGPage *)a2)) {
    goto LABEL_9;
  }
  return Buffer;
}

char *HGHWBlendFlipped::RenderPageHWBlending<(HGGPURenderAPI)1>(uint64_t a1, void *a2)
{
  uint64_t v4 = (HGRenderer *)*a2;
  Buffer = (char *)a2[1];
  unint64_t v6 = (unsigned int *)(Buffer + 16);
  if (!Buffer) {
    unint64_t v6 = (unsigned int *)(a2 + 4);
  }
  uint64_t v7 = *v6;
  Input = HGRenderer::GetInput((HGRenderer *)*a2, (HGNode *)a1, *(_DWORD *)(a1 + 432));
  long long v9 = HGRenderer::GetInput(v4, (HGNode *)a1, *(_DWORD *)(a1 + 428));
  if (Buffer) {
    (*(void (**)(char *))(*(void *)Buffer + 16))(Buffer);
  }
  else {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)v4, *((HGRect *)a2 + 1), v7, 1, (*(_DWORD *)(a1 + 16) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
  }
  NodeBitmap = HGGPURenderer::GetNodeBitmap(v4, v9, *((HGRect *)a2 + 1), (HGBuffer *)Buffer, 1u);
  uint64_t v12 = NodeBitmap;
  if (NodeBitmap == (HGBitmap *)Buffer && NodeBitmap != 0) {
    HGRenderer::DotLogInplaceRendering(v4, v9);
  }
  if (v12) {
    BOOL v14 = v12 == (HGBitmap *)Buffer;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {
    if (!v12)
    {
      HGGPURenderer::ClearMetal(v4, (HGBitmap *)Buffer, *((HGRect *)a2 + 1), v11);
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v15 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v4, *((HGRect *)a2 + 1), v12);
    HGGPURenderer::CopyMetal(v4, (HGBitmap *)Buffer, *((HGRect *)a2 + 1), v15);
    (*(void (**)(HGBitmap *))(*(void *)v15 + 24))(v15);
  }
  (*(void (**)(HGBitmap *))(*(void *)v12 + 24))(v12);
LABEL_19:
  uint64_t v16 = a2[2];
  uint64_t v17 = a2[3];
  uint64_t DOD = HGRenderer::GetDOD(v4, Input);
  uint64_t v20 = HGRectIntersection(v16, v17, DOD, v19);
  uint64_t v22 = v21;
  float v23 = *(float *)(a1 + 416);
  if (HGNode::DoInplaceHardwareBlending(Input, v4, (HGNode *)a1, v23))
  {
    uint64_t v24 = HGBlendingInfo::Get((HGBlendingInfo *)*(unsigned int *)(a1 + 424));
    (*(void (**)(HGNode *))(*(void *)Input + 240))(Input);
    (*(void (**)(HGNode *, uint64_t))(*(void *)Input + 248))(Input, v24);
    v25.n128_u32[0] = *(_DWORD *)(a1 + 416);
    (*(void (**)(HGNode *, __n128))(*(void *)Input + 280))(Input, v25);
    (*(void (**)(HGNode *, uint64_t))(*(void *)Input + 264))(Input, a1 + 496);
    *(void *)&v49.int var0 = v20;
    *(void *)&v49.unsigned int var2 = v22;
    long long v26 = HGGPURenderer::GetNodeBitmap(v4, Input, v49, (HGBuffer *)Buffer, 1u);
    HGNode::DisableInplaceHardwareBlending(Input);
    HGRenderer::DotLogHWBlending(v4, Input, (HGNode *)a1, 1);
    BOOL v27 = 0;
    if (!v26)
    {
LABEL_28:
      if (!v26) {
        return Buffer;
      }
      goto LABEL_33;
    }
  }
  else
  {
    BOOL v27 = v23 != 1.0;
    *(void *)&v50.int var0 = v20;
    *(void *)&v50.unsigned int var2 = v22;
    long long v26 = HGGPURenderer::GetNodeBitmap(v4, Input, v50, 0, 1u);
    if (!v26) {
      goto LABEL_28;
    }
  }
  if (v26 == (HGBitmap *)Buffer) {
    goto LABEL_28;
  }
  (*(void (**)(HGRenderer *, void))(*(void *)v4 + 144))(v4, 0);
  __n128 v28 = (char *)HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v4, *((HGRect *)a2 + 1), v26);
  if (v27)
  {
    uint64_t v29 = (*(uint64_t (**)(uint64_t, HGRenderer *))(*(void *)a1 + 608))(a1, v4);
    unint64_t v46 = (HGBitmap *)v28;
    if (v29
      && (uint64_t v30 = (const void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*a2 + 376))(*a2, v29, a1)) != 0)
    {
    }
    else
    {
      uint64_t v31 = 0;
    }
    int v34 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)v4 + 128))(v4, 46);
    if (!v31) {
      goto LABEL_50;
    }
    int v45 = v34;
    __src = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
    size_t v35 = strlen(__src);
    if (v35 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v36 = v35;
    uint64_t v44 = v20;
    if (v35 >= 0x17)
    {
      uint64_t v38 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v35 | 7) != 0x17) {
        uint64_t v38 = v35 | 7;
      }
      uint64_t v42 = v22;
      uint64_t v39 = v38 + 1;
      p_dst = (std::string *)operator new(v38 + 1);
      unint64_t v40 = v39 | 0x8000000000000000;
      uint64_t v22 = v42;
      __dst.__r_.__value_.__l.__size_ = v36;
      __dst.__r_.__value_.__r.__words[2] = v40;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v35;
      p_dst = &__dst;
      if (!v35) {
        goto LABEL_45;
      }
    }
    memmove(p_dst, __src, v36);
LABEL_45:
    p_dst->__r_.__value_.__s.__data_[v36] = 0;
    HGMetalHandler::SetDebugLabel(v31, &__dst);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    HGMetalHandler::EnableBlending((uint64_t)v31);
    unsigned int v41 = (const HGBlendingInfo *)HGBlendingInfo::Get((HGBlendingInfo *)*(unsigned int *)(a1 + 424));
    HGMetalHandler::SetBlendingInfo((HGMetalHandler *)v31, v41);
    HGMetalHandler::SetBlendingColor((__n128 *)v31, (__n128 *)(a1 + 496));
    (*(void (**)(std::string *, void, float, float, float, float))(v31->__r_.__value_.__r.__words[0] + 136))(v31, 0, *(float *)(a1 + 416), *(float *)(a1 + 416), *(float *)(a1 + 416), *(float *)(a1 + 416));
    HGMetalHandler::BindBuffer((HGMetalHandler *)v31, (HGBitmap *)Buffer);
    HGMetalHandler::BindTexture((HGMetalTexture ***)v31, 0, v46);
    *(void *)&v48.int var0 = v44;
    *(void *)&v48.unsigned int var2 = v22;
    HGMetalHandler::InitTextureUnit((HGMetalHandler *)v31, v48, 0);
    HGHandler::TexCoord((HGHandler *)v31, 0, 0, 0, 0);
    (*(void (**)(std::string *, void, void))(v31->__r_.__value_.__r.__words[0] + 72))(v31, 0, 0);
    (*(void (**)(std::string *, void, void))(v31->__r_.__value_.__r.__words[0] + 48))(v31, 0, 0);
    if (!v45) {
      (*(void (**)(std::string *))(v31->__r_.__value_.__r.__words[0] + 168))(v31);
    }
    (*(void (**)(std::string *))(v31->__r_.__value_.__r.__words[0] + 40))(v31);
    (*(void (**)(std::string *, uint64_t, uint64_t, uint64_t))(v31->__r_.__value_.__r.__words[0] + 192))(v31, v44, v22, 1);
LABEL_50:
    (*(void (**)(uint64_t, void *, void, std::string *))(*(void *)a1 + 496))(a1, a2, 0, v31);
    __n128 v28 = (char *)v46;
    if (!v46) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  uint64_t v32 = (const HGBlendingInfo *)HGBlendingInfo::Get((HGBlendingInfo *)*(unsigned int *)(a1 + 424));
  *(void *)&v51.int var0 = v20;
  *(void *)&v51.unsigned int var2 = v22;
  HGGPURenderer::CopyMetal(v4, (HGBitmap *)Buffer, v51, v28, v32, (__n128 *)(a1 + 496), 1);
  if (v28) {
LABEL_31:
  }
    (*(void (**)(char *))(*(void *)v28 + 24))(v28);
LABEL_32:
  HGRenderer::DotLogHWBlending(v4, Input, (HGNode *)a1, 0);
LABEL_33:
  (*(void (**)(HGBitmap *))(*(void *)v26 + 24))(v26);
  return Buffer;
}

void sub_1B771C12C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double HGShaderBinding::reset(HGShaderBinding *this)
{
  *((_DWORD *)this + 8) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

BOOL HGLimits::isfragment(HGLimits *this)
{
  return (*(_DWORD *)this & 0xF0000) == 393216;
}

uint64_t HGLimits::isarb(HGLimits *this)
{
  if ((*(_DWORD *)this & 0xFF00u) - 768 >= 0x101) {
    return 0;
  }
  else {
    return *(_DWORD *)this & 0xF0000;
  }
}

uint64_t HGLimits::isarbfp(HGLimits *this)
{
  unsigned int v1 = *(_DWORD *)this & 0xFFFFF;
  if (v1 - 394000 >= 0x131) {
    return 0;
  }
  else {
    return v1;
  }
}

uint64_t HGLimits::isglfs(HGLimits *this)
{
  unsigned int v1 = *(_DWORD *)this & 0xFFFFF;
  if (v1 - 394768 >= 0x11) {
    return 0;
  }
  else {
    return v1;
  }
}

uint64_t HGLimits::ismetal(HGLimits *this)
{
  if ((*(_DWORD *)this & 0xFFFFF) == 0x60B10) {
    return 396048;
  }
  else {
    return 0;
  }
}

BOOL HGLimits::issafe(HGLimits *this)
{
  return (*((unsigned char *)this + 7) & 1) == 0;
}

uint64_t HGLimits::isenv(HGLimits *this)
{
  return (*((_DWORD *)this + 1) >> 27) & 1;
}

uint64_t HGLimits::setnormalized(uint64_t this, int a2)
{
  if (a2) {
    int v2 = 0x800000;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(this + 4) = *(_DWORD *)(this + 4) & 0xFF7FFFFF | v2;
  return this;
}

BOOL HGLimits::texturerect(HGLimits *this)
{
  return ((*((_DWORD *)this + 1) >> 23) & 1) == 0;
}

unsigned __int8 *HGString::target(HGString *this, const char *a2)
{
  int v2 = (int)a2;
  unsigned int v7 = 0;
  double result = header((const char *)this, &v7);
  if (result)
  {
    if (v2)
    {
      uint64_t v5 = (char *)this + 33;
      if (!strncmp(v5, "OPTION NV_fragment_program; \n", 0x1DuLL)) {
        return (unsigned __int8 *)394256;
      }
      if (!strncmp(v5, "OPTION NV_fragment_program2;\n", 0x1DuLL)) {
        return (unsigned __int8 *)394272;
      }
      if (!strncmp(v5, "OPTION NV_vertex_program2;  \n", 0x1DuLL)) {
        return (unsigned __int8 *)328736;
      }
      if (!strncmp(v5, "OPTION NV_vertex_program3;  \n", 0x1DuLL)) {
        return (unsigned __int8 *)328752;
      }
    }
    return (unsigned __int8 *)v7;
  }
  return result;
}

unsigned __int8 *header(const char *__s1, unsigned int *a2)
{
  int v2 = *(unsigned __int8 *)__s1;
  if (!*__s1) {
    return 0;
  }
  uint64_t v4 = __s1;
  if (v2 != 33 && v2 != 47)
  {
    while (1)
    {
      if ((v2 - 33) >= 0xFFFFFFE0)
      {
        do
        {
          int v8 = *(unsigned __int8 *)++v4;
          int v2 = v8;
        }
        while ((v8 - 33) > 0xFFFFFFDF);
      }
      if (v2 != 35) {
        break;
      }
      long long v9 = v4;
      do
      {
        int v10 = *(unsigned __int8 *)++v9;
        int v2 = v10;
        if (!v10) {
          return 0;
        }
        int v11 = *(unsigned __int8 *)v4;
        uint64_t v4 = v9;
      }
      while (v11 != 10);
      uint64_t v4 = v9;
    }
    if (!v2) {
      return 0;
    }
  }
  if (v2 == 47)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 + 6);
    if (!strncmp(v4, "//GLfs", 6uLL))
    {
      char v7 = 0;
      unsigned int v6 = 394752;
      goto LABEL_49;
    }
    if (!strncmp(v4, "//GLvs", 6uLL))
    {
      char v7 = 0;
      unsigned int v6 = 329216;
      goto LABEL_49;
    }
    if (!strncmp(v4, "//GLps", 6uLL))
    {
      char v7 = 0;
      unsigned int v6 = 132608;
      goto LABEL_49;
    }
    if (!strncmp(v4, "//GLus", 6uLL))
    {
      char v7 = 0;
      unsigned int v6 = 460288;
      goto LABEL_49;
    }
    if (!strncmp(v4, "//CGfs", 6uLL))
    {
      char v7 = 0;
      unsigned int v6 = 395008;
    }
    else
    {
      if (strncmp(v4, "//CGvs", 6uLL))
      {
        if (!strncmp(v4, "//Metal", 7uLL))
        {
          char v7 = 0;
          uint64_t v5 = (unsigned __int8 *)(v4 + 7);
          unsigned int v6 = 396032;
          goto LABEL_49;
        }
        return 0;
      }
      char v7 = 0;
      unsigned int v6 = 329472;
    }
  }
  else
  {
    if (v2 != 33) {
      return 0;
    }
    uint64_t v5 = (unsigned __int8 *)(v4 + 7);
    if (!strncmp(v4, "!!ARBfp", 7uLL))
    {
      char v7 = 0;
      unsigned int v6 = 393984;
      goto LABEL_49;
    }
    if (!strncmp(v4, "!!NVfp", 6uLL))
    {
      char v7 = 0;
      unsigned int v6 = 394240;
      goto LABEL_48;
    }
    unsigned int v6 = 328704;
    if (!strncmp(v4, "!!ARBvp", 7uLL))
    {
      char v7 = 0;
      unsigned int v6 = 328448;
      goto LABEL_49;
    }
    if (!strncmp(v4, "!!NVvp", 6uLL))
    {
      char v7 = 0;
      goto LABEL_48;
    }
    if (!strncmp(v4, "!!NVgp", 6uLL))
    {
      char v7 = 0;
      unsigned int v6 = 197632;
      goto LABEL_48;
    }
    if (!strncmp(v4, "!!VP", 4uLL))
    {
      char v7 = 0;
      uint64_t v5 = (unsigned __int8 *)(v4 + 4);
    }
    else if (!strncmp(v4, "!!FP", 4uLL))
    {
      unsigned int v6 = 0;
      char v7 = 1;
      uint64_t v5 = (unsigned __int8 *)(v4 + 4);
    }
    else if (!strncmp(v4, "!!VSP", 5uLL))
    {
      char v7 = 0;
      uint64_t v5 = (unsigned __int8 *)(v4 + 5);
      unsigned int v6 = 263168;
    }
    else
    {
      if (!strncmp(v4, "!!HGfp", 6uLL))
      {
        char v7 = 0;
        unsigned int v6 = 394496;
        goto LABEL_48;
      }
      if (!strncmp(v4, "!!HGvp", 6uLL))
      {
        char v7 = 0;
        unsigned int v6 = 328960;
        goto LABEL_48;
      }
      if (!strncmp(v4, "!!CIfp", 6uLL))
      {
        char v7 = 0;
        unsigned int v6 = 393728;
        goto LABEL_48;
      }
      if (strncmp(v4, "!!SSEfp", 7uLL))
      {
        if (!strncmp(v4, "!!CIsw", 6uLL))
        {
          char v7 = 0;
          unsigned int v6 = 17170944;
          goto LABEL_48;
        }
        if (!strncmp(v4, "!!CIvp", 6uLL))
        {
          char v7 = 0;
          unsigned int v6 = 328192;
          goto LABEL_48;
        }
        if (!strncmp(v4, "!!CIpp", 6uLL))
        {
          char v7 = 0;
          unsigned int v6 = 66048;
LABEL_48:
          uint64_t v5 = (unsigned __int8 *)(v4 + 6);
          goto LABEL_49;
        }
        return 0;
      }
      char v7 = 0;
      unsigned int v6 = 69599744;
    }
  }
LABEL_49:
  *a2 = v6;
  int v12 = *v5;
  if ((v12 - 58) < 0xFFFFFFF6)
  {
    uint64_t v13 = 0;
    goto LABEL_66;
  }
  int v14 = 0;
  uint64_t v13 = v5 + 1;
  do
  {
    int v14 = v12 + 10 * v14 - 48;
    int v15 = *v13++;
    int v12 = v15;
  }
  while ((v15 - 58) > 0xFFFFFFF5);
  if (v7)
  {
    unsigned int v6 = 0;
    if (v12 != 46) {
      goto LABEL_55;
    }
LABEL_58:
    int v16 = *v13;
    if ((v16 - 58) >= 0xFFFFFFF6)
    {
      int v17 = 0;
      do
      {
        int v17 = v16 + 10 * v17 - 48;
        int v18 = *++v13;
        int v16 = v18;
      }
      while ((v18 - 58) > 0xFFFFFFF5);
      if (!v6) {
        goto LABEL_65;
      }
      v6 += v17;
      *a2 = v6;
      if (v6 <= 0xFF) {
        goto LABEL_65;
      }
    }
    else
    {
      uint64_t v13 = 0;
      if (v6 <= 0xFF) {
        goto LABEL_65;
      }
    }
    goto LABEL_66;
  }
  v6 += 16 * v14;
  *a2 = v6;
  if (*(v13 - 1) == 46) {
    goto LABEL_58;
  }
LABEL_55:
  --v13;
  if (v6 <= 0xFF)
  {
LABEL_65:
    *a2 = 394240;
    goto LABEL_78;
  }
LABEL_66:
  if ((v6 & 0x600) != 0)
  {
    while (1)
    {
      do
      {
LABEL_78:
        double result = v13;
        __n128 v25 = v13 + 1;
        int v26 = *v13++;
      }
      while ((v26 - 33) >= 0xFFFFFFE0);
      if (v26 != 47) {
        goto LABEL_109;
      }
      int v27 = *v25;
      if (v27 == 42)
      {
        uint64_t v13 = result + 2;
        if (result[2])
        {
          do
          {
            if (*(v25 - 1) == 42 && *v25 == 47) {
              break;
            }
            int v30 = v25[2];
            ++v25;
          }
          while (v30);
          uint64_t v13 = v25 + 1;
        }
      }
      else
      {
        if (v27 != 47) {
          return result;
        }
        __n128 v28 = result + 2;
        while (*v28)
        {
          int v29 = *(v28 - 1);
          uint64_t v13 = v28++;
          if (v29 == 10) {
            goto LABEL_78;
          }
        }
        uint64_t v13 = v28;
      }
    }
  }
  if ((v6 & 0xB00) != 0)
  {
    while (1)
    {
      do
      {
LABEL_95:
        double result = v13;
        uint64_t v31 = v13 + 1;
        int v26 = *v13++;
      }
      while ((v26 - 33) >= 0xFFFFFFE0);
      if (v26 != 47) {
        break;
      }
      int v32 = *v31;
      if (v32 == 42)
      {
        uint64_t v13 = result + 2;
        if (result[2])
        {
          do
          {
            if (*(v31 - 1) == 42 && *v31 == 47) {
              break;
            }
            int v35 = v31[2];
            ++v31;
          }
          while (v35);
          uint64_t v13 = v31 + 1;
        }
      }
      else
      {
        if (v32 != 47) {
          return result;
        }
        uint64_t v33 = result + 2;
        while (*v33)
        {
          int v34 = *(v33 - 1);
          uint64_t v13 = v33++;
          if (v34 == 10) {
            goto LABEL_95;
          }
        }
        uint64_t v13 = v33;
      }
    }
LABEL_109:
    if (!v26) {
      return 0;
    }
    return result;
  }
  unsigned __int8 v19 = *v13;
  if (!*v13) {
    return 0;
  }
  if ((v19 - 33) >= 0xE0u)
  {
    do
    {
LABEL_70:
      unsigned __int8 v20 = *++v13;
      unsigned __int8 v19 = v20;
    }
    while ((v20 - 33) > 0xDFu);
  }
LABEL_71:
  if (v19 == 35)
  {
    uint64_t v21 = v13;
    while (1)
    {
      int v22 = *++v21;
      unsigned __int8 v19 = v22;
      if (!v22) {
        return 0;
      }
      int v23 = *v13;
      uint64_t v13 = v21;
      if (v23 == 10)
      {
        uint64_t v13 = v21;
        if ((v19 - 33) >= 0xE0u) {
          goto LABEL_70;
        }
        goto LABEL_71;
      }
    }
  }
  if (v19) {
    return v13;
  }
  else {
    return 0;
  }
}

uint64_t HGString::isdistilled(HGString *this, const char *a2)
{
  int v3 = *(unsigned __int8 *)this;
  if (v3 != 47 && v3 != 33) {
    return 0;
  }
  if (!*((unsigned char *)this + 1)) {
    return 0;
  }
  if (!*((unsigned char *)this + 2)) {
    return 0;
  }
  if (!*((unsigned char *)this + 3)) {
    return 0;
  }
  if (!*((unsigned char *)this + 4)) {
    return 0;
  }
  if (!*((unsigned char *)this + 5)) {
    return 0;
  }
  if (!*((unsigned char *)this + 6)) {
    return 0;
  }
  if (!*((unsigned char *)this + 7)) {
    return 0;
  }
  if (!*((unsigned char *)this + 8)) {
    return 0;
  }
  if (!*((unsigned char *)this + 9)) {
    return 0;
  }
  if (!*((unsigned char *)this + 10)) {
    return 0;
  }
  if (!*((unsigned char *)this + 11)) {
    return 0;
  }
  if (!*((unsigned char *)this + 12)) {
    return 0;
  }
  if (!*((unsigned char *)this + 13)) {
    return 0;
  }
  if (!*((unsigned char *)this + 14)) {
    return 0;
  }
  if (!*((unsigned char *)this + 15)) {
    return 0;
  }
  if (!*((unsigned char *)this + 16)) {
    return 0;
  }
  if (!*((unsigned char *)this + 17)) {
    return 0;
  }
  int v30 = *((unsigned __int8 *)this + 16);
  if (strncmp((const char *)this + 18, "LEN=", 4uLL)) {
    return 0;
  }
  int v8 = *((char *)this + 24);
  if (v8 <= 96) {
    int v9 = 0;
  }
  else {
    int v9 = 9;
  }
  int v10 = v9 + v8;
  v6.i32[0] = *(_DWORD *)((char *)this + 25);
  int32x4_t v11 = (int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v6));
  int32x4_t v12 = vshrq_n_s32(vshlq_n_s32(v11, 0x18uLL), 0x18uLL);
  v13.i64[0] = 0x6000000060;
  v13.i64[1] = 0x6000000060;
  int8x16_t v14 = (int8x16_t)vcgtq_s32(v12, v13);
  v12.i32[0] = v11.i32[0];
  int8x16_t v15 = (int8x16_t)vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vaddq_s32(v12, (int32x4_t)vandq_s8(v14, (int8x16_t)xmmword_1B7EC1780)), (uint32x4_t)xmmword_1B7EC1790), (int32x4_t)xmmword_1B7EC17A0);
  int v16 = *((char *)this + 29);
  if (v16 <= 96) {
    int v17 = 0;
  }
  else {
    int v17 = -39;
  }
  int v18 = ((v16 + v17) << 8) - 12288;
  int v19 = *((char *)this + 30);
  if (v19 <= 96) {
    int v20 = 0;
  }
  else {
    int v20 = -39;
  }
  int v21 = 16 * (v19 + v20) - 768;
  int v22 = *((char *)this + 31);
  if (v22 <= 96) {
    int v23 = 0;
  }
  else {
    int v23 = -39;
  }
  int8x8_t v24 = vorr_s8(*(int8x8_t *)v15.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
  uint64_t v25 = v24.i32[0] | v24.i32[1] | (v10 << 28) | v18 | v21 | (v22 + v23 - 48);
  if (!v25
    || !*((unsigned char *)this + v25) && *((unsigned __int8 *)this + v25 - 138) != v30
    || (int v26 = (char *)this + v25 - 136, v27 = v25, v28 = strncmp(v26, "MD5=", 4uLL), result = v27, v28))
  {
    unsigned __int8 v29 = atomic_load(HGLogger::_enabled);
    if (v29) {
      HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"Helium WARNING -- Shader string has incorrect LEN or missing MD5.\n", v4, v5);
    }
    return 0;
  }
  return result;
}

uint64_t HGString::_distill(HGString *this, char *__s1, unsigned int a3)
{
  int v3 = __s1;
  uint64_t v661 = *MEMORY[0x1E4F143B8];
  long long v652 = 0u;
  long long v653 = 0u;
  *(_OWORD *)v650 = 0u;
  long long v651 = 0u;
  long long v648 = 0u;
  long long v649 = 0u;
  *(_OWORD *)v647 = 0u;
  int v5 = *__s1;
  if (*__s1)
  {
    int v7 = *__s1;
    int v8 = __s1;
    if ((v5 - 33) < 0xFFFFFFE0) {
      goto LABEL_4;
    }
    do
    {
LABEL_3:
      int v9 = *(unsigned __int8 *)++v8;
      int v7 = v9;
    }
    while ((v9 - 33) > 0xFFFFFFDF);
LABEL_4:
    while (v7 == 35)
    {
      int v10 = v8;
      do
      {
        int v11 = *(unsigned __int8 *)++v10;
        int v7 = v11;
        if (!v11) {
          goto LABEL_19;
        }
        int v12 = *(unsigned __int8 *)v8;
        int v8 = v10;
      }
      while (v12 != 10);
      int v8 = v10;
      if ((v7 - 33) >= 0xFFFFFFE0) {
        goto LABEL_3;
      }
    }
    if (v7 == 33)
    {
      int v654 = 0;
      *(void *)&long long v653 = 0;
      DWORD2(v653) = 0;
      int32x4_t v13 = __s1;
      *((void *)&v651 + 1) = 0;
      *(void *)&long long v652 = 0;
      if ((v5 - 33) < 0xFFFFFFE0) {
        goto LABEL_13;
      }
      do
      {
LABEL_12:
        int v14 = *(unsigned __int8 *)++v13;
        int v5 = v14;
      }
      while ((v14 - 33) > 0xFFFFFFDF);
LABEL_13:
      while (v5 == 35)
      {
        int8x16_t v15 = v13;
        do
        {
          int v16 = *(unsigned __int8 *)++v15;
          int v5 = v16;
          if (!v16) {
            goto LABEL_831;
          }
          int v17 = *(unsigned __int8 *)v13;
          int32x4_t v13 = v15;
        }
        while (v17 != 10);
        int32x4_t v13 = v15;
        if ((v5 - 33) >= 0xFFFFFFE0) {
          goto LABEL_12;
        }
      }
      if (!v5 || (v366 = header(v13, v647)) == 0)
      {
LABEL_831:
        uint64_t v218 = 4294967238;
        *((void *)this + 1) = 0;
        *((void *)this + 2) = 0;
        *(void *)this = v3;
        v372 = v650[0];
        if (!v650[0]) {
          return v218;
        }
        goto LABEL_832;
      }
      v368 = (char *)v366;
      if ((v647[0] & 0xF0000) == 0x50000)
      {
        unsigned int v369 = 0;
        unsigned int v371 = 0;
        v647[1] = -1073741824;
        unsigned int v370 = -939524096;
      }
      else if ((v647[0] & 0xF0000) == 0x60000)
      {
        v647[1] = 0;
        unsigned int v369 = a3;
        unsigned int v370 = 0x8000000;
        unsigned int v371 = 255;
      }
      else
      {
        unsigned int v369 = 0;
        unsigned int v371 = 0;
        v647[1] = 0;
        unsigned int v370 = 0x8000000;
      }
      v647[2] = v371;
      v647[3] = v369;
      if (a3 >= 0x100) {
        v647[1] = v370;
      }
      int v373 = *v366;
      if (v373 == 35)
      {
        while (v373 == 35)
        {
          ++v368;
          do
          {
            int v373 = *v368;
            if (!*v368) {
              goto LABEL_846;
            }
            int v375 = *(v368++ - 1);
          }
          while (v375 != 10);
          --v368;
          if ((v373 - 33) >= 0xFFFFFFE0)
          {
            do
            {
              int v374 = *++v368;
              int v373 = v374;
            }
            while ((v374 - 33) > 0xFFFFFFDF);
          }
        }
      }
LABEL_846:
      int v634 = 0;
      for (unint64_t i = v368; ; ++i)
      {
LABEL_849:
        while (1)
        {
          int v377 = *(unsigned __int8 *)i;
          if (v377 != 35) {
            break;
          }
          while (1)
          {
            if ((v377 - 33) >= 0xFFFFFFE0)
            {
              do
              {
                int v378 = *(unsigned __int8 *)++i;
                int v377 = v378;
              }
              while ((v378 - 33) > 0xFFFFFFDF);
            }
            if (v377 != 35) {
              break;
            }
            v379 = i;
            do
            {
              int v380 = *(unsigned __int8 *)++v379;
              int v377 = v380;
              if (!v380) {
                goto LABEL_861;
              }
              int v381 = *(unsigned __int8 *)i;
              unint64_t i = v379;
            }
            while (v381 != 10);
            unint64_t i = v379;
          }
          if (!v377)
          {
LABEL_861:
            unint64_t i = 0;
            goto LABEL_862;
          }
        }
        if ((v377 - 58) < 2) {
          break;
        }
        if (!*i) {
          goto LABEL_861;
        }
      }
      int v414 = *(unsigned __int8 *)++i;
      int v413 = v414;
      if (v414)
      {
        if ((v413 - 33) < 0xFFFFFFE0) {
          goto LABEL_966;
        }
        do
        {
LABEL_965:
          int v415 = *(unsigned __int8 *)++i;
          int v413 = v415;
        }
        while ((v415 - 33) > 0xFFFFFFDF);
LABEL_966:
        while (v413 == 35)
        {
          ++i;
          do
          {
            int v413 = *(unsigned __int8 *)i;
            if (!*i) {
              goto LABEL_862;
            }
            int v416 = *((unsigned __int8 *)i++ - 1);
          }
          while (v416 != 10);
          --i;
          if ((v413 - 33) >= 0xFFFFFFE0) {
            goto LABEL_965;
          }
        }
      }
LABEL_862:
      if (v368 == i)
      {
        unint64_t i = v368;
        goto LABEL_848;
      }
      uint64_t v382 = 0;
      LOBYTE(v383) = *v368;
      v637 = (arb *)((char *)&v648 + 10);
      __nb = &unk_1B7EC18D2;
      while (2)
      {
        char v384 = 0;
        switch((char)v383)
        {
          case 'A':
            if (strncmp(v368, "ATTRIB", 6uLL))
            {
              v417 = arb::obj_alias((uint64_t)v650, v368, (uint64_t)v647);
              goto LABEL_993;
            }
            if ((v647[0] & 0xF0000) == 0x60000) {
              v444 = &fragmentKind;
            }
            else {
              v444 = &vertexKind;
            }
            if (arb::obj_decl((uint64_t)v650, v444, (arb *)(v368 + 6), v382, (uint64_t)v647)) {
              goto LABEL_848;
            }
            uint64_t v218 = 4294967243;
            *((void *)this + 1) = 0;
            *((void *)this + 2) = 0;
            *(void *)this = v3;
            v372 = v650[0];
            if (v650[0]) {
              goto LABEL_832;
            }
            return v218;
          case 'B':
            if (strncmp(v368, "BUFFER", 6uLL)) {
              goto LABEL_1076;
            }
            int v423 = v368[6];
            v422 = (unsigned __int8 *)(v368 + 6);
            if (v423 == 52) {
              v424 = (arb *)(v422 + 1);
            }
            else {
              v424 = (arb *)v422;
            }
            if (arb::obj_decl((uint64_t)v650, &bufferKind, v424, v382, (uint64_t)v647)) {
              goto LABEL_848;
            }
            uint64_t v218 = 4294967246;
            *((void *)this + 1) = 0;
            *((void *)this + 2) = 0;
            *(void *)this = v3;
            v372 = v650[0];
            if (v650[0]) {
              goto LABEL_832;
            }
            return v218;
          case 'C':
            if (strncmp(v368, "CENTROID", 8uLL)) {
              goto LABEL_1076;
            }
            int v385 = v368[8];
            v368 += 8;
            LOBYTE(v383) = v385;
            if (!v385) {
              goto LABEL_865;
            }
            if ((v383 - 33) >= 0xE0u) {
              goto LABEL_870;
            }
            while (1)
            {
              do
              {
                if (v383 != 35) {
                  goto LABEL_865;
                }
                ++v368;
                do
                {
                  LOBYTE(v383) = *v368;
                  if (!*v368) {
                    goto LABEL_865;
                  }
                  int v387 = *(v368++ - 1);
                }
                while (v387 != 10);
                --v368;
              }
              while ((v383 - 33) < 0xE0u);
              do
              {
LABEL_870:
                char v386 = *++v368;
                LOBYTE(v383) = v386;
              }
              while ((v386 - 33) > 0xDFu);
            }
          case 'D':
            goto LABEL_1072;
          case 'E':
            if (!strncmp(v368, "ENDLOOP", 7uLL) || !strncmp(v368, "ENDREP", 6uLL))
            {
              --v634;
              goto LABEL_848;
            }
            if (strncmp(v368, "END", 3uLL)) {
              goto LABEL_1076;
            }
            if ((ctype[2 * v368[3]] & 0x40) != 0) {
              goto LABEL_848;
            }
            goto LABEL_1410;
          case 'F':
            if (!strncmp(v368, "FLAT", 4uLL))
            {
              int v410 = v368[4];
              v368 += 4;
              LOBYTE(v383) = v410;
              if (v410)
              {
                if ((v383 - 33) < 0xE0u) {
                  goto LABEL_957;
                }
                do
                {
LABEL_956:
                  char v411 = *++v368;
                  LOBYTE(v383) = v411;
                }
                while ((v411 - 33) > 0xDFu);
LABEL_957:
                while (v383 == 35)
                {
                  ++v368;
                  do
                  {
                    LOBYTE(v383) = *v368;
                    if (!*v368) {
                      goto LABEL_865;
                    }
                    int v412 = *(v368++ - 1);
                  }
                  while (v412 != 10);
                  --v368;
                  if ((v383 - 33) >= 0xE0u) {
                    goto LABEL_956;
                  }
                }
              }
            }
            else
            {
              if (strncmp(v368, "FLOAT", 5uLL)) {
                goto LABEL_1076;
              }
              int v400 = v368[5];
              v368 += 5;
              LOBYTE(v383) = v400;
              if (v400)
              {
                if ((v383 - 33) < 0xE0u) {
                  goto LABEL_925;
                }
                do
                {
LABEL_924:
                  char v401 = *++v368;
                  LOBYTE(v383) = v401;
                }
                while ((v401 - 33) > 0xDFu);
LABEL_925:
                while (v383 == 35)
                {
                  ++v368;
                  do
                  {
                    LOBYTE(v383) = *v368;
                    if (!*v368) {
                      goto LABEL_865;
                    }
                    int v402 = *(v368++ - 1);
                  }
                  while (v402 != 10);
                  --v368;
                  if ((v383 - 33) >= 0xE0u) {
                    goto LABEL_924;
                  }
                }
              }
            }
            goto LABEL_865;
          case 'I':
            if (!strncmp(v368, "INTERPOLATE", 0xBuLL)) {
              goto LABEL_848;
            }
            if (strncmp(v368, "INT", 3uLL))
            {
              v426 = v368;
              v427 = "IF";
              size_t v428 = 2;
LABEL_1037:
              if (!strncmp(v426, v427, v428)) {
                goto LABEL_848;
              }
LABEL_1076:
              char v384 = 0;
LABEL_1077:
              int v425 = *v368;
              if ((ctype[2 * *v368] & 0x40) == 0)
              {
LABEL_1078:
                size_t __nc = 0;
LABEL_1079:
                v448 = (unsigned __int8 *)(v368 - 1);
                do
                {
                  int v450 = *++v448;
                  int v449 = v450;
                }
                while ((ctype[2 * v450] & 0x40) != 0);
                *(void *)&long long __s1a = 0;
                *(void *)&long long __dst = 0;
                if (v449)
                {
                  if ((v449 - 33) < 0xFFFFFFE0) {
                    goto LABEL_1084;
                  }
                  do
                  {
LABEL_1083:
                    int v451 = *++v448;
                    int v449 = v451;
                  }
                  while ((v451 - 33) > 0xFFFFFFDF);
LABEL_1084:
                  while (v449 == 35)
                  {
                    v452 = v448;
                    do
                    {
                      int v453 = *++v452;
                      int v449 = v453;
                      if (!v453) {
                        goto LABEL_1092;
                      }
                      int v454 = *v448;
                      v448 = v452;
                    }
                    while (v454 != 10);
                    v448 = v452;
                    if ((v449 - 33) >= 0xFFFFFFE0) {
                      goto LABEL_1083;
                    }
                  }
                  if (v449 == 58) {
                    goto LABEL_1091;
                  }
                }
LABEL_1092:
                if (v384)
                {
                  v455 = 0;
                  int v456 = *v368;
                  if (v456 == 59)
                  {
                    while (1)
                    {
LABEL_1101:
                      if ((v456 - 33) >= 0xFFFFFFE0)
                      {
                        do
                        {
                          int v458 = *++v368;
                          int v456 = v458;
                        }
                        while ((v458 - 33) > 0xFFFFFFDF);
                      }
                      if (v456 != 35) {
                        break;
                      }
                      ++v368;
                      do
                      {
                        int v456 = *v368;
                        if (!*v368) {
                          goto LABEL_1108;
                        }
                        int v459 = *(v368++ - 1);
                      }
                      while (v459 != 10);
                      --v368;
                    }
LABEL_1108:
                    if ((v384 & 1) != 0
                      || (v460 = arb::asymbol((arb *)v368, (char *)&__s1a, (const char **)&__dst, v367)) == 0)
                    {
                      v462 = 0;
                      v463 = 0;
                    }
                    else
                    {
                      int v461 = *v460;
                      if (*v460 && v461 != 44)
                      {
                        do
                        {
                          if (v461 == 35)
                          {
                            while (v461 == 35)
                            {
                              ++v460;
                              do
                              {
                                int v461 = *v460;
                                if (!*v460) {
                                  goto LABEL_1112;
                                }
                                int v488 = *(v460++ - 1);
                              }
                              while (v488 != 10);
                              --v460;
                              if ((v461 - 33) >= 0xFFFFFFE0)
                              {
                                do
                                {
                                  int v487 = *++v460;
                                  int v461 = v487;
                                }
                                while ((v487 - 33) > 0xFFFFFFDF);
                              }
                            }
                          }
                          else
                          {
                            int v489 = *++v460;
                            int v461 = v489;
                          }
                        }
                        while (v461 != 44 && v461 != 0);
                      }
LABEL_1112:
                      v462 = (char *)__s1a;
                      v463 = (const char **)__dst;
                      int v464 = v460[1];
                      v368 = (char *)(v460 + 1);
                      if (v460[1])
                      {
                        if ((v464 - 33) < 0xFFFFFFE0) {
                          goto LABEL_1115;
                        }
                        do
                        {
LABEL_1114:
                          int v465 = *++v368;
                          int v464 = v465;
                        }
                        while ((v465 - 33) > 0xFFFFFFDF);
LABEL_1115:
                        while (v464 == 35)
                        {
                          ++v368;
                          do
                          {
                            int v464 = *v368;
                            if (!*v368) {
                              goto LABEL_1122;
                            }
                            int v466 = *(v368++ - 1);
                          }
                          while (v466 != 10);
                          --v368;
                          if ((v464 - 33) >= 0xFFFFFFE0) {
                            goto LABEL_1114;
                          }
                        }
                      }
                    }
LABEL_1122:
                    v467 = arb::asymbol((arb *)v368, (char *)&__s1a, (const char **)&__dst, v367);
                    if (v467)
                    {
                      if (v455)
                      {
                        v468 = arb::obj_add((uint64_t)v650, (char *)__s1a, (const char **)__dst, (uint64_t)v647, 1);
                        if (v468 && *((void *)v468 + 5) == (void)v653 && *((_DWORD *)v468 + 14) == DWORD2(v653)) {
                          *(void *)&long long v653 = 0;
                        }
                      }
                      else
                      {
                        v475 = v467;
                        while (1)
                        {
                          v476 = arb::obj_add((uint64_t)v650, (char *)__s1a, (const char **)__dst, (uint64_t)v647, 1);
                          if (v476 && *((void *)v476 + 5) == (void)v653 && *((_DWORD *)v476 + 14) == DWORD2(v653)) {
                            *(void *)&long long v653 = 0;
                          }
                          int v477 = *v475;
                          if (!*v475) {
                            goto LABEL_1128;
                          }
LABEL_1154:
                          if ((v477 - 33) >= 0xFFFFFFE0)
                          {
                            do
                            {
                              int v478 = *++v475;
                              int v477 = v478;
                            }
                            while ((v478 - 33) > 0xFFFFFFDF);
                          }
                          if (v477 == 35) {
                            break;
                          }
                          if (v477 == 44)
                          {
                            int v484 = v475[1];
                            v483 = (arb *)(v475 + 1);
                            int v482 = v484;
                            if (v484)
                            {
                              if ((v482 - 33) < 0xFFFFFFE0) {
                                goto LABEL_1165;
                              }
                              do
                              {
LABEL_1164:
                                int v485 = *((unsigned __int8 *)v483 + 1);
                                v483 = (arb *)((char *)v483 + 1);
                                int v482 = v485;
                              }
                              while ((v485 - 33) > 0xFFFFFFDF);
LABEL_1165:
                              while (v482 == 35)
                              {
                                v483 = (arb *)((char *)v483 + 1);
                                do
                                {
                                  int v482 = *(unsigned __int8 *)v483;
                                  if (!*(unsigned char *)v483) {
                                    goto LABEL_1171;
                                  }
                                  int v486 = *((unsigned __int8 *)v483 - 1);
                                  v483 = (arb *)((char *)v483 + 1);
                                }
                                while (v486 != 10);
                                v483 = (arb *)((char *)v483 - 1);
                                if ((v482 - 33) >= 0xFFFFFFE0) {
                                  goto LABEL_1164;
                                }
                              }
                            }
LABEL_1171:
                            v475 = arb::asymbol(v483, (char *)&__s1a, (const char **)&__dst, v367);
                            if (v475) {
                              continue;
                            }
                          }
                          goto LABEL_1128;
                        }
                        v479 = v475;
                        while (1)
                        {
                          int v480 = *++v475;
                          int v477 = v480;
                          if (!v480) {
                            break;
                          }
                          int v481 = *v479;
                          v479 = v475;
                          if (v481 == 10) {
                            goto LABEL_1154;
                          }
                        }
                      }
                    }
LABEL_1128:
                    if (v462)
                    {
                      v469 = arb::obj_add((uint64_t)v650, v462, v463, (uint64_t)v647, 1);
                      if (v469)
                      {
                        v470 = (unsigned char *)*((void *)v469 + 5);
                        if (v470 == (unsigned char *)v653 && *((_DWORD *)v469 + 14) == DWORD2(v653)) {
                          *(void *)&long long v653 = 0;
                        }
                        if (v470 != (unsigned char *)&longKind
                          && v470 != (unsigned char *)&unk_1B7EC18D2
                          && v470 != (unsigned char *)&shortKind
                          && v470 == outputKind
                          && __nc != 0)
                        {
                          HIDWORD(v653) = 1;
                        }
                      }
                    }
                    goto LABEL_848;
                  }
                }
                else
                {
                  if (!strncmp(v368, "SWZ", 3uLL)) {
                    v455 = (unsigned __int8 *)(v368 + 3);
                  }
                  else {
                    v455 = 0;
                  }
                  int v456 = *v368;
                  if (v456 == 59) {
                    goto LABEL_1101;
                  }
                }
                do
                {
                  if ((v456 - 33) > 0xFFFFFFDF) {
                    break;
                  }
                  int v457 = *++v368;
                  int v456 = v457;
                }
                while (v457 != 59);
                goto LABEL_1101;
              }
LABEL_1213:
              v506 = v368 - 1;
              while (1)
              {
                int v507 = v425;
                int v425 = *((unsigned __int8 *)v506 + 2);
                if (v507 == 95 && v425 == 83)
                {
                  if (v506[3] == 83)
                  {
                    v509 = (unsigned __int8 *)(v506 + 1);
                    int v508 = *(unsigned __int8 *)v506;
                    if ((v508 - 48) >= 2)
                    {
                      size_t __nc = (size_t)(v506 + 1);
                      if (v508 == 67
                        && (strncmp(v506 - 2, "FRC", 3uLL) || (ctype[2 * *((unsigned __int8 *)v506 - 3)] & 0x40) != 0))
                      {
                        int v512 = strncmp(v506 - 4, "TRUNC", 5uLL);
                        v513 = (unsigned __int8 *)(v506 + 1);
                        if (v512) {
                          v513 = (unsigned __int8 *)v506;
                        }
                        size_t __nc = (size_t)v513;
                      }
                    }
                    else
                    {
                      int v511 = *((unsigned __int8 *)v506 - 1);
                      v510 = (unsigned __int8 *)(v506 - 1);
                      if (v511 == 67) {
                        v509 = v510;
                      }
                      size_t __nc = (size_t)v509;
                    }
                    goto LABEL_1079;
                  }
                  int v425 = 83;
                }
                ++v506;
                if ((ctype[2 * v425] & 0x40) == 0) {
                  goto LABEL_1078;
                }
              }
            }
            int v391 = v368[3];
            v368 += 3;
            LOBYTE(v383) = v391;
            if (v391)
            {
              if ((v383 - 33) < 0xE0u) {
                goto LABEL_892;
              }
              do
              {
LABEL_891:
                char v392 = *++v368;
                LOBYTE(v383) = v392;
              }
              while ((v392 - 33) > 0xDFu);
LABEL_892:
              while (v383 == 35)
              {
                ++v368;
                do
                {
                  LOBYTE(v383) = *v368;
                  if (!*v368) {
                    goto LABEL_945;
                  }
                  int v393 = *(v368++ - 1);
                }
                while (v393 != 10);
                --v368;
                if ((v383 - 33) >= 0xE0u) {
                  goto LABEL_891;
                }
              }
            }
LABEL_945:
            v637 = (arb *)((char *)&v648 + 12);
            __nb = &intKind;
            uint64_t v382 = 3;
            goto LABEL_865;
          case 'K':
            if (strncmp(v368, "KIL", 3uLL)) {
              goto LABEL_1076;
            }
            v647[1] |= 0x1000000u;
            char v384 = 1;
            int v425 = *v368;
            if ((ctype[2 * *v368] & 0x40) != 0) {
              goto LABEL_1213;
            }
            goto LABEL_1078;
          case 'L':
            if (!strncmp(v368, "LOOP", 4uLL)) {
              goto LABEL_1027;
            }
            if (strncmp(v368, "LONG", 4uLL)) {
              goto LABEL_1076;
            }
            int v397 = v368[4];
            v368 += 4;
            LOBYTE(v383) = v397;
            if (!v397) {
              goto LABEL_946;
            }
            if ((v383 - 33) >= 0xE0u) {
              goto LABEL_913;
            }
LABEL_914:
            if (v383 == 35)
            {
              ++v368;
              while (1)
              {
                LOBYTE(v383) = *v368;
                if (!*v368) {
                  break;
                }
                int v399 = *(v368++ - 1);
                if (v399 == 10)
                {
                  --v368;
                  if ((v383 - 33) >= 0xE0u)
                  {
                    do
                    {
LABEL_913:
                      char v398 = *++v368;
                      LOBYTE(v383) = v398;
                    }
                    while ((v398 - 33) > 0xDFu);
                  }
                  goto LABEL_914;
                }
              }
            }
LABEL_946:
            if ((v382 & 7u) >= 3uLL) {
              v408 = __nb;
            }
            else {
              v408 = &longKind;
            }
            v409 = v637;
            if ((v382 & 7u) < 3uLL) {
              v409 = (arb *)((char *)&v648 + 11);
            }
            v637 = v409;
            __nb = v408;
            if ((v382 & 7u) < 3uLL) {
              uint64_t v382 = 2;
            }
            goto LABEL_865;
          case 'M':
            v656 = 0;
            *(void *)&long long __dst = 0;
            v655 = 0;
            int v429 = strncmp(v368, "MULA", 4uLL);
            v431 = (arb *)(v368 + 4);
            if (v429) {
              v432 = 0;
            }
            else {
              v432 = (unsigned __int8 *)(v368 + 4);
            }
            *(void *)&long long __s1a = v432;
            if (v429 || (int v433 = *(unsigned __int8 *)v431, (v433 - 33) < 0xFFFFFFE0))
            {
              if (strncmp(i, "MOV", 3uLL) || *((unsigned __int8 *)i + 3) - 33 < 0xFFFFFFE0) {
                goto LABEL_1072;
              }
              int v434 = strncmp(v368, "MUL", 3uLL);
              uint64_t v435 = v434 ? 0 : (uint64_t)(v368 + 3);
              *(void *)&long long __s1a = v435;
              if (v434 || v368[3] - 33 < 0xFFFFFFE0) {
                goto LABEL_1072;
              }
              int v436 = *(unsigned __int8 *)v431;
              if (*(unsigned char *)v431)
              {
                if ((v436 - 33) < 0xFFFFFFE0) {
                  goto LABEL_1017;
                }
                do
                {
LABEL_1016:
                  int v437 = *((unsigned __int8 *)v431 + 1);
                  v431 = (arb *)((char *)v431 + 1);
                  int v436 = v437;
                }
                while ((v437 - 33) > 0xFFFFFFDF);
LABEL_1017:
                while (v436 == 35)
                {
                  v431 = (arb *)((char *)v431 + 1);
                  do
                  {
                    int v436 = *(unsigned __int8 *)v431;
                    if (!*(unsigned char *)v431) {
                      goto LABEL_1231;
                    }
                    int v438 = *((unsigned __int8 *)v431 - 1);
                    v431 = (arb *)((char *)v431 + 1);
                  }
                  while (v438 != 10);
                  v431 = (arb *)((char *)v431 - 1);
                  if ((v436 - 33) >= 0xFFFFFFE0) {
                    goto LABEL_1016;
                  }
                }
              }
LABEL_1231:
              v514 = arb::asymbol(v431, (char *)&__dst, (const char **)&v656, v367);
              if (v431 != (arb *)__dst) {
                goto LABEL_1072;
              }
              v515 = (const char *)v514;
              __ne = v656;
              if ((unsigned __int8 *)&v656[(void)v431] != v514)
              {
                v639 = (arb *)(v514 - 4);
                if (strncmp((const char *)v514 - 4, "xyzw", 4uLL))
                {
                  if (strncmp((const char *)v639, "rgba", 4uLL)
                    && strncmp(v515 - 3, "xyzw", 3uLL)
                    && strncmp(v515 - 3, "rgba", 3uLL))
                  {
                    goto LABEL_1072;
                  }
                }
              }
              *(void *)&long long __s1a = v515;
              if (!v515) {
                goto LABEL_1072;
              }
              int v516 = *(unsigned __int8 *)v515;
              if (!*v515) {
                goto LABEL_1072;
              }
              if ((v516 - 33) < 0xFFFFFFE0) {
                goto LABEL_1241;
              }
              do
              {
LABEL_1240:
                int v517 = *(unsigned __int8 *)++v515;
                int v516 = v517;
              }
              while ((v517 - 33) > 0xFFFFFFDF);
LABEL_1241:
              while (v516 == 35)
              {
                v518 = v515;
                do
                {
                  int v519 = *(unsigned __int8 *)++v518;
                  int v516 = v519;
                  if (!v519) {
                    goto LABEL_1072;
                  }
                  int v520 = *(unsigned __int8 *)v515;
                  v515 = v518;
                }
                while (v520 != 10);
                v515 = v518;
                if ((v516 - 33) >= 0xFFFFFFE0) {
                  goto LABEL_1240;
                }
              }
              if (v516 != 44) {
                goto LABEL_1072;
              }
              int v591 = *((unsigned __int8 *)v515 + 1);
              v590 = v515 + 1;
              int v589 = v591;
              if (v591)
              {
                if ((v589 - 33) < 0xFFFFFFE0) {
                  goto LABEL_1386;
                }
                do
                {
LABEL_1385:
                  int v592 = *(unsigned __int8 *)++v590;
                  int v589 = v592;
                }
                while ((v592 - 33) > 0xFFFFFFDF);
LABEL_1386:
                while (v589 == 35)
                {
                  ++v590;
                  do
                  {
                    int v589 = *(unsigned __int8 *)v590;
                    if (!*v590) {
                      goto LABEL_1392;
                    }
                    int v593 = *((unsigned __int8 *)v590++ - 1);
                  }
                  while (v593 != 10);
                  --v590;
                  if ((v589 - 33) >= 0xFFFFFFE0) {
                    goto LABEL_1385;
                  }
                }
              }
LABEL_1392:
              if (strncmp(v590, (const char *)v431, (size_t)__ne)) {
                goto LABEL_1072;
              }
              v594 = (arb *)&__ne[(void)v590];
              v595 = arb::achr(v594, (const char *)0x2E);
              if (v595)
              {
                v597 = arb::atok(v595, v596);
                if (strncmp(v597, "xyzw", 4uLL) && strncmp(v597, "rgba", 4uLL))
                {
LABEL_1072:
                  if (!(void)v653 || !arb::isunpremult((uint64_t)v650, v368, (uint64_t)i)) {
                    goto LABEL_1076;
                  }
LABEL_1074:
                  char v384 = 0;
                  v647[1] |= 0x10000000u;
                  *(void *)&long long v653 = 0;
                  int v425 = *v368;
                  if ((ctype[2 * *v368] & 0x40) != 0) {
                    goto LABEL_1213;
                  }
                  goto LABEL_1078;
                }
                v594 = (arb *)(v597 + 4);
              }
              v598 = arb::achr(v594, (const char *)0x2C);
              if (!v598) {
                goto LABEL_1072;
              }
              v599 = v598;
              if (strncmp(v598, (const char *)v431, (size_t)__ne)) {
                goto LABEL_1072;
              }
              v600 = arb::achr((arb *)&__ne[(void)v599], (const char *)0x2E);
              *(void *)&long long __s1a = v600;
              if (!v600) {
                goto LABEL_1072;
              }
              int v601 = *v600;
              if (v601 != 119 && v601 != 97) {
                goto LABEL_1072;
              }
              if (!arb::achr((arb *)(v600 + 1), (const char *)0x3B)) {
                goto LABEL_1072;
              }
              v603 = (arb *)arb::atok((unsigned char *)i + 4, v602);
              arb::asymbol(v603, (char *)&__s1a, (const char **)&v655, v604);
              v605 = v655;
              v640 = (arb *)__s1a;
              v606 = arb::obj_add((uint64_t)v650, (char *)__s1a, (const char **)v655, (uint64_t)v647, 1);
              if (!v606) {
                goto LABEL_1072;
              }
              if (*((unsigned char **)v606 + 5) != outputKind) {
                goto LABEL_1072;
              }
              if (*((_DWORD *)v606 + 14)) {
                goto LABEL_1072;
              }
              v607 = arb::achr((arb *)&v605[(void)v640], (const char *)0x2C);
              if (!v607) {
                goto LABEL_1072;
              }
              v608 = v607;
              if (strncmp(v607, (const char *)v431, (size_t)__ne)
                || !arb::achr((arb *)&__ne[(void)v608], (const char *)0x3B))
              {
                goto LABEL_1072;
              }
            }
            else
            {
              while (1)
              {
                if ((v433 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    int v445 = *((unsigned __int8 *)v431 + 1);
                    v431 = (arb *)((char *)v431 + 1);
                    int v433 = v445;
                  }
                  while ((v445 - 33) > 0xFFFFFFDF);
                }
                if (v433 != 35) {
                  break;
                }
                v431 = (arb *)((char *)v431 + 1);
                do
                {
                  int v433 = *(unsigned __int8 *)v431;
                  if (!*(unsigned char *)v431) {
                    goto LABEL_1071;
                  }
                  int v446 = *((unsigned __int8 *)v431 - 1);
                  v431 = (arb *)((char *)v431 + 1);
                }
                while (v446 != 10);
                v431 = (arb *)((char *)v431 - 1);
              }
LABEL_1071:
              v447 = arb::asymbol(v431, (char *)&__dst, (const char **)&v656, v430);
              if (v431 != (arb *)__dst) {
                goto LABEL_1072;
              }
              v504 = v447;
              __nd = v656;
              if ((unsigned __int8 *)&v656[(void)v431] != v447)
              {
                v638 = (arb *)(v447 - 4);
                if (strncmp((const char *)v447 - 4, "xyzw", 4uLL))
                {
                  if (strncmp((const char *)v638, "rgba", 4uLL)) {
                    goto LABEL_1072;
                  }
                }
              }
              if (!v504) {
                goto LABEL_1072;
              }
              v505 = arb::obj_add((uint64_t)v650, (char *)v431, (const char **)__nd, (uint64_t)v647, 1);
              if (!v505 || *((unsigned char **)v505 + 5) != outputKind || *((_DWORD *)v505 + 14)) {
                goto LABEL_1072;
              }
            }
            char v384 = 0;
            *((void *)&v651 + 1) = v368;
            v647[1] |= 0x20000000u;
            int v425 = *v368;
            if ((ctype[2 * *v368] & 0x40) == 0) {
              goto LABEL_1078;
            }
            goto LABEL_1213;
          case 'O':
            v418 = (unsigned __int8 *)(v368 + 6);
            if (!strncmp(v368, "OUTPUT", 6uLL))
            {
              if (arb::obj_decl((uint64_t)v650, outputKind, (arb *)(v368 + 6), v382, (uint64_t)v647)) {
                goto LABEL_848;
              }
              uint64_t v218 = 4294967245;
              *((void *)this + 1) = 0;
              *((void *)this + 2) = 0;
              *(void *)this = v3;
              v372 = v650[0];
              if (!v650[0]) {
                return v218;
              }
LABEL_832:
              free(v372);
              return v218;
            }
            if (strncmp(v368, "OPTION", 6uLL)) {
              goto LABEL_1076;
            }
            int v419 = *v418;
            if (*v418)
            {
              if ((v419 - 33) < 0xFFFFFFE0) {
                goto LABEL_979;
              }
              do
              {
LABEL_978:
                int v420 = *++v418;
                int v419 = v420;
              }
              while ((v420 - 33) > 0xFFFFFFDF);
LABEL_979:
              while (v419 == 35)
              {
                ++v418;
                do
                {
                  int v419 = *v418;
                  if (!*v418) {
                    goto LABEL_1063;
                  }
                  int v421 = *(v418++ - 1);
                }
                while (v421 != 10);
                --v418;
                if ((v419 - 33) >= 0xFFFFFFE0) {
                  goto LABEL_978;
                }
              }
            }
LABEL_1063:
            if (!strncmp((const char *)v418, "NV_fragment_program", 0x13uLL))
            {
              int v493 = v418[19];
              v492 = v418 + 19;
              int v491 = v493;
              int v494 = v493 - 58;
              if ((v493 - 58) >= 0xFFFFFFF6)
              {
                int v495 = 0;
                do
                {
                  int v495 = v491 + 10 * v495 - 48;
                  int v496 = *++v492;
                  int v491 = v496;
                }
                while ((v496 - 58) > 0xFFFFFFF5);
                int v654 = v495;
                int v497 = *v492;
                if (*v492)
                {
                  if ((v497 - 33) < 0xFFFFFFE0) {
                    goto LABEL_1195;
                  }
                  do
                  {
LABEL_1194:
                    int v498 = *++v492;
                    int v497 = v498;
                  }
                  while ((v498 - 33) > 0xFFFFFFDF);
LABEL_1195:
                  while (v497 == 35)
                  {
                    v499 = v492;
                    do
                    {
                      int v500 = *++v499;
                      int v497 = v500;
                      if (!v500) {
                        goto LABEL_1201;
                      }
                      int v501 = *v492;
                      v492 = v499;
                    }
                    while (v501 != 10);
                    v492 = v499;
                    if ((v497 - 33) >= 0xFFFFFFE0) {
                      goto LABEL_1194;
                    }
                  }
                }
              }
LABEL_1201:
              BOOL v502 = __CFADD__(v494, 10);
              int v503 = 394256;
              if (v502) {
                int v503 = 16 * v654 + 394240;
              }
              v647[0] = v503;
              goto LABEL_848;
            }
            if (!strncmp((const char *)v418, "ARB_precision_hint_fastest", 0x1AuLL))
            {
              v647[1] = v647[1] & 0x3FFFFFFF | 0x40000000;
              goto LABEL_848;
            }
            if (!strncmp((const char *)v418, "ARB_precision_hint_nicest", 0x19uLL))
            {
              v647[1] |= 0x80000000;
              goto LABEL_848;
            }
            if (strncmp((const char *)v418, "ARB_draw_buffers", 0x10uLL)
              && strncmp((const char *)v418, "ATI_draw_buffers", 0x10uLL))
            {
              if (!strncmp((const char *)v418, "NV_vertex_program", 0x11uLL))
              {
                int v579 = v418[17];
                v578 = v418 + 17;
                int v577 = v579;
                unsigned int v580 = v579 - 58;
                if ((v579 - 58) >= 0xFFFFFFF6)
                {
                  int v581 = 0;
                  do
                  {
                    int v581 = v577 + 10 * v581 - 48;
                    int v582 = *++v578;
                    int v577 = v582;
                  }
                  while ((v582 - 58) > 0xFFFFFFF5);
                  int v654 = v581;
                  int v583 = *v578;
                  if (*v578)
                  {
                    if ((v583 - 33) < 0xFFFFFFE0) {
                      goto LABEL_1372;
                    }
                    do
                    {
LABEL_1371:
                      int v584 = *++v578;
                      int v583 = v584;
                    }
                    while ((v584 - 33) > 0xFFFFFFDF);
LABEL_1372:
                    while (v583 == 35)
                    {
                      v585 = v578;
                      do
                      {
                        int v586 = *++v585;
                        int v583 = v586;
                        if (!v586) {
                          goto LABEL_1378;
                        }
                        int v587 = *v578;
                        v578 = v585;
                      }
                      while (v587 != 10);
                      v578 = v585;
                      if ((v583 - 33) >= 0xFFFFFFE0) {
                        goto LABEL_1371;
                      }
                    }
                  }
                }
LABEL_1378:
                if (v580 >= 0xFFFFFFF6) {
                  int v588 = 16 * v654 + 328704;
                }
                else {
                  int v588 = 328720;
                }
                v647[0] = v588;
                goto LABEL_848;
              }
              if (!strncmp((const char *)v418, "ARB_position_invariant", 0x16uLL))
              {
                v647[1] |= 0xC0000000;
                goto LABEL_848;
              }
LABEL_1091:
              v647[3] = 0;
            }
LABEL_848:
            v368 = (char *)i;
            if (!i)
            {
LABEL_1410:
              if (HIDWORD(v653))
              {
                HIDWORD(v653) = WORD4(v648);
                uint64_t v609 = arb::obj_key((char **)v650, "", 0);
                int v610 = WORD4(v648);
                ++WORD4(v648);
                v611 = (char *)v650[0] + 88 * v609;
                *((void *)v611 + 5) = &unk_1B7EC18D2;
                *((void *)v611 + 6) = 1;
                *((_DWORD *)v611 + 14) = v610;
                *((void *)v611 + 9) = 0;
                *((void *)v611 + 10) = 0;
                *((void *)v611 + 8) = 0;
              }
              unsigned int v612 = v647[1];
              v647[2] = (v647[2] & LOBYTE(v647[1]));
              v647[3] = (v647[3] & LOBYTE(v647[1]));
              v647[1] &= 0xFFFFFF00;
              if ((v647[3] & 1) == 0)
              {
                v647[1] = v612 & 0xEFFFFF00;
                *(void *)&long long v652 = 0;
              }
              arb::obj_write((int)v650, (uint64_t)this, (const HGLimits *)v647, v3);
              v614 = *(int **)this;
              size_t v613 = *((void *)this + 1);
              double v615 = HGDigestInit(&__dst);
              if (v613 >= 0x40)
              {
                size_t v618 = v613 >> 6;
                do
                {
                  HGDigestAdd(&__dst, v614);
                  v614 += 16;
                  --v618;
                }
                while (v618);
                v613 &= 0x3Fu;
              }
              if (v613)
              {
                memcpy(&__s1a, v614, v613);
                bzero((char *)&__s1a + v613, 64 - v613);
                HGDigestAdd(&__dst, (int *)&__s1a);
              }
              arb::end((string_t *)this, (uint64_t)v647, (unsigned int *)&__dst, v615, v616, v617);
              uint64_t v218 = 0;
              v372 = v650[0];
              if (!v650[0]) {
                return v218;
              }
              goto LABEL_832;
            }
            goto LABEL_849;
          case 'P':
            if (!strncmp(v368, "PARAM", 5uLL))
            {
              if (arb::obj_decl((uint64_t)v650, paramKind, (arb *)(v368 + 5), v382, (uint64_t)v647)) {
                goto LABEL_848;
              }
              uint64_t v218 = 4294967244;
              *((void *)this + 1) = 0;
              *((void *)this + 2) = 0;
              *(void *)this = v3;
              v372 = v650[0];
              if (!v650[0]) {
                return v218;
              }
              goto LABEL_832;
            }
            if (strncmp(v368, "NOPERSPECTIVE", 0xDuLL))
            {
              if (strncmp(v368, "PRIMITIVE_IN", 0xCuLL))
              {
                v426 = v368;
                v427 = "PRIMITIVE_OUT";
                size_t v428 = 13;
                goto LABEL_1037;
              }
              goto LABEL_848;
            }
            int v394 = v368[13];
            v368 += 13;
            LOBYTE(v383) = v394;
            if (v394)
            {
              if ((v383 - 33) < 0xE0u) {
                goto LABEL_903;
              }
              do
              {
LABEL_902:
                char v395 = *++v368;
                LOBYTE(v383) = v395;
              }
              while ((v395 - 33) > 0xDFu);
LABEL_903:
              while (v383 == 35)
              {
                ++v368;
                do
                {
                  LOBYTE(v383) = *v368;
                  if (!*v368) {
                    goto LABEL_865;
                  }
                  int v396 = *(v368++ - 1);
                }
                while (v396 != 10);
                --v368;
                if ((v383 - 33) >= 0xE0u) {
                  goto LABEL_902;
                }
              }
            }
LABEL_865:
            if (v368 == i) {
              goto LABEL_848;
            }
            continue;
          case 'R':
            if ((void)v653 && arb::isunpremult((uint64_t)v650, v368, (uint64_t)i)) {
              goto LABEL_1074;
            }
            if (strncmp(v368, "REP", 3uLL))
            {
              v426 = v368;
              v427 = "RET";
              size_t v428 = 3;
              goto LABEL_1037;
            }
LABEL_1027:
            ++v634;
            char v384 = 1;
            int v425 = *v368;
            if ((ctype[2 * *v368] & 0x40) != 0) {
              goto LABEL_1213;
            }
            goto LABEL_1078;
          case 'S':
            if (strncmp(v368, "SHORT", 5uLL)) {
              goto LABEL_1076;
            }
            int v403 = v368[5];
            v368 += 5;
            int v383 = v403;
            v404 = __nb;
            if ((v382 & 7u) < 3uLL) {
              v404 = &shortKind;
            }
            v405 = v637;
            if ((v382 & 7u) < 3uLL) {
              v405 = (arb *)((char *)&v648 + 10);
            }
            v637 = v405;
            __nb = v404;
            v382 |= (v382 & 7u) < 3uLL;
            if (!v383) {
              goto LABEL_865;
            }
            if ((v383 - 33) >= 0xE0u) {
              goto LABEL_938;
            }
LABEL_939:
            if (v383 == 35)
            {
              ++v368;
              while (1)
              {
                LOBYTE(v383) = *v368;
                if (!*v368) {
                  break;
                }
                int v407 = *(v368++ - 1);
                if (v407 == 10)
                {
                  --v368;
                  if ((v383 - 33) >= 0xE0u)
                  {
                    do
                    {
LABEL_938:
                      char v406 = *++v368;
                      LOBYTE(v383) = v406;
                    }
                    while ((v406 - 33) > 0xDFu);
                  }
                  goto LABEL_939;
                }
              }
            }
            goto LABEL_865;
          case 'T':
            if (strncmp(v368, "TEMP", 4uLL))
            {
              v417 = arb::obj_texop((uint64_t)v650, (char *)&v654, (arb *)v368, v634 == 0, (int8x8_t *)v647);
LABEL_993:
              if (v417) {
                goto LABEL_848;
              }
              char v384 = 0;
              int v425 = *v368;
              if ((ctype[2 * *v368] & 0x40) == 0) {
                goto LABEL_1078;
              }
              goto LABEL_1213;
            }
            int v441 = v368[4];
            v440 = (unsigned __int8 *)(v368 + 4);
            int v439 = v441;
            if (!v441) {
              goto LABEL_1247;
            }
            if ((v439 - 33) >= 0xFFFFFFE0) {
              goto LABEL_1042;
            }
            break;
          case 'U':
            if (strncmp(v368, "UINT", 4uLL)) {
              goto LABEL_1076;
            }
            int v388 = v368[4];
            v368 += 4;
            LOBYTE(v383) = v388;
            if (!v388) {
              goto LABEL_864;
            }
            if ((v383 - 33) >= 0xE0u) {
              goto LABEL_880;
            }
LABEL_881:
            if (v383 == 35)
            {
              ++v368;
              while (1)
              {
                LOBYTE(v383) = *v368;
                if (!*v368) {
                  break;
                }
                int v390 = *(v368++ - 1);
                if (v390 == 10)
                {
                  --v368;
                  if ((v383 - 33) >= 0xE0u)
                  {
                    do
                    {
LABEL_880:
                      char v389 = *++v368;
                      LOBYTE(v383) = v389;
                    }
                    while ((v389 - 33) > 0xDFu);
                  }
                  goto LABEL_881;
                }
              }
            }
LABEL_864:
            v637 = (arb *)((char *)&v648 + 13);
            __nb = &uintKind;
            uint64_t v382 = 4;
            goto LABEL_865;
          case 'V':
            v426 = v368;
            v427 = "VERTICES_OUT";
            size_t v428 = 12;
            goto LABEL_1037;
          default:
            goto LABEL_1077;
        }
        break;
      }
      while (1)
      {
        if (v439 != 35) {
          goto LABEL_1247;
        }
        ++v440;
        do
        {
          int v439 = *v440;
          if (!*v440)
          {
            while (1)
            {
LABEL_1247:
              v521 = 0;
              do
              {
                int v522 = *((unsigned __int8 *)v521 + (void)v440 + 1);
                v521 = (const char **)((char *)v521 + 1);
              }
              while ((ctype[2 * v522] & 0x40) != 0);
              if (!v522) {
                goto LABEL_1281;
              }
              v523 = (unsigned __int8 *)v521 + (void)v440;
              if ((v522 - 33) < 0xFFFFFFE0) {
                goto LABEL_1252;
              }
              do
              {
LABEL_1251:
                int v524 = *++v523;
                int v522 = v524;
              }
              while ((v524 - 33) > 0xFFFFFFDF);
LABEL_1252:
              while (v522 == 35)
              {
                v525 = v523;
                do
                {
                  int v526 = *++v525;
                  int v522 = v526;
                  if (!v526) {
                    goto LABEL_1281;
                  }
                  int v527 = *v523;
                  v523 = v525;
                }
                while (v527 != 10);
                v523 = v525;
                if ((v522 - 33) >= 0xFFFFFFE0) {
                  goto LABEL_1251;
                }
              }
              if (v522 != 91) {
                goto LABEL_1281;
              }
              int v530 = v523[1];
              v529 = v523 + 1;
              LOBYTE(v528) = v530;
              if (!v530) {
                goto LABEL_1281;
              }
              if ((v528 - 33) < 0xE0u) {
                goto LABEL_1262;
              }
              do
              {
LABEL_1261:
                char v531 = *++v529;
                LOBYTE(v528) = v531;
              }
              while ((v531 - 33) > 0xDFu);
LABEL_1262:
              while (v528 == 35)
              {
                v532 = v529;
                do
                {
                  int v533 = *++v532;
                  LOBYTE(v528) = v533;
                  if (!v533) {
                    goto LABEL_1281;
                  }
                  int v534 = *v529;
                  v529 = v532;
                }
                while (v534 != 10);
                v529 = v532;
                if ((v528 - 33) >= 0xE0u) {
                  goto LABEL_1261;
                }
              }
              if ((v528 - 58) < 0xF6u) {
                goto LABEL_1281;
              }
              LODWORD(v631) = 0;
              do
              {
                uint64_t v631 = 10 * v631 + v528 - 48;
                int v535 = *++v529;
                int v528 = v535;
              }
              while ((v535 - 58) > 0xF5u);
              if (!v528) {
                goto LABEL_1281;
              }
              if ((v528 - 33) < 0xE0u) {
                goto LABEL_1274;
              }
              do
              {
LABEL_1273:
                char v536 = *++v529;
                LOBYTE(v528) = v536;
              }
              while ((v536 - 33) > 0xDFu);
LABEL_1274:
              while (v528 == 35)
              {
                v537 = v529;
                do
                {
                  int v538 = *++v537;
                  LOBYTE(v528) = v538;
                  if (!v538) {
                    goto LABEL_1281;
                  }
                  int v539 = *v529;
                  v529 = v537;
                }
                while (v539 != 10);
                v529 = v537;
                if ((v528 - 33) >= 0xE0u) {
                  goto LABEL_1273;
                }
              }
              if (!(_BYTE)v528) {
                goto LABEL_1281;
              }
              while (1)
              {
                if ((v528 - 33) >= 0xE0u)
                {
                  do
                  {
                    char v560 = *++v529;
                    LOBYTE(v528) = v560;
                  }
                  while ((v560 - 33) > 0xDFu);
                }
                if (v528 != 35) {
                  break;
                }
                v561 = v529;
                do
                {
                  int v562 = *++v561;
                  LOBYTE(v528) = v562;
                  if (!v562) {
                    goto LABEL_1281;
                  }
                  int v563 = *v529;
                  v529 = v561;
                }
                while (v563 != 10);
                v529 = v561;
              }
              if (v528 == 93)
              {
                ptr = (char *)v650[0];
                unint64_t v620 = (unint64_t)v650[1];
                v622 = (char *)v650[0] + 88 * (uint64_t)v650[1];
                if (!v650[1]) {
                  goto LABEL_1339;
                }
                unint64_t v623 = (unint64_t)v650[1];
                v628 = (char *)v650[0];
                while (1)
                {
                  *(void *)&long long __s1a = v440;
                  unint64_t v621 = v623 >> 1;
                  v624 = &v628[88 * (v623 >> 1)];
                  int v564 = arb::ascan((unsigned __int8 **)&__s1a, v521, (unsigned __int8 *)v624, (const char *)1);
                  if (!v564) {
                    break;
                  }
                  v565 = v622;
                  v566 = (char *)(v623 - (v621 + 1));
                  if (v564 <= 0) {
                    v565 = &v628[88 * (v623 >> 1)];
                  }
                  v622 = v565;
                  if (v564 > 0) {
                    unint64_t v567 = v621 + 1;
                  }
                  else {
                    unint64_t v567 = 0;
                  }
                  v628 += 88 * v567;
                  if (v564 <= 0) {
                    v566 = (char *)(v623 >> 1);
                  }
                  unint64_t v623 = (unint64_t)v566;
                  if (!v566) {
                    goto LABEL_1339;
                  }
                }
                if (!v628)
                {
LABEL_1339:
                  if (v620 + 1 <= (unint64_t)v651
                    || (unint64_t v625 = (v620 & 0xFFFFFFFFFFFFFFF0) + 16, (void)v651 == v625))
                  {
                    v629 = ptr;
                  }
                  else
                  {
                    *(void *)&long long v651 = (v620 & 0xFFFFFFFFFFFFFFF0) + 16;
                    v629 = (char *)malloc_type_realloc(ptr, 88 * v625, 0x10500400A17BEF8uLL);
                    v650[0] = v629;
                    unint64_t v568 = v620;
                    if (v620 >= v625) {
                      unint64_t v568 = (v620 & 0xFFFFFFFFFFFFFFF0) + 16;
                    }
                    unint64_t v620 = v568;
                  }
                  unint64_t v626 = 0x2E8BA2E8BA2E8BA3 * ((v622 - ptr) >> 3);
                  if (v620 > v626) {
                    memmove(&v629[8 * ((v622 - ptr) >> 3) + 88], &v629[8 * ((v622 - ptr) >> 3)], 88 * (v620 - v626));
                  }
                  v650[1] = (void *)(v620 + 1);
                  v624 = &v629[8 * ((v622 - ptr) >> 3)];
                  uint64_t v569 = 0;
                  if (v521)
                  {
                    unint64_t v570 = 0;
                    do
                    {
                      int v571 = v440[v570];
                      if ((v571 - 33) > 0xFFFFFFDF)
                      {
                        v572 = &v440[++v570];
                        if (v440[v570] == 35)
                        {
LABEL_1355:
                          int v573 = 35;
                          while (v573 == 35)
                          {
                            ++v572;
                            do
                            {
                              int v573 = *v572;
                              if (!*v572) {
                                goto LABEL_1349;
                              }
                              int v575 = *(v572++ - 1);
                            }
                            while (v575 != 10);
                            --v572;
                            if ((v573 - 33) >= 0xFFFFFFE0)
                            {
                              do
                              {
                                int v574 = *++v572;
                                int v573 = v574;
                              }
                              while ((v574 - 33) > 0xFFFFFFDF);
                            }
                          }
LABEL_1349:
                          unint64_t v570 = v572 - v440;
                        }
                      }
                      else
                      {
                        v624[v569++] = v571;
                        v572 = &v440[++v570];
                        if (v440[v570] == 35) {
                          goto LABEL_1355;
                        }
                      }
                    }
                    while (v570 < (unint64_t)v521);
                  }
                  v624[v569] = 0;
                }
                int v576 = WORD1(v649);
                *((void *)v624 + 5) = &arrayKind;
                *((void *)v624 + 6) = 2;
                *((_DWORD *)v624 + 14) = v576;
                *((void *)v624 + 8) = 0;
                *((void *)v624 + 9) = v631;
                *((void *)v624 + 10) = v382;
                WORD1(v649) = v576 + v631;
                v548 = (unsigned __int8 *)v521 + (void)(v529 + 1);
                int v549 = *v548;
                if (!*v548) {
                  goto LABEL_848;
                }
              }
              else
              {
LABEL_1281:
                BOOL v543 = __nb == &shortKind || __nb == &longKind || __nb == &intKind || __nb == &uintKind;
                uint64_t v544 = arb::obj_key((char **)v650, v440, v521);
                if (v543)
                {
                  uint64_t v545 = 1;
                  if (*((unsigned char *)__nb + 1)) {
                    uint64_t v545 = 2;
                  }
                  int v546 = *(unsigned __int8 *)v637;
                  *(unsigned char *)v637 = v546 + 1;
                  v547 = (char *)v650[0] + 88 * v544;
                  *((void *)v547 + 5) = __nb;
                  *((void *)v547 + 6) = v545;
                  *((_DWORD *)v547 + 14) = v546;
                  *((void *)v547 + 8) = 0;
                  *((void *)v547 + 9) = 0;
                  *((void *)v547 + 10) = v382;
                  v548 = (unsigned __int8 *)v521 + (void)v440;
                  int v549 = *v548;
                  if (!*v548) {
                    goto LABEL_848;
                  }
                }
                else
                {
                  int v550 = WORD4(v648);
                  ++WORD4(v648);
                  v551 = (char *)v650[0] + 88 * v544;
                  *((void *)v551 + 5) = &unk_1B7EC18D2;
                  *((void *)v551 + 6) = 1;
                  *((_DWORD *)v551 + 14) = v550;
                  *((void *)v551 + 8) = 0;
                  *((void *)v551 + 9) = 0;
                  *((void *)v551 + 10) = v382;
                  __nb = &unk_1B7EC18D2;
                  v548 = (unsigned __int8 *)v521 + (void)v440;
                  int v549 = *v548;
                  if (!*v548) {
                    goto LABEL_848;
                  }
                }
              }
              if ((v549 - 33) < 0xFFFFFFE0) {
                goto LABEL_1301;
              }
              do
              {
LABEL_1300:
                int v552 = *++v548;
                int v549 = v552;
              }
              while ((v552 - 33) > 0xFFFFFFDF);
LABEL_1301:
              while (v549 == 35)
              {
                v553 = v548;
                do
                {
                  int v554 = *++v553;
                  int v549 = v554;
                  if (!v554) {
                    goto LABEL_848;
                  }
                  int v555 = *v548;
                  v548 = v553;
                }
                while (v555 != 10);
                v548 = v553;
                if ((v549 - 33) >= 0xFFFFFFE0) {
                  goto LABEL_1300;
                }
              }
              if (v549 != 44) {
                goto LABEL_848;
              }
              int v557 = v548[1];
              v440 = v548 + 1;
              int v556 = v557;
              if (v557)
              {
                if ((v556 - 33) < 0xFFFFFFE0) {
                  goto LABEL_1311;
                }
                do
                {
LABEL_1310:
                  int v558 = *++v440;
                  int v556 = v558;
                }
                while ((v558 - 33) > 0xFFFFFFDF);
LABEL_1311:
                while (v556 == 35)
                {
                  ++v440;
                  do
                  {
                    int v556 = *v440;
                    if (!*v440) {
                      goto LABEL_1247;
                    }
                    int v559 = *(v440++ - 1);
                  }
                  while (v559 != 10);
                  --v440;
                  if ((v556 - 33) >= 0xFFFFFFE0) {
                    goto LABEL_1310;
                  }
                }
              }
            }
          }
          int v443 = *(v440++ - 1);
        }
        while (v443 != 10);
        --v440;
        if ((v439 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_1042:
            int v442 = *++v440;
            int v439 = v442;
          }
          while ((v442 - 33) > 0xFFFFFFDF);
          continue;
        }
      }
    }
  }
LABEL_19:
  int v18 = header(__s1, v647);
  unsigned int v19 = v647[0];
  if (v647[0])
  {
    if ((v647[0] & 0xFF00) == 0xB00) {
      goto LABEL_21;
    }
LABEL_491:
    if (!v18) {
      goto LABEL_521;
    }
    while (1)
    {
      do
      {
LABEL_506:
        v219 = v18;
        v220 = v18 + 1;
        int v221 = *v18++;
      }
      while ((v221 - 33) >= 0xFFFFFFE0);
      if (v221 != 47) {
        break;
      }
      int v222 = *v220;
      if (v222 == 42)
      {
        int v18 = v219 + 2;
        if (v219[2])
        {
          do
          {
            if (*(v220 - 1) == 42 && *v220 == 47) {
              break;
            }
            int v225 = v220[2];
            ++v220;
          }
          while (v225);
          int v18 = v220 + 1;
        }
      }
      else
      {
        if (v222 != 47) {
          goto LABEL_537;
        }
        v223 = v219 + 2;
        while (*v223)
        {
          int v224 = *(v223 - 1);
          int v18 = v223++;
          if (v224 == 10) {
            goto LABEL_506;
          }
        }
        int v18 = v223;
      }
    }
LABEL_535:
    if (!v221) {
      v219 = 0;
    }
LABEL_537:
    unsigned int v231 = 0;
    __int16 v636 = 0;
    unsigned int v627 = BYTE10(v649);
    unsigned int v632 = v647[1];
    unsigned int v633 = WORD2(v649);
    unsigned __int16 __na = WORD3(v648);
    unsigned int v630 = BYTE8(v649);
    int v635 = WORD2(v648);
    v232 = v219;
    while (1)
    {
      v233 = v232;
      while (1)
      {
        do
        {
LABEL_540:
          v234 = v233;
          v236 = v233 + 1;
          int v235 = *v233++;
        }
        while ((v235 - 33) >= 0xFFFFFFE0);
        if (v235 != 47) {
          break;
        }
        int v237 = *v236;
        if (v237 == 42)
        {
          v233 = v234 + 2;
          if (v234[2])
          {
            do
            {
              if (*(v236 - 1) == 42 && *v236 == 47) {
                break;
              }
              int v240 = v236[2];
              ++v236;
            }
            while (v240);
            v233 = v236 + 1;
          }
        }
        else
        {
          if (v237 != 47) {
            goto LABEL_555;
          }
          v238 = v234 + 2;
          while (*v238)
          {
            int v239 = *(v238 - 1);
            v233 = v238++;
            if (v239 == 10) {
              goto LABEL_540;
            }
          }
          v233 = v238;
        }
      }
      if (!v235)
      {
        WORD3(v648) = __na + 4 * (v636 + v231);
        HIDWORD(v649) = 16 * WORD3(v648);
        int v296 = v19 | 0x60600;
        if (v19 >= 0x100 && (int v296 = v19, (_BYTE)v19))
        {
          LOBYTE(v297) = v647[0];
          uint64_t v299 = *((void *)this + 1);
          uint64_t v298 = *((void *)this + 2);
          unint64_t v300 = v299 + 6;
          if ((v647[0] & 0xFFFFFF00) != 0x50600) {
            goto LABEL_769;
          }
LABEL_776:
          if (v298)
          {
            if (v300 >= *(void *)v298)
            {
              v303 = malloc_type_realloc(*(void **)(v298 + 16), (v299 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v304 = (unint64_t *)*((void *)this + 2);
              v304[2] = (unint64_t)v303;
              unint64_t *v304 = (v299 + 261) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v303;
            }
          }
          else
          {
            str_alloc((string_t *)this, v300);
          }
          uint64_t v308 = *(void *)this;
          *((void *)this + 1) += 6;
          uint64_t v306 = v308 + v299;
          __int16 v307 = 29558;
        }
        else
        {
          if ((_BYTE)v296) {
            int v297 = v296;
          }
          else {
            int v297 = v296 | 0x10;
          }
          v647[0] = v297;
          uint64_t v299 = *((void *)this + 1);
          uint64_t v298 = *((void *)this + 2);
          unint64_t v300 = v299 + 6;
          if ((v297 & 0xFFFFFF00) == 0x50600) {
            goto LABEL_776;
          }
LABEL_769:
          if (v298)
          {
            if (v300 >= *(void *)v298)
            {
              v301 = malloc_type_realloc(*(void **)(v298 + 16), (v299 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v302 = (unint64_t *)*((void *)this + 2);
              v302[2] = (unint64_t)v301;
              unint64_t *v302 = (v299 + 261) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v301;
            }
          }
          else
          {
            str_alloc((string_t *)this, v300);
          }
          uint64_t v305 = *(void *)this;
          *((void *)this + 1) += 6;
          uint64_t v306 = v305 + v299;
          __int16 v307 = 29542;
        }
        *(_WORD *)(v306 + 4) = v307;
        *(_DWORD *)uint64_t v306 = 1279733551;
        uint64_t v310 = *((void *)this + 1);
        uint64_t v309 = *((void *)this + 2);
        unint64_t v311 = v310 + 20;
        if (v309)
        {
          if (v311 >= *(void *)v309)
          {
            v312 = malloc_type_realloc(*(void **)(v309 + 16), (v310 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v313 = (unint64_t *)*((void *)this + 2);
            v313[2] = (unint64_t)v312;
            unint64_t *v313 = (v310 + 275) & 0xFFFFFFFFFFFFFF00;
            *(void *)this = v312;
          }
        }
        else
        {
          str_alloc((string_t *)this, v311);
        }
        uint64_t v314 = itoa((char *)(*(void *)this + v310), v297 >> 4);
        uint64_t v315 = *((void *)this + 2);
        uint64_t v316 = *((void *)this + 1) + v314;
        *((void *)this + 1) = v316;
        unint64_t v317 = v316 + 1;
        if (v315)
        {
          if (v317 >= *(void *)v315)
          {
            v318 = malloc_type_realloc(*(void **)(v315 + 16), (v316 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
            v319 = (void *)*((void *)this + 2);
            v319[2] = v318;
            void *v319 = (v316 & 0xFFFFFFFFFFFFFF00) + 256;
            *(void *)this = v318;
          }
        }
        else
        {
          str_alloc((string_t *)this, v317);
        }
        uint64_t v320 = *(void *)this;
        ++*((void *)this + 1);
        *(unsigned char *)(v320 + v316) = 46;
        signed int v321 = v647[0] & 0xF;
        uint64_t v323 = *((void *)this + 1);
        uint64_t v322 = *((void *)this + 2);
        unint64_t v324 = v323 + 20;
        if (v322)
        {
          if (v324 >= *(void *)v322)
          {
            v325 = malloc_type_realloc(*(void **)(v322 + 16), (v323 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v326 = (unint64_t *)*((void *)this + 2);
            v326[2] = (unint64_t)v325;
            unint64_t *v326 = (v323 + 275) & 0xFFFFFFFFFFFFFF00;
            *(void *)this = v325;
          }
        }
        else
        {
          str_alloc((string_t *)this, v324);
        }
        uint64_t v327 = itoa((char *)(*(void *)this + v323), v321);
        uint64_t v328 = *((void *)this + 2);
        uint64_t v329 = *((void *)this + 1) + v327;
        *((void *)this + 1) = v329;
        if (v328)
        {
          if (*(void *)v328 <= 0xFuLL)
          {
            v330 = malloc_type_realloc(*(void **)(v328 + 16), 0x100uLL, 0xCCCD1039uLL);
            v331 = (void *)*((void *)this + 2);
            v331[2] = v330;
            void *v331 = 256;
            *(void *)this = v330;
          }
        }
        else
        {
          str_alloc((string_t *)this, 15);
        }
        uint64_t v332 = *(void *)this;
        *((void *)this + 1) += 15 - v329;
        memcpy((void *)(v332 + v329), "               ", 15 - v329);
        uint64_t v334 = *((void *)this + 1);
        uint64_t v333 = *((void *)this + 2);
        unint64_t v335 = v334 + 1;
        if (v333)
        {
          if (v335 >= *(void *)v333)
          {
            v336 = malloc_type_realloc(*(void **)(v333 + 16), (v334 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
            v337 = (void *)*((void *)this + 2);
            v337[2] = v336;
            void *v337 = (v334 & 0xFFFFFFFFFFFFFF00) + 256;
            *(void *)this = v336;
          }
        }
        else
        {
          str_alloc((string_t *)this, v335);
        }
        uint64_t v338 = *(void *)this;
        ++*((void *)this + 1);
        *(unsigned char *)(v338 + v334) = 10;
        uint64_t v340 = *((void *)this + 1);
        uint64_t v339 = *((void *)this + 2);
        unint64_t v341 = v340 + 17;
        if (v339)
        {
          if (v341 >= *(void *)v339)
          {
            v342 = malloc_type_realloc(*(void **)(v339 + 16), (v340 + 272) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v343 = (unint64_t *)*((void *)this + 2);
            v343[2] = (unint64_t)v342;
            unint64_t *v343 = (v340 + 272) & 0xFFFFFFFFFFFFFF00;
            *(void *)this = v342;
          }
        }
        else
        {
          str_alloc((string_t *)this, v341);
        }
        uint64_t v344 = *(void *)this;
        *((void *)this + 1) += 17;
        uint64_t v345 = v344 + v340;
        *(_OWORD *)uint64_t v345 = *(_OWORD *)"//LEN=0000000000\n";
        *(unsigned char *)(v345 + 16) = 10;
        uint64_t v347 = *((void *)this + 1);
        uint64_t v346 = *((void *)this + 2);
        unint64_t v348 = v347 + v232 - v219;
        if (v346)
        {
          if (v348 >= *(void *)v346)
          {
            size_t v349 = (v348 + 255) & 0xFFFFFFFFFFFFFF00;
            v350 = malloc_type_realloc(*(void **)(v346 + 16), v349, 0xCCCD1039uLL);
            v351 = (size_t *)*((void *)this + 2);
            v351[2] = (size_t)v350;
            size_t *v351 = v349;
            *(void *)this = v350;
          }
        }
        else
        {
          str_alloc((string_t *)this, v348);
        }
        uint64_t v352 = *(void *)this;
        *((void *)this + 1) += v232 - v219;
        memcpy((void *)(v352 + v347), v219, v232 - v219);
        if (*(v232 - 1) != 10)
        {
          uint64_t v354 = *((void *)this + 1);
          uint64_t v353 = *((void *)this + 2);
          unint64_t v355 = v354 + 1;
          if (v353)
          {
            if (v355 >= *(void *)v353)
            {
              v356 = malloc_type_realloc(*(void **)(v353 + 16), (v354 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v357 = (void *)*((void *)this + 2);
              v357[2] = v356;
              void *v357 = (v354 & 0xFFFFFFFFFFFFFF00) + 256;
              *(void *)this = v356;
            }
          }
          else
          {
            str_alloc((string_t *)this, v355);
          }
          uint64_t v358 = *(void *)this;
          ++*((void *)this + 1);
          *(unsigned char *)(v358 + v354) = 10;
        }
        v360 = *(int **)this;
        size_t v359 = *((void *)this + 1);
        double v361 = HGDigestInit(&__dst);
        if (v359 >= 0x40)
        {
          size_t v364 = v359 >> 6;
          do
          {
            HGDigestAdd(&__dst, v360);
            v360 += 16;
            --v364;
          }
          while (v364);
          v359 &= 0x3Fu;
        }
        if (v359)
        {
          memcpy(&__s1a, v360, v359);
          bzero((char *)&__s1a + v359, 64 - v359);
          HGDigestAdd(&__dst, (int *)&__s1a);
        }
        glsl::end((string_t *)this, (uint64_t)v647, (unsigned int *)&__dst, 0, v361, v362, v363);
        return 0;
      }
LABEL_555:
      LODWORD(__s1a) = 0;
      uint64_t v241 = *v234;
      if (v241 == 103)
      {
        if (*v236 != 108 || v234[2] != 95) {
          goto LABEL_594;
        }
        if (!strncmp((const char *)v234 + 3, "TextureMatrix", 0xDuLL))
        {
          unsigned int v259 = v19 & 0xFFFFFF00;
          unsigned int v19 = v19 & 0xFFFFFF00 | 0x10;
          v647[0] = v259 | 0x10;
          LODWORD(__s1a) = 0;
          v260 = glsl::glindex((glsl *)(v234 + 16), (char *)&__s1a, v244);
          if (v260) {
            v236 = v260;
          }
          else {
            v236 = v234 + 16;
          }
          if ((int)__s1a + 1 > v231) {
            unsigned int v231 = __s1a + 1;
          }
          v632 |= 0x8000000u;
          v647[1] = v632;
          goto LABEL_674;
        }
        v236 = v234 + 11;
        if (!strncmp((const char *)v234 + 3, "TexCoord", 8uLL))
        {
          unsigned int v266 = v19 & 0xFFFFFF00;
          unsigned int v19 = v19 & 0xFFFFFF00 | 0x10;
          v647[0] = v266 | 0x10;
          LODWORD(__s1a) = 0;
          v267 = glsl::glindex((glsl *)(v234 + 11), (char *)&__s1a, v245);
          if (v267) {
            v236 = v267;
          }
          if ((int)__s1a + 1 > v633) {
            unsigned __int16 v268 = __s1a + 1;
          }
          else {
            unsigned __int16 v268 = v633;
          }
          unsigned int v633 = v268;
          WORD2(v649) = v268;
          goto LABEL_674;
        }
        if (!strncmp((const char *)v234 + 3, "MultiTexCoord", 0xDuLL))
        {
          v647[0] = 329232;
          LODWORD(__s1a) = 0;
          v275 = glsl::glindex((glsl *)(v234 + 16), (char *)&__s1a, v246);
          if (v275) {
            v236 = v275;
          }
          else {
            v236 = v234 + 16;
          }
          if ((int)__s1a + 1 > v633) {
            unsigned __int16 v276 = __s1a + 1;
          }
          else {
            unsigned __int16 v276 = v633;
          }
          unsigned int v633 = v276;
          WORD2(v649) = v276;
          unsigned int v19 = 329232;
          goto LABEL_674;
        }
        if (!strncmp((const char *)v234 + 3, "ModelViewProjectionMatrix", 0x19uLL))
        {
          v236 = v234 + 28;
          unsigned int v19 = v19 & 0xFFFFFF00 | 0x10;
          v647[0] = v19;
          v647[1] = v632 | 0x8000000;
          v632 |= 0x8000000u;
LABEL_713:
          __int16 v636 = 1;
          goto LABEL_674;
        }
        if (!strncmp((const char *)v234 + 3, "Position", 8uLL))
        {
          v647[0] = 329232;
          unsigned int v19 = 329232;
          goto LABEL_674;
        }
        if (!strncmp((const char *)v234 + 3, "Vertex", 6uLL) || !strncmp((const char *)v234 + 3, "Normal", 6uLL))
        {
          v647[0] = 329232;
          unsigned int v19 = 329232;
          v236 = v234 + 9;
          goto LABEL_674;
        }
        if (!strncmp((const char *)v234 + 3, "FrontFacing", 0xBuLL))
        {
          v236 = v234 + 14;
          unsigned int v19 = v19 | 0x60600;
          v647[0] = v19;
          goto LABEL_674;
        }
        v232 = v234 + 12;
        if (!strncmp((const char *)v234 + 3, "FragDepth", 9uLL) || !strncmp((const char *)v234 + 3, "FragCoord", 9uLL))
        {
          unsigned int v19 = v19 | 0x60600;
          v647[0] = v19;
          v236 = v234 + 12;
          goto LABEL_674;
        }
        if (strncmp((const char *)v234 + 3, "FragColor", 9uLL))
        {
          if (!strncmp((const char *)v234 + 3, "FragData", 8uLL))
          {
            int v294 = v19;
            unsigned int v19 = v19 | 0x60600;
            v647[0] = v294 | 0x60600;
            LODWORD(__s1a) = 0;
            v295 = glsl::glindex((glsl *)(v234 + 11), (char *)&__s1a, v247);
            if (v295)
            {
              if ((int)__s1a + 1 > v627)
              {
                unsigned int v627 = (__s1a + 1);
                BYTE10(v649) = __s1a + 1;
              }
              v236 = v295;
            }
          }
          else
          {
            v236 = v234 + 2;
            do
              unsigned int v248 = *++v236;
            while (v248 > 0x20);
          }
          goto LABEL_674;
        }
        unsigned int v19 = v19 | 0x60600;
        v647[0] = v19;
        if (!v627)
        {
          unsigned int v627 = 1;
          BYTE10(v649) = 1;
        }
      }
      else if (v241 == 104)
      {
        if (*v236 == 103 && v234[2] == 95)
        {
          v236 = v234 + 3;
          v242 = v234 + 16;
          if (!strncmp((const char *)v234 + 3, "TextureMatrix", 0xDuLL))
          {
            unsigned int v19 = 329248;
            v647[0] = 329248;
            LODWORD(__s1a) = 0;
            int v256 = *v242;
            if ((v256 - 58) >= 0xFFFFFFF6)
            {
              int v257 = 0;
              v258 = v234 + 16;
              do
              {
                int v257 = v256 + 10 * v257 - 48;
                int v269 = *++v258;
                int v256 = v269;
              }
              while ((v269 - 58) > 0xFFFFFFF5);
              LODWORD(__s1a) = v257;
            }
            else
            {
              int v257 = 0;
              v258 = 0;
            }
            if (v258) {
              v232 = v258;
            }
            else {
              v232 = v234 + 16;
            }
            if (v257 + 1 > v231) {
              unsigned int v231 = v257 + 1;
            }
          }
          else if (!strncmp((const char *)v234 + 3, "Texture", 7uLL))
          {
            int v263 = v234[10];
            v262 = v234 + 10;
            int v261 = v263;
            unsigned int v19 = v19 | 0x60600;
            v647[0] = v19;
            LODWORD(__s1a) = 0;
            if ((v263 - 58) >= 0xFFFFFFF6)
            {
              int v264 = 0;
              v265 = v262;
              do
              {
                int v264 = v261 + 10 * v264 - 48;
                int v277 = *++v265;
                int v261 = v277;
              }
              while ((v277 - 58) > 0xFFFFFFF5);
              LODWORD(__s1a) = v264;
            }
            else
            {
              int v264 = 0;
              v265 = 0;
            }
            if (v265) {
              v232 = v265;
            }
            else {
              v232 = v262;
            }
            if (v264 + 1 > v630) {
              unsigned __int8 v278 = v264 + 1;
            }
            else {
              unsigned __int8 v278 = v630;
            }
            unsigned int v630 = v278;
            BYTE8(v649) = v278;
          }
          else
          {
            if (!strncmp((const char *)v234 + 3, "TexCoord", 8uLL))
            {
              int v272 = v234[11];
              v271 = v234 + 11;
              int v270 = v272;
              unsigned int v19 = v19 & 0xFFFFFF00 | 0x20;
              v647[0] = v19;
              LODWORD(__s1a) = 0;
              if ((v272 - 58) >= 0xFFFFFFF6)
              {
                int v273 = 0;
                v274 = v271;
                do
                {
                  int v273 = v270 + 10 * v273 - 48;
                  int v284 = *++v274;
                  int v270 = v284;
                }
                while ((v284 - 58) > 0xFFFFFFF5);
                LODWORD(__s1a) = v273;
              }
              else
              {
                int v273 = 0;
                v274 = 0;
              }
              if (v274) {
                v285 = v274;
              }
              else {
                v285 = v271;
              }
              if (v273 + 1 > v633) {
                unsigned __int16 v286 = v273 + 1;
              }
              else {
                unsigned __int16 v286 = v633;
              }
              goto LABEL_723;
            }
            if (!strncmp((const char *)v234 + 3, "ProgramLocal", 0xCuLL))
            {
              int v281 = v234[15];
              v280 = v234 + 15;
              int v279 = v281;
              if ((v281 - 58) >= 0xFFFFFFF6)
              {
                int v282 = 0;
                v283 = v280;
                do
                {
                  int v282 = v279 + 10 * v282 - 48;
                  int v287 = *++v283;
                  int v279 = v287;
                }
                while ((v287 - 58) > 0xFFFFFFF5);
                LODWORD(__s1a) = v282;
              }
              else
              {
                int v282 = 0;
                v283 = 0;
              }
              if (v283) {
                v232 = v283;
              }
              else {
                v232 = v280;
              }
              if (v282 + 1 > __na) {
                unsigned __int16 v288 = v282 + 1;
              }
              else {
                unsigned __int16 v288 = __na;
              }
              unsigned __int16 __na = v288;
              WORD3(v648) = v288;
            }
            else
            {
              if (!strncmp((const char *)v234 + 3, "Position", 8uLL))
              {
                unsigned int v19 = 329248;
                v647[0] = 329248;
                goto LABEL_674;
              }
              if (strncmp((const char *)v234 + 3, "MultiTexCoord", 0xDuLL))
              {
                if (!strncmp((const char *)v234 + 3, "ProjectionMatrix", 0x10uLL))
                {
                  v236 = v234 + 19;
                  unsigned int v19 = 329248;
                  v647[0] = 329248;
                  goto LABEL_713;
                }
                v236 = v234 + 2;
                do
                  unsigned int v243 = *++v236;
                while (v243 > 0x20);
                goto LABEL_674;
              }
              unsigned int v19 = 329248;
              v647[0] = 329248;
              LODWORD(__s1a) = 0;
              int v289 = *v242;
              if ((v289 - 58) >= 0xFFFFFFF6)
              {
                int v290 = 0;
                v291 = v234 + 16;
                unsigned int v292 = v633;
                do
                {
                  int v290 = v289 + 10 * v290 - 48;
                  int v293 = *++v291;
                  int v289 = v293;
                }
                while ((v293 - 58) > 0xFFFFFFF5);
                LODWORD(__s1a) = v290;
              }
              else
              {
                int v290 = 0;
                v291 = 0;
                unsigned int v292 = v633;
              }
              if (v291) {
                v285 = v291;
              }
              else {
                v285 = v234 + 16;
              }
              if (v290 + 1 > v292) {
                unsigned __int16 v286 = v290 + 1;
              }
              else {
                unsigned __int16 v286 = v292;
              }
LABEL_723:
              unsigned int v633 = v286;
              WORD2(v649) = v286;
              v232 = v285;
            }
          }
        }
        else
        {
LABEL_594:
          if (!strncmp((const char *)v234, "texture2DRectLodOffset", 0x16uLL))
          {
            v236 = v234 + 22;
            goto LABEL_674;
          }
          if (!strncmp((const char *)v234, "texture2DRectOffset", 0x13uLL))
          {
            v236 = v234 + 19;
            goto LABEL_674;
          }
          v250 = v234 + 16;
          if (!strncmp((const char *)v234, "texture2DRectLod", 0x10uLL))
          {
            v236 = v234 + 16;
            goto LABEL_674;
          }
          if (!strncmp((const char *)v234, "texture2DRect", 0xDuLL))
          {
LABEL_662:
            v236 = v234 + 13;
            goto LABEL_674;
          }
          if (!strncmp((const char *)v234, "texture1DLodOffset", 0x12uLL))
          {
LABEL_663:
            v236 = v234 + 18;
            goto LABEL_674;
          }
          v251 = v234 + 15;
          if (!strncmp((const char *)v234, "texture1DOffset", 0xFuLL))
          {
LABEL_672:
            v236 = v251;
            goto LABEL_674;
          }
          int v252 = strncmp((const char *)v234, "texture1DLod", 0xCuLL);
          v253 = v234 + 12;
          if (!v252 || (int v254 = strncmp((const char *)v234, "texture1D", 9uLL), v253 = v234 + 9, !v254))
          {
            v236 = v253;
            goto LABEL_674;
          }
          if (!strncmp((const char *)v234, "texture2DLodOffset", 0x12uLL)) {
            goto LABEL_663;
          }
          if (!strncmp((const char *)v234, "texture2DOffset", 0xFuLL)) {
            goto LABEL_672;
          }
          if (!strncmp((const char *)v234, "texture2DLod", 0xCuLL))
          {
LABEL_739:
            v236 = v234 + 12;
            goto LABEL_674;
          }
          if (!strncmp((const char *)v234, "texture2D", 9uLL)) {
            goto LABEL_750;
          }
          if (!strncmp((const char *)v234, "texture3DLodOffset", 0x12uLL)) {
            goto LABEL_663;
          }
          if (!strncmp((const char *)v234, "texture3DOffset", 0xFuLL)) {
            goto LABEL_672;
          }
          if (!strncmp((const char *)v234, "texture3DLod", 0xCuLL)) {
            goto LABEL_739;
          }
          if (!strncmp((const char *)v234, "texture3D", 9uLL))
          {
LABEL_750:
            v236 = v234 + 9;
            goto LABEL_674;
          }
          if (!strncmp((const char *)v234, "textureCubeLodOffset", 0x14uLL))
          {
            v236 = v234 + 20;
          }
          else if (!strncmp((const char *)v234, "textureCubeOffset", 0x11uLL))
          {
            v236 = v234 + 17;
          }
          else if (!strncmp((const char *)v234, "textureCubeLod", 0xEuLL))
          {
            v236 = v234 + 14;
          }
          else
          {
            v251 = v234 + 11;
            if (!strncmp((const char *)v234, "textureCube", 0xBuLL)) {
              goto LABEL_672;
            }
            if (!strncmp((const char *)v234, "greaterThanEqual", 0x10uLL)) {
              goto LABEL_764;
            }
            if (!strncmp((const char *)v234, "lessThanEqual", 0xDuLL)) {
              goto LABEL_662;
            }
            if (!strncmp((const char *)v234, "greaterThan", 0xBuLL)
              || !strncmp((const char *)v234, "inversesqrt", 0xBuLL))
            {
              goto LABEL_672;
            }
            if (!strncmp((const char *)v234, "normalize", 9uLL)) {
              goto LABEL_750;
            }
            v250 = v234 + 8;
            if (!strncmp((const char *)v234, "lessThan", 8uLL)
              || !strncmp((const char *)v234, "notEqual", 8uLL)
              || (v250 = v234 + 7, !strncmp((const char *)v234, "reflect", 7uLL))
              || !strncmp((const char *)v234, "discard", 7uLL)
              || (v250 = v234 + 6, !strncmp((const char *)v234, "noise1", 6uLL))
              || !strncmp((const char *)v234, "noise2", 6uLL)
              || !strncmp((const char *)v234, "noise3", 6uLL)
              || !strncmp((const char *)v234, "noise4", 6uLL)
              || (v250 = v234 + 5, !strncmp((const char *)v234, "cross", 5uLL))
              || !strncmp((const char *)v234, "clamp", 5uLL)
              || !strncmp((const char *)v234, "fract", 5uLL)
              || !strncmp((const char *)v234, "equal", 5uLL)
              || !strncmp((const char *)v234, "floor", 5uLL)
              || !strncmp((const char *)v234, "while", 5uLL)
              || (v250 = v234 + 4, !strncmp((const char *)v234, "ceil", 4uLL))
              || !strncmp((const char *)v234, "log2", 4uLL)
              || !strncmp((const char *)v234, "exp2", 4uLL)
              || !strncmp((const char *)v234, "dFdx", 4uLL)
              || !strncmp((const char *)v234, "dFdy", 4uLL)
              || !strncmp((const char *)v234, "sqrt", 4uLL)
              || !strncmp((const char *)v234, "acos", 4uLL)
              || !strncmp((const char *)v234, "asin", 4uLL)
              || !strncmp((const char *)v234, "atan", 4uLL)
              || (v250 = v234 + 3, !strncmp((const char *)v234, "abs", 3uLL))
              || !strncmp((const char *)v234, "min", 3uLL)
              || !strncmp((const char *)v234, "max", 3uLL)
              || !strncmp((const char *)v234, "dot", 3uLL)
              || !strncmp((const char *)v234, "pow", 3uLL)
              || !strncmp((const char *)v234, "cos", 3uLL)
              || !strncmp((const char *)v234, "sin", 3uLL)
              || !strncmp((const char *)v234, "tan", 3uLL)
              || !strncmp((const char *)v234, "mod", 3uLL)
              || !strncmp((const char *)v234, "mix", 3uLL)
              || !strncmp((const char *)v234, "for", 3uLL))
            {
LABEL_764:
              v236 = v250;
            }
            else if (!strncmp((const char *)v234, "if", 2uLL))
            {
              v236 = v234 + 2;
            }
            else if ((ctype[2 * v241] & 0x40) != 0)
            {
              if (v241)
              {
                do
                {
                  if ((ctype[2 * v241] & 0x40) == 0) {
                    break;
                  }
                  int v255 = *++v234;
                  LODWORD(v241) = v255;
                }
                while (v255);
              }
              v236 = v234;
            }
          }
LABEL_674:
          v232 = v236;
        }
      }
      else
      {
        if ((v241 - 48) > 9)
        {
          if (v241 <= 0x3E
            && (((1 << v241) & 0xAC0000000000) != 0
             || ((1 << v241) & 0x7000000200000000) != 0 && (v241 == 61 || *v236 == 61)))
          {
            goto LABEL_674;
          }
          goto LABEL_594;
        }
        do
          int v249 = *++v234;
        while ((v249 - 48) < 0xA);
        WORD2(v648) = ++v635;
        v232 = v234;
      }
    }
  }
  unint64_t v46 = v3;
  do
  {
    while (1)
    {
      while (1)
      {
        do
        {
LABEL_103:
          long long v47 = v46;
          HGRect v49 = (unsigned __int8 *)(v46 + 1);
          int v48 = *(unsigned __int8 *)v46++;
        }
        while ((v48 - 33) >= 0xFFFFFFE0);
        if (v48 != 47) {
          break;
        }
        int v50 = *v49;
        if (v50 == 42)
        {
          unint64_t v46 = v47 + 2;
          if (v47[2])
          {
            do
            {
              if (*(v49 - 1) == 42 && *v49 == 47) {
                break;
              }
              int v60 = v49[2];
              ++v49;
            }
            while (v60);
            unint64_t v46 = (const char *)(v49 + 1);
          }
        }
        else
        {
          if (v50 != 47) {
            goto LABEL_113;
          }
          HGRect v51 = v47 + 2;
          while (*v51)
          {
            int v52 = *((unsigned __int8 *)v51 - 1);
            unint64_t v46 = v51++;
            if (v52 == 10) {
              goto LABEL_103;
            }
          }
          unint64_t v46 = v51;
        }
      }
      if (!v48)
      {
        unsigned int v19 = 0;
        if (v18) {
          goto LABEL_506;
        }
        while (1)
        {
          do
          {
LABEL_521:
            v219 = (unsigned __int8 *)v3;
            v226 = (unsigned __int8 *)(v3 + 1);
            int v221 = *v3++;
          }
          while ((v221 - 33) >= 0xFFFFFFE0);
          if (v221 != 47) {
            goto LABEL_535;
          }
          int v227 = *v226;
          if (v227 == 42)
          {
            int v3 = (char *)(v219 + 2);
            if (v219[2])
            {
              do
              {
                if (*(v226 - 1) == 42 && *v226 == 47) {
                  break;
                }
                int v230 = v226[2];
                ++v226;
              }
              while (v230);
              int v3 = (char *)(v226 + 1);
            }
          }
          else
          {
            if (v227 != 47) {
              goto LABEL_537;
            }
            v228 = (char *)(v219 + 2);
            while (*v228)
            {
              int v229 = *(v228 - 1);
              int v3 = v228++;
              if (v229 == 10) {
                goto LABEL_521;
              }
            }
            int v3 = v228;
          }
        }
      }
LABEL_113:
      if (!strncmp(v47, "vertex ", 7uLL)) {
        break;
      }
      if (!strncmp(v47, "fragment ", 9uLL))
      {
        unint64_t v61 = v47 + 8;
        do
        {
          unsigned int v63 = *(unsigned __int8 *)++v61;
          unsigned int v62 = v63;
        }
        while (v63 - 33 > 0xFFFFFFDF);
        if (v62 >= 0x21)
        {
          do
            unsigned int v64 = *(unsigned __int8 *)++v61;
          while (v64 > 0x20);
        }
        unint64_t v46 = v61 - 1;
        do
        {
          unsigned int v66 = *(unsigned __int8 *)++v46;
          unsigned int v65 = v66;
        }
        while (v66 - 33 > 0xFFFFFFDF);
        if (v65 >= 0x21)
        {
          while (v65 != 40)
          {
            unsigned int v67 = *(unsigned __int8 *)++v46;
            unsigned int v65 = v67;
            if (v67 <= 0x20) {
              goto LABEL_103;
            }
          }
          v647[0] = 396032;
          goto LABEL_21;
        }
      }
      else if (!strncmp(v47, "kernel ", 7uLL))
      {
        unint64_t v46 = v47 + 6;
        do
          int v68 = *(unsigned __int8 *)++v46;
        while ((v68 - 33) > 0xFFFFFFDF);
        if (!strncmp(v46, "void", 4uLL))
        {
LABEL_181:
          unsigned int v19 = 2816;
          goto LABEL_182;
        }
      }
      else if (!strncmp(v47, "#include", 8uLL))
      {
        unint64_t v46 = v47 + 7;
        do
          int v70 = *(unsigned __int8 *)++v46;
        while ((v70 - 33) > 0xFFFFFFDF);
        if (!strncmp(v46, "<metal_common>", 0xEuLL)
          || !strncmp(v46, "<metal_graphics>", 0x10uLL)
          || !strncmp(v46, "<metal_matrix>", 0xEuLL)
          || !strncmp(v46, "<metal_geometric>", 0x11uLL)
          || !strncmp(v46, "<metal_math>", 0xCuLL)
          || !strncmp(v46, "<metal_texture>", 0xFuLL)
          || !strncmp(v46, "<metal_stdlib>", 0xEuLL)
          || !strncmp(v46, "<metal_integer>", 0xFuLL)
          || !strncmp(v46, "<metal_relational>", 0x12uLL)
          || !strncmp(v46, "<metal_compute>", 0xFuLL)
          || !strncmp(v46, "<metal_pack>", 0xCuLL)
          || !strncmp(v46, "<metal_atomic>", 0xEuLL))
        {
          goto LABEL_181;
        }
      }
      else if (v48 == 103 && *v49 == 108 && v47[2] == 95)
      {
        unint64_t v46 = v47 + 3;
        if (!strncmp(v47 + 3, "TextureMatrix", 0xDuLL)
          || !strncmp(v47 + 3, "TexCoord", 8uLL)
          || !strncmp(v47 + 3, "MultiTexCoord", 0xDuLL)
          || !strncmp(v47 + 3, "ModelViewProjectionMatrix", 0x19uLL)
          || !strncmp(v47 + 3, "Position", 8uLL)
          || !strncmp(v47 + 3, "Vertex", 6uLL)
          || !strncmp(v47 + 3, "Normal", 6uLL)
          || !strncmp(v47 + 3, "FrontFacing", 0xBuLL)
          || !strncmp(v47 + 3, "FragDepth", 9uLL)
          || !strncmp(v47 + 3, "FragCoord", 9uLL)
          || !strncmp(v47 + 3, "FragColor", 9uLL)
          || !strncmp(v47 + 3, "FragData", 8uLL))
        {
          unsigned int v19 = 394752;
LABEL_182:
          v647[0] = v19;
          if ((v19 & 0xFF00) == 0xB00) {
            goto LABEL_21;
          }
          goto LABEL_491;
        }
      }
      else
      {
        unint64_t v46 = v47 - 1;
        do
          unsigned int v69 = *(unsigned __int8 *)++v46;
        while (v69 > 0x20);
      }
    }
    unint64_t v53 = v47 + 6;
    do
    {
      unsigned int v55 = *(unsigned __int8 *)++v53;
      unsigned int v54 = v55;
    }
    while (v55 - 33 > 0xFFFFFFDF);
    if (v54 >= 0x21)
    {
      do
        unsigned int v56 = *(unsigned __int8 *)++v53;
      while (v56 > 0x20);
    }
    unint64_t v46 = v53 - 1;
    do
    {
      unsigned int v58 = *(unsigned __int8 *)++v46;
      unsigned int v57 = v58;
    }
    while (v58 - 33 > 0xFFFFFFDF);
  }
  while (v57 < 0x21);
  while (v57 != 40)
  {
    unsigned int v59 = *(unsigned __int8 *)++v46;
    unsigned int v57 = v59;
    if (v59 <= 0x20) {
      goto LABEL_103;
    }
  }
  v647[0] = 330512;
LABEL_21:
  if (v18)
  {
    while (1)
    {
      do
      {
LABEL_24:
        int v20 = v18;
        int v21 = v18 + 1;
        int v22 = *v18++;
      }
      while ((v22 - 33) >= 0xFFFFFFE0);
      if (v22 != 47) {
        break;
      }
      int v23 = *v21;
      if (v23 == 42)
      {
        int v18 = v20 + 2;
        if (v20[2])
        {
          do
          {
            if (*(v21 - 1) == 42 && *v21 == 47) {
              break;
            }
            int v26 = v21[2];
            ++v21;
          }
          while (v26);
          int v18 = v21 + 1;
        }
      }
      else
      {
        if (v23 != 47) {
          goto LABEL_55;
        }
        int8x8_t v24 = v20 + 2;
        while (*v24)
        {
          int v25 = *(v24 - 1);
          int v18 = v24++;
          if (v25 == 10) {
            goto LABEL_24;
          }
        }
        int v18 = v24;
      }
    }
  }
  else
  {
    while (1)
    {
      do
      {
LABEL_39:
        int v20 = (unsigned __int8 *)v3;
        uint64_t v27 = (unsigned __int8 *)(v3 + 1);
        int v22 = *v3++;
      }
      while ((v22 - 33) >= 0xFFFFFFE0);
      if (v22 != 47) {
        break;
      }
      int v28 = *v27;
      if (v28 == 42)
      {
        int v3 = (char *)(v20 + 2);
        if (v20[2])
        {
          do
          {
            if (*(v27 - 1) == 42 && *v27 == 47) {
              break;
            }
            int v31 = v27[2];
            ++v27;
          }
          while (v31);
          int v3 = (char *)(v27 + 1);
        }
      }
      else
      {
        if (v28 != 47) {
          goto LABEL_55;
        }
        unsigned __int8 v29 = (char *)(v20 + 2);
        while (*v29)
        {
          int v30 = *(v29 - 1);
          int v3 = v29++;
          if (v30 == 10) {
            goto LABEL_39;
          }
        }
        int v3 = v29;
      }
    }
  }
  if (!v22) {
    int v20 = 0;
  }
LABEL_55:
  long long __s1a = 0uLL;
  unint64_t v660 = 0;
  int v32 = v20;
  while (1)
  {
    do
    {
LABEL_58:
      int v34 = v32;
      int v35 = v32 + 1;
      int v36 = *v32++;
    }
    while ((v36 - 33) >= 0xFFFFFFE0);
    if (v36 == 47)
    {
      int v37 = *v35;
      if (v37 == 42)
      {
        int v32 = v34 + 2;
        if (v34[2])
        {
          do
          {
            if (*(v35 - 1) == 42 && *v35 == 47) {
              break;
            }
            int v41 = v35[2];
            ++v35;
          }
          while (v41);
          int v32 = v35 + 1;
        }
        goto LABEL_58;
      }
      if (v37 == 47)
      {
        uint64_t v38 = v34 + 2;
        while (*v38)
        {
          int v39 = *(v38 - 1);
          int v32 = v38++;
          if (v39 == 10) {
            goto LABEL_58;
          }
        }
        int v32 = v38;
        goto LABEL_58;
      }
    }
    else if (!v36)
    {
      goto LABEL_187;
    }
    if (!strncmp((const char *)v34, "vertex ", 7uLL))
    {
      unsigned int v71 = 330512;
      goto LABEL_186;
    }
    if (!strncmp((const char *)v34, "fragment ", 9uLL)) {
      break;
    }
    if (!strncmp((const char *)v34, "kernel ", 7uLL))
    {
      uint64_t v33 = (const char *)(v34 + 7);
LABEL_57:
      v647[0] = 2816;
      int v32 = (unsigned __int8 *)v33;
      goto LABEL_58;
    }
    if (strncmp((const char *)v34, "#include", 8uLL))
    {
      int v32 = v34 - 1;
      do
        unsigned int v40 = *++v32;
      while (v40 > 0x20);
      goto LABEL_58;
    }
    uint64_t v33 = (const char *)(v34 + 25);
    do
      unsigned int v42 = *((unsigned __int8 *)v33++ - 17) - 33;
    while (v42 > 0xFFFFFFDF);
    int v32 = (unsigned __int8 *)(v33 - 18);
    if (!strncmp(v33 - 18, "<metal_common>", 0xEuLL))
    {
LABEL_95:
      v33 -= 4;
      goto LABEL_57;
    }
    if (!strncmp(v33 - 18, "<metal_graphics>", 0x10uLL))
    {
      v33 -= 2;
      goto LABEL_57;
    }
    if (!strncmp(v33 - 18, "<metal_matrix>", 0xEuLL)) {
      goto LABEL_95;
    }
    if (!strncmp(v33 - 18, "<metal_geometric>", 0x11uLL))
    {
      --v33;
      goto LABEL_57;
    }
    int v43 = strncmp(v33 - 18, "<metal_math>", 0xCuLL);
    uint64_t v44 = (unsigned __int8 *)(v33 - 6);
    if (!v43 || (int v45 = strncmp(v33 - 18, "<metal_texture>", 0xFuLL), v44 = (unsigned __int8 *)(v33 - 3), !v45))
    {
      uint64_t v33 = (const char *)v44;
      goto LABEL_57;
    }
    if (!strncmp(v33 - 18, "<metal_stdlib>", 0xEuLL)) {
      goto LABEL_95;
    }
    if (!strncmp(v33 - 18, "<metal_integer>", 0xFuLL)) {
      goto LABEL_100;
    }
    if (!strncmp(v33 - 18, "<metal_relational>", 0x12uLL)) {
      goto LABEL_57;
    }
    if (!strncmp(v33 - 18, "<metal_compute>", 0xFuLL))
    {
LABEL_100:
      v33 -= 3;
      goto LABEL_57;
    }
    if (!strncmp(v33 - 18, "<metal_pack>", 0xCuLL))
    {
      v33 -= 6;
      goto LABEL_57;
    }
    if (!strncmp(v33 - 18, "<metal_atomic>", 0xEuLL)) {
      goto LABEL_95;
    }
  }
  unsigned int v71 = 396048;
LABEL_186:
  v647[0] = v71;
LABEL_187:
  char __n = 0;
  int8x16_t v72 = "texCoord";
  unsigned int v73 = "hg_Params[";
  uint64_t j = (const char *)v20;
LABEL_188:
  uint64_t v75 = j;
  while (1)
  {
    do
    {
LABEL_190:
      uint64_t v76 = (char *)v75;
      unint64_t v78 = v75 + 1;
      int v77 = *(unsigned __int8 *)v75++;
    }
    while ((v77 - 33) >= 0xFFFFFFE0);
    if (v77 != 47) {
      break;
    }
    int v79 = *(unsigned __int8 *)v78;
    if (v79 == 42)
    {
      uint64_t v75 = v76 + 2;
      if (v76[2])
      {
        do
        {
          if (*(v78 - 1) == 42 && *v78 == 47) {
            break;
          }
        }
        while (*((unsigned __int8 *)v78++ + 2));
        uint64_t v75 = v78 + 1;
      }
    }
    else
    {
      if (v79 != 47)
      {
LABEL_205:
        LODWORD(v656) = 0;
        uint64_t v83 = *v76;
        if (v83 == 95)
        {
          if (!strncmp(v78, v72, 8uLL))
          {
            int v100 = v76[9];
            unint64_t v99 = (unsigned __int8 *)(v76 + 9);
            int v98 = v100;
            if ((v100 - 58) >= 0xFFFFFFF6)
            {
              int v101 = 0;
              float32x4_t v102 = v99;
              do
              {
                int v101 = v98 + 10 * v101 - 48;
                int v116 = *++v102;
                int v98 = v116;
              }
              while ((v116 - 58) > 0xFFFFFFF5);
              LODWORD(v656) = v101;
            }
            else
            {
              int v101 = 0;
              float32x4_t v102 = 0;
            }
            if (v102) {
              uint64_t j = (const char *)v102;
            }
            else {
              uint64_t j = (const char *)v99;
            }
            if (v101 + 1 > WORD2(v649)) {
              __int16 v117 = v101 + 1;
            }
            else {
              __int16 v117 = WORD2(v649);
            }
            WORD2(v649) = v117;
          }
          else
          {
            do
              unsigned int v94 = *++v76;
            while (v94 > 0x20);
            uint64_t j = v76;
          }
          goto LABEL_188;
        }
        if (v83 == 91 && *v78 == 91)
        {
          unint64_t v84 = v73;
          uint64_t v85 = v72;
          unint64_t v86 = v76 + 14;
          do
            unsigned int v87 = *((unsigned __int8 *)v86++ - 12) - 33;
          while (v87 >= 0xFFFFFFE0);
          float v88 = (unsigned __int8 *)(v86 - 13);
          unsigned int v89 = (unsigned __int8 *)(v86 - 5);
          if (!strncmp(v86 - 13, "texture(", 8uLL))
          {
            int v113 = *((unsigned __int8 *)v86 - 5);
            if ((v113 - 58) >= 0xFFFFFFF6)
            {
              int v114 = 0;
              v115 = (unsigned __int8 *)(v86 - 5);
              int8x16_t v72 = v85;
              do
              {
                int v114 = v113 + 10 * v114 - 48;
                int v124 = *++v115;
                int v113 = v124;
              }
              while ((v124 - 58) > 0xFFFFFFF5);
              LODWORD(v656) = v114;
            }
            else
            {
              int v114 = 0;
              v115 = 0;
              int8x16_t v72 = v85;
            }
            unsigned int v73 = v84;
            if (v115) {
              float v88 = v115;
            }
            else {
              float v88 = v89;
            }
            if (v114 + 1 > BYTE8(v649)) {
              char v125 = v114 + 1;
            }
            else {
              char v125 = BYTE8(v649);
            }
            BYTE8(v649) = v125;
            if (__n)
            {
              char __n = 0;
              LODWORD(v648) = v648 | (1 << v114);
            }
            else
            {
              char __n = 0;
            }
          }
          else if (!strncmp(v86 - 13, "sampler(", 8uLL))
          {
            int v120 = *((unsigned __int8 *)v86 - 5);
            if ((v120 - 58) >= 0xFFFFFFF6)
            {
              int v130 = 0;
              v121 = (unsigned __int8 *)(v86 - 5);
              int8x16_t v72 = v85;
              do
              {
                int v130 = v120 + 10 * v130 - 48;
                int v131 = *++v121;
                int v120 = v131;
              }
              while ((v131 - 58) > 0xFFFFFFF5);
              LODWORD(v656) = v130;
            }
            else
            {
              v121 = 0;
              int8x16_t v72 = v85;
            }
            unsigned int v73 = v84;
            if (v121) {
              float v88 = v121;
            }
            else {
              float v88 = v89;
            }
          }
          else
          {
            if (!strncmp(v86 - 13, "user(texcoord", 0xDuLL))
            {
              int v127 = *(unsigned __int8 *)v86;
              if ((v127 - 58) >= 0xFFFFFFF6)
              {
                int v128 = 0;
                v129 = (unsigned __int8 *)v86;
                do
                {
                  int v128 = v127 + 10 * v128 - 48;
                  int v136 = *++v129;
                  int v127 = v136;
                }
                while ((v136 - 58) > 0xFFFFFFF5);
                LODWORD(v656) = v128;
              }
              else
              {
                int v128 = 0;
                v129 = 0;
              }
              if (v129) {
                float v88 = v129;
              }
              else {
                float v88 = (unsigned __int8 *)v86;
              }
              if (v128 + 1 > WORD2(v649)) {
                __int16 v137 = v128 + 1;
              }
              else {
                __int16 v137 = WORD2(v649);
              }
              WORD2(v649) = v137;
            }
            else if (!strncmp(v86 - 13, "stage_in", 8uLL))
            {
              v647[0] = 396048;
              float v88 = (unsigned __int8 *)(v86 - 5);
            }
            else if (!strncmp(v86 - 13, "vertex_id", 9uLL))
            {
              float v88 = (unsigned __int8 *)(v86 - 4);
              v647[0] = 330512;
            }
            else if (!strncmp(v86 - 13, "position", 8uLL))
            {
              float v88 = (unsigned __int8 *)(v86 - 5);
            }
            else if (!strncmp(v86 - 13, "color(", 6uLL))
            {
              int v144 = *((unsigned __int8 *)v86 - 7);
              v143 = (unsigned __int8 *)(v86 - 7);
              int v142 = v144;
              if ((v144 - 58) >= 0xFFFFFFF6)
              {
                int v145 = 0;
                v146 = v143;
                do
                {
                  int v145 = v142 + 10 * v145 - 48;
                  int v147 = *++v146;
                  int v142 = v147;
                }
                while ((v147 - 58) > 0xFFFFFFF5);
                LODWORD(v656) = v145;
              }
              else
              {
                int v145 = 0;
                v146 = 0;
              }
              if (v146) {
                float v88 = v146;
              }
              else {
                float v88 = v143;
              }
              if (v145 + 1 > BYTE10(v649)) {
                char v148 = v145 + 1;
              }
              else {
                char v148 = BYTE10(v649);
              }
              BYTE10(v649) = v148;
            }
            else if (!strncmp(v86 - 13, "depth(any)", 0xAuLL))
            {
              float v88 = (unsigned __int8 *)(v86 - 3);
              BYTE9(v649) = 1;
            }
            int8x16_t v72 = v85;
            unsigned int v73 = v84;
          }
          for (uint64_t j = (const char *)(v88 + 2); *(j - 2) != 93 || *(j - 1) != 93; ++j)
            ;
          goto LABEL_188;
        }
        if (!strncmp(v76, v73, 0xAuLL))
        {
          int v95 = v76[10];
          if ((v95 - 58) >= 0xFFFFFFF6)
          {
            int v96 = 0;
            float v97 = (unsigned __int8 *)(v76 + 10);
            do
            {
              int v96 = v95 + 10 * v96 - 48;
              int v107 = *++v97;
              int v95 = v107;
            }
            while ((v107 - 58) > 0xFFFFFFF5);
            LODWORD(v656) = v96;
          }
          else
          {
            int v96 = 0;
            float v97 = 0;
          }
          if (!v97) {
            float v97 = (unsigned __int8 *)(v76 + 10);
          }
          if (v96 + 1 > WORD3(v648)) {
            __int16 v108 = v96 + 1;
          }
          else {
            __int16 v108 = WORD3(v648);
          }
          WORD3(v648) = v108;
          uint64_t j = (const char *)(v97 + 1);
        }
        else
        {
          uint64_t v90 = v72;
          int v91 = strncmp(v76, "FragmentOut ", 0xCuLL);
          uint64_t j = v76 + 12;
          if (v91) {
            uint64_t v92 = 0;
          }
          else {
            uint64_t v92 = v76 + 12;
          }
          if (!v91 && strncmp(v76 + 12, "fragmentFunc", 0xCuLL))
          {
            unsigned int v103 = *(unsigned __int8 *)j;
            if (*j)
            {
              do
              {
                if (v103 < 0x21) {
                  break;
                }
                if ((ctype[2 * v103] & 0x40) == 0) {
                  break;
                }
                unsigned int v104 = *(unsigned __int8 *)++j;
                unsigned int v103 = v104;
              }
              while (v104);
            }
            unint64_t v105 = j - v92;
            if ((unint64_t)(j - v92) >= 0x7FFFFFFFFFFFFFF8) {
              std::string::__throw_length_error[abi:ne180100]();
            }
            if (v105 >= 0x17)
            {
              uint64_t v122 = (v105 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v105 | 7) != 0x17) {
                uint64_t v122 = v105 | 7;
              }
              uint64_t v123 = v122 + 1;
              p_dst = (long long *)operator new(v122 + 1);
              *((void *)&__dst + 1) = j - v92;
              unint64_t v658 = v123 | 0x8000000000000000;
              *(void *)&long long __dst = p_dst;
            }
            else
            {
              HIBYTE(v658) = (_BYTE)j - (_BYTE)v92;
              p_dst = &__dst;
              if (j == v92) {
                goto LABEL_293;
              }
            }
            memmove(p_dst, v92, j - v92);
LABEL_293:
            int8x16_t v72 = v90;
            *((unsigned char *)p_dst + v105) = 0;
            unsigned int v73 = "hg_Params[";
            if (SHIBYTE(v660) < 0) {
              operator delete((void *)__s1a);
            }
            long long __s1a = __dst;
            unint64_t v660 = v658;
            goto LABEL_188;
          }
          uint64_t v93 = HIBYTE(v660);
          if (SHIBYTE(v660) < 0)
          {
            if (*((void *)&__s1a + 1))
            {
              if (*((void *)&__s1a + 1) == -1) {
                std::string::__throw_out_of_range[abi:ne180100]();
              }
              if (!memcmp((const void *)__s1a, v76, *((size_t *)&__s1a + 1))) {
                goto LABEL_282;
              }
            }
          }
          else if (HIBYTE(v660) && !memcmp(&__s1a, v76, HIBYTE(v660)))
          {
LABEL_282:
            if ((v93 & 0x80u) == 0) {
              uint64_t v119 = v93;
            }
            else {
              uint64_t v119 = *((void *)&__s1a + 1);
            }
            uint64_t j = &v76[v119];
            if (!strncmp(&v76[v119], ".color", 6uLL))
            {
              int v133 = *((unsigned __int8 *)j + 6);
              j += 6;
              int v132 = v133;
              int8x16_t v72 = v90;
              int v134 = 0;
              if ((v133 - 58) >= 0xFFFFFFF6)
              {
                v135 = j;
                unsigned int v73 = "hg_Params[";
                do
                {
                  int v134 = v132 + 10 * v134 - 48;
                  int v138 = *(unsigned __int8 *)++v135;
                  int v132 = v138;
                }
                while ((v138 - 58) > 0xFFFFFFF5);
                LODWORD(v656) = v134;
              }
              else
              {
                v135 = 0;
                unsigned int v73 = "hg_Params[";
              }
              if (v135) {
                uint64_t j = v135;
              }
              if (v134 + 1 > BYTE10(v649)) {
                char v139 = v134 + 1;
              }
              else {
                char v139 = BYTE10(v649);
              }
              BYTE10(v649) = v139;
            }
            else
            {
              int8x16_t v72 = v90;
              unsigned int v73 = "hg_Params[";
            }
            if (!strncmp(j, ".depth", 6uLL)) {
              v647[1] |= 0x2000000u;
            }
            goto LABEL_188;
          }
          uint64_t j = v76 + 9;
          int8x16_t v72 = v90;
          if (!strncmp(v76, "texture2d", 9uLL))
          {
            unsigned int v111 = *(unsigned __int8 *)j;
            if (*j)
            {
              unsigned int v73 = "hg_Params[";
              do
              {
                if (v111 >= 0x21 && v111 != 60) {
                  break;
                }
                unsigned int v112 = *(unsigned __int8 *)++j;
                unsigned int v111 = v112;
              }
              while (v112);
            }
            else
            {
              unsigned int v73 = "hg_Params[";
            }
            if (!strncmp(j, "half", 4uLL))
            {
              v647[1] |= 0x400000u;
              char __n = 1;
            }
            else
            {
              __n &= strncmp(j, "float", 5uLL) != 0;
            }
          }
          else if (v83 == 46)
          {
            do
              int v110 = *++v76;
            while ((v110 - 48) < 0xA);
            uint64_t j = v76;
            unsigned int v73 = "hg_Params[";
          }
          else if ((v83 - 48) > 9)
          {
            uint64_t v126 = (v83 - 33);
            if (v126 > 0x3A) {
              goto LABEL_356;
            }
            if (((1 << (v83 - 33)) & 0x5E00) != 0) {
              goto LABEL_314;
            }
            if (((1 << (v83 - 33)) & 0x38000001) != 0)
            {
              if (*v78 == 61 || v83 == 44 || v83 == 61)
              {
LABEL_314:
                uint64_t j = v78;
                unsigned int v73 = "hg_Params[";
                goto LABEL_188;
              }
LABEL_356:
              if (!strncmp(v76, "get_num_mip_levels", 0x12uLL))
              {
                uint64_t j = v76 + 18;
                unsigned int v73 = "hg_Params[";
                goto LABEL_188;
              }
              if (!strncmp(v76, "get_num_samples", 0xFuLL))
              {
                uint64_t j = v76 + 15;
                unsigned int v73 = "hg_Params[";
                goto LABEL_188;
              }
              if (!strncmp(v76, "get_array_size", 0xEuLL))
              {
                uint64_t j = v76 + 14;
                unsigned int v73 = "hg_Params[";
                goto LABEL_188;
              }
              if (!strncmp(v76, "get_height", 0xAuLL))
              {
                uint64_t j = v76 + 10;
                unsigned int v73 = "hg_Params[";
                goto LABEL_188;
              }
              if (!strncmp(v76, "get_width", 9uLL))
              {
                unsigned int v73 = "hg_Params[";
                goto LABEL_188;
              }
              if (!strncmp(v76, "get_depth", 9uLL))
              {
                unsigned int v73 = "hg_Params[";
                goto LABEL_188;
              }
              v141 = (unsigned __int8 *)(v76 + 6);
              if (!strncmp(v76, "sample", 6uLL) || !strncmp(v76, "gather", 6uLL)) {
                goto LABEL_432;
              }
              if (strncmp(v76, "write", 5uLL))
              {
                v141 = (unsigned __int8 *)(v76 + 4);
                if (!strncmp(v76, "read", 4uLL)) {
                  goto LABEL_432;
                }
                if (!strncmp(v76, "discard_fragment", 0x10uLL))
                {
                  uint64_t j = v76 + 16;
                  goto LABEL_437;
                }
                if (!strncmp(v76, "normalize", 9uLL))
                {
LABEL_437:
                  int8x16_t v72 = v90;
                  unsigned int v73 = "hg_Params[";
                  goto LABEL_188;
                }
                if (!strncmp(v76, "reflect", 7uLL))
                {
                  uint64_t j = v76 + 7;
                  goto LABEL_437;
                }
                if (strncmp(v76, "rsqrt", 5uLL)
                  && strncmp(v76, "cross", 5uLL)
                  && strncmp(v76, "clamp", 5uLL)
                  && strncmp(v76, "fract", 5uLL)
                  && strncmp(v76, "floor", 5uLL)
                  && strncmp(v76, "while", 5uLL)
                  && strncmp(v76, "ilogb", 5uLL)
                  && strncmp(v76, "ldexp", 5uLL)
                  && strncmp(v76, "round", 5uLL)
                  && strncmp(v76, "atan2", 5uLL)
                  && strncmp(v76, "trunc", 5uLL))
                {
                  if (strncmp(v76, "ceil", 4uLL)
                    && strncmp(v76, "log2", 4uLL)
                    && strncmp(v76, "exp2", 4uLL)
                    && strncmp(v76, "dfdx", 4uLL)
                    && strncmp(v76, "dfdy", 4uLL)
                    && strncmp(v76, "sqrt", 4uLL)
                    && strncmp(v76, "acos", 4uLL)
                    && strncmp(v76, "asin", 4uLL)
                    && strncmp(v76, "atan", 4uLL)
                    && strncmp(v76, "fmax", 4uLL)
                    && strncmp(v76, "fmin", 4uLL))
                  {
                    uint64_t j = v76 + 3;
                    if (strncmp(v76, "abs", 3uLL)
                      && strncmp(v76, "min", 3uLL)
                      && strncmp(v76, "max", 3uLL)
                      && strncmp(v76, "dot", 3uLL)
                      && strncmp(v76, "pow", 3uLL)
                      && strncmp(v76, "cos", 3uLL)
                      && strncmp(v76, "sin", 3uLL)
                      && strncmp(v76, "tan", 3uLL)
                      && strncmp(v76, "mod", 3uLL)
                      && strncmp(v76, "mix", 3uLL)
                      && strncmp(v76, "for", 3uLL))
                    {
                      if (!strncmp(v76, "if", 2uLL))
                      {
                        uint64_t j = v76 + 2;
                      }
                      else if ((ctype[2 * v83] & 0x40) != 0)
                      {
                        if (v83)
                        {
                          do
                          {
                            if ((ctype[2 * v83] & 0x40) == 0) {
                              break;
                            }
                            int v151 = *++v76;
                            LODWORD(v83) = v151;
                          }
                          while (v151);
                        }
                        uint64_t j = v76;
                      }
                      else
                      {
                        uint64_t j = v78;
                      }
                    }
                    goto LABEL_437;
                  }
LABEL_432:
                  uint64_t j = (const char *)v141;
                  goto LABEL_437;
                }
              }
              uint64_t j = v76 + 5;
              goto LABEL_437;
            }
            if (v126 != 58) {
              goto LABEL_356;
            }
            v140 = glsl::glindex((glsl *)v76, (char *)&v656, v109);
            if (v140)
            {
              uint64_t j = v140;
              unsigned int v73 = "hg_Params[";
            }
            else
            {
              uint64_t j = v76;
              unsigned int v73 = "hg_Params[";
              do
              {
                int v150 = *(unsigned __int8 *)++j;
                int v149 = v150;
              }
              while (v150 && v149 != 93);
            }
          }
          else
          {
            unsigned int v73 = "hg_Params[";
            do
              int v118 = *++v76;
            while ((v118 - 48) < 0xA);
            ++WORD2(v648);
            uint64_t j = v76;
          }
        }
        goto LABEL_188;
      }
      long long v80 = v76 + 2;
      while (*v80)
      {
        int v81 = *((unsigned __int8 *)v80 - 1);
        uint64_t v75 = v80++;
        if (v81 == 10) {
          goto LABEL_190;
        }
      }
      uint64_t v75 = v80;
    }
  }
  if (v77) {
    goto LABEL_205;
  }
  HIDWORD(v649) = 16 * WORD3(v648);
  LOBYTE(v152) = v647[0];
  unsigned int v153 = v647[0] | 0x60B00;
  if (v647[0] < 0x100)
  {
    BOOL v154 = 1;
  }
  else
  {
    unsigned int v153 = v647[0];
    BOOL v154 = LOBYTE(v647[0]) == 0;
  }
  if (v154)
  {
    if ((_BYTE)v153) {
      int v152 = v153;
    }
    else {
      int v152 = v153 | 0x10;
    }
    v647[0] = v152;
    if (SHIBYTE(v660) < 0) {
      goto LABEL_452;
    }
LABEL_455:
    uint64_t v156 = *((void *)this + 1);
    uint64_t v155 = *((void *)this + 2);
    unint64_t v157 = v156 + 7;
    if (v155) {
      goto LABEL_456;
    }
LABEL_453:
    str_alloc((string_t *)this, v157);
  }
  else
  {
    if ((SHIBYTE(v660) & 0x80000000) == 0) {
      goto LABEL_455;
    }
LABEL_452:
    operator delete((void *)__s1a);
    uint64_t v156 = *((void *)this + 1);
    uint64_t v155 = *((void *)this + 2);
    unint64_t v157 = v156 + 7;
    if (!v155) {
      goto LABEL_453;
    }
LABEL_456:
    if (v157 >= *(void *)v155)
    {
      v158 = malloc_type_realloc(*(void **)(v155 + 16), (v156 + 262) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v159 = (unint64_t *)*((void *)this + 2);
      v159[2] = (unint64_t)v158;
      unint64_t *v159 = (v156 + 262) & 0xFFFFFFFFFFFFFF00;
      *(void *)this = v158;
    }
  }
  uint64_t v160 = *(void *)this;
  *((void *)this + 1) += 7;
  v161 = (_DWORD *)(v160 + v156);
  *(_DWORD *)((char *)v161 + 3) = 1818326117;
  _DWORD *v161 = 1699557167;
  uint64_t v163 = *((void *)this + 1);
  uint64_t v162 = *((void *)this + 2);
  unint64_t v164 = v163 + 20;
  if (v162)
  {
    if (v164 >= *(void *)v162)
    {
      v165 = malloc_type_realloc(*(void **)(v162 + 16), (v163 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v166 = (unint64_t *)*((void *)this + 2);
      v166[2] = (unint64_t)v165;
      unint64_t *v166 = (v163 + 275) & 0xFFFFFFFFFFFFFF00;
      *(void *)this = v165;
    }
  }
  else
  {
    str_alloc((string_t *)this, v164);
  }
  uint64_t v167 = itoa((char *)(*(void *)this + v163), v152 >> 4);
  uint64_t v168 = *((void *)this + 2);
  uint64_t v169 = *((void *)this + 1) + v167;
  *((void *)this + 1) = v169;
  unint64_t v170 = v169 + 1;
  if (v168)
  {
    if (v170 >= *(void *)v168)
    {
      v171 = malloc_type_realloc(*(void **)(v168 + 16), (v169 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v172 = (void *)*((void *)this + 2);
      v172[2] = v171;
      void *v172 = (v169 & 0xFFFFFFFFFFFFFF00) + 256;
      *(void *)this = v171;
    }
  }
  else
  {
    str_alloc((string_t *)this, v170);
  }
  uint64_t v173 = *(void *)this;
  ++*((void *)this + 1);
  *(unsigned char *)(v173 + v169) = 46;
  signed int v174 = v647[0] & 0xF;
  uint64_t v176 = *((void *)this + 1);
  uint64_t v175 = *((void *)this + 2);
  unint64_t v177 = v176 + 20;
  if (v175)
  {
    if (v177 >= *(void *)v175)
    {
      v178 = malloc_type_realloc(*(void **)(v175 + 16), (v176 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v179 = (unint64_t *)*((void *)this + 2);
      v179[2] = (unint64_t)v178;
      unint64_t *v179 = (v176 + 275) & 0xFFFFFFFFFFFFFF00;
      *(void *)this = v178;
    }
  }
  else
  {
    str_alloc((string_t *)this, v177);
  }
  uint64_t v180 = itoa((char *)(*(void *)this + v176), v174);
  uint64_t v181 = *((void *)this + 2);
  uint64_t v182 = *((void *)this + 1) + v180;
  *((void *)this + 1) = v182;
  if (v181)
  {
    if (*(void *)v181 <= 0xFuLL)
    {
      v183 = malloc_type_realloc(*(void **)(v181 + 16), 0x100uLL, 0xCCCD1039uLL);
      v184 = (void *)*((void *)this + 2);
      v184[2] = v183;
      void *v184 = 256;
      *(void *)this = v183;
    }
  }
  else
  {
    str_alloc((string_t *)this, 15);
  }
  uint64_t v185 = *(void *)this;
  *((void *)this + 1) += 15 - v182;
  memcpy((void *)(v185 + v182), "               ", 15 - v182);
  uint64_t v187 = *((void *)this + 1);
  uint64_t v186 = *((void *)this + 2);
  unint64_t v188 = v187 + 1;
  if (v186)
  {
    if (v188 >= *(void *)v186)
    {
      v189 = malloc_type_realloc(*(void **)(v186 + 16), (v187 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v190 = (void *)*((void *)this + 2);
      v190[2] = v189;
      void *v190 = (v187 & 0xFFFFFFFFFFFFFF00) + 256;
      *(void *)this = v189;
    }
  }
  else
  {
    str_alloc((string_t *)this, v188);
  }
  uint64_t v191 = *(void *)this;
  ++*((void *)this + 1);
  *(unsigned char *)(v191 + v187) = 10;
  uint64_t v193 = *((void *)this + 1);
  uint64_t v192 = *((void *)this + 2);
  unint64_t v194 = v193 + 17;
  if (v192)
  {
    if (v194 >= *(void *)v192)
    {
      v195 = malloc_type_realloc(*(void **)(v192 + 16), (v193 + 272) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v196 = (unint64_t *)*((void *)this + 2);
      v196[2] = (unint64_t)v195;
      unint64_t *v196 = (v193 + 272) & 0xFFFFFFFFFFFFFF00;
      *(void *)this = v195;
    }
  }
  else
  {
    str_alloc((string_t *)this, v194);
  }
  uint64_t v197 = *(void *)this;
  *((void *)this + 1) += 17;
  uint64_t v198 = v197 + v193;
  *(_OWORD *)uint64_t v198 = *(_OWORD *)"//LEN=0000000000\n";
  *(unsigned char *)(v198 + 16) = 10;
  uint64_t v200 = *((void *)this + 1);
  uint64_t v199 = *((void *)this + 2);
  unint64_t v201 = v200 + j - (const char *)v20;
  if (v199)
  {
    if (v201 >= *(void *)v199)
    {
      size_t v202 = (v201 + 255) & 0xFFFFFFFFFFFFFF00;
      v203 = malloc_type_realloc(*(void **)(v199 + 16), v202, 0xCCCD1039uLL);
      v204 = (size_t *)*((void *)this + 2);
      v204[2] = (size_t)v203;
      size_t *v204 = v202;
      *(void *)this = v203;
    }
  }
  else
  {
    str_alloc((string_t *)this, v201);
  }
  uint64_t v205 = *(void *)this;
  *((void *)this + 1) += j - (const char *)v20;
  memcpy((void *)(v205 + v200), v20, j - (const char *)v20);
  if (*(j - 1) != 10)
  {
    uint64_t v207 = *((void *)this + 1);
    uint64_t v206 = *((void *)this + 2);
    unint64_t v208 = v207 + 1;
    if (v206)
    {
      if (v208 >= *(void *)v206)
      {
        v209 = malloc_type_realloc(*(void **)(v206 + 16), (v207 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
        v210 = (void *)*((void *)this + 2);
        v210[2] = v209;
        void *v210 = (v207 & 0xFFFFFFFFFFFFFF00) + 256;
        *(void *)this = v209;
      }
    }
    else
    {
      str_alloc((string_t *)this, v208);
    }
    uint64_t v211 = *(void *)this;
    ++*((void *)this + 1);
    *(unsigned char *)(v211 + v207) = 10;
  }
  v213 = *(int **)this;
  size_t v212 = *((void *)this + 1);
  double v214 = HGDigestInit(&__dst);
  if (v212 >= 0x40)
  {
    size_t v217 = v212 >> 6;
    do
    {
      HGDigestAdd(&__dst, v213);
      v213 += 16;
      --v217;
    }
    while (v217);
    v212 &= 0x3Fu;
  }
  if (v212)
  {
    memcpy(&__s1a, v213, v212);
    bzero((char *)&__s1a + v212, 64 - v212);
    HGDigestAdd(&__dst, (int *)&__s1a);
  }
  glsl::end((string_t *)this, (uint64_t)v647, (unsigned int *)&__dst, 0, v214, v215, v216);
  return 4294967264;
}

void sub_1B7721F0C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 137) < 0)
  {
    operator delete(*(void **)(v1 - 160));
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *arb::atok(unsigned char *this, const char *a2)
{
  int v2 = *this;
  if (*this)
  {
    if ((v2 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_3:
        int v3 = *++this;
        int v2 = v3;
      }
      while ((v3 - 33) > 0xFFFFFFDF);
    }
LABEL_4:
    if (v2 == 35)
    {
      ++this;
      while (1)
      {
        int v2 = *this;
        if (!*this) {
          break;
        }
        int v4 = *(this++ - 1);
        if (v4 == 10)
        {
          --this;
          if ((v2 - 33) >= 0xFFFFFFE0) {
            goto LABEL_3;
          }
          goto LABEL_4;
        }
      }
    }
  }
  return this;
}

unsigned __int8 *arb::obj_write(int a1, uint64_t a2, const HGLimits *a3, char *__s1)
{
  unsigned int v19 = 0;
  long long __s1a = __s1;
  v17[1] = 0;
  int v18 = 0;
  int v6 = *__s1;
  if (*__s1)
  {
    if ((v6 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_3:
        int v7 = *++__s1;
        int v6 = v7;
      }
      while ((v7 - 33) > 0xFFFFFFDF);
    }
LABEL_4:
    if (v6 == 35)
    {
      ++__s1;
      while (1)
      {
        int v6 = *__s1;
        if (!*__s1) {
          break;
        }
        int v8 = *(__s1++ - 1);
        if (v8 == 10)
        {
          --__s1;
          if ((v6 - 33) >= 0xFFFFFFE0) {
            goto LABEL_3;
          }
          goto LABEL_4;
        }
      }
    }
  }
  long long __s1a = __s1;
  if (*__s1)
  {
    uint64_t result = header(__s1, &v17[1]);
    long long __s1a = (char *)result;
    if (result)
    {
      arb::begin((string_t *)a2, HGString::_distill(char const*,unsigned int)::head, a3, v10);
      uint64_t v12 = *(void *)(a2 + 8);
      uint64_t v11 = *(void *)(a2 + 16);
      unint64_t v13 = v12 + 4;
      if (v11)
      {
        if (v13 >= *(void *)v11)
        {
          int v14 = malloc_type_realloc(*(void **)(v11 + 16), (v12 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          int8x16_t v15 = *(unint64_t **)(a2 + 16);
          _OWORD v15[2] = (unint64_t)v14;
          unint64_t *v15 = (v12 + 259) & 0xFFFFFFFFFFFFFF00;
          *(void *)a2 = v14;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v13);
      }
      string_t v16 = *(string_t *)a2;
      *(void *)(a2 + 8) += 4;
      *(_DWORD *)&v16[v12] = 170140451;
      operator new[]();
    }
  }
  return result;
}

uint64_t arb::end(string_t *a1, uint64_t a2, unsigned int *a3, double a4, double a5, uint32x4_t a6)
{
  string_t v10 = a1[1];
  string_t v9 = a1[2];
  unint64_t v11 = (unint64_t)(v10 + 4);
  if (v9)
  {
    if (v11 >= *(void *)v9)
    {
      uint64_t v12 = (const char *)malloc_type_realloc(*((void **)v9 + 2), (unint64_t)(v10 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      unint64_t v13 = (char *)a1[2];
      *((void *)v13 + 2) = v12;
      *(void *)unint64_t v13 = (unint64_t)(v10 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v12;
    }
  }
  else
  {
    str_alloc(a1, v11);
  }
  string_t v14 = *a1;
  a1[1] += 4;
  *(_DWORD *)&v10[(void)v14] = 172248645;
  string_t v16 = a1[1];
  string_t v15 = a1[2];
  unint64_t v17 = (unint64_t)(v16 + 6);
  if (v15)
  {
    if (v17 >= *(void *)v15)
    {
      int v18 = (const char *)malloc_type_realloc(*((void **)v15 + 2), (unint64_t)(v16 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      unsigned int v19 = (char *)a1[2];
      *((void *)v19 + 2) = v18;
      *(void *)unsigned int v19 = (unint64_t)(v16 + 261) & 0xFFFFFFFFFFFFFF00;
      *a1 = v18;
    }
  }
  else
  {
    str_alloc(a1, v17);
  }
  string_t v20 = *a1;
  a1[1] += 6;
  int v21 = (char *)&v16[(void)v20];
  *((_WORD *)v21 + 2) = 15669;
  *(_DWORD *)int v21 = 1145905955;
  unsigned int v22 = *a3;
  string_t v24 = a1[1];
  string_t v23 = a1[2];
  unint64_t v25 = (unint64_t)(v24 + 8);
  if (v23)
  {
    if (v25 >= *(void *)v23)
    {
      int v26 = (const char *)malloc_type_realloc(*((void **)v23 + 2), (unint64_t)(v24 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      uint64_t v27 = (char *)a1[2];
      *((void *)v27 + 2) = v26;
      *(void *)uint64_t v27 = (unint64_t)(v24 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v26;
    }
  }
  else
  {
    str_alloc(a1, v25);
  }
  uint32x2_t v28 = (uint32x2_t)vdup_n_s32(v22);
  uint32x2_t v29 = vshl_u32(v28, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v30.i8 = vshl_u32(v28, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  a6.i32[0] = v22;
  unsigned __int32 v31 = vshrq_n_u32(a6, 0x1CuLL).u32[0];
  a6.i32[1] = HIBYTE(v22);
  a6.u64[1] = (unint64_t)v29;
  v30.i32[2] = v22 >> 4;
  v30.i32[3] = v22;
  v32.i64[0] = 0xF0000000FLL;
  v32.i64[1] = 0xF0000000FLL;
  uint32x4_t v33 = (uint32x4_t)vandq_s8((int8x16_t)a6, v32);
  int32x4_t v34 = (int32x4_t)vandq_s8(v30, v32);
  int32x4_t v35 = (int32x4_t)v33;
  v35.i32[0] = v31;
  v33.i32[0] = v22;
  int8x16_t v36 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v33);
  v37.i64[0] = 0xA0000000ALL;
  v37.i64[1] = 0xA0000000ALL;
  v38.i64[0] = 0x5700000057;
  v38.i64[1] = 0x5700000057;
  *(int8x8_t *)&v24[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v36, (int8x16_t)(*(_OWORD *)&v35 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v35, v38)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v37, (uint32x4_t)v34), (int8x16_t)(*(_OWORD *)&v34 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v34, v38))));
  string_t v40 = a1[1];
  string_t v39 = a1[2];
  unint64_t v41 = (unint64_t)(v40 + 8);
  a1[1] = v40 + 8;
  unint64_t v42 = (unint64_t)(v40 + 9);
  if (v39)
  {
    if (v42 >= *(void *)v39)
    {
      int v43 = (const char *)malloc_type_realloc(*((void **)v39 + 2), (v41 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      uint64_t v44 = (char *)a1[2];
      *((void *)v44 + 2) = v43;
      *(void *)uint64_t v44 = (v41 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v43;
    }
  }
  else
  {
    str_alloc(a1, v42);
  }
  string_t v45 = *a1;
  ++a1[1];
  v45[v41] = 58;
  unsigned int v46 = a3[1];
  string_t v48 = a1[1];
  string_t v47 = a1[2];
  unint64_t v49 = (unint64_t)(v48 + 8);
  if (v47)
  {
    if (v49 >= *(void *)v47)
    {
      int v50 = (const char *)malloc_type_realloc(*((void **)v47 + 2), (unint64_t)(v48 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      HGRect v51 = (char *)a1[2];
      *((void *)v51 + 2) = v50;
      *(void *)HGRect v51 = (unint64_t)(v48 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v50;
    }
  }
  else
  {
    str_alloc(a1, v49);
  }
  uint32x2_t v52 = (uint32x2_t)vdup_n_s32(v46);
  uint32x2_t v53 = vshl_u32(v52, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v54.i8 = vshl_u32(v52, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v36.i32[0] = v46;
  unsigned __int32 v55 = vshrq_n_u32((uint32x4_t)v36, 0x1CuLL).u32[0];
  v36.i32[1] = HIBYTE(v46);
  v36.u64[1] = (unint64_t)v53;
  v54.i32[2] = v46 >> 4;
  v54.i32[3] = v46;
  v56.i64[0] = 0xF0000000FLL;
  v56.i64[1] = 0xF0000000FLL;
  uint32x4_t v57 = (uint32x4_t)vandq_s8(v36, v56);
  int32x4_t v58 = (int32x4_t)vandq_s8(v54, v56);
  int32x4_t v59 = (int32x4_t)v57;
  v59.i32[0] = v55;
  v57.i32[0] = v46;
  int8x16_t v60 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v57);
  v61.i64[0] = 0xA0000000ALL;
  v61.i64[1] = 0xA0000000ALL;
  v62.i64[0] = 0x5700000057;
  v62.i64[1] = 0x5700000057;
  *(int8x8_t *)&v48[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v60, (int8x16_t)(*(_OWORD *)&v59 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v59, v62)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v61, (uint32x4_t)v58), (int8x16_t)(*(_OWORD *)&v58 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v58, v62))));
  string_t v64 = a1[1];
  string_t v63 = a1[2];
  unint64_t v65 = (unint64_t)(v64 + 8);
  a1[1] = v64 + 8;
  unint64_t v66 = (unint64_t)(v64 + 9);
  if (v63)
  {
    if (v66 >= *(void *)v63)
    {
      unsigned int v67 = (const char *)malloc_type_realloc(*((void **)v63 + 2), (v65 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v68 = (char *)a1[2];
      *((void *)v68 + 2) = v67;
      *(void *)int v68 = (v65 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v67;
    }
  }
  else
  {
    str_alloc(a1, v66);
  }
  string_t v69 = *a1;
  ++a1[1];
  v69[v65] = 58;
  unsigned int v70 = a3[2];
  string_t v72 = a1[1];
  string_t v71 = a1[2];
  unint64_t v73 = (unint64_t)(v72 + 8);
  if (v71)
  {
    if (v73 >= *(void *)v71)
    {
      uint64_t v74 = (const char *)malloc_type_realloc(*((void **)v71 + 2), (unint64_t)(v72 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      uint64_t v75 = (char *)a1[2];
      *((void *)v75 + 2) = v74;
      *(void *)uint64_t v75 = (unint64_t)(v72 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v74;
    }
  }
  else
  {
    str_alloc(a1, v73);
  }
  uint32x2_t v76 = (uint32x2_t)vdup_n_s32(v70);
  uint32x2_t v77 = vshl_u32(v76, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v78.i8 = vshl_u32(v76, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v60.i32[0] = v70;
  unsigned __int32 v79 = vshrq_n_u32((uint32x4_t)v60, 0x1CuLL).u32[0];
  v60.i32[1] = HIBYTE(v70);
  v60.u64[1] = (unint64_t)v77;
  v78.i32[2] = v70 >> 4;
  v78.i32[3] = v70;
  v80.i64[0] = 0xF0000000FLL;
  v80.i64[1] = 0xF0000000FLL;
  uint32x4_t v81 = (uint32x4_t)vandq_s8(v60, v80);
  int32x4_t v82 = (int32x4_t)vandq_s8(v78, v80);
  int32x4_t v83 = (int32x4_t)v81;
  v83.i32[0] = v79;
  v81.i32[0] = v70;
  int8x16_t v84 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v81);
  v85.i64[0] = 0xA0000000ALL;
  v85.i64[1] = 0xA0000000ALL;
  v86.i64[0] = 0x5700000057;
  v86.i64[1] = 0x5700000057;
  *(int8x8_t *)&v72[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v84, (int8x16_t)(*(_OWORD *)&v83 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v83, v86)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v85, (uint32x4_t)v82), (int8x16_t)(*(_OWORD *)&v82 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v82, v86))));
  string_t v88 = a1[1];
  string_t v87 = a1[2];
  unint64_t v89 = (unint64_t)(v88 + 8);
  a1[1] = v88 + 8;
  unint64_t v90 = (unint64_t)(v88 + 9);
  if (v87)
  {
    if (v90 >= *(void *)v87)
    {
      int v91 = (const char *)malloc_type_realloc(*((void **)v87 + 2), (v89 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      uint64_t v92 = (char *)a1[2];
      *((void *)v92 + 2) = v91;
      *(void *)uint64_t v92 = (v89 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v91;
    }
  }
  else
  {
    str_alloc(a1, v90);
  }
  string_t v93 = *a1;
  ++a1[1];
  v93[v89] = 58;
  unsigned int v94 = a3[3];
  string_t v96 = a1[1];
  string_t v95 = a1[2];
  unint64_t v97 = (unint64_t)(v96 + 8);
  if (v95)
  {
    if (v97 >= *(void *)v95)
    {
      int v98 = (const char *)malloc_type_realloc(*((void **)v95 + 2), (unint64_t)(v96 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      unint64_t v99 = (char *)a1[2];
      *((void *)v99 + 2) = v98;
      *(void *)unint64_t v99 = (unint64_t)(v96 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v98;
    }
  }
  else
  {
    str_alloc(a1, v97);
  }
  uint32x2_t v100 = (uint32x2_t)vdup_n_s32(v94);
  uint32x2_t v101 = vshl_u32(v100, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v102.i8 = vshl_u32(v100, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v84.i32[0] = v94;
  unsigned __int32 v103 = vshrq_n_u32((uint32x4_t)v84, 0x1CuLL).u32[0];
  v84.i32[1] = HIBYTE(v94);
  v84.u64[1] = (unint64_t)v101;
  v102.i32[2] = v94 >> 4;
  v102.i32[3] = v94;
  v104.i64[0] = 0xF0000000FLL;
  v104.i64[1] = 0xF0000000FLL;
  uint32x4_t v105 = (uint32x4_t)vandq_s8(v84, v104);
  int32x4_t v106 = (int32x4_t)vandq_s8(v102, v104);
  int32x4_t v107 = (int32x4_t)v105;
  v107.i32[0] = v103;
  v105.i32[0] = v94;
  int8x16_t v108 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v105);
  v109.i64[0] = 0xA0000000ALL;
  v109.i64[1] = 0xA0000000ALL;
  v110.i64[0] = 0x5700000057;
  v110.i64[1] = 0x5700000057;
  *(int8x8_t *)&v96[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v108, (int8x16_t)(*(_OWORD *)&v107 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v107, v110)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v109, (uint32x4_t)v106), (int8x16_t)(*(_OWORD *)&v106 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v106, v110))));
  string_t v112 = a1[1];
  string_t v111 = a1[2];
  unint64_t v113 = (unint64_t)(v112 + 8);
  a1[1] = v112 + 8;
  unint64_t v114 = (unint64_t)(v112 + 9);
  if (v111)
  {
    if (v114 >= *(void *)v111)
    {
      v115 = (const char *)malloc_type_realloc(*((void **)v111 + 2), (v113 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v116 = (char *)a1[2];
      *((void *)v116 + 2) = v115;
      *(void *)int v116 = (v113 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v115;
    }
  }
  else
  {
    str_alloc(a1, v114);
  }
  string_t v117 = *a1;
  ++a1[1];
  v117[v113] = 10;
  string_t v119 = a1[1];
  string_t v118 = a1[2];
  unint64_t v120 = (unint64_t)(v119 + 6);
  if ((*(_DWORD *)a2 & 0xFE00u) <= 0x5FF)
  {
    if (v118)
    {
      if (v120 >= *(void *)v118)
      {
        uint64_t v123 = (const char *)malloc_type_realloc(*((void **)v118 + 2), (unint64_t)(v119 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        int v124 = (char *)a1[2];
        *((void *)v124 + 2) = v123;
        *(void *)int v124 = (unint64_t)(v119 + 261) & 0xFFFFFFFFFFFFFF00;
        *a1 = v123;
      }
    }
    else
    {
      str_alloc(a1, v120);
    }
    string_t v133 = *a1;
    a1[1] += 6;
    int v134 = (char *)&v119[(void)v133];
    *((_WORD *)v134 + 2) = 15687;
    *(_DWORD *)int v134 = 1230185251;
    unsigned int v127 = *(_DWORD *)(a2 + 4);
    string_t v129 = a1[1];
    string_t v128 = a1[2];
    unint64_t v130 = (unint64_t)(v129 + 8);
    if (v128) {
      goto LABEL_50;
    }
LABEL_54:
    str_alloc(a1, v130);
    goto LABEL_55;
  }
  if (v118)
  {
    if (v120 >= *(void *)v118)
    {
      v121 = (const char *)malloc_type_realloc(*((void **)v118 + 2), (unint64_t)(v119 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      uint64_t v122 = (char *)a1[2];
      *((void *)v122 + 2) = v121;
      *(void *)uint64_t v122 = (unint64_t)(v119 + 261) & 0xFFFFFFFFFFFFFF00;
      *a1 = v121;
    }
  }
  else
  {
    str_alloc(a1, v120);
  }
  string_t v125 = *a1;
  a1[1] += 6;
  uint64_t v126 = (char *)&v119[(void)v125];
  *((_WORD *)v126 + 2) = 15687;
  *(_DWORD *)uint64_t v126 = 1230188335;
  unsigned int v127 = *(_DWORD *)(a2 + 4);
  string_t v129 = a1[1];
  string_t v128 = a1[2];
  unint64_t v130 = (unint64_t)(v129 + 8);
  if (!v128) {
    goto LABEL_54;
  }
LABEL_50:
  if (v130 >= *(void *)v128)
  {
    int v131 = (const char *)malloc_type_realloc(*((void **)v128 + 2), (unint64_t)(v129 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
    int v132 = (char *)a1[2];
    *((void *)v132 + 2) = v131;
    *(void *)int v132 = (unint64_t)(v129 + 263) & 0xFFFFFFFFFFFFFF00;
    *a1 = v131;
  }
LABEL_55:
  uint32x2_t v135 = (uint32x2_t)vdup_n_s32(v127);
  uint32x2_t v136 = vshl_u32(v135, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v137.i8 = vshl_u32(v135, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v108.i32[0] = v127;
  unsigned __int32 v138 = vshrq_n_u32((uint32x4_t)v108, 0x1CuLL).u32[0];
  v108.i32[1] = HIBYTE(v127);
  v108.u64[1] = (unint64_t)v136;
  v137.i32[2] = v127 >> 4;
  v137.i32[3] = v127;
  v139.i64[0] = 0xF0000000FLL;
  v139.i64[1] = 0xF0000000FLL;
  uint32x4_t v140 = (uint32x4_t)vandq_s8(v108, v139);
  int32x4_t v141 = (int32x4_t)vandq_s8(v137, v139);
  int32x4_t v142 = (int32x4_t)v140;
  v142.i32[0] = v138;
  v140.i32[0] = v127;
  int8x16_t v143 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v140);
  v144.i64[0] = 0xA0000000ALL;
  v144.i64[1] = 0xA0000000ALL;
  v145.i64[0] = 0x5700000057;
  v145.i64[1] = 0x5700000057;
  *(int8x8_t *)&v129[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v143, (int8x16_t)(*(_OWORD *)&v142 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v142, v145)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v144, (uint32x4_t)v141), (int8x16_t)(*(_OWORD *)&v141 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v141, v145))));
  string_t v147 = a1[1];
  string_t v146 = a1[2];
  unint64_t v148 = (unint64_t)(v147 + 8);
  a1[1] = v147 + 8;
  unint64_t v149 = (unint64_t)(v147 + 9);
  if (v146)
  {
    if (v149 >= *(void *)v146)
    {
      int v150 = (const char *)malloc_type_realloc(*((void **)v146 + 2), (v148 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v151 = (char *)a1[2];
      *((void *)v151 + 2) = v150;
      *(void *)int v151 = (v148 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v150;
    }
  }
  else
  {
    str_alloc(a1, v149);
  }
  string_t v152 = *a1;
  ++a1[1];
  v152[v148] = 58;
  unsigned int v153 = *(_DWORD *)(a2 + 8);
  string_t v155 = a1[1];
  string_t v154 = a1[2];
  unint64_t v156 = (unint64_t)(v155 + 8);
  if (v154)
  {
    if (v156 >= *(void *)v154)
    {
      unint64_t v157 = (const char *)malloc_type_realloc(*((void **)v154 + 2), (unint64_t)(v155 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v158 = (char *)a1[2];
      *((void *)v158 + 2) = v157;
      *(void *)v158 = (unint64_t)(v155 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v157;
    }
  }
  else
  {
    str_alloc(a1, v156);
  }
  uint32x2_t v159 = (uint32x2_t)vdup_n_s32(v153);
  uint32x2_t v160 = vshl_u32(v159, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v161.i8 = vshl_u32(v159, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v143.i32[0] = v153;
  unsigned __int32 v162 = vshrq_n_u32((uint32x4_t)v143, 0x1CuLL).u32[0];
  v143.i32[1] = HIBYTE(v153);
  v143.u64[1] = (unint64_t)v160;
  v161.i32[2] = v153 >> 4;
  v161.i32[3] = v153;
  v163.i64[0] = 0xF0000000FLL;
  v163.i64[1] = 0xF0000000FLL;
  uint32x4_t v164 = (uint32x4_t)vandq_s8(v143, v163);
  int32x4_t v165 = (int32x4_t)vandq_s8(v161, v163);
  int32x4_t v166 = (int32x4_t)v164;
  v166.i32[0] = v162;
  v164.i32[0] = v153;
  int8x16_t v167 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v164);
  v168.i64[0] = 0xA0000000ALL;
  v168.i64[1] = 0xA0000000ALL;
  v169.i64[0] = 0x5700000057;
  v169.i64[1] = 0x5700000057;
  *(int8x8_t *)&v155[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v167, (int8x16_t)(*(_OWORD *)&v166 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v166, v169)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v168, (uint32x4_t)v165), (int8x16_t)(*(_OWORD *)&v165 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v165, v169))));
  string_t v171 = a1[1];
  string_t v170 = a1[2];
  unint64_t v172 = (unint64_t)(v171 + 8);
  a1[1] = v171 + 8;
  unint64_t v173 = (unint64_t)(v171 + 9);
  if (v170)
  {
    if (v173 >= *(void *)v170)
    {
      signed int v174 = (const char *)malloc_type_realloc(*((void **)v170 + 2), (v172 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      uint64_t v175 = (char *)a1[2];
      *((void *)v175 + 2) = v174;
      *(void *)uint64_t v175 = (v172 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v174;
    }
  }
  else
  {
    str_alloc(a1, v173);
  }
  string_t v176 = *a1;
  ++a1[1];
  v176[v172] = 58;
  unsigned int v177 = *(_DWORD *)(a2 + 12);
  string_t v179 = a1[1];
  string_t v178 = a1[2];
  unint64_t v180 = (unint64_t)(v179 + 8);
  if (v178)
  {
    if (v180 >= *(void *)v178)
    {
      uint64_t v181 = (const char *)malloc_type_realloc(*((void **)v178 + 2), (unint64_t)(v179 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      uint64_t v182 = (char *)a1[2];
      *((void *)v182 + 2) = v181;
      *(void *)uint64_t v182 = (unint64_t)(v179 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v181;
    }
  }
  else
  {
    str_alloc(a1, v180);
  }
  uint32x2_t v183 = (uint32x2_t)vdup_n_s32(v177);
  uint32x2_t v184 = vshl_u32(v183, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v185.i8 = vshl_u32(v183, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v167.i32[0] = v177;
  unsigned __int32 v186 = vshrq_n_u32((uint32x4_t)v167, 0x1CuLL).u32[0];
  v167.i32[1] = HIBYTE(v177);
  v167.u64[1] = (unint64_t)v184;
  v185.i32[2] = v177 >> 4;
  v185.i32[3] = v177;
  v187.i64[0] = 0xF0000000FLL;
  v187.i64[1] = 0xF0000000FLL;
  uint32x4_t v188 = (uint32x4_t)vandq_s8(v167, v187);
  int32x4_t v189 = (int32x4_t)vandq_s8(v185, v187);
  int32x4_t v190 = (int32x4_t)v188;
  v190.i32[0] = v186;
  v188.i32[0] = v177;
  int8x16_t v191 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v188);
  v192.i64[0] = 0xA0000000ALL;
  v192.i64[1] = 0xA0000000ALL;
  v193.i64[0] = 0x5700000057;
  v193.i64[1] = 0x5700000057;
  *(int8x8_t *)&v179[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v191, (int8x16_t)(*(_OWORD *)&v190 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v190, v193)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v192, (uint32x4_t)v189), (int8x16_t)(*(_OWORD *)&v189 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v189, v193))));
  string_t v195 = a1[1];
  string_t v194 = a1[2];
  unint64_t v196 = (unint64_t)(v195 + 8);
  a1[1] = v195 + 8;
  unint64_t v197 = (unint64_t)(v195 + 9);
  if (v194)
  {
    if (v197 >= *(void *)v194)
    {
      uint64_t v198 = (const char *)malloc_type_realloc(*((void **)v194 + 2), (v196 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      uint64_t v199 = (char *)a1[2];
      *((void *)v199 + 2) = v198;
      *(void *)uint64_t v199 = (v196 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v198;
    }
  }
  else
  {
    str_alloc(a1, v197);
  }
  string_t v200 = *a1;
  ++a1[1];
  v200[v196] = 58;
  unsigned int v201 = *(_DWORD *)(a2 + 16);
  string_t v203 = a1[1];
  string_t v202 = a1[2];
  unint64_t v204 = (unint64_t)(v203 + 8);
  if (v202)
  {
    if (v204 >= *(void *)v202)
    {
      uint64_t v205 = (const char *)malloc_type_realloc(*((void **)v202 + 2), (unint64_t)(v203 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      uint64_t v206 = (char *)a1[2];
      *((void *)v206 + 2) = v205;
      *(void *)uint64_t v206 = (unint64_t)(v203 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v205;
    }
  }
  else
  {
    str_alloc(a1, v204);
  }
  uint32x2_t v207 = (uint32x2_t)vdup_n_s32(v201);
  uint32x2_t v208 = vshl_u32(v207, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v209.i8 = vshl_u32(v207, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v191.i32[0] = v201;
  unsigned __int32 v210 = vshrq_n_u32((uint32x4_t)v191, 0x1CuLL).u32[0];
  v191.i32[1] = HIBYTE(v201);
  v191.u64[1] = (unint64_t)v208;
  v209.i32[2] = v201 >> 4;
  v209.i32[3] = v201;
  v211.i64[0] = 0xF0000000FLL;
  v211.i64[1] = 0xF0000000FLL;
  uint32x4_t v212 = (uint32x4_t)vandq_s8(v191, v211);
  int32x4_t v213 = (int32x4_t)vandq_s8(v209, v211);
  int32x4_t v214 = (int32x4_t)v212;
  v214.i32[0] = v210;
  v212.i32[0] = v201;
  int8x16_t v215 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v212);
  v216.i64[0] = 0xA0000000ALL;
  v216.i64[1] = 0xA0000000ALL;
  v217.i64[0] = 0x5700000057;
  v217.i64[1] = 0x5700000057;
  *(int8x8_t *)&v203[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v215, (int8x16_t)(*(_OWORD *)&v214 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v214, v217)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v216, (uint32x4_t)v213), (int8x16_t)(*(_OWORD *)&v213 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v213, v217))));
  string_t v219 = a1[1];
  string_t v218 = a1[2];
  unint64_t v220 = (unint64_t)(v219 + 8);
  a1[1] = v219 + 8;
  unint64_t v221 = (unint64_t)(v219 + 9);
  if (v218)
  {
    if (v221 >= *(void *)v218)
    {
      int v222 = (const char *)malloc_type_realloc(*((void **)v218 + 2), (v220 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v223 = (char *)a1[2];
      *((void *)v223 + 2) = v222;
      *(void *)v223 = (v220 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v222;
    }
  }
  else
  {
    str_alloc(a1, v221);
  }
  string_t v224 = *a1;
  ++a1[1];
  v224[v220] = 58;
  unsigned int v225 = *(unsigned __int16 *)(a2 + 20);
  string_t v227 = a1[1];
  string_t v226 = a1[2];
  unint64_t v228 = (unint64_t)(v227 + 4);
  if (v226)
  {
    if (v228 >= *(void *)v226)
    {
      int v229 = (const char *)malloc_type_realloc(*((void **)v226 + 2), (unint64_t)(v227 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      int v230 = (char *)a1[2];
      *((void *)v230 + 2) = v229;
      *(void *)int v230 = (unint64_t)(v227 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v229;
    }
  }
  else
  {
    str_alloc(a1, v228);
  }
  unsigned int v231 = (char *)&v227[(void)*a1];
  int v232 = (v225 >> 12) + 87;
  if (v225 < 0xA000) {
    LOBYTE(v232) = (v225 >> 12) | 0x30;
  }
  *unsigned int v231 = v232;
  int32x2_t v233 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v225), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v234 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v233), (int8x8_t)(*(void *)&v233 | 0x3000000030), (int8x8_t)vadd_s32(v233, (int32x2_t)0x5700000057));
  v231[2] = v234.i8[4];
  v231[1] = v234.i8[0];
  if ((v225 & 0xF) >= 0xA) {
    char v235 = (v225 & 0xF) + 87;
  }
  else {
    char v235 = v225 & 0xF | 0x30;
  }
  v231[3] = v235;
  string_t v237 = a1[1];
  string_t v236 = a1[2];
  unint64_t v238 = (unint64_t)(v237 + 4);
  a1[1] = v237 + 4;
  unint64_t v239 = (unint64_t)(v237 + 5);
  if (v236)
  {
    if (v239 >= *(void *)v236)
    {
      int v240 = (const char *)malloc_type_realloc(*((void **)v236 + 2), (v238 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      uint64_t v241 = (char *)a1[2];
      *((void *)v241 + 2) = v240;
      *(void *)uint64_t v241 = (v238 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v240;
    }
  }
  else
  {
    str_alloc(a1, v239);
  }
  string_t v242 = *a1;
  ++a1[1];
  v242[v238] = 58;
  unsigned int v243 = *(unsigned __int16 *)(a2 + 22);
  string_t v245 = a1[1];
  string_t v244 = a1[2];
  unint64_t v246 = (unint64_t)(v245 + 4);
  if (v244)
  {
    if (v246 >= *(void *)v244)
    {
      v247 = (const char *)malloc_type_realloc(*((void **)v244 + 2), (unint64_t)(v245 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      unsigned int v248 = (char *)a1[2];
      *((void *)v248 + 2) = v247;
      *(void *)unsigned int v248 = (unint64_t)(v245 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v247;
    }
  }
  else
  {
    str_alloc(a1, v246);
  }
  int v249 = (char *)&v245[(void)*a1];
  int v250 = (v243 >> 12) + 87;
  if (v243 < 0xA000) {
    LOBYTE(v250) = (v243 >> 12) | 0x30;
  }
  *int v249 = v250;
  int32x2_t v251 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v243), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v252 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v251), (int8x8_t)(*(void *)&v251 | 0x3000000030), (int8x8_t)vadd_s32(v251, (int32x2_t)0x5700000057));
  v249[2] = v252.i8[4];
  v249[1] = v252.i8[0];
  if ((v243 & 0xF) >= 0xA) {
    char v253 = (v243 & 0xF) + 87;
  }
  else {
    char v253 = v243 & 0xF | 0x30;
  }
  v249[3] = v253;
  string_t v255 = a1[1];
  string_t v254 = a1[2];
  unint64_t v256 = (unint64_t)(v255 + 4);
  a1[1] = v255 + 4;
  unint64_t v257 = (unint64_t)(v255 + 5);
  if (v254)
  {
    if (v257 >= *(void *)v254)
    {
      v258 = (const char *)malloc_type_realloc(*((void **)v254 + 2), (v256 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      unsigned int v259 = (char *)a1[2];
      *((void *)v259 + 2) = v258;
      *(void *)unsigned int v259 = (v256 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v258;
    }
  }
  else
  {
    str_alloc(a1, v257);
  }
  string_t v260 = *a1;
  ++a1[1];
  v260[v256] = 58;
  unsigned int v261 = *(unsigned __int16 *)(a2 + 24);
  string_t v263 = a1[1];
  string_t v262 = a1[2];
  unint64_t v264 = (unint64_t)(v263 + 4);
  if (v262)
  {
    if (v264 >= *(void *)v262)
    {
      v265 = (const char *)malloc_type_realloc(*((void **)v262 + 2), (unint64_t)(v263 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      unsigned int v266 = (char *)a1[2];
      *((void *)v266 + 2) = v265;
      *(void *)unsigned int v266 = (unint64_t)(v263 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v265;
    }
  }
  else
  {
    str_alloc(a1, v264);
  }
  v267 = (char *)&v263[(void)*a1];
  int v268 = (v261 >> 12) + 87;
  if (v261 < 0xA000) {
    LOBYTE(v268) = (v261 >> 12) | 0x30;
  }
  char *v267 = v268;
  int32x2_t v269 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v261), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v270 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v269), (int8x8_t)(*(void *)&v269 | 0x3000000030), (int8x8_t)vadd_s32(v269, (int32x2_t)0x5700000057));
  v267[2] = v270.i8[4];
  v267[1] = v270.i8[0];
  if ((v261 & 0xF) >= 0xA) {
    char v271 = (v261 & 0xF) + 87;
  }
  else {
    char v271 = v261 & 0xF | 0x30;
  }
  v267[3] = v271;
  string_t v273 = a1[1];
  string_t v272 = a1[2];
  unint64_t v274 = (unint64_t)(v273 + 4);
  a1[1] = v273 + 4;
  unint64_t v275 = (unint64_t)(v273 + 5);
  if (v272)
  {
    if (v275 >= *(void *)v272)
    {
      unsigned __int16 v276 = (const char *)malloc_type_realloc(*((void **)v272 + 2), (v274 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v277 = (char *)a1[2];
      *((void *)v277 + 2) = v276;
      *(void *)int v277 = (v274 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v276;
    }
  }
  else
  {
    str_alloc(a1, v275);
  }
  string_t v278 = *a1;
  ++a1[1];
  v278[v274] = 58;
  unsigned int v279 = *(unsigned __int8 *)(a2 + 26);
  string_t v281 = a1[1];
  string_t v280 = a1[2];
  unint64_t v282 = (unint64_t)(v281 + 2);
  if (v280)
  {
    if (v282 >= *(void *)v280)
    {
      v283 = (const char *)malloc_type_realloc(*((void **)v280 + 2), (unint64_t)(v281 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      int v284 = (char *)a1[2];
      *((void *)v284 + 2) = v283;
      *(void *)int v284 = (unint64_t)(v281 + 257) & 0xFFFFFFFFFFFFFF00;
      *a1 = v283;
    }
  }
  else
  {
    str_alloc(a1, v282);
  }
  v285 = (char *)&v281[(void)*a1];
  int v286 = (v279 >> 4) + 87;
  if (v279 < 0xA0) {
    LOBYTE(v286) = (v279 >> 4) | 0x30;
  }
  char *v285 = v286;
  if ((v279 & 0xF) >= 0xA) {
    char v287 = (v279 & 0xF) + 87;
  }
  else {
    char v287 = v279 & 0xF | 0x30;
  }
  v285[1] = v287;
  string_t v288 = a1[1];
  string_t v289 = a1[2];
  string_t v290 = v288 + 2;
  a1[1] = v288 + 2;
  unsigned int v291 = *(unsigned __int8 *)(a2 + 27);
  unint64_t v292 = (unint64_t)(v288 + 4);
  if (v289)
  {
    if (v292 >= *(void *)v289)
    {
      size_t v293 = (unint64_t)(v288 + 259) & 0xFFFFFFFFFFFFFF00;
      int v294 = (const char *)malloc_type_realloc(*((void **)v289 + 2), v293, 0xCCCD1039uLL);
      v295 = (char *)a1[2];
      *((void *)v295 + 2) = v294;
      *(void *)v295 = v293;
      *a1 = v294;
    }
  }
  else
  {
    str_alloc(a1, v292);
  }
  int v296 = (char *)&v290[(void)*a1];
  int v297 = (v291 >> 4) + 87;
  if (v291 < 0xA0) {
    LOBYTE(v297) = (v291 >> 4) | 0x30;
  }
  *int v296 = v297;
  if ((v291 & 0xF) >= 0xA) {
    char v298 = (v291 & 0xF) + 87;
  }
  else {
    char v298 = v291 & 0xF | 0x30;
  }
  v296[1] = v298;
  string_t v300 = a1[1];
  string_t v299 = a1[2];
  unint64_t v301 = (unint64_t)(v300 + 2);
  a1[1] = v300 + 2;
  unint64_t v302 = (unint64_t)(v300 + 3);
  if (v299)
  {
    if (v302 >= *(void *)v299)
    {
      v303 = (const char *)malloc_type_realloc(*((void **)v299 + 2), (v301 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v304 = (char *)a1[2];
      *((void *)v304 + 2) = v303;
      *(void *)v304 = (v301 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v303;
    }
  }
  else
  {
    str_alloc(a1, v302);
  }
  string_t v305 = *a1;
  ++a1[1];
  v305[v301] = 58;
  unsigned int v306 = *(unsigned __int8 *)(a2 + 28);
  string_t v308 = a1[1];
  string_t v307 = a1[2];
  unint64_t v309 = (unint64_t)(v308 + 2);
  if (v307)
  {
    if (v309 >= *(void *)v307)
    {
      uint64_t v310 = (const char *)malloc_type_realloc(*((void **)v307 + 2), (unint64_t)(v308 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      unint64_t v311 = (char *)a1[2];
      *((void *)v311 + 2) = v310;
      *(void *)unint64_t v311 = (unint64_t)(v308 + 257) & 0xFFFFFFFFFFFFFF00;
      *a1 = v310;
    }
  }
  else
  {
    str_alloc(a1, v309);
  }
  v312 = (char *)&v308[(void)*a1];
  int v313 = (v306 >> 4) + 87;
  if (v306 < 0xA0) {
    LOBYTE(v313) = (v306 >> 4) | 0x30;
  }
  char *v312 = v313;
  if ((v306 & 0xF) >= 0xA) {
    char v314 = (v306 & 0xF) + 87;
  }
  else {
    char v314 = v306 & 0xF | 0x30;
  }
  v312[1] = v314;
  string_t v315 = a1[1];
  string_t v316 = a1[2];
  string_t v317 = v315 + 2;
  a1[1] = v315 + 2;
  unsigned int v318 = *(unsigned __int8 *)(a2 + 29);
  unint64_t v319 = (unint64_t)(v315 + 4);
  if (v316)
  {
    if (v319 >= *(void *)v316)
    {
      size_t v320 = (unint64_t)(v315 + 259) & 0xFFFFFFFFFFFFFF00;
      signed int v321 = (const char *)malloc_type_realloc(*((void **)v316 + 2), v320, 0xCCCD1039uLL);
      uint64_t v322 = (char *)a1[2];
      *((void *)v322 + 2) = v321;
      *(void *)uint64_t v322 = v320;
      *a1 = v321;
    }
  }
  else
  {
    str_alloc(a1, v319);
  }
  uint64_t v323 = (char *)&v317[(void)*a1];
  int v324 = (v318 >> 4) + 87;
  if (v318 < 0xA0) {
    LOBYTE(v324) = (v318 >> 4) | 0x30;
  }
  *uint64_t v323 = v324;
  if ((v318 & 0xF) >= 0xA) {
    char v325 = (v318 & 0xF) + 87;
  }
  else {
    char v325 = v318 & 0xF | 0x30;
  }
  v323[1] = v325;
  string_t v327 = a1[1];
  string_t v326 = a1[2];
  unint64_t v328 = (unint64_t)(v327 + 2);
  a1[1] = v327 + 2;
  unint64_t v329 = (unint64_t)(v327 + 3);
  if (v326)
  {
    if (v329 >= *(void *)v326)
    {
      v330 = (const char *)malloc_type_realloc(*((void **)v326 + 2), (v328 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v331 = (char *)a1[2];
      *((void *)v331 + 2) = v330;
      *(void *)v331 = (v328 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v330;
    }
  }
  else
  {
    str_alloc(a1, v329);
  }
  string_t v332 = *a1;
  ++a1[1];
  v332[v328] = 58;
  unsigned int v333 = *(unsigned __int16 *)(a2 + 30);
  string_t v335 = a1[1];
  string_t v334 = a1[2];
  unint64_t v336 = (unint64_t)(v335 + 4);
  if (v334)
  {
    if (v336 >= *(void *)v334)
    {
      v337 = (const char *)malloc_type_realloc(*((void **)v334 + 2), (unint64_t)(v335 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      uint64_t v338 = (char *)a1[2];
      *((void *)v338 + 2) = v337;
      *(void *)uint64_t v338 = (unint64_t)(v335 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v337;
    }
  }
  else
  {
    str_alloc(a1, v336);
  }
  uint64_t v339 = (char *)&v335[(void)*a1];
  int v340 = (v333 >> 12) + 87;
  if (v333 < 0xA000) {
    LOBYTE(v340) = (v333 >> 12) | 0x30;
  }
  *uint64_t v339 = v340;
  int32x2_t v341 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v333), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v342 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v341), (int8x8_t)(*(void *)&v341 | 0x3000000030), (int8x8_t)vadd_s32(v341, (int32x2_t)0x5700000057));
  v339[2] = v342.i8[4];
  v339[1] = v342.i8[0];
  if ((v333 & 0xF) >= 0xA) {
    char v343 = (v333 & 0xF) + 87;
  }
  else {
    char v343 = v333 & 0xF | 0x30;
  }
  v339[3] = v343;
  string_t v345 = a1[1];
  string_t v344 = a1[2];
  unint64_t v346 = (unint64_t)(v345 + 4);
  a1[1] = v345 + 4;
  unint64_t v347 = (unint64_t)(v345 + 5);
  if (v344)
  {
    if (v347 >= *(void *)v344)
    {
      unint64_t v348 = (const char *)malloc_type_realloc(*((void **)v344 + 2), (v346 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      size_t v349 = (char *)a1[2];
      *((void *)v349 + 2) = v348;
      *(void *)size_t v349 = (v346 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v348;
    }
  }
  else
  {
    str_alloc(a1, v347);
  }
  string_t v350 = *a1;
  ++a1[1];
  v350[v346] = 58;
  unsigned int v351 = *(unsigned __int16 *)(a2 + 32);
  string_t v353 = a1[1];
  string_t v352 = a1[2];
  unint64_t v354 = (unint64_t)(v353 + 4);
  if (v352)
  {
    if (v354 >= *(void *)v352)
    {
      unint64_t v355 = (const char *)malloc_type_realloc(*((void **)v352 + 2), (unint64_t)(v353 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v356 = (char *)a1[2];
      *((void *)v356 + 2) = v355;
      *(void *)v356 = (unint64_t)(v353 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v355;
    }
  }
  else
  {
    str_alloc(a1, v354);
  }
  v357 = (char *)&v353[(void)*a1];
  int v358 = (v351 >> 12) + 87;
  if (v351 < 0xA000) {
    LOBYTE(v358) = (v351 >> 12) | 0x30;
  }
  char *v357 = v358;
  int32x2_t v359 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v351), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v360 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v359), (int8x8_t)(*(void *)&v359 | 0x3000000030), (int8x8_t)vadd_s32(v359, (int32x2_t)0x5700000057));
  v357[2] = v360.i8[4];
  v357[1] = v360.i8[0];
  if ((v351 & 0xF) >= 0xA) {
    char v361 = (v351 & 0xF) + 87;
  }
  else {
    char v361 = v351 & 0xF | 0x30;
  }
  v357[3] = v361;
  string_t v363 = a1[1];
  string_t v362 = a1[2];
  unint64_t v364 = (unint64_t)(v363 + 4);
  a1[1] = v363 + 4;
  unint64_t v365 = (unint64_t)(v363 + 5);
  if (v362)
  {
    if (v365 >= *(void *)v362)
    {
      v366 = (const char *)malloc_type_realloc(*((void **)v362 + 2), (v364 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v367 = (char *)a1[2];
      *((void *)v367 + 2) = v366;
      *(void *)v367 = (v364 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v366;
    }
  }
  else
  {
    str_alloc(a1, v365);
  }
  string_t v368 = *a1;
  ++a1[1];
  v368[v364] = 58;
  unsigned int v369 = *(unsigned __int16 *)(a2 + 34);
  string_t v371 = a1[1];
  string_t v370 = a1[2];
  unint64_t v372 = (unint64_t)(v371 + 4);
  if (v370)
  {
    if (v372 >= *(void *)v370)
    {
      int v373 = (const char *)malloc_type_realloc(*((void **)v370 + 2), (unint64_t)(v371 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      int v374 = (char *)a1[2];
      *((void *)v374 + 2) = v373;
      *(void *)int v374 = (unint64_t)(v371 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v373;
    }
  }
  else
  {
    str_alloc(a1, v372);
  }
  int v375 = (char *)&v371[(void)*a1];
  int v376 = (v369 >> 12) + 87;
  if (v369 < 0xA000) {
    LOBYTE(v376) = (v369 >> 12) | 0x30;
  }
  *int v375 = v376;
  int32x2_t v377 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v369), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v378 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v377), (int8x8_t)(*(void *)&v377 | 0x3000000030), (int8x8_t)vadd_s32(v377, (int32x2_t)0x5700000057));
  v375[2] = v378.i8[4];
  v375[1] = v378.i8[0];
  if ((v369 & 0xF) >= 0xA) {
    char v379 = (v369 & 0xF) + 87;
  }
  else {
    char v379 = v369 & 0xF | 0x30;
  }
  v375[3] = v379;
  string_t v381 = a1[1];
  string_t v380 = a1[2];
  unint64_t v382 = (unint64_t)(v381 + 4);
  a1[1] = v381 + 4;
  unint64_t v383 = (unint64_t)(v381 + 5);
  if (v380)
  {
    if (v383 >= *(void *)v380)
    {
      char v384 = (const char *)malloc_type_realloc(*((void **)v380 + 2), (v382 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v385 = (char *)a1[2];
      *((void *)v385 + 2) = v384;
      *(void *)int v385 = (v382 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v384;
    }
  }
  else
  {
    str_alloc(a1, v383);
  }
  string_t v386 = *a1;
  ++a1[1];
  v386[v382] = 58;
  unsigned int v387 = *(unsigned __int16 *)(a2 + 36);
  string_t v389 = a1[1];
  string_t v388 = a1[2];
  unint64_t v390 = (unint64_t)(v389 + 4);
  if (v388)
  {
    if (v390 >= *(void *)v388)
    {
      int v391 = (const char *)malloc_type_realloc(*((void **)v388 + 2), (unint64_t)(v389 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      char v392 = (char *)a1[2];
      *((void *)v392 + 2) = v391;
      *(void *)char v392 = (unint64_t)(v389 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v391;
    }
  }
  else
  {
    str_alloc(a1, v390);
  }
  int v393 = (char *)&v389[(void)*a1];
  int v394 = (v387 >> 12) + 87;
  if (v387 < 0xA000) {
    LOBYTE(v394) = (v387 >> 12) | 0x30;
  }
  *int v393 = v394;
  int32x2_t v395 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v387), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v396 = (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v395);
  *(int32x2_t *)v215.i8 = vadd_s32(v395, (int32x2_t)0x5700000057);
  double v397 = COERCE_DOUBLE(vbsl_s8(v396, (int8x8_t)(*(void *)&v395 | 0x3000000030), *(int8x8_t *)v215.i8));
  v393[2] = BYTE4(v397);
  v393[1] = LOBYTE(v397);
  if ((v387 & 0xF) >= 0xA) {
    char v398 = (v387 & 0xF) + 87;
  }
  else {
    char v398 = v387 & 0xF | 0x30;
  }
  v393[3] = v398;
  string_t v400 = a1[1];
  string_t v399 = a1[2];
  unint64_t v401 = (unint64_t)(v400 + 4);
  a1[1] = v400 + 4;
  unint64_t v402 = (unint64_t)(v400 + 5);
  if (v399)
  {
    if (v402 >= *(void *)v399)
    {
      int v403 = (const char *)malloc_type_realloc(*((void **)v399 + 2), (v401 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v404 = (char *)a1[2];
      *((void *)v404 + 2) = v403;
      *(void *)v404 = (v401 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v403;
    }
  }
  else
  {
    str_alloc(a1, v402);
  }
  string_t v405 = *a1;
  ++a1[1];
  v405[v401] = 58;
  unsigned int v406 = *(unsigned __int8 *)(a2 + 40);
  string_t v408 = a1[1];
  string_t v407 = a1[2];
  unint64_t v409 = (unint64_t)(v408 + 2);
  if (v407)
  {
    if (v409 >= *(void *)v407)
    {
      int v410 = (const char *)malloc_type_realloc(*((void **)v407 + 2), (unint64_t)(v408 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      char v411 = (char *)a1[2];
      *((void *)v411 + 2) = v410;
      *(void *)char v411 = (unint64_t)(v408 + 257) & 0xFFFFFFFFFFFFFF00;
      *a1 = v410;
    }
  }
  else
  {
    str_alloc(a1, v409);
  }
  int v412 = (char *)&v408[(void)*a1];
  int v413 = (v406 >> 4) + 87;
  if (v406 < 0xA0) {
    LOBYTE(v413) = (v406 >> 4) | 0x30;
  }
  *int v412 = v413;
  if ((v406 & 0xF) >= 0xA) {
    char v414 = (v406 & 0xF) + 87;
  }
  else {
    char v414 = v406 & 0xF | 0x30;
  }
  v412[1] = v414;
  string_t v416 = a1[1];
  string_t v415 = a1[2];
  unint64_t v417 = (unint64_t)(v416 + 2);
  a1[1] = v416 + 2;
  unint64_t v418 = (unint64_t)(v416 + 3);
  if (v415)
  {
    if (v418 >= *(void *)v415)
    {
      int v419 = (const char *)malloc_type_realloc(*((void **)v415 + 2), (v417 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v420 = (char *)a1[2];
      *((void *)v420 + 2) = v419;
      *(void *)int v420 = (v417 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v419;
    }
  }
  else
  {
    str_alloc(a1, v418);
  }
  string_t v421 = *a1;
  ++a1[1];
  v421[v417] = 58;
  char v422 = *(unsigned char *)(a2 + 41);
  unint64_t v424 = (unint64_t)a1[1];
  string_t v423 = a1[2];
  unint64_t v425 = v424 + 1;
  if (v423)
  {
    if (v425 >= *(void *)v423)
    {
      v426 = (const char *)malloc_type_realloc(*((void **)v423 + 2), (v424 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v427 = (char *)a1[2];
      *((void *)v427 + 2) = v426;
      *(void *)v427 = (v424 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v426;
    }
  }
  else
  {
    str_alloc(a1, v425);
  }
  if ((v422 & 0xFu) >= 0xA) {
    char v428 = (v422 & 0xF) + 87;
  }
  else {
    char v428 = v422 & 0xF | 0x30;
  }
  (*a1)[v424] = v428;
  string_t v430 = a1[1];
  string_t v429 = a1[2];
  unint64_t v431 = (unint64_t)(v430 + 1);
  a1[1] = v430 + 1;
  unint64_t v432 = (unint64_t)(v430 + 2);
  if (v429)
  {
    if (v432 >= *(void *)v429)
    {
      int v433 = (const char *)malloc_type_realloc(*((void **)v429 + 2), (v431 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v434 = (char *)a1[2];
      *((void *)v434 + 2) = v433;
      *(void *)int v434 = (v431 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v433;
    }
  }
  else
  {
    str_alloc(a1, v432);
  }
  string_t v435 = *a1;
  ++a1[1];
  v435[v431] = 58;
  char v436 = *(unsigned char *)(a2 + 42);
  unint64_t v438 = (unint64_t)a1[1];
  string_t v437 = a1[2];
  unint64_t v439 = v438 + 1;
  if (v437)
  {
    if (v439 >= *(void *)v437)
    {
      v440 = (const char *)malloc_type_realloc(*((void **)v437 + 2), (v438 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v441 = (char *)a1[2];
      *((void *)v441 + 2) = v440;
      *(void *)int v441 = (v438 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v440;
    }
  }
  else
  {
    str_alloc(a1, v439);
  }
  if ((v436 & 0xFu) >= 0xA) {
    char v442 = (v436 & 0xF) + 87;
  }
  else {
    char v442 = v436 & 0xF | 0x30;
  }
  (*a1)[v438] = v442;
  string_t v444 = a1[1];
  string_t v443 = a1[2];
  unint64_t v445 = (unint64_t)(v444 + 1);
  a1[1] = v444 + 1;
  unint64_t v446 = (unint64_t)(v444 + 2);
  if (v443)
  {
    if (v446 >= *(void *)v443)
    {
      v447 = (const char *)malloc_type_realloc(*((void **)v443 + 2), (v445 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v448 = (char *)a1[2];
      *((void *)v448 + 2) = v447;
      *(void *)v448 = (v445 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v447;
    }
  }
  else
  {
    str_alloc(a1, v446);
  }
  string_t v449 = *a1;
  ++a1[1];
  v449[v445] = 58;
  char v450 = *(unsigned char *)(a2 + 43);
  unint64_t v452 = (unint64_t)a1[1];
  string_t v451 = a1[2];
  unint64_t v453 = v452 + 1;
  if (v451)
  {
    if (v453 >= *(void *)v451)
    {
      int v454 = (const char *)malloc_type_realloc(*((void **)v451 + 2), (v452 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v455 = (char *)a1[2];
      *((void *)v455 + 2) = v454;
      *(void *)v455 = (v452 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v454;
    }
  }
  else
  {
    str_alloc(a1, v453);
  }
  if ((v450 & 0xFu) >= 0xA) {
    char v456 = (v450 & 0xF) + 87;
  }
  else {
    char v456 = v450 & 0xF | 0x30;
  }
  (*a1)[v452] = v456;
  string_t v458 = a1[1];
  string_t v457 = a1[2];
  unint64_t v459 = (unint64_t)(v458 + 1);
  a1[1] = v458 + 1;
  unint64_t v460 = (unint64_t)(v458 + 2);
  if (v457)
  {
    if (v460 >= *(void *)v457)
    {
      int v461 = (const char *)malloc_type_realloc(*((void **)v457 + 2), (v459 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v462 = (char *)a1[2];
      *((void *)v462 + 2) = v461;
      *(void *)v462 = (v459 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v461;
    }
  }
  else
  {
    str_alloc(a1, v460);
  }
  string_t v463 = *a1;
  ++a1[1];
  v463[v459] = 10;

  return str_close(a1, v397, *(double *)&v396, (uint32x4_t)v215);
}

const char *str_ext(string_t *a1, uint64_t a2, uint64_t a3)
{
  string_t v6 = a1[1];
  string_t v5 = a1[2];
  unint64_t v7 = (unint64_t)&v6[a3];
  if (v5)
  {
    if (v7 >= *(void *)v5)
    {
      size_t v8 = (v7 + 255) & 0xFFFFFFFFFFFFFF00;
      string_t v9 = (const char *)malloc_type_realloc(*((void **)v5 + 2), v8, 0xCCCD1039uLL);
      string_t v10 = (char *)a1[2];
      *((void *)v10 + 2) = v9;
      *(void *)string_t v10 = v8;
      *a1 = v9;
    }
  }
  else
  {
    str_alloc(a1, v7);
  }
  string_t v11 = *a1;
  a1[1] += a2;
  return &v6[(void)v11];
}

size_t str_puts(string_t *a1, const char *__src, size_t __n)
{
  string_t v7 = a1[1];
  string_t v6 = a1[2];
  unint64_t v8 = (unint64_t)&v7[__n];
  if (v6)
  {
    if (v8 >= *(void *)v6)
    {
      size_t v9 = (v8 + 255) & 0xFFFFFFFFFFFFFF00;
      string_t v10 = (const char *)malloc_type_realloc(*((void **)v6 + 2), v9, 0xCCCD1039uLL);
      string_t v11 = (char *)a1[2];
      *((void *)v11 + 2) = v10;
      *(void *)string_t v11 = v9;
      *a1 = v10;
    }
  }
  else
  {
    str_alloc(a1, v8);
  }
  string_t v12 = *a1;
  a1[1] += __n;
  memcpy((void *)&v7[(void)v12], __src, __n);
  return __n;
}

void glsl::end(string_t *a1, uint64_t a2, unsigned int *a3, char a4, double a5, double a6, uint32x4_t a7)
{
  string_t v12 = a1[1];
  string_t v11 = a1[2];
  unint64_t v13 = (unint64_t)(v12 + 6);
  if (v11)
  {
    if (v13 >= *(void *)v11)
    {
      string_t v14 = (const char *)malloc_type_realloc(*((void **)v11 + 2), (unint64_t)(v12 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      string_t v15 = (char *)a1[2];
      *((void *)v15 + 2) = v14;
      *(void *)string_t v15 = (unint64_t)(v12 + 261) & 0xFFFFFFFFFFFFFF00;
      *a1 = v14;
    }
  }
  else
  {
    str_alloc(a1, v13);
  }
  string_t v16 = *a1;
  a1[1] += 6;
  unint64_t v17 = (char *)&v12[(void)v16];
  *((_WORD *)v17 + 2) = 15669;
  *(_DWORD *)unint64_t v17 = 1145909039;
  unsigned int v18 = *a3;
  string_t v20 = a1[1];
  string_t v19 = a1[2];
  unint64_t v21 = (unint64_t)(v20 + 8);
  if (v19)
  {
    if (v21 >= *(void *)v19)
    {
      unsigned int v22 = (const char *)malloc_type_realloc(*((void **)v19 + 2), (unint64_t)(v20 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      string_t v23 = (char *)a1[2];
      *((void *)v23 + 2) = v22;
      *(void *)string_t v23 = (unint64_t)(v20 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v22;
    }
  }
  else
  {
    str_alloc(a1, v21);
  }
  uint32x2_t v24 = (uint32x2_t)vdup_n_s32(v18);
  uint32x2_t v25 = vshl_u32(v24, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v26.i8 = vshl_u32(v24, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  a7.i32[0] = v18;
  unsigned __int32 v27 = vshrq_n_u32(a7, 0x1CuLL).u32[0];
  a7.i32[1] = HIBYTE(v18);
  a7.u64[1] = (unint64_t)v25;
  v26.i32[2] = v18 >> 4;
  v26.i32[3] = v18;
  v28.i64[0] = 0xF0000000FLL;
  v28.i64[1] = 0xF0000000FLL;
  uint32x4_t v29 = (uint32x4_t)vandq_s8((int8x16_t)a7, v28);
  int32x4_t v30 = (int32x4_t)vandq_s8(v26, v28);
  int32x4_t v31 = (int32x4_t)v29;
  v31.i32[0] = v27;
  v29.i32[0] = v18;
  int8x16_t v32 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v29);
  v33.i64[0] = 0xA0000000ALL;
  v33.i64[1] = 0xA0000000ALL;
  v34.i64[0] = 0x5700000057;
  v34.i64[1] = 0x5700000057;
  *(int8x8_t *)&v20[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v32, (int8x16_t)(*(_OWORD *)&v31 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v31, v34)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v33, (uint32x4_t)v30), (int8x16_t)(*(_OWORD *)&v30 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v30, v34))));
  string_t v36 = a1[1];
  string_t v35 = a1[2];
  unint64_t v37 = (unint64_t)(v36 + 8);
  a1[1] = v36 + 8;
  unint64_t v38 = (unint64_t)(v36 + 9);
  if (v35)
  {
    if (v38 >= *(void *)v35)
    {
      string_t v39 = (const char *)malloc_type_realloc(*((void **)v35 + 2), (v37 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      string_t v40 = (char *)a1[2];
      *((void *)v40 + 2) = v39;
      *(void *)string_t v40 = (v37 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v39;
    }
  }
  else
  {
    str_alloc(a1, v38);
  }
  string_t v41 = *a1;
  ++a1[1];
  v41[v37] = 58;
  unsigned int v42 = a3[1];
  string_t v44 = a1[1];
  string_t v43 = a1[2];
  unint64_t v45 = (unint64_t)(v44 + 8);
  if (v43)
  {
    if (v45 >= *(void *)v43)
    {
      unsigned int v46 = (const char *)malloc_type_realloc(*((void **)v43 + 2), (unint64_t)(v44 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      string_t v47 = (char *)a1[2];
      *((void *)v47 + 2) = v46;
      *(void *)string_t v47 = (unint64_t)(v44 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v46;
    }
  }
  else
  {
    str_alloc(a1, v45);
  }
  uint32x2_t v48 = (uint32x2_t)vdup_n_s32(v42);
  uint32x2_t v49 = vshl_u32(v48, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v50.i8 = vshl_u32(v48, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v32.i32[0] = v42;
  unsigned __int32 v51 = vshrq_n_u32((uint32x4_t)v32, 0x1CuLL).u32[0];
  v32.i32[1] = HIBYTE(v42);
  v32.u64[1] = (unint64_t)v49;
  v50.i32[2] = v42 >> 4;
  v50.i32[3] = v42;
  v52.i64[0] = 0xF0000000FLL;
  v52.i64[1] = 0xF0000000FLL;
  uint32x4_t v53 = (uint32x4_t)vandq_s8(v32, v52);
  int32x4_t v54 = (int32x4_t)vandq_s8(v50, v52);
  int32x4_t v55 = (int32x4_t)v53;
  v55.i32[0] = v51;
  v53.i32[0] = v42;
  int8x16_t v56 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v53);
  v57.i64[0] = 0xA0000000ALL;
  v57.i64[1] = 0xA0000000ALL;
  v58.i64[0] = 0x5700000057;
  v58.i64[1] = 0x5700000057;
  *(int8x8_t *)&v44[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v56, (int8x16_t)(*(_OWORD *)&v55 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v55, v58)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v57, (uint32x4_t)v54), (int8x16_t)(*(_OWORD *)&v54 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v54, v58))));
  string_t v60 = a1[1];
  string_t v59 = a1[2];
  unint64_t v61 = (unint64_t)(v60 + 8);
  a1[1] = v60 + 8;
  unint64_t v62 = (unint64_t)(v60 + 9);
  if (v59)
  {
    if (v62 >= *(void *)v59)
    {
      string_t v63 = (const char *)malloc_type_realloc(*((void **)v59 + 2), (v61 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      string_t v64 = (char *)a1[2];
      *((void *)v64 + 2) = v63;
      *(void *)string_t v64 = (v61 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v63;
    }
  }
  else
  {
    str_alloc(a1, v62);
  }
  string_t v65 = *a1;
  ++a1[1];
  v65[v61] = 58;
  unsigned int v66 = a3[2];
  string_t v68 = a1[1];
  string_t v67 = a1[2];
  unint64_t v69 = (unint64_t)(v68 + 8);
  if (v67)
  {
    if (v69 >= *(void *)v67)
    {
      unsigned int v70 = (const char *)malloc_type_realloc(*((void **)v67 + 2), (unint64_t)(v68 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      string_t v71 = (char *)a1[2];
      *((void *)v71 + 2) = v70;
      *(void *)string_t v71 = (unint64_t)(v68 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v70;
    }
  }
  else
  {
    str_alloc(a1, v69);
  }
  uint32x2_t v72 = (uint32x2_t)vdup_n_s32(v66);
  uint32x2_t v73 = vshl_u32(v72, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v74.i8 = vshl_u32(v72, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v56.i32[0] = v66;
  unsigned __int32 v75 = vshrq_n_u32((uint32x4_t)v56, 0x1CuLL).u32[0];
  v56.i32[1] = HIBYTE(v66);
  v56.u64[1] = (unint64_t)v73;
  v74.i32[2] = v66 >> 4;
  v74.i32[3] = v66;
  v76.i64[0] = 0xF0000000FLL;
  v76.i64[1] = 0xF0000000FLL;
  uint32x4_t v77 = (uint32x4_t)vandq_s8(v56, v76);
  int32x4_t v78 = (int32x4_t)vandq_s8(v74, v76);
  int32x4_t v79 = (int32x4_t)v77;
  v79.i32[0] = v75;
  v77.i32[0] = v66;
  int8x16_t v80 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v77);
  v81.i64[0] = 0xA0000000ALL;
  v81.i64[1] = 0xA0000000ALL;
  v82.i64[0] = 0x5700000057;
  v82.i64[1] = 0x5700000057;
  *(int8x8_t *)&v68[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v80, (int8x16_t)(*(_OWORD *)&v79 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v79, v82)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v81, (uint32x4_t)v78), (int8x16_t)(*(_OWORD *)&v78 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v78, v82))));
  string_t v84 = a1[1];
  string_t v83 = a1[2];
  unint64_t v85 = (unint64_t)(v84 + 8);
  a1[1] = v84 + 8;
  unint64_t v86 = (unint64_t)(v84 + 9);
  if (v83)
  {
    if (v86 >= *(void *)v83)
    {
      string_t v87 = (const char *)malloc_type_realloc(*((void **)v83 + 2), (v85 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      string_t v88 = (char *)a1[2];
      *((void *)v88 + 2) = v87;
      *(void *)string_t v88 = (v85 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v87;
    }
  }
  else
  {
    str_alloc(a1, v86);
  }
  string_t v89 = *a1;
  ++a1[1];
  v89[v85] = 58;
  unsigned int v90 = a3[3];
  string_t v92 = a1[1];
  string_t v91 = a1[2];
  unint64_t v93 = (unint64_t)(v92 + 8);
  if (v91)
  {
    if (v93 >= *(void *)v91)
    {
      unsigned int v94 = (const char *)malloc_type_realloc(*((void **)v91 + 2), (unint64_t)(v92 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      string_t v95 = (char *)a1[2];
      *((void *)v95 + 2) = v94;
      *(void *)string_t v95 = (unint64_t)(v92 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v94;
    }
  }
  else
  {
    str_alloc(a1, v93);
  }
  uint32x2_t v96 = (uint32x2_t)vdup_n_s32(v90);
  uint32x2_t v97 = vshl_u32(v96, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v98.i8 = vshl_u32(v96, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v80.i32[0] = v90;
  unsigned __int32 v99 = vshrq_n_u32((uint32x4_t)v80, 0x1CuLL).u32[0];
  v80.i32[1] = HIBYTE(v90);
  v80.u64[1] = (unint64_t)v97;
  v98.i32[2] = v90 >> 4;
  v98.i32[3] = v90;
  v100.i64[0] = 0xF0000000FLL;
  v100.i64[1] = 0xF0000000FLL;
  uint32x4_t v101 = (uint32x4_t)vandq_s8(v80, v100);
  int32x4_t v102 = (int32x4_t)vandq_s8(v98, v100);
  int32x4_t v103 = (int32x4_t)v101;
  v103.i32[0] = v99;
  v101.i32[0] = v90;
  int8x16_t v104 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v101);
  v105.i64[0] = 0xA0000000ALL;
  v105.i64[1] = 0xA0000000ALL;
  v106.i64[0] = 0x5700000057;
  v106.i64[1] = 0x5700000057;
  *(int8x8_t *)&v92[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v104, (int8x16_t)(*(_OWORD *)&v103 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v103, v106)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v105, (uint32x4_t)v102), (int8x16_t)(*(_OWORD *)&v102 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v102, v106))));
  string_t v108 = a1[1];
  string_t v107 = a1[2];
  unint64_t v109 = (unint64_t)(v108 + 8);
  a1[1] = v108 + 8;
  unint64_t v110 = (unint64_t)(v108 + 9);
  if (v107)
  {
    if (v110 >= *(void *)v107)
    {
      string_t v111 = (const char *)malloc_type_realloc(*((void **)v107 + 2), (v109 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      string_t v112 = (char *)a1[2];
      *((void *)v112 + 2) = v111;
      *(void *)string_t v112 = (v109 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v111;
    }
  }
  else
  {
    str_alloc(a1, v110);
  }
  string_t v113 = *a1;
  ++a1[1];
  v113[v109] = 10;
  string_t v115 = a1[1];
  string_t v114 = a1[2];
  unint64_t v116 = (unint64_t)(v115 + 6);
  if (v114)
  {
    if (v116 >= *(void *)v114)
    {
      string_t v117 = (const char *)malloc_type_realloc(*((void **)v114 + 2), (unint64_t)(v115 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      string_t v118 = (char *)a1[2];
      *((void *)v118 + 2) = v117;
      *(void *)string_t v118 = (unint64_t)(v115 + 261) & 0xFFFFFFFFFFFFFF00;
      *a1 = v117;
    }
  }
  else
  {
    str_alloc(a1, v116);
  }
  string_t v119 = *a1;
  a1[1] += 6;
  unint64_t v120 = (char *)&v115[(void)v119];
  *((_WORD *)v120 + 2) = 15687;
  *(_DWORD *)unint64_t v120 = 1230188335;
  unsigned int v121 = *(_DWORD *)(a2 + 4);
  string_t v123 = a1[1];
  string_t v122 = a1[2];
  unint64_t v124 = (unint64_t)(v123 + 8);
  if (v122)
  {
    if (v124 >= *(void *)v122)
    {
      string_t v125 = (const char *)malloc_type_realloc(*((void **)v122 + 2), (unint64_t)(v123 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      uint64_t v126 = (char *)a1[2];
      *((void *)v126 + 2) = v125;
      *(void *)uint64_t v126 = (unint64_t)(v123 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v125;
    }
  }
  else
  {
    str_alloc(a1, v124);
  }
  uint32x2_t v127 = (uint32x2_t)vdup_n_s32(v121);
  uint32x2_t v128 = vshl_u32(v127, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v129.i8 = vshl_u32(v127, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v104.i32[0] = v121;
  unsigned __int32 v130 = vshrq_n_u32((uint32x4_t)v104, 0x1CuLL).u32[0];
  v104.i32[1] = HIBYTE(v121);
  v104.u64[1] = (unint64_t)v128;
  v129.i32[2] = v121 >> 4;
  v129.i32[3] = v121;
  v131.i64[0] = 0xF0000000FLL;
  v131.i64[1] = 0xF0000000FLL;
  uint32x4_t v132 = (uint32x4_t)vandq_s8(v104, v131);
  int32x4_t v133 = (int32x4_t)vandq_s8(v129, v131);
  int32x4_t v134 = (int32x4_t)v132;
  v134.i32[0] = v130;
  v132.i32[0] = v121;
  int8x16_t v135 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v132);
  v136.i64[0] = 0xA0000000ALL;
  v136.i64[1] = 0xA0000000ALL;
  v137.i64[0] = 0x5700000057;
  v137.i64[1] = 0x5700000057;
  *(int8x8_t *)&v123[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v135, (int8x16_t)(*(_OWORD *)&v134 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v134, v137)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v136, (uint32x4_t)v133), (int8x16_t)(*(_OWORD *)&v133 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v133, v137))));
  string_t v139 = a1[1];
  string_t v138 = a1[2];
  unint64_t v140 = (unint64_t)(v139 + 8);
  a1[1] = v139 + 8;
  unint64_t v141 = (unint64_t)(v139 + 9);
  if (v138)
  {
    if (v141 >= *(void *)v138)
    {
      int32x4_t v142 = (const char *)malloc_type_realloc(*((void **)v138 + 2), (v140 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int8x16_t v143 = (char *)a1[2];
      *((void *)v143 + 2) = v142;
      *(void *)int8x16_t v143 = (v140 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v142;
    }
  }
  else
  {
    str_alloc(a1, v141);
  }
  string_t v144 = *a1;
  ++a1[1];
  v144[v140] = 58;
  unsigned int v145 = *(_DWORD *)(a2 + 8);
  string_t v147 = a1[1];
  string_t v146 = a1[2];
  unint64_t v148 = (unint64_t)(v147 + 8);
  if (v146)
  {
    if (v148 >= *(void *)v146)
    {
      unint64_t v149 = (const char *)malloc_type_realloc(*((void **)v146 + 2), (unint64_t)(v147 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      int v150 = (char *)a1[2];
      *((void *)v150 + 2) = v149;
      *(void *)int v150 = (unint64_t)(v147 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v149;
    }
  }
  else
  {
    str_alloc(a1, v148);
  }
  uint32x2_t v151 = (uint32x2_t)vdup_n_s32(v145);
  uint32x2_t v152 = vshl_u32(v151, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v153.i8 = vshl_u32(v151, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v135.i32[0] = v145;
  unsigned __int32 v154 = vshrq_n_u32((uint32x4_t)v135, 0x1CuLL).u32[0];
  v135.i32[1] = HIBYTE(v145);
  v135.u64[1] = (unint64_t)v152;
  v153.i32[2] = v145 >> 4;
  v153.i32[3] = v145;
  v155.i64[0] = 0xF0000000FLL;
  v155.i64[1] = 0xF0000000FLL;
  uint32x4_t v156 = (uint32x4_t)vandq_s8(v135, v155);
  int32x4_t v157 = (int32x4_t)vandq_s8(v153, v155);
  int32x4_t v158 = (int32x4_t)v156;
  v158.i32[0] = v154;
  v156.i32[0] = v145;
  int8x16_t v159 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v156);
  v160.i64[0] = 0xA0000000ALL;
  v160.i64[1] = 0xA0000000ALL;
  v161.i64[0] = 0x5700000057;
  v161.i64[1] = 0x5700000057;
  *(int8x8_t *)&v147[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v159, (int8x16_t)(*(_OWORD *)&v158 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v158, v161)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v160, (uint32x4_t)v157), (int8x16_t)(*(_OWORD *)&v157 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v157, v161))));
  string_t v163 = a1[1];
  string_t v162 = a1[2];
  unint64_t v164 = (unint64_t)(v163 + 8);
  a1[1] = v163 + 8;
  unint64_t v165 = (unint64_t)(v163 + 9);
  if (v162)
  {
    if (v165 >= *(void *)v162)
    {
      int32x4_t v166 = (const char *)malloc_type_realloc(*((void **)v162 + 2), (v164 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int8x16_t v167 = (char *)a1[2];
      *((void *)v167 + 2) = v166;
      *(void *)int8x16_t v167 = (v164 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v166;
    }
  }
  else
  {
    str_alloc(a1, v165);
  }
  string_t v168 = *a1;
  ++a1[1];
  v168[v164] = 58;
  unsigned int v169 = *(_DWORD *)(a2 + 12);
  string_t v171 = a1[1];
  string_t v170 = a1[2];
  unint64_t v172 = (unint64_t)(v171 + 8);
  if (v170)
  {
    if (v172 >= *(void *)v170)
    {
      unint64_t v173 = (const char *)malloc_type_realloc(*((void **)v170 + 2), (unint64_t)(v171 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      signed int v174 = (char *)a1[2];
      *((void *)v174 + 2) = v173;
      *(void *)signed int v174 = (unint64_t)(v171 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v173;
    }
  }
  else
  {
    str_alloc(a1, v172);
  }
  uint32x2_t v175 = (uint32x2_t)vdup_n_s32(v169);
  uint32x2_t v176 = vshl_u32(v175, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v177.i8 = vshl_u32(v175, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v159.i32[0] = v169;
  unsigned __int32 v178 = vshrq_n_u32((uint32x4_t)v159, 0x1CuLL).u32[0];
  v159.i32[1] = HIBYTE(v169);
  v159.u64[1] = (unint64_t)v176;
  v177.i32[2] = v169 >> 4;
  v177.i32[3] = v169;
  v179.i64[0] = 0xF0000000FLL;
  v179.i64[1] = 0xF0000000FLL;
  uint32x4_t v180 = (uint32x4_t)vandq_s8(v159, v179);
  int32x4_t v181 = (int32x4_t)vandq_s8(v177, v179);
  int32x4_t v182 = (int32x4_t)v180;
  v182.i32[0] = v178;
  v180.i32[0] = v169;
  int8x16_t v183 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v180);
  v184.i64[0] = 0xA0000000ALL;
  v184.i64[1] = 0xA0000000ALL;
  v185.i64[0] = 0x5700000057;
  v185.i64[1] = 0x5700000057;
  *(int8x8_t *)&v171[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v183, (int8x16_t)(*(_OWORD *)&v182 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v182, v185)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v184, (uint32x4_t)v181), (int8x16_t)(*(_OWORD *)&v181 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v181, v185))));
  string_t v187 = a1[1];
  string_t v186 = a1[2];
  unint64_t v188 = (unint64_t)(v187 + 8);
  a1[1] = v187 + 8;
  unint64_t v189 = (unint64_t)(v187 + 9);
  if (v186)
  {
    if (v189 >= *(void *)v186)
    {
      int32x4_t v190 = (const char *)malloc_type_realloc(*((void **)v186 + 2), (v188 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int8x16_t v191 = (char *)a1[2];
      *((void *)v191 + 2) = v190;
      *(void *)int8x16_t v191 = (v188 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v190;
    }
  }
  else
  {
    str_alloc(a1, v189);
  }
  string_t v192 = *a1;
  ++a1[1];
  v192[v188] = 58;
  unsigned int v193 = *(_DWORD *)(a2 + 16);
  string_t v195 = a1[1];
  string_t v194 = a1[2];
  unint64_t v196 = (unint64_t)(v195 + 8);
  if (v194)
  {
    if (v196 >= *(void *)v194)
    {
      unint64_t v197 = (const char *)malloc_type_realloc(*((void **)v194 + 2), (unint64_t)(v195 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      uint64_t v198 = (char *)a1[2];
      *((void *)v198 + 2) = v197;
      *(void *)uint64_t v198 = (unint64_t)(v195 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v197;
    }
  }
  else
  {
    str_alloc(a1, v196);
  }
  uint32x2_t v199 = (uint32x2_t)vdup_n_s32(v193);
  uint32x2_t v200 = vshl_u32(v199, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v201.i8 = vshl_u32(v199, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v183.i32[0] = v193;
  unsigned __int32 v202 = vshrq_n_u32((uint32x4_t)v183, 0x1CuLL).u32[0];
  v183.i32[1] = HIBYTE(v193);
  v183.u64[1] = (unint64_t)v200;
  v201.i32[2] = v193 >> 4;
  v201.i32[3] = v193;
  v203.i64[0] = 0xF0000000FLL;
  v203.i64[1] = 0xF0000000FLL;
  uint32x4_t v204 = (uint32x4_t)vandq_s8(v183, v203);
  int32x4_t v205 = (int32x4_t)vandq_s8(v201, v203);
  int32x4_t v206 = (int32x4_t)v204;
  v206.i32[0] = v202;
  v204.i32[0] = v193;
  int8x16_t v207 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v204);
  v208.i64[0] = 0xA0000000ALL;
  v208.i64[1] = 0xA0000000ALL;
  v209.i64[0] = 0x5700000057;
  v209.i64[1] = 0x5700000057;
  *(int8x8_t *)&v195[(void)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v207, (int8x16_t)(*(_OWORD *)&v206 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v206, v209)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v208, (uint32x4_t)v205), (int8x16_t)(*(_OWORD *)&v205 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v205, v209))));
  string_t v211 = a1[1];
  string_t v210 = a1[2];
  unint64_t v212 = (unint64_t)(v211 + 8);
  a1[1] = v211 + 8;
  unint64_t v213 = (unint64_t)(v211 + 9);
  if (v210)
  {
    if (v213 >= *(void *)v210)
    {
      int32x4_t v214 = (const char *)malloc_type_realloc(*((void **)v210 + 2), (v212 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int8x16_t v215 = (char *)a1[2];
      *((void *)v215 + 2) = v214;
      *(void *)int8x16_t v215 = (v212 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v214;
    }
  }
  else
  {
    str_alloc(a1, v213);
  }
  string_t v216 = *a1;
  ++a1[1];
  v216[v212] = 58;
  unsigned int v217 = *(unsigned __int16 *)(a2 + 20);
  string_t v219 = a1[1];
  string_t v218 = a1[2];
  unint64_t v220 = (unint64_t)(v219 + 4);
  if (v218)
  {
    if (v220 >= *(void *)v218)
    {
      unint64_t v221 = (const char *)malloc_type_realloc(*((void **)v218 + 2), (unint64_t)(v219 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      int v222 = (char *)a1[2];
      *((void *)v222 + 2) = v221;
      *(void *)int v222 = (unint64_t)(v219 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v221;
    }
  }
  else
  {
    str_alloc(a1, v220);
  }
  v223 = (char *)&v219[(void)*a1];
  int v224 = (v217 >> 12) + 87;
  if (v217 < 0xA000) {
    LOBYTE(v224) = (v217 >> 12) | 0x30;
  }
  char *v223 = v224;
  int32x2_t v225 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v217), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v226 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v225), (int8x8_t)(*(void *)&v225 | 0x3000000030), (int8x8_t)vadd_s32(v225, (int32x2_t)0x5700000057));
  v223[2] = v226.i8[4];
  v223[1] = v226.i8[0];
  if ((v217 & 0xF) >= 0xA) {
    char v227 = (v217 & 0xF) + 87;
  }
  else {
    char v227 = v217 & 0xF | 0x30;
  }
  v223[3] = v227;
  string_t v229 = a1[1];
  string_t v228 = a1[2];
  unint64_t v230 = (unint64_t)(v229 + 4);
  a1[1] = v229 + 4;
  unint64_t v231 = (unint64_t)(v229 + 5);
  if (v228)
  {
    if (v231 >= *(void *)v228)
    {
      int v232 = (const char *)malloc_type_realloc(*((void **)v228 + 2), (v230 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int32x2_t v233 = (char *)a1[2];
      *((void *)v233 + 2) = v232;
      *(void *)int32x2_t v233 = (v230 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v232;
    }
  }
  else
  {
    str_alloc(a1, v231);
  }
  string_t v234 = *a1;
  ++a1[1];
  v234[v230] = 58;
  unsigned int v235 = *(unsigned __int16 *)(a2 + 22);
  string_t v237 = a1[1];
  string_t v236 = a1[2];
  unint64_t v238 = (unint64_t)(v237 + 4);
  if (v236)
  {
    if (v238 >= *(void *)v236)
    {
      unint64_t v239 = (const char *)malloc_type_realloc(*((void **)v236 + 2), (unint64_t)(v237 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      int v240 = (char *)a1[2];
      *((void *)v240 + 2) = v239;
      *(void *)int v240 = (unint64_t)(v237 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v239;
    }
  }
  else
  {
    str_alloc(a1, v238);
  }
  uint64_t v241 = (char *)&v237[(void)*a1];
  int v242 = (v235 >> 12) + 87;
  if (v235 < 0xA000) {
    LOBYTE(v242) = (v235 >> 12) | 0x30;
  }
  *uint64_t v241 = v242;
  int32x2_t v243 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v235), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v244 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v243), (int8x8_t)(*(void *)&v243 | 0x3000000030), (int8x8_t)vadd_s32(v243, (int32x2_t)0x5700000057));
  v241[2] = v244.i8[4];
  v241[1] = v244.i8[0];
  if ((v235 & 0xF) >= 0xA) {
    char v245 = (v235 & 0xF) + 87;
  }
  else {
    char v245 = v235 & 0xF | 0x30;
  }
  v241[3] = v245;
  string_t v247 = a1[1];
  string_t v246 = a1[2];
  unint64_t v248 = (unint64_t)(v247 + 4);
  a1[1] = v247 + 4;
  unint64_t v249 = (unint64_t)(v247 + 5);
  if (v246)
  {
    if (v249 >= *(void *)v246)
    {
      int v250 = (const char *)malloc_type_realloc(*((void **)v246 + 2), (v248 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int32x2_t v251 = (char *)a1[2];
      *((void *)v251 + 2) = v250;
      *(void *)int32x2_t v251 = (v248 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v250;
    }
  }
  else
  {
    str_alloc(a1, v249);
  }
  string_t v252 = *a1;
  ++a1[1];
  v252[v248] = 58;
  unsigned int v253 = *(unsigned __int16 *)(a2 + 24);
  string_t v255 = a1[1];
  string_t v254 = a1[2];
  unint64_t v256 = (unint64_t)(v255 + 4);
  if (v254)
  {
    if (v256 >= *(void *)v254)
    {
      unint64_t v257 = (const char *)malloc_type_realloc(*((void **)v254 + 2), (unint64_t)(v255 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v258 = (char *)a1[2];
      *((void *)v258 + 2) = v257;
      *(void *)v258 = (unint64_t)(v255 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v257;
    }
  }
  else
  {
    str_alloc(a1, v256);
  }
  unsigned int v259 = (char *)&v255[(void)*a1];
  int v260 = (v253 >> 12) + 87;
  if (v253 < 0xA000) {
    LOBYTE(v260) = (v253 >> 12) | 0x30;
  }
  *unsigned int v259 = v260;
  int32x2_t v261 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v253), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v262 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v261), (int8x8_t)(*(void *)&v261 | 0x3000000030), (int8x8_t)vadd_s32(v261, (int32x2_t)0x5700000057));
  v259[2] = v262.i8[4];
  v259[1] = v262.i8[0];
  if ((v253 & 0xF) >= 0xA) {
    char v263 = (v253 & 0xF) + 87;
  }
  else {
    char v263 = v253 & 0xF | 0x30;
  }
  v259[3] = v263;
  string_t v265 = a1[1];
  string_t v264 = a1[2];
  unint64_t v266 = (unint64_t)(v265 + 4);
  a1[1] = v265 + 4;
  unint64_t v267 = (unint64_t)(v265 + 5);
  if (v264)
  {
    if (v267 >= *(void *)v264)
    {
      int v268 = (const char *)malloc_type_realloc(*((void **)v264 + 2), (v266 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int32x2_t v269 = (char *)a1[2];
      *((void *)v269 + 2) = v268;
      *(void *)int32x2_t v269 = (v266 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v268;
    }
  }
  else
  {
    str_alloc(a1, v267);
  }
  string_t v270 = *a1;
  ++a1[1];
  v270[v266] = 58;
  unsigned int v271 = *(unsigned __int8 *)(a2 + 26);
  string_t v273 = a1[1];
  string_t v272 = a1[2];
  unint64_t v274 = (unint64_t)(v273 + 2);
  if (v272)
  {
    if (v274 >= *(void *)v272)
    {
      unint64_t v275 = (const char *)malloc_type_realloc(*((void **)v272 + 2), (unint64_t)(v273 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      unsigned __int16 v276 = (char *)a1[2];
      *((void *)v276 + 2) = v275;
      *(void *)unsigned __int16 v276 = (unint64_t)(v273 + 257) & 0xFFFFFFFFFFFFFF00;
      *a1 = v275;
    }
  }
  else
  {
    str_alloc(a1, v274);
  }
  int v277 = (char *)&v273[(void)*a1];
  int v278 = (v271 >> 4) + 87;
  if (v271 < 0xA0) {
    LOBYTE(v278) = (v271 >> 4) | 0x30;
  }
  *int v277 = v278;
  if ((v271 & 0xF) >= 0xA) {
    char v279 = (v271 & 0xF) + 87;
  }
  else {
    char v279 = v271 & 0xF | 0x30;
  }
  v277[1] = v279;
  string_t v280 = a1[1];
  string_t v281 = a1[2];
  string_t v282 = v280 + 2;
  a1[1] = v280 + 2;
  unsigned int v283 = *(unsigned __int8 *)(a2 + 27);
  unint64_t v284 = (unint64_t)(v280 + 4);
  if (v281)
  {
    if (v284 >= *(void *)v281)
    {
      size_t v285 = (unint64_t)(v280 + 259) & 0xFFFFFFFFFFFFFF00;
      int v286 = (const char *)malloc_type_realloc(*((void **)v281 + 2), v285, 0xCCCD1039uLL);
      char v287 = (char *)a1[2];
      *((void *)v287 + 2) = v286;
      *(void *)char v287 = v285;
      *a1 = v286;
    }
  }
  else
  {
    str_alloc(a1, v284);
  }
  string_t v288 = (char *)&v282[(void)*a1];
  int v289 = (v283 >> 4) + 87;
  if (v283 < 0xA0) {
    LOBYTE(v289) = (v283 >> 4) | 0x30;
  }
  *string_t v288 = v289;
  if ((v283 & 0xF) >= 0xA) {
    char v290 = (v283 & 0xF) + 87;
  }
  else {
    char v290 = v283 & 0xF | 0x30;
  }
  v288[1] = v290;
  string_t v292 = a1[1];
  string_t v291 = a1[2];
  unint64_t v293 = (unint64_t)(v292 + 2);
  a1[1] = v292 + 2;
  unint64_t v294 = (unint64_t)(v292 + 3);
  if (v291)
  {
    if (v294 >= *(void *)v291)
    {
      v295 = (const char *)malloc_type_realloc(*((void **)v291 + 2), (v293 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v296 = (char *)a1[2];
      *((void *)v296 + 2) = v295;
      *(void *)int v296 = (v293 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v295;
    }
  }
  else
  {
    str_alloc(a1, v294);
  }
  string_t v297 = *a1;
  ++a1[1];
  v297[v293] = 58;
  unsigned int v298 = *(unsigned __int8 *)(a2 + 28);
  string_t v300 = a1[1];
  string_t v299 = a1[2];
  unint64_t v301 = (unint64_t)(v300 + 2);
  if (v299)
  {
    if (v301 >= *(void *)v299)
    {
      unint64_t v302 = (const char *)malloc_type_realloc(*((void **)v299 + 2), (unint64_t)(v300 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v303 = (char *)a1[2];
      *((void *)v303 + 2) = v302;
      *(void *)v303 = (unint64_t)(v300 + 257) & 0xFFFFFFFFFFFFFF00;
      *a1 = v302;
    }
  }
  else
  {
    str_alloc(a1, v301);
  }
  v304 = (char *)&v300[(void)*a1];
  int v305 = (v298 >> 4) + 87;
  if (v298 < 0xA0) {
    LOBYTE(v305) = (v298 >> 4) | 0x30;
  }
  char *v304 = v305;
  if ((v298 & 0xF) >= 0xA) {
    char v306 = (v298 & 0xF) + 87;
  }
  else {
    char v306 = v298 & 0xF | 0x30;
  }
  v304[1] = v306;
  string_t v307 = a1[1];
  string_t v308 = a1[2];
  string_t v309 = v307 + 2;
  a1[1] = v307 + 2;
  unsigned int v310 = *(unsigned __int8 *)(a2 + 29);
  unint64_t v311 = (unint64_t)(v307 + 4);
  if (v308)
  {
    if (v311 >= *(void *)v308)
    {
      size_t v312 = (unint64_t)(v307 + 259) & 0xFFFFFFFFFFFFFF00;
      int v313 = (const char *)malloc_type_realloc(*((void **)v308 + 2), v312, 0xCCCD1039uLL);
      char v314 = (char *)a1[2];
      *((void *)v314 + 2) = v313;
      *(void *)char v314 = v312;
      *a1 = v313;
    }
  }
  else
  {
    str_alloc(a1, v311);
  }
  string_t v315 = (char *)&v309[(void)*a1];
  int v316 = (v310 >> 4) + 87;
  if (v310 < 0xA0) {
    LOBYTE(v316) = (v310 >> 4) | 0x30;
  }
  *string_t v315 = v316;
  if ((v310 & 0xF) >= 0xA) {
    char v317 = (v310 & 0xF) + 87;
  }
  else {
    char v317 = v310 & 0xF | 0x30;
  }
  v315[1] = v317;
  string_t v319 = a1[1];
  string_t v318 = a1[2];
  unint64_t v320 = (unint64_t)(v319 + 2);
  a1[1] = v319 + 2;
  unint64_t v321 = (unint64_t)(v319 + 3);
  if (v318)
  {
    if (v321 >= *(void *)v318)
    {
      uint64_t v322 = (const char *)malloc_type_realloc(*((void **)v318 + 2), (v320 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      uint64_t v323 = (char *)a1[2];
      *((void *)v323 + 2) = v322;
      *(void *)uint64_t v323 = (v320 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v322;
    }
  }
  else
  {
    str_alloc(a1, v321);
  }
  string_t v324 = *a1;
  ++a1[1];
  v324[v320] = 58;
  unsigned int v325 = *(unsigned __int16 *)(a2 + 30);
  string_t v327 = a1[1];
  string_t v326 = a1[2];
  unint64_t v328 = (unint64_t)(v327 + 4);
  if (v326)
  {
    if (v328 >= *(void *)v326)
    {
      unint64_t v329 = (const char *)malloc_type_realloc(*((void **)v326 + 2), (unint64_t)(v327 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v330 = (char *)a1[2];
      *((void *)v330 + 2) = v329;
      *(void *)v330 = (unint64_t)(v327 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v329;
    }
  }
  else
  {
    str_alloc(a1, v328);
  }
  v331 = (char *)&v327[(void)*a1];
  int v332 = (v325 >> 12) + 87;
  if (v325 < 0xA000) {
    LOBYTE(v332) = (v325 >> 12) | 0x30;
  }
  char *v331 = v332;
  int32x2_t v333 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v325), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v334 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v333), (int8x8_t)(*(void *)&v333 | 0x3000000030), (int8x8_t)vadd_s32(v333, (int32x2_t)0x5700000057));
  v331[2] = v334.i8[4];
  v331[1] = v334.i8[0];
  if ((v325 & 0xF) >= 0xA) {
    char v335 = (v325 & 0xF) + 87;
  }
  else {
    char v335 = v325 & 0xF | 0x30;
  }
  v331[3] = v335;
  string_t v337 = a1[1];
  string_t v336 = a1[2];
  unint64_t v338 = (unint64_t)(v337 + 4);
  a1[1] = v337 + 4;
  unint64_t v339 = (unint64_t)(v337 + 5);
  if (v336)
  {
    if (v339 >= *(void *)v336)
    {
      int v340 = (const char *)malloc_type_realloc(*((void **)v336 + 2), (v338 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int32x2_t v341 = (char *)a1[2];
      *((void *)v341 + 2) = v340;
      *(void *)int32x2_t v341 = (v338 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v340;
    }
  }
  else
  {
    str_alloc(a1, v339);
  }
  string_t v342 = *a1;
  ++a1[1];
  v342[v338] = 58;
  unsigned int v343 = *(unsigned __int16 *)(a2 + 32);
  string_t v345 = a1[1];
  string_t v344 = a1[2];
  unint64_t v346 = (unint64_t)(v345 + 4);
  if (v344)
  {
    if (v346 >= *(void *)v344)
    {
      unint64_t v347 = (const char *)malloc_type_realloc(*((void **)v344 + 2), (unint64_t)(v345 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      unint64_t v348 = (char *)a1[2];
      *((void *)v348 + 2) = v347;
      *(void *)unint64_t v348 = (unint64_t)(v345 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v347;
    }
  }
  else
  {
    str_alloc(a1, v346);
  }
  size_t v349 = (char *)&v345[(void)*a1];
  int v350 = (v343 >> 12) + 87;
  if (v343 < 0xA000) {
    LOBYTE(v350) = (v343 >> 12) | 0x30;
  }
  *size_t v349 = v350;
  int32x2_t v351 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v343), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v352 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v351), (int8x8_t)(*(void *)&v351 | 0x3000000030), (int8x8_t)vadd_s32(v351, (int32x2_t)0x5700000057));
  v349[2] = v352.i8[4];
  v349[1] = v352.i8[0];
  if ((v343 & 0xF) >= 0xA) {
    char v353 = (v343 & 0xF) + 87;
  }
  else {
    char v353 = v343 & 0xF | 0x30;
  }
  v349[3] = v353;
  string_t v355 = a1[1];
  string_t v354 = a1[2];
  unint64_t v356 = (unint64_t)(v355 + 4);
  a1[1] = v355 + 4;
  unint64_t v357 = (unint64_t)(v355 + 5);
  if (v354)
  {
    if (v357 >= *(void *)v354)
    {
      int v358 = (const char *)malloc_type_realloc(*((void **)v354 + 2), (v356 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int32x2_t v359 = (char *)a1[2];
      *((void *)v359 + 2) = v358;
      *(void *)int32x2_t v359 = (v356 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v358;
    }
  }
  else
  {
    str_alloc(a1, v357);
  }
  string_t v360 = *a1;
  ++a1[1];
  v360[v356] = 58;
  unsigned int v361 = *(unsigned __int16 *)(a2 + 34);
  string_t v363 = a1[1];
  string_t v362 = a1[2];
  unint64_t v364 = (unint64_t)(v363 + 4);
  if (v362)
  {
    if (v364 >= *(void *)v362)
    {
      unint64_t v365 = (const char *)malloc_type_realloc(*((void **)v362 + 2), (unint64_t)(v363 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v366 = (char *)a1[2];
      *((void *)v366 + 2) = v365;
      *(void *)v366 = (unint64_t)(v363 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v365;
    }
  }
  else
  {
    str_alloc(a1, v364);
  }
  v367 = (char *)&v363[(void)*a1];
  int v368 = (v361 >> 12) + 87;
  if (v361 < 0xA000) {
    LOBYTE(v368) = (v361 >> 12) | 0x30;
  }
  char *v367 = v368;
  int32x2_t v369 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v361), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v370 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v369), (int8x8_t)(*(void *)&v369 | 0x3000000030), (int8x8_t)vadd_s32(v369, (int32x2_t)0x5700000057));
  v367[2] = v370.i8[4];
  v367[1] = v370.i8[0];
  if ((v361 & 0xF) >= 0xA) {
    char v371 = (v361 & 0xF) + 87;
  }
  else {
    char v371 = v361 & 0xF | 0x30;
  }
  v367[3] = v371;
  string_t v373 = a1[1];
  string_t v372 = a1[2];
  unint64_t v374 = (unint64_t)(v373 + 4);
  a1[1] = v373 + 4;
  unint64_t v375 = (unint64_t)(v373 + 5);
  if (v372)
  {
    if (v375 >= *(void *)v372)
    {
      int v376 = (const char *)malloc_type_realloc(*((void **)v372 + 2), (v374 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int32x2_t v377 = (char *)a1[2];
      *((void *)v377 + 2) = v376;
      *(void *)int32x2_t v377 = (v374 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v376;
    }
  }
  else
  {
    str_alloc(a1, v375);
  }
  string_t v378 = *a1;
  ++a1[1];
  v378[v374] = 58;
  unsigned int v379 = *(unsigned __int16 *)(a2 + 36);
  string_t v381 = a1[1];
  string_t v380 = a1[2];
  unint64_t v382 = (unint64_t)(v381 + 4);
  if (v380)
  {
    if (v382 >= *(void *)v380)
    {
      unint64_t v383 = (const char *)malloc_type_realloc(*((void **)v380 + 2), (unint64_t)(v381 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      char v384 = (char *)a1[2];
      *((void *)v384 + 2) = v383;
      *(void *)char v384 = (unint64_t)(v381 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v383;
    }
  }
  else
  {
    str_alloc(a1, v382);
  }
  int v385 = (char *)&v381[(void)*a1];
  int v386 = (v379 >> 12) + 87;
  if (v379 < 0xA000) {
    LOBYTE(v386) = (v379 >> 12) | 0x30;
  }
  *int v385 = v386;
  int32x2_t v387 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v379), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  int8x8_t v388 = (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v387);
  *(int32x2_t *)v207.i8 = vadd_s32(v387, (int32x2_t)0x5700000057);
  double v389 = COERCE_DOUBLE(vbsl_s8(v388, (int8x8_t)(*(void *)&v387 | 0x3000000030), *(int8x8_t *)v207.i8));
  v385[2] = BYTE4(v389);
  v385[1] = LOBYTE(v389);
  if ((v379 & 0xF) >= 0xA) {
    char v390 = (v379 & 0xF) + 87;
  }
  else {
    char v390 = v379 & 0xF | 0x30;
  }
  v385[3] = v390;
  string_t v392 = a1[1];
  string_t v391 = a1[2];
  unint64_t v393 = (unint64_t)(v392 + 4);
  a1[1] = v392 + 4;
  unint64_t v394 = (unint64_t)(v392 + 5);
  if (v391)
  {
    if (v394 >= *(void *)v391)
    {
      int32x2_t v395 = (const char *)malloc_type_realloc(*((void **)v391 + 2), (v393 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int8x8_t v396 = (char *)a1[2];
      *((void *)v396 + 2) = v395;
      *(void *)int8x8_t v396 = (v393 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v395;
    }
  }
  else
  {
    str_alloc(a1, v394);
  }
  string_t v397 = *a1;
  ++a1[1];
  v397[v393] = 58;
  unsigned int v398 = *(unsigned __int8 *)(a2 + 40);
  string_t v400 = a1[1];
  string_t v399 = a1[2];
  unint64_t v401 = (unint64_t)(v400 + 2);
  if (v399)
  {
    if (v401 >= *(void *)v399)
    {
      unint64_t v402 = (const char *)malloc_type_realloc(*((void **)v399 + 2), (unint64_t)(v400 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      int v403 = (char *)a1[2];
      *((void *)v403 + 2) = v402;
      *(void *)int v403 = (unint64_t)(v400 + 257) & 0xFFFFFFFFFFFFFF00;
      *a1 = v402;
    }
  }
  else
  {
    str_alloc(a1, v401);
  }
  v404 = (char *)&v400[(void)*a1];
  int v405 = (v398 >> 4) + 87;
  if (v398 < 0xA0) {
    LOBYTE(v405) = (v398 >> 4) | 0x30;
  }
  char *v404 = v405;
  if ((v398 & 0xF) >= 0xA) {
    char v406 = (v398 & 0xF) + 87;
  }
  else {
    char v406 = v398 & 0xF | 0x30;
  }
  v404[1] = v406;
  string_t v408 = a1[1];
  string_t v407 = a1[2];
  unint64_t v409 = (unint64_t)(v408 + 2);
  a1[1] = v408 + 2;
  unint64_t v410 = (unint64_t)(v408 + 3);
  if (v407)
  {
    if (v410 >= *(void *)v407)
    {
      char v411 = (const char *)malloc_type_realloc(*((void **)v407 + 2), (v409 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v412 = (char *)a1[2];
      *((void *)v412 + 2) = v411;
      *(void *)int v412 = (v409 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v411;
    }
  }
  else
  {
    str_alloc(a1, v410);
  }
  string_t v413 = *a1;
  ++a1[1];
  v413[v409] = 58;
  char v414 = *(unsigned char *)(a2 + 41);
  unint64_t v416 = (unint64_t)a1[1];
  string_t v415 = a1[2];
  unint64_t v417 = v416 + 1;
  if (v415)
  {
    if (v417 >= *(void *)v415)
    {
      unint64_t v418 = (const char *)malloc_type_realloc(*((void **)v415 + 2), (v416 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v419 = (char *)a1[2];
      *((void *)v419 + 2) = v418;
      *(void *)int v419 = (v416 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v418;
    }
  }
  else
  {
    str_alloc(a1, v417);
  }
  if ((v414 & 0xFu) >= 0xA) {
    char v420 = (v414 & 0xF) + 87;
  }
  else {
    char v420 = v414 & 0xF | 0x30;
  }
  (*a1)[v416] = v420;
  string_t v422 = a1[1];
  string_t v421 = a1[2];
  unint64_t v423 = (unint64_t)(v422 + 1);
  a1[1] = v422 + 1;
  unint64_t v424 = (unint64_t)(v422 + 2);
  if (v421)
  {
    if (v424 >= *(void *)v421)
    {
      unint64_t v425 = (const char *)malloc_type_realloc(*((void **)v421 + 2), (v423 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v426 = (char *)a1[2];
      *((void *)v426 + 2) = v425;
      *(void *)v426 = (v423 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v425;
    }
  }
  else
  {
    str_alloc(a1, v424);
  }
  string_t v427 = *a1;
  ++a1[1];
  v427[v423] = 58;
  char v428 = *(unsigned char *)(a2 + 42);
  unint64_t v430 = (unint64_t)a1[1];
  string_t v429 = a1[2];
  unint64_t v431 = v430 + 1;
  if (v429)
  {
    if (v431 >= *(void *)v429)
    {
      unint64_t v432 = (const char *)malloc_type_realloc(*((void **)v429 + 2), (v430 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v433 = (char *)a1[2];
      *((void *)v433 + 2) = v432;
      *(void *)int v433 = (v430 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v432;
    }
  }
  else
  {
    str_alloc(a1, v431);
  }
  if ((v428 & 0xFu) >= 0xA) {
    char v434 = (v428 & 0xF) + 87;
  }
  else {
    char v434 = v428 & 0xF | 0x30;
  }
  (*a1)[v430] = v434;
  string_t v436 = a1[1];
  string_t v435 = a1[2];
  unint64_t v437 = (unint64_t)(v436 + 1);
  a1[1] = v436 + 1;
  unint64_t v438 = (unint64_t)(v436 + 2);
  if (v435)
  {
    if (v438 >= *(void *)v435)
    {
      unint64_t v439 = (const char *)malloc_type_realloc(*((void **)v435 + 2), (v437 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v440 = (char *)a1[2];
      *((void *)v440 + 2) = v439;
      *(void *)v440 = (v437 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v439;
    }
  }
  else
  {
    str_alloc(a1, v438);
  }
  string_t v441 = *a1;
  ++a1[1];
  v441[v437] = 58;
  char v442 = *(unsigned char *)(a2 + 43);
  unint64_t v444 = (unint64_t)a1[1];
  string_t v443 = a1[2];
  unint64_t v445 = v444 + 1;
  if (v443)
  {
    if (v445 >= *(void *)v443)
    {
      unint64_t v446 = (const char *)malloc_type_realloc(*((void **)v443 + 2), (v444 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v447 = (char *)a1[2];
      *((void *)v447 + 2) = v446;
      *(void *)v447 = (v444 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v446;
    }
  }
  else
  {
    str_alloc(a1, v445);
  }
  if ((v442 & 0xFu) >= 0xA) {
    char v448 = (v442 & 0xF) + 87;
  }
  else {
    char v448 = v442 & 0xF | 0x30;
  }
  (*a1)[v444] = v448;
  string_t v450 = a1[1];
  string_t v449 = a1[2];
  unint64_t v451 = (unint64_t)(v450 + 1);
  a1[1] = v450 + 1;
  unint64_t v452 = (unint64_t)(v450 + 2);
  if (!v449)
  {
    str_alloc(a1, v452);
    string_t v456 = *a1;
    ++a1[1];
    v456[v451] = 10;
    if (a4) {
      return;
    }
    goto LABEL_256;
  }
  if (v452 >= *(void *)v449)
  {
    unint64_t v453 = (const char *)malloc_type_realloc(*((void **)v449 + 2), (v451 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
    int v454 = (char *)a1[2];
    *((void *)v454 + 2) = v453;
    *(void *)int v454 = (v451 & 0xFFFFFFFFFFFFFF00) + 256;
    *a1 = v453;
  }
  string_t v455 = *a1;
  ++a1[1];
  v455[v451] = 10;
  if ((a4 & 1) == 0)
  {
LABEL_256:
    str_close(a1, v389, *(double *)&v388, (uint32x4_t)v207);
  }
}

void HGString::HGString(HGString *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
}

void HGString::HGString(HGString *this, HGString *a2, int a3, unsigned int a4)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  if (a2)
  {
    uint64_t v8 = HGString::isdistilled(a2, (const char *)a2);
    size_t v9 = v8;
    if (v8)
    {
      if (a4 != 255 || a3)
      {
        str_alloc((string_t *)this, v8);
        if (a4 == 255)
        {
          uint64_t v11 = *((void *)this + 1);
          uint64_t v10 = *((void *)this + 2);
          unint64_t v12 = v11 + v9;
          if (v10)
          {
            if (v12 >= *(void *)v10)
            {
              size_t v13 = (v12 + 255) & 0xFFFFFFFFFFFFFF00;
              string_t v14 = malloc_type_realloc(*(void **)(v10 + 16), v13, 0xCCCD1039uLL);
              string_t v15 = (size_t *)*((void *)this + 2);
              _OWORD v15[2] = (size_t)v14;
              size_t *v15 = v13;
              *(void *)this = v14;
            }
          }
          else
          {
            str_alloc((string_t *)this, v12);
          }
          uint64_t v22 = *(void *)this;
          *((void *)this + 1) += v9;
          memcpy((void *)(v22 + v11), a2, v9);
          str_close((string_t *)this, v23, v24, v25);
        }
        else
        {
          uint64_t v17 = *((void *)this + 1);
          uint64_t v16 = *((void *)this + 2);
          unint64_t v18 = v17 + v9 - 72;
          if (v16)
          {
            if (v18 >= *(void *)v16)
            {
              size_t v19 = (v18 + 255) & 0xFFFFFFFFFFFFFF00;
              string_t v20 = malloc_type_realloc(*(void **)(v16 + 16), v19, 0xCCCD1039uLL);
              unint64_t v21 = (size_t *)*((void *)this + 2);
              v21[2] = (size_t)v20;
              *unint64_t v21 = v19;
              *(void *)this = v20;
            }
          }
          else
          {
            str_alloc((string_t *)this, v18);
          }
          uint64_t v26 = *(void *)this;
          *((void *)this + 1) += v9 - 72;
          memcpy((void *)(v26 + v17), a2, v9 - 72);
          uint64_t v28 = *((void *)this + 1);
          uint64_t v27 = *((void *)this + 2);
          unint64_t v29 = v28 + 8;
          if (v27)
          {
            if (v29 >= *(void *)v27)
            {
              int32x4_t v30 = malloc_type_realloc(*(void **)(v27 + 16), (v28 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              int32x4_t v31 = (unint64_t *)*((void *)this + 2);
              v31[2] = (unint64_t)v30;
              *int32x4_t v31 = (v28 + 263) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v30;
            }
          }
          else
          {
            str_alloc((string_t *)this, v29);
          }
          uint64_t v32 = *(void *)this;
          *((void *)this + 1) += 8;
          *(void *)(v32 + v28) = 0x3030303030303030;
          uint64_t v34 = *((void *)this + 1);
          uint64_t v33 = *((void *)this + 2);
          unint64_t v35 = v34 + 64;
          if (v33)
          {
            if (v35 >= *(void *)v33)
            {
              string_t v36 = malloc_type_realloc(*(void **)(v33 + 16), (v34 + 319) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              unint64_t v37 = (unint64_t *)*((void *)this + 2);
              v37[2] = (unint64_t)v36;
              *unint64_t v37 = (v34 + 319) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v36;
            }
          }
          else
          {
            str_alloc((string_t *)this, v35);
          }
          uint64_t v38 = *(void *)this;
          *((void *)this + 1) += 64;
          string_t v39 = (_OWORD *)(v38 + v34);
          long long v40 = *(_OWORD *)((char *)a2 + v9 - 64);
          long long v41 = *(_OWORD *)((char *)a2 + v9 - 48);
          uint32x4_t v42 = *(uint32x4_t *)((char *)a2 + v9 - 32);
          long long v43 = *(_OWORD *)((char *)a2 + v9 - 16);
          v39[2] = v42;
          v39[3] = v43;
          _OWORD *v39 = v40;
          v39[1] = v41;
          str_close((string_t *)this, *(double *)&v40, *(double *)&v41, v42);
        }
      }
      else
      {
        *(void *)this = a2;
        *((void *)this + 1) = v8;
      }
    }
    else
    {
      HGString::_distill(this, (char *)a2, a4);
    }
  }
}

void sub_1B772AD3C(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)(v1 + 24);
  if (v3)
  {
    *(void *)(v1 + 32) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void str_alloc(string_t *a1, uint64_t a2)
{
  size_t v3 = (a2 + 255) & 0xFFFFFFFFFFFFFF00;
  string_t v4 = a1[2];
  if (v4 && *((void *)v4 + 1) < 2uLL)
  {
    string_t v5 = (char *)malloc_type_malloc(0x18uLL, 0x1010040A79CA2DEuLL);
    *((void *)v5 + 2) = malloc_type_realloc(*((void **)a1[2] + 2), v3, 0xBA3C7595uLL);
    string_t v6 = (char *)a1[2];
    *(void *)string_t v5 = v3;
    *((void *)v5 + 1) = 1;
    a1[2] = v5;
    free(v6);
    *a1 = (string_t)*((void *)v5 + 2);
  }
  else
  {
    string_t v7 = malloc_type_malloc(0x18uLL, 0x1010040A79CA2DEuLL);
    uint64_t v8 = malloc_type_malloc(v3, 0x2BEB8FE7uLL);
    *((void *)v7 + 2) = v8;
    bzero(v8, v3);
    *((void *)v7 + 1) = 1;
    string_t v9 = a1[1];
    if (v9) {
      memcpy(*((void **)v7 + 2), *a1, (size_t)v9);
    }
    string_t v10 = a1[2];
    if (v10) {
      --*((void *)v10 + 1);
    }
    *(void *)string_t v7 = v3;
    a1[2] = (string_t)v7;
    *a1 = (string_t)*((void *)v7 + 2);
  }
}

uint64_t str_close(string_t *a1, double a2, double a3, uint32x4_t a4)
{
  unint64_t v6 = (unint64_t)a1[1];
  string_t v5 = a1[2];
  unint64_t v7 = v6 + 1;
  if (v5)
  {
    if (v7 >= *(void *)v5)
    {
      uint64_t v8 = (const char *)malloc_type_realloc(*((void **)v5 + 2), (v6 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      string_t v9 = (char *)a1[2];
      *((void *)v9 + 2) = v8;
      *(void *)string_t v9 = (v6 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v8;
    }
  }
  else
  {
    str_alloc(a1, v7);
  }
  (*a1)[v6] = 0;
  *((unsigned char *)*a1 + 22) = 48;
  *((unsigned char *)*a1 + 23) = 48;
  unsigned int v10 = *((_DWORD *)a1 + 2);
  uint32x2_t v11 = (uint32x2_t)vdup_n_s32(v10);
  uint32x2_t v12 = vshl_u32(v11, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v13.i8 = vshl_u32(v11, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  a4.i64[0] = v10 | 0xFFFFFFF800000000;
  unsigned __int32 v14 = vshrq_n_u32(a4, 0x1CuLL).u32[0];
  a4.i32[1] = HIBYTE(v10);
  a4.u64[1] = (unint64_t)v12;
  v13.i32[2] = v10 >> 4;
  v13.i32[3] = v10;
  v15.i64[0] = 0xF0000000FLL;
  v15.i64[1] = 0xF0000000FLL;
  uint32x4_t v16 = (uint32x4_t)vandq_s8((int8x16_t)a4, v15);
  int32x4_t v17 = (int32x4_t)v16;
  v17.i32[0] = v14;
  v16.i32[0] = v10;
  int32x4_t v18 = (int32x4_t)vandq_s8(v13, v15);
  int8x16_t v19 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B7EC17B0, v16);
  v16.i64[0] = 0xA0000000ALL;
  v16.i64[1] = 0xA0000000ALL;
  v20.i64[0] = 0x5700000057;
  v20.i64[1] = 0x5700000057;
  *((int8x8_t *)*a1 + 3) = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v19, (int8x16_t)(*(_OWORD *)&v17 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v17, v20)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v16, (uint32x4_t)v18), (int8x16_t)(*(_OWORD *)&v18 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v18, v20))));
  return (uint64_t)*a1;
}

void HGString::HGString(HGString *this, const HGString *a2)
{
  uint64_t v3 = *((void *)a2 + 1);
  *(void *)this = *(void *)a2;
  *((void *)this + 1) = v3;
  uint64_t v4 = *((void *)a2 + 2);
  if (v4) {
    ++*(void *)(v4 + 8);
  }
  *((void *)this + 3) = 0;
  *((void *)this + 2) = v4;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  unint64_t v6 = (unsigned char *)*((void *)a2 + 3);
  string_t v5 = (unsigned char *)*((void *)a2 + 4);
  int64_t v7 = v5 - v6;
  if (v5 != v6)
  {
    if (v7 < 0) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = (char *)operator new(v5 - v6);
    *((void *)this + 3) = v8;
    *((void *)this + 4) = v8;
    string_t v9 = &v8[2 * (v7 >> 1)];
    *((void *)this + 5) = v9;
    memcpy(v8, v6, v7);
    *((void *)this + 4) = v9;
  }
}

void sub_1B772B04C(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void HGString::~HGString(HGString *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2 && (uint64_t v3 = *(void *)(v2 + 8) - 1, (*(void *)(v2 + 8) = v3) == 0))
  {
    free(*(void **)(v2 + 16));
    free(*((void **)this + 2));
    uint64_t v4 = (void *)*((void *)this + 3);
    if (!v4) {
      return;
    }
  }
  else
  {
    uint64_t v4 = (void *)*((void *)this + 3);
    if (!v4) {
      return;
    }
  }
  *((void *)this + 4) = v4;
  operator delete(v4);
}

string_t *HGString::set(string_t *this, HGString *a2, const char *a3, int a4, unsigned int a5)
{
  if (*this != (string_t)a2)
  {
    if (a2)
    {
      uint64_t v10 = HGString::isdistilled(a2, (const char *)a2);
      if (!v10)
      {
        this[1] = 0;
        HGString::_distill((HGString *)this, (char *)a2, a5);
        return this;
      }
      size_t v11 = v10;
      str_alloc(this, v10);
      if (a5 != 255)
      {
        this[1] = 0;
        size_t v19 = v11 - 72;
        string_t v20 = this[2];
        if (v20)
        {
          if (v19 >= *(void *)v20)
          {
            unint64_t v21 = (const char *)malloc_type_realloc(*((void **)v20 + 2), (v11 + 183) & 0x1FFFFFF00, 0xCCCD1039uLL);
            uint64_t v22 = (char *)this[2];
            *((void *)v22 + 2) = v21;
            *(void *)uint64_t v22 = (v11 + 183) & 0x1FFFFFF00;
            *this = v21;
          }
        }
        else
        {
          str_alloc(this, v11 - 72);
        }
        uint32x4_t v25 = (void *)*this;
        this[1] += v19;
        memcpy(v25, a2, v11 - 72);
        string_t v27 = this[1];
        string_t v26 = this[2];
        unint64_t v28 = (unint64_t)(v27 + 8);
        if (v26)
        {
          if (v28 >= *(void *)v26)
          {
            unint64_t v29 = (const char *)malloc_type_realloc(*((void **)v26 + 2), (unint64_t)(v27 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            int32x4_t v30 = (char *)this[2];
            *((void *)v30 + 2) = v29;
            *(void *)int32x4_t v30 = (unint64_t)(v27 + 263) & 0xFFFFFFFFFFFFFF00;
            *this = v29;
          }
        }
        else
        {
          str_alloc(this, v28);
        }
        int32x4_t v31 = (char *)&v27[(void)*this];
        unsigned int v32 = a5 >> 4;
        if (v32 >= 0xA) {
          char v33 = v32 + 87;
        }
        else {
          char v33 = (a5 >> 4) | 0x30;
        }
        *((_WORD *)v31 + 2) = 12336;
        *(_DWORD *)int32x4_t v31 = 808464432;
        v31[6] = v33;
        if ((a5 & 0xF) >= 0xA) {
          char v34 = (a5 & 0xF) + 87;
        }
        else {
          char v34 = a5 & 0xF | 0x30;
        }
        v31[7] = v34;
        string_t v35 = this[1];
        string_t v36 = this[2];
        string_t v37 = v35 + 8;
        this[1] = v35 + 8;
        uint64_t v38 = (uint32x4_t *)((char *)a2 + v11 - 64);
        unint64_t v39 = (unint64_t)(v35 + 72);
        if (v36)
        {
          if (v39 >= *(void *)v36)
          {
            size_t v40 = (unint64_t)(v35 + 327) & 0xFFFFFFFFFFFFFF00;
            long long v41 = (const char *)malloc_type_realloc(*((void **)v36 + 2), v40, 0xCCCD1039uLL);
            uint32x4_t v42 = (char *)this[2];
            *((void *)v42 + 2) = v41;
            *(void *)uint32x4_t v42 = v40;
            *this = v41;
          }
        }
        else
        {
          str_alloc(this, v39);
        }
        uint64_t v43 = (uint64_t)*this;
        this[1] += 64;
        string_t v44 = (uint32x4_t *)&v37[v43];
        uint32x4_t v45 = *v38;
        uint32x4_t v46 = v38[1];
        uint32x4_t v47 = v38[2];
        uint32x4_t v48 = v38[3];
        v44[2] = v47;
        v44[3] = v48;
        uint32x4_t *v44 = v45;
        v44[1] = v46;
        goto LABEL_46;
      }
      if (a4)
      {
        this[1] = 0;
        string_t v12 = this[2];
        if (v12)
        {
          if (v11 >= *(void *)v12)
          {
            int8x16_t v13 = (const char *)malloc_type_realloc(*((void **)v12 + 2), (v11 + 255) & 0x1FFFFFF00, 0xCCCD1039uLL);
            unsigned __int32 v14 = (char *)this[2];
            *((void *)v14 + 2) = v13;
            *(void *)unsigned __int32 v14 = (v11 + 255) & 0x1FFFFFF00;
            *this = v13;
          }
        }
        else
        {
          str_alloc(this, v11);
        }
        uint32x2_t v49 = (void *)*this;
        this[1] += v11;
        memcpy(v49, a2, v11);
LABEL_46:
        str_close(this, *(double *)v45.i64, *(double *)v46.i64, v47);
        return this;
      }
      string_t v23 = this[2];
      if (v23)
      {
        uint64_t v24 = *((void *)v23 + 1) - 1;
        *((void *)v23 + 1) = v24;
        if (!v24)
        {
          free(*((void **)v23 + 2));
          free((void *)this[2]);
        }
      }
      *this = (string_t)a2;
      this[1] = a3;
    }
    else
    {
      string_t v17 = this[2];
      if (v17)
      {
        uint64_t v18 = *((void *)v17 + 1) - 1;
        *((void *)v17 + 1) = v18;
        if (!v18)
        {
          free(*((void **)v17 + 2));
          free((void *)this[2]);
        }
      }
      *this = 0;
      this[1] = 0;
    }
    this[2] = 0;
    return this;
  }
  if (a2)
  {
    string_t v15 = this[1];
    if (v15)
    {
      if (!a5
        && ctype[2 * *((unsigned __int8 *)a2 + (void)v15 - 65)] & 0xF | (16
                                                                                          * ctype[2
                                                                                                * *((unsigned __int8 *)a2
                                                                                                  + (void)v15
                                                                                                  - 66)]))
      {
        str_alloc(this, (uint64_t)v15);
        *(void *)&(*this)[(void)this[1] - 72] = 0x3030303030303030;
      }
    }
  }
  return this;
}

uint64_t HGString::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*(void *)a1 != *a2)
  {
    uint64_t v5 = *(void *)(a1 + 16);
    if (v5)
    {
      uint64_t v6 = *(void *)(v5 + 8) - 1;
      *(void *)(v5 + 8) = v6;
      if (!v6)
      {
        free(*(void **)(v5 + 16));
        free(*(void **)(a1 + 16));
        uint64_t v3 = *a2;
      }
    }
    uint64_t v8 = a2[1];
    uint64_t v7 = a2[2];
    *(void *)a1 = v3;
    *(void *)(a1 + 8) = v8;
    *(void *)(a1 + 16) = v7;
    if (v7) {
      ++*(void *)(v7 + 8);
    }
  }
  return a1;
}

unint64_t HGString::hash(HGString *this, uint8x8_t a2)
{
  uint64_t v2 = *(void *)this + *((void *)this + 1);
  int v3 = *(char *)(v2 - 132);
  if (v3 <= 96) {
    int v4 = 0;
  }
  else {
    int v4 = 9;
  }
  a2.i32[0] = *(_DWORD *)(v2 - 131);
  uint32x4_t v5 = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a2));
  v6.i64[0] = v5.u32[0];
  v6.i64[1] = v5.u32[1];
  int64x2_t v7 = v6;
  v8.i64[0] = 255;
  v8.i64[1] = 255;
  v9.i64[0] = vandq_s8((int8x16_t)v6, v8).u64[0];
  v6.i64[0] = v5.u32[2];
  v6.i64[1] = v5.u32[3];
  int64x2_t v10 = vshlq_n_s64(v6, 0x38uLL);
  int64x2_t v11 = vshrq_n_s64(vshlq_n_s64(v7, 0x38uLL), 0x38uLL);
  v9.i64[1] = v11.i64[1];
  int64x2_t v12 = vdupq_n_s64(0x60uLL);
  int8x16_t v13 = (int8x16_t)vdupq_n_s64(0xFFFFFFD9uLL);
  int8x16_t v14 = (int8x16_t)vaddq_s64((int64x2_t)vshlq_u64((uint64x2_t)vsraq_n_s64((int64x2_t)vandq_s8((int8x16_t)vcgtq_s64(vshrq_n_s64(v10, 0x38uLL), v12), v13), v10, 0x38uLL), (uint64x2_t)xmmword_1B7EC17E0), (int64x2_t)xmmword_1B7EC17F0);
  int8x16_t v15 = (int8x16_t)vaddq_s64((int64x2_t)vshlq_u64((uint64x2_t)vaddq_s64(v9, (int64x2_t)vandq_s8((int8x16_t)vcgtq_s64(v11, v12), (int8x16_t)xmmword_1B7EC17C0)), (uint64x2_t)xmmword_1B7EC17D0), (int64x2_t)xmmword_1B7EC1800);
  int v16 = *(char *)(v2 - 127);
  int v17 = v16 - 48;
  if (v16 <= 96) {
    int v18 = 0;
  }
  else {
    int v18 = -39;
  }
  int v19 = (v17 + v18) << 8;
  int v20 = *(char *)(v2 - 126);
  int v21 = v20 - 48;
  if (v20 <= 96) {
    int v22 = 0;
  }
  else {
    int v22 = -39;
  }
  int v23 = v21 + v22;
  int v24 = *(char *)(v2 - 125);
  int v25 = v24 - 48;
  if (v24 <= 96) {
    int v26 = 0;
  }
  else {
    int v26 = -39;
  }
  int8x16_t v27 = vorrq_s8(v15, v14);
  uint8x8_t v28 = (uint8x8_t)vorr_s8(*(int8x8_t *)v27.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL));
  uint64_t v29 = v28.i32[0] | ((v4 + v3) << 28) | v19 | (16 * v23) | (v25 + v26);
  int v30 = *(char *)(v2 - 123);
  if (v30 <= 96) {
    int v31 = 0;
  }
  else {
    int v31 = 9;
  }
  int v32 = v31 + v30;
  v28.i32[0] = *(_DWORD *)(v2 - 122);
  uint32x4_t v33 = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v28));
  v34.i64[0] = v33.u32[0];
  v34.i64[1] = v33.u32[1];
  int64x2_t v35 = v34;
  v36.i64[0] = vandq_s8((int8x16_t)v34, v8).u64[0];
  v34.i64[0] = v33.u32[2];
  v34.i64[1] = v33.u32[3];
  int64x2_t v37 = vshlq_n_s64(v34, 0x38uLL);
  int64x2_t v38 = vshrq_n_s64(vshlq_n_s64(v35, 0x38uLL), 0x38uLL);
  v36.i64[1] = v38.i64[1];
  uint64x2_t v39 = (uint64x2_t)vsraq_n_s64((int64x2_t)vandq_s8((int8x16_t)vcgtq_s64(vshrq_n_s64(v37, 0x38uLL), v12), v13), v37, 0x38uLL);
  int64x2_t v40 = (int64x2_t)vshlq_u64((uint64x2_t)vaddq_s64(v36, (int64x2_t)vandq_s8((int8x16_t)vcgtq_s64(v38, v12), (int8x16_t)xmmword_1B7EC17C0)), (uint64x2_t)xmmword_1B7EC17D0);
  int8x16_t v41 = (int8x16_t)vaddq_s64((int64x2_t)vshlq_u64(v39, (uint64x2_t)xmmword_1B7EC17E0), (int64x2_t)xmmword_1B7EC17F0);
  int8x16_t v42 = (int8x16_t)vaddq_s64(v40, (int64x2_t)xmmword_1B7EC1800);
  int v43 = *(char *)(v2 - 118);
  int v44 = v43 - 48;
  if (v43 <= 96) {
    int v45 = 0;
  }
  else {
    int v45 = -39;
  }
  int v46 = (v44 + v45) << 8;
  int v47 = *(char *)(v2 - 117);
  int v48 = v47 - 48;
  if (v47 <= 96) {
    int v49 = 0;
  }
  else {
    int v49 = -39;
  }
  int v50 = v48 + v49;
  int v51 = *(char *)(v2 - 116);
  int v52 = v51 - 48;
  if (v51 <= 96) {
    int v53 = 0;
  }
  else {
    int v53 = -39;
  }
  int8x16_t v54 = vorrq_s8(v42, v41);
  return v29 | ((unint64_t)(vorr_s8(*(int8x8_t *)v54.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL)).u32[0] | (v32 << 28) | v46 | (16 * v50) | (v52 + v53)) << 32);
}

uint64_t HGString::Digest::isunpremult(HGString::Digest *this)
{
  return (*((unsigned __int8 *)this + 23) >> 4) & 1;
}

string_t HGString::c_str(string_t *this, double a2, double a3, uint32x4_t a4)
{
  if (!*this || this[2] || this[1][(void)*this]) {
    return (string_t)str_close(this, a2, a3, a4);
  }
  else {
    return *this;
  }
}

uint64_t HGString::signature@<X0>(HGString **this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  int v4 = *this;
  if (v4)
  {
    unsigned int v5 = HGString::target(v4, (const char *)(this[1] != 0));
    *(_DWORD *)a2 = v5;
    int64x2_t v6 = *this;
    if (v5)
    {
      int v7 = 0;
      int8x16_t v8 = (char *)this[1] + (void)v6 - 90;
      goto LABEL_6;
    }
  }
  else
  {
    int64x2_t v6 = 0;
  }
  int8x16_t v8 = (char *)v6 + 48;
  int v7 = 1;
LABEL_6:
  int v9 = *v8;
  if (v9 <= 96) {
    int v10 = 0;
  }
  else {
    int v10 = 9;
  }
  int v11 = v10 + v9;
  int v12 = v8[1];
  if (v12 <= 96) {
    int v13 = 0;
  }
  else {
    int v13 = 217;
  }
  int v14 = (((v12 + v13) << 24) - 805306368) | (v11 << 28);
  int v15 = v8[2];
  if (v15 <= 96) {
    int v16 = 0;
  }
  else {
    int v16 = -39;
  }
  int v17 = ((v15 + v16) << 20) - 50331648;
  int v18 = v8[3];
  if (v18 <= 96) {
    int v19 = 0;
  }
  else {
    int v19 = -39;
  }
  int v20 = v17 | (((v18 + v19) << 16) - 3145728);
  int v21 = v8[4];
  if (v21 <= 96) {
    int v22 = 0;
  }
  else {
    int v22 = -39;
  }
  int v23 = v14 | v20 | (((v21 + v22) << 12) - 196608);
  int v24 = v8[5];
  if (v24 <= 96) {
    int v25 = 0;
  }
  else {
    int v25 = -39;
  }
  int v26 = ((v24 + v25) << 8) - 12288;
  int v27 = v8[6];
  if (v27 <= 96) {
    int v28 = 0;
  }
  else {
    int v28 = -39;
  }
  int v29 = v26 | (16 * (v27 + v28) - 768);
  int v30 = v8[7];
  if (v30 <= 96) {
    int v31 = 0;
  }
  else {
    int v31 = -39;
  }
  *(_DWORD *)(a2 + 4) = v23 | v29 | (v30 + v31 - 48);
  int v32 = v8[9];
  if (v32 <= 96) {
    int v33 = 0;
  }
  else {
    int v33 = 9;
  }
  int v34 = v33 + v32;
  int v35 = v8[10];
  if (v35 <= 96) {
    int v36 = 0;
  }
  else {
    int v36 = 217;
  }
  int v37 = (((v35 + v36) << 24) - 805306368) | (v34 << 28);
  int v38 = v8[11];
  if (v38 <= 96) {
    int v39 = 0;
  }
  else {
    int v39 = -39;
  }
  int v40 = ((v38 + v39) << 20) - 50331648;
  int v41 = v8[12];
  if (v41 <= 96) {
    int v42 = 0;
  }
  else {
    int v42 = -39;
  }
  int v43 = v40 | (((v41 + v42) << 16) - 3145728);
  int v44 = v8[13];
  if (v44 <= 96) {
    int v45 = 0;
  }
  else {
    int v45 = -39;
  }
  int v46 = v37 | v43 | (((v44 + v45) << 12) - 196608);
  int v47 = v8[14];
  if (v47 <= 96) {
    int v48 = 0;
  }
  else {
    int v48 = -39;
  }
  int v49 = ((v47 + v48) << 8) - 12288;
  int v50 = v8[15];
  if (v50 <= 96) {
    int v51 = 0;
  }
  else {
    int v51 = -39;
  }
  int v52 = v49 | (16 * (v50 + v51) - 768);
  int v53 = v8[16];
  if (v53 <= 96) {
    int v54 = 0;
  }
  else {
    int v54 = -39;
  }
  int v55 = v46 | v52 | (v53 + v54 - 48);
  *(_DWORD *)(a2 + 8) = v55;
  int v56 = v8[18];
  if (v56 <= 96) {
    int v57 = 0;
  }
  else {
    int v57 = 9;
  }
  int v58 = v57 + v56;
  int v59 = v8[19];
  if (v59 <= 96) {
    int v60 = 0;
  }
  else {
    int v60 = 217;
  }
  int v61 = (((v59 + v60) << 24) - 805306368) | (v58 << 28);
  int v62 = v8[20];
  if (v62 <= 96) {
    int v63 = 0;
  }
  else {
    int v63 = -39;
  }
  int v64 = ((v62 + v63) << 20) - 50331648;
  int v65 = v8[21];
  if (v65 <= 96) {
    int v66 = 0;
  }
  else {
    int v66 = -39;
  }
  int v67 = v64 | (((v65 + v66) << 16) - 3145728);
  int v68 = v8[22];
  if (v68 <= 96) {
    int v69 = 0;
  }
  else {
    int v69 = -39;
  }
  int v70 = v61 | v67 | (((v68 + v69) << 12) - 196608);
  int v71 = v8[23];
  if (v71 <= 96) {
    int v72 = 0;
  }
  else {
    int v72 = -39;
  }
  int v73 = ((v71 + v72) << 8) - 12288;
  int v74 = v8[24];
  if (v74 <= 96) {
    int v75 = 0;
  }
  else {
    int v75 = -39;
  }
  int v76 = v73 | (16 * (v74 + v75) - 768);
  int v77 = v8[25];
  if (v77 <= 96) {
    int v78 = 0;
  }
  else {
    int v78 = -39;
  }
  *(_DWORD *)(a2 + 12) = v70 | v76 | (v77 + v78 - 48);
  int v79 = v8[27];
  if (v79 <= 96) {
    int v80 = 0;
  }
  else {
    int v80 = 9;
  }
  int v81 = v80 + v79;
  int v82 = v8[28];
  if (v82 <= 96) {
    int v83 = 0;
  }
  else {
    int v83 = 217;
  }
  int v84 = (((v82 + v83) << 24) - 805306368) | (v81 << 28);
  int v85 = v8[29];
  if (v85 <= 96) {
    int v86 = 0;
  }
  else {
    int v86 = -39;
  }
  int v87 = ((v85 + v86) << 20) - 50331648;
  int v88 = v8[30];
  if (v88 <= 96) {
    int v89 = 0;
  }
  else {
    int v89 = -39;
  }
  int v90 = v87 | (((v88 + v89) << 16) - 3145728);
  int v91 = v8[31];
  if (v91 <= 96) {
    int v92 = 0;
  }
  else {
    int v92 = -39;
  }
  int v93 = v84 | v90 | (((v91 + v92) << 12) - 196608);
  int v94 = v8[32];
  if (v94 <= 96) {
    int v95 = 0;
  }
  else {
    int v95 = -39;
  }
  int v96 = ((v94 + v95) << 8) - 12288;
  int v97 = v8[33];
  if (v97 <= 96) {
    int v98 = 0;
  }
  else {
    int v98 = -39;
  }
  int v99 = v96 | (16 * (v97 + v98) - 768);
  int v100 = v8[34];
  if (v100 <= 96) {
    int v101 = 0;
  }
  else {
    int v101 = -39;
  }
  *(_DWORD *)(a2 + 16) = v93 | v99 | (v100 + v101 - 48);
  int v102 = v8[36];
  if (v102 <= 96) {
    __int16 v103 = 0;
  }
  else {
    __int16 v103 = 9;
  }
  __int16 v104 = v103 + v102;
  int v105 = v8[37];
  if (v105 <= 96) {
    __int16 v106 = 0;
  }
  else {
    __int16 v106 = 217;
  }
  __int16 v107 = ((((_WORD)v105 + v106) << 8) - 12288) | (v104 << 12);
  int v108 = v8[38];
  if (v108 <= 96) {
    __int16 v109 = 0;
  }
  else {
    __int16 v109 = 4057;
  }
  __int16 v110 = 16 * (v108 + v109) - 768;
  int v111 = v8[39];
  if (v111 <= 96) {
    __int16 v112 = 0;
  }
  else {
    __int16 v112 = -39;
  }
  *(_WORD *)(a2 + 20) = v107 | v110 | (v111 + v112 - 48);
  int v113 = v8[41];
  if (v113 <= 96) {
    __int16 v114 = 0;
  }
  else {
    __int16 v114 = 9;
  }
  __int16 v115 = v114 + v113;
  int v116 = v8[42];
  if (v116 <= 96) {
    __int16 v117 = 0;
  }
  else {
    __int16 v117 = 217;
  }
  __int16 v118 = ((((_WORD)v116 + v117) << 8) - 12288) | (v115 << 12);
  int v119 = v8[43];
  if (v119 <= 96) {
    __int16 v120 = 0;
  }
  else {
    __int16 v120 = 4057;
  }
  __int16 v121 = 16 * (v119 + v120) - 768;
  int v122 = v8[44];
  if (v122 <= 96) {
    __int16 v123 = 0;
  }
  else {
    __int16 v123 = -39;
  }
  unsigned __int16 v124 = v118 | v121 | (v122 + v123 - 48);
  *(_WORD *)(a2 + 22) = v124;
  int v125 = v8[46];
  if (v125 <= 96) {
    __int16 v126 = 0;
  }
  else {
    __int16 v126 = 9;
  }
  __int16 v127 = v126 + v125;
  int v128 = v8[47];
  if (v128 <= 96) {
    __int16 v129 = 0;
  }
  else {
    __int16 v129 = 217;
  }
  __int16 v130 = ((((_WORD)v128 + v129) << 8) - 12288) | (v127 << 12);
  int v131 = v8[48];
  if (v131 <= 96) {
    __int16 v132 = 0;
  }
  else {
    __int16 v132 = 4057;
  }
  __int16 v133 = 16 * (v131 + v132) - 768;
  int v134 = v8[49];
  if (v134 <= 96) {
    __int16 v135 = 0;
  }
  else {
    __int16 v135 = -39;
  }
  *(_WORD *)(a2 + 24) = v130 | v133 | (v134 + v135 - 48);
  int v136 = v8[51];
  if (v136 <= 96) {
    char v137 = 96;
  }
  else {
    char v137 = 9;
  }
  char v138 = v137 + v136;
  int v139 = v8[52];
  if (v139 <= 96) {
    char v140 = 0;
  }
  else {
    char v140 = -39;
  }
  *(unsigned char *)(a2 + 26) = (v139 + v140 - 48) | (16 * v138);
  int v141 = v8[53];
  if (v141 <= 96) {
    char v142 = 96;
  }
  else {
    char v142 = 9;
  }
  char v143 = v142 + v141;
  int v144 = v8[54];
  if (v144 <= 96) {
    char v145 = 0;
  }
  else {
    char v145 = -39;
  }
  *(unsigned char *)(a2 + 27) = (v144 + v145 - 48) | (16 * v143);
  int v146 = v8[56];
  if (v146 <= 96) {
    char v147 = 96;
  }
  else {
    char v147 = 9;
  }
  char v148 = v147 + v146;
  int v149 = v8[57];
  if (v149 <= 96) {
    char v150 = 0;
  }
  else {
    char v150 = -39;
  }
  *(unsigned char *)(a2 + 28) = (v149 + v150 - 48) | (16 * v148);
  int v151 = v8[58];
  if (v151 <= 96) {
    char v152 = 96;
  }
  else {
    char v152 = 9;
  }
  char v153 = v152 + v151;
  int v154 = v8[59];
  if (v154 <= 96) {
    char v155 = 0;
  }
  else {
    char v155 = -39;
  }
  *(unsigned char *)(a2 + 29) = (v154 + v155 - 48) | (16 * v153);
  int v156 = v8[61];
  if (v156 <= 96) {
    __int16 v157 = 0;
  }
  else {
    __int16 v157 = 9;
  }
  __int16 v158 = v157 + v156;
  int v159 = v8[62];
  if (v159 <= 96) {
    __int16 v160 = 0;
  }
  else {
    __int16 v160 = 217;
  }
  __int16 v161 = ((((_WORD)v159 + v160) << 8) - 12288) | (v158 << 12);
  int v162 = v8[63];
  if (v162 <= 96) {
    __int16 v163 = 0;
  }
  else {
    __int16 v163 = 4057;
  }
  __int16 v164 = 16 * (v162 + v163) - 768;
  int v165 = v8[64];
  if (v165 <= 96) {
    __int16 v166 = 0;
  }
  else {
    __int16 v166 = -39;
  }
  *(_WORD *)(a2 + 30) = v161 | v164 | (v165 + v166 - 48);
  int v167 = v8[66];
  if (v167 <= 96) {
    __int16 v168 = 0;
  }
  else {
    __int16 v168 = 9;
  }
  __int16 v169 = v168 + v167;
  int v170 = v8[67];
  if (v170 <= 96) {
    __int16 v171 = 0;
  }
  else {
    __int16 v171 = 217;
  }
  __int16 v172 = ((((_WORD)v170 + v171) << 8) - 12288) | (v169 << 12);
  int v173 = v8[68];
  if (v173 <= 96) {
    __int16 v174 = 0;
  }
  else {
    __int16 v174 = 4057;
  }
  __int16 v175 = 16 * (v173 + v174) - 768;
  int v176 = v8[69];
  if (v176 <= 96) {
    __int16 v177 = 0;
  }
  else {
    __int16 v177 = -39;
  }
  *(_WORD *)(a2 + 32) = v172 | v175 | (v176 + v177 - 48);
  int v178 = v8[71];
  if (v178 <= 96) {
    __int16 v179 = 0;
  }
  else {
    __int16 v179 = 9;
  }
  __int16 v180 = v179 + v178;
  int v181 = v8[72];
  if (v181 <= 96) {
    __int16 v182 = 0;
  }
  else {
    __int16 v182 = 217;
  }
  __int16 v183 = ((((_WORD)v181 + v182) << 8) - 12288) | (v180 << 12);
  int v184 = v8[73];
  if (v184 <= 96) {
    __int16 v185 = 0;
  }
  else {
    __int16 v185 = 4057;
  }
  __int16 v186 = 16 * (v184 + v185) - 768;
  int v187 = v8[74];
  if (v187 <= 96) {
    __int16 v188 = 0;
  }
  else {
    __int16 v188 = -39;
  }
  *(_WORD *)(a2 + 34) = v183 | v186 | (v187 + v188 - 48);
  int v189 = v8[76];
  if (v189 <= 96) {
    __int16 v190 = 0;
  }
  else {
    __int16 v190 = 9;
  }
  __int16 v191 = v190 + v189;
  int v192 = v8[77];
  if (v192 <= 96) {
    __int16 v193 = 0;
  }
  else {
    __int16 v193 = 217;
  }
  __int16 v194 = ((((_WORD)v192 + v193) << 8) - 12288) | (v191 << 12);
  int v195 = v8[78];
  if (v195 <= 96) {
    __int16 v196 = 0;
  }
  else {
    __int16 v196 = 4057;
  }
  __int16 v197 = 16 * (v195 + v196) - 768;
  int v198 = v8[79];
  if (v198 <= 96) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = 4294967257;
  }
  unsigned __int16 v200 = v194 | v197 | (v198 + result - 48);
  *(_DWORD *)(a2 + 36) = v200;
  int v201 = v8[81];
  if (v201 <= 96) {
    char v202 = 96;
  }
  else {
    char v202 = 9;
  }
  char v203 = v202 + v201;
  int v204 = v8[82];
  if (v204 <= 96) {
    char v205 = 0;
  }
  else {
    char v205 = -39;
  }
  *(unsigned char *)(a2 + 40) = (v204 + v205 - 48) | (16 * v203);
  int v206 = v8[84];
  if (v206 <= 96) {
    char v207 = 0;
  }
  else {
    char v207 = -39;
  }
  *(unsigned char *)(a2 + 41) = v206 + v207 - 48;
  int v208 = v8[86];
  if (v208 <= 96) {
    char v209 = 0;
  }
  else {
    char v209 = -39;
  }
  *(unsigned char *)(a2 + 42) = v208 + v209 - 48;
  int v210 = v8[88];
  if (v210 <= 96) {
    char v211 = 0;
  }
  else {
    char v211 = -39;
  }
  *(unsigned char *)(a2 + 43) = v210 + v211 - 48;
  if (v7)
  {
    *(_WORD *)(a2 + 36) = v200 | ((_WORD)v55 << 8);
    *(_DWORD *)(a2 + 8) = v55 & 0xFFFFFF00;
  }
  *(_DWORD *)(a2 + 44) = 16 * v124;
  return result;
}

double HGString::digest@<D0>(HGString *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  double result = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v5 = a2 + 16;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  uint64_t v6 = *((void *)this + 1);
  if (v6)
  {
    if (v6 != 125 || strncmp(*(const char **)this, "//MD5=", 6uLL))
    {
      *(void *)a2 = HGString::hash(this, *(uint8x8_t *)&result);
      *(void *)(a2 + 8) = v7;
    }
    HGString::signature((HGString **)this, v5);
  }
  else
  {
    int8x16_t v8 = *(char **)this;
    if (*(void *)this)
    {
      size_t v9 = strlen(v8);
      HGDigestInit((_OWORD *)a2);
      if (v9 >= 0x40)
      {
        size_t v10 = v9 >> 6;
        do
        {
          HGDigestAdd((_DWORD *)a2, (int *)v8);
          v8 += 64;
          --v10;
        }
        while (v10);
        v9 &= 0x3Fu;
      }
      if (v9)
      {
        memcpy(__dst, v8, v9);
        bzero((char *)__dst + v9, 64 - v9);
        HGDigestAdd((_DWORD *)a2, __dst);
      }
      double result = 0.0;
      *(_OWORD *)(a2 + 48) = 0u;
      *(_OWORD *)(a2 + 36) = 0u;
      *(_OWORD *)(a2 + 20) = 0u;
      *(_DWORD *)(a2 + 16) = 394768;
    }
  }
  return result;
}

void HGString::sample2d(HGString *this@<X0>, int a2@<W1>, int a3@<W2>, HGString *a4@<X8>)
{
  if (this == 394784)
  {
    switch(a2)
    {
      case 0:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0CA0, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0CA0))
        {
          qword_1EB9A0FD0 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture0;\n"
                                     "varying highp vec4 hg_TexCoord0;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
                                     "}\n"
                                     "//MD5=1d8d1a82:d291bc55:596ea65f:a606ed93\n"
                                     "//SIG=00000000:00000001:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
          qword_1EB9A0FD8 = 413;
          xmmword_1EB9A0FE0 = 0u;
          xmmword_1EB9A0FF0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A0FD0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0CA0);
        }
        uint64_t v10 = qword_1EB9A0FD8;
        *(void *)a4 = qword_1EB9A0FD0;
        *((void *)a4 + 1) = v10;
        uint64_t v11 = xmmword_1EB9A0FE0;
        if ((void)xmmword_1EB9A0FE0) {
          ++*(void *)(xmmword_1EB9A0FE0 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v11;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A0FE0 + 1);
        int64_t v8 = xmmword_1EB9A0FF0 - *((void *)&xmmword_1EB9A0FE0 + 1);
        if ((void)xmmword_1EB9A0FF0 == *((void *)&xmmword_1EB9A0FE0 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A0FF0 - *((void *)&xmmword_1EB9A0FE0 + 1));
        break;
      case 1:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0CA8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0CA8))
        {
          qword_1EB9A1000 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture1;\n"
                                     "varying highp vec4 hg_TexCoord1;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
                                     "}\n"
                                     "//MD5=ac6d4b6f:fe3ac506:6576bd5e:27c645c3\n"
                                     "//SIG=00000000:00000002:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
          qword_1EB9A1008 = 413;
          xmmword_1EB9A1010 = 0u;
          xmmword_1EB9A1020 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1000, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0CA8);
        }
        uint64_t v32 = qword_1EB9A1008;
        *(void *)a4 = qword_1EB9A1000;
        *((void *)a4 + 1) = v32;
        uint64_t v33 = xmmword_1EB9A1010;
        if ((void)xmmword_1EB9A1010) {
          ++*(void *)(xmmword_1EB9A1010 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v33;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A1010 + 1);
        int64_t v8 = xmmword_1EB9A1020 - *((void *)&xmmword_1EB9A1010 + 1);
        if ((void)xmmword_1EB9A1020 == *((void *)&xmmword_1EB9A1010 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A1020 - *((void *)&xmmword_1EB9A1010 + 1));
        break;
      case 2:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0CB0, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0CB0))
        {
          qword_1EB9A1030 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture2;\n"
                                     "varying highp vec4 hg_TexCoord2;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
                                     "}\n"
                                     "//MD5=64d01b6e:569dc44a:d1f1e083:2b518d16\n"
                                     "//SIG=00000000:00000004:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
          qword_1EB9A1038 = 413;
          xmmword_1EB9A1040 = 0u;
          xmmword_1EB9A1050 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1030, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0CB0);
        }
        uint64_t v20 = qword_1EB9A1038;
        *(void *)a4 = qword_1EB9A1030;
        *((void *)a4 + 1) = v20;
        uint64_t v21 = xmmword_1EB9A1040;
        if ((void)xmmword_1EB9A1040) {
          ++*(void *)(xmmword_1EB9A1040 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v21;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A1040 + 1);
        int64_t v8 = xmmword_1EB9A1050 - *((void *)&xmmword_1EB9A1040 + 1);
        if ((void)xmmword_1EB9A1050 == *((void *)&xmmword_1EB9A1040 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A1050 - *((void *)&xmmword_1EB9A1040 + 1));
        break;
      case 3:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0CB8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0CB8))
        {
          qword_1EB9A1060 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture3;\n"
                                     "varying highp vec4 hg_TexCoord3;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
                                     "}\n"
                                     "//MD5=59bfeda2:66444b75:343be20d:f7a096c6\n"
                                     "//SIG=00000000:00000008:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0004:04:0:1:0\n";
          qword_1EB9A1068 = 413;
          xmmword_1EB9A1070 = 0u;
          xmmword_1EB9A1080 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1060, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0CB8);
        }
        uint64_t v28 = qword_1EB9A1068;
        *(void *)a4 = qword_1EB9A1060;
        *((void *)a4 + 1) = v28;
        uint64_t v29 = xmmword_1EB9A1070;
        if ((void)xmmword_1EB9A1070) {
          ++*(void *)(xmmword_1EB9A1070 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v29;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A1070 + 1);
        int64_t v8 = xmmword_1EB9A1080 - *((void *)&xmmword_1EB9A1070 + 1);
        if ((void)xmmword_1EB9A1080 == *((void *)&xmmword_1EB9A1070 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A1080 - *((void *)&xmmword_1EB9A1070 + 1));
        break;
      case 4:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0CC0, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0CC0))
        {
          qword_1EB9A1090 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture4;\n"
                                     "varying highp vec4 hg_TexCoord4;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
                                     "}\n"
                                     "//MD5=a55c80ef:87e7f7dc:a3f787cf:27bdb14f\n"
                                     "//SIG=00000000:00000010:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0005:05:0:1:0\n";
          qword_1EB9A1098 = 413;
          xmmword_1EB9A10A0 = 0u;
          xmmword_1EB9A10B0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1090, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0CC0);
        }
        uint64_t v16 = qword_1EB9A1098;
        *(void *)a4 = qword_1EB9A1090;
        *((void *)a4 + 1) = v16;
        uint64_t v17 = xmmword_1EB9A10A0;
        if ((void)xmmword_1EB9A10A0) {
          ++*(void *)(xmmword_1EB9A10A0 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v17;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A10A0 + 1);
        int64_t v8 = xmmword_1EB9A10B0 - *((void *)&xmmword_1EB9A10A0 + 1);
        if ((void)xmmword_1EB9A10B0 == *((void *)&xmmword_1EB9A10A0 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A10B0 - *((void *)&xmmword_1EB9A10A0 + 1));
        break;
      case 5:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0CC8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0CC8))
        {
          qword_1EB9A10C0 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture5;\n"
                                     "varying highp vec4 hg_TexCoord5;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture5, hg_TexCoord5.xy);\n"
                                     "}\n"
                                     "//MD5=05661ebe:db59835f:7507946b:b29cf29a\n"
                                     "//SIG=00000000:00000020:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0006:06:0:1:0\n";
          qword_1EB9A10C8 = 413;
          xmmword_1EB9A10D0 = 0u;
          xmmword_1EB9A10E0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A10C0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0CC8);
        }
        uint64_t v38 = qword_1EB9A10C8;
        *(void *)a4 = qword_1EB9A10C0;
        *((void *)a4 + 1) = v38;
        uint64_t v39 = xmmword_1EB9A10D0;
        if ((void)xmmword_1EB9A10D0) {
          ++*(void *)(xmmword_1EB9A10D0 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v39;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A10D0 + 1);
        int64_t v8 = xmmword_1EB9A10E0 - *((void *)&xmmword_1EB9A10D0 + 1);
        if ((void)xmmword_1EB9A10E0 == *((void *)&xmmword_1EB9A10D0 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A10E0 - *((void *)&xmmword_1EB9A10D0 + 1));
        break;
      case 6:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0CD0, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0CD0))
        {
          qword_1EB9A10F0 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture6;\n"
                                     "varying highp vec4 hg_TexCoord6;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture6, hg_TexCoord6.xy);\n"
                                     "}\n"
                                     "//MD5=22ccfeea:0aa3beb7:0667a734:f532af78\n"
                                     "//SIG=00000000:00000040:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0007:07:0:1:0\n";
          qword_1EB9A10F8 = 413;
          xmmword_1EB9A1100 = 0u;
          xmmword_1EB9A1110 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A10F0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0CD0);
        }
        uint64_t v40 = qword_1EB9A10F8;
        *(void *)a4 = qword_1EB9A10F0;
        *((void *)a4 + 1) = v40;
        uint64_t v41 = xmmword_1EB9A1100;
        if ((void)xmmword_1EB9A1100) {
          ++*(void *)(xmmword_1EB9A1100 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v41;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A1100 + 1);
        int64_t v8 = xmmword_1EB9A1110 - *((void *)&xmmword_1EB9A1100 + 1);
        if ((void)xmmword_1EB9A1110 == *((void *)&xmmword_1EB9A1100 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A1110 - *((void *)&xmmword_1EB9A1100 + 1));
        break;
      case 7:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0CD8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0CD8))
        {
          qword_1EB9A1120 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture7;\n"
                                     "varying highp vec4 hg_TexCoord7;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture7, hg_TexCoord7.xy);\n"
                                     "}\n"
                                     "//MD5=bbf4ec74:245e90b8:e9ac0fd8:351c5b3a\n"
                                     "//SIG=00000000:00000080:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0008:08:0:1:0\n";
          qword_1EB9A1128 = 413;
          xmmword_1EB9A1130 = 0u;
          xmmword_1EB9A1140 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1120, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0CD8);
        }
        uint64_t v30 = qword_1EB9A1128;
        *(void *)a4 = qword_1EB9A1120;
        *((void *)a4 + 1) = v30;
        uint64_t v31 = xmmword_1EB9A1130;
        if ((void)xmmword_1EB9A1130) {
          ++*(void *)(xmmword_1EB9A1130 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v31;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A1130 + 1);
        int64_t v8 = xmmword_1EB9A1140 - *((void *)&xmmword_1EB9A1130 + 1);
        if ((void)xmmword_1EB9A1140 == *((void *)&xmmword_1EB9A1130 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A1140 - *((void *)&xmmword_1EB9A1130 + 1));
        break;
      default:
        goto LABEL_28;
    }
    goto LABEL_114;
  }
  if (this == 394000)
  {
    switch(a2)
    {
      case 0:
        if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_6, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&_MergedGlobals_6))
        {
          qword_1EB9A0E50 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f0=fragment.texcoord[0];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##0\n"
                                     "TEX $o0,$f0,texture[0],2D;\n"
                                     "END\n"
                                     "##MD5=16e93a90:20a9533a:c6576d6f:12e8ee4d\n"
                                     "##SIG=00000000:00000001:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
          unk_1EB9A0E58 = 411;
          xmmword_1EB9A0E60 = 0u;
          xmmword_1EB9A0E70 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A0E50, &dword_1B73F3000);
          __cxa_guard_release(&_MergedGlobals_6);
        }
        uint64_t v5 = unk_1EB9A0E58;
        *(void *)a4 = qword_1EB9A0E50;
        *((void *)a4 + 1) = v5;
        uint64_t v6 = xmmword_1EB9A0E60;
        if ((void)xmmword_1EB9A0E60) {
          ++*(void *)(xmmword_1EB9A0E60 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v6;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A0E60 + 1);
        int64_t v8 = xmmword_1EB9A0E70 - *((void *)&xmmword_1EB9A0E60 + 1);
        if ((void)xmmword_1EB9A0E70 == *((void *)&xmmword_1EB9A0E60 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A0E70 - *((void *)&xmmword_1EB9A0E60 + 1));
        break;
      case 1:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C68, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0C68))
        {
          qword_1EB9A0E80 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f1=fragment.texcoord[1];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##1\n"
                                     "TEX $o0,$f1,texture[1],2D;\n"
                                     "END\n"
                                     "##MD5=b736e8a9:2ce9f250:7cba081b:ac720bf8\n"
                                     "##SIG=00000000:00000002:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
          qword_1EB9A0E88 = 411;
          xmmword_1EB9A0E90 = 0u;
          xmmword_1EB9A0EA0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A0E80, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0C68);
        }
        uint64_t v26 = qword_1EB9A0E88;
        *(void *)a4 = qword_1EB9A0E80;
        *((void *)a4 + 1) = v26;
        uint64_t v27 = xmmword_1EB9A0E90;
        if ((void)xmmword_1EB9A0E90) {
          ++*(void *)(xmmword_1EB9A0E90 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v27;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A0E90 + 1);
        int64_t v8 = xmmword_1EB9A0EA0 - *((void *)&xmmword_1EB9A0E90 + 1);
        if ((void)xmmword_1EB9A0EA0 == *((void *)&xmmword_1EB9A0E90 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A0EA0 - *((void *)&xmmword_1EB9A0E90 + 1));
        break;
      case 2:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C70, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0C70))
        {
          qword_1EB9A0EB0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f2=fragment.texcoord[2];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##2\n"
                                     "TEX $o0,$f2,texture[2],2D;\n"
                                     "END\n"
                                     "##MD5=f65ae3b0:67c9ec7f:86a5b786:54ad4649\n"
                                     "##SIG=00000000:00000004:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
          qword_1EB9A0EB8 = 411;
          xmmword_1EB9A0EC0 = 0u;
          xmmword_1EB9A0ED0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A0EB0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0C70);
        }
        uint64_t v18 = qword_1EB9A0EB8;
        *(void *)a4 = qword_1EB9A0EB0;
        *((void *)a4 + 1) = v18;
        uint64_t v19 = xmmword_1EB9A0EC0;
        if ((void)xmmword_1EB9A0EC0) {
          ++*(void *)(xmmword_1EB9A0EC0 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v19;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A0EC0 + 1);
        int64_t v8 = xmmword_1EB9A0ED0 - *((void *)&xmmword_1EB9A0EC0 + 1);
        if ((void)xmmword_1EB9A0ED0 == *((void *)&xmmword_1EB9A0EC0 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A0ED0 - *((void *)&xmmword_1EB9A0EC0 + 1));
        break;
      case 3:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C78, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0C78))
        {
          qword_1EB9A0EE0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f3=fragment.texcoord[3];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##3\n"
                                     "TEX $o0,$f3,texture[3],2D;\n"
                                     "END\n"
                                     "##MD5=3899c790:e60c7f5f:7881594e:b87c7ab6\n"
                                     "##SIG=00000000:00000008:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0004:04:0:1:0\n";
          qword_1EB9A0EE8 = 411;
          xmmword_1EB9A0EF0 = 0u;
          xmmword_1EB9A0F00 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A0EE0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0C78);
        }
        uint64_t v22 = qword_1EB9A0EE8;
        *(void *)a4 = qword_1EB9A0EE0;
        *((void *)a4 + 1) = v22;
        uint64_t v23 = xmmword_1EB9A0EF0;
        if ((void)xmmword_1EB9A0EF0) {
          ++*(void *)(xmmword_1EB9A0EF0 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v23;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A0EF0 + 1);
        int64_t v8 = xmmword_1EB9A0F00 - *((void *)&xmmword_1EB9A0EF0 + 1);
        if ((void)xmmword_1EB9A0F00 == *((void *)&xmmword_1EB9A0EF0 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A0F00 - *((void *)&xmmword_1EB9A0EF0 + 1));
        break;
      case 4:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C80, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0C80))
        {
          qword_1EB9A0F10 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f4=fragment.texcoord[4];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##4\n"
                                     "TEX $o0,$f4,texture[4],2D;\n"
                                     "END\n"
                                     "##MD5=7dc2386c:febf27ca:d6e811c9:91dd69db\n"
                                     "##SIG=00000000:00000010:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0005:05:0:1:0\n";
          qword_1EB9A0F18 = 411;
          xmmword_1EB9A0F20 = 0u;
          xmmword_1EB9A0F30 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A0F10, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0C80);
        }
        uint64_t v14 = qword_1EB9A0F18;
        *(void *)a4 = qword_1EB9A0F10;
        *((void *)a4 + 1) = v14;
        uint64_t v15 = xmmword_1EB9A0F20;
        if ((void)xmmword_1EB9A0F20) {
          ++*(void *)(xmmword_1EB9A0F20 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v15;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A0F20 + 1);
        int64_t v8 = xmmword_1EB9A0F30 - *((void *)&xmmword_1EB9A0F20 + 1);
        if ((void)xmmword_1EB9A0F30 == *((void *)&xmmword_1EB9A0F20 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A0F30 - *((void *)&xmmword_1EB9A0F20 + 1));
        break;
      case 5:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C88, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0C88))
        {
          qword_1EB9A0F40 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f5=fragment.texcoord[5];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##5\n"
                                     "TEX $o0,$f5,texture[5],2D;\n"
                                     "END\n"
                                     "##MD5=3383524a:11b3f71a:c55ccc0e:8d9dc0e3\n"
                                     "##SIG=00000000:00000020:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0006:06:0:1:0\n";
          qword_1EB9A0F48 = 411;
          xmmword_1EB9A0F50 = 0u;
          xmmword_1EB9A0F60 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A0F40, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0C88);
        }
        uint64_t v34 = qword_1EB9A0F48;
        *(void *)a4 = qword_1EB9A0F40;
        *((void *)a4 + 1) = v34;
        uint64_t v35 = xmmword_1EB9A0F50;
        if ((void)xmmword_1EB9A0F50) {
          ++*(void *)(xmmword_1EB9A0F50 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v35;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A0F50 + 1);
        int64_t v8 = xmmword_1EB9A0F60 - *((void *)&xmmword_1EB9A0F50 + 1);
        if ((void)xmmword_1EB9A0F60 == *((void *)&xmmword_1EB9A0F50 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A0F60 - *((void *)&xmmword_1EB9A0F50 + 1));
        break;
      case 6:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C90, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0C90))
        {
          qword_1EB9A0F70 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f6=fragment.texcoord[6];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##6\n"
                                     "TEX $o0,$f6,texture[6],2D;\n"
                                     "END\n"
                                     "##MD5=dc6255ee:ec02b910:da88252c:9affa0c5\n"
                                     "##SIG=00000000:00000040:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0007:07:0:1:0\n";
          qword_1EB9A0F78 = 411;
          xmmword_1EB9A0F80 = 0u;
          xmmword_1EB9A0F90 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A0F70, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0C90);
        }
        uint64_t v36 = qword_1EB9A0F78;
        *(void *)a4 = qword_1EB9A0F70;
        *((void *)a4 + 1) = v36;
        uint64_t v37 = xmmword_1EB9A0F80;
        if ((void)xmmword_1EB9A0F80) {
          ++*(void *)(xmmword_1EB9A0F80 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v37;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A0F80 + 1);
        int64_t v8 = xmmword_1EB9A0F90 - *((void *)&xmmword_1EB9A0F80 + 1);
        if ((void)xmmword_1EB9A0F90 == *((void *)&xmmword_1EB9A0F80 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A0F90 - *((void *)&xmmword_1EB9A0F80 + 1));
        break;
      case 7:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0C98, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0C98))
        {
          qword_1EB9A0FA0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f7=fragment.texcoord[7];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##7\n"
                                     "TEX $o0,$f7,texture[7],2D;\n"
                                     "END\n"
                                     "##MD5=4ef19759:2d6000ec:2c5f0d39:0e366cec\n"
                                     "##SIG=00000000:00000080:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0008:08:0:1:0\n";
          qword_1EB9A0FA8 = 411;
          xmmword_1EB9A0FB0 = 0u;
          xmmword_1EB9A0FC0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A0FA0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0C98);
        }
        uint64_t v24 = qword_1EB9A0FA8;
        *(void *)a4 = qword_1EB9A0FA0;
        *((void *)a4 + 1) = v24;
        uint64_t v25 = xmmword_1EB9A0FB0;
        if ((void)xmmword_1EB9A0FB0) {
          ++*(void *)(xmmword_1EB9A0FB0 + 8);
        }
        *((void *)a4 + 3) = 0;
        *((void *)a4 + 2) = v25;
        *((void *)a4 + 4) = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v7 = (const void *)*((void *)&xmmword_1EB9A0FB0 + 1);
        int64_t v8 = xmmword_1EB9A0FC0 - *((void *)&xmmword_1EB9A0FB0 + 1);
        if ((void)xmmword_1EB9A0FC0 == *((void *)&xmmword_1EB9A0FB0 + 1)) {
          return;
        }
        if (v8 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        size_t v9 = (char *)operator new(xmmword_1EB9A0FC0 - *((void *)&xmmword_1EB9A0FB0 + 1));
        break;
      default:
        goto LABEL_28;
    }
LABEL_114:
    *((void *)a4 + 3) = v9;
    *((void *)a4 + 4) = v9;
    int v42 = &v9[2 * (v8 >> 1)];
    *((void *)a4 + 5) = v42;
    memcpy(v9, v7, v8);
    *((void *)a4 + 4) = v42;
    return;
  }
  if (this == 396048 && a3)
  {
    switch(a2)
    {
      case 0:
        metal_sample2d0_half_s();
        uint64_t v12 = &qword_1EB9A1150;
        int v13 = a4;
        goto LABEL_22;
      case 1:
        metal_sample2d1_half_s();
        uint64_t v12 = &qword_1EB9A1180;
        int v13 = a4;
        goto LABEL_22;
      case 2:
        metal_sample2d2_half_s();
        uint64_t v12 = &qword_1EB9A11B0;
        int v13 = a4;
        goto LABEL_22;
      case 3:
        metal_sample2d3_half_s();
        uint64_t v12 = &qword_1EB9A11E0;
        int v13 = a4;
        goto LABEL_22;
      case 4:
        metal_sample2d4_half_s();
        uint64_t v12 = &qword_1EB9A1210;
        int v13 = a4;
        goto LABEL_22;
      case 5:
        metal_sample2d5_half_s();
        uint64_t v12 = &qword_1EB9A1240;
        int v13 = a4;
        goto LABEL_22;
      case 6:
        metal_sample2d6_half_s();
        uint64_t v12 = &qword_1EB9A1270;
        int v13 = a4;
        goto LABEL_22;
      case 7:
        metal_sample2d7_half_s();
        uint64_t v12 = &qword_1EB9A12A0;
        int v13 = a4;
        goto LABEL_22;
      default:
        goto LABEL_28;
    }
  }
  if (this == 396048)
  {
    switch(a2)
    {
      case 0:
        metal_sample2d0_s();
        uint64_t v12 = &qword_1EB9A12D0;
        int v13 = a4;
        break;
      case 1:
        metal_sample2d1_s();
        uint64_t v12 = &qword_1EB9A1300;
        int v13 = a4;
        break;
      case 2:
        metal_sample2d2_s();
        uint64_t v12 = &qword_1EB9A1330;
        int v13 = a4;
        break;
      case 3:
        metal_sample2d3_s();
        uint64_t v12 = &qword_1EB9A1360;
        int v13 = a4;
        break;
      case 4:
        metal_sample2d4_s();
        uint64_t v12 = &qword_1EB9A1390;
        int v13 = a4;
        break;
      case 5:
        metal_sample2d5_s();
        uint64_t v12 = &qword_1EB9A13C0;
        int v13 = a4;
        break;
      case 6:
        metal_sample2d6_s();
        uint64_t v12 = &qword_1EB9A13F0;
        int v13 = a4;
        break;
      case 7:
        metal_sample2d7_s();
        uint64_t v12 = &qword_1EB9A1420;
        int v13 = a4;
        break;
      default:
        goto LABEL_28;
    }
LABEL_22:
    HGString::HGString(v13, (const HGString *)v12);
  }
  else
  {
LABEL_28:
    *((_OWORD *)a4 + 1) = 0u;
    *((_OWORD *)a4 + 2) = 0u;
    *(_OWORD *)a4 = 0u;
  }
}

void sub_1B772D304(_Unwind_Exception *exception_object)
{
  int v3 = v2;
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 32) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void metal_sample2d0_half_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0CE0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0CE0))
  {
    qword_1EB9A1150 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=0000000207\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
                               "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = (float4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=17b31ac2:0d32b286:d460af2f:68ac1617\n"
                               "//SIG=00400000:00000001:00000000:00000001:0000:0000:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    qword_1EB9A1158 = 519;
    xmmword_1EB9A1160 = 0u;
    xmmword_1EB9A1170 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1150, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0CE0);
  }
}

void metal_sample2d1_half_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0CE8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0CE8))
  {
    qword_1EB9A1180 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=0000000207\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
                               "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = (float4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=66126f08:7a0a0541:50cb14b8:dc20ab48\n"
                               "//SIG=00400000:00000002:00000000:00000002:0000:0000:0000:0000:0000:0000:0004:0000:0002:02:0:1:0\n";
    qword_1EB9A1188 = 519;
    xmmword_1EB9A1190 = 0u;
    xmmword_1EB9A11A0 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1180, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0CE8);
  }
}

void metal_sample2d2_half_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0CF0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0CF0))
  {
    qword_1EB9A11B0 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=0000000207\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
                               "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = (float4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=e29ca5bf:3aefc427:e9cb6767:1fb5bfae\n"
                               "//SIG=00400000:00000004:00000000:00000004:0000:0000:0000:0000:0000:0000:0008:0000:0003:03:0:1:0\n";
    qword_1EB9A11B8 = 519;
    xmmword_1EB9A11C0 = 0u;
    xmmword_1EB9A11D0 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A11B0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0CF0);
  }
}

void metal_sample2d3_half_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0CF8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0CF8))
  {
    qword_1EB9A11E0 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=0000000207\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
                               "    sampler hg_Sampler3 [[ sampler(3) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = (float4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=26246cf2:677801c1:4ecdf5a0:4b8d05e2\n"
                               "//SIG=00400000:00000008:00000000:00000008:0000:0000:0000:0000:0000:0000:0010:0000:0004:04:0:1:0\n";
    qword_1EB9A11E8 = 519;
    xmmword_1EB9A11F0 = 0u;
    xmmword_1EB9A1200 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A11E0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0CF8);
  }
}

void metal_sample2d4_half_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D00, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0D00))
  {
    qword_1EB9A1210 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=0000000207\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
                               "    sampler hg_Sampler4 [[ sampler(4) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = (float4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=e58b568d:54c2b894:b659516b:b176e5ac\n"
                               "//SIG=00400000:00000010:00000000:00000010:0000:0000:0000:0000:0000:0000:0020:0000:0005:05:0:1:0\n";
    qword_1EB9A1218 = 519;
    xmmword_1EB9A1220 = 0u;
    xmmword_1EB9A1230 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1210, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0D00);
  }
}

void metal_sample2d5_half_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D08, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0D08))
  {
    qword_1EB9A1240 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=0000000207\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float5* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< half > hg_Texture5 [[ texture(5) ]], \n"
                               "    sampler hg_Sampler5 [[ sampler(5) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = (float4) hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=66f8f1b6:850d7b58:5ce020bb:4d7656a8\n"
                               "//SIG=00400000:00000020:00000000:00000020:0000:0000:0000:0000:0000:0000:0040:0000:0006:06:0:1:0\n";
    qword_1EB9A1248 = 519;
    xmmword_1EB9A1250 = 0u;
    xmmword_1EB9A1260 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1240, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0D08);
  }
}

void metal_sample2d6_half_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D10, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0D10))
  {
    qword_1EB9A1270 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=0000000207\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< half > hg_Texture6 [[ texture(6) ]], \n"
                               "    sampler hg_Sampler6 [[ sampler(6) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = (float4) hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=71cedd26:3f95a3bd:40380951:bd74d411\n"
                               "//SIG=00400000:00000040:00000000:00000040:0000:0000:0000:0000:0000:0000:0080:0000:0007:07:0:1:0\n";
    qword_1EB9A1278 = 519;
    xmmword_1EB9A1280 = 0u;
    xmmword_1EB9A1290 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1270, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0D10);
  }
}

void metal_sample2d7_half_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D18, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0D18))
  {
    qword_1EB9A12A0 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=0000000207\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< half > hg_Texture7 [[ texture(7) ]], \n"
                               "    sampler hg_Sampler7 [[ sampler(7) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = (float4) hg_Texture7.sample(hg_Sampler7, frag._texCoord7.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=366faa97:74f51e41:1aae0693:9870a122\n"
                               "//SIG=00400000:00000080:00000000:00000080:0000:0000:0000:0000:0000:0000:0100:0000:0008:08:0:1:0\n";
    qword_1EB9A12A8 = 519;
    xmmword_1EB9A12B0 = 0u;
    xmmword_1EB9A12C0 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A12A0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0D18);
  }
}

void metal_sample2d0_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D20, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0D20))
  {
    qword_1EB9A12D0 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=00000001ff\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
                               "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=6f669bc0:cf2c4116:fad604f7:6fdb36bb\n"
                               "//SIG=00000000:00000001:00000000:00000000:0000:0000:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    qword_1EB9A12D8 = 511;
    xmmword_1EB9A12E0 = 0u;
    xmmword_1EB9A12F0 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A12D0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0D20);
  }
}

void metal_sample2d1_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D28, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0D28))
  {
    qword_1EB9A1300 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=00000001ff\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
                               "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=337083c6:b5efb30c:e0498c87:962e883b\n"
                               "//SIG=00000000:00000002:00000000:00000000:0000:0000:0000:0000:0000:0000:0004:0000:0002:02:0:1:0\n";
    qword_1EB9A1308 = 511;
    xmmword_1EB9A1310 = 0u;
    xmmword_1EB9A1320 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1300, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0D28);
  }
}

void metal_sample2d2_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D30, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0D30))
  {
    qword_1EB9A1330 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=00000001ff\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
                               "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=78787321:d0f473ee:95960d97:3438eca2\n"
                               "//SIG=00000000:00000004:00000000:00000000:0000:0000:0000:0000:0000:0000:0008:0000:0003:03:0:1:0\n";
    qword_1EB9A1338 = 511;
    xmmword_1EB9A1340 = 0u;
    xmmword_1EB9A1350 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1330, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0D30);
  }
}

void metal_sample2d3_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D38, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0D38))
  {
    qword_1EB9A1360 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=00000001ff\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
                               "    sampler hg_Sampler3 [[ sampler(3) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=cd8bb6cc:4819f5f1:ddf3db57:3dfec92f\n"
                               "//SIG=00000000:00000008:00000000:00000000:0000:0000:0000:0000:0000:0000:0010:0000:0004:04:0:1:0\n";
    qword_1EB9A1368 = 511;
    xmmword_1EB9A1370 = 0u;
    xmmword_1EB9A1380 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1360, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0D38);
  }
}

void metal_sample2d4_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D40, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0D40))
  {
    qword_1EB9A1390 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=00000001ff\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
                               "    sampler hg_Sampler4 [[ sampler(4) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=2e9dff36:f2698c51:cfa8aed7:24c4c84e\n"
                               "//SIG=00000000:00000010:00000000:00000000:0000:0000:0000:0000:0000:0000:0020:0000:0005:05:0:1:0\n";
    qword_1EB9A1398 = 511;
    xmmword_1EB9A13A0 = 0u;
    xmmword_1EB9A13B0 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1390, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0D40);
  }
}

void metal_sample2d5_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D48, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0D48))
  {
    qword_1EB9A13C0 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=00000001ff\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< float > hg_Texture5 [[ texture(5) ]], \n"
                               "    sampler hg_Sampler5 [[ sampler(5) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=cc86252f:23fe64ab:2c3c7c52:1bfd6a43\n"
                               "//SIG=00000000:00000020:00000000:00000000:0000:0000:0000:0000:0000:0000:0040:0000:0006:06:0:1:0\n";
    qword_1EB9A13C8 = 511;
    xmmword_1EB9A13D0 = 0u;
    xmmword_1EB9A13E0 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A13C0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0D48);
  }
}

void metal_sample2d6_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D50, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0D50))
  {
    qword_1EB9A13F0 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=00000001ff\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< float > hg_Texture6 [[ texture(6) ]], \n"
                               "    sampler hg_Sampler6 [[ sampler(6) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=99bcb848:93607e3e:f6e46520:b61c284e\n"
                               "//SIG=00000000:00000040:00000000:00000000:0000:0000:0000:0000:0000:0000:0080:0000:0007:07:0:1:0\n";
    qword_1EB9A13F8 = 511;
    xmmword_1EB9A1400 = 0u;
    xmmword_1EB9A1410 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A13F0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0D50);
  }
}

void metal_sample2d7_s(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D58, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0D58))
  {
    qword_1EB9A1420 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=00000001ff\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                               "    texture2d< float > hg_Texture7 [[ texture(7) ]], \n"
                               "    sampler hg_Sampler7 [[ sampler(7) ]])\n"
                               "{\n"
                               "    FragmentOut output;\n"
                               "\n"
                               "    output.color0 = hg_Texture7.sample(hg_Sampler7, frag._texCoord7.xy);\n"
                               "    return output;\n"
                               "}\n"
                               "//MD5=5dc21ffb:da771f51:4ded01d3:f8c247ab\n"
                               "//SIG=00000000:00000080:00000000:00000000:0000:0000:0000:0000:0000:0000:0100:0000:0008:08:0:1:0\n";
    qword_1EB9A1428 = 511;
    xmmword_1EB9A1430 = 0u;
    xmmword_1EB9A1440 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1420, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0D58);
  }
}

void HGString::sampleRect(HGString *this@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (this <= 0x60310)
  {
    switch(a2)
    {
      case 0:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D60, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0D60))
        {
          qword_1EB9A1450 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019d\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f0=fragment.texcoord[0];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##0\n"
                                     "TEX $o0,$f0,texture[0],RECT;\n"
                                     "END\n"
                                     "##MD5=13e335a2:9b4d2bf6:db2e47e2:03487278\n"
                                     "##SIG=00000000:00000001:00000001:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
          qword_1EB9A1458 = 413;
          xmmword_1EB9A1460 = 0u;
          xmmword_1EB9A1470 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1450, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0D60);
        }
        uint64_t v4 = qword_1EB9A1458;
        *a3 = qword_1EB9A1450;
        a3[1] = v4;
        uint64_t v5 = xmmword_1EB9A1460;
        if ((void)xmmword_1EB9A1460) {
          ++*(void *)(xmmword_1EB9A1460 + 8);
        }
        a3[3] = 0;
        a3[2] = v5;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1460 + 1);
        int64_t v7 = xmmword_1EB9A1470 - *((void *)&xmmword_1EB9A1460 + 1);
        if ((void)xmmword_1EB9A1470 == *((void *)&xmmword_1EB9A1460 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1470 - *((void *)&xmmword_1EB9A1460 + 1));
        break;
      case 1:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D68, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0D68))
        {
          qword_1EB9A1480 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019d\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f1=fragment.texcoord[1];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##1\n"
                                     "TEX $o0,$f1,texture[1],RECT;\n"
                                     "END\n"
                                     "##MD5=187ebb5e:75f053ee:b9cd2328:68d3c628\n"
                                     "##SIG=00000000:00000002:00000002:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
          qword_1EB9A1488 = 413;
          xmmword_1EB9A1490 = 0u;
          xmmword_1EB9A14A0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1480, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0D68);
        }
        uint64_t v17 = qword_1EB9A1488;
        *a3 = qword_1EB9A1480;
        a3[1] = v17;
        uint64_t v18 = xmmword_1EB9A1490;
        if ((void)xmmword_1EB9A1490) {
          ++*(void *)(xmmword_1EB9A1490 + 8);
        }
        a3[3] = 0;
        a3[2] = v18;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1490 + 1);
        int64_t v7 = xmmword_1EB9A14A0 - *((void *)&xmmword_1EB9A1490 + 1);
        if ((void)xmmword_1EB9A14A0 == *((void *)&xmmword_1EB9A1490 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A14A0 - *((void *)&xmmword_1EB9A1490 + 1));
        break;
      case 2:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D70, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0D70))
        {
          qword_1EB9A14B0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019d\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f2=fragment.texcoord[2];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##2\n"
                                     "TEX $o0,$f2,texture[2],RECT;\n"
                                     "END\n"
                                     "##MD5=040e4cc4:32c92579:c792bf9b:f6c58a30\n"
                                     "##SIG=00000000:00000004:00000004:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
          qword_1EB9A14B8 = 413;
          xmmword_1EB9A14C0 = 0u;
          xmmword_1EB9A14D0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A14B0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0D70);
        }
        uint64_t v11 = qword_1EB9A14B8;
        *a3 = qword_1EB9A14B0;
        a3[1] = v11;
        uint64_t v12 = xmmword_1EB9A14C0;
        if ((void)xmmword_1EB9A14C0) {
          ++*(void *)(xmmword_1EB9A14C0 + 8);
        }
        a3[3] = 0;
        a3[2] = v12;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A14C0 + 1);
        int64_t v7 = xmmword_1EB9A14D0 - *((void *)&xmmword_1EB9A14C0 + 1);
        if ((void)xmmword_1EB9A14D0 == *((void *)&xmmword_1EB9A14C0 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A14D0 - *((void *)&xmmword_1EB9A14C0 + 1));
        break;
      case 3:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D78, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0D78))
        {
          qword_1EB9A14E0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019d\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f3=fragment.texcoord[3];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##3\n"
                                     "TEX $o0,$f3,texture[3],RECT;\n"
                                     "END\n"
                                     "##MD5=f09d8453:c175c072:e9ec1c7d:df7723d4\n"
                                     "##SIG=00000000:00000008:00000008:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0004:04:0:1:0\n";
          qword_1EB9A14E8 = 413;
          xmmword_1EB9A14F0 = 0u;
          xmmword_1EB9A1500 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A14E0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0D78);
        }
        uint64_t v13 = qword_1EB9A14E8;
        *a3 = qword_1EB9A14E0;
        a3[1] = v13;
        uint64_t v14 = xmmword_1EB9A14F0;
        if ((void)xmmword_1EB9A14F0) {
          ++*(void *)(xmmword_1EB9A14F0 + 8);
        }
        a3[3] = 0;
        a3[2] = v14;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A14F0 + 1);
        int64_t v7 = xmmword_1EB9A1500 - *((void *)&xmmword_1EB9A14F0 + 1);
        if ((void)xmmword_1EB9A1500 == *((void *)&xmmword_1EB9A14F0 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1500 - *((void *)&xmmword_1EB9A14F0 + 1));
        break;
      case 4:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D80, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0D80))
        {
          qword_1EB9A1510 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019d\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f4=fragment.texcoord[4];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##4\n"
                                     "TEX $o0,$f4,texture[4],RECT;\n"
                                     "END\n"
                                     "##MD5=0d4c4995:9892fdda:25d75c20:e69d0655\n"
                                     "##SIG=00000000:00000010:00000010:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0005:05:0:1:0\n";
          qword_1EB9A1518 = 413;
          xmmword_1EB9A1520 = 0u;
          xmmword_1EB9A1530 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1510, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0D80);
        }
        uint64_t v9 = qword_1EB9A1518;
        *a3 = qword_1EB9A1510;
        a3[1] = v9;
        uint64_t v10 = xmmword_1EB9A1520;
        if ((void)xmmword_1EB9A1520) {
          ++*(void *)(xmmword_1EB9A1520 + 8);
        }
        a3[3] = 0;
        a3[2] = v10;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1520 + 1);
        int64_t v7 = xmmword_1EB9A1530 - *((void *)&xmmword_1EB9A1520 + 1);
        if ((void)xmmword_1EB9A1530 == *((void *)&xmmword_1EB9A1520 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1530 - *((void *)&xmmword_1EB9A1520 + 1));
        break;
      case 5:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D88, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0D88))
        {
          qword_1EB9A1540 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019d\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f5=fragment.texcoord[5];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##5\n"
                                     "TEX $o0,$f5,texture[5],RECT;\n"
                                     "END\n"
                                     "##MD5=05fcc9b2:9b232369:60268b6e:77392bc9\n"
                                     "##SIG=00000000:00000020:00000020:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0006:06:0:1:0\n";
          qword_1EB9A1548 = 413;
          xmmword_1EB9A1550 = 0u;
          xmmword_1EB9A1560 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1540, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0D88);
        }
        uint64_t v19 = qword_1EB9A1548;
        *a3 = qword_1EB9A1540;
        a3[1] = v19;
        uint64_t v20 = xmmword_1EB9A1550;
        if ((void)xmmword_1EB9A1550) {
          ++*(void *)(xmmword_1EB9A1550 + 8);
        }
        a3[3] = 0;
        a3[2] = v20;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1550 + 1);
        int64_t v7 = xmmword_1EB9A1560 - *((void *)&xmmword_1EB9A1550 + 1);
        if ((void)xmmword_1EB9A1560 == *((void *)&xmmword_1EB9A1550 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1560 - *((void *)&xmmword_1EB9A1550 + 1));
        break;
      case 6:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D90, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0D90))
        {
          qword_1EB9A1570 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019d\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f6=fragment.texcoord[6];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##6\n"
                                     "TEX $o0,$f6,texture[6],RECT;\n"
                                     "END\n"
                                     "##MD5=612cfe17:9d77fa2d:25c645b8:3fc04f19\n"
                                     "##SIG=00000000:00000040:00000040:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0007:07:0:1:0\n";
          qword_1EB9A1578 = 413;
          xmmword_1EB9A1580 = 0u;
          xmmword_1EB9A1590 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1570, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0D90);
        }
        uint64_t v21 = qword_1EB9A1578;
        *a3 = qword_1EB9A1570;
        a3[1] = v21;
        uint64_t v22 = xmmword_1EB9A1580;
        if ((void)xmmword_1EB9A1580) {
          ++*(void *)(xmmword_1EB9A1580 + 8);
        }
        a3[3] = 0;
        a3[2] = v22;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1580 + 1);
        int64_t v7 = xmmword_1EB9A1590 - *((void *)&xmmword_1EB9A1580 + 1);
        if ((void)xmmword_1EB9A1590 == *((void *)&xmmword_1EB9A1580 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1590 - *((void *)&xmmword_1EB9A1580 + 1));
        break;
      case 7:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0D98, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0D98))
        {
          qword_1EB9A15A0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019d\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f7=fragment.texcoord[7];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##7\n"
                                     "TEX $o0,$f7,texture[7],RECT;\n"
                                     "END\n"
                                     "##MD5=dd11faf4:09e5515e:92d0cd6f:ce9e10ae\n"
                                     "##SIG=00000000:00000080:00000080:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0008:08:0:1:0\n";
          qword_1EB9A15A8 = 413;
          xmmword_1EB9A15B0 = 0u;
          xmmword_1EB9A15C0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A15A0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0D98);
        }
        uint64_t v15 = qword_1EB9A15A8;
        *a3 = qword_1EB9A15A0;
        a3[1] = v15;
        uint64_t v16 = xmmword_1EB9A15B0;
        if ((void)xmmword_1EB9A15B0) {
          ++*(void *)(xmmword_1EB9A15B0 + 8);
        }
        a3[3] = 0;
        a3[2] = v16;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A15B0 + 1);
        int64_t v7 = xmmword_1EB9A15C0 - *((void *)&xmmword_1EB9A15B0 + 1);
        if ((void)xmmword_1EB9A15C0 == *((void *)&xmmword_1EB9A15B0 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A15C0 - *((void *)&xmmword_1EB9A15B0 + 1));
        break;
      default:
        JUMPOUT(0);
    }
    a3[3] = v8;
    a3[4] = v8;
    uint64_t v23 = &v8[2 * (v7 >> 1)];
    a3[5] = v23;
    memcpy(v8, v6, v7);
    a3[4] = v23;
  }
  else
  {
    *((_OWORD *)a3 + 1) = 0u;
    *((_OWORD *)a3 + 2) = 0u;
    *(_OWORD *)a3 = 0u;
  }
}

void sub_1B772E548(_Unwind_Exception *exception_object)
{
  int v3 = v2;
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 32) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void HGString::zero(HGString *this@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (this == 394784)
  {
    if (a2 == 1)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0DC0, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9A0DC0))
      {
        qword_1EB9A1690 = (uint64_t)"//GLfs2.0      \n"
                                   "//LEN=0000000142\n"
                                   "#ifndef GL_ES\n"
                                   "#define lowp\n"
                                   "#define mediump\n"
                                   "#define highp\n"
                                   "#endif\n"
                                   "#define defaultp mediump\n"
                                   "void main()\n"
                                   "{\n"
                                   "\n"
                                   "    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
                                   "}\n"
                                   "//MD5=7adfdc9a:833a3e83:3a6b376d:41cc225f\n"
                                   "//SIG=00000000:00000000:00000000:00000000:0008:0000:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
        qword_1EB9A1698 = 322;
        xmmword_1EB9A16A0 = 0u;
        xmmword_1EB9A16B0 = 0u;
        __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1690, &dword_1B73F3000);
        __cxa_guard_release(&qword_1EB9A0DC0);
      }
      uint64_t v9 = qword_1EB9A1698;
      *a3 = qword_1EB9A1690;
      a3[1] = v9;
      uint64_t v10 = xmmword_1EB9A16A0;
      if ((void)xmmword_1EB9A16A0) {
        ++*(void *)(xmmword_1EB9A16A0 + 8);
      }
      a3[3] = 0;
      a3[2] = v10;
      a3[4] = 0;
      a3[5] = 0;
      uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A16A0 + 1);
      int64_t v7 = xmmword_1EB9A16B0 - *((void *)&xmmword_1EB9A16A0 + 1);
      if ((void)xmmword_1EB9A16B0 != *((void *)&xmmword_1EB9A16A0 + 1))
      {
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A16B0 - *((void *)&xmmword_1EB9A16A0 + 1));
        goto LABEL_45;
      }
      return;
    }
LABEL_25:
    *((_OWORD *)a3 + 1) = 0u;
    *((_OWORD *)a3 + 2) = 0u;
    *(_OWORD *)a3 = 0u;
    return;
  }
  if (this == 394000)
  {
    switch(a2)
    {
      case 1:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0DA0, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0DA0))
        {
          qword_1EB9A15D0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=0000000166\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,0;\n"
                                     "END\n"
                                     "##MD5=3ceff9da:f8e4fe0b:1f0d94c2:9c9fb061\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
          qword_1EB9A15D8 = 358;
          xmmword_1EB9A15E0 = 0u;
          xmmword_1EB9A15F0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A15D0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0DA0);
        }
        uint64_t v4 = qword_1EB9A15D8;
        *a3 = qword_1EB9A15D0;
        a3[1] = v4;
        uint64_t v5 = xmmword_1EB9A15E0;
        if ((void)xmmword_1EB9A15E0) {
          ++*(void *)(xmmword_1EB9A15E0 + 8);
        }
        a3[3] = 0;
        a3[2] = v5;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A15E0 + 1);
        int64_t v7 = xmmword_1EB9A15F0 - *((void *)&xmmword_1EB9A15E0 + 1);
        if ((void)xmmword_1EB9A15F0 == *((void *)&xmmword_1EB9A15E0 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A15F0 - *((void *)&xmmword_1EB9A15E0 + 1));
        break;
      case 2:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0DA8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0DA8))
        {
          qword_1EB9A1600 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000018d\n"
                                     "##                          \n"
                                     "OPTION ARB_draw_buffers;      \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "OUTPUT $o1=result.color[1];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,0;\n"
                                     "MOV $o1,0;\n"
                                     "END\n"
                                     "##MD5=4220a7e0:dd39f279:15beca1d:51f222cf\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0000:00:0:2:0\n";
          qword_1EB9A1608 = 397;
          xmmword_1EB9A1610 = 0u;
          xmmword_1EB9A1620 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1600, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0DA8);
        }
        uint64_t v17 = qword_1EB9A1608;
        *a3 = qword_1EB9A1600;
        a3[1] = v17;
        uint64_t v18 = xmmword_1EB9A1610;
        if ((void)xmmword_1EB9A1610) {
          ++*(void *)(xmmword_1EB9A1610 + 8);
        }
        a3[3] = 0;
        a3[2] = v18;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1610 + 1);
        int64_t v7 = xmmword_1EB9A1620 - *((void *)&xmmword_1EB9A1610 + 1);
        if ((void)xmmword_1EB9A1620 == *((void *)&xmmword_1EB9A1610 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1620 - *((void *)&xmmword_1EB9A1610 + 1));
        break;
      case 3:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0DB0, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0DB0))
        {
          qword_1EB9A1630 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=00000001b4\n"
                                     "##                          \n"
                                     "OPTION ARB_draw_buffers;      \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "OUTPUT $o1=result.color[1];\n"
                                     "OUTPUT $o2=result.color[2];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,0;\n"
                                     "MOV $o1,0;\n"
                                     "MOV $o2,0;\n"
                                     "END\n"
                                     "##MD5=c57659bc:b333a723:e93c4b2e:3d8afb44\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0000:00:0:3:0\n";
          qword_1EB9A1638 = 436;
          xmmword_1EB9A1640 = 0u;
          xmmword_1EB9A1650 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1630, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0DB0);
        }
        uint64_t v13 = qword_1EB9A1638;
        *a3 = qword_1EB9A1630;
        a3[1] = v13;
        uint64_t v14 = xmmword_1EB9A1640;
        if ((void)xmmword_1EB9A1640) {
          ++*(void *)(xmmword_1EB9A1640 + 8);
        }
        a3[3] = 0;
        a3[2] = v14;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1640 + 1);
        int64_t v7 = xmmword_1EB9A1650 - *((void *)&xmmword_1EB9A1640 + 1);
        if ((void)xmmword_1EB9A1650 == *((void *)&xmmword_1EB9A1640 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1650 - *((void *)&xmmword_1EB9A1640 + 1));
        break;
      case 4:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0DB8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0DB8))
        {
          qword_1EB9A1660 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=00000001db\n"
                                     "##                          \n"
                                     "OPTION ARB_draw_buffers;      \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "OUTPUT $o1=result.color[1];\n"
                                     "OUTPUT $o2=result.color[2];\n"
                                     "OUTPUT $o3=result.color[3];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,0;\n"
                                     "MOV $o1,0;\n"
                                     "MOV $o2,0;\n"
                                     "MOV $o3,0;\n"
                                     "END\n"
                                     "##MD5=cadf4aa4:08ce60f0:fa35326a:3fdb468b\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0000:00:0:4:0\n";
          qword_1EB9A1668 = 475;
          xmmword_1EB9A1670 = 0u;
          xmmword_1EB9A1680 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1660, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0DB8);
        }
        uint64_t v15 = qword_1EB9A1668;
        *a3 = qword_1EB9A1660;
        a3[1] = v15;
        uint64_t v16 = xmmword_1EB9A1670;
        if ((void)xmmword_1EB9A1670) {
          ++*(void *)(xmmword_1EB9A1670 + 8);
        }
        a3[3] = 0;
        a3[2] = v16;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1670 + 1);
        int64_t v7 = xmmword_1EB9A1680 - *((void *)&xmmword_1EB9A1670 + 1);
        if ((void)xmmword_1EB9A1680 == *((void *)&xmmword_1EB9A1670 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1680 - *((void *)&xmmword_1EB9A1670 + 1));
        break;
      default:
        goto LABEL_25;
    }
LABEL_45:
    a3[3] = v8;
    a3[4] = v8;
    uint64_t v19 = &v8[2 * (v7 >> 1)];
    a3[5] = v19;
    memcpy(v8, v6, v7);
    a3[4] = v19;
    return;
  }
  if (this != 396048 || a2 != 1) {
    goto LABEL_25;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0DC8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0DC8))
  {
    qword_1EB9A16C0 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=0000000144\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]])\n"
                               "{\n"
                               "    FragmentOut out;\n"
                               "    out.color0 = float4(0.0, 0.0, 0.0, 0.0);\n"
                               "    return out;\n"
                               "}\n"
                               "//MD5=0e8c5223:95470a31:cf2258f7:9d6891f3\n"
                               "//SIG=00000000:00000000:00000000:00000000:0004:0000:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
    qword_1EB9A16C8 = 324;
    xmmword_1EB9A16D0 = 0u;
    xmmword_1EB9A16E0 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A16C0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0DC8);
  }
  uint64_t v11 = qword_1EB9A16C8;
  *a3 = qword_1EB9A16C0;
  a3[1] = v11;
  uint64_t v12 = xmmword_1EB9A16D0;
  if ((void)xmmword_1EB9A16D0) {
    ++*(void *)(xmmword_1EB9A16D0 + 8);
  }
  a3[3] = 0;
  a3[2] = v12;
  a3[4] = 0;
  a3[5] = 0;
  uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A16D0 + 1);
  int64_t v7 = xmmword_1EB9A16E0 - *((void *)&xmmword_1EB9A16D0 + 1);
  if ((void)xmmword_1EB9A16E0 != *((void *)&xmmword_1EB9A16D0 + 1))
  {
    if (v7 < 0) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    int64_t v8 = (char *)operator new(xmmword_1EB9A16E0 - *((void *)&xmmword_1EB9A16D0 + 1));
    goto LABEL_45;
  }
}

void sub_1B772EB70(_Unwind_Exception *exception_object)
{
  int v3 = v2;
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 32) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void HGString::uniform(HGString *this@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (this == 394784)
  {
    if (a2 == 1)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0DF0, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9A0DF0))
      {
        qword_1EB9A17B0 = (uint64_t)"//GLfs2.0      \n"
                                   "//LEN=0000000161\n"
                                   "#ifndef GL_ES\n"
                                   "#define lowp\n"
                                   "#define mediump\n"
                                   "#define highp\n"
                                   "#endif\n"
                                   "#define defaultp mediump\n"
                                   "uniform defaultp vec4 hg_ProgramLocal0;\n"
                                   "void main()\n"
                                   "{\n"
                                   "    gl_FragColor = hg_ProgramLocal0;\n"
                                   "}\n"
                                   "//MD5=6f46fc08:7f6efe98:42430a53:9b0c48ab\n"
                                   "//SIG=00000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
        qword_1EB9A17B8 = 353;
        xmmword_1EB9A17C0 = 0u;
        xmmword_1EB9A17D0 = 0u;
        __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A17B0, &dword_1B73F3000);
        __cxa_guard_release(&qword_1EB9A0DF0);
      }
      uint64_t v9 = qword_1EB9A17B8;
      *a3 = qword_1EB9A17B0;
      a3[1] = v9;
      uint64_t v10 = xmmword_1EB9A17C0;
      if ((void)xmmword_1EB9A17C0) {
        ++*(void *)(xmmword_1EB9A17C0 + 8);
      }
      a3[3] = 0;
      a3[2] = v10;
      a3[4] = 0;
      a3[5] = 0;
      uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A17C0 + 1);
      int64_t v7 = xmmword_1EB9A17D0 - *((void *)&xmmword_1EB9A17C0 + 1);
      if ((void)xmmword_1EB9A17D0 != *((void *)&xmmword_1EB9A17C0 + 1))
      {
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A17D0 - *((void *)&xmmword_1EB9A17C0 + 1));
        goto LABEL_45;
      }
      return;
    }
LABEL_25:
    *((_OWORD *)a3 + 1) = 0u;
    *((_OWORD *)a3 + 2) = 0u;
    *(_OWORD *)a3 = 0u;
    return;
  }
  if (this == 394000)
  {
    switch(a2)
    {
      case 1:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0DD0, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0DD0))
        {
          qword_1EB9A16F0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=0000000184\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "PARAM $p0=program.local[0];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,$p0;\n"
                                     "END\n"
                                     "##MD5=d462425f:378ab328:d024cd98:47c08aa4\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
          qword_1EB9A16F8 = 388;
          xmmword_1EB9A1700 = 0u;
          xmmword_1EB9A1710 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A16F0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0DD0);
        }
        uint64_t v4 = qword_1EB9A16F8;
        *a3 = qword_1EB9A16F0;
        a3[1] = v4;
        uint64_t v5 = xmmword_1EB9A1700;
        if ((void)xmmword_1EB9A1700) {
          ++*(void *)(xmmword_1EB9A1700 + 8);
        }
        a3[3] = 0;
        a3[2] = v5;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1700 + 1);
        int64_t v7 = xmmword_1EB9A1710 - *((void *)&xmmword_1EB9A1700 + 1);
        if ((void)xmmword_1EB9A1710 == *((void *)&xmmword_1EB9A1700 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1710 - *((void *)&xmmword_1EB9A1700 + 1));
        break;
      case 2:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0DD8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0DD8))
        {
          qword_1EB9A1720 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=00000001c9\n"
                                     "##                          \n"
                                     "OPTION ARB_draw_buffers;      \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "OUTPUT $o1=result.color[1];\n"
                                     "PARAM $p0=program.local[0];\n"
                                     "PARAM $p1=program.local[1];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,$p0;\n"
                                     "MOV $o1,$p1;\n"
                                     "END\n"
                                     "##MD5=738a1d38:64b2f1bf:c3afc4a3:dc2a01ed\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0002:0000:0000:0000:0000:0000:0000:0000:00:0:2:0\n";
          qword_1EB9A1728 = 457;
          xmmword_1EB9A1730 = 0u;
          xmmword_1EB9A1740 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1720, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0DD8);
        }
        uint64_t v17 = qword_1EB9A1728;
        *a3 = qword_1EB9A1720;
        a3[1] = v17;
        uint64_t v18 = xmmword_1EB9A1730;
        if ((void)xmmword_1EB9A1730) {
          ++*(void *)(xmmword_1EB9A1730 + 8);
        }
        a3[3] = 0;
        a3[2] = v18;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1730 + 1);
        int64_t v7 = xmmword_1EB9A1740 - *((void *)&xmmword_1EB9A1730 + 1);
        if ((void)xmmword_1EB9A1740 == *((void *)&xmmword_1EB9A1730 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1740 - *((void *)&xmmword_1EB9A1730 + 1));
        break;
      case 3:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0DE0, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0DE0))
        {
          qword_1EB9A1750 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000020e\n"
                                     "##                          \n"
                                     "OPTION ARB_draw_buffers;      \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "OUTPUT $o1=result.color[1];\n"
                                     "OUTPUT $o2=result.color[2];\n"
                                     "PARAM $p0=program.local[0];\n"
                                     "PARAM $p1=program.local[1];\n"
                                     "PARAM $p2=program.local[2];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,$p0;\n"
                                     "MOV $o1,$p1;\n"
                                     "MOV $o2,$p2;\n"
                                     "END\n"
                                     "##MD5=f7bc6585:49c7c440:b099ae3e:eb448ac4\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0003:0000:0000:0000:0000:0000:0000:0000:00:0:3:0\n";
          qword_1EB9A1758 = 526;
          xmmword_1EB9A1760 = 0u;
          xmmword_1EB9A1770 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1750, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0DE0);
        }
        uint64_t v13 = qword_1EB9A1758;
        *a3 = qword_1EB9A1750;
        a3[1] = v13;
        uint64_t v14 = xmmword_1EB9A1760;
        if ((void)xmmword_1EB9A1760) {
          ++*(void *)(xmmword_1EB9A1760 + 8);
        }
        a3[3] = 0;
        a3[2] = v14;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1760 + 1);
        int64_t v7 = xmmword_1EB9A1770 - *((void *)&xmmword_1EB9A1760 + 1);
        if ((void)xmmword_1EB9A1770 == *((void *)&xmmword_1EB9A1760 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1770 - *((void *)&xmmword_1EB9A1760 + 1));
        break;
      case 4:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0DE8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0DE8))
        {
          qword_1EB9A1780 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=0000000253\n"
                                     "##                          \n"
                                     "OPTION ARB_draw_buffers;      \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "OUTPUT $o1=result.color[1];\n"
                                     "OUTPUT $o2=result.color[2];\n"
                                     "OUTPUT $o3=result.color[3];\n"
                                     "PARAM $p0=program.local[0];\n"
                                     "PARAM $p1=program.local[1];\n"
                                     "PARAM $p2=program.local[2];\n"
                                     "PARAM $p3=program.local[3];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,$p0;\n"
                                     "MOV $o1,$p1;\n"
                                     "MOV $o2,$p2;\n"
                                     "MOV $o3,$p3;\n"
                                     "END\n"
                                     "##MD5=b167705d:4bee0a9e:4099e1d1:d66d666c\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0004:0000:0000:0000:0000:0000:0000:0000:00:0:4:0\n";
          qword_1EB9A1788 = 595;
          xmmword_1EB9A1790 = 0u;
          xmmword_1EB9A17A0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1780, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0DE8);
        }
        uint64_t v15 = qword_1EB9A1788;
        *a3 = qword_1EB9A1780;
        a3[1] = v15;
        uint64_t v16 = xmmword_1EB9A1790;
        if ((void)xmmword_1EB9A1790) {
          ++*(void *)(xmmword_1EB9A1790 + 8);
        }
        a3[3] = 0;
        a3[2] = v16;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1790 + 1);
        int64_t v7 = xmmword_1EB9A17A0 - *((void *)&xmmword_1EB9A1790 + 1);
        if ((void)xmmword_1EB9A17A0 == *((void *)&xmmword_1EB9A1790 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A17A0 - *((void *)&xmmword_1EB9A1790 + 1));
        break;
      default:
        goto LABEL_25;
    }
LABEL_45:
    a3[3] = v8;
    a3[4] = v8;
    uint64_t v19 = &v8[2 * (v7 >> 1)];
    a3[5] = v19;
    memcpy(v8, v6, v7);
    a3[4] = v19;
    return;
  }
  if (this != 396048 || a2 != 1) {
    goto LABEL_25;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0DF8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A0DF8))
  {
    qword_1EB9A17E0 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=000000016d\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]])\n"
                               "{\n"
                               "    FragmentOut out;\n"
                               "    out.color0 = hg_Params[0];\n"
                               "    return out;\n"
                               "}\n"
                               "//MD5=4c294923:0d8b5516:557382a3:0e90cae8\n"
                               "//SIG=00000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
    qword_1EB9A17E8 = 365;
    xmmword_1EB9A17F0 = 0u;
    xmmword_1EB9A1800 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A17E0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A0DF8);
  }
  uint64_t v11 = qword_1EB9A17E8;
  *a3 = qword_1EB9A17E0;
  a3[1] = v11;
  uint64_t v12 = xmmword_1EB9A17F0;
  if ((void)xmmword_1EB9A17F0) {
    ++*(void *)(xmmword_1EB9A17F0 + 8);
  }
  a3[3] = 0;
  a3[2] = v12;
  a3[4] = 0;
  a3[5] = 0;
  uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A17F0 + 1);
  int64_t v7 = xmmword_1EB9A1800 - *((void *)&xmmword_1EB9A17F0 + 1);
  if ((void)xmmword_1EB9A1800 != *((void *)&xmmword_1EB9A17F0 + 1))
  {
    if (v7 < 0) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    int64_t v8 = (char *)operator new(xmmword_1EB9A1800 - *((void *)&xmmword_1EB9A17F0 + 1));
    goto LABEL_45;
  }
}

void sub_1B772F180(_Unwind_Exception *exception_object)
{
  int v3 = v2;
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 32) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void HGString::transform(HGString *this@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (this == 329232)
  {
    switch(a2)
    {
      case 0:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0E00, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0E00))
        {
          qword_1EB9A1810 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=0000000132\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "}\n"
                                     "//MD5=798335e4:f8112073:f251d283:ad257ca6\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0004:0000:0000:0000:0000:0000:0000:0000:00:0:0:0\n";
          qword_1EB9A1818 = 306;
          xmmword_1EB9A1820 = 0u;
          xmmword_1EB9A1830 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1810, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0E00);
        }
        uint64_t v4 = qword_1EB9A1818;
        *a3 = qword_1EB9A1810;
        a3[1] = v4;
        uint64_t v5 = xmmword_1EB9A1820;
        if ((void)xmmword_1EB9A1820) {
          ++*(void *)(xmmword_1EB9A1820 + 8);
        }
        a3[3] = 0;
        a3[2] = v5;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1820 + 1);
        int64_t v7 = xmmword_1EB9A1830 - *((void *)&xmmword_1EB9A1820 + 1);
        if ((void)xmmword_1EB9A1830 == *((void *)&xmmword_1EB9A1820 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1830 - *((void *)&xmmword_1EB9A1820 + 1));
        break;
      case 1:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0E08, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0E08))
        {
          qword_1EB9A1840 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=00000001c9\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "}\n"
                                     "//MD5=71174425:010f0f7c:df2f36ee:91448d34\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0008:0000:0000:0000:0000:0000:0000:0001:00:0:0:0\n";
          qword_1EB9A1848 = 457;
          xmmword_1EB9A1850 = 0u;
          xmmword_1EB9A1860 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1840, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0E08);
        }
        uint64_t v17 = qword_1EB9A1848;
        *a3 = qword_1EB9A1840;
        a3[1] = v17;
        uint64_t v18 = xmmword_1EB9A1850;
        if ((void)xmmword_1EB9A1850) {
          ++*(void *)(xmmword_1EB9A1850 + 8);
        }
        a3[3] = 0;
        a3[2] = v18;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1850 + 1);
        int64_t v7 = xmmword_1EB9A1860 - *((void *)&xmmword_1EB9A1850 + 1);
        if ((void)xmmword_1EB9A1860 == *((void *)&xmmword_1EB9A1850 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1860 - *((void *)&xmmword_1EB9A1850 + 1));
        break;
      case 2:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0E10, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0E10))
        {
          qword_1EB9A1870 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=0000000260\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "}\n"
                                     "//MD5=0d16a22d:f5ee5b44:fa0fdd4e:171d7327\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:000c:0000:0000:0000:0000:0000:0000:0002:00:0:0:0\n";
          qword_1EB9A1878 = 608;
          xmmword_1EB9A1880 = 0u;
          xmmword_1EB9A1890 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1870, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0E10);
        }
        uint64_t v11 = qword_1EB9A1878;
        *a3 = qword_1EB9A1870;
        a3[1] = v11;
        uint64_t v12 = xmmword_1EB9A1880;
        if ((void)xmmword_1EB9A1880) {
          ++*(void *)(xmmword_1EB9A1880 + 8);
        }
        a3[3] = 0;
        a3[2] = v12;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1880 + 1);
        int64_t v7 = xmmword_1EB9A1890 - *((void *)&xmmword_1EB9A1880 + 1);
        if ((void)xmmword_1EB9A1890 == *((void *)&xmmword_1EB9A1880 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1890 - *((void *)&xmmword_1EB9A1880 + 1));
        break;
      case 3:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0E18, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0E18))
        {
          qword_1EB9A18A0 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=00000002f7\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "uniform mat4 hg_TextureMatrix2;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "attribute vec4 hg_MultiTexCoord2;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "varying vec4 hg_TexCoord2;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "    hg_TexCoord2 = hg_TextureMatrix2 * hg_MultiTexCoord2;\n"
                                     "}\n"
                                     "//MD5=46e1660d:64e5cba3:90dbf667:6da3c1bc\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0010:0000:0000:0000:0000:0000:0000:0003:00:0:0:0\n";
          qword_1EB9A18A8 = 759;
          xmmword_1EB9A18B0 = 0u;
          xmmword_1EB9A18C0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A18A0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0E18);
        }
        uint64_t v13 = qword_1EB9A18A8;
        *a3 = qword_1EB9A18A0;
        a3[1] = v13;
        uint64_t v14 = xmmword_1EB9A18B0;
        if ((void)xmmword_1EB9A18B0) {
          ++*(void *)(xmmword_1EB9A18B0 + 8);
        }
        a3[3] = 0;
        a3[2] = v14;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A18B0 + 1);
        int64_t v7 = xmmword_1EB9A18C0 - *((void *)&xmmword_1EB9A18B0 + 1);
        if ((void)xmmword_1EB9A18C0 == *((void *)&xmmword_1EB9A18B0 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A18C0 - *((void *)&xmmword_1EB9A18B0 + 1));
        break;
      case 4:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0E20, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0E20))
        {
          qword_1EB9A18D0 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=000000038e\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "uniform mat4 hg_TextureMatrix2;\n"
                                     "uniform mat4 hg_TextureMatrix3;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "attribute vec4 hg_MultiTexCoord2;\n"
                                     "attribute vec4 hg_MultiTexCoord3;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "varying vec4 hg_TexCoord2;\n"
                                     "varying vec4 hg_TexCoord3;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "    hg_TexCoord2 = hg_TextureMatrix2 * hg_MultiTexCoord2;\n"
                                     "    hg_TexCoord3 = hg_TextureMatrix3 * hg_MultiTexCoord3;\n"
                                     "}\n"
                                     "//MD5=50ca4534:b10918ea:75eb3624:be748584\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0014:0000:0000:0000:0000:0000:0000:0004:00:0:0:0\n";
          qword_1EB9A18D8 = 910;
          xmmword_1EB9A18E0 = 0u;
          xmmword_1EB9A18F0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A18D0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0E20);
        }
        uint64_t v9 = qword_1EB9A18D8;
        *a3 = qword_1EB9A18D0;
        a3[1] = v9;
        uint64_t v10 = xmmword_1EB9A18E0;
        if ((void)xmmword_1EB9A18E0) {
          ++*(void *)(xmmword_1EB9A18E0 + 8);
        }
        a3[3] = 0;
        a3[2] = v10;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A18E0 + 1);
        int64_t v7 = xmmword_1EB9A18F0 - *((void *)&xmmword_1EB9A18E0 + 1);
        if ((void)xmmword_1EB9A18F0 == *((void *)&xmmword_1EB9A18E0 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A18F0 - *((void *)&xmmword_1EB9A18E0 + 1));
        break;
      case 5:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0E28, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0E28))
        {
          qword_1EB9A1900 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=0000000425\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "uniform mat4 hg_TextureMatrix2;\n"
                                     "uniform mat4 hg_TextureMatrix3;\n"
                                     "uniform mat4 hg_TextureMatrix4;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "attribute vec4 hg_MultiTexCoord2;\n"
                                     "attribute vec4 hg_MultiTexCoord3;\n"
                                     "attribute vec4 hg_MultiTexCoord4;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "varying vec4 hg_TexCoord2;\n"
                                     "varying vec4 hg_TexCoord3;\n"
                                     "varying vec4 hg_TexCoord4;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "    hg_TexCoord2 = hg_TextureMatrix2 * hg_MultiTexCoord2;\n"
                                     "    hg_TexCoord3 = hg_TextureMatrix3 * hg_MultiTexCoord3;\n"
                                     "    hg_TexCoord4 = hg_TextureMatrix4 * hg_MultiTexCoord4;\n"
                                     "}\n"
                                     "//MD5=9d94f62f:3562211b:261ee061:c15dfe35\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0018:0000:0000:0000:0000:0000:0000:0005:00:0:0:0\n";
          qword_1EB9A1908 = 1061;
          xmmword_1EB9A1910 = 0u;
          xmmword_1EB9A1920 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1900, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0E28);
        }
        uint64_t v19 = qword_1EB9A1908;
        *a3 = qword_1EB9A1900;
        a3[1] = v19;
        uint64_t v20 = xmmword_1EB9A1910;
        if ((void)xmmword_1EB9A1910) {
          ++*(void *)(xmmword_1EB9A1910 + 8);
        }
        a3[3] = 0;
        a3[2] = v20;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1910 + 1);
        int64_t v7 = xmmword_1EB9A1920 - *((void *)&xmmword_1EB9A1910 + 1);
        if ((void)xmmword_1EB9A1920 == *((void *)&xmmword_1EB9A1910 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1920 - *((void *)&xmmword_1EB9A1910 + 1));
        break;
      case 6:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0E30, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0E30))
        {
          qword_1EB9A1930 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=00000004bc\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "uniform mat4 hg_TextureMatrix2;\n"
                                     "uniform mat4 hg_TextureMatrix3;\n"
                                     "uniform mat4 hg_TextureMatrix4;\n"
                                     "uniform mat4 hg_TextureMatrix5;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "attribute vec4 hg_MultiTexCoord2;\n"
                                     "attribute vec4 hg_MultiTexCoord3;\n"
                                     "attribute vec4 hg_MultiTexCoord4;\n"
                                     "attribute vec4 hg_MultiTexCoord5;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "varying vec4 hg_TexCoord2;\n"
                                     "varying vec4 hg_TexCoord3;\n"
                                     "varying vec4 hg_TexCoord4;\n"
                                     "varying vec4 hg_TexCoord5;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "    hg_TexCoord2 = hg_TextureMatrix2 * hg_MultiTexCoord2;\n"
                                     "    hg_TexCoord3 = hg_TextureMatrix3 * hg_MultiTexCoord3;\n"
                                     "    hg_TexCoord4 = hg_TextureMatrix4 * hg_MultiTexCoord4;\n"
                                     "    hg_TexCoord5 = hg_TextureMatrix5 * hg_MultiTexCoord5;\n"
                                     "}\n"
                                     "//MD5=450acf6f:24c8abd8:64c7ce12:3c4bd63d\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:001c:0000:0000:0000:0000:0000:0000:0006:00:0:0:0\n";
          qword_1EB9A1938 = 1212;
          xmmword_1EB9A1940 = 0u;
          xmmword_1EB9A1950 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1930, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0E30);
        }
        uint64_t v21 = qword_1EB9A1938;
        *a3 = qword_1EB9A1930;
        a3[1] = v21;
        uint64_t v22 = xmmword_1EB9A1940;
        if ((void)xmmword_1EB9A1940) {
          ++*(void *)(xmmword_1EB9A1940 + 8);
        }
        a3[3] = 0;
        a3[2] = v22;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1940 + 1);
        int64_t v7 = xmmword_1EB9A1950 - *((void *)&xmmword_1EB9A1940 + 1);
        if ((void)xmmword_1EB9A1950 == *((void *)&xmmword_1EB9A1940 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1950 - *((void *)&xmmword_1EB9A1940 + 1));
        break;
      case 7:
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A0E38, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A0E38))
        {
          qword_1EB9A1960 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=0000000553\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "uniform mat4 hg_TextureMatrix2;\n"
                                     "uniform mat4 hg_TextureMatrix3;\n"
                                     "uniform mat4 hg_TextureMatrix4;\n"
                                     "uniform mat4 hg_TextureMatrix5;\n"
                                     "uniform mat4 hg_TextureMatrix6;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "attribute vec4 hg_MultiTexCoord2;\n"
                                     "attribute vec4 hg_MultiTexCoord3;\n"
                                     "attribute vec4 hg_MultiTexCoord4;\n"
                                     "attribute vec4 hg_MultiTexCoord5;\n"
                                     "attribute vec4 hg_MultiTexCoord6;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "varying vec4 hg_TexCoord2;\n"
                                     "varying vec4 hg_TexCoord3;\n"
                                     "varying vec4 hg_TexCoord4;\n"
                                     "varying vec4 hg_TexCoord5;\n"
                                     "varying vec4 hg_TexCoord6;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "    hg_TexCoord2 = hg_TextureMatrix2 * hg_MultiTexCoord2;\n"
                                     "    hg_TexCoord3 = hg_TextureMatrix3 * hg_MultiTexCoord3;\n"
                                     "    hg_TexCoord4 = hg_TextureMatrix4 * hg_MultiTexCoord4;\n"
                                     "    hg_TexCoord5 = hg_TextureMatrix5 * hg_MultiTexCoord5;\n"
                                     "    hg_TexCoord6 = hg_TextureMatrix6 * hg_MultiTexCoord6;\n"
                                     "}\n"
                                     "//MD5=7dfc62a1:3d3ce3a2:d06f47b1:41964040\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0020:0000:0000:0000:0000:0000:0000:0007:00:0:0:0\n";
          qword_1EB9A1968 = 1363;
          xmmword_1EB9A1970 = 0u;
          xmmword_1EB9A1980 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1960, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A0E38);
        }
        uint64_t v15 = qword_1EB9A1968;
        *a3 = qword_1EB9A1960;
        a3[1] = v15;
        uint64_t v16 = xmmword_1EB9A1970;
        if ((void)xmmword_1EB9A1970) {
          ++*(void *)(xmmword_1EB9A1970 + 8);
        }
        a3[3] = 0;
        a3[2] = v16;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A1970 + 1);
        int64_t v7 = xmmword_1EB9A1980 - *((void *)&xmmword_1EB9A1970 + 1);
        if ((void)xmmword_1EB9A1980 == *((void *)&xmmword_1EB9A1970 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A1980 - *((void *)&xmmword_1EB9A1970 + 1));
        break;
      case 8:
        if ((atomic_load_explicit((atomic_uchar *volatile)qword_1EB9A0E40, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(qword_1EB9A0E40))
        {
          qword_1EB9A1990 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=00000005ea\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "uniform mat4 hg_TextureMatrix2;\n"
                                     "uniform mat4 hg_TextureMatrix3;\n"
                                     "uniform mat4 hg_TextureMatrix4;\n"
                                     "uniform mat4 hg_TextureMatrix5;\n"
                                     "uniform mat4 hg_TextureMatrix6;\n"
                                     "uniform mat4 hg_TextureMatrix7;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "attribute vec4 hg_MultiTexCoord2;\n"
                                     "attribute vec4 hg_MultiTexCoord3;\n"
                                     "attribute vec4 hg_MultiTexCoord4;\n"
                                     "attribute vec4 hg_MultiTexCoord5;\n"
                                     "attribute vec4 hg_MultiTexCoord6;\n"
                                     "attribute vec4 hg_MultiTexCoord7;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "varying vec4 hg_TexCoord2;\n"
                                     "varying vec4 hg_TexCoord3;\n"
                                     "varying vec4 hg_TexCoord4;\n"
                                     "varying vec4 hg_TexCoord5;\n"
                                     "varying vec4 hg_TexCoord6;\n"
                                     "varying vec4 hg_TexCoord7;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "    hg_TexCoord2 = hg_TextureMatrix2 * hg_MultiTexCoord2;\n"
                                     "    hg_TexCoord3 = hg_TextureMatrix3 * hg_MultiTexCoord3;\n"
                                     "    hg_TexCoord4 = hg_TextureMatrix4 * hg_MultiTexCoord4;\n"
                                     "    hg_TexCoord5 = hg_TextureMatrix5 * hg_MultiTexCoord5;\n"
                                     "    hg_TexCoord6 = hg_TextureMatrix6 * hg_MultiTexCoord6;\n"
                                     "    hg_TexCoord7 = hg_TextureMatrix7 * hg_MultiTexCoord7;\n"
                                     "}\n"
                                     "//MD5=b215da98:d83418c2:544c293f:9ac9d419\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0024:0000:0000:0000:0000:0000:0000:0008:00:0:0:0\n";
          qword_1EB9A1998 = 1514;
          xmmword_1EB9A19A0 = 0u;
          xmmword_1EB9A19B0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1EB9A1990, &dword_1B73F3000);
          __cxa_guard_release(qword_1EB9A0E40);
        }
        uint64_t v23 = qword_1EB9A1998;
        *a3 = qword_1EB9A1990;
        a3[1] = v23;
        uint64_t v24 = xmmword_1EB9A19A0;
        if ((void)xmmword_1EB9A19A0) {
          ++*(void *)(xmmword_1EB9A19A0 + 8);
        }
        a3[3] = 0;
        a3[2] = v24;
        a3[4] = 0;
        a3[5] = 0;
        uint64_t v6 = (const void *)*((void *)&xmmword_1EB9A19A0 + 1);
        int64_t v7 = xmmword_1EB9A19B0 - *((void *)&xmmword_1EB9A19A0 + 1);
        if ((void)xmmword_1EB9A19B0 == *((void *)&xmmword_1EB9A19A0 + 1)) {
          return;
        }
        if (v7 < 0) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        int64_t v8 = (char *)operator new(xmmword_1EB9A19B0 - *((void *)&xmmword_1EB9A19A0 + 1));
        break;
      default:
        goto LABEL_9;
    }
    a3[3] = v8;
    a3[4] = v8;
    uint64_t v25 = &v8[2 * (v7 >> 1)];
    a3[5] = v25;
    memcpy(v8, v6, v7);
    a3[4] = v25;
  }
  else
  {
LABEL_9:
    *((_OWORD *)a3 + 1) = 0u;
    *((_OWORD *)a3 + 2) = 0u;
    *(_OWORD *)a3 = 0u;
  }
}

void sub_1B772F9E0(_Unwind_Exception *exception_object)
{
  int v3 = v2;
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 32) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

__n128 HGString::Digest::operator=(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

char *arb::begin(string_t *this, string_t *a2, const HGLimits *a3, const HGLimits *a4)
{
  int v7 = *(_DWORD *)a3;
  string_t v8 = this[1];
  if (v8)
  {
    str_alloc(this, (uint64_t)v8);
    (*this)[(void)this[1] - 142] = 35;
    unsigned int v9 = v7 & 0xFE00;
    __n128 result = (char *)*this;
    int v11 = *(_DWORD *)a2;
    int v12 = *(_DWORD *)a3;
    if (*(_DWORD *)a2 == *(_DWORD *)a3) {
      goto LABEL_3;
    }
  }
  else
  {
    str_alloc(this, 168);
    this[1] = (string_t)168;
    unsigned int v9 = v7 & 0xFE00;
    __n128 result = (char *)*this;
    int v11 = *(_DWORD *)a2;
    int v12 = *(_DWORD *)a3;
    if (*(_DWORD *)a2 == *(_DWORD *)a3)
    {
LABEL_3:
      uint64_t v13 = result + 62;
      if (v9 >= 0x600)
      {
LABEL_4:
        qmemcpy(v13, "//                            \n//                                \n##                                     \n", 106);
        return result;
      }
      goto LABEL_74;
    }
  }
  int v14 = v7 >> 4;
  int v15 = v7 & 0xF;
  int v16 = v7 & 0xFFF00;
  if ((v7 & 0xFFF00u) > 0x505FF)
  {
    if ((v7 & 0xFFF00u) > 0x603FF)
    {
      if ((v7 & 0xFFF00u) > 0x605FF)
      {
        if (v16 != 394752)
        {
          if (v16 != 395008)
          {
            if (v16 != 460288) {
              return result;
            }
            __int16 v17 = 29557;
            goto LABEL_47;
          }
          __int16 v18 = 29542;
LABEL_49:
          *((_WORD *)result + 2) = v18;
          int v22 = 1195585327;
          goto LABEL_57;
        }
        __int16 v17 = 29542;
        goto LABEL_47;
      }
      if (v16 != 394240)
      {
        if (v16 != 394496) {
          return result;
        }
        __int16 v20 = 28774;
LABEL_40:
        *((_WORD *)result + 2) = v20;
        int v22 = 1195909409;
LABEL_57:
        *(_DWORD *)__n128 result = v22;
        result += 6;
        goto LABEL_58;
      }
      if ((v12 & 0xC0) != 0)
      {
        __int16 v26 = 28774;
LABEL_56:
        *((_WORD *)result + 2) = v26;
        int v22 = 1447960865;
        goto LABEL_57;
      }
      int v15 = 0;
      int v42 = 1885749842;
LABEL_104:
      *(_DWORD *)(result + 3) = v42;
      *(_DWORD *)__n128 result = 1380000033;
      result += 7;
      int v14 = 1;
      goto LABEL_58;
    }
    if ((v7 & 0xFFF00u) <= 0x601FF)
    {
      if (v16 != 329216)
      {
        if (v16 != 329472) {
          return result;
        }
        __int16 v18 = 29558;
        goto LABEL_49;
      }
      __int16 v17 = 29558;
LABEL_47:
      *((_WORD *)result + 2) = v17;
      int v22 = 1279733551;
      goto LABEL_57;
    }
    if (v16 != 393728)
    {
      if (v16 != 393984) {
        return result;
      }
      int v19 = 1885749842;
      goto LABEL_36;
    }
    signed int v23 = v7 & 0xFFF00000;
    if ((int)(v7 & 0xFFF00000) > 69206015)
    {
      if (v23 <= 72351743)
      {
        if (v23 != 69206016)
        {
          int v24 = 70254592;
          goto LABEL_107;
        }
LABEL_108:
        *(_DWORD *)(result + 3) = 1885750611;
        int v21 = 1397956897;
        goto LABEL_109;
      }
      if (v23 == 72351744) {
        goto LABEL_108;
      }
      int v24 = 73400320;
LABEL_107:
      if (v23 != v24) {
        goto LABEL_58;
      }
      goto LABEL_108;
    }
    if (v23)
    {
      if (v23 != 0x1000000)
      {
        int v24 = 68157440;
        goto LABEL_107;
      }
      __int16 v25 = 30579;
    }
    else
    {
      __int16 v25 = 28774;
    }
LABEL_52:
    *((_WORD *)result + 2) = v25;
    int v22 = 1229136161;
    goto LABEL_57;
  }
  if ((v7 & 0xFFF00u) > 0x501FF)
  {
    if ((v7 & 0xFFF00u) > 0x503FF)
    {
      if (v16 != 328704)
      {
        if (v16 != 328960) {
          return result;
        }
        __int16 v20 = 28790;
        goto LABEL_40;
      }
      unsigned int v41 = v12 >> 4;
      if (v41 <= 1)
      {
        *(_DWORD *)__n128 result = 1347821857;
        result += 4;
        goto LABEL_58;
      }
      if (v41 > 3)
      {
        __int16 v26 = 28790;
        goto LABEL_56;
      }
      int v15 = 0;
      int v42 = 1886798418;
      goto LABEL_104;
    }
    if (v16 != 328192)
    {
      if (v16 != 328448) {
        return result;
      }
      int v19 = 1886798418;
LABEL_36:
      *(_DWORD *)(result + 3) = v19;
      int v21 = 1380000033;
LABEL_109:
      *(_DWORD *)__n128 result = v21;
      result += 7;
      goto LABEL_58;
    }
    __int16 v25 = 28790;
    goto LABEL_52;
  }
  if ((v7 & 0xFFF00u) <= 0x303FF)
  {
    if (v16 != 66048)
    {
      if (v16 != 132608) {
        return result;
      }
      __int16 v17 = 29552;
      goto LABEL_47;
    }
    __int16 v25 = 28784;
    goto LABEL_52;
  }
  if (v16 == 197632)
  {
    __int16 v26 = 28775;
    goto LABEL_56;
  }
  if (v16 != 263168) {
    return result;
  }
  result[4] = 80;
  *(_DWORD *)__n128 result = 1398153505;
  result += 5;
LABEL_58:
  if (v15 | v14)
  {
    *__n128 result = v14 | 0x30;
    result[1] = 46;
    result[2] = v15 | 0x30;
    result += 3;
  }
  string_t v27 = *this;
  string_t v28 = *this + 15;
  __n128 result = (char *)memset(result, 32, v28 - result);
  *((unsigned char *)v27 + 15) = 10;
  *((unsigned char *)v27 + 32) = 10;
  if (v9 < 0x600) {
    uint64_t v29 = "##LEN=0000000000\n";
  }
  else {
    uint64_t v29 = "//LEN=0000000000\n";
  }
  *((_OWORD *)v27 + 1) = *(_OWORD *)v29;
  if (v7 > 394255)
  {
    if (v7 == 394256)
    {
      uint64_t v30 = "OPTION NV_fragment_program; \n";
      goto LABEL_72;
    }
    if (v7 == 394272)
    {
      uint64_t v30 = "OPTION NV_fragment_program2;\n";
      goto LABEL_72;
    }
LABEL_93:
    uint64_t v13 = v28 + 47;
    if (v9 >= 0x600)
    {
      qmemcpy((void *)(v28 + 18), "//                          \n", 29);
      goto LABEL_4;
    }
    qmemcpy((void *)(v28 + 18), "##                          \n", 29);
    goto LABEL_73;
  }
  if (v7 == 328736)
  {
    uint64_t v30 = "OPTION NV_vertex_program2;  \n";
    goto LABEL_72;
  }
  if (v7 != 328752) {
    goto LABEL_93;
  }
  uint64_t v30 = "OPTION NV_vertex_program3;  \n";
LABEL_72:
  *(_OWORD *)(v28 + 18) = *(_OWORD *)v30;
  *(_OWORD *)(v28 + 31) = *(_OWORD *)(v30 + 13);
  uint64_t v13 = v28 + 47;
LABEL_73:
  int v11 = *(_DWORD *)a2;
LABEL_74:
  if (!v11
    || *((unsigned __int8 *)a2 + 42) != *((unsigned __int8 *)a3 + 42)
    || (*((_DWORD *)a3 + 1) ^ *((_DWORD *)a2 + 1)) >> 30)
  {
    if (*((_DWORD *)a3 + 1) >> 30 == 3)
    {
      uint64_t v31 = "OPTION ARB_position_invariant;\n";
    }
    else if ((*(_DWORD *)a3 & 0xF0000) == 0x60000 && *((unsigned __int8 *)a3 + 42) >= 2u)
    {
      uint64_t v31 = "OPTION ARB_draw_buffers;      \n";
    }
    else
    {
      uint64_t v31 = "##                            \n";
    }
    *uint64_t v13 = *(_OWORD *)v31;
    *(_OWORD *)((char *)v13 + 15) = *(_OWORD *)(v31 + 15);
    uint64_t v32 = (char *)v13 + 31;
    unsigned int v33 = *((_DWORD *)a3 + 1) & 0xC0000000;
    if (v33 == 0x80000000)
    {
      *(_DWORD *)(v32 + 31) = 169884532;
      uint64_t v34 = "OPTION ARB_precision_hint_nicest; \n";
    }
    else if (v33 == 0x40000000)
    {
      *(_DWORD *)(v32 + 31) = 171668595;
      uint64_t v34 = "OPTION ARB_precision_hint_fastest;\n";
    }
    else
    {
      *(_DWORD *)(v32 + 31) = 169877536;
      uint64_t v34 = "##                                \n";
    }
    long long v35 = *((_OWORD *)v34 + 1);
    *(_OWORD *)uint64_t v32 = *(_OWORD *)v34;
    *((_OWORD *)v32 + 1) = v35;
  }
  uint64_t v36 = *((unsigned __int8 *)a3 + 43);
  if (v36 <= 7)
  {
    string_t v37 = *this;
    uint64_t v38 = (char *)(*this + 128);
    if (*((unsigned char *)a3 + 43))
    {
      uint64_t v39 = 4 * v36;
      size_t v40 = 4 * v36 + 4;
      memcpy(v38, "TEMP $t0,$t1,$t2,$t3,$t4,$t5,$t6,$t7;  \n", v40);
      v38[v40] = 59;
      __n128 result = (char *)memset(&v38[v40 + 1], 32, 34 - v39);
      *((unsigned char *)v37 + 167) = 10;
    }
    else
    {
      qmemcpy(v38, "##                                     \n", 40);
    }
  }
  return result;
}

void arb::write(string_t *this, string_t *a2, const HGShaderBinding *a3, const HGLimits *a4, unsigned int a5, const HGLimits *__src, int a7, const char *a8, BOOL a9, unsigned int a10, int a11, BOOL a12)
{
  signed int v459 = (int)a4;
  *(_DWORD *)int v466 = 0;
  uint64_t v13 = (char *)__src + 168;
  int v12 = *((unsigned __int8 *)__src + 168);
  if (!*((unsigned char *)__src + 168)) {
    return;
  }
  unint64_t v460 = (char *)a2 + 12;
  int v461 = a2 + 1;
  string_t v463 = a2 + 2;
  int v16 = (unsigned __int8 *)__src + 168;
LABEL_6:
  while (v12 == 36)
  {
    string_t v27 = v13 + 1;
    int v26 = v13[1];
    int v28 = v26 > 99;
    if (v26 > 97) {
      ++v28;
    }
    if (v26 > 102) {
      ++v28;
    }
    if (v26 > 111) {
      ++v28;
    }
    int v29 = *((_DWORD *)a2 + v28 - (v26 > 112) - (v26 > 116));
    if (!v29)
    {
      unsigned int v30 = *((unsigned __int8 *)v13 + 1) - 102;
      if (v30 > 0x10 || ((1 << v30) & 0x10201) == 0)
      {
        v13 += 2;
LABEL_127:
        unsigned int v33 = v16;
        goto LABEL_147;
      }
    }
    uint64_t v31 = (unsigned __int8 *)(v13 + 2);
    int v32 = *((unsigned __int8 *)v13 + 2);
    if ((v32 - 58) >= 0xFFFFFFF6)
    {
      int v48 = 0;
      unsigned int v33 = (unsigned __int8 *)(v13 + 2);
      do
      {
        int v48 = v32 + 10 * v48 - 48;
        int v49 = *++v33;
        int v32 = v49;
      }
      while ((v49 - 58) > 0xFFFFFFF5);
      *(_DWORD *)int v466 = v48;
      if (*v33 != 61)
      {
LABEL_25:
        if (*v27 != 111 || a7 == 0)
        {
          if (!v29)
          {
            uint64_t v13 = (const char *)v33;
            goto LABEL_127;
          }
          size_t v35 = v31 - v16;
          string_t v37 = this[1];
          string_t v36 = this[2];
          unint64_t v38 = (unint64_t)&v37[v35];
          if (v36)
          {
            if (v38 >= *(void *)v36)
            {
              size_t v39 = (v38 + 255) & 0xFFFFFFFFFFFFFF00;
              size_t v40 = (const char *)malloc_type_realloc(*((void **)v36 + 2), v39, 0xCCCD1039uLL);
              unsigned int v41 = (char *)this[2];
              *((void *)v41 + 2) = v40;
              *(void *)unsigned int v41 = v39;
              *this = v40;
            }
          }
          else
          {
            str_alloc(this, v38);
          }
          string_t v138 = *this;
          this[1] += v35;
          memcpy((void *)&v37[(void)v138], v16, v35);
          int v131 = *(_DWORD *)v466;
          string_t v133 = this[1];
          string_t v132 = this[2];
          unint64_t v134 = (unint64_t)(v133 + 20);
          if (!v132) {
            goto LABEL_145;
          }
LABEL_138:
          if (v134 >= *(void *)v132)
          {
            __int16 v135 = (const char *)malloc_type_realloc(*((void **)v132 + 2), (unint64_t)(v133 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            int v136 = (char *)this[2];
            *((void *)v136 + 2) = v135;
            *(void *)int v136 = (unint64_t)(v133 + 275) & 0xFFFFFFFFFFFFFF00;
            *this = v135;
          }
        }
        else
        {
          size_t v58 = v27 - v16;
          string_t v60 = this[1];
          string_t v59 = this[2];
          unint64_t v61 = (unint64_t)&v60[v58];
          if (v59)
          {
            if (v61 >= *(void *)v59)
            {
              size_t v62 = (v61 + 255) & 0xFFFFFFFFFFFFFF00;
              int v63 = (const char *)malloc_type_realloc(*((void **)v59 + 2), v62, 0xCCCD1039uLL);
              int v64 = (char *)this[2];
              *((void *)v64 + 2) = v63;
              *(void *)int v64 = v62;
              *this = v63;
            }
          }
          else
          {
            str_alloc(this, v61);
          }
          string_t v124 = *this;
          this[1] += v58;
          memcpy((void *)&v60[(void)v124], v16, v58);
          unint64_t v126 = (unint64_t)this[1];
          string_t v125 = this[2];
          unint64_t v127 = v126 + 1;
          if (v125)
          {
            if (v127 >= *(void *)v125)
            {
              int v128 = (const char *)malloc_type_realloc(*((void **)v125 + 2), (v126 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              __int16 v129 = (char *)this[2];
              *((void *)v129 + 2) = v128;
              *(void *)__int16 v129 = (v126 & 0xFFFFFFFFFFFFFF00) + 256;
              *this = v128;
            }
          }
          else
          {
            str_alloc(this, v127);
          }
          string_t v130 = *this;
          ++this[1];
          v130[v126] = 116;
          int v131 = *(_DWORD *)v466;
          string_t v133 = this[1];
          string_t v132 = this[2];
          unint64_t v134 = (unint64_t)(v133 + 20);
          if (v132) {
            goto LABEL_138;
          }
LABEL_145:
          str_alloc(this, v134);
        }
        this[1] += itoa((char *)&v133[(void)*this], v131 + v29);
        uint64_t v13 = (const char *)v33;
        goto LABEL_147;
      }
    }
    else
    {
      unsigned int v33 = 0;
      if (MEMORY[0] != 61) {
        goto LABEL_25;
      }
    }
    int v462 = v29;
    int v50 = a8;
    size_t v51 = v31 - v16;
    string_t v53 = this[1];
    string_t v52 = this[2];
    unint64_t v54 = (unint64_t)&v53[v51];
    if (v52)
    {
      if (v54 >= *(void *)v52)
      {
        size_t v55 = (v54 + 255) & 0xFFFFFFFFFFFFFF00;
        int v56 = (const char *)malloc_type_realloc(*((void **)v52 + 2), v55, 0xCCCD1039uLL);
        int v57 = (char *)this[2];
        *((void *)v57 + 2) = v56;
        *(void *)int v57 = v55;
        *this = v56;
      }
    }
    else
    {
      str_alloc(this, v54);
    }
    string_t v70 = *this;
    this[1] += v51;
    memcpy((void *)&v53[(void)v70], v16, v51);
    int v71 = *v27;
    if (v71 == 102)
    {
      int v72 = *(_DWORD *)v466;
      a8 = v50;
      if (v50)
      {
        unsigned int v73 = v50 >> v466[0];
        unsigned int v74 = *(_DWORD *)v466;
        int v75 = v462;
        if ((v73 & 1) == 0) {
          goto LABEL_78;
        }
        goto LABEL_65;
      }
      int v75 = v462;
      if (v459 == -1)
      {
        if (a5 == -1) {
          goto LABEL_78;
        }
        unsigned int v74 = *(_DWORD *)v466 - a5;
        if (*(_DWORD *)v466 < a5) {
          goto LABEL_78;
        }
LABEL_65:
        if (v74 == -1) {
          goto LABEL_78;
        }
      }
      else if (a5 == -1)
      {
        if (*(_DWORD *)v466) {
          goto LABEL_78;
        }
      }
      else if (*(_DWORD *)v466 != a5)
      {
        goto LABEL_78;
      }
      this[1] -= 9;
      do
      {
        int v76 = *(unsigned __int8 *)v13++;
        unsigned int v33 = (unsigned __int8 *)v13;
      }
      while (v76 != 10);
      goto LABEL_147;
    }
    if (v71 != 111 || (a7 & 1) == 0)
    {
      int v72 = *(_DWORD *)v466;
      a8 = v50;
      int v75 = v462;
LABEL_78:
      string_t v86 = this[1];
      string_t v85 = this[2];
      unint64_t v87 = (unint64_t)(v86 + 20);
      if (v85)
      {
        if (v87 >= *(void *)v85)
        {
          int v88 = (const char *)malloc_type_realloc(*((void **)v85 + 2), (unint64_t)(v86 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          int v89 = (char *)this[2];
          *((void *)v89 + 2) = v88;
          *(void *)int v89 = (unint64_t)(v86 + 275) & 0xFFFFFFFFFFFFFF00;
          *this = v88;
        }
      }
      else
      {
        str_alloc(this, v87);
      }
      this[1] += itoa((char *)&v86[(void)*this], v72 + v75);
      uint64_t v13 = (const char *)(v33 + 1);
      int v12 = v33[1];
      while (2)
      {
        while (2)
        {
          if (v12 == 59) {
            goto LABEL_148;
          }
          if ((v12 - 48) < 0xA || (ctype[2 * v12] & 0x40) == 0)
          {
            ++v13;
LABEL_96:
            int v12 = *(unsigned __int8 *)v13;
            continue;
          }
          break;
        }
        if (!strncmp(v13, "program.local", 0xDuLL))
        {
          int v91 = (arb *)(v13 + 13);
          int v95 = *(_DWORD *)v463;
          size_t v96 = v13 + 13 - (const char *)v33;
          string_t v98 = this[1];
          string_t v97 = this[2];
          unint64_t v99 = (unint64_t)&v98[v96];
          if (v97) {
            goto LABEL_103;
          }
        }
        else if (!strncmp(v13, "fragment.texcoord", 0x11uLL))
        {
          int v91 = (arb *)(v13 + 17);
          int v95 = *(_DWORD *)v461;
          size_t v96 = v13 + 17 - (const char *)v33;
          string_t v98 = this[1];
          string_t v97 = this[2];
          unint64_t v99 = (unint64_t)&v98[v96];
          if (v97) {
            goto LABEL_103;
          }
        }
        else
        {
          if (!strncmp(v13, "result.color", 0xCuLL))
          {
            int v91 = (arb *)(v13 + 12);
            int v93 = (int *)v460;
            goto LABEL_102;
          }
          int v91 = (arb *)(v13 + 15);
          if (!strncmp(v13, "vertex.texcoord", 0xFuLL))
          {
            int v95 = *(_DWORD *)v461;
            size_t v96 = v91 - (arb *)v33;
            string_t v98 = this[1];
            string_t v97 = this[2];
            unint64_t v99 = (unint64_t)&v98[v91 - (arb *)v33];
            if (v97) {
              goto LABEL_103;
            }
          }
          else
          {
            int v92 = strncmp(v13, "result.texcoord", 0xFuLL);
            int v93 = (int *)v460;
            if (v92)
            {
              do
                int v94 = *(unsigned __int8 *)++v13;
              while ((ctype[2 * v94] & 0x40) != 0);
              goto LABEL_96;
            }
LABEL_102:
            int v95 = *v93;
            size_t v96 = v91 - (arb *)v33;
            string_t v98 = this[1];
            string_t v97 = this[2];
            unint64_t v99 = (unint64_t)&v98[v91 - (arb *)v33];
            if (v97)
            {
LABEL_103:
              if (v99 >= *(void *)v97)
              {
                size_t v100 = (v99 + 255) & 0xFFFFFFFFFFFFFF00;
                int v101 = (const char *)malloc_type_realloc(*((void **)v97 + 2), v100, 0xCCCD1039uLL);
                int v102 = (char *)this[2];
                *((void *)v102 + 2) = v101;
                *(void *)int v102 = v100;
                *this = v101;
              }
              goto LABEL_107;
            }
          }
        }
        str_alloc(this, v99);
LABEL_107:
        string_t v103 = *this;
        this[1] += v96;
        memcpy((void *)&v98[(void)v103], v33, v96);
        *(_DWORD *)int v466 = 0;
        int v105 = arb::aidx(v91, v466, 0, v104);
        if (v105) {
          unsigned int v33 = v105;
        }
        else {
          unsigned int v33 = (unsigned __int8 *)v91;
        }
        *(_DWORD *)v466 += v95;
        if (!*(_DWORD *)v466 && *v13 == 114 && v13[7] == 99)
        {
          uint64_t v13 = (const char *)v33;
          int v12 = *v33;
        }
        else
        {
          unint64_t v107 = (unint64_t)this[1];
          string_t v106 = this[2];
          unint64_t v108 = v107 + 1;
          if (v106)
          {
            if (v108 >= *(void *)v106)
            {
              __int16 v109 = (const char *)malloc_type_realloc(*((void **)v106 + 2), (v107 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              __int16 v110 = (char *)this[2];
              *((void *)v110 + 2) = v109;
              *(void *)__int16 v110 = (v107 & 0xFFFFFFFFFFFFFF00) + 256;
              *this = v109;
            }
          }
          else
          {
            str_alloc(this, v108);
          }
          string_t v111 = *this;
          ++this[1];
          v111[v107] = 91;
          signed int v112 = *(_DWORD *)v466;
          string_t v114 = this[1];
          string_t v113 = this[2];
          unint64_t v115 = (unint64_t)(v114 + 20);
          if (v113)
          {
            if (v115 >= *(void *)v113)
            {
              int v116 = (const char *)malloc_type_realloc(*((void **)v113 + 2), (unint64_t)(v114 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              __int16 v117 = (char *)this[2];
              *((void *)v117 + 2) = v116;
              *(void *)__int16 v117 = (unint64_t)(v114 + 275) & 0xFFFFFFFFFFFFFF00;
              *this = v116;
            }
          }
          else
          {
            str_alloc(this, v115);
          }
          uint64_t v118 = itoa((char *)&v114[(void)*this], v112);
          string_t v119 = this[2];
          __int16 v120 = &this[1][v118];
          this[1] = v120;
          unint64_t v121 = (unint64_t)(v120 + 1);
          if (v119)
          {
            if (v121 >= *(void *)v119)
            {
              int v122 = (const char *)malloc_type_realloc(*((void **)v119 + 2), ((unint64_t)v120 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              __int16 v123 = (char *)this[2];
              *((void *)v123 + 2) = v122;
              *(void *)__int16 v123 = ((unint64_t)v120 & 0xFFFFFFFFFFFFFF00) + 256;
              *this = v122;
            }
          }
          else
          {
            str_alloc(this, v121);
          }
          string_t v90 = *this;
          ++this[1];
          v120[(void)v90] = 93;
          uint64_t v13 = (const char *)v33;
          int v12 = *v33;
        }
        continue;
      }
    }
    this[1] -= 9;
    a8 = v50;
    do
    {
      int v77 = *(unsigned __int8 *)v13++;
      unsigned int v33 = (unsigned __int8 *)v13;
    }
    while (v77 != 10);
LABEL_147:
    int v12 = *(unsigned __int8 *)v13;
LABEL_148:
    int v16 = v33;
    if (!v12) {
      return;
    }
  }
  if (v12 == 35)
  {
    int v19 = (unsigned __int8 *)(v13 + 2);
    int v18 = *((unsigned __int8 *)v13 + 2);
    if ((v18 - 58) < 0xFFFFFFF6)
    {
      if (v18 != 37)
      {
        if (v18 == 42)
        {
          string_t v21 = this[1];
          string_t v20 = this[2];
          unint64_t v22 = (unint64_t)&v21[v13 - (const char *)v16];
          if (v20)
          {
            if (v22 >= *(void *)v20)
            {
              size_t v23 = (v22 + 255) & 0xFFFFFFFFFFFFFF00;
              int v24 = (const char *)malloc_type_realloc(*((void **)v20 + 2), v23, 0xCCCD1039uLL);
              __int16 v25 = (char *)this[2];
              *((void *)v25 + 2) = v24;
              *(void *)__int16 v25 = v23;
              *this = v24;
            }
          }
          else
          {
            str_alloc(this, v22);
          }
          string_t v139 = *this;
          this[1] += v13 - (const char *)v16;
          memcpy((void *)&v21[(void)v139], v16, v13 - (const char *)v16);
          __int16 v17 = v13 + 4;
          v13 += 4;
          goto LABEL_5;
        }
        __int16 v17 = v13 + 4;
LABEL_4:
        uint64_t v13 = (const char *)v16;
        goto LABEL_5;
      }
      __int16 v17 = v13 + 4;
      int64_t v78 = v13 + 4 - (const char *)v16;
      string_t v80 = this[1];
      string_t v79 = this[2];
      unint64_t v81 = (unint64_t)&v80[v78];
      if (v79)
      {
        if (v81 >= *(void *)v79)
        {
          size_t v82 = (v81 + 255) & 0xFFFFFFFFFFFFFF00;
          int v83 = (const char *)malloc_type_realloc(*((void **)v79 + 2), v82, 0xCCCD1039uLL);
          int v84 = (char *)this[2];
          *((void *)v84 + 2) = v83;
          *(void *)int v84 = v82;
          *this = v83;
        }
      }
      else
      {
        str_alloc(this, v81);
      }
      string_t v140 = *this;
      this[1] += v78;
      memcpy((void *)&v80[(void)v140], v16, v13 + 4 - (const char *)v16);
      if (!strncmp(v13 + 4, "TEMP r", 6uLL))
      {
        int v141 = v13 + 10;
        unsigned int v142 = *((unsigned __int16 *)a3 + 12);
        unsigned int v143 = *(_DWORD *)v466;
        while (1)
        {
          int v144 = *(unsigned __int8 *)v141;
          if ((v144 - 58) >= 0xFFFFFFF6)
          {
            unsigned int v143 = 0;
            char v145 = v141;
            do
            {
              unsigned int v143 = v144 + 10 * v143 - 48;
              int v146 = *(unsigned __int8 *)++v145;
              int v144 = v146;
            }
            while ((v146 - 58) > 0xFFFFFFF5);
            *(_DWORD *)int v466 = v143;
            int v147 = *(unsigned __int8 *)v145;
            if (*v145)
            {
              if ((v147 - 33) >= 0xFFFFFFE0)
              {
                do
                {
LABEL_161:
                  int v148 = *(unsigned __int8 *)++v145;
                  int v147 = v148;
                }
                while ((v148 - 33) > 0xFFFFFFDF);
              }
LABEL_162:
              if (v147 == 35)
              {
                ++v145;
                while (1)
                {
                  int v147 = *(unsigned __int8 *)v145;
                  if (!*v145) {
                    break;
                  }
                  int v149 = *((unsigned __int8 *)v145++ - 1);
                  if (v149 == 10)
                  {
                    --v145;
                    if ((v147 - 33) >= 0xFFFFFFE0) {
                      goto LABEL_161;
                    }
                    goto LABEL_162;
                  }
                }
              }
            }
          }
          else
          {
            char v145 = 0;
          }
          if (v143 >= v142) {
            break;
          }
          int v150 = *(unsigned __int8 *)v145;
          __int16 v17 = v145 + 2;
          int v141 = v17;
          if (v150 == 59) {
            goto LABEL_170;
          }
        }
        string_t v246 = this[1];
        string_t v245 = this[2];
        unint64_t v247 = (unint64_t)(v246 + 6);
        if (v245)
        {
          if (v247 >= *(void *)v245)
          {
            unint64_t v248 = (const char *)malloc_type_realloc(*((void **)v245 + 2), (unint64_t)(v246 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            unint64_t v249 = (char *)this[2];
            *((void *)v249 + 2) = v248;
            *(void *)unint64_t v249 = (unint64_t)(v246 + 261) & 0xFFFFFFFFFFFFFF00;
            *this = v248;
          }
        }
        else
        {
          str_alloc(this, v247);
        }
        uint64_t v346 = 0;
        string_t v347 = *this;
        this[1] += 6;
        unint64_t v348 = (char *)&v246[(void)v347];
        *((_WORD *)v348 + 2) = 29216;
        *(_DWORD *)unint64_t v348 = 1347241300;
        do
          int v349 = v145[v346++ - 2];
        while (v349 != 59);
        int64_t v350 = v145 - v141;
        size_t v351 = v145 - v141 + v346 - 1;
        string_t v353 = this[1];
        string_t v352 = this[2];
        unint64_t v354 = (unint64_t)&v353[v351];
        if (v352)
        {
          if (v354 >= *(void *)v352)
          {
            string_t v355 = (const char *)malloc_type_realloc(*((void **)v352 + 2), (unint64_t)&v353[v350 + 254 + v346] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            unint64_t v356 = (char *)this[2];
            *((void *)v356 + 2) = v355;
            *(void *)unint64_t v356 = (unint64_t)&v353[v350 + 254 + v346] & 0xFFFFFFFFFFFFFF00;
            *this = v355;
          }
        }
        else
        {
          str_alloc(this, v354);
        }
        __int16 v17 = &v145[v346 - 1];
        string_t v368 = *this;
        this[1] = &this[1][v350 - 1 + v346];
        memcpy((void *)&v353[(void)v368], v141, v351);
        if (strncmp(v17, "LONG TEMP l", 0xBuLL))
        {
LABEL_393:
          if (!strncmp(v17, "SHORT TEMP h", 0xCuLL)) {
            goto LABEL_394;
          }
LABEL_416:
          if (!strncmp(v17, "INT TEMP i", 0xAuLL)) {
            goto LABEL_417;
          }
LABEL_451:
          if (strncmp(v17, "UINT TEMP u", 0xBuLL)) {
            goto LABEL_452;
          }
          goto LABEL_455;
        }
      }
      else
      {
LABEL_170:
        if (strncmp(v17, "LONG TEMP l", 0xBuLL)) {
          goto LABEL_393;
        }
      }
      int v151 = v17 + 11;
      unsigned int v152 = *((unsigned __int8 *)a3 + 27);
      unsigned int v153 = *(_DWORD *)v466;
      while (1)
      {
        int v154 = *(unsigned __int8 *)v151;
        if ((v154 - 58) >= 0xFFFFFFF6)
        {
          unsigned int v153 = 0;
          char v155 = v151;
          do
          {
            unsigned int v153 = v154 + 10 * v153 - 48;
            int v156 = *(unsigned __int8 *)++v155;
            int v154 = v156;
          }
          while ((v156 - 58) > 0xFFFFFFF5);
          *(_DWORD *)int v466 = v153;
          int v157 = *(unsigned __int8 *)v155;
          if (*v155)
          {
            if ((v157 - 33) >= 0xFFFFFFE0)
            {
              do
              {
LABEL_178:
                int v158 = *(unsigned __int8 *)++v155;
                int v157 = v158;
              }
              while ((v158 - 33) > 0xFFFFFFDF);
            }
LABEL_179:
            if (v157 == 35)
            {
              ++v155;
              while (1)
              {
                int v157 = *(unsigned __int8 *)v155;
                if (!*v155) {
                  break;
                }
                int v159 = *((unsigned __int8 *)v155++ - 1);
                if (v159 == 10)
                {
                  --v155;
                  if ((v157 - 33) >= 0xFFFFFFE0) {
                    goto LABEL_178;
                  }
                  goto LABEL_179;
                }
              }
            }
          }
        }
        else
        {
          char v155 = 0;
        }
        if (v153 >= v152) {
          break;
        }
        int v160 = *(unsigned __int8 *)v155;
        __int16 v17 = v155 + 2;
        int v151 = v17;
        if (v160 == 59) {
          goto LABEL_393;
        }
      }
      string_t v251 = this[1];
      string_t v250 = this[2];
      unint64_t v252 = (unint64_t)(v251 + 11);
      if (v250)
      {
        if (v252 >= *(void *)v250)
        {
          unsigned int v253 = (const char *)malloc_type_realloc(*((void **)v250 + 2), (unint64_t)(v251 + 266) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          string_t v254 = (char *)this[2];
          *((void *)v254 + 2) = v253;
          *(void *)string_t v254 = (unint64_t)(v251 + 266) & 0xFFFFFFFFFFFFFF00;
          *this = v253;
        }
      }
      else
      {
        str_alloc(this, v252);
      }
      uint64_t v357 = 0;
      string_t v358 = *this;
      this[1] += 11;
      int32x2_t v359 = (char *)&v251[(void)v358];
      *(void *)int32x2_t v359 = *(void *)"LONG TEMP l";
      *(_DWORD *)(v359 + 7) = 1814057037;
      do
        int v360 = v155[v357++ - 2];
      while (v360 != 59);
      int64_t v361 = v155 - v151;
      size_t v362 = v155 - v151 + v357 - 1;
      string_t v364 = this[1];
      string_t v363 = this[2];
      unint64_t v365 = (unint64_t)&v364[v362];
      if (v363)
      {
        if (v365 >= *(void *)v363)
        {
          v366 = (const char *)malloc_type_realloc(*((void **)v363 + 2), (unint64_t)&v364[v361 + 254 + v357] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v367 = (char *)this[2];
          *((void *)v367 + 2) = v366;
          *(void *)v367 = (unint64_t)&v364[v361 + 254 + v357] & 0xFFFFFFFFFFFFFF00;
          *this = v366;
        }
      }
      else
      {
        str_alloc(this, v365);
      }
      __int16 v17 = &v155[v357 - 1];
      string_t v384 = *this;
      this[1] = &this[1][v361 - 1 + v357];
      memcpy((void *)&v364[(void)v384], v151, v362);
      if (strncmp(v17, "SHORT TEMP h", 0xCuLL)) {
        goto LABEL_416;
      }
LABEL_394:
      int32x2_t v369 = v17 + 12;
      unsigned int v370 = *((unsigned __int8 *)a3 + 26);
      unsigned int v371 = *(_DWORD *)v466;
      while (1)
      {
        int v372 = *(unsigned __int8 *)v369;
        if ((v372 - 58) >= 0xFFFFFFF6)
        {
          unsigned int v371 = 0;
          string_t v373 = v369;
          do
          {
            unsigned int v371 = v372 + 10 * v371 - 48;
            int v374 = *(unsigned __int8 *)++v373;
            int v372 = v374;
          }
          while ((v374 - 58) > 0xFFFFFFF5);
          *(_DWORD *)int v466 = v371;
          int v375 = *(unsigned __int8 *)v373;
          if (*v373)
          {
            if ((v375 - 33) >= 0xFFFFFFE0)
            {
              do
              {
LABEL_401:
                int v376 = *(unsigned __int8 *)++v373;
                int v375 = v376;
              }
              while ((v376 - 33) > 0xFFFFFFDF);
            }
LABEL_402:
            if (v375 == 35)
            {
              ++v373;
              while (1)
              {
                int v375 = *(unsigned __int8 *)v373;
                if (!*v373) {
                  break;
                }
                int v377 = *((unsigned __int8 *)v373++ - 1);
                if (v377 == 10)
                {
                  --v373;
                  if ((v375 - 33) >= 0xFFFFFFE0) {
                    goto LABEL_401;
                  }
                  goto LABEL_402;
                }
              }
            }
          }
        }
        else
        {
          string_t v373 = 0;
        }
        if (v371 >= v370) {
          break;
        }
        int v378 = *(unsigned __int8 *)v373;
        __int16 v17 = v373 + 2;
        int32x2_t v369 = v17;
        if (v378 == 59) {
          goto LABEL_416;
        }
      }
      string_t v380 = this[1];
      string_t v379 = this[2];
      unint64_t v381 = (unint64_t)(v380 + 12);
      if (v379)
      {
        if (v381 >= *(void *)v379)
        {
          unint64_t v382 = (const char *)malloc_type_realloc(*((void **)v379 + 2), (unint64_t)(v380 + 267) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          unint64_t v383 = (char *)this[2];
          *((void *)v383 + 2) = v382;
          *(void *)unint64_t v383 = (unint64_t)(v380 + 267) & 0xFFFFFFFFFFFFFF00;
          *this = v382;
        }
      }
      else
      {
        str_alloc(this, v381);
      }
      uint64_t v400 = 0;
      string_t v401 = *this;
      this[1] += 12;
      unint64_t v402 = (char *)&v380[(void)v401];
      *(void *)unint64_t v402 = *(void *)"SHORT TEMP h";
      *((_DWORD *)v402 + 2) = 1746948173;
      do
        int v403 = v373[v400++ - 2];
      while (v403 != 59);
      int64_t v404 = v373 - v369;
      size_t v405 = v373 - v369 + v400 - 1;
      string_t v407 = this[1];
      string_t v406 = this[2];
      unint64_t v408 = (unint64_t)&v407[v405];
      if (v406)
      {
        if (v408 >= *(void *)v406)
        {
          unint64_t v409 = (const char *)malloc_type_realloc(*((void **)v406 + 2), (unint64_t)&v407[v404 + 254 + v400] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          unint64_t v410 = (char *)this[2];
          *((void *)v410 + 2) = v409;
          *(void *)unint64_t v410 = (unint64_t)&v407[v404 + 254 + v400] & 0xFFFFFFFFFFFFFF00;
          *this = v409;
        }
      }
      else
      {
        str_alloc(this, v408);
      }
      __int16 v17 = &v373[v400 - 1];
      string_t v422 = *this;
      this[1] = &this[1][v404 - 1 + v400];
      memcpy((void *)&v407[(void)v422], v369, v405);
      if (strncmp(v17, "INT TEMP i", 0xAuLL)) {
        goto LABEL_451;
      }
LABEL_417:
      int v385 = v17 + 10;
      unsigned int v386 = *((unsigned __int8 *)a3 + 28);
      unsigned int v387 = *(_DWORD *)v466;
      while (1)
      {
        int v388 = *(unsigned __int8 *)v385;
        if ((v388 - 58) >= 0xFFFFFFF6)
        {
          unsigned int v387 = 0;
          double v389 = v385;
          do
          {
            unsigned int v387 = v388 + 10 * v387 - 48;
            int v390 = *(unsigned __int8 *)++v389;
            int v388 = v390;
          }
          while ((v390 - 58) > 0xFFFFFFF5);
          *(_DWORD *)int v466 = v387;
          int v391 = *(unsigned __int8 *)v389;
          if (*v389)
          {
            if ((v391 - 33) >= 0xFFFFFFE0)
            {
              do
              {
LABEL_424:
                int v392 = *(unsigned __int8 *)++v389;
                int v391 = v392;
              }
              while ((v392 - 33) > 0xFFFFFFDF);
            }
LABEL_425:
            if (v391 == 35)
            {
              ++v389;
              while (1)
              {
                int v391 = *(unsigned __int8 *)v389;
                if (!*v389) {
                  break;
                }
                int v393 = *((unsigned __int8 *)v389++ - 1);
                if (v393 == 10)
                {
                  --v389;
                  if ((v391 - 33) >= 0xFFFFFFE0) {
                    goto LABEL_424;
                  }
                  goto LABEL_425;
                }
              }
            }
          }
        }
        else
        {
          double v389 = 0;
        }
        if (v387 >= v386) {
          break;
        }
        int v394 = *(unsigned __int8 *)v389;
        __int16 v17 = v389 + 2;
        int v385 = v17;
        if (v394 == 59) {
          goto LABEL_451;
        }
      }
      string_t v396 = this[1];
      string_t v395 = this[2];
      unint64_t v397 = (unint64_t)(v396 + 10);
      if (v395)
      {
        if (v397 >= *(void *)v395)
        {
          unsigned int v398 = (const char *)malloc_type_realloc(*((void **)v395 + 2), (unint64_t)(v396 + 265) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          string_t v399 = (char *)this[2];
          *((void *)v399 + 2) = v398;
          *(void *)string_t v399 = (unint64_t)(v396 + 265) & 0xFFFFFFFFFFFFFF00;
          *this = v398;
        }
      }
      else
      {
        str_alloc(this, v397);
      }
      uint64_t v411 = 0;
      string_t v412 = *this;
      this[1] += 10;
      string_t v413 = (char *)&v396[(void)v412];
      *(void *)string_t v413 = *(void *)"INT TEMP i";
      *((_WORD *)v413 + 4) = 26912;
      do
        int v414 = v389[v411++ - 2];
      while (v414 != 59);
      int64_t v415 = v389 - v385;
      size_t v416 = v389 - v385 + v411 - 1;
      string_t v418 = this[1];
      string_t v417 = this[2];
      unint64_t v419 = (unint64_t)&v418[v416];
      if (v417)
      {
        if (v419 >= *(void *)v417)
        {
          char v420 = (const char *)malloc_type_realloc(*((void **)v417 + 2), (unint64_t)&v418[v415 + 254 + v411] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          string_t v421 = (char *)this[2];
          *((void *)v421 + 2) = v420;
          *(void *)string_t v421 = (unint64_t)&v418[v415 + 254 + v411] & 0xFFFFFFFFFFFFFF00;
          *this = v420;
        }
      }
      else
      {
        str_alloc(this, v419);
      }
      __int16 v17 = &v389[v411 - 1];
      string_t v423 = *this;
      this[1] = &this[1][v415 - 1 + v411];
      memcpy((void *)&v418[(void)v423], v385, v416);
      if (strncmp(v17, "UINT TEMP u", 0xBuLL))
      {
LABEL_452:
        uint64_t v13 = v17;
        goto LABEL_5;
      }
LABEL_455:
      uint64_t v13 = v17 + 11;
      unsigned int v424 = *((unsigned __int8 *)a3 + 29);
      unsigned int v425 = *(_DWORD *)v466;
      while (1)
      {
        int v426 = *(unsigned __int8 *)v13;
        if ((v426 - 58) >= 0xFFFFFFF6)
        {
          unsigned int v425 = 0;
          string_t v427 = v13;
          do
          {
            unsigned int v425 = v426 + 10 * v425 - 48;
            int v428 = *(unsigned __int8 *)++v427;
            int v426 = v428;
          }
          while ((v428 - 58) > 0xFFFFFFF5);
          *(_DWORD *)int v466 = v425;
          int v429 = *(unsigned __int8 *)v427;
          if (*v427)
          {
            if ((v429 - 33) >= 0xFFFFFFE0)
            {
              do
              {
LABEL_462:
                int v430 = *(unsigned __int8 *)++v427;
                int v429 = v430;
              }
              while ((v430 - 33) > 0xFFFFFFDF);
            }
LABEL_463:
            if (v429 == 35)
            {
              ++v427;
              while (1)
              {
                int v429 = *(unsigned __int8 *)v427;
                if (!*v427) {
                  break;
                }
                int v431 = *((unsigned __int8 *)v427++ - 1);
                if (v431 == 10)
                {
                  --v427;
                  if ((v429 - 33) >= 0xFFFFFFE0) {
                    goto LABEL_462;
                  }
                  goto LABEL_463;
                }
              }
            }
          }
        }
        else
        {
          string_t v427 = 0;
        }
        if (v425 >= v424) {
          break;
        }
        int v432 = *(unsigned __int8 *)v427;
        __int16 v17 = v427 + 2;
        uint64_t v13 = v17;
        if (v432 == 59) {
          goto LABEL_5;
        }
      }
      string_t v434 = this[1];
      string_t v433 = this[2];
      unint64_t v435 = (unint64_t)(v434 + 11);
      if (v433)
      {
        if (v435 >= *(void *)v433)
        {
          string_t v436 = (const char *)malloc_type_realloc(*((void **)v433 + 2), (unint64_t)(v434 + 266) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          unint64_t v437 = (char *)this[2];
          *((void *)v437 + 2) = v436;
          *(void *)unint64_t v437 = (unint64_t)(v434 + 266) & 0xFFFFFFFFFFFFFF00;
          *this = v436;
        }
      }
      else
      {
        str_alloc(this, v435);
      }
      uint64_t v438 = 0;
      string_t v439 = *this;
      this[1] += 11;
      v440 = (char *)&v434[(void)v439];
      *(void *)v440 = *(void *)"UINT TEMP u";
      *(_DWORD *)(v440 + 7) = 1965051981;
      do
        int v441 = v427[v438++ - 2];
      while (v441 != 59);
      int64_t v442 = v427 - v13;
      size_t v443 = v427 - v13 + v438 - 1;
      string_t v445 = this[1];
      string_t v444 = this[2];
      unint64_t v446 = (unint64_t)&v445[v443];
      if (v444)
      {
        if (v446 >= *(void *)v444)
        {
          v447 = (const char *)malloc_type_realloc(*((void **)v444 + 2), (unint64_t)&v445[v442 + 254 + v438] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          char v448 = (char *)this[2];
          *((void *)v448 + 2) = v447;
          *(void *)char v448 = (unint64_t)&v445[v442 + 254 + v438] & 0xFFFFFFFFFFFFFF00;
          *this = v447;
        }
      }
      else
      {
        str_alloc(this, v446);
      }
      __int16 v17 = &v427[v438 - 1];
      string_t v449 = *this;
      this[1] = &this[1][v442 - 1 + v438];
      memcpy((void *)&v445[(void)v449], v13, v443);
      goto LABEL_5;
    }
    string_t v43 = this[1];
    string_t v42 = this[2];
    unint64_t v44 = (unint64_t)&v43[v13 - (const char *)v16];
    if (v42)
    {
      if (v44 >= *(void *)v42)
      {
        size_t v45 = (v44 + 255) & 0xFFFFFFFFFFFFFF00;
        int v46 = (const char *)malloc_type_realloc(*((void **)v42 + 2), v45, 0xCCCD1039uLL);
        int v47 = (char *)this[2];
        *((void *)v47 + 2) = v46;
        *(void *)int v47 = v45;
        *this = v46;
      }
    }
    else
    {
      str_alloc(this, v44);
    }
    string_t v65 = *this;
    this[1] += v13 - (const char *)v16;
    memcpy((void *)&v43[(void)v65], v16, v13 - (const char *)v16);
    int v66 = *v19;
    if ((v66 - 58) >= 0xFFFFFFF6)
    {
      unsigned int v67 = 0;
      do
      {
        unsigned int v67 = v66 + 10 * v67 - 48;
        int v69 = *++v19;
        int v66 = v69;
      }
      while ((v69 - 58) > 0xFFFFFFF5);
      *(_DWORD *)int v466 = v67;
      if (!a8) {
        goto LABEL_57;
      }
LABEL_51:
      if (((a8 >> v67) & 1) == 0) {
        goto LABEL_189;
      }
    }
    else
    {
      int v19 = 0;
      unsigned int v67 = *(_DWORD *)v466;
      if (a8) {
        goto LABEL_51;
      }
LABEL_57:
      if (v459 != -1)
      {
        if (a5 == -1)
        {
          signed int v68 = v459;
          if (!v67)
          {
LABEL_193:
            string_t v167 = this[1];
            string_t v166 = this[2];
            unint64_t v168 = (unint64_t)(v167 + 3);
            if (v166)
            {
              if (v168 >= *(void *)v166)
              {
                __int16 v169 = (const char *)malloc_type_realloc(*((void **)v166 + 2), (unint64_t)(v167 + 258) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                int v170 = (char *)this[2];
                *((void *)v170 + 2) = v169;
                *(void *)int v170 = (unint64_t)(v167 + 258) & 0xFFFFFFFFFFFFFF00;
                *this = v169;
              }
            }
            else
            {
              str_alloc(this, v168);
            }
            string_t v171 = *this;
            this[1] += 3;
            __int16 v172 = (char *)&v167[(void)v171];
            v172[2] = 86;
            *(_WORD *)__int16 v172 = 20301;
            int v173 = v19 + 4;
            uint64_t v174 = 256;
            int v175 = *v173;
            if (v175 == 44)
            {
LABEL_248:
              string_t v218 = this[1];
              string_t v217 = this[2];
              unint64_t v219 = (unint64_t)&v218[v174 - 255];
              if (v217)
              {
                if (v219 >= *(void *)v217)
                {
                  unint64_t v220 = (const char *)malloc_type_realloc(*((void **)v217 + 2), (unint64_t)&v218[v174] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  unint64_t v221 = (char *)this[2];
                  *((void *)v221 + 2) = v220;
                  *(void *)unint64_t v221 = (unint64_t)&v218[v174] & 0xFFFFFFFFFFFFFF00;
                  *this = v220;
                }
              }
              else
              {
                str_alloc(this, v219);
              }
              string_t v222 = *this;
              this[1] = &this[1][v174 - 255];
              memcpy((void *)&v218[(void)v222], v173, v174 - 255);
              string_t v224 = this[1];
              string_t v223 = this[2];
              unint64_t v225 = (unint64_t)(v224 + 2);
              if (v223)
              {
                if (v225 >= *(void *)v223)
                {
                  int8x8_t v226 = (const char *)malloc_type_realloc(*((void **)v223 + 2), (unint64_t)(v224 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  char v227 = (char *)this[2];
                  *((void *)v227 + 2) = v226;
                  *(void *)char v227 = (unint64_t)(v224 + 257) & 0xFFFFFFFFFFFFFF00;
                  *this = v226;
                }
              }
              else
              {
                str_alloc(this, v225);
              }
              string_t v228 = *this;
              this[1] += 2;
              *(_WORD *)&v224[(void)v228] = 29732;
              string_t v230 = this[1];
              string_t v229 = this[2];
              unint64_t v231 = (unint64_t)(v230 + 20);
              if (v229)
              {
                if (v231 >= *(void *)v229)
                {
                  int v232 = (const char *)malloc_type_realloc(*((void **)v229 + 2), (unint64_t)(v230 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  int32x2_t v233 = (char *)this[2];
                  *((void *)v233 + 2) = v232;
                  *(void *)int32x2_t v233 = (unint64_t)(v230 + 275) & 0xFFFFFFFFFFFFFF00;
                  *this = v232;
                }
              }
              else
              {
                str_alloc(this, v231);
              }
              this[1] += itoa((char *)&v230[(void)*this], v68);
              __int16 v17 = (const char *)(v173 - 1);
              do
              {
                int v234 = *(unsigned __int8 *)++v17;
                uint64_t v13 = v17;
              }
              while (v234 != 59);
              goto LABEL_5;
            }
            while (2)
            {
              while (v175 != 36)
              {
                int v175 = v173[++v174 - 256];
                if (v175 == 44) {
                  goto LABEL_248;
                }
              }
              uint64_t v176 = v174 - 254;
              string_t v178 = this[1];
              string_t v177 = this[2];
              if (v177)
              {
                if ((unint64_t)&v178[v176] < *(void *)v177)
                {
                  __int16 v179 = *this;
                  goto LABEL_212;
                }
                __int16 v179 = (const char *)malloc_type_realloc(*((void **)v177 + 2), (unint64_t)&v178[v174 + 1] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                __int16 v185 = (char *)this[2];
                *((void *)v185 + 2) = v179;
                *(void *)__int16 v185 = (unint64_t)&v178[v174 + 1] & 0xFFFFFFFFFFFFFF00;
              }
              else
              {
                size_t v180 = (unint64_t)&v178[v174 + 1] & 0xFFFFFFFFFFFFFF00;
                int v181 = malloc_type_malloc(0x18uLL, 0x1010040A79CA2DEuLL);
                __int16 v182 = malloc_type_malloc(v180, 0x2BEB8FE7uLL);
                *((void *)v181 + 2) = v182;
                bzero(v182, v180);
                *((void *)v181 + 1) = 1;
                string_t v183 = this[1];
                if (v183) {
                  memcpy(*((void **)v181 + 2), *this, (size_t)v183);
                }
                string_t v184 = this[2];
                if (v184) {
                  --*((void *)v184 + 1);
                }
                *(void *)int v181 = v180;
                this[2] = (string_t)v181;
                __int16 v179 = (const char *)*((void *)v181 + 2);
              }
              *this = v179;
LABEL_212:
              __int16 v186 = &v173[v176];
              this[1] = &this[1][v174 - 254];
              memcpy((void *)&v178[(void)v179], v173, v174 - 254);
              int v187 = v173[v176];
              if ((v187 - 58) >= 0xFFFFFFF6)
              {
                int v188 = 0;
                v173 += v176;
                do
                {
                  int v188 = v187 + 10 * v188 - 48;
                  int v189 = *++v173;
                  int v187 = v189;
                }
                while ((v189 - 58) > 0xFFFFFFF5);
                *(_DWORD *)int v466 = v188;
                LOBYTE(v187) = *v186;
              }
              else
              {
                int v173 = 0;
                int v188 = *(_DWORD *)v466;
              }
              int v190 = (char)v187 > 99;
              if ((char)v187 > 97) {
                ++v190;
              }
              if ((char)v187 > 102) {
                ++v190;
              }
              if ((char)v187 > 111) {
                ++v190;
              }
              int v191 = *((_DWORD *)a2 + v190 - ((char)v187 > 112) - ((char)v187 > 116));
              string_t v193 = this[1];
              string_t v192 = this[2];
              if (v192)
              {
                if ((unint64_t)(v193 + 20) < *(void *)v192)
                {
                  signed int v194 = v188 + v191;
                  int v195 = (char *)&v193[(void)*this];
                  if (v188 + v191 < 0) {
                    break;
                  }
LABEL_234:
                  uint64_t v196 = 0;
LABEL_235:
                  uint32x4_t v204 = (uint32x4_t)vdupq_n_s32(v194);
                  int16x8_t v205 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_u32(v204, (uint32x4_t)xmmword_1B7EC1820), (int16x8_t)vcgtq_u32(v204, (uint32x4_t)xmmword_1B7EC1810)), (int8x16_t)xmmword_1B7EC1830);
                  v205.i32[0] = vaddvq_s16(v205);
                  uint8x8_t v206 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v205.i8);
                  v206.i16[0] = vaddlv_u8(v206);
                  __int32 v207 = v206.i32[0];
                  if (v194 > 9) {
                    __int32 v207 = v206.i32[0] + 1;
                  }
                  switch(v207)
                  {
                    case 1:
                      goto LABEL_246;
                    case 2:
                      goto LABEL_245;
                    case 3:
                      goto LABEL_244;
                    case 4:
                      goto LABEL_243;
                    case 5:
                      goto LABEL_242;
                    case 6:
                      goto LABEL_241;
                    case 7:
                      goto LABEL_240;
                    case 8:
                      goto LABEL_239;
                    case 9:
                      unsigned int v208 = v194 / 0x3B9ACA00u;
                      v194 %= 0x3B9ACA00u;
                      v195[v196++] = v208 | 0x30;
LABEL_239:
                      int v209 = v194 / 100000000;
                      v194 %= 100000000;
                      v195[v196++] = v209 + 48;
LABEL_240:
                      int v210 = v194 / 10000000;
                      v194 %= 10000000;
                      v195[v196++] = v210 + 48;
LABEL_241:
                      int v211 = v194 / 1000000;
                      v194 %= 1000000;
                      v195[v196++] = v211 + 48;
LABEL_242:
                      int v212 = v194 / 100000;
                      v194 %= 100000;
                      v195[v196++] = v212 + 48;
LABEL_243:
                      int v213 = v194 / 10000;
                      v194 %= 10000;
                      v195[v196++] = v213 + 48;
LABEL_244:
                      int v214 = v194 / 1000;
                      v194 %= 1000;
                      v195[v196++] = v214 + 48;
LABEL_245:
                      int v215 = v194 / 100;
                      v194 %= 100;
                      v195[v196++] = v215 + 48;
LABEL_246:
                      int v216 = v194 / 10;
                      v194 %= 10;
                      v195[v196++] = v216 + 48;
                      break;
                    default:
                      break;
                  }
                  v195[v196] = v194 + 48;
                  this[1] += v196 + 1;
                  uint64_t v174 = 256;
                  int v175 = *v173;
                  if (v175 == 44) {
                    goto LABEL_248;
                  }
                  continue;
                }
                char v202 = (const char *)malloc_type_realloc(*((void **)v192 + 2), (unint64_t)(v193 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                char v203 = (char *)this[2];
                *((void *)v203 + 2) = v202;
                *(void *)char v203 = (unint64_t)(v193 + 275) & 0xFFFFFFFFFFFFFF00;
                *this = v202;
                signed int v194 = v188 + v191;
                int v195 = (char *)&v193[(void)v202];
                if (((v188 + v191) & 0x80000000) == 0) {
                  goto LABEL_234;
                }
              }
              else
              {
                __int16 v197 = malloc_type_malloc(0x18uLL, 0x1010040A79CA2DEuLL);
                int v198 = malloc_type_malloc((unint64_t)(v193 + 275) & 0xFFFFFFFFFFFFFF00, 0x2BEB8FE7uLL);
                *((void *)v197 + 2) = v198;
                bzero(v198, (unint64_t)(v193 + 275) & 0xFFFFFFFFFFFFFF00);
                *((void *)v197 + 1) = 1;
                string_t v199 = this[1];
                if (v199) {
                  memcpy(*((void **)v197 + 2), *this, (size_t)v199);
                }
                string_t v200 = this[2];
                if (v200) {
                  --*((void *)v200 + 1);
                }
                *(void *)__int16 v197 = (unint64_t)(v193 + 275) & 0xFFFFFFFFFFFFFF00;
                this[2] = (string_t)v197;
                int v201 = (const char *)*((void *)v197 + 2);
                *this = v201;
                signed int v194 = v188 + v191;
                int v195 = (char *)&v193[(void)v201];
                if (((v188 + v191) & 0x80000000) == 0) {
                  goto LABEL_234;
                }
              }
              break;
            }
            char *v195 = 45;
            signed int v194 = -v194;
            uint64_t v196 = 1;
            goto LABEL_235;
          }
        }
        else
        {
          signed int v68 = v459;
          if (v67 == a5) {
            goto LABEL_193;
          }
        }
        goto LABEL_189;
      }
      if (a5 == -1 || (BOOL v137 = v67 >= a5, v67 -= a5, !v137))
      {
LABEL_189:
        if (!*((_DWORD *)a2 + 6))
        {
          __int16 v17 = (const char *)(v19 + 2);
          goto LABEL_5;
        }
        string_t v162 = this[1];
        string_t v161 = this[2];
        unint64_t v163 = (unint64_t)(v162 + 2);
        if (v161)
        {
          if (v163 >= *(void *)v161)
          {
            __int16 v164 = (const char *)malloc_type_realloc(*((void **)v161 + 2), (unint64_t)(v162 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            int v165 = (char *)this[2];
            *((void *)v165 + 2) = v164;
            *(void *)int v165 = (unint64_t)(v162 + 257) & 0xFFFFFFFFFFFFFF00;
            *this = v164;
          }
        }
        else
        {
          str_alloc(this, v163);
        }
        string_t v235 = *this;
        this[1] += 2;
        *(_WORD *)&v162[(void)v235] = 8995;
        int v236 = *((_DWORD *)a2 + 6);
        int v237 = *(_DWORD *)v466;
        string_t v239 = this[1];
        string_t v238 = this[2];
        unint64_t v240 = (unint64_t)(v239 + 20);
        if (v238)
        {
          if (v240 >= *(void *)v238)
          {
            uint64_t v241 = (const char *)malloc_type_realloc(*((void **)v238 + 2), (unint64_t)(v239 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            int v242 = (char *)this[2];
            *((void *)v242 + 2) = v241;
            *(void *)int v242 = (unint64_t)(v239 + 275) & 0xFFFFFFFFFFFFFF00;
            *this = v241;
          }
        }
        else
        {
          str_alloc(this, v240);
        }
        string_t v243 = (string_t)itoa((char *)&v239[(void)*this], v237 + v236);
        string_t v244 = this[1];
LABEL_291:
        size_t v266 = 0;
        unint64_t v267 = &v243[(void)v244];
        this[1] = &v243[(void)v244];
        while (1)
        {
          int v268 = v19[v266];
          if (v268 == 101)
          {
            if (v19[v266 + 1] == 91 && v19[v266 - 7] != 46)
            {
              unint64_t v331 = (unint64_t)&v243[(void)v244 + 2 + v266];
              string_t v332 = this[2];
              if (v332)
              {
                if (v331 >= *(void *)v332)
                {
                  size_t v333 = (unint64_t)&v243[(void)v244 + 257 + v266] & 0xFFFFFFFFFFFFFF00;
                  int8x8_t v334 = (const char *)malloc_type_realloc(*((void **)v332 + 2), v333, 0xCCCD1039uLL);
                  char v335 = (char *)this[2];
                  *((void *)v335 + 2) = v334;
                  *(void *)char v335 = v333;
                  *this = v334;
                }
              }
              else
              {
                str_alloc(this, v331);
              }
              __int16 v17 = (const char *)&v19[v266 + 2];
              string_t v336 = *this;
              this[1] += v266 + 2;
              memcpy((void *)&v267[(void)v336], v19, v266 + 2);
              int v337 = *(unsigned __int8 *)v17;
              if ((v337 - 58) >= 0xFFFFFFF6)
              {
                int v338 = 0;
                do
                {
                  int v338 = v337 + 10 * v338 - 48;
                  int v345 = *(unsigned __int8 *)++v17;
                  int v337 = v345;
                }
                while ((v345 - 58) > 0xFFFFFFF5);
                *(_DWORD *)int v466 = v338;
                int v339 = *((_DWORD *)a2 + 6);
                string_t v341 = this[1];
                string_t v340 = this[2];
                unint64_t v342 = (unint64_t)(v341 + 20);
                if (v340) {
                  goto LABEL_372;
                }
LABEL_377:
                str_alloc(this, v342);
                goto LABEL_378;
              }
              __int16 v17 = 0;
              int v338 = *(_DWORD *)v466;
              int v339 = *((_DWORD *)a2 + 6);
              string_t v341 = this[1];
              string_t v340 = this[2];
              unint64_t v342 = (unint64_t)(v341 + 20);
              if (!v340) {
                goto LABEL_377;
              }
LABEL_372:
              if (v342 >= *(void *)v340)
              {
                unsigned int v343 = (const char *)malloc_type_realloc(*((void **)v340 + 2), (unint64_t)(v341 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                string_t v344 = (char *)this[2];
                *((void *)v344 + 2) = v343;
                *(void *)string_t v344 = (unint64_t)(v341 + 275) & 0xFFFFFFFFFFFFFF00;
                *this = v343;
              }
LABEL_378:
              this[1] += itoa((char *)&v341[(void)*this], v338 + v339);
              uint64_t v13 = v17;
LABEL_5:
              int v16 = (unsigned __int8 *)v13;
              int v12 = *(unsigned __int8 *)v17;
              uint64_t v13 = v17;
              goto LABEL_6;
            }
          }
          else if (v268 == 36)
          {
            if (v19[v266 + 1] == 111 && a7 != 0)
            {
              unint64_t v275 = (unint64_t)&v243[(void)v244 + v266];
              string_t v276 = this[2];
              if (v276)
              {
                if (v275 >= *(void *)v276)
                {
                  size_t v277 = (unint64_t)&v243[(void)v244 + 255 + v266] & 0xFFFFFFFFFFFFFF00;
                  int v278 = (const char *)malloc_type_realloc(*((void **)v276 + 2), v277, 0xCCCD1039uLL);
                  char v279 = (char *)this[2];
                  *((void *)v279 + 2) = v278;
                  *(void *)char v279 = v277;
                  *this = v278;
                }
              }
              else
              {
                str_alloc(this, v275);
              }
              string_t v296 = *this;
              this[1] += v266;
              memcpy((void *)&v267[(void)v296], v19, v266);
              string_t v280 = &v19[v266 + 2];
              int v297 = *v280;
              if ((v297 - 58) >= 0xFFFFFFF6)
              {
                int v303 = 0;
                do
                {
                  int v303 = v297 + 10 * v303 - 48;
                  int v304 = *++v280;
                  int v297 = v304;
                }
                while ((v304 - 58) > 0xFFFFFFF5);
                *(_DWORD *)int v466 = v303;
                string_t v299 = this[1];
                string_t v298 = this[2];
                unint64_t v300 = (unint64_t)(v299 + 2);
                if (v298) {
                  goto LABEL_329;
                }
              }
              else
              {
                string_t v280 = 0;
                string_t v299 = this[1];
                string_t v298 = this[2];
                unint64_t v300 = (unint64_t)(v299 + 2);
                if (v298)
                {
LABEL_329:
                  if (v300 >= *(void *)v298)
                  {
                    unint64_t v301 = (const char *)malloc_type_realloc(*((void **)v298 + 2), (unint64_t)(v299 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    unint64_t v302 = (char *)this[2];
                    *((void *)v302 + 2) = v301;
                    *(void *)unint64_t v302 = (unint64_t)(v299 + 257) & 0xFFFFFFFFFFFFFF00;
                    *this = v301;
                  }
LABEL_335:
                  string_t v305 = *this;
                  this[1] += 2;
                  *(_WORD *)&v299[(void)v305] = 29732;
                  int v306 = (char)(v466[0] + 111);
                  int v307 = v306 > 99;
                  if (v306 > 97) {
                    ++v307;
                  }
                  if (v306 > 102) {
                    ++v307;
                  }
                  if (v306 > 111) {
                    ++v307;
                  }
                  signed int v256 = *((_DWORD *)a2 + v307 - (v306 > 112) - (v306 > 116));
                  string_t v309 = this[1];
                  string_t v308 = this[2];
                  unint64_t v310 = (unint64_t)(v309 + 20);
                  if (v308)
                  {
                    if (v310 >= *(void *)v308)
                    {
                      unint64_t v311 = (const char *)malloc_type_realloc(*((void **)v308 + 2), (unint64_t)(v309 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      size_t v312 = (char *)this[2];
                      *((void *)v312 + 2) = v311;
                      *(void *)size_t v312 = (unint64_t)(v309 + 275) & 0xFFFFFFFFFFFFFF00;
                      *this = v311;
                    }
                    int v313 = (char *)&v309[(void)*this];
                    if ((v256 & 0x80000000) == 0)
                    {
LABEL_345:
                      uint64_t v257 = 0;
                      goto LABEL_363;
                    }
                  }
                  else
                  {
                    str_alloc(this, v310);
                    int v313 = (char *)&v309[(void)*this];
                    if ((v256 & 0x80000000) == 0) {
                      goto LABEL_345;
                    }
                  }
                  char *v313 = 45;
                  signed int v256 = -v256;
                  uint64_t v257 = 1;
LABEL_363:
                  uint32x4_t v327 = (uint32x4_t)vdupq_n_s32(v256);
                  int16x8_t v328 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_u32(v327, (uint32x4_t)xmmword_1B7EC1820), (int16x8_t)vcgtq_u32(v327, (uint32x4_t)xmmword_1B7EC1810)), (int8x16_t)xmmword_1B7EC1830);
                  v328.i32[0] = vaddvq_s16(v328);
                  uint8x8_t v329 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v328.i8);
                  v329.i16[0] = vaddlv_u8(v329);
                  __int32 v330 = v329.i32[0];
                  if (v256 > 9) {
                    __int32 v330 = v329.i32[0] + 1;
                  }
                  switch(v330)
                  {
                    case 1:
                      goto LABEL_288;
                    case 2:
                      goto LABEL_287;
                    case 3:
                      goto LABEL_286;
                    case 4:
                      goto LABEL_285;
                    case 5:
                      goto LABEL_284;
                    case 6:
                      goto LABEL_283;
                    case 7:
                      goto LABEL_282;
                    case 8:
                      goto LABEL_281;
                    case 9:
                      unsigned int v255 = v256 / 0x3B9ACA00u;
                      v256 %= 0x3B9ACA00u;
                      v313[v257++] = v255 | 0x30;
LABEL_281:
                      int v258 = v256 / 100000000;
                      v256 %= 100000000;
                      v313[v257++] = v258 + 48;
LABEL_282:
                      int v259 = v256 / 10000000;
                      v256 %= 10000000;
                      v313[v257++] = v259 + 48;
LABEL_283:
                      int v260 = v256 / 1000000;
                      v256 %= 1000000;
                      v313[v257++] = v260 + 48;
LABEL_284:
                      int v261 = v256 / 100000;
                      v256 %= 100000;
                      v313[v257++] = v261 + 48;
LABEL_285:
                      int v262 = v256 / 10000;
                      v256 %= 10000;
                      v313[v257++] = v262 + 48;
LABEL_286:
                      int v263 = v256 / 1000;
                      v256 %= 1000;
                      v313[v257++] = v263 + 48;
LABEL_287:
                      int v264 = v256 / 100;
                      v256 %= 100;
                      v313[v257++] = v264 + 48;
LABEL_288:
                      int v265 = v256 / 10;
                      v256 %= 10;
                      v313[v257++] = v265 + 48;
                      break;
                    default:
                      break;
                  }
                  string_t v244 = (string_t)(v257 + 1);
                  v313[v257] = v256 + 48;
LABEL_290:
                  string_t v243 = this[1];
                  int v19 = v280;
                  goto LABEL_291;
                }
              }
              str_alloc(this, v300);
              goto LABEL_335;
            }
            unint64_t v270 = (unint64_t)&v243[(void)v244 + 2 + v266];
            string_t v271 = this[2];
            if (v271)
            {
              if (v270 >= *(void *)v271)
              {
                size_t v272 = (unint64_t)&v243[(void)v244 + 257 + v266] & 0xFFFFFFFFFFFFFF00;
                string_t v273 = (const char *)malloc_type_realloc(*((void **)v271 + 2), v272, 0xCCCD1039uLL);
                unint64_t v274 = (char *)this[2];
                *((void *)v274 + 2) = v273;
                *(void *)unint64_t v274 = v272;
                *this = v273;
              }
            }
            else
            {
              str_alloc(this, v270);
            }
            string_t v280 = &v19[v266 + 2];
            string_t v281 = *this;
            this[1] += v266 + 2;
            memcpy((void *)&v267[(void)v281], v19, v266 + 2);
            int v282 = *v280;
            if ((v282 - 58) >= 0xFFFFFFF6)
            {
              int v283 = 0;
              do
              {
                int v283 = v282 + 10 * v283 - 48;
                int v284 = *++v280;
                int v282 = v284;
              }
              while ((v284 - 58) > 0xFFFFFFF5);
              *(_DWORD *)int v466 = v283;
            }
            else
            {
              string_t v280 = 0;
              int v283 = *(_DWORD *)v466;
            }
            int v285 = (char)v19[v266 + 1];
            int v286 = v285 > 99;
            if (v285 > 97) {
              ++v286;
            }
            if (v285 > 102) {
              ++v286;
            }
            if (v285 > 111) {
              ++v286;
            }
            int v287 = *((_DWORD *)a2 + v286 - (v285 > 112) - (v285 > 116));
            string_t v289 = this[1];
            string_t v288 = this[2];
            unint64_t v290 = (unint64_t)(v289 + 20);
            if (v288)
            {
              if (v290 >= *(void *)v288)
              {
                string_t v291 = (const char *)malloc_type_realloc(*((void **)v288 + 2), (unint64_t)(v289 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                string_t v292 = (char *)this[2];
                *((void *)v292 + 2) = v291;
                *(void *)string_t v292 = (unint64_t)(v289 + 275) & 0xFFFFFFFFFFFFFF00;
                *this = v291;
              }
              signed int v293 = v283 + v287;
              unint64_t v294 = (char *)&v289[(void)*this];
              if (((v283 + v287) & 0x80000000) == 0)
              {
LABEL_325:
                uint64_t v295 = 0;
LABEL_348:
                uint32x4_t v314 = (uint32x4_t)vdupq_n_s32(v293);
                int16x8_t v315 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_u32(v314, (uint32x4_t)xmmword_1B7EC1820), (int16x8_t)vcgtq_u32(v314, (uint32x4_t)xmmword_1B7EC1810)), (int8x16_t)xmmword_1B7EC1830);
                v315.i32[0] = vaddvq_s16(v315);
                uint8x8_t v316 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v315.i8);
                v316.i16[0] = vaddlv_u8(v316);
                __int32 v317 = v316.i32[0];
                if (v293 > 9) {
                  __int32 v317 = v316.i32[0] + 1;
                }
                switch(v317)
                {
                  case 1:
                    goto LABEL_359;
                  case 2:
                    goto LABEL_358;
                  case 3:
                    goto LABEL_357;
                  case 4:
                    goto LABEL_356;
                  case 5:
                    goto LABEL_355;
                  case 6:
                    goto LABEL_354;
                  case 7:
                    goto LABEL_353;
                  case 8:
                    goto LABEL_352;
                  case 9:
                    unsigned int v318 = v293 / 0x3B9ACA00u;
                    v293 %= 0x3B9ACA00u;
                    v294[v295++] = v318 | 0x30;
LABEL_352:
                    int v319 = v293 / 100000000;
                    v293 %= 100000000;
                    v294[v295++] = v319 + 48;
LABEL_353:
                    int v320 = v293 / 10000000;
                    v293 %= 10000000;
                    v294[v295++] = v320 + 48;
LABEL_354:
                    int v321 = v293 / 1000000;
                    v293 %= 1000000;
                    v294[v295++] = v321 + 48;
LABEL_355:
                    int v322 = v293 / 100000;
                    v293 %= 100000;
                    v294[v295++] = v322 + 48;
LABEL_356:
                    int v323 = v293 / 10000;
                    v293 %= 10000;
                    v294[v295++] = v323 + 48;
LABEL_357:
                    int v324 = v293 / 1000;
                    v293 %= 1000;
                    v294[v295++] = v324 + 48;
LABEL_358:
                    int v325 = v293 / 100;
                    v293 %= 100;
                    v294[v295++] = v325 + 48;
LABEL_359:
                    int v326 = v293 / 10;
                    v293 %= 10;
                    v294[v295++] = v326 + 48;
                    break;
                  default:
                    break;
                }
                string_t v244 = (string_t)(v295 + 1);
                v294[v295] = v293 + 48;
                goto LABEL_290;
              }
            }
            else
            {
              str_alloc(this, v290);
              signed int v293 = v283 + v287;
              unint64_t v294 = (char *)&v289[(void)*this];
              if (((v283 + v287) & 0x80000000) == 0) {
                goto LABEL_325;
              }
            }
            *unint64_t v294 = 45;
            signed int v293 = -v293;
            uint64_t v295 = 1;
            goto LABEL_348;
          }
          ++v266;
        }
      }
    }
    signed int v68 = v67;
    if (v67 != -1) {
      goto LABEL_193;
    }
    goto LABEL_189;
  }
  if (strncmp(v13 - 1, "\nEND\n", 5uLL))
  {
    __int16 v17 = v13 + 1;
    goto LABEL_4;
  }
  string_t v451 = this[1];
  string_t v450 = this[2];
  unint64_t v452 = (unint64_t)&v451[v13 - (const char *)v16];
  if (v450)
  {
    if (v452 >= *(void *)v450)
    {
      size_t v453 = (v452 + 255) & 0xFFFFFFFFFFFFFF00;
      int v454 = (const char *)malloc_type_realloc(*((void **)v450 + 2), v453, 0xCCCD1039uLL);
      string_t v455 = (char *)this[2];
      *((void *)v455 + 2) = v454;
      *(void *)string_t v455 = v453;
      *this = v454;
    }
  }
  else
  {
    str_alloc(this, v452);
  }
  string_t v456 = *this;
  this[1] += v13 - (const char *)v16;
  memcpy((void *)&v451[(void)v456], v16, v13 - (const char *)v16);
}

uint64_t HGString::Digest::push(HGString::Digest *this, const HGString::Digest *a2, const HGLimits *a3)
{
  long long v3 = *(_OWORD *)a2;
  long long v4 = *((_OWORD *)a2 + 1);
  long long v5 = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 3) = v5;
  *(_OWORD *)this = v3;
  *((_OWORD *)this + 1) = v4;
  unsigned __int16 v6 = *((_WORD *)this + 26) + 1;
  *((_WORD *)this + 26) = v6;
  unsigned __int8 v7 = *((unsigned char *)this + 56) + 1;
  *((unsigned char *)this + 56) = v7;
  unsigned __int8 v8 = *((unsigned char *)this + 59) + 1;
  *((unsigned char *)this + 59) = v8;
  unsigned __int8 v9 = *((unsigned char *)this + 58) + 1;
  *((unsigned char *)this + 58) = v9;
  if (v6 <= 0xFFu)
  {
    v6 |= (unsigned __int16)(v6 << 12) | ((v7 & 0xF) << 8);
    *((_WORD *)this + 26) = v6;
  }
  if (a3)
  {
    if (*((unsigned __int16 *)a3 + 18) < v6) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v11 = 0xFFFFFFFFLL;
    if (*((unsigned __int8 *)a3 + 40) < v7 || v8 > 8u) {
      return v11;
    }
    if (*((unsigned __int16 *)this + 20)
       + v8
       + *((unsigned __int8 *)this + 43)
       + *((unsigned __int8 *)this + 42)
       + *((unsigned __int8 *)this + 44)
       + *((unsigned __int16 *)this + 25) > *((unsigned __int8 *)a3 + 27)
                                                        + *((unsigned __int16 *)a3 + 12)
                                                        + *((unsigned __int8 *)a3 + 26)
                                                        + *((unsigned __int8 *)a3 + 28)
                                                        + *((unsigned __int16 *)a3 + 17)
                                                        + *((unsigned __int8 *)a3 + 43))
      return 0xFFFFFFFFLL;
    if (*((unsigned __int8 *)a3 + 42) < v9) {
      return 0xFFFFFFFFLL;
    }
  }
  return *((unsigned __int8 *)a2 + 56);
}

uint64_t HGString::push(HGString *this, const HGLimits *a2)
{
  HGString::digest(this, (uint64_t)&v28);
  long long v24 = v28;
  long long v25 = v29[0];
  long long v26 = v29[1];
  long long v27 = v30;
  __int16 v4 = WORD2(v30) + 1;
  WORD2(v27) = WORD2(v30) + 1;
  unsigned __int8 v5 = BYTE8(v30) + 1;
  BYTE8(v27) = BYTE8(v30) + 1;
  BYTE11(v27) = BYTE11(v30) + 1;
  BYTE10(v27) = BYTE10(v30) + 1;
  if ((unsigned __int16)(WORD2(v30) + 1) <= 0xFFu)
  {
    v4 |= (v4 << 12) | ((v5 & 0xF) << 8);
    WORD2(v27) = v4;
  }
  if (!a2) {
    goto LABEL_10;
  }
  if (*((unsigned __int16 *)a2 + 18) < v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = 0xFFFFFFFFLL;
  if (*((unsigned __int8 *)a2 + 40) >= v5
    && (BYTE11(v30) + 1) <= 8u
    && WORD4(v26)
     + (BYTE11(v30) + 1)
     + BYTE11(v26)
     + BYTE10(v26)
     + BYTE12(v26)
     + WORD1(v27) <= *((unsigned __int8 *)a2 + 27)
                                 + *((unsigned __int16 *)a2 + 12)
                                 + *((unsigned __int8 *)a2 + 26)
                                 + *((unsigned __int8 *)a2 + 28)
                                 + *((unsigned __int16 *)a2 + 17)
                                 + *((unsigned __int8 *)a2 + 43)
    && *((unsigned __int8 *)a2 + 42) >= (BYTE10(v30) + 1))
  {
LABEL_10:
    uint64_t v6 = BYTE8(v30);
    LOBYTE(v23) = 1;
    HIBYTE(v23) = BYTE8(v30) + 1;
    HGString::appendHistory(this, &v23);
    if ((v29[0] & 0xFFFFF) - 394305 >= 0xFFFFFECF)
    {
      arb::begin((string_t *)this, (string_t *)v29, (const HGLimits *)&v25, v7);
      arb::end((string_t *)this, (uint64_t)&v25, (unsigned int *)&v24, v13, v14, v15);
      return v6;
    }
    if ((v29[0] & 0xFFFFF) - 394785 >= 0xFFFFFFEF)
    {
      double v8 = glsl::begin((string_t *)this, (string_t *)v29, (const HGLimits *)&v25, v7);
    }
    else
    {
      if ((v29[0] & 0xFFFFF) != 0x60B10)
      {
        if (LODWORD(v29[0])) {
          return v6;
        }
        DWORD2(v25) |= (unsigned __int16)(v4 & 0xFF00) >> 8;
        *((void *)this + 1) = 0;
        int v16 = (string_t *)this;
        char v17 = 1;
        goto LABEL_19;
      }
      int v11 = v25;
      uint64_t v12 = *((void *)this + 1);
      if (v12)
      {
        str_alloc((string_t *)this, v12);
        if (LODWORD(v29[0]) != v11) {
          goto LABEL_24;
        }
      }
      else
      {
        str_alloc((string_t *)this, 33);
        *((void *)this + 1) = 33;
        if (LODWORD(v29[0]) != v11)
        {
LABEL_24:
          int v19 = v11 >> 4;
          uint64_t v20 = *(void *)this;
          *(_DWORD *)(v20 + 3) = 1818326117;
          *(_DWORD *)uint64_t v20 = 1699557167;
          if (v19 | v11 & 0xF)
          {
            *(unsigned char *)(v20 + 7) = v19 | 0x30;
            *(unsigned char *)(v20 + 8) = 46;
            string_t v21 = (void *)(v20 + 10);
            *(unsigned char *)(v20 + 9) = v11 & 0xF | 0x30;
          }
          else
          {
            string_t v21 = (void *)(v20 + 7);
          }
          uint64_t v22 = *(void *)this;
          memset(v21, 32, *(void *)this + 15 - (void)v21);
          qmemcpy((void *)(v22 + 15), "\n//LEN=0000000000\n", 18);
          double v8 = *(double *)"//LEN=0000000000\n";
        }
      }
    }
    int v16 = (string_t *)this;
    char v17 = 0;
LABEL_19:
    glsl::end(v16, (uint64_t)&v25, (unsigned int *)&v24, v17, v8, v9, v10);
  }
  return v6;
}

void HGString::appendHistory(void *a1, _WORD *a2)
{
  unsigned __int8 v5 = (char *)a1[4];
  unint64_t v4 = a1[5];
  uint64_t v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    double v8 = (void **)(a1 + 3);
    double v9 = (char *)a1[3];
    uint64_t v10 = v5 - v9;
    if (v5 - v9 <= -3) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v10 >> 1;
    unint64_t v12 = v4 - (void)v9;
    if (v12 <= (v10 >> 1) + 1) {
      unint64_t v13 = v11 + 1;
    }
    else {
      unint64_t v13 = v12;
    }
    if (v12 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v14 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v14 = v13;
    }
    if (v14)
    {
      if (v14 < 0) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint32x4_t v15 = operator new(2 * v14);
    }
    else
    {
      uint32x4_t v15 = 0;
    }
    int v16 = &v15[2 * v11];
    _WORD *v16 = *a2;
    unsigned __int8 v7 = v16 + 1;
    if (v5 != v9)
    {
      unint64_t v17 = v5 - v9 - 2;
      if (v17 < 0x1E) {
        goto LABEL_29;
      }
      if (v5 - v15 - (v10 & 0xFFFFFFFFFFFFFFFELL) < 0x20) {
        goto LABEL_29;
      }
      uint64_t v18 = (v17 >> 1) + 1;
      unint64_t v19 = 2 * (v18 & 0xFFFFFFFFFFFFFFF0);
      uint64_t v6 = &v5[-v19];
      int v16 = (_WORD *)((char *)v16 - v19);
      uint64_t v20 = &v15[2 * v11 - 16];
      string_t v21 = (long long *)(v5 - 16);
      unint64_t v22 = v18 & 0xFFFFFFFFFFFFFFF0;
      do
      {
        long long v23 = *v21;
        *(v20 - 1) = *(v21 - 1);
        _OWORD *v20 = v23;
        v20 -= 2;
        v21 -= 2;
        v22 -= 16;
      }
      while (v22);
      if (v18 != (v18 & 0xFFFFFFFFFFFFFFF0))
      {
LABEL_29:
        do
        {
          __int16 v24 = *((_WORD *)v6 - 1);
          v6 -= 2;
          *--int v16 = v24;
        }
        while (v6 != v9);
      }
      uint64_t v6 = (char *)*v8;
    }
    a1[3] = v16;
    a1[4] = v7;
    a1[5] = &v15[2 * v14];
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    *(_WORD *)unsigned __int8 v5 = *a2;
    unsigned __int8 v7 = v5 + 2;
  }
  a1[4] = v7;
}

double glsl::begin(string_t *this, string_t *a2, const HGLimits *a3, const HGLimits *a4)
{
  int v7 = *(_DWORD *)a3;
  string_t v8 = this[1];
  if (v8)
  {
    str_alloc(this, (uint64_t)v8);
    if (*(_DWORD *)a2 == *(_DWORD *)a3) {
      return result;
    }
  }
  else
  {
    str_alloc(this, 33);
    this[1] = (string_t)33;
    if (*(_DWORD *)a2 == *(_DWORD *)a3) {
      return result;
    }
  }
  uint64_t v10 = (char *)*this;
  int v11 = v7 & 0xFFF00;
  if ((v7 & 0xFFF00u) <= 0x605FF)
  {
    switch(v11)
    {
      case 132608:
        __int16 v13 = 29552;
        break;
      case 329216:
        __int16 v13 = 29558;
        break;
      case 329472:
        __int16 v12 = 29558;
        goto LABEL_20;
      default:
        return result;
    }
LABEL_17:
    *((_WORD *)v10 + 2) = v13;
    *(_DWORD *)uint64_t v10 = 1279733551;
    int v14 = v7 >> 4;
    char v15 = v7 & 0xF;
    if (!(v14 | v7 & 0xF))
    {
LABEL_21:
      int v16 = v10 + 6;
      goto LABEL_22;
    }
LABEL_18:
    v10[6] = v14 | 0x30;
    v10[7] = 46;
    int v16 = v10 + 9;
    v10[8] = v15 | 0x30;
LABEL_22:
    string_t v17 = *this;
    memset(v16, 32, v17 + 15 - (unsigned char *)v16);
    qmemcpy((void *)(v17 + 15), "\n//LEN=0000000000\n", 18);
    return *(double *)"//LEN=0000000000\n";
  }
  switch(v11)
  {
    case 394752:
      __int16 v13 = 29542;
      goto LABEL_17;
    case 395008:
      __int16 v12 = 29542;
LABEL_20:
      *((_WORD *)v10 + 2) = v12;
      *(_DWORD *)uint64_t v10 = 1195585327;
      int v14 = v7 >> 4;
      char v15 = v7 & 0xF;
      if (!(v14 | v7 & 0xF)) {
        goto LABEL_21;
      }
      goto LABEL_18;
    case 460288:
      __int16 v13 = 29557;
      goto LABEL_17;
  }
  return result;
}

uint64_t HGString::Digest::push(HGString::Digest *this, HGShaderBinding *a2, const HGString::Digest *a3, const HGString::Digest *a4, int a5, const HGLimits *a6)
{
  int v6 = *((_DWORD *)a3 + 4);
  if (!v6)
  {
    int v9 = *((_DWORD *)a4 + 4);
    if ((v9 & 0xFFFFFu) - 394000 < 0x131 || (v9 & 0xFFFFFu) - 394768 < 0x11 || (v9 & 0xFFFFF) == 396048) {
      goto LABEL_27;
    }
    goto LABEL_16;
  }
  int v7 = v6 & 0xFFFFF;
  if (v7 != 396048 && (v7 - 394000) >= 0x131 && (v7 - 394768) > 0x10) {
    return 0xFFFFFFFFLL;
  }
  if ((v7 - 394305) >= 0xFFFFFECF)
  {
    if ((*((_DWORD *)a4 + 4) & 0xFFFFFu) - 394305 < 0xFFFFFECF) {
      goto LABEL_24;
    }
  }
  else
  {
    if ((v7 - 394785) < 0xFFFFFFEF)
    {
      if (v7 == 396048)
      {
        int v9 = *((_DWORD *)a4 + 4);
        if ((v9 & 0xFFFFF) == 0x60B10) {
          goto LABEL_27;
        }
LABEL_16:
        if (v9) {
          return 0xFFFFFFFFLL;
        }
        return *((unsigned __int8 *)a3 + 58);
      }
LABEL_24:
      if (*((_DWORD *)a4 + 4)) {
        return 0xFFFFFFFFLL;
      }
      return *((unsigned __int8 *)a3 + 58);
    }
    if ((*((_DWORD *)a4 + 4) & 0xFFFFFu) - 394785 < 0xFFFFFFEF) {
      goto LABEL_24;
    }
  }
LABEL_27:
  if (a5 && (*((unsigned __int16 *)a4 + 26) > 1u || *((unsigned __int8 *)a4 + 56) > 1u)
    || (*((_DWORD *)a3 + 5) & *((_DWORD *)a4 + 5) & 0x8000000) != 0
    || *((unsigned char *)a4 + 58) != 1)
  {
    return 0xFFFFFFFFLL;
  }
  unsigned int v13 = *((unsigned __int8 *)a4 + 59);
  if (v13 <= 1) {
    LOBYTE(v13) = 1;
  }
  unsigned __int8 v14 = v13 + *((unsigned char *)a3 + 58);
  *((unsigned char *)this + 59) = v14;
  unsigned int v15 = v14 <= *((unsigned __int8 *)a3 + 59) ? *((unsigned __int8 *)a3 + 59) : v14;
  *((unsigned char *)this + 59) = v15;
  if (v15 > 8) {
    return 0xFFFFFFFFLL;
  }
  int v16 = *((unsigned __int16 *)a3 + 25);
  int v17 = *((unsigned __int16 *)a3 + 18);
  *(_DWORD *)a2 = v16;
  *((_DWORD *)a2 + 1) = v17;
  __int16 v18 = *((_WORD *)a3 + 26);
  int v19 = *((unsigned __int8 *)a3 + 58);
  *((_DWORD *)a2 + 2) = v18;
  *((_DWORD *)a2 + 3) = v19;
  int v20 = *((unsigned __int16 *)a3 + 19);
  int v21 = *((_DWORD *)a3 + 15);
  *((_DWORD *)a2 + 4) = v20;
  *((_DWORD *)a2 + 5) = v21;
  unsigned int v22 = *((unsigned __int8 *)a3 + 56);
  *((_DWORD *)a2 + 6) = v22;
  *(void *)((char *)a2 + 28) = 0xFFFFFFFFLL;
  unsigned int v24 = *((_DWORD *)a3 + 4);
  int v23 = *((_DWORD *)a3 + 5);
  int v25 = *((_DWORD *)a4 + 5);
  if (v24 <= *((_DWORD *)a4 + 4)) {
    unsigned int v24 = *((_DWORD *)a4 + 4);
  }
  if (v19) {
    int v26 = *((_DWORD *)a3 + 5);
  }
  else {
    int v26 = *((_DWORD *)a4 + 5);
  }
  unsigned int v27 = v25 & 0xEFFFFFFF | v23 & 0xDBFFFFFF | v26 & 0x20000000;
  __int16 v28 = *((_WORD *)a4 + 24) | *((_WORD *)a3 + 24);
  __int16 v29 = *((_WORD *)a4 + 23) | *((_WORD *)a3 + 23);
  char v30 = *((unsigned char *)a4 + 57) | *((unsigned char *)a3 + 57);
  int v31 = v25 | v23;
  unsigned int v32 = v23 & v25 & 0xC0000000;
  if (v31 < 0) {
    unsigned int v32 = 0x80000000;
  }
  int v33 = v27 | v32;
  int v34 = (*((_DWORD *)a4 + 8) << v22) | *((_DWORD *)a3 + 8);
  *((_DWORD *)this + 4) = v24;
  *((_DWORD *)this + 5) = v33;
  int8x8_t v35 = vand_s8((int8x8_t)vshl_u32(*(uint32x2_t *)((char *)a4 + 24), (uint32x2_t)vdup_n_s32(v22)), (int8x8_t)0xFF000000FFLL);
  uint8x8_t v36 = (uint8x8_t)vorr_s8(v35, *(int8x8_t *)((char *)a3 + 24));
  *((uint8x8_t *)this + 3) = v36;
  *((_DWORD *)this + 8) = v34;
  *((_WORD *)this + 24) = v28;
  *((_WORD *)this + 23) = v29;
  *((unsigned char *)this + 58) = v19 + 1;
  *((unsigned char *)this + 57) = v30;
  __int16 v37 = *((_WORD *)a4 + 26);
  if (a5) {
    __int16 v37 = 1;
  }
  unsigned __int8 v38 = v37 + v18;
  unsigned __int16 v39 = (v37 + v18) | v18 & 0xFF00;
  *((_WORD *)this + 26) = v39;
  char v40 = *((unsigned char *)a4 + 56);
  if (a5) {
    char v40 = 1;
  }
  unsigned __int8 v41 = v40 + v22;
  *((unsigned char *)this + 56) = v40 + v22;
  int v42 = *((_DWORD *)a2 + 6);
  if (!a5 && !*((_DWORD *)a2 + 2) && !v42 && (*((_DWORD *)a4 + 4) & 0xFFFFF) != 0x60B10)
  {
    if (v39 > v41) {
      unsigned __int8 v41 = v38;
    }
    *((unsigned char *)this + 56) = v41;
    LOBYTE(v39) = v41;
    *((_WORD *)this + 26) = v41;
  }
  unsigned __int16 v43 = *((_WORD *)a4 + 19) + v20;
  *((_WORD *)this + 19) = v43;
  *((_DWORD *)this + 15) = *((_DWORD *)a4 + 15) + v21;
  unsigned __int16 v44 = *((_WORD *)a4 + 18) + v17;
  *((_WORD *)this + 18) = v44;
  unsigned int v45 = *((unsigned __int16 *)a4 + 20);
  if (v45 <= *((unsigned __int16 *)a3 + 20)) {
    unsigned int v45 = *((unsigned __int16 *)a3 + 20);
  }
  *((_WORD *)this + 20) = v45;
  v36.i32[0] = *(_DWORD *)((char *)a4 + 42);
  int16x8_t v46 = (int16x8_t)vmovl_u8(v36);
  v35.i32[0] = *(_DWORD *)((char *)a3 + 42);
  *(uint16x4_t *)v46.i8 = vmax_u16(*(uint16x4_t *)v46.i8, (uint16x4_t)*(_OWORD *)&vmovl_u8((uint8x8_t)v35));
  *(_DWORD *)((char *)this + 42) = vmovn_s16(v46).u32[0];
  unsigned __int16 v47 = *((_WORD *)a4 + 25) + v16;
  *((_WORD *)this + 25) = v47;
  if (a6)
  {
    if (*((unsigned __int16 *)a6 + 18) < v39) {
      return 0xFFFFFFFFLL;
    }
    if (*((unsigned __int8 *)a6 + 40) < v41) {
      return 0xFFFFFFFFLL;
    }
    if (*((unsigned __int16 *)a6 + 11) < v43) {
      return 0xFFFFFFFFLL;
    }
    unsigned int v48 = *((unsigned __int16 *)a6 + 10);
    if (v44 > v48
      || v44 + v43 > v48
      || v45 + v15 + v46.u8[2] + v46.u8[0] + v46.u8[4] + v47 > *((unsigned __int8 *)a6 + 27)
                                                             + *((unsigned __int16 *)a6 + 12)
                                                             + *((unsigned __int8 *)a6 + 26)
                                                             + *((unsigned __int8 *)a6 + 28)
                                                             + *((unsigned __int16 *)a6 + 17)
                                                             + *((unsigned __int8 *)a6 + 43))
    {
      return 0xFFFFFFFFLL;
    }
  }
  if (v42)
  {
    unsigned int v49 = *(_DWORD *)a4;
    if (v42 < 1)
    {
      unsigned int v58 = *((_DWORD *)a4 + 2);
      unsigned int v57 = *((_DWORD *)a4 + 3);
      unsigned int v52 = (v57 >> v42) | (v49 >> -(char)v42);
      unsigned int v59 = *((_DWORD *)a4 + 1);
      unsigned int v54 = (v59 >> -(char)v42) | (v49 >> v42);
      unsigned int v55 = (v58 >> -(char)v42) | (v59 >> v42);
      unsigned int v56 = (v58 >> v42) | (v57 >> -(char)v42);
    }
    else
    {
      unsigned int v51 = *((_DWORD *)a4 + 2);
      unsigned int v50 = *((_DWORD *)a4 + 3);
      unsigned int v52 = (v50 >> -(char)v42) | (v49 << v42);
      unsigned int v53 = *((_DWORD *)a4 + 1);
      unsigned int v54 = (v53 << v42) | (v49 >> -(char)v42);
      unsigned int v55 = (v51 << v42) | (v53 >> -(char)v42);
      unsigned int v56 = (v51 >> -(char)v42) | (v50 << v42);
    }
  }
  else
  {
    unsigned int v52 = *(_DWORD *)a4;
    unsigned int v54 = *((_DWORD *)a4 + 1);
    unsigned int v55 = *((_DWORD *)a4 + 2);
    unsigned int v56 = *((_DWORD *)a4 + 3);
  }
  if (v19)
  {
    char v60 = v19 & 7;
    unsigned int v61 = v52 << (v19 & 7);
    char v62 = -(char)v19 & 7;
    unsigned int v52 = (v61 | (v52 >> v62)) | (unsigned __int16)(((v52 >> 8 << v60) | (BYTE1(v52) >> v62)) << 8) | (((HIWORD(v52) << v60) | (BYTE2(v52) >> v62)) << 16) | (((HIBYTE(v52) << v60) | (HIBYTE(v52) >> v62)) << 24);
    unsigned int v54 = ((v54 << v60) | (v54 >> v62)) | (unsigned __int16)(((v54 >> 8 << v60) | (BYTE1(v54) >> v62)) << 8) | (((HIWORD(v54) << v60) | (BYTE2(v54) >> v62)) << 16) | (((HIBYTE(v54) << v60) | (HIBYTE(v54) >> v62)) << 24);
    unsigned int v55 = ((v55 << v60) | (v55 >> v62)) | (unsigned __int16)(((v55 >> 8 << v60) | (BYTE1(v55) >> v62)) << 8) | (((HIWORD(v55) << v60) | (BYTE2(v55) >> v62)) << 16) | (((HIBYTE(v55) << v60) | (HIBYTE(v55) >> v62)) << 24);
    unsigned int v56 = ((v56 << v60) | (v56 >> v62)) | (unsigned __int16)(((v56 >> 8 << v60) | (BYTE1(v56) >> v62)) << 8) | (((HIWORD(v56) << v60) | (BYTE2(v56) >> v62)) << 16) | (((HIBYTE(v56) << v60) | (HIBYTE(v56) >> v62)) << 24);
  }
  *(_DWORD *)this = *(_DWORD *)a3 ^ v52;
  *((_DWORD *)this + 1) = *((_DWORD *)a3 + 1) ^ v54;
  *((_DWORD *)this + 2) = *((_DWORD *)a3 + 2) ^ v55;
  *((_DWORD *)this + 3) = *((_DWORD *)a3 + 3) ^ v56;
  return *((unsigned int *)a2 + 3);
}

uint64_t HGString::push(HGString *this, HGShaderBinding *a2, const HGString *a3, BOOL a4, int a5, const HGLimits *a6)
{
  HGString::digest(this, (uint64_t)v39);
  HGString::digest(a3, (uint64_t)v36);
  long long v35 = 0u;
  memset(v34, 0, sizeof(v34));
  if (!LODWORD(v40[0])) {
    *((void *)this + 1) = 0;
  }
  uint64_t v11 = HGString::Digest::push((HGString::Digest *)v33, a2, (const HGString::Digest *)v39, (const HGString::Digest *)v36, a5, a6);
  if (v11 != -1)
  {
    LOBYTE(v32) = v38;
    HIBYTE(v32) = BYTE8(v35);
    HGString::appendHistory(this, &v32);
    if ((v37 & 0xFFFFFu) - 394305 >= 0xFFFFFECF)
    {
      arb::begin((string_t *)this, v40, (const HGLimits *)v34, v12);
      arb::write((string_t *)this, (string_t *)a2, (const HGShaderBinding *)v40, (const HGLimits *)0xFFFFFFFFLL, 0xFFFFFFFF, *(const HGLimits **)a3, 1, 0, v29, v30, *(int *)v31, v31[4]);
      arb::end((string_t *)this, (uint64_t)v34, v33, v16, v17, v18);
    }
    else
    {
      if ((v37 & 0xFFFFFu) - 394785 >= 0xFFFFFFEF)
      {
        glsl::begin((string_t *)this, v40, (const HGLimits *)v34, v12);
        double v21 = glsl::write(this, (string_t *)a2, (const HGShaderBinding *)0xFFFFFFFFLL, *(const HGLimits **)a3, 1, 0, v19, v20, v29, v30, *(int *)v31, v31[4]);
LABEL_19:
        glsl::end((string_t *)this, (uint64_t)v34, v33, 0, v21, v22, v23);
        return v11;
      }
      if ((v37 & 0xFFFFF) == 0x60B10)
      {
        int v13 = v34[0];
        uint64_t v14 = *((void *)this + 1);
        if (v14)
        {
          str_alloc((string_t *)this, v14);
          if (LODWORD(v40[0]) == v13) {
            goto LABEL_18;
          }
        }
        else
        {
          str_alloc((string_t *)this, 33);
          *((void *)this + 1) = 33;
          if (LODWORD(v40[0]) == v13)
          {
LABEL_18:
            metal::write(this, (string_t *)a2, (const HGShaderBinding *)v34, (const HGLimits *)0xFFFFFFFFLL, *(void *)a3, (const HGLimits *)1, 0, v15, v29, v30, *(int *)v31, v31[4]);
            goto LABEL_19;
          }
        }
        int v24 = v13 >> 4;
        uint64_t v25 = *(void *)this;
        *(_DWORD *)(v25 + 3) = 1818326117;
        *(_DWORD *)uint64_t v25 = 1699557167;
        if (v24 | v13 & 0xF)
        {
          *(unsigned char *)(v25 + 7) = v24 | 0x30;
          *(unsigned char *)(v25 + 8) = 46;
          int v26 = (void *)(v25 + 10);
          *(unsigned char *)(v25 + 9) = v13 & 0xF | 0x30;
        }
        else
        {
          int v26 = (void *)(v25 + 7);
        }
        uint64_t v27 = *(void *)this;
        memset(v26, 32, *(void *)this + 15 - (void)v26);
        qmemcpy((void *)(v27 + 15), "\n//LEN=0000000000\n", 18);
        goto LABEL_18;
      }
      return 0xFFFFFFFFLL;
    }
  }
  return v11;
}

double glsl::write(glsl *this, string_t *a2, const HGShaderBinding *a3, const HGLimits *__s1, int a5, const HGLimits *a6, unsigned int a7, const char *a8, BOOL a9, unsigned int a10, int a11, BOOL a12)
{
  unsigned int v303 = a6;
  unsigned int v301 = a3;
  uint64_t v14 = (unsigned __int8 *)__s1 + 33;
  int v13 = *((unsigned __int8 *)__s1 + 33);
  BOOL v15 = v13 == 35;
  if (v13 == 35)
  {
    if (!strncmp((const char *)__s1 + 33, "#ifndef GL_ES", 0xDuLL))
    {
      BOOL v302 = v15;
      if (*((void *)this + 1) == 33)
      {
        uint64_t v18 = *((void *)this + 2);
        if (v18)
        {
          if (*(void *)v18 <= 0x7AuLL)
          {
            unsigned int v19 = malloc_type_realloc(*(void **)(v18 + 16), 0x100uLL, 0xCCCD1039uLL);
            int v20 = (void *)*((void *)this + 2);
            v20[2] = v19;
            void *v20 = 256;
            *(void *)this = v19;
          }
        }
        else
        {
          str_alloc((string_t *)this, 122);
        }
        uint64_t v21 = *(void *)this;
        *((void *)this + 1) += 89;
        long long v17 = *((_OWORD *)v14 + 1);
        *(_OWORD *)(v21 + 33) = *(_OWORD *)v14;
        long long v22 = *((_OWORD *)v14 + 2);
        long long v23 = *((_OWORD *)v14 + 3);
        long long v24 = *((_OWORD *)v14 + 4);
        *(_OWORD *)(v21 + 106) = *(_OWORD *)(v14 + 73);
        *(_OWORD *)(v21 + 97) = v24;
        *(_OWORD *)(v21 + 81) = v23;
        *(_OWORD *)(v21 + 65) = v22;
        *(_OWORD *)(v21 + 49) = v17;
      }
      uint64_t v14 = (unsigned __int8 *)__s1 + 122;
      if (!*((unsigned char *)__s1 + 122)) {
        return *(double *)&v17;
      }
    }
    else
    {
      BOOL v302 = 0;
    }
  }
  else
  {
    BOOL v302 = 0;
    if (!*((unsigned char *)__s1 + 33)) {
      return *(double *)&v17;
    }
  }
  int v299 = 0;
  int v300 = 0;
  unsigned int v25 = 0;
  int v26 = v14;
  do
  {
LABEL_14:
    --v26;
    do
    {
      int v28 = *++v26;
      int v27 = v28;
    }
    while ((v28 - 33) > 0xFFFFFFDF);
    while (1)
    {
      if (v27 != 47)
      {
        if (!v27) {
          return *(double *)&v17;
        }
        if (v27 == 118)
        {
          if (!strncmp((const char *)v26 + 1, "ec4 main", 8uLL))
          {
            v26 += 9;
            if (a5)
            {
              uint64_t v48 = *((void *)this + 1);
              uint64_t v47 = *((void *)this + 2);
              unint64_t v49 = v48 + v26 - v14;
              if (v47)
              {
                if (v49 >= *(void *)v47)
                {
                  size_t v50 = (v49 + 255) & 0xFFFFFFFFFFFFFF00;
                  unsigned int v51 = malloc_type_realloc(*(void **)(v47 + 16), v50, 0xCCCD1039uLL);
                  unsigned int v52 = (size_t *)*((void *)this + 2);
                  v52[2] = (size_t)v51;
                  *unsigned int v52 = v50;
                  *(void *)this = v51;
                }
              }
              else
              {
                str_alloc((string_t *)this, v49);
              }
              uint64_t v81 = *(void *)this;
              *((void *)this + 1) += v26 - v14;
              memcpy((void *)(v81 + v48), v14, v26 - v14);
              signed int v82 = *((_DWORD *)a2 + 3);
              uint64_t v84 = *((void *)this + 1);
              uint64_t v83 = *((void *)this + 2);
              unint64_t v85 = v84 + 20;
              if (v83)
              {
                if (v85 >= *(void *)v83)
                {
                  string_t v86 = malloc_type_realloc(*(void **)(v83 + 16), (v84 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  unint64_t v87 = (unint64_t *)*((void *)this + 2);
                  v87[2] = (unint64_t)v86;
                  *unint64_t v87 = (v84 + 275) & 0xFFFFFFFFFFFFFF00;
                  *(void *)this = v86;
                }
              }
              else
              {
                str_alloc((string_t *)this, v85);
              }
              int v94 = (char *)(*(void *)this + v84);
              signed int v95 = v82;
LABEL_124:
              *((void *)this + 1) += itoa(v94, v95);
              uint64_t v14 = v26;
            }
            goto LABEL_218;
          }
          if (!strncmp((const char *)v26 + 1, "oid main", 8uLL))
          {
            if (a5)
            {
              uint64_t v54 = *((void *)this + 1);
              uint64_t v53 = *((void *)this + 2);
              unint64_t v55 = v54 + v26 - v14;
              if (v53)
              {
                if (v55 >= *(void *)v53)
                {
                  size_t v56 = (v55 + 255) & 0xFFFFFFFFFFFFFF00;
                  unsigned int v57 = malloc_type_realloc(*(void **)(v53 + 16), v56, 0xCCCD1039uLL);
                  unsigned int v58 = (size_t *)*((void *)this + 2);
                  v58[2] = (size_t)v57;
                  size_t *v58 = v56;
                  *(void *)this = v57;
                }
              }
              else
              {
                str_alloc((string_t *)this, v55);
              }
              uint64_t v99 = *(void *)this;
              *((void *)this + 1) += v26 - v14;
              memcpy((void *)(v99 + v54), v14, v26 - v14);
              if (v302)
              {
                uint64_t v101 = *((void *)this + 1);
                uint64_t v100 = *((void *)this + 2);
                unint64_t v102 = v101 + 9;
                if (v100)
                {
                  if (v102 >= *(void *)v100)
                  {
                    string_t v103 = malloc_type_realloc(*(void **)(v100 + 16), (v101 + 264) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    __int16 v104 = (unint64_t *)*((void *)this + 2);
                    v104[2] = (unint64_t)v103;
                    *__int16 v104 = (v101 + 264) & 0xFFFFFFFFFFFFFF00;
                    *(void *)this = v103;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v102);
                }
                uint64_t v132 = *(void *)this;
                *((void *)this + 1) += 9;
                uint64_t v133 = v132 + v101;
                *(void *)uint64_t v133 = *(void *)"defaultp ";
                *(unsigned char *)(v133 + 8) = 32;
              }
              uint64_t v135 = *((void *)this + 1);
              uint64_t v134 = *((void *)this + 2);
              unint64_t v136 = v135 + 9;
              if (v134)
              {
                if (v136 >= *(void *)v134)
                {
                  BOOL v137 = malloc_type_realloc(*(void **)(v134 + 16), (v135 + 264) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  string_t v138 = (unint64_t *)*((void *)this + 2);
                  v138[2] = (unint64_t)v137;
                  *string_t v138 = (v135 + 264) & 0xFFFFFFFFFFFFFF00;
                  *(void *)this = v137;
                }
              }
              else
              {
                str_alloc((string_t *)this, v136);
              }
              uint64_t v139 = *(void *)this;
              *((void *)this + 1) += 9;
              uint64_t v140 = v139 + v135;
              *(void *)uint64_t v140 = *(void *)"vec4 main";
              *(unsigned char *)(v140 + 8) = 110;
              signed int v141 = *((_DWORD *)a2 + 3);
              uint64_t v143 = *((void *)this + 1);
              uint64_t v142 = *((void *)this + 2);
              unint64_t v144 = v143 + 20;
              if (v142)
              {
                if (v144 >= *(void *)v142)
                {
                  char v145 = malloc_type_realloc(*(void **)(v142 + 16), (v143 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  int v146 = (unint64_t *)*((void *)this + 2);
                  v146[2] = (unint64_t)v145;
                  unint64_t *v146 = (v143 + 275) & 0xFFFFFFFFFFFFFF00;
                  *(void *)this = v145;
                }
              }
              else
              {
                str_alloc((string_t *)this, v144);
              }
              *((void *)this + 1) += itoa((char *)(*(void *)this + v143), v141);
              v26 += 9;
              int v299 = 1;
              uint64_t v14 = v26;
              goto LABEL_218;
            }
            int v299 = -1;
            int v63 = v26[9];
            v26 += 9;
            if (!v63) {
              return *(double *)&v17;
            }
          }
          else
          {
            do
              int v44 = *++v26;
            while ((ctype[2 * v44] & 0x40) != 0);
LABEL_218:
            if (!*v26) {
              return *(double *)&v17;
            }
          }
        }
        else
        {
          if (v27 != 116 || (a5 & 1) != 0)
          {
            switch(v27)
            {
              case 'g':
                if (v26[1] != 108 || v26[2] != 95) {
                  goto LABEL_91;
                }
                if (strncmp((const char *)v26 + 3, "TexCoord[", 9uLL))
                {
                  if ((a5 & 1) != 0 && !strncmp((const char *)v26 + 3, "FragColor", 9uLL))
                  {
                    uint64_t v212 = *((void *)this + 1);
                    uint64_t v211 = *((void *)this + 2);
                    unint64_t v213 = v212 + v26 - v14;
                    if (v211)
                    {
                      if (v213 >= *(void *)v211)
                      {
                        size_t v214 = (v213 + 255) & 0xFFFFFFFFFFFFFF00;
                        int v215 = malloc_type_realloc(*(void **)(v211 + 16), v214, 0xCCCD1039uLL);
                        int v216 = (size_t *)*((void *)this + 2);
                        v216[2] = (size_t)v215;
                        *int v216 = v214;
                        *(void *)this = v215;
                      }
                    }
                    else
                    {
                      str_alloc((string_t *)this, v213);
                    }
                    uint64_t v262 = *(void *)this;
                    *((void *)this + 1) += v26 - v14;
                    memcpy((void *)(v262 + v212), v14, v26 - v14);
                    uint64_t v264 = *((void *)this + 1);
                    uint64_t v263 = *((void *)this + 2);
                    unint64_t v265 = v264 + 12;
                    if (v263)
                    {
                      if (v265 >= *(void *)v263)
                      {
                        size_t v266 = malloc_type_realloc(*(void **)(v263 + 16), (v264 + 267) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                        unint64_t v267 = (unint64_t *)*((void *)this + 2);
                        v267[2] = (unint64_t)v266;
                        unint64_t *v267 = (v264 + 267) & 0xFFFFFFFFFFFFFF00;
                        *(void *)this = v266;
                      }
                    }
                    else
                    {
                      str_alloc((string_t *)this, v265);
                    }
                    uint64_t v281 = *(void *)this;
                    *((void *)this + 1) += 12;
                    uint64_t v282 = v281 + v264;
                    *(void *)uint64_t v282 = *(void *)"hg_FragColor";
                    *(_DWORD *)(v282 + 8) = 1919904879;
                    v26 += 12;
                    uint64_t v14 = v26;
                  }
                  else
                  {
                    do
                      int v46 = *++v26;
                    while ((ctype[2 * v46] & 0x40) != 0);
                  }
                  goto LABEL_218;
                }
                int64_t v176 = v26 + 11 - v14;
                uint64_t v178 = *((void *)this + 1);
                uint64_t v177 = *((void *)this + 2);
                unint64_t v179 = v178 + v176;
                if (v177)
                {
                  if (v179 >= *(void *)v177)
                  {
                    size_t v180 = (v179 + 255) & 0xFFFFFFFFFFFFFF00;
                    int v181 = malloc_type_realloc(*(void **)(v177 + 16), v180, 0xCCCD1039uLL);
                    __int16 v182 = (size_t *)*((void *)this + 2);
                    v182[2] = (size_t)v181;
                    *__int16 v182 = v180;
                    *(void *)this = v181;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v179);
                }
                uint64_t v207 = *(void *)this;
                *((void *)this + 1) += v176;
                memcpy((void *)(v207 + v178), v14, v26 + 11 - v14);
                int v208 = v26[11];
                if ((v208 - 58) >= 0xFFFFFFF6)
                {
                  unsigned int v25 = 0;
                  int v209 = v26 + 11;
                  do
                  {
                    unsigned int v25 = v208 + 10 * v25 - 48;
                    int v210 = *++v209;
                    int v208 = v210;
                  }
                  while ((v210 - 58) > 0xFFFFFFF5);
                }
                else
                {
                  unsigned int v25 = 0;
                  int v209 = 0;
                }
                if (v209) {
                  int v26 = v209;
                }
                else {
                  v26 += 11;
                }
                goto LABEL_301;
              case 'h':
                if (v26[1] != 103 || v26[2] != 95) {
                  goto LABEL_91;
                }
                if (strncmp((const char *)v26 + 3, "Texture", 7uLL))
                {
                  if (strncmp((const char *)v26 + 3, "TexCoord", 8uLL))
                  {
                    if (strncmp((const char *)v26 + 3, "ProgramLocal", 0xCuLL))
                    {
                      do
                        int v64 = *++v26;
                      while ((ctype[2 * v64] & 0x40) != 0);
                      goto LABEL_218;
                    }
                    int64_t v200 = v26 + 15 - v14;
                    uint64_t v202 = *((void *)this + 1);
                    uint64_t v201 = *((void *)this + 2);
                    unint64_t v203 = v202 + v200;
                    if (v201)
                    {
                      if (v203 >= *(void *)v201)
                      {
                        size_t v204 = (v203 + 255) & 0xFFFFFFFFFFFFFF00;
                        int16x8_t v205 = malloc_type_realloc(*(void **)(v201 + 16), v204, 0xCCCD1039uLL);
                        uint8x8_t v206 = (size_t *)*((void *)this + 2);
                        v206[2] = (size_t)v205;
                        *uint8x8_t v206 = v204;
                        *(void *)this = v205;
                      }
                    }
                    else
                    {
                      str_alloc((string_t *)this, v203);
                    }
                    uint64_t v247 = *(void *)this;
                    *((void *)this + 1) += v200;
                    memcpy((void *)(v247 + v202), v14, v26 + 15 - v14);
                    int v248 = v26[15];
                    if ((v248 - 58) >= 0xFFFFFFF6)
                    {
                      unsigned int v25 = 0;
                      unint64_t v249 = v26 + 15;
                      do
                      {
                        unsigned int v25 = v248 + 10 * v25 - 48;
                        int v250 = *++v249;
                        int v248 = v250;
                      }
                      while ((v250 - 58) > 0xFFFFFFF5);
                    }
                    else
                    {
                      unsigned int v25 = 0;
                      unint64_t v249 = 0;
                    }
                    if (v249) {
                      int v26 = v249;
                    }
                    else {
                      v26 += 15;
                    }
                    int v231 = *((_DWORD *)a2 + 4);
                    goto LABEL_302;
                  }
                  string_t v183 = v26 + 11;
                  if (a5)
                  {
                    uint64_t v193 = *((void *)this + 1);
                    uint64_t v192 = *((void *)this + 2);
                    unint64_t v194 = v193 + v183 - v14;
                    if (v192)
                    {
                      if (v194 >= *(void *)v192)
                      {
                        size_t v195 = (v194 + 255) & 0xFFFFFFFFFFFFFF00;
                        uint64_t v196 = malloc_type_realloc(*(void **)(v192 + 16), v195, 0xCCCD1039uLL);
                        __int16 v197 = (size_t *)*((void *)this + 2);
                        v197[2] = (size_t)v196;
                        *__int16 v197 = v195;
                        *(void *)this = v196;
                      }
                    }
                    else
                    {
                      str_alloc((string_t *)this, v194);
                    }
                    uint64_t v253 = *(void *)this;
                    *((void *)this + 1) += v183 - v14;
                    memcpy((void *)(v253 + v193), v14, v183 - v14);
                    int v254 = *v183;
                    if ((v254 - 58) >= 0xFFFFFFF6)
                    {
                      unsigned int v25 = 0;
                      unsigned int v255 = v26 + 11;
                      do
                      {
                        unsigned int v25 = v254 + 10 * v25 - 48;
                        int v256 = *++v255;
                        int v254 = v256;
                      }
                      while ((v256 - 58) > 0xFFFFFFF5);
                    }
                    else
                    {
                      unsigned int v25 = 0;
                      unsigned int v255 = 0;
                    }
                    if (v255) {
                      int v26 = v255;
                    }
                    else {
                      v26 += 11;
                    }
LABEL_301:
                    int v231 = *((_DWORD *)a2 + 2);
                    goto LABEL_302;
                  }
                  int v217 = *v183;
                  if ((v217 - 58) >= 0xFFFFFFF6)
                  {
                    unsigned int v25 = 0;
                    string_t v199 = v26 + 11;
                    do
                    {
                      unsigned int v25 = v217 + 10 * v25 - 48;
                      int v245 = *++v199;
                      int v217 = v245;
                    }
                    while ((v245 - 58) > 0xFFFFFFF5);
                  }
                  else
                  {
                    unsigned int v25 = 0;
                    string_t v199 = 0;
                  }
                  if (v303)
                  {
                    unsigned int v246 = v25;
                    if (((v303 >> v25) & 1) == 0) {
                      goto LABEL_323;
                    }
                  }
                  else
                  {
                    if (v301 == -1) {
                      goto LABEL_323;
                    }
                    unsigned int v246 = v25 - v301;
                    if (v25 < v301) {
                      goto LABEL_323;
                    }
                  }
                  if (v246 == -1)
                  {
LABEL_323:
                    uint64_t v276 = *((void *)this + 1);
                    uint64_t v275 = *((void *)this + 2);
                    unint64_t v277 = v276 + v183 - v14;
                    if (v275)
                    {
                      if (v277 >= *(void *)v275)
                      {
                        size_t v278 = (v277 + 255) & 0xFFFFFFFFFFFFFF00;
                        char v279 = malloc_type_realloc(*(void **)(v275 + 16), v278, 0xCCCD1039uLL);
                        string_t v280 = (size_t *)*((void *)this + 2);
                        v280[2] = (size_t)v279;
                        size_t *v280 = v278;
                        *(void *)this = v279;
                      }
                    }
                    else
                    {
                      str_alloc((string_t *)this, v277);
                    }
                    uint64_t v283 = *(void *)this;
                    *((void *)this + 1) += v183 - v14;
                    memcpy((void *)(v283 + v276), v14, v183 - v14);
                    int v252 = *((_DWORD *)a2 + 2);
LABEL_330:
                    uint64_t v285 = *((void *)this + 1);
                    uint64_t v284 = *((void *)this + 2);
                    unint64_t v286 = v285 + 20;
                    if (v284)
                    {
                      if (v286 >= *(void *)v284)
                      {
                        int v287 = malloc_type_realloc(*(void **)(v284 + 16), (v285 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                        string_t v288 = (unint64_t *)*((void *)this + 2);
                        v288[2] = (unint64_t)v287;
                        *string_t v288 = (v285 + 275) & 0xFFFFFFFFFFFFFF00;
                        *(void *)this = v287;
                      }
                    }
                    else
                    {
                      str_alloc((string_t *)this, v286);
                    }
                    *((void *)this + 1) += itoa((char *)(*(void *)this + v285), v252 + v25);
                    if (v199) {
                      int v26 = v199;
                    }
                    else {
                      int v26 = v183;
                    }
                    uint64_t v14 = v26;
                    goto LABEL_218;
                  }
                  if (!v199) {
                    string_t v199 = v26;
                  }
                  size_t v268 = v199 - v14;
                  for (unint64_t i = (const char *)v199; *i != 118 || strncmp(i, "varying", 7uLL); --i)
                    --v268;
                  uint64_t v271 = *((void *)this + 1);
                  uint64_t v270 = *((void *)this + 2);
                  unint64_t v272 = v271 + v268;
                  if (v270)
                  {
                    if (v272 >= *(void *)v270)
                    {
                      string_t v273 = malloc_type_realloc(*(void **)(v270 + 16), (v271 + v268 + 255) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      unint64_t v274 = (size_t *)*((void *)this + 2);
                      v274[2] = (size_t)v273;
                      size_t *v274 = (v271 + v268 + 255) & 0xFFFFFFFFFFFFFF00;
                      *(void *)this = v273;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)this, v272);
                  }
                  uint64_t v292 = *(void *)this;
                  *((void *)this + 1) += v268;
                  memcpy((void *)(v292 + v271), v14, v268);
                  int v290 = *v199;
                  if (*v199)
                  {
                    do
                    {
                      if (v290 == 59) {
                        break;
                      }
                      int v293 = *++v199;
                      int v290 = v293;
                    }
                    while (v293);
                  }
LABEL_347:
                  BOOL v41 = v290 == 59;
                  uint64_t v294 = v290 == 59;
                  if (v41) {
                    uint64_t v295 = v199 + 1;
                  }
                  else {
                    uint64_t v295 = v199;
                  }
                  if (*v295 == 10) {
                    ++v294;
                  }
                  int v26 = &v199[v294];
                  uint64_t v14 = &v199[v294];
                  goto LABEL_218;
                }
                string_t v183 = v26 + 10;
                if (a5)
                {
                  uint64_t v185 = *((void *)this + 1);
                  uint64_t v184 = *((void *)this + 2);
                  unint64_t v186 = v185 + v183 - v14;
                  if (v184)
                  {
                    if (v186 >= *(void *)v184)
                    {
                      size_t v187 = (v186 + 255) & 0xFFFFFFFFFFFFFF00;
                      int v188 = malloc_type_realloc(*(void **)(v184 + 16), v187, 0xCCCD1039uLL);
                      int v189 = (size_t *)*((void *)this + 2);
                      v189[2] = (size_t)v188;
                      size_t *v189 = v187;
                      *(void *)this = v188;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)this, v186);
                  }
                  uint64_t v227 = *(void *)this;
                  *((void *)this + 1) += v183 - v14;
                  memcpy((void *)(v227 + v185), v14, v183 - v14);
                  int v228 = *v183;
                  if ((v228 - 58) >= 0xFFFFFFF6)
                  {
                    unsigned int v25 = 0;
                    string_t v229 = v26 + 10;
                    do
                    {
                      unsigned int v25 = v228 + 10 * v25 - 48;
                      int v230 = *++v229;
                      int v228 = v230;
                    }
                    while ((v230 - 58) > 0xFFFFFFF5);
                  }
                  else
                  {
                    unsigned int v25 = 0;
                    string_t v229 = 0;
                  }
                  if (v229) {
                    int v26 = v229;
                  }
                  else {
                    v26 += 10;
                  }
                  int v231 = *((_DWORD *)a2 + 6);
LABEL_302:
                  uint64_t v258 = *((void *)this + 1);
                  uint64_t v257 = *((void *)this + 2);
                  unint64_t v259 = v258 + 20;
                  if (v257)
                  {
                    if (v259 >= *(void *)v257)
                    {
                      int v260 = malloc_type_realloc(*(void **)(v257 + 16), (v258 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      int v261 = (unint64_t *)*((void *)this + 2);
                      v261[2] = (unint64_t)v260;
                      *int v261 = (v258 + 275) & 0xFFFFFFFFFFFFFF00;
                      *(void *)this = v260;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)this, v259);
                  }
                  signed int v95 = v231 + v25;
                  int v94 = (char *)(*(void *)this + v258);
                  goto LABEL_124;
                }
                int v198 = *v183;
                if ((v198 - 58) >= 0xFFFFFFF6)
                {
                  unsigned int v25 = 0;
                  string_t v199 = v26 + 10;
                  do
                  {
                    unsigned int v25 = v198 + 10 * v25 - 48;
                    int v225 = *++v199;
                    int v198 = v225;
                  }
                  while ((v225 - 58) > 0xFFFFFFF5);
                }
                else
                {
                  unsigned int v25 = 0;
                  string_t v199 = 0;
                }
                if (v303)
                {
                  unsigned int v226 = v25;
                  if (((v303 >> v25) & 1) == 0) {
                    goto LABEL_274;
                  }
                }
                else
                {
                  if (v301 == -1) {
                    goto LABEL_274;
                  }
                  unsigned int v226 = v25 - v301;
                  if (v25 < v301) {
                    goto LABEL_274;
                  }
                }
                if (v226 != -1)
                {
                  if (!v199) {
                    string_t v199 = v26;
                  }
                  size_t v232 = v199 - v14;
                  for (uint64_t j = (const char *)v199; *j != 117 || strncmp(j, "uniform", 7uLL); --j)
                    --v232;
                  uint64_t v235 = *((void *)this + 1);
                  uint64_t v234 = *((void *)this + 2);
                  unint64_t v236 = v235 + v232;
                  if (v234)
                  {
                    if (v236 >= *(void *)v234)
                    {
                      int v237 = malloc_type_realloc(*(void **)(v234 + 16), (v235 + v232 + 255) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      string_t v238 = (size_t *)*((void *)this + 2);
                      v238[2] = (size_t)v237;
                      size_t *v238 = (v235 + v232 + 255) & 0xFFFFFFFFFFFFFF00;
                      *(void *)this = v237;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)this, v236);
                  }
                  uint64_t v289 = *(void *)this;
                  *((void *)this + 1) += v232;
                  memcpy((void *)(v289 + v235), v14, v232);
                  int v290 = *v199;
                  if (*v199)
                  {
                    do
                    {
                      if (v290 == 59) {
                        break;
                      }
                      int v291 = *++v199;
                      int v290 = v291;
                    }
                    while (v291);
                  }
                  goto LABEL_347;
                }
LABEL_274:
                uint64_t v240 = *((void *)this + 1);
                uint64_t v239 = *((void *)this + 2);
                unint64_t v241 = v240 + v183 - v14;
                if (v239)
                {
                  if (v241 >= *(void *)v239)
                  {
                    size_t v242 = (v241 + 255) & 0xFFFFFFFFFFFFFF00;
                    string_t v243 = malloc_type_realloc(*(void **)(v239 + 16), v242, 0xCCCD1039uLL);
                    string_t v244 = (size_t *)*((void *)this + 2);
                    v244[2] = (size_t)v243;
                    size_t *v244 = v242;
                    *(void *)this = v243;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v241);
                }
                uint64_t v251 = *(void *)this;
                *((void *)this + 1) += v183 - v14;
                memcpy((void *)(v251 + v240), v14, v183 - v14);
                int v252 = *((_DWORD *)a2 + 6);
                goto LABEL_330;
              case '{':
                if (v300 || v299 != 1)
                {
                  int v78 = v300 + 1;
LABEL_132:
                  int v300 = v78;
                  goto LABEL_133;
                }
                ++v26;
                uint64_t v73 = *((void *)this + 1);
                uint64_t v72 = *((void *)this + 2);
                unint64_t v74 = v73 + v26 - v14;
                if (v72)
                {
                  if (v74 >= *(void *)v72)
                  {
                    size_t v75 = (v74 + 255) & 0xFFFFFFFFFFFFFF00;
                    int v76 = malloc_type_realloc(*(void **)(v72 + 16), v75, 0xCCCD1039uLL);
                    int v77 = (size_t *)*((void *)this + 2);
                    v77[2] = (size_t)v76;
                    size_t *v77 = v75;
                    *(void *)this = v76;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v74);
                }
                uint64_t v147 = *(void *)this;
                *((void *)this + 1) += v26 - v14;
                memcpy((void *)(v147 + v73), v14, v26 - v14);
                uint64_t v149 = *((void *)this + 1);
                uint64_t v148 = *((void *)this + 2);
                if (v302)
                {
                  unint64_t v150 = v149 + 32;
                  if (v148)
                  {
                    if (v150 >= *(void *)v148)
                    {
                      int v151 = malloc_type_realloc(*(void **)(v148 + 16), (v149 + 287) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      unsigned int v152 = (unint64_t *)*((void *)this + 2);
                      v152[2] = (unint64_t)v151;
                      *unsigned int v152 = (v149 + 287) & 0xFFFFFFFFFFFFFF00;
                      *(void *)this = v151;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)this, v150);
                  }
                  uint64_t v190 = *(void *)this;
                  *((void *)this + 1) += 32;
                  *(void *)&long long v17 = *(void *)"\n    defaultp vec4 hg_FragColor;";
                  qmemcpy((void *)(v190 + v149), "\n    defaultp vec4 hg_FragColor;", 32);
                }
                else
                {
                  unint64_t v153 = v149 + 23;
                  if (v148)
                  {
                    if (v153 >= *(void *)v148)
                    {
                      int v154 = malloc_type_realloc(*(void **)(v148 + 16), (v149 + 278) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      char v155 = (unint64_t *)*((void *)this + 2);
                      v155[2] = (unint64_t)v154;
                      *char v155 = (v149 + 278) & 0xFFFFFFFFFFFFFF00;
                      *(void *)this = v154;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)this, v153);
                  }
                  uint64_t v191 = *(void *)this;
                  *((void *)this + 1) += 23;
                  *(void *)&long long v17 = *(void *)"\n    vec4 hg_FragColor;";
                  qmemcpy((void *)(v191 + v149), "\n    vec4 hg_FragColor;", 23);
                }
                int v299 = 1;
                int v300 = 1;
                uint64_t v14 = v26;
                goto LABEL_218;
              case '}':
                int v78 = v300 - 1;
                if (v300 != 1) {
                  goto LABEL_132;
                }
                if (v299 == -1)
                {
                  str_puts((string_t *)this, (const char *)v14, v26 - v14);
                  *(_WORD *)str_ext((string_t *)this, 2, 2) = 2685;
                  return *(double *)&v17;
                }
                if (v299 != 1) {
                  goto LABEL_132;
                }
                str_puts((string_t *)this, (const char *)v14, v26 - v14);
                qmemcpy((void *)str_ext((string_t *)this, 27, 27), "    return hg_FragColor;\n}\n", 27);
                *(void *)&long long v17 = *(void *)"hg_FragColor;\n}\n";
                return *(double *)&v17;
              default:
                if (v27 != 109 || !a5 || v26[1] != 97 || v26[2] != 105 || v26[3] != 110) {
                  goto LABEL_91;
                }
                v26 += 4;
                uint64_t v66 = *((void *)this + 1);
                uint64_t v65 = *((void *)this + 2);
                unint64_t v67 = v66 + v26 - v14;
                if (v65)
                {
                  if (v67 >= *(void *)v65)
                  {
                    size_t v68 = (v67 + 255) & 0xFFFFFFFFFFFFFF00;
                    int v69 = malloc_type_realloc(*(void **)(v65 + 16), v68, 0xCCCD1039uLL);
                    string_t v70 = (size_t *)*((void *)this + 2);
                    v70[2] = (size_t)v69;
                    size_t *v70 = v68;
                    *(void *)this = v69;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v67);
                }
                uint64_t v218 = *(void *)this;
                *((void *)this + 1) += v26 - v14;
                memcpy((void *)(v218 + v66), v14, v26 - v14);
                signed int v219 = *((_DWORD *)a2 + 3);
                uint64_t v221 = *((void *)this + 1);
                uint64_t v220 = *((void *)this + 2);
                unint64_t v222 = v221 + 20;
                if (v220)
                {
                  if (v222 >= *(void *)v220)
                  {
                    string_t v223 = malloc_type_realloc(*(void **)(v220 + 16), (v221 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    string_t v224 = (unint64_t *)*((void *)this + 2);
                    v224[2] = (unint64_t)v223;
                    *string_t v224 = (v221 + 275) & 0xFFFFFFFFFFFFFF00;
                    *(void *)this = v223;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v222);
                }
                int v94 = (char *)(*(void *)this + v221);
                signed int v95 = v219;
                goto LABEL_124;
            }
          }
          if (!strncmp((const char *)v26 + 1, "exture2DRect(hg_Texture", 0x17uLL))
          {
            char v60 = v26 + 24;
            int v59 = v26[24];
            if ((v59 - 58) >= 0xFFFFFFF6)
            {
              unsigned int v25 = 0;
              do
              {
                unsigned int v25 = v59 + 10 * v25 - 48;
                int v79 = *++v60;
                int v59 = v79;
              }
              while ((v79 - 58) > 0xFFFFFFF5);
            }
            else
            {
              char v60 = 0;
            }
            if (v303)
            {
              signed int v80 = v25;
              if (((v303 >> v25) & 1) == 0 || v25 == -1) {
                goto LABEL_120;
              }
            }
            else if (v301 == -1 || v25 < v301 || (signed int v80 = v25 - v301, v25 - v301 == -1))
            {
              do
LABEL_120:
                int v93 = *++v26;
              while ((ctype[2 * v93] & 0x40) != 0);
              goto LABEL_218;
            }
            uint64_t v89 = *((void *)this + 1);
            uint64_t v88 = *((void *)this + 2);
            unint64_t v90 = v89 + v26 - v14;
            if (v88)
            {
              if (v90 >= *(void *)v88)
              {
                size_t v297 = (v90 + 255) & 0xFFFFFFFFFFFFFF00;
                int v91 = malloc_type_realloc(*(void **)(v88 + 16), v297, 0xCCCD1039uLL);
                int v92 = (size_t *)*((void *)this + 2);
                v92[2] = (size_t)v91;
                *int v92 = v297;
                *(void *)this = v91;
              }
            }
            else
            {
              str_alloc((string_t *)this, v90);
            }
            uint64_t v111 = *(void *)this;
            *((void *)this + 1) += v26 - v14;
            memcpy((void *)(v111 + v89), v14, v26 - v14);
            uint64_t v113 = *((void *)this + 1);
            uint64_t v112 = *((void *)this + 2);
            unint64_t v114 = v113 + 4;
            if (v112)
            {
              if (v114 >= *(void *)v112)
              {
                unint64_t v115 = malloc_type_realloc(*(void **)(v112 + 16), (v113 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                int v116 = (unint64_t *)*((void *)this + 2);
                v116[2] = (unint64_t)v115;
                *int v116 = (v113 + 259) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v115;
              }
            }
            else
            {
              str_alloc((string_t *)this, v114);
            }
            uint64_t v117 = *(void *)this;
            *((void *)this + 1) += 4;
            *(_DWORD *)(v117 + v113) = 1852399981;
            uint64_t v119 = *((void *)this + 1);
            uint64_t v118 = *((void *)this + 2);
            unint64_t v120 = v119 + 20;
            if (v118)
            {
              if (v120 >= *(void *)v118)
              {
                unint64_t v121 = malloc_type_realloc(*(void **)(v118 + 16), (v119 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                int v122 = (unint64_t *)*((void *)this + 2);
                v122[2] = (unint64_t)v121;
                *int v122 = (v119 + 275) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v121;
              }
            }
            else
            {
              str_alloc((string_t *)this, v120);
            }
            uint64_t v123 = itoa((char *)(*(void *)this + v119), v80);
            uint64_t v124 = *((void *)this + 2);
            uint64_t v125 = *((void *)this + 1) + v123;
            *((void *)this + 1) = v125;
            unint64_t v126 = v125 + 1;
            if (v124)
            {
              if (v126 >= *(void *)v124)
              {
                unint64_t v127 = malloc_type_realloc(*(void **)(v124 + 16), (v125 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
                int v128 = (void *)*((void *)this + 2);
                v128[2] = v127;
                *int v128 = (v125 & 0xFFFFFFFFFFFFFF00) + 256;
                *(void *)this = v127;
              }
            }
            else
            {
              str_alloc((string_t *)this, v126);
            }
            uint64_t v129 = *(void *)this;
            ++*((void *)this + 1);
            *(unsigned char *)(v129 + v125) = 40;
            if (v60) {
              int v26 = v60;
            }
            int v130 = *v26;
            if (*v26)
            {
              do
              {
                if (v130 == 41) {
                  break;
                }
                int v131 = *++v26;
                int v130 = v131;
              }
              while (v131);
            }
          }
          else
          {
            if (strncmp((const char *)v26 + 1, "exture2D(hg_Texture", 0x13uLL))
            {
              do
                int v45 = *++v26;
              while ((ctype[2 * v45] & 0x40) != 0);
              goto LABEL_218;
            }
            char v62 = v26 + 20;
            int v61 = v26[20];
            if ((v61 - 58) >= 0xFFFFFFF6)
            {
              unsigned int v25 = 0;
              do
              {
                unsigned int v25 = v61 + 10 * v25 - 48;
                int v96 = *++v62;
                int v61 = v96;
              }
              while ((v96 - 58) > 0xFFFFFFF5);
            }
            else
            {
              char v62 = 0;
            }
            if (v303)
            {
              signed int v97 = v25;
              if (((v303 >> v25) & 1) == 0 || v25 == -1) {
                goto LABEL_146;
              }
            }
            else if (v301 == -1 || v25 < v301 || (signed int v97 = v25 - v301, v25 - v301 == -1))
            {
              do
LABEL_146:
                int v110 = *++v26;
              while ((ctype[2 * v110] & 0x40) != 0);
              goto LABEL_218;
            }
            uint64_t v106 = *((void *)this + 1);
            uint64_t v105 = *((void *)this + 2);
            unint64_t v107 = v106 + v26 - v14;
            if (v105)
            {
              if (v107 >= *(void *)v105)
              {
                size_t v298 = (v107 + 255) & 0xFFFFFFFFFFFFFF00;
                unint64_t v108 = malloc_type_realloc(*(void **)(v105 + 16), v298, 0xCCCD1039uLL);
                __int16 v109 = (size_t *)*((void *)this + 2);
                v109[2] = (size_t)v108;
                *__int16 v109 = v298;
                *(void *)this = v108;
              }
            }
            else
            {
              str_alloc((string_t *)this, v107);
            }
            uint64_t v156 = *(void *)this;
            *((void *)this + 1) += v26 - v14;
            memcpy((void *)(v156 + v106), v14, v26 - v14);
            uint64_t v158 = *((void *)this + 1);
            uint64_t v157 = *((void *)this + 2);
            unint64_t v159 = v158 + 4;
            if (v157)
            {
              if (v159 >= *(void *)v157)
              {
                int v160 = malloc_type_realloc(*(void **)(v157 + 16), (v158 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                string_t v161 = (unint64_t *)*((void *)this + 2);
                v161[2] = (unint64_t)v160;
                unint64_t *v161 = (v158 + 259) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v160;
              }
            }
            else
            {
              str_alloc((string_t *)this, v159);
            }
            uint64_t v162 = *(void *)this;
            *((void *)this + 1) += 4;
            *(_DWORD *)(v162 + v158) = 1852399981;
            uint64_t v164 = *((void *)this + 1);
            uint64_t v163 = *((void *)this + 2);
            unint64_t v165 = v164 + 20;
            if (v163)
            {
              if (v165 >= *(void *)v163)
              {
                string_t v166 = malloc_type_realloc(*(void **)(v163 + 16), (v164 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                string_t v167 = (unint64_t *)*((void *)this + 2);
                v167[2] = (unint64_t)v166;
                *string_t v167 = (v164 + 275) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v166;
              }
            }
            else
            {
              str_alloc((string_t *)this, v165);
            }
            uint64_t v168 = itoa((char *)(*(void *)this + v164), v97);
            uint64_t v169 = *((void *)this + 2);
            uint64_t v170 = *((void *)this + 1) + v168;
            *((void *)this + 1) = v170;
            unint64_t v171 = v170 + 1;
            if (v169)
            {
              if (v171 >= *(void *)v169)
              {
                __int16 v172 = malloc_type_realloc(*(void **)(v169 + 16), (v170 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
                int v173 = (void *)*((void *)this + 2);
                v173[2] = v172;
                *int v173 = (v170 & 0xFFFFFFFFFFFFFF00) + 256;
                *(void *)this = v172;
              }
            }
            else
            {
              str_alloc((string_t *)this, v171);
            }
            uint64_t v174 = *(void *)this;
            ++*((void *)this + 1);
            *(unsigned char *)(v174 + v170) = 40;
            if (v62) {
              int v26 = v62;
            }
            int v130 = *v26;
            if (*v26)
            {
              do
              {
                if (v130 == 41) {
                  break;
                }
                int v175 = *++v26;
                int v130 = v175;
              }
              while (v175);
            }
          }
          uint64_t v14 = v26;
          if (!v130) {
            return *(double *)&v17;
          }
        }
        goto LABEL_14;
      }
      if (v26[1] != 47) {
        break;
      }
      uint64_t v30 = *((void *)this + 1);
      uint64_t v29 = *((void *)this + 2);
      unint64_t v31 = v30 + v26 - v14;
      if (v29)
      {
        if (v31 < *(void *)v29)
        {
          __int16 v32 = *(char **)this;
          goto LABEL_32;
        }
        size_t v38 = (v31 + 255) & 0xFFFFFFFFFFFFFF00;
        __int16 v32 = (char *)malloc_type_realloc(*(void **)(v29 + 16), v38, 0xCCCD1039uLL);
        unsigned __int16 v39 = (size_t *)*((void *)this + 2);
        v39[2] = (size_t)v32;
        size_t *v39 = v38;
      }
      else
      {
        size_t v33 = (v31 + 255) & 0xFFFFFFFFFFFFFF00;
        int v34 = malloc_type_malloc(0x18uLL, 0x1010040A79CA2DEuLL);
        long long v35 = malloc_type_malloc(v33, 0x2BEB8FE7uLL);
        *((void *)v34 + 2) = v35;
        bzero(v35, v33);
        *((void *)v34 + 1) = 1;
        size_t v36 = *((void *)this + 1);
        if (v36) {
          memcpy(*((void **)v34 + 2), *(const void **)this, v36);
        }
        uint64_t v37 = *((void *)this + 2);
        if (v37) {
          --*(void *)(v37 + 8);
        }
        *(void *)int v34 = v33;
        *((void *)this + 2) = v34;
        __int16 v32 = (char *)*((void *)v34 + 2);
      }
      *(void *)this = v32;
LABEL_32:
      *((void *)this + 1) += v26 - v14;
      memcpy(&v32[v30], v14, v26 - v14);
      int v40 = *v26;
      if (*v26) {
        BOOL v41 = v40 == 10;
      }
      else {
        BOOL v41 = 1;
      }
      if (!v41)
      {
        do
        {
          int v42 = *++v26;
          int v40 = v42;
          if (v42) {
            BOOL v43 = v40 == 10;
          }
          else {
            BOOL v43 = 1;
          }
        }
        while (!v43);
      }
      if (v40 == 10) {
        ++v26;
      }
      int v27 = *v26;
      uint64_t v14 = v26;
    }
LABEL_91:
    if ((v27 - 48) >= 0xA && (ctype[2 * v27] & 0x40) != 0)
    {
      do
        int v71 = *++v26;
      while ((ctype[2 * v71] & 0x40) != 0);
      goto LABEL_218;
    }
LABEL_133:
    ;
  }
  while (*++v26);
  return *(double *)&v17;
}

void metal::write(metal *this, string_t *a2, const HGShaderBinding *a3, const HGLimits *a4, uint64_t a5, const HGLimits *a6, unsigned int a7, const char *a8, BOOL a9, unsigned int a10, int a11, BOOL a12)
{
  int v458 = (int)a6;
  unsigned int v459 = 0;
  __int16 v12 = (unsigned __int8 *)a5;
  unsigned int v453 = a4;
  if (!strncmp((const char *)(a5 + 16), "//LEN=", 6uLL))
  {
    atox(v12 + 22, &v459);
    if (v459 >= 0x22)
    {
      unsigned int v14 = 0;
      string_t v456 = &v12[v459];
      BOOL v15 = v12 + 33;
      while (1)
      {
        uint64_t v19 = 0;
        int v20 = v15 + 1;
        do
        {
          uint64_t v21 = v20;
          uint64_t v22 = v15[v19++];
          ++v20;
        }
        while ((v22 - 33) > 0xFFFFFFDF);
        uint64_t v18 = &v15[v19];
        long long v23 = &v15[v19 - 1];
        if (v22 != 47 || *v18 != 47) {
          break;
        }
        int64_t v24 = v15 - v12;
        size_t v25 = v15 - v12 + v19 - 1;
        uint64_t v27 = *((void *)this + 1);
        uint64_t v26 = *((void *)this + 2);
        unint64_t v28 = v25 + v27;
        if (v26)
        {
          if (v28 >= *(void *)v26)
          {
            uint64_t v29 = malloc_type_realloc(*(void **)(v26 + 16), (v27 + v24 + v19 + 254) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            uint64_t v30 = (unint64_t *)*((void *)this + 2);
            _OWORD v30[2] = (unint64_t)v29;
            *uint64_t v30 = (v27 + v24 + v19 + 254) & 0xFFFFFFFFFFFFFF00;
            *(void *)this = v29;
          }
        }
        else
        {
          str_alloc((string_t *)this, v28);
        }
        uint64_t v54 = *(void *)this;
        *((void *)this + 1) = *((void *)this + 1) + v24 + v19 - 1;
        memcpy((void *)(v54 + v27), v12, v25);
        int v55 = *v23;
        if (*v23) {
          BOOL v56 = v55 == 10;
        }
        else {
          BOOL v56 = 1;
        }
        if (!v56)
        {
          do
          {
            int v57 = *++v23;
            int v55 = v57;
            if (v57) {
              BOOL v58 = v55 == 10;
            }
            else {
              BOOL v58 = 1;
            }
          }
          while (!v58);
        }
        if (v55 == 10) {
          __int16 v12 = v23 + 1;
        }
        else {
          __int16 v12 = v23;
        }
LABEL_6:
        uint64_t v18 = v12;
LABEL_7:
        BOOL v15 = v18;
        if (v18 >= v456) {
          return;
        }
      }
      if (!strncmp((const char *)&v15[v19 - 1], "[[ visible ]]", 0xDuLL))
      {
        int64_t v37 = v15 - v12;
        size_t v38 = v15 - v12 + v19 - 1;
        uint64_t v40 = *((void *)this + 1);
        uint64_t v39 = *((void *)this + 2);
        unint64_t v41 = v38 + v40;
        if (v39)
        {
          if (v41 >= *(void *)v39)
          {
            int v42 = malloc_type_realloc(*(void **)(v39 + 16), (v40 + v37 + v19 + 254) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            BOOL v43 = (unint64_t *)*((void *)this + 2);
            v43[2] = (unint64_t)v42;
            *BOOL v43 = (v40 + v37 + v19 + 254) & 0xFFFFFFFFFFFFFF00;
            *(void *)this = v42;
          }
        }
        else
        {
          str_alloc((string_t *)this, v41);
        }
        uint64_t v47 = *(void *)this;
        *((void *)this + 1) = *((void *)this + 1) + v37 + v19 - 1;
        memcpy((void *)(v47 + v40), v12, v38);
        uint64_t v48 = (uint64_t)&v15[v19 - 1];
        int v49 = *v23;
        if (*v23)
        {
          do
          {
            if (v49 == 41) {
              break;
            }
            ++v21;
            int v50 = *(unsigned __int8 *)++v48;
            int v49 = v50;
          }
          while (v50);
        }
        BOOL v56 = v49 == 41;
        uint64_t v51 = v49 == 41;
        if (v56) {
          uint64_t v18 = (unsigned __int8 *)(v48 + 1);
        }
        else {
          uint64_t v18 = (unsigned __int8 *)v48;
        }
        int v52 = *v18;
        if (v52 != 59)
        {
          do
          {
            do
            {
              int v53 = v52;
              int v52 = v21[v51++];
            }
            while (v53 != 125);
          }
          while (v52 != 10);
          uint64_t v18 = &v21[v51 - 2];
        }
        __int16 v12 = &v15[v19 - 1];
        goto LABEL_7;
      }
      if (v458)
      {
        if (!strncmp((const char *)&v15[v19 - 1], "fragment ", 9uLL))
        {
          int64_t v61 = v15 - v12;
          uint64_t v63 = *((void *)this + 1);
          uint64_t v62 = *((void *)this + 2);
          unint64_t v64 = v15 - v12 + v19 - 1 + v63;
          if (v62)
          {
            if (v64 >= *(void *)v62)
            {
              uint64_t v65 = malloc_type_realloc(*(void **)(v62 + 16), (v63 + v61 + v19 + 254) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              uint64_t v66 = (unint64_t *)*((void *)this + 2);
              v66[2] = (unint64_t)v65;
              *uint64_t v66 = (v63 + v61 + v19 + 254) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v65;
            }
          }
          else
          {
            str_alloc((string_t *)this, v64);
          }
          uint64_t v86 = *(void *)this;
          *((void *)this + 1) = *((void *)this + 1) + v61 + v19 - 1;
          memcpy((void *)(v86 + v63), v12, v15 - v12 + v19 - 1);
          uint64_t v88 = *((void *)this + 1);
          uint64_t v87 = *((void *)this + 2);
          unint64_t v89 = v88 + 7;
          if (v87)
          {
            if (v89 >= *(void *)v87)
            {
              unint64_t v90 = malloc_type_realloc(*(void **)(v87 + 16), (v88 + 262) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              int v91 = (unint64_t *)*((void *)this + 2);
              v91[2] = (unint64_t)v90;
              unint64_t *v91 = (v88 + 262) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v90;
            }
          }
          else
          {
            str_alloc((string_t *)this, v89);
          }
          __int16 v12 = &v15[v19 + 8];
          uint64_t v16 = *(void *)this;
          *((void *)this + 1) += 7;
          long long v17 = (_DWORD *)(v16 + v88);
          *(_DWORD *)((char *)v17 + 3) = 543385972;
          *long long v17 = 1952543859;
          goto LABEL_6;
        }
        if (strncmp((const char *)&v15[v19 - 1], "fragmentFunc", 0xCuLL))
        {
LABEL_26:
          int v44 = &v15[v19];
          uint64_t v45 = (uint64_t)&v15[v19 + 9];
          if (strncmp((const char *)&v15[v19 - 1], "hg_Texture", 0xAuLL))
          {
            if (strncmp((const char *)&v15[v19 - 1], "hg_Sampler", 0xAuLL))
            {
              if (!strncmp((const char *)&v15[v19 - 1], "hg_Params[", 0xAuLL))
              {
                int64_t v71 = v15 - v12;
                size_t v72 = v15 - v12 + v19 + 9;
                uint64_t v74 = *((void *)this + 1);
                uint64_t v73 = *((void *)this + 2);
                unint64_t v75 = v72 + v74;
                if (v73)
                {
                  if (v75 >= *(void *)v73)
                  {
                    int v76 = malloc_type_realloc(*(void **)(v73 + 16), (v74 + v71 + v19 + 264) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    int v77 = (unint64_t *)*((void *)this + 2);
                    v77[2] = (unint64_t)v76;
                    unint64_t *v77 = (v74 + v71 + v19 + 264) & 0xFFFFFFFFFFFFFF00;
                    *(void *)this = v76;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v75);
                }
                uint64_t v318 = *(void *)this;
                *((void *)this + 1) += v71 + v19 + 9;
                memcpy((void *)(v318 + v74), v12, v72);
                int v319 = v44[9];
                __int16 v12 = &v15[v19 + 9];
                if ((v319 - 58) >= 0xFFFFFFF6)
                {
                  int v320 = 0;
                  __int16 v12 = &v15[v19 + 9];
                  do
                  {
                    int v320 = v319 + 10 * v320 - 48;
                    int v321 = *++v12;
                    int v319 = v321;
                  }
                  while ((v321 - 58) > 0xFFFFFFF5);
                  int v322 = *((_DWORD *)a2 + 4);
LABEL_395:
                  unsigned int v14 = v322 + v320;
                }
              }
              else
              {
                if (strncmp((const char *)&v15[v19 - 1], "_texCoord", 9uLL))
                {
                  if ((v22 - 48) < 0xA || (ctype[2 * v22] & 0x40) == 0) {
                    goto LABEL_7;
                  }
                  do
                    int v46 = *++v23;
                  while ((ctype[2 * v46] & 0x40) != 0);
                  goto LABEL_110;
                }
                int64_t v112 = v15 - v12;
                size_t v113 = v15 - v12 + v19 + 8;
                uint64_t v115 = *((void *)this + 1);
                uint64_t v114 = *((void *)this + 2);
                unint64_t v116 = v113 + v115;
                if (v114)
                {
                  if (v116 >= *(void *)v114)
                  {
                    uint64_t v117 = malloc_type_realloc(*(void **)(v114 + 16), (v115 + v112 + v19 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    uint64_t v118 = (unint64_t *)*((void *)this + 2);
                    v118[2] = (unint64_t)v117;
                    *uint64_t v118 = (v115 + v112 + v19 + 263) & 0xFFFFFFFFFFFFFF00;
                    *(void *)this = v117;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v116);
                }
                int v441 = &v15[v19];
                uint64_t v442 = *(void *)this;
                *((void *)this + 1) += v112 + v19 + 8;
                memcpy((void *)(v442 + v115), v12, v113);
                int v443 = v441[8];
                __int16 v12 = v441 + 8;
                if ((v443 - 58) >= 0xFFFFFFF6)
                {
                  int v320 = 0;
                  __int16 v12 = v441 + 8;
                  do
                  {
                    int v320 = v443 + 10 * v320 - 48;
                    int v444 = *++v12;
                    int v443 = v444;
                  }
                  while ((v444 - 58) > 0xFFFFFFF5);
                  int v322 = *((_DWORD *)a2 + 2);
                  goto LABEL_395;
                }
              }
              uint64_t v446 = *((void *)this + 1);
              uint64_t v445 = *((void *)this + 2);
              unint64_t v447 = v446 + 20;
              if (v445)
              {
                if (v447 >= *(void *)v445)
                {
                  char v448 = malloc_type_realloc(*(void **)(v445 + 16), (v446 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  string_t v449 = (unint64_t *)*((void *)this + 2);
                  v449[2] = (unint64_t)v448;
                  *string_t v449 = (v446 + 275) & 0xFFFFFFFFFFFFFF00;
                  *(void *)this = v448;
                }
              }
              else
              {
                str_alloc((string_t *)this, v447);
              }
              *((void *)this + 1) += itoa((char *)(*(void *)this + v446), v14);
              goto LABEL_6;
            }
            int v67 = v44[9];
            if ((v67 - 58) >= 0xFFFFFFF6)
            {
              unsigned int v14 = 0;
              unsigned int v68 = a7;
              do
              {
                unsigned int v14 = v67 + 10 * v14 - 48;
                int v99 = *(unsigned __int8 *)++v45;
                int v67 = v99;
              }
              while ((v99 - 58) > 0xFFFFFFF5);
            }
            else
            {
              uint64_t v45 = 0;
              unsigned int v68 = a7;
            }
            int v100 = v14 - v453;
            if (v14 < v453 || v453 == -1) {
              int v100 = -1;
            }
            if ((v68 >> v14)) {
              int v102 = v14;
            }
            else {
              int v102 = -1;
            }
            if (v68) {
              int v100 = v102;
            }
            if (v100 == -1 && v458 == 0)
            {
              int v452 = *((_DWORD *)a2 + 6);
              int64_t v105 = v15 - v12;
              size_t v106 = v15 - v12 + v19 - 1;
              uint64_t v108 = *((void *)this + 1);
              uint64_t v107 = *((void *)this + 2);
              unint64_t v109 = v106 + v108;
              if (v107)
              {
                if (v109 >= *(void *)v107)
                {
                  int v110 = malloc_type_realloc(*(void **)(v107 + 16), (v108 + v105 + v19 + 254) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  uint64_t v111 = (unint64_t *)*((void *)this + 2);
                  v111[2] = (unint64_t)v110;
                  *uint64_t v111 = (v108 + v105 + v19 + 254) & 0xFFFFFFFFFFFFFF00;
                  *(void *)this = v110;
                }
              }
              else
              {
                str_alloc((string_t *)this, v109);
              }
              uint64_t v373 = *(void *)this;
              *((void *)this + 1) = *((void *)this + 1) + v105 + v19 - 1;
              memcpy((void *)(v373 + v108), v12, v106);
              uint64_t v375 = *((void *)this + 1);
              uint64_t v374 = *((void *)this + 2);
              unint64_t v376 = v375 + 10;
              if (v374)
              {
                if (v376 >= *(void *)v374)
                {
                  int v377 = malloc_type_realloc(*(void **)(v374 + 16), (v375 + 265) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  int v378 = (unint64_t *)*((void *)this + 2);
                  v378[2] = (unint64_t)v377;
                  *int v378 = (v375 + 265) & 0xFFFFFFFFFFFFFF00;
                  *(void *)this = v377;
                }
              }
              else
              {
                str_alloc((string_t *)this, v376);
              }
              uint64_t v386 = *(void *)this;
              *((void *)this + 1) += 10;
              uint64_t v387 = v386 + v375;
              *(void *)uint64_t v387 = *(void *)"hg_Sampler";
              *(_WORD *)(v387 + 8) = 29285;
              uint64_t v389 = *((void *)this + 1);
              uint64_t v388 = *((void *)this + 2);
              unint64_t v390 = v389 + 20;
              if (v388)
              {
                if (v390 >= *(void *)v388)
                {
                  int v391 = malloc_type_realloc(*(void **)(v388 + 16), (v389 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  int v392 = (unint64_t *)*((void *)this + 2);
                  v392[2] = (unint64_t)v391;
                  *int v392 = (v389 + 275) & 0xFFFFFFFFFFFFFF00;
                  *(void *)this = v391;
                }
              }
              else
              {
                str_alloc((string_t *)this, v390);
              }
              *((void *)this + 1) += itoa((char *)(*(void *)this + v389), v452 + v14);
              if (v45) {
                __int16 v12 = (unsigned __int8 *)v45;
              }
              else {
                __int16 v12 = &v15[v19 - 1];
              }
              uint64_t v18 = v12;
              do
                int v394 = *++v18;
              while ((ctype[2 * v394] & 0x40) != 0);
              goto LABEL_7;
            }
            do
              int v104 = *++v23;
            while ((ctype[2 * v104] & 0x40) != 0);
LABEL_110:
            uint64_t v18 = v23;
            goto LABEL_7;
          }
          int v59 = v44[9];
          if ((v59 - 58) >= 0xFFFFFFF6)
          {
            unsigned int v14 = 0;
            unsigned int v60 = a7;
            do
            {
              unsigned int v14 = v59 + 10 * v14 - 48;
              int v69 = *(unsigned __int8 *)++v45;
              int v59 = v69;
            }
            while ((v69 - 58) > 0xFFFFFFF5);
          }
          else
          {
            uint64_t v45 = 0;
            unsigned int v60 = a7;
          }
          if (v60)
          {
            unsigned int v70 = v14;
            if (((v60 >> v14) & 1) == 0) {
              goto LABEL_82;
            }
          }
          else if (v453 == -1 || (unsigned int v70 = v14 - v453, v14 < v453))
          {
LABEL_82:
            if (!v458)
            {
              int64_t v92 = v15 - v12;
              size_t v93 = v15 - v12 + v19 - 1;
              uint64_t v95 = *((void *)this + 1);
              uint64_t v94 = *((void *)this + 2);
              unint64_t v96 = v93 + v95;
              int v451 = *((_DWORD *)a2 + 6);
              if (v94)
              {
                if (v96 >= *(void *)v94)
                {
                  signed int v97 = malloc_type_realloc(*(void **)(v94 + 16), (v95 + v92 + v19 + 254) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  string_t v98 = (unint64_t *)*((void *)this + 2);
                  v98[2] = (unint64_t)v97;
                  *string_t v98 = (v95 + v92 + v19 + 254) & 0xFFFFFFFFFFFFFF00;
                  *(void *)this = v97;
                }
              }
              else
              {
                str_alloc((string_t *)this, v96);
              }
              uint64_t v367 = *(void *)this;
              *((void *)this + 1) = *((void *)this + 1) + v92 + v19 - 1;
              memcpy((void *)(v367 + v95), v12, v93);
              uint64_t v369 = *((void *)this + 1);
              uint64_t v368 = *((void *)this + 2);
              unint64_t v370 = v369 + 10;
              if (v368)
              {
                if (v370 >= *(void *)v368)
                {
                  unsigned int v371 = malloc_type_realloc(*(void **)(v368 + 16), (v369 + 265) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  int v372 = (unint64_t *)*((void *)this + 2);
                  v372[2] = (unint64_t)v371;
                  unint64_t *v372 = (v369 + 265) & 0xFFFFFFFFFFFFFF00;
                  *(void *)this = v371;
                }
              }
              else
              {
                str_alloc((string_t *)this, v370);
              }
              uint64_t v379 = *(void *)this;
              *((void *)this + 1) += 10;
              uint64_t v380 = v379 + v369;
              *(void *)uint64_t v380 = *(void *)"hg_Texture";
              *(_WORD *)(v380 + 8) = 25970;
              uint64_t v382 = *((void *)this + 1);
              uint64_t v381 = *((void *)this + 2);
              unint64_t v383 = v382 + 20;
              if (v381)
              {
                if (v383 >= *(void *)v381)
                {
                  string_t v384 = malloc_type_realloc(*(void **)(v381 + 16), (v382 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  int v385 = (unint64_t *)*((void *)this + 2);
                  v385[2] = (unint64_t)v384;
                  *int v385 = (v382 + 275) & 0xFFFFFFFFFFFFFF00;
                  *(void *)this = v384;
                }
              }
              else
              {
                str_alloc((string_t *)this, v383);
              }
              *((void *)this + 1) += itoa((char *)(*(void *)this + v382), v451 + v14);
              if (v45) {
                __int16 v12 = (unsigned __int8 *)v45;
              }
              else {
                __int16 v12 = &v15[v19 - 1];
              }
              uint64_t v18 = v12;
              do
                int v393 = *++v18;
              while ((ctype[2 * v393] & 0x40) != 0);
              goto LABEL_7;
            }
            do
              int v85 = *++v23;
            while ((ctype[2 * v85] & 0x40) != 0);
            goto LABEL_110;
          }
          if (v70 == -1) {
            goto LABEL_82;
          }
          int v450 = v70;
          int64_t v78 = v15 - v12;
          size_t v79 = v15 - v12 + v19 - 1;
          uint64_t v81 = *((void *)this + 1);
          uint64_t v80 = *((void *)this + 2);
          unint64_t v82 = v79 + v81;
          if (v80)
          {
            if (v82 >= *(void *)v80)
            {
              uint64_t v83 = malloc_type_realloc(*(void **)(v80 + 16), (v81 + v78 + v19 + 254) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              uint64_t v84 = (unint64_t *)*((void *)this + 2);
              v84[2] = (unint64_t)v83;
              *uint64_t v84 = (v81 + v78 + v19 + 254) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v83;
            }
          }
          else
          {
            str_alloc((string_t *)this, v82);
          }
          uint64_t v323 = *(void *)this;
          *((void *)this + 1) = *((void *)this + 1) + v78 + v19 - 1;
          memcpy((void *)(v323 + v81), v12, v79);
          uint64_t v325 = *((void *)this + 1);
          uint64_t v324 = *((void *)this + 2);
          unint64_t v326 = v325 + 12;
          if (v324)
          {
            unsigned int v327 = v450;
            if (v326 >= *(void *)v324)
            {
              int16x8_t v328 = malloc_type_realloc(*(void **)(v324 + 16), (v325 + 267) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              uint8x8_t v329 = (unint64_t *)*((void *)this + 2);
              v329[2] = (unint64_t)v328;
              *uint8x8_t v329 = (v325 + 267) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v328;
            }
          }
          else
          {
            str_alloc((string_t *)this, v326);
            unsigned int v327 = v450;
          }
          uint64_t v330 = *(void *)this;
          *((void *)this + 1) += 12;
          uint64_t v331 = v330 + v325;
          *(void *)uint64_t v331 = *(void *)"fragmentFunc";
          *(_DWORD *)(v331 + 8) = 1668183366;
          uint64_t v333 = *((void *)this + 1);
          uint64_t v332 = *((void *)this + 2);
          unint64_t v334 = v333 + 20;
          if (v332)
          {
            if (v334 >= *(void *)v332)
            {
              char v335 = malloc_type_realloc(*(void **)(v332 + 16), (v333 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              string_t v336 = (unint64_t *)*((void *)this + 2);
              v336[2] = (unint64_t)v335;
              unint64_t *v336 = (v333 + 275) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v335;
            }
          }
          else
          {
            str_alloc((string_t *)this, v334);
          }
          uint64_t v337 = itoa((char *)(*(void *)this + v333), v327);
          uint64_t v338 = *((void *)this + 2);
          uint64_t v339 = *((void *)this + 1) + v337;
          *((void *)this + 1) = v339;
          unint64_t v340 = v339 + 1;
          if (v338)
          {
            if (v340 >= *(void *)v338)
            {
              string_t v341 = malloc_type_realloc(*(void **)(v338 + 16), (v339 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              unint64_t v342 = (void *)*((void *)this + 2);
              v342[2] = v341;
              void *v342 = (v339 & 0xFFFFFFFFFFFFFF00) + 256;
              *(void *)this = v341;
            }
          }
          else
          {
            str_alloc((string_t *)this, v340);
          }
          uint64_t v343 = *(void *)this;
          ++*((void *)this + 1);
          *(unsigned char *)(v343 + v339) = 40;
          uint64_t v345 = *((void *)this + 1);
          uint64_t v344 = *((void *)this + 2);
          unint64_t v346 = v345 + 4;
          if (v344)
          {
            if (v346 >= *(void *)v344)
            {
              string_t v347 = malloc_type_realloc(*(void **)(v344 + 16), (v345 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              unint64_t v348 = (unint64_t *)*((void *)this + 2);
              v348[2] = (unint64_t)v347;
              *unint64_t v348 = (v345 + 259) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v347;
            }
          }
          else
          {
            str_alloc((string_t *)this, v346);
          }
          uint64_t v349 = *(void *)this;
          *((void *)this + 1) += 4;
          *(_DWORD *)(v349 + v345) = 1734439526;
          uint64_t v351 = *((void *)this + 1);
          uint64_t v350 = *((void *)this + 2);
          unint64_t v352 = v351 + 2;
          if (v350)
          {
            if (v352 >= *(void *)v350)
            {
              string_t v353 = malloc_type_realloc(*(void **)(v350 + 16), (v351 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              unint64_t v354 = (unint64_t *)*((void *)this + 2);
              v354[2] = (unint64_t)v353;
              *unint64_t v354 = (v351 + 257) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v353;
            }
          }
          else
          {
            str_alloc((string_t *)this, v352);
          }
          uint64_t v355 = *(void *)this;
          *((void *)this + 1) += 2;
          *(_WORD *)(v355 + v351) = 8236;
          uint64_t v357 = *((void *)this + 1);
          uint64_t v356 = *((void *)this + 2);
          unint64_t v358 = v357 + 9;
          if (v356)
          {
            if (v358 >= *(void *)v356)
            {
              int32x2_t v359 = malloc_type_realloc(*(void **)(v356 + 16), (v357 + 264) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              int v360 = (unint64_t *)*((void *)this + 2);
              v360[2] = (unint64_t)v359;
              unint64_t *v360 = (v357 + 264) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v359;
            }
          }
          else
          {
            str_alloc((string_t *)this, v358);
          }
          uint64_t v361 = *(void *)this;
          *((void *)this + 1) += 9;
          uint64_t v362 = v361 + v357;
          *(void *)uint64_t v362 = *(void *)"hg_Params";
          *(unsigned char *)(v362 + 8) = 115;
          string_t v363 = (unsigned char *)*((void *)this + 3);
          if (v327)
          {
            if (v327 >= (unint64_t)((uint64_t)(*((void *)this + 4) - (void)v363) >> 1))
            {
              signed int v364 = 0;
              uint64_t v395 = 2 * v327;
              int v366 = v363[v395];
              if (!v363[v395])
              {
LABEL_379:
                if (v45) {
                  string_t v433 = (unsigned __int8 *)v45;
                }
                else {
                  string_t v433 = v23;
                }
                __int16 v12 = v433 + 1;
                int v434 = *v433;
                if (v434)
                {
                  do
                  {
                    if (v434 == 41) {
                      break;
                    }
                    int v434 = *v12++;
                  }
                  while (*(v12 - 1));
                }
                uint64_t v436 = *((void *)this + 1);
                uint64_t v435 = *((void *)this + 2);
                unint64_t v437 = v436 + 8;
                if (v435)
                {
                  if (v437 >= *(void *)v435)
                  {
                    uint64_t v438 = malloc_type_realloc(*(void **)(v435 + 16), (v436 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    string_t v439 = (unint64_t *)*((void *)this + 2);
                    v439[2] = (unint64_t)v438;
                    *string_t v439 = (v436 + 263) & 0xFFFFFFFFFFFFFF00;
                    *(void *)this = v438;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v437);
                }
                uint64_t v440 = *(void *)this;
                *((void *)this + 1) += 8;
                *(void *)(v440 + v436) = 0x30726F6C6F632E29;
                goto LABEL_6;
              }
            }
            else
            {
              signed int v364 = v363[2 * v327 - 1];
              uint64_t v365 = 2 * v327;
              int v366 = v363[v365];
              if (!v363[v365]) {
                goto LABEL_379;
              }
            }
          }
          else
          {
            signed int v364 = 0;
            int v366 = *v363;
            if (!*v363) {
              goto LABEL_379;
            }
          }
          uint64_t v396 = *((void *)this + 1);
          do
          {
            unint64_t v397 = v396 + 2;
            uint64_t v398 = *((void *)this + 2);
            if (v398)
            {
              if (v397 >= *(void *)v398)
              {
                string_t v399 = malloc_type_realloc(*(void **)(v398 + 16), (v396 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                uint64_t v400 = (unint64_t *)*((void *)this + 2);
                v400[2] = (unint64_t)v399;
                *uint64_t v400 = (v396 + 257) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v399;
              }
            }
            else
            {
              str_alloc((string_t *)this, v397);
            }
            uint64_t v401 = *(void *)this;
            *((void *)this + 1) += 2;
            *(_WORD *)(v401 + v396) = 8236;
            uint64_t v403 = *((void *)this + 1);
            uint64_t v402 = *((void *)this + 2);
            unint64_t v404 = v403 + 10;
            if (v402)
            {
              if (v404 >= *(void *)v402)
              {
                size_t v405 = malloc_type_realloc(*(void **)(v402 + 16), (v403 + 265) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                string_t v406 = (unint64_t *)*((void *)this + 2);
                v406[2] = (unint64_t)v405;
                *string_t v406 = (v403 + 265) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v405;
              }
            }
            else
            {
              str_alloc((string_t *)this, v404);
            }
            uint64_t v407 = *(void *)this;
            *((void *)this + 1) += 10;
            uint64_t v408 = v407 + v403;
            *(void *)uint64_t v408 = *(void *)"hg_Texture";
            *(_WORD *)(v408 + 8) = 25970;
            uint64_t v410 = *((void *)this + 1);
            uint64_t v409 = *((void *)this + 2);
            unint64_t v411 = v410 + 20;
            if (v409)
            {
              if (v411 >= *(void *)v409)
              {
                string_t v412 = malloc_type_realloc(*(void **)(v409 + 16), (v410 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                string_t v413 = (unint64_t *)*((void *)this + 2);
                v413[2] = (unint64_t)v412;
                *string_t v413 = (v410 + 275) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v412;
              }
            }
            else
            {
              str_alloc((string_t *)this, v411);
            }
            uint64_t v414 = itoa((char *)(*(void *)this + v410), v364);
            uint64_t v415 = *((void *)this + 2);
            uint64_t v416 = *((void *)this + 1) + v414;
            *((void *)this + 1) = v416;
            unint64_t v417 = v416 + 2;
            if (v415)
            {
              if (v417 >= *(void *)v415)
              {
                string_t v418 = malloc_type_realloc(*(void **)(v415 + 16), (v416 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                unint64_t v419 = (unint64_t *)*((void *)this + 2);
                v419[2] = (unint64_t)v418;
                *unint64_t v419 = (v416 + 257) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v418;
              }
            }
            else
            {
              str_alloc((string_t *)this, v417);
            }
            uint64_t v420 = *(void *)this;
            *((void *)this + 1) += 2;
            *(_WORD *)(v420 + v416) = 8236;
            uint64_t v422 = *((void *)this + 1);
            uint64_t v421 = *((void *)this + 2);
            unint64_t v423 = v422 + 10;
            if (v421)
            {
              if (v423 >= *(void *)v421)
              {
                unsigned int v424 = malloc_type_realloc(*(void **)(v421 + 16), (v422 + 265) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                unsigned int v425 = (unint64_t *)*((void *)this + 2);
                v425[2] = (unint64_t)v424;
                *unsigned int v425 = (v422 + 265) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v424;
              }
            }
            else
            {
              str_alloc((string_t *)this, v423);
            }
            uint64_t v426 = *(void *)this;
            *((void *)this + 1) += 10;
            uint64_t v427 = v426 + v422;
            *(void *)uint64_t v427 = *(void *)"hg_Sampler";
            *(_WORD *)(v427 + 8) = 29285;
            uint64_t v429 = *((void *)this + 1);
            uint64_t v428 = *((void *)this + 2);
            unint64_t v430 = v429 + 20;
            if (v428)
            {
              if (v430 >= *(void *)v428)
              {
                int v431 = malloc_type_realloc(*(void **)(v428 + 16), (v429 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                int v432 = (unint64_t *)*((void *)this + 2);
                v432[2] = (unint64_t)v431;
                unint64_t *v432 = (v429 + 275) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v431;
              }
            }
            else
            {
              str_alloc((string_t *)this, v430);
            }
            uint64_t v396 = *((void *)this + 1) + itoa((char *)(*(void *)this + v429), v364);
            *((void *)this + 1) = v396;
            ++v364;
            --v366;
          }
          while (v366);
          goto LABEL_379;
        }
        int64_t v31 = v15 - v12;
        uint64_t v33 = *((void *)this + 1);
        uint64_t v32 = *((void *)this + 2);
        unint64_t v34 = v15 - v12 + v19 + 11 + v33;
        if (v32)
        {
          if (v34 >= *(void *)v32)
          {
            long long v35 = malloc_type_realloc(*(void **)(v32 + 16), (v33 + v31 + v19 + 266) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            size_t v36 = (unint64_t *)*((void *)this + 2);
            v36[2] = (unint64_t)v35;
            *size_t v36 = (v33 + v31 + v19 + 266) & 0xFFFFFFFFFFFFFF00;
            *(void *)this = v35;
          }
        }
        else
        {
          str_alloc((string_t *)this, v34);
        }
        uint64_t v119 = *(void *)this;
        *((void *)this + 1) += v31 + v19 + 11;
        memcpy((void *)(v119 + v33), v12, v15 - v12 + v19 + 11);
        signed int v120 = *((_DWORD *)a2 + 3);
        uint64_t v122 = *((void *)this + 1);
        uint64_t v121 = *((void *)this + 2);
        unint64_t v123 = v122 + 20;
        if (v121)
        {
          if (v123 >= *(void *)v121)
          {
            uint64_t v124 = malloc_type_realloc(*(void **)(v121 + 16), (v122 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            uint64_t v125 = (unint64_t *)*((void *)this + 2);
            v125[2] = (unint64_t)v124;
            *uint64_t v125 = (v122 + 275) & 0xFFFFFFFFFFFFFF00;
            *(void *)this = v124;
          }
        }
        else
        {
          str_alloc((string_t *)this, v123);
        }
        uint64_t v18 = &v15[v19 + 11];
        *((void *)this + 1) += itoa((char *)(*(void *)this + v122), v120);
        __int16 v12 = v18;
        if (*v18 != 40) {
          goto LABEL_7;
        }
      }
      else
      {
        if (strncmp((const char *)&v15[v19 - 1], "fragmentFunc", 0xCuLL)) {
          goto LABEL_26;
        }
        uint64_t v18 = &v15[v19 + 11];
        if (*v18 != 40) {
          goto LABEL_7;
        }
      }
      uint64_t v127 = *((void *)this + 1);
      uint64_t v126 = *((void *)this + 2);
      unint64_t v128 = v127 + v18 - v12;
      if (v126)
      {
        if (v128 >= *(void *)v126)
        {
          size_t v129 = (v128 + 255) & 0xFFFFFFFFFFFFFF00;
          int v130 = malloc_type_realloc(*(void **)(v126 + 16), v129, 0xCCCD1039uLL);
          int v131 = (size_t *)*((void *)this + 2);
          v131[2] = (size_t)v130;
          *int v131 = v129;
          *(void *)this = v130;
        }
      }
      else
      {
        str_alloc((string_t *)this, v128);
      }
      uint64_t v132 = *(void *)this;
      *((void *)this + 1) += v18 - v12;
      memcpy((void *)(v132 + v127), v12, v18 - v12);
      __int16 v12 = &v15[v19 + 12];
      if (*v12 == 41)
      {
LABEL_128:
        if ((v458 & 1) != 0 || !*((unsigned char *)a3 + 40))
        {
LABEL_281:
          uint64_t v312 = *((void *)this + 1);
          uint64_t v311 = *((void *)this + 2);
          unint64_t v313 = v12 - v18 + v312;
          if (v311)
          {
            if (v313 >= *(void *)v311)
            {
              size_t v314 = (v313 + 255) & 0xFFFFFFFFFFFFFF00;
              int16x8_t v315 = malloc_type_realloc(*(void **)(v311 + 16), v314, 0xCCCD1039uLL);
              uint8x8_t v316 = (size_t *)*((void *)this + 2);
              v316[2] = (size_t)v315;
              *uint8x8_t v316 = v314;
              *(void *)this = v315;
            }
          }
          else
          {
            str_alloc((string_t *)this, v313);
          }
          uint64_t v317 = *(void *)this;
          *((void *)this + 1) += v12 - v18;
          memcpy((void *)(v317 + v312), v18, v12 - v18);
          goto LABEL_6;
        }
        unsigned int v133 = 0;
        while (1)
        {
          uint64_t v136 = *((void *)this + 1);
          uint64_t v135 = *((void *)this + 2);
          unint64_t v137 = v136 + 1;
          if (v135)
          {
            if (v137 >= *(void *)v135)
            {
              string_t v138 = malloc_type_realloc(*(void **)(v135 + 16), (v136 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              uint64_t v139 = (void *)*((void *)this + 2);
              v139[2] = v138;
              *uint64_t v139 = (v136 & 0xFFFFFFFFFFFFFF00) + 256;
              *(void *)this = v138;
            }
          }
          else
          {
            str_alloc((string_t *)this, v137);
          }
          uint64_t v140 = *(void *)this;
          ++*((void *)this + 1);
          *(unsigned char *)(v140 + v136) = 44;
          uint64_t v142 = *((void *)this + 1);
          uint64_t v141 = *((void *)this + 2);
          unint64_t v143 = v142 + 1;
          if (v141)
          {
            if (v143 >= *(void *)v141)
            {
              unint64_t v144 = malloc_type_realloc(*(void **)(v141 + 16), (v142 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              char v145 = (void *)*((void *)this + 2);
              v145[2] = v144;
              *char v145 = (v142 & 0xFFFFFFFFFFFFFF00) + 256;
              *(void *)this = v144;
            }
          }
          else
          {
            str_alloc((string_t *)this, v143);
          }
          uint64_t v146 = *(void *)this;
          ++*((void *)this + 1);
          *(unsigned char *)(v146 + v142) = 10;
          uint64_t v148 = *((void *)this + 1);
          uint64_t v147 = *((void *)this + 2);
          unint64_t v149 = v148 + 4;
          if (v147)
          {
            if (v149 >= *(void *)v147)
            {
              unint64_t v150 = malloc_type_realloc(*(void **)(v147 + 16), (v148 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              int v151 = (unint64_t *)*((void *)this + 2);
              v151[2] = (unint64_t)v150;
              *int v151 = (v148 + 259) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v150;
            }
          }
          else
          {
            str_alloc((string_t *)this, v149);
          }
          uint64_t v152 = *(void *)this;
          *((void *)this + 1) += 4;
          *(_DWORD *)(v152 + v148) = 538976288;
          uint64_t v154 = *((void *)this + 1);
          uint64_t v153 = *((void *)this + 2);
          unint64_t v155 = v154 + v12 - v18;
          if (v153)
          {
            if (v155 >= *(void *)v153)
            {
              size_t v156 = (v155 + 255) & 0xFFFFFFFFFFFFFF00;
              uint64_t v157 = malloc_type_realloc(*(void **)(v153 + 16), v156, 0xCCCD1039uLL);
              uint64_t v158 = (size_t *)*((void *)this + 2);
              v158[2] = (size_t)v157;
              size_t *v158 = v156;
              *(void *)this = v157;
            }
          }
          else
          {
            str_alloc((string_t *)this, v155);
          }
          uint64_t v159 = *(void *)this;
          *((void *)this + 1) += v12 - v18;
          memcpy((void *)(v159 + v154), v18, v12 - v18);
          if (v133 <= 7 && ((*((_DWORD *)a3 + 4) >> v133) & 1) != 0)
          {
            uint64_t v161 = *((void *)this + 1);
            uint64_t v160 = *((void *)this + 2);
            unint64_t v162 = v161 + 28;
            if (v160)
            {
              if (v162 >= *(void *)v160)
              {
                uint64_t v163 = malloc_type_realloc(*(void **)(v160 + 16), (v161 + 283) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                uint64_t v164 = (unint64_t *)*((void *)this + 2);
                v164[2] = (unint64_t)v163;
                *uint64_t v164 = (v161 + 283) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v163;
              }
            }
            else
            {
              str_alloc((string_t *)this, v162);
            }
            uint64_t v176 = *(void *)this;
            *((void *)this + 1) += 28;
            qmemcpy((void *)(v176 + v161), "texture2d< half > hg_Texture", 28);
            uint64_t v172 = *((void *)this + 1);
            uint64_t v171 = *((void *)this + 2);
            unint64_t v173 = v172 + 20;
            if (!v171) {
              goto LABEL_163;
            }
          }
          else
          {
            uint64_t v166 = *((void *)this + 1);
            uint64_t v165 = *((void *)this + 2);
            unint64_t v167 = v166 + 29;
            if (v165)
            {
              if (v167 >= *(void *)v165)
              {
                uint64_t v168 = malloc_type_realloc(*(void **)(v165 + 16), (v166 + 284) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                uint64_t v169 = (unint64_t *)*((void *)this + 2);
                v169[2] = (unint64_t)v168;
                *uint64_t v169 = (v166 + 284) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v168;
              }
            }
            else
            {
              str_alloc((string_t *)this, v167);
            }
            uint64_t v170 = *(void *)this;
            *((void *)this + 1) += 29;
            qmemcpy((void *)(v170 + v166), "texture2d< float > hg_Texture", 29);
            uint64_t v172 = *((void *)this + 1);
            uint64_t v171 = *((void *)this + 2);
            unint64_t v173 = v172 + 20;
            if (!v171)
            {
LABEL_163:
              str_alloc((string_t *)this, v173);
              goto LABEL_164;
            }
          }
          if (v173 >= *(void *)v171)
          {
            uint64_t v174 = malloc_type_realloc(*(void **)(v171 + 16), (v172 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            int v175 = (unint64_t *)*((void *)this + 2);
            v175[2] = (unint64_t)v174;
            *int v175 = (v172 + 275) & 0xFFFFFFFFFFFFFF00;
            *(void *)this = v174;
          }
LABEL_164:
          uint64_t v177 = itoa((char *)(*(void *)this + v172), v133);
          uint64_t v178 = *((void *)this + 2);
          uint64_t v179 = *((void *)this + 1) + v177;
          *((void *)this + 1) = v179;
          unint64_t v180 = v179 + 12;
          if (v178)
          {
            if (v180 >= *(void *)v178)
            {
              int v181 = malloc_type_realloc(*(void **)(v178 + 16), (v179 + 267) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              __int16 v182 = (unint64_t *)*((void *)this + 2);
              v182[2] = (unint64_t)v181;
              *__int16 v182 = (v179 + 267) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v181;
            }
          }
          else
          {
            str_alloc((string_t *)this, v180);
          }
          uint64_t v183 = *(void *)this;
          *((void *)this + 1) += 12;
          uint64_t v184 = v183 + v179;
          *(void *)uint64_t v184 = *(void *)" [[ texture(";
          *(_DWORD *)(v184 + 8) = 677737077;
          uint64_t v186 = *((void *)this + 1);
          uint64_t v185 = *((void *)this + 2);
          unint64_t v187 = v186 + 20;
          if (v185)
          {
            if (v187 >= *(void *)v185)
            {
              int v188 = malloc_type_realloc(*(void **)(v185 + 16), (v186 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              int v189 = (unint64_t *)*((void *)this + 2);
              v189[2] = (unint64_t)v188;
              unint64_t *v189 = (v186 + 275) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v188;
            }
          }
          else
          {
            str_alloc((string_t *)this, v187);
          }
          uint64_t v190 = itoa((char *)(*(void *)this + v186), v133);
          uint64_t v191 = *((void *)this + 2);
          uint64_t v192 = *((void *)this + 1) + v190;
          *((void *)this + 1) = v192;
          unint64_t v193 = v192 + 4;
          if (v191)
          {
            if (v193 >= *(void *)v191)
            {
              unint64_t v194 = malloc_type_realloc(*(void **)(v191 + 16), (v192 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              size_t v195 = (unint64_t *)*((void *)this + 2);
              v195[2] = (unint64_t)v194;
              unint64_t *v195 = (v192 + 259) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v194;
            }
          }
          else
          {
            str_alloc((string_t *)this, v193);
          }
          uint64_t v196 = *(void *)this;
          *((void *)this + 1) += 4;
          *(_DWORD *)(v196 + v192) = 1566384169;
          uint64_t v198 = *((void *)this + 1);
          uint64_t v197 = *((void *)this + 2);
          unint64_t v199 = v198 + 1;
          if (v197)
          {
            if (v199 >= *(void *)v197)
            {
              int64_t v200 = malloc_type_realloc(*(void **)(v197 + 16), (v198 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              uint64_t v201 = (void *)*((void *)this + 2);
              v201[2] = v200;
              *uint64_t v201 = (v198 & 0xFFFFFFFFFFFFFF00) + 256;
              *(void *)this = v200;
            }
          }
          else
          {
            str_alloc((string_t *)this, v199);
          }
          uint64_t v202 = *(void *)this;
          ++*((void *)this + 1);
          *(unsigned char *)(v202 + v198) = 44;
          uint64_t v204 = *((void *)this + 1);
          uint64_t v203 = *((void *)this + 2);
          unint64_t v205 = v204 + 1;
          if (v203)
          {
            if (v205 >= *(void *)v203)
            {
              uint8x8_t v206 = malloc_type_realloc(*(void **)(v203 + 16), (v204 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              uint64_t v207 = (void *)*((void *)this + 2);
              v207[2] = v206;
              *uint64_t v207 = (v204 & 0xFFFFFFFFFFFFFF00) + 256;
              *(void *)this = v206;
            }
          }
          else
          {
            str_alloc((string_t *)this, v205);
          }
          uint64_t v208 = *(void *)this;
          ++*((void *)this + 1);
          *(unsigned char *)(v208 + v204) = 10;
          uint64_t v210 = *((void *)this + 1);
          uint64_t v209 = *((void *)this + 2);
          unint64_t v211 = v210 + 4;
          if (v209)
          {
            if (v211 >= *(void *)v209)
            {
              uint64_t v212 = malloc_type_realloc(*(void **)(v209 + 16), (v210 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              unint64_t v213 = (unint64_t *)*((void *)this + 2);
              v213[2] = (unint64_t)v212;
              unint64_t *v213 = (v210 + 259) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v212;
            }
          }
          else
          {
            str_alloc((string_t *)this, v211);
          }
          uint64_t v214 = *(void *)this;
          *((void *)this + 1) += 4;
          *(_DWORD *)(v214 + v210) = 538976288;
          unint64_t v216 = *((void *)this + 1);
          uint64_t v215 = *((void *)this + 2);
          if (v215)
          {
            size_t v217 = *(void *)v215;
            if (v216 >= *(void *)v215)
            {
              size_t v217 = (v216 + 255) & 0xFFFFFFFFFFFFFF00;
              uint64_t v218 = malloc_type_realloc(*(void **)(v215 + 16), v217, 0xCCCD1039uLL);
              unint64_t v216 = *((void *)this + 1);
              uint64_t v215 = *((void *)this + 2);
              *(void *)(v215 + 16) = v218;
              *(void *)uint64_t v215 = v217;
              *(void *)this = v218;
            }
            unint64_t v219 = v216 + 18;
            if (v216 + 18 < v217) {
              goto LABEL_197;
            }
LABEL_195:
            size_t v220 = (v219 + 255) & 0xFFFFFFFFFFFFFF00;
            uint64_t v221 = malloc_type_realloc(*(void **)(v215 + 16), v220, 0xCCCD1039uLL);
            unint64_t v222 = (size_t *)*((void *)this + 2);
            v222[2] = (size_t)v221;
            *unint64_t v222 = v220;
            *(void *)this = v221;
            goto LABEL_197;
          }
          str_alloc((string_t *)this, *((void *)this + 1));
          unint64_t v216 = *((void *)this + 1);
          uint64_t v215 = *((void *)this + 2);
          unint64_t v219 = v216 + 18;
          if (!v215)
          {
            str_alloc((string_t *)this, v219);
            goto LABEL_197;
          }
          if (v219 >= *(void *)v215) {
            goto LABEL_195;
          }
LABEL_197:
          uint64_t v223 = *(void *)this;
          *((void *)this + 1) += 18;
          uint64_t v224 = v223 + v216;
          *(_OWORD *)uint64_t v224 = *(_OWORD *)"sampler hg_Sampler";
          *(_WORD *)(v224 + 16) = 29285;
          uint64_t v226 = *((void *)this + 1);
          uint64_t v225 = *((void *)this + 2);
          unint64_t v227 = v226 + 20;
          if (v225)
          {
            if (v227 >= *(void *)v225)
            {
              int v228 = malloc_type_realloc(*(void **)(v225 + 16), (v226 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              string_t v229 = (unint64_t *)*((void *)this + 2);
              v229[2] = (unint64_t)v228;
              *string_t v229 = (v226 + 275) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v228;
            }
          }
          else
          {
            str_alloc((string_t *)this, v227);
          }
          uint64_t v230 = itoa((char *)(*(void *)this + v226), v133);
          uint64_t v231 = *((void *)this + 2);
          uint64_t v232 = *((void *)this + 1) + v230;
          *((void *)this + 1) = v232;
          unint64_t v233 = v232 + 12;
          if (v231)
          {
            if (v233 >= *(void *)v231)
            {
              uint64_t v234 = malloc_type_realloc(*(void **)(v231 + 16), (v232 + 267) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              uint64_t v235 = (unint64_t *)*((void *)this + 2);
              v235[2] = (unint64_t)v234;
              *uint64_t v235 = (v232 + 267) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v234;
            }
          }
          else
          {
            str_alloc((string_t *)this, v233);
          }
          uint64_t v236 = *(void *)this;
          *((void *)this + 1) += 12;
          uint64_t v237 = v236 + v232;
          *(void *)uint64_t v237 = *(void *)" [[ sampler(";
          *(_DWORD *)(v237 + 8) = 678585708;
          uint64_t v239 = *((void *)this + 1);
          uint64_t v238 = *((void *)this + 2);
          unint64_t v240 = v239 + 20;
          if (v238)
          {
            if (v240 >= *(void *)v238)
            {
              unint64_t v241 = malloc_type_realloc(*(void **)(v238 + 16), (v239 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              size_t v242 = (unint64_t *)*((void *)this + 2);
              v242[2] = (unint64_t)v241;
              unint64_t *v242 = (v239 + 275) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v241;
            }
          }
          else
          {
            str_alloc((string_t *)this, v240);
          }
          uint64_t v243 = itoa((char *)(*(void *)this + v239), v133);
          uint64_t v244 = *((void *)this + 2);
          uint64_t v245 = *((void *)this + 1) + v243;
          *((void *)this + 1) = v245;
          unint64_t v246 = v245 + 4;
          if (v244)
          {
            if (v246 >= *(void *)v244)
            {
              uint64_t v247 = malloc_type_realloc(*(void **)(v244 + 16), (v245 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              int v248 = (unint64_t *)*((void *)this + 2);
              v248[2] = (unint64_t)v247;
              *int v248 = (v245 + 259) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v247;
            }
          }
          else
          {
            str_alloc((string_t *)this, v246);
          }
          uint64_t v134 = *(void *)this;
          *((void *)this + 1) += 4;
          *(_DWORD *)(v134 + v245) = 1566384169;
          ++v133;
          uint64_t v18 = v12;
          if (v133 >= *((unsigned __int8 *)a3 + 40))
          {
            uint64_t v18 = v12;
            goto LABEL_281;
          }
        }
      }
      uint64_t v249 = (uint64_t)&v15[v19 + 12];
      while (1)
      {
        uint64_t v253 = 0;
        int v254 = (unsigned __int8 *)(v249 + 12);
        uint64_t v255 = v249 + 1;
        do
        {
          int v256 = v254;
          uint64_t v257 = *(unsigned __int8 *)(v249 + v253);
          uint64_t v258 = (unsigned __int8 *)v255;
          ++v253;
          ++v254;
          ++v255;
        }
        while ((v257 - 33) > 0xFFFFFFDF);
        __int16 v12 = (unsigned __int8 *)(v249 + v253);
        unint64_t v259 = (const char *)(v249 + v253 - 1);
        if (!strncmp(v259, "[[ stage_in", 0xBuLL)) {
          break;
        }
        if (!strncmp((const char *)(v249 + v253 - 1), "[[ buffer(", 0xAuLL))
        {
          uint64_t v267 = v249 - (void)v18;
          uint64_t v269 = *((void *)this + 1);
          uint64_t v268 = *((void *)this + 2);
          unint64_t v270 = v249 - (void)v18 + v253 - 2 + v269;
          if (v268)
          {
            if (v270 >= *(void *)v268)
            {
              uint64_t v271 = malloc_type_realloc(*(void **)(v268 + 16), (v269 + v267 + v253 + 253) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              unint64_t v272 = (unint64_t *)*((void *)this + 2);
              v272[2] = (unint64_t)v271;
              *unint64_t v272 = (v269 + v267 + v253 + 253) & 0xFFFFFFFFFFFFFF00;
              *(void *)this = v271;
            }
          }
          else
          {
            str_alloc((string_t *)this, v270);
          }
          uint64_t v299 = v249 + v253 - 2;
          uint64_t v300 = *(void *)this;
          *((void *)this + 1) = *((void *)this + 1) + v267 + v253 - 2;
          memcpy((void *)(v300 + v269), v18, v249 - (void)v18 + v253 - 2);
          uint64_t v301 = 0;
          uint64_t v302 = v249 + v253;
          while (*(unsigned char *)(v302 + v301 - 2) != 93 || *(unsigned char *)(v302 + v301 - 1) != 93)
            ++v301;
          uint64_t v18 = (unsigned __int8 *)(v249 + v253 + v301);
          if ((v458 & 1) == 0)
          {
            size_t v285 = v301 + 2;
            uint64_t v304 = *((void *)this + 1);
            uint64_t v303 = *((void *)this + 2);
            unint64_t v305 = v301 + 2 + v304;
            if (v303)
            {
              if (v305 >= *(void *)v303)
              {
                int v306 = malloc_type_realloc(*(void **)(v303 + 16), (v304 + v301 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                int v307 = (unint64_t *)*((void *)this + 2);
                v307[2] = (unint64_t)v306;
                *int v307 = (v304 + v301 + 257) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v306;
              }
            }
            else
            {
              str_alloc((string_t *)this, v305);
            }
            uint64_t v308 = *(void *)this;
            *((void *)this + 1) += v301 + 2;
            uint64_t v251 = (void *)(v308 + v304);
            int v252 = (const void *)v299;
            goto LABEL_215;
          }
          goto LABEL_216;
        }
        if (!strncmp((const char *)(v249 + v253 - 1), "[[ texture(", 0xBuLL))
        {
          int v273 = v12[10];
          if ((v273 - 58) >= 0xFFFFFFF6)
          {
            unsigned int v14 = 0;
            do
            {
              unsigned int v14 = v273 + 10 * v14 - 48;
              int v274 = *v256++;
              int v273 = v274;
            }
            while ((v274 - 58) > 0xFFFFFFF5);
          }
          if (v458)
          {
            uint64_t v275 = v249 - (void)v18;
            uint64_t v277 = *((void *)this + 1);
            uint64_t v276 = *((void *)this + 2);
            unint64_t v278 = v275 + v253 - 2 + v277;
            if (v276)
            {
              if (v278 >= *(void *)v276)
              {
                char v279 = malloc_type_realloc(*(void **)(v276 + 16), (v277 + v275 + v253 + 253) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                string_t v280 = (unint64_t *)*((void *)this + 2);
                v280[2] = (unint64_t)v279;
                unint64_t *v280 = (v277 + v275 + v253 + 253) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v279;
              }
            }
            else
            {
              str_alloc((string_t *)this, v278);
            }
            uint64_t v309 = *(void *)this;
            *((void *)this + 1) = *((void *)this + 1) + v275 + v253 - 2;
            memcpy((void *)(v309 + v277), v18, v275 + v253 - 2);
          }
          while (*(v258 - 2) != 93 || *(v258 - 1) != 93)
            ++v258;
        }
        else
        {
          if (strncmp((const char *)(v249 + v253 - 1), "[[ sampler(", 0xBuLL))
          {
            if ((v257 - 48) >= 0xA && (ctype[2 * v257] & 0x40) != 0)
            {
              do
                int v260 = *(unsigned __int8 *)++v259;
              while ((ctype[2 * v260] & 0x40) != 0);
              __int16 v12 = (unsigned __int8 *)v259;
            }
            goto LABEL_217;
          }
          int v291 = v12[10];
          if ((v291 - 58) >= 0xFFFFFFF6)
          {
            unsigned int v14 = 0;
            do
            {
              unsigned int v14 = v291 + 10 * v14 - 48;
              int v292 = *v256++;
              int v291 = v292;
            }
            while ((v292 - 58) > 0xFFFFFFF5);
          }
          if (v458)
          {
            uint64_t v293 = v249 - (void)v18;
            uint64_t v295 = *((void *)this + 1);
            uint64_t v294 = *((void *)this + 2);
            unint64_t v296 = v293 + v253 - 2 + v295;
            if (v294)
            {
              if (v296 >= *(void *)v294)
              {
                size_t v297 = malloc_type_realloc(*(void **)(v294 + 16), (v295 + v293 + v253 + 253) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                size_t v298 = (unint64_t *)*((void *)this + 2);
                v298[2] = (unint64_t)v297;
                *size_t v298 = (v295 + v293 + v253 + 253) & 0xFFFFFFFFFFFFFF00;
                *(void *)this = v297;
              }
            }
            else
            {
              str_alloc((string_t *)this, v296);
            }
            uint64_t v310 = *(void *)this;
            *((void *)this + 1) = *((void *)this + 1) + v293 + v253 - 2;
            memcpy((void *)(v310 + v295), v18, v293 + v253 - 2);
          }
          while (*(v258 - 2) != 93 || *(v258 - 1) != 93)
            ++v258;
        }
        uint64_t v18 = v258;
        __int16 v12 = v258;
LABEL_217:
        uint64_t v249 = (uint64_t)v12;
        if (*v12 == 41) {
          goto LABEL_128;
        }
      }
      uint64_t v261 = v249 - (void)v18;
      uint64_t v263 = *((void *)this + 1);
      uint64_t v262 = *((void *)this + 2);
      unint64_t v264 = v249 - (void)v18 + v253 - 2 + v263;
      if (v262)
      {
        if (v264 >= *(void *)v262)
        {
          unint64_t v265 = malloc_type_realloc(*(void **)(v262 + 16), (v263 + v261 + v253 + 253) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          size_t v266 = (unint64_t *)*((void *)this + 2);
          v266[2] = (unint64_t)v265;
          *size_t v266 = (v263 + v261 + v253 + 253) & 0xFFFFFFFFFFFFFF00;
          *(void *)this = v265;
        }
      }
      else
      {
        str_alloc((string_t *)this, v264);
      }
      uint64_t v281 = v12 - 2;
      uint64_t v282 = *(void *)this;
      *((void *)this + 1) = *((void *)this + 1) + v261 + v253 - 2;
      memcpy((void *)(v282 + v263), v18, v249 - (void)v18 + v253 - 2);
      uint64_t v283 = 0;
      uint64_t v284 = v249 + v253;
      while (*(unsigned char *)(v284 + v283 - 2) != 93 || *(unsigned char *)(v284 + v283 - 1) != 93)
        ++v283;
      uint64_t v18 = (unsigned __int8 *)(v249 + v253 + v283);
      if ((v458 & 1) == 0)
      {
        size_t v285 = v283 + 2;
        uint64_t v287 = *((void *)this + 1);
        uint64_t v286 = *((void *)this + 2);
        unint64_t v288 = v283 + 2 + v287;
        if (v286)
        {
          if (v288 >= *(void *)v286)
          {
            uint64_t v289 = malloc_type_realloc(*(void **)(v286 + 16), (v287 + v283 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            int v290 = (unint64_t *)*((void *)this + 2);
            v290[2] = (unint64_t)v289;
            *int v290 = (v287 + v283 + 257) & 0xFFFFFFFFFFFFFF00;
            *(void *)this = v289;
          }
        }
        else
        {
          str_alloc((string_t *)this, v288);
        }
        uint64_t v250 = *(void *)this;
        *((void *)this + 1) += v283 + 2;
        uint64_t v251 = (void *)(v250 + v287);
        int v252 = v281;
LABEL_215:
        memcpy(v251, v252, v285);
      }
LABEL_216:
      __int16 v12 = v18;
      goto LABEL_217;
    }
  }
}

uint64_t HGString::Digest::pop(HGString::Digest *this, HGShaderBinding *a2, const HGString::Digest *a3, const HGString::Digest *a4, int a5, const HGLimits *a6)
{
  unsigned int v6 = *((_DWORD *)a3 + 4);
  int v7 = v6 & 0xFFFFF;
  if ((v6 & 0xFFFFF) - 394305 > 0xFFFFFECE)
  {
    unsigned int v9 = *((_DWORD *)a4 + 4);
    if ((v9 & 0xFFFFF) - 394305 >= 0xFFFFFECF) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }
  BOOL v8 = v7 != 396048 && (v7 - 394768) >= 0x11;
  if (v8)
  {
    if (*((_DWORD *)a4 + 4))
    {
      *((_DWORD *)a2 + 8) = 0;
      *(_OWORD *)a2 = 0u;
      *((_OWORD *)a2 + 1) = 0u;
      long long v11 = *(_OWORD *)a4;
      long long v12 = *((_OWORD *)a4 + 1);
      long long v13 = *((_OWORD *)a4 + 3);
      *((_OWORD *)this + 2) = *((_OWORD *)a4 + 2);
      *((_OWORD *)this + 3) = v13;
      *(_OWORD *)this = v11;
      *((_OWORD *)this + 1) = v12;
      return *((unsigned __int8 *)a4 + 58);
    }
    return 0xFFFFFFFFLL;
  }
  if ((v7 - 394785) >= 0xFFFFFFEF)
  {
    unsigned int v9 = *((_DWORD *)a4 + 4);
    if ((v9 & 0xFFFFF) - 394785 >= 0xFFFFFFEF) {
      goto LABEL_18;
    }
LABEL_12:
    if (!*((_DWORD *)a4 + 4)) {
      return *((unsigned __int8 *)a3 + 58);
    }
    return 0xFFFFFFFFLL;
  }
  if (v7 != 396048) {
    goto LABEL_12;
  }
  unsigned int v9 = *((_DWORD *)a4 + 4);
  if ((v9 & 0xFFFFF) != 0x60B10)
  {
    if (!v9) {
      return *((unsigned __int8 *)a3 + 58);
    }
    return 0xFFFFFFFFLL;
  }
LABEL_18:
  int v15 = *((_DWORD *)a3 + 5);
  int v16 = *((_DWORD *)a4 + 5);
  if ((v16 & v15 & 0x8000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if (!*((unsigned char *)a4 + 56))
  {
    int v18 = 0;
LABEL_33:
    unsigned int v22 = 0;
    unsigned int v23 = *((unsigned __int8 *)a3 + 52) - v18;
    goto LABEL_35;
  }
  int v17 = 0;
  int v18 = 0;
  int v19 = -1;
  do
  {
    if (((1 << v17) & a5) != 0) {
      ++v18;
    }
    if (v19 == -1 && ((1 << v17) & a5) == 0) {
      int v19 = v17;
    }
    ++v17;
  }
  while (*((unsigned __int8 *)a4 + 56) != v17);
  if (v19 == -1) {
    goto LABEL_33;
  }
  unsigned int v21 = *((unsigned __int16 *)a3 + 26);
  if (v21 > 0xFF)
  {
    int v24 = ~v19;
    unsigned int v22 = ((v21 >> 8) & 0xF) + v24;
    unsigned int v23 = v24 + (v21 >> 12);
  }
  else
  {
    unsigned int v22 = *((unsigned __int8 *)a3 + 56) - v19;
    unsigned int v23 = *((_WORD *)a3 + 26) - v19;
  }
LABEL_35:
  if (v6 <= v9) {
    unsigned int v6 = v9;
  }
  *((_DWORD *)this + 4) = v6;
  int v25 = *((_DWORD *)a3 + 6);
  int8x8_t v26 = *(int8x8_t *)((char *)a3 + 28);
  unsigned int v27 = v16 & 0xEFFFFFFF | v15 & 0xDBFFFFFF;
  __int16 v28 = *((_WORD *)a4 + 24) | *((_WORD *)a3 + 24);
  __int16 v29 = *((_WORD *)a4 + 23) | *((_WORD *)a3 + 23);
  char v30 = *((unsigned char *)a4 + 57) | *((unsigned char *)a3 + 57);
  if ((v16 | v15) >= 0) {
    unsigned int v31 = v16 & v15 & 0xC0000000;
  }
  else {
    unsigned int v31 = 0x80000000;
  }
  int v32 = v27 | v31;
  unsigned int v33 = *((_DWORD *)a4 + 6) & ~a5;
  if ((v22 & 0x80000000) != 0) {
    unsigned int v34 = v33 >> -(char)v22;
  }
  else {
    unsigned int v34 = v33 << v22;
  }
  int8x8_t v35 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(*(int8x8_t *)((char *)a4 + 28), (int8x8_t)vdup_n_s32(~a5)), (uint32x2_t)vdup_n_s32(v22)), (int8x8_t)0xFF000000FFLL);
  *((_DWORD *)this + 5) = v32;
  *((_DWORD *)this + 6) = v34 | v25;
  uint8x8_t v36 = (uint8x8_t)vorr_s8(v35, v26);
  *(uint8x8_t *)((char *)this + 28) = v36;
  *((_WORD *)this + 24) = v28;
  *((_WORD *)this + 23) = v29;
  unsigned __int16 v37 = *((_WORD *)a4 + 18) + *((_WORD *)a3 + 18);
  *((_WORD *)this + 18) = v37;
  unsigned __int16 v38 = *((_WORD *)a4 + 19) + *((_WORD *)a3 + 19);
  *((_WORD *)this + 19) = v38;
  *((_DWORD *)this + 15) = *((_DWORD *)a4 + 15) + *((_DWORD *)a3 + 15);
  unsigned int v39 = *((unsigned __int16 *)a4 + 20);
  if (v39 <= *((unsigned __int16 *)a3 + 20)) {
    unsigned int v39 = *((unsigned __int16 *)a3 + 20);
  }
  *((_WORD *)this + 20) = v39;
  v36.i32[0] = *(_DWORD *)((char *)a4 + 42);
  int16x8_t v40 = (int16x8_t)vmovl_u8(v36);
  v35.i32[0] = *(_DWORD *)((char *)a3 + 42);
  *(uint16x4_t *)v40.i8 = vmax_u16(*(uint16x4_t *)v40.i8, (uint16x4_t)*(_OWORD *)&vmovl_u8((uint8x8_t)v35));
  *(_DWORD *)((char *)this + 42) = vmovn_s16(v40).u32[0];
  unsigned __int16 v41 = *((_WORD *)a4 + 25) + *((_WORD *)a3 + 25);
  *((_WORD *)this + 25) = v41;
  unsigned int v42 = (unsigned __int16)(*((_WORD *)a4 + 26) + v23);
  *((_WORD *)this + 26) = *((_WORD *)a4 + 26) + v23;
  if (*((unsigned __int8 *)a3 + 52) <= v42) {
    unsigned int v43 = v42;
  }
  else {
    unsigned int v43 = *((unsigned __int8 *)a3 + 52);
  }
  *((_WORD *)this + 26) = v43;
  unsigned int v44 = (*((unsigned char *)a4 + 56) + v22);
  *((unsigned char *)this + 56) = *((unsigned char *)a4 + 56) + v22;
  if (*((unsigned __int8 *)a3 + 56) <= v44) {
    unsigned int v45 = v44;
  }
  else {
    unsigned int v45 = *((unsigned __int8 *)a3 + 56);
  }
  *((unsigned char *)this + 56) = v45;
  *((unsigned char *)this + 57) = v30;
  unsigned int v46 = *((unsigned __int8 *)a4 + 58);
  *((unsigned char *)this + 58) = v46;
  unsigned int v47 = *((unsigned __int8 *)a4 + 59);
  if (*((unsigned __int8 *)a3 + 59) > v47) {
    unsigned int v47 = *((unsigned __int8 *)a3 + 59);
  }
  *((unsigned char *)this + 59) = v47;
  if (!a6) {
    goto LABEL_62;
  }
  if (v43 > *((unsigned __int16 *)a6 + 18)
    || v45 > *((unsigned __int8 *)a6 + 40)
    || *((unsigned __int16 *)a6 + 11) < v38)
  {
    return 0xFFFFFFFFLL;
  }
  unsigned int v48 = *((unsigned __int16 *)a6 + 10);
  uint64_t v14 = 0xFFFFFFFFLL;
  if (v37 > v48 || v37 + v38 > v48) {
    return v14;
  }
  if (v39 + v40.u8[2] + v40.u8[0] + v40.u8[4] + v41 + v47 > *((unsigned __int8 *)a6 + 27)
                                                           + *((unsigned __int16 *)a6 + 12)
                                                           + *((unsigned __int8 *)a6 + 26)
                                                           + *((unsigned __int8 *)a6 + 28)
                                                           + *((unsigned __int16 *)a6 + 17)
                                                           + *((unsigned __int8 *)a6 + 43)
    || v46 > *((unsigned __int8 *)a6 + 42))
  {
    return 0xFFFFFFFFLL;
  }
LABEL_62:
  int v49 = *((unsigned __int16 *)a3 + 18);
  *(_DWORD *)a2 = *((unsigned __int16 *)a3 + 25);
  *((_DWORD *)a2 + 1) = v49;
  *((_DWORD *)a2 + 2) = v23;
  *((_DWORD *)a2 + 3) = 0;
  int v50 = *((_DWORD *)a3 + 15);
  *((_DWORD *)a2 + 4) = *((unsigned __int16 *)a3 + 19);
  *((_DWORD *)a2 + 5) = v50;
  *((_DWORD *)a2 + 6) = v22;
  *(void *)((char *)a2 + 28) = 0xFFFFFFFFLL;
  unsigned int v51 = bswap32(*(_DWORD *)a3);
  unsigned int v52 = bswap32(*((_DWORD *)a3 + 1));
  unsigned int v53 = bswap32(*((_DWORD *)a3 + 2));
  unsigned int v54 = bswap32(*((_DWORD *)a3 + 3));
  BOOL v8 = v51 >= *(_DWORD *)a4;
  *(_DWORD *)this = v51 - *(_DWORD *)a4;
  int v55 = !v8;
  unsigned int v56 = v52 - *((_DWORD *)a4 + 1) - v55;
  *((_DWORD *)this + 1) = v56;
  unsigned int v57 = (__PAIR64__(v53, v52) - __PAIR64__(*((_DWORD *)a4 + 2), v56)) >> 32;
  *((_DWORD *)this + 2) = v57;
  *((_DWORD *)this + 3) = (__PAIR64__(v54, v53) - __PAIR64__(*((_DWORD *)a4 + 3), v57)) >> 32;
  return *((unsigned int *)a2 + 3);
}

uint64_t HGString::pop(HGString *this, HGShaderBinding *a2, const HGString *a3, const char *a4, const HGLimits *a5)
{
  HGString::digest(this, (uint64_t)v35);
  HGString::digest(a3, (uint64_t)v33);
  memset(v32, 0, sizeof(v32));
  uint64_t v11 = HGString::Digest::pop((HGString::Digest *)&v28, a2, (const HGString::Digest *)v35, (const HGString::Digest *)v33, (int)a4, a5);
  if (v11 != -1)
  {
    if ((v34 & 0xFFFFFu) - 394305 >= 0xFFFFFECF)
    {
      arb::begin((string_t *)this, v36, (const HGLimits *)v32, v10);
      arb::write((string_t *)this, (string_t *)a2, (const HGShaderBinding *)v36, (const HGLimits *)0xFFFFFFFFLL, 0, *(const HGLimits **)a3, 0, a4, v28, v29, v30, v31);
      arb::end((string_t *)this, (uint64_t)v32, (unsigned int *)&v28, v15, v16, v17);
    }
    else
    {
      if ((v34 & 0xFFFFFu) - 394785 >= 0xFFFFFFEF)
      {
        glsl::begin((string_t *)this, v36, (const HGLimits *)v32, v10);
        double v20 = glsl::write(this, (string_t *)a2, 0, *(const HGLimits **)a3, 0, (const HGLimits *)a4, v18, v19, v28, v29, v30, v31);
LABEL_17:
        glsl::end((string_t *)this, (uint64_t)v32, (unsigned int *)&v28, 0, v20, v21, v22);
        return v11;
      }
      if ((v34 & 0xFFFFF) == 0x60B10)
      {
        int v12 = v32[0];
        uint64_t v13 = *((void *)this + 1);
        if (v13)
        {
          str_alloc((string_t *)this, v13);
          if (LODWORD(v36[0]) == v12) {
            goto LABEL_16;
          }
        }
        else
        {
          str_alloc((string_t *)this, 33);
          *((void *)this + 1) = 33;
          if (LODWORD(v36[0]) == v12)
          {
LABEL_16:
            metal::write(this, (string_t *)a2, (const HGShaderBinding *)v32, 0, *(void *)a3, 0, a4, v14, v28, v29, v30, v31);
            goto LABEL_17;
          }
        }
        int v23 = v12 >> 4;
        uint64_t v24 = *(void *)this;
        *(_DWORD *)(v24 + 3) = 1818326117;
        *(_DWORD *)uint64_t v24 = 1699557167;
        if (v23 | v12 & 0xF)
        {
          *(unsigned char *)(v24 + 7) = v23 | 0x30;
          *(unsigned char *)(v24 + 8) = 46;
          int v25 = (void *)(v24 + 10);
          *(unsigned char *)(v24 + 9) = v12 & 0xF | 0x30;
        }
        else
        {
          int v25 = (void *)(v24 + 7);
        }
        uint64_t v26 = *(void *)this;
        memset(v25, 32, *(void *)this + 15 - (void)v25);
        qmemcpy((void *)(v26 + 15), "\n//LEN=0000000000\n", 18);
        goto LABEL_16;
      }
      return 0xFFFFFFFFLL;
    }
  }
  return v11;
}

uint64_t HGString::undo(HGString *this)
{
  uint64_t v2 = *((void *)this + 1);
  HGString::signature((HGString **)this, (uint64_t)v18);
  if ((v18[0] & 0xFFFFFu) - 394305 >= 0xFFFFFECF)
  {
    arb::undo(this, v3);
    uint64_t v2 = arb::undo(this, v9);
    uint64_t v10 = *((void *)this + 4);
    if (*((void *)this + 3) == v10) {
      return v2;
    }
    goto LABEL_27;
  }
  if ((v18[0] & 0xFFFFF) != 0x60B10) {
    goto LABEL_26;
  }
  unint64_t v4 = *(const char **)this;
  uint64_t v5 = *((void *)this + 1);
  unsigned int v6 = *(const char **)this;
  if (*(void *)this + v5 - 139 != *(void *)this)
  {
    uint64_t v7 = v5 - 139;
    do
    {
      BOOL v8 = &v4[v7];
      if (v4[v7] == 47 && v8[1] == 47 && !strncmp(v8, "//SIG=", 6uLL))
      {
        unsigned int v6 = &v4[v7];
        goto LABEL_13;
      }
      --v7;
    }
    while (v7);
    unsigned int v6 = v4;
  }
LABEL_13:
  if (strncmp(v6, "//Metal1.0     \n", 0x10uLL))
  {
    int64_t v11 = v6 + 96 - v4;
    bzero((void *)(v6 + 96), v5 - v11);
    *((void *)this + 1) = v11;
    int v12 = *(const char **)this;
    uint64_t v13 = *(const char **)this;
    if (*(void *)this + v11 - 139 == *(void *)this) {
      goto LABEL_24;
    }
LABEL_17:
    int64_t v14 = v11 - 139;
    do
    {
      double v15 = &v12[v14];
      if (v12[v14] == 47 && v15[1] == 47 && !strncmp(v15, "//SIG=", 6uLL))
      {
        uint64_t v13 = &v12[v14];
        goto LABEL_24;
      }
      --v14;
    }
    while (v14);
    uint64_t v13 = v12;
    goto LABEL_24;
  }
  *((void *)this + 1) = 0;
  *unint64_t v4 = 0;
  int v12 = *(const char **)this;
  int64_t v11 = *((void *)this + 1);
  uint64_t v13 = *(const char **)this;
  if (*(void *)this + v11 - 139 != *(void *)this) {
    goto LABEL_17;
  }
LABEL_24:
  if (!strncmp(v13, "//Metal1.0     \n", 0x10uLL))
  {
    *((void *)this + 1) = 0;
    *int v12 = 0;
    uint64_t v2 = *((void *)this + 1);
    uint64_t v10 = *((void *)this + 4);
    if (*((void *)this + 3) == v10) {
      return v2;
    }
    goto LABEL_27;
  }
  double v16 = (void *)(v13 + 96);
  uint64_t v2 = v13 + 96 - v12;
  bzero(v16, v11 - v2);
  *((void *)this + 1) = v2;
LABEL_26:
  uint64_t v10 = *((void *)this + 4);
  if (*((void *)this + 3) != v10) {
LABEL_27:
  }
    *((void *)this + 4) = v10 - 2;
  return v2;
}

uint64_t arb::undo(arb *this, string_t *a2)
{
  unsigned int v3 = 0;
  unsigned int v4 = 0;
  unsigned int v5 = 0;
  uint64_t v7 = *(void *)this;
  uint64_t v6 = *((void *)this + 1);
  BOOL v8 = *(unsigned char **)this;
  uint64_t v9 = *(void *)this + v6;
  int v10 = *(unsigned __int8 *)(v9 - 3);
  int64_t v11 = (unsigned __int8 *)(v9 - 143);
  for (uint64_t i = v6; ; --i)
  {
    int v13 = *v11;
    if (v13 != 36) {
      break;
    }
    if (v11[1] == 116)
    {
      int64_t v14 = v11 + 2;
      int v15 = v11[2];
      if ((v15 - 58) >= 0xFFFFFFF6)
      {
        unsigned int v3 = 0;
        do
        {
          unsigned int v3 = v15 + 10 * v3 - 48;
          int v16 = *++v14;
          int v15 = v16;
        }
        while ((v16 - 58) > 0xFFFFFFF5);
        if (v15)
        {
          if ((v15 - 33) >= 0xFFFFFFE0)
          {
            do
            {
LABEL_11:
              int v17 = *++v14;
              int v15 = v17;
            }
            while ((v17 - 33) > 0xFFFFFFDF);
          }
LABEL_12:
          if (v15 == 35)
          {
            unsigned int v18 = v14;
            while (1)
            {
              int v19 = *++v18;
              int v15 = v19;
              if (!v19) {
                break;
              }
              int v20 = *v14;
              int64_t v14 = v18;
              if (v20 == 10)
              {
                int64_t v14 = v18;
                if ((v15 - 33) >= 0xFFFFFFE0) {
                  goto LABEL_11;
                }
                goto LABEL_12;
              }
            }
          }
        }
      }
      if (v3 + 1 <= v5 + v4) {
        unsigned int v21 = v5;
      }
      else {
        unsigned int v21 = v3 + 1 - v4;
      }
      unsigned int v22 = v5 + v4 - v3;
      if (v3 >= v4)
      {
        unsigned int v5 = v21;
      }
      else
      {
        unsigned int v4 = v3;
        unsigned int v5 = v22;
      }
    }
LABEL_3:
    --v11;
  }
  if (v13 != 64) {
    goto LABEL_3;
  }
  while (v13 != 35 || *(unsigned char *)(v7 + i - 141) != 36)
    int v13 = *(unsigned __int8 *)(v7 + i-- - 144);
  if ((unint64_t)(i - 143) > 0xA8)
  {
    if (v10 != 59 || *(unsigned char *)(v7 + i - 146) != 59)
    {
      if (v6)
      {
        unsigned int v23 = v5 + v4;
        if (v23 <= 8 && v6 - 142 >= 0 && v5)
        {
          char v24 = v23 - 1;
          uint64_t v25 = v6 + v7 - 149;
          do
          {
            if (*(unsigned char *)(v25 + 7) == 36 && *(unsigned char *)(v25 + 8) == 116 && *(char *)(v25 + 9) == (char)(v24 + 48))
            {
              if (!strncmp((const char *)v25, "#UTPUT ", 7uLL))
              {
                *(unsigned char *)uint64_t v25 = 79;
                --v24;
                --v5;
              }
              else
              {
                *(unsigned char *)(v25 + 8) = 111;
              }
            }
            unint64_t v26 = v25 + 6;
            BOOL v8 = *(unsigned char **)this;
            --v25;
          }
          while (v26 >= *(void *)this && v5 != 0);
        }
      }
      uint64_t v28 = v7 + i;
      int v29 = *(char *)(v28 - 146);
      if (v29 <= 96) {
        int v30 = 0;
      }
      else {
        int v30 = -39;
      }
      unsigned int v31 = v29 + v30 - 48;
      if (v31 <= 7)
      {
        int v32 = v8 + 128;
        if (v31)
        {
          uint64_t v33 = 4 * v31;
          memcpy(v8 + 128, "TEMP $t0,$t1,$t2,$t3,$t4,$t5,$t6,$t7;  \n", v33 + 4);
          v32[v33 + 4] = 59;
          memset(&v32[v33 + 5], 32, 34 - v33);
          v8[167] = 10;
        }
        else
        {
          qmemcpy(v8 + 128, "##                                     \n", 40);
        }
      }
      *((void *)this + 1) = v28 - *(void *)this - 143;
      *(unsigned char *)(v28 - 285) = 69;
    }
  }
  else
  {
    *((void *)this + 1) = 0;
    *BOOL v8 = 0;
  }
  return *((void *)this + 1);
}

uint64_t HGString::setp(HGString *this, uint64_t a2)
{
  uint64_t v2 = *(const char **)this;
  if (**(unsigned char **)this != 47
    || strncmp(*(const char **)this, "//GLfs", 6uLL)
    || strncmp(v2 + 33, "#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp ", 0x51uLL))
  {
    return 0;
  }
  uint64_t v6 = v2 + 114;
  int v7 = *((unsigned __int8 *)v2 + 114);
  if (v7 == 104) {
    unsigned int v8 = 2;
  }
  else {
    unsigned int v8 = 1;
  }
  if (v7 == 108) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = v8;
  }
  if (v9 == a2) {
    return a2;
  }
  str_alloc((string_t *)this, *((void *)this + 1));
  if (a2 == 2)
  {
    *(_DWORD *)((char *)v6 + 3) = 538996840;
    _DWORD *v6 = 1751607656;
    return v9;
  }
  else
  {
    if (a2)
    {
      *(_DWORD *)((char *)v6 + 3) = 1886221673;
      _DWORD *v6 = 1768187245;
    }
    else
    {
      *(_DWORD *)((char *)v6 + 3) = 538976368;
      _DWORD *v6 = 1886875500;
    }
    return v9;
  }
}

unsigned __int8 *atox(unsigned __int8 *result, unsigned int *a2)
{
  uint64_t v2 = *result;
  if ((ctype[2 * v2] & 0x10) != 0)
  {
    if ((char)v2 <= 96) {
      int v3 = 0;
    }
    else {
      int v3 = -39;
    }
    int v4 = (char)v2 + v3 - 48;
    uint64_t v5 = result[1];
    if ((ctype[2 * v5] & 0x10) != 0)
    {
      int v6 = (char)v5 <= 96 ? 0 : -39;
      int v4 = ((char)v5 + v6 - 48) | (16 * v4);
      uint64_t v7 = result[2];
      if ((ctype[2 * v7] & 0x10) != 0)
      {
        int v8 = (char)v7 <= 96 ? 0 : -39;
        int v4 = ((char)v7 + v8 - 48) | (16 * v4);
        uint64_t v9 = result[3];
        if ((ctype[2 * v9] & 0x10) != 0)
        {
          int v10 = (char)v9 <= 96 ? 0 : -39;
          int v4 = ((char)v9 + v10 - 48) | (16 * v4);
          uint64_t v11 = result[4];
          if ((ctype[2 * v11] & 0x10) != 0)
          {
            int v12 = (char)v11 <= 96 ? 0 : -39;
            int v4 = ((char)v11 + v12 - 48) | (16 * v4);
            uint64_t v13 = result[5];
            if ((ctype[2 * v13] & 0x10) != 0)
            {
              int v14 = (char)v13 <= 96 ? 0 : -39;
              int v4 = ((char)v13 + v14 - 48) | (16 * v4);
              uint64_t v15 = result[6];
              if ((ctype[2 * v15] & 0x10) != 0)
              {
                int v16 = (char)v15 <= 96 ? 0 : -39;
                int v4 = ((char)v15 + v16 - 48) | (16 * v4);
                uint64_t v17 = result[7];
                if ((ctype[2 * v17] & 0x10) != 0)
                {
                  int v18 = (char)v17 <= 96 ? 0 : -39;
                  int v4 = ((char)v17 + v18 - 48) | (16 * v4);
                  uint64_t v19 = result[8];
                  if ((ctype[2 * v19] & 0x10) != 0)
                  {
                    int v20 = (char)v19 <= 96 ? 0 : -39;
                    int v4 = ((char)v19 + v20 - 48) | (16 * v4);
                    uint64_t v21 = result[9];
                    if ((ctype[2 * v21] & 0x10) != 0)
                    {
                      if ((char)v21 <= 96) {
                        int v22 = 0;
                      }
                      else {
                        int v22 = -39;
                      }
                      int v4 = ((char)v21 + v22 - 48) | (16 * v4);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    *a2 = v4;
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

uint32x2_t *merge(uint32x2_t *result, int8x8_t *a2, int8x8_t *a3, int a4, int a5)
{
  unsigned int v5 = result[5].u8[3];
  if (v5 <= 1) {
    LOBYTE(v5) = 1;
  }
  unsigned __int8 v6 = v5 + a2[5].i8[2];
  unsigned int v7 = v6;
  a3[5].i8[3] = v6;
  unsigned int v8 = a2[5].u8[3];
  if (v7 > v8) {
    LOBYTE(v8) = v7;
  }
  a3[5].i8[3] = v8;
  __int32 v9 = a2->i32[1];
  __int32 v10 = result->i32[1];
  unsigned int v11 = v10 & 0xEFFFFFFF | v9 & 0xDBFFFFFF;
  __int8 v12 = a2[5].i8[2];
  if (v12) {
    __int32 v13 = a2->i32[1];
  }
  else {
    __int32 v13 = result->i32[1];
  }
  __int16 v14 = result[4].i16[0] | a2[4].i16[0];
  __int16 v15 = result[3].i16[3] | a2[3].i16[3];
  __int8 v16 = result[5].i8[1] | a2[5].i8[1];
  int v17 = v10 | v9;
  int v18 = v13 & 0x20000000;
  unsigned int v19 = v9 & v10 & 0xC0000000;
  if (v17 < 0) {
    unsigned int v19 = 0x80000000;
  }
  int v20 = v11 | v19 | v18;
  __int16 v21 = a2[4].i16[2];
  int v22 = (result[2].i32[0] << v21) | a2[2].i32[0];
  a3->i32[0] = a2->i32[0];
  a3->i32[1] = v20;
  a3[1] = vorr_s8(vand_s8((int8x8_t)vshl_u32(result[1], (uint32x2_t)vdup_n_s32(v21)), (int8x8_t)0xFF000000FFLL), a2[1]);
  a3[2].i32[0] = v22;
  a3[4].i16[0] = v14;
  a3[3].i16[3] = v15;
  a3[5].i8[2] = v12 + 1;
  a3[5].i8[1] = v16;
  __int16 v23 = result[4].i16[2];
  if ((a4 & a5) != 0) {
    __int16 v23 = 1;
  }
  a3[4].i16[2] = (v23 + v21) | v21 & 0xFF00;
  char v24 = result[5].i8[0];
  if ((a4 & a5) != 0) {
    char v24 = 1;
  }
  a3[5].i8[0] = v24 + a2[5].i8[0];
  a3[2].i16[3] = result[2].i16[3] + a2[2].i16[3];
  a3[5].i32[1] = result[5].i32[1] + a2[5].i32[1];
  return result;
}

uint64_t arb::obj_decl(uint64_t a1, unsigned char *a2, arb *this, uint64_t a4, uint64_t a5)
{
  int v5 = *(unsigned __int8 *)this;
  if (!*(unsigned char *)this) {
    return 0;
  }
  unsigned int v7 = this;
  unsigned int v67 = 0;
  if ((v5 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_3:
      int v9 = *((unsigned __int8 *)v7 + 1);
      unsigned int v7 = (arb *)((char *)v7 + 1);
      int v5 = v9;
    }
    while ((v9 - 33) > 0xFFFFFFDF);
  }
LABEL_4:
  if (v5 == 35)
  {
    __int32 v10 = v7;
    while (1)
    {
      int v11 = *((unsigned __int8 *)v10 + 1);
      __int32 v10 = (arb *)((char *)v10 + 1);
      int v5 = v11;
      if (!v11) {
        return 0;
      }
      int v12 = *(unsigned __int8 *)v7;
      unsigned int v7 = v10;
      if (v12 == 10)
      {
        unsigned int v7 = v10;
        if ((v5 - 33) >= 0xFFFFFFE0) {
          goto LABEL_3;
        }
        goto LABEL_4;
      }
    }
  }
  if (!v5) {
    return 0;
  }
  __int16 v14 = (const char **)arb::alen(v7, (const char *)1);
  unint64_t v66 = 0;
  __int16 v15 = *(char **)a1;
  unint64_t v16 = *(void *)(a1 + 8);
  uint64_t v17 = *(void *)a1 + 88 * v16;
  unint64_t v64 = *(char **)a1;
  if (!v16) {
    goto LABEL_22;
  }
  while (1)
  {
    unint64_t v18 = v16 >> 1;
    *(void *)unsigned int v68 = v7;
    unsigned int v19 = (unsigned __int8 *)&v15[88 * (v16 >> 1)];
    int v20 = arb::ascan((unsigned __int8 **)v68, v14, v19, (const char *)1);
    if (!v20) {
      break;
    }
    if (v20 > 0)
    {
      unint64_t v21 = v18 + 1;
    }
    else
    {
      uint64_t v17 = (uint64_t)&v15[88 * (v16 >> 1)];
      unint64_t v21 = 0;
    }
    v15 += 88 * v21;
    if (v20 <= 0) {
      v16 >>= 1;
    }
    else {
      v16 -= v18 + 1;
    }
    if (!v16) {
      goto LABEL_22;
    }
  }
  if (!v15) {
LABEL_22:
  }
    unsigned int v19 = (unsigned __int8 *)v17;
  unint64_t v66 = 0x2E8BA2E8BA2E8BA3 * ((v19 - (unsigned __int8 *)v64) >> 3);
  int v22 = (unsigned __int8 *)v14 + (void)v7;
  int v23 = *((unsigned __int8 *)v14 + (void)v7);
  if (!*((unsigned char *)v14 + (void)v7)) {
    return 0;
  }
  if ((v23 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_25:
      int v24 = *++v22;
      int v23 = v24;
    }
    while ((v24 - 33) > 0xFFFFFFDF);
  }
LABEL_26:
  if (v23 == 35)
  {
    uint64_t v25 = v22;
    while (1)
    {
      int v26 = *++v25;
      int v23 = v26;
      if (!v26) {
        return 0;
      }
      int v27 = *v22;
      int v22 = v25;
      if (v27 == 10)
      {
        int v22 = v25;
        if ((v23 - 33) >= 0xFFFFFFE0) {
          goto LABEL_25;
        }
        goto LABEL_26;
      }
    }
  }
  if (v23 != 61) {
    return 0;
  }
  int v30 = v22[1];
  int v29 = v22 + 1;
  int v28 = v30;
  if (v30)
  {
    if ((v28 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_35:
        int v31 = *++v29;
        int v28 = v31;
      }
      while ((v31 - 33) > 0xFFFFFFDF);
    }
LABEL_36:
    if (v28 == 35)
    {
      ++v29;
      while (1)
      {
        int v28 = *v29;
        if (!*v29) {
          break;
        }
        int v32 = *(v29++ - 1);
        if (v32 == 10)
        {
          --v29;
          if ((v28 - 33) >= 0xFFFFFFE0) {
            goto LABEL_35;
          }
          goto LABEL_36;
        }
      }
    }
  }
  size_t v34 = 0;
  do
    int v35 = *((unsigned __int8 *)v7 + ++v34);
  while ((ctype[2 * v35] & 0x40) != 0);
  uint8x8_t v36 = (arb *)((char *)v7 + v34);
  if (v35)
  {
    if ((v35 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_47:
        int v37 = *((unsigned __int8 *)v36 + 1);
        uint8x8_t v36 = (arb *)((char *)v36 + 1);
        int v35 = v37;
      }
      while ((v37 - 33) > 0xFFFFFFDF);
    }
LABEL_48:
    if (v35 == 35)
    {
      uint8x8_t v36 = (arb *)((char *)v36 + 1);
      while (1)
      {
        int v35 = *(unsigned __int8 *)v36;
        if (!*(unsigned char *)v36) {
          break;
        }
        int v38 = *((unsigned __int8 *)v36 - 1);
        uint8x8_t v36 = (arb *)((char *)v36 + 1);
        if (v38 == 10)
        {
          uint8x8_t v36 = (arb *)((char *)v36 - 1);
          if ((v35 - 33) >= 0xFFFFFFE0) {
            goto LABEL_47;
          }
          goto LABEL_48;
        }
      }
    }
  }
  *(_DWORD *)unsigned int v68 = 0;
  unsigned int v65 = 0;
  if (!arb::aidx(v36, v68, &v65, v13))
  {
    unsigned int v67 = -1;
    arb::obj_declare((char **)a1, &v66, a2, v7, v34, (signed int *)&v67, (arb *)v29, a4, a5);
    return 1;
  }
  if (v65 != -1) {
    unsigned int v65 = *(_DWORD *)v68 - 1;
  }
  *(_DWORD *)unsigned int v68 = 0;
  int v39 = *v29;
  if (!*v29) {
    goto LABEL_78;
  }
  if ((v39 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_59:
      int v40 = *++v29;
      int v39 = v40;
    }
    while ((v40 - 33) > 0xFFFFFFDF);
  }
LABEL_60:
  if (v39 == 35)
  {
    unsigned __int16 v41 = v29;
    while (1)
    {
      int v42 = *++v41;
      int v39 = v42;
      if (!v42) {
        goto LABEL_78;
      }
      int v43 = *v29;
      int v29 = v41;
      if (v43 == 10)
      {
        int v29 = v41;
        if ((v39 - 33) >= 0xFFFFFFE0) {
          goto LABEL_59;
        }
        goto LABEL_60;
      }
    }
  }
  if (v39 != 123)
  {
LABEL_78:
    unsigned int v45 = 0;
    goto LABEL_79;
  }
  int v46 = v29[1];
  unsigned int v45 = (arb *)(v29 + 1);
  int v44 = v46;
  if (v46)
  {
    if ((v44 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_71:
        int v47 = *((unsigned __int8 *)v45 + 1);
        unsigned int v45 = (arb *)((char *)v45 + 1);
        int v44 = v47;
      }
      while ((v47 - 33) > 0xFFFFFFDF);
    }
LABEL_72:
    if (v44 == 35)
    {
      unsigned int v45 = (arb *)((char *)v45 + 1);
      while (1)
      {
        int v44 = *(unsigned __int8 *)v45;
        if (!*(unsigned char *)v45) {
          break;
        }
        int v48 = *((unsigned __int8 *)v45 - 1);
        unsigned int v45 = (arb *)((char *)v45 + 1);
        if (v48 == 10)
        {
          unsigned int v45 = (arb *)((char *)v45 - 1);
          if ((v44 - 33) >= 0xFFFFFFE0) {
            goto LABEL_71;
          }
          goto LABEL_72;
        }
      }
    }
  }
LABEL_79:
  unsigned int v67 = 0;
  int v49 = arb::obj_declare((char **)a1, &v66, a2, v7, v34, (signed int *)&v67, v45, a4, a5);
  if (v49)
  {
    int v50 = v49;
    while (v67 <= v65)
    {
      int v51 = *v50;
      if (!*v50) {
        break;
      }
      if ((v51 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_84:
          int v52 = *++v50;
          int v51 = v52;
        }
        while ((v52 - 33) > 0xFFFFFFDF);
      }
LABEL_85:
      if (v51 == 35)
      {
        unsigned int v53 = v50;
        while (1)
        {
          int v54 = *++v53;
          int v51 = v54;
          if (!v54) {
            return 1;
          }
          int v55 = *v50;
          int v50 = v53;
          if (v55 == 10)
          {
            int v50 = v53;
            if ((v51 - 33) >= 0xFFFFFFE0) {
              goto LABEL_84;
            }
            goto LABEL_85;
          }
        }
      }
      if (v51 != 44) {
        return 1;
      }
      int v58 = v50[1];
      unsigned int v56 = (arb *)(v50 + 1);
      int v57 = v58;
      if (v58)
      {
        if ((v57 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_94:
            int v59 = *((unsigned __int8 *)v56 + 1);
            unsigned int v56 = (arb *)((char *)v56 + 1);
            int v57 = v59;
          }
          while ((v59 - 33) > 0xFFFFFFDF);
        }
LABEL_95:
        if (v57 == 35)
        {
          unsigned int v56 = (arb *)((char *)v56 + 1);
          while (1)
          {
            int v57 = *(unsigned __int8 *)v56;
            if (!*(unsigned char *)v56) {
              break;
            }
            int v60 = *((unsigned __int8 *)v56 - 1);
            unsigned int v56 = (arb *)((char *)v56 + 1);
            if (v60 == 10)
            {
              unsigned int v56 = (arb *)((char *)v56 - 1);
              if ((v57 - 33) >= 0xFFFFFFE0) {
                goto LABEL_94;
              }
              goto LABEL_95;
            }
          }
        }
      }
      int v50 = arb::obj_declare((char **)a1, &v66, a2, v7, v34, (signed int *)&v67, v56, a4, a5);
      if (!v50) {
        goto LABEL_102;
      }
    }
    return 1;
  }
LABEL_102:
  unint64_t v61 = *(void *)(a1 + 8);
  if (v66 + 1 < v61)
  {
    memcpy((void *)(*(void *)a1 + 88 * v66), (const void *)(*(void *)a1 + 88 * v66 + 88), 88 * (v61 + ~v66));
    unint64_t v61 = *(void *)(a1 + 8);
  }
  uint64_t result = 0;
  *(void *)(a1 + 8) = v61 - 1;
  return result;
}

unsigned __int8 *arb::obj_alias(uint64_t a1, char *__s1, uint64_t a3)
{
  int v6 = strncmp(__s1, "ALIAS", 5uLL);
  uint64_t result = 0;
  unsigned int v8 = (unsigned __int8 *)(__s1 + 5);
  if (v6) {
    int v9 = 0;
  }
  else {
    int v9 = v8;
  }
  if (v6) {
    return result;
  }
  int v10 = *v8;
  if (!*v8)
  {
    int v9 = v8;
    goto LABEL_15;
  }
LABEL_7:
  if ((v10 - 33) >= 0xFFFFFFE0)
  {
    do
    {
      int v11 = *++v8;
      int v10 = v11;
    }
    while ((v11 - 33) > 0xFFFFFFDF);
  }
  if (v10 == 35)
  {
    int v12 = v8;
    while (1)
    {
      int v13 = *++v8;
      int v10 = v13;
      if (!v13) {
        goto LABEL_15;
      }
      int v14 = *v12;
      int v12 = v8;
      if (v14 == 10) {
        goto LABEL_7;
      }
    }
  }
  if (!v10)
  {
LABEL_15:
    int64_t v15 = 0;
    uint64_t result = v9;
    unint64_t v16 = v9;
    int i = *v9;
    if (i == 35) {
      goto LABEL_18;
    }
    while (i != 59)
    {
      ++v15;
      if ((i - 33) < 0xFFFFFFE0) {
        uint64_t result = &v9[v15];
      }
      unint64_t v16 = &v9[v15];
      for (int i = v9[v15]; i == 35; int i = *v16)
      {
LABEL_18:
        if ((i - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_19:
            int v18 = *++v16;
            int i = v18;
          }
          while ((v18 - 33) > 0xFFFFFFDF);
        }
LABEL_20:
        if (i == 35)
        {
          ++v16;
          while (1)
          {
            int i = *v16;
            if (!*v16) {
              break;
            }
            int v19 = *(v16++ - 1);
            if (v19 == 10)
            {
              --v16;
              if ((i - 33) >= 0xFFFFFFE0) {
                goto LABEL_19;
              }
              goto LABEL_20;
            }
          }
        }
        int64_t v15 = v16 - v9;
      }
    }
    return result;
  }
  int v20 = 0;
  do
  {
    int v21 = *((unsigned __int8 *)v20 + (void)v8 + 1);
    int v20 = (const char **)((char *)v20 + 1);
  }
  while ((ctype[2 * v21] & 0x40) != 0);
  int v22 = (unsigned __int8 *)v20 + (void)v8;
  if (v21)
  {
    if ((v21 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_36:
        int v23 = *++v22;
        int v21 = v23;
      }
      while ((v23 - 33) > 0xFFFFFFDF);
    }
LABEL_37:
    if (v21 == 35)
    {
      ++v22;
      while (1)
      {
        int v21 = *v22;
        if (!*v22) {
          break;
        }
        int v24 = *(v22++ - 1);
        if (v24 == 10)
        {
          --v22;
          if ((v21 - 33) >= 0xFFFFFFE0) {
            goto LABEL_36;
          }
          goto LABEL_37;
        }
      }
    }
  }
  int v27 = v22[1];
  int v26 = (char *)(v22 + 1);
  int v25 = v27;
  if (v27)
  {
    if ((v25 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_45:
        int v28 = *++v26;
        int v25 = v28;
      }
      while ((v28 - 33) > 0xFFFFFFDF);
    }
LABEL_46:
    if (v25 == 35)
    {
      ++v26;
      while (1)
      {
        int v25 = *v26;
        if (!*v26) {
          break;
        }
        int v29 = *(v26++ - 1);
        if (v29 == 10)
        {
          --v26;
          if ((v25 - 33) >= 0xFFFFFFE0) {
            goto LABEL_45;
          }
          goto LABEL_46;
        }
      }
    }
  }
  int64_t v30 = 0;
  int v31 = v26;
  if (v25 != 35) {
    goto LABEL_55;
  }
  do
  {
LABEL_59:
    int v32 = &v26[v30];
    int v33 = 35;
LABEL_61:
    if (v33 == 35)
    {
      ++v32;
      while (1)
      {
        int v33 = *v32;
        if (!*v32) {
          break;
        }
        int v35 = *(v32++ - 1);
        if (v35 == 10)
        {
          --v32;
          if ((v33 - 33) >= 0xFFFFFFE0)
          {
            do
            {
              int v34 = *++v32;
              int v33 = v34;
            }
            while ((v34 - 33) > 0xFFFFFFDF);
          }
          goto LABEL_61;
        }
      }
    }
    int64_t v30 = v32 - v26;
    int v25 = *v32;
  }
  while (v25 == 35);
LABEL_55:
  while (v25 != 59)
  {
    ++v30;
    if ((v25 - 33) < 0xFFFFFFE0) {
      int v31 = &v26[v30];
    }
    int v25 = v26[v30];
    if (v25 == 35) {
      goto LABEL_59;
    }
  }
  uint8x8_t v36 = (const char **)(v31 - v26);
  int v37 = arb::obj_add(a1, v26, (const char **)(v31 - v26), a3, 0);
  if (v37)
  {
    uint64_t v38 = *((void *)v37 + 5);
    uint64_t v39 = *((void *)v37 + 6);
    int v40 = *((_DWORD *)v37 + 14);
    uint64_t v41 = *((void *)v37 + 8);
    *(_OWORD *)size_t v72 = *(_OWORD *)(v37 + 72);
    uint64_t v42 = *(void *)a1 + 88 * arb::obj_key((char **)a1, v8, v20);
    *(void *)(v42 + 40) = v38;
    *(void *)(v42 + 48) = v39;
    *(_DWORD *)(v42 + 56) = v40;
    *(void *)(v42 + 64) = v41;
    *(_OWORD *)(v42 + 72) = *(_OWORD *)v72;
    goto LABEL_15;
  }
  uint64_t v73 = v36;
  int v44 = *(char **)a1;
  unint64_t v43 = *(void *)(a1 + 8);
  if (!v43) {
    goto LABEL_79;
  }
  unint64_t v45 = *(void *)(a1 + 8);
  int v46 = *(char **)a1;
  while (1)
  {
    unint64_t v47 = v45 >> 1;
    uint64_t v74 = (unsigned __int8 *)v26;
    int v48 = arb::ascan(&v74, v73, (unsigned __int8 *)&v46[88 * (v45 >> 1)], (const char *)1);
    if (!v48) {
      break;
    }
    if (v48 > 0) {
      unint64_t v49 = v47 + 1;
    }
    else {
      unint64_t v49 = 0;
    }
    v46 += 88 * v49;
    if (v48 <= 0) {
      v45 >>= 1;
    }
    else {
      v45 -= v47 + 1;
    }
    if (!v45) {
      goto LABEL_79;
    }
  }
  int v9 = v74;
  int v51 = &v46[88 * (v45 >> 1)];
  if (!v46)
  {
LABEL_79:
    if (!v43) {
      goto LABEL_101;
    }
    while (1)
    {
      unint64_t v50 = v43 >> 1;
      uint64_t v74 = (unsigned __int8 *)v26;
      int v51 = &v44[88 * (v43 >> 1)];
      int v52 = arb::ascan(&v74, v73, (unsigned __int8 *)v51, 0);
      if (!v52) {
        break;
      }
      if (v52 > 0) {
        unint64_t v53 = v50 + 1;
      }
      else {
        unint64_t v53 = 0;
      }
      v44 += 88 * v53;
      if (v52 <= 0) {
        v43 >>= 1;
      }
      else {
        v43 -= v50 + 1;
      }
      if (!v43) {
        goto LABEL_101;
      }
    }
    int v9 = v74;
    if (!v44)
    {
LABEL_101:
      uint64_t v58 = *(void *)a1 + 88 * arb::obj_key((char **)a1, v8, v20);
      *(void *)(v58 + 40) = v26;
      *(void *)(v58 + 48) = v20;
      *(_DWORD *)(v58 + 56) = -1;
      *(void *)(v58 + 72) = 0;
      *(void *)(v58 + 80) = 0;
      *(void *)(v58 + 64) = 0;
      goto LABEL_15;
    }
  }
  uint64_t v54 = arb::obj_key((char **)a1, v8, v20);
  int v55 = *v9;
  if (*v9)
  {
    if ((v55 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_94:
        int v56 = *++v9;
        int v55 = v56;
      }
      while ((v56 - 33) > 0xFFFFFFDF);
    }
LABEL_95:
    if (v55 == 35)
    {
      ++v9;
      while (1)
      {
        int v55 = *v9;
        if (!*v9) {
          break;
        }
        int v57 = *(v9++ - 1);
        if (v57 == 10)
        {
          --v9;
          if ((v55 - 33) >= 0xFFFFFFE0) {
            goto LABEL_94;
          }
          goto LABEL_95;
        }
      }
    }
  }
  int64_t v59 = 0;
  int v60 = v9;
  if (v55 != 35) {
    goto LABEL_105;
  }
  do
  {
LABEL_109:
    unint64_t v61 = &v9[v59];
    int v62 = 35;
LABEL_111:
    if (v62 == 35)
    {
      ++v61;
      while (1)
      {
        int v62 = *v61;
        if (!*v61) {
          break;
        }
        int v64 = *(v61++ - 1);
        if (v64 == 10)
        {
          --v61;
          if ((v62 - 33) >= 0xFFFFFFE0)
          {
            do
            {
              int v63 = *++v61;
              int v62 = v63;
            }
            while ((v63 - 33) > 0xFFFFFFDF);
          }
          goto LABEL_111;
        }
      }
    }
    int64_t v59 = v61 - v9;
    int v55 = *v61;
  }
  while (v55 == 35);
LABEL_105:
  while (v55 != 59)
  {
    ++v59;
    if ((v55 - 33) < 0xFFFFFFE0) {
      int v60 = &v9[v59];
    }
    int v55 = v9[v59];
    if (v55 == 35) {
      goto LABEL_109;
    }
  }
  uint64_t v65 = *((void *)v51 + 6);
  int v66 = *((_DWORD *)v51 + 14);
  int64_t v67 = v60 - v9;
  if (v67)
  {
    uint64_t v68 = *((void *)v51 + 10) | 0x20;
    int v69 = v9;
    int64_t v70 = v67;
  }
  else
  {
    int v69 = (unsigned __int8 *)*((void *)v51 + 8);
    int64_t v70 = *((void *)v51 + 9);
    uint64_t v68 = *((void *)v51 + 10);
  }
  uint64_t v71 = *(void *)a1 + 88 * v54;
  *(void *)(v71 + 40) = *((void *)v51 + 5);
  *(void *)(v71 + 48) = v65;
  *(_DWORD *)(v71 + 56) = v66;
  *(void *)(v71 + 64) = v69;
  *(void *)(v71 + 72) = v70;
  *(void *)(v71 + 80) = v68;
  return &v9[v67];
}

char *arb::isunpremult(uint64_t a1, char *__s1, uint64_t a3)
{
  uint64_t v118 = 0;
  int v6 = strncmp(__s1, "DIVA", 4uLL);
  unsigned int v8 = (arb *)(__s1 + 4);
  if (v6) {
    int v9 = 0;
  }
  else {
    int v9 = __s1 + 4;
  }
  *(void *)uint64_t v119 = v9;
  if (!v6)
  {
    int v10 = *(unsigned __int8 *)v8;
    if ((v10 - 33) >= 0xFFFFFFE0)
    {
LABEL_28:
      if ((v10 - 33) >= 0xFFFFFFE0)
      {
        do
        {
          int v24 = *((unsigned __int8 *)v8 + 1);
          unsigned int v8 = (arb *)((char *)v8 + 1);
          int v10 = v24;
        }
        while ((v24 - 33) > 0xFFFFFFDF);
      }
      if (v10 == 35)
      {
        unsigned int v8 = (arb *)((char *)v8 + 1);
        while (1)
        {
          int v10 = *(unsigned __int8 *)v8;
          if (!*(unsigned char *)v8) {
            break;
          }
          int v25 = *((unsigned __int8 *)v8 - 1);
          unsigned int v8 = (arb *)((char *)v8 + 1);
          if (v25 == 10)
          {
            unsigned int v8 = (arb *)((char *)v8 - 1);
            goto LABEL_28;
          }
        }
      }
      int v26 = arb::asymbol(v8, v119, (const char **)&v118, v7);
      if (v8 != *(arb **)v119) {
        return 0;
      }
      int v28 = (const char *)v26;
      if ((unsigned __int8 *)v118 + (void)v8 == v26 || !strncmp((const char *)v26 - 4, "xyzw", 4uLL))
      {
        if (!v28) {
          return 0;
        }
      }
      else
      {
        int v29 = strncmp(v28 - 4, "rgba", 4uLL);
        uint64_t result = 0;
        if (v29 || !v28) {
          return result;
        }
      }
      int v32 = *(unsigned __int8 *)v28;
      if (*v28)
      {
        if ((v32 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_53:
            int v33 = *(unsigned __int8 *)++v28;
            int v32 = v33;
          }
          while ((v33 - 33) > 0xFFFFFFDF);
        }
LABEL_54:
        if (v32 == 35)
        {
          int v34 = v28;
          while (1)
          {
            int v35 = *(unsigned __int8 *)++v34;
            int v32 = v35;
            if (!v35) {
              break;
            }
            int v36 = *(unsigned __int8 *)v28;
            int v28 = v34;
            if (v36 == 10)
            {
              int v28 = v34;
              if ((v32 - 33) >= 0xFFFFFFE0) {
                goto LABEL_53;
              }
              goto LABEL_54;
            }
          }
        }
        else if (v32 == 44)
        {
          int v52 = *((unsigned __int8 *)v28 + 1);
          int v51 = (arb *)(v28 + 1);
          int v50 = v52;
          if (v52)
          {
            if ((v50 - 33) >= 0xFFFFFFE0)
            {
              do
              {
LABEL_85:
                int v53 = *((unsigned __int8 *)v51 + 1);
                int v51 = (arb *)((char *)v51 + 1);
                int v50 = v53;
              }
              while ((v53 - 33) > 0xFFFFFFDF);
            }
LABEL_86:
            if (v50 == 35)
            {
              int v51 = (arb *)((char *)v51 + 1);
              while (1)
              {
                int v50 = *(unsigned __int8 *)v51;
                if (!*(unsigned char *)v51) {
                  break;
                }
                int v54 = *((unsigned __int8 *)v51 - 1);
                int v51 = (arb *)((char *)v51 + 1);
                if (v54 == 10)
                {
                  int v51 = (arb *)((char *)v51 - 1);
                  if ((v50 - 33) >= 0xFFFFFFE0) {
                    goto LABEL_85;
                  }
                  goto LABEL_86;
                }
              }
            }
          }
LABEL_93:
          int v55 = arb::asymbol(v51, v119, (const char **)&v118, v27);
          if (v51 == *(arb **)v119)
          {
            int v56 = v55;
            int v57 = v118;
            if ((unsigned __int8 *)v118 + (void)v51 == v55 || !strncmp((const char *)v55 - 4, "xyzw", 4uLL))
            {
              if (!v56) {
                return 0;
              }
            }
            else
            {
              int v58 = strncmp((const char *)v56 - 4, "rgba", 4uLL);
              uint64_t result = 0;
              if (v58 || !v56) {
                return result;
              }
            }
            unint64_t v59 = *(void *)(a1 + 8);
            if (v59)
            {
              uint64_t v60 = *(void *)a1;
              while (1)
              {
                unint64_t v61 = v59 >> 1;
                signed int v120 = v51;
                uint64_t v62 = v60 + 88 * (v59 >> 1);
                int v63 = arb::ascan((unsigned __int8 **)&v120, (const char **)v57, (unsigned __int8 *)v62, (const char *)1);
                if (!v63) {
                  break;
                }
                if (v63 > 0) {
                  unint64_t v64 = v61 + 1;
                }
                else {
                  unint64_t v64 = 0;
                }
                v60 += 88 * v64;
                if (v63 <= 0) {
                  v59 >>= 1;
                }
                else {
                  v59 -= v61 + 1;
                }
                if (!v59) {
                  goto LABEL_110;
                }
              }
            }
            else
            {
LABEL_110:
              uint64_t v62 = 0;
            }
            if (*(void *)(v62 + 40) != *(void *)(a1 + 48)) {
              return 0;
            }
            uint64_t result = __s1;
            if (*(_DWORD *)(v62 + 56) != *(_DWORD *)(a1 + 56)) {
              return 0;
            }
            goto LABEL_113;
          }
          return 0;
        }
      }
      int v51 = 0;
      goto LABEL_93;
    }
  }
  int v11 = strncmp(__s1, "MAX", 3uLL);
  int v12 = __s1 + 3;
  if (v11) {
    int v13 = 0;
  }
  else {
    int v13 = __s1 + 3;
  }
  *(void *)uint64_t v119 = v13;
  if (!v11
    && (int v14 = *v12, (v14 - 33) >= 0xFFFFFFE0)
    && !strncmp((const char *)a3, "RCP", 3uLL)
    && (int64_t v15 = (unsigned char *)(a3 + 3), *(unsigned __int8 *)(a3 + 3) - 33 >= 0xFFFFFFE0))
  {
LABEL_43:
    if ((v14 - 33) >= 0xFFFFFFE0)
    {
      do
      {
        int v30 = *++v12;
        int v14 = v30;
      }
      while ((v30 - 33) > 0xFFFFFFDF);
    }
    if (v14 == 35)
    {
      ++v12;
      while (1)
      {
        int v14 = *v12;
        if (!*v12) {
          break;
        }
        int v31 = *(v12++ - 1);
        if (v31 == 10)
        {
          --v12;
          goto LABEL_43;
        }
      }
    }
    size_t v37 = -1;
    do
      int v38 = v12[++v37];
    while ((ctype[2 * v38] & 0x40) != 0);
    if (!v38) {
      return 0;
    }
    uint64_t v39 = &v12[v37];
    if ((v38 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_64:
        int v40 = *++v39;
        int v38 = v40;
      }
      while ((v40 - 33) > 0xFFFFFFDF);
    }
LABEL_65:
    if (v38 == 35)
    {
      uint64_t v41 = v39;
      while (1)
      {
        int v42 = *++v41;
        int v38 = v42;
        if (!v42) {
          return 0;
        }
        int v43 = *v39;
        uint64_t v39 = v41;
        if (v43 == 10)
        {
          uint64_t v39 = v41;
          if ((v38 - 33) >= 0xFFFFFFE0) {
            goto LABEL_64;
          }
          goto LABEL_65;
        }
      }
    }
    if (v38 != 46) {
      return 0;
    }
    int v67 = v39[1];
    uint64_t v65 = (unsigned __int8 *)(v39 + 1);
    int v66 = v67;
    if (v67)
    {
      if ((v66 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_117:
          int v68 = *++v65;
          int v66 = v68;
        }
        while ((v68 - 33) > 0xFFFFFFDF);
      }
LABEL_118:
      if (v66 == 35)
      {
        ++v65;
        while (1)
        {
          int v66 = *v65;
          if (!*v65) {
            break;
          }
          int v69 = *(v65++ - 1);
          if (v69 == 10)
          {
            --v65;
            if ((v66 - 33) >= 0xFFFFFFE0) {
              goto LABEL_117;
            }
            goto LABEL_118;
          }
        }
      }
    }
    *(void *)uint64_t v119 = v65;
    int v75 = *v65;
    if (v75 != 119 && v75 != 97) {
      return 0;
    }
    uint64_t result = arb::achr((arb *)(v65 + 1), (const char *)0x2C);
    if (!result) {
      return result;
    }
    int v77 = (arb *)result;
    int64_t v78 = arb::asymbol((arb *)result, v119, (const char **)&v118, v76);
    uint64_t v80 = v118;
    size_t v79 = *(arb **)v119;
    uint64_t result = (char *)arb::isidentity(v77, *(arb **)v119, (const char *)v118, (const char *)v78, (const char *)4);
    if (!result) {
      return result;
    }
    uint64_t v81 = arb::obj_search(*(void *)a1, *(void *)(a1 + 8), (unsigned __int8 *)v79, (const char **)v80);
    if (*((void *)v81 + 5) != *(void *)(a1 + 48)) {
      return 0;
    }
    if (*((_DWORD *)v81 + 14) != *(_DWORD *)(a1 + 56)) {
      return 0;
    }
    unint64_t v82 = (arb *)arb::achr((arb *)v78, (const char *)0x2C);
    arb::asymbol(v82, v119, (const char **)&v118, v83);
    if (v82 != *(arb **)v119) {
      return 0;
    }
    uint64_t v84 = v118;
    int v85 = arb::obj_search(*(void *)a1, *(void *)(a1 + 8), (unsigned __int8 *)v82, (const char **)v118);
    if ((!v85
       || *((_UNKNOWN **)v85 + 5) != &constantKind
       || !arb::isepsilon(*((arb **)v85 + 8), (const char *)v84 + (void)v82, v86))
      && !arb::isepsilon(v82, (const char *)v84 + (void)v82, v86))
    {
      return 0;
    }
    uint64_t v111 = arb::atok(v15, v87);
    if (strncmp(v111, v12, v37) || (ctype[2 * v111[v37]] & 0x40) != 0) {
      return 0;
    }
    size_t v113 = (arb *)arb::atok(&v111[v37], v112);
    uint64_t result = arb::achr(v113, (const char *)0x2E);
    if (!result) {
      return result;
    }
    uint64_t v114 = result;
    if (strncmp(result, "xyz", 3uLL) && strncmp(v114, "rgb", 3uLL)) {
      return 0;
    }
    uint64_t result = arb::achr((arb *)(v114 + 3), (const char *)0x2C);
    if (!result) {
      return result;
    }
    uint64_t v115 = result;
    if (strncmp(result, v12, v37) || (ctype[2 * v115[v37]] & 0x40) != 0) {
      return 0;
    }
    uint64_t result = arb::achr((arb *)&v115[v37], (const char *)0x2E);
    if (!result) {
      return result;
    }
    int v116 = *result;
    if (v116 != 119 && v116 != 97) {
      return 0;
    }
    uint64_t v117 = arb::achr((arb *)(result + 1), (const char *)0x3B);
    if (strncmp(v117, "SWZ", 3uLL)) {
      return 0;
    }
    uint64_t v94 = v117 + 3;
    if (v117[3] - 33 < 0xFFFFFFE0) {
      return 0;
    }
  }
  else
  {
    int v16 = strncmp(__s1, "RCP", 3uLL);
    uint64_t result = 0;
    if (v16) {
      int v18 = 0;
    }
    else {
      int v18 = __s1 + 3;
    }
    *(void *)uint64_t v119 = v18;
    if (v16) {
      return result;
    }
    int v19 = *v12;
    if ((v19 - 33) < 0xFFFFFFE0) {
      return 0;
    }
    if (strncmp((const char *)a3, "SWZ", 3uLL)) {
      return 0;
    }
    int v21 = *(unsigned __int8 *)(a3 + 3);
    int v20 = (unsigned char *)(a3 + 3);
    if ((v21 - 33) < 0xFFFFFFE0) {
      return 0;
    }
    if ((v19 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_21:
        int v22 = *++v12;
        int v19 = v22;
      }
      while ((v22 - 33) > 0xFFFFFFDF);
    }
LABEL_22:
    if (v19 == 35)
    {
      ++v12;
      while (1)
      {
        int v19 = *v12;
        if (!*v12) {
          break;
        }
        int v23 = *(v12++ - 1);
        if (v23 == 10)
        {
          --v12;
          if ((v19 - 33) >= 0xFFFFFFE0) {
            goto LABEL_21;
          }
          goto LABEL_22;
        }
      }
    }
    size_t v37 = -1;
    do
      int v44 = v12[++v37];
    while ((ctype[2 * v44] & 0x40) != 0);
    if (!v44) {
      return 0;
    }
    unint64_t v45 = &v12[v37];
    if ((v44 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_75:
        int v46 = *++v45;
        int v44 = v46;
      }
      while ((v46 - 33) > 0xFFFFFFDF);
    }
LABEL_76:
    if (v44 == 35)
    {
      unint64_t v47 = v45;
      while (1)
      {
        int v48 = *++v47;
        int v44 = v48;
        if (!v48) {
          return 0;
        }
        int v49 = *v45;
        unint64_t v45 = v47;
        if (v49 == 10)
        {
          unint64_t v45 = v47;
          if ((v44 - 33) >= 0xFFFFFFE0) {
            goto LABEL_75;
          }
          goto LABEL_76;
        }
      }
    }
    if (v44 != 46) {
      return 0;
    }
    int v72 = v45[1];
    uint64_t v71 = v45 + 1;
    int v70 = v72;
    if (v72)
    {
      if ((v70 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_127:
          int v73 = *(unsigned __int8 *)++v71;
          int v70 = v73;
        }
        while ((v73 - 33) > 0xFFFFFFDF);
      }
LABEL_128:
      if (v70 == 35)
      {
        ++v71;
        while (1)
        {
          int v70 = *(unsigned __int8 *)v71;
          if (!*v71) {
            break;
          }
          int v74 = *((unsigned __int8 *)v71++ - 1);
          if (v74 == 10)
          {
            --v71;
            if ((v70 - 33) >= 0xFFFFFFE0) {
              goto LABEL_127;
            }
            goto LABEL_128;
          }
        }
      }
    }
    *(void *)uint64_t v119 = v71;
    if (strncmp(v71, "xyz", 3uLL))
    {
      if (strncmp(v71, "rgb", 3uLL)) {
        return 0;
      }
    }
    uint64_t result = arb::achr((arb *)(v71 + 3), (const char *)0x2C);
    if (!result) {
      return result;
    }
    arb::asymbol((arb *)result, v119, (const char **)&v118, v88);
    unint64_t v90 = v118;
    unint64_t v89 = *(arb **)v119;
    int v91 = arb::obj_search(*(void *)a1, *(void *)(a1 + 8), *(unsigned __int8 **)v119, (const char **)v118);
    if (*((void *)v91 + 5) != *(void *)(a1 + 48)) {
      return 0;
    }
    if (*((_DWORD *)v91 + 14) != *(_DWORD *)(a1 + 56)) {
      return 0;
    }
    if (*((unsigned char *)v90 + (void)v89) != 46) {
      return 0;
    }
    int v92 = *((unsigned __int8 *)v89 + (void)v90 + 1);
    if (v92 != 119 && v92 != 97) {
      return 0;
    }
    uint64_t result = arb::achr((arb *)((char *)v90 + (void)v89 + 2), (const char *)0x3B);
    if (!result) {
      return result;
    }
    uint64_t v94 = v20;
  }
  uint64_t v95 = arb::atok(v94, v93);
  if (strncmp(v95, v12, v37) || (ctype[2 * v95[v37]] & 0x40) != 0) {
    return 0;
  }
  uint64_t result = arb::achr((arb *)&v95[v37], (const char *)0x2E);
  if (result)
  {
    int v96 = *result;
    if (v96 != 119 && v96 != 97) {
      return 0;
    }
    uint64_t result = arb::achr((arb *)(result + 1), (const char *)0x2C);
    if (result)
    {
      signed int v97 = result;
      if (strncmp(result, v12, v37) || (ctype[2 * v97[v37]] & 0x40) != 0) {
        return 0;
      }
      uint64_t result = arb::achr((arb *)&v97[v37], (const char *)0x2C);
      if (result)
      {
        if (*result == 120)
        {
          uint64_t result = arb::achr((arb *)(result + 1), (const char *)0x2C);
          if (!result) {
            return result;
          }
          if (*result == 121)
          {
            uint64_t result = arb::achr((arb *)(result + 1), (const char *)0x2C);
            if (!result) {
              return result;
            }
            if (*result == 122)
            {
              uint64_t result = arb::achr((arb *)(result + 1), (const char *)0x2C);
              if (!result) {
                return result;
              }
              if (*result == 49)
              {
                uint64_t result = arb::achr((arb *)(result + 1), (const char *)0x3B);
                if (!result) {
                  return result;
                }
                string_t v98 = result;
                if (!strncmp(result, "MUL", 3uLL))
                {
                  int v100 = (arb *)arb::atok(v98 + 3, v99);
                  int v102 = arb::asymbol(v100, v119, (const char **)&v118, v101);
                  uint64_t result = arb::achr((arb *)v102, (const char *)0x2C);
                  if (result)
                  {
                    int v104 = (arb *)result;
                    int64_t v105 = arb::asymbol((arb *)result, v119, (const char **)&v118, v103);
                    uint64_t v107 = v118;
                    size_t v106 = *(arb **)v119;
                    uint64_t result = (char *)arb::isidentity(v104, *(arb **)v119, (const char *)v118, (const char *)v105, (const char *)4);
                    if (result)
                    {
                      uint64_t v108 = arb::obj_search(*(void *)a1, *(void *)(a1 + 8), (unsigned __int8 *)v106, (const char **)v107);
                      if (*((void *)v108 + 5) != *(void *)(a1 + 48)
                        || *((_DWORD *)v108 + 14) != *(_DWORD *)(a1 + 56))
                      {
                        return 0;
                      }
                      uint64_t result = arb::achr((arb *)v105, (const char *)0x2C);
                      if (result)
                      {
                        unint64_t v109 = result;
                        if (strncmp(result, v12, v37)) {
                          return 0;
                        }
                        if ((ctype[2 * v109[v37]] & 0x40) != 0) {
                          return 0;
                        }
                        int v110 = arb::achr((arb *)&v109[v37], (const char *)0x3B);
                        uint64_t result = v98;
                        if (!v110) {
                          return 0;
                        }
LABEL_113:
                        *(void *)(a1 + 32) = __s1;
                        *(void *)(a1 + 40) = result;
                        return result;
                      }
                    }
                  }
                  return result;
                }
              }
            }
          }
        }
        return 0;
      }
    }
  }
  return result;
}

unsigned __int8 *arb::aidx(arb *this, char *a2, unsigned int *a3, unsigned int *a4)
{
  int v4 = *(unsigned __int8 *)this;
  if (!*(unsigned char *)this) {
    return 0;
  }
  if ((v4 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_3:
      int v5 = *((unsigned __int8 *)this + 1);
      this = (arb *)((char *)this + 1);
      int v4 = v5;
    }
    while ((v5 - 33) > 0xFFFFFFDF);
  }
LABEL_4:
  if (v4 == 35)
  {
    int v6 = this;
    while (1)
    {
      int v7 = *((unsigned __int8 *)v6 + 1);
      int v6 = (arb *)((char *)v6 + 1);
      int v4 = v7;
      if (!v7) {
        return 0;
      }
      int v8 = *(unsigned __int8 *)this;
      this = v6;
      if (v8 == 10)
      {
        this = v6;
        if ((v4 - 33) >= 0xFFFFFFE0) {
          goto LABEL_3;
        }
        goto LABEL_4;
      }
    }
  }
  if (v4 != 91) {
    return 0;
  }
  int v11 = *((unsigned __int8 *)this + 1);
  int v9 = (unsigned __int8 *)this + 1;
  int v10 = v11;
  if (!v11)
  {
LABEL_21:
    if (a3)
    {
      if (a2) {
        *(_DWORD *)a2 = 0;
      }
      goto LABEL_24;
    }
    return 0;
  }
  if ((v10 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_13:
      int v12 = *++v9;
      int v10 = v12;
    }
    while ((v12 - 33) > 0xFFFFFFDF);
  }
LABEL_14:
  if (v10 == 35)
  {
    ++v9;
    while (1)
    {
      int v10 = *v9;
      if (!*v9) {
        goto LABEL_21;
      }
      int v13 = *(v9++ - 1);
      if (v13 == 10)
      {
        --v9;
        if ((v10 - 33) >= 0xFFFFFFE0) {
          goto LABEL_13;
        }
        goto LABEL_14;
      }
    }
  }
  if ((v10 - 58) < 0xFFFFFFF6) {
    goto LABEL_21;
  }
  int v21 = 0;
  do
  {
    int v21 = v10 + 10 * v21 - 48;
    int v22 = *++v9;
    int v10 = v22;
  }
  while ((v22 - 58) > 0xFFFFFFF5);
  if (v10)
  {
    if ((v10 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_44:
        int v23 = *++v9;
        int v10 = v23;
      }
      while ((v23 - 33) > 0xFFFFFFDF);
    }
LABEL_45:
    if (v10 == 35)
    {
      ++v9;
      while (1)
      {
        int v10 = *v9;
        if (!*v9) {
          break;
        }
        int v24 = *(v9++ - 1);
        if (v24 == 10)
        {
          --v9;
          if ((v10 - 33) >= 0xFFFFFFE0) {
            goto LABEL_44;
          }
          goto LABEL_45;
        }
      }
    }
  }
  if (a2) {
    *(_DWORD *)a2 = v21;
  }
  if (!a3) {
    goto LABEL_26;
  }
  *a3 = v21;
  int v15 = *v9;
  if (v15 == 46)
  {
    if (v9[1] != 46) {
      goto LABEL_26;
    }
    int v26 = v9[2];
    v9 += 2;
    int v25 = v26;
    if (v26)
    {
      int v27 = v9;
      if ((v25 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_58:
          int v28 = *++v27;
          int v25 = v28;
        }
        while ((v28 - 33) > 0xFFFFFFDF);
      }
LABEL_59:
      if (v25 == 35)
      {
        int v29 = v27;
        while (1)
        {
          int v30 = *++v29;
          int v25 = v30;
          if (!v30) {
            break;
          }
          int v31 = *v27;
          int v27 = v29;
          if (v31 == 10)
          {
            int v27 = v29;
            if ((v25 - 33) >= 0xFFFFFFE0) {
              goto LABEL_58;
            }
            goto LABEL_59;
          }
        }
      }
      else if ((v25 - 58) >= 0xFFFFFFF6)
      {
        int v14 = 0;
        do
        {
          int v14 = v25 + 10 * v14 - 48;
          int v32 = *++v27;
          int v25 = v32;
        }
        while ((v32 - 58) > 0xFFFFFFF5);
        if (!v25) {
          goto LABEL_77;
        }
        if ((v25 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_70:
            int v33 = *++v27;
            int v25 = v33;
          }
          while ((v33 - 33) > 0xFFFFFFDF);
        }
LABEL_71:
        if (v25 == 35)
        {
          int v9 = v27 + 1;
          while (1)
          {
            int v25 = *v9;
            if (!*v9) {
              break;
            }
            int v34 = *(v9++ - 1);
            if (v34 == 10)
            {
              int v27 = v9 - 1;
              if ((v25 - 33) >= 0xFFFFFFE0) {
                goto LABEL_70;
              }
              goto LABEL_71;
            }
          }
        }
        else
        {
LABEL_77:
          int v9 = v27;
        }
        goto LABEL_25;
      }
    }
LABEL_24:
    int v14 = -1;
LABEL_25:
    *a3 = v14;
LABEL_26:
    int v15 = *v9;
  }
  if (!v15) {
    return 0;
  }
  if ((v15 - 33) >= 0xE0u)
  {
    do
    {
LABEL_29:
      char v16 = *++v9;
      LOBYTE(v15) = v16;
    }
    while ((v16 - 33) > 0xDFu);
  }
LABEL_30:
  if (v15 == 35)
  {
    uint64_t v17 = v9;
    while (1)
    {
      int v18 = *++v17;
      LOBYTE(v15) = v18;
      if (!v18) {
        return 0;
      }
      int v19 = *v9;
      int v9 = v17;
      if (v19 == 10)
      {
        int v9 = v17;
        if ((v15 - 33) >= 0xE0u) {
          goto LABEL_29;
        }
        goto LABEL_30;
      }
    }
  }
  if (v15 == 93) {
    return v9 + 1;
  }
  else {
    return 0;
  }
}

uint64_t arb::obj_key(char **a1, unsigned __int8 *a2, const char **a3)
{
  int v5 = *a1;
  unint64_t v6 = (unint64_t)a1[1];
  uint64_t v7 = (uint64_t)&(*a1)[88 * v6];
  if (!v6) {
    goto LABEL_13;
  }
  unint64_t v8 = (unint64_t)a1[1];
  int v9 = *a1;
  while (1)
  {
    unint64_t v10 = v8 >> 1;
    int v29 = a2;
    int v11 = (unsigned __int8 *)&v9[88 * (v8 >> 1)];
    int v12 = arb::ascan(&v29, a3, v11, (const char *)1);
    if (!v12) {
      break;
    }
    if (v12 > 0)
    {
      unint64_t v13 = v10 + 1;
    }
    else
    {
      uint64_t v7 = (uint64_t)&v9[88 * (v8 >> 1)];
      unint64_t v13 = 0;
    }
    v9 += 88 * v13;
    if (v12 <= 0) {
      v8 >>= 1;
    }
    else {
      v8 -= v10 + 1;
    }
    if (!v8) {
      goto LABEL_13;
    }
  }
  if (!v9)
  {
LABEL_13:
    unint64_t v14 = 0x2E8BA2E8BA2E8BA3 * ((v7 - (uint64_t)v5) >> 3);
    unint64_t v15 = (unint64_t)a1[2];
    unint64_t v16 = (v6 & 0xFFFFFFFFFFFFFFF0) + 16;
    if (v6 + 1 > v15 && v15 != v16)
    {
      a1[2] = (char *)v16;
      int v26 = (char *)malloc_type_realloc(v5, 88 * v16, 0x10500400A17BEF8uLL);
      int v5 = v26;
      *a1 = v26;
      unint64_t v6 = (unint64_t)a1[1];
      int v27 = a1[2];
      if (v6 > (unint64_t)v27)
      {
        a1[1] = v27;
        unint64_t v6 = (unint64_t)v27;
      }
    }
    if (v6 > v14)
    {
      memmove(&v5[88 * v14 + 88], &v5[88 * v14], 88 * (v6 - v14));
      int v5 = *a1;
      unint64_t v6 = (unint64_t)a1[1];
    }
    a1[1] = (char *)(v6 + 1);
    int v11 = (unsigned __int8 *)&v5[88 * v14];
    uint64_t v18 = 0;
    if (a3)
    {
      unint64_t v19 = 0;
      do
      {
        int v20 = a2[v19];
        if ((v20 - 33) <= 0xFFFFFFDF)
        {
          v11[v18++] = v20;
          int v21 = &a2[++v19];
          if (a2[v19] == 35)
          {
LABEL_28:
            int v22 = 35;
LABEL_30:
            if (v22 == 35)
            {
              ++v21;
              while (1)
              {
                int v22 = *v21;
                if (!*v21) {
                  break;
                }
                int v24 = *(v21++ - 1);
                if (v24 == 10)
                {
                  --v21;
                  if ((v22 - 33) >= 0xFFFFFFE0)
                  {
                    do
                    {
                      int v23 = *++v21;
                      int v22 = v23;
                    }
                    while ((v23 - 33) > 0xFFFFFFDF);
                  }
                  goto LABEL_30;
                }
              }
            }
            unint64_t v19 = v21 - a2;
          }
        }
        else
        {
          int v21 = &a2[++v19];
          if (a2[v19] == 35) {
            goto LABEL_28;
          }
        }
      }
      while (v19 < (unint64_t)a3);
    }
    v11[v18] = 0;
    int v5 = *a1;
  }
  return 0x2E8BA2E8BA2E8BA3 * ((v11 - (unsigned __int8 *)v5) >> 3);
}

unsigned char *arb::achr(arb *this, const char *a2)
{
  char v2 = *(unsigned char *)this;
  if (*(unsigned char *)this)
  {
    if ((v2 - 33) >= 0xE0u)
    {
      do
      {
LABEL_3:
        char v3 = *((unsigned char *)this + 1);
        this = (arb *)((char *)this + 1);
        char v2 = v3;
      }
      while ((v3 - 33) > 0xDFu);
    }
LABEL_4:
    if (v2 == 35)
    {
      this = (arb *)((char *)this + 1);
      while (1)
      {
        char v2 = *(unsigned char *)this;
        if (!*(unsigned char *)this) {
          break;
        }
        int v4 = *((unsigned __int8 *)this - 1);
        this = (arb *)((char *)this + 1);
        if (v4 == 10)
        {
          this = (arb *)((char *)this - 1);
          if ((v2 - 33) >= 0xE0u) {
            goto LABEL_3;
          }
          goto LABEL_4;
        }
      }
    }
  }
  if (v2 != a2) {
    return 0;
  }
  int v7 = *((unsigned __int8 *)this + 1);
  uint64_t result = (char *)this + 1;
  int v6 = v7;
  if (v7)
  {
    if ((v6 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_13:
        int v8 = *++result;
        int v6 = v8;
      }
      while ((v8 - 33) > 0xFFFFFFDF);
    }
LABEL_14:
    if (v6 == 35)
    {
      ++result;
      while (1)
      {
        int v6 = *result;
        if (!*result) {
          break;
        }
        int v9 = *(result++ - 1);
        if (v9 == 10)
        {
          --result;
          if ((v6 - 33) >= 0xFFFFFFE0) {
            goto LABEL_13;
          }
          goto LABEL_14;
        }
      }
    }
  }
  return result;
}

char *arb::obj_texop(uint64_t a1, char *a2, arb *this, int a4, int8x8_t *a5)
{
  uint64_t v5 = 1;
  if (*((unsigned char *)this + 1) == 69) {
    uint64_t v5 = 2;
  }
  uint64_t v119 = (char **)v5;
  if (*((unsigned char *)this + v5) != 88) {
    return 0;
  }
  __s1 = 0;
  uint64_t v118 = 0;
  int v116 = 0;
  unint64_t v10 = (unsigned __int8 *)this + 2;
  int v11 = *((unsigned __int8 *)this + 2);
  int v12 = arb::isssat(this, a2);
  do
  {
    int v15 = *++v10;
    int v14 = v15;
  }
  while ((ctype[2 * v15] & 0x40) != 0);
  if (v11 == 88) {
    int v16 = a4;
  }
  else {
    int v16 = 0;
  }
  int64_t v112 = v12;
  if (v14)
  {
    if ((v14 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_11:
        int v17 = *++v10;
        int v14 = v17;
      }
      while ((v17 - 33) > 0xFFFFFFDF);
    }
LABEL_12:
    if (v14 == 35)
    {
      ++v10;
      while (1)
      {
        int v14 = *v10;
        if (!*v10) {
          break;
        }
        int v18 = *(v10++ - 1);
        if (v18 == 10)
        {
          --v10;
          if ((v14 - 33) >= 0xFFFFFFE0) {
            goto LABEL_11;
          }
          goto LABEL_12;
        }
      }
    }
    else
    {
      while (v14 == 46)
      {
        int v22 = v10[1];
        int v21 = v10 + 1;
        int v20 = v22;
        if (v22)
        {
          if ((v20 - 33) >= 0xFFFFFFE0)
          {
            do
            {
LABEL_21:
              int v23 = *++v21;
              int v20 = v23;
            }
            while ((v23 - 33) > 0xFFFFFFDF);
          }
LABEL_22:
          if (v20 == 35)
          {
            ++v21;
            while (1)
            {
              int v20 = *v21;
              if (!*v21) {
                break;
              }
              int v24 = *(v21++ - 1);
              if (v24 == 10)
              {
                --v21;
                if ((v20 - 33) >= 0xFFFFFFE0) {
                  goto LABEL_21;
                }
                goto LABEL_22;
              }
            }
          }
        }
        unint64_t v10 = v21 - 1;
        do
        {
          int v25 = *++v10;
          int v14 = v25;
        }
        while ((ctype[2 * v25] & 0x40) != 0);
        if (!v14) {
          break;
        }
        if ((v14 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_32:
            int v26 = *++v10;
            int v14 = v26;
          }
          while ((v26 - 33) > 0xFFFFFFDF);
        }
LABEL_33:
        if (v14 == 35)
        {
          ++v10;
          while (1)
          {
            int v14 = *v10;
            if (!*v10) {
              goto LABEL_40;
            }
            int v27 = *(v10++ - 1);
            if (v27 == 10)
            {
              --v10;
              if ((v14 - 33) >= 0xFFFFFFE0) {
                goto LABEL_32;
              }
              goto LABEL_33;
            }
          }
        }
      }
    }
  }
LABEL_40:
  int v28 = arb::asymbol((arb *)v10, (char *)&v118, (const char **)&v116, v13);
  int v30 = *v28;
  if (!*v28) {
    goto LABEL_93;
  }
  int v31 = v28;
LABEL_42:
  if ((v30 - 33) >= 0xFFFFFFE0)
  {
    do
    {
      int v32 = *++v31;
      int v30 = v32;
    }
    while ((v32 - 33) > 0xFFFFFFDF);
  }
  if (v30 == 35)
  {
    int v33 = v31;
    while (1)
    {
      int v34 = *++v31;
      int v30 = v34;
      if (!v34) {
        goto LABEL_93;
      }
      int v35 = *v33;
      int v33 = v31;
      if (v35 == 10) {
        goto LABEL_42;
      }
    }
  }
  if (v30 != 40) {
    goto LABEL_74;
  }
  while (1)
  {
    if (v30 != 35)
    {
      int v38 = *++v31;
      int v30 = v38;
      goto LABEL_60;
    }
LABEL_53:
    if (v30 == 35) {
      break;
    }
LABEL_60:
    if (v30 == 41 || v30 == 0) {
      goto LABEL_65;
    }
  }
  ++v31;
  while (1)
  {
    int v30 = *v31;
    if (!*v31) {
      break;
    }
    int v37 = *(v31++ - 1);
    if (v37 == 10)
    {
      --v31;
      if ((v30 - 33) >= 0xFFFFFFE0)
      {
        do
        {
          int v36 = *++v31;
          int v30 = v36;
        }
        while ((v36 - 33) > 0xFFFFFFDF);
      }
      goto LABEL_53;
    }
  }
LABEL_65:
  int v40 = *++v31;
  int v30 = v40;
  if (v40)
  {
    if ((v30 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_67:
        int v41 = *++v31;
        int v30 = v41;
      }
      while ((v41 - 33) > 0xFFFFFFDF);
    }
LABEL_68:
    if (v30 == 35)
    {
      int v42 = v31;
      while (1)
      {
        int v43 = *++v42;
        int v30 = v43;
        if (!v43) {
          goto LABEL_93;
        }
        int v44 = *v31;
        int v31 = v42;
        if (v44 == 10)
        {
          int v31 = v42;
          if ((v30 - 33) >= 0xFFFFFFE0) {
            goto LABEL_67;
          }
          goto LABEL_68;
        }
      }
    }
LABEL_74:
    if (!v30) {
      goto LABEL_93;
    }
    if ((v30 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_76:
        int v45 = *++v31;
        int v30 = v45;
      }
      while ((v45 - 33) > 0xFFFFFFDF);
    }
LABEL_77:
    if (v30 == 35)
    {
      int v46 = v31;
      while (1)
      {
        int v47 = *++v46;
        int v30 = v47;
        if (!v47) {
          goto LABEL_93;
        }
        int v48 = *v31;
        int v31 = v46;
        if (v48 == 10)
        {
          int v31 = v46;
          if ((v30 - 33) >= 0xFFFFFFE0) {
            goto LABEL_76;
          }
          goto LABEL_77;
        }
      }
    }
    if (v30 != 44) {
      goto LABEL_93;
    }
    int v51 = v31[1];
    int v50 = (arb *)(v31 + 1);
    int v49 = v51;
    if (v51)
    {
      if ((v49 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_86:
          int v52 = *((unsigned __int8 *)v50 + 1);
          int v50 = (arb *)((char *)v50 + 1);
          int v49 = v52;
        }
        while ((v52 - 33) > 0xFFFFFFDF);
      }
LABEL_87:
      if (v49 == 35)
      {
        int v50 = (arb *)((char *)v50 + 1);
        while (1)
        {
          int v49 = *(unsigned __int8 *)v50;
          if (!*(unsigned char *)v50) {
            break;
          }
          int v53 = *((unsigned __int8 *)v50 - 1);
          int v50 = (arb *)((char *)v50 + 1);
          if (v53 == 10)
          {
            int v50 = (arb *)((char *)v50 - 1);
            if ((v49 - 33) >= 0xFFFFFFE0) {
              goto LABEL_86;
            }
            goto LABEL_87;
          }
        }
      }
    }
  }
  else
  {
LABEL_93:
    int v50 = 0;
  }
  uint64_t v114 = 0;
  *(void *)uint64_t v115 = 0;
  int v54 = (char *)arb::asymbol(v50, v115, (const char **)&v114, v29);
  int v55 = v54;
  if (v11 == 81)
  {
    int v16 = 0;
    BOOL v56 = 1;
    int v57 = *v54;
    if (!*v54) {
      goto LABEL_122;
    }
LABEL_100:
    unint64_t v59 = v55;
    if ((v57 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_101:
        int v60 = *(unsigned __int8 *)++v59;
        int v57 = v60;
      }
      while ((v60 - 33) > 0xFFFFFFDF);
    }
LABEL_102:
    if (v57 == 35)
    {
      unint64_t v61 = v59;
      while (1)
      {
        int v62 = *(unsigned __int8 *)++v61;
        int v57 = v62;
        if (!v62) {
          goto LABEL_122;
        }
        int v63 = *(unsigned __int8 *)v59;
        unint64_t v59 = v61;
        if (v63 == 10)
        {
          unint64_t v59 = v61;
          if ((v57 - 33) >= 0xFFFFFFE0) {
            goto LABEL_101;
          }
          goto LABEL_102;
        }
      }
    }
    if (v57 != 44) {
      goto LABEL_122;
    }
    int v68 = *((unsigned __int8 *)v59 + 1);
    int v67 = (char *)(v59 + 1);
    int v66 = v68;
    if (v68)
    {
      if ((v66 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_115:
          int v69 = *++v67;
          int v66 = v69;
        }
        while ((v69 - 33) > 0xFFFFFFDF);
      }
LABEL_116:
      if (v66 == 35)
      {
        ++v67;
        while (1)
        {
          int v66 = *v67;
          if (!*v67) {
            break;
          }
          int v70 = *(v67++ - 1);
          if (v70 == 10)
          {
            --v67;
            if ((v66 - 33) >= 0xFFFFFFE0) {
              goto LABEL_115;
            }
            goto LABEL_116;
          }
        }
      }
    }
  }
  else
  {
    if (v50 != *(arb **)v115
      || (int v58 = v54, &v114[(void)v50] != v54)
      && (v64 = strncmp(v54 - 4, "xyzw", 4uLL), int v58 = (void *)v55, v64)
      && (v65 = strncmp(v55 - 4, "rgba", 4uLL), int v58 = (void *)v55, v65))
    {
      int v58 = 0;
    }
    BOOL v56 = v58 != 0;
    int v57 = *(unsigned __int8 *)v55;
    if (*v55) {
      goto LABEL_100;
    }
LABEL_122:
    int v67 = 0;
  }
  int v72 = arb::obj_add(a1, *(char **)v115, (const char **)v114, (uint64_t)a5, 0);
  if (v11 != 68)
  {
LABEL_165:
    if (strncmp(v67, "texture", 7uLL)) {
      goto LABEL_177;
    }
LABEL_166:
    int v96 = (arb *)(v67 + 7);
    *(_DWORD *)a2 = 0;
    signed int v97 = arb::aidx(v96, a2, 0, v95);
    if (!v97) {
      signed int v97 = (unsigned __int8 *)v96;
    }
    if (a5)
    {
      a5->i32[1] |= 1 << *(_DWORD *)a2;
      if (*(_DWORD *)a2 >= a5[5].u8[0]) {
        a5[5].i8[0] = *(_DWORD *)a2 + 1;
      }
    }
    if (!v72 || *((_UNKNOWN **)v72 + 5) != &fragmentKind)
    {
      if (a5) {
        BOOL v56 = 0;
      }
      goto LABEL_177;
    }
    uint64_t v102 = *((void *)v72 + 8);
    if (v16)
    {
      if (v102)
      {
LABEL_195:
        BOOL v56 = 0;
        LOBYTE(v16) = 1;
        goto LABEL_177;
      }
      if (*(_DWORD *)a2 == *((_DWORD *)v72 + 14))
      {
        if (a5)
        {
          string_t v103 = arb::achr((arb *)v97, (const char *)0x2C);
          int64_t v105 = arb::atok(v103, v104);
          if (strncmp(v105, "RECT", 4uLL))
          {
            LOBYTE(v16) = 0;
            goto LABEL_177;
          }
          if (!arb::isidentity(v50, *(arb **)v115, v114, v55, (const char *)2)) {
            goto LABEL_195;
          }
          uint64_t v108 = (arb *)arb::achr((arb *)(v105 + 4), (const char *)0x2C);
          if (v108)
          {
            unint64_t v109 = arb::achr(v108, (const char *)0x28);
            if (v109)
            {
              *(_DWORD *)size_t v113 = 0;
              do
              {
                uint64_t v111 = (arb *)arb::atoi(v109, v113, v110);
                if (!v111) {
                  break;
                }
                if (*(_DWORD *)v113) {
                  goto LABEL_195;
                }
                unint64_t v109 = arb::achr(v111, (const char *)0x2C);
              }
              while (v109);
            }
          }
        }
        LOBYTE(v16) = 1;
        goto LABEL_177;
      }
    }
    else if (v102)
    {
      LOBYTE(v16) = 0;
      BOOL v56 = 0;
      goto LABEL_177;
    }
    BOOL v56 = 0;
    if (a5)
    {
      int v106 = *((_DWORD *)v72 + 14);
      if (*(_DWORD *)a2 != v106)
      {
        BOOL v56 = 0;
        int v107 = 1 << v106;
        a5[1] = vand_s8(a5[1], (int8x8_t)vdup_n_s32(~v107));
        a5[2].i32[0] &= ~v107;
      }
    }
    goto LABEL_177;
  }
  if (!a5) {
    goto LABEL_176;
  }
  int v73 = arb::asymbol((arb *)v67, (char *)&__s1, (const char **)&v119, v71);
  arb::obj_add(a1, __s1, (const char **)v119, (uint64_t)a5, 1);
  int v75 = *v73;
  if (!*v73) {
    goto LABEL_144;
  }
  if ((v75 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_127:
      int v76 = *++v73;
      int v75 = v76;
    }
    while ((v76 - 33) > 0xFFFFFFDF);
  }
LABEL_128:
  if (v75 == 35)
  {
    int v77 = v73;
    while (1)
    {
      int v78 = *++v77;
      int v75 = v78;
      if (!v78) {
        break;
      }
      int v79 = *v73;
      int v73 = v77;
      if (v79 == 10)
      {
        int v73 = v77;
        if ((v75 - 33) >= 0xFFFFFFE0) {
          goto LABEL_127;
        }
        goto LABEL_128;
      }
    }
LABEL_144:
    uint64_t v81 = 0;
  }
  else
  {
    if (v75 != 44) {
      goto LABEL_144;
    }
    int v82 = v73[1];
    uint64_t v81 = (arb *)(v73 + 1);
    int v80 = v82;
    if (v82)
    {
      if ((v80 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_137:
          int v83 = *((unsigned __int8 *)v81 + 1);
          uint64_t v81 = (arb *)((char *)v81 + 1);
          int v80 = v83;
        }
        while ((v83 - 33) > 0xFFFFFFDF);
      }
LABEL_138:
      if (v80 == 35)
      {
        uint64_t v81 = (arb *)((char *)v81 + 1);
        while (1)
        {
          int v80 = *(unsigned __int8 *)v81;
          if (!*(unsigned char *)v81) {
            break;
          }
          int v84 = *((unsigned __int8 *)v81 - 1);
          uint64_t v81 = (arb *)((char *)v81 + 1);
          if (v84 == 10)
          {
            uint64_t v81 = (arb *)((char *)v81 - 1);
            if ((v80 - 33) >= 0xFFFFFFE0) {
              goto LABEL_137;
            }
            goto LABEL_138;
          }
        }
      }
    }
  }
  int v85 = arb::asymbol(v81, (char *)&__s1, (const char **)&v119, v74);
  arb::obj_add(a1, __s1, (const char **)v119, (uint64_t)a5, 1);
  int v86 = *v85;
  if (!*v85)
  {
LABEL_164:
    int v16 = 0;
    int v67 = 0;
    goto LABEL_165;
  }
  if ((v86 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_147:
      int v87 = *++v85;
      int v86 = v87;
    }
    while ((v87 - 33) > 0xFFFFFFDF);
  }
LABEL_148:
  if (v86 == 35)
  {
    uint64_t v88 = v85;
    while (1)
    {
      int v89 = *++v88;
      int v86 = v89;
      if (!v89) {
        goto LABEL_164;
      }
      int v90 = *v85;
      int v85 = v88;
      if (v90 == 10)
      {
        int v85 = v88;
        if ((v86 - 33) >= 0xFFFFFFE0) {
          goto LABEL_147;
        }
        goto LABEL_148;
      }
    }
  }
  if (v86 != 44) {
    goto LABEL_164;
  }
  int v92 = v85[1];
  int v67 = (char *)(v85 + 1);
  int v91 = v92;
  if (v92)
  {
    if ((v91 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_157:
        int v93 = *++v67;
        int v91 = v93;
      }
      while ((v93 - 33) > 0xFFFFFFDF);
    }
LABEL_158:
    if (v91 == 35)
    {
      ++v67;
      while (1)
      {
        int v91 = *v67;
        if (!*v67) {
          break;
        }
        int v94 = *(v67++ - 1);
        if (v94 == 10)
        {
          --v67;
          if ((v91 - 33) >= 0xFFFFFFE0) {
            goto LABEL_157;
          }
          goto LABEL_158;
        }
      }
    }
  }
LABEL_176:
  int v16 = 0;
  if (!strncmp(v67, "texture", 7uLL)) {
    goto LABEL_166;
  }
LABEL_177:
  unint64_t v19 = v118;
  if (v118)
  {
    string_t v98 = arb::obj_add(a1, v118, (const char **)v116, (uint64_t)a5, 1);
    if (a5)
    {
      if (v98)
      {
        int v99 = (void *)*((void *)v98 + 5);
        *(void *)(a1 + 48) = v99;
        *(_DWORD *)(a1 + 56) = *((_DWORD *)v98 + 14);
        if (v99 == &outputKind && v112 != 0) {
          *(_DWORD *)(a1 + 60) = 1;
        }
LABEL_186:
        if (v56)
        {
          if (v16)
          {
LABEL_191:
            a5[2].i32[0] &= ~(1 << *(_DWORD *)a2);
            return v19;
          }
        }
        else
        {
          a5[1].i32[0] &= ~(1 << *(_DWORD *)a2);
        }
        a5[1].i32[1] &= ~(1 << *(_DWORD *)a2);
        goto LABEL_191;
      }
    }
  }
  if (a5) {
    goto LABEL_186;
  }
  return v19;
}

uint64_t arb::alen(arb *this, const char *a2)
{
  BOOL v3 = *(unsigned __int8 *)this - 48 < 0xA || (ctype[2 * *(unsigned __int8 *)this] & 0x40) == 0;
  int v4 = (const char *)this;
  if (!v3)
  {
    int v5 = (int)a2;
    int v6 = 0;
    int v7 = 0;
    int v8 = 0;
    int v9 = "state";
    unint64_t v10 = "texgen";
    int v11 = this;
    int v4 = (const char *)this;
    while (1)
    {
      uint64_t v12 = 0;
      do
        char v13 = ctype[2 * v4[++v12]];
      while ((v13 & 0x40) != 0);
      if (!v12) {
        return v4 - (const char *)this;
      }
      if (v7)
      {
        int v14 = v10;
        int v15 = v9;
        if (!strncmp(v4, "eye", 3uLL))
        {
          int v7 = 0;
          int v6 = v4 + 3;
          int v16 = (arb *)&v4[v12];
          int v17 = v4[v12];
          if (!v4[v12]) {
            goto LABEL_76;
          }
        }
        else
        {
          int v18 = strncmp(v4, "object", 6uLL);
          int v7 = 0;
          if (v18) {
            int v6 = 0;
          }
          else {
            int v6 = v4 + 6;
          }
          int v16 = (arb *)&v4[v12];
          int v17 = v4[v12];
          if (!v4[v12]) {
            goto LABEL_76;
          }
        }
      }
      else if (v8)
      {
        int v15 = v9;
        int v14 = v10;
        int v19 = strncmp(v4, v10, 6uLL);
        int v8 = 0;
        int v7 = v4 + 6;
        if (v19) {
          int v7 = 0;
        }
        int v16 = (arb *)&v4[v12];
        int v17 = v4[v12];
        if (!v4[v12])
        {
LABEL_76:
          int v31 = (const char *)v16;
          goto LABEL_72;
        }
      }
      else
      {
        int v14 = v10;
        if (v11 == this)
        {
          int v15 = v9;
          int v20 = strncmp(v4, v9, 5uLL);
          int v7 = 0;
          if (v20) {
            int v8 = 0;
          }
          else {
            int v8 = v4 + 5;
          }
          int v16 = (arb *)&v4[v12];
          int v17 = v4[v12];
          if (!v4[v12]) {
            goto LABEL_76;
          }
        }
        else
        {
          int v15 = v9;
          int v8 = 0;
          int v7 = 0;
          int v16 = (arb *)&v4[v12];
          int v17 = v4[v12];
          if (!v4[v12]) {
            goto LABEL_76;
          }
        }
      }
      int v21 = (unsigned __int8 *)v16;
      while (1)
      {
        int v11 = v16;
        int v22 = v17;
        int v16 = (arb *)v21;
        if ((v17 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_32:
            int v23 = *((unsigned __int8 *)v16 + 1);
            int v16 = (arb *)((char *)v16 + 1);
            int v22 = v23;
          }
          while ((v23 - 33) > 0xFFFFFFDF);
        }
LABEL_33:
        int v24 = (char *)v16;
        if (v22 == 35) {
          break;
        }
        if (v22 != 91) {
          goto LABEL_52;
        }
        do
        {
          int v28 = *++v24;
          int v27 = v28;
          if (!v28) {
            break;
          }
          if ((v27 - 33) >= 0xFFFFFFE0)
          {
            do
            {
LABEL_41:
              int v29 = *++v24;
              int v27 = v29;
            }
            while ((v29 - 33) > 0xFFFFFFDF);
          }
LABEL_42:
          if (v27 == 35)
          {
            ++v24;
            while (1)
            {
              int v27 = *v24;
              if (!*v24) {
                goto LABEL_50;
              }
              int v30 = *(v24++ - 1);
              if (v30 == 10)
              {
                --v24;
                if ((v27 - 33) >= 0xFFFFFFE0) {
                  goto LABEL_41;
                }
                goto LABEL_42;
              }
            }
          }
        }
        while (v27 && v27 != 93);
LABEL_50:
        int v32 = v24[1];
        int v31 = v24 + 1;
        int v17 = v32;
        int v21 = (unsigned __int8 *)v31;
        if (!v32) {
          goto LABEL_72;
        }
      }
      while (1)
      {
        int v25 = *++v24;
        int v22 = v25;
        if (!v25) {
          break;
        }
        int v26 = *(unsigned __int8 *)v16;
        int v16 = (arb *)v24;
        if (v26 == 10)
        {
          int v16 = (arb *)v24;
          if ((v22 - 33) >= 0xFFFFFFE0) {
            goto LABEL_32;
          }
          goto LABEL_33;
        }
      }
LABEL_52:
      int v33 = v21;
      if ((v17 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_53:
          int v34 = *++v33;
          int v17 = v34;
        }
        while ((v34 - 33) > 0xFFFFFFDF);
      }
LABEL_54:
      if (v17 == 35)
      {
        int v35 = v33;
        while (1)
        {
          int v36 = *++v35;
          int v17 = v36;
          if (!v36) {
            break;
          }
          int v37 = *v33;
          int v33 = v35;
          if (v37 == 10)
          {
            int v33 = v35;
            if ((v17 - 33) >= 0xFFFFFFE0) {
              goto LABEL_53;
            }
            goto LABEL_54;
          }
        }
LABEL_71:
        int v31 = (const char *)v21;
        int v16 = v11;
LABEL_72:
        if (v5) {
          int v4 = v31;
        }
        else {
          int v4 = (const char *)v16;
        }
        return v4 - (const char *)this;
      }
      if (v17 != 46) {
        goto LABEL_71;
      }
      int v4 = (const char *)(v33 + 1);
      char v38 = ctype[2 * v33[1]];
      if (!v6 && (ctype[2 * v33[1]] & 0x20) != 0)
      {
        char v39 = ctype[2 * v33[2]];
        if ((v39 & 0x20) != 0)
        {
          char v39 = ctype[2 * v33[3]];
          if ((v39 & 0x20) != 0)
          {
            char v39 = ctype[2 * v33[4]];
            if ((v39 & 0x20) != 0) {
              char v39 = ctype[2 * v33[5]];
            }
          }
        }
        if ((v39 & 0x40) == 0)
        {
          if (v5) {
            int v4 = (const char *)v21;
          }
          else {
            int v4 = (const char *)v11;
          }
          return v4 - (const char *)this;
        }
      }
      if (v33[1] - 48 >= 0xA)
      {
        int v9 = v15;
        unint64_t v10 = v14;
        if ((v38 & 0x40) != 0) {
          continue;
        }
      }
      return v4 - (const char *)this;
    }
  }
  return v4 - (const char *)this;
}

unsigned __int8 *arb::obj_declare(char **a1, unint64_t *a2, unsigned char *a3, const void *a4, size_t __n, signed int *a6, arb *this, uint64_t a8, uint64_t a9)
{
  *(void *)uint64_t v147 = 0;
  uint64_t v14 = *(unsigned __int8 *)this;
  if (*(unsigned char *)this)
  {
    int v15 = *(unsigned __int8 *)this;
    int v16 = this;
    if ((v14 - 33) < 0xFFFFFFE0) {
      goto LABEL_4;
    }
    do
    {
LABEL_3:
      int v17 = *((unsigned __int8 *)v16 + 1);
      int v16 = (arb *)((char *)v16 + 1);
      int v15 = v17;
    }
    while ((v17 - 33) > 0xFFFFFFDF);
LABEL_4:
    while (v15 == 35)
    {
      int v18 = v16;
      do
      {
        int v19 = *((unsigned __int8 *)v18 + 1);
        int v18 = (arb *)((char *)v18 + 1);
        int v15 = v19;
        if (!v19) {
          goto LABEL_20;
        }
        int v20 = *(unsigned __int8 *)v16;
        int v16 = v18;
      }
      while (v20 != 10);
      int v16 = v18;
      if ((v15 - 33) >= 0xFFFFFFE0) {
        goto LABEL_3;
      }
    }
    if (v15 == 123)
    {
      int v23 = *((unsigned __int8 *)v16 + 1);
      int v22 = (char *)v16 + 1;
      int v21 = v23;
      if (v23)
      {
        if ((v21 - 33) < 0xFFFFFFE0) {
          goto LABEL_14;
        }
        do
        {
LABEL_13:
          int v24 = *++v22;
          int v21 = v24;
        }
        while ((v24 - 33) > 0xFFFFFFDF);
LABEL_14:
        while (v21 == 35)
        {
          ++v22;
          do
          {
            int v21 = *v22;
            if (!*v22) {
              goto LABEL_199;
            }
            int v25 = *(v22++ - 1);
          }
          while (v25 != 10);
          --v22;
          if ((v21 - 33) >= 0xFFFFFFE0) {
            goto LABEL_13;
          }
        }
        if (v21)
        {
          do
          {
            while (1)
            {
              if ((v21 - 33) >= 0xFFFFFFE0)
              {
                do
                {
                  int v135 = *++v22;
                  int v21 = v135;
                }
                while ((v135 - 33) > 0xFFFFFFDF);
              }
              if (v21 != 35) {
                break;
              }
              ++v22;
              do
              {
                int v21 = *v22;
                if (!*v22) {
                  goto LABEL_199;
                }
                int v137 = *(v22++ - 1);
              }
              while (v137 != 10);
              --v22;
            }
            if (!v21) {
              break;
            }
            if (v21 == 125) {
              break;
            }
            int v136 = *++v22;
            int v21 = v136;
          }
          while (v136);
        }
      }
LABEL_199:
      unint64_t v125 = *a2;
      signed int v144 = *a6;
      unint64_t v126 = (unint64_t)a1[1];
      unint64_t v127 = (unint64_t)a1[2];
      if (v126 + 1 <= v127)
      {
        size_t v129 = *a1;
      }
      else
      {
        unint64_t v128 = (v126 & 0xFFFFFFFFFFFFFFF0) + 16;
        size_t v129 = *a1;
        if (v127 != v128)
        {
          a1[2] = (char *)v128;
          size_t v129 = (char *)malloc_type_realloc(v129, 88 * v128, 0x10500400A17BEF8uLL);
          *a1 = v129;
          unint64_t v126 = (unint64_t)a1[1];
          int v130 = a1[2];
          if (v126 > (unint64_t)v130)
          {
            a1[1] = v130;
            unint64_t v126 = (unint64_t)v130;
          }
        }
      }
      if (v126 > v125)
      {
        memmove(&v129[88 * v125 + 88], &v129[88 * v125], 88 * (v126 - v125));
        size_t v129 = *a1;
        unint64_t v126 = (unint64_t)a1[1];
      }
      char v39 = v22 + 1;
      a1[1] = (char *)(v126 + 1);
      int v131 = &v129[88 * v125];
      memcpy(v131, a4, __n);
      if (v144 != -1)
      {
        v131[__n] = 91;
        __n += itoa(&v131[__n + 1], v144) + 2;
        v131[__n - 1] = 93;
      }
      v131[__n] = 0;
      unint64_t v132 = (*a2)++;
      int v133 = *(unsigned __int16 *)(a9 + 20);
      uint64_t v134 = (uint64_t)&(*a1)[88 * v132];
      *(void *)(v134 + 40) = &constantKind;
      *(void *)(v134 + 48) = 2;
      *(_DWORD *)(v134 + 56) = v133;
      *(void *)(v134 + 64) = this;
      *(void *)(v134 + 72) = v39 - (unsigned __int8 *)this;
      *(void *)(v134 + 80) = a8;
      ++*a6;
      *(_WORD *)(a9 + 20) = v133 + 1;
      return v39;
    }
  }
LABEL_20:
  if ((v14 - 48) < 0xA || (ctype[2 * v14] & 0x40) == 0)
  {
    uint64_t v27 = 0;
    do
      int v28 = (char)ctype[2 * *((unsigned __int8 *)this + v27++)];
    while (v28 < 0);
    unint64_t v29 = *a2;
    signed int v30 = *a6;
    unint64_t v31 = (unint64_t)a1[1];
    unint64_t v32 = (unint64_t)a1[2];
    if (v31 + 1 <= v32)
    {
      int v34 = *a1;
    }
    else
    {
      unint64_t v33 = (v31 & 0xFFFFFFFFFFFFFFF0) + 16;
      int v34 = *a1;
      if (v32 != v33)
      {
        a1[2] = (char *)v33;
        int v34 = (char *)malloc_type_realloc(v34, 88 * v33, 0x10500400A17BEF8uLL);
        *a1 = v34;
        unint64_t v31 = (unint64_t)a1[1];
        int v35 = a1[2];
        if (v31 > (unint64_t)v35)
        {
          a1[1] = v35;
          unint64_t v31 = (unint64_t)v35;
        }
      }
    }
    if (v31 > v29)
    {
      memmove(&v34[88 * v29 + 88], &v34[88 * v29], 88 * (v31 - v29));
      int v34 = *a1;
      unint64_t v31 = (unint64_t)a1[1];
    }
    char v39 = (unsigned __int8 *)this + v27 - 1;
    a1[1] = (char *)(v31 + 1);
    int v45 = &v34[88 * v29];
    memcpy(v45, a4, __n);
    if (v30 != -1)
    {
      v45[__n] = 91;
      __n += itoa(&v45[__n + 1], v30) + 2;
      v45[__n - 1] = 93;
    }
    v45[__n] = 0;
    unint64_t v46 = (*a2)++;
    int v47 = *(unsigned __int16 *)(a9 + 20);
    uint64_t v48 = (uint64_t)&(*a1)[88 * v46];
    *(void *)(v48 + 40) = &constantKind;
    *(void *)(v48 + 48) = 2;
    *(_DWORD *)(v48 + 56) = v47;
    *(void *)(v48 + 64) = this;
    *(void *)(v48 + 72) = v27 - 1;
    *(void *)(v48 + 80) = a8;
    ++*a6;
    *(_WORD *)(a9 + 20) = v47 + 1;
    return v39;
  }
  uint64_t v143 = arb::alen(this, 0);
  int v36 = (char *)this + v143;
  char v38 = arb::aidx((arb *)((char *)this + v143), &v147[4], (unsigned int *)v147, v37);
  if (!v38)
  {
    int v42 = 0;
    int v49 = 0;
    *(void *)uint64_t v147 = 0;
    char v39 = (unsigned __int8 *)this + v143;
    int v41 = a3;
    goto LABEL_82;
  }
  char v39 = v38;
  int v40 = *v38;
  int v41 = a3;
  if (!*v38) {
    goto LABEL_81;
  }
  int v42 = v38;
  if ((v40 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_34:
      int v43 = *++v42;
      int v40 = v43;
    }
    while ((v43 - 33) > 0xFFFFFFDF);
  }
LABEL_35:
  if (v40 == 35)
  {
    ++v42;
    while (1)
    {
      int v40 = *v42;
      if (!*v42) {
        goto LABEL_52;
      }
      int v44 = *(v42++ - 1);
      if (v44 == 10)
      {
        --v42;
        if ((v40 - 33) >= 0xFFFFFFE0) {
          goto LABEL_34;
        }
        goto LABEL_35;
      }
    }
  }
  if (v40 <= 58)
  {
    if (!v40)
    {
LABEL_52:
      char v39 = v42;
      int v49 = v42;
      goto LABEL_82;
    }
    if (v40 != 44) {
      goto LABEL_56;
    }
LABEL_55:
    int v49 = 0;
    int v42 = v38;
    goto LABEL_82;
  }
  if (v40 == 59 || v40 == 125) {
    goto LABEL_55;
  }
LABEL_56:
  uint64_t v50 = 0;
  char v39 = v42;
  while (1)
  {
    if (!v50)
    {
      uint64_t v51 = 0;
      int v42 = v39;
      int v49 = v39;
      switch(v40)
      {
        case '#':
          goto LABEL_69;
        case '$':
        case '%':
        case '&':
        case '\'':
        case '*':
        case '+':
        case '-':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case '<':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '\\':
          goto LABEL_77;
        case '(':
        case '[':
          goto LABEL_76;
        case ')':
        case ']':
          goto LABEL_64;
        case ',':
        case ';':
          goto LABEL_82;
        default:
          if (v40 == 123) {
            goto LABEL_76;
          }
          if (v40 == 125) {
            goto LABEL_81;
          }
          goto LABEL_77;
      }
    }
    if (v40 <= 90) {
      break;
    }
    uint64_t v51 = v50;
    switch(v40)
    {
      case '[':
      case '{':
        goto LABEL_76;
      case '\\':
      case '^':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '|':
        break;
      case ']':
      case '}':
        goto LABEL_64;
      default:
        goto LABEL_80;
    }
LABEL_77:
    int v54 = *++v39;
    int v40 = v54;
    uint64_t v50 = v51;
LABEL_78:
    int v42 = v39;
    int v49 = v39;
    if (!v40) {
      goto LABEL_82;
    }
  }
  if (v40 != 35)
  {
    if (v40 == 40)
    {
LABEL_76:
      uint64_t v51 = (v50 + 1);
    }
    else if (v40 == 41)
    {
LABEL_64:
      uint64_t v51 = (v50 - 1);
    }
    else
    {
LABEL_80:
      uint64_t v51 = v50;
    }
    goto LABEL_77;
  }
LABEL_69:
  if ((v40 - 33) >= 0xFFFFFFE0)
  {
    do
    {
      int v53 = *++v39;
      int v40 = v53;
    }
    while ((v53 - 33) > 0xFFFFFFDF);
  }
  if (v40 != 35) {
    goto LABEL_78;
  }
  ++v39;
  while (1)
  {
    int v40 = *v39;
    if (!*v39) {
      break;
    }
    int v52 = *(v39++ - 1);
    if (v52 == 10)
    {
      --v39;
      goto LABEL_69;
    }
  }
LABEL_81:
  int v42 = v39;
  int v49 = v39;
LABEL_82:
  if (v41 == &paramKind)
  {
    if (!v49)
    {
      if (strncmp((const char *)this, "program", 7uLL)
        || (uint64_t v121 = arb::achr((arb *)((char *)this + 7), (const char *)0x2E)) == 0
        || strncmp(v121, "local", 5uLL))
      {
        if (!strncmp((const char *)this, "state", 5uLL)
          && (uint64_t v122 = arb::achr((arb *)((char *)this + 5), (const char *)0x2E)) != 0
          && !strncmp(v122, "matrix", 6uLL))
        {
          if (strncmp((const char *)this + v143 - 3, "row", 3uLL))
          {
            *(_DWORD *)uint64_t v147 = 3;
            *(_DWORD *)&v147[4] = 0;
            a8 |= 0x10uLL;
            if (v42) {
              char v39 = v42;
            }
          }
        }
        else
        {
          int v89 = *(_DWORD *)&v147[4];
          if (!v42) {
            int v89 = -1;
          }
          *(_DWORD *)&v147[4] = v89;
        }
        *(_DWORD *)(a9 + 4) |= 0x8000000u;
LABEL_133:
        unsigned int v90 = *(_DWORD *)&v147[4];
        if (*(_DWORD *)&v147[4] != -1)
        {
LABEL_134:
          if ((a8 & 0x10) == 0)
          {
            int v91 = *v36;
            if (*v36)
            {
              if ((v91 - 33) >= 0xFFFFFFE0)
              {
                do
                {
LABEL_137:
                  int v92 = *++v36;
                  int v91 = v92;
                }
                while ((v92 - 33) > 0xFFFFFFDF);
              }
LABEL_138:
              if (v91 == 35)
              {
                ++v36;
                while (1)
                {
                  int v91 = *v36;
                  if (!*v36) {
                    break;
                  }
                  int v93 = *(v36++ - 1);
                  if (v93 == 10)
                  {
                    --v36;
                    if ((v91 - 33) >= 0xFFFFFFE0) {
                      goto LABEL_137;
                    }
                    goto LABEL_138;
                  }
                }
              }
            }
            uint64_t v143 = v36 - (unsigned char *)this + 1;
          }
          if (v90 > *(_DWORD *)v147) {
            return v39;
          }
          string_t v138 = v39;
          int v94 = a2;
          uint64_t v95 = a8;
          size_t v96 = __n;
          size_t v140 = __n + 2;
          size_t v142 = __n + 1;
          unint64_t v97 = v90;
          do
          {
            int v100 = v94;
            unint64_t v101 = *v94;
            signed int v102 = (*a6)++;
            unint64_t v103 = (unint64_t)a1[1];
            unint64_t v104 = (unint64_t)a1[2];
            if (v103 + 1 <= v104)
            {
              int v106 = *a1;
            }
            else
            {
              unint64_t v105 = (v103 & 0xFFFFFFFFFFFFFFF0) + 16;
              int v106 = *a1;
              if (v104 != v105)
              {
                a1[2] = (char *)v105;
                int v106 = (char *)malloc_type_realloc(v106, 88 * v105, 0x10500400A17BEF8uLL);
                *a1 = v106;
                unint64_t v103 = (unint64_t)a1[1];
                int v107 = a1[2];
                if (v103 > (unint64_t)v107)
                {
                  a1[1] = v107;
                  unint64_t v103 = (unint64_t)v107;
                }
              }
            }
            if (v103 > v101)
            {
              memmove(&v106[88 * v101 + 88], &v106[88 * v101], 88 * (v103 - v101));
              int v106 = *a1;
              unint64_t v103 = (unint64_t)a1[1];
            }
            a1[1] = (char *)(v103 + 1);
            uint64_t v108 = &v106[88 * v101];
            memcpy(v108, a4, v96);
            size_t v109 = v96;
            if (v102 != -1)
            {
              v108[v96] = 91;
              size_t v109 = v140 + itoa(&v108[v142], v102);
              v108[v109 - 1] = 93;
            }
            v108[v109] = 0;
            int v94 = v100;
            unint64_t v98 = (*v100)++;
            uint64_t v99 = (uint64_t)&(*a1)[88 * v98];
            *(void *)(v99 + 40) = this;
            *(void *)(v99 + 48) = v143;
            *(_DWORD *)(v99 + 56) = v97;
            *(void *)(v99 + 64) = 0;
            *(void *)(v99 + 72) = 0;
            *(void *)(v99 + 80) = v95;
            BOOL v60 = v97++ >= *(unsigned int *)v147;
          }
          while (!v60);
          return v138;
        }
LABEL_165:
        unint64_t v110 = *a2;
        signed int v111 = (*a6)++;
        unint64_t v112 = (unint64_t)a1[1];
        unint64_t v113 = (unint64_t)a1[2];
        if (v112 + 1 <= v113)
        {
          uint64_t v115 = *a1;
        }
        else
        {
          unint64_t v114 = (v112 & 0xFFFFFFFFFFFFFFF0) + 16;
          uint64_t v115 = *a1;
          if (v113 != v114)
          {
            a1[2] = (char *)v114;
            uint64_t v115 = (char *)malloc_type_realloc(v115, 88 * v114, 0x10500400A17BEF8uLL);
            *a1 = v115;
            unint64_t v112 = (unint64_t)a1[1];
            int v116 = a1[2];
            if (v112 > (unint64_t)v116)
            {
              a1[1] = v116;
              unint64_t v112 = (unint64_t)v116;
            }
          }
        }
        uint64_t v117 = v39;
        if (v112 > v110)
        {
          memmove(&v115[88 * v110 + 88], &v115[88 * v110], 88 * (v112 - v110));
          uint64_t v115 = *a1;
          unint64_t v112 = (unint64_t)a1[1];
        }
        a1[1] = (char *)(v112 + 1);
        uint64_t v118 = &v115[88 * v110];
        memcpy(v118, a4, __n);
        if (v111 != -1)
        {
          v118[__n] = 91;
          __n += itoa(&v118[__n + 1], v111) + 2;
          v118[__n - 1] = 93;
        }
        v118[__n] = 0;
        unint64_t v119 = (*a2)++;
        char v39 = v117;
        uint64_t v120 = (uint64_t)&(*a1)[88 * v119];
        *(void *)(v120 + 40) = this;
        *(void *)(v120 + 48) = v117 - (unsigned __int8 *)this;
        *(_DWORD *)(v120 + 56) = -1;
        *(void *)(v120 + 64) = 0;
        *(void *)(v120 + 72) = 0;
        *(void *)(v120 + 80) = a8;
        return v39;
      }
      unsigned int v55 = *(_DWORD *)v147;
      if (*(_DWORD *)v147 >= *(unsigned __int16 *)(a9 + 22))
      {
        *(_WORD *)(a9 + 22) = *(_WORD *)v147 + 1;
        *(_DWORD *)(a9 + 44) = 16 * (unsigned __int16)(v55 + 1);
      }
      goto LABEL_89;
    }
    int v70 = *(unsigned __int16 *)(a9 + 22);
    *(_WORD *)(a9 + 22) = v70 + 1;
LABEL_113:
    *(_DWORD *)uint64_t v147 = v70;
    *(_DWORD *)&v147[4] = v70;
    goto LABEL_114;
  }
  if (v41 == &fragmentKind)
  {
    if (v49)
    {
LABEL_112:
      int v70 = *(unsigned __int16 *)(a9 + 36);
      *(_WORD *)(a9 + 36) = v70 + 1;
      goto LABEL_113;
    }
    if (!strncmp((const char *)this, "fragment", 8uLL))
    {
      uint64_t v71 = arb::achr((arb *)((char *)this + 8), (const char *)0x2E);
      if (v71)
      {
        int v72 = v71;
        if (!strncmp(v71, "texcoord", 8uLL)) {
          goto LABEL_192;
        }
        if (!strncmp(v72, "position", 8uLL))
        {
LABEL_162:
          unsigned int v90 = *(_DWORD *)&v147[4];
          if (!v42) {
            unsigned int v90 = -1;
          }
          *(_DWORD *)&v147[4] = v90;
          if (v90 != -1) {
            goto LABEL_134;
          }
          goto LABEL_165;
        }
      }
    }
LABEL_161:
    *(_DWORD *)(a9 + 4) |= 0x8000000u;
    goto LABEL_162;
  }
  if (v41 == &vertexKind)
  {
    if (v49) {
      goto LABEL_112;
    }
    if (!strncmp((const char *)this, "vertex", 6uLL))
    {
      unint64_t v123 = arb::achr((arb *)((char *)this + 6), (const char *)0x2E);
      if (v123)
      {
        if (!strncmp(v123, "texcoord", 8uLL))
        {
LABEL_192:
          unsigned int v55 = *(_DWORD *)v147;
          if (*(_DWORD *)v147 >= *(unsigned __int16 *)(a9 + 36)) {
            *(_WORD *)(a9 + 36) = *(_WORD *)v147 + 1;
          }
          goto LABEL_89;
        }
      }
    }
    goto LABEL_161;
  }
  if (v41 == &outputKind)
  {
    if (v49)
    {
      int v70 = *(unsigned __int8 *)(a9 + 42);
      *(unsigned char *)(a9 + 42) = v70 + 1;
      goto LABEL_113;
    }
    if (strncmp((const char *)this, "result", 6uLL)
      || (uint64_t v124 = arb::achr((arb *)((char *)this + 6), (const char *)0x2E)) == 0
      || strncmp(v124, "color", 5uLL))
    {
      *(_DWORD *)(a9 + 12) = 0;
      unsigned int v90 = *(_DWORD *)&v147[4];
      if (!v42) {
        unsigned int v90 = -1;
      }
      *(_DWORD *)&v147[4] = v90;
      if (v90 != -1) {
        goto LABEL_134;
      }
      goto LABEL_165;
    }
    unsigned int v55 = *(_DWORD *)v147;
    if (*(_DWORD *)v147 >= *(unsigned __int8 *)(a9 + 42)) {
      *(unsigned char *)(a9 + 42) = v147[0] + 1;
    }
LABEL_89:
    unint64_t v56 = *(unsigned int *)&v147[4];
    if (*(_DWORD *)&v147[4] > v55) {
      return v39;
    }
    string_t v138 = v39;
    do
    {
      unint64_t v61 = *a2;
      signed int v62 = (*a6)++;
      unint64_t v63 = (unint64_t)a1[1];
      unint64_t v64 = (unint64_t)a1[2];
      if (v63 + 1 <= v64)
      {
        int v66 = *a1;
      }
      else
      {
        unint64_t v65 = (v63 & 0xFFFFFFFFFFFFFFF0) + 16;
        int v66 = *a1;
        if (v64 != v65)
        {
          a1[2] = (char *)v65;
          int v66 = (char *)malloc_type_realloc(v66, 88 * v65, 0x10500400A17BEF8uLL);
          *a1 = v66;
          unint64_t v63 = (unint64_t)a1[1];
          int v67 = a1[2];
          if (v63 > (unint64_t)v67)
          {
            a1[1] = v67;
            unint64_t v63 = (unint64_t)v67;
          }
        }
      }
      if (v63 > v61)
      {
        memmove(&v66[88 * v61 + 88], &v66[88 * v61], 88 * (v63 - v61));
        int v66 = *a1;
        unint64_t v63 = (unint64_t)a1[1];
      }
      a1[1] = (char *)(v63 + 1);
      int v68 = &v66[88 * v61];
      memcpy(v68, a4, __n);
      size_t v69 = __n;
      if (v62 != -1)
      {
        v68[__n] = 91;
        size_t v69 = __n + 2 + itoa(&v68[__n + 1], v62);
        v68[v69 - 1] = 93;
      }
      v68[v69] = 0;
      unint64_t v57 = (*a2)++;
      uint64_t v58 = 1;
      if (a3[1]) {
        uint64_t v58 = 2;
      }
      uint64_t v59 = (uint64_t)&(*a1)[88 * v57];
      *(void *)(v59 + 40) = a3;
      *(void *)(v59 + 48) = v58;
      *(_DWORD *)(v59 + 56) = v56;
      *(void *)(v59 + 64) = 0;
      *(void *)(v59 + 72) = 0;
      *(void *)(v59 + 80) = a8;
      BOOL v60 = v56++ >= *(unsigned int *)v147;
    }
    while (!v60);
    return v138;
  }
  if (!v41) {
    goto LABEL_133;
  }
  if (!v49)
  {
    unsigned int v55 = *(_DWORD *)v147;
    goto LABEL_89;
  }
LABEL_114:
  unint64_t v73 = *a2;
  signed int v74 = (*a6)++;
  unint64_t v75 = (unint64_t)a1[1];
  unint64_t v76 = (unint64_t)a1[2];
  if (v75 + 1 <= v76)
  {
    int v79 = a2;
    int v78 = *a1;
  }
  else
  {
    unint64_t v77 = (v75 & 0xFFFFFFFFFFFFFFF0) + 16;
    int v78 = *a1;
    int v79 = a2;
    if (v76 != v77)
    {
      a1[2] = (char *)v77;
      int v78 = (char *)malloc_type_realloc(v78, 88 * v77, 0x10500400A17BEF8uLL);
      *a1 = v78;
      unint64_t v75 = (unint64_t)a1[1];
      int v80 = a1[2];
      if (v75 > (unint64_t)v80)
      {
        a1[1] = v80;
        unint64_t v75 = (unint64_t)v80;
      }
    }
  }
  uint64_t v81 = a8;
  int v82 = v39;
  if (v75 > v73)
  {
    memmove(&v78[88 * v73 + 88], &v78[88 * v73], 88 * (v75 - v73));
    int v78 = *a1;
    unint64_t v75 = (unint64_t)a1[1];
  }
  a1[1] = (char *)(v75 + 1);
  int v83 = &v78[88 * v73];
  memcpy(v83, a4, __n);
  if (v74 != -1)
  {
    v83[__n] = 91;
    __n += itoa(&v83[__n + 1], v74) + 2;
    v83[__n - 1] = 93;
  }
  v83[__n] = 0;
  unint64_t v84 = (*v79)++;
  uint64_t v85 = 1;
  if (a3[1]) {
    uint64_t v85 = 2;
  }
  int v86 = *(_DWORD *)&v147[4];
  uint64_t v87 = (uint64_t)&(*a1)[88 * v84];
  *(void *)(v87 + 40) = a3;
  *(void *)(v87 + 48) = v85;
  *(_DWORD *)(v87 + 56) = v86;
  *(void *)(v87 + 64) = this;
  *(void *)(v87 + 72) = v49 - (unsigned __int8 *)this;
  *(void *)(v87 + 80) = v81;
  return v82;
}

uint64_t arb::ascan(unsigned __int8 **this, const char **a2, unsigned __int8 *a3, const char *a4)
{
  int v4 = *this;
  int v5 = (unsigned __int8 *)a2 + (void)*this;
  while (1)
  {
    while (1)
    {
      if (v4 < v5)
      {
        uint64_t v6 = *v4;
        if ((ctype[2 * v6] & 0x40) != 0) {
          break;
        }
      }
      int v7 = 0;
      int v8 = *a3;
      int v9 = &ctype[2 * *a3];
      int v10 = v9[1];
      if ((*v9 & 0x40) != 0) {
        goto LABEL_18;
      }
LABEL_6:
      if (!v8)
      {
        if (a4)
        {
          if (*v4 == 91)
          {
            uint64_t v27 = v4 + 1;
            int v26 = v4[1];
            if (v4[1])
            {
              if ((v26 - 33) >= 0xFFFFFFE0)
              {
                do
                {
LABEL_48:
                  int v28 = *++v27;
                  int v26 = v28;
                }
                while ((v28 - 33) > 0xFFFFFFDF);
              }
LABEL_49:
              if (v26 != 35)
              {
                char v13 = v4;
                if ((v26 - 58) >= 0xFFFFFFF6)
                {
                  int v7 = 0;
                  char v13 = v27;
                  do
                  {
                    int v10 = 0;
                    int v7 = v26 + 10 * v7 - 48;
                    int v33 = *++v13;
                    int v26 = v33;
                  }
                  while ((v33 - 58) > 0xFFFFFFF5);
                }
                goto LABEL_57;
              }
              unint64_t v29 = v27;
              while (1)
              {
                int v30 = *++v29;
                int v26 = v30;
                if (!v30) {
                  break;
                }
                int v31 = *v27;
                uint64_t v27 = v29;
                if (v31 == 10)
                {
                  uint64_t v27 = v29;
                  if ((v26 - 33) >= 0xFFFFFFE0) {
                    goto LABEL_48;
                  }
                  goto LABEL_49;
                }
              }
            }
          }
        }
LABEL_55:
        *this = v4;
        return (v7 - v10);
      }
      if (v7) {
        goto LABEL_55;
      }
      int v11 = *v4;
      if (!*v4) {
        goto LABEL_20;
      }
      if ((v11 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_10:
          int v12 = *++v4;
          int v11 = v12;
        }
        while ((v12 - 33) > 0xFFFFFFDF);
      }
LABEL_11:
      if (v11 == 35)
      {
        char v13 = v4 + 1;
        while (1)
        {
          int v11 = *v13;
          if (!*v13) {
            break;
          }
          int v14 = *(v13++ - 1);
          if (v14 == 10)
          {
            int v4 = v13 - 1;
            if ((v11 - 33) >= 0xFFFFFFE0) {
              goto LABEL_10;
            }
            goto LABEL_11;
          }
        }
      }
      else
      {
LABEL_20:
        char v13 = v4;
      }
      if (v13 >= v5)
      {
        int v7 = 0;
        if (v10) {
          goto LABEL_57;
        }
      }
      else
      {
        int v7 = ctype[2 * v11 + 1];
        if (v7 != v10) {
          goto LABEL_57;
        }
      }
      if (v8 == 91)
      {
        int v17 = *++a3;
        int v16 = v17;
        if ((v17 - 58) < 0xFFFFFFF6) {
          goto LABEL_39;
        }
        int v10 = 0;
        int v18 = a3;
        do
        {
          int v10 = v16 + 10 * v10 - 48;
          int v19 = *++v18;
          int v16 = v19;
        }
        while ((v19 - 58) > 0xFFFFFFF5);
        int v4 = v13 + 1;
        int v20 = v13[1];
        if (!v13[1]) {
          goto LABEL_39;
        }
        if ((v20 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_31:
            int v21 = *++v4;
            int v20 = v21;
          }
          while ((v21 - 33) > 0xFFFFFFDF);
        }
LABEL_32:
        if (v20 == 35)
        {
          int v22 = v4;
          while (1)
          {
            int v23 = *++v22;
            int v20 = v23;
            if (!v23) {
              break;
            }
            int v24 = *v4;
            int v4 = v22;
            if (v24 == 10)
            {
              int v4 = v22;
              if ((v20 - 33) >= 0xFFFFFFE0) {
                goto LABEL_31;
              }
              goto LABEL_32;
            }
          }
LABEL_39:
          int v4 = v13 + 1;
        }
        else
        {
          if ((v20 - 58) < 0xFFFFFFF6) {
            goto LABEL_39;
          }
          int v7 = 0;
          do
          {
            int v7 = v20 + 10 * v7 - 48;
            int v25 = *++v4;
            int v20 = v25;
          }
          while ((v25 - 58) > 0xFFFFFFF5);
          a3 = v18;
          if (v7 != v10) {
            goto LABEL_57;
          }
        }
      }
      else
      {
        int v4 = v13 + 1;
        ++a3;
      }
    }
    int v7 = ctype[2 * v6 + 1];
    int v8 = *a3;
    int v15 = &ctype[2 * *a3];
    int v10 = v15[1];
    if ((*v15 & 0x40) == 0) {
      goto LABEL_6;
    }
LABEL_18:
    if (v7 != v10) {
      break;
    }
    ++a3;
    ++v4;
  }
  char v13 = v4;
LABEL_57:
  *this = v13;
  return (v7 - v10);
}

char *map_insert(char **a1, unint64_t a2)
{
  unint64_t v4 = (unint64_t)a1[1];
  unint64_t v5 = (unint64_t)a1[2];
  if (v4 + 1 <= v5)
  {
    int v7 = *a1;
  }
  else
  {
    unint64_t v6 = (v4 & 0xFFFFFFFFFFFFFFF0) + 16;
    int v7 = *a1;
    if (v5 != v6)
    {
      a1[2] = (char *)v6;
      int v7 = (char *)malloc_type_realloc(v7, 88 * v6, 0x10500400A17BEF8uLL);
      *a1 = v7;
      unint64_t v4 = (unint64_t)a1[1];
      int v8 = a1[2];
      if (v4 > (unint64_t)v8)
      {
        a1[1] = v8;
        unint64_t v4 = (unint64_t)v8;
      }
    }
  }
  if (v4 > a2)
  {
    memmove(&v7[88 * a2 + 88], &v7[88 * a2], 88 * (v4 - a2));
    int v7 = *a1;
    unint64_t v4 = (unint64_t)a1[1];
  }
  a1[1] = (char *)(v4 + 1);
  return &v7[88 * a2];
}

uint64_t itoa(char *a1, signed int a2)
{
  if (a2 < 0)
  {
    *a1 = 45;
    a2 = -a2;
    uint64_t v2 = 1;
  }
  else
  {
    uint64_t v2 = 0;
  }
  uint32x4_t v3 = (uint32x4_t)vdupq_n_s32(a2);
  int16x8_t v4 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_u32(v3, (uint32x4_t)xmmword_1B7EC1820), (int16x8_t)vcgtq_u32(v3, (uint32x4_t)xmmword_1B7EC1810)), (int8x16_t)xmmword_1B7EC1830);
  v4.i32[0] = vaddvq_s16(v4);
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v4.i8);
  v5.i16[0] = vaddlv_u8(v5);
  __int32 v6 = v5.i32[0];
  if (a2 > 9) {
    __int32 v6 = v5.i32[0] + 1;
  }
  switch(v6)
  {
    case 1:
      goto LABEL_15;
    case 2:
      goto LABEL_14;
    case 3:
      goto LABEL_13;
    case 4:
      goto LABEL_12;
    case 5:
      goto LABEL_11;
    case 6:
      goto LABEL_10;
    case 7:
      goto LABEL_9;
    case 8:
      goto LABEL_8;
    case 9:
      unsigned int v7 = a2 / 0x3B9ACA00u;
      a2 %= 0x3B9ACA00u;
      a1[v2++] = v7 | 0x30;
LABEL_8:
      int v8 = a2 / 100000000;
      a2 %= 100000000;
      a1[v2++] = v8 + 48;
LABEL_9:
      int v9 = a2 / 10000000;
      a2 %= 10000000;
      a1[v2++] = v9 + 48;
LABEL_10:
      int v10 = a2 / 1000000;
      a2 %= 1000000;
      a1[v2++] = v10 + 48;
LABEL_11:
      int v11 = a2 / 100000;
      a2 %= 100000;
      a1[v2++] = v11 + 48;
LABEL_12:
      int v12 = a2 / 10000;
      a2 %= 10000;
      a1[v2++] = v12 + 48;
LABEL_13:
      int v13 = a2 / 1000;
      a2 %= 1000;
      a1[v2++] = v13 + 48;
LABEL_14:
      int v14 = a2 / 100;
      a2 %= 100;
      a1[v2++] = v14 + 48;
LABEL_15:
      int v15 = a2 / 10;
      a2 %= 10;
      a1[v2++] = v15 + 48;
      break;
    default:
      break;
  }
  a1[v2] = a2 + 48;
  return v2 + 1;
}

char *arb::obj_add(uint64_t a1, char *__s1, const char **a3, uint64_t a4, int a5)
{
  *(_DWORD *)int v54 = 0;
  int v10 = *(char **)a1;
  unint64_t v9 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)a1 + 88 * v9;
  int v52 = *(char **)a1;
  if (!v9) {
    goto LABEL_26;
  }
  while (1)
  {
    unint64_t v12 = v9 >> 1;
    unsigned int v55 = (unsigned __int8 *)__s1;
    int v13 = &v10[88 * (v9 >> 1)];
    int v14 = arb::ascan(&v55, a3, (unsigned __int8 *)v13, (const char *)1);
    if (!v14) {
      break;
    }
    if (v14 > 0)
    {
      unint64_t v15 = v12 + 1;
    }
    else
    {
      uint64_t v11 = (uint64_t)&v10[88 * (v9 >> 1)];
      unint64_t v15 = 0;
    }
    v10 += 88 * v15;
    if (v14 <= 0) {
      v9 >>= 1;
    }
    else {
      v9 -= v12 + 1;
    }
    if (!v9) {
      goto LABEL_26;
    }
  }
  if (!v10)
  {
LABEL_26:
    int v13 = 0;
    if ((unint64_t)a3 < 0xC || !a4) {
      return v13;
    }
    int v13 = 0;
    switch(*__s1)
    {
      case 'f':
        if (strncmp(__s1, "fragment", 8uLL)) {
          goto LABEL_44;
        }
        int v24 = arb::achr((arb *)(__s1 + 8), (const char *)0x2E);
        if (!v24) {
          goto LABEL_44;
        }
        int v25 = v24;
        if (strncmp(v24, "texcoord", 8uLL))
        {
          if (strncmp(v25, "position", 8uLL)) {
            goto LABEL_44;
          }
          return 0;
        }
        int v40 = (arb *)(v25 + 8);
        if (arb::achr(v40, (const char *)0x5B) && !arb::aidx(v40, v54, 0, v41))
        {
          if (*(unsigned __int16 *)(a4 + 36) > 7u) {
            return 0;
          }
          int v13 = 0;
          __int16 v46 = 8;
          goto LABEL_62;
        }
        int v13 = map_insert((char **)a1, 0x2E8BA2E8BA2E8BA3 * ((v11 - (uint64_t)v52) >> 3));
        arb::acpy((uint64_t)v13, __s1, (const char *)a3);
        int v42 = *(_DWORD *)v54;
        *((void *)v13 + 5) = &fragmentKind;
        *((void *)v13 + 6) = 2;
        *((_DWORD *)v13 + 14) = v42;
        *((void *)v13 + 9) = 0;
        *((void *)v13 + 10) = 0;
        *((void *)v13 + 8) = 0;
        if (*(_DWORD *)v54 >= *(unsigned __int16 *)(a4 + 36)) {
          *(_WORD *)(a4 + 36) = *(_WORD *)v54 + 1;
        }
        if (a5) {
          *(_DWORD *)(a4 + 12) &= ~(1 << *((_DWORD *)v13 + 14));
        }
        return v13;
      case 'p':
        if (strncmp(__s1, "program", 7uLL)) {
          goto LABEL_44;
        }
        int v26 = arb::achr((arb *)(__s1 + 7), (const char *)0x2E);
        if (!v26) {
          goto LABEL_44;
        }
        uint64_t v27 = v26;
        if (strncmp(v26, "local", 5uLL)) {
          return 0;
        }
        arb::aidx((arb *)(v27 + 5), v54, 0, v28);
        int v13 = map_insert((char **)a1, 0x2E8BA2E8BA2E8BA3 * ((v11 - (uint64_t)v52) >> 3));
        arb::acpy((uint64_t)v13, __s1, (const char *)a3);
        int v43 = *(_DWORD *)v54;
        *((void *)v13 + 5) = &paramKind;
        *((void *)v13 + 6) = 2;
        *((_DWORD *)v13 + 14) = v43;
        *((void *)v13 + 9) = 0;
        *((void *)v13 + 10) = 0;
        *((void *)v13 + 8) = 0;
        if (*(_DWORD *)v54 >= *(unsigned __int16 *)(a4 + 22))
        {
          unsigned __int16 v44 = *(_WORD *)v54 + 1;
          *(_WORD *)(a4 + 22) = *(_WORD *)v54 + 1;
          *(_DWORD *)(a4 + 44) = 16 * v44;
        }
        return v13;
      case 'r':
        if (strncmp(__s1, "result", 6uLL)) {
          goto LABEL_44;
        }
        unint64_t v29 = __s1 + 6;
        int v30 = arb::achr((arb *)(__s1 + 6), (const char *)0x2E);
        if (!v30) {
          goto LABEL_50;
        }
        int v31 = v30;
        if (strncmp(v30, "color", 5uLL)) {
          goto LABEL_50;
        }
        arb::aidx((arb *)(v31 + 5), v54, 0, v32);
        int v13 = map_insert((char **)a1, 0x2E8BA2E8BA2E8BA3 * ((v11 - (uint64_t)v52) >> 3));
        arb::acpy((uint64_t)v13, __s1, (const char *)a3);
        int v33 = *(_DWORD *)v54;
        *((void *)v13 + 5) = &outputKind;
        *((void *)v13 + 6) = 2;
        *((_DWORD *)v13 + 14) = v33;
        *((void *)v13 + 9) = 0;
        *((void *)v13 + 10) = 0;
        *((void *)v13 + 8) = 0;
        if (*(_DWORD *)v54 >= *(unsigned __int8 *)(a4 + 42)) {
          *(unsigned char *)(a4 + 42) = v54[0] + 1;
        }
        return v13;
      case 's':
        goto LABEL_44;
      case 'v':
        if (!strncmp(__s1, "vertex", 6uLL) && (int v37 = arb::achr((arb *)(__s1 + 6), (const char *)0x2E)) != 0)
        {
          unint64_t v29 = (char *)v37;
          if (!strncmp(v37, "texcoord", 8uLL))
          {
            arb::aidx((arb *)(v29 + 8), v54, 0, v38);
            int v13 = map_insert((char **)a1, 0x2E8BA2E8BA2E8BA3 * ((v11 - (uint64_t)v52) >> 3));
            arb::acpy((uint64_t)v13, __s1, (const char *)a3);
            int v45 = *(_DWORD *)v54;
            *((void *)v13 + 5) = &vertexKind;
            *((void *)v13 + 6) = 2;
            *((_DWORD *)v13 + 14) = v45;
            *((void *)v13 + 9) = 0;
            *((void *)v13 + 10) = 0;
            *((void *)v13 + 8) = 0;
            if (*(_DWORD *)v54 >= *(unsigned __int16 *)(a4 + 36))
            {
              __int16 v46 = *(_WORD *)v54 + 1;
LABEL_62:
              *(_WORD *)(a4 + 36) = v46;
            }
            return v13;
          }
LABEL_50:
          int v39 = strncmp(v29, "position", 8uLL);
          int v34 = *(_DWORD *)(a4 + 4);
          int v13 = 0;
          if (!v39) {
            goto LABEL_51;
          }
        }
        else
        {
LABEL_44:
          int v13 = 0;
          int v34 = *(_DWORD *)(a4 + 4);
        }
        int v35 = v34 | 0x8000000;
        goto LABEL_46;
      default:
        return v13;
    }
  }
  if (!a4) {
    return v13;
  }
  int v16 = *(unsigned __int8 **)&v10[88 * v12 + 40];
  if (a5 && v16 == (unsigned __int8 *)&fragmentKind)
  {
    *(_DWORD *)(a4 + 12) &= ~(1 << *(_DWORD *)&v10[88 * v12 + 56]);
    int v16 = (unsigned __int8 *)&fragmentKind;
  }
  if (strncmp((const char *)v16, "vertex", 6uLL)) {
    return v13;
  }
  int v19 = v16[6];
  int v18 = v16 + 6;
  int v17 = v19;
  if (!v19) {
    return v13;
  }
  if ((v17 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_19:
      int v20 = *++v18;
      int v17 = v20;
    }
    while ((v20 - 33) > 0xFFFFFFDF);
  }
LABEL_20:
  if (v17 == 35)
  {
    int v21 = v18;
    while (1)
    {
      int v22 = *++v21;
      int v17 = v22;
      if (!v22) {
        return v13;
      }
      int v23 = *v18;
      int v18 = v21;
      if (v23 == 10)
      {
        int v18 = v21;
        if ((v17 - 33) >= 0xFFFFFFE0) {
          goto LABEL_19;
        }
        goto LABEL_20;
      }
    }
  }
  if (v17 == 46)
  {
    int v49 = v18[1];
    uint64_t v48 = (const char *)(v18 + 1);
    int v47 = v49;
    if (v49)
    {
      if ((v47 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_66:
          int v50 = *(unsigned __int8 *)++v48;
          int v47 = v50;
        }
        while ((v50 - 33) > 0xFFFFFFDF);
      }
LABEL_67:
      if (v47 == 35)
      {
        ++v48;
        while (1)
        {
          int v47 = *(unsigned __int8 *)v48;
          if (!*v48) {
            break;
          }
          int v51 = *((unsigned __int8 *)v48++ - 1);
          if (v51 == 10)
          {
            --v48;
            if ((v47 - 33) >= 0xFFFFFFE0) {
              goto LABEL_66;
            }
            goto LABEL_67;
          }
        }
      }
    }
    if (!strncmp(v48, "position", 8uLL))
    {
      int v34 = *(_DWORD *)(a4 + 4);
LABEL_51:
      int v35 = v34 & 0x3FFFFFFF;
LABEL_46:
      *(_DWORD *)(a4 + 4) = v35;
    }
  }
  return v13;
}

uint64_t arb::acpy(uint64_t this, char *a2, const char *a3)
{
  uint64_t v3 = 0;
  if (a3)
  {
    unint64_t v4 = 0;
    do
    {
      int v5 = a2[v4];
      if ((v5 - 33) <= 0xFFFFFFDF)
      {
        *(unsigned char *)(this + v3++) = v5;
        __int32 v6 = &a2[++v4];
        if (a2[v4] == 35)
        {
LABEL_9:
          int v7 = 35;
LABEL_11:
          if (v7 == 35)
          {
            ++v6;
            while (1)
            {
              int v7 = *v6;
              if (!*v6) {
                break;
              }
              int v9 = *(v6++ - 1);
              if (v9 == 10)
              {
                --v6;
                if ((v7 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    int v8 = *++v6;
                    int v7 = v8;
                  }
                  while ((v8 - 33) > 0xFFFFFFDF);
                }
                goto LABEL_11;
              }
            }
          }
          unint64_t v4 = v6 - a2;
        }
      }
      else
      {
        __int32 v6 = &a2[++v4];
        if (a2[v4] == 35) {
          goto LABEL_9;
        }
      }
    }
    while (v4 < (unint64_t)a3);
  }
  *(unsigned char *)(this + v3) = 0;
  return this;
}

unsigned __int8 *arb::asymbol(arb *this, char *a2, const char **a3, unint64_t *a4)
{
  __int32 v6 = this;
  int v7 = *(unsigned __int8 *)this;
  if (v7 != 45) {
    goto LABEL_209;
  }
  __int32 v6 = (arb *)((char *)this + 1);
  int v7 = *((unsigned __int8 *)this + 1);
  if (!*((unsigned char *)this + 1)) {
    goto LABEL_21;
  }
  if ((v7 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_4:
      int v8 = *((unsigned __int8 *)v6 + 1);
      __int32 v6 = (arb *)((char *)v6 + 1);
      int v7 = v8;
    }
    while ((v8 - 33) > 0xFFFFFFDF);
  }
LABEL_5:
  if (v7 == 35)
  {
    __int32 v6 = (arb *)((char *)v6 + 1);
    while (1)
    {
      int v7 = *(unsigned __int8 *)v6;
      if (!*(unsigned char *)v6) {
        break;
      }
      int v9 = *((unsigned __int8 *)v6 - 1);
      __int32 v6 = (arb *)((char *)v6 + 1);
      if (v9 == 10)
      {
        __int32 v6 = (arb *)((char *)v6 - 1);
        if ((v7 - 33) >= 0xFFFFFFE0) {
          goto LABEL_4;
        }
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_209:
    if (v7 == 124)
    {
      int v11 = *((unsigned __int8 *)v6 + 1);
      __int32 v6 = (arb *)((char *)v6 + 1);
      int v10 = v11;
      if (v11)
      {
        if ((v10 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_14:
            int v12 = *((unsigned __int8 *)v6 + 1);
            __int32 v6 = (arb *)((char *)v6 + 1);
            int v10 = v12;
          }
          while ((v12 - 33) > 0xFFFFFFDF);
        }
LABEL_15:
        if (v10 == 35)
        {
          __int32 v6 = (arb *)((char *)v6 + 1);
          while (1)
          {
            int v10 = *(unsigned __int8 *)v6;
            if (!*(unsigned char *)v6) {
              break;
            }
            int v13 = *((unsigned __int8 *)v6 - 1);
            __int32 v6 = (arb *)((char *)v6 + 1);
            if (v13 == 10)
            {
              __int32 v6 = (arb *)((char *)v6 - 1);
              if ((v10 - 33) >= 0xFFFFFFE0) {
                goto LABEL_14;
              }
              goto LABEL_15;
            }
          }
        }
      }
    }
  }
LABEL_21:
  int v14 = strncmp((const char *)v6, "state", 5uLL);
  *(void *)a2 = v6;
  *a3 = 0;
  int v16 = *(unsigned __int8 *)v6;
  if ((v16 - 48) < 0xA || (ctype[2 * *(unsigned __int8 *)v6] & 0x40) == 0)
  {
    if (v16 == 123)
    {
      int v18 = v6;
      do
      {
        if (v16 == 35)
        {
          while (v16 == 35)
          {
            int v18 = (arb *)((char *)v18 + 1);
            do
            {
              int v16 = *(unsigned __int8 *)v18;
              if (!*(unsigned char *)v18) {
                goto LABEL_43;
              }
              int v20 = *((unsigned __int8 *)v18 - 1);
              int v18 = (arb *)((char *)v18 + 1);
            }
            while (v20 != 10);
            int v18 = (arb *)((char *)v18 - 1);
            if ((v16 - 33) >= 0xFFFFFFE0)
            {
              do
              {
                int v19 = *((unsigned __int8 *)v18 + 1);
                int v18 = (arb *)((char *)v18 + 1);
                int v16 = v19;
              }
              while ((v19 - 33) > 0xFFFFFFDF);
            }
          }
        }
        else
        {
          int v21 = *((unsigned __int8 *)v18 + 1);
          int v18 = (arb *)((char *)v18 + 1);
          int v16 = v21;
        }
      }
      while (v16 != 125 && v16 != 0);
LABEL_43:
      int v25 = *((unsigned __int8 *)v18 + 1);
      int v23 = (char *)v18 + 1;
      int v24 = v25;
      if (v25)
      {
        if ((v24 - 33) < 0xFFFFFFE0) {
          goto LABEL_46;
        }
        do
        {
LABEL_45:
          int v26 = *(unsigned __int8 *)++v23;
          int v24 = v26;
        }
        while ((v26 - 33) > 0xFFFFFFDF);
LABEL_46:
        while (v24 == 35)
        {
          ++v23;
          do
          {
            int v24 = *(unsigned __int8 *)v23;
            if (!*v23) {
              goto LABEL_183;
            }
            int v27 = *((unsigned __int8 *)v23++ - 1);
          }
          while (v27 != 10);
          --v23;
          if ((v24 - 33) >= 0xFFFFFFE0) {
            goto LABEL_45;
          }
        }
      }
LABEL_183:
      int v79 = (const char *)(v23 - (const char *)v6);
    }
    else
    {
      if ((ctype[2 * *(unsigned __int8 *)v6] & 0x80) == 0) {
        return 0;
      }
      if (*((unsigned char *)v6 + 1) == 68)
      {
        uint64_t result = (unsigned __int8 *)v6 + 2;
        *a3 = (const char *)2;
        return result;
      }
      uint64_t v88 = 0;
      do
        int v89 = (char)ctype[2 * (v88++)[(void)v6 + 1]];
      while (v89 < 0);
      *a3 = v88;
      int v23 = &v88[(void)v6];
      if ((ctype[2 * v88[(void)v6]] & 0x20) == 0)
      {
LABEL_185:
        int v80 = &v23[((unint64_t)ctype[2 * *(unsigned __int8 *)v23] >> 5) & 1];
        uint64_t v81 = (unsigned __int8 *)&v80[((unint64_t)ctype[2 * *(unsigned __int8 *)v80] >> 5) & 1];
        int v82 = &v81[((unint64_t)ctype[2 * *v81] >> 5) & 1];
        return &v82[((unint64_t)ctype[2 * *v82] >> 5) & 1];
      }
      int v79 = v88 - 1;
    }
    *a3 = v79;
    goto LABEL_185;
  }
  int v28 = v14;
  unint64_t v29 = (unsigned __int8 *)v6;
  while (1)
  {
    do
    {
      int v31 = *++v29;
      int v30 = v31;
    }
    while ((ctype[2 * v31] & 0x40) != 0);
    if (!v30) {
      break;
    }
    unint64_t v32 = v29;
    if ((v30 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_55:
        int v33 = *++v32;
        int v30 = v33;
      }
      while ((v33 - 33) > 0xFFFFFFDF);
    }
LABEL_56:
    if (v30 == 35)
    {
      uint64_t result = v32 + 1;
      while (1)
      {
        int v30 = *result;
        if (!*result) {
          goto LABEL_91;
        }
        int v35 = *(result++ - 1);
        if (v35 == 10)
        {
          unint64_t v32 = result - 1;
          if ((v30 - 33) >= 0xFFFFFFE0) {
            goto LABEL_55;
          }
          goto LABEL_56;
        }
      }
    }
    if (v30 != 91)
    {
      uint64_t result = v32;
      *a3 = (const char *)(v29 - (unsigned __int8 *)v6);
      int v36 = *v32;
      if (v36 == 46) {
        goto LABEL_93;
      }
      goto LABEL_188;
    }
    uint64_t result = arb::aidx((arb *)v32, 0, 0, v15);
    int v37 = result;
    if (result) {
      goto LABEL_92;
    }
    int v38 = 91;
    while (1)
    {
      if (v38 != 35)
      {
        int v41 = *++v32;
        int v38 = v41;
        goto LABEL_77;
      }
LABEL_70:
      if (v38 == 35) {
        break;
      }
LABEL_77:
      if (v38 == 93 || v38 == 0) {
        goto LABEL_82;
      }
    }
    ++v32;
    while (1)
    {
      int v38 = *v32;
      if (!*v32) {
        break;
      }
      int v40 = *(v32++ - 1);
      if (v40 == 10)
      {
        --v32;
        if ((v38 - 33) >= 0xFFFFFFE0)
        {
          do
          {
            int v39 = *++v32;
            int v38 = v39;
          }
          while ((v39 - 33) > 0xFFFFFFDF);
        }
        goto LABEL_70;
      }
    }
LABEL_82:
    int v43 = v32[1];
    uint64_t result = v32 + 1;
    if (v32[1])
    {
      if ((v43 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_84:
          int v44 = *++result;
          int v43 = v44;
        }
        while ((v44 - 33) > 0xFFFFFFDF);
      }
LABEL_85:
      if (v43 == 35)
      {
        ++result;
        while (1)
        {
          int v43 = *result;
          if (!*result) {
            break;
          }
          int v45 = *(result++ - 1);
          if (v45 == 10)
          {
            --result;
            if ((v43 - 33) >= 0xFFFFFFE0) {
              goto LABEL_84;
            }
            goto LABEL_85;
          }
        }
      }
    }
LABEL_91:
    int v37 = v29;
LABEL_92:
    *a3 = (const char *)(v37 - (unsigned __int8 *)v6);
    int v36 = *result;
    if (v36 != 46) {
      goto LABEL_188;
    }
LABEL_93:
    int v46 = result[1];
    unint64_t v29 = result + 1;
    if (result[1])
    {
      if ((v46 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_95:
          int v47 = *++v29;
          int v46 = v47;
        }
        while ((v47 - 33) > 0xFFFFFFDF);
      }
LABEL_96:
      if (v46 == 35)
      {
        ++v29;
        while (1)
        {
          int v46 = *v29;
          if (!*v29) {
            break;
          }
          int v48 = *(v29++ - 1);
          if (v48 == 10)
          {
            --v29;
            if ((v46 - 33) >= 0xFFFFFFE0) {
              goto LABEL_95;
            }
            goto LABEL_96;
          }
        }
      }
    }
    if (!strncmp((const char *)v29, "row", 3uLL) && (ctype[2 * v29[3]] & 0x40) == 0)
    {
      int v49 = arb::aidx((arb *)(v29 + 3), 0, 0, v15);
      int v50 = *v49;
      if (!*v49) {
        goto LABEL_186;
      }
      int v51 = v49;
      if ((v50 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_106:
          int v52 = *++v51;
          int v50 = v52;
        }
        while ((v52 - 33) > 0xFFFFFFDF);
      }
LABEL_107:
      if (v50 == 35)
      {
        int v53 = v51;
        while (1)
        {
          int v54 = *++v53;
          int v50 = v54;
          if (!v54) {
            break;
          }
          int v55 = *v51;
          int v51 = v53;
          if (v55 == 10)
          {
            int v51 = v53;
            if ((v50 - 33) >= 0xFFFFFFE0) {
              goto LABEL_106;
            }
            goto LABEL_107;
          }
        }
LABEL_186:
        unint64_t v29 = v49;
        goto LABEL_187;
      }
      if (v50 != 46) {
        goto LABEL_186;
      }
      int v56 = v51[1];
      unint64_t v29 = v51 + 1;
      int v46 = v56;
      if (v56)
      {
        if ((v46 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_118:
            int v57 = *++v29;
            int v46 = v57;
          }
          while ((v57 - 33) > 0xFFFFFFDF);
        }
LABEL_119:
        if (v46 == 35)
        {
          ++v29;
          while (1)
          {
            int v46 = *v29;
            if (!*v29) {
              break;
            }
            int v58 = *(v29++ - 1);
            if (v58 == 10)
            {
              --v29;
              if ((v46 - 33) >= 0xFFFFFFE0) {
                goto LABEL_118;
              }
              goto LABEL_119;
            }
          }
        }
      }
    }
    if (!v28)
    {
      if (!strncmp((const char *)v29, "eye", 3uLL))
      {
        uint64_t v59 = v29 + 3;
        int v60 = v29[3];
        if (v29[3]) {
          goto LABEL_138;
        }
      }
      else
      {
        if (strncmp((const char *)v29, "object", 6uLL)) {
          goto LABEL_126;
        }
        uint64_t v59 = v29 + 6;
        int v60 = v29[6];
        if (!v29[6]) {
          goto LABEL_146;
        }
LABEL_138:
        unint64_t v61 = v59;
        if ((v60 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_139:
            int v62 = *++v61;
            int v60 = v62;
          }
          while ((v62 - 33) > 0xFFFFFFDF);
        }
LABEL_140:
        if (v60 == 35)
        {
          unint64_t v63 = v61;
          while (1)
          {
            int v64 = *++v63;
            int v60 = v64;
            if (!v64) {
              break;
            }
            int v65 = *v61;
            unint64_t v61 = v63;
            if (v65 == 10)
            {
              unint64_t v61 = v63;
              if ((v60 - 33) >= 0xFFFFFFE0) {
                goto LABEL_139;
              }
              goto LABEL_140;
            }
          }
        }
      }
LABEL_146:
      int v68 = v59[1];
      int v66 = v59 + 1;
      int v67 = v68;
      if (v68)
      {
        if ((v67 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_148:
            int v69 = *++v66;
            int v67 = v69;
          }
          while ((v69 - 33) > 0xFFFFFFDF);
        }
LABEL_149:
        if (v67 == 35)
        {
          ++v66;
          while (1)
          {
            int v67 = *v66;
            if (!*v66) {
              break;
            }
            int v70 = *(v66++ - 1);
            if (v70 == 10)
            {
              --v66;
              if ((v67 - 33) >= 0xFFFFFFE0) {
                goto LABEL_148;
              }
              goto LABEL_149;
            }
          }
        }
      }
      unint64_t v29 = v66 + 1;
      *a3 = (const char *)(v66 + 1 - (unsigned __int8 *)v6);
      int v71 = v66[1];
      if (!v66[1]) {
        goto LABEL_187;
      }
      int v72 = v66 + 1;
      if ((v71 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_157:
          int v73 = *++v72;
          int v71 = v73;
        }
        while ((v73 - 33) > 0xFFFFFFDF);
      }
LABEL_158:
      if (v71 == 35)
      {
        signed int v74 = v72;
        while (1)
        {
          int v75 = *++v74;
          int v71 = v75;
          if (!v75) {
            goto LABEL_187;
          }
          int v76 = *v72;
          int v72 = v74;
          if (v76 == 10)
          {
            int v72 = v74;
            if ((v71 - 33) >= 0xFFFFFFE0) {
              goto LABEL_157;
            }
            goto LABEL_158;
          }
        }
      }
      if (v71 != 46) {
        goto LABEL_187;
      }
      int v46 = v72[1];
      unint64_t v29 = v72 + 1;
      if (v72[1])
      {
        if ((v46 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_174:
            int v77 = *++v29;
            int v46 = v77;
          }
          while ((v77 - 33) > 0xFFFFFFDF);
        }
LABEL_175:
        if (v46 == 35)
        {
          ++v29;
          while (1)
          {
            int v46 = *v29;
            if (!*v29) {
              break;
            }
            int v78 = *(v29++ - 1);
            if (v78 == 10)
            {
              --v29;
              if ((v46 - 33) >= 0xFFFFFFE0) {
                goto LABEL_174;
              }
              goto LABEL_175;
            }
          }
        }
      }
    }
LABEL_126:
    if ((ctype[2 * v46] & 0x20) != 0)
    {
      if ((ctype[2 * v29[1]] & 0x20) != 0)
      {
        if ((ctype[2 * v29[2]] & 0x20) != 0)
        {
          if ((ctype[2 * v29[3]] & 0x20) != 0)
          {
            if ((ctype[2 * v29[4]] & 0x40) == 0)
            {
              v29 += 4;
              goto LABEL_187;
            }
          }
          else if ((ctype[2 * v29[3]] & 0x40) == 0)
          {
            v29 += 3;
            goto LABEL_187;
          }
        }
        else if ((ctype[2 * v29[2]] & 0x40) == 0)
        {
          v29 += 2;
          goto LABEL_187;
        }
      }
      else if ((ctype[2 * v29[1]] & 0x40) == 0)
      {
        ++v29;
        goto LABEL_187;
      }
    }
    if ((v46 - 48) < 0xA || (ctype[2 * v46] & 0x40) == 0)
    {
LABEL_187:
      int v36 = *v29;
      uint64_t result = v29;
      goto LABEL_188;
    }
  }
  uint64_t result = v29;
  *a3 = (const char *)(v29 - (unsigned __int8 *)v6);
  int v36 = *v29;
  if (v36 == 46) {
    goto LABEL_93;
  }
LABEL_188:
  if (v36)
  {
    int v83 = result;
    if ((v36 - 33) >= 0xE0u)
    {
      do
      {
LABEL_190:
        char v84 = *++v83;
        LOBYTE(v36) = v84;
      }
      while ((v84 - 33) > 0xDFu);
    }
LABEL_191:
    if (v36 == 35)
    {
      uint64_t v85 = v83;
      while (1)
      {
        int v86 = *++v85;
        LOBYTE(v36) = v86;
        if (!v86) {
          break;
        }
        int v87 = *v83;
        int v83 = v85;
        if (v87 == 10)
        {
          int v83 = v85;
          if ((v36 - 33) >= 0xE0u) {
            goto LABEL_190;
          }
          goto LABEL_191;
        }
      }
    }
    else if (v36 == 124)
    {
      return v83 + 1;
    }
  }
  return result;
}

const char *arb::isidentity(arb *this, arb *a2, const char *a3, const char *a4, const char *a5)
{
  if (this != a2) {
    return 0;
  }
  int v5 = a4;
  if (&a3[(void)this] != a4)
  {
    unsigned int v7 = a5;
    if (strncmp(a4 - 4, "xyzw", 4uLL))
    {
      if (strncmp(v5 - 4, "rgba", 4uLL) && strncmp(&v5[-v7], "xyzw", v7) && strncmp(&v5[-v7], "rgba", v7)) {
        return 0;
      }
    }
  }
  return v5;
}

unsigned __int8 *arb::obj_search(uint64_t a1, unint64_t a2, unsigned __int8 *a3, const char **a4)
{
  if (!a2) {
    return 0;
  }
  unint64_t v6 = a2;
  while (1)
  {
    unint64_t v8 = v6 >> 1;
    int v13 = a3;
    int v9 = (unsigned __int8 *)(a1 + 88 * (v6 >> 1));
    int v10 = arb::ascan(&v13, a4, v9, (const char *)1);
    if (!v10) {
      break;
    }
    if (v10 > 0) {
      unint64_t v11 = v8 + 1;
    }
    else {
      unint64_t v11 = 0;
    }
    a1 += 88 * v11;
    if (v10 <= 0) {
      v6 >>= 1;
    }
    else {
      v6 -= v8 + 1;
    }
    if (!v6) {
      return 0;
    }
  }
  return v9;
}

BOOL arb::isepsilon(arb *this, const char *a2, const char *a3)
{
  uint64_t v3 = (const char *)this;
  if (*a2 == 46)
  {
    int v6 = *((unsigned __int8 *)a2 + 1);
    unint64_t v4 = a2 + 1;
    char v5 = v6;
    if (v6)
    {
      if ((v5 - 33) >= 0xE0u)
      {
        do
        {
LABEL_4:
          char v7 = *++v4;
          char v5 = v7;
        }
        while ((v7 - 33) > 0xDFu);
      }
LABEL_5:
      if (v5 != 35)
      {
        int v28 = v5;
        int v12 = 3;
        unsigned int v29 = v28 - 98;
        if (v29 > 0x18)
        {
          char v11 = 0;
        }
        else if (((1 << v29) & 0x410000) != 0)
        {
          int v12 = 0;
          char v11 = 1;
        }
        else if (((1 << v29) & 0x800020) != 0)
        {
          char v11 = 0;
          int v12 = 1;
        }
        else
        {
          BOOL v30 = ((1 << v29) & 0x1000001) == 0;
          char v11 = 0;
          if (v30) {
            int v12 = 3;
          }
          else {
            int v12 = 2;
          }
        }
        goto LABEL_12;
      }
      unint64_t v8 = v4;
      while (1)
      {
        int v9 = *(unsigned __int8 *)++v8;
        char v5 = v9;
        if (!v9) {
          break;
        }
        int v10 = *(unsigned __int8 *)v4;
        unint64_t v4 = v8;
        if (v10 == 10)
        {
          unint64_t v4 = v8;
          if ((v5 - 33) >= 0xE0u) {
            goto LABEL_4;
          }
          goto LABEL_5;
        }
      }
    }
  }
  char v11 = 0;
  int v12 = 3;
  if (*(unsigned char *)this != 123) {
    return !strncmp(v3, "9.999999975e-07", 0xFuLL) || strncmp(v3, "1e-6", 4uLL) == 0;
  }
LABEL_12:
  uint64_t v3 = (char *)this + 1;
  int v13 = *((unsigned __int8 *)this + 1);
  if (*((unsigned char *)this + 1))
  {
    if ((v13 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_15:
        int v14 = *(unsigned __int8 *)++v3;
        int v13 = v14;
      }
      while ((v14 - 33) > 0xFFFFFFDF);
    }
LABEL_16:
    if (v13 == 35)
    {
      ++v3;
      while (1)
      {
        int v13 = *(unsigned __int8 *)v3;
        if (!*v3) {
          break;
        }
        int v15 = *((unsigned __int8 *)v3++ - 1);
        if (v15 == 10)
        {
          --v3;
          if ((v13 - 33) >= 0xFFFFFFE0) {
            goto LABEL_15;
          }
          goto LABEL_16;
        }
      }
    }
  }
  if ((v11 & 1) == 0)
  {
    while (1)
    {
      int v17 = v3 - 1;
      do
      {
        int v19 = *(unsigned __int8 *)++v17;
        int v18 = v19;
      }
      while ((char)ctype[2 * v19] < 0);
      if (!v18) {
        return 0;
      }
      if ((v18 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_30:
          int v20 = *(unsigned __int8 *)++v17;
          int v18 = v20;
        }
        while ((v20 - 33) > 0xFFFFFFDF);
      }
LABEL_31:
      if (v18 == 35)
      {
        int v21 = v17;
        while (1)
        {
          int v22 = *(unsigned __int8 *)++v21;
          int v18 = v22;
          if (!v22) {
            return 0;
          }
          int v23 = *(unsigned __int8 *)v17;
          int v17 = v21;
          if (v23 == 10)
          {
            int v17 = v21;
            if ((v18 - 33) >= 0xFFFFFFE0) {
              goto LABEL_30;
            }
            goto LABEL_31;
          }
        }
      }
      if (v18 != 44) {
        return 0;
      }
      int v25 = *((unsigned __int8 *)v17 + 1);
      uint64_t v3 = v17 + 1;
      int v24 = v25;
      if (v25)
      {
        if ((v24 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_40:
            int v26 = *(unsigned __int8 *)++v3;
            int v24 = v26;
          }
          while ((v26 - 33) > 0xFFFFFFDF);
        }
LABEL_41:
        if (v24 == 35)
        {
          ++v3;
          while (1)
          {
            int v24 = *(unsigned __int8 *)v3;
            if (!*v3) {
              break;
            }
            int v27 = *((unsigned __int8 *)v3++ - 1);
            if (v27 == 10)
            {
              --v3;
              if ((v24 - 33) >= 0xFFFFFFE0) {
                goto LABEL_40;
              }
              goto LABEL_41;
            }
          }
        }
      }
      if (!--v12) {
        return !strncmp(v3, "9.999999975e-07", 0xFuLL) || strncmp(v3, "1e-6", 4uLL) == 0;
      }
    }
  }
  else
  {
    return !strncmp(v3, "9.999999975e-07", 0xFuLL) || strncmp(v3, "1e-6", 4uLL) == 0;
  }
}

unsigned __int8 *arb::isssat(arb *this, const char *a2)
{
  int v2 = *(unsigned __int8 *)this;
  if ((ctype[2 * *(unsigned __int8 *)this] & 0x40) == 0) {
    return 0;
  }
  for (int i = (char *)this - 1; ; ++i)
  {
    int v6 = v2;
    int v2 = *((unsigned __int8 *)i + 2);
    if (v6 != 95 || v2 != 83) {
      goto LABEL_6;
    }
    if (i[3] == 83) {
      break;
    }
    int v2 = 83;
LABEL_6:
    if ((ctype[2 * v2] & 0x40) == 0) {
      return 0;
    }
  }
  uint64_t v3 = (unsigned __int8 *)(i + 1);
  int v7 = *(unsigned __int8 *)i;
  if ((v7 - 48) < 2)
  {
    int v9 = *((unsigned __int8 *)i - 1);
    unint64_t v8 = (unsigned __int8 *)(i - 1);
    if (v9 == 67) {
      return v8;
    }
    return v3;
  }
  if (v7 != 67 || !strncmp(i - 2, "FRC", 3uLL) && (ctype[2 * *((unsigned __int8 *)i - 3)] & 0x40) == 0) {
    return v3;
  }
  if (strncmp(i - 4, "TRUNC", 5uLL)) {
    return (unsigned __int8 *)i;
  }
  return v3;
}

unsigned char *arb::atoi(unsigned char *this, char *a2, int *a3)
{
  int v3 = *this;
  if (v3 == 45)
  {
    int v4 = -1;
LABEL_13:
    int v9 = *++this;
    int v3 = v9;
    if (!v9) {
      return 0;
    }
    goto LABEL_4;
  }
  int v4 = 1;
  if (v3 == 43) {
    goto LABEL_13;
  }
  if (!*this) {
    return 0;
  }
LABEL_4:
  if ((v3 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_5:
      int v5 = *++this;
      int v3 = v5;
    }
    while ((v5 - 33) > 0xFFFFFFDF);
  }
LABEL_6:
  if (v3 == 35)
  {
    int v6 = this;
    while (1)
    {
      int v7 = *++v6;
      int v3 = v7;
      if (!v7) {
        return 0;
      }
      int v8 = *this;
      this = v6;
      if (v8 == 10)
      {
        this = v6;
        if ((v3 - 33) >= 0xFFFFFFE0) {
          goto LABEL_5;
        }
        goto LABEL_6;
      }
    }
  }
  if ((v3 - 58) < 0xFFFFFFF6) {
    return 0;
  }
  int v10 = 0;
  do
  {
    int v10 = v3 + 10 * v10 - 48;
    int v11 = *++this;
    int v3 = v11;
  }
  while ((v11 - 58) > 0xFFFFFFF5);
  *(_DWORD *)a2 = v10 * v4;
  int v12 = *this;
  if (*this)
  {
    if ((v12 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_21:
        int v13 = *++this;
        int v12 = v13;
      }
      while ((v13 - 33) > 0xFFFFFFDF);
    }
LABEL_22:
    if (v12 == 35)
    {
      ++this;
      while (1)
      {
        int v12 = *this;
        if (!*this) {
          break;
        }
        int v14 = *(this++ - 1);
        if (v14 == 10)
        {
          --this;
          if ((v12 - 33) >= 0xFFFFFFE0) {
            goto LABEL_21;
          }
          goto LABEL_22;
        }
      }
    }
  }
  return this;
}

unsigned __int8 *arb::obj_write_op(uint64_t *a1, uint64_t a2, char *__s1)
{
  int v6 = strncmp(__s1, "SWZ", 3uLL);
  int v8 = arb::isssat((arb *)__s1, v7);
  int v9 = v8;
  int v10 = __s1 - 1;
  do
  {
    int v12 = *++v10;
    int v11 = v12;
  }
  while ((ctype[2 * v12] & 0x40) != 0);
  *(void *)unint64_t v119 = 0;
  *(void *)uint64_t v120 = 0;
  uint64_t v117 = 0;
  uint64_t v118 = 0;
  if (v11)
  {
    int v13 = v10;
    if ((v11 - 33) < 0xFFFFFFE0) {
      goto LABEL_6;
    }
    do
    {
LABEL_5:
      int v14 = *++v13;
      int v11 = v14;
    }
    while ((v14 - 33) > 0xFFFFFFDF);
LABEL_6:
    while (v11 == 35)
    {
      int v15 = v13;
      do
      {
        int v16 = *++v15;
        int v11 = v16;
        if (!v16) {
          goto LABEL_17;
        }
        int v17 = *v13;
        int v13 = v15;
      }
      while (v17 != 10);
      int v13 = v15;
      if ((v11 - 33) >= 0xFFFFFFE0) {
        goto LABEL_5;
      }
    }
    if ((v11 & 0xFE) == 0x3A)
    {
      unint64_t v18 = v13 + 1 - __s1;
      if (v13 + 1 == __s1) {
        return 0;
      }
      uint64_t v20 = *(void *)(a2 + 8);
      uint64_t v19 = *(void *)(a2 + 16);
      unint64_t v21 = v20 + v18;
      if (v19)
      {
        if (v21 >= *(void *)v19)
        {
          size_t v22 = (v21 + 255) & 0xFFFFFFFFFFFFFF00;
          int v23 = malloc_type_realloc(*(void **)(v19 + 16), v22, 0xCCCD1039uLL);
          int v24 = *(size_t **)(a2 + 16);
          v24[2] = (size_t)v23;
          *int v24 = v22;
          *(void *)a2 = v23;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v21);
      }
      uint64_t v109 = 0;
      unint64_t v110 = 0;
      uint64_t v111 = *(void *)a2 + v20;
      while (1)
      {
        int v112 = __s1[v110];
        if ((v112 - 33) > 0xFFFFFFDF)
        {
          unint64_t v113 = &__s1[++v110];
          if (__s1[v110] != 35) {
            goto LABEL_155;
          }
        }
        else
        {
          *(unsigned char *)(v111 + v109++) = v112;
          unint64_t v113 = &__s1[++v110];
          if (__s1[v110] != 35) {
            goto LABEL_155;
          }
        }
        int v114 = 35;
        while (v114 == 35)
        {
          ++v113;
          do
          {
            int v114 = *v113;
            if (!*v113) {
              goto LABEL_154;
            }
            int v116 = *(v113++ - 1);
          }
          while (v116 != 10);
          --v113;
          if ((v114 - 33) >= 0xFFFFFFE0)
          {
            do
            {
              int v115 = *++v113;
              int v114 = v115;
            }
            while ((v115 - 33) > 0xFFFFFFDF);
          }
        }
LABEL_154:
        unint64_t v110 = v113 - __s1;
LABEL_155:
        if (v110 >= v18)
        {
          *(void *)(a2 + 8) += v109;
          return 0;
        }
      }
    }
  }
LABEL_17:
  if (v8)
  {
    int64_t v25 = v8 - (unsigned __int8 *)__s1;
    uint64_t v27 = *(void *)(a2 + 8);
    uint64_t v26 = *(void *)(a2 + 16);
    unint64_t v28 = v27 + v8 - (unsigned __int8 *)__s1;
    if (v26)
    {
      if (v28 >= *(void *)v26)
      {
        size_t v29 = (v28 + 255) & 0xFFFFFFFFFFFFFF00;
        BOOL v30 = malloc_type_realloc(*(void **)(v26 + 16), v29, 0xCCCD1039uLL);
        int v31 = *(size_t **)(a2 + 16);
        v31[2] = (size_t)v30;
        *int v31 = v29;
        *(void *)a2 = v30;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v28);
    }
    string_t v36 = *(string_t *)a2;
    *(void *)(a2 + 8) += v25;
    memcpy((void *)&v36[v27], __s1, v9 - (unsigned __int8 *)__s1);
    unint64_t v32 = a1;
    int v33 = (string_t *)a2;
    int v34 = (arb *)v10;
    int v35 = 0;
  }
  else
  {
    unint64_t v32 = a1;
    int v33 = (string_t *)a2;
    int v34 = (arb *)__s1;
    int v35 = 1;
  }
  int v38 = (arb *)arb::obj_write_dest(v32, v33, v34, v120, &v117, v35, 1);
LABEL_25:
  int v39 = *(unsigned __int8 *)v38;
  if (!*(unsigned char *)v38)
  {
    int v83 = v38;
    goto LABEL_102;
  }
  int v40 = *(unsigned __int8 *)v38;
  int v41 = v38;
  if ((v39 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_27:
      int v42 = *((unsigned __int8 *)v41 + 1);
      int v41 = (arb *)((char *)v41 + 1);
      int v40 = v42;
    }
    while ((v42 - 33) > 0xFFFFFFDF);
  }
LABEL_28:
  if (v40 != 35)
  {
    if (v40 != 44) {
      goto LABEL_100;
    }
    int v48 = *((unsigned __int8 *)v41 + 1);
    int v47 = (arb *)((char *)v41 + 1);
    int v46 = v48;
    if (v48)
    {
      if ((v46 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_37:
          int v49 = *((unsigned __int8 *)v47 + 1);
          int v47 = (arb *)((char *)v47 + 1);
          int v46 = v49;
        }
        while ((v49 - 33) > 0xFFFFFFDF);
      }
LABEL_38:
      if (v46 == 35)
      {
        int v47 = (arb *)((char *)v47 + 1);
        while (1)
        {
          int v46 = *(unsigned __int8 *)v47;
          if (!*(unsigned char *)v47) {
            break;
          }
          int v50 = *((unsigned __int8 *)v47 - 1);
          int v47 = (arb *)((char *)v47 + 1);
          if (v50 == 10)
          {
            int v47 = (arb *)((char *)v47 - 1);
            if ((v46 - 33) >= 0xFFFFFFE0) {
              goto LABEL_37;
            }
            goto LABEL_38;
          }
        }
      }
    }
    uint64_t v52 = *(void *)(a2 + 8);
    uint64_t v51 = *(void *)(a2 + 16);
    unint64_t v53 = v52 + 1;
    if (v51)
    {
      if (v53 >= *(void *)v51)
      {
        int v54 = malloc_type_realloc(*(void **)(v51 + 16), (v52 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
        int v55 = *(void **)(a2 + 16);
        v55[2] = v54;
        *int v55 = (v52 & 0xFFFFFFFFFFFFFF00) + 256;
        *(void *)a2 = v54;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v53);
    }
    string_t v56 = *(string_t *)a2;
    ++*(void *)(a2 + 8);
    v56[v52] = 44;
    int v57 = arb::asymbol(v47, v119, (const char **)&v118, v37);
    if (v57)
    {
      int v38 = (arb *)arb::obj_write_symbol(a1, a2, (const char *)v47, *(const char **)v119, v118, (char *)v57);
      goto LABEL_98;
    }
    int v58 = *(unsigned __int8 *)v47;
    if (v58 != 40)
    {
LABEL_80:
      int v38 = v47;
      goto LABEL_98;
    }
    uint64_t v59 = v47;
    while (1)
    {
      if (v58 == 35)
      {
LABEL_55:
        if (v58 == 35)
        {
          uint64_t v59 = (arb *)((char *)v59 + 1);
          while (1)
          {
            int v58 = *(unsigned __int8 *)v59;
            if (!*(unsigned char *)v59) {
              break;
            }
            int v61 = *((unsigned __int8 *)v59 - 1);
            uint64_t v59 = (arb *)((char *)v59 + 1);
            if (v61 == 10)
            {
              uint64_t v59 = (arb *)((char *)v59 - 1);
              if ((v58 - 33) >= 0xFFFFFFE0)
              {
                do
                {
                  int v60 = *((unsigned __int8 *)v59 + 1);
                  uint64_t v59 = (arb *)((char *)v59 + 1);
                  int v58 = v60;
                }
                while ((v60 - 33) > 0xFFFFFFDF);
              }
              goto LABEL_55;
            }
          }
LABEL_67:
          int v65 = *((unsigned __int8 *)v59 + 1);
          int v38 = (arb *)((char *)v59 + 1);
          int v64 = v65;
          if (v65)
          {
            if ((v64 - 33) >= 0xFFFFFFE0)
            {
              do
              {
LABEL_69:
                int v66 = *((unsigned __int8 *)v38 + 1);
                int v38 = (arb *)((char *)v38 + 1);
                int v64 = v66;
              }
              while ((v66 - 33) > 0xFFFFFFDF);
            }
LABEL_70:
            if (v64 == 35)
            {
              int v38 = (arb *)((char *)v38 + 1);
              while (1)
              {
                int v64 = *(unsigned __int8 *)v38;
                if (!*(unsigned char *)v38) {
                  break;
                }
                int v67 = *((unsigned __int8 *)v38 - 1);
                int v38 = (arb *)((char *)v38 + 1);
                if (v67 == 10)
                {
                  int v38 = (arb *)((char *)v38 - 1);
                  if ((v64 - 33) >= 0xFFFFFFE0) {
                    goto LABEL_69;
                  }
                  goto LABEL_70;
                }
              }
            }
          }
          unint64_t v68 = v38 - v47;
          if (v38 == v47) {
            goto LABEL_80;
          }
          uint64_t v70 = *(void *)(a2 + 8);
          uint64_t v69 = *(void *)(a2 + 16);
          unint64_t v71 = v70 + v68;
          if (v69)
          {
            if (v71 >= *(void *)v69)
            {
              size_t v72 = (v71 + 255) & 0xFFFFFFFFFFFFFF00;
              int v73 = malloc_type_realloc(*(void **)(v69 + 16), v72, 0xCCCD1039uLL);
              signed int v74 = *(size_t **)(a2 + 16);
              v74[2] = (size_t)v73;
              size_t *v74 = v72;
              *(void *)a2 = v73;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v71);
          }
          uint64_t v75 = 0;
          unint64_t v76 = 0;
          uint64_t v77 = *(void *)a2 + v70;
          while (2)
          {
            int v78 = *((unsigned __int8 *)v47 + v76);
            if ((v78 - 33) > 0xFFFFFFDF)
            {
              ++v76;
              int v79 = (char *)v47 + v76;
              if (*((unsigned char *)v47 + v76) == 35)
              {
LABEL_89:
                int v80 = 35;
LABEL_91:
                if (v80 == 35)
                {
                  ++v79;
                  while (1)
                  {
                    int v80 = *v79;
                    if (!*v79) {
                      break;
                    }
                    int v82 = *(v79++ - 1);
                    if (v82 == 10)
                    {
                      --v79;
                      if ((v80 - 33) >= 0xFFFFFFE0)
                      {
                        do
                        {
                          int v81 = *++v79;
                          int v80 = v81;
                        }
                        while ((v81 - 33) > 0xFFFFFFDF);
                      }
                      goto LABEL_91;
                    }
                  }
                }
                unint64_t v76 = v79 - (unsigned char *)v47;
              }
            }
            else
            {
              *(unsigned char *)(v77 + v75++) = v78;
              ++v76;
              int v79 = (char *)v47 + v76;
              if (*((unsigned char *)v47 + v76) == 35) {
                goto LABEL_89;
              }
            }
            if (v76 < v68) {
              continue;
            }
            break;
          }
          *(void *)(a2 + 8) += v75;
LABEL_98:
          if (!v6)
          {
            int v39 = *(unsigned __int8 *)v38;
            goto LABEL_100;
          }
          goto LABEL_25;
        }
      }
      else
      {
        int v62 = *((unsigned __int8 *)v59 + 1);
        uint64_t v59 = (arb *)((char *)v59 + 1);
        int v58 = v62;
      }
      if (v58 == 41 || v58 == 0) {
        goto LABEL_67;
      }
    }
  }
  int v43 = v41;
  while (1)
  {
    int v44 = *((unsigned __int8 *)v43 + 1);
    int v43 = (arb *)((char *)v43 + 1);
    int v40 = v44;
    if (!v44) {
      break;
    }
    int v45 = *(unsigned __int8 *)v41;
    int v41 = v43;
    if (v45 == 10)
    {
      int v41 = v43;
      if ((v40 - 33) >= 0xFFFFFFE0) {
        goto LABEL_27;
      }
      goto LABEL_28;
    }
  }
LABEL_100:
  int v83 = v38;
  if (!v39 || v39 == 59) {
    goto LABEL_102;
  }
  while (2)
  {
    if (v39 != 35)
    {
      int v98 = *((unsigned __int8 *)v83 + 1);
      int v83 = (arb *)((char *)v83 + 1);
      int v39 = v98;
LABEL_125:
      if (v39 == 59 || v39 == 0) {
        goto LABEL_102;
      }
      continue;
    }
    break;
  }
LABEL_118:
  if (v39 != 35) {
    goto LABEL_125;
  }
  int v83 = (arb *)((char *)v83 + 1);
  while (1)
  {
    int v39 = *(unsigned __int8 *)v83;
    if (!*(unsigned char *)v83) {
      break;
    }
    int v97 = *((unsigned __int8 *)v83 - 1);
    int v83 = (arb *)((char *)v83 + 1);
    if (v97 == 10)
    {
      int v83 = (arb *)((char *)v83 - 1);
      if ((v39 - 33) >= 0xFFFFFFE0)
      {
        do
        {
          int v96 = *((unsigned __int8 *)v83 + 1);
          int v83 = (arb *)((char *)v83 + 1);
          int v39 = v96;
        }
        while ((v96 - 33) > 0xFFFFFFDF);
      }
      goto LABEL_118;
    }
  }
LABEL_102:
  int v86 = *((unsigned __int8 *)v83 + 1);
  char v84 = (arb *)((char *)v83 + 1);
  int v85 = v86;
  if (v86)
  {
    if ((v85 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_104:
        int v87 = *((unsigned __int8 *)v84 + 1);
        char v84 = (arb *)((char *)v84 + 1);
        int v85 = v87;
      }
      while ((v87 - 33) > 0xFFFFFFDF);
    }
LABEL_105:
    if (v85 == 35)
    {
      char v84 = (arb *)((char *)v84 + 1);
      while (1)
      {
        int v85 = *(unsigned __int8 *)v84;
        if (!*(unsigned char *)v84) {
          break;
        }
        int v88 = *((unsigned __int8 *)v84 - 1);
        char v84 = (arb *)((char *)v84 + 1);
        if (v88 == 10)
        {
          char v84 = (arb *)((char *)v84 - 1);
          if ((v85 - 33) >= 0xFFFFFFE0) {
            goto LABEL_104;
          }
          goto LABEL_105;
        }
      }
    }
  }
  unint64_t v89 = v84 - v38;
  if (v84 == v38) {
    goto LABEL_148;
  }
  uint64_t v91 = *(void *)(a2 + 8);
  uint64_t v90 = *(void *)(a2 + 16);
  unint64_t v92 = v91 + v89;
  if (v90)
  {
    if (v92 >= *(void *)v90)
    {
      size_t v93 = (v92 + 255) & 0xFFFFFFFFFFFFFF00;
      int v94 = malloc_type_realloc(*(void **)(v90 + 16), v93, 0xCCCD1039uLL);
      uint64_t v95 = *(size_t **)(a2 + 16);
      v95[2] = (size_t)v94;
      *uint64_t v95 = v93;
      *(void *)a2 = v94;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v92);
  }
  uint64_t v100 = 0;
  unint64_t v101 = 0;
  uint64_t v102 = *(void *)a2 + v91;
  while (2)
  {
    int v103 = *((unsigned __int8 *)v38 + v101);
    if ((v103 - 33) > 0xFFFFFFDF)
    {
      ++v101;
      unint64_t v104 = (char *)v38 + v101;
      if (*((unsigned char *)v38 + v101) == 35)
      {
LABEL_139:
        int v105 = 35;
LABEL_141:
        if (v105 == 35)
        {
          ++v104;
          while (1)
          {
            int v105 = *v104;
            if (!*v104) {
              break;
            }
            int v107 = *(v104++ - 1);
            if (v107 == 10)
            {
              --v104;
              if ((v105 - 33) >= 0xFFFFFFE0)
              {
                do
                {
                  int v106 = *++v104;
                  int v105 = v106;
                }
                while ((v106 - 33) > 0xFFFFFFDF);
              }
              goto LABEL_141;
            }
          }
        }
        unint64_t v101 = v104 - (unsigned char *)v38;
      }
    }
    else
    {
      *(unsigned char *)(v102 + v100++) = v103;
      ++v101;
      unint64_t v104 = (char *)v38 + v101;
      if (*((unsigned char *)v38 + v101) == 35) {
        goto LABEL_139;
      }
    }
    if (v101 < v89) {
      continue;
    }
    break;
  }
  *(void *)(a2 + 8) += v100;
LABEL_148:
  if (!v9) {
    return 0;
  }
  return v9;
}

unsigned __int8 *arb::obj_write_dest(uint64_t *a1, string_t *a2, arb *this, char *a4, const char **a5, int a6, int a7)
{
  int v10 = a4;
  int v13 = this;
  while (1)
  {
    do
    {
      int v14 = (unsigned __int8 *)v13;
      int v16 = *(unsigned __int8 *)v13;
      int v13 = (arb *)((char *)v13 + 1);
      int v15 = v16;
    }
    while ((ctype[2 * v16] & 0x40) != 0);
    if (!v15) {
      break;
    }
    if ((v15 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_5:
        int v17 = *++v14;
        int v15 = v17;
      }
      while ((v17 - 33) > 0xFFFFFFDF);
    }
LABEL_6:
    if (v15 == 35)
    {
      ++v14;
      while (1)
      {
        int v15 = *v14;
        if (!*v14) {
          goto LABEL_24;
        }
        int v18 = *(v14++ - 1);
        if (v18 == 10)
        {
          --v14;
          if ((v15 - 33) >= 0xFFFFFFE0) {
            goto LABEL_5;
          }
          goto LABEL_6;
        }
      }
    }
    if (v15 != 46) {
      break;
    }
    int v19 = v14[1];
    int v13 = (arb *)(v14 + 1);
    if (!v14[1])
    {
LABEL_23:
      int v14 = (unsigned __int8 *)v13;
      break;
    }
    if ((v19 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_15:
        int v20 = *((unsigned __int8 *)v13 + 1);
        int v13 = (arb *)((char *)v13 + 1);
        int v19 = v20;
      }
      while ((v20 - 33) > 0xFFFFFFDF);
    }
LABEL_16:
    if (v19 == 35)
    {
      int v14 = (unsigned __int8 *)v13 + 1;
      while (1)
      {
        int v19 = *v14;
        if (!*v14) {
          goto LABEL_24;
        }
        int v21 = *(v14++ - 1);
        if (v21 == 10)
        {
          int v13 = (arb *)(v14 - 1);
          if ((v19 - 33) >= 0xFFFFFFE0) {
            goto LABEL_15;
          }
          goto LABEL_16;
        }
      }
    }
    if (!v19) {
      goto LABEL_23;
    }
  }
LABEL_24:
  size_t v22 = a2[1];
  unint64_t v23 = v14 - (unsigned __int8 *)this;
  if (v14 == (unsigned __int8 *)this) {
    goto LABEL_45;
  }
  unint64_t v24 = (unint64_t)&v22[v23];
  string_t v25 = a2[2];
  if (v25)
  {
    if (v24 >= *(void *)v25)
    {
      size_t v27 = (v24 + 255) & 0xFFFFFFFFFFFFFF00;
      unint64_t v28 = (const char *)malloc_type_realloc(*((void **)v25 + 2), v27, 0xCCCD1039uLL);
      size_t v29 = (char *)a2[2];
      *((void *)v29 + 2) = v28;
      *(void *)size_t v29 = v27;
      int v10 = a4;
      *a2 = v28;
    }
  }
  else
  {
    str_alloc(a2, v24);
  }
  uint64_t v30 = 0;
  unint64_t v31 = 0;
  unint64_t v32 = &v22[(void)*a2];
  do
  {
    int v33 = *((unsigned __int8 *)this + v31);
    if ((v33 - 33) <= 0xFFFFFFDF)
    {
      v32[v30++] = v33;
      ++v31;
      int v34 = (char *)this + v31;
      if (*((unsigned char *)this + v31) != 35) {
        continue;
      }
    }
    else
    {
      ++v31;
      int v34 = (char *)this + v31;
      if (*((unsigned char *)this + v31) != 35) {
        continue;
      }
    }
    int v35 = 35;
LABEL_38:
    if (v35 == 35)
    {
      ++v34;
      while (1)
      {
        int v35 = *v34;
        if (!*v34) {
          break;
        }
        int v37 = *(v34++ - 1);
        if (v37 == 10)
        {
          --v34;
          if ((v35 - 33) >= 0xFFFFFFE0)
          {
            do
            {
              int v36 = *++v34;
              int v35 = v36;
            }
            while ((v36 - 33) > 0xFFFFFFDF);
          }
          goto LABEL_38;
        }
      }
    }
    unint64_t v31 = v34 - (unsigned char *)this;
  }
  while (v31 < v23);
  size_t v22 = &a2[1][v30];
  a2[1] = v22;
LABEL_45:
  unint64_t v38 = (unint64_t)(v22 + 1);
  string_t v39 = a2[2];
  if (v39)
  {
    if (v38 >= *(void *)v39)
    {
      int v40 = (const char *)malloc_type_realloc(*((void **)v39 + 2), ((unint64_t)v22 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      int v41 = (char *)a2[2];
      *((void *)v41 + 2) = v40;
      *(void *)int v41 = ((unint64_t)v22 & 0xFFFFFFFFFFFFFF00) + 256;
      *a2 = v40;
    }
  }
  else
  {
    str_alloc(a2, v38);
  }
  string_t v42 = *a2;
  ++a2[1];
  v22[(void)v42] = 32;
  int v43 = arb::asymbol((arb *)v14, v10, a5, (unint64_t *)a4);
  if (!v43)
  {
    int v44 = v14;
    goto LABEL_67;
  }
  int v44 = v43;
  if (a6) {
    goto LABEL_62;
  }
  int v45 = a6;
  int v46 = v10;
  uint64_t v90 = a5;
  int v88 = v45;
  int v89 = a7;
  unint64_t v47 = a1[1];
  if (!v47)
  {
LABEL_61:
    a7 = v89;
    int v10 = v46;
    a6 = v88;
LABEL_62:
    int v54 = *(const char **)v10;
    int v55 = (char *)*a5;
    if (a7)
    {
      string_t v56 = a1;
      int v57 = a2;
      int v58 = (const char *)v14;
      uint64_t v59 = (char *)v44;
    }
    else
    {
      uint64_t v59 = &v55[(void)v54];
      string_t v56 = a1;
      int v57 = a2;
      int v58 = *(const char **)v10;
    }
    arb::obj_write_symbol(v56, (uint64_t)v57, v58, v54, v55, v59);
    goto LABEL_67;
  }
  int v48 = *(unsigned __int8 **)v10;
  int v49 = (char *)*a5;
  uint64_t v50 = *a1;
  while (1)
  {
    unint64_t v51 = v47 >> 1;
    unint64_t v92 = v48;
    int v52 = arb::ascan(&v92, (const char **)v49, (unsigned __int8 *)(v50 + 88 * (v47 >> 1)), (const char *)1);
    if (!v52) {
      break;
    }
    if (v52 > 0) {
      unint64_t v53 = v51 + 1;
    }
    else {
      unint64_t v53 = 0;
    }
    v50 += 88 * v53;
    if (v52 <= 0) {
      v47 >>= 1;
    }
    else {
      v47 -= v51 + 1;
    }
    if (!v47) {
      goto LABEL_61;
    }
  }
  a7 = v89;
  int v10 = v46;
  a6 = v88;
  if (!v50 || *(_UNKNOWN **)(v50 + 88 * v51 + 40) != &outputKind) {
    goto LABEL_62;
  }
  unint64_t v67 = (unint64_t)a2[1];
  string_t v66 = a2[2];
  unint64_t v68 = v67 + 1;
  if (v66)
  {
    if (v68 >= *(void *)v66)
    {
      uint64_t v69 = (const char *)malloc_type_realloc(*((void **)v66 + 2), (v67 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      uint64_t v70 = (char *)a2[2];
      *((void *)v70 + 2) = v69;
      *(void *)uint64_t v70 = (v67 & 0xFFFFFFFFFFFFFF00) + 256;
      *a2 = v69;
    }
  }
  else
  {
    str_alloc(a2, v68);
  }
  string_t v81 = *a2;
  ++a2[1];
  v81[v67] = 114;
  signed int v82 = *((_DWORD *)a1 + 15);
  string_t v84 = a2[1];
  string_t v83 = a2[2];
  unint64_t v85 = (unint64_t)(v84 + 20);
  if (v83)
  {
    if (v85 >= *(void *)v83)
    {
      int v86 = (const char *)malloc_type_realloc(*((void **)v83 + 2), (unint64_t)(v84 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      int v87 = (char *)a2[2];
      *((void *)v87 + 2) = v86;
      *(void *)int v87 = (unint64_t)(v84 + 275) & 0xFFFFFFFFFFFFFF00;
      *a2 = v86;
    }
  }
  else
  {
    str_alloc(a2, v85);
  }
  a2[1] += itoa((char *)&v84[(void)*a2], v82);
  if (v89) {
    str_putm(a2, &(*v90)[*(void *)v10], v44 - (unsigned __int8 *)&(*v90)[*(void *)v10]);
  }
LABEL_67:
  int v60 = *v44;
  if (!*v44) {
    return v44;
  }
  int v61 = (const char *)v44;
LABEL_69:
  if ((v60 - 33) >= 0xFFFFFFE0)
  {
    do
    {
      int v62 = *(unsigned __int8 *)++v61;
      int v60 = v62;
    }
    while ((v62 - 33) > 0xFFFFFFDF);
  }
  if (v60 == 35)
  {
    unint64_t v63 = v61;
    while (1)
    {
      int v64 = *(unsigned __int8 *)++v61;
      int v60 = v64;
      if (!v64) {
        return v44;
      }
      int v65 = *(unsigned __int8 *)v63;
      unint64_t v63 = v61;
      if (v65 == 10) {
        goto LABEL_69;
      }
    }
  }
  if (v60 != 40) {
    return v44;
  }
  unint64_t v71 = v61;
  while (2)
  {
    if (v60 != 35)
    {
      int v74 = *(unsigned __int8 *)++v71;
      int v60 = v74;
LABEL_93:
      if (v60 == 41 || v60 == 0) {
        goto LABEL_98;
      }
      continue;
    }
    break;
  }
LABEL_86:
  if (v60 != 35) {
    goto LABEL_93;
  }
  ++v71;
  while (1)
  {
    int v60 = *(unsigned __int8 *)v71;
    if (!*v71) {
      break;
    }
    int v73 = *((unsigned __int8 *)v71++ - 1);
    if (v73 == 10)
    {
      --v71;
      if ((v60 - 33) >= 0xFFFFFFE0)
      {
        do
        {
          int v72 = *(unsigned __int8 *)++v71;
          int v60 = v72;
        }
        while ((v72 - 33) > 0xFFFFFFDF);
      }
      goto LABEL_86;
    }
  }
LABEL_98:
  int v77 = *((unsigned __int8 *)v71 + 1);
  int v44 = (unsigned __int8 *)(v71 + 1);
  int v76 = v77;
  if (v77)
  {
    if ((v76 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_100:
        int v78 = *++v44;
        int v76 = v78;
      }
      while ((v78 - 33) > 0xFFFFFFDF);
    }
LABEL_101:
    if (v76 == 35)
    {
      ++v44;
      while (1)
      {
        int v76 = *v44;
        if (!*v44) {
          break;
        }
        int v79 = *(v44++ - 1);
        if (v79 == 10)
        {
          --v44;
          if ((v76 - 33) >= 0xFFFFFFE0) {
            goto LABEL_100;
          }
          goto LABEL_101;
        }
      }
    }
  }
  if (a6) {
    str_putm(a2, v61, v44 - (unsigned __int8 *)v61);
  }
  return v44;
}

char *arb::obj_write_symbol(void *a1, uint64_t a2, const char *a3, const char *a4, char *a5, char *a6)
{
  int v181 = a5;
  unint64_t v11 = a1[1];
  if (v11)
  {
    uint64_t v13 = *a1;
    while (1)
    {
      unint64_t v14 = v11 >> 1;
      *(void *)__int16 v182 = a4;
      int v15 = arb::ascan((unsigned __int8 **)v182, (const char **)a5, (unsigned __int8 *)(v13 + 88 * (v11 >> 1)), (const char *)1);
      if (!v15) {
        break;
      }
      if (v15 > 0) {
        unint64_t v17 = v14 + 1;
      }
      else {
        unint64_t v17 = 0;
      }
      v13 += 88 * v17;
      if (v15 <= 0) {
        v11 >>= 1;
      }
      else {
        v11 -= v14 + 1;
      }
      if (!v11) {
        goto LABEL_17;
      }
    }
    *(void *)__int16 v182 = 0;
    if (v13)
    {
      uint64_t v179 = a1;
      if (a3 == a4) {
        goto LABEL_122;
      }
      uint64_t v19 = *(void *)(a2 + 8);
      uint64_t v18 = *(void *)(a2 + 16);
      unint64_t v20 = v19 + a4 - a3;
      if (v18)
      {
        if (v20 >= *(void *)v18)
        {
          size_t v21 = (v20 + 255) & 0xFFFFFFFFFFFFFF00;
          size_t v22 = malloc_type_realloc(*(void **)(v18 + 16), v21, 0xCCCD1039uLL);
          unint64_t v23 = *(size_t **)(a2 + 16);
          _OWORD v23[2] = (size_t)v22;
          *unint64_t v23 = v21;
          *(void *)a2 = v22;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v20);
      }
      uint64_t v93 = 0;
      int v94 = 0;
      uint64_t v95 = *(void *)a2 + v19;
      while (1)
      {
        int v96 = v94[(void)a3];
        if ((v96 - 33) <= 0xFFFFFFDF)
        {
          *(unsigned char *)(v95 + v93++) = v96;
          int v97 = &(++v94)[(void)a3];
          if (v94[(void)a3] == 35)
          {
LABEL_113:
            int v98 = 35;
            while (v98 == 35)
            {
              ++v97;
              do
              {
                int v98 = *v97;
                if (!*v97) {
                  goto LABEL_107;
                }
                int v100 = *(v97++ - 1);
              }
              while (v100 != 10);
              --v97;
              if ((v98 - 33) >= 0xFFFFFFE0)
              {
                do
                {
                  int v99 = *++v97;
                  int v98 = v99;
                }
                while ((v99 - 33) > 0xFFFFFFDF);
              }
            }
LABEL_107:
            int v94 = (unsigned char *)(v97 - a3);
          }
        }
        else
        {
          int v97 = &(++v94)[(void)a3];
          if (v94[(void)a3] == 35) {
            goto LABEL_113;
          }
        }
        if ((unint64_t)v94 >= a4 - a3)
        {
          *(void *)(a2 + 8) += v93;
LABEL_122:
          uint64_t v101 = v13 + 88 * v14;
          uint64_t v102 = *(void *)(v101 + 40);
          uint64_t v178 = (void **)(v101 + 40);
          unint64_t v105 = *(void *)(v101 + 48);
          unint64_t v104 = (void *)(v101 + 48);
          unint64_t v103 = v105;
          if (!v105) {
            goto LABEL_143;
          }
          uint64_t v107 = *(void *)(a2 + 8);
          uint64_t v106 = *(void *)(a2 + 16);
          unint64_t v108 = v107 + v103;
          if (v106)
          {
            if (v108 >= *(void *)v106)
            {
              size_t v177 = (v108 + 255) & 0xFFFFFFFFFFFFFF00;
              uint64_t v109 = malloc_type_realloc(*(void **)(v106 + 16), v177, 0xCCCD1039uLL);
              unint64_t v110 = *(size_t **)(a2 + 16);
              v110[2] = (size_t)v109;
              *unint64_t v110 = v177;
              *(void *)a2 = v109;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v108);
          }
          uint64_t v111 = 0;
          int v112 = 0;
          uint64_t v113 = *(void *)a2 + v107;
          while (2)
          {
            int v114 = v112[v102];
            if ((v114 - 33) <= 0xFFFFFFDF)
            {
              *(unsigned char *)(v113 + v111++) = v114;
              ++v112;
              int v115 = &v112[v102];
              if (v112[v102] == 35)
              {
LABEL_134:
                int v116 = 35;
                while (v116 == 35)
                {
                  ++v115;
                  do
                  {
                    int v116 = *v115;
                    if (!*v115) {
                      goto LABEL_128;
                    }
                    int v118 = *(v115++ - 1);
                  }
                  while (v118 != 10);
                  --v115;
                  if ((v116 - 33) >= 0xFFFFFFE0)
                  {
                    do
                    {
                      int v117 = *++v115;
                      int v116 = v117;
                    }
                    while ((v117 - 33) > 0xFFFFFFDF);
                  }
                }
LABEL_128:
                int v112 = &v115[-v102];
              }
            }
            else
            {
              ++v112;
              int v115 = &v112[v102];
              if (v112[v102] == 35) {
                goto LABEL_134;
              }
            }
            if ((unint64_t)v112 >= v103)
            {
              *(void *)(a2 + 8) += v111;
LABEL_143:
              uint64_t v119 = v13 + 88 * v14;
              signed int v122 = *(_DWORD *)(v119 + 56);
              uint64_t v120 = (signed int *)(v119 + 56);
              signed int v121 = v122;
              if (v122 != -1)
              {
                if ((*(unsigned char *)(v13 + 88 * v14 + 80) & 0x10) == 0)
                {
                  uint64_t v124 = *(void *)(a2 + 8);
                  uint64_t v123 = *(void *)(a2 + 16);
                  unint64_t v125 = v124 + 20;
                  if (*((char *)*v178 + *v104 - 1) == 91)
                  {
                    if (!v123) {
                      goto LABEL_147;
                    }
LABEL_156:
                    if (v125 >= *(void *)v123)
                    {
                      int v135 = malloc_type_realloc(*(void **)(v123 + 16), (v124 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      int v136 = *(unint64_t **)(a2 + 16);
                      v136[2] = (unint64_t)v135;
                      *int v136 = (v124 + 275) & 0xFFFFFFFFFFFFFF00;
                      *(void *)a2 = v135;
                    }
                    goto LABEL_158;
                  }
                  if (v123)
                  {
                    if (v125 >= *(void *)v123)
                    {
                      int v131 = malloc_type_realloc(*(void **)(v123 + 16), (v124 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      unint64_t v132 = *(unint64_t **)(a2 + 16);
                      v132[2] = (unint64_t)v131;
                      *unint64_t v132 = (v124 + 275) & 0xFFFFFFFFFFFFFF00;
                      *(void *)a2 = v131;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)a2, v125);
                  }
                  *(void *)(a2 + 8) += itoa((char *)(*(void *)a2 + v124), v121);
                  if ((*(unsigned char *)(v13 + 88 * v14 + 80) & 0x20) == 0)
                  {
LABEL_185:
                    uint64_t v161 = &a5[(void)a4];
                    if (v161 == a6) {
                      goto LABEL_95;
                    }
                    if (*v178 == &arrayKind)
                    {
                      int v162 = *v161;
                      if (*v161)
                      {
                        if ((v162 - 33) < 0xFFFFFFE0) {
                          goto LABEL_190;
                        }
                        do
                        {
LABEL_189:
                          int v163 = *++v161;
                          int v162 = v163;
                        }
                        while ((v163 - 33) > 0xFFFFFFDF);
LABEL_190:
                        while (v162 == 35)
                        {
                          ++v161;
                          do
                          {
                            int v162 = *v161;
                            if (!*v161) {
                              goto LABEL_196;
                            }
                            int v164 = *(v161++ - 1);
                          }
                          while (v164 != 10);
                          --v161;
                          if ((v162 - 33) >= 0xFFFFFFE0) {
                            goto LABEL_189;
                          }
                        }
                      }
LABEL_196:
                      int v167 = v161[1];
                      uint64_t v166 = (arb *)(v161 + 1);
                      int v165 = v167;
                      if (v167)
                      {
                        if ((v165 - 33) < 0xFFFFFFE0) {
                          goto LABEL_199;
                        }
                        do
                        {
LABEL_198:
                          int v168 = *((unsigned __int8 *)v166 + 1);
                          uint64_t v166 = (arb *)((char *)v166 + 1);
                          int v165 = v168;
                        }
                        while ((v168 - 33) > 0xFFFFFFDF);
LABEL_199:
                        while (v165 == 35)
                        {
                          uint64_t v166 = (arb *)((char *)v166 + 1);
                          do
                          {
                            int v165 = *(unsigned __int8 *)v166;
                            if (!*(unsigned char *)v166) {
                              goto LABEL_205;
                            }
                            int v169 = *((unsigned __int8 *)v166 - 1);
                            uint64_t v166 = (arb *)((char *)v166 + 1);
                          }
                          while (v169 != 10);
                          uint64_t v166 = (arb *)((char *)v166 - 1);
                          if ((v165 - 33) >= 0xFFFFFFE0) {
                            goto LABEL_198;
                          }
                        }
                      }
LABEL_205:
                      uint64_t v171 = *(void *)(a2 + 8);
                      uint64_t v170 = *(void *)(a2 + 16);
                      unint64_t v172 = v171 + 1;
                      if (v170)
                      {
                        if (v172 >= *(void *)v170)
                        {
                          unint64_t v173 = malloc_type_realloc(*(void **)(v170 + 16), (v171 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
                          uint64_t v174 = *(void **)(a2 + 16);
                          v174[2] = v173;
                          *uint64_t v174 = (v171 & 0xFFFFFFFFFFFFFF00) + 256;
                          *(void *)a2 = v173;
                        }
                      }
                      else
                      {
                        str_alloc((string_t *)a2, v172);
                      }
                      string_t v175 = *(string_t *)a2;
                      ++*(void *)(a2 + 8);
                      v175[v171] = 91;
                      uint64_t v176 = arb::asymbol(v166, v182, (const char **)&v181, v16);
                      uint64_t v161 = (char *)arb::obj_write_symbol(v179, a2, v166, *(void *)v182, v181, v176);
                    }
                    str_putm((string_t *)a2, v161, a6 - v161);
                    goto LABEL_95;
                  }
LABEL_164:
                  uint64_t v144 = v13 + 88 * v14;
                  unint64_t v145 = *(void *)(v144 + 72);
                  if (!v145) {
                    goto LABEL_185;
                  }
                  uint64_t v146 = *(void *)(v144 + 64);
                  uint64_t v148 = *(void *)(a2 + 8);
                  uint64_t v147 = *(void *)(a2 + 16);
                  unint64_t v149 = v148 + v145;
                  if (v147)
                  {
                    if (v149 >= *(void *)v147)
                    {
                      size_t v150 = (v149 + 255) & 0xFFFFFFFFFFFFFF00;
                      int v151 = malloc_type_realloc(*(void **)(v147 + 16), v150, 0xCCCD1039uLL);
                      uint64_t v152 = *(size_t **)(a2 + 16);
                      v152[2] = (size_t)v151;
                      *uint64_t v152 = v150;
                      *(void *)a2 = v151;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)a2, v149);
                  }
                  uint64_t v153 = 0;
                  uint64_t v154 = 0;
                  uint64_t v155 = *(void *)a2 + v148;
                  while (2)
                  {
                    int v156 = v154[v146];
                    if ((v156 - 33) <= 0xFFFFFFDF)
                    {
                      *(unsigned char *)(v155 + v153++) = v156;
                      ++v154;
                      uint64_t v157 = &v154[v146];
                      if (v154[v146] == 35)
                      {
LABEL_176:
                        int v158 = 35;
                        while (v158 == 35)
                        {
                          ++v157;
                          do
                          {
                            int v158 = *v157;
                            if (!*v157) {
                              goto LABEL_170;
                            }
                            int v160 = *(v157++ - 1);
                          }
                          while (v160 != 10);
                          --v157;
                          if ((v158 - 33) >= 0xFFFFFFE0)
                          {
                            do
                            {
                              int v159 = *++v157;
                              int v158 = v159;
                            }
                            while ((v159 - 33) > 0xFFFFFFDF);
                          }
                        }
LABEL_170:
                        uint64_t v154 = &v157[-v146];
                      }
                    }
                    else
                    {
                      ++v154;
                      uint64_t v157 = &v154[v146];
                      if (v154[v146] == 35) {
                        goto LABEL_176;
                      }
                    }
                    if ((unint64_t)v154 >= v145)
                    {
                      *(void *)(a2 + 8) += v153;
                      goto LABEL_185;
                    }
                    continue;
                  }
                }
                uint64_t v127 = *(void *)(a2 + 8);
                uint64_t v126 = *(void *)(a2 + 16);
                unint64_t v128 = v127 + 5;
                if (v126)
                {
                  if (v128 >= *(void *)v126)
                  {
                    size_t v129 = malloc_type_realloc(*(void **)(v126 + 16), (v127 + 260) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    int v130 = *(unint64_t **)(a2 + 16);
                    v130[2] = (unint64_t)v129;
                    *int v130 = (v127 + 260) & 0xFFFFFFFFFFFFFF00;
                    *(void *)a2 = v129;
                  }
                }
                else
                {
                  str_alloc((string_t *)a2, v128);
                }
                string_t v133 = *(string_t *)a2;
                *(void *)(a2 + 8) += 5;
                uint64_t v134 = (char *)&v133[v127];
                v134[4] = 91;
                *(_DWORD *)uint64_t v134 = 2003792430;
                signed int v121 = *v120;
                uint64_t v124 = *(void *)(a2 + 8);
                uint64_t v123 = *(void *)(a2 + 16);
                unint64_t v125 = v124 + 20;
                if (v123) {
                  goto LABEL_156;
                }
LABEL_147:
                str_alloc((string_t *)a2, v125);
LABEL_158:
                uint64_t v137 = itoa((char *)(*(void *)a2 + v124), v121);
                uint64_t v138 = *(void *)(a2 + 16);
                uint64_t v139 = *(void *)(a2 + 8) + v137;
                *(void *)(a2 + 8) = v139;
                unint64_t v140 = v139 + 1;
                if (v138)
                {
                  if (v140 >= *(void *)v138)
                  {
                    uint64_t v141 = malloc_type_realloc(*(void **)(v138 + 16), (v139 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
                    size_t v142 = *(void **)(a2 + 16);
                    v142[2] = v141;
                    *size_t v142 = (v139 & 0xFFFFFFFFFFFFFF00) + 256;
                    *(void *)a2 = v141;
                  }
                }
                else
                {
                  str_alloc((string_t *)a2, v140);
                }
                string_t v143 = *(string_t *)a2;
                ++*(void *)(a2 + 8);
                v143[v139] = 93;
              }
              if ((*(unsigned char *)(v13 + 88 * v14 + 80) & 0x20) == 0) {
                goto LABEL_185;
              }
              goto LABEL_164;
            }
            continue;
          }
        }
      }
    }
  }
LABEL_17:
  int v25 = strncmp(a4, "texture", 7uLL);
  if (v25) {
    uint64_t v26 = 0;
  }
  else {
    uint64_t v26 = a4 + 7;
  }
  *(void *)__int16 v182 = v26;
  if (!v25)
  {
    *(_DWORD *)unint64_t v180 = 0;
    arb::aidx((arb *)(a4 + 7), v180, 0, v24);
    if (a3 != a4)
    {
      uint64_t v35 = *(void *)(a2 + 8);
      uint64_t v34 = *(void *)(a2 + 16);
      unint64_t v36 = v35 + a4 - a3;
      if (v34)
      {
        if (v36 >= *(void *)v34)
        {
          size_t v37 = (v36 + 255) & 0xFFFFFFFFFFFFFF00;
          unint64_t v38 = malloc_type_realloc(*(void **)(v34 + 16), v37, 0xCCCD1039uLL);
          string_t v39 = *(size_t **)(a2 + 16);
          v39[2] = (size_t)v38;
          size_t *v39 = v37;
          *(void *)a2 = v38;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v36);
      }
      uint64_t v51 = 0;
      int v52 = 0;
      uint64_t v53 = *(void *)a2 + v35;
      while (1)
      {
        int v54 = v52[(void)a3];
        if ((v54 - 33) <= 0xFFFFFFDF)
        {
          *(unsigned char *)(v53 + v51++) = v54;
          int v55 = &(++v52)[(void)a3];
          if (v52[(void)a3] == 35)
          {
LABEL_55:
            int v56 = 35;
            while (v56 == 35)
            {
              ++v55;
              do
              {
                int v56 = *v55;
                if (!*v55) {
                  goto LABEL_49;
                }
                int v58 = *(v55++ - 1);
              }
              while (v58 != 10);
              --v55;
              if ((v56 - 33) >= 0xFFFFFFE0)
              {
                do
                {
                  int v57 = *++v55;
                  int v56 = v57;
                }
                while ((v57 - 33) > 0xFFFFFFDF);
              }
            }
LABEL_49:
            int v52 = (unsigned char *)(v55 - a3);
          }
        }
        else
        {
          int v55 = &(++v52)[(void)a3];
          if (v52[(void)a3] == 35) {
            goto LABEL_55;
          }
        }
        if ((unint64_t)v52 >= a4 - a3)
        {
          uint64_t v49 = *(void *)(a2 + 8) + v51;
          *(void *)(a2 + 8) = v49;
          unint64_t v50 = v49 + 8;
          uint64_t v48 = *(void *)(a2 + 16);
          if (v48) {
            goto LABEL_64;
          }
LABEL_46:
          str_alloc((string_t *)a2, v50);
          goto LABEL_66;
        }
      }
    }
    uint64_t v49 = *(void *)(a2 + 8);
    uint64_t v48 = *(void *)(a2 + 16);
    unint64_t v50 = v49 + 8;
    if (!v48) {
      goto LABEL_46;
    }
LABEL_64:
    if (v50 >= *(void *)v48)
    {
      uint64_t v59 = malloc_type_realloc(*(void **)(v48 + 16), (v49 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      int v60 = *(unint64_t **)(a2 + 16);
      v60[2] = (unint64_t)v59;
      *int v60 = (v49 + 263) & 0xFFFFFFFFFFFFFF00;
      *(void *)a2 = v59;
    }
LABEL_66:
    string_t v61 = *(string_t *)a2;
    *(void *)(a2 + 8) += 8;
    *(void *)&v61[v49] = 0x5B65727574786574;
    signed int v62 = *(_DWORD *)v180;
    uint64_t v64 = *(void *)(a2 + 8);
    uint64_t v63 = *(void *)(a2 + 16);
    unint64_t v65 = v64 + 20;
    if (v63)
    {
      if (v65 >= *(void *)v63)
      {
        string_t v66 = malloc_type_realloc(*(void **)(v63 + 16), (v64 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        unint64_t v67 = *(unint64_t **)(a2 + 16);
        v67[2] = (unint64_t)v66;
        *unint64_t v67 = (v64 + 275) & 0xFFFFFFFFFFFFFF00;
        *(void *)a2 = v66;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v65);
    }
    uint64_t v68 = itoa((char *)(*(void *)a2 + v64), v62);
    uint64_t v69 = *(void *)(a2 + 16);
    uint64_t v70 = *(void *)(a2 + 8) + v68;
    *(void *)(a2 + 8) = v70;
    *(_DWORD *)unint64_t v180 = v68 + 8;
    unint64_t v71 = v70 + 1;
    if (v69)
    {
      if (v71 >= *(void *)v69)
      {
        int v72 = malloc_type_realloc(*(void **)(v69 + 16), (v70 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
        int v73 = *(void **)(a2 + 16);
        v73[2] = v72;
        *int v73 = (v70 & 0xFFFFFFFFFFFFFF00) + 256;
        *(void *)a2 = v72;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v71);
    }
    string_t v74 = *(string_t *)a2;
    ++*(void *)(a2 + 8);
    v74[v70] = 93;
    uint64_t v75 = &a5[(void)a4];
    if (v75 == a6) {
      goto LABEL_95;
    }
    uint64_t v77 = *(void *)(a2 + 8);
    uint64_t v76 = *(void *)(a2 + 16);
    unint64_t v78 = v77 + a6 - v75;
    if (v76)
    {
      if (v78 >= *(void *)v76)
      {
        size_t v79 = (v78 + 255) & 0xFFFFFFFFFFFFFF00;
        int v80 = malloc_type_realloc(*(void **)(v76 + 16), v79, 0xCCCD1039uLL);
        string_t v81 = *(size_t **)(a2 + 16);
        v81[2] = (size_t)v80;
        *string_t v81 = v79;
        *(void *)a2 = v80;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v78);
    }
    uint64_t v40 = 0;
    signed int v82 = 0;
    uint64_t v83 = *(void *)a2 + v77;
    while (1)
    {
      int v84 = v82[(void)v75];
      if ((v84 - 33) <= 0xFFFFFFDF)
      {
        *(unsigned char *)(v83 + v40++) = v84;
        unint64_t v85 = &(++v82)[(void)v75];
        if (v82[(void)v75] == 35)
        {
LABEL_86:
          int v86 = 35;
LABEL_88:
          if (v86 == 35)
          {
            ++v85;
            while (1)
            {
              int v86 = *v85;
              if (!*v85) {
                break;
              }
              int v88 = *(v85++ - 1);
              if (v88 == 10)
              {
                --v85;
                if ((v86 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    int v87 = *++v85;
                    int v86 = v87;
                  }
                  while ((v87 - 33) > 0xFFFFFFDF);
                }
                goto LABEL_88;
              }
            }
          }
          signed int v82 = (unsigned char *)(v85 - v75);
        }
      }
      else
      {
        unint64_t v85 = &(++v82)[(void)v75];
        if (v82[(void)v75] == 35) {
          goto LABEL_86;
        }
      }
      if ((unint64_t)v82 >= a6 - v75)
      {
LABEL_94:
        *(void *)(a2 + 8) += v40;
        goto LABEL_95;
      }
    }
  }
  size_t v27 = (unsigned char *)(a6 - a3);
  if (a6 != a3)
  {
    uint64_t v29 = *(void *)(a2 + 8);
    uint64_t v28 = *(void *)(a2 + 16);
    unint64_t v30 = (unint64_t)&v27[v29];
    if (v28)
    {
      if (v30 >= *(void *)v28)
      {
        size_t v31 = (v30 + 255) & 0xFFFFFFFFFFFFFF00;
        unint64_t v32 = malloc_type_realloc(*(void **)(v28 + 16), v31, 0xCCCD1039uLL);
        int v33 = *(size_t **)(a2 + 16);
        v33[2] = (size_t)v32;
        size_t *v33 = v31;
        *(void *)a2 = v32;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v30);
    }
    uint64_t v40 = 0;
    int v41 = 0;
    uint64_t v42 = *(void *)a2 + v29;
    while (1)
    {
      int v43 = v41[(void)a3];
      if ((v43 - 33) <= 0xFFFFFFDF)
      {
        *(unsigned char *)(v42 + v40++) = v43;
        int v44 = &(++v41)[(void)a3];
        if (v41[(void)a3] == 35)
        {
LABEL_37:
          int v45 = 35;
LABEL_39:
          if (v45 == 35)
          {
            ++v44;
            while (1)
            {
              int v45 = *v44;
              if (!*v44) {
                break;
              }
              int v47 = *(v44++ - 1);
              if (v47 == 10)
              {
                --v44;
                if ((v45 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    int v46 = *++v44;
                    int v45 = v46;
                  }
                  while ((v46 - 33) > 0xFFFFFFDF);
                }
                goto LABEL_39;
              }
            }
          }
          int v41 = (unsigned char *)(v44 - a3);
        }
      }
      else
      {
        int v44 = &(++v41)[(void)a3];
        if (v41[(void)a3] == 35) {
          goto LABEL_37;
        }
      }
      if (v41 >= v27) {
        goto LABEL_94;
      }
    }
  }
LABEL_95:
  int v89 = *a6;
  if (*a6)
  {
    if ((v89 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_97:
        int v90 = *++a6;
        int v89 = v90;
      }
      while ((v90 - 33) > 0xFFFFFFDF);
    }
LABEL_98:
    if (v89 == 35)
    {
      ++a6;
      while (1)
      {
        int v89 = *a6;
        if (!*a6) {
          break;
        }
        int v91 = *(a6++ - 1);
        if (v91 == 10)
        {
          --a6;
          if ((v89 - 33) >= 0xFFFFFFE0) {
            goto LABEL_97;
          }
          goto LABEL_98;
        }
      }
    }
  }
  return a6;
}

void arb::obj_write_ssat(uint64_t a1, uint64_t a2, arb *this, unint64_t *a4)
{
  int v7 = *(unsigned __int8 *)this;
  int v8 = v7;
  int v9 = this;
  if ((ctype[2 * *(unsigned __int8 *)this] & 0x40) != 0)
  {
    int v9 = this;
    do
    {
      int v10 = *((unsigned __int8 *)v9 + 1);
      int v9 = (arb *)((char *)v9 + 1);
      int v8 = v10;
    }
    while ((ctype[2 * v10] & 0x40) != 0);
  }
  int v116 = 0;
  *(void *)int v117 = 0;
  unint64_t v11 = v9;
  if (v8)
  {
    unint64_t v11 = v9;
    if ((v8 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_6:
        int v12 = *((unsigned __int8 *)v11 + 1);
        unint64_t v11 = (arb *)((char *)v11 + 1);
        int v8 = v12;
      }
      while ((v12 - 33) > 0xFFFFFFDF);
    }
LABEL_7:
    if (v8 == 35)
    {
      unint64_t v11 = (arb *)((char *)v11 + 1);
      while (1)
      {
        int v8 = *(unsigned __int8 *)v11;
        if (!*(unsigned char *)v11) {
          break;
        }
        int v13 = *((unsigned __int8 *)v11 - 1);
        unint64_t v11 = (arb *)((char *)v11 + 1);
        if (v13 == 10)
        {
          unint64_t v11 = (arb *)((char *)v11 - 1);
          if ((v8 - 33) >= 0xFFFFFFE0) {
            goto LABEL_6;
          }
          goto LABEL_7;
        }
      }
    }
  }
  *(void *)int v117 = v11;
  arb::asymbol(v11, v117, (const char **)&v116, a4);
  unint64_t v14 = v116;
  int v15 = *(unsigned __int8 **)v117;
  uint64_t v16 = *(void *)a1;
  unint64_t v17 = *(void *)(a1 + 8);
  unint64_t v18 = v17 >> 1;
  int v118 = *(unsigned __int8 **)v117;
  int v19 = arb::ascan(&v118, (const char **)v116, (unsigned __int8 *)(v16 + 88 * (v17 >> 1)), (const char *)1);
  for (int i = v7;
        v19;
        int v19 = arb::ascan(&v118, (const char **)v14, (unsigned __int8 *)(v16 + 88 * (v17 >> 1)), (const char *)1))
  {
    if (v19 > 0) {
      unint64_t v20 = v18 + 1;
    }
    else {
      unint64_t v20 = 0;
    }
    v16 += 88 * v20;
    if (v19 <= 0) {
      unint64_t v17 = v18;
    }
    else {
      v17 -= v18 + 1;
    }
    unint64_t v18 = v17 >> 1;
    int v118 = v15;
  }
  size_t v21 = *(void **)(v16 + 88 * v18 + 40);
  uint64_t v23 = *(void *)(a2 + 8);
  uint64_t v22 = *(void *)(a2 + 16);
  if (v21 == &outputKind)
  {
    unint64_t v27 = v23 + 5;
    if (v22)
    {
      if (v27 >= *(void *)v22)
      {
        uint64_t v28 = malloc_type_realloc(*(void **)(v22 + 16), (v23 + 260) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        uint64_t v29 = *(unint64_t **)(a2 + 16);
        _OWORD v29[2] = (unint64_t)v28;
        *uint64_t v29 = (v23 + 260) & 0xFFFFFFFFFFFFFF00;
        *(void *)a2 = v28;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v27);
    }
    string_t v52 = *(string_t *)a2;
    *(void *)(a2 + 8) += 5;
    uint64_t v53 = (char *)&v52[v23];
    v53[4] = 114;
    *(_DWORD *)uint64_t v53 = 542001485;
    signed int v54 = *(_DWORD *)(a1 + 60);
    uint64_t v56 = *(void *)(a2 + 8);
    uint64_t v55 = *(void *)(a2 + 16);
    unint64_t v57 = v56 + 20;
    if (v55)
    {
      if (v57 >= *(void *)v55)
      {
        int v58 = malloc_type_realloc(*(void **)(v55 + 16), (v56 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        uint64_t v59 = *(unint64_t **)(a2 + 16);
        v59[2] = (unint64_t)v58;
        *uint64_t v59 = (v56 + 275) & 0xFFFFFFFFFFFFFF00;
        *(void *)a2 = v58;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v57);
    }
    uint64_t v60 = itoa((char *)(*(void *)a2 + v56), v54);
    uint64_t v61 = *(void *)(a2 + 16);
    uint64_t v62 = *(void *)(a2 + 8) + v60;
    *(void *)(a2 + 8) = v62;
    unint64_t v63 = v62 + 2;
    if (v61)
    {
      if (v63 >= *(void *)v61)
      {
        uint64_t v64 = malloc_type_realloc(*(void **)(v61 + 16), (v62 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        unint64_t v65 = *(unint64_t **)(a2 + 16);
        v65[2] = (unint64_t)v64;
        unint64_t *v65 = (v62 + 257) & 0xFFFFFFFFFFFFFF00;
        *(void *)a2 = v64;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v63);
    }
    string_t v66 = *(string_t *)a2;
    *(void *)(a2 + 8) += 2;
    *(_WORD *)&v66[v62] = 29228;
    signed int v67 = *(_DWORD *)(a1 + 60);
    uint64_t v69 = *(void *)(a2 + 8);
    uint64_t v68 = *(void *)(a2 + 16);
    unint64_t v70 = v69 + 20;
    if (v68)
    {
      if (v70 >= *(void *)v68)
      {
        unint64_t v71 = malloc_type_realloc(*(void **)(v68 + 16), (v69 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        int v72 = *(unint64_t **)(a2 + 16);
        v72[2] = (unint64_t)v71;
        *int v72 = (v69 + 275) & 0xFFFFFFFFFFFFFF00;
        *(void *)a2 = v71;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v70);
    }
    uint64_t v73 = itoa((char *)(*(void *)a2 + v69), v67);
    uint64_t v74 = *(void *)(a2 + 16);
    uint64_t v75 = *(void *)(a2 + 8) + v73;
    *(void *)(a2 + 8) = v75;
    unint64_t v76 = v75 + 7;
    if (v74)
    {
      if (v76 >= *(void *)v74)
      {
        uint64_t v77 = malloc_type_realloc(*(void **)(v74 + 16), (v75 + 262) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        unint64_t v78 = *(unint64_t **)(a2 + 16);
        v78[2] = (unint64_t)v77;
        unint64_t *v78 = (v75 + 262) & 0xFFFFFFFFFFFFFF00;
        *(void *)a2 = v77;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v76);
    }
    string_t v79 = *(string_t *)a2;
    *(void *)(a2 + 8) += 7;
    int v80 = (char *)&v79[v75];
    *(_DWORD *)(v80 + 3) = 1480674570;
    *(_DWORD *)int v80 = 171651372;
    if (i != 95)
    {
      uint64_t v81 = v9 - this - 5;
      uint64_t v83 = *(void *)(a2 + 8);
      uint64_t v82 = *(void *)(a2 + 16);
      unint64_t v84 = v83 + v81;
      if (v82)
      {
        if (v84 >= *(void *)v82)
        {
          size_t v85 = (v84 + 255) & 0xFFFFFFFFFFFFFF00;
          int v86 = malloc_type_realloc(*(void **)(v82 + 16), v85, 0xCCCD1039uLL);
          int v87 = *(size_t **)(a2 + 16);
          v87[2] = (size_t)v86;
          *int v87 = v85;
          *(void *)a2 = v86;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v84);
      }
      string_t v100 = *(string_t *)a2;
      *(void *)(a2 + 8) += v81;
      memcpy((void *)&v100[v83], this, v9 - this - 5);
    }
    arb::obj_write_dest((uint64_t *)a1, (string_t *)a2, v9, v117, (const char **)&v116, 1, 1);
    uint64_t v102 = *(void *)(a2 + 8);
    uint64_t v101 = *(void *)(a2 + 16);
    unint64_t v103 = v102 + 2;
    if (v101)
    {
      if (v103 >= *(void *)v101)
      {
        unint64_t v104 = malloc_type_realloc(*(void **)(v101 + 16), (v102 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        unint64_t v105 = *(unint64_t **)(a2 + 16);
        v105[2] = (unint64_t)v104;
        *unint64_t v105 = (v102 + 257) & 0xFFFFFFFFFFFFFF00;
        *(void *)a2 = v104;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v103);
    }
    string_t v106 = *(string_t *)a2;
    *(void *)(a2 + 8) += 2;
    *(_WORD *)&v106[v102] = 29228;
    signed int v107 = *(_DWORD *)(a1 + 60);
    uint64_t v109 = *(void *)(a2 + 8);
    uint64_t v108 = *(void *)(a2 + 16);
    unint64_t v110 = v109 + 20;
    if (v108)
    {
      if (v110 >= *(void *)v108)
      {
        uint64_t v111 = malloc_type_realloc(*(void **)(v108 + 16), (v109 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        int v112 = *(unint64_t **)(a2 + 16);
        v112[2] = (unint64_t)v111;
        *int v112 = (v109 + 275) & 0xFFFFFFFFFFFFFF00;
        *(void *)a2 = v111;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v110);
    }
    uint64_t v113 = itoa((char *)(*(void *)a2 + v109), v107);
    uint64_t v95 = *(void *)(a2 + 16);
    uint64_t v96 = *(void *)(a2 + 8) + v113;
    *(void *)(a2 + 8) = v96;
    unint64_t v97 = v96 + 4;
    if (v95) {
      goto LABEL_69;
    }
LABEL_82:
    str_alloc((string_t *)a2, v97);
    goto LABEL_83;
  }
  unint64_t v24 = v23 + 3;
  if (v22)
  {
    if (v24 >= *(void *)v22)
    {
      int v25 = malloc_type_realloc(*(void **)(v22 + 16), (v23 + 258) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      uint64_t v26 = *(unint64_t **)(a2 + 16);
      v26[2] = (unint64_t)v25;
      *uint64_t v26 = (v23 + 258) & 0xFFFFFFFFFFFFFF00;
      *(void *)a2 = v25;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v24);
  }
  string_t v30 = *(string_t *)a2;
  *(void *)(a2 + 8) += 3;
  size_t v31 = (char *)&v30[v23];
  v31[2] = 78;
  *(_WORD *)size_t v31 = 18765;
  arb::obj_write_dest((uint64_t *)a1, (string_t *)a2, v9, v117, (const char **)&v116, 1, 1);
  uint64_t v33 = *(void *)(a2 + 8);
  uint64_t v32 = *(void *)(a2 + 16);
  unint64_t v34 = v33 + 1;
  if (v32)
  {
    if (v34 >= *(void *)v32)
    {
      uint64_t v35 = malloc_type_realloc(*(void **)(v32 + 16), (v33 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      unint64_t v36 = *(void **)(a2 + 16);
      v36[2] = v35;
      *unint64_t v36 = (v33 & 0xFFFFFFFFFFFFFF00) + 256;
      *(void *)a2 = v35;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v34);
  }
  string_t v37 = *(string_t *)a2;
  ++*(void *)(a2 + 8);
  v37[v33] = 44;
  arb::obj_write_symbol((void *)a1, a2, *(const char **)v117, *(const char **)v117, v116, &v116[*(void *)v117]);
  uint64_t v39 = *(void *)(a2 + 8);
  uint64_t v38 = *(void *)(a2 + 16);
  unint64_t v40 = v39 + 7;
  if (v38)
  {
    if (v40 >= *(void *)v38)
    {
      int v41 = malloc_type_realloc(*(void **)(v38 + 16), (v39 + 262) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      uint64_t v42 = *(unint64_t **)(a2 + 16);
      v42[2] = (unint64_t)v41;
      *uint64_t v42 = (v39 + 262) & 0xFFFFFFFFFFFFFF00;
      *(void *)a2 = v41;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v40);
  }
  string_t v43 = *(string_t *)a2;
  *(void *)(a2 + 8) += 7;
  int v44 = (char *)&v43[v39];
  *(_DWORD *)(v44 + 3) = 1480674570;
  *(_DWORD *)int v44 = 171651372;
  if (i != 95)
  {
    uint64_t v45 = v9 - this - 5;
    uint64_t v47 = *(void *)(a2 + 8);
    uint64_t v46 = *(void *)(a2 + 16);
    unint64_t v48 = v47 + v45;
    if (v46)
    {
      if (v48 >= *(void *)v46)
      {
        size_t v49 = (v48 + 255) & 0xFFFFFFFFFFFFFF00;
        unint64_t v50 = malloc_type_realloc(*(void **)(v46 + 16), v49, 0xCCCD1039uLL);
        uint64_t v51 = *(size_t **)(a2 + 16);
        v51[2] = (size_t)v50;
        *uint64_t v51 = v49;
        *(void *)a2 = v50;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v48);
    }
    string_t v88 = *(string_t *)a2;
    *(void *)(a2 + 8) += v45;
    memcpy((void *)&v88[v47], this, v9 - this - 5);
  }
  arb::obj_write_dest((uint64_t *)a1, (string_t *)a2, v9, v117, (const char **)&v116, 1, 1);
  uint64_t v90 = *(void *)(a2 + 8);
  uint64_t v89 = *(void *)(a2 + 16);
  unint64_t v91 = v90 + 1;
  if (v89)
  {
    if (v91 >= *(void *)v89)
    {
      unint64_t v92 = malloc_type_realloc(*(void **)(v89 + 16), (v90 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      uint64_t v93 = *(void **)(a2 + 16);
      v93[2] = v92;
      *uint64_t v93 = (v90 & 0xFFFFFFFFFFFFFF00) + 256;
      *(void *)a2 = v92;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v91);
  }
  string_t v94 = *(string_t *)a2;
  ++*(void *)(a2 + 8);
  v94[v90] = 44;
  arb::obj_write_symbol((void *)a1, a2, *(const char **)v117, *(const char **)v117, v116, &v116[*(void *)v117]);
  uint64_t v96 = *(void *)(a2 + 8);
  uint64_t v95 = *(void *)(a2 + 16);
  unint64_t v97 = v96 + 4;
  if (!v95) {
    goto LABEL_82;
  }
LABEL_69:
  if (v97 >= *(void *)v95)
  {
    int v98 = malloc_type_realloc(*(void **)(v95 + 16), (v96 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
    int v99 = *(unint64_t **)(a2 + 16);
    v99[2] = (unint64_t)v98;
    *int v99 = (v96 + 259) & 0xFFFFFFFFFFFFFF00;
    *(void *)a2 = v98;
  }
LABEL_83:
  string_t v114 = *(string_t *)a2;
  *(void *)(a2 + 8) += 4;
  *(_DWORD *)&v114[v96] = 993078572;
}

void str_putm(string_t *a1, const char *a2, unint64_t a3)
{
  if (a3)
  {
    string_t v7 = a1[1];
    string_t v6 = a1[2];
    unint64_t v8 = (unint64_t)&v7[a3];
    if (v6)
    {
      if (v8 >= *(void *)v6)
      {
        size_t v9 = (v8 + 255) & 0xFFFFFFFFFFFFFF00;
        int v10 = (const char *)malloc_type_realloc(*((void **)v6 + 2), v9, 0xCCCD1039uLL);
        unint64_t v11 = (char *)a1[2];
        *((void *)v11 + 2) = v10;
        *(void *)unint64_t v11 = v9;
        *a1 = v10;
      }
    }
    else
    {
      str_alloc(a1, v8);
    }
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = &v7[(void)*a1];
    while (1)
    {
      if ((a2[v13] - 33) <= 0xDFu)
      {
        char v16 = 120;
        switch(a2[v13])
        {
          case 'a':
            char v16 = 119;
            break;
          case 'b':
            char v16 = 122;
            break;
          case 'g':
            char v16 = 121;
            break;
          case 'r':
            break;
          default:
            char v16 = a2[v13];
            break;
        }
        v14[v12++] = v16;
        int v15 = &a2[++v13];
        if (a2[v13] == 35)
        {
LABEL_18:
          int v17 = 35;
LABEL_20:
          if (v17 == 35)
          {
            ++v15;
            while (1)
            {
              int v17 = *(unsigned __int8 *)v15;
              if (!*v15) {
                break;
              }
              int v19 = *((unsigned __int8 *)v15++ - 1);
              if (v19 == 10)
              {
                --v15;
                if ((v17 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    int v18 = *(unsigned __int8 *)++v15;
                    int v17 = v18;
                  }
                  while ((v18 - 33) > 0xFFFFFFDF);
                }
                goto LABEL_20;
              }
            }
          }
          unint64_t v13 = v15 - a2;
        }
      }
      else
      {
        int v15 = &a2[++v13];
        if (a2[v13] == 35) {
          goto LABEL_18;
        }
      }
      if (v13 >= a3)
      {
        a1[1] += v12;
        return;
      }
    }
  }
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
}

unsigned char *glsl::glindex(glsl *this, char *a2, unsigned int *a3)
{
  while (1)
  {
    do
    {
LABEL_3:
      int v3 = this;
      int v4 = (char *)this + 1;
      int v5 = *(unsigned __int8 *)this;
      this = (glsl *)((char *)this + 1);
    }
    while ((v5 - 33) >= 0xFFFFFFE0);
    if (v5 != 47) {
      break;
    }
    int v6 = *v4;
    if (v6 == 42)
    {
      this = (glsl *)((char *)v3 + 2);
      if (*((unsigned char *)v3 + 2))
      {
        do
        {
          if (*(v4 - 1) == 42 && *v4 == 47) {
            break;
          }
          int v9 = v4[2];
          ++v4;
        }
        while (v9);
        this = (glsl *)(v4 + 1);
      }
    }
    else
    {
      if (v6 != 47) {
        return 0;
      }
      string_t v7 = (glsl *)((char *)v3 + 2);
      while (*(unsigned char *)v7)
      {
        int v8 = *((unsigned __int8 *)v7 - 1);
        this = v7;
        string_t v7 = (glsl *)((char *)v7 + 1);
        if (v8 == 10) {
          goto LABEL_3;
        }
      }
      this = v7;
    }
  }
  if (v5 != 91) {
    return 0;
  }
  int v10 = *v4;
  if ((v10 - 58) < 0xFFFFFFF6) {
    return 0;
  }
  int v12 = 0;
  do
  {
    int v12 = v10 + 10 * v12 - 48;
    int v13 = *++v4;
    int v10 = v13;
  }
  while ((v13 - 58) > 0xFFFFFFF5);
  *(_DWORD *)a2 = v12;
  while (1)
  {
    do
    {
LABEL_24:
      unint64_t v14 = v4;
      int v15 = v4 + 1;
      int v16 = *v4++;
    }
    while ((v16 - 33) >= 0xFFFFFFE0);
    if (v16 != 47) {
      break;
    }
    int v17 = *v15;
    if (v17 == 42)
    {
      int v4 = v14 + 2;
      if (v14[2])
      {
        do
        {
          if (*(v15 - 1) == 42 && *v15 == 47) {
            break;
          }
          int v20 = v15[2];
          ++v15;
        }
        while (v20);
        int v4 = v15 + 1;
      }
    }
    else
    {
      if (v17 != 47) {
        return 0;
      }
      int v18 = v14 + 2;
      while (*v18)
      {
        int v19 = *(v18 - 1);
        int v4 = v18++;
        if (v19 == 10) {
          goto LABEL_24;
        }
      }
      int v4 = v18;
    }
  }
  if (v16 == 93) {
    return v14;
  }
  else {
    return 0;
  }
}

void string_t::~string_t(string_t *this)
{
  int v2 = (char *)this[3];
  if (v2)
  {
    this[4] = v2;
    operator delete(v2);
  }
}

void HGAutoReleasePoolScopeGuard::HGAutoReleasePoolScopeGuard(HGAutoReleasePoolScopeGuard *this)
{
  *(void *)this = objc_opt_new();
}

void HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(id *this)
{
  *this = 0;
}

void HRasterizerTexture::HRasterizerTexture(HRasterizerTexture *this)
{
}

void sub_1B774014C(_Unwind_Exception *a1)
{
  HgcRasterizerTexture::~HgcRasterizerTexture(v1);
  _Unwind_Resume(a1);
}

void HRasterizerTexture::~HRasterizerTexture(HRasterizerTexture *this)
{
  HgcRasterizerTexture::~HgcRasterizerTexture(this);

  HGObject::operator delete(v1);
}

void HGSynchronizable::HGSynchronizable(HGSynchronizable *this)
{
  this->int var0 = (void **)&unk_1F10CF360;
  this->unsigned int var2 = 0;
  this->unsigned int var3 = 0;
  pthread_mutex_init(&this->var1, 0);
  pthread_cond_init(&this->var4, 0);
}

void HGSynchronizable::~HGSynchronizable(HGSynchronizable *this)
{
  this->int var0 = (void **)&unk_1F10CF360;
  pthread_cond_destroy(&this->var4);
  pthread_mutex_destroy(&this->var1);
}

{
  uint64_t vars8;

  this->int var0 = (void **)&unk_1F10CF360;
  pthread_cond_destroy(&this->var4);
  pthread_mutex_destroy(&this->var1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t HGSynchronizable::Notify(HGSynchronizable *this)
{
  return pthread_cond_signal(&this->var4);
}

uint64_t HGSynchronizable::NotifyAll(HGSynchronizable *this)
{
  return pthread_cond_broadcast(&this->var4);
}

_opaque_pthread_t *HGSynchronizable::Lock(HGSynchronizable *this)
{
  unsigned int var2 = this->var2;
  uint64_t result = pthread_self();
  if (var2 == result)
  {
    ++this->var3;
  }
  else
  {
    pthread_mutex_lock(&this->var1);
    this->unsigned int var3 = 0;
    uint64_t result = pthread_self();
    this->unsigned int var2 = result;
  }
  return result;
}

HGSynchronizable *HGSynchronizable::Unlock(HGSynchronizable *this)
{
  unint64_t var3 = this->var3;
  if (var3)
  {
    this->unint64_t var3 = var3 - 1;
  }
  else
  {
    this->unsigned int var2 = 0;
    this->unint64_t var3 = 0;
    return (HGSynchronizable *)pthread_mutex_unlock(&this->var1);
  }
  return this;
}

pthread_t HGSynchronizable::Wait(HGSynchronizable *this)
{
  unint64_t var3 = this->var3;
  this->unsigned int var2 = 0;
  p_unsigned int var2 = &this->var2;
  this->unint64_t var3 = 0;
  pthread_cond_wait(&this->var4, &this->var1);
  this->unint64_t var3 = var3;
  pthread_t result = pthread_self();
  *p_unsigned int var2 = result;
  return result;
}

void sub_1B7740394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGSynchronizable::NestingReleaser::~NestingReleaser(HGSynchronizable::NestingReleaser *this)
{
  *(void *)(*(void *)this + 80) = *((void *)this + 1);
  *(void *)(*(void *)this + 72) = pthread_self();
}

uint64_t HGMultiTexBlendBase::create(HGMultiTexBlendBase *this)
{
  switch((int)this)
  {
    case 2:
      uint64_t v1 = HGObject::operator new(0x1E0uLL);
      HGMultiTexBlend<2>::HGMultiTexBlend((uint64_t)v1);
    case 3:
      int v3 = HGObject::operator new(0x1E0uLL);
      HGMultiTexBlend<3>::HGMultiTexBlend((uint64_t)v3);
    case 4:
      int v4 = HGObject::operator new(0x1F0uLL);
      HGMultiTexBlend<4>::HGMultiTexBlend((uint64_t)v4);
    case 5:
      int v5 = HGObject::operator new(0x1F0uLL);
      HGMultiTexBlend<5>::HGMultiTexBlend((uint64_t)v5);
    case 6:
      int v6 = HGObject::operator new(0x200uLL);
      HGMultiTexBlend<6>::HGMultiTexBlend((uint64_t)v6);
    case 7:
      string_t v7 = HGObject::operator new(0x200uLL);
      HGMultiTexBlend<7>::HGMultiTexBlend((uint64_t)v7);
    case 8:
      int v8 = HGObject::operator new(0x210uLL);
      HGMultiTexBlend<8>::HGMultiTexBlend((uint64_t)v8);
    default:
      return 0;
  }
}

void sub_1B77404CC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77404E0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77404F4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7740508(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B774051C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7740530(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7740544(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<2>::HGMultiTexBlend(uint64_t a1)
{
  HGNode::HGNode((HGNode *)a1);
  void *v2 = &unk_1F10CF390;
  int v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(void *)(a1 + 440) = v3;
  int v4 = (HgcMultiTexBlend_2 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_2::HgcMultiTexBlend_2(v4);
}

void sub_1B77406DC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7740700(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7740714(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<2>::~HGMultiTexBlend(HGNode *this)
{
  *(void *)this = &unk_1F10CF390;
  uint64_t v2 = *((void *)this + 55);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 58);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 56);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *((void *)this + 57);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }

  HGNode::~HGNode(this);
}

void HGMultiTexBlend<2>::~HGMultiTexBlend(HGNode *a1)
{
  HGMultiTexBlend<2>::~HGMultiTexBlend(a1);

  HGObject::operator delete(v1);
}

uint64_t HGMultiTexBlend<2>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a1 + 8 * a2;
  uint64_t result = *(void *)(v3 + 448);
  if (result)
  {
    uint64_t v5 = v3 + 448;
    (*(void (**)(uint64_t, uint64_t))(*(void *)result + 576))(result, a3);
    int v6 = *(uint64_t (**)(void))(**(void **)v5 + 160);
    return v6();
  }
  return result;
}

uint64_t HGMultiTexBlend<2>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<2>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  (*(void (**)(void, void, float, float, float, float))(**(void **)(a1 + 464) + 96))(*(void *)(a1 + 464), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(void, uint64_t, float, float, float, float))(**(void **)(a1 + 464) + 96))(*(void *)(a1 + 464), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  uint64_t v4 = *(void *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v4 + 120))(v4, 0, Input);
  return *(void *)(a1 + 464);
}

void HGMultiTexBlend<3>::HGMultiTexBlend(uint64_t a1)
{
  HGNode::HGNode((HGNode *)a1);
  void *v2 = &unk_1F10CF5F0;
  uint64_t v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(void *)(a1 + 440) = v3;
  uint64_t v4 = (HgcMultiTexBlend_3 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_3::HgcMultiTexBlend_3(v4);
}

void sub_1B7740BE4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7740C1C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<3>::~HGMultiTexBlend(HGNode *this)
{
  *(void *)this = &unk_1F10CF5F0;
  uint64_t v2 = *((void *)this + 55);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 59);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 56);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *((void *)this + 57);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  uint64_t v6 = *((void *)this + 58);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }

  HGNode::~HGNode(this);
}

void HGMultiTexBlend<3>::~HGMultiTexBlend(HGNode *a1)
{
  HGMultiTexBlend<3>::~HGMultiTexBlend(a1);

  HGObject::operator delete(v1);
}

uint64_t HGMultiTexBlend<3>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a1 + 8 * a2;
  uint64_t result = *(void *)(v3 + 448);
  if (result)
  {
    uint64_t v5 = v3 + 448;
    (*(void (**)(uint64_t, uint64_t))(*(void *)result + 576))(result, a3);
    uint64_t v6 = *(uint64_t (**)(void))(**(void **)v5 + 160);
    return v6();
  }
  return result;
}

uint64_t HGMultiTexBlend<3>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<3>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  (*(void (**)(void, void, float, float, float, float))(**(void **)(a1 + 472) + 96))(*(void *)(a1 + 472), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(void, uint64_t, float, float, float, float))(**(void **)(a1 + 472) + 96))(*(void *)(a1 + 472), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  uint64_t v4 = *(void *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v4 + 120))(v4, 0, Input);
  return *(void *)(a1 + 472);
}

void HGMultiTexBlend<4>::HGMultiTexBlend(uint64_t a1)
{
  HGNode::HGNode((HGNode *)a1);
  void *v2 = &unk_1F10CF850;
  uint64_t v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(void *)(a1 + 440) = v3;
  uint64_t v4 = (HgcMultiTexBlend_4 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_4::HgcMultiTexBlend_4(v4);
}

void sub_1B7741188(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B77411C0(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<4>::~HGMultiTexBlend(HGNode *this)
{
  *(void *)this = &unk_1F10CF850;
  uint64_t v2 = *((void *)this + 55);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 60);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 56);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *((void *)this + 57);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  uint64_t v6 = *((void *)this + 58);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  uint64_t v7 = *((void *)this + 59);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }

  HGNode::~HGNode(this);
}

void HGMultiTexBlend<4>::~HGMultiTexBlend(HGNode *a1)
{
  HGMultiTexBlend<4>::~HGMultiTexBlend(a1);

  HGObject::operator delete(v1);
}

uint64_t HGMultiTexBlend<4>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a1 + 8 * a2;
  uint64_t result = *(void *)(v3 + 448);
  if (result)
  {
    uint64_t v5 = v3 + 448;
    (*(void (**)(uint64_t, uint64_t))(*(void *)result + 576))(result, a3);
    uint64_t v6 = *(uint64_t (**)(void))(**(void **)v5 + 160);
    return v6();
  }
  return result;
}

uint64_t HGMultiTexBlend<4>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<4>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  (*(void (**)(void, void, float, float, float, float))(**(void **)(a1 + 480) + 96))(*(void *)(a1 + 480), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(void, uint64_t, float, float, float, float))(**(void **)(a1 + 480) + 96))(*(void *)(a1 + 480), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  uint64_t v4 = *(void *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v4 + 120))(v4, 0, Input);
  return *(void *)(a1 + 480);
}

void HGMultiTexBlend<5>::HGMultiTexBlend(uint64_t a1)
{
  HGNode::HGNode((HGNode *)a1);
  void *v2 = &unk_1F10CFAB0;
  uint64_t v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(void *)(a1 + 440) = v3;
  uint64_t v4 = (HgcMultiTexBlend_5 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_5::HgcMultiTexBlend_5(v4);
}

void sub_1B77417E8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7741820(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<5>::~HGMultiTexBlend(HGNode *this)
{
  *(void *)this = &unk_1F10CFAB0;
  uint64_t v2 = *((void *)this + 55);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 61);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 56);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *((void *)this + 57);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  uint64_t v6 = *((void *)this + 58);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  uint64_t v7 = *((void *)this + 59);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  uint64_t v8 = *((void *)this + 60);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }

  HGNode::~HGNode(this);
}

void HGMultiTexBlend<5>::~HGMultiTexBlend(HGNode *a1)
{
  HGMultiTexBlend<5>::~HGMultiTexBlend(a1);

  HGObject::operator delete(v1);
}

uint64_t HGMultiTexBlend<5>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a1 + 8 * a2;
  uint64_t result = *(void *)(v3 + 448);
  if (result)
  {
    uint64_t v5 = v3 + 448;
    (*(void (**)(uint64_t, uint64_t))(*(void *)result + 576))(result, a3);
    uint64_t v6 = *(uint64_t (**)(void))(**(void **)v5 + 160);
    return v6();
  }
  return result;
}

uint64_t HGMultiTexBlend<5>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<5>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  (*(void (**)(void, void, float, float, float, float))(**(void **)(a1 + 488) + 96))(*(void *)(a1 + 488), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(void, uint64_t, float, float, float, float))(**(void **)(a1 + 488) + 96))(*(void *)(a1 + 488), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  uint64_t v4 = *(void *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v4 + 120))(v4, 0, Input);
  return *(void *)(a1 + 488);
}

void HGMultiTexBlend<6>::HGMultiTexBlend(uint64_t a1)
{
  HGNode::HGNode((HGNode *)a1);
  void *v2 = &unk_1F10CFD10;
  uint64_t v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(void *)(a1 + 440) = v3;
  uint64_t v4 = (HgcMultiTexBlend_6 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_6::HgcMultiTexBlend_6(v4);
}

void sub_1B7741EF4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7741F2C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<6>::~HGMultiTexBlend(HGNode *this)
{
  *(void *)this = &unk_1F10CFD10;
  uint64_t v2 = *((void *)this + 55);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 62);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 56);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *((void *)this + 57);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  uint64_t v6 = *((void *)this + 58);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  uint64_t v7 = *((void *)this + 59);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  uint64_t v8 = *((void *)this + 60);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
  uint64_t v9 = *((void *)this + 61);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }

  HGNode::~HGNode(this);
}

void HGMultiTexBlend<6>::~HGMultiTexBlend(HGNode *a1)
{
  HGMultiTexBlend<6>::~HGMultiTexBlend(a1);

  HGObject::operator delete(v1);
}

uint64_t HGMultiTexBlend<6>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a1 + 8 * a2;
  uint64_t result = *(void *)(v3 + 448);
  if (result)
  {
    uint64_t v5 = v3 + 448;
    (*(void (**)(uint64_t, uint64_t))(*(void *)result + 576))(result, a3);
    uint64_t v6 = *(uint64_t (**)(void))(**(void **)v5 + 160);
    return v6();
  }
  return result;
}

uint64_t HGMultiTexBlend<6>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<6>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  (*(void (**)(void, void, float, float, float, float))(**(void **)(a1 + 496) + 96))(*(void *)(a1 + 496), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(void, uint64_t, float, float, float, float))(**(void **)(a1 + 496) + 96))(*(void *)(a1 + 496), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  uint64_t v4 = *(void *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v4 + 120))(v4, 0, Input);
  return *(void *)(a1 + 496);
}

void HGMultiTexBlend<7>::HGMultiTexBlend(uint64_t a1)
{
  HGNode::HGNode((HGNode *)a1);
  void *v2 = &unk_1F10CFF70;
  uint64_t v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(void *)(a1 + 440) = v3;
  uint64_t v4 = (HgcMultiTexBlend_7 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_7::HgcMultiTexBlend_7(v4);
}

void sub_1B77426AC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B77426E4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<7>::~HGMultiTexBlend(HGNode *this)
{
  *(void *)this = &unk_1F10CFF70;
  uint64_t v2 = *((void *)this + 55);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 63);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 56);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *((void *)this + 57);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  uint64_t v6 = *((void *)this + 58);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  uint64_t v7 = *((void *)this + 59);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  uint64_t v8 = *((void *)this + 60);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
  uint64_t v9 = *((void *)this + 61);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  uint64_t v10 = *((void *)this + 62);
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  }

  HGNode::~HGNode(this);
}

void HGMultiTexBlend<7>::~HGMultiTexBlend(HGNode *a1)
{
  HGMultiTexBlend<7>::~HGMultiTexBlend(a1);

  HGObject::operator delete(v1);
}

uint64_t HGMultiTexBlend<7>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a1 + 8 * a2;
  uint64_t result = *(void *)(v3 + 448);
  if (result)
  {
    uint64_t v5 = v3 + 448;
    (*(void (**)(uint64_t, uint64_t))(*(void *)result + 576))(result, a3);
    uint64_t v6 = *(uint64_t (**)(void))(**(void **)v5 + 160);
    return v6();
  }
  return result;
}

uint64_t HGMultiTexBlend<7>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<7>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  (*(void (**)(void, void, float, float, float, float))(**(void **)(a1 + 504) + 96))(*(void *)(a1 + 504), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(void, uint64_t, float, float, float, float))(**(void **)(a1 + 504) + 96))(*(void *)(a1 + 504), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  uint64_t v4 = *(void *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v4 + 120))(v4, 0, Input);
  return *(void *)(a1 + 504);
}

void HGMultiTexBlend<8>::HGMultiTexBlend(uint64_t a1)
{
  HGNode::HGNode((HGNode *)a1);
  void *v2 = &unk_1F10D01D0;
  uint64_t v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(void *)(a1 + 440) = v3;
  uint64_t v4 = (HgcMultiTexBlend_8 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_8::HgcMultiTexBlend_8(v4);
}

void sub_1B7742EF0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7742F28(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<8>::~HGMultiTexBlend(HGNode *this)
{
  *(void *)this = &unk_1F10D01D0;
  uint64_t v2 = *((void *)this + 55);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 64);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 56);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *((void *)this + 57);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  uint64_t v6 = *((void *)this + 58);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  uint64_t v7 = *((void *)this + 59);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  uint64_t v8 = *((void *)this + 60);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
  uint64_t v9 = *((void *)this + 61);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  uint64_t v10 = *((void *)this + 62);
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  }
  uint64_t v11 = *((void *)this + 63);
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  }

  HGNode::~HGNode(this);
}

void HGMultiTexBlend<8>::~HGMultiTexBlend(HGNode *a1)
{
  HGMultiTexBlend<8>::~HGMultiTexBlend(a1);

  HGObject::operator delete(v1);
}

uint64_t HGMultiTexBlend<8>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a1 + 8 * a2;
  uint64_t result = *(void *)(v3 + 448);
  if (result)
  {
    uint64_t v5 = v3 + 448;
    (*(void (**)(uint64_t, uint64_t))(*(void *)result + 576))(result, a3);
    uint64_t v6 = *(uint64_t (**)(void))(**(void **)v5 + 160);
    return v6();
  }
  return result;
}

uint64_t HGMultiTexBlend<8>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<8>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  (*(void (**)(void, void, float, float, float, float))(**(void **)(a1 + 512) + 96))(*(void *)(a1 + 512), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(void, uint64_t, float, float, float, float))(**(void **)(a1 + 512) + 96))(*(void *)(a1 + 512), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  uint64_t v4 = *(void *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v4 + 120))(v4, 0, Input);
  return *(void *)(a1 + 512);
}

void HGGradientRadial::HGGradientRadial(HGGradientRadial *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v2 = &unk_1F10D04F0;
  *(void *)(v2 + 416) = 0;
  HGNode::SetFlags((HGNode *)v2, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
  *((_DWORD *)this + 102) = 3;
}

void sub_1B774337C(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 416);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGGradientRadial::~HGGradientRadial(HGNode *this)
{
  *(void *)this = &unk_1F10D04F0;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D04F0;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGGradientRadial::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  Input = HGRenderer::GetInput(a2, this, 0);
  if (!(*(unsigned int (**)(HGRenderer *))(*(void *)a2 + 304))(a2)
    || (uint64_t DOD = HGRenderer::GetDOD(a2, Input), (HIDWORD(v6) - HIDWORD(DOD)) > 1))
  {
    (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 3, &v39);
    (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 4, &v36);
    (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 5, &v33);
    BOOL v10 = *(float *)&v39.var0 == 1.0;
    if (*(float *)&v39.var1 != 0.0) {
      BOOL v10 = 0;
    }
    v9.n128_f32[0] = v33;
    v8.n128_f32[0] = v34;
    v7.n128_f32[0] = v35;
    if (v10
      && *(float *)&v39.var3 == 0.0
      && v36 == 0.0
      && v37 == 1.0
      && v38 == 0.0
      && v33 == 0.0
      && v34 == 0.0
      && v35 == 1.0)
    {
      int v11 = 0;
      goto LABEL_33;
    }
    if (v36 != 0.0) {
      BOOL v10 = 0;
    }
    if (v10 && v37 == 1.0)
    {
      if (v33 != 0.0)
      {
LABEL_32:
        int v11 = 3;
LABEL_33:
        *((_DWORD *)this + 102) = v11;
        (*(void (**)(HGNode *, uint64_t, float *, __n128, __n128, __n128))(*(void *)this + 104))(this, 2, v32, v7, v8, v9);
        _OWORD v32[3] = 1.0 / v32[0];
        (*(void (**)(HGNode *, uint64_t))(*(void *)this + 96))(this, 2);
        switch(*((_DWORD *)this + 102))
        {
          case 0:
            size_t v21 = (HgcGradientRadialIdentity *)HGObject::operator new(0x1A0uLL);
            HgcGradientRadialIdentity::HgcGradientRadialIdentity(v21);
          case 1:
            uint64_t v22 = (HgcGradientRadialTranslate *)HGObject::operator new(0x1A0uLL);
            HgcGradientRadialTranslate::HgcGradientRadialTranslate(v22);
          case 2:
            uint64_t v23 = (HgcGradientRadialAffine *)HGObject::operator new(0x1A0uLL);
            HgcGradientRadialAffine::HgcGradientRadialAffine(v23);
          case 3:
            unint64_t v24 = (HgcGradientRadialPerspective *)HGObject::operator new(0x1A0uLL);
            HgcGradientRadialPerspective::HgcGradientRadialPerspective(v24);
          default:
            (*(void (**)(void, void, HGNode *))(**((void **)this + 52) + 120))(*((void *)this + 52), 0, Input);
            (*(void (**)(HGNode *, void, float *))(*(void *)this + 104))(this, 0, &v28);
            int v25 = (void *)((char *)this + 416);
            (*(void (**)(void, void, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 0, v28, v29, v30, v31);
            (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 1, &v28);
            (*(void (**)(void, uint64_t, float, float, float, float))(*(void *)*v25 + 96))(*v25, 1, v28, v29, v30, v31);
            (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 2, &v28);
            (*(void (**)(void, uint64_t, float, float, float, float))(*(void *)*v25 + 96))(*v25, 2, v28, v29, v30, v31);
            (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 3, &v28);
            (*(void (**)(void, uint64_t, float, float, float, float))(*(void *)*v25 + 96))(*v25, 3, v28, v29, v30, v31);
            (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 4, &v28);
            (*(void (**)(void, uint64_t, float, float, float, float))(*(void *)*v25 + 96))(*v25, 4, v28, v29, v30, v31);
            (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 5, &v28);
            (*(void (**)(void, uint64_t, float, float, float, float))(*(void *)*v25 + 96))(*v25, 5, v28, v29, v30, v31);
            (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 6, &v28);
            (*(void (**)(void, uint64_t, float, float, float, float))(*(void *)*v25 + 96))(*v25, 6, v28, v29, v30, v31);
            uint64_t v26 = *((void *)this + 52);
            break;
        }
        return v26;
      }
      if (v34 == 0.0 && v35 == 1.0)
      {
        int v11 = 1;
        goto LABEL_33;
      }
    }
    if (v33 == 0.0 && v34 == 0.0)
    {
      v8.n128_u32[0] = 1.0;
      if (v35 == 1.0)
      {
        int v11 = 2;
        goto LABEL_33;
      }
    }
    goto LABEL_32;
  }
  uint64_t v13 = DOD;
  uint64_t v14 = v6;
  int v15 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v15);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v15, (const char *)3, v16);
  uint64_t v17 = HGRectMake4i(0, 0, 0, 1u);
  *(void *)&v39.int var0 = HGRectGrow(v13, v14, v17);
  *(void *)&v39.unsigned int var2 = v18;
  HGTextureWrap::SetCropRect(v15, &v39);
  (*(void (**)(HGTextureWrap *, void, HGNode *))(*(void *)v15 + 120))(v15, 0, Input);
  int v19 = (HGNode *)HGObject::operator new(0x1B0uLL);
  HGNode::HGNode(v19);
  *(void *)int v19 = &unk_1F10D04F0;
  *((void *)v19 + 52) = 0;
  HGNode::SetFlags(v19, 0, 5);
  *((_DWORD *)v19 + 4) |= 0x601u;
  *((_DWORD *)v19 + 102) = 3;
  int v20 = (HGNode *)*((void *)this + 52);
  if (v20 == v19)
  {
    (*(void (**)(HGNode *))(*(void *)v19 + 24))(v19);
    int v19 = (HGNode *)*((void *)this + 52);
  }
  else
  {
    if (v20) {
      (*(void (**)(HGNode *))(*(void *)v20 + 24))(v20);
    }
    *((void *)this + 52) = v19;
  }
  (*(void (**)(HGNode *, void, HGTextureWrap *))(*(void *)v19 + 120))(v19, 0, v15);
  (*(void (**)(HGNode *, void, HGRect *))(*(void *)this + 104))(this, 0, &v39);
  (*(void (**)(void, void, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 0, *(float *)&v39.var0, *(float *)&v39.var1, *(float *)&v39.var2, *(float *)&v39.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 1, &v39);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 1, *(float *)&v39.var0, *(float *)&v39.var1, *(float *)&v39.var2, *(float *)&v39.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 2, &v39);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 2, *(float *)&v39.var0, *(float *)&v39.var1, *(float *)&v39.var2, *(float *)&v39.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 3, &v39);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 3, *(float *)&v39.var0, *(float *)&v39.var1, *(float *)&v39.var2, *(float *)&v39.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 4, &v39);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 4, *(float *)&v39.var0, *(float *)&v39.var1, *(float *)&v39.var2, *(float *)&v39.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 5, &v39);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 5, *(float *)&v39.var0, *(float *)&v39.var1, *(float *)&v39.var2, *(float *)&v39.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 6, &v39);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 6, *(float *)&v39.var0, *(float *)&v39.var1, *(float *)&v39.var2, *(float *)&v39.var3);
  uint64_t v26 = *((void *)this + 52);
  (*(void (**)(HGTextureWrap *))(*(void *)v15 + 24))(v15);
  return v26;
}

void sub_1B7744124(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *HGGradientRadial::label_B(HGGradientRadial *this)
{
  uint64_t v1 = *((int *)this + 102);
  if (v1 > 2) {
    return "kXFormPerspective";
  }
  else {
    return off_1E616C388[v1];
  }
}

void HGGradientRadial::info(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t HGColorConformLook3DLUT::HGColorConformLook3DLUT(uint64_t a1, int a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  HGObject::HGObject((HGObject *)a1);
  *uint64_t v4 = &unk_1F10DDC48;
  v4[8] = 0;
  v4[2] = 0;
  v4[9] = 0;
  v4[10] = 0;
  v4[4] = 33;
  int v5 = 0;
  uint64_t v6 = @"CinemaGamut_CanonLog2-to-BT.709_WideDR_33_Ver1.0";
  switch(a2)
  {
    case 0:
      int v5 = 0;
      *(void *)(a1 + 32) = 65;
      uint64_t v6 = @"ARRI_LogC4-to-Gamma24_Rec709-D65_v1-65";
      goto LABEL_15;
    case 1:
      *(void *)(a1 + 32) = 65;
      uint64_t v6 = @"ARRI_LogC4-to-Gamma24_Rec2020-D65_v1-65";
      int v5 = 3;
      goto LABEL_15;
    case 2:
      goto LABEL_15;
    case 3:
      uint64_t v6 = @"CinemaGamut_CanonLog2-to-BT.2020_WideDR_33_Ver1.0";
      int v5 = 3;
      goto LABEL_15;
    case 4:
      int v5 = 0;
      uint64_t v6 = @"CinemaGamut_CanonLog3-to-BT.709_WideDR_33_Ver1.0";
      goto LABEL_15;
    case 5:
      uint64_t v6 = @"CinemaGamut_CanonLog3-to-BT.2020_WideDR_33_Ver1.0";
      int v5 = 3;
      goto LABEL_15;
    case 6:
      int v5 = 0;
      uint64_t v6 = @"VLog_to_V709_forV35_ver100";
      goto LABEL_15;
    case 7:
      uint64_t v6 = @"VLog_to_V2020_forV35_20160707";
      int v5 = 3;
      goto LABEL_15;
    case 8:
      int v5 = 0;
      uint64_t v6 = @"Z_6_N-Log-Full_to_REC709_Full_33_V01-00";
      goto LABEL_15;
    case 9:
      int v5 = 0;
      *(void *)(a1 + 32) = 65;
      uint64_t v6 = @"AppleLogToRec709_v1.0";
      goto LABEL_15;
    case 10:
      int v5 = 0;
      uint64_t v6 = @"DJI_Mavic_3_D-Log_to_Rec.709_V1";
      goto LABEL_15;
    case 11:
      int v5 = 0;
      uint64_t v6 = @"XH2S_FLog_FGamut_to_WDR_BT.709_33grid_V.1.00";
      goto LABEL_15;
    case 12:
      int v5 = 0;
      uint64_t v6 = @"XH2S_FLog2_FGamut_to_WDR_BT.709_33grid_V.1.00";
LABEL_15:
      *(_DWORD *)(a1 + 108) = v5;
      *(_DWORD *)(a1 + 112) = 1;
      break;
    default:
      uint64_t v6 = 0;
      break;
  }
  __n128 v7 = (void *)[MEMORY[0x1E4F28B50] bundleWithIdentifier:@"com.apple.Helium"];
  if (v7
    && (__n128 v8 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9B8]), "initWithContentsOfFile:", objc_msgSend(v7, "pathForResource:ofType:", v6, @"3dlut")), (v9 = v8) != 0))
  {
    CC_SHA1((const void *)[v8 bytes], objc_msgSend(v8, "length"), md);
    HGColorConformLook3DLUT::SetChecksum((HGColorConformLook3DLUT *)a1, md, 20);
    HGColorConformLook3DLUT::SetBuffer((HGColorConformLook3DLUT *)a1, v9);
    *(void *)(a1 + 24) = 1065353216;
    uint64_t v10 = *(void *)(a1 + 32);
    *(void *)(a1 + 40) = 6 * v10;
    *(void *)(a1 + 48) = 6 * v10 * v10;
    *(unsigned char *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 60) = 1;
    *(_OWORD *)(a1 + 88) = xmmword_1B7E73E70;
    *(unsigned char *)(a1 + 104) = 0;
  }
  else
  {
    HGColorConformLook3DLUT::Clear((HGColorConformLook3DLUT *)a1);
  }
  return a1;
}

void sub_1B7744644(_Unwind_Exception *a1)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *((void *)v1 + 9) = v4;
    operator delete(v4);
  }
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGTransform::HGTransform(HGTransform *this)
{
  HGObject::HGObject(this);
  *(void *)uint64_t v1 = &unk_1F10D0758;
  *(_OWORD *)(v1 + 56) = 0u;
  *(_OWORD *)(v1 + 88) = 0u;
  *(_OWORD *)(v1 + 24) = 0u;
  *(_OWORD *)(v1 + 40) = 0u;
  *(_OWORD *)(v1 + 72) = 0u;
  *(_OWORD *)(v1 + 104) = 0u;
  *(_OWORD *)(v1 + 120) = 0u;
  *(void *)(v1 + 16) = 0x3FF0000000000000;
  *(void *)(v1 + 56) = 0x3FF0000000000000;
  *(void *)(v1 + 96) = 0x3FF0000000000000;
  *(void *)(v1 + 136) = 0x3FF0000000000000;
}

void HGTransform::~HGTransform(HGTransform *this)
{
  HGObject::~HGObject(this);

  HGObject::operator delete(v1);
}

float64x2_t HGTransform::GetMatrixf(float64x2_t *this, float32x4_t *a2)
{
  float32x4_t v2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[3]), this[4]);
  *a2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[1]), this[2]);
  a2[1] = v2;
  float64x2_t result = this[8];
  float32x4_t v4 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[7]), result);
  a2[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[5]), this[6]);
  a2[3] = v4;
  return result;
}

double HGTransform::GetMatrixd(HGTransform *this, double *a2)
{
  *a2 = *((double *)this + 2);
  a2[1] = *((double *)this + 3);
  a2[2] = *((double *)this + 4);
  a2[3] = *((double *)this + 5);
  a2[4] = *((double *)this + 6);
  a2[5] = *((double *)this + 7);
  a2[6] = *((double *)this + 8);
  a2[7] = *((double *)this + 9);
  a2[8] = *((double *)this + 10);
  a2[9] = *((double *)this + 11);
  a2[10] = *((double *)this + 12);
  a2[11] = *((double *)this + 13);
  a2[12] = *((double *)this + 14);
  a2[13] = *((double *)this + 15);
  a2[14] = *((double *)this + 16);
  double result = *((double *)this + 17);
  a2[15] = result;
  return result;
}

float64x2_t HGTransform::GetMatrixfloat4x4(float64x2_t *this, simd::float4x4 *a2)
{
  float32x4_t v2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[3]), this[4]);
  float32x4_t v3 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[5]), this[6]);
  float64x2_t result = this[8];
  float32x4_t v5 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[7]), result);
  a2->columns[0] = (simd_float4)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(this[1]), this[2]);
  a2->columns[1] = (simd_float4)v2;
  a2->columns[2] = (simd_float4)v3;
  a2->columns[3] = (simd_float4)v5;
  return result;
}

uint64_t HGTransform::GetMatrixPtr(HGTransform *this)
{
  return (uint64_t)this + 16;
}

double HGTransform::LoadIdentity(HGTransform *this)
{
  double result = 0.0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 2) = 0x3FF0000000000000;
  *((void *)this + 7) = 0x3FF0000000000000;
  *((void *)this + 12) = 0x3FF0000000000000;
  *((void *)this + 17) = 0x3FF0000000000000;
  return result;
}

float64x2_t HGTransform::LoadColumnf(HGTransform *this, float32x2_t *a2, int a3)
{
  float32x4_t v3 = (float64x2_t *)((char *)this + 32 * a3);
  float64x2_t result = vcvtq_f64_f32(*a2);
  float64x2_t v5 = vcvtq_f64_f32(a2[1]);
  v3[1] = result;
  v3[2] = v5;
  return result;
}

float64x2_t HGTransform::LoadMatrixf(float64x2_t *this, float32x2_t *a2)
{
  float64x2_t v2 = vcvtq_f64_f32(a2[1]);
  this[1] = vcvtq_f64_f32(*a2);
  this[2] = v2;
  float64x2_t v3 = vcvtq_f64_f32(a2[3]);
  this[3] = vcvtq_f64_f32(a2[2]);
  this[4] = v3;
  float64x2_t v4 = vcvtq_f64_f32(a2[5]);
  this[5] = vcvtq_f64_f32(a2[4]);
  this[6] = v4;
  float64x2_t result = vcvtq_f64_f32(a2[6]);
  float64x2_t v6 = vcvtq_f64_f32(a2[7]);
  this[7] = result;
  this[8] = v6;
  return result;
}

double HGTransform::LoadMatrixd(HGTransform *this, double *a2)
{
  *((double *)this + 2) = *a2;
  *((double *)this + 3) = a2[1];
  *((double *)this + 4) = a2[2];
  *((double *)this + 5) = a2[3];
  *((double *)this + 6) = a2[4];
  *((double *)this + 7) = a2[5];
  *((double *)this + 8) = a2[6];
  *((double *)this + 9) = a2[7];
  *((double *)this + 10) = a2[8];
  *((double *)this + 11) = a2[9];
  *((double *)this + 12) = a2[10];
  *((double *)this + 13) = a2[11];
  *((double *)this + 14) = a2[12];
  *((double *)this + 15) = a2[13];
  *((double *)this + 16) = a2[14];
  double result = a2[15];
  *((double *)this + 17) = result;
  return result;
}

uint64_t HGTransform::LoadMatrixfloat4x4(HGTransform *this, const simd::float4x4 *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  simd_float4 v2 = a2->columns[1];
  v5[0] = a2->columns[0];
  v5[1] = v2;
  simd_float4 v3 = a2->columns[3];
  v5[2] = a2->columns[2];
  v5[3] = v3;
  return (*(uint64_t (**)(HGTransform *, _OWORD *))(*(void *)this + 64))(this, v5);
}

uint64_t HGTransform::LoadMatrixdouble4x4(HGTransform *this, const simd::double4x4 *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  long long v2 = *(_OWORD *)&a2->columns[0].f64[2];
  v7[0] = *(_OWORD *)a2->columns[0].f64;
  v7[1] = v2;
  long long v3 = *(_OWORD *)&a2->columns[1].f64[2];
  v7[2] = *(_OWORD *)a2->columns[1].f64;
  v7[3] = v3;
  long long v4 = *(_OWORD *)&a2->columns[2].f64[2];
  v7[4] = *(_OWORD *)a2->columns[2].f64;
  v7[5] = v4;
  long long v5 = *(_OWORD *)&a2->columns[3].f64[2];
  v7[6] = *(_OWORD *)a2->columns[3].f64;
  v7[7] = v5;
  return (*(uint64_t (**)(HGTransform *, _OWORD *))(*(void *)this + 72))(this, v7);
}

__n128 HGTransform::LoadTransform(HGTransform *this, const HGTransform *a2)
{
  long long v2 = *((_OWORD *)a2 + 1);
  long long v3 = *((_OWORD *)a2 + 2);
  long long v4 = *((_OWORD *)a2 + 4);
  *((_OWORD *)this + 3) = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + 4) = v4;
  *((_OWORD *)this + 1) = v2;
  *((_OWORD *)this + 2) = v3;
  __n128 result = *((__n128 *)a2 + 5);
  long long v6 = *((_OWORD *)a2 + 6);
  long long v7 = *((_OWORD *)a2 + 8);
  *((_OWORD *)this + 7) = *((_OWORD *)a2 + 7);
  *((_OWORD *)this + 8) = v7;
  *((__n128 *)this + 5) = result;
  *((_OWORD *)this + 6) = v6;
  return result;
}

double HGTransform::LoadOrtho(HGTransform *this, float a2, float a3, float a4, float a5, float a6, float a7)
{
  (*(void (**)(HGTransform *))(*(void *)this + 56))(this);
  *((double *)this + 2) = 2.0 / (float)(a3 - a2);
  *((double *)this + 7) = 2.0 / (float)(a5 - a4);
  *((double *)this + 12) = -2.0 / (float)(a7 - a6);
  *((double *)this + 14) = (float)((float)-(float)(a2 + a3) / (float)(a3 - a2));
  *((double *)this + 15) = (float)((float)-(float)(a4 + a5) / (float)(a5 - a4));
  double result = (float)((float)-(float)(a6 + a7) / (float)(a7 - a6));
  *((double *)this + 16) = result;
  return result;
}

double HGTransform::LoadFrustum(HGTransform *this, float a2, float a3, float a4, float a5, float a6, float a7)
{
  (*(void (**)(HGTransform *))(*(void *)this + 56))(this);
  *((double *)this + 2) = (float)((float)(a6 + a6) / (float)(a3 - a2));
  *((double *)this + 7) = (float)((float)(a6 + a6) / (float)(a5 - a4));
  *((double *)this + 10) = (float)((float)(a2 + a3) / (float)(a3 - a2));
  *((double *)this + 11) = (float)((float)(a4 + a5) / (float)(a5 - a4));
  *((void *)this + 15) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((double *)this + 12) = (float)((float)-(float)(a6 + a7) / (float)(a7 - a6));
  *((double *)this + 16) = (float)((float)((float)(a7 * -2.0) * a6) / (float)(a7 - a6));
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_OWORD *)this + 4) = 0u;
  double result = -1.0;
  *(_OWORD *)((char *)this + 104) = xmmword_1B7E7C890;
  *((void *)this + 17) = 0;
  return result;
}

void HGTransform::Translate(HGTransform *this, double a2, double a3, double a4)
{
  HGObject::HGObject((HGObject *)v8);
  uint64_t v13 = 0;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v12 = 0u;
  v8[0] = &unk_1F10D0758;
  void v8[2] = 0x3FF0000000000000;
  long long v11 = 0x3FF0000000000000uLL;
  uint64_t v14 = 0x3FF0000000000000;
  uint64_t v15 = 0;
  uint64_t v19 = 0x3FF0000000000000;
  double v16 = a2;
  double v17 = a3;
  double v18 = a4;
  (*(void (**)(HGTransform *, void *))(*(void *)this + 192))(this, v8);
  HGObject::~HGObject((HGObject *)v8);
}

void sub_1B7744D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGTransform::Rotate(HGTransform *this, double a2, double a3, double a4, double a5)
{
  double v9 = a2 * 0.0174532925;
  float v10 = sin(a2 * 0.0174532925);
  if (v10 != 0.0)
  {
    double v11 = a3 * a3;
    double v12 = a4 * a4;
    double v13 = a5 * a5;
    double v14 = a3 * a3 + a4 * a4 + a5 * a5;
    if (v14 != 1.0)
    {
      if (v14 == 0.0) {
        return;
      }
      double v15 = sqrt(v14);
      a3 = a3 / v15;
      a4 = a4 / v15;
      a5 = a5 / v15;
      double v11 = v11 / v14;
      double v12 = v12 / v14;
      double v13 = v13 / v14;
    }
    double v16 = v10;
    float v17 = cos(v9);
    double v18 = v17;
    HGObject::HGObject((HGObject *)v22);
    v22[0] = &unk_1F10D0758;
    v22[5] = 0;
    v22[9] = 0;
    long long v23 = 0u;
    long long v24 = 0u;
    uint64_t v25 = 0x3FF0000000000000;
    double v19 = (1.0 - v18) * (a4 * a3);
    *(double *)&v22[2] = (1.0 - v18) * v11 + v18;
    *(double *)&v22[3] = v19 - a5 * v16;
    double v20 = (1.0 - v18) * (a5 * a3);
    *(double *)&v22[4] = a4 * v16 + v20;
    double v21 = (1.0 - v18) * (a5 * a4);
    *(double *)&v22[6] = a5 * v16 + v19;
    *(double *)&v22[7] = (1.0 - v18) * v12 + v18;
    *(double *)&v22[8] = v21 - a3 * v16;
    *(double *)&v22[10] = v20 - a4 * v16;
    *(double *)&v22[11] = v21 + a3 * v16;
    *(double *)&v22[12] = (1.0 - v18) * v13 + v18;
    (*(void (**)(HGTransform *, void *))(*(void *)this + 192))(this, v22);
    HGObject::~HGObject((HGObject *)v22);
  }
}

void sub_1B7744F28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGTransform::Shear(HGTransform *this, double a2, double a3, double a4, double a5)
{
  __double2 v9 = __sincos_stret(a2 * 0.0174532925);
  float sinval = v9.__sinval;
  if (sinval != 0.0)
  {
    float cosval = v9.__cosval;
    if (cosval != 0.0)
    {
      double v12 = a3 * a3;
      double v13 = a3 * a3 + a4 * a4 + a5 * a5;
      if (v13 != 1.0)
      {
        if (v13 == 0.0) {
          return;
        }
        a3 = a3 / sqrt(v13);
        double v12 = v12 / v13;
      }
      double v14 = sinval;
      HGObject::HGObject((HGObject *)v17);
      BOOL v15 = a3 < 0.0 && v12 == 1.0;
      uint64_t v22 = 0;
      long long v19 = 0u;
      long long v18 = 0u;
      long long v21 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      v17[0] = &unk_1F10D0758;
      unsigned int v17[2] = 0x3FF0000000000000;
      long long v20 = 0x3FF0000000000000uLL;
      uint64_t v23 = 0x3FF0000000000000;
      uint64_t v26 = 0x3FF0000000000000;
      double v16 = -v14;
      if (v15) {
        double v16 = v14;
      }
      *((double *)&v19 + 1) = v16 / *(float *)&v9.__cosval;
      (*(void (**)(HGTransform *, void *))(*(void *)this + 192))(this, v17);
      HGObject::~HGObject((HGObject *)v17);
    }
  }
}

void sub_1B7745094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGTransform::Scale(HGTransform *this, double a2, double a3, double a4)
{
  HGObject::HGObject((HGObject *)v8);
  v8[0] = &unk_1F10D0758;
  uint64_t v13 = 0;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v12 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v17 = 0x3FF0000000000000;
  *(double *)&void v8[2] = a2;
  long long v11 = *(unint64_t *)&a3;
  double v14 = a4;
  (*(void (**)(HGTransform *, void *))(*(void *)this + 192))(this, v8);
  HGObject::~HGObject((HGObject *)v8);
}

void sub_1B774517C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGTransform::Perspective(HGTransform *this, double a2, double a3)
{
  HGObject::HGObject((HGObject *)v8);
  uint64_t v13 = 0;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v12 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  v8[0] = &unk_1F10D0758;
  void v8[2] = 0x3FF0000000000000;
  long long v11 = 0x3FF0000000000000uLL;
  double v14 = 1.0;
  uint64_t v17 = 0x3FF0000000000000;
  float v6 = tan(a2 * 0.00872664626);
  double v7 = v6 + v6;
  if (v7 != 0.0)
  {
    double v14 = a3 / v7 + 1.0;
    *(double *)&long long v15 = -v7 / a3;
    *((double *)&v16 + 1) = -v14;
    (*(void (**)(HGTransform *, void *))(*(void *)this + 192))(this, v8);
  }
  HGObject::~HGObject((HGObject *)v8);
}

void sub_1B774529C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

float64x2_t HGTransform::Multiply(float64x2_t *this, float64x2_t *a2)
{
  if (a2)
  {
    double v2 = this[1].f64[0];
    double v3 = this[1].f64[1];
    double v4 = this[2].f64[0];
    double v5 = this[2].f64[1];
    float64x2_t v6 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[1], v2), vmulq_n_f64(a2[3], v3)), vmulq_n_f64(a2[5], v4)), vmulq_n_f64(a2[7], v5));
    float64x2_t v7 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[2], v2), vmulq_n_f64(a2[4], v3)), vmulq_n_f64(a2[6], v4)), vmulq_n_f64(a2[8], v5));
    this[1] = v6;
    this[2] = v7;
    v7.f64[0] = this[3].f64[0];
    double v8 = this[3].f64[1];
    double v9 = this[4].f64[0];
    double v10 = this[4].f64[1];
    float64x2_t v11 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[1], v7.f64[0]), vmulq_n_f64(a2[3], v8)), vmulq_n_f64(a2[5], v9)), vmulq_n_f64(a2[7], v10));
    float64x2_t v12 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[2], v7.f64[0]), vmulq_n_f64(a2[4], v8)), vmulq_n_f64(a2[6], v9)), vmulq_n_f64(a2[8], v10));
    this[3] = v11;
    this[4] = v12;
    v12.f64[0] = this[5].f64[0];
    double v13 = this[5].f64[1];
    double v14 = this[6].f64[0];
    double v15 = this[6].f64[1];
    float64x2_t v16 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[1], v12.f64[0]), vmulq_n_f64(a2[3], v13)), vmulq_n_f64(a2[5], v14)), vmulq_n_f64(a2[7], v15));
    float64x2_t v17 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[2], v12.f64[0]), vmulq_n_f64(a2[4], v13)), vmulq_n_f64(a2[6], v14)), vmulq_n_f64(a2[8], v15));
    this[5] = v16;
    this[6] = v17;
    v17.f64[0] = this[7].f64[0];
    double v18 = this[7].f64[1];
    double v19 = this[8].f64[0];
    double v20 = this[8].f64[1];
    float64x2_t v21 = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[1], v17.f64[0]), vmulq_n_f64(a2[3], v18)), vmulq_n_f64(a2[5], v19)), vmulq_n_f64(a2[7], v20));
    float64x2_t result = vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(a2[2], v17.f64[0]), vmulq_n_f64(a2[4], v18)), vmulq_n_f64(a2[6], v19)), vmulq_n_f64(a2[8], v20));
    this[7] = v21;
    this[8] = result;
  }
  return result;
}

double HGTransform::PreMultiply(HGTransform *this, const HGTransform *a2)
{
  if (a2)
  {
    double v2 = *((double *)this + 2);
    double v3 = *((double *)this + 3);
    double v4 = *((double *)this + 6);
    double v5 = *((double *)this + 7);
    double v6 = *((double *)this + 10);
    double v7 = *((double *)this + 11);
    double v8 = *((double *)this + 14);
    double v9 = *((double *)this + 15);
    double v10 = v2 * *((double *)a2 + 2) + v4 * *((double *)a2 + 3) + v6 * *((double *)a2 + 4) + v8 * *((double *)a2 + 5);
    double v11 = v2 * *((double *)a2 + 6) + v4 * *((double *)a2 + 7) + v6 * *((double *)a2 + 8) + v8 * *((double *)a2 + 9);
    double v12 = v2 * *((double *)a2 + 10) + v4 * *((double *)a2 + 11) + v6 * *((double *)a2 + 12) + v8 * *((double *)a2 + 13);
    double v13 = v2 * *((double *)a2 + 14) + v4 * *((double *)a2 + 15) + v6 * *((double *)a2 + 16) + v8 * *((double *)a2 + 17);
    *((double *)this + 2) = v10;
    *((double *)this + 6) = v11;
    *((double *)this + 10) = v12;
    *((double *)this + 14) = v13;
    double v14 = v3 * *((double *)a2 + 2) + v5 * *((double *)a2 + 3) + v7 * *((double *)a2 + 4) + v9 * *((double *)a2 + 5);
    double v15 = v3 * *((double *)a2 + 6) + v5 * *((double *)a2 + 7) + v7 * *((double *)a2 + 8) + v9 * *((double *)a2 + 9);
    double v16 = v3 * *((double *)a2 + 10) + v5 * *((double *)a2 + 11) + v7 * *((double *)a2 + 12) + v9 * *((double *)a2 + 13);
    double v17 = v3 * *((double *)a2 + 14) + v5 * *((double *)a2 + 15) + v7 * *((double *)a2 + 16) + v9 * *((double *)a2 + 17);
    *((double *)this + 3) = v14;
    *((double *)this + 7) = v15;
    *((double *)this + 11) = v16;
    *((double *)this + 15) = v17;
    double v18 = *((double *)this + 4);
    double v19 = *((double *)this + 5);
    double v20 = *((double *)this + 8);
    double v21 = *((double *)this + 9);
    double v22 = *((double *)this + 12);
    double v23 = *((double *)this + 13);
    double v24 = *((double *)this + 16);
    double v25 = *((double *)this + 17);
    double v26 = v18 * *((double *)a2 + 2) + v20 * *((double *)a2 + 3) + v22 * *((double *)a2 + 4) + v24 * *((double *)a2 + 5);
    double v27 = v18 * *((double *)a2 + 6) + v20 * *((double *)a2 + 7) + v22 * *((double *)a2 + 8) + v24 * *((double *)a2 + 9);
    double v28 = v18 * *((double *)a2 + 10)
        + v20 * *((double *)a2 + 11)
        + v22 * *((double *)a2 + 12)
        + v24 * *((double *)a2 + 13);
    double v29 = v18 * *((double *)a2 + 14)
        + v20 * *((double *)a2 + 15)
        + v22 * *((double *)a2 + 16)
        + v24 * *((double *)a2 + 17);
    *((double *)this + 4) = v26;
    *((double *)this + 8) = v27;
    *((double *)this + 12) = v28;
    *((double *)this + 16) = v29;
    double result = v19 * *((double *)a2 + 2)
           + v21 * *((double *)a2 + 3)
           + v23 * *((double *)a2 + 4)
           + v25 * *((double *)a2 + 5);
    double v31 = v19 * *((double *)a2 + 6) + v21 * *((double *)a2 + 7) + v23 * *((double *)a2 + 8) + v25 * *((double *)a2 + 9);
    double v32 = v19 * *((double *)a2 + 10)
        + v21 * *((double *)a2 + 11)
        + v23 * *((double *)a2 + 12)
        + v25 * *((double *)a2 + 13);
    double v33 = v19 * *((double *)a2 + 14)
        + v21 * *((double *)a2 + 15)
        + v23 * *((double *)a2 + 16)
        + v25 * *((double *)a2 + 17);
    *((double *)this + 5) = result;
    *((double *)this + 9) = v31;
    *((double *)this + 13) = v32;
    *((double *)this + 17) = v33;
  }
  return result;
}

float64x2_t *HGTransform::Transform(float64x2_t *this, float32x4_t *a2, const float *a3, int a4)
{
  if (a4 >= 1)
  {
    float64x2_t v5 = this[1];
    float64x2_t v4 = this[2];
    float64x2_t v7 = this[3];
    float64x2_t v6 = this[4];
    float64x2_t v9 = this[5];
    float64x2_t v8 = this[6];
    float64x2_t v11 = this[7];
    float64x2_t v10 = this[8];
    if (a4 < 4
      || ((uint64_t v12 = 16 * (a4 - 1) + 16, (char *)a3 + v12 > (char *)a2)
        ? (BOOL v13 = (char *)a2 + v12 > (char *)a3)
        : (BOOL v13 = 0),
          v13))
    {
      LODWORD(v14) = 0;
      double v15 = a2;
      double v16 = a3;
    }
    else
    {
      uint64_t v14 = a4 & 0xFFFFFFFC;
      double v15 = &a2[v14];
      double v16 = &a3[4 * v14];
      uint64_t v17 = v14;
      do
      {
        float32x4x4_t v27 = vld4q_f32(a3);
        a3 += 16;
        float64x2_t v18 = vcvt_hight_f64_f32(v27.val[0]);
        float64x2_t v19 = vcvtq_f64_f32(*(float32x2_t *)v27.val[0].f32);
        float64x2_t v20 = vcvt_hight_f64_f32(v27.val[1]);
        float64x2_t v21 = vcvtq_f64_f32(*(float32x2_t *)v27.val[1].f32);
        float64x2_t v22 = vcvtq_f64_f32(*(float32x2_t *)v27.val[2].f32);
        float64x2_t v23 = vcvt_hight_f64_f32(v27.val[2]);
        float64x2_t v24 = vcvt_hight_f64_f32(v27.val[3]);
        v27.val[0] = (float32x4_t)vcvtq_f64_f32(*(float32x2_t *)v27.val[3].f32);
        v26.val[0] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v19, v5.f64[0]), vmulq_n_f64(v21, v7.f64[0])), vmulq_n_f64(v22, v9.f64[0])), vmulq_n_f64((float64x2_t)v27.val[0], v11.f64[0]))), vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v18, v5.f64[0]), vmulq_n_f64(v20, v7.f64[0])), vmulq_n_f64(v23, v9.f64[0])), vmulq_n_f64(v24, v11.f64[0])));
        v26.val[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vaddq_f64(vaddq_f64(vmulq_laneq_f64(v19, v5, 1), vmulq_laneq_f64(v21, v7, 1)), vmulq_laneq_f64(v22, v9, 1)), vmulq_laneq_f64((float64x2_t)v27.val[0], v11, 1))), vaddq_f64(vaddq_f64(vaddq_f64(vmulq_laneq_f64(v18, v5, 1), vmulq_laneq_f64(v20, v7, 1)), vmulq_laneq_f64(v23, v9, 1)), vmulq_laneq_f64(v24, v11, 1)));
        v26.val[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v19, v4.f64[0]), vmulq_n_f64(v21, v6.f64[0])), vmulq_n_f64(v22, v8.f64[0])), vmulq_n_f64((float64x2_t)v27.val[0], v10.f64[0]))), vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v18, v4.f64[0]), vmulq_n_f64(v20, v6.f64[0])), vmulq_n_f64(v23, v8.f64[0])), vmulq_n_f64(v24, v10.f64[0])));
        v26.val[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vaddq_f64(vaddq_f64(vmulq_laneq_f64(v19, v4, 1), vmulq_laneq_f64(v21, v6, 1)), vmulq_laneq_f64(v22, v8, 1)), vmulq_laneq_f64((float64x2_t)v27.val[0], v10, 1))), vaddq_f64(vaddq_f64(vaddq_f64(vmulq_laneq_f64(v18, v4, 1), vmulq_laneq_f64(v20, v6, 1)), vmulq_laneq_f64(v23, v8, 1)), vmulq_laneq_f64(v24, v10, 1)));
        vst4q_f32(a2->f32, v26);
        a2 += 4;
        v17 -= 4;
      }
      while (v17);
      if (v14 == a4) {
        return this;
      }
    }
    int v25 = a4 - v14;
    do
    {
      *v15++ = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v5, *v16), vmulq_n_f64(v7, v16[1])), vmulq_n_f64(v9, v16[2])), vmulq_n_f64(v11, v16[3]))), vaddq_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v4, *v16), vmulq_n_f64(v6, v16[1])), vmulq_n_f64(v8, v16[2])), vmulq_n_f64(v10, v16[3])));
      v16 += 4;
      --v25;
    }
    while (v25);
  }
  return this;
}

float32x2_t HGTransform::Project(float64x2_t *this, float32x2_t *a2, int a3, int a4)
{
  float32x2_t result = vcvt_f32_f64(vdivq_f64(vaddq_f64(this[7], vaddq_f64(vmulq_n_f64(this[1], (double)a3), vmulq_n_f64(this[3], (double)a4))), (float64x2_t)vdupq_lane_s64(COERCE__INT64(this[8].f64[1] + this[2].f64[1] * (double)a3 + this[4].f64[1] * (double)a4), 0)));
  *a2 = result;
  return result;
}

double *HGTransform::Invert(double *this)
{
  uint64_t v1 = 0;
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  double v2 = this + 2;
  double v3 = this[2];
  float64x2_t v4 = this + 6;
  double v5 = this[6];
  float64x2_t v6 = this + 10;
  double v7 = this[10];
  float64x2_t v8 = this + 14;
  double v9 = this[14];
  double v10 = this[3];
  double v11 = this[7];
  double v12 = this[8];
  double v13 = this[11];
  double v14 = this[12];
  double v16 = this[15];
  double v15 = this[16];
  double v18 = this[4];
  double v17 = this[5];
  double v19 = this[9];
  double v20 = this[13];
  float64x2_t v21 = this + 2;
  double v22 = 1.0;
  double v23 = 1.0;
  double v24 = 1.0;
  double v25 = 1.0;
  double v26 = this[17];
  do
  {
    double v27 = fabs(v25 * v3);
    double v28 = fabs(v24 * v10);
    double v29 = fabs(v18 * v23);
    double v30 = fabs(v17 * v22);
    if (v27 < v28) {
      double v31 = v28;
    }
    else {
      double v31 = v27;
    }
    if (v29 < v30) {
      double v32 = v30;
    }
    else {
      double v32 = v29;
    }
    if (v31 <= v32)
    {
      if (v29 <= v30)
      {
        if (v17 * v22 == 0.0)
        {
LABEL_21:
          this[2] = 1.0;
          *(_OWORD *)(this + 3) = 0u;
          *(_OWORD *)(this + 5) = 0u;
          this[7] = 1.0;
          *((_OWORD *)this + 4) = 0u;
          *((_OWORD *)this + 5) = 0u;
          this[12] = 1.0;
          *(_OWORD *)(this + 13) = 0u;
          *(_OWORD *)(this + 15) = 0u;
          this[17] = 1.0;
          return this;
        }
        double v54 = v19 / v17;
        double v19 = v20 / v17;
        double v20 = v26 / v17;
        double v55 = v19 * v3;
        double v56 = v26 / v17 * v3;
        double v26 = 1.0 / v17;
        double v57 = 1.0 / v17 * v3;
        double v3 = v5 - v54 * v3;
        double v5 = v7 - v55;
        double v7 = v9 - v56;
        double v46 = v11 - v54 * v10;
        double v11 = v13 - v19 * v10;
        double v13 = v16 - v20 * v10;
        double v58 = v18 * v19;
        double v59 = v18 * v20;
        double v60 = v18 * v26;
        double v18 = v12 - v18 * v54;
        double v12 = v14 - v58;
        double v22 = 0.0;
        double v9 = 0.0 - v57;
        double v16 = 0.0 - v26 * v10;
        double v14 = v15 - v59;
        int v33 = 3;
        double v15 = 0.0 - v60;
        double v17 = v54;
        float64x2_t v8 = v2;
      }
      else
      {
        if (v18 * v23 == 0.0) {
          goto LABEL_21;
        }
        double v42 = v12 / v18;
        double v12 = v14 / v18;
        double v14 = v15 / v18;
        double v43 = v12 * v3;
        double v44 = v15 / v18 * v3;
        double v15 = 1.0 / v18;
        double v45 = 1.0 / v18 * v3;
        double v3 = v5 - v42 * v3;
        double v5 = v7 - v43;
        double v7 = v9 - v44;
        double v46 = v11 - v42 * v10;
        double v11 = v13 - v12 * v10;
        double v13 = v16 - v14 * v10;
        double v47 = v19 - v42 * v17;
        double v19 = v20 - v12 * v17;
        double v23 = 0.0;
        double v9 = 0.0 - v45;
        double v16 = 0.0 - v15 * v10;
        double v20 = v26 - v17 * v14;
        int v33 = 2;
        double v18 = v42;
        double v26 = 0.0 - v15 * v17;
        double v17 = v47;
        float64x2_t v6 = v2;
      }
      double v10 = v46;
    }
    else if (v27 <= v28)
    {
      if (v24 * v10 == 0.0) {
        goto LABEL_21;
      }
      double v48 = v11 / v10;
      double v11 = v13 / v10;
      double v13 = v16 / v10;
      double v49 = v11 * v3;
      double v50 = v16 / v10 * v3;
      double v16 = 1.0 / v10;
      double v51 = 1.0 / v10 * v3;
      double v3 = v5 - v48 * v3;
      double v5 = v7 - v49;
      double v7 = v9 - v50;
      double v52 = v12 - v18 * v48;
      double v12 = v14 - v18 * v11;
      double v14 = v15 - v18 * v13;
      double v53 = v19 - v17 * v48;
      double v19 = v20 - v17 * v11;
      double v24 = 0.0;
      double v9 = 0.0 - v51;
      double v15 = 0.0 - v18 * v16;
      double v20 = v26 - v17 * v13;
      int v33 = 1;
      double v18 = v52;
      double v26 = 0.0 - v17 * v16;
      double v17 = v53;
      float64x2_t v4 = v2;
      double v10 = v48;
    }
    else
    {
      if (v25 * v3 == 0.0) {
        goto LABEL_21;
      }
      int v33 = 0;
      double v34 = v5 / v3;
      double v5 = v7 / v3;
      double v35 = v10 * v34;
      double v7 = v9 / v3;
      double v36 = v10 * v5;
      double v37 = v10 * (v9 / v3);
      double v9 = 1.0 / v3;
      double v38 = v10 * (1.0 / v3);
      double v39 = v11 - v35;
      double v11 = v13 - v36;
      double v13 = v16 - v37;
      double v40 = v12 - v18 * v34;
      double v12 = v14 - v18 * v5;
      double v14 = v15 - v18 * v7;
      double v41 = v19 - v17 * v34;
      double v19 = v20 - v17 * v5;
      double v25 = 0.0;
      double v16 = 0.0 - v38;
      double v15 = 0.0 - v18 * v9;
      double v20 = v26 - v17 * v7;
      double v18 = v40;
      double v26 = 0.0 - v17 * v9;
      double v17 = v41;
      float64x2_t v21 = v2;
      double v10 = v39;
      double v3 = v34;
    }
    v65[v1++] = v33;
    v2 += 4;
  }
  while (v1 != 4);
  uint64_t v61 = v65[1];
  uint64_t v62 = v65[0];
  uint64_t v63 = v65[2];
  uint64_t v64 = v65[3];
  v21[v62] = v3;
  v61 *= 8;
  *(double *)((char *)v21 + v61) = v10;
  v63 *= 8;
  *(double *)((char *)v21 + v63) = v18;
  v64 *= 8;
  *(double *)((char *)v21 + v64) = v17;
  v4[v62] = v5;
  *(double *)((char *)v4 + v61) = v11;
  *(double *)((char *)v4 + v63) = v12;
  *(double *)((char *)v4 + v64) = v19;
  v6[v62] = v7;
  *(double *)((char *)v6 + v61) = v13;
  *(double *)((char *)v6 + v63) = v14;
  *(double *)((char *)v6 + v64) = v20;
  v8[v62] = v9;
  *(double *)((char *)v8 + v61) = v16;
  *(double *)((char *)v8 + v63) = v15;
  *(double *)((char *)v8 + v64) = v26;
  return this;
}

double HGTransform::Invert2D(HGTransform *this)
{
  double v2 = *((double *)this + 6);
  double v1 = *((double *)this + 7);
  double v3 = *((double *)this + 17);
  double v4 = *((double *)this + 9);
  double v6 = *((double *)this + 14);
  double v5 = *((double *)this + 15);
  double v7 = v1 * v3 - v4 * v5;
  double v8 = *((double *)this + 5);
  double v9 = v4 * v6 - v3 * v2;
  double v10 = v5 * v2 - v1 * v6;
  double v11 = *((double *)this + 2);
  double v12 = *((double *)this + 3);
  double v13 = v7 * v11 + v12 * v9 + v10 * v8;
  if (v13 == 0.0) {
    double v13 = 0.0000000596046448;
  }
  double v14 = (v1 * v11 - v2 * v12) / v13;
  double v15 = fabs(v14);
  double v16 = -0.0000000596046448;
  if (v14 >= 0.0) {
    double v16 = 0.0000000596046448;
  }
  if (v15 <= 0.0000000596046448) {
    double v17 = v16;
  }
  else {
    double v17 = (v1 * v11 - v2 * v12) / v13;
  }
  *((double *)this + 2) = v7 / v13;
  *((double *)this + 3) = (v5 * v8 - v3 * v12) / v13;
  *((double *)this + 5) = (v4 * v12 - v1 * v8) / v13;
  *((double *)this + 6) = v9 / v13;
  *((double *)this + 7) = (v3 * v11 - v6 * v8) / v13;
  *((double *)this + 9) = (v2 * v8 - v4 * v11) / v13;
  *((double *)this + 14) = v10 / v13;
  *((double *)this + 15) = (v6 * v12 - v5 * v11) / v13;
  *((double *)this + 17) = v17;
  *((void *)this + 16) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  double result = 1.0;
  *((_OWORD *)this + 6) = xmmword_1B7E733D0;
  return result;
}

double HGTransform::Adjoint2D(HGTransform *this)
{
  double v2 = *((double *)this + 6);
  double v1 = *((double *)this + 7);
  double v3 = *((double *)this + 17);
  double v4 = *((double *)this + 9);
  double v6 = *((double *)this + 14);
  double v5 = *((double *)this + 15);
  double v7 = *((double *)this + 5);
  double v9 = *((double *)this + 2);
  double v8 = *((double *)this + 3);
  *((double *)this + 2) = v1 * v3 - v4 * v5;
  *((double *)this + 3) = v5 * v7 - v3 * v8;
  *((double *)this + 5) = v4 * v8 - v1 * v7;
  *((double *)this + 6) = v4 * v6 - v3 * v2;
  *((double *)this + 7) = v3 * v9 - v6 * v7;
  *((double *)this + 9) = v2 * v7 - v4 * v9;
  *((double *)this + 14) = v5 * v2 - v1 * v6;
  *((double *)this + 15) = v6 * v8 - v5 * v9;
  *((double *)this + 17) = v1 * v9 - v2 * v8;
  *((void *)this + 16) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  double result = 1.0;
  *((_OWORD *)this + 6) = xmmword_1B7E733D0;
  return result;
}

double HGTransform::Matrix2D(HGTransform *this)
{
  *((void *)this + 16) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  double result = 1.0;
  *((_OWORD *)this + 6) = xmmword_1B7E733D0;
  return result;
}

BOOL HGTransform::IsIdentity(HGTransform *this)
{
  return *((double *)this + 2) == 1.0
      && *((double *)this + 3) == 0.0
      && *((double *)this + 4) == 0.0
      && *((double *)this + 5) == 0.0
      && *((double *)this + 6) == 0.0
      && *((double *)this + 7) == 1.0
      && *((double *)this + 8) == 0.0
      && *((double *)this + 9) == 0.0
      && *((double *)this + 10) == 0.0
      && *((double *)this + 11) == 0.0
      && *((double *)this + 12) == 1.0
      && *((double *)this + 13) == 0.0
      && *((double *)this + 14) == 0.0
      && *((double *)this + 15) == 0.0
      && *((double *)this + 16) == 0.0
      && *((double *)this + 17) == 1.0;
}

BOOL HGTransform::IsEqual(HGTransform *this, HGTransform *a2)
{
  return a2
      && *((double *)this + 2) == *((double *)a2 + 2)
      && *((double *)this + 3) == *((double *)a2 + 3)
      && *((double *)this + 4) == *((double *)a2 + 4)
      && *((double *)this + 5) == *((double *)a2 + 5)
      && *((double *)this + 6) == *((double *)a2 + 6)
      && *((double *)this + 7) == *((double *)a2 + 7)
      && *((double *)this + 8) == *((double *)a2 + 8)
      && *((double *)this + 9) == *((double *)a2 + 9)
      && *((double *)this + 10) == *((double *)a2 + 10)
      && *((double *)this + 11) == *((double *)a2 + 11)
      && *((double *)this + 12) == *((double *)a2 + 12)
      && *((double *)this + 13) == *((double *)a2 + 13)
      && *((double *)this + 14) == *((double *)a2 + 14)
      && *((double *)this + 15) == *((double *)a2 + 15)
      && *((double *)this + 16) == *((double *)a2 + 16)
      && *((double *)this + 17) == *((double *)a2 + 17);
}

BOOL HGTransform::IsXYFlipAndOrIntegerTranslation(HGTransform *this)
{
  BOOL v1 = *((double *)this + 3) != 0.0
    || *((double *)this + 4) != 0.0
    || *((double *)this + 5) != 0.0
    || *((double *)this + 6) != 0.0
    || *((double *)this + 8) != 0.0
    || *((double *)this + 9) != 0.0
    || *((double *)this + 10) != 0.0
    || *((double *)this + 11) != 0.0
    || *((double *)this + 12) != 1.0
    || *((double *)this + 13) != 0.0
    || *((double *)this + 16) != 0.0
    || *((double *)this + 17) != 1.0;
  double v2 = *((double *)this + 2);
  if (v2 != 1.0 && v2 != -1.0) {
    return 0;
  }
  double v4 = *((double *)this + 7);
  BOOL v5 = v4 != 1.0;
  if (v4 == -1.0) {
    BOOL v5 = 0;
  }
  if (v1 || v5) {
    return 0;
  }
  double v6 = *((double *)this + 14);
  float v7 = v6;
  if (vabdd_f64((double)(int)llroundf(v7), v6) >= 0.00100000005) {
    return 0;
  }
  double v8 = *((double *)this + 15);
  float v9 = v8;
  return vabdd_f64((double)(int)llroundf(v9), v8) < 0.00100000005;
}

BOOL HGTransform::HasPerspective(HGTransform *this)
{
  return fabs(*((double *)this + 5)) >= 0.00000381469727
      || fabs(*((double *)this + 9)) >= 0.00000381469727
      || fabs(*((double *)this + 13)) >= 0.00000381469727
      || vabdd_f64(1.0, *((double *)this + 17)) >= 0.00000381469727;
}

double HGTransform::Transpose(HGTransform *this)
{
  float v1 = *((double *)this + 3);
  float v2 = *((double *)this + 4);
  double v3 = *((double *)this + 5);
  uint64_t v4 = *((void *)this + 10);
  uint64_t v5 = *((void *)this + 11);
  *((void *)this + 3) = *((void *)this + 6);
  *((void *)this + 4) = v4;
  double v6 = *((double *)this + 13);
  *((void *)this + 5) = *((void *)this + 14);
  *((double *)this + 6) = v1;
  double v7 = *((double *)this + 9);
  float v8 = *((double *)this + 8);
  *((double *)this + 10) = v2;
  *((double *)this + 11) = v8;
  uint64_t v9 = *((void *)this + 15);
  uint64_t v10 = *((void *)this + 16);
  *((void *)this + 8) = v5;
  *((void *)this + 9) = v9;
  *(float *)&uint64_t v9 = v3;
  *((void *)this + 13) = v10;
  *((double *)this + 14) = *(float *)&v9;
  *(float *)&uint64_t v9 = v7;
  double result = *(float *)&v9;
  *(float *)&uint64_t v10 = v6;
  *((double *)this + 15) = result;
  *((double *)this + 16) = *(float *)&v10;
  return result;
}

uint64_t HGTransformUtils::GetDOD(HGTransformUtils *this, const HGTransform *a2, HGRect a3, float a4, float a5)
{
  uint64_t v7 = *(void *)&a3.var0;
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  if (HGRectIsNull((uint64_t)a2, *(uint64_t *)&a3.var0)) {
    return 0;
  }
  if (!(*(unsigned int (**)(HGTransformUtils *))(*(void *)this + 224))(this)) {
    a4 = a4 + 0.00024414;
  }
  float v98 = (float)(int)a2 - a4;
  float v99 = (float)SHIDWORD(a2) - a4;
  uint64_t v100 = 0x3F80000000000000;
  float v101 = a4 + (float)(int)v7;
  float v102 = v99;
  uint64_t v103 = 0x3F80000000000000;
  float v104 = v101;
  float v105 = a4 + (float)SHIDWORD(v7);
  uint64_t v106 = 0x3F80000000000000;
  float v107 = v98;
  float v108 = v105;
  uint64_t v109 = 0x3F80000000000000;
  (*(void (**)(HGTransformUtils *, float *, float *, uint64_t))(*(void *)this + 208))(this, &v98, &v98, 4);
  BOOL v11 = *((float *)&v100 + 1) < a5;
  unsigned int v12 = (4 * (*((float *)&v106 + 1) < a5)) | (2 * (*((float *)&v103 + 1) < a5)) | (8 * (*((float *)&v109 + 1) < a5)) | v11;
  if (v12 == 15) {
    return 0;
  }
  if (!v12) {
    return HGRectMake4f(v11, fminf(v98 / *((float *)&v100 + 1), fminf(v101 / *((float *)&v103 + 1), fminf(v104 / *((float *)&v106 + 1), v107 / *((float *)&v109 + 1)))), fminf(v99 / *((float *)&v100 + 1), fminf(v102 / *((float *)&v103 + 1), fminf(v105 / *((float *)&v106 + 1), v108 / *((float *)&v109 + 1)))), fmaxf(v98 / *((float *)&v100 + 1), fmaxf(v101 / *((float *)&v103 + 1), fmaxf(v104 / *((float *)&v106 + 1), v107 / *((float *)&v109 + 1)))), fmaxf(v99 / *((float *)&v100 + 1), fmaxf(v102 / *((float *)&v103 + 1), fmaxf(v105 / *((float *)&v106 + 1), v108 / *((float *)&v109 + 1)))));
  }
  BOOL v13 = *((float *)&v103 + 1) >= a5;
  if (*((float *)&v100 + 1) >= a5) {
    BOOL v13 = 1;
  }
  int v14 = *((float *)&v106 + 1) >= a5 || v13;
  if (*((float *)&v106 + 1) < a5) {
    char v15 = 3;
  }
  else {
    char v15 = 2;
  }
  if (*((float *)&v109 + 1) >= a5) {
    int v14 = 1;
  }
  if (!v13) {
    LOBYTE(v11) = v15;
  }
  if (v14) {
    char v16 = v11;
  }
  else {
    char v16 = 4;
  }
  if ((v12 >> ((v16 + 1) & 3)))
  {
    double v17 = &v98 + 4 * ((v16 + 1) & 3);
    double v18 = &v98 + 4 * (v16 & 3);
    float v19 = (float)(a5 - v17[3]) / (float)(v18[3] - v17[3]);
    float v20 = v17[1];
    float v21 = v18[1];
    *(float *)v90.i32 = *v17 + (float)(v19 * (float)(*v18 - *v17));
    int v22 = 1;
    *(float *)&v90.i32[1] = v20 + (float)(v19 * (float)(v21 - v20));
    float v91 = a5;
    unsigned int v23 = (v16 + 2) & 3;
    if ((v12 >> v23)) {
      goto LABEL_25;
    }
LABEL_30:
    if (v22)
    {
      double v37 = (float32x2_t *)(&v98 + 4 * ((v16 + 1) & 3));
      double v38 = (float32x2_t *)(&v98 + 4 * v23);
      float v39 = v38[1].f32[1];
      float32x2_t v40 = *v38;
      int32x2_t v92 = (int32x2_t)vadd_f32(*v37, vmul_n_f32(vsub_f32(*v38, *v37), (float)(a5 - v37[1].f32[1]) / (float)(v39 - v37[1].f32[1])));
      float v93 = a5;
      unsigned int v41 = 2;
      float v42 = v40.f32[1];
    }
    else
    {
      double v52 = &v98 + 4 * v23;
      v40.f32[0] = *v52;
      float v42 = v52[1];
      float v39 = v52[3];
      unsigned int v41 = 1;
    }
    int v24 = 0;
    unsigned int v48 = v41;
    v90.i32[3 * v41] = v40.i32[0];
LABEL_37:
    double v53 = (float *)&v90 + 3 * v48;
    v53[1] = v42;
    v53[2] = v39;
    uint64_t v25 = v41 + 1;
    char v26 = v16 - 1;
    unsigned int v27 = (v16 - 1) & 3;
    if (((v12 >> ((v16 - 1) & 3)) & 1) == 0) {
      goto LABEL_27;
    }
    goto LABEL_38;
  }
  int v22 = 0;
  double v34 = (__int32 *)(&v98 + 4 * ((v16 + 1) & 3));
  __int32 v35 = v34[1];
  float v36 = *((float *)v34 + 3);
  v90.i32[0] = *v34;
  v90.i32[1] = v35;
  float v91 = v36;
  unsigned int v23 = (v16 + 2) & 3;
  if (((v12 >> v23) & 1) == 0) {
    goto LABEL_30;
  }
LABEL_25:
  if (!v22)
  {
    double v43 = &v98 + 4 * v23;
    double v44 = &v98 + 4 * ((v16 + 1) & 3);
    float v45 = (float)(a5 - v43[3]) / (float)(v44[3] - v43[3]);
    float v46 = v43[1];
    float v47 = v44[1];
    *(float *)v92.i32 = *v43 + (float)(v45 * (float)(*v44 - *v43));
    unsigned int v48 = 1;
    float v42 = v46 + (float)(v45 * (float)(v47 - v46));
    float v39 = a5;
    unsigned int v41 = 1;
    int v24 = 1;
    goto LABEL_37;
  }
  int v24 = 1;
  uint64_t v25 = 1;
  char v26 = v16 - 1;
  unsigned int v27 = (v16 - 1) & 3;
  if (((v12 >> ((v16 - 1) & 3)) & 1) == 0)
  {
LABEL_27:
    if (v24)
    {
      double v28 = (float32x2_t *)(&v98 + 4 * ((v16 + 2) & 3));
      double v29 = (float32x2_t *)(&v98 + 4 * v27);
      float v30 = v29[1].f32[1];
      double v31 = (float32x2_t *)((char *)&v90 + 12 * v25);
      float32x2_t v32 = *v29;
      *double v31 = vadd_f32(*v28, vmul_n_f32(vsub_f32(*v29, *v28), (float)(a5 - v28[1].f32[1]) / (float)(v30 - v28[1].f32[1])));
      v31[1].f32[0] = a5;
      LODWORD(v25) = v25 + 1;
      float v33 = v32.f32[1];
    }
    else
    {
      double v49 = &v98 + 4 * v27;
      v32.f32[0] = *v49;
      float v33 = v49[1];
      float v30 = v49[3];
    }
    int v50 = 0;
    unsigned int v51 = v25;
    v90.i32[3 * v25] = v32.i32[0];
LABEL_43:
    uint64_t v68 = (float *)&v90 + 3 * v51;
    v68[1] = v33;
    v68[2] = v30;
    uint64_t v25 = (v25 + 1);
    unsigned int v54 = v16 & 3;
    if ((v12 >> v54)) {
      goto LABEL_44;
    }
LABEL_40:
    if (v50)
    {
      double v55 = (float32x2_t *)(&v98 + 4 * (v26 & 3));
      float v56 = v55[1].f32[1];
      float v57 = a5 - v56;
      double v58 = (float32x2_t *)(&v98 + 4 * v54);
      double v59 = (float32x2_t *)((char *)&v90 + 12 * v25);
      v59[1].f32[0] = a5;
      a5 = v58[1].f32[1];
      float v60 = v57 / (float)(a5 - v56);
      float32x2_t v61 = *v58;
      *double v59 = vadd_f32(*v55, vmul_n_f32(vsub_f32(*v58, *v55), v60));
      LODWORD(v25) = v25 + 1;
      float v62 = v61.f32[1];
    }
    else
    {
      uint64_t v75 = &v98 + 4 * v54;
      v61.f32[0] = *v75;
      float v62 = v75[1];
      a5 = v75[3];
    }
    unsigned int v74 = v25;
    v90.i32[3 * v25] = v61.i32[0];
    goto LABEL_48;
  }
LABEL_38:
  if (!v24)
  {
    uint64_t v63 = &v98 + 4 * v27;
    uint64_t v64 = &v98 + 4 * ((v16 + 2) & 3);
    float v65 = (float)(a5 - v63[3]) / (float)(v64[3] - v63[3]);
    float v66 = v63[1];
    float v67 = v64[1];
    *(float *)&v90.i32[3 * v25] = *v63 + (float)(v65 * (float)(*v64 - *v63));
    unsigned int v51 = v25;
    float v33 = v66 + (float)(v65 * (float)(v67 - v66));
    int v50 = 1;
    float v30 = a5;
    goto LABEL_43;
  }
  int v50 = 1;
  unsigned int v54 = v16 & 3;
  if (((v12 >> v54) & 1) == 0) {
    goto LABEL_40;
  }
LABEL_44:
  if (v50) {
    goto LABEL_49;
  }
  uint64_t v69 = &v98 + 4 * v54;
  unint64_t v70 = &v98 + 4 * (v26 & 3);
  float v71 = (float)(a5 - v69[3]) / (float)(v70[3] - v69[3]);
  float v72 = v69[1];
  float v73 = v70[1];
  *(float *)&v90.i32[3 * v25] = *v69 + (float)(v71 * (float)(*v70 - *v69));
  unsigned int v74 = v25;
  float v62 = v72 + (float)(v71 * (float)(v73 - v72));
LABEL_48:
  unint64_t v76 = (float *)&v90 + 3 * v74;
  v76[1] = v62;
  v76[2] = a5;
  uint64_t v25 = (v25 + 1);
LABEL_49:
  if ((int)v25 <= 0)
  {
    float v79 = *(float *)&v90.i32[1];
    float v78 = *(float *)v90.i32;
    goto LABEL_59;
  }
  if (v25 >= 4)
  {
    int v80 = (const float *)&v90;
    float32x4x3_t v111 = vld3q_f32(v80);
    uint64_t v77 = v25 & 0x7C;
    int8x16_t v81 = (int8x16_t)vdivq_f32(v111.val[0], v111.val[2]);
    v111.val[0] = vdivq_f32(v111.val[1], v111.val[2]);
    int32x2_t v90 = vzip1_s32(*(int32x2_t *)v81.i8, *(int32x2_t *)v111.val[0].f32);
    int32x2_t v92 = vzip2_s32(*(int32x2_t *)v81.i8, *(int32x2_t *)v111.val[0].f32);
    v111.val[0].i64[0] = vextq_s8((int8x16_t)v111.val[0], (int8x16_t)v111.val[0], 8uLL).u64[0];
    v111.val[1].i64[0] = vextq_s8(v81, v81, 8uLL).u64[0];
    int32x2_t v94 = vzip1_s32(*(int32x2_t *)v111.val[1].f32, *(int32x2_t *)v111.val[0].f32);
    int32x2_t v95 = vzip2_s32(*(int32x2_t *)v111.val[1].f32, *(int32x2_t *)v111.val[0].f32);
    if (v77 == v25) {
      goto LABEL_56;
    }
  }
  else
  {
    uint64_t v77 = 0;
  }
  uint64_t v82 = (float32x2_t *)((char *)&v90 + 12 * v77);
  uint64_t v83 = v25 - v77;
  do
  {
    unint64_t v84 = (const float *)&v82[1];
    float32x2_t v85 = vld1_dup_f32(v84);
    float32x2_t *v82 = vdiv_f32(*v82, v85);
    uint64_t v82 = (float32x2_t *)((char *)v82 + 12);
    --v83;
  }
  while (v83);
LABEL_56:
  float v79 = *(float *)&v90.i32[1];
  float v78 = *(float *)v90.i32;
  if ((int)v25 >= 2)
  {
    float v86 = fminf(*(float *)v90.i32, *(float *)v92.i32);
    float v87 = fminf(*(float *)&v90.i32[1], *(float *)&v92.i32[1]);
    float v88 = fmaxf(*(float *)v90.i32, *(float *)v92.i32);
    float v89 = fmaxf(*(float *)&v90.i32[1], *(float *)&v92.i32[1]);
    if (v25 == 2)
    {
      float v78 = v86;
      float v79 = v87;
    }
    else
    {
      float v78 = fminf(v86, *(float *)v94.i32);
      float v79 = fminf(v87, *(float *)&v94.i32[1]);
      float v88 = fmaxf(v88, *(float *)v94.i32);
      float v89 = fmaxf(v89, *(float *)&v94.i32[1]);
      if (v25 != 3)
      {
        float v78 = fminf(v78, *(float *)v95.i32);
        float v79 = fminf(v79, *(float *)&v95.i32[1]);
        float v88 = fmaxf(v88, *(float *)v95.i32);
        float v89 = fmaxf(v89, *(float *)&v95.i32[1]);
        if (v25 != 4)
        {
          float v78 = fminf(v78, v96);
          float v79 = fminf(v79, v97);
          float v88 = fmaxf(v88, v96);
          float v89 = fmaxf(v89, v97);
          if (v25 != 5)
          {
            float v78 = fminf(v78, v98);
            float v79 = fminf(v79, v99);
            float v88 = fmaxf(v88, v98);
            float v89 = fmaxf(v89, v99);
            if (v25 != 6)
            {
              float v78 = fminf(v78, *((float *)&v100 + 1));
              float v79 = fminf(v79, v101);
              float v88 = fmaxf(v88, *((float *)&v100 + 1));
              float v89 = fmaxf(v89, v101);
            }
          }
        }
      }
    }
    return HGRectMake4f(v25, v78 - a4, v79 - a4, a4 + v88, a4 + v89);
  }
LABEL_59:
  float v88 = v78;
  float v89 = v79;
  return HGRectMake4f(v25, v78 - a4, v79 - a4, a4 + v88, a4 + v89);
}

uint64_t HGTransformUtils::GetROI(HGTransformUtils *this, unint64_t a2, HGRect a3, float a4, float a5)
{
  int var0 = a3.var0;
  int v8 = a2;
  uint64_t v116 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = HIDWORD(a2);
  int var1 = a3.var1;
  int v12 = (*(uint64_t (**)(HGTransformUtils *))(*(void *)this + 224))(this);
  float v104 = (float)v8 + 0.5;
  float v105 = (float)(int)v10 + 0.5;
  uint64_t v106 = 0x3F80000000000000;
  float v107 = (float)var0 + -0.5;
  float v108 = v105;
  uint64_t v109 = 0x3F80000000000000;
  float v110 = v107;
  float v111 = (float)var1 + -0.5;
  uint64_t v112 = 0x3F80000000000000;
  float v113 = v104;
  float v114 = v111;
  uint64_t v115 = 0x3F80000000000000;
  (*(void (**)(HGTransformUtils *, float *, float *, uint64_t))(*(void *)this + 208))(this, &v104, &v104, 4);
  uint64_t v13 = *((float *)&v106 + 1) < a5;
  unsigned int v14 = (4 * (*((float *)&v112 + 1) < a5)) | (2 * (*((float *)&v109 + 1) < a5)) | (8 * (*((float *)&v115 + 1) < a5)) | v13;
  if (v12) {
    float v15 = a4;
  }
  else {
    float v15 = a4 + 0.00024414;
  }
  if (v14 == 15) {
    return 0;
  }
  if (v14)
  {
    BOOL v21 = *((float *)&v109 + 1) >= a5;
    if (*((float *)&v106 + 1) >= a5) {
      BOOL v21 = 1;
    }
    int v22 = *((float *)&v112 + 1) >= a5 || v21;
    if (*((float *)&v112 + 1) < a5) {
      char v23 = 3;
    }
    else {
      char v23 = 2;
    }
    if (*((float *)&v115 + 1) >= a5) {
      int v22 = 1;
    }
    if (!v21) {
      LOBYTE(v13) = v23;
    }
    if (v22) {
      char v24 = v13;
    }
    else {
      char v24 = 4;
    }
    if ((v14 >> ((v24 + 1) & 3)))
    {
      uint64_t v25 = &v104 + 4 * ((v24 + 1) & 3);
      char v26 = &v104 + 4 * (v24 & 3);
      float v27 = (float)(a5 - v25[3]) / (float)(v26[3] - v25[3]);
      float v28 = v25[1];
      float v29 = v26[1];
      *(float *)v96.i32 = *v25 + (float)(v27 * (float)(*v26 - *v25));
      int v30 = 1;
      *(float *)&v96.i32[1] = v28 + (float)(v27 * (float)(v29 - v28));
      float v97 = a5;
      unsigned int v31 = (v24 + 2) & 3;
      if ((v14 >> v31))
      {
LABEL_25:
        if (v30)
        {
          int v32 = 1;
          uint64_t v13 = 1;
          char v33 = v24 - 1;
          unsigned int v34 = (v24 - 1) & 3;
          if (((v14 >> ((v24 - 1) & 3)) & 1) == 0)
          {
LABEL_27:
            if (v32)
            {
              __int32 v35 = (float32x2_t *)(&v104 + 4 * ((v24 + 2) & 3));
              float v36 = (float32x2_t *)(&v104 + 4 * v34);
              float v37 = v36[1].f32[1];
              double v38 = (float32x2_t *)((char *)&v96 + 12 * v13);
              float32x2_t v39 = *v36;
              *double v38 = vadd_f32(*v35, vmul_n_f32(vsub_f32(*v36, *v35), (float)(a5 - v35[1].f32[1]) / (float)(v37 - v35[1].f32[1])));
              v38[1].f32[0] = a5;
              LODWORD(v13) = v13 + 1;
              float v40 = v39.f32[1];
            }
            else
            {
              float v56 = &v104 + 4 * v34;
              v39.f32[0] = *v56;
              float v40 = v56[1];
              float v37 = v56[3];
            }
            int v57 = 0;
            unsigned int v58 = v13;
            v96.i32[3 * v13] = v39.i32[0];
            goto LABEL_43;
          }
LABEL_38:
          if (v32)
          {
            int v57 = 1;
            unsigned int v61 = v24 & 3;
            if ((v14 >> v61))
            {
LABEL_44:
              if (v57) {
                goto LABEL_49;
              }
              unint64_t v76 = &v104 + 4 * v61;
              uint64_t v77 = &v104 + 4 * (v33 & 3);
              float v78 = (float)(a5 - v76[3]) / (float)(v77[3] - v76[3]);
              float v79 = v76[1];
              float v80 = v77[1];
              *(float *)&v96.i32[3 * v13] = *v76 + (float)(v78 * (float)(*v77 - *v76));
              unsigned int v81 = v13;
              float v69 = v79 + (float)(v78 * (float)(v80 - v79));
LABEL_48:
              uint64_t v83 = (float *)&v96 + 3 * v81;
              v83[1] = v69;
              v83[2] = a5;
              uint64_t v13 = (v13 + 1);
LABEL_49:
              if ((int)v13 <= 0)
              {
                float v86 = *(float *)&v96.i32[1];
                float v85 = *(float *)v96.i32;
                goto LABEL_59;
              }
              if (v13 >= 4)
              {
                float v87 = (const float *)&v96;
                float32x4x3_t v117 = vld3q_f32(v87);
                uint64_t v84 = v13 & 0x7C;
                int8x16_t v88 = (int8x16_t)vdivq_f32(v117.val[0], v117.val[2]);
                v117.val[0] = vdivq_f32(v117.val[1], v117.val[2]);
                int32x2_t v96 = vzip1_s32(*(int32x2_t *)v88.i8, *(int32x2_t *)v117.val[0].f32);
                int32x2_t v98 = vzip2_s32(*(int32x2_t *)v88.i8, *(int32x2_t *)v117.val[0].f32);
                v117.val[0].i64[0] = vextq_s8((int8x16_t)v117.val[0], (int8x16_t)v117.val[0], 8uLL).u64[0];
                v117.val[1].i64[0] = vextq_s8(v88, v88, 8uLL).u64[0];
                int32x2_t v100 = vzip1_s32(*(int32x2_t *)v117.val[1].f32, *(int32x2_t *)v117.val[0].f32);
                int32x2_t v101 = vzip2_s32(*(int32x2_t *)v117.val[1].f32, *(int32x2_t *)v117.val[0].f32);
                if (v84 == v13) {
                  goto LABEL_56;
                }
              }
              else
              {
                uint64_t v84 = 0;
              }
              float v89 = (float32x2_t *)((char *)&v96 + 12 * v84);
              uint64_t v90 = v13 - v84;
              do
              {
                float v91 = (const float *)&v89[1];
                float32x2_t v92 = vld1_dup_f32(v91);
                *float v89 = vdiv_f32(*v89, v92);
                float v89 = (float32x2_t *)((char *)v89 + 12);
                --v90;
              }
              while (v90);
LABEL_56:
              float v86 = *(float *)&v96.i32[1];
              float v85 = *(float *)v96.i32;
              if ((int)v13 >= 2)
              {
                float v93 = fminf(*(float *)v96.i32, *(float *)v98.i32);
                float v94 = fminf(*(float *)&v96.i32[1], *(float *)&v98.i32[1]);
                float v95 = fmaxf(*(float *)v96.i32, *(float *)v98.i32);
                float v16 = fmaxf(*(float *)&v96.i32[1], *(float *)&v98.i32[1]);
                if (v13 == 2)
                {
                  float v85 = v93;
                  float v86 = v94;
                }
                else
                {
                  float v85 = fminf(v93, *(float *)v100.i32);
                  float v86 = fminf(v94, *(float *)&v100.i32[1]);
                  float v95 = fmaxf(v95, *(float *)v100.i32);
                  float v16 = fmaxf(v16, *(float *)&v100.i32[1]);
                  if (v13 != 3)
                  {
                    float v85 = fminf(v85, *(float *)v101.i32);
                    float v86 = fminf(v86, *(float *)&v101.i32[1]);
                    float v95 = fmaxf(v95, *(float *)v101.i32);
                    float v16 = fmaxf(v16, *(float *)&v101.i32[1]);
                    if (v13 != 4)
                    {
                      float v85 = fminf(v85, v102);
                      float v86 = fminf(v86, v103);
                      float v95 = fmaxf(v95, v102);
                      float v16 = fmaxf(v16, v103);
                      if (v13 != 5)
                      {
                        float v85 = fminf(v85, v104);
                        float v86 = fminf(v86, v105);
                        float v95 = fmaxf(v95, v104);
                        float v16 = fmaxf(v16, v105);
                        if (v13 != 6)
                        {
                          float v85 = fminf(v85, *((float *)&v106 + 1));
                          float v86 = fminf(v86, v107);
                          float v95 = fmaxf(v95, *((float *)&v106 + 1));
                          float v16 = fmaxf(v16, v107);
                        }
                      }
                    }
                  }
                }
                goto LABEL_60;
              }
LABEL_59:
              float v95 = v85;
              float v16 = v86;
LABEL_60:
              float v17 = v85 - v15;
              float v18 = v86 - v15;
              float v19 = v15 + v95;
              return HGRectMake4f(v13, v17, v18, v19, v15 + v16);
            }
LABEL_40:
            if (v57)
            {
              float v62 = (float32x2_t *)(&v104 + 4 * (v33 & 3));
              float v63 = v62[1].f32[1];
              float v64 = a5 - v63;
              float v65 = (float32x2_t *)(&v104 + 4 * v61);
              float v66 = (float32x2_t *)((char *)&v96 + 12 * v13);
              v66[1].f32[0] = a5;
              a5 = v65[1].f32[1];
              float v67 = v64 / (float)(a5 - v63);
              float32x2_t v68 = *v65;
              *float v66 = vadd_f32(*v62, vmul_n_f32(vsub_f32(*v65, *v62), v67));
              LODWORD(v13) = v13 + 1;
              float v69 = v68.f32[1];
            }
            else
            {
              uint64_t v82 = &v104 + 4 * v61;
              v68.f32[0] = *v82;
              float v69 = v82[1];
              a5 = v82[3];
            }
            unsigned int v81 = v13;
            v96.i32[3 * v13] = v68.i32[0];
            goto LABEL_48;
          }
          unint64_t v70 = &v104 + 4 * v34;
          float v71 = &v104 + 4 * ((v24 + 2) & 3);
          float v72 = (float)(a5 - v70[3]) / (float)(v71[3] - v70[3]);
          float v73 = v70[1];
          float v74 = v71[1];
          *(float *)&v96.i32[3 * v13] = *v70 + (float)(v72 * (float)(*v71 - *v70));
          unsigned int v58 = v13;
          float v40 = v73 + (float)(v72 * (float)(v74 - v73));
          int v57 = 1;
          float v37 = a5;
LABEL_43:
          uint64_t v75 = (float *)&v96 + 3 * v58;
          v75[1] = v40;
          v75[2] = v37;
          uint64_t v13 = (v13 + 1);
          unsigned int v61 = v24 & 3;
          if ((v14 >> v61)) {
            goto LABEL_44;
          }
          goto LABEL_40;
        }
        int v50 = &v104 + 4 * v31;
        unsigned int v51 = &v104 + 4 * ((v24 + 1) & 3);
        float v52 = (float)(a5 - v50[3]) / (float)(v51[3] - v50[3]);
        float v53 = v50[1];
        float v54 = v51[1];
        *(float *)v98.i32 = *v50 + (float)(v52 * (float)(*v51 - *v50));
        unsigned int v55 = 1;
        float v49 = v53 + (float)(v52 * (float)(v54 - v53));
        float v46 = a5;
        unsigned int v48 = 1;
        int v32 = 1;
LABEL_37:
        float v60 = (float *)&v96 + 3 * v55;
        v60[1] = v49;
        v60[2] = v46;
        uint64_t v13 = v48 + 1;
        char v33 = v24 - 1;
        unsigned int v34 = (v24 - 1) & 3;
        if (((v14 >> ((v24 - 1) & 3)) & 1) == 0) {
          goto LABEL_27;
        }
        goto LABEL_38;
      }
    }
    else
    {
      int v30 = 0;
      unsigned int v41 = (__int32 *)(&v104 + 4 * ((v24 + 1) & 3));
      __int32 v42 = v41[1];
      float v43 = *((float *)v41 + 3);
      v96.i32[0] = *v41;
      v96.i32[1] = v42;
      float v97 = v43;
      unsigned int v31 = (v24 + 2) & 3;
      if ((v14 >> v31)) {
        goto LABEL_25;
      }
    }
    if (v30)
    {
      double v44 = (float32x2_t *)(&v104 + 4 * ((v24 + 1) & 3));
      float v45 = (float32x2_t *)(&v104 + 4 * v31);
      float v46 = v45[1].f32[1];
      float32x2_t v47 = *v45;
      int32x2_t v98 = (int32x2_t)vadd_f32(*v44, vmul_n_f32(vsub_f32(*v45, *v44), (float)(a5 - v44[1].f32[1]) / (float)(v46 - v44[1].f32[1])));
      float v99 = a5;
      unsigned int v48 = 2;
      float v49 = v47.f32[1];
    }
    else
    {
      double v59 = &v104 + 4 * v31;
      v47.f32[0] = *v59;
      float v49 = v59[1];
      float v46 = v59[3];
      unsigned int v48 = 1;
    }
    int v32 = 0;
    unsigned int v55 = v48;
    v96.i32[3 * v48] = v47.i32[0];
    goto LABEL_37;
  }
  float v104 = v104 / *((float *)&v106 + 1);
  float v105 = v105 / *((float *)&v106 + 1);
  float v107 = v107 / *((float *)&v109 + 1);
  float v108 = v108 / *((float *)&v109 + 1);
  float v110 = v110 / *((float *)&v112 + 1);
  float v111 = v111 / *((float *)&v112 + 1);
  float v113 = v113 / *((float *)&v115 + 1);
  float v114 = v114 / *((float *)&v115 + 1);
  float v16 = fmaxf(v105, fmaxf(v108, fmaxf(v111, v114)));
  float v17 = fminf(v104, fminf(v107, fminf(v110, v113))) - v15;
  float v18 = fminf(v105, fminf(v108, fminf(v111, v114))) - v15;
  float v19 = v15 + fmaxf(v104, fmaxf(v107, fmaxf(v110, v113)));
  return HGRectMake4f(v13, v17, v18, v19, v15 + v16);
}

float HGTransformUtils::MinW(HGTransformUtils *this)
{
  return 0.000001;
}

void HGBuffer::HGBuffer(HGBuffer *this, HGRect a2, HGBitmap *a3)
{
  HGBitmap::HGBitmap((HGBitmap *)this, a2, a3);
  *double v3 = &unk_1F10D0898;
}

void *HGBuffer::HGBuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  double result = (void *)HGBitmap::HGBitmap(a1, a2, a3, a4);
  *double result = &unk_1F10D0898;
  return result;
}

void *HGBuffer::HGBuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  double result = (void *)HGBitmap::HGBitmap(a1, a2, a3, a4, a5);
  *double result = &unk_1F10D0898;
  return result;
}

void HGBuffer::~HGBuffer(HGBitmap *this, void *a2)
{
  HGBitmap::~HGBitmap(this, a2);

  HGObject::operator delete(v2);
}

BOOL HGProgramDescriptor::IsMergeable(HGProgramDescriptor *this)
{
  if ((*((char *)this + 87) & 0x80000000) == 0)
  {
    uint64_t v1 = *((unsigned __int8 *)this + 87);
    int v2 = *((char *)this + 111);
    if ((v2 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    if (*((void *)this + 12)) {
      return v1 != 0;
    }
    goto LABEL_7;
  }
  uint64_t v1 = *((void *)this + 9);
  int v2 = *((char *)this + 111);
  if (v2 < 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((_BYTE)v2) {
    return v1 != 0;
  }
LABEL_7:
  if (*((char *)this + 183) < 0) {
    return v1 && *((void *)this + 21) != 0;
  }
  else {
    return v1 && *((unsigned char *)this + 183) != 0;
  }
}

BOOL HGProgramDescriptor::IsComplete(HGProgramDescriptor *this)
{
  if (*((char *)this + 87) < 0)
  {
    if (*((void *)this + 9)) {
      goto LABEL_3;
    }
  }
  else if (*((unsigned char *)this + 87))
  {
LABEL_3:
    if (*((char *)this + 111) < 0)
    {
      if (*((void *)this + 12)) {
        return 1;
      }
    }
    else if (*((unsigned char *)this + 111))
    {
      return 1;
    }
    int v1 = *((char *)this + 183);
    if (v1 < 0) {
      return *((void *)this + 21) != 0;
    }
    return (_BYTE)v1 != 0;
  }
  if (*((char *)this + 63) < 0)
  {
    if (!*((void *)this + 6)) {
      return 0;
    }
  }
  else if (!*((unsigned char *)this + 63))
  {
    return 0;
  }
  if (*((char *)this + 111) < 0)
  {
    if (*((void *)this + 12)) {
      return 1;
    }
  }
  else if (*((unsigned char *)this + 111))
  {
    return 1;
  }
  int v1 = *((char *)this + 159);
  if (v1 < 0) {
    return *((void *)this + 18) != 0;
  }
  return (_BYTE)v1 != 0;
}

uint64_t HGProgramDescriptor::IsConcatenated(HGProgramDescriptor *this)
{
  if (*((char *)this + 87) < 0)
  {
    uint64_t v1 = *((void *)this + 9);
    int v2 = *((char *)this + 111);
    if ((v2 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v2) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v1 = *((unsigned __int8 *)this + 87);
    int v2 = *((char *)this + 111);
    if ((v2 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  if (*((void *)this + 12))
  {
LABEL_4:
    if (!v1) {
      return 0;
    }
    goto LABEL_20;
  }
LABEL_8:
  if (*((char *)this + 183) < 0)
  {
    if (v1) {
      BOOL v4 = *((void *)this + 21) == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4) {
      return 0;
    }
  }
  else
  {
    if (v1) {
      BOOL v3 = *((unsigned char *)this + 183) == 0;
    }
    else {
      BOOL v3 = 1;
    }
    if (v3) {
      return 0;
    }
  }
LABEL_20:
  for (uint64_t i = *((void *)this + 14); i != *((void *)this + 15); i += 16)
  {
    if (!*(_DWORD *)i && *(void *)(i + 8)) {
      return 1;
    }
  }
  return 0;
}

__n128 HGProgramDescriptor::SetReturnBinding(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 184) = *(_DWORD *)a2;
  std::string::operator=((std::string *)(a1 + 192), (const std::string *)(a2 + 8));
  __n128 result = *(__n128 *)(a2 + 32);
  *(__n128 *)(a1 + 216) = result;
  return result;
}

void HGProgramDescriptor::SetArgumentBindings(uint64_t a1, uint64_t *a2)
{
  BOOL v4 = (void **)(a1 + 232);
  if (v4 != (void **)a2) {
    std::vector<HGBinding>::__assign_with_size[abi:ne180100]<HGBinding*,HGBinding*>(v4, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 4));
  }
  uint64_t v5 = a2[1] - *a2;
  if (v5)
  {
    uint64_t v6 = 0;
    unint64_t v7 = v5 / 48;
    if (v7 <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7;
    }
    while (1)
    {
      int v9 = *(_DWORD *)(*a2 + v6);
      if (v9 == 9) {
        break;
      }
      if (v9 != 10) {
        goto LABEL_9;
      }
      int v14 = 1;
      uint64_t v15 = 0;
      unint64_t v10 = *(void *)(a1 + 120);
      if (v10 < *(void *)(a1 + 128))
      {
        *(_DWORD *)unint64_t v10 = 1;
LABEL_8:
        *(void *)(v10 + 8) = 0;
        *(void *)(a1 + 120) = v10 + 16;
        goto LABEL_9;
      }
      BOOL v11 = std::vector<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>::__push_back_slow_path<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>((void **)(a1 + 112), (uint64_t)&v14);
      uint64_t v12 = v15;
      *(void *)(a1 + 120) = v11;
      if (v12) {
        goto LABEL_14;
      }
LABEL_9:
      v6 += 48;
      if (!--v8) {
        return;
      }
    }
    int v14 = 2;
    uint64_t v15 = 0;
    unint64_t v10 = *(void *)(a1 + 120);
    if (v10 >= *(void *)(a1 + 128))
    {
      uint64_t v13 = std::vector<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>::__push_back_slow_path<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>((void **)(a1 + 112), (uint64_t)&v14);
      uint64_t v12 = v15;
      *(void *)(a1 + 120) = v13;
      if (!v12) {
        goto LABEL_9;
      }
LABEL_14:
      (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
      goto LABEL_9;
    }
    *(_DWORD *)unint64_t v10 = 2;
    goto LABEL_8;
  }
}

void sub_1B77476C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B77476D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  return a1;
}

void HGProgramDescriptor::SetStageInBindings(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (void **)(a1 + 256);
  if (v2 != (void **)a2) {
    std::vector<HGBinding>::__assign_with_size[abi:ne180100]<HGBinding*,HGBinding*>(v2, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 4));
  }
}

void *HGProgramDescriptor::SetInput(void *result, unint64_t a2, void *a3)
{
  uint64_t v3 = result[14];
  if (a2 < (result[15] - v3) >> 4)
  {
    uint64_t v5 = (void *)*a3;
    if (*a3)
    {
      uint64_t v6 = result;
      (*(void (**)(void *))(*v5 + 16))(v5);
      uint64_t v7 = v6[14];
      uint64_t v8 = 16 * a2;
      *(_DWORD *)(v7 + v8) = 0;
      int v9 = (void **)(v7 + 16 * a2 + 8);
      __n128 result = *(void **)(v7 + v8 + 8);
      if (result == v5) {
        return (void *)(*(uint64_t (**)(void *))(*v5 + 24))(v5);
      }
    }
    else
    {
      *(_DWORD *)(v3 + 16 * a2) = 0;
      int v9 = (void **)(v3 + 16 * a2 + 8);
      __n128 result = *v9;
      if (!*v9) {
        return result;
      }
    }
    if (result) {
      __n128 result = (void *)(*(uint64_t (**)(void *))(*result + 24))(result);
    }
    *int v9 = v5;
  }
  return result;
}

void sub_1B774788C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *HGProgramDescriptor::SetInput(void *result, unint64_t a2, int a3)
{
  uint64_t v3 = result[14];
  if (a2 < (result[15] - v3) >> 4)
  {
    *(_DWORD *)(v3 + 16 * a2) = a3;
    BOOL v4 = (void **)(v3 + 16 * a2 + 8);
    __n128 result = *v4;
    if (*v4)
    {
      __n128 result = (void *)(*(uint64_t (**)(void *))(*result + 24))(result);
      *BOOL v4 = 0;
    }
  }
  return result;
}

void sub_1B7747918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

std::string *HGProgramDescriptor::EncodeShaderDeclarations(std::string *result, std::string *this)
{
  uint64_t v3 = (uint64_t)result;
  if (result[3].__r_.__value_.__s.__data_[15] < 0)
  {
    std::string::pointer data = result[3].__r_.__value_.__l.__data_;
    int v5 = result[4].__r_.__value_.__s.__data_[15];
    if ((v5 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v5) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else
  {
    std::string::pointer data = (std::string::pointer)result[3].__r_.__value_.__s.__data_[15];
    int v5 = result[4].__r_.__value_.__s.__data_[15];
    if ((v5 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  if (result[4].__r_.__value_.__r.__words[0])
  {
LABEL_4:
    if (!data) {
      return result;
    }
LABEL_18:
    if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v8 = 1046;
    }
    else {
      std::string::size_type v8 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) + 1023;
    }
    std::string::reserve(this, v8);
    HGMetalUtils::stringForMetalHeader((uint64_t)__p);
    if (v17 >= 0) {
      int v9 = __p;
    }
    else {
      int v9 = (void **)__p[0];
    }
    if (v17 >= 0) {
      std::string::size_type v10 = HIBYTE(v17);
    }
    else {
      std::string::size_type v10 = (std::string::size_type)__p[1];
    }
    std::string::append(this, (const std::string::value_type *)v9, v10);
    if (SHIBYTE(v17) < 0) {
      operator delete(__p[0]);
    }
    std::string::append(this, "struct FragmentOut {\n");
    *((unsigned char *)&v15.__r_.__value_.__s + 23) = 4;
    strcpy((char *)&v15, "    ");
    BOOL v11 = std::string::append(&v15, "float4 color0 [[ color(0) ]];\n");
    long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    int64_t v17 = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    if (v17 >= 0) {
      uint64_t v13 = __p;
    }
    else {
      uint64_t v13 = (void **)__p[0];
    }
    if (v17 >= 0) {
      std::string::size_type v14 = HIBYTE(v17);
    }
    else {
      std::string::size_type v14 = (std::string::size_type)__p[1];
    }
    std::string::append(this, (const std::string::value_type *)v13, v14);
    if (SHIBYTE(v17) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_37;
      }
    }
    else if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_37:
      std::string::append(this, "};\n\n");
      std::string::append(this, "extern \"C\" {\n");
      HGProgramDescriptor::privateEncodeShaderDeclarations(v3, this);
      return std::string::append(this, "}\n");
    }
    operator delete(v15.__r_.__value_.__l.__data_);
    goto LABEL_37;
  }
LABEL_8:
  if (result[7].__r_.__value_.__s.__data_[15] < 0)
  {
    if (data) {
      BOOL v7 = result[7].__r_.__value_.__r.__words[0] == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7) {
      goto LABEL_18;
    }
  }
  else
  {
    if (data) {
      BOOL v6 = result[7].__r_.__value_.__s.__data_[15] == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (!v6) {
      goto LABEL_18;
    }
  }
  return result;
}

void sub_1B7747B28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

std::string *HGProgramDescriptor::privateEncodeShaderDeclarations(uint64_t a1, std::string *a2)
{
  BOOL v4 = *(int **)(a1 + 112);
  int v5 = *(int **)(a1 + 120);
  while (v4 != v5)
  {
    int v6 = *v4;
    LODWORD(__dst) = *v4;
    std::string::size_type v7 = *((void *)v4 + 1);
    std::string::size_type v41 = v7;
    if (v7)
    {
      (*(void (**)(std::string::size_type))(*(void *)v7 + 16))(v7);
      if (!v6)
      {
        (*(void (**)(std::string::size_type))(*(void *)v7 + 16))(v7);
        HGProgramDescriptor::privateEncodeShaderDeclarations(v7, a2);
        (*(void (**)(std::string::size_type))(*(void *)v7 + 24))(v7);
      }
      (*(void (**)(std::string::size_type))(*(void *)v7 + 24))(v7);
    }
    v4 += 4;
  }
  std::string::append(a2, "[[ visible ]] ");
  int v8 = *(char *)(a1 + 215);
  if (v8 >= 0) {
    size_t v9 = *(unsigned __int8 *)(a1 + 215);
  }
  else {
    size_t v9 = *(void *)(a1 + 200);
  }
  unint64_t v10 = v9 + 1;
  if (v9 + 1 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_77;
  }
  if (v10 >= 0x17)
  {
    uint64_t v12 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v12 = v10 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_dst = (void **)operator new(v12 + 1);
    std::string::size_type v41 = v9 + 1;
    int64_t v42 = v13 | 0x8000000000000000;
    long long __dst = p_dst;
  }
  else
  {
    std::string::size_type v41 = 0;
    int64_t v42 = 0;
    long long __dst = 0;
    p_dst = (void **)&__dst;
    HIBYTE(v42) = v9 + 1;
    if (!v9) {
      goto LABEL_22;
    }
  }
  if (v8 >= 0) {
    std::string::size_type v14 = (const void *)(a1 + 192);
  }
  else {
    std::string::size_type v14 = *(const void **)(a1 + 192);
  }
  memmove(p_dst, v14, v9);
LABEL_22:
  *(_WORD *)((char *)p_dst + v9) = 32;
  if (v42 >= 0) {
    std::string v15 = (const std::string::value_type *)&__dst;
  }
  else {
    std::string v15 = (const std::string::value_type *)__dst;
  }
  if (v42 >= 0) {
    std::string::size_type v16 = HIBYTE(v42);
  }
  else {
    std::string::size_type v16 = v41;
  }
  std::string::append(a2, v15, v16);
  if (SHIBYTE(v42) < 0) {
    operator delete(__dst);
  }
  int v17 = *(char *)(a1 + 87);
  if (v17 >= 0) {
    size_t v18 = *(unsigned __int8 *)(a1 + 87);
  }
  else {
    size_t v18 = *(void *)(a1 + 72);
  }
  unint64_t v19 = v18 + 1;
  if (v18 + 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_77:
  }
    std::string::__throw_length_error[abi:ne180100]();
  if (v19 >= 0x17)
  {
    uint64_t v21 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17) {
      uint64_t v21 = v19 | 7;
    }
    uint64_t v22 = v21 + 1;
    float v20 = (void **)operator new(v21 + 1);
    std::string::size_type v41 = v18 + 1;
    int64_t v42 = v22 | 0x8000000000000000;
    long long __dst = v20;
  }
  else
  {
    std::string::size_type v41 = 0;
    int64_t v42 = 0;
    long long __dst = 0;
    float v20 = (void **)&__dst;
    HIBYTE(v42) = v18 + 1;
    if (!v18) {
      goto LABEL_44;
    }
  }
  if (v17 >= 0) {
    char v23 = (const void *)(a1 + 64);
  }
  else {
    char v23 = *(const void **)(a1 + 64);
  }
  memmove(v20, v23, v18);
LABEL_44:
  *(_WORD *)((char *)v20 + v18) = 40;
  if (v42 >= 0) {
    char v24 = (const std::string::value_type *)&__dst;
  }
  else {
    char v24 = (const std::string::value_type *)__dst;
  }
  if (v42 >= 0) {
    std::string::size_type v25 = HIBYTE(v42);
  }
  else {
    std::string::size_type v25 = v41;
  }
  std::string::append(a2, v24, v25);
  if (SHIBYTE(v42) < 0) {
    operator delete(__dst);
  }
  uint64_t v27 = *(void *)(a1 + 232);
  uint64_t v26 = *(void *)(a1 + 240);
  if (v27 != v26)
  {
    std::string::append(a2, "");
    unsigned int v28 = *(_DWORD *)(v27 + 36) - 1;
    if (v28 <= 3) {
      std::string::append(a2, off_1E616C3A0[v28]);
    }
    int v29 = *(char *)(v27 + 31);
    if (v29 >= 0) {
      int v30 = (const std::string::value_type *)(v27 + 8);
    }
    else {
      int v30 = *(const std::string::value_type **)(v27 + 8);
    }
    if (v29 >= 0) {
      std::string::size_type v31 = *(unsigned __int8 *)(v27 + 31);
    }
    else {
      std::string::size_type v31 = *(void *)(v27 + 16);
    }
    std::string::append(a2, v30, v31);
    unsigned int v32 = *(_DWORD *)(v27 + 36) - 1;
    if (v32 <= 3) {
      std::string::append(a2, off_1E616C3C0[v32]);
    }
    for (uint64_t i = v27 + 48; i != v26; i += 48)
    {
      std::string::append(a2, ", ");
      unsigned int v34 = *(_DWORD *)(i + 36) - 1;
      if (v34 <= 3) {
        std::string::append(a2, off_1E616C3A0[v34]);
      }
      int v35 = *(char *)(i + 31);
      if (v35 >= 0) {
        float v36 = (const std::string::value_type *)(i + 8);
      }
      else {
        float v36 = *(const std::string::value_type **)(i + 8);
      }
      if (v35 >= 0) {
        std::string::size_type v37 = *(unsigned __int8 *)(i + 31);
      }
      else {
        std::string::size_type v37 = *(void *)(i + 16);
      }
      std::string::append(a2, v36, v37);
      unsigned int v38 = *(_DWORD *)(i + 36) - 1;
      if (v38 <= 3) {
        std::string::append(a2, off_1E616C3C0[v38]);
      }
    }
  }
  return std::string::append(a2, ");\n");
}

void sub_1B7747F80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B7747FA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

std::string *HGProgramDescriptor::EncodeShaderBufferStruct(std::string *result, std::string *this)
{
  uint64_t v3 = (std::string::__raw *)result;
  if (result[3].__r_.__value_.__s.__data_[15] < 0)
  {
    std::string::pointer data = result[3].__r_.__value_.__l.__data_;
    int v5 = result[4].__r_.__value_.__s.__data_[15];
    if ((v5 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v5) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }
  else
  {
    std::string::pointer data = (std::string::pointer)result[3].__r_.__value_.__s.__data_[15];
    int v5 = result[4].__r_.__value_.__s.__data_[15];
    if ((v5 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  if (result[4].__r_.__value_.__r.__words[0])
  {
LABEL_4:
    if (!data) {
      return result;
    }
    goto LABEL_5;
  }
LABEL_12:
  if (result[7].__r_.__value_.__s.__data_[15] < 0)
  {
    if (data) {
      BOOL v8 = result[7].__r_.__value_.__r.__words[0] == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8) {
      goto LABEL_5;
    }
  }
  else
  {
    if (data) {
      BOOL v7 = result[7].__r_.__value_.__s.__data_[15] == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7)
    {
LABEL_5:
      if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v6 = 278;
      }
      else {
        std::string::size_type v6 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) + 255;
      }
      std::string::reserve(this, v6);
      std::string::append(this, "struct ShaderParameters {\n");
      unint64_t v9 = 0;
      HGProgramDescriptor::privateEncodeShaderBufferStruct(v3, this, &v9);
      return std::string::append(this, "};\n");
    }
  }
  return result;
}

void HGProgramDescriptor::privateEncodeShaderBufferStruct(void *a1, std::string *a2, unint64_t *a3)
{
  std::string::size_type v6 = (int *)a1[14];
  BOOL v7 = (int *)a1[15];
  while (v6 != v7)
  {
    int v8 = *v6;
    LODWORD(v41) = *v6;
    uint64_t v9 = *((void *)v6 + 1);
    *((void *)&v41 + 1) = v9;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
    }
    if (v8 != 2)
    {
      if (v8) {
        BOOL v10 = 1;
      }
      else {
        BOOL v10 = v9 == 0;
      }
      if (!v10)
      {
        (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
        HGProgramDescriptor::privateEncodeShaderBufferStruct(v9, a2, a3);
        ++*a3;
        (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
LABEL_2:
        (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
        goto LABEL_3;
      }
      ++*a3;
    }
    if (v9) {
      goto LABEL_2;
    }
LABEL_3:
    v6 += 4;
  }
  std::to_string(&v40, *a3);
  BOOL v11 = std::string::insert(&v40, 0, "r");
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  int64_t v42 = v11->__r_.__value_.__r.__words[2];
  long long v41 = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  for (uint64_t i = a1[29]; i != a1[30]; i += 48)
  {
    if (*(_DWORD *)i == 2 && *(_DWORD *)(i + 40))
    {
      *((unsigned char *)&v36.__r_.__value_.__s + 23) = 4;
      strcpy((char *)&v36, "    ");
      std::string::size_type v14 = std::string::append(&v36, "alignas(16) ");
      long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      v37.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      int v16 = *(char *)(i + 31);
      if (v16 >= 0) {
        int v17 = (const std::string::value_type *)(i + 8);
      }
      else {
        int v17 = *(const std::string::value_type **)(i + 8);
      }
      if (v16 >= 0) {
        std::string::size_type v18 = *(unsigned __int8 *)(i + 31);
      }
      else {
        std::string::size_type v18 = *(void *)(i + 16);
      }
      unint64_t v19 = std::string::append(&v37, v17, v18);
      long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
      v38.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v20;
      v19->__r_.__value_.__l.__size_ = 0;
      v19->__r_.__value_.__r.__words[2] = 0;
      v19->__r_.__value_.__r.__words[0] = 0;
      uint64_t v21 = std::string::append(&v38, " buffer_");
      long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v22;
      v21->__r_.__value_.__l.__size_ = 0;
      v21->__r_.__value_.__r.__words[2] = 0;
      v21->__r_.__value_.__r.__words[0] = 0;
      if (v42 >= 0) {
        char v23 = (const std::string::value_type *)&v41;
      }
      else {
        char v23 = (const std::string::value_type *)v41;
      }
      if (v42 >= 0) {
        std::string::size_type v24 = HIBYTE(v42);
      }
      else {
        std::string::size_type v24 = *((void *)&v41 + 1);
      }
      std::string::size_type v25 = std::string::append(&v39, v23, v24);
      long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &v40;
      }
      else {
        uint64_t v27 = (std::string *)v40.__r_.__value_.__r.__words[0];
      }
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v40.__r_.__value_.__l.__size_;
      }
      std::string::append(a2, (const std::string::value_type *)v27, size);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v40.__r_.__value_.__l.__data_);
        if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_49;
        }
LABEL_43:
        if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_44;
        }
LABEL_50:
        operator delete(v38.__r_.__value_.__l.__data_);
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_51;
        }
LABEL_45:
        if ((SHIBYTE(v36.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_46;
        }
LABEL_52:
        operator delete(v36.__r_.__value_.__l.__data_);
        unsigned int v29 = *(_DWORD *)(i + 40);
        if (v29 < 2)
        {
LABEL_62:
          std::string::append(a2, ";\n");
          break;
        }
      }
      else
      {
        if ((SHIBYTE(v39.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_43;
        }
LABEL_49:
        operator delete(v39.__r_.__value_.__l.__data_);
        if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_50;
        }
LABEL_44:
        if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_45;
        }
LABEL_51:
        operator delete(v37.__r_.__value_.__l.__data_);
        if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_52;
        }
LABEL_46:
        unsigned int v29 = *(_DWORD *)(i + 40);
        if (v29 < 2) {
          goto LABEL_62;
        }
      }
      std::to_string(&v38, v29);
      int v30 = std::string::insert(&v38, 0, "[");
      long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v31;
      v30->__r_.__value_.__l.__size_ = 0;
      v30->__r_.__value_.__r.__words[2] = 0;
      v30->__r_.__value_.__r.__words[0] = 0;
      unsigned int v32 = std::string::append(&v39, "]");
      long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v33;
      v32->__r_.__value_.__l.__size_ = 0;
      v32->__r_.__value_.__r.__words[2] = 0;
      v32->__r_.__value_.__r.__words[0] = 0;
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unsigned int v34 = &v40;
      }
      else {
        unsigned int v34 = (std::string *)v40.__r_.__value_.__r.__words[0];
      }
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v35 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v35 = v40.__r_.__value_.__l.__size_;
      }
      std::string::append(a2, (const std::string::value_type *)v34, v35);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v40.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v39.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_61;
        }
      }
      else if ((SHIBYTE(v39.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_61:
        if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_62;
        }
LABEL_68:
        operator delete(v38.__r_.__value_.__l.__data_);
        goto LABEL_62;
      }
      operator delete(v39.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_62;
      }
      goto LABEL_68;
    }
  }
  if (SHIBYTE(v42) < 0) {
    operator delete((void *)v41);
  }
}

void sub_1B7748530(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a42 < 0)
  {
    operator delete(__p);
    if (a35 < 0)
    {
LABEL_5:
      operator delete(a30);
      if ((a28 & 0x80000000) == 0)
      {
LABEL_9:
        if (*(char *)(v42 - 73) < 0)
        {
          operator delete(*(void **)(v42 - 96));
          _Unwind_Resume(a1);
        }
        _Unwind_Resume(a1);
      }
LABEL_8:
      operator delete(a23);
      goto LABEL_9;
    }
  }
  else if (a35 < 0)
  {
    goto LABEL_5;
  }
  if ((a28 & 0x80000000) == 0) {
    goto LABEL_9;
  }
  goto LABEL_8;
}

void HGProgramDescriptor::EncodeShaderFunction(uint64_t a1, std::string *this)
{
  uint64_t v184 = *MEMORY[0x1E4F143B8];
  if (*(char *)(a1 + 87) < 0)
  {
    uint64_t v4 = *(void *)(a1 + 72);
    int v5 = *(char *)(a1 + 111);
    if ((v5 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v5) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 87);
    int v5 = *(char *)(a1 + 111);
    if ((v5 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  if (*(void *)(a1 + 96))
  {
LABEL_4:
    if (!v4) {
      return;
    }
    goto LABEL_19;
  }
LABEL_8:
  if (*(char *)(a1 + 183) < 0)
  {
    if (v4) {
      BOOL v7 = *(void *)(a1 + 168) == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (v7) {
      return;
    }
  }
  else
  {
    if (v4) {
      BOOL v6 = *(unsigned char *)(a1 + 183) == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (v6) {
      return;
    }
  }
LABEL_19:
  if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v8 = 2070;
  }
  else {
    std::string::size_type v8 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) + 2047;
  }
  std::string::reserve(this, v8);
  unint64_t v180 = 0;
  int v181 = 0;
  unint64_t v182 = 0;
  LODWORD(v178[0]) = 7;
  HIBYTE(v178[1]) = 10;
  strcpy((char *)v178 + 8, "VertexData");
  long long v179 = xmmword_1B7E75170;
  uint64_t v9 = std::vector<HGBinding>::__push_back_slow_path<HGBinding>(&v180, (uint64_t)v178);
  int v181 = v9;
  if (SHIBYTE(v178[1]) < 0)
  {
    operator delete(*((void **)&v178[0] + 1));
    uint64_t v9 = v181;
  }
  LODWORD(v178[0]) = 2;
  HIBYTE(v178[1]) = 16;
  strcpy((char *)v178 + 8, "ShaderParameters");
  long long v179 = xmmword_1B7EC1C20;
  if ((unint64_t)v9 >= v182)
  {
    int v181 = std::vector<HGBinding>::__push_back_slow_path<HGBinding>(&v180, (uint64_t)v178);
    if (SHIBYTE(v178[1]) < 0) {
      operator delete(*((void **)&v178[0] + 1));
    }
  }
  else
  {
    *(_DWORD *)uint64_t v9 = 2;
    long long v10 = *(_OWORD *)((char *)v178 + 8);
    *((void *)v9 + 3) = *((void *)&v178[1] + 1);
    *(_OWORD *)(v9 + 8) = v10;
    v178[1] = 0uLL;
    *((void *)&v178[0] + 1) = 0;
    *((_OWORD *)v9 + 2) = v179;
    int v181 = v9 + 48;
  }
  memset(v178, 0, sizeof(v178));
  LODWORD(v179) = 1065353216;
  long long v177 = 0uLL;
  uint64_t v175 = 0;
  uint64_t v176 = 0;
  char v174 = 0;
  memset(&v173, 0, sizeof(v173));
  std::string::reserve(&v173, 0x400uLL);
  std::string::append(&v173, "{\n");
  HGProgramDescriptor::privateEncodeShaderFunction(a1, &v173, (uint64_t)&v180, (uint64_t)v178, (unint64_t *)&v177 + 1, &v177, &v176, &v175, &v174);
  *((unsigned char *)&v169.__r_.__value_.__s + 23) = 4;
  strcpy((char *)&v169, "    ");
  BOOL v11 = std::string::append(&v169, "return ");
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v170.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v170.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  v183.__r_.__value_.__r.__words[0] = (std::string::size_type)&v177 + 8;
  uint64_t v13 = std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t)v178, (unint64_t *)&v177 + 1, (uint64_t)&std::piecewise_construct, (uint64_t **)&v183);
  int v16 = (const std::string::value_type *)v13[3];
  std::string::size_type v14 = (const std::string::value_type *)(v13 + 3);
  long long v15 = v16;
  int v17 = v14[23];
  if (v17 >= 0) {
    std::string::size_type v18 = v14;
  }
  else {
    std::string::size_type v18 = v15;
  }
  if (v17 >= 0) {
    std::string::size_type v19 = *((unsigned __int8 *)v14 + 23);
  }
  else {
    std::string::size_type v19 = *((void *)v14 + 1);
  }
  long long v20 = std::string::append(&v170, v18, v19);
  long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  long long v22 = std::string::append(&__dst, ";\n");
  long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  v172.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v172.__r_.__value_.__l.__data_ = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if ((v172.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v24 = &v172;
  }
  else {
    std::string::size_type v24 = (std::string *)v172.__r_.__value_.__r.__words[0];
  }
  if ((v172.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v172.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v172.__r_.__value_.__l.__size_;
  }
  std::string::append(&v173, (const std::string::value_type *)v24, size);
  if (SHIBYTE(v172.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v172.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_42:
      if ((SHIBYTE(v170.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_43;
      }
LABEL_89:
      operator delete(v170.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v169.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_44;
      }
      goto LABEL_90;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_42;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_89;
  }
LABEL_43:
  if ((SHIBYTE(v169.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_44;
  }
LABEL_90:
  operator delete(v169.__r_.__value_.__l.__data_);
LABEL_44:
  std::string::append(&v173, "};");
  memset(&v172, 0, sizeof(v172));
  std::string::reserve(&v172, 0x400uLL);
  std::operator+<char>();
  long long v26 = std::string::append(&v170, " ");
  long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_dst = &__dst;
  }
  else {
    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v29 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v29 = __dst.__r_.__value_.__l.__size_;
  }
  std::string::append(&v172, (const std::string::value_type *)p_dst, v29);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v170.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_52:
      int v30 = (const char **)(a1 + 40);
      int v31 = *(char *)(a1 + 63);
      if ((v31 & 0x80000000) == 0) {
        goto LABEL_53;
      }
LABEL_93:
      if (*(void *)(a1 + 48))
      {
        unsigned int v32 = *v30;
        size_t v33 = strlen(*v30);
        if (v33 <= 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_57;
        }
      }
      else
      {
        unsigned int v32 = "fragmentFunc";
        size_t v33 = strlen("fragmentFunc");
        if (v33 <= 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_57;
        }
      }
LABEL_95:
      std::string::__throw_length_error[abi:ne180100]();
    }
  }
  else if ((SHIBYTE(v170.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_52;
  }
  operator delete(v170.__r_.__value_.__l.__data_);
  int v30 = (const char **)(a1 + 40);
  int v31 = *(char *)(a1 + 63);
  if (v31 < 0) {
    goto LABEL_93;
  }
LABEL_53:
  if (v31) {
    unsigned int v32 = (const char *)v30;
  }
  else {
    unsigned int v32 = "fragmentFunc";
  }
  size_t v33 = strlen(v32);
  if (v33 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_95;
  }
LABEL_57:
  std::string::size_type v34 = v33;
  int v164 = this;
  if (v33 >= 0x17)
  {
    uint64_t v36 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v33 | 7) != 0x17) {
      uint64_t v36 = v33 | 7;
    }
    uint64_t v37 = v36 + 1;
    std::string::size_type v35 = operator new(v36 + 1);
    __dst.__r_.__value_.__l.__size_ = v34;
    __dst.__r_.__value_.__r.__words[2] = v37 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
    goto LABEL_63;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v33;
  std::string::size_type v35 = &__dst;
  if (v33) {
LABEL_63:
  }
    memmove(v35, v32, v34);
  *((unsigned char *)v35 + v34) = 0;
  int v38 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v39 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t v39 = __dst.__r_.__value_.__l.__size_;
  }
  unint64_t v40 = v39 + 1;
  if (v39 + 1 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v40 >= 0x17)
  {
    uint64_t v42 = (v40 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v40 | 7) != 0x17) {
      uint64_t v42 = v40 | 7;
    }
    uint64_t v43 = v42 + 1;
    long long v41 = (char *)operator new(v42 + 1);
    v170.__r_.__value_.__l.__size_ = v39 + 1;
    v170.__r_.__value_.__r.__words[2] = v43 | 0x8000000000000000;
    v170.__r_.__value_.__r.__words[0] = (std::string::size_type)v41;
  }
  else
  {
    memset(&v170, 0, sizeof(v170));
    long long v41 = (char *)&v170;
    *((unsigned char *)&v170.__r_.__value_.__s + 23) = v39 + 1;
    if (!v39) {
      goto LABEL_78;
    }
  }
  if (v38 >= 0) {
    double v44 = &__dst;
  }
  else {
    double v44 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  memmove(v41, v44, v39);
LABEL_78:
  *(_WORD *)&v41[v39] = 40;
  if ((v170.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    float v45 = &v170;
  }
  else {
    float v45 = (std::string *)v170.__r_.__value_.__r.__words[0];
  }
  if ((v170.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v46 = HIBYTE(v170.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v46 = v170.__r_.__value_.__l.__size_;
  }
  std::string::append(&v172, (const std::string::value_type *)v45, v46);
  if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v170.__r_.__value_.__l.__data_);
    *((unsigned char *)&v170.__r_.__value_.__s + 23) = 0;
    v170.__r_.__value_.__s.__data_[0] = 0;
    float32x2_t v47 = v180;
    unsigned int v48 = v181;
    if (v180 == v181) {
      goto LABEL_256;
    }
    goto LABEL_97;
  }
  *((unsigned char *)&v170.__r_.__value_.__s + 23) = 0;
  v170.__r_.__value_.__s.__data_[0] = 0;
  float32x2_t v47 = v180;
  unsigned int v48 = v181;
  if (v180 != v181)
  {
LABEL_97:
    uint64_t v165 = 0;
    while (2)
    {
      if ((v170.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        float v49 = &v170;
      }
      else {
        float v49 = (std::string *)v170.__r_.__value_.__r.__words[0];
      }
      if ((v170.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v50 = HIBYTE(v170.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v50 = v170.__r_.__value_.__l.__size_;
      }
      std::string::append(&v172, (const std::string::value_type *)v49, v50);
      switch(*(_DWORD *)v47)
      {
        case 2:
          unsigned int v51 = *((_DWORD *)v47 + 9) - 1;
          if (v51 <= 3) {
            std::string::append(&v172, off_1E616C3A0[v51]);
          }
          int v52 = v47[31];
          if (v52 >= 0) {
            float v53 = v47 + 8;
          }
          else {
            float v53 = (const std::string::value_type *)*((void *)v47 + 1);
          }
          if (v52 >= 0) {
            std::string::size_type v54 = v47[31];
          }
          else {
            std::string::size_type v54 = *((void *)v47 + 2);
          }
          std::string::append(&v172, v53, v54);
          unsigned int v55 = *((_DWORD *)v47 + 9) - 1;
          if (v55 <= 3) {
            std::string::append(&v172, off_1E616C3C0[v55]);
          }
          std::string::append(&v172, "shaderParams [[ buffer(0) ]]");
          goto LABEL_240;
        case 5:
          int v60 = v47[31];
          if (v60 >= 0) {
            size_t v61 = v47[31];
          }
          else {
            size_t v61 = *((void *)v47 + 2);
          }
          unint64_t v62 = v61 + 1;
          if (v61 + 1 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          if (v62 >= 0x17)
          {
            uint64_t v87 = (v62 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v62 | 7) != 0x17) {
              uint64_t v87 = v62 | 7;
            }
            uint64_t v88 = v87 + 1;
            float v63 = (char *)operator new(v87 + 1);
            v183.__r_.__value_.__l.__size_ = v61 + 1;
            v183.__r_.__value_.__r.__words[2] = v88 | 0x8000000000000000;
            v183.__r_.__value_.__r.__words[0] = (std::string::size_type)v63;
          }
          else
          {
            memset(&v183, 0, sizeof(v183));
            float v63 = (char *)&v183;
            *((unsigned char *)&v183.__r_.__value_.__s + 23) = v61 + 1;
            if (!v61)
            {
LABEL_184:
              *(_WORD *)&v63[v61] = 32;
              uint64_t v90 = std::string::append(&v183, "position [[ position ]]");
              long long v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
              v169.__r_.__value_.__r.__words[2] = v90->__r_.__value_.__r.__words[2];
              *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v91;
              v90->__r_.__value_.__l.__size_ = 0;
              v90->__r_.__value_.__r.__words[2] = 0;
              v90->__r_.__value_.__r.__words[0] = 0;
              if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                float32x2_t v92 = &v169;
              }
              else {
                float32x2_t v92 = (std::string *)v169.__r_.__value_.__r.__words[0];
              }
              if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type v93 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type v93 = v169.__r_.__value_.__l.__size_;
              }
              goto LABEL_203;
            }
          }
          if (v60 >= 0) {
            float v89 = v47 + 8;
          }
          else {
            float v89 = (const void *)*((void *)v47 + 1);
          }
          memmove(v63, v89, v61);
          goto LABEL_184;
        case 6:
          int v56 = v47[31];
          if (v56 >= 0) {
            size_t v57 = v47[31];
          }
          else {
            size_t v57 = *((void *)v47 + 2);
          }
          unint64_t v58 = v57 + 8;
          if (v57 + 8 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          if (v58 >= 0x17)
          {
            uint64_t v72 = (v58 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v58 | 7) != 0x17) {
              uint64_t v72 = v58 | 7;
            }
            uint64_t v73 = v72 + 1;
            double v59 = operator new(v72 + 1);
            v183.__r_.__value_.__l.__size_ = v57 + 8;
            v183.__r_.__value_.__r.__words[2] = v73 | 0x8000000000000000;
            v183.__r_.__value_.__r.__words[0] = (std::string::size_type)v59;
          }
          else
          {
            memset(&v183, 0, sizeof(v183));
            double v59 = &v183;
            *((unsigned char *)&v183.__r_.__value_.__s + 23) = v57 + 8;
            if (!v57) {
              goto LABEL_152;
            }
          }
          if (v56 >= 0) {
            float v74 = v47 + 8;
          }
          else {
            float v74 = (const void *)*((void *)v47 + 1);
          }
          memmove(v59, v74, v57);
LABEL_152:
          strcpy((char *)v59 + v57, " sampler");
          std::to_string(&v168, BYTE4(v165));
          if ((v168.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v75 = &v168;
          }
          else {
            uint64_t v75 = (std::string *)v168.__r_.__value_.__r.__words[0];
          }
          if ((v168.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v76 = HIBYTE(v168.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v76 = v168.__r_.__value_.__l.__size_;
          }
          uint64_t v77 = std::string::append(&v183, (const std::string::value_type *)v75, v76);
          long long v78 = *(_OWORD *)&v77->__r_.__value_.__l.__data_;
          v169.__r_.__value_.__r.__words[2] = v77->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v78;
          v77->__r_.__value_.__l.__size_ = 0;
          v77->__r_.__value_.__r.__words[2] = 0;
          v77->__r_.__value_.__r.__words[0] = 0;
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            float v79 = &v169;
          }
          else {
            float v79 = (std::string *)v169.__r_.__value_.__r.__words[0];
          }
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v80 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v80 = v169.__r_.__value_.__l.__size_;
          }
          std::string::append(&v172, (const std::string::value_type *)v79, v80);
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v169.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_166:
              if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_167;
              }
              goto LABEL_246;
            }
          }
          else if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_166;
          }
          operator delete(v168.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_167;
          }
LABEL_246:
          operator delete(v183.__r_.__value_.__l.__data_);
LABEL_167:
          std::to_string(&v168, BYTE4(v165));
          unsigned int v81 = std::string::insert(&v168, 0, " [[ sampler(");
          long long v82 = *(_OWORD *)&v81->__r_.__value_.__l.__data_;
          v183.__r_.__value_.__r.__words[2] = v81->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v82;
          v81->__r_.__value_.__l.__size_ = 0;
          v81->__r_.__value_.__r.__words[2] = 0;
          v81->__r_.__value_.__r.__words[0] = 0;
          uint64_t v83 = std::string::append(&v183, ") ]]");
          long long v84 = *(_OWORD *)&v83->__r_.__value_.__l.__data_;
          v169.__r_.__value_.__r.__words[2] = v83->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v84;
          v83->__r_.__value_.__l.__size_ = 0;
          v83->__r_.__value_.__r.__words[2] = 0;
          v83->__r_.__value_.__r.__words[0] = 0;
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            float v85 = &v169;
          }
          else {
            float v85 = (std::string *)v169.__r_.__value_.__r.__words[0];
          }
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v86 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v86 = v169.__r_.__value_.__l.__size_;
          }
          std::string::append(&v172, (const std::string::value_type *)v85, v86);
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v169.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_175:
              if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_176;
              }
              goto LABEL_252;
            }
          }
          else if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_175;
          }
          operator delete(v183.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_176;
          }
LABEL_252:
          operator delete(v168.__r_.__value_.__l.__data_);
LABEL_176:
          ++BYTE4(v165);
          goto LABEL_240;
        case 7:
          int v64 = v47[31];
          if (v64 >= 0) {
            size_t v65 = v47[31];
          }
          else {
            size_t v65 = *((void *)v47 + 2);
          }
          unint64_t v66 = v65 + 1;
          if (v65 + 1 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          if (v66 >= 0x17)
          {
            uint64_t v94 = (v66 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v66 | 7) != 0x17) {
              uint64_t v94 = v66 | 7;
            }
            uint64_t v95 = v94 + 1;
            float v67 = (char *)operator new(v94 + 1);
            v183.__r_.__value_.__l.__size_ = v65 + 1;
            v183.__r_.__value_.__r.__words[2] = v95 | 0x8000000000000000;
            v183.__r_.__value_.__r.__words[0] = (std::string::size_type)v67;
          }
          else
          {
            memset(&v183, 0, sizeof(v183));
            float v67 = (char *)&v183;
            *((unsigned char *)&v183.__r_.__value_.__s + 23) = v65 + 1;
            if (!v65) {
              goto LABEL_197;
            }
          }
          if (v64 >= 0) {
            int32x2_t v96 = v47 + 8;
          }
          else {
            int32x2_t v96 = (const void *)*((void *)v47 + 1);
          }
          memmove(v67, v96, v65);
LABEL_197:
          *(_WORD *)&v67[v65] = 32;
          float v97 = std::string::append(&v183, "vdata [[ stage_in ]]");
          long long v98 = *(_OWORD *)&v97->__r_.__value_.__l.__data_;
          v169.__r_.__value_.__r.__words[2] = v97->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v98;
          v97->__r_.__value_.__l.__size_ = 0;
          v97->__r_.__value_.__r.__words[2] = 0;
          v97->__r_.__value_.__r.__words[0] = 0;
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            float32x2_t v92 = &v169;
          }
          else {
            float32x2_t v92 = (std::string *)v169.__r_.__value_.__r.__words[0];
          }
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v93 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v93 = v169.__r_.__value_.__l.__size_;
          }
LABEL_203:
          std::string::append(&v172, (const std::string::value_type *)v92, v93);
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v169.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_240;
            }
          }
          else if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_240;
          }
          operator delete(v183.__r_.__value_.__l.__data_);
          goto LABEL_240;
        case 9:
          int v68 = v47[31];
          if (v68 >= 0) {
            size_t v69 = v47[31];
          }
          else {
            size_t v69 = *((void *)v47 + 2);
          }
          unint64_t v70 = v69 + 8;
          if (v69 + 8 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          if (v70 >= 0x17)
          {
            uint64_t v99 = (v70 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v70 | 7) != 0x17) {
              uint64_t v99 = v70 | 7;
            }
            uint64_t v100 = v99 + 1;
            float v71 = operator new(v99 + 1);
            v183.__r_.__value_.__l.__size_ = v69 + 8;
            v183.__r_.__value_.__r.__words[2] = v100 | 0x8000000000000000;
            v183.__r_.__value_.__r.__words[0] = (std::string::size_type)v71;
          }
          else
          {
            memset(&v183, 0, sizeof(v183));
            float v71 = &v183;
            *((unsigned char *)&v183.__r_.__value_.__s + 23) = v69 + 8;
            if (!v69) {
              goto LABEL_215;
            }
          }
          if (v68 >= 0) {
            int32x2_t v101 = v47 + 8;
          }
          else {
            int32x2_t v101 = (const void *)*((void *)v47 + 1);
          }
          memmove(v71, v101, v69);
LABEL_215:
          strcpy((char *)v71 + v69, " texture");
          std::to_string(&v168, v165);
          if ((v168.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            float v102 = &v168;
          }
          else {
            float v102 = (std::string *)v168.__r_.__value_.__r.__words[0];
          }
          if ((v168.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v103 = HIBYTE(v168.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v103 = v168.__r_.__value_.__l.__size_;
          }
          float v104 = std::string::append(&v183, (const std::string::value_type *)v102, v103);
          long long v105 = *(_OWORD *)&v104->__r_.__value_.__l.__data_;
          v169.__r_.__value_.__r.__words[2] = v104->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v105;
          v104->__r_.__value_.__l.__size_ = 0;
          v104->__r_.__value_.__r.__words[2] = 0;
          v104->__r_.__value_.__r.__words[0] = 0;
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v106 = &v169;
          }
          else {
            uint64_t v106 = (std::string *)v169.__r_.__value_.__r.__words[0];
          }
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v107 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v107 = v169.__r_.__value_.__l.__size_;
          }
          std::string::append(&v172, (const std::string::value_type *)v106, v107);
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v169.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_229:
              if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_230;
              }
              goto LABEL_249;
            }
          }
          else if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_229;
          }
          operator delete(v168.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_230;
          }
LABEL_249:
          operator delete(v183.__r_.__value_.__l.__data_);
LABEL_230:
          std::to_string(&v168, v165);
          float v108 = std::string::insert(&v168, 0, " [[ texture(");
          long long v109 = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
          v183.__r_.__value_.__r.__words[2] = v108->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v109;
          v108->__r_.__value_.__l.__size_ = 0;
          v108->__r_.__value_.__r.__words[2] = 0;
          v108->__r_.__value_.__r.__words[0] = 0;
          float v110 = std::string::append(&v183, ") ]]");
          long long v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
          v169.__r_.__value_.__r.__words[2] = v110->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v111;
          v110->__r_.__value_.__l.__size_ = 0;
          v110->__r_.__value_.__r.__words[2] = 0;
          v110->__r_.__value_.__r.__words[0] = 0;
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v112 = &v169;
          }
          else {
            uint64_t v112 = (std::string *)v169.__r_.__value_.__r.__words[0];
          }
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v113 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v113 = v169.__r_.__value_.__l.__size_;
          }
          std::string::append(&v172, (const std::string::value_type *)v112, v113);
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v169.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_238:
              if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_239;
              }
              goto LABEL_255;
            }
          }
          else if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_238;
          }
          operator delete(v183.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_239;
          }
LABEL_255:
          operator delete(v168.__r_.__value_.__l.__data_);
LABEL_239:
          LOBYTE(v165) = v165 + 1;
LABEL_240:
          *((unsigned char *)&v169.__r_.__value_.__s + 23) = 4;
          strcpy((char *)&v169, "    ");
          float v114 = std::string::insert(&v169, 0, ",\n");
          std::string::size_type v115 = v114->__r_.__value_.__r.__words[0];
          v183.__r_.__value_.__r.__words[0] = v114->__r_.__value_.__l.__size_;
          *(std::string::size_type *)((char *)v183.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v114->__r_.__value_.__r.__words[1] + 7);
          char v116 = HIBYTE(v114->__r_.__value_.__r.__words[2]);
          v114->__r_.__value_.__l.__size_ = 0;
          v114->__r_.__value_.__r.__words[2] = 0;
          v114->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v170.__r_.__value_.__l.__data_);
          }
          v170.__r_.__value_.__r.__words[0] = v115;
          v170.__r_.__value_.__l.__size_ = v183.__r_.__value_.__r.__words[0];
          *(std::string::size_type *)((char *)&v170.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v183.__r_.__value_.__r.__words + 7);
          *((unsigned char *)&v170.__r_.__value_.__s + 23) = v116;
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v169.__r_.__value_.__l.__data_);
          }
          v47 += 48;
          if (v47 != v48) {
            continue;
          }
          goto LABEL_256;
        default:
          goto LABEL_240;
      }
    }
  }
LABEL_256:
  std::string::append(&v172, ")\n");
  memset(&v169, 0, sizeof(v169));
  std::string::reserve(&v169, 0x400uLL);
  std::string::append(&v169, "struct VertexData {\n");
  *((unsigned char *)&v168.__r_.__value_.__s + 23) = 4;
  strcpy((char *)&v168, "    ");
  float32x4x3_t v117 = std::string::append(&v168, "float4 _position [[ position ]];\n");
  long long v118 = *(_OWORD *)&v117->__r_.__value_.__l.__data_;
  v183.__r_.__value_.__r.__words[2] = v117->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v118;
  v117->__r_.__value_.__l.__size_ = 0;
  v117->__r_.__value_.__r.__words[2] = 0;
  v117->__r_.__value_.__r.__words[0] = 0;
  if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v119 = &v183;
  }
  else {
    uint64_t v119 = (std::string *)v183.__r_.__value_.__r.__words[0];
  }
  if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v120 = HIBYTE(v183.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v120 = v183.__r_.__value_.__l.__size_;
  }
  std::string::append(&v169, (const std::string::value_type *)v119, v120);
  if ((SHIBYTE(v183.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_264;
    }
LABEL_267:
    operator delete(v168.__r_.__value_.__l.__data_);
    uint64_t v121 = v177;
    if (!(void)v177) {
      goto LABEL_303;
    }
    goto LABEL_268;
  }
  operator delete(v183.__r_.__value_.__l.__data_);
  if (SHIBYTE(v168.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_267;
  }
LABEL_264:
  uint64_t v121 = v177;
  if ((void)v177)
  {
LABEL_268:
    uint64_t v122 = 0;
    while (1)
    {
      *((unsigned char *)&v167.__r_.__value_.__s + 23) = 4;
      strcpy((char *)&v167, "    ");
      uint64_t v123 = std::string::append(&v167, "float4 _texcoord");
      long long v124 = *(_OWORD *)&v123->__r_.__value_.__l.__data_;
      v168.__r_.__value_.__r.__words[2] = v123->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v168.__r_.__value_.__l.__data_ = v124;
      v123->__r_.__value_.__l.__size_ = 0;
      v123->__r_.__value_.__r.__words[2] = 0;
      v123->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v166, v122);
      if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v125 = &v166;
      }
      else {
        unint64_t v125 = (std::string *)v166.__r_.__value_.__r.__words[0];
      }
      if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v126 = HIBYTE(v166.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v126 = v166.__r_.__value_.__l.__size_;
      }
      uint64_t v127 = std::string::append(&v168, (const std::string::value_type *)v125, v126);
      long long v128 = *(_OWORD *)&v127->__r_.__value_.__l.__data_;
      v183.__r_.__value_.__r.__words[2] = v127->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v128;
      v127->__r_.__value_.__l.__size_ = 0;
      v127->__r_.__value_.__r.__words[2] = 0;
      v127->__r_.__value_.__r.__words[0] = 0;
      if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t v129 = &v183;
      }
      else {
        size_t v129 = (std::string *)v183.__r_.__value_.__r.__words[0];
      }
      if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v130 = HIBYTE(v183.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v130 = v183.__r_.__value_.__l.__size_;
      }
      std::string::append(&v169, (const std::string::value_type *)v129, v130);
      if (SHIBYTE(v183.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v183.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v166.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_285:
          if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_286;
          }
          goto LABEL_298;
        }
      }
      else if ((SHIBYTE(v166.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_285;
      }
      operator delete(v166.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_286:
        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_299;
        }
        goto LABEL_287;
      }
LABEL_298:
      operator delete(v168.__r_.__value_.__l.__data_);
      if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0) {
LABEL_299:
      }
        operator delete(v167.__r_.__value_.__l.__data_);
LABEL_287:
      std::to_string(&v167, v122);
      int v131 = std::string::insert(&v167, 0, " [[ user(texcoord");
      long long v132 = *(_OWORD *)&v131->__r_.__value_.__l.__data_;
      v168.__r_.__value_.__r.__words[2] = v131->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v168.__r_.__value_.__l.__data_ = v132;
      v131->__r_.__value_.__l.__size_ = 0;
      v131->__r_.__value_.__r.__words[2] = 0;
      v131->__r_.__value_.__r.__words[0] = 0;
      string_t v133 = std::string::append(&v168, ") ]];\n");
      long long v134 = *(_OWORD *)&v133->__r_.__value_.__l.__data_;
      v183.__r_.__value_.__r.__words[2] = v133->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v134;
      v133->__r_.__value_.__l.__size_ = 0;
      v133->__r_.__value_.__r.__words[2] = 0;
      v133->__r_.__value_.__r.__words[0] = 0;
      if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v135 = &v183;
      }
      else {
        int v135 = (std::string *)v183.__r_.__value_.__r.__words[0];
      }
      if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v136 = HIBYTE(v183.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v136 = v183.__r_.__value_.__l.__size_;
      }
      std::string::append(&v169, (const std::string::value_type *)v135, v136);
      if (SHIBYTE(v183.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v183.__r_.__value_.__l.__data_);
        if (SHIBYTE(v168.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_269;
        }
LABEL_301:
        if ((SHIBYTE(v167.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_270;
        }
LABEL_302:
        operator delete(v167.__r_.__value_.__l.__data_);
        if (v121 == ++v122) {
          break;
        }
      }
      else
      {
        if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_301;
        }
LABEL_269:
        operator delete(v168.__r_.__value_.__l.__data_);
        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_302;
        }
LABEL_270:
        if (v121 == ++v122) {
          break;
        }
      }
    }
  }
LABEL_303:
  if (!v174) {
    goto LABEL_312;
  }
  *((unsigned char *)&v168.__r_.__value_.__s + 23) = 4;
  strcpy((char *)&v168, "    ");
  uint64_t v137 = std::string::append(&v168, "float4 _color [[ user(primary) ]];\n");
  long long v138 = *(_OWORD *)&v137->__r_.__value_.__l.__data_;
  v183.__r_.__value_.__r.__words[2] = v137->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v138;
  v137->__r_.__value_.__l.__size_ = 0;
  v137->__r_.__value_.__r.__words[2] = 0;
  v137->__r_.__value_.__r.__words[0] = 0;
  if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v139 = &v183;
  }
  else {
    uint64_t v139 = (std::string *)v183.__r_.__value_.__r.__words[0];
  }
  if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v140 = HIBYTE(v183.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v140 = v183.__r_.__value_.__l.__size_;
  }
  std::string::append(&v169, (const std::string::value_type *)v139, v140);
  if (SHIBYTE(v183.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v183.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_312;
    }
  }
  else if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_312;
  }
  operator delete(v168.__r_.__value_.__l.__data_);
LABEL_312:
  std::string::append(&v169, "};\n");
  int v141 = SHIBYTE(v169.__r_.__value_.__r.__words[2]);
  if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v142 = HIBYTE(v169.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t v142 = v169.__r_.__value_.__l.__size_;
  }
  int v143 = SHIBYTE(v172.__r_.__value_.__r.__words[2]);
  if ((v172.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v144 = HIBYTE(v172.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t v144 = v172.__r_.__value_.__l.__size_;
  }
  unint64_t v145 = v144 + v142;
  if (v144 + v142 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v145 <= 0x16)
  {
    memset(&v168, 0, sizeof(v168));
    uint64_t v146 = (char *)&v168;
    *((unsigned char *)&v168.__r_.__value_.__s + 23) = v144 + v142;
    if (!v142) {
      goto LABEL_325;
    }
    goto LABEL_321;
  }
  uint64_t v157 = (v145 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v145 | 7) != 0x17) {
    uint64_t v157 = v145 | 7;
  }
  uint64_t v158 = v157 + 1;
  uint64_t v146 = (char *)operator new(v157 + 1);
  v168.__r_.__value_.__l.__size_ = v144 + v142;
  v168.__r_.__value_.__r.__words[2] = v158 | 0x8000000000000000;
  v168.__r_.__value_.__r.__words[0] = (std::string::size_type)v146;
  if (v142)
  {
LABEL_321:
    if (v141 >= 0) {
      uint64_t v147 = &v169;
    }
    else {
      uint64_t v147 = (std::string *)v169.__r_.__value_.__r.__words[0];
    }
    memmove(v146, v147, v142);
  }
LABEL_325:
  uint64_t v148 = &v146[v142];
  if (v144)
  {
    if (v143 >= 0) {
      unint64_t v149 = &v172;
    }
    else {
      unint64_t v149 = (std::string *)v172.__r_.__value_.__r.__words[0];
    }
    memmove(v148, v149, v144);
  }
  v148[v144] = 0;
  if ((v173.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v150 = &v173;
  }
  else {
    size_t v150 = (std::string *)v173.__r_.__value_.__r.__words[0];
  }
  if ((v173.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v151 = HIBYTE(v173.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v151 = v173.__r_.__value_.__l.__size_;
  }
  uint64_t v152 = std::string::append(&v168, (const std::string::value_type *)v150, v151);
  long long v153 = *(_OWORD *)&v152->__r_.__value_.__l.__data_;
  v183.__r_.__value_.__r.__words[2] = v152->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v153;
  v152->__r_.__value_.__l.__size_ = 0;
  v152->__r_.__value_.__r.__words[2] = 0;
  v152->__r_.__value_.__r.__words[0] = 0;
  if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v154 = &v183;
  }
  else {
    uint64_t v154 = (std::string *)v183.__r_.__value_.__r.__words[0];
  }
  if ((v183.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v155 = HIBYTE(v183.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v155 = v183.__r_.__value_.__l.__size_;
  }
  std::string::append(v164, (const std::string::value_type *)v154, v155);
  if (SHIBYTE(v183.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v183.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_344:
      if ((SHIBYTE(v169.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_345;
      }
      goto LABEL_357;
    }
  }
  else if ((SHIBYTE(v168.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_344;
  }
  operator delete(v168.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v169.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_345:
    if ((SHIBYTE(v170.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_346;
    }
    goto LABEL_358;
  }
LABEL_357:
  operator delete(v169.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v170.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_346:
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_347;
    }
    goto LABEL_359;
  }
LABEL_358:
  operator delete(v170.__r_.__value_.__l.__data_);
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_347:
    if ((SHIBYTE(v172.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_348;
    }
    goto LABEL_360;
  }
LABEL_359:
  operator delete(__dst.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v172.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_348:
    if ((SHIBYTE(v173.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_349;
    }
    goto LABEL_361;
  }
LABEL_360:
  operator delete(v172.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v173.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_349:
    int v156 = *(void ***)&v178[1];
    if (!*(void *)&v178[1]) {
      goto LABEL_362;
    }
    do
    {
LABEL_368:
      int v163 = (void **)*v156;
      if (*((char *)v156 + 47) < 0) {
        operator delete(v156[3]);
      }
      operator delete(v156);
      int v156 = v163;
    }
    while (v163);
    goto LABEL_362;
  }
LABEL_361:
  operator delete(v173.__r_.__value_.__l.__data_);
  int v156 = *(void ***)&v178[1];
  if (*(void *)&v178[1]) {
    goto LABEL_368;
  }
LABEL_362:
  int v159 = *(void **)&v178[0];
  *(void *)&v178[0] = 0;
  if (v159) {
    operator delete(v159);
  }
  int v160 = v180;
  if (v180)
  {
    uint64_t v161 = v181;
    int v162 = v180;
    if (v181 != v180)
    {
      do
      {
        if (*(v161 - 17) < 0) {
          operator delete(*((void **)v161 - 5));
        }
        v161 -= 48;
      }
      while (v161 != v160);
      int v162 = v180;
    }
    int v181 = v160;
    operator delete(v162);
  }
}

void sub_1B7749B48(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 177) < 0)
  {
    operator delete(*(void **)(v1 - 200));
    std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v1 - 152));
    _Unwind_Resume(a1);
  }
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v1 - 152));
  _Unwind_Resume(a1);
}

void sub_1B7749F50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if ((a32 & 0x80000000) == 0) {
    JUMPOUT(0x1B7749F08);
  }
  JUMPOUT(0x1B7749F00);
}

void HGProgramDescriptor::privateEncodeShaderFunction(uint64_t a1, std::string *a2, uint64_t a3, uint64_t a4, unint64_t *a5, long long *a6, void *a7, uint64_t *a8, unsigned char *a9)
{
  uint64_t v9 = a5;
  long long v223 = 0u;
  long long v224 = 0u;
  long long v221 = 0u;
  long long v222 = 0u;
  long long v219 = 0u;
  long long v220 = 0u;
  long long v217 = 0u;
  long long v218 = 0u;
  long long v216 = 0u;
  uint64_t v13 = *(void *)(a1 + 232);
  uint64_t v12 = *(void *)(a1 + 240);
  uint64_t v214 = 0;
  uint64_t v215 = 0;
  std::string __p = 0;
  uint64_t v14 = v12 - v13;
  if (v14)
  {
    unint64_t v15 = v14 / 48;
    if ((unint64_t)(v14 / 48) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    int v17 = operator new(8 * v15);
    std::string __p = v17;
    uint64_t v215 = &v17[v15];
    bzero(v17, 8 * v15);
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v214 = v215;
    if (v15 <= 1) {
      uint64_t v20 = 1;
    }
    else {
      uint64_t v20 = v15;
    }
    while (2)
    {
      uint64_t v21 = *(void *)(a1 + 232);
      switch(*(_DWORD *)(v21 + v18))
      {
        case 5:
          *int v17 = -1;
          goto LABEL_7;
        case 6:
          if (*((void *)&v218 + 1))
          {
            uint64_t v25 = *(void *)(*(void *)(*((void *)&v216 + 1) + (((unint64_t)v218 >> 6) & 0x3FFFFFFFFFFFFF8))
                            + 8 * (v218 & 0x1FF));
            *(void *)&long long v218 = v218 + 1;
            --*((void *)&v218 + 1);
            if ((unint64_t)v218 < 0x400) {
              goto LABEL_51;
            }
            operator delete(**((void ***)&v216 + 1));
            *((void *)&v216 + 1) += 8;
            uint64_t v26 = -512;
            long long v27 = &v218;
          }
          else
          {
            uint64_t v41 = *((void *)&v222 + 1);
            uint64_t v25 = *a8;
            if ((void)v223 == *((void *)&v222 + 1)) {
              uint64_t v42 = 0;
            }
            else {
              uint64_t v42 = (((void)v223 - *((void *)&v222 + 1)) << 6) - 1;
            }
            unint64_t v43 = *((void *)&v224 + 1) + v224;
            if (v42 == *((void *)&v224 + 1) + (void)v224)
            {
              std::deque<unsigned long>::__add_back_capacity(&v222);
              uint64_t v41 = *((void *)&v222 + 1);
              unint64_t v43 = *((void *)&v224 + 1) + v224;
            }
            uint64_t v44 = *((void *)&v219 + 1);
            uint64_t v45 = (((void)v220 - *((void *)&v219 + 1)) << 6) - 1;
            BOOL v157 = (void)v220 == *((void *)&v219 + 1);
            *(void *)(*(void *)(v41 + ((v43 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v43 & 0x1FF)) = *(void *)a6;
            ++*((void *)&v224 + 1);
            if (v157) {
              uint64_t v46 = 0;
            }
            else {
              uint64_t v46 = v45;
            }
            unint64_t v47 = *((void *)&v221 + 1) + v221;
            if (v46 == *((void *)&v221 + 1) + (void)v221)
            {
              std::deque<unsigned long>::__add_back_capacity(&v219);
              uint64_t v44 = *((void *)&v219 + 1);
              unint64_t v47 = *((void *)&v221 + 1) + v221;
            }
            *(void *)(*(void *)(v44 + ((v47 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v47 & 0x1FF)) = *a7;
            ++*((void *)&v221 + 1);
            ++*a7;
            ++*a8;
            long long v27 = a6;
            uint64_t v26 = 1;
          }
          *(void *)v27 += v26;
LABEL_51:
          *int v17 = v25;
          unint64_t v48 = *(void *)(a3 + 8);
          if (v48 >= *(void *)(a3 + 16))
          {
            *(void *)(a3 + 8) = std::vector<HGBinding>::__push_back_slow_path<HGBinding const&>((char **)a3, v21 + v18);
          }
          else
          {
            *(_DWORD *)unint64_t v48 = *(_DWORD *)(v21 + v18);
            float v49 = (std::string *)(v48 + 8);
            std::string::size_type v50 = (const std::string::value_type **)(v21 + v18 + 8);
            if (*(char *)(v21 + v18 + 31) < 0)
            {
              std::string::__init_copy_ctor_external(v49, *v50, *(void *)(v21 + v18 + 16));
            }
            else
            {
              long long v51 = *(_OWORD *)v50;
              *(void *)(v48 + 24) = *(void *)(v21 + v18 + 24);
              *(_OWORD *)&v49->__r_.__value_.__l.__data_ = v51;
            }
            *(_OWORD *)(v48 + 32) = *(_OWORD *)(v21 + v18 + 32);
            *(void *)(a3 + 8) = v48 + 48;
            *(void *)(a3 + 8) = v48 + 48;
          }
          goto LABEL_7;
        case 8:
          if (!*((void *)&v224 + 1))
          {
            uint64_t v34 = *((void *)&v219 + 1);
            uint64_t v22 = *(void *)a6;
            if ((void)v220 == *((void *)&v219 + 1)) {
              uint64_t v35 = 0;
            }
            else {
              uint64_t v35 = (((void)v220 - *((void *)&v219 + 1)) << 6) - 1;
            }
            unint64_t v36 = *((void *)&v221 + 1) + v221;
            if (v35 == *((void *)&v221 + 1) + (void)v221)
            {
              std::deque<unsigned long>::__add_back_capacity(&v219);
              uint64_t v34 = *((void *)&v219 + 1);
              unint64_t v36 = *((void *)&v221 + 1) + v221;
            }
            uint64_t v37 = *((void *)&v216 + 1);
            uint64_t v38 = (((void)v217 - *((void *)&v216 + 1)) << 6) - 1;
            BOOL v157 = (void)v217 == *((void *)&v216 + 1);
            *(void *)(*(void *)(v34 + ((v36 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v36 & 0x1FF)) = *a7;
            ++*((void *)&v221 + 1);
            if (v157) {
              uint64_t v39 = 0;
            }
            else {
              uint64_t v39 = v38;
            }
            unint64_t v40 = *((void *)&v218 + 1) + v218;
            if (v39 == *((void *)&v218 + 1) + (void)v218)
            {
              std::deque<unsigned long>::__add_back_capacity(&v216);
              uint64_t v37 = *((void *)&v216 + 1);
              unint64_t v40 = *((void *)&v218 + 1) + v218;
            }
            *(void *)(*(void *)(v37 + ((v40 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v40 & 0x1FF)) = *a8;
            ++*((void *)&v218 + 1);
            ++*a7;
            ++*a8;
            std::string::size_type v24 = a6;
            uint64_t v23 = 1;
            goto LABEL_37;
          }
          uint64_t v22 = *(void *)(*(void *)(*((void *)&v222 + 1) + (((unint64_t)v224 >> 6) & 0x3FFFFFFFFFFFFF8))
                          + 8 * (v224 & 0x1FF));
          *(void *)&long long v224 = v224 + 1;
          --*((void *)&v224 + 1);
          if ((unint64_t)v224 >= 0x400)
          {
            operator delete(**((void ***)&v222 + 1));
            *((void *)&v222 + 1) += 8;
            uint64_t v23 = -512;
            std::string::size_type v24 = &v224;
LABEL_37:
            *(void *)v24 += v23;
          }
          *int v17 = v22;
LABEL_7:
          v18 += 48;
          ++v17;
          if (!--v20)
          {
            uint64_t v116 = *((void *)&v224 + 1);
            uint64_t v117 = *((void *)&v218 + 1);
            uint64_t v14 = *((void *)&v221 + 1);
            uint64_t v9 = a5;
            goto LABEL_182;
          }
          continue;
        case 9:
          if (*((void *)&v221 + 1))
          {
            uint64_t v28 = *(void *)(*(void *)(*((void *)&v219 + 1) + (((unint64_t)v221 >> 6) & 0x3FFFFFFFFFFFFF8))
                            + 8 * (v221 & 0x1FF));
            *(void *)&long long v221 = v221 + 1;
            --*((void *)&v221 + 1);
            if ((unint64_t)v221 < 0x400)
            {
LABEL_67:
              *int v17 = v28;
              unint64_t v59 = *(void *)(a3 + 8);
              if (v59 >= *(void *)(a3 + 16))
              {
                uint64_t v63 = std::vector<HGBinding>::__push_back_slow_path<HGBinding const&>((char **)a3, v21 + v18);
              }
              else
              {
                *(_DWORD *)unint64_t v59 = *(_DWORD *)(v21 + v18);
                int v60 = (std::string *)(v59 + 8);
                size_t v61 = (const std::string::value_type **)(v21 + v18 + 8);
                if (*(char *)(v21 + v18 + 31) < 0)
                {
                  std::string::__init_copy_ctor_external(v60, *v61, *(void *)(v21 + v18 + 16));
                }
                else
                {
                  long long v62 = *(_OWORD *)v61;
                  *(void *)(v59 + 24) = *(void *)(v21 + v18 + 24);
                  *(_OWORD *)&v60->__r_.__value_.__l.__data_ = v62;
                }
                *(_OWORD *)(v59 + 32) = *(_OWORD *)(v21 + v18 + 32);
                uint64_t v63 = v59 + 48;
                *(void *)(a3 + 8) = v59 + 48;
              }
              *(void *)(a3 + 8) = v63;
              ++v19;
              goto LABEL_7;
            }
            operator delete(**((void ***)&v219 + 1));
            *((void *)&v219 + 1) += 8;
            uint64_t v29 = -512;
            int v30 = &v221;
          }
          else
          {
            uint64_t v52 = *((void *)&v222 + 1);
            uint64_t v28 = *a7;
            if ((void)v223 == *((void *)&v222 + 1)) {
              uint64_t v53 = 0;
            }
            else {
              uint64_t v53 = (((void)v223 - *((void *)&v222 + 1)) << 6) - 1;
            }
            unint64_t v54 = *((void *)&v224 + 1) + v224;
            if (v53 == *((void *)&v224 + 1) + (void)v224)
            {
              std::deque<unsigned long>::__add_back_capacity(&v222);
              uint64_t v52 = *((void *)&v222 + 1);
              unint64_t v54 = *((void *)&v224 + 1) + v224;
            }
            uint64_t v55 = *((void *)&v216 + 1);
            uint64_t v56 = (((void)v217 - *((void *)&v216 + 1)) << 6) - 1;
            BOOL v157 = (void)v217 == *((void *)&v216 + 1);
            *(void *)(*(void *)(v52 + ((v54 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v54 & 0x1FF)) = *(void *)a6;
            ++*((void *)&v224 + 1);
            if (v157) {
              uint64_t v57 = 0;
            }
            else {
              uint64_t v57 = v56;
            }
            unint64_t v58 = *((void *)&v218 + 1) + v218;
            if (v57 == *((void *)&v218 + 1) + (void)v218)
            {
              std::deque<unsigned long>::__add_back_capacity(&v216);
              uint64_t v55 = *((void *)&v216 + 1);
              unint64_t v58 = *((void *)&v218 + 1) + v218;
            }
            *(void *)(*(void *)(v55 + ((v58 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v58 & 0x1FF)) = *a8;
            ++*((void *)&v218 + 1);
            ++*a7;
            ++*a8;
            int v30 = a6;
            uint64_t v29 = 1;
          }
          *(void *)v30 += v29;
          goto LABEL_67;
        case 0xA:
          uint64_t v31 = *(void *)(a1 + 112) + 16 * v19;
          int v32 = *(_DWORD *)v31;
          LODWORD(v206.__r_.__value_.__l.__data_) = *(_DWORD *)v31;
          std::string::size_type v33 = *(void *)(v31 + 8);
          v206.__r_.__value_.__l.__size_ = v33;
          if (v33) {
            (*(void (**)(std::string::size_type))(*(void *)v33 + 16))(v33);
          }
          if (v32 != 3)
          {
            if (v32 != 1)
            {
              if (!v32)
              {
                if (v33)
                {
                  (*(void (**)(std::string::size_type))(*(void *)v33 + 16))(v33);
                  HGProgramDescriptor::privateEncodeShaderFunction(v33, a2, a3, a4, a5, a6, a7, a8, a9);
                  *int v17 = *a5;
                  (*(void (**)(std::string::size_type))(*(void *)v33 + 24))(v33);
                  ++*a5;
LABEL_159:
                  (*(void (**)(std::string::size_type))(*(void *)v33 + 24))(v33);
                  goto LABEL_160;
                }
                ++*a5;
LABEL_160:
                ++v19;
                goto LABEL_7;
              }
LABEL_158:
              ++*a5;
              if (v33) {
                goto LABEL_159;
              }
              goto LABEL_160;
            }
            unint64_t v64 = (*a7)++;
            unint64_t v65 = (*a8)++;
            unint64_t __val = (*(void *)a6)++;
            std::to_string((std::string *)v207, *a5);
            unint64_t v66 = std::string::insert((std::string *)v207, 0, "r");
            long long v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
            v212.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v212.__r_.__value_.__l.__data_ = v67;
            v66->__r_.__value_.__l.__size_ = 0;
            v66->__r_.__value_.__r.__words[2] = 0;
            v66->__r_.__value_.__r.__words[0] = 0;
            if ((v207[23] & 0x80000000) != 0)
            {
              operator delete(*(void **)v207);
              *(void *)uint64_t v207 = *a5;
              if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_73;
              }
            }
            else
            {
              *(void *)uint64_t v207 = *a5;
              if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_73:
                *(std::string *)&v207[8] = v212;
                goto LABEL_102;
              }
            }
            std::string::__init_copy_ctor_external((std::string *)&v207[8], v212.__r_.__value_.__l.__data_, v212.__r_.__value_.__l.__size_);
LABEL_102:
            std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long const,std::string>>(a4, (unint64_t *)v207, (uint64_t)v207);
            if ((v207[31] & 0x80000000) != 0) {
              operator delete(*(void **)&v207[8]);
            }
            *int v17 = *a5;
            *((unsigned char *)&v209.__r_.__value_.__s + 23) = 4;
            strcpy((char *)&v209, "    ");
            unsigned int v81 = std::string::append(&v209, "float4 ");
            long long v82 = *(_OWORD *)&v81->__r_.__value_.__l.__data_;
            v210.__r_.__value_.__r.__words[2] = v81->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v82;
            v81->__r_.__value_.__l.__size_ = 0;
            v81->__r_.__value_.__r.__words[2] = 0;
            v81->__r_.__value_.__r.__words[0] = 0;
            if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v83 = &v212;
            }
            else {
              uint64_t v83 = (std::string *)v212.__r_.__value_.__r.__words[0];
            }
            if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type size = HIBYTE(v212.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type size = v212.__r_.__value_.__l.__size_;
            }
            float v85 = std::string::append(&v210, (const std::string::value_type *)v83, size);
            long long v86 = *(_OWORD *)&v85->__r_.__value_.__l.__data_;
            __dst.__r_.__value_.__r.__words[2] = v85->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v86;
            v85->__r_.__value_.__l.__size_ = 0;
            v85->__r_.__value_.__r.__words[2] = 0;
            v85->__r_.__value_.__r.__words[0] = 0;
            uint64_t v87 = std::string::append(&__dst, " = ");
            long long v88 = *(_OWORD *)&v87->__r_.__value_.__l.__data_;
            *(void *)&v207[16] = *((void *)&v87->__r_.__value_.__l + 2);
            *(_OWORD *)uint64_t v207 = v88;
            v87->__r_.__value_.__l.__size_ = 0;
            v87->__r_.__value_.__r.__words[2] = 0;
            v87->__r_.__value_.__r.__words[0] = 0;
            if (v207[23] >= 0) {
              float v89 = v207;
            }
            else {
              float v89 = *(const std::string::value_type **)v207;
            }
            if (v207[23] >= 0) {
              std::string::size_type v90 = v207[23];
            }
            else {
              std::string::size_type v90 = *(void *)&v207[8];
            }
            std::string::append(a2, v89, v90);
            if ((v207[23] & 0x80000000) != 0)
            {
              operator delete(*(void **)v207);
              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_118:
                if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_119;
                }
                goto LABEL_167;
              }
            }
            else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_118;
            }
            operator delete(__dst.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_119:
              if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_120;
              }
LABEL_168:
              operator delete(v209.__r_.__value_.__l.__data_);
LABEL_120:
              std::to_string(&v210, v64);
              long long v91 = std::string::insert(&v210, 0, "texture");
              long long v92 = *(_OWORD *)&v91->__r_.__value_.__l.__data_;
              __dst.__r_.__value_.__r.__words[2] = v91->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v92;
              v91->__r_.__value_.__l.__size_ = 0;
              v91->__r_.__value_.__r.__words[2] = 0;
              v91->__r_.__value_.__r.__words[0] = 0;
              std::string::size_type v93 = std::string::append(&__dst, ".sample(");
              long long v94 = *(_OWORD *)&v93->__r_.__value_.__l.__data_;
              *(void *)&v207[16] = *((void *)&v93->__r_.__value_.__l + 2);
              *(_OWORD *)uint64_t v207 = v94;
              v93->__r_.__value_.__l.__size_ = 0;
              v93->__r_.__value_.__r.__words[2] = 0;
              v93->__r_.__value_.__r.__words[0] = 0;
              if (v207[23] >= 0) {
                uint64_t v95 = v207;
              }
              else {
                uint64_t v95 = *(const std::string::value_type **)v207;
              }
              if (v207[23] >= 0) {
                std::string::size_type v96 = v207[23];
              }
              else {
                std::string::size_type v96 = *(void *)&v207[8];
              }
              std::string::append(a2, v95, v96);
              if ((v207[23] & 0x80000000) != 0)
              {
                operator delete(*(void **)v207);
                if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
LABEL_128:
                  if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                    goto LABEL_129;
                  }
LABEL_171:
                  operator delete(v210.__r_.__value_.__l.__data_);
LABEL_129:
                  std::to_string(&v210, v65);
                  float v97 = std::string::insert(&v210, 0, "sampler");
                  long long v98 = *(_OWORD *)&v97->__r_.__value_.__l.__data_;
                  __dst.__r_.__value_.__r.__words[2] = v97->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v98;
                  v97->__r_.__value_.__l.__size_ = 0;
                  v97->__r_.__value_.__r.__words[2] = 0;
                  v97->__r_.__value_.__r.__words[0] = 0;
                  uint64_t v99 = std::string::append(&__dst, ", ");
                  long long v100 = *(_OWORD *)&v99->__r_.__value_.__l.__data_;
                  *(void *)&v207[16] = *((void *)&v99->__r_.__value_.__l + 2);
                  *(_OWORD *)uint64_t v207 = v100;
                  v99->__r_.__value_.__l.__size_ = 0;
                  v99->__r_.__value_.__r.__words[2] = 0;
                  v99->__r_.__value_.__r.__words[0] = 0;
                  if (v207[23] >= 0) {
                    int32x2_t v101 = v207;
                  }
                  else {
                    int32x2_t v101 = *(const std::string::value_type **)v207;
                  }
                  if (v207[23] >= 0) {
                    std::string::size_type v102 = v207[23];
                  }
                  else {
                    std::string::size_type v102 = *(void *)&v207[8];
                  }
                  std::string::append(a2, v101, v102);
                  if ((v207[23] & 0x80000000) != 0)
                  {
                    operator delete(*(void **)v207);
                    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                    {
LABEL_137:
                      if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        goto LABEL_138;
                      }
LABEL_174:
                      operator delete(v210.__r_.__value_.__l.__data_);
LABEL_138:
                      std::to_string(&v210, __val);
                      std::string::size_type v103 = std::string::insert(&v210, 0, "vdata._texcoord");
                      long long v104 = *(_OWORD *)&v103->__r_.__value_.__l.__data_;
                      __dst.__r_.__value_.__r.__words[2] = v103->__r_.__value_.__r.__words[2];
                      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v104;
                      v103->__r_.__value_.__l.__size_ = 0;
                      v103->__r_.__value_.__r.__words[2] = 0;
                      v103->__r_.__value_.__r.__words[0] = 0;
                      long long v105 = std::string::append(&__dst, ".xy);\n");
                      long long v106 = *(_OWORD *)&v105->__r_.__value_.__l.__data_;
                      *(void *)&v207[16] = *((void *)&v105->__r_.__value_.__l + 2);
                      *(_OWORD *)uint64_t v207 = v106;
                      v105->__r_.__value_.__l.__size_ = 0;
                      v105->__r_.__value_.__r.__words[2] = 0;
                      v105->__r_.__value_.__r.__words[0] = 0;
                      if (v207[23] >= 0) {
                        std::string::size_type v107 = v207;
                      }
                      else {
                        std::string::size_type v107 = *(const std::string::value_type **)v207;
                      }
                      if (v207[23] >= 0) {
                        std::string::size_type v108 = v207[23];
                      }
                      else {
                        std::string::size_type v108 = *(void *)&v207[8];
                      }
                      std::string::append(a2, v107, v108);
                      if ((v207[23] & 0x80000000) != 0)
                      {
                        operator delete(*(void **)v207);
                        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                        {
LABEL_146:
                          if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                          {
LABEL_147:
                            *(_DWORD *)uint64_t v207 = 9;
                            v207[31] = 18;
                            strcpy(&v207[8], "texture2d< float >");
                            long long v208 = xmmword_1B7E75170;
                            unint64_t v109 = *(void *)(a3 + 8);
                            if (v109 >= *(void *)(a3 + 16))
                            {
                              long long v111 = std::vector<HGBinding>::__push_back_slow_path<HGBinding>((char **)a3, (uint64_t)v207);
                              int v112 = v207[31];
                              *(void *)(a3 + 8) = v111;
                              if (v112 < 0)
                              {
                                operator delete(*(void **)&v207[8]);
                                long long v111 = *(char **)(a3 + 8);
                              }
                            }
                            else
                            {
                              *(_DWORD *)unint64_t v109 = 9;
                              long long v110 = *(_OWORD *)&v207[8];
                              *(void *)(v109 + 24) = *(void *)&v207[24];
                              *(_OWORD *)(v109 + 8) = v110;
                              memset(&v207[8], 0, 24);
                              *(_OWORD *)(v109 + 32) = v208;
                              long long v111 = (char *)(v109 + 48);
                              *(void *)(a3 + 8) = v109 + 48;
                            }
                            *(_DWORD *)uint64_t v207 = 6;
                            v207[31] = 7;
                            strcpy(&v207[8], "sampler");
                            long long v208 = xmmword_1B7E75170;
                            if ((unint64_t)v111 >= *(void *)(a3 + 16))
                            {
                              float v114 = std::vector<HGBinding>::__push_back_slow_path<HGBinding>((char **)a3, (uint64_t)v207);
                              int v115 = v207[31];
                              *(void *)(a3 + 8) = v114;
                              if (v115 < 0)
                              {
                                operator delete(*(void **)&v207[8]);
                                if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                  goto LABEL_158;
                                }
                              }
                              else if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                              {
                                goto LABEL_158;
                              }
                            }
                            else
                            {
                              *(_DWORD *)long long v111 = 6;
                              long long v113 = *(_OWORD *)&v207[8];
                              *((void *)v111 + 3) = *(void *)&v207[24];
                              *(_OWORD *)(v111 + 8) = v113;
                              memset(&v207[8], 0, 24);
                              *((_OWORD *)v111 + 2) = v208;
                              *(void *)(a3 + 8) = v111 + 48;
                              if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                goto LABEL_158;
                              }
                            }
                            std::string::size_type v80 = (void *)v212.__r_.__value_.__r.__words[0];
LABEL_154:
                            operator delete(v80);
                            ++*a5;
                            if (!v33) {
                              goto LABEL_160;
                            }
                            goto LABEL_159;
                          }
LABEL_177:
                          operator delete(v210.__r_.__value_.__l.__data_);
                          goto LABEL_147;
                        }
                      }
                      else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      {
                        goto LABEL_146;
                      }
                      operator delete(__dst.__r_.__value_.__l.__data_);
                      if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        goto LABEL_147;
                      }
                      goto LABEL_177;
                    }
                  }
                  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  {
                    goto LABEL_137;
                  }
                  operator delete(__dst.__r_.__value_.__l.__data_);
                  if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                    goto LABEL_138;
                  }
                  goto LABEL_174;
                }
              }
              else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
                goto LABEL_128;
              }
              operator delete(__dst.__r_.__value_.__l.__data_);
              if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_129;
              }
              goto LABEL_171;
            }
LABEL_167:
            operator delete(v210.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_120;
            }
            goto LABEL_168;
          }
          std::to_string(&v212, *a5);
          int v68 = std::string::insert(&v212, 0, "r");
          long long v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
          *(void *)&v207[16] = *((void *)&v68->__r_.__value_.__l + 2);
          *(_OWORD *)uint64_t v207 = v69;
          v68->__r_.__value_.__l.__size_ = 0;
          v68->__r_.__value_.__r.__words[2] = 0;
          v68->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v212.__r_.__value_.__l.__data_);
          }
          *int v17 = *a5;
          *((unsigned char *)&v209.__r_.__value_.__s + 23) = 4;
          strcpy((char *)&v209, "    ");
          unint64_t v70 = std::string::append(&v209, "float4 ");
          long long v71 = *(_OWORD *)&v70->__r_.__value_.__l.__data_;
          v210.__r_.__value_.__r.__words[2] = v70->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v71;
          v70->__r_.__value_.__l.__size_ = 0;
          v70->__r_.__value_.__r.__words[2] = 0;
          v70->__r_.__value_.__r.__words[0] = 0;
          if (v207[23] >= 0) {
            uint64_t v72 = v207;
          }
          else {
            uint64_t v72 = *(const std::string::value_type **)v207;
          }
          if (v207[23] >= 0) {
            std::string::size_type v73 = v207[23];
          }
          else {
            std::string::size_type v73 = *(void *)&v207[8];
          }
          float v74 = std::string::append(&v210, v72, v73);
          long long v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
          __dst.__r_.__value_.__r.__words[2] = v74->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v75;
          v74->__r_.__value_.__l.__size_ = 0;
          v74->__r_.__value_.__r.__words[2] = 0;
          v74->__r_.__value_.__r.__words[0] = 0;
          std::string::size_type v76 = std::string::append(&__dst, " = ");
          long long v77 = *(_OWORD *)&v76->__r_.__value_.__l.__data_;
          v212.__r_.__value_.__r.__words[2] = v76->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v212.__r_.__value_.__l.__data_ = v77;
          v76->__r_.__value_.__l.__size_ = 0;
          v76->__r_.__value_.__r.__words[2] = 0;
          v76->__r_.__value_.__r.__words[0] = 0;
          if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v78 = &v212;
          }
          else {
            long long v78 = (std::string *)v212.__r_.__value_.__r.__words[0];
          }
          if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v79 = HIBYTE(v212.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v79 = v212.__r_.__value_.__l.__size_;
          }
          std::string::append(a2, (const std::string::value_type *)v78, v79);
          if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v212.__r_.__value_.__l.__data_);
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_90:
              if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_91;
              }
              goto LABEL_163;
            }
          }
          else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_90;
          }
          operator delete(__dst.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_91:
            if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_92:
              std::string::append(a2, "float4(0.0, 0.0, 0.0, 0.0);\n");
              if ((v207[23] & 0x80000000) == 0) {
                goto LABEL_158;
              }
              std::string::size_type v80 = *(void **)v207;
              goto LABEL_154;
            }
LABEL_164:
            operator delete(v209.__r_.__value_.__l.__data_);
            goto LABEL_92;
          }
LABEL_163:
          operator delete(v210.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_92;
          }
          goto LABEL_164;
        case 0xB:
          *int v17 = -1;
          *a9 = 1;
          goto LABEL_7;
        default:
          goto LABEL_7;
      }
    }
  }
  uint64_t v117 = 0;
  uint64_t v116 = 0;
LABEL_182:
  *(void *)a6 -= v116;
  *a8 -= v117;
  *a7 -= v14;
  std::to_string((std::string *)v207, *v9);
  long long v118 = std::string::insert((std::string *)v207, 0, "r");
  long long v119 = *(_OWORD *)&v118->__r_.__value_.__l.__data_;
  v212.__r_.__value_.__r.__words[2] = v118->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v212.__r_.__value_.__l.__data_ = v119;
  v118->__r_.__value_.__l.__size_ = 0;
  v118->__r_.__value_.__r.__words[2] = 0;
  v118->__r_.__value_.__r.__words[0] = 0;
  if ((v207[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)v207);
    *(void *)uint64_t v207 = *v9;
    if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_184;
    }
  }
  else
  {
    *(void *)uint64_t v207 = *v9;
    if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_184:
      *(std::string *)&v207[8] = v212;
      goto LABEL_187;
    }
  }
  std::string::__init_copy_ctor_external((std::string *)&v207[8], v212.__r_.__value_.__l.__data_, v212.__r_.__value_.__l.__size_);
LABEL_187:
  std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long const,std::string>>(a4, (unint64_t *)v207, (uint64_t)v207);
  if ((v207[31] & 0x80000000) != 0) {
    operator delete(*(void **)&v207[8]);
  }
  *((unsigned char *)&v206.__r_.__value_.__s + 23) = 4;
  strcpy((char *)&v206, "    ");
  int v120 = *(char *)(a1 + 215);
  if (v120 >= 0) {
    uint64_t v121 = (const std::string::value_type *)(a1 + 192);
  }
  else {
    uint64_t v121 = *(const std::string::value_type **)(a1 + 192);
  }
  if (v120 >= 0) {
    std::string::size_type v122 = *(unsigned __int8 *)(a1 + 215);
  }
  else {
    std::string::size_type v122 = *(void *)(a1 + 200);
  }
  uint64_t v123 = std::string::append(&v206, v121, v122);
  long long v124 = *(_OWORD *)&v123->__r_.__value_.__l.__data_;
  v209.__r_.__value_.__r.__words[2] = v123->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v209.__r_.__value_.__l.__data_ = v124;
  v123->__r_.__value_.__l.__size_ = 0;
  v123->__r_.__value_.__r.__words[2] = 0;
  v123->__r_.__value_.__r.__words[0] = 0;
  unint64_t v125 = std::string::append(&v209, " ");
  long long v126 = *(_OWORD *)&v125->__r_.__value_.__l.__data_;
  v210.__r_.__value_.__r.__words[2] = v125->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v126;
  v125->__r_.__value_.__l.__size_ = 0;
  v125->__r_.__value_.__r.__words[2] = 0;
  v125->__r_.__value_.__r.__words[0] = 0;
  if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v127 = &v212;
  }
  else {
    uint64_t v127 = (std::string *)v212.__r_.__value_.__r.__words[0];
  }
  if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v128 = HIBYTE(v212.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v128 = v212.__r_.__value_.__l.__size_;
  }
  size_t v129 = std::string::append(&v210, (const std::string::value_type *)v127, v128);
  long long v130 = *(_OWORD *)&v129->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v129->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v130;
  v129->__r_.__value_.__l.__size_ = 0;
  v129->__r_.__value_.__r.__words[2] = 0;
  v129->__r_.__value_.__r.__words[0] = 0;
  int v131 = std::string::append(&__dst, " = ");
  long long v132 = *(_OWORD *)&v131->__r_.__value_.__l.__data_;
  *(void *)&v207[16] = *((void *)&v131->__r_.__value_.__l + 2);
  *(_OWORD *)uint64_t v207 = v132;
  v131->__r_.__value_.__l.__size_ = 0;
  v131->__r_.__value_.__r.__words[2] = 0;
  v131->__r_.__value_.__r.__words[0] = 0;
  if (v207[23] >= 0) {
    string_t v133 = v207;
  }
  else {
    string_t v133 = *(const std::string::value_type **)v207;
  }
  if (v207[23] >= 0) {
    std::string::size_type v134 = v207[23];
  }
  else {
    std::string::size_type v134 = *(void *)&v207[8];
  }
  std::string::append(a2, v133, v134);
  if ((v207[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)v207);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_209:
      if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_210;
      }
      goto LABEL_216;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_209;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_210:
    if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_211;
    }
    goto LABEL_217;
  }
LABEL_216:
  operator delete(v210.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_211:
    if ((SHIBYTE(v206.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_212;
    }
LABEL_218:
    operator delete(v206.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_213;
    }
    goto LABEL_219;
  }
LABEL_217:
  operator delete(v209.__r_.__value_.__l.__data_);
  if (SHIBYTE(v206.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_218;
  }
LABEL_212:
  if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_213:
    *(std::string *)uint64_t v207 = v212;
    goto LABEL_220;
  }
LABEL_219:
  std::string::__init_copy_ctor_external((std::string *)v207, v212.__r_.__value_.__l.__data_, v212.__r_.__value_.__l.__size_);
LABEL_220:
  int v135 = *(char *)(a1 + 87);
  if (v135 >= 0) {
    size_t v136 = *(unsigned __int8 *)(a1 + 87);
  }
  else {
    size_t v136 = *(void *)(a1 + 72);
  }
  unint64_t v137 = v136 + 1;
  if (v136 + 1 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v137 >= 0x17)
  {
    uint64_t v139 = (v137 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v137 | 7) != 0x17) {
      uint64_t v139 = v137 | 7;
    }
    uint64_t v140 = v139 + 1;
    p_dst = (char *)operator new(v139 + 1);
    __dst.__r_.__value_.__l.__size_ = v136 + 1;
    __dst.__r_.__value_.__r.__words[2] = v140 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = (char *)&__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v136 + 1;
    if (!v136) {
      goto LABEL_234;
    }
  }
  if (v135 >= 0) {
    int v141 = (const void *)(a1 + 64);
  }
  else {
    int v141 = *(const void **)(a1 + 64);
  }
  memmove(p_dst, v141, v136);
LABEL_234:
  *(_WORD *)&p_dst[v136] = 40;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v142 = &__dst;
  }
  else {
    size_t v142 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v143 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v143 = __dst.__r_.__value_.__l.__size_;
  }
  std::string::append(a2, (const std::string::value_type *)v142, v143);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
    __dst.__r_.__value_.__s.__data_[0] = 0;
    uint64_t v144 = *(void *)(a1 + 240) - *(void *)(a1 + 232);
    if (!v144) {
      goto LABEL_325;
    }
LABEL_244:
    uint64_t v145 = 0;
    uint64_t v146 = 0;
    uint64_t v147 = 0;
    unint64_t v148 = v144 / 48;
    if (v148 <= 1) {
      uint64_t v149 = 1;
    }
    else {
      uint64_t v149 = v148;
    }
    size_t v150 = "vdata._color";
    while (2)
    {
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v152 = &__dst;
      }
      else {
        uint64_t v152 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v153 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v153 = __dst.__r_.__value_.__l.__size_;
      }
      std::string::append(a2, (const std::string::value_type *)v152, v153);
      MEMORY[0x1BA9BF660](&__dst, ", ");
      uint64_t v154 = *(void *)(a1 + 232);
      std::string::size_type v151 = v150;
      switch(*(_DWORD *)(v154 + v145))
      {
        case 2:
          uint64_t v155 = v154 + v145;
          int v156 = *(_DWORD *)(v154 + v145 + 36);
          if (!*(_DWORD *)(v155 + 40))
          {
            if (((v156 - 1) & 0xFFFFFFFD) != 0) {
              std::string::size_type v151 = "0";
            }
            else {
              std::string::size_type v151 = "0x0";
            }
            goto LABEL_249;
          }
          BOOL v157 = v156 == 4 || v156 == 2;
          if (v157)
          {
            std::operator+<char>();
            if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v158 = &v210;
            }
            else {
              uint64_t v158 = (std::string *)v210.__r_.__value_.__r.__words[0];
            }
            if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v159 = HIBYTE(v210.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v159 = v210.__r_.__value_.__l.__size_;
            }
          }
          else
          {
            std::operator+<char>();
            if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v158 = &v210;
            }
            else {
              uint64_t v158 = (std::string *)v210.__r_.__value_.__r.__words[0];
            }
            if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v159 = HIBYTE(v210.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v159 = v210.__r_.__value_.__l.__size_;
            }
          }
          std::string::append(a2, (const std::string::value_type *)v158, v159);
          if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v210.__r_.__value_.__l.__data_);
            std::string::size_type v151 = "[0]";
            if (*(_DWORD *)(v155 + 40) > 1u) {
              goto LABEL_249;
            }
          }
          else
          {
            std::string::size_type v151 = "[0]";
            if (*(_DWORD *)(v155 + 40) > 1u) {
              goto LABEL_249;
            }
          }
          goto LABEL_250;
        case 5:
          std::string::size_type v151 = "vdata._position";
          goto LABEL_249;
        case 6:
          std::to_string(&v209, *((void *)__p + v147));
          uint64_t v175 = std::string::insert(&v209, 0, "sampler");
          long long v176 = *(_OWORD *)&v175->__r_.__value_.__l.__data_;
          v210.__r_.__value_.__r.__words[2] = v175->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v176;
          v175->__r_.__value_.__l.__size_ = 0;
          v175->__r_.__value_.__r.__words[2] = 0;
          v175->__r_.__value_.__r.__words[0] = 0;
          if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v177 = &v210;
          }
          else {
            long long v177 = (std::string *)v210.__r_.__value_.__r.__words[0];
          }
          if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v178 = HIBYTE(v210.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v178 = v210.__r_.__value_.__l.__size_;
          }
          goto LABEL_304;
        case 8:
          std::to_string(&v209, *((void *)__p + v147));
          long long v179 = std::string::insert(&v209, 0, "vdata._texcoord");
          long long v180 = *(_OWORD *)&v179->__r_.__value_.__l.__data_;
          v210.__r_.__value_.__r.__words[2] = v179->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v180;
          v179->__r_.__value_.__l.__size_ = 0;
          v179->__r_.__value_.__r.__words[2] = 0;
          v179->__r_.__value_.__r.__words[0] = 0;
          if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v177 = &v210;
          }
          else {
            long long v177 = (std::string *)v210.__r_.__value_.__r.__words[0];
          }
          if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v178 = HIBYTE(v210.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v178 = v210.__r_.__value_.__l.__size_;
          }
LABEL_304:
          std::string::append(a2, (const std::string::value_type *)v177, v178);
          if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v210.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_250;
            }
          }
          else if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_250;
          }
          operator delete(v209.__r_.__value_.__l.__data_);
          goto LABEL_250;
        case 9:
          std::to_string(&v209, *((void *)__p + v147));
          int v160 = std::string::insert(&v209, 0, "texture");
          long long v161 = *(_OWORD *)&v160->__r_.__value_.__l.__data_;
          v210.__r_.__value_.__r.__words[2] = v160->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v161;
          v160->__r_.__value_.__l.__size_ = 0;
          v160->__r_.__value_.__r.__words[2] = 0;
          v160->__r_.__value_.__r.__words[0] = 0;
          if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            int v162 = &v210;
          }
          else {
            int v162 = (std::string *)v210.__r_.__value_.__r.__words[0];
          }
          if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v163 = HIBYTE(v210.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v163 = v210.__r_.__value_.__l.__size_;
          }
          std::string::append(a2, (const std::string::value_type *)v162, v163);
          if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v210.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_278;
            }
          }
          else if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_278;
          }
          operator delete(v209.__r_.__value_.__l.__data_);
LABEL_278:
          ++v146;
LABEL_250:
          ++v147;
          v145 += 48;
          if (v149 != v147) {
            continue;
          }
          goto LABEL_325;
        case 0xA:
          int v164 = v150;
          v209.__r_.__value_.__r.__words[0] = 0;
          v209.__r_.__value_.__r.__words[0] = *((void *)__p + v147);
          v210.__r_.__value_.__r.__words[0] = (std::string::size_type)&v209;
          uint64_t v165 = std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(a4, (unint64_t *)&v209, (uint64_t)&std::piecewise_construct, (uint64_t **)&v210);
          std::string v168 = (const std::string::value_type *)v165[3];
          std::string v166 = (const std::string::value_type *)(v165 + 3);
          std::string v167 = v168;
          int v169 = v166[23];
          if (v169 >= 0) {
            std::string v170 = v166;
          }
          else {
            std::string v170 = v167;
          }
          if (v169 >= 0) {
            std::string::size_type v171 = *((unsigned __int8 *)v166 + 23);
          }
          else {
            std::string::size_type v171 = *((void *)v166 + 1);
          }
          std::string::append(a2, v170, v171);
          uint64_t v172 = *(void *)(a1 + 112) + 16 * v146;
          int v173 = *(_DWORD *)v172;
          LODWORD(v210.__r_.__value_.__l.__data_) = *(_DWORD *)v172;
          char v174 = *(_DWORD **)(v172 + 8);
          v210.__r_.__value_.__l.__size_ = (std::string::size_type)v174;
          if (v174)
          {
            (*(void (**)(_DWORD *))(*(void *)v174 + 16))(v174);
            if (!v173)
            {
              (*(void (**)(_DWORD *))(*(void *)v174 + 16))(v174);
              if (v174[46] == 4) {
                std::string::append(a2, ".color0");
              }
              (*(void (**)(_DWORD *))(*(void *)v174 + 24))(v174);
            }
            (*(void (**)(_DWORD *))(*(void *)v174 + 24))(v174);
          }
          ++v146;
          size_t v150 = v164;
          goto LABEL_250;
        case 0xB:
LABEL_249:
          std::string::append(a2, v151);
          goto LABEL_250;
        default:
          goto LABEL_250;
      }
    }
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
  __dst.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v144 = *(void *)(a1 + 240) - *(void *)(a1 + 232);
  if (v144) {
    goto LABEL_244;
  }
LABEL_325:
  std::string::append(a2, ");\n");
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((v207[23] & 0x80000000) == 0)
    {
LABEL_327:
      if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_328;
      }
      goto LABEL_337;
    }
  }
  else if ((v207[23] & 0x80000000) == 0)
  {
    goto LABEL_327;
  }
  operator delete(*(void **)v207);
  if ((SHIBYTE(v212.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_328:
    int v181 = __p;
    if (!__p) {
      goto LABEL_330;
    }
    goto LABEL_329;
  }
LABEL_337:
  operator delete(v212.__r_.__value_.__l.__data_);
  int v181 = __p;
  if (__p) {
LABEL_329:
  }
    operator delete(v181);
LABEL_330:
  unint64_t v182 = (void **)*((void *)&v216 + 1);
  std::string v183 = (void **)v217;
  *((void *)&v218 + 1) = 0;
  unint64_t v184 = v217 - *((void *)&v216 + 1);
  if ((void)v217 - *((void *)&v216 + 1) >= 0x11uLL)
  {
    do
    {
      operator delete(*v182);
      std::string v183 = (void **)v217;
      unint64_t v182 = (void **)(*((void *)&v216 + 1) + 8);
      *((void *)&v216 + 1) = v182;
      unint64_t v184 = v217 - (void)v182;
    }
    while ((void)v217 - (void)v182 > 0x10uLL);
  }
  unint64_t v185 = v184 >> 3;
  if (v185 == 1)
  {
    uint64_t v186 = 256;
    goto LABEL_340;
  }
  if (v185 == 2)
  {
    uint64_t v186 = 512;
LABEL_340:
    *(void *)&long long v218 = v186;
  }
  if (v182 != v183)
  {
    do
    {
      unint64_t v187 = *v182++;
      operator delete(v187);
    }
    while (v182 != v183);
    if ((void)v217 != *((void *)&v216 + 1)) {
      *(void *)&long long v217 = v217 + ((*((void *)&v216 + 1) - v217 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if ((void)v216) {
    operator delete((void *)v216);
  }
  int v188 = (void **)*((void *)&v219 + 1);
  int v189 = (void **)v220;
  *((void *)&v221 + 1) = 0;
  unint64_t v190 = v220 - *((void *)&v219 + 1);
  if ((void)v220 - *((void *)&v219 + 1) >= 0x11uLL)
  {
    do
    {
      operator delete(*v188);
      int v189 = (void **)v220;
      int v188 = (void **)(*((void *)&v219 + 1) + 8);
      *((void *)&v219 + 1) = v188;
      unint64_t v190 = v220 - (void)v188;
    }
    while ((void)v220 - (void)v188 > 0x10uLL);
  }
  unint64_t v191 = v190 >> 3;
  if (v191 == 1)
  {
    uint64_t v192 = 256;
    goto LABEL_353;
  }
  if (v191 == 2)
  {
    uint64_t v192 = 512;
LABEL_353:
    *(void *)&long long v221 = v192;
  }
  if (v188 != v189)
  {
    do
    {
      unint64_t v193 = *v188++;
      operator delete(v193);
    }
    while (v188 != v189);
    if ((void)v220 != *((void *)&v219 + 1)) {
      *(void *)&long long v220 = v220 + ((*((void *)&v219 + 1) - v220 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if ((void)v219) {
    operator delete((void *)v219);
  }
  unint64_t v194 = (void **)*((void *)&v222 + 1);
  size_t v195 = (void **)v223;
  *((void *)&v224 + 1) = 0;
  unint64_t v196 = v223 - *((void *)&v222 + 1);
  if ((void)v223 - *((void *)&v222 + 1) >= 0x11uLL)
  {
    do
    {
      operator delete(*v194);
      size_t v195 = (void **)v223;
      unint64_t v194 = (void **)(*((void *)&v222 + 1) + 8);
      *((void *)&v222 + 1) = v194;
      unint64_t v196 = v223 - (void)v194;
    }
    while ((void)v223 - (void)v194 > 0x10uLL);
  }
  unint64_t v197 = v196 >> 3;
  if (v197 == 1)
  {
    uint64_t v198 = 256;
    goto LABEL_366;
  }
  if (v197 == 2)
  {
    uint64_t v198 = 512;
LABEL_366:
    *(void *)&long long v224 = v198;
  }
  if (v194 != v195)
  {
    do
    {
      unint64_t v199 = *v194++;
      operator delete(v199);
    }
    while (v194 != v195);
    if ((void)v223 != *((void *)&v222 + 1)) {
      *(void *)&long long v223 = v223 + ((*((void *)&v222 + 1) - v223 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if ((void)v222) {
    operator delete((void *)v222);
  }
}

void sub_1B774B9BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50,void *a51)
{
  if (a50 < 0) {
    operator delete(__p);
  }
  std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>::~pair((uint64_t)&a24);
  if (a51) {
    operator delete(a51);
  }
  std::deque<unsigned long>::~deque[abi:ne180100]((void *)(v51 - 240));
  std::deque<unsigned long>::~deque[abi:ne180100]((void *)(v51 - 192));
  std::deque<unsigned long>::~deque[abi:ne180100]((void *)(v51 - 144));
  _Unwind_Resume(a1);
}

const char *HGProgramDescriptor::GetFragmentFunctionName(HGProgramDescriptor *this)
{
  if (*((char *)this + 63) < 0)
  {
    if (*((void *)this + 6)) {
      return (const char *)*((void *)this + 5);
    }
    else {
      return "fragmentFunc";
    }
  }
  else if (*((unsigned char *)this + 63))
  {
    return (char *)this + 40;
  }
  else
  {
    return "fragmentFunc";
  }
}

uint64_t std::unordered_map<unsigned long,std::string>::~unordered_map[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      int v5 = (void **)*v2;
      if (*((char *)v2 + 47) < 0) {
        operator delete(v2[3]);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

void **std::vector<HGBinding>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 17) < 0) {
          operator delete(*(v3 - 5));
        }
        v3 -= 6;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void HGProgramDescriptor::EncodeShaderProgram(uint64_t a1, std::string *this, char *a3)
{
  if (*(char *)(a1 + 87) < 0)
  {
    uint64_t v5 = *(void *)(a1 + 72);
    int v6 = *(char *)(a1 + 111);
    if ((v6 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v6) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 87);
    int v6 = *(char *)(a1 + 111);
    if ((v6 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  if (*(void *)(a1 + 96))
  {
LABEL_4:
    BOOL v7 = 1;
    if (!v5) {
      goto LABEL_23;
    }
    goto LABEL_12;
  }
LABEL_8:
  if (*(char *)(a1 + 183) < 0)
  {
    BOOL v7 = *(void *)(a1 + 168) != 0;
    if (!v5) {
      goto LABEL_23;
    }
  }
  else
  {
    BOOL v7 = *(unsigned char *)(a1 + 183) != 0;
    if (!v5) {
      goto LABEL_23;
    }
  }
LABEL_12:
  if (v7)
  {
    if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v8 = 2070;
    }
    else {
      std::string::size_type v8 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) + 2047;
    }
    std::string::reserve(this, v8);
    *(_OWORD *)std::string __p = 0u;
    *(_OWORD *)int v17 = 0u;
    int v18 = 1065353216;
    HGProgramDescriptor::privateEncodeShaderProgram((uint64_t *)a1, this, (uint64_t)__p);
    uint64_t v9 = (void **)v17[0];
    if (v17[0])
    {
      do
      {
        BOOL v11 = (void **)*v9;
        if (*((char *)v9 + 39) < 0) {
          operator delete(v9[2]);
        }
        operator delete(v9);
        uint64_t v9 = v11;
      }
      while (v11);
    }
    long long v10 = __p[0];
    __p[0] = 0;
    if (v10) {
      operator delete(v10);
    }
    return;
  }
LABEL_23:
  char v12 = *(unsigned char *)(a1 + 159);
  if (v12 < 0)
  {
    if (*(void *)(a1 + 144)) {
      goto LABEL_25;
    }
  }
  else if (*(unsigned char *)(a1 + 159))
  {
LABEL_25:
    if (v12 >= 0) {
      uint64_t v13 = (const std::string::value_type *)(a1 + 136);
    }
    else {
      uint64_t v13 = *(const std::string::value_type **)(a1 + 136);
    }
    if (v12 >= 0) {
      std::string::size_type v14 = *(unsigned __int8 *)(a1 + 159);
    }
    else {
      std::string::size_type v14 = *(void *)(a1 + 144);
    }
    std::string::append(this, v13, v14);
    return;
  }
  unint64_t v15 = (void *)(a1 + 40);
  if (*(char *)(a1 + 63) < 0) {
    unint64_t v15 = (void *)*v15;
  }
  HGLogger::warning((HGLogger *)"Missing fragment shader for %s\n", (const char *)this, a3, v15);
}

void sub_1B774C1D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::unordered_map<std::string,BOOL>::~unordered_map[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *HGProgramDescriptor::privateEncodeShaderProgram(uint64_t *result, std::string *a2, uint64_t a3)
{
  uint64_t v5 = result;
  uint64_t v6 = result[14];
  uint64_t v7 = result[15];
  while (v6 != v7)
  {
    int v8 = *(_DWORD *)v6;
    LODWORD(__p) = *(_DWORD *)v6;
    std::string::size_type v9 = *(void *)(v6 + 8);
    std::string::size_type v20 = v9;
    if (v9)
    {
      (*(void (**)(std::string::size_type))(*(void *)v9 + 16))(v9);
      if (!v8)
      {
        (*(void (**)(std::string::size_type))(*(void *)v9 + 16))(v9);
        HGProgramDescriptor::privateEncodeShaderProgram(v9, a2, a3);
        (*(void (**)(std::string::size_type))(*(void *)v9 + 24))(v9);
      }
      __n128 result = (uint64_t *)(*(uint64_t (**)(std::string::size_type))(*(void *)v9 + 24))(v9);
    }
    v6 += 16;
  }
  if (*((char *)v5 + 183) < 0)
  {
    if (!v5[21]) {
      return result;
    }
  }
  else if (!*((unsigned char *)v5 + 183))
  {
    return result;
  }
  std::string __p = v5 + 8;
  __n128 result = std::__hash_table<std::__hash_value_type<std::string,BOOL>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BOOL>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BOOL>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BOOL>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a3, (uint64_t)(v5 + 8), (uint64_t)&std::piecewise_construct, (long long **)&__p);
  if (!*((unsigned char *)result + 40))
  {
    int v10 = *((char *)v5 + 183);
    if (v10 >= 0) {
      size_t v11 = *((unsigned __int8 *)v5 + 183);
    }
    else {
      size_t v11 = v5[21];
    }
    unint64_t v12 = v11 + 1;
    if (v11 + 1 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v12 >= 0x17)
    {
      uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v12 | 7) != 0x17) {
        uint64_t v14 = v12 | 7;
      }
      uint64_t v15 = v14 + 1;
      p_p = (char *)operator new(v14 + 1);
      std::string::size_type v20 = v11 + 1;
      int64_t v21 = v15 | 0x8000000000000000;
      std::string __p = p_p;
    }
    else
    {
      std::string::size_type v20 = 0;
      int64_t v21 = 0;
      std::string __p = 0;
      p_p = (char *)&__p;
      HIBYTE(v21) = v11 + 1;
      if (!v11)
      {
LABEL_27:
        *(_WORD *)&p_p[v11] = 10;
        if (v21 >= 0) {
          int v17 = (const std::string::value_type *)&__p;
        }
        else {
          int v17 = (const std::string::value_type *)__p;
        }
        if (v21 >= 0) {
          std::string::size_type v18 = HIBYTE(v21);
        }
        else {
          std::string::size_type v18 = v20;
        }
        std::string::append(a2, v17, v18);
        if (SHIBYTE(v21) < 0) {
          operator delete(__p);
        }
        std::string __p = v5 + 8;
        __n128 result = std::__hash_table<std::__hash_value_type<std::string,BOOL>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BOOL>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BOOL>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BOOL>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a3, (uint64_t)(v5 + 8), (uint64_t)&std::piecewise_construct, (long long **)&__p);
        *((unsigned char *)result + 40) = 1;
        return result;
      }
    }
    if (v10 >= 0) {
      int v16 = v5 + 20;
    }
    else {
      int v16 = (const void *)v5[20];
    }
    memmove(p_p, v16, v11);
    goto LABEL_27;
  }
  return result;
}

void sub_1B774C458(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::unordered_map<std::string,BOOL>::~unordered_map[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v5 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

void HGProgramDescriptor::CopyDependencies(HGProgramDescriptor *this)
{
  *(_OWORD *)std::string __p = 0u;
  *(_OWORD *)uint64_t v2 = 0u;
  int v3 = 1065353216;
  operator new();
}

void sub_1B774C5E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *HGProgramDescriptor::privateGetDependencies(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  uint64_t v6 = result[14];
  uint64_t v7 = result[15];
  while (v6 != v7)
  {
    if (!*(_DWORD *)v6)
    {
      uint64_t v8 = *(void *)(v6 + 8);
      if (v8)
      {
        (*(void (**)(void))(*(void *)v8 + 16))(*(void *)(v6 + 8));
        HGProgramDescriptor::privateGetDependencies(v8, a2, a3);
        __n128 result = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 24))(v8);
      }
    }
    v6 += 16;
  }
  if (*((char *)v5 + 87) < 0)
  {
    if (!v5[9]) {
      return result;
    }
  }
  else if (!*((unsigned char *)v5 + 87))
  {
    return result;
  }
  v14.__r_.__value_.__r.__words[0] = (std::string::size_type)(v5 + 8);
  __n128 result = std::__hash_table<std::__hash_value_type<std::string,BOOL>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BOOL>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BOOL>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BOOL>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a3, (uint64_t)(v5 + 8), (uint64_t)&std::piecewise_construct, (long long **)&v14);
  if (!*((unsigned char *)result + 40))
  {
    if (*((char *)v5 + 111) < 0)
    {
      std::string::__init_copy_ctor_external(&v14, (const std::string::value_type *)v5[11], v5[12]);
      if ((*((char *)v5 + 87) & 0x80000000) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      std::string v14 = *(std::string *)(v5 + 11);
      if ((*((char *)v5 + 87) & 0x80000000) == 0)
      {
LABEL_14:
        std::string __p = *(std::string *)(v5 + 8);
LABEL_17:
        unint64_t v9 = *(void *)(a2 + 8);
        if (v9 >= *(void *)(a2 + 16))
        {
          unint64_t v12 = std::vector<HGProgramDescriptor::Dependency>::__push_back_slow_path<HGProgramDescriptor::Dependency>((void **)a2, (uint64_t)&v14);
          int v13 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
          *(void *)(a2 + 8) = v12;
          if (v13 < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          long long v10 = *(_OWORD *)&v14.__r_.__value_.__l.__data_;
          *(void *)(v9 + 16) = *((void *)&v14.__r_.__value_.__l + 2);
          *(_OWORD *)unint64_t v9 = v10;
          memset(&v14, 0, sizeof(v14));
          std::string::size_type v11 = __p.__r_.__value_.__r.__words[2];
          *(_OWORD *)(v9 + 24) = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *(void *)(v9 + 40) = v11;
          memset(&__p, 0, sizeof(__p));
          *(void *)(a2 + 8) = v9 + 48;
        }
        if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v14.__r_.__value_.__l.__data_);
        }
        v14.__r_.__value_.__r.__words[0] = (std::string::size_type)(v5 + 8);
        __n128 result = std::__hash_table<std::__hash_value_type<std::string,BOOL>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BOOL>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BOOL>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BOOL>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a3, (uint64_t)(v5 + 8), (uint64_t)&std::piecewise_construct, (long long **)&v14);
        *((unsigned char *)result + 40) = 1;
        return result;
      }
    }
    std::string::__init_copy_ctor_external(&__p, (const std::string::value_type *)v5[8], v5[9]);
    goto LABEL_17;
  }
  return result;
}

void sub_1B774C828(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void HGProgramDescriptor::Dependency::~Dependency(void **this)
{
  if ((*((char *)this + 47) & 0x80000000) == 0)
  {
    if ((*((char *)this + 23) & 0x80000000) == 0) {
      return;
    }
LABEL_5:
    operator delete(*this);
    return;
  }
  operator delete(this[3]);
  if (*((char *)this + 23) < 0) {
    goto LABEL_5;
  }
}

uint64_t HGProgramDescriptor::GetSignature@<X0>(HGProgramDescriptor *this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 20) = 0u;
  *(_OWORD *)(a2 + 4) = 0u;
  *(_DWORD *)a2 = 396048;
  *(unsigned char *)(a2 + 42) = 1;
  return HGProgramDescriptor::privateGetSignature((uint64_t)this, (HGLimits *)a2);
}

uint64_t HGProgramDescriptor::privateGetSignature(uint64_t this, HGLimits *a2)
{
  int v3 = (void *)this;
  uint64_t v4 = *(int **)(this + 112);
  uint64_t v5 = *(int **)(this + 120);
  while (v4 != v5)
  {
    int v6 = *v4;
    uint64_t v7 = (HGProgramDescriptor *)*((void *)v4 + 1);
    if (v7) {
      this = (*(uint64_t (**)(HGProgramDescriptor *))(*(void *)v7 + 16))(v7);
    }
    if (v6 == 1)
    {
      ++*((_WORD *)a2 + 18);
      ++*((unsigned char *)a2 + 40);
LABEL_3:
      if (!v7) {
        goto LABEL_5;
      }
LABEL_4:
      this = (*(uint64_t (**)(HGProgramDescriptor *))(*(void *)v7 + 24))(v7);
      goto LABEL_5;
    }
    if (v6) {
      goto LABEL_3;
    }
    if (v7)
    {
      (*(void (**)(HGProgramDescriptor *))(*(void *)v7 + 16))(v7);
      HGProgramDescriptor::privateGetSignature(v7, a2);
      (*(void (**)(HGProgramDescriptor *))(*(void *)v7 + 24))(v7);
      goto LABEL_4;
    }
LABEL_5:
    v4 += 4;
  }
  uint64_t v8 = v3[29];
  uint64_t v9 = v3[30];
  if (v8 == v9)
  {
    int v15 = *((_DWORD *)a2 + 11);
  }
  else
  {
    int v10 = 0;
    int v11 = *((unsigned __int16 *)a2 + 18);
    int v12 = *((_DWORD *)a2 + 3);
    int v13 = *((unsigned __int16 *)a2 + 16);
    int v14 = *((unsigned __int16 *)a2 + 11);
    int v15 = *((_DWORD *)a2 + 11);
    this = 1;
    int v16 = *((unsigned __int8 *)a2 + 40);
    do
    {
      switch(*(_DWORD *)v8)
      {
        case 2:
          v14 += *(unsigned __int16 *)(v8 + 40);
          *((_WORD *)a2 + 11) = v14;
          v15 += *(_DWORD *)(v8 + 44);
          *((_DWORD *)a2 + 11) = v15;
          break;
        case 3:
          *((unsigned char *)a2 + 41) = 1;
          break;
        case 7:
          int v17 = (_DWORD *)v3[32];
          std::string::size_type v18 = (_DWORD *)v3[33];
          while (v17 != v18)
          {
            if (*v17 == 8) {
              *((_WORD *)a2 + 18) = ++v11;
            }
            v17 += 12;
          }
          break;
        case 8:
          *((_WORD *)a2 + 18) = ++v11;
          break;
        case 9:
          *((unsigned char *)a2 + 40) = ++v16;
          ++v10;
          break;
        case 0xA:
          v12 |= 1 << v10;
          *((_DWORD *)a2 + 3) = v12;
          ++v10;
          break;
        case 0xB:
          v13 |= 0x200u;
          *((_WORD *)a2 + 16) = v13;
          break;
        default:
          break;
      }
      v8 += 48;
    }
    while (v8 != v9);
  }
  *((_DWORD *)a2 + 11) = (v15 + 15) & 0xFFFFFFF0;
  return this;
}

void sub_1B774CB64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
  std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>::~pair((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HGProgramDescriptor::SetFragmentFunctionName(HGProgramDescriptor *this, const char *a2)
{
}

void HGProgramDescriptor::SetVertexFunctionName(HGProgramDescriptor *this, const char *a2)
{
}

uint64_t HGProgramDescriptor::GetMetalLibPath(HGProgramDescriptor *this)
{
  uint64_t result = (uint64_t)this + 88;
  if (*((char *)this + 111) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t HGProgramDescriptor::GetVertexFunctionName(HGProgramDescriptor *this)
{
  uint64_t result = (uint64_t)this + 16;
  if (*((char *)this + 39) < 0) {
    return *(void *)result;
  }
  return result;
}

unint64_t HGProgramDescriptor::GetHash(HGProgramDescriptor *this, const char *a2, char *a3)
{
  int v4 = *((char *)this + 87);
  if (v4 < 0)
  {
    uint64_t v5 = *((void *)this + 9);
    int v6 = *((char *)this + 111);
    if ((v6 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v6) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v5 = *((unsigned __int8 *)this + 87);
    int v6 = *((char *)this + 111);
    if ((v6 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  if (*((void *)this + 12))
  {
LABEL_4:
    BOOL v7 = 1;
    if (!v5) {
      goto LABEL_166;
    }
LABEL_12:
    if (!v7) {
      goto LABEL_166;
    }
    std::string v206 = 0;
    uint64_t v207 = 0;
    long long v208 = 0;
    uint64_t v8 = *((void *)this + 15) - *((void *)this + 14);
    if (v8)
    {
      unint64_t v9 = 0;
      if ((unint64_t)(v8 >> 4) <= 1) {
        uint64_t v10 = 1;
      }
      else {
        uint64_t v10 = v8 >> 4;
      }
      uint64_t v200 = v10;
      while (2)
      {
        uint64_t v12 = *((void *)this + 14) + 16 * v9;
        int v13 = *(_DWORD *)v12;
        int v204 = *(_DWORD *)v12;
        int v14 = *(HGProgramDescriptor **)(v12 + 8);
        unint64_t v205 = v14;
        if (v14) {
          (*(void (**)(HGProgramDescriptor *))(*(void *)v14 + 16))(v14);
        }
        switch(v13)
        {
          case 0:
            if (!v14) {
              goto LABEL_21;
            }
            (*(void (**)(HGProgramDescriptor *))(*(void *)v14 + 16))(v14);
            std::to_string(&v201, v9);
            int v15 = std::string::insert(&v201, 0, "Pointer");
            long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
            int64_t v203 = v15->__r_.__value_.__r.__words[2];
            *(_OWORD *)std::string __p = v16;
            v15->__r_.__value_.__l.__size_ = 0;
            v15->__r_.__value_.__r.__words[2] = 0;
            v15->__r_.__value_.__r.__words[0] = 0;
            if (v203 >= 0) {
              int v17 = (uint64_t *)__p;
            }
            else {
              int v17 = (uint64_t *)__p[0];
            }
            if (v203 >= 0) {
              unint64_t v18 = HIBYTE(v203);
            }
            else {
              unint64_t v18 = (unint64_t)__p[1];
            }
            unint64_t v19 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v209, v17, v18);
            unint64_t v20 = v19;
            int64_t v21 = v207;
            if (v207 < v208)
            {
              *(void *)uint64_t v207 = v19;
              uint64_t v22 = (uint64_t)(v21 + 8);
              goto LABEL_141;
            }
            unint64_t v54 = (char *)v206;
            int64_t v55 = v207 - (unsigned char *)v206;
            uint64_t v56 = (v207 - (unsigned char *)v206) >> 3;
            unint64_t v57 = v56 + 1;
            if ((unint64_t)(v56 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v58 = v208 - (unsigned char *)v206;
            if ((v208 - (unsigned char *)v206) >> 2 > v57) {
              unint64_t v57 = v58 >> 2;
            }
            if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v59 = v57;
            }
            if (v59)
            {
              if (v59 >> 61) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              int v60 = (char *)operator new(8 * v59);
              size_t v61 = (unint64_t *)&v60[8 * v56];
              *size_t v61 = v20;
              uint64_t v22 = (uint64_t)(v61 + 1);
              if (v21 == v54) {
                goto LABEL_139;
              }
            }
            else
            {
              int v60 = 0;
              size_t v61 = (unint64_t *)(8 * v56);
              *(void *)(8 * v56) = v20;
              uint64_t v22 = 8 * v56 + 8;
              if (v21 == v54)
              {
LABEL_139:
                std::string v206 = v61;
                uint64_t v207 = (char *)v22;
                long long v208 = &v60[8 * v59];
                if (v54) {
                  operator delete(v54);
                }
LABEL_141:
                uint64_t v207 = (char *)v22;
                if (SHIBYTE(v203) < 0)
                {
                  operator delete(__p[0]);
                  if ((SHIBYTE(v201.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                    goto LABEL_143;
                  }
                }
                else if ((SHIBYTE(v201.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
                  goto LABEL_143;
                }
                operator delete(v201.__r_.__value_.__l.__data_);
LABEL_143:
                uint64_t Hash = HGProgramDescriptor::GetHash(v14);
                uint64_t v102 = Hash;
                std::string::size_type v103 = v207;
                if (v207 < v208)
                {
                  *(void *)uint64_t v207 = Hash;
                  uint64_t v11 = (uint64_t)(v103 + 8);
                  uint64_t v10 = v200;
LABEL_19:
                  uint64_t v207 = (char *)v11;
                  (*(void (**)(HGProgramDescriptor *))(*(void *)v14 + 24))(v14);
                  goto LABEL_20;
                }
                long long v104 = (char *)v206;
                int64_t v105 = v207 - (unsigned char *)v206;
                uint64_t v106 = (v207 - (unsigned char *)v206) >> 3;
                unint64_t v107 = v106 + 1;
                if ((unint64_t)(v106 + 1) >> 61) {
                  std::vector<double>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v108 = v208 - (unsigned char *)v206;
                if ((v208 - (unsigned char *)v206) >> 2 > v107) {
                  unint64_t v107 = v108 >> 2;
                }
                if ((unint64_t)v108 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v109 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v109 = v107;
                }
                if (v109)
                {
                  if (v109 >> 61) {
                    std::__throw_bad_array_new_length[abi:ne180100]();
                  }
                  long long v110 = (char *)operator new(8 * v109);
                  long long v111 = (uint64_t *)&v110[8 * v106];
                  *long long v111 = v102;
                  uint64_t v11 = (uint64_t)(v111 + 1);
                  if (v103 != v104)
                  {
LABEL_153:
                    unint64_t v112 = v103 - 8 - v104;
                    if (v112 >= 0x58)
                    {
                      unint64_t v113 = v103 - &v110[v105];
                      uint64_t v10 = v200;
                      if (v113 >= 0x20)
                      {
                        uint64_t v114 = (v112 >> 3) + 1;
                        uint64_t v115 = 8 * (v114 & 0x3FFFFFFFFFFFFFFCLL);
                        uint64_t v116 = &v103[-v115];
                        long long v111 = (uint64_t *)((char *)v111 - v115);
                        uint64_t v117 = &v110[8 * v106 - 16];
                        long long v118 = v103 - 16;
                        uint64_t v119 = v114 & 0x3FFFFFFFFFFFFFFCLL;
                        do
                        {
                          long long v120 = *(_OWORD *)v118;
                          *((_OWORD *)v117 - 1) = *((_OWORD *)v118 - 1);
                          *(_OWORD *)uint64_t v117 = v120;
                          v117 -= 32;
                          v118 -= 32;
                          v119 -= 4;
                        }
                        while (v119);
                        std::string::size_type v103 = v116;
                        if (v114 == (v114 & 0x3FFFFFFFFFFFFFFCLL))
                        {
LABEL_164:
                          std::string v206 = v111;
                          uint64_t v207 = (char *)v11;
                          long long v208 = &v110[8 * v109];
                          if (v104) {
                            operator delete(v104);
                          }
                          goto LABEL_19;
                        }
                      }
                    }
                    else
                    {
                      uint64_t v10 = v200;
                    }
                    do
                    {
                      uint64_t v121 = *((void *)v103 - 1);
                      v103 -= 8;
                      *--long long v111 = v121;
                    }
                    while (v103 != v104);
                    goto LABEL_164;
                  }
                }
                else
                {
                  long long v110 = 0;
                  long long v111 = (uint64_t *)(8 * v106);
                  *(void *)(8 * v106) = v102;
                  uint64_t v11 = 8 * v106 + 8;
                  if (v103 != v104) {
                    goto LABEL_153;
                  }
                }
                uint64_t v10 = v200;
                goto LABEL_164;
              }
            }
            unint64_t v92 = v21 - 8 - v54;
            if (v92 < 0x58) {
              goto LABEL_297;
            }
            if ((unint64_t)(v21 - &v60[v55]) < 0x20) {
              goto LABEL_297;
            }
            uint64_t v93 = (v92 >> 3) + 1;
            uint64_t v94 = 8 * (v93 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v95 = &v21[-v94];
            size_t v61 = (unint64_t *)((char *)v61 - v94);
            std::string::size_type v96 = &v60[8 * v56 - 16];
            float v97 = v21 - 16;
            uint64_t v98 = v93 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v99 = *(_OWORD *)v97;
              *((_OWORD *)v96 - 1) = *((_OWORD *)v97 - 1);
              *(_OWORD *)std::string::size_type v96 = v99;
              v96 -= 32;
              v97 -= 32;
              v98 -= 4;
            }
            while (v98);
            int64_t v21 = v95;
            if (v93 != (v93 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_297:
              do
              {
                unint64_t v100 = *((void *)v21 - 1);
                v21 -= 8;
                *--size_t v61 = v100;
              }
              while (v21 != v54);
            }
            goto LABEL_139;
          case 1:
            std::to_string(&v201, v9);
            uint64_t v46 = std::string::insert(&v201, 0, "Sampler");
            long long v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
            int64_t v203 = v46->__r_.__value_.__r.__words[2];
            *(_OWORD *)std::string __p = v47;
            v46->__r_.__value_.__l.__size_ = 0;
            v46->__r_.__value_.__r.__words[2] = 0;
            v46->__r_.__value_.__r.__words[0] = 0;
            if (v203 >= 0) {
              unint64_t v48 = (uint64_t *)__p;
            }
            else {
              unint64_t v48 = (uint64_t *)__p[0];
            }
            if (v203 >= 0) {
              unint64_t v49 = HIBYTE(v203);
            }
            else {
              unint64_t v49 = (unint64_t)__p[1];
            }
            unint64_t v27 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v209, v48, v49);
            uint64_t v28 = (unint64_t *)v207;
            if (v207 < v208) {
              goto LABEL_75;
            }
            uint64_t v29 = (unint64_t *)v206;
            int64_t v50 = v207 - (unsigned char *)v206;
            uint64_t v51 = (v207 - (unsigned char *)v206) >> 3;
            unint64_t v52 = v51 + 1;
            if ((unint64_t)(v51 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v53 = v208 - (unsigned char *)v206;
            if ((v208 - (unsigned char *)v206) >> 2 > v52) {
              unint64_t v52 = v53 >> 2;
            }
            if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v34 = v52;
            }
            if (v34)
            {
              if (v34 >> 61) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              uint64_t v35 = operator new(8 * v34);
              unint64_t v36 = (unint64_t *)&v35[8 * v51];
              *unint64_t v36 = v27;
              uint64_t v37 = (uint64_t)(v36 + 1);
              if (v28 == v29) {
                goto LABEL_105;
              }
            }
            else
            {
              uint64_t v35 = 0;
              unint64_t v36 = (unint64_t *)(8 * v51);
              *(void *)(8 * v51) = v27;
              uint64_t v37 = 8 * v51 + 8;
              if (v28 == v29) {
                goto LABEL_105;
              }
            }
            unint64_t v64 = (char *)(v28 - 1) - (char *)v29;
            if (v64 < 0x58)
            {
              uint64_t v10 = v200;
              do
              {
LABEL_122:
                unint64_t v91 = *--v28;
                *--unint64_t v36 = v91;
              }
              while (v28 != v29);
              goto LABEL_123;
            }
            unint64_t v83 = (char *)v28 - &v35[v50];
            uint64_t v10 = v200;
            if (v83 < 0x20) {
              goto LABEL_122;
            }
            uint64_t v84 = (v64 >> 3) + 1;
            uint64_t v85 = 8 * (v84 & 0x3FFFFFFFFFFFFFFCLL);
            long long v86 = &v28[v85 / 0xFFFFFFFFFFFFFFF8];
            unint64_t v36 = (unint64_t *)((char *)v36 - v85);
            uint64_t v87 = &v35[8 * v51 - 16];
            long long v88 = v28 - 2;
            uint64_t v89 = v84 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v90 = *(_OWORD *)v88;
              *(v87 - 1) = *((_OWORD *)v88 - 1);
              *uint64_t v87 = v90;
              v87 -= 2;
              v88 -= 4;
              v89 -= 4;
            }
            while (v89);
            uint64_t v28 = v86;
            if (v84 != (v84 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_122;
            }
            goto LABEL_123;
          case 2:
            std::to_string(&v201, v9);
            uint64_t v23 = std::string::insert(&v201, 0, "Ignore");
            long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
            int64_t v203 = v23->__r_.__value_.__r.__words[2];
            *(_OWORD *)std::string __p = v24;
            v23->__r_.__value_.__l.__size_ = 0;
            v23->__r_.__value_.__r.__words[2] = 0;
            v23->__r_.__value_.__r.__words[0] = 0;
            if (v203 >= 0) {
              uint64_t v25 = (uint64_t *)__p;
            }
            else {
              uint64_t v25 = (uint64_t *)__p[0];
            }
            if (v203 >= 0) {
              unint64_t v26 = HIBYTE(v203);
            }
            else {
              unint64_t v26 = (unint64_t)__p[1];
            }
            unint64_t v27 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v209, v25, v26);
            uint64_t v28 = (unint64_t *)v207;
            if (v207 < v208) {
              goto LABEL_75;
            }
            uint64_t v29 = (unint64_t *)v206;
            int64_t v30 = v207 - (unsigned char *)v206;
            uint64_t v31 = (v207 - (unsigned char *)v206) >> 3;
            unint64_t v32 = v31 + 1;
            if ((unint64_t)(v31 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v33 = v208 - (unsigned char *)v206;
            if ((v208 - (unsigned char *)v206) >> 2 > v32) {
              unint64_t v32 = v33 >> 2;
            }
            if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v34 = v32;
            }
            if (v34)
            {
              if (v34 >> 61) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              uint64_t v35 = operator new(8 * v34);
              unint64_t v36 = (unint64_t *)&v35[8 * v31];
              *unint64_t v36 = v27;
              uint64_t v37 = (uint64_t)(v36 + 1);
              if (v28 == v29) {
                goto LABEL_105;
              }
            }
            else
            {
              uint64_t v35 = 0;
              unint64_t v36 = (unint64_t *)(8 * v31);
              *(void *)(8 * v31) = v27;
              uint64_t v37 = 8 * v31 + 8;
              if (v28 == v29) {
                goto LABEL_105;
              }
            }
            unint64_t v62 = (char *)(v28 - 1) - (char *)v29;
            if (v62 < 0x58)
            {
              uint64_t v10 = v200;
              do
              {
LABEL_110:
                unint64_t v73 = *--v28;
                *--unint64_t v36 = v73;
              }
              while (v28 != v29);
              goto LABEL_123;
            }
            unint64_t v65 = (char *)v28 - &v35[v30];
            uint64_t v10 = v200;
            if (v65 < 0x20) {
              goto LABEL_110;
            }
            uint64_t v66 = (v62 >> 3) + 1;
            uint64_t v67 = 8 * (v66 & 0x3FFFFFFFFFFFFFFCLL);
            int v68 = &v28[v67 / 0xFFFFFFFFFFFFFFF8];
            unint64_t v36 = (unint64_t *)((char *)v36 - v67);
            long long v69 = &v35[8 * v31 - 16];
            unint64_t v70 = v28 - 2;
            uint64_t v71 = v66 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *(_OWORD *)v70;
              *(v69 - 1) = *((_OWORD *)v70 - 1);
              _OWORD *v69 = v72;
              v69 -= 2;
              v70 -= 4;
              v71 -= 4;
            }
            while (v71);
            uint64_t v28 = v68;
            if (v66 != (v66 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_110;
            }
            goto LABEL_123;
          case 3:
            std::to_string(&v201, v9);
            uint64_t v38 = std::string::insert(&v201, 0, "Zero");
            long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
            int64_t v203 = v38->__r_.__value_.__r.__words[2];
            *(_OWORD *)std::string __p = v39;
            v38->__r_.__value_.__l.__size_ = 0;
            v38->__r_.__value_.__r.__words[2] = 0;
            v38->__r_.__value_.__r.__words[0] = 0;
            if (v203 >= 0) {
              unint64_t v40 = (uint64_t *)__p;
            }
            else {
              unint64_t v40 = (uint64_t *)__p[0];
            }
            if (v203 >= 0) {
              unint64_t v41 = HIBYTE(v203);
            }
            else {
              unint64_t v41 = (unint64_t)__p[1];
            }
            unint64_t v27 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v209, v40, v41);
            uint64_t v28 = (unint64_t *)v207;
            if (v207 < v208)
            {
LABEL_75:
              *uint64_t v28 = v27;
              uint64_t v37 = (uint64_t)(v28 + 1);
              goto LABEL_125;
            }
            uint64_t v29 = (unint64_t *)v206;
            int64_t v42 = v207 - (unsigned char *)v206;
            uint64_t v43 = (v207 - (unsigned char *)v206) >> 3;
            unint64_t v44 = v43 + 1;
            if ((unint64_t)(v43 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v45 = v208 - (unsigned char *)v206;
            if ((v208 - (unsigned char *)v206) >> 2 > v44) {
              unint64_t v44 = v45 >> 2;
            }
            if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v34 = v44;
            }
            if (v34)
            {
              if (v34 >> 61) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              uint64_t v35 = operator new(8 * v34);
              unint64_t v36 = (unint64_t *)&v35[8 * v43];
              *unint64_t v36 = v27;
              uint64_t v37 = (uint64_t)(v36 + 1);
              if (v28 == v29)
              {
LABEL_105:
                uint64_t v10 = v200;
                goto LABEL_123;
              }
            }
            else
            {
              uint64_t v35 = 0;
              unint64_t v36 = (unint64_t *)(8 * v43);
              *(void *)(8 * v43) = v27;
              uint64_t v37 = 8 * v43 + 8;
              if (v28 == v29) {
                goto LABEL_105;
              }
            }
            unint64_t v63 = (char *)(v28 - 1) - (char *)v29;
            if (v63 < 0x58)
            {
              uint64_t v10 = v200;
              do
              {
LABEL_116:
                unint64_t v82 = *--v28;
                *--unint64_t v36 = v82;
              }
              while (v28 != v29);
              goto LABEL_123;
            }
            unint64_t v74 = (char *)v28 - &v35[v42];
            uint64_t v10 = v200;
            if (v74 < 0x20) {
              goto LABEL_116;
            }
            uint64_t v75 = (v63 >> 3) + 1;
            uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
            long long v77 = &v28[v76 / 0xFFFFFFFFFFFFFFF8];
            unint64_t v36 = (unint64_t *)((char *)v36 - v76);
            long long v78 = &v35[8 * v43 - 16];
            std::string::size_type v79 = v28 - 2;
            uint64_t v80 = v75 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v81 = *(_OWORD *)v79;
              *(v78 - 1) = *((_OWORD *)v79 - 1);
              _OWORD *v78 = v81;
              v78 -= 2;
              v79 -= 4;
              v80 -= 4;
            }
            while (v80);
            uint64_t v28 = v77;
            if (v75 != (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_116;
            }
LABEL_123:
            std::string v206 = v36;
            uint64_t v207 = (char *)v37;
            long long v208 = &v35[8 * v34];
            if (v29) {
              operator delete(v29);
            }
LABEL_125:
            uint64_t v207 = (char *)v37;
            if (SHIBYTE(v203) < 0)
            {
              operator delete(__p[0]);
              if ((SHIBYTE(v201.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_127:
                if (v14) {
                  goto LABEL_20;
                }
                goto LABEL_21;
              }
            }
            else if ((SHIBYTE(v201.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_127;
            }
            operator delete(v201.__r_.__value_.__l.__data_);
            if (v14) {
LABEL_20:
            }
              (*(void (**)(HGProgramDescriptor *))(*(void *)v14 + 24))(v14);
LABEL_21:
            if (++v9 != v10) {
              continue;
            }
            LOBYTE(v4) = *((unsigned char *)this + 87);
            if ((v4 & 0x80) == 0) {
              goto LABEL_176;
            }
            goto LABEL_199;
          default:
            goto LABEL_127;
        }
      }
    }
    if ((v4 & 0x80) != 0)
    {
LABEL_199:
      if (!*((void *)this + 9))
      {
LABEL_200:
        char v142 = *((unsigned char *)this + 63);
        if (v142 < 0)
        {
          if (*((void *)this + 6)) {
            goto LABEL_202;
          }
        }
        else if (*((unsigned char *)this + 63))
        {
LABEL_202:
          if (v142 >= 0) {
            std::string::size_type v143 = (uint64_t *)((char *)this + 40);
          }
          else {
            std::string::size_type v143 = (uint64_t *)*((void *)this + 5);
          }
          if (v142 >= 0) {
            unint64_t v144 = *((unsigned __int8 *)this + 63);
          }
          else {
            unint64_t v144 = *((void *)this + 6);
          }
          unint64_t v128 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)__p, v143, v144);
          size_t v129 = (unint64_t *)v207;
          if (v207 < v208) {
            goto LABEL_209;
          }
          long long v130 = (unint64_t *)v206;
          int64_t v163 = v207 - (unsigned char *)v206;
          uint64_t v164 = (v207 - (unsigned char *)v206) >> 3;
          unint64_t v165 = v164 + 1;
          if ((unint64_t)(v164 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v166 = v208 - (unsigned char *)v206;
          if ((v208 - (unsigned char *)v206) >> 2 > v165) {
            unint64_t v165 = v166 >> 2;
          }
          if ((unint64_t)v166 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v167 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v167 = v165;
          }
          if (v167)
          {
            if (v167 >> 61) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            std::string v168 = operator new(8 * v167);
            unint64_t v137 = (unint64_t *)&v168[8 * v164];
            long long v138 = &v168[8 * v167];
            *unint64_t v137 = v128;
            uint64_t v139 = (uint64_t)(v137 + 1);
            int64_t v169 = (char *)v129 - (char *)v130;
            if (v129 == v130) {
              goto LABEL_272;
            }
            goto LABEL_266;
          }
          std::string v168 = 0;
          unint64_t v137 = (unint64_t *)(8 * v164);
          long long v138 = 0;
          *(void *)(8 * v164) = v128;
          uint64_t v139 = 8 * v164 + 8;
          int64_t v169 = (char *)v129 - (char *)v130;
          if (v129 != v130)
          {
LABEL_266:
            unint64_t v191 = v169 - 8;
            if (v191 < 0x58) {
              goto LABEL_298;
            }
            if ((unint64_t)((char *)v129 - v168 - v163) < 0x20) {
              goto LABEL_298;
            }
            uint64_t v192 = (v191 >> 3) + 1;
            uint64_t v193 = 8 * (v192 & 0x3FFFFFFFFFFFFFFCLL);
            unint64_t v194 = &v129[v193 / 0xFFFFFFFFFFFFFFF8];
            unint64_t v137 = (unint64_t *)((char *)v137 - v193);
            size_t v195 = &v168[8 * v164 - 16];
            unint64_t v196 = v129 - 2;
            uint64_t v197 = v192 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v198 = *(_OWORD *)v196;
              *(v195 - 1) = *((_OWORD *)v196 - 1);
              _OWORD *v195 = v198;
              v195 -= 2;
              v196 -= 4;
              v197 -= 4;
            }
            while (v197);
            size_t v129 = v194;
            if (v192 != (v192 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_298:
              do
              {
                unint64_t v199 = *--v129;
                *--unint64_t v137 = v199;
              }
              while (v129 != v130);
            }
          }
LABEL_272:
          std::string v206 = v137;
          uint64_t v207 = (char *)v139;
          long long v208 = v138;
          if (v130) {
            operator delete(v130);
          }
LABEL_274:
          uint64_t v207 = (char *)v139;
          unint64_t v145 = *((unsigned __int8 *)this + 111);
          if (*((char *)this + 111) < 0)
          {
LABEL_275:
            if (!*((void *)this + 12))
            {
LABEL_276:
              uint64_t v152 = (char *)v206;
              std::string::size_type v151 = v207;
              if (v206 == v207) {
                goto LABEL_277;
              }
LABEL_260:
              unint64_t v125 = 0;
              int v188 = v152;
              do
              {
                uint64_t v189 = *(void *)v188;
                v188 += 8;
                v125 ^= (v125 << 6) + (v125 >> 2) - 0x61C8864680B583EBLL + v189;
              }
              while (v188 != v151);
              if (!v152) {
                return v125;
              }
LABEL_263:
              uint64_t v207 = v152;
              operator delete(v152);
              return v125;
            }
LABEL_213:
            if ((v145 & 0x80u) == 0) {
              uint64_t v146 = (uint64_t *)((char *)this + 88);
            }
            else {
              uint64_t v146 = (uint64_t *)*((void *)this + 11);
            }
            if ((v145 & 0x80u) == 0) {
              unint64_t v147 = v145;
            }
            else {
              unint64_t v147 = *((void *)this + 12);
            }
            unint64_t v148 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)__p, v146, v147);
            unint64_t v149 = v148;
            size_t v150 = v207;
            if (v207 < v208)
            {
              *(void *)uint64_t v207 = v148;
              std::string::size_type v151 = v150 + 8;
              uint64_t v152 = (char *)v206;
              if (v206 != v150 + 8) {
                goto LABEL_260;
              }
              goto LABEL_277;
            }
            std::string::size_type v153 = (char *)v206;
            int64_t v154 = v207 - (unsigned char *)v206;
            uint64_t v155 = (v207 - (unsigned char *)v206) >> 3;
            unint64_t v156 = v155 + 1;
            if ((unint64_t)(v155 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v157 = v208 - (unsigned char *)v206;
            if ((v208 - (unsigned char *)v206) >> 2 > v156) {
              unint64_t v156 = v157 >> 2;
            }
            if ((unint64_t)v157 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v158 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v158 = v156;
            }
            if (v158)
            {
              if (v158 >> 61) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              std::string::size_type v159 = (char *)operator new(8 * v158);
              int v160 = (unint64_t *)&v159[8 * v155];
              long long v161 = &v159[8 * v158];
              *int v160 = v149;
              std::string::size_type v151 = (char *)(v160 + 1);
              int64_t v162 = v150 - v153;
              if (v150 == v153)
              {
LABEL_257:
                std::string v206 = v160;
                uint64_t v207 = v151;
                long long v208 = v161;
                if (v153) {
                  operator delete(v153);
                }
                uint64_t v152 = (char *)v206;
                if (v206 != v151) {
                  goto LABEL_260;
                }
LABEL_277:
                unint64_t v125 = 0;
                if (!v152) {
                  return v125;
                }
                goto LABEL_263;
              }
            }
            else
            {
              std::string::size_type v159 = 0;
              int v160 = (unint64_t *)(8 * v155);
              long long v161 = 0;
              *(void *)(8 * v155) = v149;
              std::string::size_type v151 = (char *)(8 * v155 + 8);
              int64_t v162 = v150 - v153;
              if (v150 == v153) {
                goto LABEL_257;
              }
            }
            unint64_t v179 = v162 - 8;
            if (v179 < 0x58) {
              goto LABEL_299;
            }
            if ((unint64_t)(v150 - v159 - v154) < 0x20) {
              goto LABEL_299;
            }
            uint64_t v180 = (v179 >> 3) + 1;
            uint64_t v181 = 8 * (v180 & 0x3FFFFFFFFFFFFFFCLL);
            unint64_t v182 = &v150[-v181];
            int v160 = (unint64_t *)((char *)v160 - v181);
            std::string v183 = &v159[8 * v155 - 16];
            unint64_t v184 = v150 - 16;
            uint64_t v185 = v180 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v186 = *(_OWORD *)v184;
              *((_OWORD *)v183 - 1) = *((_OWORD *)v184 - 1);
              *(_OWORD *)std::string v183 = v186;
              v183 -= 32;
              v184 -= 32;
              v185 -= 4;
            }
            while (v185);
            size_t v150 = v182;
            if (v180 != (v180 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_299:
              do
              {
                unint64_t v187 = *((void *)v150 - 1);
                v150 -= 8;
                *--int v160 = v187;
              }
              while (v150 != v153);
            }
            goto LABEL_257;
          }
LABEL_212:
          if (!v145) {
            goto LABEL_276;
          }
          goto LABEL_213;
        }
        unint64_t v145 = *((unsigned __int8 *)this + 111);
        if (*((char *)this + 111) < 0) {
          goto LABEL_275;
        }
        goto LABEL_212;
      }
    }
    else
    {
LABEL_176:
      if (!(_BYTE)v4) {
        goto LABEL_200;
      }
    }
    if ((v4 & 0x80u) == 0) {
      long long v126 = (uint64_t *)((char *)this + 64);
    }
    else {
      long long v126 = (uint64_t *)*((void *)this + 8);
    }
    if ((v4 & 0x80u) == 0) {
      unint64_t v127 = v4;
    }
    else {
      unint64_t v127 = *((void *)this + 9);
    }
    unint64_t v128 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)__p, v126, v127);
    size_t v129 = (unint64_t *)v207;
    if (v207 < v208)
    {
LABEL_209:
      unint64_t *v129 = v128;
      uint64_t v139 = (uint64_t)(v129 + 1);
      goto LABEL_274;
    }
    long long v130 = (unint64_t *)v206;
    int64_t v131 = v207 - (unsigned char *)v206;
    uint64_t v132 = (v207 - (unsigned char *)v206) >> 3;
    unint64_t v133 = v132 + 1;
    if ((unint64_t)(v132 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v134 = v208 - (unsigned char *)v206;
    if ((v208 - (unsigned char *)v206) >> 2 > v133) {
      unint64_t v133 = v134 >> 2;
    }
    if ((unint64_t)v134 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v135 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v135 = v133;
    }
    if (v135)
    {
      if (v135 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      size_t v136 = operator new(8 * v135);
      unint64_t v137 = (unint64_t *)&v136[8 * v132];
      long long v138 = &v136[8 * v135];
      *unint64_t v137 = v128;
      uint64_t v139 = (uint64_t)(v137 + 1);
      int64_t v140 = (char *)v129 - (char *)v130;
      if (v129 == v130) {
        goto LABEL_272;
      }
    }
    else
    {
      size_t v136 = 0;
      unint64_t v137 = (unint64_t *)(8 * v132);
      long long v138 = 0;
      *(void *)(8 * v132) = v128;
      uint64_t v139 = 8 * v132 + 8;
      int64_t v140 = (char *)v129 - (char *)v130;
      if (v129 == v130) {
        goto LABEL_272;
      }
    }
    unint64_t v170 = v140 - 8;
    if (v170 < 0x58) {
      goto LABEL_300;
    }
    if ((unint64_t)((char *)v129 - v136 - v131) < 0x20) {
      goto LABEL_300;
    }
    uint64_t v171 = (v170 >> 3) + 1;
    uint64_t v172 = 8 * (v171 & 0x3FFFFFFFFFFFFFFCLL);
    int v173 = &v129[v172 / 0xFFFFFFFFFFFFFFF8];
    unint64_t v137 = (unint64_t *)((char *)v137 - v172);
    char v174 = &v136[8 * v132 - 16];
    uint64_t v175 = v129 - 2;
    uint64_t v176 = v171 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v177 = *(_OWORD *)v175;
      *(v174 - 1) = *((_OWORD *)v175 - 1);
      *char v174 = v177;
      v174 -= 2;
      v175 -= 4;
      v176 -= 4;
    }
    while (v176);
    size_t v129 = v173;
    if (v171 != (v171 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_300:
      do
      {
        unint64_t v178 = *--v129;
        *--unint64_t v137 = v178;
      }
      while (v129 != v130);
    }
    goto LABEL_272;
  }
LABEL_8:
  if (*((char *)this + 183) < 0)
  {
    BOOL v7 = *((void *)this + 21) != 0;
    if (!v5) {
      goto LABEL_166;
    }
    goto LABEL_12;
  }
  BOOL v7 = *((unsigned char *)this + 183) != 0;
  if (v5) {
    goto LABEL_12;
  }
LABEL_166:
  char v122 = *((unsigned char *)this + 159);
  if (v122 < 0)
  {
    if (*((void *)this + 18)) {
      goto LABEL_168;
    }
  }
  else if (*((unsigned char *)this + 159))
  {
LABEL_168:
    if (v122 >= 0) {
      uint64_t v123 = (uint64_t *)((char *)this + 136);
    }
    else {
      uint64_t v123 = (uint64_t *)*((void *)this + 17);
    }
    if (v122 >= 0) {
      unint64_t v124 = *((unsigned __int8 *)this + 159);
    }
    else {
      unint64_t v124 = *((void *)this + 18);
    }
    return std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v206, v123, v124);
  }
  int v141 = (void *)((char *)this + 40);
  if (*((char *)this + 63) < 0) {
    int v141 = (void *)*v141;
  }
  HGLogger::warning((HGLogger *)"Missing fragment shader for %s\n", a2, a3, v141);
  return 0;
}

void sub_1B774DB8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,uint64_t a26,void *__p,uint64_t a28)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGProgramDescriptor::SetShaderProgram(HGProgramDescriptor *this, const char *a2)
{
}

void HGProgramDescriptor::SetVisibleShaderWithSource(HGProgramDescriptor *this, const char *a2, const char *a3)
{
  MEMORY[0x1BA9BF660]((char *)this + 64, a2);

  JUMPOUT(0x1BA9BF660);
}

void std::vector<HGBinding>::__assign_with_size[abi:ne180100]<HGBinding*,HGBinding*>(void **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = (uint64_t)a1[2];
  unint64_t v9 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)*a1) >> 4) < a4)
  {
    if (v9)
    {
      uint64_t v10 = (char *)a1[1];
      uint64_t v11 = *a1;
      if (v10 != v9)
      {
        do
        {
          if (*(v10 - 17) < 0) {
            operator delete(*((void **)v10 - 5));
          }
          v10 -= 48;
        }
        while (v10 != v9);
        uint64_t v11 = *a1;
      }
      a1[1] = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0x555555555555555) {
      goto LABEL_46;
    }
    unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 4);
    uint64_t v22 = 2 * v21;
    if (2 * v21 <= a4) {
      uint64_t v22 = a4;
    }
    unint64_t v23 = v21 >= 0x2AAAAAAAAAAAAAALL ? 0x555555555555555 : v22;
    if (v23 > 0x555555555555555) {
LABEL_46:
    }
      std::vector<double>::__throw_length_error[abi:ne180100]();
    uint64_t v24 = 6 * v23;
    unint64_t v20 = (void **)operator new(48 * v23);
    *a1 = v20;
    a1[1] = v20;
    a1[2] = &v20[v24];
    if (v6 != a3)
    {
      unint64_t v25 = 0;
      do
      {
        uint64_t v26 = v6 + v25;
        LODWORD(v20[v25 / 8]) = *(_DWORD *)(v6 + v25);
        unint64_t v27 = (std::string *)&v20[v25 / 8 + 1];
        uint64_t v28 = (const std::string::value_type **)(v6 + v25 + 8);
        if (*(char *)(v6 + v25 + 31) < 0)
        {
          std::string::__init_copy_ctor_external(v27, *v28, *(void *)(v26 + 16));
        }
        else
        {
          *(_OWORD *)&v27->__r_.__value_.__l.__data_ = *(_OWORD *)v28;
          v20[v25 / 8 + 3] = *(void **)(v6 + v25 + 24);
        }
        *(_OWORD *)&v20[v25 / 8 + 4] = *(_OWORD *)(v26 + 32);
        v25 += 48;
      }
      while (v26 + 48 != a3);
      unint64_t v20 = (void **)((char *)v20 + v25);
    }
LABEL_38:
    a1[1] = v20;
    return;
  }
  uint64_t v12 = (void **)a1[1];
  if (0xAAAAAAAAAAAAAAABLL * (((char *)v12 - v9) >> 4) >= a4)
  {
    if (a2 == a3)
    {
      unint64_t v20 = (void **)*a1;
    }
    else
    {
      unint64_t v20 = (void **)*a1;
      do
      {
        *(_DWORD *)unint64_t v9 = *(_DWORD *)v6;
        std::string::operator=((std::string *)(v9 + 8), (const std::string *)(v6 + 8));
        *((_OWORD *)v9 + 2) = *(_OWORD *)(v6 + 32);
        v20 += 6;
        v6 += 48;
        v9 += 48;
      }
      while (v6 != a3);
      uint64_t v12 = (void **)a1[1];
    }
    while (v12 != v20)
    {
      if (*((char *)v12 - 17) < 0) {
        operator delete(*(v12 - 5));
      }
      v12 -= 6;
    }
    goto LABEL_38;
  }
  uint64_t v13 = a2 + 16 * (((char *)v12 - v9) >> 4);
  if (v12 != (void **)v9)
  {
    do
    {
      *(_DWORD *)unint64_t v9 = *(_DWORD *)v6;
      std::string::operator=((std::string *)(v9 + 8), (const std::string *)(v6 + 8));
      *((_OWORD *)v9 + 2) = *(_OWORD *)(v6 + 32);
      v6 += 48;
      v9 += 48;
    }
    while (v6 != v13);
    unint64_t v9 = (char *)a1[1];
  }
  int v14 = v9;
  if (v13 != a3)
  {
    uint64_t v15 = 0;
    do
    {
      uint64_t v17 = v13 + v15;
      *(_DWORD *)&v9[v15] = *(_DWORD *)(v13 + v15);
      unint64_t v18 = (std::string *)&v9[v15 + 8];
      unint64_t v19 = (const std::string::value_type **)(v13 + v15 + 8);
      if (*(char *)(v13 + v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(v18, *v19, *(void *)(v17 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)v19;
        *(void *)&v9[v15 + 24] = *(void *)(v13 + v15 + 24);
        *(_OWORD *)&v18->__r_.__value_.__l.__data_ = v16;
      }
      *(_OWORD *)&v9[v15 + 32] = *(_OWORD *)(v17 + 32);
      v15 += 48;
    }
    while (v17 + 48 != a3);
    int v14 = &v9[v15];
  }
  a1[1] = v14;
}

void sub_1B774E020(_Unwind_Exception *exception_object)
{
  for (; v3; v3 -= 48)
  {
    if (*(char *)(v2 + v3 - 17) < 0) {
      operator delete(*(void **)(v2 + v3 - 40));
    }
  }
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(exception_object);
}

char *std::vector<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>::__push_back_slow_path<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>(void **a1, uint64_t a2)
{
  int v4 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v5 = (v3 - (unsigned char *)*a1) >> 4;
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (unsigned char *)a1[2] - v4;
  if (v7 >> 3 > v6) {
    unint64_t v6 = v7 >> 3;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
  }
  if (v6 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v9 = 16 * v6;
  uint64_t v10 = (char *)operator new(16 * v6);
  uint64_t v11 = &v10[16 * v5];
  uint64_t v12 = &v10[v9];
  *(_DWORD *)uint64_t v11 = *(_DWORD *)a2;
  *((void *)v11 + 1) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v13 = v11 + 16;
  if (v3 != v4)
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = &v11[v14];
      *((_DWORD *)v15 - 4) = *(_DWORD *)&v3[v14 - 16];
      uint64_t v16 = *(void *)&v3[v14 - 8];
      *((void *)v15 - 1) = v16;
      if (v16) {
        (*(void (**)(uint64_t))(*(void *)v16 + 16))(v16);
      }
      v14 -= 16;
    }
    while (&v3[v14] != v4);
    v11 += v14;
  }
  uint64_t v17 = (char *)*a1;
  unint64_t v18 = (char *)a1[1];
  *a1 = v11;
  a1[1] = v13;
  a1[2] = v12;
  while (v18 != v17)
  {
    uint64_t v19 = *((void *)v18 - 1);
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 24))(v19);
    }
    v18 -= 16;
  }
  if (v17) {
    operator delete(v17);
  }
  return v13;
}

uint64_t std::__split_buffer<std::pair<HGProgramDescriptor::InputType,HGRef<HGProgramDescriptor>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    while (1)
    {
      uint64_t v4 = i - 16;
      *(void *)(a1 + 16) = i - 16;
      uint64_t v5 = *(void *)(i - 8);
      if (v5) {
        break;
      }
      i -= 16;
      if (v4 == v3) {
        goto LABEL_6;
      }
    }
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
LABEL_6:
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *std::vector<HGBinding>::__push_back_slow_path<HGBinding>(char **a1, uint64_t a2)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 4) > v4) {
    unint64_t v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v6 = 0x555555555555555;
  }
  else {
    unint64_t v6 = v4;
  }
  if (v6)
  {
    if (v6 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v7 = (char *)operator new(48 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[48 * v3];
  uint64_t v9 = &v7[48 * v6];
  *(_DWORD *)uint64_t v8 = *(_DWORD *)a2;
  *(_OWORD *)(v8 + 8) = *(_OWORD *)(a2 + 8);
  *((void *)v8 + 3) = *(void *)(a2 + 24);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  *((_OWORD *)v8 + 2) = *(_OWORD *)(a2 + 32);
  uint64_t v10 = v8 + 48;
  uint64_t v11 = *a1;
  uint64_t v12 = a1[1];
  if (v12 == *a1)
  {
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
    if (!v12) {
      return v10;
    }
    goto LABEL_20;
  }
  do
  {
    int v13 = *((_DWORD *)v12 - 12);
    v12 -= 48;
    *((_DWORD *)v8 - 12) = v13;
    v8 -= 48;
    long long v14 = *(_OWORD *)(v12 + 8);
    *((void *)v8 + 3) = *((void *)v12 + 3);
    *(_OWORD *)(v8 + 8) = v14;
    *((void *)v12 + 2) = 0;
    *((void *)v12 + 3) = 0;
    *((void *)v12 + 1) = 0;
    *((_OWORD *)v8 + 2) = *((_OWORD *)v12 + 2);
  }
  while (v12 != v11);
  uint64_t v15 = *a1;
  uint64_t v12 = a1[1];
  *a1 = v8;
  a1[1] = v10;
  a1[2] = v9;
  if (v12 != v15)
  {
    do
    {
      if (*(v12 - 17) < 0) {
        operator delete(*((void **)v12 - 5));
      }
      v12 -= 48;
    }
    while (v12 != v15);
    uint64_t v12 = v15;
  }
  if (v12) {
LABEL_20:
  }
    operator delete(v12);
  return v10;
}

void *std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        if (v9.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v13 = v11[1];
            if (v13 == v7)
            {
              if (v11[2] == v7) {
                return v11;
              }
            }
            else if ((v13 & (v8 - 1)) != v4)
            {
              goto LABEL_23;
            }
            uint64_t v11 = (void *)*v11;
            if (!v11) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == v7) {
              return v11;
            }
          }
          else
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
            if (v12 != v4) {
              break;
            }
          }
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
LABEL_23:
  long long v14 = (void *)(a1 + 16);
  uint64_t v11 = operator new(0x30uLL);
  *uint64_t v11 = 0;
  v11[1] = v7;
  uint64_t v15 = **a4;
  v11[4] = 0;
  v11[5] = 0;
  v11[2] = v15;
  v11[3] = 0;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (v8 && (float)(v17 * (float)v8) >= v16)
  {
    uint64_t v18 = *(void *)a1;
    uint64_t v19 = *(void **)(*(void *)a1 + 8 * v4);
    if (v19)
    {
LABEL_26:
      *uint64_t v11 = *v19;
LABEL_61:
      void *v19 = v11;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v20 = 1;
    if (v8 >= 3) {
      BOOL v20 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v8);
    unint64_t v22 = vcvtps_u32_f32(v16 / v17);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v8 = *(void *)(a1 + 8);
    }
    if (prime > v8) {
      goto LABEL_37;
    }
    if (prime < v8)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v8 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (prime <= v24) {
        size_t prime = v24;
      }
      if (prime < v8) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v8 = *(void *)(a1 + 8);
    unint64_t v27 = v8 - 1;
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
      {
        unint64_t v4 = v7 % v8;
        uint64_t v18 = *(void *)a1;
        uint64_t v19 = *(void **)(*(void *)a1 + 8 * (v7 % v8));
        if (v19) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v7;
        uint64_t v18 = *(void *)a1;
        uint64_t v19 = *(void **)(*(void *)a1 + 8 * v7);
        if (v19) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v27 & v7;
      uint64_t v18 = *(void *)a1;
      uint64_t v19 = *(void **)(*(void *)a1 + 8 * (v27 & v7));
      if (v19) {
        goto LABEL_26;
      }
    }
  }
  *uint64_t v11 = *v14;
  void *v14 = v11;
  *(void *)(v18 + 8 * v4) = v14;
  if (*v11)
  {
    unint64_t v28 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v28 >= v8) {
        v28 %= v8;
      }
    }
    else
    {
      v28 &= v8 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1B774E7F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::string>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::string>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16) && *(char *)(v2 + 47) < 0) {
      operator delete(*(void **)(v2 + 24));
    }
    operator delete((void *)v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (!a2)
  {
    uint64_t v15 = *(void **)a1;
    *(void *)a1 = 0;
    if (v15) {
      operator delete(v15);
    }
    *(void *)(a1 + 8) = 0;
    return;
  }
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  unint64_t v4 = operator new(8 * a2);
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = 0;
  *(void *)(a1 + 8) = a2;
  do
    *(void *)(*(void *)a1 + 8 * v6++) = 0;
  while (a2 != v6);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void **)(a1 + 16);
  if (v7)
  {
    unint64_t v9 = v7[1];
    unint64_t v10 = a2 - 1;
    if ((a2 & (a2 - 1)) == 0)
    {
      uint64_t v11 = v9 & v10;
      *(void *)(*(void *)a1 + 8 * v11) = v8;
      while (1)
      {
        unint64_t v12 = (void *)*v7;
        if (!*v7) {
          break;
        }
        uint64_t v13 = v12[1] & v10;
        if (v13 == v11)
        {
          unint64_t v7 = (void *)*v7;
        }
        else if (*(void *)(*(void *)a1 + 8 * v13))
        {
          *unint64_t v7 = *v12;
          uint64_t v14 = 8 * v13;
          *unint64_t v12 = **(void **)(*(void *)a1 + v14);
          **(void **)(*(void *)a1 + v14) = v12;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v13) = v7;
          unint64_t v7 = v12;
          uint64_t v11 = v13;
        }
      }
      return;
    }
    if (v9 >= a2) {
      v9 %= a2;
    }
    *(void *)(*(void *)a1 + 8 * v9) = v8;
    float v16 = (void *)*v7;
    if (*v7)
    {
      while (1)
      {
        unint64_t v18 = v16[1];
        if (v18 >= a2) {
          v18 %= a2;
        }
        if (v18 == v9) {
          goto LABEL_25;
        }
        if (*(void *)(*(void *)a1 + 8 * v18))
        {
          *unint64_t v7 = *v16;
          uint64_t v17 = 8 * v18;
          void *v16 = **(void **)(*(void *)a1 + v17);
          **(void **)(*(void *)a1 + v17) = v16;
          float v16 = v7;
LABEL_25:
          unint64_t v7 = v16;
          float v16 = (void *)*v16;
          if (!v16) {
            return;
          }
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v18) = v7;
          unint64_t v7 = v16;
          float v16 = (void *)*v16;
          unint64_t v9 = v18;
          if (!v16) {
            return;
          }
        }
      }
    }
  }
}

uint64_t std::vector<HGBinding>::__push_back_slow_path<HGBinding const&>(char **a1, uint64_t a2)
{
  unint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 4);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((a1[2] - v3) >> 4) > v6) {
    unint64_t v6 = 0x5555555555555556 * ((a1[2] - v3) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v8 = 0x555555555555555;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v8)
  {
    if (v8 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unint64_t v9 = operator new(48 * v8);
  }
  else
  {
    unint64_t v9 = 0;
  }
  unint64_t v10 = (char *)&v9[3 * v5];
  uint64_t v19 = (char *)&v9[3 * v8];
  *(_DWORD *)unint64_t v10 = *(_DWORD *)a2;
  uint64_t v11 = (std::string *)(v10 + 8);
  if (*(char *)(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)(a2 + 8), *(void *)(a2 + 16));
    unint64_t v3 = *a1;
    unint64_t v4 = a1[1];
    unint64_t v10 = (char *)&v9[3 * v5];
  }
  else
  {
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 8);
    *((void *)v10 + 3) = *(void *)(a2 + 24);
  }
  v9[3 * v5 + 2] = *(_OWORD *)(a2 + 32);
  uint64_t v12 = (uint64_t)&v9[3 * v5 + 3];
  if (v4 == v3)
  {
    uint64_t v15 = v3;
  }
  else
  {
    do
    {
      int v13 = *((_DWORD *)v4 - 12);
      v4 -= 48;
      *((_DWORD *)v10 - 12) = v13;
      v10 -= 48;
      long long v14 = *(_OWORD *)(v4 + 8);
      *((void *)v10 + 3) = *((void *)v4 + 3);
      *(_OWORD *)(v10 + 8) = v14;
      *((void *)v4 + 2) = 0;
      *((void *)v4 + 3) = 0;
      *((void *)v4 + 1) = 0;
      *((_OWORD *)v10 + 2) = *((_OWORD *)v4 + 2);
    }
    while (v4 != v3);
    uint64_t v15 = *a1;
    unint64_t v3 = a1[1];
  }
  *a1 = v10;
  a1[1] = (char *)v12;
  a1[2] = v19;
  if (v3 != v15)
  {
    float v16 = (void **)(v3 - 48);
    do
    {
      if (*((char *)v16 + 31) < 0) {
        operator delete(v16[1]);
      }
      BOOL v17 = v16 == (void **)v15;
      v16 -= 6;
    }
    while (!v17);
    unint64_t v3 = v15;
  }
  if (v3) {
    operator delete(v3);
  }
  return v12;
}

void sub_1B774EBE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<HGBinding>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long const,std::string>>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = (char *)*v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = *((void *)v10 + 1);
            if (v12 == v6)
            {
              if (*((void *)v10 + 2) == v6) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_23;
            }
            unint64_t v10 = *(char **)v10;
            if (!v10) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == v6)
          {
            if (*((void *)v10 + 2) == v6) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
LABEL_23:
  int v13 = (void *)(a1 + 16);
  unint64_t v10 = (char *)operator new(0x30uLL);
  *(void *)unint64_t v10 = 0;
  *((void *)v10 + 1) = v6;
  *((void *)v10 + 2) = *(void *)a3;
  *(_OWORD *)(v10 + 24) = *(_OWORD *)(a3 + 8);
  *((void *)v10 + 5) = *(void *)(a3 + 24);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    uint64_t v16 = *(void *)a1;
    BOOL v17 = *(void **)(*(void *)a1 + 8 * v3);
    if (v17)
    {
LABEL_26:
      *(void *)unint64_t v10 = *v17;
LABEL_61:
      *BOOL v17 = v10;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v18 = 1;
    if (v7 >= 3) {
      BOOL v18 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v7);
    unint64_t v20 = vcvtps_u32_f32(v14 / v15);
    if (v19 <= v20) {
      size_t prime = v20;
    }
    else {
      size_t prime = v19;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v22 = *(int8x8_t *)(a1 + 8);
    if (prime > *(void *)&v22) {
      goto LABEL_37;
    }
    if (prime < *(void *)&v22)
    {
      unint64_t v23 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(void *)&v22 < 3uLL || (uint8x8_t v24 = (uint8x8_t)vcnt_s8(v22), v24.i16[0] = vaddlv_u8(v24), v24.u32[0] > 1uLL))
      {
        unint64_t v23 = std::__next_prime(v23);
      }
      else
      {
        uint64_t v25 = 1 << -(char)__clz(v23 - 1);
        if (v23 >= 2) {
          unint64_t v23 = v25;
        }
      }
      if (prime <= v23) {
        size_t prime = v23;
      }
      if (prime < *(void *)&v22) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    unint64_t v26 = v7 - 1;
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
      {
        unint64_t v3 = v6 % v7;
        uint64_t v16 = *(void *)a1;
        BOOL v17 = *(void **)(*(void *)a1 + 8 * (v6 % v7));
        if (v17) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v3 = v6;
        uint64_t v16 = *(void *)a1;
        BOOL v17 = *(void **)(*(void *)a1 + 8 * v6);
        if (v17) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v3 = v26 & v6;
      uint64_t v16 = *(void *)a1;
      BOOL v17 = *(void **)(*(void *)a1 + 8 * (v26 & v6));
      if (v17) {
        goto LABEL_26;
      }
    }
  }
  *(void *)unint64_t v10 = *v13;
  *int v13 = v10;
  *(void *)(v16 + 8 * v3) = v13;
  if (*(void *)v10)
  {
    unint64_t v27 = *(void *)(*(void *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v27 >= v7) {
        v27 %= v7;
      }
    }
    else
    {
      v27 &= v7 - 1;
    }
    BOOL v17 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1B774EF2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::string>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<std::string,BOOL>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BOOL>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BOOL>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BOOL>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3, long long **a4)
{
  unint64_t v6 = (unsigned char *)a2;
  unint64_t v8 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v9 = v8;
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)v45, (uint64_t *)a2, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v4 = v10;
      if (v10 >= v12) {
        unint64_t v4 = v10 % v12;
      }
    }
    else
    {
      unint64_t v4 = (v12 - 1) & v10;
    }
    float v14 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      float v15 = *v14;
      if (*v14)
      {
        char v16 = v6[23];
        if (v16 >= 0) {
          uint64_t v17 = v6[23];
        }
        else {
          uint64_t v17 = *((void *)v6 + 1);
        }
        if (v16 < 0) {
          unint64_t v6 = *(unsigned char **)v6;
        }
        if (v13.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v22 = v15[1];
            if (v22 == v11)
            {
              uint64_t v23 = *((unsigned __int8 *)v15 + 39);
              if ((v23 & 0x80u) == 0) {
                uint64_t v24 = *((unsigned __int8 *)v15 + 39);
              }
              else {
                uint64_t v24 = v15[3];
              }
              if (v24 == v17)
              {
                if ((v23 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v15[2], v6, v15[3])) {
                    return v15;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v15 + 39)) {
                    return v15;
                  }
                  uint64_t v25 = 0;
                  while (*((unsigned __int8 *)v15 + v25 + 16) == v6[v25])
                  {
                    if (v23 == ++v25) {
                      return v15;
                    }
                  }
                }
              }
            }
            else if ((v22 & (v12 - 1)) != v4)
            {
              goto LABEL_51;
            }
            float v15 = (uint64_t *)*v15;
            if (!v15) {
              goto LABEL_51;
            }
          }
        }
        do
        {
          unint64_t v18 = v15[1];
          if (v18 == v11)
          {
            uint64_t v19 = *((unsigned __int8 *)v15 + 39);
            if ((v19 & 0x80u) == 0) {
              uint64_t v20 = *((unsigned __int8 *)v15 + 39);
            }
            else {
              uint64_t v20 = v15[3];
            }
            if (v20 == v17)
            {
              if ((v19 & 0x80) != 0)
              {
                if (!memcmp((const void *)v15[2], v6, v15[3])) {
                  return v15;
                }
              }
              else
              {
                if (!*((unsigned char *)v15 + 39)) {
                  return v15;
                }
                uint64_t v21 = 0;
                while (*((unsigned __int8 *)v15 + v21 + 16) == v6[v21])
                {
                  if (v19 == ++v21) {
                    return v15;
                  }
                }
              }
            }
          }
          else
          {
            if (v18 >= v12) {
              v18 %= v12;
            }
            if (v18 != v4) {
              break;
            }
          }
          float v15 = (uint64_t *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_51:
  unint64_t v26 = (char *)operator new(0x30uLL);
  v45[0] = v26;
  v45[1] = a1 + 16;
  char v46 = 0;
  *(void *)unint64_t v26 = 0;
  *((void *)v26 + 1) = v11;
  unint64_t v27 = (std::string *)(v26 + 16);
  unint64_t v28 = *a4;
  if (*((char *)*a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v27, *(const std::string::value_type **)v28, *((void *)v28 + 1));
  }
  else
  {
    long long v29 = *v28;
    *((void *)v26 + 4) = *((void *)v28 + 2);
    *(_OWORD *)&v27->__r_.__value_.__l.__data_ = v29;
  }
  v26[40] = 0;
  char v46 = 1;
  float v30 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v31 = *(float *)(a1 + 32);
  if (!v12 || (float)(v31 * (float)v12) < v30)
  {
    BOOL v34 = 1;
    if (v12 >= 3) {
      BOOL v34 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v35 = v34 | (2 * v12);
    unint64_t v36 = vcvtps_u32_f32(v30 / v31);
    if (v35 <= v36) {
      size_t prime = v36;
    }
    else {
      size_t prime = v35;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v38 = *(int8x8_t *)(a1 + 8);
    if (prime > *(void *)&v38) {
      goto LABEL_68;
    }
    if (prime < *(void *)&v38)
    {
      unint64_t v39 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(void *)&v38 < 3uLL || (uint8x8_t v40 = (uint8x8_t)vcnt_s8(v38), v40.i16[0] = vaddlv_u8(v40), v40.u32[0] > 1uLL))
      {
        unint64_t v39 = std::__next_prime(v39);
      }
      else
      {
        uint64_t v41 = 1 << -(char)__clz(v39 - 1);
        if (v39 >= 2) {
          unint64_t v39 = v41;
        }
      }
      if (prime <= v39) {
        size_t prime = v39;
      }
      if (prime < *(void *)&v38) {
LABEL_68:
      }
        std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v12 = *(void *)(a1 + 8);
    unint64_t v42 = v12 - 1;
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
      {
        unint64_t v4 = v11 % v12;
        unint64_t v32 = *(void **)(*(void *)a1 + 8 * (v11 % v12));
        uint64_t v33 = (void *)v45[0];
        if (v32) {
          goto LABEL_57;
        }
      }
      else
      {
        unint64_t v4 = v11;
        unint64_t v32 = *(void **)(*(void *)a1 + 8 * v11);
        uint64_t v33 = (void *)v45[0];
        if (v32) {
          goto LABEL_57;
        }
      }
    }
    else
    {
      unint64_t v4 = v42 & v11;
      unint64_t v32 = *(void **)(*(void *)a1 + 8 * (v42 & v11));
      uint64_t v33 = (void *)v45[0];
      if (v32) {
        goto LABEL_57;
      }
    }
LABEL_81:
    void *v33 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v45[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v45[0])
    {
      unint64_t v43 = *(void *)(*(void *)v45[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v43 >= v12) {
          v43 %= v12;
        }
      }
      else
      {
        v43 &= v12 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v43) = v45[0];
    }
    goto LABEL_92;
  }
  unint64_t v32 = *(void **)(*(void *)a1 + 8 * v4);
  uint64_t v33 = (void *)v45[0];
  if (!v32) {
    goto LABEL_81;
  }
LABEL_57:
  void *v33 = *v32;
  *unint64_t v32 = v45[0];
LABEL_92:
  float v15 = (uint64_t *)v45[0];
  ++*(void *)(a1 + 24);
  return v15;
}

void sub_1B774F388(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B774F39C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16) && *(char *)(v2 + 39) < 0) {
      operator delete(*(void **)(v2 + 16));
    }
    operator delete((void *)v2);
  }
  return a1;
}

char *std::vector<HGProgramDescriptor::Dependency>::__push_back_slow_path<HGProgramDescriptor::Dependency>(void **a1, uint64_t a2)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 4);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) > v4) {
    unint64_t v4 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v6 = 0x555555555555555;
  }
  else {
    unint64_t v6 = v4;
  }
  if (v6)
  {
    if (v6 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unint64_t v7 = (char *)operator new(48 * v6);
  }
  else
  {
    unint64_t v7 = 0;
  }
  unint64_t v8 = &v7[48 * v3];
  *((void *)v8 + 2) = *(void *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  unint64_t v9 = &v7[48 * v6];
  long long v10 = *(_OWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_OWORD *)(v8 + 24) = v10;
  *((void *)v8 + 5) = *(void *)(a2 + 40);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  unint64_t v11 = v8 + 48;
  unint64_t v12 = (char *)*a1;
  uint8x8_t v13 = (char *)a1[1];
  if (v13 == *a1)
  {
    *a1 = v8;
    a1[1] = v11;
    a1[2] = v9;
    if (!v13) {
      return v11;
    }
    goto LABEL_23;
  }
  do
  {
    long long v14 = *((_OWORD *)v13 - 3);
    *((void *)v8 - 4) = *((void *)v13 - 4);
    *((_OWORD *)v8 - 3) = v14;
    *((void *)v13 - 5) = 0;
    *((void *)v13 - 4) = 0;
    *((void *)v13 - 6) = 0;
    long long v15 = *(_OWORD *)(v13 - 24);
    *((void *)v8 - 1) = *((void *)v13 - 1);
    *(_OWORD *)(v8 - 24) = v15;
    v8 -= 48;
    *((void *)v13 - 2) = 0;
    *((void *)v13 - 1) = 0;
    *((void *)v13 - 3) = 0;
    v13 -= 48;
  }
  while (v13 != v12);
  char v16 = (char *)*a1;
  uint8x8_t v13 = (char *)a1[1];
  *a1 = v8;
  a1[1] = v11;
  a1[2] = v9;
  if (v13 != v16)
  {
    while (1)
    {
      if (*(v13 - 1) < 0)
      {
        operator delete(*((void **)v13 - 3));
        if (*(v13 - 25) < 0) {
LABEL_20:
        }
          operator delete(*((void **)v13 - 6));
      }
      else if (*(v13 - 25) < 0)
      {
        goto LABEL_20;
      }
      v13 -= 48;
      if (v13 == v16)
      {
        uint8x8_t v13 = v16;
        break;
      }
    }
  }
  if (v13) {
LABEL_23:
  }
    operator delete(v13);
  return v11;
}

void HGComicEdges::HGComicEdges(HGComicEdges *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10D0918;
  *(void *)(v1 + 408) = 0;
  *(void *)(v1 + 416) = 0;
  *(_DWORD *)(v1 + 16) |= 0x600u;
}

void HGComicEdges::~HGComicEdges(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGComicEdges::SetParameter(HGComicEdges *this, int a2, float a3, float a4, float a5, float a6)
{
  switch(a2)
  {
    case 0:
      if (*((float *)this + 102) == a3) {
        goto LABEL_11;
      }
      *((float *)this + 102) = a3;
      uint64_t result = 1;
      break;
    case 1:
      if (*((float *)this + 103) == a3) {
        goto LABEL_11;
      }
      *((float *)this + 103) = a3;
      uint64_t result = 1;
      break;
    case 2:
      if (*((float *)this + 104) == a3) {
        goto LABEL_11;
      }
      *((float *)this + 104) = a3;
      uint64_t result = 1;
      break;
    case 3:
      if (*((float *)this + 105) == a3)
      {
LABEL_11:
        uint64_t result = 0;
      }
      else
      {
        *((float *)this + 105) = a3;
        uint64_t result = 1;
      }
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HGComicEdges::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicEdges::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

uint64_t HGComicEdges::GetROI@<X0>(uint64_t a1@<X0>, int a2@<W2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a2 == 1)
  {
    *(void *)&v9.int var0 = a3;
    *(void *)&v9.unsigned int var2 = a4;
    goto LABEL_5;
  }
  if (!a2)
  {
    LODWORD(a5) = vcvtps_s32_f32(*(float *)(a1 + 408) + *(float *)(a1 + 408));
    *(void *)&v10.unsigned int var2 = a5 | (a5 << 32);
    *(void *)&v9.int var0 = a3;
    *(void *)&v9.unsigned int var2 = a4;
    v10.int var0 = -(int)a5;
    v10.int var1 = -(int)a5;
    HGRect::Grow(&v9, v10);
LABEL_5:
    uint64_t v5 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    uint64_t v7 = v6;
    *(void *)&v11.int var0 = v5;
    *(void *)&v11.unsigned int var2 = v7;
    HGRect::Grow(&v9, v11);
    return *(void *)&v9.var0;
  }
  return HGRectNull;
}

uint64_t HGComicEdges::RenderTile(HGComicEdges *this, HGTile *a2)
{
  uint64_t v4 = HGTile::Renderer(a2);
  int v5 = (*(uint64_t (**)(HGComicEdges *, uint64_t))(*(void *)this + 312))(this, v4);
  uint64_t v6 = *((_DWORD *)a2 + 2) - *(void *)a2;
  int v81 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v81 >= 1 && (int)v6 >= 1)
  {
    int v9 = v5;
    int v10 = 0;
    *(float32x2_t *)v11.f32 = vadd_f32(vcvt_f32_s32(*(int32x2_t *)a2), (float32x2_t)0x3F0000003F000000);
    v11.i64[1] = 0x3F80000000000000;
    float v12 = *((float *)this + 102);
    float v84 = *((float *)this + 103);
    float v13 = v12 + v12;
    float v14 = 1.0 / (float)(v12 * (float)(v12 + v12));
    uint64_t v15 = *((void *)a2 + 2);
    float32x4_t v16 = (float32x4_t)xmmword_1B7E759E0;
    float32x4_t v17 = v11;
    float32x4_t v87 = v11;
    do
    {
      int v83 = v10;
      uint64_t v18 = 0;
      float32x4_t v82 = v17;
      float32x4_t v19 = v17;
      do
      {
        uint64_t v28 = *((void *)a2 + 12);
        uint64_t v29 = *((int *)a2 + 26);
        float32x4_t v30 = vsubq_f32(v19, v11);
        if (v9)
        {
          int32x4_t v31 = vaddq_s32(vcvtq_s32_f32(v30), vcltzq_f32(v30));
          float32x2_t v32 = (float32x2_t)vsubq_f32(v30, vcvtq_f32_s32(v31)).u64[0];
          uint64_t v33 = (float32x4_t *)(v28 + 16 * (v31.i32[0] + v31.i32[1] * (int)v29));
          float32x4_t v34 = vaddq_f32(*v33, vmulq_n_f32(vsubq_f32(v33[1], *v33), v32.f32[0]));
          float32x4_t v85 = vaddq_f32(v34, vmulq_lane_f32(vsubq_f32(vaddq_f32(v33[v29], vmulq_n_f32(vsubq_f32(v33[(int)v29 + 1], v33[v29]), v32.f32[0])), v34), v32, 1));
          uint64_t v35 = *((void *)a2 + 10);
          uint64_t v36 = *((int *)a2 + 22);
          float32x4_t v88 = v19;
          int32x4_t v37 = vaddq_s32(vcvtq_s32_f32(v30), vcltzq_f32(v30));
          float32x2_t v38 = (float32x2_t)vsubq_f32(v30, vcvtq_f32_s32(v37)).u64[0];
          unint64_t v39 = (float32x4_t *)(v35 + 16 * (v37.i32[0] + v37.i32[1] * (int)v36));
          float32x4_t v40 = vaddq_f32(*v39, vmulq_n_f32(vsubq_f32(v39[1], *v39), v38.f32[0]));
          float32x4_t v41 = vaddq_f32(v40, vmulq_lane_f32(vsubq_f32(vaddq_f32(v39[v36], vmulq_n_f32(vsubq_f32(v39[(int)v36 + 1], v39[v36]), v38.f32[0])), v40), v38, 1));
        }
        else
        {
          v42.i64[0] = 0x3F0000003F000000;
          v42.i64[1] = 0x3F0000003F000000;
          float32x4_t v43 = vaddq_f32(v30, v42);
          int32x4_t v44 = vcvtq_s32_f32(v43);
          v43.i64[0] = vaddq_s32(v44, vcgtq_f32(vcvtq_f32_s32(v44), v43)).u64[0];
          float32x4_t v85 = *(float32x4_t *)(v28 + 16 * (v43.i32[0] + v43.i32[1] * (int)v29));
          uint64_t v35 = *((void *)a2 + 10);
          uint64_t v36 = *((int *)a2 + 22);
          float32x4_t v88 = v19;
          v43.i64[0] = 0x3F0000003F000000;
          v43.i64[1] = 0x3F0000003F000000;
          float32x4_t v45 = vaddq_f32(v30, v43);
          int32x4_t v46 = vcvtq_s32_f32(v45);
          v45.i64[0] = vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)).u64[0];
          float32x4_t v41 = *(float32x4_t *)(v35 + 16 * (v45.i32[0] + v45.i32[1] * (int)v36));
        }
        float32x4_t v47 = v41;
        float v91 = v41.f32[0];
        int8x16_t v48 = (int8x16_t)vmulq_f32(v41, v16);
        float v49 = vaddv_f32(vadd_f32(*(float32x2_t *)v48.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v48, v48, 8uLL)));
        int8x16_t v50 = (int8x16_t)vmulq_f32(v47, (float32x4_t)xmmword_1B7EC1C40);
        float v51 = vaddv_f32(vadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL)));
        int8x16_t v52 = (int8x16_t)vmulq_f32(v47, (float32x4_t)xmmword_1B7EC1C50);
        BOOL v53 = fabsf(atan2f(vaddv_f32(vadd_f32(*(float32x2_t *)v52.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL))), v51)+ -2.3) < 0.3;
        if (v49 > 0.8) {
          BOOL v53 = 1;
        }
        if (v49 < 0.4) {
          BOOL v53 = 1;
        }
        _ZF = !v53;
        if (v53) {
          unsigned int v55 = -1;
        }
        else {
          unsigned int v55 = 0;
        }
        *(float *)&__int32 v56 = v91;
        if (_ZF) {
          *(float *)&__int32 v56 = v49;
        }
        v57.i64[1] = 0;
        v57.i32[0] = v56;
        v57.i32[1] = v56;
        if (v13 < 1.0)
        {
          float32x4_t v20 = (float32x4_t)xmmword_1B7E76310;
        }
        else
        {
          float32x4_t v86 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_n_s32(v55), (int8x16_t)xmmword_1B7E736B0, (int8x16_t)xmmword_1B7E759E0);
          uint64_t v58 = (int)v36 + 1;
          float32x4_t v20 = (float32x4_t)xmmword_1B7E76310;
          float v59 = 1.0;
          do
          {
            float32x4_t v90 = v20;
            float32x4_t v92 = v57;
            float v69 = v59 * (float)-(float)(v59 * v59);
            float v89 = expf(v69 * 0.5);
            float v70 = expf(v14 * v69);
            v71.i64[1] = 0;
            v71.f32[0] = (float)((float)(v85.f32[2] + v85.f32[2]) + -1.0) * v59;
            v71.f32[1] = v59 * (float)-(float)((float)(v85.f32[1] + v85.f32[1]) + -1.0);
            float32x4_t v72 = vsubq_f32(vsubq_f32(v88, (float32x4_t)v71.u64[0]), v87);
            if (v9)
            {
              int32x4_t v73 = vaddq_s32(vcvtq_s32_f32(v72), vcltzq_f32(v72));
              float32x2_t v74 = (float32x2_t)vsubq_f32(v72, vcvtq_f32_s32(v73)).u64[0];
              uint64_t v75 = (float32x4_t *)(v35 + 16 * (v73.i32[0] + v73.i32[1] * (int)v36));
              float32x4_t v76 = vaddq_f32(*v75, vmulq_n_f32(vsubq_f32(v75[1], *v75), v74.f32[0]));
              float32x4_t v63 = vaddq_f32(v76, vmulq_lane_f32(vsubq_f32(vaddq_f32(v75[v36], vmulq_n_f32(vsubq_f32(v75[v58], v75[v36]), v74.f32[0])), v76), v74, 1));
              float32x4_t v77 = vsubq_f32(vaddq_f32(v88, v71), v87);
              int32x4_t v78 = vaddq_s32(vcvtq_s32_f32(v77), vcltzq_f32(v77));
              v77.i64[0] = vsubq_f32(v77, vcvtq_f32_s32(v78)).u64[0];
              std::string::size_type v79 = (float32x4_t *)(v35 + 16 * (v78.i32[0] + v78.i32[1] * (int)v36));
              float32x4_t v80 = vaddq_f32(*v79, vmulq_n_f32(vsubq_f32(v79[1], *v79), v77.f32[0]));
              float32x4_t v66 = vaddq_f32(v80, vmulq_lane_f32(vsubq_f32(vaddq_f32(v79[v36], vmulq_n_f32(vsubq_f32(v79[v58], v79[v36]), v77.f32[0])), v80), *(float32x2_t *)v77.f32, 1));
            }
            else
            {
              v60.i64[0] = 0x3F0000003F000000;
              v60.i64[1] = 0x3F0000003F000000;
              float32x4_t v61 = vaddq_f32(v72, v60);
              int32x4_t v62 = vcvtq_s32_f32(v61);
              v61.i64[0] = vaddq_s32(v62, vcgtq_f32(vcvtq_f32_s32(v62), v61)).u64[0];
              float32x4_t v63 = *(float32x4_t *)(v35 + 16 * (v61.i32[0] + v61.i32[1] * (int)v36));
              float32x4_t v64 = vaddq_f32(vsubq_f32(vaddq_f32(v88, v71), v87), v60);
              int32x4_t v65 = vcvtq_s32_f32(v64);
              v64.i64[0] = vaddq_s32(v65, vcgtq_f32(vcvtq_f32_s32(v65), v64)).u64[0];
              float32x4_t v66 = *(float32x4_t *)(v35 + 16 * (v64.i32[0] + v64.i32[1] * (int)v36));
            }
            unint64_t v67 = __PAIR64__(LODWORD(v70), LODWORD(v89));
            int8x16_t v68 = (int8x16_t)vmulq_f32(v86, vaddq_f32(v63, v66));
            *(float32x2_t *)v68.i8 = vadd_f32(*(float32x2_t *)v68.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL));
            float32x4_t v20 = vaddq_f32(v90, (float32x4_t)v67);
            float32x4_t v57 = vaddq_f32(v92, vmulq_n_f32((float32x4_t)v67, vadd_f32(*(float32x2_t *)v68.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v68.i8, 1)).f32[0]));
            float v59 = v59 + 1.0;
          }
          while (v59 <= v13);
        }
        v21.i64[0] = 0x3F0000003F000000;
        v21.i64[1] = 0x3F0000003F000000;
        v21.i64[0] = vmulq_f32(v57, vdivq_f32(v21, v20)).u64[0];
        _NF = (float)(v84 * (float)((float)(v21.f32[0] + vmuls_lane_f32(-0.99, *(float32x2_t *)v21.f32, 1)) * 300.0)) < 0.8;
        float v23 = 0.0;
        if (!_NF) {
          float v23 = 1.0;
        }
        float32x4_t v16 = (float32x4_t)xmmword_1B7E759E0;
        float32x4_t v24 = v85;
        v24.f32[0] = v23;
        __asm { FMOV            V0.4S, #1.0 }
        *(float32x4_t *)(v15 + 16 * v18) = vmaxnmq_f32(vminnmq_f32(v24, _Q0), (float32x4_t)0);
        float32x4_t v11 = v87;
        float32x4_t v19 = vaddq_f32(v88, (float32x4_t)xmmword_1B7E736B0);
        ++v18;
      }
      while (v18 != v6);
      float32x4_t v17 = vaddq_f32(v82, (float32x4_t)xmmword_1B7E736C0);
      v15 += 16 * *((int *)a2 + 6);
      int v10 = v83 + 1;
    }
    while (v83 + 1 != v81);
  }
  return 0;
}

HGComicEdges *HGComicEdges::GetOutput(HGComicEdges *this, HGRenderer *a2, char *a3)
{
  return this;
}

const char *HGComicEdges::GetProgram(HGComicEdges *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) > 0x60B0F) {
    return "//Metal1.0     \n"
  }
           "//LEN=0000000c37\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]],\n"
           "                                  texture2d< half >      hg_Texture1 [[ texture(1) ]],\n"
           "                                  sampler                hg_Sampler1 [[ sampler(1) ]])\n"
           "{\n"
           "    const half sigma {static_cast<half>(hg_Params[0].x)};\n"
           "    const float prethreshold {hg_Params[0].y};\n"
           "    //const float threshold {hg_Params[0].z};\n"
           "    const float thesholdCoeffAdj {hg_Params[0].w};\n"
           "\n"
           "    const half sigma22 {1.0h / (2.0h * sigma * sigma)};\n"
           "    const half sigmax2 {2.0h * sigma};\n"
           "\n"
           "    const half alpha {hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).a};\n"
           "\n"
           "    const half2 gradient = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).yz;\n"
           "    const half2 dirPerpen {gradient.y * 2.0h - 1.0h, -(gradient.x * 2.0h - 1.0h)};\n"
           "\n"
           "    half3 lumaWeights {0.2126h, 0.7152h, 0.0722h};\n"
           "    constexpr half3 uWeights {-0.1146h, -0.3854h, 0.5000h};\n"
           "    constexpr half3 vWeights {0.5000h, -0.4542h, -0.0458h};\n"
           "    \n"
           "    const half3 srcRGB = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).rgb;\n"
           "    \n"
           "    const half srcY {dot(srcRGB, lumaWeights)};\n"
           "    const half srcU {dot(srcRGB, uWeights)};\n"
           "    const half srcV {dot(srcRGB, vWeights)};\n"
           "    \n"
           "    const half chromaAngle {atan2(srcV, srcU)};\n"
           "    \n"
           "    // if skintone found, then detect edges only on red channel to reduce wrinkles and shadows, otherwise use"
           " ITU Rec.709 luma for sky, trees, etc.\n"
           "    half luma = {srcY};\n"
           "    \n"
           "    if (abs(chromaAngle - 2.3h) < 0.3h || srcY > 0.8h || srcY < 0.4h)\n"
           "    {\n"
           "        luma = {srcRGB.r};\n"
           "        lumaWeights = {1.0h, 0.0h, 0.0h};\n"
           "    }\n"
           "\n"
           "    // edge detection using extended difference of gaussian thresholding\n"
           "    float2 acc {luma, luma};\n"
           "    half2 norma {0.5h, 0.5h};\n"
           "\n"
           "    for (half i {1.0h}; i <= sigmax2; i++)\n"
           "    {\n"
           "        const half2 coeff {exp(-i * i * i * 0.5h), exp(-i * i * i * sigma22)};\n"
           "        \n"
           "        const float2 uNeg = frag._texCoord0.xy - static_cast<float2>(i * dirPerpen);\n"
           "        const float2 uPos = frag._texCoord0.xy + static_cast<float2>(i * dirPerpen);\n"
           "        \n"
           "        const half3 pixel1 = hg_Texture0.sample(hg_Sampler0, uNeg).rgb;\n"
           "        const half3 pixel2 = hg_Texture0.sample(hg_Sampler0, uPos).rgb;\n"
           "\n"
           "        norma += coeff;\n"
           "        acc   += static_cast<float2>(coeff * dot((pixel1+pixel2), lumaWeights));\n"
           "    }\n"
           "\n"
           "    acc = acc * 0.5f / static_cast<float2>(norma);\n"
           "\n"
           "    const half total {static_cast<half>((acc.x  - acc.y * (0.99f + thesholdCoeffAdj)) * 300.0f * prethreshold"
           ")};\n"
           "\n"
           "    FragmentOut out {float4(step(0.8h, total), static_cast<float2>(gradient), alpha)};\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "\n"
           "    return out;\n"
           "}\n"
           "//MD5=9d181266:b7bbbd77:46ccdefd:532fadfc\n"
           "//SIG=00000000:00000000:00000000:00000003:0021:0001:0000:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)) {
    return "//GLfs1.0      \n"
  }
           "//LEN=0000000ae7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#define precision\n"
           "#define defaultp mediump\n"
           "#endif\n"
           "\n"
           "precision highp float;\n"
           "precision highp int;\n"
           "\n"
           "uniform defaultp sampler2DRect hg_Texture0; //BFFILTER\n"
           "uniform defaultp sampler2DRect hg_Texture1; //GAUSSFILTER\n"
           "\n"
           "uniform highp vec4 hg_ProgramLocal0;    // {.x == sigma, .y == prethreshold, .z == threshold, .w == threshold"
           " coeff adj}\n"
           "\n"
           "void main()\n"
           "{\n"
           "    float sigma = hg_ProgramLocal0.x;\n"
           "    float prethreshold = hg_ProgramLocal0.y;\n"
           "    float threshold = hg_ProgramLocal0.z;\n"
           "    float thresholdCoeffAduint64_t j = hg_ProgramLocal0.w;\n"
           "\n"
           "    float sigma22 = 1.0/ (2.0 * sigma  * sigma) ;\n"
           "    float sigmax2 = 2.0 * sigma ;\n"
           "\n"
           "    float alpha = texture2DRect(hg_Texture1, gl_TexCoord[1].xy).a;\n"
           "    vec2 gradient = texture2DRect(hg_Texture1, gl_TexCoord[1].xy).yz;\n"
           "    vec2 dirPerpen = vec2(gradient.y*2.0-1.0,  -(gradient.x*2.0-1.0));\n"
           "\n"
           "    vec3 lumaWeights = vec3( 0.2126,  0.7152, 0.0722);\n"
           "    vec3 uWeights    = vec3(-0.1146, -0.3854, 0.5000);\n"
           "    vec3 vWeights    = vec3( 0.5000, -0.4542,-0.0458);\n"
           "    vec3 srcRGB = texture2DRect( hg_Texture0, gl_TexCoord[0].xy).rgb;\n"
           "    float srcY = dot(srcRGB, lumaWeights);\n"
           "    float srcU = dot(srcRGB, uWeights);\n"
           "    float srcV = dot(srcRGB, vWeights);\n"
           "    float chromaAngle = atan(srcV, srcU);\n"
           "    \n"
           "    // if skintone found, then detect edges only on red channel to reduce wrinkles and shadows, otherwise use"
           " ITU Rec.709 luma for sky, trees, etc.\n"
           "    float luma = srcY;\n"
           "    \n"
           "    if (abs(chromaAngle - 2.3) < 0.3 || srcY > 0.8 || srcY < 0.4) \n"
           "    {\n"
           "        luma = srcRGB.r;\n"
           "        lumaWeights = vec3(1.0,0.0,0.0);\n"
           "    }\n"
           "\n"
           "    // edge detection using extended difference of gaussian thresholding\n"
           "    vec2 acc = vec2(luma, luma);\n"
           "    vec2 norma = vec2(0.5, 0.5);\n"
           "\n"
           "    for ( float uint64_t i = 1.0; i <= sigmax2; i ++) \n"
           "    {\n"
           "        vec2 coeff = vec2( exp( -i*i*i*0.5), exp( -i*i*i* sigma22)); //primera  fija, segunda variable\n"
           "        \n"
           "        vec2 uNeg = gl_TexCoord[0].xy - i * dirPerpen;\n"
           "        vec2 uPos = gl_TexCoord[0].xy + i * dirPerpen;\n"
           "        \n"
           "        vec3 pixel1 = texture2DRect( hg_Texture0, uNeg).rgb;\n"
           "        vec3 pixel2 = texture2DRect( hg_Texture0, uPos).rgb;\n"
           "        norma += coeff;\n"
           "        acc   += coeff * dot((pixel1+pixel2), lumaWeights) ;\n"
           "    }\n"
           "\n"
           "    acc  = acc*0.5/norma;\n"
           "\n"
           "    float total =   (acc.x  - acc.y * (0.99 + thresholdCoeffAdj))* 300.0*prethreshold; //substract second pow"
           "3  from first pow3 and 'cranck' the result\n"
           "\n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    gl_FragColor = clamp(vec4( (step (0.8, total)),gradient, alpha), 0.0, 1.0);   // remove residual gray t"
           "ones     ADD GRADIENT INSIDE THE EDGES TEXTURE\n"
           "}\n"
           "//MD5=6b6ff578:2a238d62:fa69622e:3bf77bdd\n"
           "//SIG=00000000:00000000:00000000:00000000:0042:0001:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  return 0;
}

uint64_t HGComicEdges::BindTexture(HGComicEdges *this, HGHandler *a2, uint64_t a3)
{
  return 0;
}

uint64_t HGGPURenderer::Concatenate(HGRenderer *a1, void *a2, unsigned __int8 *a3, const char *a4)
{
  uint64_t v120 = *MEMORY[0x1E4F143B8];
  Limits = (HGLimits *)HGRenderer::GetLimits(a1, 393216);
  char v103 = HGString::Digest::isunpremult((HGString::Digest *)a3);
  unint64_t v8 = (HGLimits *)(a3 + 16);
  unint64_t v109 = (HGString::Digest *)a3;
  uint64_t v9 = a3[56];
  LODWORD(a3) = HGLimits::isglfs((HGLimits *)(a3 + 16)) != 0;
  int v10 = a3 - (HGLimits::isarbfp(v8) != 0);
  if (HGLimits::ismetal(v8)) {
    int v13 = -2;
  }
  else {
    int v13 = 0;
  }
  if (!(v10 + v13)) {
    return 0xFFFFFFFFLL;
  }
  long long v110 = a2;
  unint64_t v100 = a1;
  if (v9)
  {
    uint64_t v14 = 0;
    char v15 = 1;
    int v106 = v10 + v13;
    do
    {
      if (v14 == v9 - 1 && *((unsigned __int16 *)v109 + 26) <= v9) {
        char v15 = 1;
      }
      *(void *)(a2[37] + 56 * v14) = 0;
      if (((1 << v14) & a4) != 0)
      {
        uint64_t v16 = a2[10];
        if (!v16
          || (uint64_t v17 = *(void *)(v16 + 8 * v14)) == 0
          || (uint64_t v18 = *(void *)(v17 + 16)) == 0
          || (uint64_t v19 = *(void *)(v18 + 144)) == 0
          || (uint64_t v20 = *(void *)(v19 + 64)) == 0
          || (v15 & 1) == 0 && (*(unsigned __int8 *)(v20 + 56) > 1u || *(unsigned __int16 *)(v20 + 52) > 1u)
          || ((BOOL v107 = HGLimits::isglfs((HGLimits *)(v20 + 16)) != 0,
               int v108 = v107 - (HGLimits::isarbfp((HGLimits *)(v20 + 16)) != 0),
               HGLimits::ismetal((HGLimits *)(v20 + 16)))
            ? (int v21 = -2)
            : (int v21 = 0),
              v108 + v21 != v106 || *(unsigned char *)(v20 + 58) != 1))
        {
          char v15 = 0;
          a4 = (const char *)(a4 & ~(1 << v14));
        }
        a2 = v110;
      }
      ++v14;
    }
    while (v14 != v9);
  }
  uint64_t v22 = a2[37];
  unint64_t v23 = 0x6DB6DB6DB6DB6DB7 * ((a2[38] - v22) >> 3);
  unint64_t v24 = v23 - v9;
  uint64_t v25 = v100;
  if (v23 > v9)
  {
    unint64_t v26 = v9;
    if (v24 < 2) {
      goto LABEL_33;
    }
    unint64_t v26 = (v24 & 0xFFFFFFFFFFFFFFFELL) + v9;
    unint64_t v27 = (void *)(v22 + 56 * v9);
    unint64_t v28 = v24 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      *unint64_t v27 = 0;
      v27[7] = 0;
      v27 += 14;
      v28 -= 2;
    }
    while (v28);
    if (v24 != (v24 & 0xFFFFFFFFFFFFFFFELL))
    {
LABEL_33:
      uint64_t v29 = (void *)(v22 + 56 * v26);
      unint64_t v30 = v23 - v26;
      do
      {
        *uint64_t v29 = 0;
        v29 += 7;
        --v30;
      }
      while (v30);
    }
  }
  long long v99 = (HGShaderBinding *)((char *)a2 + 260);
  *((_DWORD *)a2 + 71) = 0;
  if (!a4 || !a2[10])
  {
LABEL_105:
    if (!(*(unsigned int (**)(HGRenderer *, HGString::Digest *))(*(void *)v25 + 432))(v25, v109))
    {
      v110[8] = v109;
      HGShaderBinding::reset(v99);
      return 0;
    }
    v110[8] = 0;
    HGShaderBinding::reset(v99);
    return 0xFFFFFFFFLL;
  }
  memset(v119, 0, 128);
  long long v117 = 0u;
  memset(v116, 0, sizeof(v116));
  WORD2(v117) = *((_WORD *)v109 + 26);
  BYTE8(v117) = *((unsigned char *)v109 + 56);
  int v115 = 0;
  long long v113 = 0u;
  long long v114 = 0u;
  uint64_t v112 = 0;
  if (!v9)
  {
    unsigned int v98 = 0;
    int v101 = 0;
    goto LABEL_76;
  }
  uint64_t v31 = 0;
  int v101 = 0;
  unsigned int v98 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 16;
  char v34 = 1;
  uint64_t v35 = Limits;
  do
  {
    if (v9 - 1 == v31 && *((unsigned __int16 *)v109 + 26) <= v9) {
      char v34 = 1;
    }
    unsigned int v38 = ((2 << v31) - 1) & a4;
    if (((1 << v31) & a4) != 0)
    {
      uint64_t v39 = *(void *)(v110[10] + 8 * v31);
      if (v39)
      {
        uint64_t v40 = *(void *)(v39 + 16);
        if (v40)
        {
          uint64_t v41 = *(void *)(v40 + 144);
          __int16 v104 = WORD2(v117);
          char v102 = BYTE8(v117);
          if (v41)
          {
            uint64_t v11 = *(void *)(v41 + 64);
            if (v11)
            {
              if (*(unsigned __int16 *)(v11 + 52) + WORD2(v117) < *((unsigned __int16 *)v35 + 18)
                && *(unsigned __int8 *)(v11 + 56) + BYTE8(v117) < *((unsigned __int8 *)v35 + 40))
              {
                uint64_t v42 = 1 - v32;
                if (HGString::Digest::push((HGString::Digest *)&v119[64 * (1 - v32)], (HGShaderBinding *)(v110[37] + v33), (const HGString::Digest *)&v119[64 * v32], (const HGString::Digest *)v11, (v34 & 1) == 0, 0) == -1|| HGString::Digest::pop((HGString::Digest *)v116, (HGShaderBinding *)&v113, (const HGString::Digest *)&v119[64 * (1 - v32)], v109, ((2 << v31) - 1) & a4, Limits) == -1)
                {
                  uint64_t v35 = Limits;
                }
                else
                {
                  int v43 = (*(uint64_t (**)(HGRenderer *, _OWORD *, void, uint64_t *))(*(void *)v100 + 416))(v100, v116, 0, &v112);
                  if (v43 == -1) {
                    goto LABEL_62;
                  }
                  uint64_t v35 = Limits;
                  if (!v43)
                  {
                    uint64_t v36 = v110;
                    v110[8] = v112;
                    long long v37 = v114;
                    *(_OWORD *)long long v99 = v113;
                    *(_OWORD *)((char *)a2 + 276) = v37;
                    *((_DWORD *)a2 + 73) = v115;
                    unsigned int v98 = ((2 << v31) - 1) & a4;
                    goto LABEL_41;
                  }
                  v101 |= (1 << v31) & a4;
                  if (v43 > -2) {
                    goto LABEL_64;
                  }
                }
              }
            }
          }
          WORD2(v117) = v104;
          BYTE8(v117) = v102;
          a4 = (const char *)(a4 & ~(1 << v31));
        }
      }
    }
    if ((a4 & ~v38) != 0)
    {
      HGString::Digest::push((HGString::Digest *)&v119[64 * v32], (const HGString::Digest *)&v119[64 * v32], v35);
      char v34 = 0;
      uint64_t v42 = v32;
LABEL_62:
      uint64_t v36 = v110;
      uint64_t v35 = Limits;
      goto LABEL_41;
    }
    char v34 = 0;
    uint64_t v42 = v32;
LABEL_64:
    uint64_t v36 = v110;
LABEL_41:
    ++v31;
    v33 += 56;
    uint64_t v32 = v42;
  }
  while (v9 != v31);
  uint64_t v25 = v100;
  if (!a4) {
    goto LABEL_105;
  }
  if (a4 != v98)
  {
LABEL_76:
    unsigned __int8 v52 = atomic_load(HGLogger::_enabled);
    if (v52) {
      HGLogger::log((HGLogger *)"concat", (const char *)1, (HGLogger *)"testing concat chain:\n", (const char *)v11, v12);
    }
    HGLogger::indent(1);
    BOOL v53 = (const char *)(*(uint64_t (**)(void *))(*v110 + 48))(v110);
    snprintf(__str, 0x100uLL, "node = %p (%s)\n", v110, v53);
    unsigned __int8 v56 = atomic_load(HGLogger::_enabled);
    if (v56) {
      HGLogger::log((HGLogger *)"concat", (const char *)1, (HGLogger *)"%s", v54, v55, __str);
    }
    HGString::HGString((HGString *)v111);
    if (v9)
    {
      uint64_t v57 = 0;
      uint64_t v58 = 16;
      char v59 = 1;
      do
      {
        if (v9 - 1 == v57 && *((unsigned __int16 *)v109 + 26) <= v9) {
          char v59 = 1;
        }
        if ((a4 >> v57))
        {
          float32x4_t v60 = *(void **)(*(void *)(*(void *)(v110[10] + 8 * v57) + 16) + 144);
          float32x4_t v61 = (const char *)(*(uint64_t (**)(void *))(*v60 + 48))(v60);
          snprintf(__str, 0x100uLL, "input #%d = %p (%s)\n", v57, v60, v61);
          unsigned __int8 v64 = atomic_load(HGLogger::_enabled);
          if (v64) {
            HGLogger::log((HGLogger *)"concat", (const char *)1, (HGLogger *)"%s", v62, v63, __str);
          }
          HGString::push((HGString *)v111, (HGShaderBinding *)(v110[37] + v58), (const HGString *)(v60[8] + 64), v103, (v59 & 1) == 0, 0);
        }
        else if (((a4 >> v57) & 0xFFFFFFFE) != 0)
        {
          HGString::push((HGString *)v111, 0);
          char v59 = 0;
        }
        ++v57;
        v58 += 56;
      }
      while (v9 != v57);
    }
    HGLogger::indent(0xFFFFFFFFLL);
    uint64_t v25 = v100;
    while (1)
    {
      if ((int)v9 >= 1)
      {
        while (((a4 >> v9) & 1) == 0)
        {
          BOOL v65 = __OFSUB__(v9, 1);
          LODWORD(v9) = v9 - 1;
          if (((int)v9 < 0) ^ v65 | (v9 == 0))
          {
            LODWORD(v9) = 0;
            break;
          }
        }
      }
      int v66 = 1 << v9;
      if (HGString::pop((HGString *)v111, (HGShaderBinding *)&v113, (HGString::Digest *)((char *)v109 + 64), a4, 0) != -1&& (v66 & v101) == 0&& !(*(unsigned int (**)(HGRenderer *, unsigned char *, void, uint64_t *))(*(void *)v100 + 408))(v100, v111, 0, &v112))
      {
        unsigned __int8 v78 = atomic_load(HGLogger::_enabled);
        if (v78) {
          HGLogger::log((HGLogger *)"concat", (const char *)1, (HGLogger *)"concat chain OK!!\n", v67, v68);
        }
        float v70 = v110;
        v110[8] = v112;
        long long v79 = v114;
        *(_OWORD *)long long v99 = v113;
        *((_OWORD *)v99 + 1) = v79;
        *((_DWORD *)v99 + 8) = v115;
        if (a4)
        {
          uint64_t v85 = *(void *)(*(void *)(*(void *)v110[10] + 16) + 144);
          float32x4_t v71 = (void *)v110[37];
          *float32x4_t v71 = v85;
          uint64_t v80 = *(void *)(v85 + 64);
        }
        else
        {
          uint64_t v80 = 0;
          float32x4_t v71 = (void *)v110[37];
        }
        v71[1] = v80;
        if ((a4 & 2) != 0)
        {
          uint64_t v87 = *(void *)(*(void *)(*(void *)(v110[10] + 8) + 16) + 144);
          v71[7] = v87;
          uint64_t v86 = *(void *)(v87 + 64);
        }
        else
        {
          uint64_t v86 = 0;
        }
        v71[8] = v86;
        if ((a4 & 4) != 0)
        {
          uint64_t v89 = *(void *)(*(void *)(*(void *)(v110[10] + 16) + 16) + 144);
          v71[14] = v89;
          uint64_t v88 = *(void *)(v89 + 64);
        }
        else
        {
          uint64_t v88 = 0;
        }
        v71[15] = v88;
        if ((a4 & 8) != 0)
        {
          uint64_t v91 = *(void *)(*(void *)(*(void *)(v110[10] + 24) + 16) + 144);
          v71[21] = v91;
          uint64_t v90 = *(void *)(v91 + 64);
        }
        else
        {
          uint64_t v90 = 0;
        }
        v71[22] = v90;
        if ((a4 & 0x10) != 0)
        {
          uint64_t v93 = *(void *)(*(void *)(*(void *)(v110[10] + 32) + 16) + 144);
          v71[28] = v93;
          uint64_t v92 = *(void *)(v93 + 64);
        }
        else
        {
          uint64_t v92 = 0;
        }
        v71[29] = v92;
        if ((a4 & 0x20) != 0)
        {
          uint64_t v95 = *(void *)(*(void *)(*(void *)(v110[10] + 40) + 16) + 144);
          v71[35] = v95;
          uint64_t v94 = *(void *)(v95 + 64);
        }
        else
        {
          uint64_t v94 = 0;
        }
        v71[36] = v94;
        if ((a4 & 0x40) != 0)
        {
          uint64_t v97 = *(void *)(*(void *)(*(void *)(v110[10] + 48) + 16) + 144);
          v71[42] = v97;
          uint64_t v96 = *(void *)(v97 + 64);
        }
        else
        {
          uint64_t v96 = 0;
        }
        v71[43] = v96;
        if ((a4 & 0x80) != 0) {
          goto LABEL_129;
        }
        goto LABEL_158;
      }
      a4 = (const char *)(a4 & ~v66);
      if (!a4)
      {
        HGString::~HGString((HGString *)v111);
        goto LABEL_105;
      }
      if (a4 == v98) {
        break;
      }
      HGString::undo((HGString *)v111);
    }
    if (v98)
    {
      float v70 = v110;
      uint64_t v81 = *(void *)(*(void *)(*(void *)v110[10] + 16) + 144);
      float32x4_t v71 = (void *)v110[37];
      *float32x4_t v71 = v81;
      v71[1] = *(void *)(v81 + 64);
      if ((v98 & 2) == 0) {
        goto LABEL_123;
      }
LABEL_111:
      uint64_t v72 = *(void *)(*(void *)(*(void *)(v70[10] + 8) + 16) + 144);
      v71[7] = v72;
      v71[8] = *(void *)(v72 + 64);
      if ((v98 & 4) != 0) {
        goto LABEL_112;
      }
LABEL_124:
      v71[15] = 0;
      if ((v98 & 8) == 0) {
        goto LABEL_125;
      }
LABEL_113:
      uint64_t v74 = *(void *)(*(void *)(*(void *)(v70[10] + 24) + 16) + 144);
      v71[21] = v74;
      v71[22] = *(void *)(v74 + 64);
      if ((v98 & 0x10) != 0) {
        goto LABEL_114;
      }
LABEL_126:
      v71[29] = 0;
      if ((v98 & 0x20) == 0) {
        goto LABEL_127;
      }
LABEL_115:
      uint64_t v76 = *(void *)(*(void *)(*(void *)(v70[10] + 40) + 16) + 144);
      v71[35] = v76;
      v71[36] = *(void *)(v76 + 64);
      if ((v98 & 0x40) != 0) {
        goto LABEL_116;
      }
LABEL_128:
      v71[43] = 0;
      if ((v98 & 0x80) != 0)
      {
LABEL_129:
        uint64_t v82 = *(void *)(*(void *)(*(void *)(v70[10] + 56) + 16) + 144);
        v71[49] = v82;
        uint64_t v83 = *(void *)(v82 + 64);
        goto LABEL_159;
      }
    }
    else
    {
      float v70 = v110;
      float32x4_t v71 = (void *)v110[37];
      v71[1] = 0;
      if ((v98 & 2) != 0) {
        goto LABEL_111;
      }
LABEL_123:
      v71[8] = 0;
      if ((v98 & 4) == 0) {
        goto LABEL_124;
      }
LABEL_112:
      uint64_t v73 = *(void *)(*(void *)(*(void *)(v70[10] + 16) + 16) + 144);
      v71[14] = v73;
      v71[15] = *(void *)(v73 + 64);
      if ((v98 & 8) != 0) {
        goto LABEL_113;
      }
LABEL_125:
      v71[22] = 0;
      if ((v98 & 0x10) == 0) {
        goto LABEL_126;
      }
LABEL_114:
      uint64_t v75 = *(void *)(*(void *)(*(void *)(v70[10] + 32) + 16) + 144);
      v71[28] = v75;
      v71[29] = *(void *)(v75 + 64);
      if ((v98 & 0x20) != 0) {
        goto LABEL_115;
      }
LABEL_127:
      v71[36] = 0;
      if ((v98 & 0x40) == 0) {
        goto LABEL_128;
      }
LABEL_116:
      uint64_t v77 = *(void *)(*(void *)(*(void *)(v70[10] + 48) + 16) + 144);
      v71[42] = v77;
      v71[43] = *(void *)(v77 + 64);
      if ((v98 & 0x80) != 0) {
        goto LABEL_129;
      }
    }
LABEL_158:
    uint64_t v83 = 0;
LABEL_159:
    v71[50] = v83;
    HGString::~HGString((HGString *)v111);
    return 1;
  }
  if (a4)
  {
    uint64_t v84 = *(void *)(*(void *)(*(void *)v36[10] + 16) + 144);
    int32x4_t v44 = (void *)v36[37];
    void *v44 = v84;
    v44[1] = *(void *)(v84 + 64);
    if ((a4 & 2) == 0) {
      goto LABEL_131;
    }
LABEL_69:
    uint64_t v45 = *(void *)(*(void *)(*(void *)(v36[10] + 8) + 16) + 144);
    v44[7] = v45;
    v44[8] = *(void *)(v45 + 64);
    if ((a4 & 4) != 0) {
      goto LABEL_70;
    }
LABEL_132:
    v44[15] = 0;
    if ((a4 & 8) == 0) {
      goto LABEL_133;
    }
LABEL_71:
    uint64_t v47 = *(void *)(*(void *)(*(void *)(v36[10] + 24) + 16) + 144);
    v44[21] = v47;
    v44[22] = *(void *)(v47 + 64);
    if ((a4 & 0x10) != 0) {
      goto LABEL_72;
    }
LABEL_134:
    v44[29] = 0;
    if ((a4 & 0x20) == 0) {
      goto LABEL_135;
    }
LABEL_73:
    uint64_t v49 = *(void *)(*(void *)(*(void *)(v36[10] + 40) + 16) + 144);
    v44[35] = v49;
    v44[36] = *(void *)(v49 + 64);
    if ((a4 & 0x40) != 0) {
      goto LABEL_74;
    }
LABEL_136:
    v44[43] = 0;
    if ((a4 & 0x80) == 0) {
      goto LABEL_137;
    }
LABEL_75:
    uint64_t v51 = *(void *)(*(void *)(*(void *)(v36[10] + 56) + 16) + 144);
    v44[49] = v51;
    v44[50] = *(void *)(v51 + 64);
  }
  else
  {
    int32x4_t v44 = (void *)v36[37];
    v44[1] = 0;
    if ((a4 & 2) != 0) {
      goto LABEL_69;
    }
LABEL_131:
    v44[8] = 0;
    if ((a4 & 4) == 0) {
      goto LABEL_132;
    }
LABEL_70:
    uint64_t v46 = *(void *)(*(void *)(*(void *)(v36[10] + 16) + 16) + 144);
    v44[14] = v46;
    v44[15] = *(void *)(v46 + 64);
    if ((a4 & 8) != 0) {
      goto LABEL_71;
    }
LABEL_133:
    v44[22] = 0;
    if ((a4 & 0x10) == 0) {
      goto LABEL_134;
    }
LABEL_72:
    uint64_t v48 = *(void *)(*(void *)(*(void *)(v36[10] + 32) + 16) + 144);
    v44[28] = v48;
    v44[29] = *(void *)(v48 + 64);
    if ((a4 & 0x20) != 0) {
      goto LABEL_73;
    }
LABEL_135:
    v44[36] = 0;
    if ((a4 & 0x40) == 0) {
      goto LABEL_136;
    }
LABEL_74:
    uint64_t v50 = *(void *)(*(void *)(*(void *)(v36[10] + 48) + 16) + 144);
    v44[42] = v50;
    v44[43] = *(void *)(v50 + 64);
    if ((a4 & 0x80) != 0) {
      goto LABEL_75;
    }
LABEL_137:
    v44[50] = 0;
  }
  return 1;
}

void sub_1B7750C04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

void sub_1B7750C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

void sub_1B7750C30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::Concatenate(HGGPURenderer *this, HGNode *a2, unsigned int a3)
{
  HGNode::GetProgramDescriptor(a2, &v87);
  HGProgramDescriptor::GetSignature(v87, (uint64_t)v84);
  if (v86)
  {
    for (unint64_t i = 0; i < v86; ++i)
    {
      if ((a3 & (1 << i)) != 0)
      {
        uint64_t v7 = *((void *)a2 + 10);
        if (!v7) {
          goto LABEL_3;
        }
        uint64_t v8 = *(void *)(v7 + 8 * i);
        if (!v8) {
          goto LABEL_3;
        }
        uint64_t v9 = *(void *)(v8 + 16);
        if (!v9) {
          goto LABEL_3;
        }
        HGNode::GetProgramDescriptor(*(HGNode **)(v9 + 144), v81);
        if (!v81[0]) {
          goto LABEL_3;
        }
        BOOL IsMergeable = HGProgramDescriptor::IsMergeable(v81[0]);
        if (v81[0]) {
          (*(void (**)(HGProgramDescriptor *))(*(void *)v81[0] + 24))(v81[0]);
        }
        if (!IsMergeable) {
LABEL_3:
        }
          a3 &= ~(1 << i);
      }
      unsigned int v6 = v86;
    }
  }
  else
  {
    unsigned int v6 = 0;
  }
  uint64_t v11 = *((void *)a2 + 37);
  uint64_t v12 = *((void *)a2 + 38) - v11;
  if (v12)
  {
    unint64_t v13 = v12 / 56;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    if (v13 < 2)
    {
      unint64_t v14 = 0;
LABEL_23:
      unint64_t v17 = v13 - v14;
      uint64_t v18 = (void *)(v11 + 56 * v14);
      do
      {
        void *v18 = 0;
        v18 += 7;
        --v17;
      }
      while (v17);
      goto LABEL_25;
    }
    unint64_t v14 = v13 & 0xFFFFFFFFFFFFFFFELL;
    unint64_t v15 = v13 & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v16 = (void *)*((void *)a2 + 37);
    do
    {
      void *v16 = 0;
      v16[7] = 0;
      v16 += 14;
      v15 -= 2;
    }
    while (v15);
    if (v13 != v14) {
      goto LABEL_23;
    }
  }
LABEL_25:
  uint64_t v19 = (HGShaderBinding *)((char *)a2 + 260);
  *((_DWORD *)a2 + 71) = 0;
  if (!a3 || (uint64_t v20 = (uint64_t *)*((void *)a2 + 10)) == 0)
  {
LABEL_75:
    v21.n128_f64[0] = HGShaderBinding::reset(v19);
    uint64_t v59 = 0;
    float32x4_t v60 = v87;
    if (!v87) {
      return v59;
    }
    goto LABEL_89;
  }
  v21.n128_u64[1] = 0;
  long long v82 = 0u;
  long long v83 = 0u;
  *(_OWORD *)uint64_t v81 = 0u;
  if (!v6)
  {
    int v32 = 0;
LABEL_78:
    int v38 = 0;
    int v39 = BYTE4(v83) - v32;
    goto LABEL_79;
  }
  int v73 = v85;
  if (a3)
  {
    uint64_t v22 = *v20;
    if (v22)
    {
      uint64_t v23 = *(void *)(v22 + 16);
      if (v23)
      {
        HGNode::GetProgramDescriptor(*(HGNode **)(v23 + 144), &v80);
        HGProgramDescriptor::GetSignature(v80, (uint64_t)v77);
        int v24 = BYTE8(v83);
        if (v6 + v79 + BYTE8(v83) <= 8 && (int v25 = BYTE4(v83), v73 + v78 + BYTE4(v83) <= 8))
        {
          int v33 = BYTE10(v83);
          int v34 = WORD3(v82);
          int v35 = HIDWORD(v83);
          uint64_t v36 = *((void *)a2 + 37);
          *(void *)(v36 + 16) = 0;
          *(_DWORD *)(v36 + 24) = v25;
          *(_DWORD *)(v36 + 28) = v33;
          *(_DWORD *)(v36 + 32) = v34;
          *(_DWORD *)(v36 + 36) = v35;
          *(_DWORD *)(v36 + 40) = v24;
          *(void *)(v36 + 44) = 0xFFFFFFFFLL;
          HGProgramDescriptor::SetInput(v87, 0, &v80);
          long long v75 = 0u;
          long long v76 = 0u;
          long long v74 = 0u;
          merge(v77, (int8x8_t *)v81, (int8x8_t *)&v74, 0, 1);
          *(_OWORD *)uint64_t v81 = v74;
          long long v82 = v75;
          v21.n128_u64[1] = *((void *)&v76 + 1);
          long long v83 = v76;
          int v26 = 1;
          unint64_t v27 = v80;
          if (!v80) {
            goto LABEL_41;
          }
        }
        else
        {
          int v26 = 0;
          a3 &= ~1u;
          unint64_t v27 = v80;
          if (!v80)
          {
LABEL_41:
            int v72 = v26;
            BOOL v28 = (a3 & 1) == 0;
            if (a3) {
              goto LABEL_42;
            }
            goto LABEL_36;
          }
        }
        (*(void (**)(HGProgramDescriptor *))(*(void *)v27 + 24))(v27);
        goto LABEL_41;
      }
    }
  }
  int v72 = 0;
  BOOL v28 = (a3 & 1) == 0;
  if (a3) {
    goto LABEL_42;
  }
LABEL_36:
  uint64_t v29 = *((void *)a2 + 37);
  *(void *)(v29 + 16) = 0;
  *(void *)(v29 + 24) = 0;
  *(_DWORD *)(v29 + 40) = 0;
  *(void *)(v29 + 32) = 0;
  *(void *)(v29 + 44) = 0xFFFFFFFFLL;
  __int16 v30 = ++WORD2(v83);
  char v31 = ++BYTE8(v83);
  ++BYTE11(v83);
  ++BYTE10(v83);
  if (WORD2(v83) <= 0xFFu) {
    WORD2(v83) = (v30 << 12) | ((v31 & 0xF) << 8) | v30;
  }
LABEL_42:
  if (v6 != 1)
  {
    int v37 = 0;
    int v40 = -1;
    uint64_t v41 = 72;
    unint64_t v42 = 1;
    uint64_t v43 = v6;
    while (1)
    {
      BOOL v45 = v42 != v86 - 1 || v85 > v86;
      int v46 = 1 << v42;
      if ((a3 & (1 << v42)) == 0) {
        goto LABEL_66;
      }
      uint64_t v47 = *(void *)(*((void *)a2 + 10) + 8 * v42);
      if (!v47) {
        goto LABEL_66;
      }
      uint64_t v48 = *(void *)(v47 + 16);
      if (!v48) {
        goto LABEL_66;
      }
      HGNode::GetProgramDescriptor(*(HGNode **)(v48 + 144), &v80);
      HGProgramDescriptor::GetSignature(v80, (uint64_t)v77);
      int v49 = BYTE8(v83);
      if ((int)(v43 + v40 + v79 + BYTE8(v83)) <= 8)
      {
        int v50 = BYTE4(v83);
        if (v73 + v40 + v78 + BYTE4(v83) < 9 && (!v45 || v79 <= 1u && v78 < 2u)) {
          break;
        }
      }
      a3 &= ~v46;
      uint64_t v51 = v80;
      if (v80) {
        goto LABEL_65;
      }
LABEL_66:
      if ((a3 & v46) == 0)
      {
        uint64_t v52 = *((void *)a2 + 37) + v41;
        *(void *)uint64_t v52 = 0;
        *(void *)(v52 + 8) = 0;
        *(_DWORD *)(v52 + 24) = 0;
        *(void *)(v52 + 16) = 0;
        *(void *)(v52 + 28) = 0xFFFFFFFFLL;
        __int16 v53 = ++WORD2(v83);
        char v54 = ++BYTE8(v83);
        ++BYTE11(v83);
        ++BYTE10(v83);
        if (WORD2(v83) <= 0xFFu) {
          WORD2(v83) = (v53 << 12) | ((v54 & 0xF) << 8) | v53;
        }
        if (!v28) {
          int v37 = v42;
        }
        BOOL v28 = 1;
      }
      ++v42;
      v41 += 56;
      --v40;
      if (v43 == v42) {
        goto LABEL_44;
      }
    }
    int v55 = BYTE10(v83);
    int v56 = WORD3(v82);
    int v57 = HIDWORD(v83);
    uint64_t v58 = *((void *)a2 + 37) + v41;
    *(void *)uint64_t v58 = 0;
    *(_DWORD *)(v58 + 8) = v50;
    *(_DWORD *)(v58 + 12) = v55;
    *(_DWORD *)(v58 + 16) = v56;
    *(_DWORD *)(v58 + 20) = v57;
    *(_DWORD *)(v58 + 24) = v49;
    *(void *)(v58 + 28) = 0xFFFFFFFFLL;
    HGProgramDescriptor::SetInput(v87, v42, &v80);
    long long v75 = 0u;
    long long v76 = 0u;
    long long v74 = 0u;
    merge(v77, (int8x8_t *)v81, (int8x8_t *)&v74, v45, 1);
    *(_OWORD *)uint64_t v81 = v74;
    long long v82 = v75;
    v21.n128_u64[1] = *((void *)&v76 + 1);
    long long v83 = v76;
    ++v72;
    uint64_t v51 = v80;
    if (!v80) {
      goto LABEL_66;
    }
LABEL_65:
    (*(void (**)(HGProgramDescriptor *))(*(void *)v51 + 24))(v51);
    goto LABEL_66;
  }
  int v37 = 0;
LABEL_44:
  if (!a3)
  {
    uint64_t v19 = (HGShaderBinding *)((char *)a2 + 260);
    goto LABEL_75;
  }
  if (!v28)
  {
    uint64_t v19 = (HGShaderBinding *)((char *)a2 + 260);
    int v32 = v72;
    goto LABEL_78;
  }
  uint64_t v19 = (HGShaderBinding *)((char *)a2 + 260);
  if (WORD2(v83) > 0xFFu)
  {
    int v38 = (HIBYTE(WORD2(v83)) & 0xF) + ~v37;
    int v39 = ~v37 + (WORD2(v83) >> 12);
  }
  else
  {
    int v38 = BYTE8(v83) - v37;
    int v39 = BYTE4(v83) - v37;
  }
LABEL_79:
  int v61 = WORD3(v82);
  int v62 = HIDWORD(v83);
  *(void *)uint64_t v19 = 0;
  *((_DWORD *)a2 + 67) = v39;
  *((_DWORD *)a2 + 68) = 0;
  *((_DWORD *)a2 + 69) = v61;
  *((_DWORD *)a2 + 70) = v62;
  *((_DWORD *)a2 + 71) = v38;
  v21.n128_u64[0] = 0xFFFFFFFFLL;
  *((void *)a2 + 36) = 0xFFFFFFFFLL;
  uint64_t v64 = *((void *)a2 + 37);
  uint64_t v63 = *((void *)a2 + 38);
  uint64_t v65 = v63 - v64;
  if (v63 != v64)
  {
    uint64_t v66 = 0;
    unint64_t v67 = v65 / 56;
    if (v67 <= 1) {
      unint64_t v67 = 1;
    }
    int8x16_t v68 = (_DWORD *)(v64 + 36);
    do
    {
      while (1)
      {
        if ((a3 >> v66))
        {
          uint64_t v69 = *(void *)(*((void *)a2 + 10) + 8 * v66);
          if (v69)
          {
            uint64_t v70 = *(void *)(v69 + 16);
            if (v70) {
              break;
            }
          }
        }
        *(v68 - 1) = v61;
        *int8x16_t v68 = v62;
        ++v66;
        v68 += 14;
        if (v67 == v66) {
          goto LABEL_88;
        }
      }
      *(void *)(v68 - 9) = *(void *)(v70 + 144);
      ++v66;
      v68 += 14;
    }
    while (v67 != v66);
  }
LABEL_88:
  uint64_t v59 = 1;
  float32x4_t v60 = v87;
  if (v87) {
LABEL_89:
  }
    (*(void (**)(HGProgramDescriptor *, __n128))(*(void *)v60 + 24))(v60, v21);
  return v59;
}

void sub_1B7751304(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a26) {
    (*(void (**)(uint64_t))(*(void *)a26 + 24))(a26);
  }
  uint64_t v29 = *(void *)(v27 - 112);
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 24))(v29);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGColorGamma::RenderTile()
{
  return 0;
}

void HGColorGamma::HGColorGamma(HGColorGamma *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v2 = &unk_1F10D0B80;
  *(void *)(v2 + 544) = 0;
  *(_OWORD *)(v2 + 416) = 0u;
  *(_OWORD *)(v2 + 432) = 0u;
  *(_OWORD *)(v2 + 448) = 0u;
  *(_OWORD *)(v2 + 464) = 0u;
  *(_OWORD *)(v2 + 480) = 0u;
  *(_OWORD *)(v2 + 496) = 0u;
  *(_OWORD *)(v2 + 512) = 0u;
  *(void *)(v2 + 528) = 0;
  *(_OWORD *)(v2 + 560) = 0u;
  *(_OWORD *)(v2 + 576) = 0u;
  *(_OWORD *)(v2 + 592) = 0u;
  *(_OWORD *)(v2 + 608) = 0u;
  *(_OWORD *)(v2 + 624) = 0u;
  *(_OWORD *)(v2 + 640) = 0u;
  *(_OWORD *)(v2 + 656) = 0u;
  *(_OWORD *)(v2 + 672) = 0u;
  *(_OWORD *)(v2 + 688) = 0u;
  *(_OWORD *)(v2 + 704) = 0u;
  *(_OWORD *)(v2 + 720) = 0u;
  *(_OWORD *)(v2 + 729) = 0u;
  *(_OWORD *)(v2 + 752) = 0u;
  *(_WORD *)(v2 + 745) = 257;
  *(_DWORD *)(v2 + 1172) = 65793;
  *(void *)(v2 + 1156) = 0xBF00000040000000;
  *(_DWORD *)(v2 + 1152) = 1024;
  *(void *)(v2 + 1164) = 0x100000320;
  *(_WORD *)(v2 + 1024) = 0;
  *(unsigned char *)(v2 + 1026) = 0;
  *(_DWORD *)(v2 + 1036) = 1;
  *(_OWORD *)(v2 + 1040) = HGRectInfinite;
  *(void *)(v2 + 1056) = 0;
  *(_DWORD *)(v2 + 1064) = 0;
  *(void *)(v2 + 408) = 0;
  *(unsigned char *)(v2 + 880) = 0;
  HGNode::ClearBits((HGNode *)v2, v3, v4);
  *((unsigned char *)this + 745) = 1;
  HGNode::ClearBits((HGNode *)this, v5, v6);
  *((unsigned char *)this + 745) = 1;
  *((_OWORD *)this + 56) = xmmword_1B7E736B0;
  *((_OWORD *)this + 57) = xmmword_1B7E736C0;
  *((_OWORD *)this + 58) = xmmword_1B7E736D0;
  *((_OWORD *)this + 59) = xmmword_1B7E734D0;
  HGNode::ClearBits((HGNode *)this, v7, v8);
  *((unsigned char *)this + 745) = 1;
  *((_OWORD *)this + 60) = xmmword_1B7E736B0;
  *((_OWORD *)this + 61) = xmmword_1B7E736C0;
  *((_OWORD *)this + 62) = xmmword_1B7E736D0;
  *((_OWORD *)this + 63) = xmmword_1B7E734D0;
  HGNode::ClearBits((HGNode *)this, v9, v10);
  *((unsigned char *)this + 745) = 1;
  *(void *)((char *)this + 1028) = 0;
  __asm { FMOV            V0.4S, #1.0 }
  *((_OWORD *)this + 48) = _Q0;
  *((_OWORD *)this + 49) = 0u;
  *((_OWORD *)this + 50) = 0u;
  *((_OWORD *)this + 51) = 0u;
  *((_OWORD *)this + 52) = 0u;
  *((_OWORD *)this + 53) = 0u;
  *((_OWORD *)this + 54) = 0u;
  *((unsigned char *)this + 880) = 1;
  HGColorGamma::SetYCbCrBiasAndScale((HGNode *)this, v16, v17);
  *((void *)this + 147) = 0;
}

void sub_1B7751590(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

double HGColorGamma::SetConversionPreset(uint64_t a1, uint64_t a2, char *a3)
{
  int v3 = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(unsigned char *)(a1 + 745) = 1;
  switch(v3)
  {
    case 0:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B7E736B0;
      *(_OWORD *)(a1 + 912) = xmmword_1B7E736C0;
      *(_OWORD *)(a1 + 928) = xmmword_1B7E736D0;
      *(_OWORD *)(a1 + 944) = xmmword_1B7E734D0;
      HGNode::ClearBits((HGNode *)a1, v7, v8);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = xmmword_1B7E736B0;
      *(_OWORD *)(a1 + 976) = xmmword_1B7E736C0;
      *(_OWORD *)(a1 + 992) = xmmword_1B7E736D0;
      *(_OWORD *)(a1 + 1008) = xmmword_1B7E734D0;
      HGNode::ClearBits((HGNode *)a1, v9, v10);
      *(unsigned char *)(a1 + 745) = 1;
      *(void *)(a1 + 1028) = 0;
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(a1 + 768) = _Q0;
      *(_OWORD *)(a1 + 784) = 0u;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      *(_OWORD *)(a1 + 864) = 0u;
      *(unsigned char *)(a1 + 880) = 1;
      break;
    case 1:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B7EC1CF0;
      *(_OWORD *)(a1 + 912) = xmmword_1B7EC1D00;
      long long v57 = xmmword_1B7E734D0;
      *(_OWORD *)(a1 + 928) = xmmword_1B7EC1D10;
      *(_OWORD *)(a1 + 944) = xmmword_1B7E734D0;
      HGNode::ClearBits((HGNode *)a1, v16, v17);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = xmmword_1B7E736B0;
      *(_OWORD *)(a1 + 976) = xmmword_1B7E736C0;
      long long v20 = xmmword_1B7E736D0;
      goto LABEL_5;
    case 2:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B7EC1CF0;
      *(_OWORD *)(a1 + 912) = xmmword_1B7EC1D00;
      long long v57 = xmmword_1B7E734D0;
      *(_OWORD *)(a1 + 928) = xmmword_1B7EC1D10;
      *(_OWORD *)(a1 + 944) = xmmword_1B7E734D0;
      HGNode::ClearBits((HGNode *)a1, v21, v22);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = xmmword_1B7EC1D20;
      *(_OWORD *)(a1 + 976) = xmmword_1B7EC1D30;
      long long v20 = xmmword_1B7EC1D40;
LABEL_5:
      *(_OWORD *)(a1 + 992) = v20;
      *(_OWORD *)(a1 + 1008) = v57;
      HGNode::ClearBits((HGNode *)a1, v18, v19);
      *(unsigned char *)(a1 + 745) = 1;
      *(void *)(a1 + 1028) = 6;
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(a1 + 768) = _Q0;
      *(_OWORD *)(a1 + 784) = 0u;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      *(_OWORD *)(a1 + 864) = 0u;
      *(unsigned char *)(a1 + 880) = 1;
      HGNode::ClearBits((HGNode *)a1, v25, v26);
      *(unsigned char *)(a1 + 745) = 1;
      float v24 = 2.16 - -1.14;
      *(float *)(a1 + 1156) = v24;
      *(float *)(a1 + 1160) = -1.14;
      uint64_t v29 = &HGAYCCToneCurveToLinearLUTInfo::s_1DLUTnumBins;
      goto LABEL_11;
    case 3:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B7E736B0;
      *(_OWORD *)(a1 + 912) = xmmword_1B7E736C0;
      long long v32 = xmmword_1B7E736D0;
      goto LABEL_8;
    case 4:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B7EC1CA0;
      *(_OWORD *)(a1 + 912) = xmmword_1B7EC1CB0;
      long long v32 = xmmword_1B7EC1CC0;
LABEL_8:
      *(_OWORD *)(a1 + 928) = v32;
      *(_OWORD *)(a1 + 944) = xmmword_1B7E734D0;
      HGNode::ClearBits((HGNode *)a1, v30, v31);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = xmmword_1B7E759E0;
      *(_OWORD *)(a1 + 976) = xmmword_1B7EC1CD0;
      *(_OWORD *)(a1 + 992) = xmmword_1B7EC1CE0;
      *(_OWORD *)(a1 + 1008) = xmmword_1B7E734D0;
      HGNode::ClearBits((HGNode *)a1, v33, v34);
      *(unsigned char *)(a1 + 745) = 1;
      *(void *)(a1 + 1028) = 7;
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(a1 + 768) = _Q0;
      *(_OWORD *)(a1 + 784) = 0u;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      *(_OWORD *)(a1 + 864) = 0u;
      *(unsigned char *)(a1 + 880) = 1;
      HGNode::ClearBits((HGNode *)a1, v37, v38);
      *(unsigned char *)(a1 + 745) = 1;
      float v36 = 1.42 - -0.18;
      *(float *)(a1 + 1156) = v36;
      *(float *)(a1 + 1160) = -0.18;
      uint64_t v29 = &HGLinearToAYCCToneCurveLUTInfo::s_1DLUTnumBins;
      goto LABEL_11;
    case 5:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B7E736B0;
      *(_OWORD *)(a1 + 912) = xmmword_1B7E736C0;
      *(_OWORD *)(a1 + 928) = xmmword_1B7E736D0;
      *(_OWORD *)(a1 + 944) = xmmword_1B7E734D0;
      HGNode::ClearBits((HGNode *)a1, v39, v40);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = xmmword_1B7E736B0;
      *(_OWORD *)(a1 + 976) = xmmword_1B7E736C0;
      *(_OWORD *)(a1 + 992) = xmmword_1B7E736D0;
      *(_OWORD *)(a1 + 1008) = xmmword_1B7E734D0;
      HGNode::ClearBits((HGNode *)a1, v41, v42);
      *(unsigned char *)(a1 + 745) = 1;
      *(void *)(a1 + 1028) = 8;
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(a1 + 768) = _Q0;
      *(_OWORD *)(a1 + 784) = 0u;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      *(_OWORD *)(a1 + 864) = 0u;
      *(unsigned char *)(a1 + 880) = 1;
      HGNode::ClearBits((HGNode *)a1, v45, v46);
      *(unsigned char *)(a1 + 745) = 1;
      float v44 = 1.252941 - -0.752941;
      *(float *)(a1 + 1156) = v44;
      *(float *)(a1 + 1160) = -0.752941;
      uint64_t v29 = &HG_ERsRGBToneCurveToLinearLUTInfo::s_1DLUTnumBins;
      goto LABEL_11;
    case 6:
      HGNode::ClearBits((HGNode *)a1, v5, v6);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B7E736B0;
      *(_OWORD *)(a1 + 912) = xmmword_1B7E736C0;
      *(_OWORD *)(a1 + 928) = xmmword_1B7E736D0;
      *(_OWORD *)(a1 + 944) = xmmword_1B7E734D0;
      HGNode::ClearBits((HGNode *)a1, v47, v48);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = xmmword_1B7E736B0;
      *(_OWORD *)(a1 + 976) = xmmword_1B7E736C0;
      *(_OWORD *)(a1 + 992) = xmmword_1B7E736D0;
      *(_OWORD *)(a1 + 1008) = xmmword_1B7E734D0;
      HGNode::ClearBits((HGNode *)a1, v49, v50);
      *(unsigned char *)(a1 + 745) = 1;
      *(void *)(a1 + 1028) = 9;
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(a1 + 768) = _Q0;
      *(_OWORD *)(a1 + 784) = 0u;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      *(_OWORD *)(a1 + 864) = 0u;
      *(unsigned char *)(a1 + 880) = 1;
      HGNode::ClearBits((HGNode *)a1, v53, v54);
      *(unsigned char *)(a1 + 745) = 1;
      float v52 = 1.67496694 - -0.527113747;
      *(float *)(a1 + 1156) = v52;
      *(float *)(a1 + 1160) = -0.527113747;
      uint64_t v29 = &HGLinearToERsRGBToneCurveLUTInfo::s_1DLUTnumBins;
LABEL_11:
      int v55 = *v29;
      HGNode::ClearBits((HGNode *)a1, v27, v28);
      *(unsigned char *)(a1 + 745) = 1;
      *(_DWORD *)(a1 + 1152) = v55;
      break;
    default:
      break;
  }

  *(void *)&double result = HGColorGamma::SetYCbCrBiasAndScale((HGNode *)a1, v5, v6).n128_u64[0];
  return result;
}

uint64_t HGColorGamma::ReleaseNodes(HGColorGamma *this)
{
  uint64_t v2 = *((void *)this + 53);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *((void *)this + 53) = 0;
  }
  uint64_t v3 = *((void *)this + 54);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    *((void *)this + 54) = 0;
  }
  uint64_t v4 = *((void *)this + 57);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
    *((void *)this + 57) = 0;
  }
  uint64_t v5 = *((void *)this + 55);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    *((void *)this + 55) = 0;
  }
  uint64_t v6 = *((void *)this + 56);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
    *((void *)this + 56) = 0;
  }
  uint64_t v7 = *((void *)this + 58);
  if (v7)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
    *((void *)this + 58) = 0;
  }
  uint64_t v8 = *((void *)this + 80);
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
    *((void *)this + 80) = 0;
  }
  uint64_t v9 = *((void *)this + 81);
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
    *((void *)this + 81) = 0;
  }
  uint64_t v10 = *((void *)this + 82);
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
    *((void *)this + 82) = 0;
  }
  uint64_t v11 = *((void *)this + 83);
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
    *((void *)this + 83) = 0;
  }
  uint64_t v12 = *((void *)this + 84);
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
    *((void *)this + 84) = 0;
  }
  uint64_t v13 = *((void *)this + 85);
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
    *((void *)this + 85) = 0;
  }
  uint64_t v14 = *((void *)this + 86);
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
    *((void *)this + 86) = 0;
  }
  uint64_t v15 = *((void *)this + 87);
  if (v15)
  {
    (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
    *((void *)this + 87) = 0;
  }
  uint64_t v16 = *((void *)this + 88);
  if (v16)
  {
    (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
    *((void *)this + 88) = 0;
  }
  uint64_t v17 = *((void *)this + 89);
  if (v17)
  {
    (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
    *((void *)this + 89) = 0;
  }
  uint64_t v18 = *((void *)this + 59);
  if (v18)
  {
    (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
    *((void *)this + 59) = 0;
  }
  uint64_t v19 = *((void *)this + 60);
  if (v19)
  {
    (*(void (**)(uint64_t))(*(void *)v19 + 24))(v19);
    *((void *)this + 60) = 0;
  }
  uint64_t v20 = *((void *)this + 62);
  if (v20)
  {
    (*(void (**)(uint64_t))(*(void *)v20 + 24))(v20);
    *((void *)this + 62) = 0;
  }
  uint64_t v21 = *((void *)this + 61);
  if (v21)
  {
    (*(void (**)(uint64_t))(*(void *)v21 + 24))(v21);
    *((void *)this + 61) = 0;
  }
  uint64_t v22 = *((void *)this + 63);
  if (v22)
  {
    (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
    *((void *)this + 63) = 0;
  }
  uint64_t v23 = *((void *)this + 64);
  if (v23)
  {
    (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
    *((void *)this + 64) = 0;
  }
  uint64_t v24 = *((void *)this + 65);
  if (v24)
  {
    (*(void (**)(uint64_t))(*(void *)v24 + 24))(v24);
    *((void *)this + 65) = 0;
  }
  uint64_t v25 = *((void *)this + 70);
  if (v25)
  {
    (*(void (**)(uint64_t))(*(void *)v25 + 24))(v25);
    *((void *)this + 70) = 0;
  }
  uint64_t v26 = *((void *)this + 71);
  if (v26)
  {
    (*(void (**)(uint64_t))(*(void *)v26 + 24))(v26);
    *((void *)this + 71) = 0;
  }
  uint64_t v27 = *((void *)this + 66);
  if (v27)
  {
    (*(void (**)(uint64_t))(*(void *)v27 + 24))(v27);
    *((void *)this + 66) = 0;
  }
  uint64_t v28 = *((void *)this + 68);
  if (v28)
  {
    (*(void (**)(uint64_t))(*(void *)v28 + 24))(v28);
    *((void *)this + 68) = 0;
  }
  uint64_t v29 = *((void *)this + 72);
  if (v29)
  {
    (*(void (**)(uint64_t))(*(void *)v29 + 24))(v29);
    *((void *)this + 72) = 0;
  }
  uint64_t v30 = *((void *)this + 73);
  if (v30)
  {
    (*(void (**)(uint64_t))(*(void *)v30 + 24))(v30);
    *((void *)this + 73) = 0;
  }
  uint64_t v31 = *((void *)this + 74);
  if (v31)
  {
    (*(void (**)(uint64_t))(*(void *)v31 + 24))(v31);
    *((void *)this + 74) = 0;
  }
  uint64_t v32 = *((void *)this + 75);
  if (v32)
  {
    (*(void (**)(uint64_t))(*(void *)v32 + 24))(v32);
    *((void *)this + 75) = 0;
  }
  uint64_t v33 = *((void *)this + 76);
  if (v33)
  {
    (*(void (**)(uint64_t))(*(void *)v33 + 24))(v33);
    *((void *)this + 76) = 0;
  }
  uint64_t v34 = *((void *)this + 77);
  if (v34)
  {
    (*(void (**)(uint64_t))(*(void *)v34 + 24))(v34);
    *((void *)this + 77) = 0;
  }
  uint64_t v35 = *((void *)this + 79);
  if (v35)
  {
    (*(void (**)(uint64_t))(*(void *)v35 + 24))(v35);
    *((void *)this + 79) = 0;
  }
  uint64_t v36 = *((void *)this + 78);
  if (v36)
  {
    (*(void (**)(uint64_t))(*(void *)v36 + 24))(v36);
    *((void *)this + 78) = 0;
  }
  uint64_t v37 = *((void *)this + 90);
  if (v37)
  {
    (*(void (**)(uint64_t))(*(void *)v37 + 24))(v37);
    *((void *)this + 90) = 0;
  }
  uint64_t v38 = *((void *)this + 91);
  if (v38)
  {
    (*(void (**)(uint64_t))(*(void *)v38 + 24))(v38);
    *((void *)this + 91) = 0;
  }
  uint64_t v39 = *((void *)this + 92);
  if (v39)
  {
    (*(void (**)(uint64_t))(*(void *)v39 + 24))(v39);
    *((void *)this + 92) = 0;
  }
  uint64_t result = *((void *)this + 51);
  if (result)
  {
    uint64_t result = MEMORY[0x1BA9BFBA0](result, 0x1000C4028F2CA5ALL);
    *((void *)this + 51) = 0;
  }
  return result;
}

void HGColorGamma::~HGColorGamma(HGColorGamma *this)
{
  *(void *)this = &unk_1F10D0B80;
  HGColorGamma::ReleaseNodes(this);

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10D0B80;
  HGColorGamma::ReleaseNodes(this);
  HGNode::~HGNode((HGNode *)this);

  HGObject::operator delete(v2);
}

uint64_t HGColorGamma::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

uint64_t HGColorGamma::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3 || *(void *)(a1 + 416)) {
    return 0;
  }
  else {
    return a4;
  }
}

HGNode *HGColorGamma::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v3 = (HGColorGamma *)this;
  Input = HGRenderer::GetInput(a2, this, 0);
  int v115 = Input;
  if (!Input) {
    return 0;
  }
  if (*((_DWORD *)Input + 3) == 1112363084 && !*((_DWORD *)v3 + 257))
  {
    int8x16_t v5 = vmvnq_s8((int8x16_t)vceqq_f32(vmulq_f32(*((float32x4_t *)v3 + 48), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890));
    *(int32x2_t *)v5.i8 = vpmin_s32(*(int32x2_t *)v5.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL));
    if (!vpmin_s32(*(int32x2_t *)v5.i8, *(int32x2_t *)v5.i8).u32[0])
    {
      int8x16_t v6 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 57), (float32x4_t)xmmword_1B7E736C0), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 56), (float32x4_t)xmmword_1B7E736B0)), vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 58), (float32x4_t)xmmword_1B7E736D0), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 59), (float32x4_t)xmmword_1B7E734D0))))));
      *(int32x2_t *)v6.i8 = vpmin_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
      if (!vpmin_s32(*(int32x2_t *)v6.i8, *(int32x2_t *)v6.i8).u32[0])
      {
        int8x16_t v7 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 61), (float32x4_t)xmmword_1B7E736C0), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 60), (float32x4_t)xmmword_1B7E736B0)), vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 62), (float32x4_t)xmmword_1B7E736D0), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 63), (float32x4_t)xmmword_1B7E734D0))))));
        *(int32x2_t *)v7.i8 = vpmin_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
        if (!vpmin_s32(*(int32x2_t *)v7.i8, *(int32x2_t *)v7.i8).u32[0]) {
          *((void *)v3 + 147) = Input;
        }
      }
    }
  }
  HGColorGamma::ConcatenateWithUpstreamNode((HGNode *)v3, a2, &v115);
  if (*((unsigned char *)v3 + 745))
  {
    HGColorGamma::ReleaseNodes(v3);
    operator new();
  }
  if (*((unsigned char *)v3 + 744)
    && !*((unsigned char *)v3 + 1024)
    && (*(unsigned int (**)(HGRenderer *))(*(void *)a2 + 304))(a2))
  {
    *((void *)v3 + 52) = HGBitmapLoader::GetBitmapPtr((HGBitmapLoader *)v115);
    return (HGNode *)v3;
  }
  if (!*((unsigned char *)v3 + 746))
  {
    (*(void (**)(void, void, HGNode *))(**((void **)v3 + 94) + 120))(*((void *)v3 + 94), 0, v115);
    return (HGNode *)*((void *)v3 + 95);
  }
  *((unsigned char *)v3 + 746) = 0;
  uint64_t v9 = *((int *)v3 + 265);
  if (v9 > 0x1A)
  {
    uint64_t v10 = 1;
    uint64_t v11 = v115;
    if (*((_DWORD *)v115 + 3) != 1112363084) {
      goto LABEL_34;
    }
  }
  else
  {
    uint64_t v10 = dword_1B7EC2F28[v9];
    uint64_t v11 = v115;
    if (*((_DWORD *)v115 + 3) != 1112363084) {
      goto LABEL_34;
    }
  }
  int BitmapFormat = HGBitmapLoader::GetBitmapFormat((HGBitmapLoader *)v11);
  int v13 = BitmapFormat;
  switch(BitmapFormat)
  {
    case 14:
      goto LABEL_25;
    case 31:
      if (*((_DWORD *)v3 + 265) != 2)
      {
LABEL_34:
        int v17 = 0;
        uint64_t v15 = 0;
        uint64_t v18 = (HGNode *)*((void *)v3 + 94);
        if (!v18) {
          goto LABEL_46;
        }
        goto LABEL_44;
      }
      break;
    case 16:
      if (*((_DWORD *)v3 + 265) != 3) {
        goto LABEL_34;
      }
      break;
    case 15:
LABEL_25:
      if (*((_DWORD *)v3 + 265) != 1) {
        goto LABEL_34;
      }
      break;
    default:
      goto LABEL_34;
  }
  if ((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2))
  {
    uint64_t v15 = 0;
  }
  else
  {
    if (v13 == 14)
    {
      uint64_t v15 = (HGNode *)*((void *)v3 + 59);
      if (!v15)
      {
        uint64_t v16 = (HgcColorGamma_2vuy_yxzx_expand *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)uint64_t v16 = 0u;
        *((_OWORD *)v16 + 1) = 0u;
        *((_OWORD *)v16 + 2) = 0u;
        *((_OWORD *)v16 + 3) = 0u;
        *((_OWORD *)v16 + 4) = 0u;
        *((_OWORD *)v16 + 5) = 0u;
        *((_OWORD *)v16 + 6) = 0u;
        *((_OWORD *)v16 + 7) = 0u;
        *((_OWORD *)v16 + 8) = 0u;
        *((_OWORD *)v16 + 9) = 0u;
        *((_OWORD *)v16 + 10) = 0u;
        *((_OWORD *)v16 + 11) = 0u;
        *((_OWORD *)v16 + 12) = 0u;
        *((_OWORD *)v16 + 13) = 0u;
        *((_OWORD *)v16 + 14) = 0u;
        *((_OWORD *)v16 + 15) = 0u;
        *((_OWORD *)v16 + 16) = 0u;
        *((_OWORD *)v16 + 17) = 0u;
        *((_OWORD *)v16 + 18) = 0u;
        *((_OWORD *)v16 + 19) = 0u;
        *((_OWORD *)v16 + 20) = 0u;
        *((_OWORD *)v16 + 21) = 0u;
        *((_OWORD *)v16 + 22) = 0u;
        *((_OWORD *)v16 + 23) = 0u;
        *((_OWORD *)v16 + 24) = 0u;
        *((_OWORD *)v16 + 25) = 0u;
        HgcColorGamma_2vuy_yxzx_expand::HgcColorGamma_2vuy_yxzx_expand(v16);
      }
    }
    else
    {
      if (v13 == 31)
      {
        uint64_t v19 = HGColorGamma::m_Getv210_YXZXExpandNode(v3, v14);
      }
      else if (v13 == 15)
      {
        uint64_t v19 = HGColorGamma::m_Get2vuy_XYXZExpandNode(v3);
      }
      else
      {
        uint64_t v19 = HGColorGamma::m_Getv216_YXZXExpandNode(v3);
      }
      uint64_t v15 = (HGNode *)v19;
    }
    (*(void (**)(HGNode *, void, HGNode *))(*(void *)v15 + 120))(v15, 0, v11);
    *((void *)v3 + 94) = v15;
  }
  int v17 = 1;
  uint64_t v18 = (HGNode *)*((void *)v3 + 94);
  if (v18)
  {
LABEL_44:
    if (*((unsigned char *)v3 + 1026)) {
      HGNode::SetSupportedFormatPrecisions(v18, (const char *)v10, v8);
    }
  }
LABEL_46:
  switch(*((_DWORD *)v3 + 264))
  {
    case 0xE:
    case 0xF:
      if (*((_DWORD *)v3 + 266) == 1) {
        goto LABEL_48;
      }
      break;
    case 0x10:
      if (*((_DWORD *)v3 + 266) == 3) {
        goto LABEL_48;
      }
      break;
    case 0x1F:
      if (*((_DWORD *)v3 + 266) == 2) {
LABEL_48:
      }
        *((unsigned char *)v3 + 1173) = 1;
      break;
    default:
      break;
  }
  int v20 = *((_DWORD *)v3 + 257);
  if (v20)
  {
    if (v20 > 4)
    {
      if (v20 >= 0xA)
      {
        HDRFunctionNode = HGColorGamma::m_GetHDRFunctionNode((uint64_t)v3, v20);
        goto LABEL_68;
      }
LABEL_76:
      uint64_t v25 = (HGApply1DLUT *)*((void *)v3 + 80);
      if (!v25)
      {
        uint64_t v25 = (HGApply1DLUT *)HGObject::operator new(0x1D0uLL);
        HGApply1DLUT::HGApply1DLUT(v25, *((_DWORD *)v3 + 288), *((float *)v3 + 289), *((float *)v3 + 290), 1, 1, 1, 0, 1, 1);
        LOBYTE(v26) = 0;
        *((void *)v3 + 80) = v25;
        if (v17) {
          goto LABEL_103;
        }
        goto LABEL_109;
      }
      goto LABEL_77;
    }
    int v21 = *((_DWORD *)v3 + 292);
    if (v21 == 2)
    {
      switch(v20)
      {
        case 3:
          HDRFunctionNode = (HGHLG::OETF *)HGColorGamma::m_GetToneParamCurve3(v3);
          break;
        case 2:
          HDRFunctionNode = HGColorGamma::m_GetToneParamCurve2(v3);
          break;
        case 1:
          HDRFunctionNode = HGColorGamma::m_GetToneParamCurve1(v3);
          break;
        default:
          HDRFunctionNode = HGColorGamma::m_GetToneParamCurve4(v3);
          break;
      }
LABEL_68:
      uint64_t v25 = HDRFunctionNode;
      LOBYTE(v26) = 0;
      if (v17) {
        goto LABEL_103;
      }
LABEL_109:
      uint64_t v30 = v15;
      goto LABEL_110;
    }
LABEL_70:
    if (v21 >= 3 && *((unsigned char *)v3 + 880))
    {
      if (*((unsigned char *)v3 + 1172))
      {
        if (*((unsigned char *)v3 + 1173)) {
          uint64_t v26 = v17 ^ 1u;
        }
        else {
          uint64_t v26 = 0;
        }
      }
      else
      {
        uint64_t v26 = 0;
      }
      GammaFittedNode = (HGNode *)HGColorGamma::m_GetGammaFittedNode(v3);
      HGToneCurve::SetPremultiplyState(GammaFittedNode, v26, v29);
      uint64_t v25 = (HGApply1DLUT *)HGColorGamma::m_GetGammaFittedNode(v3);
      if (!v17) {
        goto LABEL_109;
      }
      goto LABEL_103;
    }
    goto LABEL_76;
  }
  int8x16_t v23 = vmvnq_s8((int8x16_t)vceqq_f32(vmulq_f32(*((float32x4_t *)v3 + 48), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890));
  *(int32x2_t *)v23.i8 = vpmin_s32(*(int32x2_t *)v23.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v23.i8, *(int32x2_t *)v23.i8).u32[0])
  {
    int v21 = *((_DWORD *)v3 + 292);
    if ((v21 - 1) > 1) {
      goto LABEL_70;
    }
    if (*((unsigned char *)v3 + 1172))
    {
      char v24 = *((unsigned char *)v3 + 1173) ? v17 : 1;
      if ((v24 & 1) == 0)
      {
        if (*((unsigned char *)v3 + 880)) {
          GammaUniformNode = HGColorGamma::m_GetGammaUniformNode(v3);
        }
        else {
          GammaUniformNode = HGColorGamma::m_GetGammaMCNode(v3);
        }
        uint64_t v25 = GammaUniformNode;
        LOBYTE(v26) = 1;
        if (!v17) {
          goto LABEL_109;
        }
        goto LABEL_103;
      }
    }
    uint64_t v25 = (HGApply1DLUT *)*((void *)v3 + 57);
    if (v25)
    {
LABEL_77:
      LOBYTE(v26) = 0;
      if (v17) {
        goto LABEL_103;
      }
      goto LABEL_109;
    }
    uint64_t v26 = (uint64_t)HGObject::operator new(0x1B0uLL);
    HGGamma::HGGamma((HGGamma *)v26);
    *((void *)v3 + 57) = v26;
    HGGamma::SetPremultiplyState(v26, 0);
    LOBYTE(v26) = 0;
    uint64_t v25 = (HGApply1DLUT *)*((void *)v3 + 57);
    if (!v17) {
      goto LABEL_109;
    }
  }
  else
  {
    if (!*((unsigned char *)v3 + 1172))
    {
      LOBYTE(v26) = 0;
      uint64_t v25 = 0;
      if (v17) {
        goto LABEL_103;
      }
      goto LABEL_109;
    }
    uint64_t v25 = 0;
    if (*((unsigned char *)v3 + 1173)) {
      LOBYTE(v26) = v17 ^ 1;
    }
    else {
      LOBYTE(v26) = 0;
    }
    if (!v17) {
      goto LABEL_109;
    }
  }
LABEL_103:
  if (!*((unsigned char *)v3 + 1026) || *((_DWORD *)v3 + 259) != 1) {
    goto LABEL_109;
  }
  uint64_t v30 = (HGNode *)*((void *)v3 + 75);
  if (!v30)
  {
    uint64_t v31 = (HgcColorGamma_chroma_upsample_f1 *)HGObject::operator new(0x1A0uLL);
    *(_OWORD *)uint64_t v31 = 0u;
    *((_OWORD *)v31 + 1) = 0u;
    *((_OWORD *)v31 + 2) = 0u;
    *((_OWORD *)v31 + 3) = 0u;
    *((_OWORD *)v31 + 4) = 0u;
    *((_OWORD *)v31 + 5) = 0u;
    *((_OWORD *)v31 + 6) = 0u;
    *((_OWORD *)v31 + 7) = 0u;
    *((_OWORD *)v31 + 8) = 0u;
    *((_OWORD *)v31 + 9) = 0u;
    *((_OWORD *)v31 + 10) = 0u;
    *((_OWORD *)v31 + 11) = 0u;
    *((_OWORD *)v31 + 12) = 0u;
    *((_OWORD *)v31 + 13) = 0u;
    *((_OWORD *)v31 + 14) = 0u;
    *((_OWORD *)v31 + 15) = 0u;
    *((_OWORD *)v31 + 16) = 0u;
    *((_OWORD *)v31 + 17) = 0u;
    *((_OWORD *)v31 + 18) = 0u;
    *((_OWORD *)v31 + 19) = 0u;
    *((_OWORD *)v31 + 20) = 0u;
    *((_OWORD *)v31 + 21) = 0u;
    *((_OWORD *)v31 + 22) = 0u;
    *((_OWORD *)v31 + 23) = 0u;
    *((_OWORD *)v31 + 24) = 0u;
    *((_OWORD *)v31 + 25) = 0u;
    HgcColorGamma_chroma_upsample_f1::HgcColorGamma_chroma_upsample_f1(v31);
  }
  uint64_t v32 = *(void (**)(HGNode *, void, HGNode *))(*(void *)v30 + 120);
  if (v15)
  {
    v32(v30, 0, v15);
  }
  else
  {
    v32(v30, 0, v11);
    *((void *)v3 + 94) = v30;
  }
  HGNode::SetSupportedFormatPrecisions(v30, (const char *)v10, v33);
LABEL_110:
  int8x16_t v34 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 57), (float32x4_t)xmmword_1B7E736C0), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 56), (float32x4_t)xmmword_1B7E736B0)), vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 58), (float32x4_t)xmmword_1B7E736D0), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 59), (float32x4_t)xmmword_1B7E734D0))))));
  *(int32x2_t *)v34.i8 = vpmin_s32(*(int32x2_t *)v34.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v34.i8, *(int32x2_t *)v34.i8).u32[0]) {
    __asm { FMOV            V2.4S, #1.0 }
  }
  else {
    _Q2 = *((float32x4_t *)v3 + 67);
  }
  float32x4_t v40 = vmulq_f32(_Q2, *((float32x4_t *)v3 + 69));
  int8x16_t v41 = (int8x16_t)vceqzq_f32(v40);
  *(int32x2_t *)v41.i8 = vpmax_s32(*(int32x2_t *)v41.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL));
  if (!vpmax_s32(*(int32x2_t *)v41.i8, *(int32x2_t *)v41.i8).u32[0]) {
    goto LABEL_115;
  }
  __asm { FMOV            V0.4S, #1.0 }
  int8x16_t v43 = vmvnq_s8((int8x16_t)vceqq_f32(_Q2, _Q0));
  *(int32x2_t *)v43.i8 = vpmin_s32(*(int32x2_t *)v43.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v43.i8, *(int32x2_t *)v43.i8).u32[0])
  {
LABEL_115:
    uint64_t v44 = *((void *)v3 + 66);
    __n128 v111 = (__n128)_Q2;
    float32x4_t v112 = v40;
    if (v30)
    {
      if (!v44)
      {
        uint64_t v45 = (HgcColorGamma_bias *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)uint64_t v45 = 0u;
        *((_OWORD *)v45 + 1) = 0u;
        *((_OWORD *)v45 + 2) = 0u;
        *((_OWORD *)v45 + 3) = 0u;
        *((_OWORD *)v45 + 4) = 0u;
        *((_OWORD *)v45 + 5) = 0u;
        *((_OWORD *)v45 + 6) = 0u;
        *((_OWORD *)v45 + 7) = 0u;
        *((_OWORD *)v45 + 8) = 0u;
        *((_OWORD *)v45 + 9) = 0u;
        *((_OWORD *)v45 + 10) = 0u;
        *((_OWORD *)v45 + 11) = 0u;
        *((_OWORD *)v45 + 12) = 0u;
        *((_OWORD *)v45 + 13) = 0u;
        *((_OWORD *)v45 + 14) = 0u;
        *((_OWORD *)v45 + 15) = 0u;
        *((_OWORD *)v45 + 16) = 0u;
        *((_OWORD *)v45 + 17) = 0u;
        *((_OWORD *)v45 + 18) = 0u;
        *((_OWORD *)v45 + 19) = 0u;
        *((_OWORD *)v45 + 20) = 0u;
        *((_OWORD *)v45 + 21) = 0u;
        *((_OWORD *)v45 + 22) = 0u;
        *((_OWORD *)v45 + 23) = 0u;
        *((_OWORD *)v45 + 24) = 0u;
        *((_OWORD *)v45 + 25) = 0u;
        HgcColorGamma_bias::HgcColorGamma_bias(v45);
      }
      (*(void (**)(uint64_t, void, HGNode *))(*(void *)v44 + 120))(v44, 0, v30);
      uint64_t v30 = (HGNode *)*((void *)v3 + 66);
      if (!v30)
      {
        int v46 = (HgcColorGamma_bias *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)int v46 = 0u;
        *((_OWORD *)v46 + 1) = 0u;
        *((_OWORD *)v46 + 2) = 0u;
        *((_OWORD *)v46 + 3) = 0u;
        *((_OWORD *)v46 + 4) = 0u;
        *((_OWORD *)v46 + 5) = 0u;
        *((_OWORD *)v46 + 6) = 0u;
        *((_OWORD *)v46 + 7) = 0u;
        *((_OWORD *)v46 + 8) = 0u;
        *((_OWORD *)v46 + 9) = 0u;
        *((_OWORD *)v46 + 10) = 0u;
        *((_OWORD *)v46 + 11) = 0u;
        *((_OWORD *)v46 + 12) = 0u;
        *((_OWORD *)v46 + 13) = 0u;
        *((_OWORD *)v46 + 14) = 0u;
        *((_OWORD *)v46 + 15) = 0u;
        *((_OWORD *)v46 + 16) = 0u;
        *((_OWORD *)v46 + 17) = 0u;
        *((_OWORD *)v46 + 18) = 0u;
        *((_OWORD *)v46 + 19) = 0u;
        *((_OWORD *)v46 + 20) = 0u;
        *((_OWORD *)v46 + 21) = 0u;
        *((_OWORD *)v46 + 22) = 0u;
        *((_OWORD *)v46 + 23) = 0u;
        *((_OWORD *)v46 + 24) = 0u;
        *((_OWORD *)v46 + 25) = 0u;
        HgcColorGamma_bias::HgcColorGamma_bias(v46);
      }
    }
    else
    {
      if (!v44)
      {
        uint64_t v47 = (HgcColorGamma_bias *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)uint64_t v47 = 0u;
        *((_OWORD *)v47 + 1) = 0u;
        *((_OWORD *)v47 + 2) = 0u;
        *((_OWORD *)v47 + 3) = 0u;
        *((_OWORD *)v47 + 4) = 0u;
        *((_OWORD *)v47 + 5) = 0u;
        *((_OWORD *)v47 + 6) = 0u;
        *((_OWORD *)v47 + 7) = 0u;
        *((_OWORD *)v47 + 8) = 0u;
        *((_OWORD *)v47 + 9) = 0u;
        *((_OWORD *)v47 + 10) = 0u;
        *((_OWORD *)v47 + 11) = 0u;
        *((_OWORD *)v47 + 12) = 0u;
        *((_OWORD *)v47 + 13) = 0u;
        *((_OWORD *)v47 + 14) = 0u;
        *((_OWORD *)v47 + 15) = 0u;
        *((_OWORD *)v47 + 16) = 0u;
        *((_OWORD *)v47 + 17) = 0u;
        *((_OWORD *)v47 + 18) = 0u;
        *((_OWORD *)v47 + 19) = 0u;
        *((_OWORD *)v47 + 20) = 0u;
        *((_OWORD *)v47 + 21) = 0u;
        *((_OWORD *)v47 + 22) = 0u;
        *((_OWORD *)v47 + 23) = 0u;
        *((_OWORD *)v47 + 24) = 0u;
        *((_OWORD *)v47 + 25) = 0u;
        HgcColorGamma_bias::HgcColorGamma_bias(v47);
      }
      (*(void (**)(uint64_t, void, HGNode *))(*(void *)v44 + 120))(v44, 0, v11);
      uint64_t v30 = (HGNode *)*((void *)v3 + 66);
      if (!v30)
      {
        uint64_t v48 = (HgcColorGamma_bias *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)uint64_t v48 = 0u;
        *((_OWORD *)v48 + 1) = 0u;
        *((_OWORD *)v48 + 2) = 0u;
        *((_OWORD *)v48 + 3) = 0u;
        *((_OWORD *)v48 + 4) = 0u;
        *((_OWORD *)v48 + 5) = 0u;
        *((_OWORD *)v48 + 6) = 0u;
        *((_OWORD *)v48 + 7) = 0u;
        *((_OWORD *)v48 + 8) = 0u;
        *((_OWORD *)v48 + 9) = 0u;
        *((_OWORD *)v48 + 10) = 0u;
        *((_OWORD *)v48 + 11) = 0u;
        *((_OWORD *)v48 + 12) = 0u;
        *((_OWORD *)v48 + 13) = 0u;
        *((_OWORD *)v48 + 14) = 0u;
        *((_OWORD *)v48 + 15) = 0u;
        *((_OWORD *)v48 + 16) = 0u;
        *((_OWORD *)v48 + 17) = 0u;
        *((_OWORD *)v48 + 18) = 0u;
        *((_OWORD *)v48 + 19) = 0u;
        *((_OWORD *)v48 + 20) = 0u;
        *((_OWORD *)v48 + 21) = 0u;
        *((_OWORD *)v48 + 22) = 0u;
        *((_OWORD *)v48 + 23) = 0u;
        *((_OWORD *)v48 + 24) = 0u;
        *((_OWORD *)v48 + 25) = 0u;
        HgcColorGamma_bias::HgcColorGamma_bias(v48);
      }
      *((void *)v3 + 94) = v30;
    }
    (*(void (**)(HGNode *, void, float, float, float, double))(*(void *)v30 + 96))(v30, 0, -v112.f32[0], -v112.f32[1], -v112.f32[2], 0.0);
    (*(void (**)(HGNode *, uint64_t, __n128, float, float, float))(*(void *)v30 + 96))(v30, 1, v111, v111.n128_f32[1], v111.n128_f32[2], 1.0);
  }
  if (v17)
  {
    if (!*((unsigned char *)v3 + 1026) && *((_DWORD *)v3 + 259) == 1)
    {
      uint64_t v49 = (HGNode *)*((void *)v3 + 75);
      if (!v49)
      {
        int v50 = (HgcColorGamma_chroma_upsample_f1 *)HGObject::operator new(0x1A0uLL);
        *(_OWORD *)int v50 = 0u;
        *((_OWORD *)v50 + 1) = 0u;
        *((_OWORD *)v50 + 2) = 0u;
        *((_OWORD *)v50 + 3) = 0u;
        *((_OWORD *)v50 + 4) = 0u;
        *((_OWORD *)v50 + 5) = 0u;
        *((_OWORD *)v50 + 6) = 0u;
        *((_OWORD *)v50 + 7) = 0u;
        *((_OWORD *)v50 + 8) = 0u;
        *((_OWORD *)v50 + 9) = 0u;
        *((_OWORD *)v50 + 10) = 0u;
        *((_OWORD *)v50 + 11) = 0u;
        *((_OWORD *)v50 + 12) = 0u;
        *((_OWORD *)v50 + 13) = 0u;
        *((_OWORD *)v50 + 14) = 0u;
        *((_OWORD *)v50 + 15) = 0u;
        *((_OWORD *)v50 + 16) = 0u;
        *((_OWORD *)v50 + 17) = 0u;
        *((_OWORD *)v50 + 18) = 0u;
        *((_OWORD *)v50 + 19) = 0u;
        *((_OWORD *)v50 + 20) = 0u;
        *((_OWORD *)v50 + 21) = 0u;
        *((_OWORD *)v50 + 22) = 0u;
        *((_OWORD *)v50 + 23) = 0u;
        *((_OWORD *)v50 + 24) = 0u;
        *((_OWORD *)v50 + 25) = 0u;
        HgcColorGamma_chroma_upsample_f1::HgcColorGamma_chroma_upsample_f1(v50);
      }
      uint64_t v51 = *(void (**)(HGNode *, void, HGNode *))(*(void *)v49 + 120);
      if (v30)
      {
        v51(v49, 0, v30);
        uint64_t v52 = 0;
      }
      else
      {
        v51(v49, 0, v11);
        uint64_t v52 = 0;
        *((void *)v3 + 94) = v49;
      }
      char v53 = 1;
      goto LABEL_144;
    }
    goto LABEL_141;
  }
  if (!*((unsigned char *)v3 + 1172) || (*((unsigned char *)v3 + 1173) ? (char v54 = v26) : (char v54 = 0), (v54 & 1) != 0))
  {
LABEL_141:
    uint64_t v52 = 0;
    goto LABEL_142;
  }
  uint64_t UnpremultiplyNode = HGColorGamma::m_GetUnpremultiplyNode(v3);
  uint64_t v52 = UnpremultiplyNode;
  if (!UnpremultiplyNode)
  {
LABEL_142:
    char v53 = 1;
    if (v30) {
      goto LABEL_143;
    }
    goto LABEL_155;
  }
  if (*((unsigned char *)v3 + 1174))
  {
    (*(void (**)(void))(*(void *)UnpremultiplyNode + 120))();
    char v53 = 0;
    if (!v30) {
      *((void *)v3 + 94) = v52;
    }
    uint64_t v49 = (HGNode *)v52;
LABEL_144:
    uint64_t v55 = *((void *)v3 + 53);
    if (!v55)
    {
      int v56 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
      HGColorMatrix::HGColorMatrix(v56);
    }
    (*(void (**)(uint64_t, void, HGNode *))(*(void *)v55 + 120))(v55, 0, v49);
    if (v53) {
      goto LABEL_162;
    }
    goto LABEL_161;
  }
  char v53 = 0;
  if (v30)
  {
LABEL_143:
    uint64_t v49 = v30;
    goto LABEL_144;
  }
LABEL_155:
  uint64_t v58 = *((void *)v3 + 53);
  if (!v58)
  {
    uint64_t v59 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v59);
  }
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v58 + 120))(v58, 0, v11);
  uint64_t v60 = *((void *)v3 + 53);
  if (!v60)
  {
    int v61 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v61);
  }
  *((void *)v3 + 94) = v60;
  if (v53)
  {
LABEL_162:
    uint64_t v52 = *((void *)v3 + 53);
    if (!v52)
    {
      unint64_t v67 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
      HGColorMatrix::HGColorMatrix(v67);
    }
    if (v25) {
      goto LABEL_164;
    }
    goto LABEL_171;
  }
LABEL_161:
  if (*((unsigned char *)v3 + 1174)) {
    goto LABEL_162;
  }
  uint64_t v75 = *((void *)v3 + 53);
  if (!v75)
  {
    long long v76 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v76);
  }
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v52 + 120))(v52, 0, v75);
  if (v25)
  {
LABEL_164:
    (*(void (**)(HGApply1DLUT *, void, uint64_t))(*(void *)v25 + 120))(v25, 0, v52);
    uint64_t v62 = *((void *)v3 + 54);
    if (!v62)
    {
      uint64_t v63 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
      HGColorMatrix::HGColorMatrix(v63);
    }
    (*(void (**)(uint64_t, void, HGApply1DLUT *))(*(void *)v62 + 120))(v62, 0, v25);
    uint64_t v64 = (HGNode *)*((void *)v3 + 54);
    if (v64) {
      goto LABEL_167;
    }
LABEL_174:
    uint64_t v70 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v70);
  }
LABEL_171:
  uint64_t v68 = *((void *)v3 + 54);
  if (!v68)
  {
    uint64_t v69 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v69);
  }
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v68 + 120))(v68, 0, v52);
  uint64_t v64 = (HGNode *)*((void *)v3 + 54);
  if (!v64) {
    goto LABEL_174;
  }
LABEL_167:
  uint64_t v65 = *((int *)v3 + 266);
  if (v65 <= 0x1A)
  {
    uint64_t v66 = dword_1B7EC2F28[v65];
    if (v17) {
      goto LABEL_194;
    }
LABEL_176:
    if (*((unsigned char *)v3 + 1172))
    {
      if (*((unsigned char *)v3 + 1173)) {
        char v71 = v26;
      }
      else {
        char v71 = 1;
      }
      if ((v71 & 1) == 0)
      {
        uint64_t v72 = *((void *)v3 + 72);
        if (!v72)
        {
          int v73 = (HgcPremultiply *)HGObject::operator new(0x1A0uLL);
          HgcPremultiply::HgcPremultiply(v73);
        }
        (*(void (**)(uint64_t, void, HGNode *))(*(void *)v72 + 120))(v72, 0, v64);
        uint64_t v64 = (HGNode *)*((void *)v3 + 72);
        if (!v64)
        {
          long long v74 = (HgcPremultiply *)HGObject::operator new(0x1A0uLL);
          HgcPremultiply::HgcPremultiply(v74);
        }
      }
    }
    else if (*((unsigned char *)v3 + 1173))
    {
      uint64_t v77 = *((void *)v3 + 72);
      if (!v77)
      {
        unsigned __int16 v78 = (HgcPremultiply *)HGObject::operator new(0x1A0uLL);
        HgcPremultiply::HgcPremultiply(v78);
      }
      (*(void (**)(uint64_t, void, HGNode *))(*(void *)v77 + 120))(v77, 0, v64);
      uint64_t v64 = (HGNode *)*((void *)v3 + 72);
      if (!v64)
      {
        unsigned __int8 v79 = (HgcPremultiply *)HGObject::operator new(0x1A0uLL);
        HgcPremultiply::HgcPremultiply(v79);
      }
    }
    goto LABEL_194;
  }
  uint64_t v66 = 1;
  if ((v17 & 1) == 0) {
    goto LABEL_176;
  }
LABEL_194:
  int8x16_t v80 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 61), (float32x4_t)xmmword_1B7E736C0), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 60), (float32x4_t)xmmword_1B7E736B0)), vandq_s8((int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 62), (float32x4_t)xmmword_1B7E736D0), (int8x16_t)vceqq_f32(*((float32x4_t *)v3 + 63), (float32x4_t)xmmword_1B7E734D0))))));
  *(int32x2_t *)v80.i8 = vpmin_s32(*(int32x2_t *)v80.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v80, v80, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v80.i8, *(int32x2_t *)v80.i8).u32[0]) {
    __asm { FMOV            V2.4S, #1.0 }
  }
  else {
    _Q2 = *((float32x4_t *)v3 + 68);
  }
  int8x16_t v82 = (int8x16_t)vceqzq_f32(*((float32x4_t *)v3 + 70));
  *(int32x2_t *)v82.i8 = vpmax_s32(*(int32x2_t *)v82.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v82, v82, 8uLL));
  if (!vpmax_s32(*(int32x2_t *)v82.i8, *(int32x2_t *)v82.i8).u32[0]) {
    goto LABEL_199;
  }
  __asm { FMOV            V0.4S, #1.0 }
  int8x16_t v84 = vmvnq_s8((int8x16_t)vceqq_f32(_Q2, _Q0));
  *(int32x2_t *)v84.i8 = vpmin_s32(*(int32x2_t *)v84.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v84, v84, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v84.i8, *(int32x2_t *)v84.i8).u32[0])
  {
LABEL_199:
    __n128 v113 = (__n128)_Q2;
    *(_OWORD *)long long v114 = *((_OWORD *)v3 + 70);
    uint64_t v85 = *((void *)v3 + 68);
    if (!v85)
    {
      unsigned __int8 v86 = (HgcColorGamma_bias *)HGObject::operator new(0x1A0uLL);
      *(_OWORD *)unsigned __int8 v86 = 0u;
      *((_OWORD *)v86 + 1) = 0u;
      *((_OWORD *)v86 + 2) = 0u;
      *((_OWORD *)v86 + 3) = 0u;
      *((_OWORD *)v86 + 4) = 0u;
      *((_OWORD *)v86 + 5) = 0u;
      *((_OWORD *)v86 + 6) = 0u;
      *((_OWORD *)v86 + 7) = 0u;
      *((_OWORD *)v86 + 8) = 0u;
      *((_OWORD *)v86 + 9) = 0u;
      *((_OWORD *)v86 + 10) = 0u;
      *((_OWORD *)v86 + 11) = 0u;
      *((_OWORD *)v86 + 12) = 0u;
      *((_OWORD *)v86 + 13) = 0u;
      *((_OWORD *)v86 + 14) = 0u;
      *((_OWORD *)v86 + 15) = 0u;
      *((_OWORD *)v86 + 16) = 0u;
      *((_OWORD *)v86 + 17) = 0u;
      *((_OWORD *)v86 + 18) = 0u;
      *((_OWORD *)v86 + 19) = 0u;
      *((_OWORD *)v86 + 20) = 0u;
      *((_OWORD *)v86 + 21) = 0u;
      *((_OWORD *)v86 + 22) = 0u;
      *((_OWORD *)v86 + 23) = 0u;
      *((_OWORD *)v86 + 24) = 0u;
      *((_OWORD *)v86 + 25) = 0u;
      HgcColorGamma_bias::HgcColorGamma_bias(v86);
    }
    (*(void (**)(uint64_t, void, HGNode *))(*(void *)v85 + 120))(v85, 0, v64);
    uint64_t v64 = (HGNode *)*((void *)v3 + 68);
    if (!v64)
    {
      uint64_t v87 = (HgcColorGamma_bias *)HGObject::operator new(0x1A0uLL);
      *(_OWORD *)uint64_t v87 = 0u;
      *((_OWORD *)v87 + 1) = 0u;
      *((_OWORD *)v87 + 2) = 0u;
      *((_OWORD *)v87 + 3) = 0u;
      *((_OWORD *)v87 + 4) = 0u;
      *((_OWORD *)v87 + 5) = 0u;
      *((_OWORD *)v87 + 6) = 0u;
      *((_OWORD *)v87 + 7) = 0u;
      *((_OWORD *)v87 + 8) = 0u;
      *((_OWORD *)v87 + 9) = 0u;
      *((_OWORD *)v87 + 10) = 0u;
      *((_OWORD *)v87 + 11) = 0u;
      *((_OWORD *)v87 + 12) = 0u;
      *((_OWORD *)v87 + 13) = 0u;
      *((_OWORD *)v87 + 14) = 0u;
      *((_OWORD *)v87 + 15) = 0u;
      *((_OWORD *)v87 + 16) = 0u;
      *((_OWORD *)v87 + 17) = 0u;
      *((_OWORD *)v87 + 18) = 0u;
      *((_OWORD *)v87 + 19) = 0u;
      *((_OWORD *)v87 + 20) = 0u;
      *((_OWORD *)v87 + 21) = 0u;
      *((_OWORD *)v87 + 22) = 0u;
      *((_OWORD *)v87 + 23) = 0u;
      *((_OWORD *)v87 + 24) = 0u;
      *((_OWORD *)v87 + 25) = 0u;
      HgcColorGamma_bias::HgcColorGamma_bias(v87);
    }
    (*(void (**)(HGNode *, void, float, float, float, float))(*(void *)v64 + 96))(v64, 0, -v114[0], -v114[1], -v114[2], -v114[3]);
    (*(void (**)(HGNode *, uint64_t, __n128, float, float, float))(*(void *)v64 + 96))(v64, 1, v113, v113.n128_f32[1], v113.n128_f32[2], v113.n128_f32[3]);
    if (*((unsigned char *)v3 + 1026)) {
      HGNode::SetSupportedFormatPrecisions(v64, (const char *)v66, v88);
    }
  }
  if (*((unsigned char *)v3 + 1025))
  {
    uint64_t v89 = (HGDither *)*((void *)v3 + 92);
    if (!v89)
    {
      uint64_t v89 = (HGDither *)HGObject::operator new(0x1D0uLL);
      HGDither::HGDither(v89);
      *((void *)v3 + 92) = v89;
    }
    (*(void (**)(HGDither *, void, double, double, double, double))(*(void *)v89 + 96))(v89, 0, 0.0, 0.0, 0.0, 0.0);
    uint64_t v90 = (HGDither *)*((void *)v3 + 92);
    if (!v90)
    {
      uint64_t v90 = (HGDither *)HGObject::operator new(0x1D0uLL);
      HGDither::HGDither(v90);
      *((void *)v3 + 92) = v90;
    }
    (*(void (**)(HGDither *, void, HGNode *))(*(void *)v90 + 120))(v90, 0, v64);
    uint64_t v64 = (HGNode *)*((void *)v3 + 92);
    if (!v64)
    {
      uint64_t v64 = (HGNode *)HGObject::operator new(0x1D0uLL);
      HGDither::HGDither((HGDither *)v64);
      *((void *)v3 + 92) = v64;
    }
    if (*((unsigned char *)v3 + 1026)) {
      HGNode::SetSupportedFormatPrecisions(v64, (const char *)v66, v91);
    }
  }
  switch(*((_DWORD *)v3 + 264))
  {
    case 0xE:
    case 0xF:
      if (*((_DWORD *)v3 + 266) == 1) {
        goto LABEL_228;
      }
      break;
    case 0x10:
      if (*((_DWORD *)v3 + 266) == 3) {
        goto LABEL_228;
      }
      break;
    case 0x16:
      if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) == 0)
      {
        uint64_t PixelFormatConversion_kV4B_WXYZ_OutputNode = HGColorGamma::m_GetPixelFormatConversion_kV4B_WXYZ_OutputNode(v3);
        (*(void (**)(uint64_t, void, HGNode *))(*(void *)PixelFormatConversion_kV4B_WXYZ_OutputNode + 120))(PixelFormatConversion_kV4B_WXYZ_OutputNode, 0, v64);
        uint64_t v93 = HGColorGamma::m_GetPixelFormatConversion_kV4B_WXYZ_OutputNode(v3);
        goto LABEL_242;
      }
      break;
    case 0x1A:
      if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) == 0)
      {
        uint64_t PixelFormatConversion_kV4S_WXYZ_OutputNode = HGColorGamma::m_GetPixelFormatConversion_kV4S_WXYZ_OutputNode(v3);
        (*(void (**)(uint64_t, void, HGNode *))(*(void *)PixelFormatConversion_kV4S_WXYZ_OutputNode + 120))(PixelFormatConversion_kV4S_WXYZ_OutputNode, 0, v64);
        uint64_t v93 = HGColorGamma::m_GetPixelFormatConversion_kV4S_WXYZ_OutputNode(v3);
        goto LABEL_242;
      }
      break;
    case 0x1D:
      if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) == 0)
      {
        uint64_t PixelFormatConversion_kV4F_WXYZ_OutputNode = HGColorGamma::m_GetPixelFormatConversion_kV4F_WXYZ_OutputNode(v3);
        (*(void (**)(uint64_t, void, HGNode *))(*(void *)PixelFormatConversion_kV4F_WXYZ_OutputNode + 120))(PixelFormatConversion_kV4F_WXYZ_OutputNode, 0, v64);
        uint64_t v93 = HGColorGamma::m_GetPixelFormatConversion_kV4F_WXYZ_OutputNode(v3);
        goto LABEL_242;
      }
      break;
    case 0x1F:
      if (*((_DWORD *)v3 + 266) == 2)
      {
LABEL_228:
        if (*((_DWORD *)v3 + 259) == 1)
        {
          if (!HGRectIsInfinite(*((void *)v3 + 130), *((void *)v3 + 131)))
          {
            uint64_t v96 = (HGCrop *)*((void *)v3 + 90);
            if (!v96)
            {
              uint64_t v96 = (HGCrop *)HGObject::operator new(0x1A0uLL);
              HGCrop::HGCrop(v96);
              *((void *)v3 + 90) = v96;
            }
            (*(void (**)(HGCrop *, void, float, float, float, float))(*(void *)v96 + 96))(v96, 0, (float)*((int *)v3 + 260), (float)*((int *)v3 + 261), (float)*((int *)v3 + 262), (float)*((int *)v3 + 263));
            (*(void (**)(HGCrop *, void, HGNode *))(*(void *)v96 + 120))(v96, 0, v64);
            uint64_t v64 = (HGNode *)*((void *)v3 + 91);
            if (!v64)
            {
              uint64_t v64 = (HGNode *)HGObject::operator new(0x1D0uLL);
              HGTextureWrap::HGTextureWrap((HGTextureWrap *)v64);
              *((void *)v3 + 91) = v64;
            }
            HGTextureWrap::SetTextureWrapMode((uint64_t)v64, (const char *)1, v97);
            (*(void (**)(HGNode *, void, HGCrop *))(*(void *)v64 + 120))(v64, 0, v96);
            if (*((unsigned char *)v3 + 1026)) {
              HGNode::SetSupportedFormatPrecisions(v64, (const char *)v66, v98);
            }
          }
          uint64_t v99 = *((void *)v3 + 74);
          if (!v99)
          {
            char v102 = (HgcColorGamma_chroma_downsample_f1 *)HGObject::operator new(0x1A0uLL);
            *(_OWORD *)char v102 = 0u;
            *((_OWORD *)v102 + 1) = 0u;
            *((_OWORD *)v102 + 2) = 0u;
            *((_OWORD *)v102 + 3) = 0u;
            *((_OWORD *)v102 + 4) = 0u;
            *((_OWORD *)v102 + 5) = 0u;
            *((_OWORD *)v102 + 6) = 0u;
            *((_OWORD *)v102 + 7) = 0u;
            *((_OWORD *)v102 + 8) = 0u;
            *((_OWORD *)v102 + 9) = 0u;
            *((_OWORD *)v102 + 10) = 0u;
            *((_OWORD *)v102 + 11) = 0u;
            *((_OWORD *)v102 + 12) = 0u;
            *((_OWORD *)v102 + 13) = 0u;
            *((_OWORD *)v102 + 14) = 0u;
            *((_OWORD *)v102 + 15) = 0u;
            *((_OWORD *)v102 + 16) = 0u;
            *((_OWORD *)v102 + 17) = 0u;
            *((_OWORD *)v102 + 18) = 0u;
            *((_OWORD *)v102 + 19) = 0u;
            *((_OWORD *)v102 + 20) = 0u;
            *((_OWORD *)v102 + 21) = 0u;
            *((_OWORD *)v102 + 22) = 0u;
            *((_OWORD *)v102 + 23) = 0u;
            *((_OWORD *)v102 + 24) = 0u;
            *((_OWORD *)v102 + 25) = 0u;
            HgcColorGamma_chroma_downsample_f1::HgcColorGamma_chroma_downsample_f1(v102);
          }
          (*(void (**)(uint64_t, void, HGNode *))(*(void *)v99 + 120))(v99, 0, v64);
          uint64_t v64 = (HGNode *)*((void *)v3 + 74);
          if (!v64)
          {
            __int16 v104 = (HgcColorGamma_chroma_downsample_f1 *)HGObject::operator new(0x1A0uLL);
            *(_OWORD *)__int16 v104 = 0u;
            *((_OWORD *)v104 + 1) = 0u;
            *((_OWORD *)v104 + 2) = 0u;
            *((_OWORD *)v104 + 3) = 0u;
            *((_OWORD *)v104 + 4) = 0u;
            *((_OWORD *)v104 + 5) = 0u;
            *((_OWORD *)v104 + 6) = 0u;
            *((_OWORD *)v104 + 7) = 0u;
            *((_OWORD *)v104 + 8) = 0u;
            *((_OWORD *)v104 + 9) = 0u;
            *((_OWORD *)v104 + 10) = 0u;
            *((_OWORD *)v104 + 11) = 0u;
            *((_OWORD *)v104 + 12) = 0u;
            *((_OWORD *)v104 + 13) = 0u;
            *((_OWORD *)v104 + 14) = 0u;
            *((_OWORD *)v104 + 15) = 0u;
            *((_OWORD *)v104 + 16) = 0u;
            *((_OWORD *)v104 + 17) = 0u;
            *((_OWORD *)v104 + 18) = 0u;
            *((_OWORD *)v104 + 19) = 0u;
            *((_OWORD *)v104 + 20) = 0u;
            *((_OWORD *)v104 + 21) = 0u;
            *((_OWORD *)v104 + 22) = 0u;
            *((_OWORD *)v104 + 23) = 0u;
            *((_OWORD *)v104 + 24) = 0u;
            *((_OWORD *)v104 + 25) = 0u;
            HgcColorGamma_chroma_downsample_f1::HgcColorGamma_chroma_downsample_f1(v104);
          }
          if (*((unsigned char *)v3 + 1026)) {
            HGNode::SetSupportedFormatPrecisions(v64, (const char *)v66, v103);
          }
        }
        if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) == 0)
        {
          int64_t v105 = 0;
          switch(*((_DWORD *)v3 + 264))
          {
            case 0xE:
              int64_t v105 = (HGNode *)*((void *)v3 + 76);
              if (!v105)
              {
                int v106 = (HgcColorGamma_2vuy_yxzx_collapse *)HGObject::operator new(0x1A0uLL);
                *(_OWORD *)int v106 = 0u;
                *((_OWORD *)v106 + 1) = 0u;
                *((_OWORD *)v106 + 2) = 0u;
                *((_OWORD *)v106 + 3) = 0u;
                *((_OWORD *)v106 + 4) = 0u;
                *((_OWORD *)v106 + 5) = 0u;
                *((_OWORD *)v106 + 6) = 0u;
                *((_OWORD *)v106 + 7) = 0u;
                *((_OWORD *)v106 + 8) = 0u;
                *((_OWORD *)v106 + 9) = 0u;
                *((_OWORD *)v106 + 10) = 0u;
                *((_OWORD *)v106 + 11) = 0u;
                *((_OWORD *)v106 + 12) = 0u;
                *((_OWORD *)v106 + 13) = 0u;
                *((_OWORD *)v106 + 14) = 0u;
                *((_OWORD *)v106 + 15) = 0u;
                *((_OWORD *)v106 + 16) = 0u;
                *((_OWORD *)v106 + 17) = 0u;
                *((_OWORD *)v106 + 18) = 0u;
                *((_OWORD *)v106 + 19) = 0u;
                *((_OWORD *)v106 + 20) = 0u;
                *((_OWORD *)v106 + 21) = 0u;
                *((_OWORD *)v106 + 22) = 0u;
                *((_OWORD *)v106 + 23) = 0u;
                *((_OWORD *)v106 + 24) = 0u;
                *((_OWORD *)v106 + 25) = 0u;
                HgcColorGamma_2vuy_yxzx_collapse::HgcColorGamma_2vuy_yxzx_collapse(v106);
              }
              return result;
            case 0xF:
              int64_t v105 = (HGNode *)*((void *)v3 + 77);
              if (!v105)
              {
                BOOL v107 = (HgcColorGamma_2vuy_xyxz_collapse *)HGObject::operator new(0x1A0uLL);
                *(_OWORD *)BOOL v107 = 0u;
                *((_OWORD *)v107 + 1) = 0u;
                *((_OWORD *)v107 + 2) = 0u;
                *((_OWORD *)v107 + 3) = 0u;
                *((_OWORD *)v107 + 4) = 0u;
                *((_OWORD *)v107 + 5) = 0u;
                *((_OWORD *)v107 + 6) = 0u;
                *((_OWORD *)v107 + 7) = 0u;
                *((_OWORD *)v107 + 8) = 0u;
                *((_OWORD *)v107 + 9) = 0u;
                *((_OWORD *)v107 + 10) = 0u;
                *((_OWORD *)v107 + 11) = 0u;
                *((_OWORD *)v107 + 12) = 0u;
                *((_OWORD *)v107 + 13) = 0u;
                *((_OWORD *)v107 + 14) = 0u;
                *((_OWORD *)v107 + 15) = 0u;
                *((_OWORD *)v107 + 16) = 0u;
                *((_OWORD *)v107 + 17) = 0u;
                *((_OWORD *)v107 + 18) = 0u;
                *((_OWORD *)v107 + 19) = 0u;
                *((_OWORD *)v107 + 20) = 0u;
                *((_OWORD *)v107 + 21) = 0u;
                *((_OWORD *)v107 + 22) = 0u;
                *((_OWORD *)v107 + 23) = 0u;
                *((_OWORD *)v107 + 24) = 0u;
                *((_OWORD *)v107 + 25) = 0u;
                HgcColorGamma_2vuy_xyxz_collapse::HgcColorGamma_2vuy_xyxz_collapse(v107);
              }
              return result;
            case 0x10:
              int64_t v105 = (HGNode *)*((void *)v3 + 78);
              if (!v105)
              {
                int v108 = (HgcColorGamma_v216_yxzx_collapse *)HGObject::operator new(0x1A0uLL);
                *(_OWORD *)int v108 = 0u;
                *((_OWORD *)v108 + 1) = 0u;
                *((_OWORD *)v108 + 2) = 0u;
                *((_OWORD *)v108 + 3) = 0u;
                *((_OWORD *)v108 + 4) = 0u;
                *((_OWORD *)v108 + 5) = 0u;
                *((_OWORD *)v108 + 6) = 0u;
                *((_OWORD *)v108 + 7) = 0u;
                *((_OWORD *)v108 + 8) = 0u;
                *((_OWORD *)v108 + 9) = 0u;
                *((_OWORD *)v108 + 10) = 0u;
                *((_OWORD *)v108 + 11) = 0u;
                *((_OWORD *)v108 + 12) = 0u;
                *((_OWORD *)v108 + 13) = 0u;
                *((_OWORD *)v108 + 14) = 0u;
                *((_OWORD *)v108 + 15) = 0u;
                *((_OWORD *)v108 + 16) = 0u;
                *((_OWORD *)v108 + 17) = 0u;
                *((_OWORD *)v108 + 18) = 0u;
                *((_OWORD *)v108 + 19) = 0u;
                *((_OWORD *)v108 + 20) = 0u;
                *((_OWORD *)v108 + 21) = 0u;
                *((_OWORD *)v108 + 22) = 0u;
                *((_OWORD *)v108 + 23) = 0u;
                *((_OWORD *)v108 + 24) = 0u;
                *((_OWORD *)v108 + 25) = 0u;
                HgcColorGamma_v216_yxzx_collapse::HgcColorGamma_v216_yxzx_collapse(v108);
              }
              return result;
            case 0x1F:
              int64_t v105 = (HGNode *)*((void *)v3 + 79);
              if (!v105)
              {
                unint64_t v109 = (HgcColorGamma_v210_yxzx_rgba_collapse *)HGObject::operator new(0x1A0uLL);
                HgcColorGamma_v210_yxzx_rgba_collapse::HgcColorGamma_v210_yxzx_rgba_collapse(v109);
              }
              return result;
            default:
              break;
          }
          (*(void (**)(HGNode *, void, HGNode *))(*(void *)v105 + 120))(v105, 0, v64);
          uint64_t v64 = v105;
        }
      }
      break;
    case 0x20:
      if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) == 0)
      {
        uint64_t PixelFormatConversion_kV4B10Bit_BE_OutputNode = HGColorGamma::m_GetPixelFormatConversion_kV4B10Bit_BE_OutputNode(v3);
        (*(void (**)(uint64_t, void, HGNode *))(*(void *)PixelFormatConversion_kV4B10Bit_BE_OutputNode
                                                          + 120))(PixelFormatConversion_kV4B10Bit_BE_OutputNode, 0, v64);
        uint64_t v93 = HGColorGamma::m_GetPixelFormatConversion_kV4B10Bit_BE_OutputNode(v3);
        goto LABEL_242;
      }
      break;
    case 0x21:
      if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) == 0)
      {
        uint64_t PixelFormatConversion_kV4S_BE_WXYZ_OutputNode = HGColorGamma::m_GetPixelFormatConversion_kV4S_BE_WXYZ_OutputNode(v3);
        (*(void (**)(uint64_t, void, HGNode *))(*(void *)PixelFormatConversion_kV4S_BE_WXYZ_OutputNode
                                                          + 120))(PixelFormatConversion_kV4S_BE_WXYZ_OutputNode, 0, v64);
        uint64_t v93 = HGColorGamma::m_GetPixelFormatConversion_kV4S_BE_WXYZ_OutputNode(v3);
LABEL_242:
        uint64_t v64 = (HGNode *)v93;
      }
      break;
    default:
      break;
  }
  *((void *)v3 + 95) = v64;
  return v64;
}

void sub_1B7753DE4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753DF8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753E0C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753E20(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753E34(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753E48(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753E5C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753E70(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753E84(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753E98(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753EAC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753EC0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753ED4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753EE8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753EFC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753F10(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753F24(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753F38(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753F4C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753F60(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753F74(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753F88(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753F9C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753FB0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753FC4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753FD8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7753FEC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7754000(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7754014(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7754028(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B775403C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7754050(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7754064(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7754078(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::ConcatenateWithUpstreamNode(HGNode *this, HGRenderer *a2, HGNode **a3)
{
  uint64_t result = (uint64_t)*a3;
  if (*a3)
  {
    if (result)
    {
      uint64_t v7 = result;
      uint64_t result = HGRenderer::IsMergeable(a2, this, 0, 0);
      if (result)
      {
        uint64_t result = (*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2);
        if (result)
        {
          uint64_t v10 = *(HGNode **)(v7 + 1176);
          if (v10)
          {
            if (!*((_DWORD *)this + 264))
            {
              if ((*(_DWORD *)(v7 + 1060) - 1) > 2)
              {
                if (*((unsigned __int8 *)this + 1172) != *(unsigned __int8 *)(v7 + 1173)) {
                  HGLogger::warning((HGLogger *)"HGColorGamma concatenating with upstream node: inconsistent premultiplication states.\n", v8, v9);
                }
                char v11 = *(unsigned char *)(v7 + 1172);
                *((unsigned char *)this + 745) = 1;
                *((unsigned char *)this + 1172) = v11;
              }
              else
              {
                *((_WORD *)this + 586) = 0;
              }
              int v12 = *(_DWORD *)(v7 + 1036);
              HGNode::ClearBits(this, (uint64_t)v8, v9);
              *((unsigned char *)this + 745) = 1;
              *((_DWORD *)this + 259) = v12;
              int v13 = *(_DWORD *)(v7 + 1060);
              HGNode::ClearBits(this, v14, v15);
              *((unsigned char *)this + 745) = 1;
              *((_DWORD *)this + 265) = v13;
              __n128 v18 = HGColorGamma::SetYCbCrBiasAndScale(this, v16, v17);
              uint64_t result = (*(uint64_t (**)(HGNode *, void, HGNode *, __n128))(*(void *)this + 120))(this, 0, v10, v18);
              *a3 = v10;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t HGColorGamma::ScaleParams(float32x4_t *this, HGNode *a2, HGRenderer *a3)
{
  *(float32x4_t *)(this[25].i64[1] + 128) = this[48];
  *(float32x4_t *)(this[25].i64[1] + 144) = this[49];
  *(float32x4_t *)(this[25].i64[1] + 160) = this[50];
  *(float32x4_t *)(this[25].i64[1] + 176) = this[51];
  *(float32x4_t *)(this[25].i64[1] + 192) = this[52];
  *(float32x4_t *)(this[25].i64[1] + 208) = this[53];
  *(float32x4_t *)(this[25].i64[1] + 224) = this[54];
  *(_DWORD *)(this[25].i64[1] + 240) = this[64].i32[1];
  HGColorGamma::LoadMacroNodeParams(this);
  uint64_t v6 = this[64].u32[1];
  if (!v6)
  {
    int8x16_t v9 = vmvnq_s8((int8x16_t)vceqq_f32(vmulq_f32(this[48], (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890));
    *(int32x2_t *)v9.i8 = vpmin_s32(*(int32x2_t *)v9.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
    if (vpmin_s32(*(int32x2_t *)v9.i8, *(int32x2_t *)v9.i8).u32[0])
    {
      int v7 = this[73].i32[0];
      if ((v7 - 1) <= 1)
      {
        if (this[55].i8[0])
        {
          uint64_t v10 = (HGGamma *)this[27].i64[1];
          if (!v10)
          {
            uint64_t v10 = (HGGamma *)HGObject::operator new(0x1B0uLL);
            HGGamma::HGGamma(v10);
            this[27].i64[1] = (uint64_t)v10;
          }
        }
        else
        {
          uint64_t v10 = (HGGamma *)this[28].i64[0];
          if (!v10)
          {
            uint64_t v10 = (HGGamma *)HGObject::operator new(0x1C0uLL);
            HGGammaMC::HGGammaMC(v10);
            this[28].i64[0] = (uint64_t)v10;
          }
        }
        (*(void (**)(HGGamma *, void, float, float, float, float))(*(void *)v10 + 96))(v10, 0, *(float *)(this[25].i64[1] + 128), *(float *)(this[25].i64[1] + 132), *(float *)(this[25].i64[1] + 136), 1.0);
        uint64_t v25 = this[28].i64[1];
        if (!v25)
        {
          uint64_t v26 = (HGGamma *)HGObject::operator new(0x1B0uLL);
          HGGamma::HGGamma(v26);
          this[28].i64[1] = (uint64_t)v26;
          HGGamma::SetPremultiplyState((uint64_t)v26, 0);
          uint64_t v25 = this[28].i64[1];
        }
        uint64_t v27 = (_DWORD *)this[25].i64[1];
        v21.n128_u32[0] = v27[32];
        v22.n128_u32[0] = v27[33];
        v23.n128_u32[0] = v27[34];
        v24.n128_u32[0] = 1.0;
        (*(void (**)(uint64_t, void, __n128, __n128, __n128, __n128))(*(void *)v25 + 96))(v25, 0, v21, v22, v23, v24);
        return 0;
      }
      goto LABEL_17;
    }
    return 0;
  }
  if ((int)v6 > 4)
  {
    if (v6 <= 9)
    {
LABEL_24:
      {
        __cxa_atexit((void (*)(void *))HGColorGammaLUTEntryFactory::~HGColorGammaLUTEntryFactory, &HGColorGamma::ScaleParams(HGNode *,HGRenderer *)::lutFactory, &dword_1B73F3000);
      }
      switch(this[64].i32[1])
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
          operator new();
        case 5:
          switch(this[64].i32[2])
          {
            case 0:
              operator new();
            case 1:
              operator new();
            case 2:
              operator new();
            case 3:
              operator new();
            case 4:
              operator new();
            case 5:
              operator new();
            case 6:
              operator new();
            case 7:
              operator new();
            case 8:
              operator new();
            case 9:
              operator new();
            case 0xA:
              operator new();
            case 0xB:
              operator new();
            case 0xC:
              operator new();
            case 0xD:
              operator new();
            case 0xE:
              operator new();
            case 0xF:
              operator new();
            case 0x10:
              operator new();
            case 0x11:
              operator new();
            default:
              goto LABEL_28;
          }
        case 6:
          operator new();
        case 7:
          operator new();
        case 8:
          operator new();
        case 9:
          operator new();
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xD:
        case 0xE:
        case 0xF:
        case 0x10:
        case 0x11:
        case 0x12:
          operator new();
        default:
          break;
      }
LABEL_28:
      uint64_t LUTCache = HGLUTCacheManager::getLUTCache(*((void *)a3 + 69), (uint64_t *)&HGColorGamma::ScaleParams(HGNode *,HGRenderer *)::lutFactory);
      NewLUT = (HGBitmap *)HGLUTCache::getNewLUT(LUTCache, 0);
      int v20 = (HGApply1DLUT *)this[40].i64[0];
      if (!v20)
      {
        int v20 = (HGApply1DLUT *)HGObject::operator new(0x1D0uLL);
        HGApply1DLUT::HGApply1DLUT(v20, this[72].i32[0], this[72].f32[1], this[72].f32[2], 1, 1, 1, 0, 1, 1);
        this[40].i64[0] = (uint64_t)v20;
      }
      HGApply1DLUT::SetLUTBitmap(v20, NewLUT);
      (*(void (**)(HGBitmap *))(*(void *)NewLUT + 24))(NewLUT);
      return 0;
    }
    return 0;
  }
  int v7 = this[73].i32[0];
  if (v7 == 2)
  {
    if (v6 == 3)
    {
      if (this[73].i8[7])
      {
        uint64_t v28 = this[44].i64[0];
        if (!v28)
        {
          uint64_t v29 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(v29);
        }
      }
      else
      {
        uint64_t v28 = this[42].i64[0];
        if (!v28)
        {
          int8x16_t v34 = (HgcToneParamCurve3 *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3::HgcToneParamCurve3(v34);
        }
      }
      (*(void (**)(uint64_t, void, float, float, float, float))(*(void *)v28 + 96))(v28, 0, *(float *)(this[25].i64[1] + 128), *(float *)(this[25].i64[1] + 132), *(float *)(this[25].i64[1] + 136), 1.0);
      if (this[73].i8[7])
      {
        uint64_t v35 = this[44].i64[0];
        if (!v35)
        {
          uint64_t v36 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(v36);
        }
      }
      else
      {
        uint64_t v35 = this[42].i64[0];
        if (!v35)
        {
          int8x16_t v43 = (HgcToneParamCurve3 *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3::HgcToneParamCurve3(v43);
        }
      }
      (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)v35 + 96))(v35, 1, *(float *)(this[25].i64[1] + 144), *(float *)(this[25].i64[1] + 148), *(float *)(this[25].i64[1] + 152), 1.0);
      if (this[73].i8[7])
      {
        uint64_t v44 = this[44].i64[0];
        if (!v44)
        {
          uint64_t v45 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(v45);
        }
      }
      else
      {
        uint64_t v44 = this[42].i64[0];
        if (!v44)
        {
          int v56 = (HgcToneParamCurve3 *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3::HgcToneParamCurve3(v56);
        }
      }
      (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)v44 + 96))(v44, 2, *(float *)(this[25].i64[1] + 160), *(float *)(this[25].i64[1] + 164), *(float *)(this[25].i64[1] + 168), 1.0);
      if (this[73].i8[7])
      {
        uint64_t v57 = this[44].i64[0];
        if (!v57)
        {
          uint64_t v58 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(v58);
        }
      }
      else
      {
        uint64_t v57 = this[42].i64[0];
        if (!v57)
        {
          uint64_t v65 = (HgcToneParamCurve3 *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3::HgcToneParamCurve3(v65);
        }
      }
      (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)v57 + 96))(v57, 3, *(float *)(this[25].i64[1] + 176), *(float *)(this[25].i64[1] + 180), *(float *)(this[25].i64[1] + 184), 1.0);
      if (this[73].i8[7])
      {
        uint64_t v70 = (HgcToneParamCurve2AntiSymmetric *)this[44].i64[0];
        if (!v70)
        {
          char v71 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(v71);
        }
      }
      else
      {
        uint64_t v70 = (HgcToneParamCurve2AntiSymmetric *)this[42].i64[0];
        if (!v70)
        {
          uint64_t v75 = (HgcToneParamCurve3 *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve3::HgcToneParamCurve3(v75);
        }
      }
      long long v76 = (_DWORD *)this[25].i64[1];
      v66.n128_u32[0] = v76[48];
      v67.n128_u32[0] = v76[49];
      v68.n128_u32[0] = v76[50];
    }
    else
    {
      if (v6 != 2)
      {
        if (v6 == 1)
        {
          if (this[73].i8[7])
          {
            uint64_t v8 = (HgcToneParamCurve1AntiSymmetric *)this[43].i64[0];
            if (!v8)
            {
              uint64_t v8 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1AntiSymmetric::HgcToneParamCurve1AntiSymmetric(v8);
              this[43].i64[0] = (uint64_t)v8;
            }
          }
          else
          {
            uint64_t v8 = (HgcToneParamCurve1AntiSymmetric *)this[41].i64[0];
            if (!v8)
            {
              uint64_t v32 = (HgcToneParamCurve1 *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1::HgcToneParamCurve1(v32);
            }
          }
          (*(void (**)(HgcToneParamCurve1AntiSymmetric *, void, float, float, float, float))(*(void *)v8 + 96))(v8, 0, *(float *)(this[25].i64[1] + 128), *(float *)(this[25].i64[1] + 132), *(float *)(this[25].i64[1] + 136), 1.0);
          if (this[73].i8[7])
          {
            uint64_t v33 = (HgcToneParamCurve1AntiSymmetric *)this[43].i64[0];
            if (!v33)
            {
              uint64_t v33 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1AntiSymmetric::HgcToneParamCurve1AntiSymmetric(v33);
              this[43].i64[0] = (uint64_t)v33;
            }
          }
          else
          {
            uint64_t v33 = (HgcToneParamCurve1AntiSymmetric *)this[41].i64[0];
            if (!v33)
            {
              int8x16_t v41 = (HgcToneParamCurve1 *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1::HgcToneParamCurve1(v41);
            }
          }
          (*(void (**)(HgcToneParamCurve1AntiSymmetric *, uint64_t, float, float, float, float))(*(void *)v33 + 96))(v33, 1, *(float *)(this[25].i64[1] + 144), *(float *)(this[25].i64[1] + 148), *(float *)(this[25].i64[1] + 152), 1.0);
          if (this[73].i8[7])
          {
            unint64_t v42 = (HgcToneParamCurve1AntiSymmetric *)this[43].i64[0];
            if (!v42)
            {
              unint64_t v42 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1AntiSymmetric::HgcToneParamCurve1AntiSymmetric(v42);
              this[43].i64[0] = (uint64_t)v42;
            }
          }
          else
          {
            unint64_t v42 = (HgcToneParamCurve1AntiSymmetric *)this[41].i64[0];
            if (!v42)
            {
              int v50 = (HgcToneParamCurve1 *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1::HgcToneParamCurve1(v50);
            }
          }
          (*(void (**)(HgcToneParamCurve1AntiSymmetric *, uint64_t, float, float, float, float))(*(void *)v42 + 96))(v42, 2, *(float *)(this[25].i64[1] + 160), *(float *)(this[25].i64[1] + 164), *(float *)(this[25].i64[1] + 168), 1.0);
          if (this[73].i8[7])
          {
            uint64_t v55 = (HgcToneParamCurve1AntiSymmetric *)this[43].i64[0];
            if (!v55)
            {
              uint64_t v55 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1AntiSymmetric::HgcToneParamCurve1AntiSymmetric(v55);
              this[43].i64[0] = (uint64_t)v55;
            }
          }
          else
          {
            uint64_t v55 = (HgcToneParamCurve1AntiSymmetric *)this[41].i64[0];
            if (!v55)
            {
              uint64_t v63 = (HgcToneParamCurve1 *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve1::HgcToneParamCurve1(v63);
            }
          }
          uint64_t v64 = (float *)this[25].i64[1];
          v51.n128_f64[0] = -v64[40] / v64[36];
          v51.n128_f32[0] = v51.n128_f64[0];
          v52.n128_f64[0] = -v64[41] / v64[37];
          v52.n128_f32[0] = v52.n128_f64[0];
          v54.n128_f64[0] = v64[38];
          v53.n128_f64[0] = -v64[42] / v54.n128_f64[0];
          v53.n128_f32[0] = v53.n128_f64[0];
          v54.n128_u32[0] = 1.0;
          (*(void (**)(HgcToneParamCurve1AntiSymmetric *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)v55 + 96))(v55, 3, v51, v52, v53, v54);
        }
        else
        {
          if (this[73].i8[7])
          {
            uint64_t v31 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v31)
            {
              uint64_t v31 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v31);
              this[44].i64[1] = (uint64_t)v31;
            }
          }
          else
          {
            uint64_t v31 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v31)
            {
              uint64_t v39 = (HgcToneParamCurve4 *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v39);
            }
          }
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, void, float, float, float, float))(*(void *)v31 + 96))(v31, 0, *(float *)(this[25].i64[1] + 128), *(float *)(this[25].i64[1] + 132), *(float *)(this[25].i64[1] + 136), 1.0);
          if (this[73].i8[7])
          {
            float32x4_t v40 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v40)
            {
              float32x4_t v40 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v40);
              this[44].i64[1] = (uint64_t)v40;
            }
          }
          else
          {
            float32x4_t v40 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v40)
            {
              uint64_t v48 = (HgcToneParamCurve4 *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v48);
            }
          }
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, uint64_t, float, float, float, float))(*(void *)v40 + 96))(v40, 1, *(float *)(this[25].i64[1] + 144), *(float *)(this[25].i64[1] + 148), *(float *)(this[25].i64[1] + 152), 1.0);
          if (this[73].i8[7])
          {
            uint64_t v49 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v49)
            {
              uint64_t v49 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v49);
              this[44].i64[1] = (uint64_t)v49;
            }
          }
          else
          {
            uint64_t v49 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v49)
            {
              int v61 = (HgcToneParamCurve4 *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v61);
            }
          }
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, uint64_t, float, float, float, float))(*(void *)v49 + 96))(v49, 2, *(float *)(this[25].i64[1] + 160), *(float *)(this[25].i64[1] + 164), *(float *)(this[25].i64[1] + 168), 1.0);
          if (this[73].i8[7])
          {
            uint64_t v62 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v62)
            {
              uint64_t v62 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v62);
              this[44].i64[1] = (uint64_t)v62;
            }
          }
          else
          {
            uint64_t v62 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v62)
            {
              int v73 = (HgcToneParamCurve4 *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v73);
            }
          }
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, uint64_t, float, float, float, float))(*(void *)v62 + 96))(v62, 3, *(float *)(this[25].i64[1] + 176), *(float *)(this[25].i64[1] + 180), *(float *)(this[25].i64[1] + 184), 1.0);
          if (this[73].i8[7])
          {
            long long v74 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v74)
            {
              long long v74 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v74);
              this[44].i64[1] = (uint64_t)v74;
            }
          }
          else
          {
            long long v74 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v74)
            {
              unsigned __int8 v79 = (HgcToneParamCurve4 *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v79);
            }
          }
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, uint64_t, float, float, float, float))(*(void *)v74 + 96))(v74, 4, *(float *)(this[25].i64[1] + 192), *(float *)(this[25].i64[1] + 196), *(float *)(this[25].i64[1] + 200), 1.0);
          if (this[73].i8[7])
          {
            int8x16_t v80 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v80)
            {
              int8x16_t v80 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v80);
              this[44].i64[1] = (uint64_t)v80;
            }
          }
          else
          {
            int8x16_t v80 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v80)
            {
              uint64_t v81 = (HgcToneParamCurve4 *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v81);
            }
          }
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, uint64_t, float, float, float, float))(*(void *)v80 + 96))(v80, 5, *(float *)(this[25].i64[1] + 208), *(float *)(this[25].i64[1] + 212), *(float *)(this[25].i64[1] + 216), 1.0);
          if (this[73].i8[7])
          {
            unsigned __int8 v86 = (HgcToneParamCurve4AntiSymmetric *)this[44].i64[1];
            if (!v86)
            {
              unsigned __int8 v86 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v86);
              this[44].i64[1] = (uint64_t)v86;
            }
          }
          else
          {
            unsigned __int8 v86 = (HgcToneParamCurve4AntiSymmetric *)this[42].i64[1];
            if (!v86)
            {
              uint64_t v87 = (HgcToneParamCurve4 *)HGObject::operator new(0x1A0uLL);
              HgcToneParamCurve4::HgcToneParamCurve4(v87);
            }
          }
          uint64_t v88 = (_DWORD *)this[25].i64[1];
          v82.n128_u32[0] = v88[56];
          v83.n128_u32[0] = v88[57];
          v84.n128_u32[0] = v88[58];
          v85.n128_u32[0] = 1.0;
          (*(void (**)(HgcToneParamCurve4AntiSymmetric *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)v86 + 96))(v86, 6, v82, v83, v84, v85);
        }
        return 0;
      }
      if (this[73].i8[7])
      {
        uint64_t v30 = (HgcToneParamCurve2AntiSymmetric *)this[43].i64[1];
        if (!v30)
        {
          uint64_t v30 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(v30);
          this[43].i64[1] = (uint64_t)v30;
        }
      }
      else
      {
        uint64_t v30 = (HgcToneParamCurve2AntiSymmetric *)this[41].i64[1];
        if (!v30)
        {
          uint64_t v37 = (HgcToneParamCurve2 *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2::HgcToneParamCurve2(v37);
        }
      }
      (*(void (**)(HgcToneParamCurve2AntiSymmetric *, void, float, float, float, float))(*(void *)v30 + 96))(v30, 0, *(float *)(this[25].i64[1] + 128), *(float *)(this[25].i64[1] + 132), *(float *)(this[25].i64[1] + 136), 1.0);
      if (this[73].i8[7])
      {
        uint64_t v38 = (HgcToneParamCurve2AntiSymmetric *)this[43].i64[1];
        if (!v38)
        {
          uint64_t v38 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(v38);
          this[43].i64[1] = (uint64_t)v38;
        }
      }
      else
      {
        uint64_t v38 = (HgcToneParamCurve2AntiSymmetric *)this[41].i64[1];
        if (!v38)
        {
          int v46 = (HgcToneParamCurve2 *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2::HgcToneParamCurve2(v46);
        }
      }
      (*(void (**)(HgcToneParamCurve2AntiSymmetric *, uint64_t, float, float, float, float))(*(void *)v38 + 96))(v38, 1, *(float *)(this[25].i64[1] + 144), *(float *)(this[25].i64[1] + 148), *(float *)(this[25].i64[1] + 152), 1.0);
      if (this[73].i8[7])
      {
        uint64_t v47 = (HgcToneParamCurve2AntiSymmetric *)this[43].i64[1];
        if (!v47)
        {
          uint64_t v47 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(v47);
          this[43].i64[1] = (uint64_t)v47;
        }
      }
      else
      {
        uint64_t v47 = (HgcToneParamCurve2AntiSymmetric *)this[41].i64[1];
        if (!v47)
        {
          uint64_t v59 = (HgcToneParamCurve2 *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2::HgcToneParamCurve2(v59);
        }
      }
      (*(void (**)(HgcToneParamCurve2AntiSymmetric *, uint64_t, float, float, float, float))(*(void *)v47 + 96))(v47, 2, *(float *)(this[25].i64[1] + 160), *(float *)(this[25].i64[1] + 164), *(float *)(this[25].i64[1] + 168), 1.0);
      if (this[73].i8[7])
      {
        uint64_t v60 = (HgcToneParamCurve2AntiSymmetric *)this[43].i64[1];
        if (!v60)
        {
          uint64_t v60 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(v60);
          this[43].i64[1] = (uint64_t)v60;
        }
      }
      else
      {
        uint64_t v60 = (HgcToneParamCurve2AntiSymmetric *)this[41].i64[1];
        if (!v60)
        {
          uint64_t v72 = (HgcToneParamCurve2 *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2::HgcToneParamCurve2(v72);
        }
      }
      (*(void (**)(HgcToneParamCurve2AntiSymmetric *, uint64_t, float, float, float, float))(*(void *)v60 + 96))(v60, 3, *(float *)(this[25].i64[1] + 176), *(float *)(this[25].i64[1] + 180), *(float *)(this[25].i64[1] + 184), 1.0);
      if (this[73].i8[7])
      {
        uint64_t v70 = (HgcToneParamCurve2AntiSymmetric *)this[43].i64[1];
        if (!v70)
        {
          uint64_t v70 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(v70);
          this[43].i64[1] = (uint64_t)v70;
        }
      }
      else
      {
        uint64_t v70 = (HgcToneParamCurve2AntiSymmetric *)this[41].i64[1];
        if (!v70)
        {
          uint64_t v77 = (HgcToneParamCurve2 *)HGObject::operator new(0x1A0uLL);
          HgcToneParamCurve2::HgcToneParamCurve2(v77);
        }
      }
      unsigned __int16 v78 = (float *)this[25].i64[1];
      v66.n128_f64[0] = -v78[40] / v78[36];
      v66.n128_f32[0] = v66.n128_f64[0];
      v67.n128_f64[0] = -v78[41] / v78[37];
      v67.n128_f32[0] = v67.n128_f64[0];
      v69.n128_f64[0] = v78[38];
      v68.n128_f64[0] = -v78[42] / v69.n128_f64[0];
      v68.n128_f32[0] = v68.n128_f64[0];
    }
    v69.n128_u32[0] = 1.0;
    (*(void (**)(HgcToneParamCurve2AntiSymmetric *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)v70 + 96))(v70, 4, v66, v67, v68, v69);
    return 0;
  }
LABEL_17:
  if (v7 < 3 || !this[55].i8[0]) {
    goto LABEL_24;
  }
  uint64_t v11 = this[29].i64[0];
  if (!v11)
  {
    int v12 = (HGToneCurve *)HGObject::operator new(0x1E0uLL);
    HGToneCurve::HGToneCurve(v12);
  }
  int v13 = (float *)this[25].i64[1];
  HGToneCurve::SetToneCurveParams(v11, v6, v5, v13[32], v13[36], v13[40], v13[44], v13[48], v13[52], v13[56]);
  uint64_t v15 = this[29].i64[0];
  if (!v15)
  {
    uint64_t v16 = (HGToneCurve *)HGObject::operator new(0x1E0uLL);
    HGToneCurve::HGToneCurve(v16);
  }
  HGToneCurve::SetToneCurveQuality(v15, (this[73].i32[0] - 3), v14);
  return 0;
}

void sub_1B7755704(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1081C40A1FA7B50);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::m_Get2vuy_XYXZExpandNode(HGColorGamma *this)
{
  if (!*((void *)this + 60))
  {
    uint64_t v2 = (HgcColorGamma_2vuy_xyxz_expand *)HGObject::operator new(0x1A0uLL);
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 12) = 0u;
    *((_OWORD *)v2 + 13) = 0u;
    *((_OWORD *)v2 + 14) = 0u;
    *((_OWORD *)v2 + 15) = 0u;
    *((_OWORD *)v2 + 16) = 0u;
    *((_OWORD *)v2 + 17) = 0u;
    *((_OWORD *)v2 + 18) = 0u;
    *((_OWORD *)v2 + 19) = 0u;
    *((_OWORD *)v2 + 20) = 0u;
    *((_OWORD *)v2 + 21) = 0u;
    *((_OWORD *)v2 + 22) = 0u;
    *((_OWORD *)v2 + 23) = 0u;
    *((_OWORD *)v2 + 24) = 0u;
    *((_OWORD *)v2 + 25) = 0u;
    HgcColorGamma_2vuy_xyxz_expand::HgcColorGamma_2vuy_xyxz_expand(v2);
  }
  return *((void *)this + 60);
}

void sub_1B7755CFC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::m_Getv210_YXZXExpandNode(HGColorGamma *this, HGRenderer *a2)
{
  if (!*((void *)this + 62))
  {
    uint64_t v3 = (HgcColorGamma_v210_yxzx_rgba_expand *)HGObject::operator new(0x1A0uLL);
    HgcColorGamma_v210_yxzx_rgba_expand::HgcColorGamma_v210_yxzx_rgba_expand(v3);
  }
  return *((void *)this + 62);
}

void sub_1B7755D7C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::m_Getv216_YXZXExpandNode(HGColorGamma *this)
{
  if (!*((void *)this + 61))
  {
    uint64_t v2 = (HgcColorGamma_v216_yxzx_expand *)HGObject::operator new(0x1A0uLL);
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 12) = 0u;
    *((_OWORD *)v2 + 13) = 0u;
    *((_OWORD *)v2 + 14) = 0u;
    *((_OWORD *)v2 + 15) = 0u;
    *((_OWORD *)v2 + 16) = 0u;
    *((_OWORD *)v2 + 17) = 0u;
    *((_OWORD *)v2 + 18) = 0u;
    *((_OWORD *)v2 + 19) = 0u;
    *((_OWORD *)v2 + 20) = 0u;
    *((_OWORD *)v2 + 21) = 0u;
    *((_OWORD *)v2 + 22) = 0u;
    *((_OWORD *)v2 + 23) = 0u;
    *((_OWORD *)v2 + 24) = 0u;
    *((_OWORD *)v2 + 25) = 0u;
    HgcColorGamma_v216_yxzx_expand::HgcColorGamma_v216_yxzx_expand(v2);
  }
  return *((void *)this + 61);
}

void sub_1B7755E34(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGGamma *HGColorGamma::m_GetGammaUniformNode(HGColorGamma *this)
{
  if (*((void *)this + 55)) {
    return (HGGamma *)*((void *)this + 55);
  }
  uint64_t v3 = (HGGamma *)HGObject::operator new(0x1B0uLL);
  HGGamma::HGGamma(v3);
  *((void *)this + 55) = v3;
  return v3;
}

void sub_1B7755E98(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGGammaMC *HGColorGamma::m_GetGammaMCNode(HGColorGamma *this)
{
  if (*((void *)this + 56)) {
    return (HGGammaMC *)*((void *)this + 56);
  }
  uint64_t v3 = (HGGammaMC *)HGObject::operator new(0x1C0uLL);
  HGGammaMC::HGGammaMC(v3);
  *((void *)this + 56) = v3;
  return v3;
}

void sub_1B7755EFC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcToneParamCurve1AntiSymmetric *HGColorGamma::m_GetToneParamCurve1(HGColorGamma *this)
{
  if (!*((unsigned char *)this + 1175))
  {
    uint64_t v2 = *((void *)this + 82);
    if (!v2)
    {
      uint64_t v4 = (HgcToneParamCurve1 *)HGObject::operator new(0x1A0uLL);
      HgcToneParamCurve1::HgcToneParamCurve1(v4);
    }
    return (HgcToneParamCurve1AntiSymmetric *)v2;
  }
  uint64_t v2 = *((void *)this + 86);
  if (v2) {
    return (HgcToneParamCurve1AntiSymmetric *)v2;
  }
  int8x16_t v5 = (HgcToneParamCurve1AntiSymmetric *)HGObject::operator new(0x1A0uLL);
  HgcToneParamCurve1AntiSymmetric::HgcToneParamCurve1AntiSymmetric(v5);
  *((void *)this + 86) = v5;
  return v5;
}

void sub_1B7755F94(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7755FA8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcToneParamCurve2AntiSymmetric *HGColorGamma::m_GetToneParamCurve2(HGColorGamma *this)
{
  if (!*((unsigned char *)this + 1175))
  {
    uint64_t v2 = *((void *)this + 83);
    if (!v2)
    {
      uint64_t v4 = (HgcToneParamCurve2 *)HGObject::operator new(0x1A0uLL);
      HgcToneParamCurve2::HgcToneParamCurve2(v4);
    }
    return (HgcToneParamCurve2AntiSymmetric *)v2;
  }
  uint64_t v2 = *((void *)this + 87);
  if (v2) {
    return (HgcToneParamCurve2AntiSymmetric *)v2;
  }
  int8x16_t v5 = (HgcToneParamCurve2AntiSymmetric *)HGObject::operator new(0x1A0uLL);
  HgcToneParamCurve2AntiSymmetric::HgcToneParamCurve2AntiSymmetric(v5);
  *((void *)this + 87) = v5;
  return v5;
}

void sub_1B7756040(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7756054(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::m_GetToneParamCurve3(HGColorGamma *this)
{
  if (*((unsigned char *)this + 1175))
  {
    uint64_t v1 = *((void *)this + 88);
    if (!v1)
    {
      uint64_t v4 = (HgcToneParamCurve3AntiSymmetric *)HGObject::operator new(0x1A0uLL);
      HgcToneParamCurve3AntiSymmetric::HgcToneParamCurve3AntiSymmetric(v4);
    }
  }
  else
  {
    uint64_t v1 = *((void *)this + 84);
    if (!v1)
    {
      uint64_t v3 = (HgcToneParamCurve3 *)HGObject::operator new(0x1A0uLL);
      HgcToneParamCurve3::HgcToneParamCurve3(v3);
    }
  }
  return v1;
}

void sub_1B77560EC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7756100(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HgcToneParamCurve4AntiSymmetric *HGColorGamma::m_GetToneParamCurve4(HGColorGamma *this)
{
  if (!*((unsigned char *)this + 1175))
  {
    uint64_t v2 = *((void *)this + 85);
    if (!v2)
    {
      uint64_t v4 = (HgcToneParamCurve4 *)HGObject::operator new(0x1A0uLL);
      HgcToneParamCurve4::HgcToneParamCurve4(v4);
    }
    return (HgcToneParamCurve4AntiSymmetric *)v2;
  }
  uint64_t v2 = *((void *)this + 89);
  if (v2) {
    return (HgcToneParamCurve4AntiSymmetric *)v2;
  }
  int8x16_t v5 = (HgcToneParamCurve4AntiSymmetric *)HGObject::operator new(0x1A0uLL);
  HgcToneParamCurve4AntiSymmetric::HgcToneParamCurve4AntiSymmetric(v5);
  *((void *)this + 89) = v5;
  return v5;
}

void sub_1B7756198(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77561AC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::m_GetGammaFittedNode(HGColorGamma *this)
{
  if (!*((void *)this + 58))
  {
    uint64_t v2 = (HGToneCurve *)HGObject::operator new(0x1E0uLL);
    HGToneCurve::HGToneCurve(v2);
  }
  return *((void *)this + 58);
}

void sub_1B7756210(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGHLG::OETF *HGColorGamma::m_GetHDRFunctionNode(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 648)) {
    return *(HGHLG::OETF **)(a1 + 648);
  }
  switch(a2)
  {
    case 10:
      uint64_t v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGHLG::OETF::OETF(v4);
      goto LABEL_14;
    case 11:
      uint64_t v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGHLG::InverseOETF::InverseOETF(v4);
      goto LABEL_14;
    case 12:
      uint64_t v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGPQ::OETF::OETF(v4, 1, 100.0);
      goto LABEL_14;
    case 13:
      uint64_t v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGPQ::InverseOETF::InverseOETF(v4, 1, 100.0);
      goto LABEL_14;
    case 14:
      int8x16_t v5 = (HGNode *)HGObject::operator new(0x1B0uLL);
      HGPQ::EOTF::EOTF(v5, 100.0);
    case 15:
      uint64_t v6 = (HGNode *)HGObject::operator new(0x1B0uLL);
      HGPQ::InverseEOTF::InverseEOTF(v6, 100.0);
    case 16:
      uint64_t v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGACEScct::Encode::Encode(v4);
      goto LABEL_14;
    case 17:
      uint64_t v4 = (HGHLG::OETF *)HGObject::operator new(0x1B0uLL);
      HGACEScct::Decode::Decode(v4);
LABEL_14:
      *(void *)(a1 + 648) = v4;
      uint64_t result = v4;
      break;
    case 18:
      int v7 = (HGSony709_800_MLUT *)HGObject::operator new(0x1A0uLL);
      HGSony709_800_MLUT::HGSony709_800_MLUT(v7);
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

void sub_1B7756384(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7756398(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77563AC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77563C0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77563D4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77563E8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77563FC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7756410(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7756424(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::m_GetUnpremultiplyNode(HGColorGamma *this)
{
  if (!*((void *)this + 73))
  {
    switch(*((_DWORD *)this + 257))
    {
      case 5:
      case 0xB:
      case 0xD:
      case 0xE:
      case 0x11:
        uint64_t v3 = (HgcUnpremultiplySanitized *)HGObject::operator new(0x1A0uLL);
        HgcUnpremultiplySanitized::HgcUnpremultiplySanitized(v3);
      default:
        uint64_t v2 = (HgcUnpremultiply *)HGObject::operator new(0x1A0uLL);
        HgcUnpremultiply::HgcUnpremultiply(v2);
    }
  }
  return *((void *)this + 73);
}

void sub_1B775657C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7756590(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::m_GetPixelFormatConversion_kV4B10Bit_BE_OutputNode(HGColorGamma *this)
{
  if (!*((void *)this + 71))
  {
    uint64_t v2 = (HgcPixelFormatConversion_kV4B10Bit_BE_output *)HGObject::operator new(0x1A0uLL);
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 12) = 0u;
    *((_OWORD *)v2 + 13) = 0u;
    *((_OWORD *)v2 + 14) = 0u;
    *((_OWORD *)v2 + 15) = 0u;
    *((_OWORD *)v2 + 16) = 0u;
    *((_OWORD *)v2 + 17) = 0u;
    *((_OWORD *)v2 + 18) = 0u;
    *((_OWORD *)v2 + 19) = 0u;
    *((_OWORD *)v2 + 20) = 0u;
    *((_OWORD *)v2 + 21) = 0u;
    *((_OWORD *)v2 + 22) = 0u;
    *((_OWORD *)v2 + 23) = 0u;
    *((_OWORD *)v2 + 24) = 0u;
    *((_OWORD *)v2 + 25) = 0u;
    HgcPixelFormatConversion_kV4B10Bit_BE_output::HgcPixelFormatConversion_kV4B10Bit_BE_output(v2);
  }
  return *((void *)this + 71);
}

void sub_1B775667C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::m_GetPixelFormatConversion_kV4S_BE_WXYZ_OutputNode(HGColorGamma *this)
{
  if (!*((void *)this + 70))
  {
    uint64_t v2 = (HgcPixelFormatConversion_kV4S_BE_WXYZ_output *)HGObject::operator new(0x1A0uLL);
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 12) = 0u;
    *((_OWORD *)v2 + 13) = 0u;
    *((_OWORD *)v2 + 14) = 0u;
    *((_OWORD *)v2 + 15) = 0u;
    *((_OWORD *)v2 + 16) = 0u;
    *((_OWORD *)v2 + 17) = 0u;
    *((_OWORD *)v2 + 18) = 0u;
    *((_OWORD *)v2 + 19) = 0u;
    *((_OWORD *)v2 + 20) = 0u;
    *((_OWORD *)v2 + 21) = 0u;
    *((_OWORD *)v2 + 22) = 0u;
    *((_OWORD *)v2 + 23) = 0u;
    *((_OWORD *)v2 + 24) = 0u;
    *((_OWORD *)v2 + 25) = 0u;
    HgcPixelFormatConversion_kV4S_BE_WXYZ_output::HgcPixelFormatConversion_kV4S_BE_WXYZ_output(v2);
  }
  return *((void *)this + 70);
}

void sub_1B7756734(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::m_GetPixelFormatConversion_kV4B_WXYZ_OutputNode(HGColorGamma *this)
{
  if (!*((void *)this + 63))
  {
    uint64_t v2 = (HgcPixelFormatConversion_kV4B_WXYZ_output *)HGObject::operator new(0x200uLL);
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 12) = 0u;
    *((_OWORD *)v2 + 13) = 0u;
    *((_OWORD *)v2 + 14) = 0u;
    *((_OWORD *)v2 + 15) = 0u;
    *((_OWORD *)v2 + 16) = 0u;
    *((_OWORD *)v2 + 17) = 0u;
    *((_OWORD *)v2 + 18) = 0u;
    *((_OWORD *)v2 + 19) = 0u;
    *((_OWORD *)v2 + 20) = 0u;
    *((_OWORD *)v2 + 21) = 0u;
    *((_OWORD *)v2 + 22) = 0u;
    *((_OWORD *)v2 + 23) = 0u;
    *((_OWORD *)v2 + 24) = 0u;
    *((_OWORD *)v2 + 25) = 0u;
    *((_OWORD *)v2 + 26) = 0u;
    *((_OWORD *)v2 + 27) = 0u;
    *((_OWORD *)v2 + 28) = 0u;
    *((_OWORD *)v2 + 29) = 0u;
    *((_OWORD *)v2 + 30) = 0u;
    *((_OWORD *)v2 + 31) = 0u;
    HgcPixelFormatConversion_kV4B_WXYZ_output::HgcPixelFormatConversion_kV4B_WXYZ_output(v2);
  }
  return *((void *)this + 63);
}

void sub_1B77567F8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::m_GetPixelFormatConversion_kV4S_WXYZ_OutputNode(HGColorGamma *this)
{
  if (!*((void *)this + 64))
  {
    uint64_t v2 = (HgcPixelFormatConversion_kV4S_WXYZ_output *)HGObject::operator new(0x200uLL);
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 12) = 0u;
    *((_OWORD *)v2 + 13) = 0u;
    *((_OWORD *)v2 + 14) = 0u;
    *((_OWORD *)v2 + 15) = 0u;
    *((_OWORD *)v2 + 16) = 0u;
    *((_OWORD *)v2 + 17) = 0u;
    *((_OWORD *)v2 + 18) = 0u;
    *((_OWORD *)v2 + 19) = 0u;
    *((_OWORD *)v2 + 20) = 0u;
    *((_OWORD *)v2 + 21) = 0u;
    *((_OWORD *)v2 + 22) = 0u;
    *((_OWORD *)v2 + 23) = 0u;
    *((_OWORD *)v2 + 24) = 0u;
    *((_OWORD *)v2 + 25) = 0u;
    *((_OWORD *)v2 + 26) = 0u;
    *((_OWORD *)v2 + 27) = 0u;
    *((_OWORD *)v2 + 28) = 0u;
    *((_OWORD *)v2 + 29) = 0u;
    *((_OWORD *)v2 + 30) = 0u;
    *((_OWORD *)v2 + 31) = 0u;
    HgcPixelFormatConversion_kV4S_WXYZ_output::HgcPixelFormatConversion_kV4S_WXYZ_output(v2);
  }
  return *((void *)this + 64);
}

void sub_1B77568BC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::m_GetPixelFormatConversion_kV4F_WXYZ_OutputNode(HGColorGamma *this)
{
  if (!*((void *)this + 65))
  {
    uint64_t v2 = (HgcPixelFormatConversion_kV4F_WXYZ_output *)HGObject::operator new(0x200uLL);
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 12) = 0u;
    *((_OWORD *)v2 + 13) = 0u;
    *((_OWORD *)v2 + 14) = 0u;
    *((_OWORD *)v2 + 15) = 0u;
    *((_OWORD *)v2 + 16) = 0u;
    *((_OWORD *)v2 + 17) = 0u;
    *((_OWORD *)v2 + 18) = 0u;
    *((_OWORD *)v2 + 19) = 0u;
    *((_OWORD *)v2 + 20) = 0u;
    *((_OWORD *)v2 + 21) = 0u;
    *((_OWORD *)v2 + 22) = 0u;
    *((_OWORD *)v2 + 23) = 0u;
    *((_OWORD *)v2 + 24) = 0u;
    *((_OWORD *)v2 + 25) = 0u;
    *((_OWORD *)v2 + 26) = 0u;
    *((_OWORD *)v2 + 27) = 0u;
    *((_OWORD *)v2 + 28) = 0u;
    *((_OWORD *)v2 + 29) = 0u;
    *((_OWORD *)v2 + 30) = 0u;
    *((_OWORD *)v2 + 31) = 0u;
    HgcPixelFormatConversion_kV4F_WXYZ_output::HgcPixelFormatConversion_kV4F_WXYZ_output(v2);
  }
  return *((void *)this + 65);
}

void sub_1B7756980(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

_OWORD *HGColorGamma::LoadMacroNodeParams(_OWORD *this)
{
  uint64_t v1 = this;
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  float32x4_t v3 = *((float32x4_t *)this + 56);
  float32x4_t v2 = *((float32x4_t *)this + 57);
  float32x4_t v5 = *((float32x4_t *)this + 58);
  float32x4_t v4 = *((float32x4_t *)this + 59);
  int8x16_t v6 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(v2, (float32x4_t)xmmword_1B7E736C0), (int8x16_t)vceqq_f32(v3, (float32x4_t)xmmword_1B7E736B0)), vandq_s8((int8x16_t)vceqq_f32(v5, (float32x4_t)xmmword_1B7E736D0), (int8x16_t)vceqq_f32(v4, (float32x4_t)xmmword_1B7E734D0))))));
  *(int32x2_t *)v6.i8 = vpmin_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v6.i8, *(int32x2_t *)v6.i8).u32[0])
  {
    float32x4_t v7 = *((float32x4_t *)this + 67);
    float32x4_t v22 = vmulq_f32(v3, v7);
    float32x4_t v23 = vmulq_f32(v7, v2);
    float32x4_t v24 = vmulq_f32(v7, v5);
    float32x4_t v25 = vmulq_f32(v7, v4);
    uint64_t v8 = (_OWORD *)*((void *)this + 53);
    if (!v8)
    {
      int8x16_t v9 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
      HGColorMatrix::HGColorMatrix(v9);
    }
    this = HGColorMatrix::LoadMatrix(v8, &v22, 1);
  }
  float32x4_t v11 = *((float32x4_t *)v1 + 60);
  float32x4_t v10 = *((float32x4_t *)v1 + 61);
  float32x4_t v13 = *((float32x4_t *)v1 + 62);
  float32x4_t v12 = *((float32x4_t *)v1 + 63);
  int8x16_t v14 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(v10, (float32x4_t)xmmword_1B7E736C0), (int8x16_t)vceqq_f32(v11, (float32x4_t)xmmword_1B7E736B0)), vandq_s8((int8x16_t)vceqq_f32(v13, (float32x4_t)xmmword_1B7E736D0), (int8x16_t)vceqq_f32(v12, (float32x4_t)xmmword_1B7E734D0))))));
  *(int32x2_t *)v14.i8 = vpmin_s32(*(int32x2_t *)v14.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL));
  if (vpmin_s32(*(int32x2_t *)v14.i8, *(int32x2_t *)v14.i8).u32[0])
  {
    int8x16_t v15 = *((int8x16_t *)v1 + 68);
    *(int32x2_t *)v16.f32 = vdup_lane_s32(*(int32x2_t *)v15.i8, 0);
    *(int8x8_t *)&v16.u32[2] = vqtbl1_s8(v15, (int8x8_t)0xF0E0D0C03020100);
    float32x4_t v17 = vmulq_f32(v11, v16);
    *(int32x2_t *)v16.f32 = vdup_lane_s32(*(int32x2_t *)v15.i8, 1);
    *(int8x8_t *)&v16.u32[2] = vqtbl1_s8(v15, (int8x8_t)0xF0E0D0C07060504);
    float32x4_t v22 = v17;
    float32x4_t v23 = vmulq_f32(v10, v16);
    *(int8x8_t *)v18.f32 = vqtbl1_s8(v15, (int8x8_t)0xB0A09080B0A0908);
    *(int8x8_t *)&v18.u32[2] = vqtbl1_s8(v15, (int8x8_t)0xF0E0D0C0B0A0908);
    float32x4_t v19 = vmulq_f32(v13, v18);
    *(int8x8_t *)v18.f32 = vqtbl1_s8(v15, (int8x8_t)0xF0E0D0C0F0E0D0CLL);
    v18.i64[1] = v18.i64[0];
    float32x4_t v24 = v19;
    float32x4_t v25 = vmulq_f32(v12, v18);
    int v20 = (_OWORD *)*((void *)v1 + 54);
    if (!v20)
    {
      __n128 v21 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
      HGColorMatrix::HGColorMatrix(v21);
    }
    return HGColorMatrix::LoadMatrix(v20, &v22, 1);
  }
  return this;
}

void sub_1B7756B90(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7756BA4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorGamma::PrepareOutputNode(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(result + 1036) == 1)
  {
    *(void *)(result + 1040) = a3;
    *(void *)(result + 1048) = a4;
  }
  return result;
}

char *HGColorGamma::label_B(HGColorGamma *this)
{
  return hgcolorgamma_span_read_label[*(int *)(*((void *)this + 51) + 288)];
}

uint64_t HGColorGamma::SetParameter(HGColorGamma *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

HGNode *HGColorGamma::SetFallbackMode(HGNode *this, uint64_t a2, char *a3)
{
  char v3 = a2;
  uint64_t result = HGNode::ClearBits(this, a2, a3);
  *((unsigned char *)this + 745) = 1;
  *((unsigned char *)this + 1024) = v3;
  return result;
}

HGNode *HGColorGamma::SetToneQualityMode(uint64_t a1, uint64_t a2, char *a3)
{
  int v3 = a2;
  uint64_t result = HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(unsigned char *)(a1 + 745) = 1;
  *(_DWORD *)(a1 + 1168) = v3;
  return result;
}

HGNode *HGColorGamma::SetInOut422FilterMode(uint64_t a1, uint64_t a2, char *a3)
{
  int v3 = a2;
  uint64_t result = HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(unsigned char *)(a1 + 745) = 1;
  *(_DWORD *)(a1 + 1036) = v3;
  return result;
}

HGRect *HGColorGamma::SetInOut422FilterRect(HGRect *this, HGRect a2)
{
  this[65] = a2;
  return this;
}

double HGColorGamma::SetInputPixelFormat(uint64_t a1, uint64_t a2, char *a3)
{
  int v3 = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(unsigned char *)(a1 + 745) = 1;
  *(_DWORD *)(a1 + 1060) = v3;

  *(void *)&double result = HGColorGamma::SetYCbCrBiasAndScale((HGNode *)a1, v5, v6).n128_u64[0];
  return result;
}

__n128 HGColorGamma::SetYCbCrBiasAndScale(HGNode *this, uint64_t a2, char *a3)
{
  _Q0 = xmmword_1B7EC1D50;
  long long v5 = xmmword_1B7EC1D60;
  switch(*((_DWORD *)this + 265))
  {
    case 0:
      __asm { FMOV            V0.4S, #1.0; jumptable 00000001B7756D38 case 0 }
      long long v5 = 0uLL;
      goto LABEL_8;
    case 1:
    case 5:
    case 8:
    case 0xA:
    case 0x10:
    case 0x17:
      goto LABEL_8;
    case 2:
      _Q0 = xmmword_1B7EC1DB0;
      long long v5 = xmmword_1B7EC1DC0;
      goto LABEL_8;
    case 3:
    case 6:
    case 0xC:
    case 0xE:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x19:
    case 0x1A:
      _Q0 = xmmword_1B7EC1D90;
      long long v5 = xmmword_1B7EC1DA0;
      goto LABEL_8;
    case 4:
    case 7:
      long long v5 = xmmword_1B7EC1D80;
      goto LABEL_8;
    case 9:
    case 0xB:
      long long v5 = xmmword_1B7EC1D80;
      __asm { FMOV            V0.4S, #1.0 }
      goto LABEL_8;
    case 0xD:
    case 0xF:
    case 0x18:
      long long v5 = xmmword_1B7EC1D70;
      __asm { FMOV            V0.4S, #1.0 }
LABEL_8:
      long long v16 = v5;
      long long v18 = _Q0;
      HGNode::ClearBits(this, a2, a3);
      *((unsigned char *)this + 745) = 1;
      *((_OWORD *)this + 69) = v16;
      HGNode::ClearBits(this, v10, v11);
      *((unsigned char *)this + 745) = 1;
      *((_OWORD *)this + 67) = v18;
      break;
    default:
      break;
  }
  __n128 result = (__n128)xmmword_1B7EC1DD0;
  long long v13 = xmmword_1B7EC1DE0;
  switch(*((_DWORD *)this + 266))
  {
    case 0:
      __asm { FMOV            V0.4S, #1.0; jumptable 00000001B7756E00 case 0 }
      long long v13 = 0uLL;
      goto LABEL_16;
    case 1:
    case 5:
    case 8:
    case 0xA:
    case 0x10:
    case 0x17:
      goto LABEL_16;
    case 2:
      __n128 result = (__n128)xmmword_1B7EC1E30;
      long long v13 = xmmword_1B7EC1E40;
      goto LABEL_16;
    case 3:
    case 6:
    case 0xC:
    case 0xE:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x19:
    case 0x1A:
      __n128 result = (__n128)xmmword_1B7EC1E10;
      long long v13 = xmmword_1B7EC1E20;
      goto LABEL_16;
    case 4:
    case 7:
      long long v13 = xmmword_1B7EC1E00;
      goto LABEL_16;
    case 9:
    case 0xB:
      long long v13 = xmmword_1B7EC1E00;
      __asm { FMOV            V0.4S, #1.0 }
      goto LABEL_16;
    case 0xD:
    case 0xF:
    case 0x18:
      long long v13 = xmmword_1B7EC1DF0;
      __asm { FMOV            V0.4S, #1.0 }
LABEL_16:
      long long v17 = v13;
      __n128 v19 = result;
      HGNode::ClearBits(this, a2, a3);
      *((unsigned char *)this + 745) = 1;
      *((_OWORD *)this + 70) = v17;
      HGNode::ClearBits(this, v14, v15);
      *((unsigned char *)this + 745) = 1;
      __n128 result = v19;
      *((__n128 *)this + 68) = v19;
      break;
    default:
      return result;
  }
  return result;
}

double HGColorGamma::SetOutputPixelFormat(uint64_t a1, uint64_t a2, char *a3)
{
  int v3 = (int)a3;
  int v4 = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(unsigned char *)(a1 + 745) = 1;
  *(_DWORD *)(a1 + 1056) = v4;
  *(_DWORD *)(a1 + 1064) = v3;

  *(void *)&double result = HGColorGamma::SetYCbCrBiasAndScale((HGNode *)a1, v6, v7).n128_u64[0];
  return result;
}

unsigned char *HGColorGamma::SetPremultiplyState(unsigned char *this, char a2, char a3)
{
  this[745] = 1;
  this[1172] = a2;
  this[1173] = a3;
  return this;
}

HGNode *HGColorGamma::Set1DLutScaleAndOffset(HGNode *this, float a2, float a3, uint64_t a4, char *a5)
{
  double result = HGNode::ClearBits(this, a4, a5);
  *((unsigned char *)this + 745) = 1;
  *((float *)this + 289) = a2;
  *((float *)this + 290) = a3;
  return result;
}

HGNode *HGColorGamma::SetARRILogCExposureIndex(HGNode *this, uint64_t a2, char *a3)
{
  int v3 = a2;
  double result = HGNode::ClearBits(this, a2, a3);
  *((unsigned char *)this + 745) = 1;
  *((_DWORD *)this + 291) = v3;
  return result;
}

__n128 HGColorGamma::LoadMatrix1(uint64_t a1, uint64_t a2, char *a3)
{
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(unsigned char *)(a1 + 745) = 1;
  *(_OWORD *)(a1 + 896) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 912) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 928) = *(_OWORD *)(a2 + 32);
  __n128 result = *(__n128 *)(a2 + 48);
  *(__n128 *)(a1 + 944) = result;
  return result;
}

__n128 HGColorGamma::LoadMatrix2(uint64_t a1, uint64_t a2, char *a3)
{
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(unsigned char *)(a1 + 745) = 1;
  *(_OWORD *)(a1 + 960) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 976) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 992) = *(_OWORD *)(a2 + 32);
  __n128 result = *(__n128 *)(a2 + 48);
  *(__n128 *)(a1 + 1008) = result;
  return result;
}

HGNode *HGColorGamma::SetGammaFunction(uint64_t a1, uint64_t a2, char *a3, __n128 a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8, float32x4_t a9, float32x4_t a10)
{
  int v10 = a2;
  __n128 result = HGNode::ClearBits((HGNode *)a1, a2, a3);
  float v13 = a5.f32[0];
  int8x16_t v15 = (int8x16_t)a6;
  int8x16_t v14 = (int8x16_t)a7;
  *(unsigned char *)(a1 + 745) = 1;
  switch(v10)
  {
    case 1:
      int8x16_t v16 = (int8x16_t)vceqzq_f32(vmulq_f32(a6, (float32x4_t)xmmword_1B7E75890));
      int8x16_t v17 = vandq_s8((int8x16_t)vceqq_f32(vmulq_f32(a5, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890), (int8x16_t)vceqq_f32(vmulq_f32((float32x4_t)a4, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890));
      goto LABEL_6;
    case 2:
      int8x16_t v18 = (int8x16_t)vceqq_f32(vmulq_f32((float32x4_t)a4, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890);
      int8x16_t v19 = (int8x16_t)vceqq_f32(vmulq_f32(a5, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890);
      int8x16_t v20 = (int8x16_t)vceqzq_f32(vmulq_f32(a6, (float32x4_t)xmmword_1B7E75890));
      int8x16_t v21 = (int8x16_t)vceqzq_f32(vmulq_f32(a7, (float32x4_t)xmmword_1B7E75890));
      goto LABEL_5;
    case 3:
      int8x16_t v18 = (int8x16_t)vceqq_f32(vmulq_f32((float32x4_t)a4, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890);
      int8x16_t v19 = (int8x16_t)vceqq_f32(vmulq_f32(a5, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890);
      int8x16_t v20 = (int8x16_t)vceqzq_f32(vmulq_f32(a6, (float32x4_t)xmmword_1B7E75890));
      int8x16_t v21 = (int8x16_t)vceqq_f32(vmulq_f32(a7, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890);
LABEL_5:
      int8x16_t v17 = vandq_s8(v19, v18);
      int8x16_t v16 = vandq_s8(v20, v21);
LABEL_6:
      int8x16_t v22 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(v17, v16))));
      *(int32x2_t *)v22.i8 = vpmin_s32(*(int32x2_t *)v22.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
      if (vpmin_s32(*(int32x2_t *)v22.i8, *(int32x2_t *)v22.i8).u32[0]) {
        goto LABEL_7;
      }
      goto LABEL_10;
    case 4:
      int8x16_t v29 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vmvn_s8((int8x8_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8(vandq_s8((int8x16_t)vceqq_f32(vmulq_f32(a5, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890), (int8x16_t)vceqq_f32(vmulq_f32((float32x4_t)a4, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890)), vandq_s8((int8x16_t)vceqq_f32(vmulq_f32(a7, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E75890), (int8x16_t)vceqzq_f32(vmulq_f32(vaddq_f32(a6, a9), (float32x4_t)xmmword_1B7E75890)))), (int8x16_t)vceqzq_f32(vmulq_f32(a10, (float32x4_t)xmmword_1B7E75890)))))), 0x1FuLL));
      *(int32x2_t *)v29.i8 = vpmin_s32(*(int32x2_t *)v29.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL));
      if (!vpmin_s32(*(int32x2_t *)v29.i8, *(int32x2_t *)v29.i8).u32[0]) {
        goto LABEL_10;
      }
      goto LABEL_7;
    case 5:
LABEL_10:
      *(void *)(a1 + 1028) = 0;
      __asm { FMOV            V0.4S, #1.0 }
      v28.i64[0] = 0;
      v28.i32[2] = 0;
      *(_OWORD *)(a1 + 768) = _Q0;
      *(_OWORD *)(a1 + 784) = 0u;
      __asm { FMOV            V2.2S, #1.0 }
      float v26 = 0.0;
      *(_OWORD *)(a1 + 800) = 0u;
      *(_OWORD *)(a1 + 816) = 0u;
      float v23 = 0.0;
      float v13 = 0.0;
      int8x16_t v24 = 0uLL;
      int8x16_t v25 = 0uLL;
      *(_OWORD *)(a1 + 832) = 0u;
      *(_OWORD *)(a1 + 848) = 0u;
      int8x16_t v14 = 0uLL;
      int8x16_t v15 = 0uLL;
      *(_OWORD *)(a1 + 864) = 0u;
      if (1.0 == *(float *)_D2.i32) {
        goto LABEL_11;
      }
      goto LABEL_24;
    default:
LABEL_7:
      *(_DWORD *)(a1 + 1028) = v10;
      *(_DWORD *)(a1 + 1032) = 0;
      *(__n128 *)(a1 + 768) = a4;
      *(float32x4_t *)(a1 + 784) = a5;
      *(float32x4_t *)(a1 + 800) = a6;
      *(float32x4_t *)(a1 + 816) = a7;
      float v23 = a5.f32[1];
      int8x16_t v25 = a8;
      int8x16_t v24 = (int8x16_t)a9;
      *(int8x16_t *)(a1 + 832) = a8;
      *(float32x4_t *)(a1 + 848) = a9;
      float v26 = a5.f32[2];
      _D2 = (int32x2_t)vextq_s8((int8x16_t)a4, (int8x16_t)a4, 4uLL).u64[0];
      float32x4_t v28 = a10;
      *(float32x4_t *)(a1 + 864) = a10;
      if (a4.n128_f32[0] != *(float *)_D2.i32) {
        goto LABEL_24;
      }
LABEL_11:
      if (vceq_f32((float32x2_t)_D2, (float32x2_t)vdup_lane_s32(_D2, 1)).u8[0])
      {
        _ZF = v13 == v23 && v23 == v26;
        if (_ZF
          && (v35 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v15.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v15.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL))), (vand_s8((int8x8_t)v35, (int8x8_t)vdup_lane_s32(v35, 1)).u32[0] & 1) != 0)&& (int32x2_t v36 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v14.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v14.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL))), (vand_s8((int8x8_t)v36, (int8x8_t)vdup_lane_s32(v36, 1)).u32[0] & 1) != 0)&& (v37 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v25.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v25.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL))), (vand_s8((int8x8_t)v37, (int8x8_t)vdup_lane_s32(v37, 1)).u32[0] & 1) != 0)&& (v38 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v24.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v24.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL))), (vand_s8((int8x8_t)v38, (int8x8_t)vdup_lane_s32(v38, 1)).u32[0] & 1) != 0))
        {
          BOOL v39 = v28.f32[1] == v28.f32[2];
          if (v28.f32[0] != v28.f32[1]) {
            BOOL v39 = 0;
          }
          *(unsigned char *)(a1 + 880) = v39;
        }
        else
        {
          *(unsigned char *)(a1 + 880) = 0;
        }
      }
      else
      {
LABEL_24:
        *(unsigned char *)(a1 + 880) = 0;
      }
      return result;
  }
}

HGNode *HGColorGamma::SetDitherMode(HGNode *this, uint64_t a2, char *a3)
{
  char v3 = a2;
  __n128 result = HGNode::ClearBits(this, a2, a3);
  *((unsigned char *)this + 745) = 1;
  *((unsigned char *)this + 1025) = v3;
  return result;
}

HGNode *HGColorGamma::SetFixedPointPrecisionMode(HGNode *this, uint64_t a2, char *a3)
{
  char v3 = a2;
  __n128 result = HGNode::ClearBits(this, a2, a3);
  *((unsigned char *)this + 745) = 1;
  *((unsigned char *)this + 1026) = v3;
  return result;
}

uint64_t HGColorGamma::SetAntiSymmetricToneCurves(uint64_t this, char a2)
{
  *(unsigned char *)(this + 1175) = a2;
  return this;
}

double HGColorGamma::SetConversion(uint64_t a1, uint64_t a2, char *a3, unsigned int a4, int a5)
{
  int v7 = (int)a3;
  unsigned int v8 = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(unsigned char *)(a1 + 745) = 1;
  int v10 = (_OWORD *)((char *)&HGColorGamma::YCbCrToRGB + 64 * (unint64_t)v8);
  HGNode::ClearBits((HGNode *)a1, v11, v12);
  *(unsigned char *)(a1 + 745) = 1;
  *(_OWORD *)(a1 + 896) = *v10;
  *(_OWORD *)(a1 + 912) = v10[1];
  *(_OWORD *)(a1 + 928) = v10[2];
  *(_OWORD *)(a1 + 944) = xmmword_1B7E734D0;
  int8x16_t v15 = HGNode::ClearBits((HGNode *)a1, v13, v14);
  *(unsigned char *)(a1 + 745) = 1;
  *(_DWORD *)(a1 + 1028) = 5;
  *(_DWORD *)(a1 + 1032) = v7;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(a1 + 768) = _Q0;
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_OWORD *)(a1 + 848) = 0u;
  *(_OWORD *)(a1 + 864) = 0u;
  *(unsigned char *)(a1 + 880) = 1;
  switch(v7)
  {
    case 0:
    case 1:
      int v23 = 0;
      double v24 = 0.0;
      int8x16_t v25 = &HGArriLogCDefaultToneCurveLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 2:
      int v23 = 0;
      double v24 = 0.0;
      int8x16_t v25 = &HGArriLogCLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 3:
      double v24 = 0.0;
      double v26 = 1.0;
      int v23 = 2048;
      break;
    case 4:
      double v24 = HGCanonLogToneCurveLUTInfo::kMinLogGamma((HGCanonLogToneCurveLUTInfo *)v15);
      double v26 = HGCanonLogToneCurveLUTInfo::kMaxLogGamma(v27);
      int v23 = 0;
      break;
    case 5:
      int v23 = 0;
      double v24 = -0.0730593607;
      int8x16_t v25 = &HGCanonLogLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 6:
      int v23 = 0;
      double v24 = -0.0730593607;
      int8x16_t v25 = &HGCanonLog2LinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 7:
      int v23 = 0;
      double v24 = -0.0730593607;
      int8x16_t v25 = &HGCanonLog3LinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 8:
      int v23 = 0;
      double v24 = -0.0730593607;
      int8x16_t v25 = &HGSonySLog2LinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 9:
      int v23 = 0;
      double v24 = 0.0;
      int8x16_t v25 = &HGSonySLog3LinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 10:
      int v23 = 0;
      double v24 = 0.0;
      int8x16_t v25 = &HGPanasonicVLogLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 11:
      int v23 = 0;
      double v24 = 0.0;
      int8x16_t v25 = &HGNikonNLogLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 12:
    case 13:
      int v23 = 0;
      double v24 = 0.0;
      int8x16_t v25 = &HGBMDFilmLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 14:
      int v23 = 0;
      double v24 = 0.0;
      int8x16_t v25 = &HGAppleLogLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 15:
      int v23 = 0;
      double v24 = 0.0;
      int8x16_t v25 = &HGDJIDLogLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 16:
      int v23 = 0;
      double v24 = 0.0;
      int8x16_t v25 = &HGFujifilmFLogLinearizationLUTInfo::kMaxLogGamma;
      goto LABEL_19;
    case 17:
      int v23 = 0;
      double v24 = 0.0;
      int8x16_t v25 = &HGFujifilmFLog2LinearizationLUTInfo::kMaxLogGamma;
LABEL_19:
      double v26 = *(double *)v25;
      break;
    default:
      int v23 = 0;
      double v24 = 0.0;
      double v26 = 0.0;
      break;
  }
  float v28 = v26 - v24;
  HGNode::ClearBits((HGNode *)a1, v16, v17);
  *(unsigned char *)(a1 + 745) = 1;
  *(float *)(a1 + 1156) = v28;
  float v29 = v24;
  *(float *)(a1 + 1160) = v29;
  if (v23)
  {
    HGNode::ClearBits((HGNode *)a1, v30, v31);
    *(unsigned char *)(a1 + 745) = 1;
    *(_DWORD *)(a1 + 1152) = v23;
  }
  unint64_t v32 = (unint64_t)a4 << 6;
  uint64_t v33 = (char *)&HGColorGamma::logGamutRGBToRec2020RGB + v32;
  int8x16_t v34 = (char *)&HGColorGamma::logGamutRGBToRec709RGB + v32;
  if (a5 == 3) {
    int32x2_t v35 = v33;
  }
  else {
    int32x2_t v35 = v34;
  }
  HGNode::ClearBits((HGNode *)a1, v30, v31);
  *(unsigned char *)(a1 + 745) = 1;
  *(_OWORD *)(a1 + 960) = *v35;
  *(_OWORD *)(a1 + 976) = v35[1];
  *(_OWORD *)(a1 + 992) = v35[2];
  *(_OWORD *)(a1 + 1008) = v35[3];

  *(void *)&double result = HGColorGamma::SetYCbCrBiasAndScale((HGNode *)a1, v36, v37).n128_u64[0];
  return result;
}

uint64_t HGColorGamma::SetConversion(uint64_t a1, uint64_t a2, char *a3, unsigned int a4, unsigned int a5, int a6, unsigned int a7)
{
  int v11 = (int)a3;
  unsigned int v12 = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(unsigned char *)(a1 + 745) = 1;
  if (a6 == 8)
  {
    if (!a7 && (v11 != 8 || !a4))
    {
      uint64_t v16 = (_OWORD *)((char *)&HGColorGamma::YCbCrToRGB + 64 * (unint64_t)a4);
      HGNode::ClearBits((HGNode *)a1, v14, v15);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = *v16;
      *(_OWORD *)(a1 + 912) = v16[1];
      *(_OWORD *)(a1 + 928) = v16[2];
      *(_OWORD *)(a1 + 944) = xmmword_1B7E734D0;
      switch(v11)
      {
        case 1:
          HGNode::ClearBits((HGNode *)a1, v17, v18);
          *(unsigned char *)(a1 + 745) = 1;
          *(void *)(a1 + 1028) = 0;
          _Q0 = xmmword_1B7EC1E80;
          goto LABEL_38;
        case 8:
          HGNode::ClearBits((HGNode *)a1, v17, v18);
          *(unsigned char *)(a1 + 745) = 1;
          *(void *)(a1 + 1028) = 0;
          goto LABEL_37;
        case 13:
          HGColorGamma::SetGammaFunctionSRGBLinearize((HGNode *)a1, v17, v18);
          break;
        case 16:
          HGNode::ClearBits((HGNode *)a1, v17, v18);
          *(unsigned char *)(a1 + 745) = 1;
          __n128 v84 = (uint64_t *)(a1 + 1028);
          uint64_t v85 = 13;
          goto LABEL_36;
        case 17:
          HGNode::ClearBits((HGNode *)a1, v17, v18);
          *(unsigned char *)(a1 + 745) = 1;
          *(void *)(a1 + 1028) = 0;
          _Q0 = xmmword_1B7EC1E70;
          goto LABEL_38;
        case 18:
          HGNode::ClearBits((HGNode *)a1, v17, v18);
          *(unsigned char *)(a1 + 745) = 1;
          __n128 v84 = (uint64_t *)(a1 + 1028);
          uint64_t v85 = 11;
LABEL_36:
          *__n128 v84 = v85;
LABEL_37:
          __asm { FMOV            V0.4S, #1.0 }
LABEL_38:
          *(_OWORD *)(a1 + 768) = _Q0;
          *(_OWORD *)(a1 + 784) = 0u;
          *(_OWORD *)(a1 + 800) = 0u;
          *(_OWORD *)(a1 + 816) = 0u;
          *(_OWORD *)(a1 + 832) = 0u;
          *(_OWORD *)(a1 + 848) = 0u;
          *(_OWORD *)(a1 + 864) = 0u;
          *(unsigned char *)(a1 + 880) = 1;
          break;
        default:
          break;
      }
      if (v12 == a5)
      {
        HGNode::ClearBits((HGNode *)a1, v17, v18);
        *(unsigned char *)(a1 + 745) = 1;
LABEL_43:
        *(_OWORD *)(a1 + 960) = xmmword_1B7E736B0;
        *(_OWORD *)(a1 + 976) = xmmword_1B7E736C0;
        long long v32 = xmmword_1B7E736D0;
        goto LABEL_44;
      }
      unsigned __int8 v86 = (double *)((char *)&HGColorGamma::XYZToRGB + 72 * a5);
      uint64_t v87 = (char *)&HGColorGamma::RGBToXYZ + 72 * v12;
      double v88 = v86[1];
      double v89 = *((double *)v87 + 2);
      double v90 = *((double *)v87 + 5);
      double v91 = *((double *)v87 + 8);
      double v92 = v86[2];
      double v93 = v86[3];
      double v94 = *v86 * v89 + v88 * v90 + v92 * v91;
      double v95 = v86[4];
      double v96 = v86[5];
      double v97 = v89 * v93 + v90 * v95 + v91 * v96;
      double v98 = v86[6];
      double v99 = v86[7];
      double v100 = v86[8];
      double v101 = v89 * v98 + v90 * v99 + v91 * v100;
      *(float *)&double v94 = v94;
      *(float *)&double v90 = v97;
      float64x2_t v102 = *(float64x2_t *)(v87 + 24);
      float64x2_t v103 = *((float64x2_t *)v87 + 3);
      *(float32x2_t *)&long long v104 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(*(float64x2_t *)v87, *v86), vmulq_n_f64(v102, v88)), vmulq_n_f64(v103, v92)));
      *((void *)&v104 + 1) = LODWORD(v94);
      long long v112 = v104;
      *(float32x2_t *)&long long v104 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(*(float64x2_t *)v87, v93), vmulq_n_f64(v102, v95)), vmulq_n_f64(v103, v96)));
      *((void *)&v104 + 1) = LODWORD(v90);
      long long v109 = v104;
      *(float32x2_t *)&long long v105 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(*(float64x2_t *)v87, v98), vmulq_n_f64(v102, v99)), vmulq_n_f64(v103, v100)));
      *(float *)&long long v104 = v101;
      *((void *)&v105 + 1) = v104;
      long long v115 = v105;
      HGNode::ClearBits((HGNode *)a1, v17, v18);
      long long v32 = v115;
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 960) = v112;
      *(_OWORD *)(a1 + 976) = v109;
LABEL_44:
      *(_OWORD *)(a1 + 992) = v32;
      *(_OWORD *)(a1 + 1008) = xmmword_1B7E734D0;
      HGColorGamma::SetYCbCrBiasAndScale((HGNode *)a1, v30, v31);
      return 1;
    }
    return 0;
  }
  if (v11 == 8)
  {
    if (a4) {
      return 0;
    }
    if (v12 == a5)
    {
      long long v107 = xmmword_1B7E736D0;
      long long v110 = xmmword_1B7E736C0;
      long long v113 = xmmword_1B7E736B0;
    }
    else
    {
      uint64_t v58 = (double *)((char *)&HGColorGamma::XYZToRGB + 72 * a5);
      uint64_t v59 = (char *)&HGColorGamma::RGBToXYZ + 72 * v12;
      double v60 = v58[1];
      double v61 = *((double *)v59 + 2);
      double v62 = *((double *)v59 + 5);
      double v63 = *((double *)v59 + 8);
      double v64 = v58[2];
      double v65 = v58[3];
      double v66 = *v58 * v61 + v60 * v62 + v64 * v63;
      double v67 = v58[4];
      double v68 = v58[5];
      double v69 = v61 * v65 + v62 * v67 + v63 * v68;
      double v70 = v58[6];
      double v71 = v58[7];
      double v72 = v58[8];
      double v73 = v61 * v70 + v62 * v71;
      *(float *)&double v66 = v66;
      *(float *)&double v62 = v69;
      float64x2_t v74 = *(float64x2_t *)(v59 + 24);
      float64x2_t v75 = *((float64x2_t *)v59 + 3);
      *(float32x2_t *)&long long v76 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(*(float64x2_t *)v59, *v58), vmulq_n_f64(v74, v60)), vmulq_n_f64(v75, v64)));
      *((void *)&v76 + 1) = LODWORD(v66);
      long long v113 = v76;
      *(float32x2_t *)&long long v76 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(*(float64x2_t *)v59, v65), vmulq_n_f64(v74, v67)), vmulq_n_f64(v75, v68)));
      *((void *)&v76 + 1) = LODWORD(v62);
      long long v110 = v76;
      *(float32x2_t *)&long long v77 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(*(float64x2_t *)v59, v70), vmulq_n_f64(v74, v71)), vmulq_n_f64(v75, v72)));
      *(float *)&long long v76 = v73 + v63 * v72;
      *((void *)&v77 + 1) = v76;
      long long v107 = v77;
    }
    HGNode::ClearBits((HGNode *)a1, v14, v15);
    *(unsigned char *)(a1 + 745) = 1;
    *(_OWORD *)(a1 + 896) = v113;
    *(_OWORD *)(a1 + 912) = v110;
    *(_OWORD *)(a1 + 928) = v107;
    *(_OWORD *)(a1 + 944) = xmmword_1B7E734D0;
    switch(a6)
    {
      case 1:
        HGNode::ClearBits((HGNode *)a1, v78, v79);
        *(unsigned char *)(a1 + 745) = 1;
        *(void *)(a1 + 1028) = 0;
        _Q0 = xmmword_1B7EC1E60;
        goto LABEL_29;
      case 13:
        HGColorGamma::SetGammaFunctionSRGBGamma((HGNode *)a1, v78, v79);
        break;
      case 16:
        HGNode::ClearBits((HGNode *)a1, v78, v79);
        *(unsigned char *)(a1 + 745) = 1;
        uint64_t v81 = (uint64_t *)(a1 + 1028);
        uint64_t v82 = 12;
        goto LABEL_28;
      case 17:
        HGNode::ClearBits((HGNode *)a1, v78, v79);
        *(unsigned char *)(a1 + 745) = 1;
        *(void *)(a1 + 1028) = 0;
        _Q0 = xmmword_1B7EC1E50;
        goto LABEL_29;
      case 18:
        HGNode::ClearBits((HGNode *)a1, v78, v79);
        *(unsigned char *)(a1 + 745) = 1;
        uint64_t v81 = (uint64_t *)(a1 + 1028);
        uint64_t v82 = 10;
LABEL_28:
        *uint64_t v81 = v82;
        __asm { FMOV            V0.4S, #1.0 }
LABEL_29:
        *(_OWORD *)(a1 + 768) = _Q0;
        *(_OWORD *)(a1 + 784) = 0u;
        *(_OWORD *)(a1 + 800) = 0u;
        *(_OWORD *)(a1 + 816) = 0u;
        *(_OWORD *)(a1 + 832) = 0u;
        *(_OWORD *)(a1 + 848) = 0u;
        *(_OWORD *)(a1 + 864) = 0u;
        *(unsigned char *)(a1 + 880) = 1;
        break;
      default:
        break;
    }
LABEL_30:
    __n128 v83 = (_OWORD *)((char *)&HGColorGamma::RGBToYCbCr + 64 * (unint64_t)a7);
    HGNode::ClearBits((HGNode *)a1, v78, v79);
    *(unsigned char *)(a1 + 745) = 1;
    *(_OWORD *)(a1 + 960) = *v83;
    *(_OWORD *)(a1 + 976) = v83[1];
    long long v32 = v83[2];
    goto LABEL_44;
  }
  uint64_t result = 0;
  if (v12 == a5 && v11 == a6)
  {
    HGNode::ClearBits((HGNode *)a1, v14, v15);
    *(unsigned char *)(a1 + 745) = 1;
    *(void *)(a1 + 1028) = 0;
    __asm { FMOV            V0.4S, #1.0 }
    *(_OWORD *)(a1 + 768) = _Q0;
    *(_OWORD *)(a1 + 784) = 0u;
    *(_OWORD *)(a1 + 800) = 0u;
    *(_OWORD *)(a1 + 816) = 0u;
    *(_OWORD *)(a1 + 832) = 0u;
    *(_OWORD *)(a1 + 848) = 0u;
    *(_OWORD *)(a1 + 864) = 0u;
    *(unsigned char *)(a1 + 880) = 1;
    if (a4 == a7)
    {
      HGNode::ClearBits((HGNode *)a1, v21, v22);
      *(unsigned char *)(a1 + 745) = 1;
      *(_OWORD *)(a1 + 896) = xmmword_1B7E736B0;
      *(_OWORD *)(a1 + 912) = xmmword_1B7E736C0;
      *(_OWORD *)(a1 + 928) = xmmword_1B7E736D0;
      *(_OWORD *)(a1 + 944) = xmmword_1B7E734D0;
      HGNode::ClearBits((HGNode *)a1, v28, v29);
      *(unsigned char *)(a1 + 745) = 1;
      long long v32 = xmmword_1B7E736D0;
      *(_OWORD *)(a1 + 960) = xmmword_1B7E736B0;
      *(_OWORD *)(a1 + 976) = xmmword_1B7E736C0;
      goto LABEL_44;
    }
    if (a4)
    {
      if (a7)
      {
        uint64_t v33 = (float *)((char *)&HGColorGamma::RGBToYCbCr + 64 * (unint64_t)a7);
        int8x16_t v34 = (float32x2_t *)((char *)&HGColorGamma::YCbCrToRGB + 64 * (unint64_t)a4);
        double v35 = *v33;
        double v36 = v33[1];
        double v37 = v33[2];
        double v38 = COERCE_FLOAT(*((_OWORD *)v33 + 1));
        double v39 = COERCE_FLOAT(HIDWORD(*((void *)v33 + 2)));
        double v40 = COERCE_FLOAT(*((void *)v33 + 3));
        double v41 = COERCE_FLOAT(*((_OWORD *)v33 + 2));
        double v42 = COERCE_FLOAT(HIDWORD(*((void *)v33 + 4)));
        double v43 = COERCE_FLOAT(*((void *)v33 + 5));
        double v44 = COERCE_FLOAT(*(void *)&v34[1]);
        double v45 = COERCE_FLOAT(*(void *)&v34[3]);
        double v46 = COERCE_FLOAT(*(void *)&v34[5]);
        double v47 = v35 * v44 + v36 * v45 + v37 * v46;
        double v48 = v38 * v44 + v39 * v45 + v40 * v46;
        double v49 = v41 * v44 + v42 * v45 + v43 * v46;
        *(float *)&double v45 = v47;
        *(float *)&double v46 = v48;
        float64x2_t v50 = vcvtq_f64_f32(*v34);
        float64x2_t v51 = vcvtq_f64_f32(v34[2]);
        float64x2_t v52 = vcvtq_f64_f32(v34[4]);
        *(float32x2_t *)&long long v53 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v50, v35), vmulq_n_f64(v51, v36)), vmulq_n_f64(v52, v37)));
        *((void *)&v53 + 1) = LODWORD(v45);
        *(float32x2_t *)&long long v54 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v50, v38), vmulq_n_f64(v51, v39)), vmulq_n_f64(v52, v40)));
        *((void *)&v54 + 1) = LODWORD(v46);
        long long v111 = v54;
        long long v114 = v53;
        *(float32x2_t *)&long long v55 = vcvt_f32_f64(vaddq_f64(vaddq_f64(vmulq_n_f64(v50, v41), vmulq_n_f64(v51, v42)), vmulq_n_f64(v52, v43)));
        *(float *)&long long v54 = v49;
        *((void *)&v55 + 1) = v54;
        long long v108 = v55;
        HGNode::ClearBits((HGNode *)a1, v21, v22);
        *(unsigned char *)(a1 + 745) = 1;
        *(_OWORD *)(a1 + 896) = v114;
        *(_OWORD *)(a1 + 912) = v111;
        *(_OWORD *)(a1 + 928) = v108;
      }
      else
      {
        int v106 = (_OWORD *)((char *)&HGColorGamma::YCbCrToRGB + 64 * (unint64_t)a4);
        HGNode::ClearBits((HGNode *)a1, v21, v22);
        *(unsigned char *)(a1 + 745) = 1;
        *(_OWORD *)(a1 + 896) = *v106;
        *(_OWORD *)(a1 + 912) = v106[1];
        *(_OWORD *)(a1 + 928) = v106[2];
      }
      *(_OWORD *)(a1 + 944) = xmmword_1B7E734D0;
      HGNode::ClearBits((HGNode *)a1, v56, v57);
      *(unsigned char *)(a1 + 745) = 1;
      goto LABEL_43;
    }
    HGNode::ClearBits((HGNode *)a1, v21, v22);
    *(unsigned char *)(a1 + 745) = 1;
    *(_OWORD *)(a1 + 896) = xmmword_1B7E736B0;
    *(_OWORD *)(a1 + 912) = xmmword_1B7E736C0;
    *(_OWORD *)(a1 + 928) = xmmword_1B7E736D0;
    *(_OWORD *)(a1 + 944) = xmmword_1B7E734D0;
    goto LABEL_30;
  }
  return result;
}

HGNode *HGColorGamma::SetGammaFunctionSRGBLinearize(HGNode *this, uint64_t a2, char *a3)
{
  uint64_t result = HGNode::ClearBits(this, a2, a3);
  *((unsigned char *)this + 745) = 1;
  int32x2_t v5 = vpmin_s32((int32x2_t)-1, (int32x2_t)0xFFFFFFFFLL);
  unsigned __int32 v6 = vpmin_s32(v5, v5).u32[0];
  if (v6)
  {
    int8x16_t v7 = (int8x16_t)xmmword_1B7EC1EA0;
    *((_OWORD *)this + 49) = xmmword_1B7EC1E90;
    *((_OWORD *)this + 50) = xmmword_1B7EC1EA0;
    int8x16_t v8 = (int8x16_t)xmmword_1B7EC1EB0;
    int8x16_t v9 = (int8x16_t)xmmword_1B7EC1EC0;
    *((_OWORD *)this + 51) = xmmword_1B7EC1EB0;
    *((_OWORD *)this + 52) = xmmword_1B7EC1EC0;
    *((_OWORD *)this + 53) = 0u;
    *((_OWORD *)this + 54) = 0u;
    _Q3 = xmmword_1B7EC1ED0;
    unsigned __int32 v6 = 3;
  }
  else
  {
    int8x16_t v9 = 0uLL;
    *((_OWORD *)this + 53) = 0u;
    *((_OWORD *)this + 54) = 0u;
    *((_OWORD *)this + 51) = 0u;
    *((_OWORD *)this + 52) = 0u;
    *((_OWORD *)this + 49) = 0u;
    *((_OWORD *)this + 50) = 0u;
    __asm { FMOV            V3.4S, #1.0 }
    int8x16_t v8 = 0uLL;
    int8x16_t v7 = 0uLL;
  }
  unsigned __int8 v15 = 0;
  *((_DWORD *)this + 257) = v6;
  *((_DWORD *)this + 258) = 0;
  *((_OWORD *)this + 48) = _Q3;
  int32x2_t v16 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL)));
  if ((vand_s8((int8x8_t)v16, (int8x8_t)vdup_lane_s32(v16, 1)).u8[0] & 1) == 0) {
    goto LABEL_7;
  }
  int32x2_t v17 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v8.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)));
  if (vand_s8((int8x8_t)v17, (int8x8_t)vdup_lane_s32(v17, 1)).u8[0])
  {
    int32x2_t v18 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v9.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL)));
    unsigned __int8 v15 = vand_s8((int8x8_t)v18, (int8x8_t)vdup_lane_s32(v18, 1)).u8[0];
LABEL_7:
    *((unsigned char *)this + 880) = v15 & 1;
    return result;
  }
  *((unsigned char *)this + 880) = 0;
  return result;
}

HGNode *HGColorGamma::SetGammaFunctionSRGBGamma(HGNode *this, uint64_t a2, char *a3)
{
  uint64_t result = HGNode::ClearBits(this, a2, a3);
  *((unsigned char *)this + 745) = 1;
  int32x2_t v5 = vpmin_s32((int32x2_t)-1, (int32x2_t)0xFFFFFFFFLL);
  unsigned __int32 v6 = vpmin_s32(v5, v5).u32[0];
  if (v6)
  {
    *((_OWORD *)this + 49) = xmmword_1B7EC1EE0;
    *((_OWORD *)this + 50) = 0u;
    int8x16_t v7 = (int8x16_t)xmmword_1B7EC1EF0;
    int8x16_t v8 = (int8x16_t)xmmword_1B7EC1F00;
    *((_OWORD *)this + 51) = xmmword_1B7EC1EF0;
    *((_OWORD *)this + 52) = xmmword_1B7EC1F00;
    int8x16_t v9 = (int8x16_t)xmmword_1B7EC1F10;
    *((_OWORD *)this + 53) = xmmword_1B7EC1F10;
    *((_OWORD *)this + 54) = 0u;
    _Q3 = xmmword_1B7EC1F20;
    unsigned __int32 v6 = 4;
  }
  else
  {
    int8x16_t v9 = 0uLL;
    *((_OWORD *)this + 53) = 0u;
    *((_OWORD *)this + 54) = 0u;
    *((_OWORD *)this + 51) = 0u;
    *((_OWORD *)this + 52) = 0u;
    *((_OWORD *)this + 49) = 0u;
    *((_OWORD *)this + 50) = 0u;
    __asm { FMOV            V3.4S, #1.0 }
    int8x16_t v8 = 0uLL;
    int8x16_t v7 = 0uLL;
  }
  unsigned __int8 v15 = 0;
  *((_DWORD *)this + 257) = v6;
  *((_DWORD *)this + 258) = 0;
  *((_OWORD *)this + 48) = _Q3;
  int32x2_t v16 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL)));
  if ((vand_s8((int8x8_t)v16, (int8x8_t)vdup_lane_s32(v16, 1)).u8[0] & 1) == 0) {
    goto LABEL_7;
  }
  int32x2_t v17 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v8.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)));
  if (vand_s8((int8x8_t)v17, (int8x8_t)vdup_lane_s32(v17, 1)).u8[0])
  {
    int32x2_t v18 = vceq_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.i8, 1), (float32x2_t)vzip1_s32(*(int32x2_t *)v9.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL)));
    unsigned __int8 v15 = vand_s8((int8x8_t)v18, (int8x8_t)vdup_lane_s32(v18, 1)).u8[0];
LABEL_7:
    *((unsigned char *)this + 880) = v15 & 1;
    return result;
  }
  *((unsigned char *)this + 880) = 0;
  return result;
}

uint64_t HGColorGamma::TestConversion(int a1, int a2, int a3, int a4, int a5, int a6)
{
  if (a5 == 8)
  {
    if (a6) {
      return 0;
    }
    return a2 != 8 || !a3;
  }
  if (a2 == 8) {
    return !a3;
  }
  uint64_t result = 0;
  if (a1 == a4 && a2 == a5) {
    return 1;
  }
  return result;
}

void HGColorGammaLUTEntryFactory::~HGColorGammaLUTEntryFactory(HGColorGammaLUTEntryFactory *this)
{
}

void HGColorGammaLUTEntryFactory::createLUTEntry()
{
}

void sub_1B775841C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0xA1C40987D6AD5);
  _Unwind_Resume(a1);
}

void HGCColorGamma_2vuy_yxzx_expand::~HGCColorGamma_2vuy_yxzx_expand(HGNode *this)
{
  HgcColorGamma_2vuy_yxzx_expand::~HgcColorGamma_2vuy_yxzx_expand(this);

  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_2vuy_yxzx_expand::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_2vuy_yxzx_expand::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4 & 0xFFFFFFFFFFFFFFFELL;
  }
}

void HGCColorGamma_2vuy_xyxz_expand::~HGCColorGamma_2vuy_xyxz_expand(HGNode *this)
{
  HgcColorGamma_2vuy_xyxz_expand::~HgcColorGamma_2vuy_xyxz_expand(this);

  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_2vuy_xyxz_expand::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_2vuy_xyxz_expand::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4 & 0xFFFFFFFFFFFFFFFELL;
  }
}

void HGCColorGamma_v210_yxzx_rgba_expand::~HGCColorGamma_v210_yxzx_rgba_expand(HGNode *this)
{
  HgcColorGamma_v210_yxzx_rgba_expand::~HgcColorGamma_v210_yxzx_rgba_expand(this);

  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_v210_yxzx_rgba_expand::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_v210_yxzx_rgba_expand::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  HIDWORD(v5) = -1431655765 * a4 + 715827882;
  LODWORD(v5) = HIDWORD(v5);
  if ((v5 >> 1) < 0x2AAAAAAB)
  {
    unsigned int v7 = a4;
  }
  else
  {
    float v6 = (double)(int)a4 / 6.0;
    unsigned int v7 = (int)(float)(floorf(v6) * 6.0);
  }
  return a4 & 0xFFFFFFFF00000000 | v7;
}

void HGCColorGamma_v216_yxzx_expand::~HGCColorGamma_v216_yxzx_expand(HGNode *this)
{
  HgcColorGamma_v216_yxzx_expand::~HgcColorGamma_v216_yxzx_expand(this);

  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_v216_yxzx_expand::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_v216_yxzx_expand::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4 & 0xFFFFFFFFFFFFFFFELL;
  }
}

void HGCPixelFormatConversion_kV4B_WXYZ_output::~HGCPixelFormatConversion_kV4B_WXYZ_output(HGCPixelFormatConversion_kV4B_WXYZ_output *this)
{
  HgcPixelFormatConversion_kV4B_WXYZ_output::~HgcPixelFormatConversion_kV4B_WXYZ_output(this);

  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4B_WXYZ_output::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4B_WXYZ_output::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void HGCPixelFormatConversion_kV4S_WXYZ_output::~HGCPixelFormatConversion_kV4S_WXYZ_output(HGCPixelFormatConversion_kV4S_WXYZ_output *this)
{
  HgcPixelFormatConversion_kV4S_WXYZ_output::~HgcPixelFormatConversion_kV4S_WXYZ_output(this);

  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4S_WXYZ_output::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4S_WXYZ_output::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void HGCPixelFormatConversion_kV4F_WXYZ_output::~HGCPixelFormatConversion_kV4F_WXYZ_output(HGCPixelFormatConversion_kV4F_WXYZ_output *this)
{
  HgcPixelFormatConversion_kV4F_WXYZ_output::~HgcPixelFormatConversion_kV4F_WXYZ_output(this);

  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4F_WXYZ_output::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4F_WXYZ_output::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void HGCPixelFormatConversion_kV4S_BE_WXYZ_output::~HGCPixelFormatConversion_kV4S_BE_WXYZ_output(HGNode *this)
{
  HgcPixelFormatConversion_kV4S_BE_WXYZ_output::~HgcPixelFormatConversion_kV4S_BE_WXYZ_output(this);

  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4S_BE_WXYZ_output::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4S_BE_WXYZ_output::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void HGCPixelFormatConversion_kV4B10Bit_BE_output::~HGCPixelFormatConversion_kV4B10Bit_BE_output(HGNode *this)
{
  HgcPixelFormatConversion_kV4B10Bit_BE_output::~HgcPixelFormatConversion_kV4B10Bit_BE_output(this);

  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4B10Bit_BE_output::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4B10Bit_BE_output::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void HGCColorGamma_bias::~HGCColorGamma_bias(HGNode *this)
{
  HgcColorGamma_bias::~HgcColorGamma_bias(this);

  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_bias::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCColorGamma_bias::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

void HGCColorGamma_chroma_downsample_f1::~HGCColorGamma_chroma_downsample_f1(HGNode *this)
{
  HgcColorGamma_chroma_downsample_f1::~HgcColorGamma_chroma_downsample_f1(this);

  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_chroma_downsample_f1::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_chroma_downsample_f1::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return (a4 - 1) | a4 & 0xFFFFFFFF00000000;
  }
}

void HGCColorGamma_chroma_upsample_f1::~HGCColorGamma_chroma_upsample_f1(HGNode *this)
{
  HgcColorGamma_chroma_upsample_f1::~HgcColorGamma_chroma_upsample_f1(this);

  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_chroma_upsample_f1::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_chroma_upsample_f1::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return (a4 - 1) | a4 & 0xFFFFFFFF00000000;
  }
}

void HGCColorGamma_2vuy_yxzx_collapse::~HGCColorGamma_2vuy_yxzx_collapse(HGNode *this)
{
  HgcColorGamma_2vuy_yxzx_collapse::~HgcColorGamma_2vuy_yxzx_collapse(this);

  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_2vuy_yxzx_collapse::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_2vuy_yxzx_collapse::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4 & 0xFFFFFFFFFFFFFFFELL;
  }
}

void HGCColorGamma_2vuy_xyxz_collapse::~HGCColorGamma_2vuy_xyxz_collapse(HGNode *this)
{
  HgcColorGamma_2vuy_xyxz_collapse::~HgcColorGamma_2vuy_xyxz_collapse(this);

  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_2vuy_xyxz_collapse::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_2vuy_xyxz_collapse::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4 & 0xFFFFFFFFFFFFFFFELL;
  }
}

void HGCColorGamma_v210_yxzx_rgba_collapse::~HGCColorGamma_v210_yxzx_rgba_collapse(HGNode *this)
{
  HgcColorGamma_v210_yxzx_rgba_collapse::~HgcColorGamma_v210_yxzx_rgba_collapse(this);

  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_v210_yxzx_rgba_collapse::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_v210_yxzx_rgba_collapse::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  HIDWORD(v5) = -1431655765 * a4 + 715827882;
  LODWORD(v5) = HIDWORD(v5);
  if ((v5 >> 1) < 0x2AAAAAAB)
  {
    unsigned int v7 = a4;
  }
  else
  {
    float v6 = (double)(int)a4 / 6.0;
    unsigned int v7 = (int)(float)(floorf(v6) * 6.0);
  }
  return a4 & 0xFFFFFFFF00000000 | v7;
}

void HGCColorGamma_v216_yxzx_collapse::~HGCColorGamma_v216_yxzx_collapse(HGNode *this)
{
  HgcColorGamma_v216_yxzx_collapse::~HgcColorGamma_v216_yxzx_collapse(this);

  HGObject::operator delete(v1);
}

uint64_t HGCColorGamma_v216_yxzx_collapse::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

unint64_t HGCColorGamma_v216_yxzx_collapse::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4 & 0xFFFFFFFFFFFFFFFELL;
  }
}

void HGGamma::HGGamma(HGGamma *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10D34D8;
  *(void *)(v1 + 408) = 0;
  *(unsigned char *)(v1 + 420) = 1;
  if (*(float *)(v1 + 416) != 1.0) {
    *(_DWORD *)(v1 + 416) = 1065353216;
  }
}

void HGGamma::~HGGamma(HGNode *this)
{
  *(void *)this = &unk_1F10D34D8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D34D8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGGamma::SetPremultiplyState(uint64_t this, char a2)
{
  *(unsigned char *)(this + 420) = a2;
  return this;
}

uint64_t HGGamma::SetParameter(HGGamma *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  float v7 = fabsf(a3);
  if (*((float *)this + 104) == v7) {
    return 0;
  }
  *((float *)this + 104) = v7;
  return 1;
}

HGNode *HGGamma::GetOutput(HGGamma *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  if (vabds_f32(1.0, *((float *)this + 104)) >= 0.001)
  {
    int v4 = *((unsigned __int8 *)this + 420);
    unint64_t v5 = (HgcGamma *)HGObject::operator new(0x1D0uLL);
    *(_OWORD *)unint64_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *((_OWORD *)v5 + 2) = 0u;
    *((_OWORD *)v5 + 3) = 0u;
    *((_OWORD *)v5 + 4) = 0u;
    *((_OWORD *)v5 + 5) = 0u;
    *((_OWORD *)v5 + 6) = 0u;
    *((_OWORD *)v5 + 7) = 0u;
    *((_OWORD *)v5 + 8) = 0u;
    *((_OWORD *)v5 + 9) = 0u;
    *((_OWORD *)v5 + 10) = 0u;
    *((_OWORD *)v5 + 11) = 0u;
    *((_OWORD *)v5 + 12) = 0u;
    *((_OWORD *)v5 + 13) = 0u;
    *((_OWORD *)v5 + 14) = 0u;
    *((_OWORD *)v5 + 15) = 0u;
    *((_OWORD *)v5 + 16) = 0u;
    *((_OWORD *)v5 + 17) = 0u;
    *((_OWORD *)v5 + 18) = 0u;
    *((_OWORD *)v5 + 19) = 0u;
    *((_OWORD *)v5 + 20) = 0u;
    *((_OWORD *)v5 + 21) = 0u;
    *((_OWORD *)v5 + 22) = 0u;
    *((_OWORD *)v5 + 23) = 0u;
    *((_OWORD *)v5 + 24) = 0u;
    *((_OWORD *)v5 + 25) = 0u;
    *((_OWORD *)v5 + 26) = 0u;
    *((_OWORD *)v5 + 27) = 0u;
    *((_OWORD *)v5 + 28) = 0u;
    if (v4) {
      HgcGamma::HgcGamma(v5);
    }
    HgcGammaNoPremult::HgcGammaNoPremult(v5);
  }
  return Input;
}

void sub_1B7759680(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void HGGammaMC::HGGammaMC(HGGammaMC *this)
{
  HGNode::HGNode((HGNode *)this);
  v1->i64[0] = (uint64_t)&unk_1F10D3758;
  v1[25].i64[1] = 0;
  __asm { FMOV            V0.4S, #1.0 }
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v1[26], _Q0)))) & 1) != 0
    || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v1[27], (float32x4_t)xmmword_1B7E734D0)))) & 1) != 0)
  {
    v1[26] = _Q0;
    v1[27] = (float32x4_t)xmmword_1B7E734D0;
  }
}

void HGGammaMC::~HGGammaMC(HGNode *this)
{
  *(void *)this = &unk_1F10D3758;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D3758;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGGammaMC::SetParameter(float32x4_t *this, int a2, float32x2_t a3, float32_t a4, float a5, float a6)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  a3.f32[1] = a4;
  *(float32x2_t *)v7.f32 = vabs_f32(a3);
  float v8 = fabsf(a5);
  __asm { FMOV            V1.2S, #1.0 }
  *(float32x2_t *)v14.f32 = vsub_f32(_D1, *(float32x2_t *)v7.f32);
  float v15 = 1.0 - v8;
  v16.i64[0] = v7.i64[0];
  v16.i64[1] = __PAIR64__(1.0, LODWORD(v8));
  if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(this[26], v16))), 0xFuLL))) & 1) == 0)
  {
    v17.i64[0] = v14.i64[0];
    v17.i64[1] = __PAIR64__(1.0, LODWORD(v15));
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(this[27], v17))), 0xFuLL))) & 1) == 0)return 0; {
  }
    }
  v7.i64[1] = __PAIR64__(1.0, LODWORD(v8));
  v14.i64[1] = __PAIR64__(1.0, LODWORD(v15));
  this[26] = v7;
  this[27] = v14;
  return 1;
}

HGNode *HGGammaMC::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  Input = HGRenderer::GetInput(a2, this, 0);
  if (*((float *)this + 104) != 1.0 || *((float *)this + 105) != 1.0 || *((float *)this + 106) != 1.0)
  {
    float v6 = (HgcGamma *)HGObject::operator new(0x1D0uLL);
    *(_OWORD *)float v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 8) = 0u;
    *((_OWORD *)v6 + 9) = 0u;
    *((_OWORD *)v6 + 10) = 0u;
    *((_OWORD *)v6 + 11) = 0u;
    *((_OWORD *)v6 + 12) = 0u;
    *((_OWORD *)v6 + 13) = 0u;
    *((_OWORD *)v6 + 14) = 0u;
    *((_OWORD *)v6 + 15) = 0u;
    *((_OWORD *)v6 + 16) = 0u;
    *((_OWORD *)v6 + 17) = 0u;
    *((_OWORD *)v6 + 18) = 0u;
    *((_OWORD *)v6 + 19) = 0u;
    *((_OWORD *)v6 + 20) = 0u;
    *((_OWORD *)v6 + 21) = 0u;
    *((_OWORD *)v6 + 22) = 0u;
    *((_OWORD *)v6 + 23) = 0u;
    *((_OWORD *)v6 + 24) = 0u;
    *((_OWORD *)v6 + 25) = 0u;
    *((_OWORD *)v6 + 26) = 0u;
    *((_OWORD *)v6 + 27) = 0u;
    *((_OWORD *)v6 + 28) = 0u;
    HgcGamma::HgcGamma(v6);
  }
  return Input;
}

void sub_1B7759C24(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void anonymous namespace'::Gamma<HgcGamma>::~Gamma(HGNode *this)
{
  *(void *)this = &unk_1F10D39D8;
  if (*((char *)this + 463) < 0)
  {
    operator delete(*((void **)this + 55));
    if ((*((char *)this + 439) & 0x80000000) == 0)
    {
LABEL_3:
      uint64_t v2 = this;
      goto LABEL_5;
    }
  }
  else if ((*((char *)this + 439) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*((void **)this + 52));
  uint64_t v2 = this;

LABEL_5:
  HgcGamma::~HgcGamma(v2);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10D39D8;
  if (*((char *)this + 463) < 0)
  {
    operator delete(*((void **)this + 55));
    if ((*((char *)this + 439) & 0x80000000) == 0)
    {
LABEL_3:
      HgcGamma::~HgcGamma(this);
      goto LABEL_5;
    }
  }
  else if ((*((char *)this + 439) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*((void **)this + 52));
  HgcGamma::~HgcGamma(this);

LABEL_5:
  HGObject::operator delete(v2);
}

uint64_t anonymous namespace'::Gamma<HgcGamma>::label_A(uint64_t a1)
{
  uint64_t result = a1 + 416;
  if (*(char *)(a1 + 439) < 0) {
    return *(void *)result;
  }
  return result;
}

void anonymous namespace'::Gamma<HgcGammaNoPremult>::~Gamma(HGNode *this)
{
  *(void *)this = &unk_1F10D3C28;
  if (*((char *)this + 463) < 0)
  {
    operator delete(*((void **)this + 55));
    if ((*((char *)this + 439) & 0x80000000) == 0)
    {
LABEL_3:
      uint64_t v2 = this;
      goto LABEL_5;
    }
  }
  else if ((*((char *)this + 439) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*((void **)this + 52));
  uint64_t v2 = this;

LABEL_5:
  HgcGammaNoPremult::~HgcGammaNoPremult(v2);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10D3C28;
  if (*((char *)this + 463) < 0)
  {
    operator delete(*((void **)this + 55));
    if ((*((char *)this + 439) & 0x80000000) == 0)
    {
LABEL_3:
      HgcGammaNoPremult::~HgcGammaNoPremult(this);
      goto LABEL_5;
    }
  }
  else if ((*((char *)this + 439) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*((void **)this + 52));
  HgcGammaNoPremult::~HgcGammaNoPremult(this);

LABEL_5:
  HGObject::operator delete(v2);
}

uint64_t anonymous namespace'::Gamma<HgcGammaNoPremult>::label_A(uint64_t a1)
{
  uint64_t result = a1 + 416;
  if (*(char *)(a1 + 439) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t DepthBufferManager::init(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = a2;
  return result;
}

void DepthBufferManager::~DepthBufferManager(DepthBufferManager *this)
{
  *(void *)this = &unk_1F10D3E78;
  for (unint64_t i = (void *)*((void *)this + 2); i != *((void **)this + 3); unint64_t i = (void *)*((void *)this + 2))
    (*(void (**)(DepthBufferManager *))(*(void *)this + 32))(this);
  *((void *)this + 1) = 0;
  if (i)
  {
    *((void *)this + 3) = i;
    operator delete(i);
  }
}

BOOL DepthBufferManager::hasDepthBuffer(DepthBufferManager *this)
{
  return *((void *)this + 2) != *((void *)this + 3);
}

uint64_t DepthBufferManager::getDepthBuffer(DepthBufferManager *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (*((void *)this + 2) == v1) {
    return 0;
  }
  else {
    return *(void *)(v1 - 8);
  }
}

void *DepthBufferManager::uninit(void *this)
{
  for (unint64_t i = this; i[2] != i[3]; this = (void *)(*(uint64_t (**)(void *))(*i + 32))(i))
    ;
  i[1] = 0;
  return this;
}

void DepthBufferManager::push(DepthBufferManager *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6) {
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"dbm : PUSH\n", a4, a5);
  }
  uint64_t v8 = (char *)*((void *)this + 3);
  unint64_t v7 = *((void *)this + 4);
  if ((unint64_t)v8 < v7)
  {
    *(void *)uint64_t v8 = 0;
    uint64_t v9 = (uint64_t)(v8 + 8);
    goto LABEL_25;
  }
  int v10 = (char *)*((void *)this + 2);
  uint64_t v11 = (v8 - v10) >> 3;
  unint64_t v12 = v11 + 1;
  if ((unint64_t)(v11 + 1) >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v13 = v7 - (void)v10;
  if (v13 >> 2 > v12) {
    unint64_t v12 = v13 >> 2;
  }
  if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v14 = v12;
  }
  if (v14)
  {
    if (v14 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    float v15 = (char *)operator new(8 * v14);
    float32x4_t v16 = &v15[8 * v11];
    float32x4_t v17 = &v15[8 * v14];
    *(void *)float32x4_t v16 = 0;
    uint64_t v9 = (uint64_t)(v16 + 8);
    int32x2_t v18 = (char *)(v8 - v10);
    if (v8 == v10) {
      goto LABEL_23;
    }
    goto LABEL_16;
  }
  float v15 = 0;
  float32x4_t v16 = (char *)(8 * v11);
  float32x4_t v17 = 0;
  *(void *)(8 * v11) = 0;
  uint64_t v9 = 8 * v11 + 8;
  int32x2_t v18 = (char *)(v8 - v10);
  if (v8 != v10)
  {
LABEL_16:
    unint64_t v19 = (unint64_t)(v18 - 8);
    if (v19 < 0x58) {
      goto LABEL_30;
    }
    if ((unint64_t)(v10 - v15) < 0x20) {
      goto LABEL_30;
    }
    uint64_t v20 = (v19 >> 3) + 1;
    uint64_t v21 = 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
    int8x16_t v22 = &v8[-v21];
    v16 -= v21;
    int v23 = &v15[8 * v11 - 16];
    double v24 = v8 - 16;
    uint64_t v25 = v20 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v26 = *(_OWORD *)v24;
      *((_OWORD *)v23 - 1) = *((_OWORD *)v24 - 1);
      *(_OWORD *)int v23 = v26;
      v23 -= 32;
      v24 -= 32;
      v25 -= 4;
    }
    while (v25);
    uint64_t v8 = v22;
    if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_30:
      do
      {
        uint64_t v27 = *((void *)v8 - 1);
        v8 -= 8;
        *((void *)v16 - 1) = v27;
        v16 -= 8;
      }
      while (v8 != v10);
    }
    uint64_t v8 = (char *)*((void *)this + 2);
  }
LABEL_23:
  *((void *)this + 2) = v16;
  *((void *)this + 3) = v9;
  *((void *)this + 4) = v17;
  if (v8) {
    operator delete(v8);
  }
LABEL_25:
  *((void *)this + 3) = v9;
}

void DepthBufferManager::pop(DepthBufferManager *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6) {
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"dbm : POP\n", a4, a5);
  }
  uint64_t v8 = *((void *)this + 2);
  uint64_t v7 = *((void *)this + 3);
  if (v8 == v7)
  {
    *((void *)this + 3) = v8 - 8;
  }
  else
  {
    uint64_t v9 = *(void *)(v7 - 8);
    if (v9)
    {
      (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
      uint64_t v7 = *((void *)this + 3);
    }
    *((void *)this + 3) = v7 - 8;
  }
}

uint64_t DepthBufferManager::enableDepth(DepthBufferManager *this)
{
  return (*(uint64_t (**)(DepthBufferManager *, uint64_t, uint64_t, void, void))(*(void *)this + 64))(this, 1, 1, 0, 0);
}

void DBM_gl::DBM_gl(DBM_gl *this, HGRenderer *a2)
{
  *((unsigned char *)this + 40) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1F10D3ED8;
  *((void *)this + 10) = 0;
  *((void *)this + 9) = (char *)this + 80;
  *((void *)this + 11) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 24) = -1;
  *((void *)this + 13) = 0;
  uint64_t v4 = HGRectMake4i(0, 0, 1u, 1u);
  uint64_t v6 = (*(uint64_t (**)(HGRenderer *, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 136))(a2, v4, v5, 28);
  (*(void (**)(void, uint64_t))(**((void **)this + 1) + 144))(*((void *)this + 1), v6);
  (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  DBM_gl::_initOneDepthFormat(this, 6402);
  *((_DWORD *)this + 24) = 6402;
  glFlush();
  (*(void (**)(void, void))(**((void **)this + 1) + 144))(*((void *)this + 1), 0);
}

void sub_1B775A44C(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v2, *((void **)v1 + 10));
  DepthBufferManager::~DepthBufferManager(v1);
  _Unwind_Resume(a1);
}

void DBM_gl::~DBM_gl(DBM_gl *this)
{
  *(void *)this = &unk_1F10D3ED8;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 72, *((void **)this + 10));
  for (*(void *)this = &unk_1F10D3E78; ; (*(void (**)(DBM_gl *))(*(void *)this + 32))(this))
  {
    uint64_t v2 = (void *)*((void *)this + 2);
    if (v2 == *((void **)this + 3)) {
      break;
    }
  }
  *((void *)this + 1) = 0;
  if (v2)
  {
    *((void *)this + 3) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10D3ED8;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 72, *((void **)this + 10));
  for (*(void *)this = &unk_1F10D3E78; ; (*(void (**)(DBM_gl *))(*(void *)this + 32))(this))
  {
    uint64_t v2 = (void *)*((void *)this + 2);
    if (v2 == *((void **)this + 3)) {
      break;
    }
  }
  *((void *)this + 1) = 0;
  if (v2)
  {
    *((void *)this + 3) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

HGGPURenderer *DBM_gl::uninit(HGGPURenderer **this)
{
  if (this[13])
  {
    HGGPURenderer::GetCurrentContext(this[1], (uint64_t *)&v7);
    HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v8, &v7.var0);
    HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v8);
    PCSharedCount::PCSharedCount(&v7);
    GLuint v2 = *((_DWORD *)this + 26);
    GLuint shaders = 0;
    glGetAttachedShaders(v2, 1, 0, &shaders);
    glDeleteShader(shaders);
    glDeleteProgram(v2);
    this[13] = 0;
  }
  char v3 = this[6];
  if (v3)
  {
    (*(void (**)(HGGPURenderer *))(*(void *)v3 + 24))(v3);
    this[6] = 0;
  }
  uint64_t v4 = this[7];
  if (v4)
  {
    (*(void (**)(HGGPURenderer *))(*(void *)v4 + 24))(v4);
    this[7] = 0;
  }
  uint64_t result = this[8];
  if (result)
  {
    uint64_t result = (HGGPURenderer *)(*(uint64_t (**)(HGGPURenderer *))(*(void *)result + 24))(result);
    this[8] = 0;
  }
  while (this[2] != this[3])
    uint64_t result = (HGGPURenderer *)(*((uint64_t (**)(HGGPURenderer **))*this + 4))(this);
  this[1] = 0;
  return result;
}

void sub_1B775A744(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

uint64_t DBM_gl::enableDepth(DBM_gl *this)
{
  return (*(uint64_t (**)(DBM_gl *, uint64_t, uint64_t, void, void))(*(void *)this + 64))(this, 1, 1, 0, 0);
}

void DBM_gl::enableDepth(DBM_gl *this, int a2, int flag, const char *a4, char *a5)
{
  int v5 = (int)a5;
  GLenum v6 = a4;
  unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
  if (v10) {
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"depth enabled\n", a4, a5);
  }
  if (a2)
  {
    glDepthMask(flag);
    glEnable(0xB71u);
    if (v6) {
      GLenum v11 = v6;
    }
    else {
      GLenum v11 = 513;
    }
    glDepthFunc(v11);
  }
  else if (flag)
  {
    unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
    if (v12) {
      HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"\n *** DBM ERROR : can't write depth with depth test off.\n\n", a4, a5);
    }
  }
  if (*((unsigned char *)this + 112) || v5)
  {
    unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
    if (v13) {
      HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"depth cleared\n", a4, a5);
    }
    glClearDepthf(1.0);
    glClear(0x100u);
    *((unsigned char *)this + 112) = 0;
  }
}

void DBM_gl::disableDepth(DBM_gl *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
  if (v5) {
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"depth disabled\n", a4, a5);
  }
  glDepthMask(0);

  glDisable(0xB71u);
}

void *DBM_gl::_reinitDepth(void *this)
{
  if (this[6])
  {
    uint64_t v1 = this;
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, void))(*this + 64))(this, 1, 1, 519, 0);
    uint64_t v2 = v1[13];
    if (!v2)
    {
      GLuint Program = glCreateProgram();
      GLuint Shader = glCreateShader(0x8B30u);
      GLint length = strlen(DBM_gl::_reinitDepth(void)::shaderStr);
      glShaderSource(Shader, 1, (const GLchar *const *)&DBM_gl::_reinitDepth(void)::shaderStr, &length);
      glCompileShader(Shader);
      glAttachShader(Program, Shader);
      glBindAttribLocation(Program, 0, "hg_TexCoord0");
      glLinkProgram(Program);
      LODWORD(v2) = Program;
      v1[13] = Program;
    }
    glUseProgram(v2);
    uint64_t v5 = HGRectIntersection(*(void *)(*(void *)(v1[3] - 8) + 20), *(void *)(*(void *)(v1[3] - 8) + 28), *(void *)(v1[6] + 20), *(void *)(v1[6] + 28));
    uint64_t v7 = v6;
    uint64_t v8 = *(unsigned int *)(v1[6] + 168);
    uint64_t v9 = *(unsigned int *)(*(void *)(v1[3] - 8) + 156);
    (*(void (**)(void, void))(*(void *)v1[1] + 152))(v1[1], 0);
    *(void *)&v16.int var0 = v5;
    *(void *)&v16.unsigned int var2 = v7;
    HGGPURenderer::Rect((HGGPURenderer *)v1[1], v16);
    (*(void (**)(void, void, void, void, void))(*(void *)v1[1] + 152))(v1[1], 0, 0, 0, 0);
    glUseProgram(0);
    if ((_MergedGlobals_7 & 1) == 0)
    {
      for (GLenum i = glGetError(); i; GLenum i = glGetError())
      {
        unsigned __int8 v13 = HGGLGetErrorString(i);
        printf("glGetError : %s\n", v13);
      }
    }
    unsigned __int8 v14 = atomic_load(HGLogger::_enabled);
    if (v14) {
      HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"** copying depth texture %d into depth buffer %d\n", v10, v11, v8, v9);
    }
    return (void *)(*(uint64_t (**)(void *))(*v1 + 72))(v1);
  }
  return this;
}

void DBM_gl::_bind(DBM_gl *this, HGNode *a2, HGRect a3, int a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 2) == *((void *)this + 3)) {
    return;
  }
  uint64_t v4 = *(void *)&a3.var2;
  uint64_t v5 = *(void *)&a3.var0;
  *((unsigned char *)this + 112) = 1;
  snprintf(__str, 0x64uLL, "DBM_gl::bind( rect : %d %d %d %d)", a3.var0, a3.var1, a3.var2, a3.var3);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v55, "gpu", 1, __str);
  uint64_t v9 = *(void *)(*((void *)this + 1) + 24);
  unint64_t v10 = *(void *)(v9 + 136);
  unint64_t v11 = *(void *)(v9 + 144);
  uint64_t v12 = *((void *)this + 3);
  uint64_t v13 = *(void *)(v12 - 8);
  if (!v13) {
    goto LABEL_32;
  }
  unint64_t v14 = *(void *)(v13 + 136);
  unint64_t v15 = *(void *)(v13 + 144);
  unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
  if (v16) {
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"************ already has depth buffer, let's check \n", v7, v8);
  }
  unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
  if (v17) {
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)" current depth buffer rect : %d %d %d %d\n", v7, v8, v14, HIDWORD(v14), v15, HIDWORD(v15));
  }
  unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
  if (v18) {
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)" requested rect : %d %d %d %d\n", v7, v8, v10, HIDWORD(v10), v11, HIDWORD(v11));
  }
  if (!HGRectIsEqual(v14, v15, v10, v11))
  {
    if (HGRectContainsRect(v14, v15, v10, v11))
    {
      unsigned __int8 v25 = atomic_load(HGLogger::_enabled);
      if (v25) {
        HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"too big!, we'll need a sub-buffer to render into! \n", v23, v24);
      }
      uint64_t v26 = *((void *)this + 3);
      if (*((void *)this + 2) == v26) {
        uint64_t v27 = 0;
      }
      else {
        uint64_t v27 = *(void *)(v26 - 8);
      }
      *((void *)this + 7) = v27;
      (*(void (**)(uint64_t))(*(void *)v27 + 16))(v27);
    }
    else if (HGRectContainsRect(v10, v11, v14, v15))
    {
      unsigned __int8 v31 = atomic_load(HGLogger::_enabled);
      if (v31) {
        HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"nope, too bad\n", v29, v30);
      }
      *((unsigned char *)this + 112) = 1;
      uint64_t v32 = *((void *)this + 3);
      if (*((void *)this + 2) == v32 || (uint64_t v33 = *(HGBitmap **)(v32 - 8)) == 0)
      {
        unsigned __int8 v52 = atomic_load(HGLogger::_enabled);
        if (v52) {
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"no depth, but need one! use a small \"deep\" texture\n", v29, v30);
        }
        int8x16_t v34 = DBM_gl::nullTexture(this);
        (*(void (**)(void *))(*(void *)v34 + 16))(v34);
      }
      else
      {
        int8x16_t v34 = HGGLTexture::CreateTexture(*(HGGLTexture **)(v32 - 8), *((HGGLBuffer **)this + 1), v28);
        HGGPURenderer::AddTextureUsage(*((HGGPURenderer **)this + 1), v33);
      }
      *((void *)this + 6) = v34;
      uint64_t v35 = *(void *)(v12 - 8);
      if (!v35) {
        goto LABEL_32;
      }
LABEL_31:
      (*(void (**)(uint64_t))(*(void *)v35 + 24))(v35);
      *(void *)(v12 - 8) = 0;
      goto LABEL_32;
    }
    uint64_t v35 = *(void *)(v12 - 8);
    if (!v35) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  unsigned __int8 v21 = atomic_load(HGLogger::_enabled);
  if (v21) {
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"same size, perfect!!\n", v19, v20);
  }
  *((unsigned char *)this + 112) = 0;
  uint64_t v22 = *(void *)(v12 - 8);
  if (qword_1EB9A19F8 == v22)
  {
    *((unsigned char *)this + 112) = 1;
    qword_1EB9A19F8 = 0;
    if (v22) {
      goto LABEL_33;
    }
  }
  else if (v22)
  {
    goto LABEL_33;
  }
LABEL_32:
  GLuint texture = 0;
  HGGPURenderer::GenRectTexture(*((HGTextureManager ***)this + 1), (char *)&texture, (char *)0xDE1, v11 - v10, HIDWORD(v11) - HIDWORD(v10), *((_DWORD *)this + 24), 6402, 5125, 0);
  glBindTexture(0xDE1u, texture);
  glTexParameteri(0xDE1u, 0x2802u, 33071);
  glTexParameteri(0xDE1u, 0x2803u, 33071);
  glTexParameteri(0xDE1u, 0x2800u, 9728);
  glTexParameteri(0xDE1u, 0x2801u, 9728);
  glTexImage2D(0xDE1u, 0, *((_DWORD *)this + 24), v11 - v10, HIDWORD(v11) - HIDWORD(v10), 0, 0x1902u, 0x1405u, 0);
  double v36 = HGObject::operator new(0xB8uLL);
  HGGLBuffer::HGGLBuffer((uint64_t)v36, v10, v11, 7, *((void *)this + 1));
  GLuint v37 = texture;
  v36[39] = texture;
  v36[40] = v37;
  v36[38] = 3553;
  *((void *)v36 + 17) = v5;
  *((void *)v36 + 18) = v4;
  *((unsigned char *)v36 + 180) = 0;
  *(void *)(v12 - 8) = v36;
  glBindTexture(0xDE1u, 0);
  uint64_t v22 = *(void *)(v12 - 8);
  if (!v22) {
    goto LABEL_42;
  }
LABEL_33:
  if (!a4)
  {
LABEL_42:
    if (v22)
    {
      uint64_t v46 = *(unsigned int *)(v22 + 156);
      unsigned __int8 v47 = atomic_load(HGLogger::_enabled);
      if (v47) {
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"created (not bound) depth with ID %d\n", v19, v20, v46);
      }
      qword_1EB9A19F8 = *(void *)(v12 - 8);
    }
    goto LABEL_46;
  }
  uint64_t v38 = *(unsigned int *)(v22 + 156);
  glFramebufferTexture2D(0x8D40u, 0x8D00u, 0xDE1u, *(_DWORD *)(v22 + 156), 0);
  unsigned __int8 v41 = atomic_load(HGLogger::_enabled);
  if (v41) {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"Drawing into depth with ID %d\n", v39, v40, v38);
  }
  if ((_MergedGlobals_7 & 1) == 0)
  {
    GLenum v42 = glCheckFramebufferStatus(0x8D40u);
    if (v42 != 36053)
    {
      double v43 = HGGLGetFramebufferStatusString(v42);
      printf("glCheckFBOStatus : %s\n", v43);
    }
    if ((_MergedGlobals_7 & 1) == 0)
    {
      while (1)
      {
        GLenum Error = glGetError();
        if (!Error) {
          break;
        }
        double v45 = HGGLGetErrorString(Error);
        printf("glGetError : %s\n", v45);
      }
    }
  }
LABEL_46:
  GLuint texture = 0;
  glGetIntegerv(0xD56u, (GLint *)&texture);
  unsigned __int8 v50 = atomic_load(HGLogger::_enabled);
  if (v50) {
    HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"fbo depth size : %d \t tex depth size : %d\n", v48, v49, texture, 0xFFFFFFFFLL);
  }
  DBM_gl::_reinitDepth(this);
  uint64_t v51 = *((void *)this + 6);
  if (v51) {
    (*(void (**)(uint64_t))(*(void *)v51 + 24))(v51);
  }
  *((void *)this + 6) = 0;
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v55);
}

void sub_1B775B128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775B13C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775B150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775B164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775B178(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  HGObject::operator delete(v14);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a14);
  _Unwind_Resume(a1);
}

void sub_1B775B198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775B1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775B1C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775B1D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775B1E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void DBM_gl::preBind(DBM_gl *this, HGRect a2)
{
  uint64_t v2 = *(void *)&a2.var2;
  *(void *)&a2.unsigned int var2 = *(void *)&a2.var0;
  DBM_gl::_bind(this, *(HGNode **)&a2.var0, *(HGRect *)&a2.var2, 0);
}

void DBM_gl::bind(DBM_gl *this, HGNode *a2, HGRect a3)
{
}

uint64_t DBM_gl::unbind(DBM_gl *this)
{
  glFramebufferTexture2D(0x8D40u, 0x8D00u, 0xDE1u, 0, 0);
  unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
  if (v5) {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"unbinding depth\n", v3, v4);
  }
  uint64_t result = *((void *)this + 6);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
  }
  *((void *)this + 6) = 0;
  if (*((void *)this + 7))
  {
    uint64_t v7 = *((void *)this + 3);
    if (*((void *)this + 2) == v7 || (uint64_t v8 = *(HGBitmap **)(v7 - 8)) == 0)
    {
      unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
      if (v10) {
        HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"no depth, but need one! use a small \"deep\" texture\n", v3, v4);
      }
      Texture = DBM_gl::nullTexture(this);
      (*(void (**)(void *))(*(void *)Texture + 16))(Texture);
    }
    else
    {
      Texture = HGGLTexture::CreateTexture(*(HGGLTexture **)(v7 - 8), *((HGGLBuffer **)this + 1), v2);
      HGGPURenderer::AddTextureUsage(*((HGGPURenderer **)this + 1), v8);
    }
    *((void *)this + 6) = Texture;
    (*(void (**)(void))(**(void **)(v7 - 8) + 24))(*(void *)(v7 - 8));
    uint64_t v11 = *((void *)this + 7);
    *(void *)(v7 - 8) = v11;
    (*(void (**)(uint64_t))(*(void *)v11 + 16))(v11);
    uint64_t v12 = *((void *)this + 7);
    uint64_t v13 = *(unsigned int *)(*((void *)this + 6) + 168);
    uint64_t v14 = *(unsigned int *)(v12 + 156);
    unint64_t v15 = (void *)*((void *)this + 1);
    uint64_t v16 = v15[3];
    uint64_t v17 = (*(uint64_t (**)(void *, void, void, uint64_t))(*v15 + 136))(v15, *(void *)(v12 + 20), *(void *)(v12 + 28), 24);
    (*(void (**)(void, uint64_t))(**((void **)this + 1) + 144))(*((void *)this + 1), v17);
    glFramebufferTexture2D(0x8D40u, 0x8D00u, 0xDE1u, v14, 0);
    if ((_MergedGlobals_7 & 1) == 0)
    {
      GLenum v18 = glCheckFramebufferStatus(0x8D40u);
      if (v18 != 36053)
      {
        unint64_t v19 = HGGLGetFramebufferStatusString(v18);
        printf("glCheckFBOStatus : %s\n", v19);
      }
      if ((_MergedGlobals_7 & 1) == 0)
      {
        for (GLenum i = glGetError(); i; GLenum i = glGetError())
        {
          unsigned __int8 v21 = HGGLGetErrorString(i);
          printf("glGetError : %s\n", v21);
        }
      }
    }
    DBM_gl::_reinitDepth(this);
    glFramebufferTexture2D(0x8D40u, 0x8D00u, 0xDE1u, v14, 0);
    (*(void (**)(void, uint64_t))(**((void **)this + 1) + 144))(*((void *)this + 1), v16);
    (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
    unsigned __int8 v24 = atomic_load(HGLogger::_enabled);
    if (v24) {
      HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"** copying page depth texture %d into full-buffered depth buffer %d\n", v22, v23, v13, v14);
    }
    (*(void (**)(void))(**((void **)this + 7) + 24))(*((void *)this + 7));
    *((void *)this + 7) = 0;
    uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 6) + 24))(*((void *)this + 6));
    *((void *)this + 6) = 0;
  }
  return result;
}

void *DBM_gl::nullTexture(DBM_gl *this)
{
  if (*((void *)this + 8)) {
    return (void *)*((void *)this + 8);
  }
  GLuint texture = 0;
  HGGPURenderer::GenRectTexture(*((HGTextureManager ***)this + 1), (char *)&texture, (char *)0xDE1, 1, 1, *((_DWORD *)this + 24), 6402, 5125, 0);
  glBindTexture(0xDE1u, texture);
  glTexParameteri(0xDE1u, 0x2802u, 33071);
  glTexParameteri(0xDE1u, 0x2803u, 33071);
  glTexParameteri(0xDE1u, 0x2800u, 9728);
  glTexParameteri(0xDE1u, 0x2801u, 9728);
  glTexImage2D(0xDE1u, 0, *((_DWORD *)this + 24), 1, 1, 0, 0x1902u, 0x1405u, &DBM_gl::nullTexture(void)::deep_pixel);
  uint64_t v3 = HGRectMake4i(0, 0, 1u, 1u);
  uint64_t v5 = v4;
  uint64_t v6 = HGObject::operator new(0xC8uLL);
  HGGLTexture::HGGLTexture((uint64_t)v6, v3, v5, 7, *((void *)this + 1), 3553, texture != 0);
  *((void *)this + 8) = v6;
  return v6;
}

void sub_1B775B6D4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t DBM_gl::_initOneDepthFormat(DBM_gl *this, int a2)
{
  *((_DWORD *)this + 24) = a2;
  HGGPURenderer::GetCurrentContext(*((HGGPURenderer **)this + 1), (uint64_t *)&v17);
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v18, &v17.var0);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v18);
  PCSharedCount::PCSharedCount(&v17);
  _MergedGlobals_7 = 1;
  (*(void (**)(DBM_gl *))(*(void *)this + 24))(this);
  uint64_t v4 = HGRectMake4i(0, 0, 1u, 1u);
  (*(void (**)(DBM_gl *, void, uint64_t, uint64_t))(*(void *)this + 40))(this, 0, v4, v5);
  GLenum v6 = glCheckFramebufferStatus(0x8D40u);
  GLint params = -1;
  glGetIntegerv(0xD56u, &params);
  (*(void (**)(DBM_gl *))(*(void *)this + 48))(this);
  _MergedGlobals_7 = 0;
  if (v6 == 36053)
  {
    GLint v7 = params;
    if (params >= 1)
    {
      uint64_t v9 = (uint64_t **)((char *)this + 80);
      uint64_t v8 = (uint64_t *)*((void *)this + 10);
      if (v8)
      {
        do
        {
          while (1)
          {
            unsigned __int8 v10 = (uint64_t **)v8;
            int v11 = *((_DWORD *)v8 + 7);
            if (v11 <= a2) {
              break;
            }
            uint64_t v8 = *v10;
            uint64_t v9 = v10;
            if (!*v10) {
              goto LABEL_11;
            }
          }
          if (v11 >= a2)
          {
            uint64_t v14 = v10;
            goto LABEL_14;
          }
          uint64_t v8 = v10[1];
        }
        while (v8);
        uint64_t v9 = v10 + 1;
      }
      else
      {
        unsigned __int8 v10 = (uint64_t **)((char *)this + 80);
      }
LABEL_11:
      uint64_t v14 = operator new(0x28uLL);
      v14[7] = a2;
      v14[8] = 0;
      *(void *)uint64_t v14 = 0;
      *((void *)v14 + 1) = 0;
      *((void *)v14 + 2) = v10;
      *uint64_t v9 = (uint64_t *)v14;
      uint64_t v12 = **((void **)this + 9);
      uint64_t v13 = (uint64_t *)v14;
      if (v12)
      {
        *((void *)this + 9) = v12;
        uint64_t v13 = *v9;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 10), v13);
      ++*((void *)this + 11);
LABEL_14:
      v14[8] = v7;
    }
  }
  return (*(uint64_t (**)(DBM_gl *))(*(void *)this + 32))(this);
}

void sub_1B775B8F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  (*(void (**)(uint64_t))(*(void *)v10 + 32))(v10);
  _Unwind_Resume(a1);
}

uint64_t DBM_cpu::DBM_cpu(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F10D3F40;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 44) = HGRectMake4i(0, 0, 0, 0);
  *(void *)(a1 + 52) = v3;
  return a1;
}

void sub_1B775B9B8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v2;
  uint64_t v5 = *v3;
  if (*v3)
  {
    v1[10] = v5;
    operator delete(v5);
  }
  for (void *v1 = &unk_1F10D3E78; ; (*(void (**)(void *))(*v1 + 32))(v1))
  {
    GLenum v6 = (void *)v1[2];
    if (v6 == (void *)v1[3]) {
      break;
    }
  }
  v1[1] = 0;
  if (v6)
  {
    v1[3] = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

void DBM_cpu::~DBM_cpu(DBM_cpu *this)
{
  *(void *)this = &unk_1F10D3F40;
  uint64_t v2 = (void *)*((void *)this + 9);
  if (v2)
  {
    *((void *)this + 10) = v2;
    operator delete(v2);
  }
  for (*(void *)this = &unk_1F10D3E78; ; (*(void (**)(DBM_cpu *))(*(void *)this + 32))(this))
  {
    uint64_t v3 = (void *)*((void *)this + 2);
    if (v3 == *((void **)this + 3)) {
      break;
    }
  }
  *((void *)this + 1) = 0;
  if (v3)
  {
    *((void *)this + 3) = v3;
    operator delete(v3);
  }
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D3F40;
  uint64_t v2 = (void *)*((void *)this + 9);
  if (v2)
  {
    *((void *)this + 10) = v2;
    operator delete(v2);
  }
  for (*(void *)this = &unk_1F10D3E78; ; (*(void (**)(DBM_cpu *))(*(void *)this + 32))(this))
  {
    uint64_t v3 = (void *)*((void *)this + 2);
    if (v3 == *((void **)this + 3)) {
      break;
    }
  }
  *((void *)this + 1) = 0;
  if (v3)
  {
    *((void *)this + 3) = v3;
    operator delete(v3);
  }

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t DBM_cpu::push(DBM_cpu *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  DepthBufferManager::push(this, a2, a3, a4, a5);
  GLint v7 = (char *)*((void *)this + 10);
  unint64_t v6 = *((void *)this + 11);
  uint64_t v8 = v7;
  if ((unint64_t)v7 < v6)
  {
    *(void *)GLint v7 = 0;
    uint64_t v9 = (uint64_t)(v7 + 8);
    goto LABEL_23;
  }
  uint64_t v10 = (char *)*((void *)this + 9);
  uint64_t v11 = (v7 - v10) >> 3;
  unint64_t v12 = v11 + 1;
  if ((unint64_t)(v11 + 1) >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v13 = v6 - (void)v10;
  if (v13 >> 2 > v12) {
    unint64_t v12 = v13 >> 2;
  }
  if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v14 = v12;
  }
  if (v14)
  {
    if (v14 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unint64_t v15 = (char *)operator new(8 * v14);
    uint64_t v16 = &v15[8 * v11];
    PCSharedCount v17 = &v15[8 * v14];
    *(void *)uint64_t v16 = 0;
    uint64_t v9 = (uint64_t)(v16 + 8);
    GLenum v18 = (char *)(v7 - v10);
    if (v7 == v10) {
      goto LABEL_21;
    }
    goto LABEL_14;
  }
  unint64_t v15 = 0;
  uint64_t v16 = (char *)(8 * v11);
  PCSharedCount v17 = 0;
  *(void *)(8 * v11) = 0;
  uint64_t v9 = 8 * v11 + 8;
  GLenum v18 = (char *)(v7 - v10);
  if (v7 != v10)
  {
LABEL_14:
    unint64_t v19 = (unint64_t)(v18 - 8);
    if (v19 < 0x58) {
      goto LABEL_28;
    }
    if ((unint64_t)(v10 - v15) < 0x20) {
      goto LABEL_28;
    }
    uint64_t v20 = (v19 >> 3) + 1;
    uint64_t v21 = 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v8 = &v7[-v21];
    v16 -= v21;
    uint64_t v22 = &v15[8 * v11 - 16];
    int v23 = (long long *)(v7 - 16);
    uint64_t v24 = v20 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v25 = *v23;
      *((_OWORD *)v22 - 1) = *(v23 - 1);
      *(_OWORD *)uint64_t v22 = v25;
      v22 -= 32;
      v23 -= 2;
      v24 -= 4;
    }
    while (v24);
    if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_28:
      do
      {
        uint64_t v26 = *((void *)v8 - 1);
        v8 -= 8;
        *((void *)v16 - 1) = v26;
        v16 -= 8;
      }
      while (v8 != v10);
    }
    uint64_t v8 = (char *)*((void *)this + 9);
  }
LABEL_21:
  *((void *)this + 9) = v16;
  *((void *)this + 10) = v9;
  *((void *)this + 11) = v17;
  if (v8) {
    operator delete(v8);
  }
LABEL_23:
  *((void *)this + 10) = v9;
  uint64_t result = HGRectMake4i(0, 0, 0, 0);
  *(void *)((char *)this + 44) = result;
  *(void *)((char *)this + 52) = v28;
  return result;
}

uint64_t DBM_cpu::pop(DBM_cpu *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6) {
    HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"dbm : POP\n", a4, a5);
  }
  uint64_t v7 = *((void *)this + 3);
  if (*((void *)this + 2) == v7)
  {
    uint64_t v7 = *((void *)this + 2);
  }
  else
  {
    uint64_t v8 = *(void *)(v7 - 8);
    if (v8)
    {
      (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
      uint64_t v7 = *((void *)this + 3);
    }
  }
  *((void *)this + 3) = v7 - 8;
  *((void *)this + 10) -= 8;
  uint64_t result = HGRectMake4i(0, 0, 0, 0);
  *(void *)((char *)this + 44) = result;
  *(void *)((char *)this + 52) = v10;
  return result;
}

uint64_t DBM_cpu::bufferHint(uint64_t result, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(result + 80) - 8) = a2;
  }
  return result;
}

void DBM_cpu::bind(DBM_cpu *this, HGNode *a2, HGRect a3)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 2) != *((void *)this + 3))
  {
    uint64_t v3 = *(void *)&a3.var2;
    uint64_t v4 = *(void *)&a3.var0;
    uint64_t var1 = a3.var1;
    uint64_t var3 = a3.var3;
    snprintf(__str, 0x64uLL, "DBM_cpu::bind( rect : %d %d %d %d)", a3.var0, a3.var1, a3.var2, a3.var3);
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v57, "gpu", 1, __str);
    int v10 = v4;
    uint64_t v56 = var1;
    LODWORD(v11) = var1;
    uint64_t v12 = v3;
    uint64_t v13 = v4;
    if (HGRectIsNull(*(void *)((char *)this + 44), *(void *)((char *)this + 52)))
    {
      uint64_t v14 = *((void *)this + 3);
      if (!*(void *)(v14 - 8)) {
        goto LABEL_13;
      }
    }
    else
    {
      unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
      if (v15) {
        HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"current request for : %d %d %d %d\n", v8, v9, *((unsigned int *)this + 11), *((unsigned int *)this + 12), *((unsigned int *)this + 13), *((unsigned int *)this + 14));
      }
      unint64_t v16 = HGRectUnion(v4, v3, *(void *)((char *)this + 44), *(void *)((char *)this + 52));
      int v10 = v16;
      uint64_t v12 = v17;
      unint64_t v11 = HIDWORD(v16);
      uint64_t v13 = v16;
      uint64_t v14 = *((void *)this + 3);
      if (!*(void *)(v14 - 8)) {
        goto LABEL_13;
      }
    }
    unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
    if (v18) {
      HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"************ already has depth buffer... \n", v8, v9);
    }
    BOOL IsEqual = HGRectIsEqual(*(void *)(*(void *)(v14 - 8) + 20), *(void *)(*(void *)(v14 - 8) + 28), v4, v3);
    unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
    if (!IsEqual)
    {
      if (v22) {
        HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"... nope, too bad... creating a new one... \n", v20, v21);
      }
      (*(void (**)(void))(**(void **)(v14 - 8) + 24))(*(void *)(v14 - 8));
      *(void *)(v14 - 8) = 0;
      uint64_t v23 = *(void *)(*((void *)this + 10) - 8);
      if (!v23) {
        goto LABEL_15;
      }
LABEL_14:
      uint64_t v24 = HGRectIntersection(v13, v12, *(void *)(v23 + 20), *(void *)(v23 + 28));
      if (!HGRectIsNull(v24, v25))
      {
        unsigned __int8 v43 = atomic_load(HGLogger::_enabled);
        if (v43) {
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"found pre-allocated buffer %p\n", v26, v27, v23);
        }
        unsigned __int8 v44 = atomic_load(HGLogger::_enabled);
        if (v44) {
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"current tile : %d %d %d %d\n", v26, v27, v4, v56, v3, var3);
        }
        unsigned __int8 v45 = atomic_load(HGLogger::_enabled);
        if (v45) {
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"buffered depth : %d %d %d %d\n", v26, v27, *(unsigned int *)(v23 + 20), *(unsigned int *)(v23 + 24), *(unsigned int *)(v23 + 28), *(unsigned int *)(v23 + 32));
        }
        if (*(void *)(v14 - 8)) {
          goto LABEL_45;
        }
        uint64_t v46 = (HGBitmap *)HGObject::operator new(0x80uLL);
        HGBitmap::HGBitmap(v46, *(void *)(v23 + 20), *(void *)(v23 + 28), *(unsigned int *)(v23 + 16), *(void *)(v23 + 80), *(void *)(v23 + 64));
        uint64_t v28 = (HGBuffer *)HGObject::operator new(0x80uLL);
        *(void *)&v60.int var0 = v13;
        *(void *)&v60.unsigned int var2 = v12;
        HGBuffer::HGBuffer(v28, v60, v46);
        (*(void (**)(HGBitmap *))(*(void *)v46 + 24))(v46);
        *(void *)(v14 - 8) = v28;
        if (HGRectIsNull(*(void *)((char *)this + 44), *(void *)((char *)this + 52)))
        {
          int v42 = 0;
        }
        else
        {
          int v52 = v4 - *((_DWORD *)v28 + 5);
          int v53 = *((_DWORD *)v28 + 14);
          int v42 = (v56 - *((_DWORD *)v28 + 6)) * *((_DWORD *)v28 + 16) + v52 * v53;
          unsigned __int8 v54 = atomic_load(HGLogger::_enabled);
          if (v54) {
            HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"bind : offset : %d\n", v47, v48, ((v56 - *((_DWORD *)v28 + 6)) * *((_DWORD *)v28 + 16) + v52 * v53));
          }
        }
        goto LABEL_44;
      }
LABEL_15:
      if (*(void *)(v14 - 8))
      {
LABEL_45:
        HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v57);
        return;
      }
      uint64_t v28 = (HGBuffer *)HGObject::operator new(0x80uLL);
      HGBuffer::HGBuffer((uint64_t)v28, v13, v12, 28);
      *(void *)(v14 - 8) = v28;
      unsigned __int8 v31 = atomic_load(HGLogger::_enabled);
      if (v31) {
        HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"bind : new buffer : %p\n", v29, v30, v28);
      }
      if (HIDWORD(v12) - (int)v11 >= 1 && (int)v12 - v10 >= 1)
      {
        int v32 = 0;
        __asm { FMOV            V0.4S, #1.0 }
        do
        {
          uint64_t v38 = (_OWORD *)(*((void *)v28 + 10) + v32 * *((_DWORD *)v28 + 16));
          int v39 = v12 - v10;
          do
          {
            *uint64_t v38 = _Q0;
            uint64_t v38 = (_OWORD *)((char *)v38 + *((int *)v28 + 14));
            --v39;
          }
          while (v39);
          ++v32;
        }
        while (v32 != HIDWORD(v12) - v11);
      }
      if (HGRectIsNull(*(void *)((char *)this + 44), *(void *)((char *)this + 52)))
      {
        int v42 = 0;
      }
      else
      {
        int v49 = v4 - v10;
        int v50 = *((_DWORD *)v28 + 14);
        int v42 = (v56 - v11) * *((_DWORD *)v28 + 16) + (v4 - v10) * v50;
        unsigned __int8 v51 = atomic_load(HGLogger::_enabled);
        if (v51) {
          HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"bind : offset : %d\n", v40, v41, ((v56 - v11) * *((_DWORD *)v28 + 16) + v49 * v50));
        }
      }
LABEL_44:
      *((void *)this + 8) = *((void *)v28 + 10) + v42;
      *(void *)((char *)this + 44) = HGRectMake4i(0, 0, 0, 0);
      *(void *)((char *)this + 52) = v55;
      goto LABEL_45;
    }
    if (v22) {
      HGLogger::log((HGLogger *)"depth", (const char *)2, (HGLogger *)"... same rect, yeah!! \n", v20, v21);
    }
LABEL_13:
    uint64_t v23 = *(void *)(*((void *)this + 10) - 8);
    if (!v23) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
}

void sub_1B775C328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775C33C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  HGObject::operator delete(v14);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a14);
  _Unwind_Resume(a1);
}

void sub_1B775C3C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775C3DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775C3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775C408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775C41C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B775C430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t DBM_cpu::setDepthBuffer(DBM_cpu *this, HGBitmap *a2, HGRect a3)
{
  (*(void (**)(DBM_cpu *, void, void, void))(*(void *)this + 40))(this, 0, *(void *)&a3.var0, *(void *)&a3.var2);
  uint64_t v7 = *((void *)this + 3);
  if (*((void *)this + 2) != v7)
  {
    uint64_t v8 = *(void *)(v7 - 8);
    if (v8)
    {
      unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
      if (v9) {
        HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"copying depth from cached depth %p to current dbm's depth %p\n", v5, v6, a2, v8);
      }
      uint64_t v10 = HGRectIntersection(*(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28), *(void *)(v8 + 20), *(void *)(v8 + 28));
      unint64_t v12 = HIDWORD(v11);
      if (SHIDWORD(v10) < SHIDWORD(v11))
      {
        size_t v13 = *((_DWORD *)a2 + 14) * ((int)v11 - (int)v10);
        uint64_t v14 = SHIDWORD(v10);
        uint64_t v15 = (int)v10;
        do
        {
          memcpy((void *)(*(void *)(v8 + 80)+ *(void *)(v8 + 64) * (v14 - *(int *)(v8 + 24))+ *(void *)(v8 + 56) * (v15 - *(int *)(v8 + 20))), (const void *)(*((void *)a2 + 10)+ *((void *)a2 + 8) * (v14 - *((int *)a2 + 6))+ *((void *)a2 + 7) * (v15 - *((int *)a2 + 5))), v13);
          ++v14;
        }
        while (v12 != v14);
      }
    }
  }
  unint64_t v16 = *(uint64_t (**)(DBM_cpu *))(*(void *)this + 48);

  return v16(this);
}

void HGMetalBuffer::~HGMetalBuffer(HGMetalBuffer *this)
{
  *(void *)this = &unk_1F10D3FE0;
  uint64_t v3 = (void *)((char *)this + 128);
  uint64_t v2 = (uint64_t *)*((void *)this + 16);
  if (v2) {
    HGMetalBufferPool::releaseBuffer(v2, *((void *)this + 18));
  }
  else {

  }
  *uint64_t v3 = 0;
  v3[1] = 0;
  v3[2] = 0;

  HGBitmap::~HGBitmap((HGBitmap *)this, v4);
}

{
  void *v1;
  uint64_t vars8;

  HGMetalBuffer::~HGMetalBuffer(this);

  HGObject::operator delete(v1);
}

uint64_t HGMetalBuffer::GetContent(id *this)
{
  return [this[18] contents];
}

char *HGMetalBuffer::ModifyRangeAndMarkAsDirty(id *this, uint64_t a2, size_t a3, const void *a4)
{
  uint64_t result = (char *)[this[18] contents];
  if (result)
  {
    uint64_t v8 = &result[a2];
    return (char *)memcpy(v8, a4, a3);
  }
  return result;
}

BOOL HGMetalBuffer::canCreateFromBytes(HGBitmap *this, HGBitmap *a2)
{
  uint64_t v2 = this;
  Storage = (const void *)HGBitmap::GetStorage(this);
  if (Storage
  {
    BOOL IsEqual = HGRectIsEqual(*(void *)((char *)v4 + 20), *(void *)((char *)v4 + 28), *(void *)((char *)v2 + 36), *(void *)((char *)v2 + 44));
    int v7 = getpagesize();
    if (IsEqual) {
      uint64_t v2 = v5;
    }
    uint64_t v8 = v7;
    if (!(*((void *)v2 + 10) % v7)) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v8 = getpagesize();
    if (!(*((void *)v2 + 10) % v8))
    {
LABEL_7:
      BOOL v9 = *((void *)v2 + 9) % v8 == 0;
      return HGMetalUtils::metalFormat(*((_DWORD *)v2 + 4)) && v9;
    }
  }
  BOOL v9 = 0;
  return HGMetalUtils::metalFormat(*((_DWORD *)v2 + 4)) && v9;
}

BOOL HGMetalBuffer::canCreateFromBytes(uint64_t a1, HGBitmap *this)
{
  Storage = (const void *)HGBitmap::GetStorage(this);
  if (!Storage
  {
    unsigned __int8 v6 = this;
  }
  unsigned int v8 = *(_DWORD *)(HGMetalDeviceInfo::getDeviceInfo(a1) + 48);
  if (*((_DWORD *)v6 + 7) - *((_DWORD *)v6 + 5) > v8 || *((_DWORD *)v6 + 8) - *((_DWORD *)v6 + 6) > v8) {
    return 0;
  }

  return HGMetalBuffer::canCreateFromBytes(this, v7);
}

const char *HGMetalBuffer::createFromBytes@<X0>(HGMetalBuffer *this@<X2>, void *a2@<X0>, uint64_t *a3@<X1>, char a4@<W3>, void *a5@<X8>)
{
  *a5 = 0;
  if (this && *((void *)this + 10))
  {
    if (HGMetalBuffer::canCreateFromBytes((HGBitmap *)this, (HGBitmap *)a3))
    {
      int v26 = 4608;
      kdebug_trace();
      Storage = (const void *)HGBitmap::GetStorage((HGBitmap *)this);
      if (!Storage
      {
        unint64_t v12 = this;
      }
      unsigned int v15 = *(_DWORD *)(HGMetalDeviceInfo::getDeviceInfo((uint64_t)a2) + 48);
      if (*((_DWORD *)v12 + 7) - *((_DWORD *)v12 + 5) > v15 || *((_DWORD *)v12 + 8) - *((_DWORD *)v12 + 6) > v15)
      {
        HGLogger::warning((HGLogger *)"HGMetalBuffer::createFromBytes() failed. Exceeding buffer size limits.", v13, v14);
        return (const char *)kdebug_trace();
      }
      if ((a4 & 1) == 0) {
        HGLogger::warning((HGLogger *)"MTLResourceStorageModeManaged is not available on iOS.", v13, v14);
      }
      if (a3)
      {
        uint64_t v18 = *((void *)v12 + 9);
        v25[0] = *((void *)v12 + 10);
        v25[1] = v18;
        v25[2] = 0;
        uint64_t v22 = HGMetalBufferWrapperInfinipool::newBuffer(a3, (uint64_t)v25);
        if (v22)
        {
LABEL_22:
          uint64_t v23 = HGObject::operator new(0x98uLL);
          HGBitmap::HGBitmap((uint64_t)v23, *(void *)((char *)v12 + 20), *(void *)((char *)v12 + 28), *((_DWORD *)v12 + 4), 0);
          *uint64_t v23 = &unk_1F10D3FE0;
          v23[17] = 0;
          v23[18] = 0;
          v23[16] = 0;
          *((_DWORD *)v23 + 3) |= 0x120u;
          if (a2)
          {
            v23[17] = a2;
            id v24 = a2;
          }
          *a5 = v23;
          *((_OWORD *)v23 + 4) = *((_OWORD *)v12 + 4);
          v23[18] = v22;
          HGBitmap::SetStorage((HGBitmap *)v23, v12);
          return (const char *)kdebug_trace();
        }
      }
      else
      {
        uint64_t v22 = [a2 newBufferWithBytesNoCopy:*((void *)v12 + 10) length:*((void *)v12 + 9) options:0 deallocator:0];
        uint64_t v20 = (char *)*((void *)v12 + 9);
        uint64_t v21 = *((void *)v12 + 10);
        unint64_t v19 = 0;
        if (v22) {
          goto LABEL_22;
        }
      }
      HGLogger::warning((HGLogger *)"HGMetalBuffer::createFromBytes() failed. MTLBuffer creation failed.", v19, v20, v21);
      return (const char *)kdebug_trace();
    }
    uint64_t v17 = "HGMetalBuffer::createFromBytes() failed. Data is not properly aligned.";
  }
  else
  {
    uint64_t v17 = "HGMetalBuffer::createFromBytes() failed. No HGBitmap provided.";
  }

  return HGLogger::warning((HGLogger *)v17, (const char *)a3, (char *)this);
}

void sub_1B775CB5C(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  HGBitmap::~HGBitmap(v13, a2);
  HGObject::operator delete(v13);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B775CBC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
}

void sub_1B775CBDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
}

void sub_1B775CBF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
}

void sub_1B775CC04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
}

void sub_1B775CC1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
}

void sub_1B775CC30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
}

const char *HGMetalBuffer::createWithCopy@<X0>(void *a1@<X0>, uint64_t a2@<X1>, char *a3@<X2>, void *a4@<X8>)
{
  *a4 = 0;
  if (a2 && *(void *)(a2 + 80))
  {
    kdebug_trace();
    uint64_t v7 = [a1 newBufferWithBytes:*(void *)(a2 + 80) length:*(void *)(a2 + 72) options:32];
    if (v7)
    {
      unsigned int v8 = HGObject::operator new(0x98uLL);
      HGBitmap::HGBitmap((uint64_t)v8, *(void *)(a2 + 20), *(void *)(a2 + 28), *(_DWORD *)(a2 + 16), 0);
      *unsigned int v8 = &unk_1F10D3FE0;
      v8[17] = 0;
      v8[18] = 0;
      unsigned char v8[16] = 0;
      *((_DWORD *)v8 + 3) |= 0x120u;
      if (a1)
      {
        v8[17] = a1;
        id v11 = a1;
      }
      *a4 = v8;
      *((_OWORD *)v8 + 4) = *(_OWORD *)(a2 + 64);
      v8[18] = v7;
    }
    else
    {
      HGLogger::warning((HGLogger *)"HGMetalBuffer::createWithCopy() failed. MTLBuffer creation failed.", 0, *(char **)(a2 + 72), *(void *)(a2 + 80));
    }
    unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
    if (v13) {
      HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - HGMetalBuffer::createWithCopy: newBufferWithBytes with copy of misaligned data\n", v9, v10);
    }
    return (const char *)kdebug_trace();
  }
  else
  {
    return HGLogger::warning((HGLogger *)"HGMetalBuffer::createWithCopy() failed. No HGBitmap provided.", (const char *)a2, a3);
  }
}

void sub_1B775CDE0(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  HGBitmap::~HGBitmap(v11, a2);
  HGObject::operator delete(v11);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

void sub_1B775CE0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B775CE24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  uint64_t v13 = *v11;
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
  }
  _Unwind_Resume(a1);
}

uint64_t HGMetalBuffer::create@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, void *a6@<X8>)
{
  unint64_t v12 = HGObject::operator new(0x98uLL);
  HGBitmap::HGBitmap((uint64_t)v12, a3, a4, a5, 0);
  *(void *)unint64_t v12 = &unk_1F10D3FE0;
  *((void *)v12 + 17) = 0;
  *((void *)v12 + 18) = 0;
  *((void *)v12 + 16) = 0;
  *((_DWORD *)v12 + 3) |= 0x120u;
  if (a1)
  {
    *((void *)v12 + 17) = a1;
    id v13 = a1;
  }
  *a6 = v12;
  if (a2)
  {
    uint64_t v18 = *((void *)v12 + 9);
    uint64_t result = HGMetalBufferPool::newBuffer(a2, &v18);
    uint64_t v17 = result;
    if (result)
    {
LABEL_5:
      *((void *)v12 + 18) = v17;
      *((void *)v12 + 16) = a2;
      return result;
    }
  }
  else
  {
    uint64_t v17 = [a1 newBufferWithLength:*((void *)v12 + 9) options:0];
    uint64_t result = *((void *)v12 + 18);
    unint64_t v16 = (char *)*((void *)v12 + 9);
    unsigned int v15 = 0;
    if (v17) {
      goto LABEL_5;
    }
  }
  HGLogger::warning((HGLogger *)"HGMetalBuffer::create() failed. Failed to allocate buffer object.", v15, v16);
  uint64_t result = (*(uint64_t (**)(void *))(*(void *)v12 + 24))(v12);
  *a6 = 0;
  return result;
}

void sub_1B775CFB0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGMetalBuffer::create@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  uint64_t v8 = HGRectMake4i(0, 0, a3, 1u);

  return HGMetalBuffer::create(a1, a2, v8, v7, 1, a4);
}

void *HGMetalBuffer::getMetalStorage(HGBitmap *this, HGBitmap *a2)
{
  if (!this) {
    return 0;
  }
  uint64_t v2 = this;
  do
  {
    Storage = (const void *)HGBitmap::GetStorage(v2);
    if (!Storage) {
      break;
    }
    uint64_t v2 = v5;
  }
  while (!v3 && v5 != 0);
  return v3;
}

uint64_t HGComicLUT::GetFormat(HGComicLUT *this)
{
  return 17;
}

uint64_t HGComicLUT::GetRect(HGComicLUT *this)
{
  HGRect::Init(&v2, 0, 0, 512, 512);
  return *(void *)&v2.var0;
}

void *HGComicLUT::GetData(int a1)
{
  if ((a1 - 1) > 4) {
    return &HGComicLUT0Data;
  }
  else {
    return *(&off_1E616C630 + a1 - 1);
  }
}

uint64_t HGGLBuffer::HGGLBuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v7 = HGBuffer::HGBuffer(a1, a2, a3, a4, 0);
  *uint64_t v7 = &unk_1F10D4060;
  unsigned char v7[16] = a5;
  *(_OWORD *)(v7 + 17) = *(_OWORD *)((char *)v7 + 20);
  v7[19] = 0;
  v7[20] = 0;
  *((_DWORD *)v7 + 42) = 0;
  *(int32x2_t *)((char *)v7 + 172) = vsub_s32(*(int32x2_t *)((char *)v7 + 28), *(int32x2_t *)((char *)v7 + 20));
  *((_WORD *)v7 + 90) = 257;
  *((unsigned char *)v7 + 182) = 0;
  *((_DWORD *)v7 + 3) |= 0x110u;
  if (a5)
  {
    (*(void (**)(uint64_t))(*(void *)a5 + 16))(a5);
    *(unsigned char *)(a1 + 182) = 1;
  }
  return a1;
}

void sub_1B775D2A0(_Unwind_Exception *a1)
{
  HGBuffer::~HGBuffer(v1);
  _Unwind_Resume(a1);
}

uint64_t HGGLBuffer::HGGLBuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6, int a7, char a8)
{
  id v13 = HGBuffer::HGBuffer(a1, a2, a3, a4, 0);
  *id v13 = &unk_1F10D4060;
  unsigned char v13[16] = a5;
  *(_OWORD *)(v13 + 17) = *(_OWORD *)((char *)v13 + 20);
  *((_DWORD *)v13 + 38) = a6;
  *((_DWORD *)v13 + 39) = a7;
  v13[20] = 0;
  *((_DWORD *)v13 + 42) = 0;
  *(int32x2_t *)((char *)v13 + 172) = vsub_s32(*(int32x2_t *)((char *)v13 + 28), *(int32x2_t *)((char *)v13 + 20));
  *((unsigned char *)v13 + 180) = 0;
  *((unsigned char *)v13 + 181) = a8;
  *((unsigned char *)v13 + 182) = 0;
  *((_DWORD *)v13 + 3) |= 0x110u;
  if (a5)
  {
    (*(void (**)(uint64_t))(*(void *)a5 + 16))(a5);
    *(unsigned char *)(a1 + 182) = 1;
  }
  return a1;
}

void sub_1B775D394(_Unwind_Exception *a1)
{
  HGBuffer::~HGBuffer(v1);
  _Unwind_Resume(a1);
}

void HGGLBuffer::~HGGLBuffer(HGGLBuffer *this)
{
  *(void *)this = &unk_1F10D4060;
  uint64_t v2 = *((void *)this + 16);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *((void *)this + 16) = 0;
    *((unsigned char *)this + 182) = 1;
    uint64_t v3 = this;
  }
  else
  {
    *((unsigned char *)this + 182) = 0;
    uint64_t v3 = this;
  }
  HGBuffer::~HGBuffer(v3);
}

{
  uint64_t v2;
  char v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10D4060;
  uint64_t v2 = *((void *)this + 16);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *((void *)this + 16) = 0;
    uint64_t v3 = 1;
  }
  else
  {
    uint64_t v3 = 0;
  }
  *((unsigned char *)this + 182) = v3;
  HGBuffer::~HGBuffer(this);

  HGObject::operator delete(v4);
}

atomic_uint *HGGLBuffer::Release(HGBitmap *this)
{
  if (*((void *)this + 16))
  {
    unsigned int v2 = atomic_load((unsigned int *)this + 2);
    if (v2 == 1)
    {
      HGGPURenderer::ReleaseBitmap(*((int64x2_t **)this + 16), this, (char *)1);
      uint64_t v3 = *((void *)this + 16);
      if (v3)
      {
        (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
        *((void *)this + 16) = 0;
      }
    }
  }

  return HGObject::Release((atomic_uint *)this);
}

void HGGLBuffer::ReadPixels(HGGLBuffer *this, HGPixelBufferObj *a2, HGRect a3)
{
}

uint64_t HGGLBuffer::AttachRenderer(uint64_t result, uint64_t a2)
{
  if (!*(unsigned char *)(result + 182) && a2 && !*(void *)(result + 128))
  {
    *(void *)(result + 128) = a2;
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  }
  return result;
}

uint64_t HGGLBuffer::DetachRenderer(uint64_t this)
{
  if (!*(unsigned char *)(this + 182))
  {
    uint64_t v1 = this;
    this = *(void *)(this + 128);
    if (this)
    {
      this = (*(uint64_t (**)(uint64_t))(*(void *)this + 24))(this);
      *(void *)(v1 + 128) = 0;
    }
  }
  return this;
}

uint64_t HGBlendingInfo::Get(HGBlendingInfo *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_8, memory_order_acquire) & 1) == 0)
  {
    int v4 = (int)this;
    int v2 = __cxa_guard_acquire((__guard *)&_MergedGlobals_8);
    LODWORD(this) = v4;
    if (v2)
    {
      qword_1EB9A1A08 = 0;
      qword_1EB9A1A10 = 1;
      dword_1EB9A1A18 = 1;
      unk_1EB9A1A24 = 0;
      unk_1EB9A1A1C = 0;
      dword_1EB9A1A2C = 0;
      qword_1EB9A1A30 = 1;
      dword_1EB9A1A38 = 1;
      unk_1EB9A1A44 = 0;
      unk_1EB9A1A3C = 0;
      dword_1EB9A1A4C = 0;
      qword_1EB9A1A50 = 1;
      dword_1EB9A1A58 = 1;
      unk_1EB9A1A64 = 0;
      unk_1EB9A1A5C = 0;
      dword_1EB9A1A6C = 0;
      qword_1EB9A1A70 = 1;
      dword_1EB9A1A78 = 1;
      unk_1EB9A1A84 = 0;
      unk_1EB9A1A7C = 0;
      dword_1EB9A1A8C = 0;
      qword_1EB9A1A90 = 1;
      dword_1EB9A1A98 = 1;
      dword_1EB9A1AAC = 0;
      unk_1EB9A1A9C = 0;
      unk_1EB9A1AA4 = 0;
      qword_1EB9A1AB0 = 1;
      dword_1EB9A1AB8 = 1;
      dword_1EB9A1ACC = 0;
      unk_1EB9A1ABC = 0;
      unk_1EB9A1AC4 = 0;
      qword_1EB9A1AD0 = 1;
      dword_1EB9A1AD8 = 1;
      unk_1EB9A1AE4 = 0;
      unk_1EB9A1ADC = 0;
      dword_1EB9A1AEC = 0;
      qword_1EB9A1AF0 = 1;
      dword_1EB9A1AF8 = 1;
      unk_1EB9A1B04 = 0;
      unk_1EB9A1AFC = 0;
      dword_1EB9A1B0C = 0;
      xmmword_1EB9A1B10 = xmmword_1B7EBF8F0;
      qword_1EB9A1B20 = 0;
      xmmword_1EB9A1B30 = xmmword_1B7E7AF00;
      qword_1EB9A1B40 = 0;
      qword_1EB9A1B28 = 3;
      qword_1EB9A1B48 = 0;
      qword_1EB9A1B50 = 1;
      dword_1EB9A1B58 = 1;
      unk_1EB9A1B64 = 0;
      unk_1EB9A1B5C = 0;
      dword_1EB9A1B6C = 0;
      qword_1EB9A1B70 = 1;
      dword_1EB9A1B78 = 1;
      unk_1EB9A1B84 = 0;
      unk_1EB9A1B7C = 0;
      dword_1EB9A1B8C = 0;
      qword_1EB9A1B90 = 1;
      dword_1EB9A1B98 = 1;
      unk_1EB9A1BA4 = 0;
      unk_1EB9A1B9C = 0;
      dword_1EB9A1BAC = 0;
      qword_1EB9A1BB0 = 1;
      dword_1EB9A1BB8 = 1;
      unk_1EB9A1BC4 = 0;
      unk_1EB9A1BBC = 0;
      dword_1EB9A1BCC = 0;
      xmmword_1EB9A1BD0 = xmmword_1B7EBF8F0;
      qword_1EB9A1BE0 = 0;
      xmmword_1EB9A1BF0 = xmmword_1B8343090;
      qword_1EB9A1C00 = 0;
      qword_1EB9A1BE8 = 3;
      qword_1EB9A1C08 = 0;
      xmmword_1EB9A1C10 = xmmword_1B7EBF8F0;
      qword_1EB9A1C20 = 0;
      xmmword_1EB9A1C30 = xmmword_1B83430A0;
      qword_1EB9A1C40 = 0;
      qword_1EB9A1C28 = 3;
      qword_1EB9A1C48 = 0;
      qword_1EB9A1C50 = 1;
      dword_1EB9A1C58 = 1;
      unk_1EB9A1C64 = 0;
      unk_1EB9A1C5C = 0;
      dword_1EB9A1C6C = 0;
      qword_1EB9A1C70 = 1;
      dword_1EB9A1C78 = 1;
      unk_1EB9A1C84 = 0;
      unk_1EB9A1C7C = 0;
      dword_1EB9A1C8C = 0;
      qword_1EB9A1C90 = 1;
      dword_1EB9A1C98 = 1;
      unk_1EB9A1CA4 = 0;
      unk_1EB9A1C9C = 0;
      dword_1EB9A1CAC = 0;
      qword_1EB9A1CB0 = 1;
      dword_1EB9A1CB8 = 1;
      unk_1EB9A1CC4 = 0;
      unk_1EB9A1CBC = 0;
      dword_1EB9A1CCC = 0;
      qword_1EB9A1CD0 = 1;
      dword_1EB9A1CD8 = 1;
      unk_1EB9A1CE4 = 0;
      unk_1EB9A1CDC = 0;
      dword_1EB9A1CEC = 0;
      qword_1EB9A1CF0 = 1;
      dword_1EB9A1CF8 = 1;
      unk_1EB9A1D04 = 0;
      unk_1EB9A1CFC = 0;
      dword_1EB9A1D0C = 0;
      qword_1EB9A1D10 = 1;
      dword_1EB9A1D18 = 1;
      unk_1EB9A1D24 = 0;
      unk_1EB9A1D1C = 0;
      dword_1EB9A1D2C = 0;
      qword_1EB9A1D30 = 1;
      dword_1EB9A1D38 = 1;
      unk_1EB9A1D44 = 0;
      unk_1EB9A1D3C = 0;
      dword_1EB9A1D4C = 0;
      qword_1EB9A1D50 = 1;
      dword_1EB9A1D58 = 1;
      unk_1EB9A1D64 = 0;
      unk_1EB9A1D5C = 0;
      dword_1EB9A1D6C = 0;
      xmmword_1EB9A1D70 = xmmword_1B7EBF8F0;
      qword_1EB9A1D80 = 0;
      xmmword_1EB9A1D90 = xmmword_1B83430B0;
      qword_1EB9A1DA0 = 0;
      qword_1EB9A1D88 = 3;
      qword_1EB9A1DA8 = 0;
      qword_1EB9A1DB0 = 1;
      dword_1EB9A1DB8 = 1;
      unk_1EB9A1DC4 = 0;
      unk_1EB9A1DBC = 0;
      dword_1EB9A1DCC = 0;
      qword_1EB9A1DD0 = 1;
      dword_1EB9A1DD8 = 1;
      unk_1EB9A1DE4 = 0;
      unk_1EB9A1DDC = 0;
      dword_1EB9A1DEC = 0;
      qword_1EB9A1DF0 = 1;
      dword_1EB9A1DF8 = 1;
      unk_1EB9A1E04 = 0;
      unk_1EB9A1DFC = 0;
      dword_1EB9A1E0C = 0;
      xmmword_1EB9A1E10 = xmmword_1B7EBF8F0;
      qword_1EB9A1E20 = 0;
      xmmword_1EB9A1E30 = xmmword_1B7EBF8E0;
      qword_1EB9A1E40 = 0;
      qword_1EB9A1E28 = 3;
      qword_1EB9A1E48 = 0;
      qword_1EB9A1E50 = 1;
      dword_1EB9A1E58 = 1;
      unk_1EB9A1E64 = 0;
      unk_1EB9A1E5C = 0;
      dword_1EB9A1E6C = 0;
      xmmword_1EB9A1E70 = xmmword_1B7EBF8F0;
      qword_1EB9A1E80 = 0;
      xmmword_1EB9A1E90 = xmmword_1B83430C0;
      qword_1EB9A1EA0 = 0;
      qword_1EB9A1E88 = 3;
      xmmword_1EB9A1EB0 = xmmword_1B83430D0;
      qword_1EB9A1EC0 = 0;
      qword_1EB9A1EA8 = 3;
      qword_1EB9A1EC8 = 0;
      qword_1EB9A1ED0 = 1;
      dword_1EB9A1ED8 = 1;
      unk_1EB9A1EE4 = 0;
      unk_1EB9A1EDC = 0;
      dword_1EB9A1EEC = 0;
      xmmword_1EB9A1EF0 = xmmword_1B7EBF8F0;
      qword_1EB9A1F00 = 0;
      *(void *)&long long v3 = 0x100000001;
      *((void *)&v3 + 1) = 0x100000001;
      xmmword_1EB9A1F10 = v3;
      qword_1EB9A1F20 = 0x200000002;
      qword_1EB9A1F08 = 0;
      xmmword_1EB9A1F30 = xmmword_1B7EBF8F0;
      qword_1EB9A1F40 = 0;
      qword_1EB9A1F28 = 0;
      __cxa_guard_release((__guard *)&_MergedGlobals_8);
      LODWORD(this) = v4;
    }
  }
  return (uint64_t)&_MergedGlobals_8 + 32 * this + 8;
}

BOOL HGBlendingInfo::operator<(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 < *(void *)a2) {
    return 1;
  }
  if (*(void *)a2 < *(void *)a1) {
    return 0;
  }
  int v3 = *(_DWORD *)(a1 + 8);
  int v4 = *(_DWORD *)(a2 + 8);
  if (v3 < v4) {
    return 1;
  }
  if (v4 < v3) {
    return 0;
  }
  int v5 = *(_DWORD *)(a1 + 12);
  int v6 = *(_DWORD *)(a2 + 12);
  if (v5 < v6) {
    return 1;
  }
  if (v6 < v5) {
    return 0;
  }
  int v7 = *(_DWORD *)(a1 + 16);
  int v8 = *(_DWORD *)(a2 + 16);
  if (v7 < v8) {
    return 1;
  }
  if (v8 < v7) {
    return 0;
  }
  int v9 = *(_DWORD *)(a1 + 20);
  int v10 = *(_DWORD *)(a2 + 20);
  if (v9 < v10) {
    return 1;
  }
  if (v10 < v9) {
    return 0;
  }
  int v11 = *(_DWORD *)(a1 + 24);
  int v12 = *(_DWORD *)(a2 + 24);
  if (v11 < v12) {
    return 1;
  }
  if (v12 >= v11) {
    return *(_DWORD *)(a1 + 28) < *(_DWORD *)(a2 + 28);
  }
  return 0;
}

BOOL HGBlendingInfo::operator==(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2
      && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
      && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
      && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16)
      && *(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20)
      && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
      && *(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 28);
}

void HGMetalBlendingInfo::HGMetalBlendingInfo(HGMetalBlendingInfo *this, int32x2_t *a2)
{
  int8x8_t v2 = (int8x8_t)a2[1];
  int8x8_t v3 = (int8x8_t)a2[2];
  int8x8_t v4 = (int8x8_t)vcgt_u32((uint32x2_t)0xD0000000DLL, (uint32x2_t)v2);
  int32x2_t v5 = vsub_s32((int32x2_t)vand_s8(v2, v4), (int32x2_t)vmvn_s8(v4));
  v6.i64[0] = v5.u32[0];
  v6.i64[1] = v5.u32[1];
  uint64x2_t v7 = v6;
  int8x8_t v8 = (int8x8_t)vcgt_u32((uint32x2_t)0xD0000000DLL, (uint32x2_t)v3);
  int32x2_t v9 = vsub_s32((int32x2_t)vand_s8(v3, v8), (int32x2_t)vmvn_s8(v8));
  v6.i64[0] = v9.u32[0];
  v6.i64[1] = v9.u32[1];
  *(uint64x2_t *)this = v7;
  *((uint64x2_t *)this + 1) = v6;
  uint32x2_t v10 = (uint32x2_t)vadd_s32(a2[3], (int32x2_t)-1);
  v6.i64[0] = v10.u32[0];
  v6.i64[1] = v10.u32[1];
  *((int8x16_t *)this + 2) = vandq_s8((int8x16_t)vaddw_u32((uint64x2_t)vdupq_n_s64(1uLL), v10), (int8x16_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(4uLL), v6));
}

void HGGLHandler::HGGLHandler(HGGLHandler *this)
{
  HGHandler::HGHandler(this);
  *(void *)uint64_t v1 = &unk_1F10D40E0;
  *(_DWORD *)(v1 + 248) = 3553;
}

uint64_t HGGLHandler::InitTexture(HGGLHandler *this, int a2, HGRect a3, HGRect a4, HGRect a5, int a6, int a7)
{
  *((_DWORD *)this + 62) = a2;
  return HGHandler::InitTexture((uint64_t)this, a2, a3, a4, a5, a6, a7);
}

void HGGLHandler::SetFilter(HGGLHandler *this, BOOL a2, BOOL a3)
{
  BOOL v3 = a3;
  BOOL v4 = a2;
  if (a2 < 0)
  {
    BOOL v4 = *((_DWORD *)this + 59) != 0;
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((a3 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  BOOL v3 = *((_DWORD *)this + 59) != 0;
LABEL_3:
  GLenum v6 = *((_DWORD *)this + 62);
  if (v4) {
    GLint v7 = 9729;
  }
  else {
    GLint v7 = 9728;
  }
  glTexParameteri(v6, 0x2800u, v7);
  if (v3) {
    GLint v8 = 9729;
  }
  else {
    GLint v8 = 9728;
  }
  glTexParameteri(*((_DWORD *)this + 62), 0x2801u, v8);
  unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
  if ((v11 & 1) == 0)
  {
    unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
    if ((v12 & 1) == 0) {
      return;
    }
    goto LABEL_15;
  }
  id v13 = "linear";
  if (!v4) {
    id v13 = "nearest";
  }
  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"min filter: %s\n", v9, v10, v13);
  unsigned __int8 v14 = atomic_load(HGLogger::_enabled);
  if (v14)
  {
LABEL_15:
    unsigned int v15 = "linear";
    if (!v3) {
      unsigned int v15 = "nearest";
    }
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"mag filter: %s\n", v9, v10, v15);
  }
}

uint64_t HGGLHandler::ActiveTexture(HGGLHandler *this, int a2, int a3)
{
  uint64_t v5 = (*((_DWORD *)this + 40) + a2);
  glActiveTexture(v5 + 33984);
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8) {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"active texture: %d\n", v6, v7, v5);
  }
  if (a3)
  {
    unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
    if (v9) {
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"physical translate: { %d, %d, %lf }\n", v6, v7, *((unsigned int *)this + 60), *((unsigned int *)this + 61), 0);
    }
  }
  return v5;
}

uint64_t HGGLHandler::ActiveTextureMatrix(HGGLHandler *this, uint64_t a2)
{
  return (*(uint64_t (**)(HGGLHandler *, uint64_t, void))(*(void *)this + 72))(this, a2, 0);
}

void HGGLHandler::LoadIdentity(HGGLHandler *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
  if (v5) {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"load identity\n", a4, a5);
  }
}

void HGGLHandler::Translate(HGGLHandler *this, double a2, double a3, double a4, uint64_t a5, uint64_t a6, const char *a7, char *a8)
{
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8) {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"translate: { %lf, %lf, %lf }\n", a7, a8, *(void *)&a2, *(void *)&a3, *(void *)&a4);
  }
}

void HGGLHandler::Scale(HGGLHandler *this, double a2, double a3, double a4, uint64_t a5, uint64_t a6, const char *a7, char *a8)
{
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8) {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"scale: { %lf, %lf, %lf }\n", a7, a8, *(void *)&a2, *(void *)&a3, *(void *)&a4);
  }
}

void HGGLHandler::MultMatrix(HGGLHandler *this, const double *a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6)
  {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"mult: { { %lf, %lf, %lf, %lf}, \n", a4, a5, *(void *)a2, *((void *)a2 + 1), *((void *)a2 + 2), *((void *)a2 + 3));
    unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
    if ((v10 & 1) == 0)
    {
LABEL_3:
      unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
      if ((v8 & 1) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else
  {
    unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
    if ((v7 & 1) == 0) {
      goto LABEL_3;
    }
  }
  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"        { %lf, %lf, %lf, %lf}, \n", a4, a5, *((void *)a2 + 4), *((void *)a2 + 5), *((void *)a2 + 6), *((void *)a2 + 7));
  unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
  if ((v11 & 1) == 0)
  {
LABEL_4:
    unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) == 0) {
      return;
    }
LABEL_9:
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"        { %lf, %lf, %lf, %lf} }\n", a4, a5, *((void *)a2 + 12), *((void *)a2 + 13), *((void *)a2 + 14), *((void *)a2 + 15));
    return;
  }
LABEL_8:
  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"        { %lf, %lf, %lf, %lf}, \n", a4, a5, *((void *)a2 + 8), *((void *)a2 + 9), *((void *)a2 + 10), *((void *)a2 + 11));
  unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
  if (v12) {
    goto LABEL_9;
  }
}

void HGGLHandler::MultMatrix(HGGLHandler *this, const float *a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6)
  {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"mult: { { %lf, %lf, %lf, %lf}, \n", a4, a5, *a2, a2[1], a2[2], a2[3]);
    unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
    if ((v10 & 1) == 0)
    {
LABEL_3:
      unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
      if ((v8 & 1) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else
  {
    unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
    if ((v7 & 1) == 0) {
      goto LABEL_3;
    }
  }
  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"        { %lf, %lf, %lf, %lf}, \n", a4, a5, a2[4], a2[5], a2[6], a2[7]);
  unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
  if ((v11 & 1) == 0)
  {
LABEL_4:
    unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) == 0) {
      return;
    }
LABEL_9:
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"        { %lf, %lf, %lf, %lf} }\n", a4, a5, a2[12], a2[13], a2[14], a2[15]);
    return;
  }
LABEL_8:
  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"        { %lf, %lf, %lf, %lf}, \n", a4, a5, a2[8], a2[9], a2[10], a2[11]);
  unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
  if (v12) {
    goto LABEL_9;
  }
}

void HGGLSLHandler::~HGGLSLHandler(OZChannelBase *this, const PCString *a2)
{
  OZChannelBase::setRangeName(this, a2);

  JUMPOUT(0x1BA9BFBA0);
}

HGGLSLHandler *HGGLSLHandler::Reset(HGGLSLHandler *this, HGRenderer *a2, int a3)
{
  HGHandler::Reset((uint64_t)this, (uint64_t)a2);
  *((_DWORD *)this + 63) = a3;
  *((void *)this + 96) = 0;
  GLState = (uint64_t **)HGGPURenderer::GetGLState(a2);
  int UniformLocation = HGGLState::getUniformLocation(GLState, *((unsigned int *)this + 63), 0, 0);
  *((_DWORD *)this + 194) = UniformLocation;
  if (a2)
  {
    int v8 = UniformLocation;
    if (v8 != -1 && v9 != 0)
    {
      uint64_t ProjectionMatrix = HGGPURenderer::GetProjectionMatrix(v9);
      (*(void (**)(uint64_t, char *))(*(void *)ProjectionMatrix + 40))(ProjectionMatrix, (char *)this + 780);
      glUniformMatrix4fv(*((_DWORD *)this + 194), 1, 0, (const GLfloat *)this + 195);
      unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
      if (v16) {
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (projection) :\n", v14, v15, *((unsigned int *)this + 194));
      }
      log_matrix((float *)this + 195, v12, v13, v14, v15);
    }
  }
  *((_OWORD *)this + 16) = xmmword_1B7E736B0;
  *((_OWORD *)this + 17) = xmmword_1B7E736C0;
  *((_OWORD *)this + 18) = xmmword_1B7E736D0;
  *((_OWORD *)this + 19) = xmmword_1B7E734D0;
  *((_OWORD *)this + 20) = xmmword_1B7E736B0;
  *((_OWORD *)this + 21) = xmmword_1B7E736C0;
  *((_OWORD *)this + 22) = xmmword_1B7E736D0;
  *((_OWORD *)this + 23) = xmmword_1B7E734D0;
  *((_OWORD *)this + 24) = xmmword_1B7E736B0;
  *((_OWORD *)this + 25) = xmmword_1B7E736C0;
  *((_OWORD *)this + 26) = xmmword_1B7E736D0;
  *((_OWORD *)this + 27) = xmmword_1B7E734D0;
  *((_OWORD *)this + 28) = xmmword_1B7E736B0;
  *((_OWORD *)this + 29) = xmmword_1B7E736C0;
  *((_OWORD *)this + 30) = xmmword_1B7E736D0;
  *((_OWORD *)this + 31) = xmmword_1B7E734D0;
  *((_OWORD *)this + 32) = xmmword_1B7E736B0;
  *((_OWORD *)this + 33) = xmmword_1B7E736C0;
  *((_OWORD *)this + 34) = xmmword_1B7E736D0;
  *((_OWORD *)this + 35) = xmmword_1B7E734D0;
  *((_OWORD *)this + 36) = xmmword_1B7E736B0;
  *((_OWORD *)this + 37) = xmmword_1B7E736C0;
  *((_OWORD *)this + 38) = xmmword_1B7E736D0;
  *((_OWORD *)this + 39) = xmmword_1B7E734D0;
  *((_OWORD *)this + 40) = xmmword_1B7E736B0;
  *((_OWORD *)this + 41) = xmmword_1B7E736C0;
  *((_OWORD *)this + 42) = xmmword_1B7E736D0;
  *((_OWORD *)this + 43) = xmmword_1B7E734D0;
  *((_OWORD *)this + 44) = xmmword_1B7E736B0;
  *((_OWORD *)this + 45) = xmmword_1B7E736C0;
  *((_OWORD *)this + 46) = xmmword_1B7E736D0;
  *((_OWORD *)this + 47) = xmmword_1B7E734D0;
  return this;
}

void log_matrix(float *a1, int a2, const float *a3, const char *a4, char *a5)
{
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6)
  {
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)" { { %lf, %lf, %lf, %lf}, \n", a4, a5, *a1, a1[1], a1[2], a1[3]);
    unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
    if ((v10 & 1) == 0)
    {
LABEL_3:
      unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
      if ((v8 & 1) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else
  {
    unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
    if ((v7 & 1) == 0) {
      goto LABEL_3;
    }
  }
  HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"   { %lf, %lf, %lf, %lf}, \n", a4, a5, a1[4], a1[5], a1[6], a1[7]);
  unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
  if ((v11 & 1) == 0)
  {
LABEL_4:
    unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) == 0) {
      return;
    }
LABEL_9:
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"   { %lf, %lf, %lf, %lf} }\n", a4, a5, a1[12], a1[13], a1[14], a1[15]);
    return;
  }
LABEL_8:
  HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"   { %lf, %lf, %lf, %lf}, \n", a4, a5, a1[8], a1[9], a1[10], a1[11]);
  unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
  if (v12) {
    goto LABEL_9;
  }
}

void HGGLSLHandler::LoadModelViewMatrix(float32x2_t *this, const simd::float4x4 *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  BOOL v3 = (float32x4_t *)((char *)&this[97] + 4);
  HGHandler::LoadModelViewMatrix((HGHandler *)this, a2);
  float32x4_t v4 = v3[1];
  float32x4_t v5 = v3[2];
  float32x4_t v6 = v3[3];
  float32x4_t v7 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v3, COERCE_FLOAT(*(_OWORD *)this[4].f32)), v4, this[4], 1), v5, *(float32x4_t *)this[4].f32, 2), v6, *(float32x4_t *)this[4].f32, 3);
  float32x4_t v8 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v3, COERCE_FLOAT(*(_OWORD *)this[6].f32)), v4, this[6], 1), v5, *(float32x4_t *)this[6].f32, 2), v6, *(float32x4_t *)this[6].f32, 3);
  float32x4_t v9 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v3, COERCE_FLOAT(*(_OWORD *)this[8].f32)), v4, this[8], 1), v5, *(float32x4_t *)this[8].f32, 2), v6, *(float32x4_t *)this[8].f32, 3);
  *(float32x4_t *)value = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v3, COERCE_FLOAT(*(_OWORD *)this[2].f32)), v4, this[2], 1), v5, *(float32x4_t *)this[2].f32, 2), v6, *(float32x4_t *)this[2].f32, 3);
  float32x4_t v16 = v7;
  float32x4_t v17 = v8;
  float32x4_t v18 = v9;
  glUniformMatrix4fv(this[97].i32[0], 1, 0, value);
  unsigned __int8 v14 = atomic_load(HGLogger::_enabled);
  if (v14) {
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (model-view-projection) :\n", v12, v13, this[97].u32[0]);
  }
  log_matrix(value, v10, v11, v12, v13);
}

const char *HGGLSLHandler::LoadProjectionMatrix(HGGLSLHandler *this, const simd::float4x4 *a2, char *a3)
{
  return HGLogger::error((HGLogger *)"Projection matrix loading not supported in OpenGL", (const char *)a2, a3);
}

void HGGLSLHandler::Commit(HGGLSLHandler *this)
{
  GLState = (uint64_t **)HGGPURenderer::GetGLState(*((HGGPURenderer **)this + 18));
  BOOL v3 = GLState;
  if (*((unsigned char *)this + 772))
  {
    uint64_t UniformLocation = HGGLState::getUniformLocation(GLState, *((unsigned int *)this + 63), 1, 0);
    if (UniformLocation != -1)
    {
      uint64_t v5 = UniformLocation;
      glUniformMatrix4fv(UniformLocation, 1, 0, (const GLfloat *)this + 64);
      unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
      if (v10) {
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v8, v9, v5);
      }
      log_matrix((float *)this + 64, v6, v7, v8, v9);
    }
  }
  if ((*((unsigned char *)this + 772) & 2) != 0)
  {
    uint64_t v11 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 1);
    if (v11 != -1)
    {
      uint64_t v12 = v11;
      glUniformMatrix4fv(v11, 1, 0, (const GLfloat *)this + 80);
      unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
      if (v17) {
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v15, v16, v12);
      }
      log_matrix((float *)this + 80, v13, v14, v15, v16);
    }
  }
  if ((*((unsigned char *)this + 772) & 4) != 0)
  {
    uint64_t v18 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 2);
    if (v18 != -1)
    {
      uint64_t v19 = v18;
      glUniformMatrix4fv(v18, 1, 0, (const GLfloat *)this + 96);
      unsigned __int8 v24 = atomic_load(HGLogger::_enabled);
      if (v24) {
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v22, v23, v19);
      }
      log_matrix((float *)this + 96, v20, v21, v22, v23);
    }
  }
  if ((*((unsigned char *)this + 772) & 8) != 0)
  {
    uint64_t v25 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 3);
    if (v25 != -1)
    {
      uint64_t v26 = v25;
      glUniformMatrix4fv(v25, 1, 0, (const GLfloat *)this + 112);
      unsigned __int8 v31 = atomic_load(HGLogger::_enabled);
      if (v31) {
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v29, v30, v26);
      }
      log_matrix((float *)this + 112, v27, v28, v29, v30);
    }
  }
  if ((*((unsigned char *)this + 772) & 0x10) != 0)
  {
    uint64_t v32 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 4);
    if (v32 != -1)
    {
      uint64_t v33 = v32;
      glUniformMatrix4fv(v32, 1, 0, (const GLfloat *)this + 128);
      unsigned __int8 v38 = atomic_load(HGLogger::_enabled);
      if (v38) {
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v36, v37, v33);
      }
      log_matrix((float *)this + 128, v34, v35, v36, v37);
    }
  }
  if ((*((unsigned char *)this + 772) & 0x20) != 0)
  {
    uint64_t v39 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 5);
    if (v39 != -1)
    {
      uint64_t v40 = v39;
      glUniformMatrix4fv(v39, 1, 0, (const GLfloat *)this + 144);
      unsigned __int8 v45 = atomic_load(HGLogger::_enabled);
      if (v45) {
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v43, v44, v40);
      }
      log_matrix((float *)this + 144, v41, v42, v43, v44);
    }
  }
  if ((*((unsigned char *)this + 772) & 0x40) != 0)
  {
    uint64_t v46 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 6);
    if (v46 != -1)
    {
      uint64_t v47 = v46;
      glUniformMatrix4fv(v46, 1, 0, (const GLfloat *)this + 160);
      unsigned __int8 v52 = atomic_load(HGLogger::_enabled);
      if (v52) {
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v50, v51, v47);
      }
      log_matrix((float *)this + 160, v48, v49, v50, v51);
    }
  }
  if ((*((unsigned char *)this + 772) & 0x80) != 0)
  {
    uint64_t v53 = HGGLState::getUniformLocation(v3, *((unsigned int *)this + 63), 1, 7);
    if (v53 != -1)
    {
      uint64_t v54 = v53;
      uint64_t v55 = (GLfloat *)((char *)this + 704);
      glUniformMatrix4fv(v53, 1, 0, v55);
      unsigned __int8 v60 = atomic_load(HGLogger::_enabled);
      if (v60) {
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"uniform matrix %d (texture) :\n", v58, v59, v54);
      }
      log_matrix(v55, v56, v57, v58, v59);
    }
  }
}

uint64_t HGGLSLHandler::ActiveTexture(int32x2_t *this, int a2, int a3)
{
  uint64_t v5 = (this[20].i32[0] + a2);
  this[96].i32[0] = v5;
  glActiveTexture(v5 + 33984);
  if (a3)
  {
    *(float32x2_t *)&long long v6 = vcvt_f32_s32(this[30]);
    *((void *)&v6 + 1) = 0x3F80000000000000;
    *(_OWORD *)this[8 * (unint64_t)this[96].u32[0] + 38].i8 = v6;
  }
  return v5;
}

uint64_t HGGLSLHandler::ActiveTextureMatrix(HGGLSLHandler *this, uint64_t a2)
{
  return (*(uint64_t (**)(HGGLSLHandler *, uint64_t, void))(*(void *)this + 72))(this, a2, 0);
}

double HGGLSLHandler::LoadIdentity(HGGLSLHandler *this)
{
  *((_OWORD *)this + 4 * (unint64_t)*((unsigned int *)this + 192) + 16) = xmmword_1B7E736B0;
  uint64_t v1 = *((unsigned int *)this + 192);
  int8x8_t v2 = (_OWORD *)((char *)this + 64 * v1 + 256);
  v2[1] = xmmword_1B7E736C0;
  v2[2] = xmmword_1B7E736D0;
  double result = 0.0;
  v2[3] = xmmword_1B7E734D0;
  *((_DWORD *)this + 193) |= 1 << v1;
  return result;
}

float32x4_t HGGLSLHandler::Translate(HGGLSLHandler *this, double a2, double a3, double a4)
{
  uint64_t v4 = *((unsigned int *)this + 192);
  uint64_t v5 = (float32x4_t *)((char *)this + 64 * v4);
  float v6 = a2;
  float v7 = a3;
  float v8 = a4;
  float32x4_t result = vaddq_f32(vaddq_f32(vmulq_n_f32(v5[16], v6), vmulq_n_f32(v5[17], v7)), vaddq_f32(vmulq_n_f32(v5[18], v8), v5[19]));
  v5[19] = result;
  *((_DWORD *)this + 193) |= 1 << v4;
  return result;
}

float32x4_t HGGLSLHandler::Scale(HGGLSLHandler *this, double a2, double a3, double a4)
{
  uint64_t v4 = (float32x4_t *)((char *)this + 64 * (unint64_t)*((unsigned int *)this + 192));
  float v5 = a2;
  float32x4_t result = vmulq_n_f32(v4[16], v5);
  float v7 = a3;
  float v8 = a4;
  float32x4_t v9 = vmulq_n_f32(v4[17], v7);
  float32x4_t v10 = vmulq_n_f32(v4[18], v8);
  unsigned char v4[16] = result;
  v4[17] = v9;
  v4[18] = v10;
  *((_DWORD *)this + 193) |= 1 << *((_DWORD *)this + 192);
  return result;
}

float32x4_t HGGLSLHandler::MultMatrix(HGGLSLHandler *this, const double *a2)
{
  float v2 = *a2;
  float v3 = a2[1];
  float v4 = a2[2];
  float v5 = a2[3];
  float v6 = a2[4];
  float v7 = a2[5];
  float v8 = a2[6];
  float v9 = a2[7];
  float v10 = a2[8];
  float v11 = a2[9];
  float v12 = a2[10];
  float v13 = a2[11];
  float v14 = a2[12];
  float v15 = a2[13];
  float v16 = a2[14];
  float v17 = a2[15];
  uint64_t v18 = (float32x4_t *)((char *)this + 64 * (unint64_t)*((unsigned int *)this + 192));
  float32x4_t v19 = v18[16];
  float32x4_t v20 = v18[17];
  float32x4_t v21 = vaddq_f32(vmulq_n_f32(v19, v2), vmulq_n_f32(v20, v3));
  float32x4_t v22 = v18[18];
  float32x4_t v23 = v18[19];
  float32x4_t result = vaddq_f32(v21, vaddq_f32(vmulq_n_f32(v22, v4), vmulq_n_f32(v23, v5)));
  unsigned char v18[16] = result;
  v18[17] = vaddq_f32(vaddq_f32(vmulq_n_f32(v19, v6), vmulq_n_f32(v20, v7)), vaddq_f32(vmulq_n_f32(v22, v8), vmulq_n_f32(v23, v9)));
  v18[18] = vaddq_f32(vaddq_f32(vmulq_n_f32(v19, v10), vmulq_n_f32(v20, v11)), vaddq_f32(vmulq_n_f32(v22, v12), vmulq_n_f32(v23, v13)));
  v18[19] = vaddq_f32(vaddq_f32(vmulq_n_f32(v19, v14), vmulq_n_f32(v20, v15)), vaddq_f32(vmulq_n_f32(v22, v16), vmulq_n_f32(v23, v17)));
  *((_DWORD *)this + 193) |= 1 << *((_DWORD *)this + 192);
  return result;
}

float32x4_t HGGLSLHandler::MultMatrix(HGGLSLHandler *this, const float *a2)
{
  float v2 = (float32x4_t *)((char *)this + 64 * (unint64_t)*((unsigned int *)this + 192));
  float32x4_t v3 = v2[16];
  float32x4_t v4 = v2[17];
  float32x4_t v5 = v2[18];
  float32x4_t v6 = v2[19];
  float32x4_t result = vaddq_f32(vaddq_f32(vmulq_n_f32(v3, COERCE_FLOAT(*(_OWORD *)a2)), vmulq_lane_f32(v4, *(float32x2_t *)a2, 1)), vaddq_f32(vmulq_laneq_f32(v5, *(float32x4_t *)a2, 2), vmulq_laneq_f32(v6, *(float32x4_t *)a2, 3)));
  float32x4_t v8 = vaddq_f32(vaddq_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)a2 + 1))), vmulq_lane_f32(v4, *(float32x2_t *)(a2 + 4), 1)), vaddq_f32(vmulq_laneq_f32(v5, *(float32x4_t *)(a2 + 4), 2), vmulq_laneq_f32(v6, *(float32x4_t *)(a2 + 4), 3)));
  float32x4_t v9 = vaddq_f32(vaddq_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)a2 + 2))), vmulq_lane_f32(v4, *(float32x2_t *)(a2 + 8), 1)), vaddq_f32(vmulq_laneq_f32(v5, *(float32x4_t *)(a2 + 8), 2), vmulq_laneq_f32(v6, *(float32x4_t *)(a2 + 8), 3)));
  float32x4_t v10 = vaddq_f32(vaddq_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)a2 + 3))), vmulq_lane_f32(v4, *(float32x2_t *)(a2 + 12), 1)), vaddq_f32(vmulq_laneq_f32(v5, *(float32x4_t *)(a2 + 12), 2), vmulq_laneq_f32(v6, *(float32x4_t *)(a2 + 12), 3)));
  v2[16] = result;
  v2[17] = v8;
  v2[18] = v9;
  v2[19] = v10;
  *((_DWORD *)this + 193) |= 1 << *((_DWORD *)this + 192);
  return result;
}

float32x4_t HGGLSLHandler::Normalize(HGGLSLHandler *this)
{
  __asm { FMOV            V1.2S, #1.0 }
  *(float32x2_t *)v6.f32 = vdiv_f32(_D1, vcvt_f32_u32((uint32x2_t)vsub_s32(*(int32x2_t *)((char *)this + 228), *(int32x2_t *)((char *)this + 220))));
  *(float32x2_t *)&v6.u32[2] = _D1;
  float v7 = (float32x4_t *)((char *)this + 64 * (unint64_t)*((unsigned int *)this + 192));
  float32x4_t v8 = vmulq_f32(v7[16], v6);
  float32x4_t v9 = vmulq_f32(v7[17], v6);
  float32x4_t v10 = vmulq_f32(v7[18], v6);
  float32x4_t result = vmulq_f32(v6, v7[19]);
  unsigned char v7[16] = v8;
  v7[17] = v9;
  v7[18] = v10;
  v7[19] = result;
  *((_DWORD *)this + 193) |= 1 << *((_DWORD *)this + 192);
  return result;
}

void HGGLSLHandler::Rect(HGGLSLHandler *this, HGRect a2, int a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  ptr[0] = (float)a2.var0;
  ptr[1] = (float)a2.var1;
  ptr[2] = (float)a2.var2;
  ptr[3] = (float)a2.var1;
  ptr[4] = (float)a2.var0;
  ptr[5] = (float)a2.var3;
  ptr[6] = (float)a2.var2;
  ptr[7] = (float)a2.var3;
  if (a3 < 1)
  {
    glVertexAttribPointer(0, 2, 0x1406u, 0, 0, ptr);
    glEnableVertexAttribArray(0);
    glDrawArrays(5u, 0, 4);
  }
  else
  {
    GLuint v4 = a3 + 7;
    do
    {
      glVertexAttribPointer(v4, 2, 0x1406u, 0, 0, ptr);
      glEnableVertexAttribArray(v4--);
    }
    while (v4 != 7);
    glVertexAttribPointer(0, 2, 0x1406u, 0, 0, ptr);
    glEnableVertexAttribArray(0);
    glDrawArrays(5u, 0, 4);
    GLuint v5 = a3 + 7;
    do
    {
      glVertexAttribPointer(v5, 2, 0x1406u, 0, 0, 0);
      glDisableVertexAttribArray(v5--);
    }
    while (v5 != 7);
  }
  glVertexAttribPointer(0, 2, 0x1406u, 0, 0, 0);
  glDisableVertexAttribArray(0);
}

uint64_t HGGLSLHandler::LocalParameter(HGGLSLHandler *this, int a2, GLfloat a3, GLfloat a4, GLfloat a5, GLfloat a6)
{
  uint64_t v11 = (*((_DWORD *)this + 42) + a2);
  GLState = (uint64_t **)HGGPURenderer::GetGLState(*((HGGPURenderer **)this + 18));
  GLint UniformLocation = HGGLState::getUniformLocation(GLState, *((unsigned int *)this + 63), 2, v11);
  if (UniformLocation != -1)
  {
    glUniform4f(UniformLocation, a3, a4, a5, a6);
    unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
    if (v16) {
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"program_local(%d): { %f, %f, %f, %f }\n", v14, v15, v11, a3, a4, a5, a6);
    }
  }
  return v11;
}

uint64_t HGGLSLHandler::LocalParameters(HGGLSLHandler *this, uint64_t a2, float *a3, int a4)
{
  if (a4 >= 1)
  {
    int v5 = a4;
    uint64_t v8 = a2;
    do
    {
      (*(void (**)(HGGLSLHandler *, uint64_t, float, float, float, float))(*(void *)this + 136))(this, v8, *a3, a3[1], a3[2], a3[3]);
      uint64_t v8 = (v8 + 1);
      a3 += 4;
      --v5;
    }
    while (v5);
  }
  return a2;
}

uint64_t HGGLSLHandler::LocalParametersBuffer(HGGLSLHandler *this, void *a2, unint64_t a3, unint64_t a4)
{
  return (*(uint64_t (**)(HGGLSLHandler *, unint64_t, void *, unint64_t))(*(void *)this + 144))(this, a4 >> 4, a2, a3 >> 4);
}

void HGGLSLHandler::UnBind(HGGLSLHandler *this)
{
}

void HFDenseCRF::HFDenseCRF(HFDenseCRF *this, const __CFUUID *a2)
{
  *(void *)this = &unk_1F10D42D8;
}

void HFDenseCRF::~HFDenseCRF(HFDenseCRF *this)
{
  *(void *)this = &unk_1F10D42D8;
}

{
  *(void *)this = &unk_1F10D42D8;
  JUMPOUT(0x1BA9BFBA0);
}

uint64_t HFDenseCRF::GenerateMask(HFDenseCRF *this, HGBitmap *a2, HGBitmap *a3, HGBitmap *a4, float a5, float a6, float a7, float a8, float a9, float a10, uint64_t a11)
{
  unint64_t v11 = (*((_DWORD *)a2 + 7) - *((_DWORD *)a2 + 5));
  if (v11 != *((_DWORD *)a3 + 7) - *((_DWORD *)a3 + 5)
    || (int v14 = *((_DWORD *)a2 + 8), v15 = *((_DWORD *)a2 + 6), v14 - v15 != *((_DWORD *)a3 + 8) - *((_DWORD *)a3 + 6))
    || v11 != *((_DWORD *)a4 + 7) - *((_DWORD *)a4 + 5)
    || v14 - v15 != *((_DWORD *)a4 + 8) - *((_DWORD *)a4 + 6))
  {
    float v17 = "Error: inputs to CRF must be the same size";
LABEL_22:
    puts(v17);
    return 1;
  }
  if (*((_DWORD *)a2 + 4) != 21)
  {
    float v17 = "Error: image buffer for CRF must have 3 channels of 32-floats";
    goto LABEL_22;
  }
  unsigned int v16 = *((_DWORD *)a3 + 4);
  float v17 = "Error: probability buffer for CRF must have up to 3 channels of 32-floats";
  if (v16 > 0x15 || ((1 << v16) & 0x202080) == 0) {
    goto LABEL_22;
  }
  if (*((_DWORD *)a4 + 4) != 7)
  {
    float v17 = "Error: matte buffer for CRF must have 1 channel of 32-floats";
    goto LABEL_22;
  }
  int v156 = *((_DWORD *)a2 + 5);
  int v157 = *((_DWORD *)a2 + 7);
  unint64_t v150 = (v14 - v15);
  unint64_t v158 = HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v158, *(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28), 13);
  int v152 = v15;
  int v153 = v14;
  unint64_t v154 = v11;
  if (v14 != v15 && v157 != v156)
  {
    double v72 = (const float *)*((void *)a3 + 10);
    uint64_t v73 = *((void *)a3 + 8);
    uint64_t v74 = v158[10];
    uint64_t v75 = v158[8];
    if (v11 <= 1) {
      unint64_t v76 = 1;
    }
    else {
      unint64_t v76 = v11;
    }
    if (v150 <= 1) {
      uint64_t v77 = 1;
    }
    else {
      uint64_t v77 = (v14 - v15);
    }
    if (v76 < 4)
    {
      uint64_t v78 = (float *)(v72 + 3);
      unsigned __int8 v79 = (float *)(v74 + 12);
      do
      {
        float v80 = expf(-*(v78 - 3));
        float v81 = expf(-*(v78 - 2));
        float v82 = 1.0 / (float)(v80 + v81);
        *(v79 - 3) = v80 * v82;
        *(v79 - 2) = v81 * v82;
        if (v11 >= 2)
        {
          float v83 = expf(-*(v78 - 1));
          float v84 = expf(-*v78);
          float v85 = 1.0 / (float)(v83 + v84);
          *(v79 - 1) = v83 * v85;
          *unsigned __int8 v79 = v84 * v85;
          if (v76 != 2)
          {
            float v86 = expf(-v78[1]);
            float v87 = expf(-v78[2]);
            float v88 = 1.0 / (float)(v86 + v87);
            v79[1] = v86 * v88;
            v79[2] = v87 * v88;
          }
        }
        uint64_t v78 = (float *)((char *)v78 + v73);
        unsigned __int8 v79 = (float *)((char *)v79 + v75);
        --v77;
      }
      while (v77);
      goto LABEL_11;
    }
    uint64_t v104 = 0;
    uint64_t v169 = 2 * v76;
    uint64_t v171 = (const float *)*((void *)a3 + 10);
    uint64_t v175 = v76 & 0xFFFFFFFC;
    unint64_t v177 = v76;
    __asm { FMOV            V0.4S, #1.0 }
    int v106 = v171;
    long long v107 = (float *)v158[10];
    float32x4_t v179 = _Q0;
    uint64_t v173 = *((void *)a3 + 8);
    do
    {
      uint64_t v108 = v75;
      uint64_t v109 = v74;
      if (v74 + v75 * v104 >= (unint64_t)&v72[v169] + v73 * v104
        || (unint64_t)v72 + v73 * v104 >= v74 + v169 * 4 + v75 * v104)
      {
        uint64_t v111 = v175;
        long long v112 = v106;
        long long v113 = v107;
        do
        {
          float32x4x2_t v201 = vld2q_f32(v112);
          v112 += 8;
          float32x4_t v186 = v201.val[1];
          float32x4_t v190 = vnegq_f32(v201.val[0]);
          float v196 = expf(v190.f32[1]);
          v114.f32[0] = expf(v190.f32[0]);
          v114.f32[1] = v196;
          float32x4_t v197 = v114;
          float v115 = expf(v190.f32[2]);
          float32x4_t v116 = v197;
          v116.f32[2] = v115;
          float32x4_t v198 = v116;
          float v117 = expf(v190.f32[3]);
          float32x4_t v118 = v198;
          v118.f32[3] = v117;
          float32x4_t v199 = v118;
          float32x4_t v191 = vnegq_f32(v186);
          float v183 = expf(v191.f32[1]);
          v119.f32[0] = expf(v191.f32[0]);
          v119.f32[1] = v183;
          float32x4_t v184 = v119;
          float v120 = expf(v191.f32[2]);
          float32x4_t v121 = v184;
          v121.f32[2] = v120;
          float32x4_t v185 = v121;
          float v122 = expf(v191.f32[3]);
          float32x4_t v123 = v185;
          v123.f32[3] = v122;
          float32x4_t v124 = v123;
          float32x4_t v125 = vdivq_f32(v179, vaddq_f32(v199, v123));
          v203.val[0] = vmulq_f32(v199, v125);
          v203.val[1] = vmulq_f32(v124, v125);
          vst2q_f32(v113, v203);
          v113 += 8;
          v111 -= 4;
        }
        while (v111);
        uint64_t v126 = v175;
        if (v177 == v175) {
          goto LABEL_115;
        }
      }
      else
      {
        uint64_t v126 = 0;
      }
      uint64_t v127 = v177 - v126;
      uint64_t v128 = (8 * v126) | 4;
      do
      {
        float v129 = expf(-*(const float *)((char *)v106 + v128 - 4));
        float v130 = expf(-*(const float *)((char *)v106 + v128));
        float v131 = 1.0 / (float)(v129 + v130);
        uint64_t v132 = (float *)((char *)v107 + v128);
        *(v132 - 1) = v129 * v131;
        *uint64_t v132 = v130 * v131;
        v128 += 8;
        --v127;
      }
      while (v127);
LABEL_115:
      ++v104;
      uint64_t v75 = v108;
      long long v107 = (float *)((char *)v107 + v108);
      double v72 = v171;
      uint64_t v73 = v173;
      int v106 = (const float *)((char *)v106 + v173);
      uint64_t v74 = v109;
    }
    while (v104 != v77);
  }
LABEL_11:
  uint64_t v18 = HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v18, *(void *)((char *)v158 + 20), *(void *)((char *)v158 + 28), *((unsigned int *)v158 + 4));
  uint64_t v155 = v18;
  std::string::size_type v151 = HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v151, *(void *)((char *)v158 + 20), *(void *)((char *)v158 + 28), *((unsigned int *)v158 + 4));
  if (!a11) {
    goto LABEL_57;
  }
  float32x4_t v19 = v158;
  unint64_t v20 = v154;
  float32x4_t v21 = v18;
  if (v153 == v152) {
    goto LABEL_59;
  }
  if (v157 == v156) {
    goto LABEL_58;
  }
  uint64_t v22 = 0;
  float32x4_t v23 = (const float *)*((void *)a3 + 10);
  uint64_t v24 = *((void *)a3 + 8);
  uint64_t v25 = (const float *)v18[10];
  unint64_t v167 = (const float *)v151[10];
  uint64_t v172 = v151[8];
  uint64_t v174 = v18[8];
  if (v154 <= 1) {
    uint64_t v26 = 1;
  }
  else {
    uint64_t v26 = v154;
  }
  if (v150 <= 1) {
    uint64_t v27 = 1;
  }
  else {
    uint64_t v27 = v150;
  }
  uint64_t v165 = 2 * v26;
  unint64_t v176 = v26;
  int64_t v163 = v23;
  uint64_t v164 = v26 & 0xFFFFFFFC;
  uint64_t v166 = (float *)v158[10];
  __asm { FMOV            V0.4S, #1.0 }
  float32x4_t v178 = _Q0;
  uint64_t v168 = v27;
  uint64_t v170 = v158[8];
  long long v161 = (const float *)v18[10];
  uint64_t v162 = v24;
  while (2)
  {
    uint64_t v160 = v22;
    uint64_t v33 = 0;
    int v34 = v23;
    uint64_t v35 = v25;
    double v36 = v166;
    GLuint v37 = v167;
    do
    {
      if (v176 < 4)
      {
        uint64_t v38 = 0;
LABEL_28:
        float v40 = a7;
        float v39 = a10;
LABEL_29:
        uint64_t v41 = v176 - v38;
        uint64_t v42 = (8 * v38) | 4;
        do
        {
          float v43 = (float)((float)(*(const float *)((char *)v35 + v42) * v40) - *(const float *)((char *)v34 + v42))
              + (float)(*(const float *)((char *)v37 + v42) * v39);
          float v44 = expf((float)((float)(*(const float *)((char *)v35 + v42 - 4) * v40)- *(const float *)((char *)v34 + v42 - 4))+ (float)(*(const float *)((char *)v37 + v42 - 4) * v39));
          float v45 = expf(v43);
          float v40 = a7;
          float v39 = a10;
          float v46 = 1.0 / (float)(v44 + v45);
          uint64_t v47 = (float *)((char *)v36 + v42);
          *(v47 - 1) = v44 * v46;
          *uint64_t v47 = v45 * v46;
          v42 += 8;
          --v41;
        }
        while (v41);
        goto LABEL_25;
      }
      uint64_t v38 = 0;
      unint64_t v48 = (unint64_t)v166 + v170 * v33;
      unint64_t v49 = (unint64_t)&v166[v165] + v170 * v33;
      BOOL v51 = v48 < (unint64_t)&v25[v165] + v174 * v33 && (unint64_t)v25 + v174 * v33 < v49;
      BOOL v53 = v48 < (unint64_t)&v167[v165] + v172 * v33 && (unint64_t)v167 + v172 * v33 < v49;
      BOOL v54 = (unint64_t)v23 + v24 * v33 >= v49 || v48 >= (unint64_t)&v23[v165] + v24 * v33;
      if (!v54 || v51) {
        goto LABEL_28;
      }
      float v40 = a7;
      float v39 = a10;
      if (v53) {
        goto LABEL_29;
      }
      uint64_t v55 = v164;
      int v56 = v34;
      uint64_t v57 = v35;
      uint64_t v58 = v37;
      uint64_t v59 = v36;
      do
      {
        float32x4x2_t v200 = vld2q_f32(v56);
        v56 += 8;
        float32x4x2_t v204 = vld2q_f32(v57);
        v57 += 8;
        float32x4x2_t v206 = vld2q_f32(v58);
        v58 += 8;
        float32x4_t v180 = vaddq_f32(vsubq_f32(vmulq_n_f32(v204.val[0], v40), v200.val[0]), vmulq_n_f32(v206.val[0], v39));
        float32x4_t v189 = vaddq_f32(vsubq_f32(vmulq_n_f32(v204.val[1], v40), v200.val[1]), vmulq_n_f32(v206.val[1], v39));
        float v192 = expf(v180.f32[1]);
        v60.f32[0] = expf(v180.f32[0]);
        v60.f32[1] = v192;
        float32x4_t v193 = v60;
        float v61 = expf(v180.f32[2]);
        float32x4_t v62 = v193;
        v62.f32[2] = v61;
        float32x4_t v194 = v62;
        float v63 = expf(v180.f32[3]);
        float32x4_t v64 = v194;
        v64.f32[3] = v63;
        float32x4_t v195 = v64;
        v180.i32[0] = expf(v189.f32[1]);
        v65.f32[0] = expf(v189.f32[0]);
        v65.i32[1] = v180.i32[0];
        float32x4_t v181 = v65;
        float v66 = expf(v189.f32[2]);
        float32x4_t v67 = v181;
        v67.f32[2] = v66;
        float32x4_t v182 = v67;
        float v68 = expf(v189.f32[3]);
        float v40 = a7;
        float v39 = a10;
        float32x4_t v69 = v182;
        v69.f32[3] = v68;
        float32x4_t v70 = v69;
        float32x4_t v71 = vdivq_f32(v178, vaddq_f32(v195, v69));
        v202.val[0] = vmulq_f32(v195, v71);
        v202.val[1] = vmulq_f32(v70, v71);
        vst2q_f32(v59, v202);
        v59 += 8;
        v55 -= 4;
      }
      while (v55);
      float32x4_t v23 = v163;
      uint64_t v38 = v164;
      uint64_t v25 = v161;
      uint64_t v24 = v162;
      if (v176 != v164) {
        goto LABEL_29;
      }
LABEL_25:
      ++v33;
      double v36 = (float *)((char *)v36 + v170);
      GLuint v37 = (const float *)((char *)v37 + v172);
      uint64_t v35 = (const float *)((char *)v35 + v174);
      int v34 = (const float *)((char *)v34 + v24);
    }
    while (v33 != v168);
    uint64_t v22 = v160 + 1;
    if (v160 + 1 != a11) {
      continue;
    }
    break;
  }
LABEL_57:
  float32x4_t v19 = v158;
  unint64_t v20 = v154;
  float32x4_t v21 = v155;
  if (v153 != v152)
  {
LABEL_58:
    if (v157 == v156) {
      goto LABEL_59;
    }
    uint64_t v89 = v19[10];
    uint64_t v90 = v19[8];
    uint64_t v91 = v150;
    uint64_t v92 = *((void *)a4 + 10);
    uint64_t v93 = *((void *)a4 + 8);
    if (v20 <= 1) {
      unint64_t v94 = 1;
    }
    else {
      unint64_t v94 = v20;
    }
    if (v150 <= 1) {
      uint64_t v91 = 1;
    }
    if (v94 < 8)
    {
      double v95 = (float *)(v89 + 28);
      double v96 = (float *)(v92 + 12);
      do
      {
        if (*(v95 - 7) <= *(v95 - 6)) {
          float v97 = 0.0;
        }
        else {
          float v97 = 1.0;
        }
        *(v96 - 3) = v97;
        if (v20 >= 2)
        {
          float v98 = *(v95 - 5) <= *(v95 - 4) ? 0.0 : 1.0;
          *(v96 - 2) = v98;
          if (v94 != 2)
          {
            float v99 = *(v95 - 3) <= *(v95 - 2) ? 0.0 : 1.0;
            *(v96 - 1) = v99;
            if (v94 != 3)
            {
              float v100 = *(v95 - 1) <= *v95 ? 0.0 : 1.0;
              *double v96 = v100;
              if (v94 != 4)
              {
                float v101 = v95[1] <= v95[2] ? 0.0 : 1.0;
                v96[1] = v101;
                if (v94 != 5)
                {
                  float v102 = v95[3] <= v95[4] ? 0.0 : 1.0;
                  v96[2] = v102;
                  if (v94 != 6)
                  {
                    if (v95[5] <= v95[6]) {
                      float v103 = 0.0;
                    }
                    else {
                      float v103 = 1.0;
                    }
                    v96[3] = v103;
                  }
                }
              }
            }
          }
        }
        double v95 = (float *)((char *)v95 + v90);
        double v96 = (float *)((char *)v96 + v93);
        --v91;
      }
      while (v91);
      goto LABEL_59;
    }
    uint64_t v133 = 0;
    uint64_t v134 = (const float *)(v89 + 32);
    unint64_t v135 = (int8x16_t *)(v92 + 16);
    __asm { FMOV            V0.4S, #1.0 }
    uint64_t v137 = v19[10];
    uint64_t v138 = *((void *)a4 + 10);
    while (2)
    {
      if (v92 + v93 * v133 >= v89 + 8 * v94 + v90 * v133 || v89 + v90 * v133 >= v92 + 4 * v94 + v93 * v133)
      {
        uint64_t v140 = v94 & 0xFFFFFFF8;
        int v141 = v135;
        char v142 = v134;
        do
        {
          std::string::size_type v143 = v142 - 8;
          float32x4x2_t v205 = vld2q_f32(v143);
          float32x4x2_t v207 = vld2q_f32(v142);
          v141[-1] = vandq_s8(_Q0, (int8x16_t)vcgtq_f32(v205.val[0], v205.val[1]));
          int8x16_t *v141 = vandq_s8(_Q0, (int8x16_t)vcgtq_f32(v207.val[0], v207.val[1]));
          v142 += 16;
          v141 += 2;
          v140 -= 8;
        }
        while (v140);
        uint64_t v144 = v94 & 0xFFFFFFF8;
        if (v94 != v144) {
          goto LABEL_137;
        }
      }
      else
      {
        uint64_t v144 = 0;
LABEL_137:
        uint64_t v145 = v94 - v144;
        uint64_t v146 = 8 * v144;
        unint64_t v147 = (float *)(v138 + 4 * v144);
        do
        {
          if (*(float *)(v137 + v146) <= *(float *)(v137 + v146 + 4)) {
            float v148 = 0.0;
          }
          else {
            float v148 = 1.0;
          }
          *v147++ = v148;
          v146 += 8;
          --v145;
        }
        while (v145);
      }
      ++v133;
      uint64_t v134 = (const float *)((char *)v134 + v90);
      unint64_t v135 = (int8x16_t *)((char *)v135 + v93);
      v138 += v93;
      v137 += v90;
      if (v133 == v91) {
        break;
      }
      continue;
    }
  }
LABEL_59:
  if (v151) {
    (*(void (**)(void *))(*v151 + 24))(v151);
  }
  if (v21) {
    (*(void (**)(void *))(*v21 + 24))(v21);
  }
  if (v19) {
    (*(void (**)(void *))(*v19 + 24))(v19);
  }
  return 0;
}

void sub_1B775FBB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 24))(a14);
  }
  (*(void (**)(void *))(*(void *)a16 + 24))(a16);
  _Unwind_Resume(a1);
}

uint64_t HGComputeDevice::HGComputeDevice()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  *(void *)uint64_t v0 = &unk_1F10D4308;
  *(_DWORD *)(v0 + 8) = v1;
  *(_OWORD *)(v0 + 16) = 0u;
  float v2 = (std::string *)(v0 + 40);
  *(_OWORD *)(v0 + 32) = 0u;
  *(_OWORD *)(v0 + 48) = 0u;
  if (!gethostname(v4.sysname, 0x1000uLL))
  {
    char v5 = 0;
    MEMORY[0x1BA9BF660](v0 + 16, &v4);
    if (uname(&v4)) {
      goto LABEL_6;
    }
    goto LABEL_9;
  }
  if (*(char *)(v0 + 39) < 0)
  {
    **(unsigned char **)(v0 + 16) = 0;
    *(void *)(v0 + 24) = 0;
    if (uname(&v4)) {
      goto LABEL_6;
    }
LABEL_9:
    MEMORY[0x1BA9BF660](v2, &v4);
    std::string::push_back(v2, 32);
    std::string::append(v2, v4.release);
    std::string::push_back(v2, 32);
    std::string::append(v2, v4.machine);
    std::string::push_back(v2, 32);
    std::string::append(v2, v4.version);
    return v0;
  }
  *(unsigned char *)(v0 + 16) = 0;
  *(unsigned char *)(v0 + 39) = 0;
  if (!uname(&v4)) {
    goto LABEL_9;
  }
LABEL_6:
  if (*(char *)(v0 + 63) < 0)
  {
    **(unsigned char **)(v0 + 40) = 0;
    *(void *)(v0 + 48) = 0;
  }
  else
  {
    *(unsigned char *)(v0 + 40) = 0;
    *(unsigned char *)(v0 + 63) = 0;
  }
  return v0;
}

void sub_1B775FE30(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 63) < 0)
  {
    operator delete(*v3);
    if ((*(char *)(v1 + 39) & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((*(char *)(v1 + 39) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void HGCPUComputeDevice::HGCPUComputeDevice(HGCPUComputeDevice *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = HGComputeDevice::HGComputeDevice();
  *(void *)uint64_t v2 = &unk_1F10D4328;
  *(_OWORD *)(v2 + 64) = 0u;
  uint64_t v3 = v2 + 64;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(void *)(v2 + 112) = 0;
  utsname v4 = macho_arch_name_for_mach_header(0);
  if (v4) {
    char v5 = v4;
  }
  else {
    char v5 = "(unknown)";
  }
  MEMORY[0x1BA9BF660](v3, v5);
  LODWORD(v6) = 0;
  size_t v7 = 4;
  sysctlbyname("hw.physicalcpu", &v6, &v7, 0, 0);
  *((_DWORD *)this + 22) = v6;
  LODWORD(v6) = 0;
  size_t v7 = 4;
  sysctlbyname("hw.activecpu", &v6, &v7, 0, 0);
  *((_DWORD *)this + 23) = v6;
  size_t v6 = 8;
  size_t v7 = 0;
  *(void *)uint64_t v8 = 0x1800000006;
  sysctl(v8, 2u, &v7, &v6, 0, 0);
  *((void *)this + 12) = v7;
  size_t v6 = 8;
  size_t v7 = 0;
  sysctlbyname("hw.l1dcachesize", &v7, &v6, 0, 0);
  *((void *)this + 13) = v7;
  size_t v6 = 8;
  size_t v7 = 0;
  sysctlbyname("hw.l2cachesize", &v7, &v6, 0, 0);
  *((void *)this + 14) = v7;
}

void sub_1B7760014(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 87) < 0) {
    operator delete(*v2);
  }
  HGComputeDevice::~HGComputeDevice((void **)v1);
  _Unwind_Resume(a1);
}

void HGComputeDevice::~HGComputeDevice(void **this)
{
  *this = &unk_1F10D4308;
  if ((*((char *)this + 63) & 0x80000000) == 0)
  {
    if ((*((char *)this + 39) & 0x80000000) == 0) {
      return;
    }
LABEL_5:
    operator delete(this[2]);
    return;
  }
  operator delete(this[5]);
  if (*((char *)this + 39) < 0) {
    goto LABEL_5;
  }
}

{
  uint64_t vars8;

  *this = &unk_1F10D4308;
  if (*((char *)this + 63) < 0)
  {
    operator delete(this[5]);
    if ((*((char *)this + 39) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((*((char *)this + 39) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[2]);
LABEL_3:

  JUMPOUT(0x1BA9BFBA0);
}

void *HGGPUComputeDevice::HGGPUComputeDevice(void *a1, void *a2)
{
  uint64_t v4 = HGComputeDevice::HGComputeDevice();
  *(void *)uint64_t v4 = &unk_1F10D4348;
  *(void *)(v4 + 64) = 0;
  uint64_t v5 = v4 + 64;
  *(void *)(v4 + 96) = 0;
  *(void *)(v4 + 72) = 0;
  *(void *)(v4 + 80) = 0;
  *(_DWORD *)(v4 + 88) = 0;
  *(_DWORD *)(v4 + 104) = -1;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 139) = 0u;
  *(unsigned char *)(v4 + 155) = 1;
  *(void *)(v4 + 120) = a2;
  id v6 = a2;
  DeviceInfo = (id *)HGMetalDeviceInfo::getDeviceInfo(a1[15]);
  a1[16] = DeviceInfo;
  uint64_t v8 = HGMetalDeviceInfo::name(DeviceInfo);
  MEMORY[0x1BA9BF660](v5, v8);
  uint64_t v9 = a1[16];
  a1[12] = *(void *)(v9 + 24);
  a1[14] = *(void *)(v9 + 40);
  return a1;
}

void sub_1B776016C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 87) < 0) {
    operator delete(*v2);
  }
  HGComputeDevice::~HGComputeDevice((void **)v1);
  _Unwind_Resume(a1);
}

void HGGPUComputeDevice::~HGGPUComputeDevice(HGGPUComputeDevice *this)
{
  uint64_t v2 = (void *)*((void *)this + 15);
  if (v2) {

  }
  if (*((char *)this + 87) < 0)
  {
    operator delete(*((void **)this + 8));
    *(void *)this = &unk_1F10D4308;
    if ((*((char *)this + 63) & 0x80000000) == 0)
    {
LABEL_5:
      if ((*((char *)this + 39) & 0x80000000) == 0) {
        return;
      }
LABEL_9:
      operator delete(*((void **)this + 2));
      return;
    }
  }
  else
  {
    *(void *)this = &unk_1F10D4308;
    if ((*((char *)this + 63) & 0x80000000) == 0) {
      goto LABEL_5;
    }
  }
  operator delete(*((void **)this + 5));
  if (*((char *)this + 39) < 0) {
    goto LABEL_9;
  }
}

{
  void *v2;
  uint64_t vars8;

  uint64_t v2 = (void *)*((void *)this + 15);
  if (v2) {

  }
  if (*((char *)this + 87) < 0)
  {
    operator delete(*((void **)this + 8));
    *(void *)this = &unk_1F10D4308;
    if ((*((char *)this + 63) & 0x80000000) == 0)
    {
LABEL_5:
      if ((*((char *)this + 39) & 0x80000000) == 0) {
        goto LABEL_6;
      }
LABEL_11:
      operator delete(*((void **)this + 2));
LABEL_6:
      JUMPOUT(0x1BA9BFBA0);
    }
  }
  else
  {
    *(void *)this = &unk_1F10D4308;
    if ((*((char *)this + 63) & 0x80000000) == 0) {
      goto LABEL_5;
    }
  }
  operator delete(*((void **)this + 5));
  if ((*((char *)this + 39) & 0x80000000) == 0) {
    goto LABEL_6;
  }
  goto LABEL_11;
}

uint64_t HGGPUComputeDevice::GetGLVirtualScreen(HGGPUComputeDevice *this)
{
  uint64_t result = *((unsigned int *)this + 26);
  if (result == -1)
  {
    uint64_t result = 0;
    *((_DWORD *)this + 26) = 0;
  }
  return result;
}

void HGComputeDeviceManager::GetCPUComputeDevice(HGComputeDeviceManager *this@<X0>, void *a2@<X8>)
{
  HG_RENDERER_ENV::Init(this);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1F50, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1F50))
  {
    qword_1EB9A1F68 = 0;
    unk_1EB9A1F70 = 0;
    qword_1EB9A1F60 = 0;
    __cxa_atexit((void (*)(void *))std::vector<std::shared_ptr<HGComputeDevice const>>::~vector[abi:ne180100], &qword_1EB9A1F60, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A1F50);
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&_MergedGlobals_9, memory_order_acquire) != -1)
  {
    float32x4_t v10 = &v8;
    uint64_t v9 = &v10;
    std::__call_once(&_MergedGlobals_9, &v9, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<CreateComputeDeviceList(void)::$_0 &&>>);
  }
  uint64_t v3 = qword_1EB9A1F60;
  uint64_t v4 = qword_1EB9A1F68;
  if (qword_1EB9A1F60 == qword_1EB9A1F68)
  {
LABEL_12:
    *a2 = 0;
    a2[1] = 0;
    return;
  }
  while (1)
  {
    uint64_t v5 = *(_DWORD **)v3;
    id v6 = *(std::__shared_weak_count **)(v3 + 8);
    if (v6) {
      break;
    }
    if (!v5[2]) {
      goto LABEL_14;
    }
LABEL_7:
    v3 += 16;
    if (v3 == v4) {
      goto LABEL_12;
    }
  }
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  if (v5[2])
  {
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    goto LABEL_7;
  }
LABEL_14:
  if (v7)
  {
    *a2 = v7;
    a2[1] = v6;
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_18:
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    if (v6) {
      goto LABEL_18;
    }
  }
}

uint64_t *HGComputeDeviceManager::GetGPUComputeDeviceList(HGComputeDeviceManager *this)
{
  return &qword_1EB9A1F78;
}

void GetSortedGPUDeviceList(HG_RENDERER_ENV *a1)
{
  HG_RENDERER_ENV::Init(a1);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1F50, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1F50))
  {
    qword_1EB9A1F68 = 0;
    unk_1EB9A1F70 = 0;
    qword_1EB9A1F60 = 0;
    __cxa_atexit((void (*)(void *))std::vector<std::shared_ptr<HGComputeDevice const>>::~vector[abi:ne180100], &qword_1EB9A1F60, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A1F50);
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&_MergedGlobals_9, memory_order_acquire) != -1)
  {
    uint64_t v3 = &v1;
    uint64_t v2 = &v3;
    std::__call_once(&_MergedGlobals_9, &v2, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<CreateComputeDeviceList(void)::$_0 &&>>);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1F58, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1EB9A1F58))
    {
      qword_1EB9A1F80 = 0;
      unk_1EB9A1F88 = 0;
      qword_1EB9A1F78 = 0;
      __cxa_atexit((void (*)(void *))std::vector<std::shared_ptr<HGGPUComputeDevice const>>::~vector[abi:ne180100], &qword_1EB9A1F78, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1F58);
    }
  }
}

void HGComputeDeviceManager::GetGPUComputeDeviceForCGLVirtualScreen(HGComputeDeviceManager *this@<X0>, void *a2@<X8>)
{
  int v2 = (int)this;
  GetSortedGPUDeviceList(this);
  uint64_t v4 = (void *)qword_1EB9A1F78;
  uint64_t v5 = qword_1EB9A1F80;
  if (qword_1EB9A1F78 == qword_1EB9A1F80)
  {
LABEL_6:
    *a2 = 0;
    a2[1] = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v6 = *v4;
      int v7 = *(_DWORD *)(*v4 + 104);
      if (v7 == -1)
      {
        int v7 = 0;
        *(_DWORD *)(v6 + 104) = 0;
      }
      if (v7 == v2) {
        break;
      }
      v4 += 2;
      if (v4 == (void *)v5) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = v4[1];
    *a2 = v6;
    a2[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
  }
}

void HGCPUComputeDevice::~HGCPUComputeDevice(void **this)
{
  if (*((char *)this + 87) < 0)
  {
    operator delete(this[8]);
    *this = &unk_1F10D4308;
    if ((*((char *)this + 63) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 39) & 0x80000000) == 0) {
        return;
      }
LABEL_7:
      operator delete(this[2]);
      return;
    }
  }
  else
  {
    *this = &unk_1F10D4308;
    if ((*((char *)this + 63) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  operator delete(this[5]);
  if (*((char *)this + 39) < 0) {
    goto LABEL_7;
  }
}

{
  uint64_t vars8;

  if (*((char *)this + 87) < 0)
  {
    operator delete(this[8]);
    *this = &unk_1F10D4308;
    if ((*((char *)this + 63) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 39) & 0x80000000) == 0) {
        goto LABEL_4;
      }
LABEL_9:
      operator delete(this[2]);
LABEL_4:
      JUMPOUT(0x1BA9BFBA0);
    }
  }
  else
  {
    *this = &unk_1F10D4308;
    if ((*((char *)this + 63) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  operator delete(this[5]);
  if ((*((char *)this + 39) & 0x80000000) == 0) {
    goto LABEL_4;
  }
  goto LABEL_9;
}

void **std::vector<std::shared_ptr<HGComputeDevice const>>::~vector[abi:ne180100](void **a1)
{
  int v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<CreateComputeDeviceList(void)::$_0 &&>>()
{
  uint64_t v0 = (std::__shared_weak_count *)operator new(0x90uLL);
  v0->__shared_owners_ = 0;
  v0->__shared_weak_owners_ = 0;
  v0->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10D4398;
  HGCPUComputeDevice::HGCPUComputeDevice((HGCPUComputeDevice *)&v0[1]);
  *(void *)&long long v20 = v1;
  *((void *)&v20 + 1) = v0;
  atomic_fetch_add_explicit(&v0->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v2 = qword_1EB9A1F68;
  if ((unint64_t)qword_1EB9A1F68 >= unk_1EB9A1F70)
  {
    uint64_t v3 = std::vector<std::shared_ptr<HGComputeDevice const>>::__push_back_slow_path<std::shared_ptr<HGComputeDevice const>>((char **)&qword_1EB9A1F60, (uint64_t)&v20);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)&v20 + 1);
    qword_1EB9A1F68 = (uint64_t)v3;
    if (*((void *)&v20 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v20 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  else
  {
    *(void *)qword_1EB9A1F68 = v1;
    *(void *)(v2 + 8) = v0;
    qword_1EB9A1F68 = v2 + 16;
  }
  id v5 = MTLCreateSystemDefaultDevice();
  if (v5)
  {
    uint64_t v6 = (std::__shared_weak_count *)operator new(0xB8uLL);
    v6->__shared_owners_ = 0;
    v6->__shared_weak_owners_ = 0;
    v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10D43E8;
    int v7 = HGGPUComputeDevice::HGGPUComputeDevice(&v6[1].__vftable, v5);
    *(void *)&long long v20 = v7;
    *((void *)&v20 + 1) = v6;
    uint64_t v18 = v7;
    float32x4_t v19 = v6;
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v8 = qword_1EB9A1F68;
    if ((unint64_t)qword_1EB9A1F68 >= unk_1EB9A1F70)
    {
      uint64_t v9 = std::vector<std::shared_ptr<HGComputeDevice const>>::__push_back_slow_path<std::shared_ptr<HGComputeDevice const>>((char **)&qword_1EB9A1F60, (uint64_t)&v18);
      float32x4_t v10 = v19;
      qword_1EB9A1F68 = (uint64_t)v9;
      if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    else
    {
      *(void *)qword_1EB9A1F68 = v7;
      *(void *)(v8 + 8) = v6;
      qword_1EB9A1F68 = v8 + 16;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1F58, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A1F58))
    {
      qword_1EB9A1F80 = 0;
      unk_1EB9A1F88 = 0;
      qword_1EB9A1F78 = 0;
      __cxa_atexit((void (*)(void *))std::vector<std::shared_ptr<HGGPUComputeDevice const>>::~vector[abi:ne180100], &qword_1EB9A1F78, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1F58);
    }
    uint64_t v11 = qword_1EB9A1F80;
    if ((unint64_t)qword_1EB9A1F80 >= unk_1EB9A1F88)
    {
      float v13 = std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__push_back_slow_path<std::shared_ptr<HGGPUComputeDevice const> const&>((uint64_t)&qword_1EB9A1F78, &v20);
    }
    else
    {
      *(void *)qword_1EB9A1F80 = v20;
      uint64_t v12 = *((void *)&v20 + 1);
      *(void *)(v11 + 8) = *((void *)&v20 + 1);
      if (v12) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
      }
      float v13 = (_OWORD *)(v11 + 16);
    }
    qword_1EB9A1F80 = (uint64_t)v13;

    int v14 = (std::__shared_weak_count *)*((void *)&v20 + 1);
    if (*((void *)&v20 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v20 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1F58, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1F58))
  {
    qword_1EB9A1F80 = 0;
    unk_1EB9A1F88 = 0;
    qword_1EB9A1F78 = 0;
    __cxa_atexit((void (*)(void *))std::vector<std::shared_ptr<HGGPUComputeDevice const>>::~vector[abi:ne180100], &qword_1EB9A1F78, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A1F58);
  }
  int v15 = (uint64_t *)qword_1EB9A1F78;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1F58, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1F58))
  {
    qword_1EB9A1F80 = 0;
    unk_1EB9A1F88 = 0;
    qword_1EB9A1F78 = 0;
    __cxa_atexit((void (*)(void *))std::vector<std::shared_ptr<HGGPUComputeDevice const>>::~vector[abi:ne180100], &qword_1EB9A1F78, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A1F58);
  }
  unint64_t v16 = 126 - 2 * __clz((qword_1EB9A1F80 - (uint64_t)v15) >> 4);
  if ((uint64_t *)qword_1EB9A1F80 == v15) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = v16;
  }
  std::__introsort<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *,false>(v15, (uint64_t *)qword_1EB9A1F80, (uint64_t)&v20, v17, 1);
  if (!atomic_fetch_add(&v0->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v0->__on_zero_shared)(v0);
    std::__shared_weak_count::__release_weak(v0);
  }
}

void sub_1B7760DC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__call_once_proxy[abi:ne180100]<std::tuple<CreateComputeDeviceList(void)::$_0 &&>>(a10);
  }
  if (a12 && !atomic_fetch_add(&a12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
    std::__shared_weak_count::__release_weak(a12);
  }
  if (!atomic_fetch_add(v13, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<HGCPUComputeDevice>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10D4398;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HGCPUComputeDevice>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10D4398;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::__shared_ptr_emplace<HGCPUComputeDevice>::__on_zero_shared(uint64_t a1)
{
  if ((*(char *)(a1 + 111) & 0x80000000) == 0)
  {
    *(void *)(a1 + 24) = &unk_1F10D4308;
    if ((*(char *)(a1 + 87) & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    operator delete(*(void **)(a1 + 64));
    if ((*(char *)(a1 + 63) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_7;
  }
  operator delete(*(void **)(a1 + 88));
  *(void *)(a1 + 24) = &unk_1F10D4308;
  if (*(char *)(a1 + 87) < 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((*(char *)(a1 + 63) & 0x80000000) == 0) {
    return;
  }
LABEL_7:
  uint64_t v2 = *(void **)(a1 + 40);

  operator delete(v2);
}

char *std::vector<std::shared_ptr<HGComputeDevice const>>::__push_back_slow_path<std::shared_ptr<HGComputeDevice const>>(char **a1, uint64_t a2)
{
  uint64_t v3 = (a1[1] - *a1) >> 4;
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v5 = a1[2] - *a1;
  if (v5 >> 3 > v4) {
    unint64_t v4 = v5 >> 3;
  }
  BOOL v6 = (unint64_t)v5 >= 0x7FFFFFFFFFFFFFF0;
  unint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
  if (!v6) {
    unint64_t v7 = v4;
  }
  if (v7 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v9 = 16 * v7;
  float32x4_t v10 = (char *)operator new(16 * v7);
  uint64_t v11 = &v10[16 * v3];
  *(_OWORD *)uint64_t v11 = *(_OWORD *)a2;
  uint64_t v12 = v11 + 16;
  float v13 = &v10[v9];
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  int v14 = *a1;
  int v15 = a1[1];
  if (v15 == *a1)
  {
    *a1 = v11;
    a1[1] = v12;
    a1[2] = v13;
    if (!v15) {
      return v12;
    }
    goto LABEL_17;
  }
  do
  {
    long long v16 = *((_OWORD *)v15 - 1);
    v15 -= 16;
    *((_OWORD *)v11 - 1) = v16;
    v11 -= 16;
    *(void *)int v15 = 0;
    *((void *)v15 + 1) = 0;
  }
  while (v15 != v14);
  uint64_t v17 = *a1;
  int v15 = a1[1];
  *a1 = v11;
  a1[1] = v12;
  a1[2] = v13;
  if (v15 != v17)
  {
    do
    {
      uint64_t v18 = (std::__shared_weak_count *)*((void *)v15 - 1);
      if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
      v15 -= 16;
    }
    while (v15 != v17);
    int v15 = v17;
  }
  if (v15) {
LABEL_17:
  }
    operator delete(v15);
  return v12;
}

void std::__shared_ptr_emplace<HGGPUComputeDevice>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10D43E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HGGPUComputeDevice>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10D43E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::__shared_ptr_emplace<HGGPUComputeDevice>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 144);
  if (v2) {

  }
  if ((*(char *)(a1 + 111) & 0x80000000) == 0)
  {
    *(void *)(a1 + 24) = &unk_1F10D4308;
    if ((*(char *)(a1 + 87) & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_8:
    operator delete(*(void **)(a1 + 64));
    if ((*(char *)(a1 + 63) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_9;
  }
  operator delete(*(void **)(a1 + 88));
  *(void *)(a1 + 24) = &unk_1F10D4308;
  if (*(char *)(a1 + 87) < 0) {
    goto LABEL_8;
  }
LABEL_5:
  if ((*(char *)(a1 + 63) & 0x80000000) == 0) {
    return;
  }
LABEL_9:
  uint64_t v3 = *(void **)(a1 + 40);

  operator delete(v3);
}

void **std::vector<std::shared_ptr<HGGPUComputeDevice const>>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    unint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      unint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

_OWORD *std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__push_back_slow_path<std::shared_ptr<HGGPUComputeDevice const> const&>(uint64_t a1, long long *a2)
{
  uint64_t v3 = *(void **)a1;
  unint64_t v4 = *(void **)(a1 + 8);
  uint64_t v5 = ((uint64_t)v4 - *(void *)a1) >> 4;
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = *(void *)(a1 + 16) - (void)v3;
  if (v7 >> 3 > v6) {
    unint64_t v6 = v7 >> 3;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
  }
  if (v6 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v9 = 16 * v6;
  float32x4_t v10 = (char *)operator new(16 * v6);
  uint64_t v11 = &v10[16 * v5];
  long long v12 = *a2;
  *(_OWORD *)uint64_t v11 = *a2;
  if (*((void *)&v12 + 1))
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v12 + 1) + 8), 1uLL, memory_order_relaxed);
    uint64_t v3 = *(void **)a1;
    unint64_t v4 = *(void **)(a1 + 8);
  }
  float v13 = &v10[v9];
  int v14 = v11 + 16;
  if (v4 == v3)
  {
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v14;
    *(void *)(a1 + 16) = v13;
    if (!v3) {
      return v14;
    }
    goto LABEL_19;
  }
  do
  {
    long long v15 = *((_OWORD *)v4 - 1);
    v4 -= 2;
    *((_OWORD *)v11 - 1) = v15;
    v11 -= 16;
    *unint64_t v4 = 0;
    v4[1] = 0;
  }
  while (v4 != v3);
  long long v16 = *(void **)a1;
  uint64_t v3 = *(void **)(a1 + 8);
  *(void *)a1 = v11;
  *(void *)(a1 + 8) = v14;
  *(void *)(a1 + 16) = v13;
  if (v3 != v16)
  {
    do
    {
      uint64_t v17 = (std::__shared_weak_count *)*(v3 - 1);
      if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
      v3 -= 2;
    }
    while (v3 != v16);
    uint64_t v3 = v16;
  }
  if (v3) {
LABEL_19:
  }
    operator delete(v3);
  return v14;
}

void std::__introsort<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
void std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(void *a1, void *a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = a1 + 2;
    if (a1 + 2 != a2)
    {
      uint64_t v5 = 0;
      char v6 = a1;
      do
      {
        uint64_t v7 = v6;
        char v6 = v4;
        uint64_t v8 = v7[2];
        uint64_t v9 = *v7;
        if (*(void *)(v8 + 112) > *(void *)(*v7 + 112))
        {
          uint64_t v10 = v7[3];
          uint64_t v11 = v5;
          void *v6 = 0;
          v6[1] = 0;
          while (1)
          {
            long long v12 = (void *)((char *)a1 + v11);
            uint64_t v13 = *(void *)((char *)a1 + v11 + 8);
            *long long v12 = 0;
            v12[1] = 0;
            uint64_t v14 = *(std::__shared_weak_count **)((char *)a1 + v11 + 24);
            v12[2] = v9;
            void v12[3] = v13;
            if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
              std::__shared_weak_count::__release_weak(v14);
            }
            if (!v11) {
              break;
            }
            uint64_t v9 = *(void *)((char *)a1 + v11 - 16);
            v11 -= 16;
            if (*(void *)(v8 + 112) <= *(void *)(v9 + 112))
            {
              unint64_t v15 = (void *)((char *)a1 + v11 + 16);
              uint64_t v16 = *(std::__shared_weak_count **)((char *)a1 + v11 + 24);
              void *v15 = v8;
              v15[1] = v10;
              if (!v16) {
                goto LABEL_4;
              }
              goto LABEL_15;
            }
          }
          uint64_t v16 = (std::__shared_weak_count *)a1[1];
          *a1 = v8;
          a1[1] = v10;
          if (!v16) {
            goto LABEL_4;
          }
LABEL_15:
          if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
        }
LABEL_4:
        unint64_t v4 = v6 + 2;
        v5 += 16;
      }
      while (v6 + 2 != a2);
    }
  }
}

void std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(void *a1, void *a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = a1;
    unint64_t v4 = a1 + 2;
    if (a1 + 2 != a2)
    {
      uint64_t v5 = (std::__shared_weak_count **)(a1 + 3);
      do
      {
        char v6 = (std::__shared_weak_count **)v3;
        uint64_t v3 = v4;
        uint64_t v7 = v6[2];
        uint64_t v8 = *v6;
        if (v7[4].__shared_weak_owners_ > (unint64_t)(*v6)[4].__shared_weak_owners_)
        {
          uint64_t v9 = v6[3];
          uint64_t v10 = v5;
          *uint64_t v3 = 0;
          v3[1] = 0;
          do
          {
            uint64_t v11 = *(v10 - 2);
            *(v10 - 3) = 0;
            *(v10 - 2) = 0;
            long long v12 = *v10;
            *(v10 - 1) = v8;
            char *v10 = v11;
            if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
              std::__shared_weak_count::__release_weak(v12);
            }
            uint64_t v8 = *(v10 - 5);
            v10 -= 2;
          }
          while (v7[4].__shared_weak_owners_ > (unint64_t)v8[4].__shared_weak_owners_);
          uint64_t v13 = *v10;
          *(v10 - 1) = v7;
          char *v10 = v9;
          if (v13)
          {
            if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
              std::__shared_weak_count::__release_weak(v13);
            }
          }
        }
        unint64_t v4 = v3 + 2;
        v5 += 2;
      }
      while (v3 + 2 != a2);
    }
  }
}

uint64_t *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::shared_ptr<HGGPUComputeDevice const> *,SortGPUDevices &>(long long *a1, uint64_t *a2)
{
  long long v2 = *a1;
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  unint64_t v3 = *(void *)(v2 + 112);
  if (v3 <= *(void *)(*(a2 - 2) + 112))
  {
    char v6 = (uint64_t *)(a1 + 1);
    do
    {
      unint64_t v4 = v6;
      if (v6 >= a2) {
        break;
      }
      v6 += 2;
    }
    while (v3 <= *(void *)(*v4 + 112));
  }
  else
  {
    unint64_t v4 = (uint64_t *)a1;
    do
    {
      uint64_t v5 = v4[2];
      v4 += 2;
    }
    while (v3 <= *(void *)(v5 + 112));
  }
  if (v4 < a2)
  {
    do
    {
      uint64_t v7 = *(a2 - 2);
      a2 -= 2;
    }
    while (v3 > *(void *)(v7 + 112));
  }
  if (v4 < a2)
  {
    uint64_t v8 = *v4;
    uint64_t v9 = *a2;
    do
    {
      *unint64_t v4 = v9;
      *a2 = v8;
      uint64_t v10 = v4[1];
      v4[1] = a2[1];
      a2[1] = v10;
      do
      {
        uint64_t v11 = v4[2];
        v4 += 2;
        uint64_t v8 = v11;
      }
      while (v3 <= *(void *)(v11 + 112));
      do
      {
        uint64_t v12 = *(a2 - 2);
        a2 -= 2;
        uint64_t v9 = v12;
      }
      while (v3 > *(void *)(v12 + 112));
    }
    while (v4 < a2);
  }
  uint64_t v13 = (long long *)(v4 - 2);
  if (v4 - 2 != (uint64_t *)a1)
  {
    long long v14 = *v13;
    *(void *)uint64_t v13 = 0;
    *(v4 - 1) = 0;
    unint64_t v15 = (std::__shared_weak_count *)*((void *)a1 + 1);
    *a1 = v14;
    if (v15)
    {
      if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        long long v18 = v2;
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
        long long v2 = v18;
      }
    }
  }
  uint64_t v16 = (std::__shared_weak_count *)*(v4 - 1);
  *((_OWORD *)v4 - 1) = v2;
  if (!v16 || atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return v4;
  }
  ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
  std::__shared_weak_count::__release_weak(v16);
  return v4;
}

long long *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::shared_ptr<HGGPUComputeDevice const> *,SortGPUDevices &>(long long *a1, long long *a2)
{
  uint64_t v3 = 0;
  long long v4 = *a1;
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  unint64_t v5 = *(void *)(v4 + 112);
  do
    uint64_t v6 = *(void *)&a1[++v3];
  while (*(void *)(v6 + 112) > v5);
  unint64_t v7 = (unint64_t)&a1[v3];
  if (v3 == 1)
  {
    do
    {
      if (v7 >= (unint64_t)a2) {
        break;
      }
      uint64_t v9 = *((void *)a2-- - 2);
    }
    while (*(void *)(v9 + 112) <= v5);
  }
  else
  {
    do
      uint64_t v8 = *((void *)a2-- - 2);
    while (*(void *)(v8 + 112) <= v5);
  }
  if (v7 >= (unint64_t)a2)
  {
    uint64_t v11 = &a1[v3];
    uint64_t v16 = (long long *)(v7 - 16);
    if ((long long *)(v7 - 16) == a1) {
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v10 = *(void *)a2;
    uint64_t v11 = &a1[v3];
    uint64_t v12 = a2;
    do
    {
      *(void *)uint64_t v11 = v10;
      *(void *)uint64_t v12 = v6;
      uint64_t v13 = *((void *)v11 + 1);
      *((void *)v11 + 1) = *((void *)v12 + 1);
      *((void *)v12 + 1) = v13;
      do
      {
        uint64_t v14 = *((void *)v11++ + 2);
        uint64_t v6 = v14;
      }
      while (*(void *)(v14 + 112) > v5);
      do
      {
        uint64_t v15 = *((void *)v12-- - 2);
        uint64_t v10 = v15;
      }
      while (*(void *)(v15 + 112) <= v5);
    }
    while (v11 < v12);
    uint64_t v16 = v11 - 1;
    if (v11 - 1 == a1) {
      goto LABEL_20;
    }
  }
  long long v17 = *v16;
  *(void *)uint64_t v16 = 0;
  *((void *)v16 + 1) = 0;
  long long v18 = (std::__shared_weak_count *)*((void *)a1 + 1);
  *a1 = v17;
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    long long v21 = v4;
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
    long long v4 = v21;
  }
LABEL_20:
  uint64_t v19 = (std::__shared_weak_count *)*((void *)v11 - 1);
  *(v11 - 1) = v4;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  return v16;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 2);
      uint64_t v7 = *a1;
      if (*(void *)(v6 + 112) > *(void *)(*a1 + 112))
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        uint64_t v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      uint64_t v9 = a1[2];
      unint64_t v10 = *(void *)(v9 + 112);
      uint64_t v11 = *a1;
      unint64_t v12 = *(void *)(*a1 + 112);
      uint64_t v13 = *(a2 - 2);
      unint64_t v14 = *(void *)(v13 + 112);
      if (v10 > v12)
      {
        if (v14 <= v10)
        {
          uint64_t v15 = a1 + 3;
          uint64_t v43 = a1[3];
          uint64_t v44 = a1[1];
          *a1 = v9;
          a1[1] = v43;
          a1[2] = v11;
          a1[3] = v44;
          uint64_t v45 = *(a2 - 2);
          if (*(void *)(v45 + 112) <= v12) {
            return result;
          }
          a1[2] = v45;
        }
        else
        {
          uint64_t v15 = a1 + 1;
          *a1 = v13;
        }
        *(a2 - 2) = v11;
        uint64_t v37 = a2 - 1;
        goto LABEL_25;
      }
      if (v14 > v10)
      {
        a1[2] = v13;
        *(a2 - 2) = v9;
        uint64_t v37 = a1 + 3;
        uint64_t v36 = a1[3];
        a1[3] = *(a2 - 1);
        *(a2 - 1) = v36;
        uint64_t v38 = a1[2];
        uint64_t v39 = *a1;
        if (*(void *)(v38 + 112) > *(void *)(*a1 + 112))
        {
          *a1 = v38;
          a1[2] = v39;
          uint64_t v15 = a1 + 1;
LABEL_25:
          uint64_t v46 = *v15;
          uint64_t *v15 = *v37;
          *uint64_t v37 = v46;
          return result;
        }
      }
      return result;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(a1, a1 + 2, a1 + 4, a1 + 6);
      uint64_t v24 = *(a2 - 2);
      uint64_t v25 = a1[6];
      if (*(void *)(v24 + 112) > *(void *)(v25 + 112))
      {
        a1[6] = v24;
        *(a2 - 2) = v25;
        uint64_t v26 = a1[7];
        a1[7] = *(a2 - 1);
        *(a2 - 1) = v26;
        uint64_t v27 = a1[6];
        unint64_t v28 = *(void *)(v27 + 112);
        uint64_t v29 = a1[4];
        if (v28 > *(void *)(v29 + 112))
        {
          uint64_t v30 = a1[5];
          uint64_t v31 = a1[7];
          a1[4] = v27;
          a1[5] = v31;
          a1[6] = v29;
          a1[7] = v30;
          uint64_t v32 = a1[2];
          if (v28 > *(void *)(v32 + 112))
          {
            uint64_t v33 = a1[3];
            a1[2] = v27;
            a1[3] = v31;
            a1[4] = v32;
            a1[5] = v33;
            uint64_t v34 = *a1;
            if (v28 > *(void *)(*a1 + 112))
            {
              uint64_t v35 = a1[1];
              *a1 = v27;
              a1[1] = v31;
              a1[2] = v34;
              a1[3] = v35;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v16 = a1 + 4;
      uint64_t v17 = a1[4];
      uint64_t v18 = a1[2];
      unint64_t v19 = *(void *)(v18 + 112);
      uint64_t v20 = *a1;
      unint64_t v21 = *(void *)(*a1 + 112);
      unint64_t v22 = *(void *)(v17 + 112);
      if (v19 > v21)
      {
        if (v22 <= v19)
        {
          uint64_t v23 = a1 + 3;
          uint64_t v47 = a1[3];
          uint64_t v48 = a1[1];
          *a1 = v18;
          a1[1] = v47;
          a1[2] = v20;
          a1[3] = v48;
          if (v22 <= v21) {
            goto LABEL_30;
          }
          a1[2] = v17;
        }
        else
        {
          uint64_t v23 = a1 + 1;
          *a1 = v17;
        }
        a1[4] = v20;
        unint64_t v41 = a1 + 5;
        goto LABEL_29;
      }
      if (v22 > v19)
      {
        unint64_t v41 = a1 + 3;
        uint64_t v40 = a1[3];
        uint64_t v42 = a1[5];
        a1[4] = v18;
        a1[5] = v40;
        a1[2] = v17;
        a1[3] = v42;
        if (v22 > v21)
        {
          *a1 = v17;
          a1[2] = v20;
          uint64_t v23 = a1 + 1;
LABEL_29:
          uint64_t v49 = *v23;
          *uint64_t v23 = *v41;
          *unint64_t v41 = v49;
        }
      }
LABEL_30:
      int v50 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v51 = 0;
      int v52 = 0;
      while (1)
      {
        uint64_t v53 = *v50;
        uint64_t v54 = *v16;
        if (*(void *)(*v50 + 112) > *(void *)(v54 + 112))
        {
          uint64_t v55 = v50[1];
          uint64_t v56 = v51;
          *int v50 = 0;
          v50[1] = 0;
          while (1)
          {
            uint64_t v57 = (uint64_t *)((char *)a1 + v56);
            uint64_t v58 = *(uint64_t *)((char *)a1 + v56 + 40);
            v57[4] = 0;
            v57[5] = 0;
            uint64_t v59 = *(std::__shared_weak_count **)((char *)a1 + v56 + 56);
            v57[6] = v54;
            v57[7] = v58;
            if (v59 && !atomic_fetch_add(&v59->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
              std::__shared_weak_count::__release_weak(v59);
            }
            if (v56 == -32) {
              break;
            }
            uint64_t v54 = *(uint64_t *)((char *)a1 + v56 + 16);
            v56 -= 16;
            if (*(void *)(v53 + 112) <= *(void *)(v54 + 112))
            {
              uint64_t v60 = (uint64_t *)((char *)a1 + v56 + 48);
              unint64_t v61 = *(std::__shared_weak_count **)((char *)a1 + v56 + 56);
              *uint64_t v60 = v53;
              v60[1] = v55;
              if (!v61) {
                goto LABEL_32;
              }
              goto LABEL_44;
            }
          }
          unint64_t v61 = (std::__shared_weak_count *)a1[1];
          *a1 = v53;
          a1[1] = v55;
          if (!v61) {
            goto LABEL_32;
          }
LABEL_44:
          if (!atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
            std::__shared_weak_count::__release_weak(v61);
          }
LABEL_32:
          if (++v52 == 8) {
            return v50 + 2 == a2;
          }
        }
        uint64_t v16 = v50;
        v51 += 16;
        v50 += 2;
        if (v50 == a2) {
          return 1;
        }
      }
  }
}

uint64_t *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a2;
  unint64_t v5 = *(void *)(*a2 + 112);
  uint64_t v6 = *result;
  uint64_t v7 = *a3;
  unint64_t v8 = *(void *)(*a3 + 112);
  if (v5 <= *(void *)(*result + 112))
  {
    if (v8 > v5)
    {
      *a2 = v7;
      *a3 = v4;
      uint64_t v11 = a2 + 1;
      uint64_t v10 = a2[1];
      a2[1] = a3[1];
      a3[1] = v10;
      uint64_t v12 = *result;
      if (*(void *)(*a2 + 112) > *(void *)(*result + 112))
      {
        *BOOL result = *a2;
        uint64_t v9 = result + 1;
        *a2 = v12;
LABEL_10:
        uint64_t v14 = *v9;
        *uint64_t v9 = *v11;
        *uint64_t v11 = v14;
      }
    }
  }
  else
  {
    if (v8 > v5)
    {
      uint64_t v9 = result + 1;
      *BOOL result = v7;
LABEL_9:
      *a3 = v6;
      uint64_t v11 = a3 + 1;
      goto LABEL_10;
    }
    *BOOL result = v4;
    *a2 = v6;
    uint64_t v9 = a2 + 1;
    uint64_t v13 = result[1];
    result[1] = a2[1];
    a2[1] = v13;
    uint64_t v6 = *a2;
    if (*(void *)(*a3 + 112) > *(void *)(*a2 + 112))
    {
      *a2 = *a3;
      goto LABEL_9;
    }
  }
  uint64_t v15 = *a3;
  if (*(void *)(*a4 + 112) > *(void *)(*a3 + 112))
  {
    *a3 = *a4;
    *a4 = v15;
    uint64_t v16 = a3[1];
    a3[1] = a4[1];
    a4[1] = v16;
    uint64_t v17 = *a2;
    if (*(void *)(*a3 + 112) > *(void *)(*a2 + 112))
    {
      *a2 = *a3;
      *a3 = v17;
      uint64_t v18 = a2[1];
      a2[1] = a3[1];
      a3[1] = v18;
      uint64_t v19 = *result;
      if (*(void *)(*a2 + 112) > *(void *)(*result + 112))
      {
        *BOOL result = *a2;
        *a2 = v19;
        uint64_t v20 = result[1];
        result[1] = a2[1];
        a2[1] = v20;
      }
    }
  }
  return result;
}

void std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 < 2) {
    return;
  }
  uint64_t v6 = (uint64_t)a4 - a1;
  uint64_t v7 = v4 >> 1;
  if ((uint64_t)(v4 >> 1) < ((uint64_t)a4 - a1) >> 4) {
    return;
  }
  uint64_t v9 = v6 >> 3;
  uint64_t v10 = (v6 >> 3) + 1;
  uint64_t v11 = (void *)(a1 + 16 * v10);
  uint64_t v12 = v9 + 2;
  if (v9 + 2 >= a3)
  {
    uint64_t v14 = *a4;
    if (*(void *)(*v11 + 112) > *(void *)(*a4 + 112)) {
      return;
    }
  }
  else
  {
    uint64_t v13 = *v11;
    if (*(void *)(*v11 + 112) > *(void *)(v11[2] + 112))
    {
      uint64_t v13 = v11[2];
      v11 += 2;
      uint64_t v10 = v12;
    }
    uint64_t v14 = *a4;
    if (*(void *)(v13 + 112) > *(void *)(*a4 + 112)) {
      return;
    }
  }
  uint64_t v15 = a4[1];
  *a4 = 0;
  a4[1] = 0;
  uint64_t v16 = *v11;
  while (1)
  {
    uint64_t v17 = v11;
    uint64_t v18 = v11[1];
    *uint64_t v17 = 0;
    v17[1] = 0;
    uint64_t v19 = (std::__shared_weak_count *)a4[1];
    *a4 = v16;
    a4[1] = v18;
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    if (v7 < v10) {
      break;
    }
    uint64_t v11 = (void *)(a1 + 16 * ((2 * v10) | 1));
    if (2 * v10 + 2 < a3)
    {
      uint64_t v16 = *v11;
      if (*(void *)(*v11 + 112) <= *(void *)(v11[2] + 112))
      {
        uint64_t v10 = (2 * v10) | 1;
      }
      else
      {
        uint64_t v16 = v11[2];
        v11 += 2;
        uint64_t v10 = 2 * v10 + 2;
      }
      a4 = v17;
      if (*(void *)(v16 + 112) > *(void *)(v14 + 112)) {
        break;
      }
    }
    else
    {
      uint64_t v16 = *v11;
      uint64_t v10 = (2 * v10) | 1;
      a4 = v17;
      if (*(void *)(*v11 + 112) > *(void *)(v14 + 112)) {
        break;
      }
    }
  }
  uint64_t v20 = (std::__shared_weak_count *)v17[1];
  *uint64_t v17 = v14;
  v17[1] = v15;
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
}

void std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices,std::shared_ptr<HGGPUComputeDevice const> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 < 2) {
    return;
  }
  uint64_t v8 = 0;
  long long v23 = *(_OWORD *)a1;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  int64_t v9 = (unint64_t)(a4 - 2) >> 1;
  uint64_t v10 = (void *)a1;
  do
  {
    uint64_t v11 = v10;
    v10 += 2 * v8 + 2;
    if (2 * v8 + 2 >= a4)
    {
      uint64_t v8 = (2 * v8) | 1;
      uint64_t v15 = *v10;
      uint64_t v16 = v10[1];
      void *v10 = 0;
      v10[1] = 0;
      uint64_t v14 = (std::__shared_weak_count *)v11[1];
      *uint64_t v11 = v15;
      v11[1] = v16;
      if (!v14) {
        continue;
      }
    }
    else
    {
      uint64_t v12 = *v10;
      if (*(void *)(*v10 + 112) <= *(void *)(v10[2] + 112))
      {
        uint64_t v8 = (2 * v8) | 1;
      }
      else
      {
        uint64_t v12 = v10[2];
        v10 += 2;
        uint64_t v8 = 2 * v8 + 2;
      }
      uint64_t v13 = v10[1];
      void *v10 = 0;
      v10[1] = 0;
      uint64_t v14 = (std::__shared_weak_count *)v11[1];
      *uint64_t v11 = v12;
      v11[1] = v13;
      if (!v14) {
        continue;
      }
    }
    if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  while (v8 <= v9);
  if (v10 == (void *)(a2 - 16))
  {
    long long v21 = v23;
    long long v24 = 0uLL;
    unint64_t v22 = (std::__shared_weak_count *)v10[1];
    *(_OWORD *)uint64_t v10 = v21;
    if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  else
  {
    long long v17 = *(_OWORD *)(a2 - 16);
    *(void *)(a2 - 16) = 0;
    *(void *)(a2 - 8) = 0;
    uint64_t v18 = (std::__shared_weak_count *)v10[1];
    *(_OWORD *)uint64_t v10 = v17;
    if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
    long long v19 = v23;
    long long v24 = 0uLL;
    uint64_t v20 = *(std::__shared_weak_count **)(a2 - 8);
    *(_OWORD *)(a2 - 16) = v19;
    if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
    std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(a1, (uint64_t)(v10 + 2), a3, ((uint64_t)v10 - a1 + 16) >> 4);
  }
  if (*((void *)&v24 + 1))
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v24 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(void))(**((void **)&v24 + 1) + 16))(*((void *)&v24 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v24 + 1));
    }
  }
}

void sub_1B7762DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,SortGPUDevices &,std::shared_ptr<HGGPUComputeDevice const> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v6 = v4 >> 1;
    uint64_t v7 = (void *)(a1 + 16 * (v4 >> 1));
    uint64_t v8 = (void *)(a2 - 16);
    uint64_t v9 = *(void *)(a2 - 16);
    if (*(void *)(*v7 + 112) > *(void *)(v9 + 112))
    {
      uint64_t v10 = *(void *)(a2 - 8);
      *uint64_t v8 = 0;
      *(void *)(a2 - 8) = 0;
      uint64_t v11 = *v7;
      do
      {
        uint64_t v12 = v7;
        uint64_t v13 = v7[1];
        *uint64_t v12 = 0;
        v12[1] = 0;
        uint64_t v14 = (std::__shared_weak_count *)v8[1];
        *uint64_t v8 = v11;
        v8[1] = v13;
        if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
        if (!v6) {
          break;
        }
        unint64_t v6 = (v6 - 1) >> 1;
        uint64_t v7 = (void *)(a1 + 16 * v6);
        uint64_t v11 = *v7;
        uint64_t v8 = v12;
      }
      while (*(void *)(*v7 + 112) > *(void *)(v9 + 112));
      uint64_t v15 = (std::__shared_weak_count *)v12[1];
      *uint64_t v12 = v9;
      v12[1] = v10;
      if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<CreateComputeDeviceList(void)::$_0 &&>>(std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

uint64_t HGFormatUtils::toGLInternalFormat(int a1)
{
  return s_HGFormatInfos[8 * a1];
}

uint64_t HGFormatUtils::toGLFormat(int a1)
{
  return s_HGFormatInfos[8 * a1 + 1];
}

uint64_t HGFormatUtils::toGLType(int a1)
{
  return s_HGFormatInfos[8 * a1 + 2];
}

uint64_t HGFormatUtils::toString(int a1)
{
  return *(void *)&s_HGFormatInfos[8 * a1 + 6];
}

uint64_t HGFormatUtils::RGBtoRGBA(uint64_t result, const char *a2, char *a3)
{
  uint64_t v3 = result;
  unsigned int v4 = s_HGFormatInfos[8 * result + 1];
  if (v4 - 6403 > 7) {
    goto LABEL_9;
  }
  if (((1 << (v4 - 3)) & 0xE9) != 0) {
    return result;
  }
  if (v4 == 6407)
  {
    unsigned int v5 = s_HGFormatInfos[8 * result + 2];
    switch(v5)
    {
      case 0x1403u:
        return 25;
      case 0x1406u:
        return 28;
      case 0x8D61u:
        return 27;
      default:
        return 24;
    }
  }
  else
  {
LABEL_9:
    if (v4 != 32993 && v4 != 33319)
    {
      HGLogger::warning((HGLogger *)"componentsPerPixel -- unknown GL format", a2, a3);
      return v3;
    }
  }
  return result;
}

uint64_t HGFormatUtils::precision(int a1)
{
  unsigned int v1 = s_HGFormatInfos[8 * a1 + 2];
  switch(v1)
  {
    case 0x1403u:
      return 2;
    case 0x1406u:
      return 8;
    case 0x8D61u:
      return 4;
  }
  return 1;
}

uint64_t HGFormatUtils::bytesPerPixel(int a1)
{
  if (a1 <= 41) {
    return s_HGFormatInfos[8 * a1 + 3];
  }
  else {
    return 0;
  }
}

uint64_t HGFormatUtils::tileWidthFactorRequirement(int a1)
{
  if (a1 == 31) {
    return 6;
  }
  else {
    return 2;
  }
}

uint64_t HGFormatUtils::GLFormatToByteSize(HGFormatUtils *this, const char *a2, char *a3)
{
  int v3 = (int)a2;
  unsigned int v4 = 1;
  switch((int)this)
  {
    case 6403:
    case 6406:
    case 6409:
      goto LABEL_9;
    case 6404:
    case 6405:
      goto LABEL_16;
    case 6407:
      unsigned int v4 = 3;
      if ((int)a2 <= 5125) {
        goto LABEL_17;
      }
      goto LABEL_10;
    case 6408:
      goto LABEL_8;
    case 6410:
      goto LABEL_6;
    default:
      if (this == 32993)
      {
LABEL_8:
        unsigned int v4 = 4;
LABEL_9:
        if ((int)a2 <= 5125) {
          goto LABEL_17;
        }
      }
      else if (this == 33319)
      {
LABEL_6:
        unsigned int v4 = 2;
        if ((int)a2 <= 5125) {
          goto LABEL_17;
        }
      }
      else
      {
LABEL_16:
        HGLogger::warning((HGLogger *)"componentsPerPixel -- unknown GL format", a2, a3);
        unsigned int v4 = 1;
        if (v3 <= 5125)
        {
LABEL_17:
          if (v3 == 5121) {
            return v4;
          }
          if (v3 == 5123) {
            return 2 * v4;
          }
          goto LABEL_13;
        }
      }
LABEL_10:
      if (v3 == 5126) {
        return 4 * v4;
      }
      if (v3 == 34235) {
        return v4;
      }
      if (v3 != 36193)
      {
LABEL_13:
        HGLogger::warning((HGLogger *)"bytesPerComponent -- unknown GL type", a2, a3);
        return v4;
      }
      return 2 * v4;
  }
}

const char *HGFormatUtils::GLPixelFormatToString(HGFormatUtils *this, const char *a2, char *a3)
{
  if ((int)this > 32992)
  {
    if (this == 32993)
    {
      return "GL_BGRA";
    }
    else if (this == 33319)
    {
      return "GL_RG";
    }
    else
    {
LABEL_9:
      HGLogger::warning((HGLogger *)"HGFormatUtils::GLPixelFormatToString -- unknown GL format", a2, a3, v3, v4);
      return "";
    }
  }
  else
  {
    switch((int)this)
    {
      case 6402:
        BOOL result = "GL_DEPTH_COMPONENT";
        break;
      case 6403:
        BOOL result = "GL_RED";
        break;
      case 6404:
      case 6405:
        goto LABEL_9;
      case 6406:
        BOOL result = "GL_ALPHA";
        break;
      case 6407:
        BOOL result = "GL_RGB";
        break;
      case 6408:
        BOOL result = "GL_RGBA";
        break;
      case 6409:
        BOOL result = "GL_LUMINANCE";
        break;
      case 6410:
        BOOL result = "GL_LUMINANCE_ALPHA";
        break;
      default:
        if (this) {
          goto LABEL_9;
        }
        BOOL result = "(null)";
        break;
    }
  }
  return result;
}

const char *HGFormatUtils::GLPixelTypeToString(HGFormatUtils *this, const char *a2, char *a3)
{
  if ((int)this > 34234)
  {
    if (this == 34235)
    {
      return "GL_UNSIGNED_SHORT_8_8_REV_APPLE";
    }
    else if (this == 36193)
    {
      return "GL_HALF";
    }
    else
    {
LABEL_9:
      HGLogger::warning((HGLogger *)"HGFormatUtils::GLPixelTypeToString -- unknown GL type", a2, a3, v3, v4);
      return "";
    }
  }
  else
  {
    switch((int)this)
    {
      case 5121:
        BOOL result = "GL_UNSIGNED_BYTE";
        break;
      case 5122:
      case 5124:
        goto LABEL_9;
      case 5123:
        BOOL result = "GL_UNSIGNED_SHORT";
        break;
      case 5125:
        BOOL result = "GL_UNSIGNED_INT";
        break;
      case 5126:
        BOOL result = "GL_FLOAT";
        break;
      default:
        if (this) {
          goto LABEL_9;
        }
        BOOL result = "(null)";
        break;
    }
  }
  return result;
}

uint64_t HGFormatUtils::isPackedFormat(unsigned int a1)
{
  return (a1 < 0x20) & (0x8001C000 >> a1);
}

unint64_t HGFormatUtils::collapseRectForFormat(uint64_t *a1, int a2)
{
  uint64_t v2 = *a1;
  if ((a2 - 14) < 3) {
    return v2 & 0xFFFFFFFF00000000 | vcvtms_s32_f32((float)(int)v2 * 0.5);
  }
  if (a2 == 31) {
    return v2 & 0xFFFFFFFF00000000 | vcvts_n_s32_f32(floorf((float)(int)v2 / 6.0), 2uLL);
  }
  return v2 & 0xFFFFFFFF00000000 | *a1;
}

HGFormatUtils *HGFormatUtils::adjustPrecision(HGFormatUtils *this, unsigned int a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1F98, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1F98))
  {
    operator new();
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FA8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1FA8))
  {
    operator new();
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EB9A1FB0, memory_order_acquire) != -1)
  {
    long long v24 = &v22;
    long long v23 = &v24;
    std::__call_once(&qword_1EB9A1FB0, &v23, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGFormatUtils::adjustPrecision(unsigned int,unsigned int)::$_0 &&>>);
  }
  BOOL result = 0;
  if (this && a2)
  {
    if ((a2 & this) != 0)
    {
      return this;
    }
    else
    {
      uint64_t v5 = _MergedGlobals_10;
      uint64_t v7 = (uint64_t **)(_MergedGlobals_10 + 8);
      unint64_t v6 = *(unsigned int **)(_MergedGlobals_10 + 8);
      if (v6)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v8 = v6;
            unsigned int v9 = v6[7];
            if (v9 <= this) {
              break;
            }
            unint64_t v6 = (unsigned int *)*v8;
            uint64_t v7 = (uint64_t **)v8;
            if (!*v8) {
              goto LABEL_17;
            }
          }
          if (v9 >= this) {
            break;
          }
          unint64_t v6 = (unsigned int *)v8[1];
          if (!v6)
          {
            uint64_t v7 = (uint64_t **)(v8 + 1);
            goto LABEL_17;
          }
        }
      }
      else
      {
        uint64_t v8 = (void *)(_MergedGlobals_10 + 8);
LABEL_17:
        uint64_t v10 = v8;
        uint64_t v8 = operator new(0x28uLL);
        *((_DWORD *)v8 + 7) = this;
        *((_DWORD *)v8 + 8) = 0;
        *uint64_t v8 = 0;
        v8[1] = 0;
        int v8[2] = v10;
        *uint64_t v7 = v8;
        uint64_t v11 = **(void **)v5;
        uint64_t v12 = v8;
        if (v11)
        {
          *(void *)uint64_t v5 = v11;
          uint64_t v12 = *v7;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v5 + 8), v12);
        ++*(void *)(v5 + 16);
      }
      uint64_t v13 = *((unsigned int *)v8 + 8);
      uint64_t v14 = qword_1EB9A1FA0;
      uint64_t v16 = (uint64_t **)(qword_1EB9A1FA0 + 8);
      uint64_t v15 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
      if (v15)
      {
        while (1)
        {
          while (1)
          {
            long long v17 = (uint64_t **)v15;
            unsigned int v18 = *((_DWORD *)v15 + 8);
            if (v18 <= a2) {
              break;
            }
            uint64_t v15 = *v17;
            uint64_t v16 = v17;
            if (!*v17) {
              goto LABEL_27;
            }
          }
          if (v18 >= a2) {
            break;
          }
          uint64_t v15 = v17[1];
          if (!v15)
          {
            uint64_t v16 = v17 + 1;
            goto LABEL_27;
          }
        }
      }
      else
      {
        long long v17 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_27:
        long long v19 = (uint64_t *)v17;
        long long v17 = (uint64_t **)operator new(0x40uLL);
        *((_DWORD *)v17 + 8) = a2;
        v17[6] = 0;
        v17[7] = 0;
        v17[5] = 0;
        *long long v17 = 0;
        v17[1] = 0;
        unsigned int v17[2] = v19;
        uint64_t *v16 = (uint64_t *)v17;
        uint64_t v20 = **(void **)v14;
        long long v21 = (uint64_t *)v17;
        if (v20)
        {
          *(void *)uint64_t v14 = v20;
          long long v21 = *v16;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v14 + 8), v21);
        ++*(void *)(v14 + 16);
      }
      return (HGFormatUtils *)*((unsigned int *)v17[5] + v13);
    }
  }
  return result;
}

void sub_1B77638A8(_Unwind_Exception *a1)
{
}

void sub_1B77638C0(_Unwind_Exception *a1)
{
}

uint64_t HGFormatUtils::buildFormat(int a1, int a2)
{
  int v2 = a2 - 1;
  if (a2 - 1) <= 7 && ((0x8Bu >> v2)) {
    return *((unsigned int *)*(&off_1E616CB98 + v2) + a1 - 1);
  }
  else {
    return 0;
  }
}

uint64_t HGGPURenderer::UpdateLimits(HGGPURenderer *this, HGLimits *a2, int a3)
{
  int v3 = a3 & 0xF0000;
  if ((a3 & 0xFF00) != 0xB00)
  {
    *(_OWORD *)((char *)a2 + 20) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)((char *)a2 + 4) = 0u;
    *(_DWORD *)a2 = a3;
    if (v3 == 393216) {
      __int16 v8 = 64;
    }
    else {
      __int16 v8 = 128;
    }
    *((_WORD *)a2 + 10) = -1;
    *((_WORD *)a2 + 11) = v8;
    *((_WORD *)a2 + 12) = -1;
    unint64_t v6 = (char *)a2 + 40;
    *((_WORD *)a2 + 21) = -1;
    *((_WORD *)a2 + 18) = 8;
    goto LABEL_14;
  }
  *((_DWORD *)a2 + 9) = 8;
  *(_DWORD *)a2 = a3;
  *(_DWORD *)((char *)a2 + 30) = 0;
  *(void *)((char *)a2 + 12) = 0;
  *(void *)((char *)a2 + 4) = 0;
  *((_DWORD *)a2 + 5) = -1;
  *((_DWORD *)a2 + 11) = -1;
  *((_WORD *)a2 + 17) = 0;
  *((unsigned char *)a2 + 41) = 0;
  *((unsigned char *)a2 + 43) = 0;
  *((_WORD *)a2 + 12) = -1;
  *(_DWORD *)((char *)a2 + 26) = -256;
  BOOL v4 = v3 == 393216;
  if (v3 == 393216) {
    char v5 = 31;
  }
  else {
    char v5 = 0;
  }
  *((unsigned char *)a2 + 40) = v5;
  unint64_t v6 = (char *)a2 + 40;
  if (v4) {
    char v7 = 4;
  }
  else {
    char v7 = 60;
  }
  *((unsigned char *)a2 + 42) = v7;
  if (v4) {
LABEL_14:
  }
    unsigned char *v6 = 8;
  return HGLimits::setnormalized((uint64_t)a2, 1);
}

void *PBOStrategy::PBOStageSetBuffer::operator()(void *result)
{
  uint64_t v1 = result[1];
  int v2 = (void *)result[4];
  if (v2) {
    BOOL result = (void *)(*(uint64_t (**)(void))(*v2 + 16))(result[4]);
  }
  char v5 = v2;
  int v3 = *(void **)(v1 + 8);
  if ((unint64_t)v3 >= *(void *)(v1 + 16))
  {
    BOOL v4 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>((void **)v1, &v5);
    BOOL result = v5;
    *(void *)(v1 + 8) = v4;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 24))(result);
    }
  }
  else
  {
    *int v3 = v2;
    *(void *)(v1 + 8) = v3 + 1;
  }
  return result;
}

void sub_1B7763AAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

void PBOStrategy::PBOStageReadPixels::operator()(uint64_t a1, int a2)
{
  signed int v3 = a2 % ((*(void *)(*(void *)(a1 + 24) + 8) - **(void **)(a1 + 24)) >> 3);
  BOOL v4 = (uint64_t *)(**(void **)(a1 + 16) + 16 * a2);
  uint64_t v5 = *(void *)(**(void **)(a1 + 8) + 8 * a2);
  uint64_t v6 = HGRectIntersection(*v4, v4[1], *(void *)(v5 + 20), *(void *)(v5 + 28));
  uint64_t v8 = v7;
  HGPixelBufferObj::padding(*(void *)(**(void **)(a1 + 24) + 8 * v3), *(_DWORD *)(a1 + 32));
  int v9 = *(_DWORD *)(v5 + 12);
  if ((v9 & 0x10) != 0)
  {
    if ((v9 & 0x100) != 0)
    {
      uint64_t v12 = *(HGPixelBufferObj **)(**(void **)(a1 + 24) + 8 * v3);
      *(void *)&v13.int var0 = v6;
      *(void *)&v13.unsigned int var2 = v8;
      HGGLBuffer::ReadPixels((HGGLBuffer *)v5, v12, v13);
    }
    else if ((v9 & 0x200) != 0)
    {
      uint64_t v10 = *(HGPixelBufferObj **)(**(void **)(a1 + 24) + 8 * v3);
      *(void *)&v11.int var0 = v6;
      *(void *)&v11.unsigned int var2 = v8;
      HGGLTexture::ReadPixels((HGGLTexture *)v5, v10, v11);
    }
  }
}

uint64_t PBOStrategy::PBOStageMapBuffer::operator()(uint64_t a1, int a2)
{
  HGPixelBufferObj::GetDataPtr(*(HGPixelBufferObj **)(**(void **)(a1 + 24)
                                                    + 8
                                                    * (int)(a2
                                                          % ((*(void *)(*(void *)(a1 + 24) + 8)
                                                                          - **(void **)(a1 + 24)) >> 3))));
  BOOL v4 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = *v4;
  uint64_t result = *(void *)(*v4 + 8 * a2);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    *(void *)(v5 + 8 * a2) = 0;
  }
  return result;
}

void PBOStrategy::PBOStageStartCopy::operator()(uint64_t a1, unsigned int a2)
{
}

uint64_t PBOStrategy::PBOStageFinishCopy::operator()(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = **(void **)(a1 + 24);
  uint64_t v4 = 8 * (int)(a2 % ((unint64_t)(*(void *)(*(void *)(a1 + 24) + 8) - v3) >> 3));
  HGPixelBufferObj::FinishCopyBitmap(*(void *)(v3 + v4));
  uint64_t v5 = *(HGPixelBufferObj **)(**(void **)(a1 + 24) + v4);

  return HGPixelBufferObj::ReleaseDataPtr(v5);
}

void HGGPURenderer::Init(HGGPURenderer *this, const char *a2, char *a3)
{
  if (!*((void *)this + 139))
  {
    *((unsigned char *)this + 809) = 0;
    HGLogger::warning((HGLogger *)"Failed to initialize Metal device.", a2, a3);
  }
  uint64_t v4 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v4);
  *((void *)this + 151) = v4;
  *((_DWORD *)this + 335) = 1;
  GLPBO::forcePostReadPixelsFence(HG_RENDERER_ENV::FORCE_POST_READPIXELS_FENCE);
  GLPBO::forcePostReadPixelsFinish(HG_RENDERER_ENV::FORCE_POST_READPIXELS_FINISH);
  operator new();
}

void sub_1B7764284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10, PCSharedCount a11, PCSharedCount a12, uint64_t a13, PCSharedCount a14)
{
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  PCSharedCount::PCSharedCount(&a12);
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void sub_1B776435C()
{
}

void sub_1B7764364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  MEMORY[0x1BA9BFBA0](v10, 0x10A1C40F99B7576);
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void sub_1B776439C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  MEMORY[0x1BA9BFBA0](v10, 0x10A0C40B3F59724);
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void sub_1B77643CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void sub_1B77643E8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B2C40048180CFLL);
  _Unwind_Resume(a1);
}

void sub_1B776440C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B776448C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void HGGPURenderer::HGGPURenderer(HGRenderer *a1)
{
}

void sub_1B7764754(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v3, 0x10A0C406BFFB60BLL);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1 + 1440, *(void **)(v1 + 1448));
  std::deque<HGNode *>::~deque[abi:ne180100](v1 + 1376);
  uint64_t v6 = *(void **)(v1 + 1216);
  if (v6)
  {
    *(void *)(v1 + 1224) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *(void *)(v1 + 1176);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  uint64_t v8 = *(void *)(v1 + 1152);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
  if (*v4) {
    (*(void (**)(void))(*(void *)*v4 + 24))(*v4);
  }
  std::__tree<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::__map_value_compare<HGMetalDeviceInfo const*,std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::less<HGMetalDeviceInfo const*>,true>,std::allocator<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>>>::destroy(v2, *(void **)(v1 + 1128));
  uint64_t v9 = *(void *)(v1 + 1112);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  HGRenderer::~HGRenderer((HGRenderer *)v1);
  _Unwind_Resume(a1);
}

void HGGPURenderer::HGGPURenderer(HGRenderer *a1, PC_Sp_counted_base **a2)
{
  v2.int var0 = *a2;
  HGGPURenderer::HGGPURenderer(a1);
}

void sub_1B7764968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

int64x2_t *HGGPURenderer::PurgePostDeleteEvents(int64x2_t *this)
{
  uint64_t v1 = this[92].i64[0];
  if (v1)
  {
    PCSharedCount v2 = this;
    uint64_t v3 = *(pthread_mutex_t **)(v1 + 112);
    HGTextureManager::PostTextureDeleteEventList::lock(v3);
    while (HGTextureManager::PostTextureDeleteEventList::hasEvent((HGTextureManager::PostTextureDeleteEventList *)v3))
    {
      uint64_t v4 = HGTextureManager::PostTextureDeleteEventList::popEvent((HGTextureManager::PostTextureDeleteEventList *)v3);
      HGTextureManager::PostTextureDeleteEventList::unlock(v3);
      (*(void (**)(int64x2_t *))(v2->i64[0] + 16))(v2);
      uint64_t v5 = v2[86].i64[1];
      unint64_t v6 = v2[88].u64[0];
      unint64_t v7 = v6 >> 9;
      uint64_t v8 = (char *)(v5 + 8 * (v6 >> 9));
      uint64_t v9 = v2[87].i64[0];
      if (v9 == v5)
      {
        unint64_t v12 = v2[88].i64[1] + v6;
        HGRect v13 = (char *)(v5 + 8 * (v12 >> 9));
        if (v7 == v12 >> 9)
        {
          HGRect v11 = 0;
          if (!v5) {
            goto LABEL_16;
          }
LABEL_12:
          if ((char *)(*(void *)v8 + 4096) != v11) {
            goto LABEL_41;
          }
          v8 += 8;
          goto LABEL_45;
        }
        HGRect v11 = 0;
        uint64_t v14 = 0;
        uint64_t v10 = *(void *)v8;
      }
      else
      {
        uint64_t v10 = *(void *)(v5 + 8 * v7);
        HGRect v11 = (char *)(v10 + 8 * (v2[88].i64[0] & 0x1FF));
        unint64_t v12 = v2[88].i64[1] + v6;
        HGRect v13 = (char *)(v5 + 8 * (v12 >> 9));
        uint64_t v14 = *(void *)v13 + 8 * (v12 & 0x1FF);
        if (v7 == v12 >> 9)
        {
          if (v11 != (char *)v14)
          {
            while (*(void *)v11 != v4)
            {
              v11 += 8;
              if (v11 == (char *)v14)
              {
                HGRect v11 = (char *)(*(void *)v13 + 8 * (v12 & 0x1FF));
                break;
              }
            }
            if (!v5)
            {
LABEL_16:
              uint64_t v8 = 0;
              if (v9 != v5) {
                goto LABEL_42;
              }
              goto LABEL_46;
            }
          }
          goto LABEL_12;
        }
      }
      uint64_t v15 = (char *)(v10 + 4096);
      while (*(void *)v11 != v4)
      {
        v11 += 8;
        if (v11 == v15) {
          goto LABEL_26;
        }
      }
      if (v11 != v15) {
        goto LABEL_41;
      }
LABEL_26:
      uint64_t v16 = (uint64_t *)(v8 + 8);
      if (v8 + 8 != v13)
      {
        uint64_t v17 = 0;
        v8 += 8;
        uint64_t v18 = *v16;
        while (*(void *)(v18 + v17) != v4)
        {
          v17 += 8;
          if (v17 == 4096) {
            goto LABEL_26;
          }
        }
        HGRect v11 = (char *)(v18 + v17);
LABEL_41:
        if (v9 != v5) {
          goto LABEL_42;
        }
        goto LABEL_46;
      }
      if (*(void *)v13 == v14)
      {
        uint64_t v8 = v13;
        HGRect v11 = (char *)v14;
        if (v9 != v5) {
          goto LABEL_42;
        }
        goto LABEL_46;
      }
      HGRect v11 = *(char **)v13;
      while (*(void *)v11 != v4)
      {
        v11 += 8;
        if (v11 == (char *)v14)
        {
          HGRect v11 = (char *)v14;
          break;
        }
      }
      if ((char *)(*(void *)v13 + 4096) != v11)
      {
        uint64_t v8 = v13;
        if (v9 != v5) {
          goto LABEL_42;
        }
        goto LABEL_46;
      }
      v8 += 16;
LABEL_45:
      HGRect v11 = *(char **)v8;
      if (v9 != v5)
      {
LABEL_42:
        if (v11 == (char *)(*(void *)v13 + 8 * (v12 & 0x1FF))) {
          goto LABEL_4;
        }
LABEL_47:
        std::deque<Pipeline *>::erase(v2 + 86, v8, v11);
        (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
        goto LABEL_4;
      }
LABEL_46:
      if (v11) {
        goto LABEL_47;
      }
LABEL_4:
      (*(void (**)(int64x2_t *))(v2->i64[0] + 24))(v2);
      HGTextureManager::PostTextureDeleteEventList::lock(v3);
    }
    return (int64x2_t *)HGTextureManager::PostTextureDeleteEventList::unlock(v3);
  }
  return this;
}

void HGGPURenderer::InitMetal(HGGPURenderer *this)
{
  HGLogger::setLevel((HGLogger *)"metal_osx", 0);
  HGLogger::setLevel((HGLogger *)"metal", 0);
  HGLogger::setLevel((HGLogger *)"concat", 0);
  uint64_t v2 = *((void *)this + 139);
  if (v2)
  {
    if ((HG_RENDERER_ENV::METAL_MAX_ENCODERS_PER_BUFFER & 0x80000000) == 0) {
      HGMetalContext::setCommandBufferLimits(v2, HG_RENDERER_ENV::METAL_MAX_ENCODERS_PER_BUFFER, -1);
    }
    int v3 = HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_COUNT;
    uint64_t v4 = HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_MEMORY;
    if ((HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_COUNT & 0x80000000) == 0
      || (HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_MEMORY & 0x80000000) == 0)
    {
      uint64_t v5 = *((void *)this + 139);
      if (HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_COUNT < 0) {
        int v3 = *(_DWORD *)(v5 + 84);
      }
      if (HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_MEMORY < 0) {
        uint64_t v4 = *(void *)(v5 + 88);
      }
      *(_DWORD *)(v5 + 84) = v3;
      *(void *)(v5 + 88) = v4;
    }
    if (HG_RENDERER_ENV::METAL_UPLOAD_TEXTURE_CREATION_STRATEGY >= 1)
    {
      if (HG_RENDERER_ENV::METAL_UPLOAD_TEXTURE_CREATION_STRATEGY == 1) {
        int v6 = 5;
      }
      else {
        int v6 = 13;
      }
      switch(HG_RENDERER_ENV::METAL_UPLOAD_TEXTURE_CREATION_STRATEGY)
      {
        case 3:
          v6 |= 0x10u;
          break;
        case 4:
          v6 |= 0x20u;
          break;
        case 5:
          v6 |= 0x40u;
          break;
        case 6:
          v6 |= 0x80u;
          break;
        default:
          break;
      }
      *(_DWORD *)(*((void *)this + 139) + 48) = v6;
    }
    if (HG_RENDERER_ENV::METAL_BLIT_MAX_TILE_SIZE_MB >= 1) {
      *(_DWORD *)(*((void *)this + 139) + 96) = HG_RENDERER_ENV::METAL_BLIT_MAX_TILE_SIZE_MB;
    }
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"HeliumRender #", 14);
    std::ostream::operator<<();
    unint64_t v7 = (HGMetalContext *)*((void *)this + 139);
    std::stringbuf::str();
    if (v11 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    HGMetalContext::setLabel(v7, p_p);
    if (v11 < 0) {
      operator delete(__p);
    }
    v12[0] = *MEMORY[0x1E4FBA408];
    uint64_t v9 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    *(void *)((char *)v12 + *(void *)(v12[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
    v13[0] = v9;
    v13[1] = MEMORY[0x1E4FBA470] + 16;
    if (v14 < 0) {
      operator delete((void *)v13[9]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1BA9BFAB0](&v15);
  }
  operator new();
}

void sub_1B7764F64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
    _Unwind_Resume(a1);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void HGGPURenderer::InitDefaultPageSize(PCICCTransferFunctionLUT **this)
{
  uint64_t LUTEnd = PCICCTransferFunctionLUT::getLUTEnd(this[139]);
  *((_DWORD *)this + 312) = *(_DWORD *)(LUTEnd + 48);
  unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
  if (v5) {
    HGLogger::log((HGLogger *)"init", (const char *)1, (HGLogger *)"m_MaxPageSize : %d\n", v2, v3, *((unsigned int *)this + 312));
  }
  float v6 = 0.25;
  if (HG_RENDERER_ENV::LOW_MEMORY_USAGE == 1) {
    float v6 = 0.125;
  }
  unint64_t v7 = *(void *)(LUTEnd + 40);
  this[157] = (PCICCTransferFunctionLUT *)(float)(v6 * (float)v7);
  int v8 = HG_RENDERER_ENV::FORCE_PAGE_SIZE;
  if (HG_RENDERER_ENV::FORCE_PAGE_SIZE != -1)
  {
    *((_DWORD *)this + 165) = HG_RENDERER_ENV::FORCE_PAGE_SIZE;
    int v9 = *((_DWORD *)this + 312);
    if (v8 <= v9) {
      return;
    }
LABEL_21:
    *((_DWORD *)this + 165) = v9;
    return;
  }
  if (HGMetalDeviceInfo::isIntel((HGMetalDeviceInfo *)LUTEnd))
  {
    *((_DWORD *)this + 165) = 555;
    int v9 = *((_DWORD *)this + 312);
    if (v9 < 555) {
      goto LABEL_21;
    }
  }
  else if (v7 < 0x1DCD65000)
  {
    if (v7 < 0x77359400)
    {
      if (v7 < 0x3B9ACA00)
      {
        *((_DWORD *)this + 165) = 750;
        int v9 = *((_DWORD *)this + 312);
        if (v9 < 750) {
          goto LABEL_21;
        }
      }
      else
      {
        *((_DWORD *)this + 165) = 1500;
        int v9 = *((_DWORD *)this + 312);
        if (v9 < 1500) {
          goto LABEL_21;
        }
      }
    }
    else
    {
      *((_DWORD *)this + 165) = 3000;
      int v9 = *((_DWORD *)this + 312);
      if (v9 < 3000) {
        goto LABEL_21;
      }
    }
  }
  else
  {
    *((_DWORD *)this + 165) = 5000;
    int v9 = *((_DWORD *)this + 312);
    if (v9 < 5000) {
      goto LABEL_21;
    }
  }
}

void HGGPURenderer::~HGGPURenderer(HGGPURenderer *this)
{
  *(void *)this = &unk_1F10D4438;
  if (*((unsigned char *)this + 1281))
  {
    HGGLGetCurrentContext();
    HGGLContext::Share();
  }
  HGLUTCacheManager::clear(*((HGLUTCacheManager **)this + 69));
  (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
  uint64_t v2 = (const void *)*((void *)this + 164);
  if (v2)
  {
    if (v3)
    {
      uint64_t v4 = v3;
      HGMetalHandler::FinalizeCommandBuffer(v3);
      HGMetalHandler::BindBuffer(v4, 0);
    }
  }
  unsigned __int8 v5 = (id *)*((void *)this + 165);
  if (v5)
  {
    HGMetalCommandBufferRef::waitUntilCompleted(v5);
    float v6 = (id *)*((void *)this + 165);
    if (v6)
    {
      HGMetalCommandBufferRef::~HGMetalCommandBufferRef(v6);
      MEMORY[0x1BA9BFBA0]();
    }
  }
  *((void *)this + 165) = 0;
  unint64_t v7 = (HGTextureManager *)*((void *)this + 184);
  if (v7)
  {
    HGTextureManager::finishDeleteTextureQueue(v7);
    HGGPURenderer::PurgePostDeleteEvents((int64x2_t *)this);
    int v8 = (HGTextureManager *)*((void *)this + 184);
    if (v8)
    {
      HGTextureManager::~HGTextureManager(v8);
      MEMORY[0x1BA9BFBA0]();
    }
    *((void *)this + 184) = 0;
  }
  *((_DWORD *)this + 290) = 0;
  int v9 = (HGGLContext *)*((void *)this + 144);
  if (v9)
  {
    if (*((_DWORD *)this + 357) != -1)
    {
      HGGLContext::setCurrent(v9);
      glDeleteTextures(1, (const GLuint *)this + 357);
    }
    HGGLShaderCache::ResetMetal(*((HGGLShaderCache **)this + 161), *((const HGMetalContext **)this + 139));
    HGGLShaderCache::ResetGLSL(*((HGGLShaderCache **)this + 161));
    HGGLShaderCache::ResetARB(*((HGGLShaderCache **)this + 161));
  }
  uint64_t v10 = (void **)*((void *)this + 161);
  if (v10)
  {
    HGGLShaderCache::~HGGLShaderCache(v10);
    MEMORY[0x1BA9BFBA0]();
  }
  *((void *)this + 161) = 0;
  uint64_t v11 = *((void *)this + 162);
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = *((void *)this + 163);
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  uint64_t v13 = *((void *)this + 164);
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  char v14 = (void **)*((void *)this + 179);
  if (v14)
  {
    uint64_t v15 = (char *)*v14;
    if (*v14)
    {
      uint64_t v16 = (char *)v14[1];
      uint64_t v17 = *v14;
      if (v16 != v15)
      {
        do
        {
          uint64_t v19 = *((void *)v16 - 1);
          v16 -= 8;
          uint64_t v18 = v19;
          if (v19) {
            (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
          }
        }
        while (v16 != v15);
        uint64_t v17 = *v14;
      }
      v14[1] = v15;
      operator delete(v17);
    }
    MEMORY[0x1BA9BFBA0](v14, 0x20C40960023A9);
  }
  *((void *)this + 179) = 0;
  uint64_t v20 = (HGGLState *)*((void *)this + 146);
  if (v20)
  {
    HGGLState::~HGGLState(v20);
    MEMORY[0x1BA9BFBA0]();
  }
  if (*((unsigned char *)this + 1281)) {
    HGGPURenderer::UnBindCachedFramebuffer(this);
  }
  long long v21 = (HGGLContext *)*((void *)this + 144);
  if (v21)
  {
    HGGLContext::context((uint64_t *)&v31, v21);
    if (PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v31))
    {
      v30.int var0 = v31.var0;
      HGGLSetCurrentContext(&v30.var0);
      PCSharedCount::PCSharedCount(&v30);
      glBindFramebuffer(0x8D40u, 0);
      if (*((_DWORD *)this + 297)) {
        glDeleteFramebuffers(1, (const GLuint *)this + 297);
      }
    }
    uint64_t v22 = *((void *)this + 144);
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
    }
    *((void *)this + 144) = 0;
    PCSharedCount::PCSharedCount(&v31);
  }
  uint64_t v23 = *((void *)this + 143);
  if (v23)
  {
    (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
    *((void *)this + 143) = 0;
  }
  uint64_t v24 = *((void *)this + 151);
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  }
  *((void *)this + 151) = 0;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 1440, *((void **)this + 181));
  std::deque<HGNode *>::~deque[abi:ne180100]((uint64_t)this + 1376);
  uint64_t v25 = (void *)*((void *)this + 152);
  if (v25)
  {
    *((void *)this + 153) = v25;
    operator delete(v25);
  }
  uint64_t v26 = *((void *)this + 147);
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 24))(v26);
  }
  uint64_t v27 = *((void *)this + 144);
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 24))(v27);
  }
  uint64_t v28 = *((void *)this + 143);
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 24))(v28);
  }
  std::__tree<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::__map_value_compare<HGMetalDeviceInfo const*,std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::less<HGMetalDeviceInfo const*>,true>,std::allocator<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>>>::destroy((uint64_t)this + 1120, *((void **)this + 141));
  uint64_t v29 = *((void *)this + 139);
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 24))(v29);
  }
  HGRenderer::~HGRenderer(this);
}

{
  void *v1;
  uint64_t vars8;

  HGGPURenderer::~HGGPURenderer(this);

  HGObject::operator delete(v1);
}

void HGGPURenderer::FinishMetalCommandBuffer(HGGPURenderer *this)
{
  (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
  uint64_t v2 = (const void *)*((void *)this + 164);
  if (v2)
  {
    if (v3)
    {
      uint64_t v4 = v3;
      HGMetalHandler::FinalizeCommandBuffer(v3);
      HGMetalHandler::BindBuffer(v4, 0);
    }
  }
  unsigned __int8 v5 = (id *)*((void *)this + 165);
  if (v5)
  {
    HGMetalCommandBufferRef::waitUntilCompleted(v5);
  }
}

uint64_t HGGPURenderer::GetMetalContext(HGGPURenderer *this)
{
  return *((void *)this + 139);
}

void HGGPURenderer::UnBindCachedFramebuffer(HGGPURenderer *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1FC0))
  {
    operator new();
  }
  std::mutex::lock((std::mutex *)qword_1EB9A1FB8);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v14, "framebuffer", 2, "UnBindCachedFramebuffer()");
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1FC8))
  {
    qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
    qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
    qword_1EB9A1FE0 = 0;
    __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A1FC8);
  }
  uint64_t v4 = (uint64_t *)qword_1EB9A1FD8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v10 = v4;
    int v11 = __cxa_guard_acquire(&qword_1EB9A1FC8);
    uint64_t v4 = v10;
    if (v11)
    {
      qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FE0 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1FC8);
      uint64_t v4 = v10;
    }
  }
  if (v4 == &qword_1EB9A1FD0)
  {
LABEL_7:
    uint64_t v4 = &qword_1EB9A1FD0;
  }
  else
  {
    while (*((_DWORD *)v4 + 7) != *((_DWORD *)this + 298))
    {
      uint64_t v4 = (uint64_t *)v4[1];
      if (v4 == &qword_1EB9A1FD0) {
        goto LABEL_7;
      }
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v12 = v4;
    int v13 = __cxa_guard_acquire(&qword_1EB9A1FC8);
    uint64_t v4 = v12;
    if (v13)
    {
      qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FE0 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1FC8);
      uint64_t v4 = v12;
    }
  }
  if (v4 == &qword_1EB9A1FD0)
  {
    unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
    if (v8)
    {
      float v6 = "uh oh! unknown framebuffer (%d)\n";
      uint64_t v7 = 1;
      goto LABEL_14;
    }
  }
  else
  {
    *((unsigned char *)v4 + 32) = 0;
    unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
    if (v5)
    {
      float v6 = "done with framebuffer (%d) - marking unused\n";
      uint64_t v7 = 2;
LABEL_14:
      HGLogger::log((HGLogger *)"framebuffer", (const char *)v7, (HGLogger *)v6, v2, v3, *((unsigned int *)this + 298));
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1FC0))
  {
    operator new();
  }
  std::mutex::unlock((std::mutex *)qword_1EB9A1FB8);
  glBindFramebuffer(0x8D40u, 0);
  *((_DWORD *)this + 298) = 0;
  FBOStrategy::cleanupCache(v9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v14);
}

void sub_1B7765AC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  __cxa_guard_abort(&qword_1EB9A1FC0);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7765AE0(_Unwind_Exception *a1)
{
}

void sub_1B7765AF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::label(PCICCTransferFunctionLUT **this)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v16);
  HGRenderer::label((uint64_t *)__p, (HGRenderer *)this);
  if ((v15 & 0x80u) == 0) {
    uint64_t v2 = __p;
  }
  else {
    uint64_t v2 = (void **)__p[0];
  }
  if ((v15 & 0x80u) == 0) {
    uint64_t v3 = v15;
  }
  else {
    uint64_t v3 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)v2, v3);
  if ((char)v15 < 0)
  {
    operator delete(__p[0]);
    uint64_t v4 = this[139];
    if (!v4) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v4 = this[139];
    if (!v4) {
      goto LABEL_13;
    }
  }
  unsigned __int8 v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" ID:0x", 6);
  *(_DWORD *)((char *)v5 + *(void *)(*v5 - 24) + 8) = *(_DWORD *)((unsigned char *)v5 + *(void *)(*v5 - 24) + 8) & 0xFFFFFFB5 | 8;
  PCICCTransferFunctionLUT::getLUTEnd(v4);
  std::ostream::operator<<();
  uint64_t LUTEnd = (id *)PCICCTransferFunctionLUT::getLUTEnd(v4);
  if (HGMetalDeviceInfo::name(LUTEnd))
  {
    uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" (", 2);
    unsigned __int8 v8 = (id *)PCICCTransferFunctionLUT::getLUTEnd(v4);
    int v9 = (const char *)HGMetalDeviceInfo::name(v8);
    size_t v10 = strlen(v9);
    int v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)v9, v10);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)")", 1);
  }
LABEL_13:
  std::stringbuf::str();
  v16[0] = *MEMORY[0x1E4FBA408];
  uint64_t v12 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v16 + *(void *)(v16[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v17[0] = v12;
  v17[1] = MEMORY[0x1E4FBA470] + 16;
  if (v18 < 0) {
    operator delete((void *)v17[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BA9BFAB0](&v19);
}

void sub_1B7765DA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
    _Unwind_Resume(a1);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::debugDescription(HGGPURenderer *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 40))();
}

uint64_t HGGPURenderer::ShouldAllocateGLTexture(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  if (*(unsigned char *)(a1 + 1281))
  {
    uint64_t result = *(void *)(a1 + 1472);
    if (!result) {
      return result;
    }
    unsigned int v9 = HGTextureManager::maxTextureSizeGL(result, a4);
    if (v9 < a2 || v9 < a3) {
      return 0;
    }
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 1112)) + 48);
    if (v11 < a2 || v11 < a3) {
      return 0;
    }
  }
  if (a4 <= 41) {
    uint64_t v13 = s_HGFormatInfos[8 * a4 + 3];
  }
  else {
    uint64_t v13 = 0;
  }
  return a3 * (unint64_t)a2 * v13 < *(void *)(a1 + 1256);
}

uint64_t HGGPURenderer::ShouldAllocateTexture(uint64_t a1, unsigned int a2, unsigned int a3, int a4, int a5, int a6)
{
  if (*(unsigned char *)(a1 + 1281))
  {
    if (a5)
    {
      unsigned int v11 = *(_DWORD *)(PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 1112)) + 48);
      BOOL v12 = v11 >= a2 && v11 >= a3;
      char v13 = !v12;
      if (!v12 || !a6)
      {
        if (v13) {
          return 0;
        }
        goto LABEL_24;
      }
LABEL_21:
      uint64_t result = *(void *)(a1 + 1472);
      if (!result) {
        return result;
      }
      unsigned int v17 = HGTextureManager::maxTextureSizeGL(result, a4);
      uint64_t result = 0;
      if (v17 < a2 || v17 < a3) {
        return result;
      }
      goto LABEL_24;
    }
    if (a6) {
      goto LABEL_21;
    }
  }
  else
  {
    unsigned int v15 = *(_DWORD *)(PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 1112)) + 48);
    if (v15 < a2 || v15 < a3) {
      return 0;
    }
  }
LABEL_24:
  if (a4 <= 41) {
    uint64_t v18 = s_HGFormatInfos[8 * a4 + 3];
  }
  else {
    uint64_t v18 = 0;
  }
  return a3 * (unint64_t)a2 * v18 < *(void *)(a1 + 1256);
}

uint64_t HGGPURenderer::IsCPU(HGGPURenderer *this)
{
  return 0;
}

uint64_t HGGPURenderer::RenderFullROI_Default(HGGPURenderer *this)
{
  return 0;
}

const char *HGGPURenderer::RenderBitmap(HGGPURenderer *this, HGBitmap *a2, HGNode *a3)
{
  int v3 = *((_DWORD *)a2 + 3);
  if (*((unsigned char *)this + 1280)) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = (*((_DWORD *)a2 + 3) & 0x10) == 0;
  }
  if (!v4)
  {
    unsigned __int8 v5 = "  ERROR : cannot render to shared GL texture.";
    return HGLogger::warning((HGLogger *)v5, (const char *)a2, (char *)a3);
  }
  if ((~v3 & 0x210) == 0)
  {
    unsigned __int8 v5 = "  ERROR : bitmap is a GL texture (need a HGGLBuffer).";
    return HGLogger::warning((HGLogger *)v5, (const char *)a2, (char *)a3);
  }
  if ((~v3 & 0x120) == 0)
  {
    unsigned __int8 v5 = "  ERROR : bitmap is a MTL buffer (need a texture).";
    return HGLogger::warning((HGLogger *)v5, (const char *)a2, (char *)a3);
  }
  HGRendererOutput::HGRendererOutput((HGRendererOutput *)v9, a3, a2);
  HGRenderer::RenderNode(this, (const HGRendererOutput *)v9, (char *)1, &v8);
  uint64_t result = (const char *)v8;
  if (v8) {
    return (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
  return result;
}

{
  uint64_t vars8;

  HGLogger::warning((HGLogger *)"  WARNING : calling obsolete HGGPURenderer function:\n  (fullROI is always 'on' when providing a destination bitmap)\n", (const char *)a2, (char *)a3);

  return HGGPURenderer::RenderBitmap(this, a2, a3);
}

uint64_t HGGPURenderer::GetGLTexture(HGGPURenderer *this, HGBitmap *a2, char *a3)
{
  if (*((unsigned char *)this + 809))
  {
    uint64_t v4 = *((void *)this + 146);
    if (v4)
    {
      HGGLContext::context((uint64_t *)&v9, *((HGGLContext **)this + 143));
      HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v10, v4, &v9);
      PCSharedCount::PCSharedCount(&v9);
      *(void *)&v11.int var0 = *(void *)((char *)a2 + 20);
      *(void *)&v11.unsigned int var2 = *(void *)((char *)a2 + 28);
      uint64_t v6 = HGGPURenderer::ConvertToGLTexture(this, v11, a2);
      (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
      HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v10);
      return v6;
    }
    uint64_t v8 = "Renderer does not support OpenGL";
  }
  else
  {
    uint64_t v8 = "Invalid Renderer";
  }
  HGLogger::warning((HGLogger *)v8, (const char *)a2, a3);
  return 0;
}

void sub_1B7766278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
}

void sub_1B776628C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::ConvertToGLTexture(HGGPURenderer *this, HGRect a2, HGBitmap *a3)
{
  uint64_t v3 = *(void *)&a2.var2;
  uint64_t v4 = *(void *)&a2.var0;
  uint64_t v6 = HGGPURenderer::ConvertToNonMetalTexture(this, a3);
  uint64_t v7 = v6;
  int v8 = *((_DWORD *)v6 + 3);
  if ((v8 & 0x30) != 0)
  {
    if ((v8 & 0x10) == 0) {
      goto LABEL_3;
    }
    if ((v8 & 0x100) != 0)
    {
      (*(void (**)(HGGPURenderer *, HGBitmap *))(*(void *)this + 144))(this, v6);
      uint64_t v9 = (*(uint64_t (**)(HGGPURenderer *))(*(void *)this + 328))(this);
      goto LABEL_10;
    }
    if ((v8 & 0x200) != 0)
    {
      uint64_t v9 = (uint64_t)v10;
      if (v10) {
        (*(void (**)(void *))(*(void *)v10 + 16))(v10);
      }
    }
    else
    {
LABEL_3:
      uint64_t v9 = 0;
    }
  }
  else
  {
    uint64_t v9 = (*(uint64_t (**)(HGGPURenderer *, uint64_t, uint64_t, HGBitmap *))(*(void *)this + 352))(this, v4, v3, v6);
  }
LABEL_10:
  (*(void (**)(HGBitmap *))(*(void *)v7 + 24))(v7);
  return v9;
}

uint64_t HGGPURenderer::GetRawGLTexture(HGGPURenderer *this, HGBitmap *a2, char *a3)
{
  if (*((unsigned char *)this + 809))
  {
    uint64_t v4 = *((void *)this + 146);
    if (v4)
    {
      HGGLContext::context((uint64_t *)&v9, *((HGGLContext **)this + 143));
      HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v10, v4, &v9);
      PCSharedCount::PCSharedCount(&v9);
      uint64_t v6 = HGGPURenderer::ConvertToRawGLTexture(this, a2);
      (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
      HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v10);
      return v6;
    }
    int v8 = "Renderer does not support OpenGL";
  }
  else
  {
    int v8 = "Invalid Renderer";
  }
  HGLogger::warning((HGLogger *)v8, (const char *)a2, a3);
  return 0;
}

void sub_1B7766528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
}

void sub_1B776653C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::ConvertToRawGLTexture(HGGPURenderer *this, HGBitmap *a2)
{
  uint64_t v4 = HGGPURenderer::ConvertToNonMetalTexture(this, a2);
  unsigned __int8 v5 = v4;
  if (*((unsigned char *)v4 + 12))
  {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)this, *(HGRect *)((char *)a2 + 20), *((unsigned int *)a2 + 4), 0, 0, 0, *((unsigned char *)this + 1336) == 0);
    HGGPURenderer::BufferCopyOpenGL(this, (HGBuffer *)Buffer, *(HGRect *)((char *)a2 + 20), v5);
  }
  else
  {
    (*(void (**)(HGBitmap *))(*(void *)v4 + 16))(v4);
    Buffer = (char *)v5;
  }
  uint64_t v7 = HGGPURenderer::ConvertToGLTexture(this, *(HGRect *)(Buffer + 20), (HGBitmap *)Buffer);
  (*(void (**)(HGBitmap *))(*(void *)v5 + 24))(v5);
  (*(void (**)(char *))(*(void *)Buffer + 24))(Buffer);
  return v7;
}

HGBitmap *HGGPURenderer::GetMetalTexture(HGGPURenderer *this, HGBitmap *a2, char *a3)
{
  if (*((unsigned char *)this + 809))
  {
    uint64_t v5 = *((void *)this + 146);
    if (v5)
    {
      HGGLContext::context((uint64_t *)&v9, *((HGGLContext **)this + 143));
      HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v10, v5, &v9);
      PCSharedCount::PCSharedCount(&v9);
      uint64_t v6 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)this, *(HGRect *)((char *)a2 + 20), a2, 1);
      (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
      HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v10);
      return v6;
    }
    else
    {
      *(void *)&v8.int var0 = *(void *)((char *)a2 + 20);
      *(void *)&v8.unsigned int var2 = *(void *)((char *)a2 + 28);
      return HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)this, v8, a2, 1);
    }
  }
  else
  {
    HGLogger::warning((HGLogger *)"Invalid Renderer", (const char *)a2, a3);
    return 0;
  }
}

void sub_1B776678C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
}

void sub_1B77667A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

HGBitmap *HGGPURenderer::ConvertToMetalTexture(HGMetalTexture **this, HGRect a2, HGBitmap *a3)
{
  return HGGPURenderer::ConvertToMetalTexture(this, a2, a3, 1);
}

HGBitmap *HGGPURenderer::ConvertToRawMetalTexture(HGGPURenderer *this, HGBitmap *a2)
{
  uint64_t v4 = HGGPURenderer::ConvertToNonGLTexture(this, a2);
  uint64_t v5 = v4;
  if (*((unsigned char *)v4 + 12))
  {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)this, *(HGRect *)((char *)a2 + 20), *((unsigned int *)a2 + 4), 1, 0, 0, *((unsigned char *)this + 1336) == 0);
    HGGPURenderer::BufferCopyMetal(this, (HGBuffer *)Buffer, *(HGRect *)((char *)a2 + 20), v5);
  }
  else
  {
    (*(void (**)(HGBitmap *))(*(void *)v4 + 16))(v4);
    Buffer = (char *)v5;
  }
  uint64_t v7 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)this, *(HGRect *)(Buffer + 20), (HGBitmap *)Buffer, 1);
  (*(void (**)(HGBitmap *))(*(void *)v5 + 24))(v5);
  (*(void (**)(char *))(*(void *)Buffer + 24))(Buffer);
  return v7;
}

HGBitmap *HGGPURenderer::GetBitmap(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 809))
  {
    uint64_t v3 = (HGBitmap *)a2;
    int v5 = *(_DWORD *)(a2 + 12);
    if ((v5 & 0x30) != 0)
    {
      if ((v5 & 0x20) != 0)
      {
        uint64_t v13 = *(unsigned int *)(a2 + 16);
        if (v13 != a3) {
          HGLogger::warning((HGLogger *)"HGGPURenderer::GetBitmap() -- Requested format (%s) doesn't match the bitmap's format (%s) and will be ignored.", (const char *)a2, (char *)a3, *(void *)&s_HGFormatInfos[8 * a3 + 6], *(void *)&s_HGFormatInfos[8 * v13 + 6]);
        }
        char v14 = (HGBitmap *)HGObject::operator new(0x80uLL);
        HGBitmap::HGBitmap(v14, *(void *)((char *)v3 + 20), *(void *)((char *)v3 + 28), *((unsigned int *)v3 + 4));
        HGGPURenderer::ReadbackMetalTexture((HGGPURenderer *)a1, v3, v14);
        uint64_t v3 = v14;
      }
      else
      {
        uint64_t v7 = *(void *)(a1 + 1168);
        HGGLContext::context((uint64_t *)&v16, *(HGGLContext **)(a1 + 1144));
        HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v17, v7, &v16);
        PCSharedCount::PCSharedCount(&v16);
        if (*((unsigned char *)v3 + 13))
        {
          (*(void (**)(uint64_t, HGBitmap *))(*(void *)a1 + 144))(a1, v3);
          size_t v10 = (char *)HGObject::operator new(0x80uLL);
          __n128 v15 = HGBitmap::HGBitmap(v10, *(void *)((char *)v3 + 20), *(void *)((char *)v3 + 28), a3);
          (*(void (**)(uint64_t, void, void, char *, __n128))(*(void *)a1 + 344))(a1, *(void *)((char *)v3 + 20), *(void *)((char *)v3 + 28), v10, v15);
        }
        else
        {
          Buffer = HGGPURenderer::CreateBuffer(a1, *(HGRect *)((char *)v3 + 20), a3, 0, 0, 0, *(unsigned char *)(a1 + 1336) == 0);
          (*(void (**)(uint64_t, char *))(*(void *)a1 + 144))(a1, Buffer);
          (*(void (**)(uint64_t, void, HGBitmap *, void, void))(*(void *)a1 + 152))(a1, 0, v3, 0, 0);
          HGGPURenderer::Copy((HGGPURenderer *)a1, *(HGRect *)((char *)v3 + 20), 0, v9);
          (*(void (**)(uint64_t, void, void, void, void))(*(void *)a1 + 152))(a1, 0, 0, 0, 0);
          size_t v10 = (char *)HGObject::operator new(0x80uLL);
          __n128 v11 = HGBitmap::HGBitmap(v10, *(void *)(Buffer + 20), *(void *)(Buffer + 28), *((unsigned int *)Buffer + 4));
          (*(void (**)(uint64_t, void, void, char *, __n128))(*(void *)a1 + 344))(a1, *(void *)(v10 + 20), *(void *)(v10 + 28), v10, v11);
          (*(void (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
          (*(void (**)(char *))(*(void *)Buffer + 24))(Buffer);
        }
        HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v17);
        uint64_t v3 = (HGBitmap *)v10;
      }
    }
    else
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 16))(a2);
    }
    (*(void (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
    return v3;
  }
  else
  {
    HGLogger::warning((HGLogger *)"Invalid Renderer", (const char *)a2, (char *)a3);
    return 0;
  }
}

void sub_1B7766C70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
  HGObject::operator delete(v12);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(&a12);
  _Unwind_Resume(a1);
}

void sub_1B7766C90(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7766CA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11)
{
}

void sub_1B7766CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

void sub_1B7766CCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::ReadbackMetalTexture(HGGPURenderer *this, HGBitmap *a2, HGBitmap *a3)
{
  (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
  HGRect v8 = (const void *)*((void *)this + 164);
  if (v8)
  {
    if (v9)
    {
      size_t v10 = v9;
      HGMetalHandler::FinalizeCommandBuffer(v9);
      HGMetalHandler::BindBuffer(v10, 0);
    }
  }
  __n128 v11 = (id *)*((void *)this + 165);
  if (v11) {
    HGMetalCommandBufferRef::waitUntilCompleted(v11);
  }
  if ((~*((_DWORD *)a2 + 3) & 0x220) != 0
    || (MetalStorage = (HGMetalTexture *)HGMetalTexture::getMetalStorage(a2, (HGBitmap *)v6)) == 0)
  {
    HGLogger::warning((HGLogger *)"HGGPURenderer::ReadbackMetalTexture failed.", v6, v7);
  }
  else
  {
    uint64_t v13 = (id *)*((void *)this + 139);
    HGRect v14 = *(HGRect *)((char *)a3 + 20);
    HGMetalTexture::CopyTexture(MetalStorage, v13, a3, v14);
  }
}

char *HGGPURenderer::CreateBuffer(uint64_t a1, HGRect a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  return HGGPURenderer::CreateBuffer(a1, a2, a3, a4, a5, a6, *(unsigned char *)(a1 + 1336) == 0);
}

uint64_t HGGPURenderer::Copy(HGGPURenderer *this, HGRect a2, const char *a3, char *a4)
{
  int v4 = (int)a3;
  uint64_t v5 = *(void *)&a2.var2;
  uint64_t v6 = *(void *)&a2.var0;
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8) {
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"copy texture to buffer [%d %d %d %d]\n", a3, a4, *(void *)&a2.var0, a2.var1, *(void *)&a2.var2, a2.var3);
  }
  PCSharedCount v9 = (HGGLShaderCache *)*((void *)this + 161);
  HGString::sample2d((HGString *)0x60620, v4, 0, (HGString *)v26);
  uint64_t v13 = HGString::c_str(v26, v10, v11, v12);
  Entry = HGGLShaderCache::GetEntry(v9, v13);
  HGString::~HGString((HGString *)v26);
  uint64_t result = (*(uint64_t (**)(HGGPURenderer *, int *))(*(void *)this + 432))(this, Entry);
  if (result) {
    PCSharedCount v16 = 0;
  }
  else {
    PCSharedCount v16 = Entry;
  }
  uint64_t v17 = *((void *)this + 3 * v4 + 4);
  if (v16) {
    BOOL v18 = v17 == 0;
  }
  else {
    BOOL v18 = 1;
  }
  if (!v18)
  {
    uint64_t v19 = (HGHandler *)(*(uint64_t (**)(HGGPURenderer *))(*(void *)this + 368))(this);
    uint64_t v20 = *(unsigned int *)(v17 + 160);
    uint64_t v21 = *(void *)(v17 + 20);
    uint64_t v22 = *(void *)(v17 + 28);
    uint64_t TextureRect = HGGLTexture::GetTextureRect((HGGLTexture *)v17);
    LODWORD(v25) = -*(_DWORD *)(v17 + 20);
    HIDWORD(v25) = -*(_DWORD *)(v17 + 24);
    (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v19 + 32))(v19, v20, v6, v5, v21, v22, TextureRect, v24, v25);
    HGHandler::TexCoord(v19, v4, 0, 0, 0);
    (*(void (**)(HGHandler *))(*(void *)v19 + 168))(v19);
    (*(void (**)(HGHandler *))(*(void *)v19 + 40))(v19);
    *(void *)&v27.int var0 = v6;
    *(void *)&v27.unsigned int var2 = v5;
    HGGPURenderer::Rect(this, v19, v27, (v4 + 1));
    return (*(uint64_t (**)(HGGPURenderer *, HGHandler *))(*(void *)this + 392))(this, v19);
  }
  return result;
}

void sub_1B7767094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::StartGPUCapture(HGGPURenderer *this)
{
  uint64_t v1 = (OZChannelBase *)*((void *)this + 139);
  if (v1)
  {
    int v3 = *((_DWORD *)this + 366);
    if (v3)
    {
      if (v3 == 2)
      {
        int v10 = 0;
        v9[0] = (uint64_t)this;
        v9[1] = (uint64_t)&v10;
        HGGPURenderer::StartGPUCapture(void)::$_0::operator()((uint64_t)__p, v9);
        while (1)
        {
          int v4 = v8 >= 0 ? (const char *)__p : (const char *)__p[0];
          if (access(v4, 0)) {
            break;
          }
          HGGPURenderer::StartGPUCapture(void)::$_0::operator()((uint64_t)&v5, v9);
          if (SHIBYTE(v8) < 0) {
            operator delete(__p[0]);
          }
          *(_OWORD *)std::string __p = v5;
          uint64_t v8 = v6;
        }
        OZChannelBase::setRangeName(v1, (const PCString *)1);
      }
      else
      {
        HIBYTE(v8) = 0;
        LOBYTE(__p[0]) = 0;
        OZChannelBase::setRangeName(v1, 0);
      }
      if (SHIBYTE(v8) < 0) {
        operator delete(__p[0]);
      }
      *((_DWORD *)this + 366) = 0;
    }
  }
}

void sub_1B77671A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::StartGPUCapture(void)::$_0::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v21);
  int v4 = *(char *)(v3 + 1047);
  if (v4 >= 0) {
    uint64_t v5 = v3 + 1024;
  }
  else {
    uint64_t v5 = *(void *)(v3 + 1024);
  }
  if (v4 >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(v3 + 1047);
  }
  else {
    uint64_t v6 = *(void *)(v3 + 1032);
  }
  uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v5, v6);
  char v20 = 7;
  strcpy((char *)v19, "/helium");
  uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)v19, 7);
  PCSharedCount v9 = v8;
  uint64_t v10 = *v8;
  double v11 = (char *)v8 + *(void *)(*v8 - 24);
  if (*((_DWORD *)v11 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(void *)(*v8 - 24)));
    uint32x4_t v12 = std::locale::use_facet(v17, MEMORY[0x1E4FBA258]);
    int v13 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 32);
    std::locale::~locale(v17);
    *((_DWORD *)v11 + 36) = v13;
    uint64_t v10 = *v9;
  }
  *((_DWORD *)v11 + 36) = 48;
  *(uint64_t *)((char *)v9 + *(void *)(v10 - 24) + 24) = 3;
  ++*(_DWORD *)a2[1];
  HGRect v14 = (void *)std::ostream::operator<<();
  char v18 = 9;
  strcpy((char *)v17, ".gputrace");
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)v17, 9);
  if (v18 < 0)
  {
    operator delete(v17[0].__locale_);
    if ((v20 & 0x80000000) == 0) {
      goto LABEL_11;
    }
  }
  else if ((v20 & 0x80000000) == 0)
  {
    goto LABEL_11;
  }
  operator delete(v19[0]);
LABEL_11:
  std::stringbuf::str();
  v21[0] = *MEMORY[0x1E4FBA408];
  uint64_t v15 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v21 + *(void *)(v21[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v22[0] = v15;
  v22[1] = MEMORY[0x1E4FBA470] + 16;
  if (v23 < 0) {
    operator delete((void *)v22[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BA9BFAB0](&v24);
}

void sub_1B77674AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if ((a21 & 0x80000000) == 0)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a22);
    _Unwind_Resume(a1);
  }
  operator delete(__p);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void sub_1B7767540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::RenderBgn(HGGPURenderer *this, int a2)
{
  HGRenderer::RenderBgn(this, a2);
  if (*((unsigned char *)this + 1281))
  {
    HGCVGLTextureFactory::flush(*((CVOpenGLESTextureCacheRef **)this + 147));
    HGGLState::startContextTracking(*((HGGLState **)this + 146));
    HGTextureManager::renderBgn(*((HGTextureManager **)this + 184));
    uint64_t v3 = *((void *)this + 146);
    if (v3)
    {
      int v4 = (HGGLContext *)*((void *)this + *((unsigned int *)this + 290) + 143);
      if (v4) {
        HGGLContext::context((uint64_t *)&v8, v4);
      }
      else {
        HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v8, 0);
      }
      HGGLState::setCurrentContext(v3, &v8.var0);
      PCSharedCount::PCSharedCount(&v8);
    }
    glIsTexture(0);
  }
  uint64_t result = HGGLShaderCache::ClearStats(*((HGGLShaderCache **)this + 161));
  uint64_t v6 = (OZChannelBase *)*((void *)this + 139);
  if (v6)
  {
    HGGPURenderer::StartGPUCapture(this);
    return OZChannelBase::setRangeName(v6, v7);
  }
  return result;
}

void sub_1B776760C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

double HGGPURenderer::RenderEnd(HGGPURenderer *this, int a2)
{
  if (HG_RENDERER_ENV::FORCE_POST_RENDER_FINISH)
  {
    BOOL v4 = 1;
    if (*((unsigned char *)this + 1281)) {
      goto LABEL_3;
    }
LABEL_10:
    *((_DWORD *)this + 311) = 0;
    goto LABEL_11;
  }
  BOOL v4 = *((_DWORD *)this + 170) != 0;
  if (!*((unsigned char *)this + 1281)) {
    goto LABEL_10;
  }
LABEL_3:
  if (*((_DWORD *)this + 311))
  {
    glFlush();
    if (*((unsigned char *)this + 1281)) {
      BOOL v5 = v4;
    }
    else {
      BOOL v5 = 0;
    }
    *((_DWORD *)this + 311) = 0;
    if (v5) {
      goto LABEL_14;
    }
LABEL_11:
    HGGPURenderer::FrameEnd(this);
    if (!v4) {
      goto LABEL_17;
    }
    goto LABEL_15;
  }
  *((_DWORD *)this + 311) = 0;
  if (!v4)
  {
    HGGPURenderer::FrameEnd(this);
    unint64_t v8 = *((unsigned int *)this + 172);
    if ((v8 & 0x80000000) != 0) {
      goto LABEL_21;
    }
    goto LABEL_18;
  }
LABEL_14:
  glFinish();
  HGGPURenderer::FrameEnd(this);
  if (!v4) {
    goto LABEL_17;
  }
LABEL_15:
  uint64_t v7 = (id *)*((void *)this + 165);
  if (v7) {
    HGMetalCommandBufferRef::waitUntilCompleted(v7);
  }
LABEL_17:
  unint64_t v8 = *((unsigned int *)this + 172);
  if ((v8 & 0x80000000) != 0) {
    goto LABEL_21;
  }
LABEL_18:
  PCSharedCount v9 = (const void *)*((void *)this + 164);
  if (v9)
  {
    if (v10) {
      HGMetalHandler::WaitForCommandBuffersCount(v10, v8);
    }
  }
LABEL_21:
  double v11 = (OZChannelBase *)*((void *)this + 139);
  if (v11) {
    OZChannelBase::setRangeName(v11, v6);
  }
  HGGPURenderer::PurgePostDeleteEvents((int64x2_t *)this);
  if (*((unsigned char *)this + 1281))
  {
    HGTextureManager::renderEnd(*((HGTextureManager **)this + 184));
    HGGLState::stopContextTracking(*((PCSharedCount **)this + 146));
  }
  HGRenderer::RenderEnd(this, a2);
  if (*((void *)this + 182))
  {
    uint64_t v15 = (void *)*((void *)this + 180);
    PCSharedCount v16 = (_OWORD *)((char *)this + 1448);
    if (v15 != (void *)((char *)this + 1448))
    {
      do
      {
        uint64_t v17 = (void *)v15[4];
        if (!v17) {
          __cxa_bad_typeid();
        }
        HGLogger::warning((HGLogger *)"ProcessNode( %p) :\n  unable to subdivide input ROI for node (or concatenated chain) : %s\n", v12, v13, v15[4], *(void *)(*(void *)(*v17 - 8) + 8) & 0x7FFFFFFFFFFFFFFFLL);
        char v18 = (void *)v15[1];
        if (v18)
        {
          do
          {
            uint64_t v19 = v18;
            char v18 = (void *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            uint64_t v19 = (void *)v15[2];
            BOOL v20 = *v19 == (void)v15;
            uint64_t v15 = v19;
          }
          while (!v20);
        }
        uint64_t v15 = v19;
      }
      while (v19 != (void *)v16);
    }
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 1440, *((void **)this + 181));
    *((void *)this + 180) = v16;
    double result = 0.0;
    _OWORD *v16 = 0u;
  }
  return result;
}

_DWORD *HGGPURenderer::FrameEnd(HGGPURenderer *this)
{
  (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
  uint64_t v2 = (const void *)*((void *)this + 164);
  if (v2)
  {
    if (v3)
    {
      BOOL v4 = v3;
      HGMetalHandler::FinalizeCommandBuffer(v3);
      HGMetalHandler::BindBuffer(v4, 0);
    }
  }
  BOOL v5 = (id *)*((void *)this + 165);
  if (v5) {
    HGMetalCommandBufferRef::waitUntilScheduled(v5);
  }
  double result = (_DWORD *)*((void *)this + 164);
  if (result)
  {
    if (result)
    {
      uint64_t v7 = (uint64_t)result;
      unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
      if ((v8 & 1) != 0 && *((int *)this + 163) >= 1)
      {
        *(void *)uint64_t v10 = 0;
        unsigned int v9 = 0;
        HGMetalHandler::GetFrameCounters(result, &v10[1], v10, &v9);
        printf("+ Helium Render Summary : %d command buffers, %d encoders, %d draw calls\n", v9, v10[0], v10[1]);
      }
      return (_DWORD *)HGMetalHandler::FrameEnd(v7);
    }
  }
  return result;
}

void *HGGPURenderer::WaitForCommandBuffers(void *this)
{
  unint64_t v1 = *((unsigned int *)this + 172);
  if ((v1 & 0x80000000) == 0)
  {
    this = (void *)this[164];
    if (this)
    {
      if (this)
      {
        return (void *)HGMetalHandler::WaitForCommandBuffersCount((HGMetalHandler *)this, v1);
      }
    }
  }
  return this;
}

void HGGPURenderer::AdjustForBufferLocation(uint64_t a1, uint64_t a2, int a3)
{
  HGLogger::setLevel((HGLogger *)"bufferAPI", 0);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v22, "bufferAPI", 1, "AdjustForBufferLocation(HGNode*)");
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
    HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"node %p : %s\n", v8, v9, a2, v7);
  }
  int NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI((HGGPURenderer *)a1, (HGNode *)a2);
  int v15 = NodeRenderAPI;
  unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
  if (v16)
  {
    uint64_t v17 = "Metal";
    if (!NodeRenderAPI) {
      uint64_t v17 = "OpenGL";
    }
    HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"node API: %s\n", v13, v14, v17);
  }
  if (a3 == 4 && v15 == 1)
  {
    BOOL v18 = 1;
    goto LABEL_19;
  }
  BOOL v18 = a3 == 5 && v15 == 0;
  if (a3 == 4 || (a3 - 1) >= 2 && !v15)
  {
LABEL_19:
    if (*(unsigned char *)(a1 + 1280))
    {
      if (!v18)
      {
        int v20 = *(_DWORD *)(a1 + 1272);
        if (v20 == 2)
        {
          HGLogger::error((HGLogger *)"%s", v11, v12, "OpenGL sharegroup : HGRendererBufferLocation is an OpenGL object.");
        }
        else if (v20 == 1)
        {
          HGLogger::warning((HGLogger *)"%s", v11, v12, "OpenGL sharegroup : HGRendererBufferLocation is an OpenGL object.");
        }
        goto LABEL_26;
      }
    }
    else
    {
      HGLogger::warning((HGLogger *)"no GL sharegroup : OpenGL HGRendererBufferLocation ignored.", v11, v12);
    }
LABEL_25:
    *(_DWORD *)(a2 + 16) |= 0x1000u;
    goto LABEL_26;
  }
  BOOL v21 = !v18;
  if (a3 == 1) {
    BOOL v21 = 0;
  }
  if (!v21) {
    goto LABEL_25;
  }
LABEL_26:
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v22);
}

void sub_1B7767C04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7767C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7767C2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::GetNodeRenderAPI(HGGPURenderer *this, HGNode *a2)
{
  LODWORD(v4) = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)this + 128))(this, 43);
  uint64_t v5 = HGNode::SupportsMetal(a2);
  int v6 = HGNode::SupportsGLSL(a2);
  if (v5 & 1) != 0 || (v6)
  {
    if (v4) {
      uint64_t v4 = v4;
    }
    else {
      uint64_t v4 = v6 ^ 1u;
    }
    if (v4 != 1)
    {
      if (v4) {
        BOOL v10 = 0;
      }
      else {
        BOOL v10 = *((unsigned char *)this + 1281) == 0;
      }
      if (!v10) {
        return v4;
      }
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v7 = (*(uint64_t (**)(HGNode *))(*(void *)a2 + 48))(a2);
    HGLogger::warning((HGLogger *)"no supported API in node %s (%p)!!", v8, v9, v7, a2);
  }
  uint64_t v4 = v5;
  if (v5) {
    BOOL v12 = 0;
  }
  else {
    BOOL v12 = *((unsigned char *)this + 1281) == 0;
  }
  if (!v12) {
    return v4;
  }
LABEL_18:
  uint64_t v13 = (*(uint64_t (**)(HGNode *))(*(void *)a2 + 48))(a2);
  HGLogger::warning((HGLogger *)"OpenGL is not supported! No render path available for node %s (%p).", v14, v15, v13, a2);
  return v4;
}

const char *HGGPURenderer::ValidateGLSharegroupSupport(const char *this, const char *a2, char *a3)
{
  int v3 = *((_DWORD *)this + 318);
  if (v3 == 2) {
    return HGLogger::error((HGLogger *)"%s", a2, a3, a2);
  }
  if (v3 == 1) {
    return HGLogger::warning((HGLogger *)"%s", a2, a3, a2);
  }
  return this;
}

HGBitmap *HGGPURenderer::AdjustForBufferLocation(HGGPURenderer *a1, HGBitmap *a2, int a3)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v34, "bufferAPI", 1, "AdjustForBufferLocation(HGBitmap*)");
  if ((int)HGLogger::getLevel((HGLogger *)"bufferAPI", v6) >= 1)
  {
    unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
    if (v9)
    {
      if ((*((_DWORD *)a2 + 3) & 0x30) != 0) {
        BOOL v10 = "no";
      }
      else {
        BOOL v10 = "yes";
      }
      HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"buffer is cpu memory : %s\n", v7, v8, v10);
    }
    unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
    if (v11)
    {
      if (*((_DWORD *)a2 + 3)) {
        BOOL v12 = "yes";
      }
      else {
        BOOL v12 = "no";
      }
      HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"buffer is IOSurface : %s\n", v7, v8, v12);
    }
    unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
    if (v13)
    {
      if ((*((_DWORD *)a2 + 3) & 0x20) != 0) {
        HGRect v14 = "yes";
      }
      else {
        HGRect v14 = "no";
      }
      HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"buffer is Metal texture : %s\n", v7, v8, v14);
    }
    unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
    if (v15)
    {
      if ((*((_DWORD *)a2 + 3) & 0x10) != 0) {
        unsigned __int8 v16 = "yes";
      }
      else {
        unsigned __int8 v16 = "no";
      }
      HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"buffer is OpenGL buffer/texture : %s\n", v7, v8, v16);
    }
  }
  char v17 = (*(uint64_t (**)(HGBitmap *))(*(void *)a2 + 64))(a2);
  if (a3 == 3) {
    char v20 = v17;
  }
  else {
    char v20 = 1;
  }
  if (v20)
  {
    if (a3 == 2)
    {
      unsigned __int8 v21 = atomic_load(HGLogger::_enabled);
      if (v21) {
        HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"convert buffer to system memory bitmap\n", v18, v19);
      }
      uint64_t v22 = (HGBitmap *)(*(uint64_t (**)(HGGPURenderer *, HGBitmap *, void))(*(void *)a1 + 96))(a1, a2, *((unsigned int *)a2 + 4));
      goto LABEL_49;
    }
    BOOL v27 = 0;
    BOOL v26 = a3 == 4;
    if (!*((unsigned char *)a1 + 1280)) {
      goto LABEL_40;
    }
  }
  else
  {
    if (!*((unsigned char *)a1 + 1280))
    {
LABEL_43:
      unsigned __int8 v30 = atomic_load(HGLogger::_enabled);
      if (v30) {
        HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"convert buffer to Metal texture\n", v18, v19);
      }
      if (HG_RENDERER_ENV::FORCE_NATIVE_TEXTURE_OUTPUT == 1) {
        uint64_t v22 = HGGPURenderer::ConvertToRawMetalTexture(a1, a2);
      }
      else {
        uint64_t v22 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)a1, *(HGRect *)((char *)a2 + 20), a2, 1);
      }
LABEL_49:
      a2 = v22;
      if (!v22) {
        goto LABEL_59;
      }
      goto LABEL_54;
    }
    int v25 = *((_DWORD *)a1 + 317);
    BOOL v26 = v25 == 0;
    BOOL v27 = v25 != 0;
    if (a3 == 4) {
      BOOL v26 = 1;
    }
  }
  if (v26)
  {
    unsigned __int8 v28 = atomic_load(HGLogger::_enabled);
    if (v28) {
      HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"convert buffer to OpenGL texture\n", v18, v19);
    }
    if (HG_RENDERER_ENV::FORCE_NATIVE_TEXTURE_OUTPUT == 1) {
      uint64_t v22 = (HGBitmap *)HGGPURenderer::ConvertToRawGLTexture(a1, a2);
    }
    else {
      uint64_t v22 = (HGBitmap *)HGGPURenderer::ConvertToGLTexture(a1, *(HGRect *)((char *)a2 + 20), a2);
    }
    goto LABEL_49;
  }
LABEL_40:
  BOOL v29 = !v27;
  if (a3 == 5) {
    BOOL v29 = 0;
  }
  if (!v29) {
    goto LABEL_43;
  }
  unsigned __int8 v31 = atomic_load(HGLogger::_enabled);
  if (v31) {
    HGLogger::log((HGLogger *)"bufferAPI", (const char *)1, (HGLogger *)"no-op. We're good.\n", v18, v19);
  }
  (*(void (**)(HGBitmap *))(*(void *)a2 + 16))(a2);
LABEL_54:
  if ((*((unsigned char *)a2 + 12) & 0x10) != 0)
  {
    int v32 = *((_DWORD *)a1 + 318);
    if (v32 == 2)
    {
      HGLogger::error((HGLogger *)"%s", v23, v24, "OpenGL sharegroup : HGGPURenderer output is an OpenGL object.");
    }
    else if (v32 == 1)
    {
      HGLogger::warning((HGLogger *)"%s", v23, v24, "OpenGL sharegroup : HGGPURenderer output is an OpenGL object.");
    }
  }
LABEL_59:
  (*(void (**)(HGGPURenderer *, void))(*(void *)a1 + 144))(a1, 0);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v34);
  return a2;
}

void sub_1B77681F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7768208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B776821C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::GenRectTexture(HGTextureManager **this, char *a2, char *a3, int a4, int a5, int a6, int a7, int a8, BOOL a9)
{
  int v14 = (int)a3;
  if (a9) {
    HGLogger::error((HGLogger *)"wrong texture creation function for shared texture", a2, a3);
  }
  HGTextureManager::TextureInfo::TextureInfo((HGTextureManager::TextureInfo *)v17, v14, a4, a5, a6, a7, a8);
  HGTextureManager::createTexture(this[184], (unsigned int *)a2, (const HGTextureManager::TextureInfo *)v17);
}

void HGGPURenderer::AddTextureUsage(HGGPURenderer *this, HGBitmap *a2)
{
  uint64_t v4 = (char *)*((void *)this + 153);
  uint64_t v5 = v4;
  unint64_t v6 = *((void *)this + 154);
  if ((unint64_t)v4 < v6)
  {
    *(void *)uint64_t v4 = a2;
    uint64_t v7 = (uint64_t)(v4 + 8);
    goto LABEL_23;
  }
  unsigned __int8 v8 = (void **)((char *)this + 1216);
  unsigned __int8 v9 = (char *)*((void *)this + 152);
  uint64_t v10 = (v4 - v9) >> 3;
  unint64_t v11 = v10 + 1;
  if ((unint64_t)(v10 + 1) >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v12 = v6 - (void)v9;
  if (v12 >> 2 > v11) {
    unint64_t v11 = v12 >> 2;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v11;
  }
  if (v13)
  {
    if (v13 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int v14 = (char *)operator new(8 * v13);
    unsigned __int8 v15 = &v14[8 * v10];
    unsigned __int8 v16 = &v14[8 * v13];
    *(void *)unsigned __int8 v15 = a2;
    uint64_t v7 = (uint64_t)(v15 + 8);
    char v17 = (char *)(v4 - v9);
    if (v4 == v9) {
      goto LABEL_21;
    }
    goto LABEL_14;
  }
  int v14 = 0;
  unsigned __int8 v15 = (char *)(8 * v10);
  unsigned __int8 v16 = 0;
  *(void *)(8 * v10) = a2;
  uint64_t v7 = 8 * v10 + 8;
  char v17 = (char *)(v4 - v9);
  if (v4 != v9)
  {
LABEL_14:
    unint64_t v18 = (unint64_t)(v17 - 8);
    if (v18 < 0x58) {
      goto LABEL_28;
    }
    if ((unint64_t)(v9 - v14) < 0x20) {
      goto LABEL_28;
    }
    uint64_t v19 = (v18 >> 3) + 1;
    uint64_t v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v5 = &v4[-v20];
    v15 -= v20;
    unsigned __int8 v21 = &v14[8 * v10 - 16];
    uint64_t v22 = (long long *)(v4 - 16);
    uint64_t v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v24 = *v22;
      *((_OWORD *)v21 - 1) = *(v22 - 1);
      *(_OWORD *)unsigned __int8 v21 = v24;
      v21 -= 32;
      v22 -= 2;
      v23 -= 4;
    }
    while (v23);
    if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_28:
      do
      {
        uint64_t v25 = *((void *)v5 - 1);
        v5 -= 8;
        *((void *)v15 - 1) = v25;
        v15 -= 8;
      }
      while (v5 != v9);
    }
    uint64_t v5 = (char *)*v8;
  }
LABEL_21:
  *((void *)this + 152) = v15;
  *((void *)this + 153) = v7;
  *((void *)this + 154) = v16;
  if (v5) {
    operator delete(v5);
  }
LABEL_23:
  *((void *)this + 153) = v7;
  *((_DWORD *)this + 310) = -1;
}

unint64_t HGGPURenderer::TextureUsageCount(HGGPURenderer *this)
{
  unint64_t result = *((unsigned int *)this + 310);
  if (result == -1)
  {
    int v3 = (unsigned char *)*((void *)this + 152);
    uint64_t v4 = (unsigned char *)*((void *)this + 153);
    int64_t v5 = v4 - v3;
    if (v4 == v3)
    {
      uint64_t v7 = 0;
      unint64_t v6 = 0;
    }
    else
    {
      if (v5 < 0) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v6 = (char *)operator new(v4 - v3);
      uint64_t v7 = &v6[8 * (v5 >> 3)];
      memcpy(v6, v3, v5);
    }
    unint64_t v8 = 126 - 2 * __clz((v7 - v6) >> 3);
    if (v7 == v6) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = v8;
    }
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **,false>((uint64_t)v6, v7, (uint64_t)&v15, v9, 1);
    if (v7 != v6)
    {
      uint64_t v10 = v6 + 8;
      while (v10 != v7)
      {
        uint64_t v11 = *((void *)v10 - 1);
        uint64_t v12 = *(void *)v10;
        v10 += 8;
        if (v11 == v12)
        {
          unint64_t v13 = v10 - 16;
          while (v10 != v7)
          {
            uint64_t v14 = v11;
            uint64_t v11 = *(void *)v10;
            if (v14 != *(void *)v10)
            {
              *((void *)v13 + 1) = v11;
              v13 += 8;
            }
            v10 += 8;
          }
          uint64_t v7 = v13 + 8;
          break;
        }
      }
    }
    if (v6) {
      operator delete(v6);
    }
    unint64_t result = (unint64_t)(v7 - v6) >> 3;
    *((_DWORD *)this + 310) = result;
  }
  return result;
}

void sub_1B77685B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (v10) {
    operator delete(v10);
  }
  _Unwind_Resume(exception_object);
}

atomic_uint *HGGPURenderer::Release(HGGPURenderer *this)
{
  if (HGGPURenderer::TextureUsageCount(this))
  {
    unsigned int v2 = atomic_load((unsigned int *)this + 2);
    if (v2 == HGGPURenderer::TextureUsageCount(this) + 1)
    {
      HGObject::Retain((uint64_t)this);
      uint64_t v3 = *((void *)this + 170);
      if (v3)
      {
        uint64_t v4 = (char *)*((void *)this + 152);
        int64_t v5 = (char *)*((void *)this + 153);
        if (v4 != v5)
        {
          while (*(void *)v4 != v3)
          {
            v4 += 8;
            if (v4 == v5)
            {
              uint64_t v4 = (char *)*((void *)this + 153);
              break;
            }
          }
        }
        int64_t v6 = v5 - (v4 + 8);
        if (v5 != v4 + 8)
        {
          memmove(v4, v4 + 8, v5 - (v4 + 8));
          uint64_t v3 = *((void *)this + 170);
        }
        *((void *)this + 153) = &v4[v6];
        *((_DWORD *)this + 310) = -1;
        (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
        *((void *)this + 170) = 0;
      }
      uint64_t v7 = *((void *)this + 171);
      if (v7)
      {
        (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
        *((void *)this + 171) = 0;
      }
      uint64_t v8 = *((void *)this + 169);
      if (v8)
      {
        (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
        *((void *)this + 169) = 0;
      }
      (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
      HGObject::Release((atomic_uint *)this);
    }
  }

  return HGObject::Release((atomic_uint *)this);
}

void HGGPURenderer::SetParameter(HGRenderer *this, const char *a2, char *a3)
{
  int v3 = (int)a3;
  switch((int)a2)
  {
    case 5:
    case 46:
      return;
    case 18:
      if (HG_RENDERER_ENV::FORCE_PAGE_SIZE == -1)
      {
        int v5 = *((_DWORD *)this + 312);
        if (v5 >= (int)a3) {
          int v5 = (int)a3;
        }
        *((_DWORD *)this + 165) = v5;
      }
      break;
    case 19:
      HGRenderer::SetParameter((uint64_t)this, 19, a3);
      int Target = HGRenderer::GetTarget(this, 393216);
      if (*((_DWORD *)this + 144) == 28
        && (Target - 394305) <= 0xFFFFFFBE
        && HG_RENDERER_ENV::LOW_MEMORY_USAGE)
      {
        uint64_t v7 = *(void (**)(HGRenderer *, uint64_t, uint64_t))(*(void *)this + 120);
        v7(this, 26, 12);
      }
      break;
    case 20:
      int v8 = *((_DWORD *)this + 145);
      HGRenderer::SetParameter((uint64_t)this, 20, a3);
      int v9 = *((_DWORD *)this + 145);
      if (v8 != v9)
      {
        if (v9 == 28)
        {
          std::string::basic_string[abi:ne180100]<0>(&v14, "highp");
        }
        else if (v9 == 24)
        {
          std::string::basic_string[abi:ne180100]<0>(&v14, "lowp");
        }
        else
        {
          std::string::basic_string[abi:ne180100]<0>(&v14, "mediump");
        }
        std::string __p = v14;
        HGGLState::resetUniforms(*((HGGLState ***)this + 146));
        HGGLShaderCache::SetPrecisionKeyword(*((void *)this + 161), &__p);
        HGGLShaderCache::ResetGLSL(*((HGGLShaderCache **)this + 161));
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      break;
    case 21:
      *((_DWORD *)this + 335) = a3;
      break;
    case 25:
      *((void *)this + 157) = (uint64_t)(int)a3 << 20;
      break;
    case 26:
      *((void *)this + 157) = (unint64_t)(float)((float)((float)(int)a3 / 100.0)
                                                        * (float)*(unint64_t *)(PCICCTransferFunctionLUT::getLUTEnd(*((PCICCTransferFunctionLUT **)this + 139))
                                                                                     + 40));
      break;
    case 35:
      if (*((unsigned char *)this + 1281) && *((void *)this + 184))
      {
        uint64_t v10 = (POTPaddingPolicy *)HGObject::operator new(0x10uLL);
        uint64_t v11 = v10;
        if (v3 == 128)
        {
          POTPaddingPolicy::POTPaddingPolicy(v10);
          uint64_t v12 = (void *)*((void *)this + 184);
          char v17 = v11;
          if (v11) {
            (*(void (**)(POTPaddingPolicy *))(*(void *)v11 + 16))(v11);
          }
          HGTextureManager::setTexturePaddingPolicy(v12, (void **)&v17);
          if (v17) {
            (*(void (**)(POTPaddingPolicy *))(*(void *)v17 + 24))(v17);
          }
          if (v11) {
            (*(void (**)(POTPaddingPolicy *))(*(void *)v11 + 24))(v11);
          }
        }
        else
        {
          BorderPaddingPolicy::BorderPaddingPolicy(v10, v3);
          unint64_t v13 = (void *)*((void *)this + 184);
          unsigned __int8 v16 = v11;
          if (v11) {
            (*(void (**)(POTPaddingPolicy *))(*(void *)v11 + 16))(v11);
          }
          HGTextureManager::setTexturePaddingPolicy(v13, (void **)&v16);
          if (v16) {
            (*(void (**)(POTPaddingPolicy *))(*(void *)v16 + 24))(v16);
          }
          if (v11) {
            (*(void (**)(POTPaddingPolicy *))(*(void *)v11 + 24))(v11);
          }
        }
      }
      break;
    case 37:
      *((unsigned char *)this + 1265) = a3 != 0;
      break;
    case 38:
      if (HG_RENDERER_ENV::FORCE_TEXTURE_STORAGE_HINT == -1) {
        *((unsigned char *)this + 1264) = (_BYTE)a3;
      }
      break;
    case 39:
      *((unsigned char *)this + 1266) = a3 != 0;
      break;
    case 43:
      *((_DWORD *)this + 317) = a3;
      if (!a3 && !*((unsigned char *)this + 1281))
      {
        *((_DWORD *)this + 317) = 1;
        HGLogger::warning((HGLogger *)"Renderer does not support OpenGL rendering! Welcome to the future!", a2, a3);
      }
      break;
    case 44:
      *((_DWORD *)this + 318) = a3;
      break;
    case 45:
      *((_DWORD *)this + 319) = a3;
      break;
    case 47:
      *((_DWORD *)this + 366) = a3;
      break;
    default:
      HGRenderer::SetParameter((uint64_t)this, (int)a2, a3);
      break;
  }
}

void sub_1B7768C74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
  _Unwind_Resume(a1);
}

int HGGPURenderer::GetParameter(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 18:
      LODWORD(a1) = *(_DWORD *)(a1 + 660);
      break;
    case 21:
      LODWORD(a1) = *(_DWORD *)(a1 + 1340);
      break;
    case 25:
      a1 = *(void *)(a1 + 1256) >> 20;
      break;
    case 26:
      LODWORD(a1) = llroundf((float)(unint64_t)(*(void *)(a1 + 1256)/ *(void *)(PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 1112))+ 40))* 100.0);
      break;
    case 27:
      LODWORD(a1) = *(_DWORD *)(a1 + 1248);
      break;
    case 43:
      LODWORD(a1) = *(_DWORD *)(a1 + 1268);
      break;
    case 44:
      LODWORD(a1) = *(_DWORD *)(a1 + 1272);
      break;
    case 45:
      LODWORD(a1) = *(_DWORD *)(a1 + 1276);
      break;
    case 47:
      LODWORD(a1) = *(_DWORD *)(a1 + 1464);
      break;
    default:
      LODWORD(a1) = HGRenderer::GetParameter(a1, a2);
      break;
  }
  return a1;
}

char *HGGPURenderer::CreateBuffer(uint64_t a1, HGRect a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(void *)&a2.var2;
  uint64_t v8 = *(void *)&a2.var0;
  int v9 = *(_DWORD *)(a1 + 620);
  if (v9 == 2) {
    a5 = 1;
  }
  if (v9) {
    BOOL v11 = a5 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11)
  {
    if (a3 == 24) {
      int v14 = 23;
    }
    else {
      int v14 = a3;
    }
    unsigned __int8 v21 = 0;
    char v15 = *(PCICCTransferFunctionLUT **)(a1 + 1112);
    if (v15)
    {
      uint64_t LUTEnd = (HGGPUResources *)PCICCTransferFunctionLUT::getLUTEnd(v15);
      DeviceResources = HGGPUResources::getDeviceResources(LUTEnd, v17);
      if (DeviceResources)
      {
        uint64_t v19 = (const char *)*((void *)DeviceResources + 3);
        if (v19)
        {
          (*(void (**)(void))(*(void *)v19 + 16))(*((void *)DeviceResources + 3));
          unsigned __int8 v21 = v19;
        }
      }
    }
    HGCVBitmap::create(&v21, v8, v7, v14, &v22);
    if (v21) {
      (*(void (**)(const char *))(*(void *)v21 + 24))(v21);
    }
    unint64_t v13 = (HGBuffer *)HGObject::operator new(0x80uLL);
    *(void *)&v24.int var0 = *(void *)((char *)v22 + 20);
    *(void *)&v24.unsigned int var2 = *(void *)((char *)v22 + 28);
    HGBuffer::HGBuffer(v13, v24, v22);
    if (v22) {
      (*(void (**)(HGBitmap *))(*(void *)v22 + 24))(v22);
    }
    return (char *)v13;
  }
  if (a4 == 1)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t, void, void, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 336))(a1, *(void *)&a2.var0, *(void *)&a2.var2, a3, a6, a7);
    unint64_t v13 = (HGBuffer *)HGObject::operator new(0x80uLL);
    HGBuffer::HGBuffer(v13, *(HGRect *)(v12 + 20), (HGBitmap *)v12);
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
    return (char *)v13;
  }

  return HGGPURenderer::CreateBuffer(a1, a2, a3, a6);
}

void sub_1B77691D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v12 = v10;
  HGObject::operator delete(v12);
  (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  _Unwind_Resume(a1);
}

char *HGGPURenderer::CreateBuffer(uint64_t a1, HGRect a2, int a3, int a4)
{
  if (a3)
  {
    uint64_t v5 = *(void *)&a2.var2;
    uint64_t v6 = *(void *)&a2.var0;
    uint64_t v7 = a1;
    HGRect v26 = a2;
    LODWORD(a1) = a2.var0;
    if (a4)
    {
      unsigned int v10 = *(_DWORD *)(v7 + 1340);
      if (v10)
      {
        uint64_t v11 = HGRectMake4i(-v10, -v10, *(_DWORD *)(v7 + 1340), v10);
        uint64_t v13 = v12;
        *(void *)&v28.int var0 = v11;
        *(void *)&v28.unsigned int var2 = v13;
        HGRect::Grow(&v26, v28);
        a2 = v26;
      }
      a1 = HGTextureManager::adjustTextureSize(*(HGTextureManager **)(v7 + 1472), a2);
      *(void *)&v26.int var0 = a1;
      *(void *)&v26.unsigned int var2 = v14;
      if (a3 != 31)
      {
LABEL_4:
        uint64_t v8 = *(void *)(v7 + 1168);
        if (!v8) {
          goto LABEL_15;
        }
        goto LABEL_11;
      }
    }
    else if (a3 != 31)
    {
      goto LABEL_4;
    }
    v26.unsigned int var2 = a1 + 6 * (((int)v5 - (int)v6 + 5) / 6u);
    uint64_t v8 = *(void *)(v7 + 1168);
    if (!v8)
    {
LABEL_15:
      HGGLContext::isES2(*(HGGLContext **)(v7 + 1144 + 8 * *(unsigned int *)(v7 + 1160)));
      unsigned __int8 v16 = (int *)&s_HGFormatInfos[8 * a3];
      int v17 = *v16;
      HGGLContext::isES2(*(HGGLContext **)(v7 + 1144 + 8 * *(unsigned int *)(v7 + 1160)));
      unsigned int v18 = v16[2];
      HGGLContext::isES2(*(HGGLContext **)(v7 + 1144 + 8 * *(unsigned int *)(v7 + 1160)));
      int v19 = v16[1];
      unsigned int v25 = 0;
      HGTextureManager::TextureInfo::TextureInfo((HGTextureManager::TextureInfo *)&v27, 3553, v26.var2 - v26.var0, v26.var3 - v26.var1, v17, v19, v18);
      HGTextureManager::createTexture(*(HGTextureManager **)(v7 + 1472), &v25, (const HGTextureManager::TextureInfo *)&v27);
      HGTextureManager::activeTexture(*(HGTextureManager **)(v7 + 1472), 0x84C0u, v20, v21, v22);
      HGTextureManager::bindTexture(*(HGTextureManager **)(v7 + 1472), 0xDE1u, v25);
      glTexParameteri(0xDE1u, 0x2800u, 9728);
      glTexParameteri(0xDE1u, 0x2801u, 9728);
      glTexParameteri(0xDE1u, 0x2802u, 33071);
      glTexParameteri(0xDE1u, 0x2803u, 33071);
      HGTextureManager::texImage2D(*(HGTextureManager **)(v7 + 1472), 3553, 0, v17, v26.var2 - v26.var0, v26.var3 - v26.var1, 0, v19, v18, 0);
      HGTextureManager::bindTexture(*(HGTextureManager **)(v7 + 1472), 0xDE1u, 0);
      int v9 = (char *)HGObject::operator new(0xB8uLL);
      HGGLBuffer::HGGLBuffer((uint64_t)v9, v6, v5, a3, v7);
      unsigned int v23 = v25;
      *((_DWORD *)v9 + 39) = v25;
      *((_DWORD *)v9 + 40) = v23;
      *((_DWORD *)v9 + 38) = 3553;
      *(HGRect *)(v9 + 136) = v26;
      v9[180] = !HGRectIsEqual(*(uint64_t *)&v26.var0, *(uint64_t *)&v26.var2, v6, v5);
      return v9;
    }
LABEL_11:
    char v15 = *(HGGLContext **)(v7 + 8 * *(unsigned int *)(v7 + 1160) + 1144);
    if (v15) {
      HGGLContext::context((uint64_t *)&v27, v15);
    }
    else {
      HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v27, 0);
    }
    HGGLState::setCurrentContext(v8, &v27.var0);
    PCSharedCount::PCSharedCount(&v27);
    goto LABEL_15;
  }
  HGLogger::error((HGLogger *)"CreateBuffer() : format == kHGFormat_Null.\n", *(const char **)&a2.var0, *(char **)&a2.var2);
  return 0;
}

void sub_1B7769568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, PCSharedCount a15)
{
}

void sub_1B776957C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

char *HGGPURenderer::CreateBuffer(uint64_t a1, HGRect a2, int a3)
{
  return HGGPURenderer::CreateBuffer(a1, a2, a3, 1);
}

void *HGGPURenderer::CreateTexture(HGGPURenderer *this, uint64_t a2, HGGPURenderer *a3)
{
  if (!*((void *)this + 3)) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 146);
  if (v4)
  {
    uint64_t v5 = (HGGLContext *)*((void *)this + *((unsigned int *)this + 290) + 143);
    if (v5) {
      HGGLContext::context((uint64_t *)&v9, v5);
    }
    else {
      HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v9, 0);
    }
    HGGLState::setCurrentContext(v4, &v9.var0);
    PCSharedCount::PCSharedCount(&v9);
  }
  if (*((unsigned char *)this + 1281))
  {
    if (*((_DWORD *)this + 311)) {
      glFlush();
    }
  }
  *((_DWORD *)this + 311) = 0;
  uint64_t v6 = *((void *)this + 3);
  if (!*(_DWORD *)(v6 + 156)) {
    return 0;
  }
  Texture = HGGLTexture::CreateTexture(*((HGGLTexture **)this + 3), this, a3);
  HGGPURenderer::AddTextureUsage(this, (HGBitmap *)v6);
  return Texture;
}

void sub_1B7769674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void *HGGPURenderer::CreateMetalTexture(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char a5, int a6)
{
  uint64_t v9 = *(void *)(a1 + 1112);
  if (*(unsigned char *)(v9 + 52))
  {
    uint64_t v12 = *(void **)(*(void *)(v9 + 16) + 16);
    uint64_t v13 = (uint64_t *)HGMetalContext::texturePool((HGMetalContext *)v9);
    HGMetalTexture::create(v12, v13, a2, a3, a4, a5, 1, a6, &v17, 0);
    if (v17)
    {
      (*(void (**)(void *))(*(void *)v17 + 16))(v17);
      uint64_t v14 = v17;
      char v15 = v17;
      if (!v17) {
        return v15;
      }
      goto LABEL_7;
    }
    char v15 = HGObject::operator new(0x80uLL);
    HGBuffer::HGBuffer((uint64_t)v15, 0, 0, a4);
    uint64_t v14 = v17;
    if (v17) {
LABEL_7:
    }
      (*(void (**)(void *))(*(void *)v14 + 24))(v14);
  }
  else
  {
    char v15 = HGObject::operator new(0x80uLL);
    HGBuffer::HGBuffer((uint64_t)v15, a2, a3, a4);
  }
  return v15;
}

void sub_1B77697C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  HGObject::operator delete(v10);
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(a1);
}

const char *HGGPURenderer::ReadBitmap(const char *this, HGRect a2, HGBitmap *a3)
{
  if (*((void *)this + 3))
  {
    int v4 = *((_DWORD *)a3 + 4);
    if (v4 != 31)
    {
      if (v4)
      {
        uint64_t v5 = *(void *)&a2.var2;
        uint64_t v6 = *(void *)&a2.var0;
        uint64_t v7 = (uint64_t)this;
        uint64_t v8 = *((void *)this + 146);
        uint64_t v9 = *(HGGLContext **)&this[8 * *((unsigned int *)this + 290) + 1144];
        if (v9) {
          HGGLContext::context((uint64_t *)&v10, v9);
        }
        else {
          HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v10, 0);
        }
        HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v11, v8, &v10);
        PCSharedCount::PCSharedCount(&v10);
        if (*(unsigned char *)(v7 + 1281) && *(_DWORD *)(v7 + 1244)) {
          glFlush();
        }
        *(_DWORD *)(v7 + 1244) = 0;
        *(void *)&v13.int var0 = v6;
        *(void *)&v13.unsigned int var2 = v5;
        HGGPURenderer::ReadBitmapClassic((HGGPURenderer *)v7, v13, a3);
      }
      return HGLogger::error((HGLogger *)"ReadBitmap() : bmp->m_Format == kHGFormat_Null. No readback attempted.\n", *(const char **)&a2.var0, *(char **)&a2.var2);
    }
  }
  return this;
}

void sub_1B7769928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
}

void sub_1B776993C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::GetCurrentContext(HGGPURenderer *this@<X0>, uint64_t *a2@<X8>)
{
  unsigned int v2 = (HGGLContext *)*((void *)this + *((unsigned int *)this + 290) + 143);
  if (v2) {
    HGGLContext::context(a2, v2);
  }
  else {
    HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)a2, 0);
  }
}

void HGGPURenderer::ReadBitmapClassic(HGGPURenderer *this, HGRect a2, HGBitmap *a3)
{
  uint64_t v3 = *(void *)&a2.var2;
  uint64_t v4 = *(void *)&a2.var0;
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  int v7 = 4352;
  kdebug_trace();
  HGRectIntersection(v4, v3, *(void *)(*((void *)this + 3) + 20), *(void *)(*((void *)this + 3) + 28));
  *(void *)uint64_t v8 = 0;
  uint64_t v9 = 0;
  HGRenderUtils::BufferFiller::BufferFiller((HGRenderUtils::BufferFiller *)v6);
}

void sub_1B7769CA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, int a19, int a20,char a21)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void HGGPURenderer::ReadBitmapWithPBO(HGGPURenderer *this, HGRect a2, HGBitmap *a3)
{
  uint64_t v3 = *(void *)&a2.var2;
  uint64_t v4 = *(void *)&a2.var0;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v8 = 4354;
  kdebug_trace();
  uint64_t v6 = *((void *)this + 3);
  (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
  (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
  if (!*((void *)this + 179)) {
    operator new();
  }
  HGRectIntersection(v4, v3, *(void *)(v6 + 20), *(void *)(v6 + 28));
  *(void *)uint64_t v9 = 0;
  uint64_t v10 = 0;
  HGRenderUtils::BufferFiller::BufferFiller((HGRenderUtils::BufferFiller *)v7);
}

void sub_1B776A3D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, PCSharedCount a12, uint64_t a13, uint64_t a14, PCSharedCount a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, char a20,int a21,int a22,char a23)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void PBOStrategy::PBOTilingPolicy::tile(_DWORD *a1, unint64_t a2, unint64_t a3, uint64_t *a4)
{
  unint64_t v4 = HIDWORD(a2);
  unint64_t v5 = HIDWORD(a3);
  a4[1] = *a4;
  unsigned int v6 = (HIDWORD(a3) - HIDWORD(a2)) / *a1;
  if (v6 != -1)
  {
    unsigned int v8 = a3;
    unint64_t v9 = a2;
    int v10 = 0;
    unsigned int v32 = (HIDWORD(a3) - HIDWORD(a2)) / *a1;
    unsigned int v33 = 6 * (((HIDWORD(a3) - HIDWORD(a2)) / (v6 + 1) + 6) / 6);
    unint64_t v30 = HIDWORD(a3);
    unsigned int v31 = a3;
    do
    {
      while (1)
      {
        unsigned int v12 = v4 + v10 * v33;
        unsigned int v13 = v10 == v6 ? v5 : v12 + v33;
        uint64_t v14 = HGRectMake4i(v9, v12, v8, v13);
        uint64_t v16 = v14;
        uint64_t v17 = v15;
        int v19 = (uint64_t *)a4[1];
        unint64_t v18 = a4[2];
        if ((unint64_t)v19 >= v18) {
          break;
        }
        uint64_t *v19 = v14;
        v19[1] = v15;
        unsigned int v6 = v32;
        a4[1] = (uint64_t)(v19 + 2);
        BOOL v11 = v10++ == v32;
        if (v11) {
          return;
        }
      }
      unint64_t v5 = v4;
      unint64_t v20 = v9;
      unsigned __int8 v21 = (uint64_t *)*a4;
      uint64_t v22 = ((uint64_t)v19 - *a4) >> 4;
      unint64_t v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 60) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v24 = v18 - (void)v21;
      if (v24 >> 3 > v23) {
        unint64_t v23 = v24 >> 3;
      }
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v25 = v23;
      }
      if (v25)
      {
        if (v25 >> 60) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        HGRect v26 = (char *)operator new(16 * v25);
        PCSharedCount v27 = (uint64_t *)&v26[16 * v22];
        *PCSharedCount v27 = v16;
        v27[1] = v17;
        uint64_t v28 = (uint64_t)v27;
        unint64_t v9 = v20;
        if (v19 == v21)
        {
LABEL_26:
          unint64_t v4 = v5;
          unsigned int v6 = v32;
          BOOL v29 = v27 + 2;
          *a4 = v28;
          a4[1] = (uint64_t)(v27 + 2);
          a4[2] = (uint64_t)&v26[16 * v25];
          LODWORD(v5) = v30;
          if (!v19) {
            goto LABEL_22;
          }
          goto LABEL_21;
        }
      }
      else
      {
        HGRect v26 = 0;
        PCSharedCount v27 = (uint64_t *)(16 * v22);
        *PCSharedCount v27 = v16;
        v27[1] = v15;
        uint64_t v28 = 16 * v22;
        unint64_t v9 = v20;
        if (v19 == v21) {
          goto LABEL_26;
        }
      }
      unsigned int v6 = v32;
      do
      {
        *(_OWORD *)(v28 - 16) = *((_OWORD *)v19 - 1);
        v28 -= 16;
        v19 -= 2;
      }
      while (v19 != v21);
      int v19 = (uint64_t *)*a4;
      unint64_t v4 = v5;
      BOOL v29 = v27 + 2;
      *a4 = v28;
      a4[1] = (uint64_t)(v27 + 2);
      a4[2] = (uint64_t)&v26[16 * v25];
      LODWORD(v5) = v30;
      if (!v19) {
        goto LABEL_22;
      }
LABEL_21:
      operator delete(v19);
LABEL_22:
      unsigned int v8 = v31;
      a4[1] = (uint64_t)v29;
      BOOL v11 = v10++ == v6;
    }
    while (!v11);
  }
}

void PBOStrategy::Pipeliner::addStage(char **a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = a3;
  int v7 = a1[1];
  unint64_t v6 = (unint64_t)a1[2];
  if ((unint64_t)v7 < v6)
  {
    *(void *)int v7 = a2;
    *((void *)v7 + 1) = a3;
    uint64_t v8 = (uint64_t)(v7 + 16);
    goto LABEL_18;
  }
  unint64_t v9 = *a1;
  uint64_t v10 = (v7 - *a1) >> 4;
  unint64_t v11 = v10 + 1;
  if ((unint64_t)(v10 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v12 = v6 - (void)v9;
  if (v12 >> 3 > v11) {
    unint64_t v11 = v12 >> 3;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v11;
  }
  if (v13)
  {
    if (v13 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v14 = (char *)operator new(16 * v13);
    uint64_t v15 = &v14[16 * v10];
    uint64_t v16 = &v14[16 * v13];
    *(void *)uint64_t v15 = a2;
    *((void *)v15 + 1) = v5;
    uint64_t v8 = (uint64_t)(v15 + 16);
    if (v7 == v9) {
      goto LABEL_16;
    }
    goto LABEL_14;
  }
  uint64_t v15 = (char *)(16 * v10);
  uint64_t v16 = 0;
  *(void *)uint64_t v15 = a2;
  *((void *)v15 + 1) = a3;
  uint64_t v8 = 16 * v10 + 16;
  if (v7 != v9)
  {
    do
    {
LABEL_14:
      *((_OWORD *)v15 - 1) = *((_OWORD *)v7 - 1);
      v15 -= 16;
      v7 -= 16;
    }
    while (v7 != v9);
    int v7 = *a1;
  }
LABEL_16:
  *a1 = v15;
  a1[1] = (char *)v8;
  a1[2] = v16;
  if (v7) {
    operator delete(v7);
  }
LABEL_18:
  a1[1] = (char *)v8;
}

void PBOStrategy::Pipeliner::execute(PBOStrategy::Pipeliner *this)
{
}

void **std::vector<HGRef<HGBitmap>>::~vector[abi:ne180100](void **a1)
{
  unsigned int v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    unint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *((void *)v3 - 1);
        v3 -= 8;
        uint64_t v5 = v6;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
        }
      }
      while (v3 != v2);
      unint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

HGBuffer *HGGPURenderer::LoadNullBuffer(HGGPURenderer *this)
{
  unsigned int v2 = (void *)*((void *)this + 169);
  if (!v2)
  {
    unsigned int v2 = HGObject::operator new(0x80uLL);
    uint64_t v3 = HGRectMake4i(0, 0, 0, 0);
    HGBitmap::HGBitmap(v2, v3, v4, 24);
    *((void *)this + 169) = v2;
  }
  (*(void (**)(void *))(*(void *)v2 + 16))(v2);
  uint64_t v5 = *((void *)this + 169);
  uint64_t v6 = (HGBuffer *)HGObject::operator new(0x80uLL);
  HGBuffer::HGBuffer(v6, *(HGRect *)(v5 + 20), (HGBitmap *)v5);
  (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  return v6;
}

void sub_1B776AD60(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B776AD74(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

unsigned int *HGGPURenderer::LoadNullGLTexture(HGGPURenderer *this)
{
  uint64_t v2 = *((void *)this + 170);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    return (unsigned int *)*((void *)this + 170);
  }
  else
  {
    uint64_t v3 = (unsigned int *)HGObject::operator new(0xC8uLL);
    *(void *)&v12.int var0 = 0;
    *(void *)&v12.unsigned int var2 = 0;
    HGGLTexture::HGGLTexture((HGGLTexture *)v3, v12, 0, this);
    HGTextureManager::TextureInfo::TextureInfo((HGTextureManager::TextureInfo *)v11, 3553, 1, 1, 6408, 6408, 5121);
    HGTextureManager::createTexture(*((HGTextureManager **)this + 184), v3 + 42, (const HGTextureManager::TextureInfo *)v11);
    HGTextureManager::activeTexture(*((HGTextureManager **)this + 184), 0x84C0u, v4, v5, v6);
    HGTextureManager::bindTexture(*((HGTextureManager **)this + 184), 0xDE1u, v3[42]);
    v3[40] = 3553;
    *((void *)v3 + 22) = *((void *)v3 + 21);
    HGTextureManager::texImage2D(*((HGTextureManager **)this + 184), 3553, 0, 6408, 1, 1, 0, 6408, 0x1401u, &HGGPURenderer::LoadNullGLTexture(void)::black_pixel);
    HGTextureManager::bindTexture(*((HGTextureManager **)this + 184), 0xDE1u, 0);
    unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
    if (v9) {
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"Uploading black texture to ID %d\n", v7, v8, *((void *)v3 + 21));
    }
    *((void *)this + 170) = v3;
    (*(void (**)(unsigned int *))(*(void *)v3 + 16))(v3);
    HGGPURenderer::AddTextureUsage(this, *((HGBitmap **)this + 170));
  }
  return v3;
}

void sub_1B776AF2C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::LoadNullMetalTexture(HGGPURenderer *this)
{
  uint64_t v2 = *((void *)this + 171);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    return *((void *)this + 171);
  }
  else
  {
    uint64_t v4 = HGRectMake4i(0, 0, 1u, 1u);
    uint64_t v6 = v5;
    int v7 = (char *)HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap(v7, v4, v6, 24);
    bzero(*((void **)v7 + 10), *((void *)v7 + 9));
    uint64_t v8 = (HGMetalContext *)*((void *)this + 139);
    unsigned __int8 v9 = *(void **)(*((void *)v8 + 2) + 16);
    uint64_t v10 = (uint64_t *)HGMetalContext::texturePool(v8);
    HGMetalTexture::createWithCopy(v9, v10, (uint64_t)v7, *(void *)(v7 + 20), *(void *)(v7 + 28), 0, 0, &v13);
    (*(void (**)(HGMetalTexture *))(*(void *)v13 + 16))(v13);
    unint64_t v11 = v13;
    *((void *)this + 171) = v13;
    (*(void (**)(HGMetalTexture *))(*(void *)v11 + 16))(v11);
    uint64_t v12 = *((void *)this + 171);
    if (v13) {
      (*(void (**)(HGMetalTexture *))(*(void *)v13 + 24))(v13);
    }
    (*(void (**)(char *))(*(void *)v7 + 24))(v7);
    return v12;
  }
}

void sub_1B776B0E0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

unsigned int *HGGPURenderer::LoadTexture(HGGPURenderer *this, HGRect a2, HGBitmap *a3)
{
  return HGGPURenderer::LoadTexture(this, a2, a3, 1);
}

unsigned int *HGGPURenderer::LoadTexture(HGGPURenderer *this, HGRect a2, HGBitmap *a3, int a4)
{
  uint64_t v6 = *(void *)&a2.var2;
  uint64_t v7 = *(void *)&a2.var0;
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v135, "lt", 1, "HGGPURenderer::LoadTexture");
  uint64_t v9 = *((void *)this + 146);
  uint64_t v10 = (HGGLContext *)*((void *)this + *((unsigned int *)this + 290) + 143);
  if (v10) {
    HGGLContext::context((uint64_t *)&v133, v10);
  }
  else {
    HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v133, 0);
  }
  HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v134, v9, &v133);
  PCSharedCount::PCSharedCount(&v133);
  if (!a3)
  {
    NullGLTexture = HGGPURenderer::LoadNullGLTexture(this);
    goto LABEL_9;
  }
  *(void *)&v132.int var0 = 0;
  *(void *)&v132.int var2 = 0;
  *(void *)&v132.int var0 = HGRectIntersection(v7, v6, *(void *)((char *)a3 + 20), *(void *)((char *)a3 + 28));
  *(void *)&v132.int var2 = v11;
  if (HGRect::IsNull(&v132) || *((_DWORD *)a3 + 4) == 31)
  {
LABEL_7:
    NullGLTexture = HGGPURenderer::LoadNullGLTexture(this);
LABEL_9:
    uint64_t v14 = NullGLTexture;
    goto LABEL_10;
  }
  CVBitmapStorage = HGCVBitmap::getCVBitmapStorage(a3, v12);
  if (CVBitmapStorage)
  {
    (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
    uint64_t v17 = (const void *)*((void *)this + 164);
    if (v17)
    {
      if (v18)
      {
        int v19 = v18;
        HGMetalHandler::FinalizeCommandBuffer(v18);
        HGMetalHandler::BindBuffer(v19, 0);
      }
    }
    unint64_t v20 = (id *)*((void *)this + 165);
    if (v20) {
      HGMetalCommandBufferRef::waitUntilScheduled(v20);
    }
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v128, "lt", 1, "LoadTexture -- via CVOpenGLTextureCacheCreateTextureFromImage");
    uint64_t v21 = *((void *)this + 147);
    (*(void (**)(void *))(*(void *)CVBitmapStorage + 16))(CVBitmapStorage);
    *(void *)&v131.int var0 = CVBitmapStorage;
    HGCVGLTextureFactory::create(&__p, v21, &v131);
    if (*(void *)&v131.var0) {
      (*(void (**)(void))(**(void **)&v131.var0 + 24))(*(void *)&v131.var0);
    }
    uint64_t v22 = (HGBitmap *)__p;
    if (__p)
    {
      EdgePolicy = (const HGEdgePolicy *)HGBitmap::GetEdgePolicy(a3);
      HGBitmap::SetEdgePolicy(v22, EdgePolicy);
      HGGLTexture::AssignRenderer((HGGLTexture *)__p, this);
      if (!__p)
      {
        uint64_t v14 = 0;
        goto LABEL_29;
      }
      (*(void (**)(void *))(*(void *)__p + 16))(__p);
      uint64_t v24 = __p;
      uint64_t v14 = (unsigned int *)__p;
      if (!__p) {
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v14 = HGGPURenderer::LoadNullGLTexture(this);
      uint64_t v24 = __p;
      if (!__p)
      {
LABEL_29:
        HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v128);
        goto LABEL_10;
      }
    }
    (*(void (**)(void *))(*(void *)v24 + 24))(v24);
    goto LABEL_29;
  }
  if (!*((void *)a3 + 10)) {
    goto LABEL_7;
  }
  int v25 = *((_DWORD *)a3 + 4);
  uint64_t v26 = (v25 - 14);
  uint64_t v27 = *((void *)a3 + 8) % *((void *)a3 + 7);
  if (v26 >= 3)
  {
    if (v25 == 31)
    {
      v132.int var2 = vcvts_n_s32_f32(ceilf((float)v132.var2 / 6.0), 2uLL);
      v132.int var0 = vcvts_n_s32_f32(floorf((float)v132.var0 / 6.0), 2uLL);
      uint64_t v28 = *(void *)&v132.var0;
      LODWORD(v26) = vcvtps_s32_f32((float)((float)v132.var2 * 3.0) * 0.5);
      unint64_t v29 = *(void *)&v132.var2 & 0xFFFFFFFF00000000 | v26;
      int var0 = vcvtms_s32_f32((float)((float)v132.var0 * 3.0) * 0.5);
    }
    else
    {
      uint64_t v28 = *(void *)&v132.var0;
      unint64_t v29 = *(void *)&v132.var2;
      int var0 = v132.var0;
    }
  }
  else
  {
    v132.int var2 = vcvtps_s32_f32((float)v132.var2 * 0.5);
    v132.int var0 = vcvtms_s32_f32((float)v132.var0 * 0.5);
    uint64_t v28 = *(void *)&v132.var0;
    unint64_t v29 = *(void *)&v132.var2 & 0xFFFFFFFF00000000 | (int)(float)((float)v132.var2 + (float)v132.var2);
    int var0 = (int)(float)((float)(int)v28 + (float)(int)v28);
  }
  GLint v31 = s_Alignments[v27];
  HGRect v131 = v132;
  if (a4 && !*(_DWORD *)HGBitmap::GetEdgePolicy(a3))
  {
    unsigned int v32 = *((_DWORD *)this + 335);
    if (v32)
    {
      uint64_t v33 = HGRectMake4i(-v32, -v32, v32, *((_DWORD *)this + 335));
      uint64_t v35 = v34;
      *(void *)&v136.int var0 = v33;
      *(void *)&v136.int var2 = v35;
      HGRect::Grow(&v131, v136);
    }
    *(void *)&v131.int var0 = HGTextureManager::adjustTextureSize(*((HGTextureManager **)this + 184), v131);
    *(void *)&v131.int var2 = v36;
  }
  unsigned int v116 = var0;
  BOOL IsEqual = HGRectIsEqual(*(uint64_t *)&v131.var0, *(uint64_t *)&v131.var2, *(uint64_t *)&v132.var0, *(uint64_t *)&v132.var2);
  unsigned __int8 v40 = atomic_load(HGLogger::_enabled);
  if (v40) {
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"bitmap rect : [%d %d %d %d]\n", v37, v38, *((unsigned int *)a3 + 5), *((unsigned int *)a3 + 6), *((unsigned int *)a3 + 7), *((unsigned int *)a3 + 8));
  }
  unsigned __int8 v41 = atomic_load(HGLogger::_enabled);
  if (v41) {
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"inter rect  : [%d %d %d %d]\n", v37, v38, v132.var0, v132.var1, v132.var2, v132.var3);
  }
  unsigned __int8 v42 = atomic_load(HGLogger::_enabled);
  if (v42) {
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"padded rect : [%d %d %d %d]\n", v37, v38, v131.var0, v131.var1, v131.var2, v131.var3);
  }
  unsigned __int8 v43 = atomic_load(HGLogger::_enabled);
  if (v43)
  {
    uint64_t v44 = "no";
    if (!IsEqual) {
      uint64_t v44 = "yes";
    }
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"padded : %s\n", v37, v38, v44);
  }
  int var2 = v131.var2;
  int var3 = v131.var3;
  int v48 = v131.var0;
  int var1 = v131.var1;
  unsigned __int8 v49 = atomic_load(HGLogger::_enabled);
  if (v49) {
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"FORCE_UPLOAD_SUB_IMAGE    : %s\n", v37, v38, "no");
  }
  unsigned __int8 v50 = atomic_load(HGLogger::_enabled);
  if (v50) {
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"FORCE_UPLOAD_LINE_BY_LINE : %s\n", v37, v38, "no");
  }
  unsigned __int8 v51 = atomic_load(HGLogger::_enabled);
  if (v51) {
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"FORCE_TEX_COPY            : %s\n", v37, v38, "no");
  }
  (*(void (**)(HGBitmap *))(*(void *)a3 + 16))(a3);
  uint64_t v54 = *((void *)a3 + 7);
  uint64_t v55 = *((void *)a3 + 8);
  BOOL v118 = IsEqual;
  BOOL v56 = IsEqual && v54 * (v131.var2 - v131.var0) == v55;
  uint64_t v114 = v54 * (v132.var2 - v132.var0);
  uint64_t v115 = *((void *)a3 + 8);
  BOOL v121 = v56;
  int v57 = v114 == v55 || v56;
  unsigned __int8 v58 = atomic_load(HGLogger::_enabled);
  if (v58) {
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"NO_GL_UNPACK_ROW_LENGTH : %s\n", v52, v53, "yes");
  }
  unsigned __int8 v59 = atomic_load(HGLogger::_enabled);
  if (v59)
  {
    uint64_t v60 = "no";
    if (v121) {
      uint64_t v60 = "yes";
    }
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"canUploadFull     : %s\n", v52, v53, v60);
  }
  unsigned __int8 v61 = atomic_load(HGLogger::_enabled);
  if (v61)
  {
    float32x4_t v62 = "no";
    if (v114 == v115) {
      float32x4_t v62 = "yes";
    }
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"canUploadSubImage : %s\n", v52, v53, v62);
  }
  unsigned __int8 v63 = atomic_load(HGLogger::_enabled);
  if (v63)
  {
    unint64_t v64 = "no";
    if (!v118) {
      unint64_t v64 = "yes";
    }
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"needBorderUpload  : %s\n", v52, v53, v64);
  }
  unsigned __int8 v65 = atomic_load(HGLogger::_enabled);
  if (v65)
  {
    unint64_t v66 = "yes";
    if (v121) {
      unint64_t v66 = "no";
    }
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"uploadSubImage    : %s\n", v52, v53, v66);
  }
  unsigned __int8 v67 = atomic_load(HGLogger::_enabled);
  if (v67)
  {
    unint64_t v68 = "yes";
    if (v57) {
      unint64_t v68 = "no";
    }
    HGLogger::log((HGLogger *)"lt", (const char *)1, (HGLogger *)"uploadLineByLine  : %s\n", v52, v53, v68);
  }
  HGGLContext::isES2(*((HGGLContext **)this + *((unsigned int *)this + 290) + 143));
  uint64_t v14 = (unsigned int *)HGObject::operator new(0xC8uLL);
  *(void *)&v137.int var0 = v28 & 0xFFFFFFFF00000000 | v116;
  *(void *)&v137.int var2 = v29;
  HGGLTexture::HGGLTexture((HGGLTexture *)v14, v137, a3, this);
  float32x4_t v69 = (int *)&s_HGFormatInfos[8 * v14[4]];
  int v70 = *v69;
  int v71 = v69[1];
  int v72 = v69[2];
  *(HGRect *)(v14 + 5) = v132;
  HGTextureManager::TextureInfo::TextureInfo((HGTextureManager::TextureInfo *)v128, 3553, var2 - v48, var3 - var1, v70, v71, v72);
  if (v121)
  {
    uint64_t v73 = *((void *)v14 + 8);
    uint64_t v129 = *((void *)v14 + 10);
    uint64_t v130 = v73;
  }
  HGTextureManager::createTexture(*((HGTextureManager **)this + 184), v14 + 42, (const HGTextureManager::TextureInfo *)v128);
  HGTextureManager::activeTexture(*((HGTextureManager **)this + 184), 0x84C0u, v74, v75, v76);
  HGTextureManager::bindTexture(*((HGTextureManager **)this + 184), 0xDE1u, v14[42]);
  v14[40] = 3553;
  *((void *)v14 + 22) = *((void *)v14 + 21);
  *((HGRect *)v14 + 9) = v131;
  if (!v121) {
    HGTextureManager::texImage2D(*((HGTextureManager **)this + 184), (const HGTextureManager::TextureInfo *)v128);
  }
  glPixelStorei(0xCF5u, v31);
  if (v121)
  {
    HGTextureManager::texImage2D(*((HGTextureManager **)this + 184), (const HGTextureManager::TextureInfo *)v128);
  }
  else
  {
    uint64_t v77 = *((void *)v14 + 10);
    unsigned int v78 = v14[5];
    unsigned int v79 = v14[6];
    GLint v80 = v78 - v131.var0;
    GLint v81 = v79 - v131.var1;
    GLsizei v82 = v14[7] - v78;
    uint64_t v83 = v14[8] - v79;
    if (v114 == v115)
    {
      float v84 = &s_HGFormatInfos[8 * v14[4]];
      glTexSubImage2D(0xDE1u, 0, v80, v81, v82, v83, v84[1], v84[2], *((const GLvoid **)v14 + 10));
    }
    else if ((int)v83 >= 1)
    {
      for (uint64_t i = 0; i != v83; ++i)
      {
        float v86 = &s_HGFormatInfos[8 * v14[4]];
        glTexSubImage2D(0xDE1u, 0, v80, v81 + i, v82, 1, v86[1], v86[2], (const GLvoid *)(v77 + *((void *)v14 + 8) * i));
      }
    }
  }
  glPixelStorei(0xCF5u, 4);
  if (v118)
  {
    int v89 = !v121;
    unsigned __int8 v90 = atomic_load(HGLogger::_enabled);
    if ((v90 & 1) == 0) {
      goto LABEL_118;
    }
  }
  else
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v127, "lt", 1, "border sub-tex image");
    std::string __p = 0;
    float32x4_t v125 = 0;
    uint64_t v126 = 0;
    signed int v91 = v132.var0;
    int v92 = v132.var3;
    int v122 = v132.var2;
    signed int v93 = v131.var0;
    unint64_t v94 = v131.var2;
    signed int v95 = v131.var3;
    if (v131.var1 >= v132.var1)
    {
      unsigned int v98 = 0;
      unsigned int v96 = v132.var1;
      signed int v99 = v132.var3;
    }
    else
    {
      int v117 = v132.var0;
      unsigned int v119 = v131.var2;
      unsigned int v96 = v132.var1;
      *(void *)&long long v123 = HGRectMake4i(v131.var0, v131.var1, v131.var2, v132.var1);
      *((void *)&v123 + 1) = v97;
      std::vector<HGRect>::push_back[abi:ne180100]((char **)&__p, &v123);
      unsigned int v98 = (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - v123);
      signed int v99 = v92;
      unint64_t v94 = v119;
      signed int v91 = v117;
    }
    if (v95 > v99)
    {
      unsigned int v120 = v96;
      signed int v100 = v91;
      long long v123 = 0uLL;
      uint64_t v101 = (unint64_t *)v94;
      *(void *)&long long v123 = HGRectMake4i(v93, v99, v94, v95);
      *((void *)&v123 + 1) = v102;
      std::vector<HGRect>::push_back[abi:ne180100]((char **)&__p, &v123);
      if (v98 <= (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - (int)v123)) {
        unsigned int v98 = (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - v123);
      }
      unint64_t v94 = (unint64_t)v101;
      signed int v91 = v100;
      unsigned int v96 = v120;
    }
    if (v93 >= v91)
    {
      signed int v105 = v122;
    }
    else
    {
      unint64_t v103 = (unint64_t *)v94;
      long long v123 = 0uLL;
      *(void *)&long long v123 = HGRectMake4i(v93, v96, v91, v99);
      *((void *)&v123 + 1) = v104;
      std::vector<HGRect>::push_back[abi:ne180100]((char **)&__p, &v123);
      if (v98 <= (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - (int)v123)) {
        unsigned int v98 = (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - v123);
      }
      signed int v105 = v122;
      unint64_t v94 = (unint64_t)v103;
    }
    if ((int)v94 > v105)
    {
      long long v123 = 0uLL;
      *(void *)&long long v123 = HGRectMake4i(v105, v96, v94, v99);
      *((void *)&v123 + 1) = v106;
      std::vector<HGRect>::push_back[abi:ne180100]((char **)&__p, &v123);
      if (v98 <= (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - (int)v123)) {
        unsigned int v98 = (HIDWORD(v123) - DWORD1(v123)) * (DWORD2(v123) - v123);
      }
    }
    size_t v107 = *((void *)a3 + 7) * v98;
    pixels = (void *)HGMemory::allocate((HGMemory *)v107, 0, (unint64_t *)v94);
    bzero(pixels, v107);
    glPixelStorei(0xCF5u, 1);
    uint64_t v109 = __p;
    uint64_t v110 = v125;
    if (__p != v125)
    {
      do
      {
        uint64_t v111 = &s_HGFormatInfos[8 * v14[4]];
        glTexSubImage2D(0xDE1u, 0, *v109 - v131.var0, v109[1] - v131.var1, v109[2] - *v109, v109[3] - v109[1], v111[1], v111[2], pixels);
        v109 += 4;
      }
      while (v109 != v110);
    }
    glPixelStorei(0xCF5u, 4);
    HGMemory::release((HGMemory *)pixels, v112);
    if (__p)
    {
      float32x4_t v125 = __p;
      operator delete(__p);
    }
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v127);
    int v89 = 1;
    unsigned __int8 v113 = atomic_load(HGLogger::_enabled);
    if ((v113 & 1) == 0) {
      goto LABEL_118;
    }
  }
  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"Uploading %s texture ID %d (%dx%d)\n", v87, v88, "2D", *((void *)v14 + 21), v14[7] - v14[5], v14[8] - v14[6]);
LABEL_118:
  if (v89) {
    glFlush();
  }
  HGTextureManager::bindTexture(*((HGTextureManager **)this + 184), 0xDE1u, 0);
  (*(void (**)(HGBitmap *))(*(void *)a3 + 24))(a3);
LABEL_10:
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v134);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v135);
  return v14;
}

void sub_1B776BDF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,char a23,uint64_t a24,char a25)
{
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)(v25 - 136));
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v25 - 112));
  _Unwind_Resume(a1);
}

void HGGPURenderer::FlushMetalCommandBuffer(HGGPURenderer *this)
{
  (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
  uint64_t v2 = (const void *)*((void *)this + 164);
  if (v2)
  {
    if (v3)
    {
      uint64_t v4 = v3;
      HGMetalHandler::FinalizeCommandBuffer(v3);
      HGMetalHandler::BindBuffer(v4, 0);
    }
  }
  uint64_t v5 = (id *)*((void *)this + 165);
  if (v5)
  {
    HGMetalCommandBufferRef::waitUntilScheduled(v5);
  }
}

void std::vector<HGRect>::push_back[abi:ne180100](char **a1, _OWORD *a2)
{
  uint64_t v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 < v4)
  {
    *(_OWORD *)uint64_t v5 = *a2;
    uint64_t v6 = v5 + 16;
LABEL_3:
    a1[1] = v6;
    return;
  }
  uint64_t v7 = *a1;
  uint64_t v8 = (v5 - *a1) >> 4;
  unint64_t v9 = v8 + 1;
  if ((unint64_t)(v8 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v10 = v4 - (void)v7;
  if (v10 >> 3 > v9) {
    unint64_t v9 = v10 >> 3;
  }
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v11 = v9;
  }
  if (v11)
  {
    if (v11 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v12 = (char *)operator new(16 * v11);
  }
  else
  {
    uint64_t v12 = 0;
  }
  unint64_t v13 = &v12[16 * v8];
  *(_OWORD *)unint64_t v13 = *a2;
  uint64_t v6 = v13 + 16;
  if (v5 != v7)
  {
    do
    {
      *((_OWORD *)v13 - 1) = *((_OWORD *)v5 - 1);
      v13 -= 16;
      v5 -= 16;
    }
    while (v5 != v7);
    uint64_t v5 = *a1;
  }
  *a1 = v13;
  a1[1] = v6;
  a1[2] = &v12[16 * v11];
  if (!v5) {
    goto LABEL_3;
  }
  operator delete(v5);
  a1[1] = v6;
}

uint64_t HGGPURenderer::SetProjectionMatrix(HGGPURenderer *this, HGTransform *a2)
{
  return (*(uint64_t (**)(void, HGTransform *))(**((void **)this + 151) + 96))(*((void *)this + 151), a2);
}

uint64_t HGGPURenderer::BindBuffer(HGGPURenderer *this, HGBitmap *a2)
{
  uint64_t v4 = *((void *)this + 146);
  if (v4)
  {
    uint64_t v5 = (HGGLContext *)*((void *)this + *((unsigned int *)this + 290) + 143);
    if (v5) {
      HGGLContext::context((uint64_t *)&v25, v5);
    }
    else {
      HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v25, 0);
    }
    HGGLState::setCurrentContext(v4, &v25.var0);
    PCSharedCount::PCSharedCount(&v25);
  }
  (*(void (**)(HGGPURenderer *, void, void, void, void))(*(void *)this + 152))(this, 0, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, void, void, void))(*(void *)this + 152))(this, 1, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, void, void, void))(*(void *)this + 152))(this, 2, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, void, void, void))(*(void *)this + 152))(this, 3, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, void, void, void))(*(void *)this + 152))(this, 4, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, void, void, void))(*(void *)this + 152))(this, 5, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, void, void, void))(*(void *)this + 152))(this, 6, 0, 0, 0);
  (*(void (**)(HGGPURenderer *, uint64_t, void, void, void))(*(void *)this + 152))(this, 7, 0, 0, 0);
  unint64_t v9 = (HGTextureManager *)*((void *)this + 184);
  if (v9) {
    HGTextureManager::activeTexture(v9, 0x84C0u, v6, v7, v8);
  }
  uint64_t v10 = (HGBitmap *)*((void *)this + 168);
  if (a2 && v10 == a2) {
    return 0;
  }
  if (v10)
  {
    (*(void (**)(HGBitmap *))(*(void *)v10 + 24))(v10);
    *((void *)this + 168) = 0;
  }
  if (a2)
  {
    *((void *)this + 168) = a2;
    (*(void (**)(HGBitmap *))(*(void *)a2 + 16))(a2);
    a2 = (HGBitmap *)*((void *)this + 168);
    if (a2)
    {
      int v14 = *((_DWORD *)a2 + 3);
      if ((v14 & 0x10) == 0)
      {
        CVBitmapStorage = HGCVBitmap::getCVBitmapStorage(*((HGBitmap **)this + 168), v12);
        if (CVBitmapStorage)
        {
          uint64_t v18 = *((void *)this + 147);
          if (v18)
          {
            int v19 = CVBitmapStorage;
            (*(void (**)(void *))(*(void *)CVBitmapStorage + 16))(CVBitmapStorage);
            uint64_t v24 = v19;
            HGCVGLTextureFactory::create(&v25, v18, &v24);
            if (v24) {
              (*(void (**)(void *))(*(void *)v24 + 24))(v24);
            }
            int var0 = v25.var0;
            int v21 = *((_DWORD *)v25.var0 + 40);
            uint64_t v22 = *((void *)v25.var0 + 21);
            a2 = (HGBitmap *)HGObject::operator new(0xB8uLL);
            HGGLBuffer::HGGLBuffer((uint64_t)a2, *(void *)((char *)var0 + 20), *(void *)((char *)var0 + 28), *((_DWORD *)var0 + 4), (uint64_t)this, v21, v22, 1);
            HGBitmap::SetStorage(a2, (HGObject *)v25.var0);
            if (v25.var0) {
              (*(void (**)(PC_Sp_counted_base *))(*(void *)v25.var0 + 24))(v25.var0);
            }
            if (a2) {
              goto LABEL_28;
            }
          }
        }
        goto LABEL_26;
      }
      if ((v14 & 0x100) == 0)
      {
        HGLogger::warning((HGLogger *)"BindBuffer() : bitmap is a texture, not a buffer", (const char *)v12, v13);
LABEL_26:
        a2 = 0;
        HGLogger::warning((HGLogger *)"BindBuffer() : couldn't bind buffer", v16, v17);
        goto LABEL_28;
      }
      (*(void (**)(void))(*(void *)a2 + 16))(*((void *)this + 168));
    }
  }
LABEL_28:
  uint64_t v11 = HGGPURenderer::BindBufferInternal(this, a2);
  if (a2) {
    (*(void (**)(HGBitmap *))(*(void *)a2 + 24))(a2);
  }
  return v11;
}

void sub_1B776C608(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  if (a10.var0) {
    (*(void (**)(PC_Sp_counted_base *))(*(void *)a10.var0 + 24))(a10.var0);
  }
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::BindBufferInternal(HGGPURenderer *this, HGBitmap *a2)
{
  if (*((unsigned char *)this + 1281)) {
    glUseProgram(0);
  }
  uint64_t v4 = *((void *)this + 3);
  if (v4)
  {
    uint64_t v5 = *((void *)this + 3);
    if (*(_DWORD *)(v4 + 156))
    {
      HGTextureManager::framebufferTexture2D(*((HGTextureManager **)this + 184), *(_DWORD *)(v4 + 152), 0);
      uint64_t v5 = *((void *)this + 3);
    }
    uint64_t v6 = (char *)*((void *)this + 152);
    uint64_t v7 = (char *)*((void *)this + 153);
    if (v6 != v7)
    {
      while (*(void *)v6 != v5)
      {
        v6 += 8;
        if (v6 == v7)
        {
          uint64_t v6 = (char *)*((void *)this + 153);
          break;
        }
      }
    }
    int64_t v8 = v7 - (v6 + 8);
    if (v7 != v6 + 8) {
      memmove(v6, v6 + 8, v7 - (v6 + 8));
    }
    *((void *)this + 153) = &v6[v8];
    *((_DWORD *)this + 310) = -1;
    HGGLBuffer::DetachRenderer(v4);
    (*(void (**)(void))(**((void **)this + 3) + 24))(*((void *)this + 3));
    *((void *)this + 3) = 0;
  }
  if (a2)
  {
    *((void *)this + 3) = a2;
    (*(void (**)(HGBitmap *))(*(void *)a2 + 16))(a2);
    uint64_t v9 = *((void *)this + 3);
    if (!v9 || *(HGGPURenderer **)(v9 + 128) != this)
    {
      (*(void (**)(void))(*(void *)v9 + 24))(*((void *)this + 3));
      *((void *)this + 3) = 0;
      HGLogger::warning((HGLogger *)"BindBufferInternal() : buffer is tied to another renderer", v10, v11);
      return 0xFFFFFFFFLL;
    }
    *((_DWORD *)this + 290) = s_HGFormatInfos[8 * *(unsigned int *)(v9 + 16) + 4];
    if (*((unsigned char *)this + 1281) && *((_DWORD *)this + 311)) {
      glFlush();
    }
    *((_DWORD *)this + 311) = 0;
    uint64_t v15 = *((void *)this + 146);
    if (v15)
    {
      uint64_t v16 = (HGGLContext *)*((void *)this + *((unsigned int *)this + 290) + 143);
      if (v16) {
        HGGLContext::context((uint64_t *)&v23, v16);
      }
      else {
        HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v23, 0);
      }
      HGGLState::setCurrentContext(v15, &v23.var0);
      PCSharedCount::PCSharedCount(&v23);
    }
    if (*(_DWORD *)(v9 + 156))
    {
      HGGPURenderer::BindCachedFramebuffer(this, *((unsigned int *)this + 290), (*(_DWORD *)(v9 + 144) - *(_DWORD *)(v9 + 136)), (*(_DWORD *)(v9 + 148) - *(_DWORD *)(v9 + 140)));
      HGTextureManager::framebufferTexture2D(*((HGTextureManager **)this + 184), *(_DWORD *)(v9 + 152), *(unsigned int *)(v9 + 156));
      unsigned __int8 v19 = atomic_load(HGLogger::_enabled);
      if (v19)
      {
        unint64_t v20 = "RECT";
        if (*(_DWORD *)(v9 + 152) == 3553) {
          unint64_t v20 = "2D";
        }
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"Drawing into FBO with %s texture ID %d\n", v17, v18, v20, *(unsigned int *)(v9 + 156));
      }
      if (*(unsigned char *)(v9 + 180))
      {
        GLsizei v21 = *(_DWORD *)(v9 + 144) - *(_DWORD *)(v9 + 136);
        GLsizei v22 = *(_DWORD *)(v9 + 148) - *(_DWORD *)(v9 + 140);
        if ((v22 * v21) > 0xFFF)
        {
          glViewport(0, 0, v21, v22);
          (*(void (**)(void, float, float, float, float, float, float))(**((void **)this + 151) + 104))(*((void *)this + 151), (float)*(int *)(v9 + 136), (float)*(int *)(v9 + 144), (float)*(int *)(v9 + 140), (float)*(int *)(v9 + 148), -1.0, 1.0);
          HGGPURenderer::Clear(this, *(HGRect *)(v9 + 20), *(HGRect *)(v9 + 136));
        }
        else
        {
          glClearColor(0.0, 0.0, 0.0, 0.0);
          glClear(0x4000u);
        }
        *(unsigned char *)(v9 + 180) = 0;
      }
      glViewport(*(_DWORD *)(v9 + 20) - *(_DWORD *)(v9 + 136), *(_DWORD *)(v9 + 24) - *(_DWORD *)(v9 + 140), *(_DWORD *)(v9 + 172), *(_DWORD *)(v9 + 176));
      (*(void (**)(void, float, float, float, float, float, float))(**((void **)this + 151) + 104))(*((void *)this + 151), (float)*(int *)(v9 + 20), (float)*(int *)(v9 + 28), (float)*(int *)(v9 + 24), (float)*(int *)(v9 + 32), -1.0, 1.0);
    }
    HGGLBuffer::AttachRenderer(v9, (uint64_t)this);
    HGGPURenderer::AddTextureUsage(this, *((HGBitmap **)this + 3));
  }
  else
  {
    *((_DWORD *)this + 290) = *((_DWORD *)this + 158) != 0;
    if (*((unsigned char *)this + 1281) && *((_DWORD *)this + 311)) {
      glFlush();
    }
    *((_DWORD *)this + 311) = 0;
    uint64_t v13 = *((void *)this + 146);
    if (v13)
    {
      int v14 = (HGGLContext *)*((void *)this + *((unsigned int *)this + 290) + 143);
      if (v14) {
        HGGLContext::context((uint64_t *)&v23, v14);
      }
      else {
        HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v23, 0);
      }
      HGGLState::setCurrentContext(v13, &v23.var0);
      PCSharedCount::PCSharedCount(&v23);
    }
  }
  return 0;
}

void sub_1B776CB10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
}

void sub_1B776CB24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
}

void HGGPURenderer::BindCachedFramebuffer(HGGPURenderer *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1FC0))
  {
    operator new();
  }
  std::mutex::lock((std::mutex *)qword_1EB9A1FB8);
  GLuint framebuffers = *((_DWORD *)this + 298);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1FC8))
  {
    qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
    qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
    qword_1EB9A1FE0 = 0;
    __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A1FC8);
  }
  int64_t v8 = (uint64_t *)qword_1EB9A1FD8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1FC8))
  {
    qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
    qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
    qword_1EB9A1FE0 = 0;
    __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A1FC8);
  }
  if (v8 == &qword_1EB9A1FD0)
  {
LABEL_7:
    int64_t v8 = &qword_1EB9A1FD0;
  }
  else
  {
    while (*((_DWORD *)v8 + 7) != framebuffers)
    {
      int64_t v8 = (uint64_t *)v8[1];
      if (v8 == &qword_1EB9A1FD0) {
        goto LABEL_7;
      }
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1FC8))
  {
    qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
    qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
    qword_1EB9A1FE0 = 0;
    __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A1FC8);
  }
  if (v8 != &qword_1EB9A1FD0
    && *((_DWORD *)v8 + 4) == a2
    && *((_DWORD *)v8 + 5) == a3
    && *((_DWORD *)v8 + 6) == a4)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A1FC8))
    {
      qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FE0 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1FC8);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A1FC8))
    {
      qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FE0 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1FC8);
    }
    uint64_t v9 = (uint64_t *)qword_1EB9A1FD8;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A1FC8))
    {
      qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FE0 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1FC8);
    }
    if (v9 != v8)
    {
      uint64_t v10 = (uint64_t *)v8[1];
      if (v10 != v9)
      {
        uint64_t v11 = *v8;
        *(void *)(v11 + 8) = v10;
        *(void *)v8[1] = v11;
        uint64_t v12 = *v9;
        *(void *)(v12 + 8) = v8;
        *int64_t v8 = v12;
        *uint64_t v9 = (uint64_t)v8;
        v8[1] = (uint64_t)v9;
      }
    }
  }
  else
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v30, "framebuffer", 2, "BindCachedFramebuffer()");
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A1FC8))
    {
      qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FE0 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1FC8);
    }
    if (v8 != &qword_1EB9A1FD0)
    {
      unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
      if (v15) {
        HGLogger::log((HGLogger *)"framebuffer", (const char *)2, (HGLogger *)"done with framebuffer (%d) - marking unused\n", v13, v14, framebuffers);
      }
      *((unsigned char *)v8 + 32) = 0;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A1FC8))
    {
      qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FE0 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1FC8);
    }
    uint64_t v16 = (uint64_t *)qword_1EB9A1FD8;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A1FC8))
    {
      qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FE0 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1FC8);
    }
    while (v16 != &qword_1EB9A1FD0)
    {
      if (*((_DWORD *)v16 + 4) == a2
        && *((_DWORD *)v16 + 5) == a3
        && *((_DWORD *)v16 + 6) == a4
        && !*((unsigned char *)v16 + 32))
      {
        goto LABEL_36;
      }
      uint64_t v16 = (uint64_t *)v16[1];
    }
    uint64_t v16 = &qword_1EB9A1FD0;
LABEL_36:
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A1FC8))
    {
      qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FE0 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1FC8);
    }
    if (v16 == &qword_1EB9A1FD0)
    {
      glGenFramebuffers(1, &framebuffers);
      GLuint v22 = framebuffers;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9A1FC8))
      {
        qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
        qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
        qword_1EB9A1FE0 = 0;
        __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
        __cxa_guard_release(&qword_1EB9A1FC8);
      }
      PCSharedCount v23 = (char *)operator new(0x28uLL);
      *((_DWORD *)v23 + 6) = a4;
      *((_DWORD *)v23 + 7) = v22;
      v23[32] = 1;
      *(_WORD *)(v23 + 33) = v28;
      v23[35] = v29;
      uint64_t v26 = qword_1EB9A1FD8;
      *(void *)PCSharedCount v23 = &qword_1EB9A1FD0;
      *((void *)v23 + 1) = v26;
      *((void *)v23 + 2) = a2 | (unint64_t)(a3 << 32);
      *(void *)uint64_t v26 = v23;
      qword_1EB9A1FD8 = (uint64_t)v23;
      ++qword_1EB9A1FE0;
      LOBYTE(v26) = atomic_load(HGLogger::_enabled);
      if (v26) {
        HGLogger::log((HGLogger *)"framebuffer", (const char *)2, (HGLogger *)"allocating new framebuffer (%d) [%d, %d, %d]\n", v24, v25, framebuffers, a2, a3, a4);
      }
    }
    else
    {
      unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
      if (v17) {
        HGLogger::log((HGLogger *)"framebuffer", (const char *)2, (HGLogger *)"found unused framebuffer (%d) [%d, %d, %d]\n", v13, v14, *((unsigned int *)v16 + 7), a2, a3, a4);
      }
      *((unsigned char *)v16 + 32) = 1;
      GLuint framebuffers = *((_DWORD *)v16 + 7);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9A1FC8))
      {
        qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
        qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
        qword_1EB9A1FE0 = 0;
        __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
        __cxa_guard_release(&qword_1EB9A1FC8);
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9A1FC8))
      {
        qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
        qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
        qword_1EB9A1FE0 = 0;
        __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
        __cxa_guard_release(&qword_1EB9A1FC8);
      }
      uint64_t v18 = (uint64_t *)qword_1EB9A1FD8;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9A1FC8))
      {
        qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
        qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
        qword_1EB9A1FE0 = 0;
        __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
        __cxa_guard_release(&qword_1EB9A1FC8);
      }
      if (v18 != v16)
      {
        unsigned __int8 v19 = (uint64_t *)v16[1];
        if (v19 != v18)
        {
          uint64_t v20 = *v16;
          *(void *)(v20 + 8) = v19;
          *(void *)v16[1] = v20;
          uint64_t v21 = *v18;
          *(void *)(v21 + 8) = v16;
          uint64_t *v16 = v21;
          uint64_t *v18 = (uint64_t)v16;
          v16[1] = (uint64_t)v18;
        }
      }
    }
    glBindFramebuffer(0x8D40u, framebuffers);
    *((_DWORD *)this + 298) = framebuffers;
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v30);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1FC0))
  {
    operator new();
  }
  std::mutex::unlock((std::mutex *)qword_1EB9A1FB8);
  FBOStrategy::cleanupCache(v27);
}

void sub_1B776D360(_Unwind_Exception *a1)
{
}

void sub_1B776D378(_Unwind_Exception *a1)
{
}

void sub_1B776D390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B776D3A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B776D3B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

BOOL HGGPURenderer::Clear(HGGPURenderer *this, HGRect a2, HGRect a3)
{
  uint64_t v3 = *(void *)&a3.var2;
  signed int var0 = a3.var0;
  uint64_t v5 = *(void *)&a2.var2;
  signed int v6 = a2.var0;
  signed int var1 = a2.var1;
  signed int v9 = a3.var1;
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v28, "gpu", 2, "clear texture borders to zero");
  BOOL v10 = var1 > v9;
  if (var1 > v9)
  {
    uint64_t v11 = HGRectMake4i(var0, v9, v3, var1);
    uint64_t v13 = v12;
    *(void *)&v29.signed int var0 = v11;
    *(void *)&v29.int var2 = v13;
    HGGPURenderer::Clear(this, v29, v13, v14);
  }
  if (SHIDWORD(v5) < SHIDWORD(v3))
  {
    uint64_t v15 = HGRectMake4i(var0, HIDWORD(v5), v3, HIDWORD(v3));
    unsigned __int8 v17 = v16;
    *(void *)&v30.signed int var0 = v15;
    *(void *)&v30.int var2 = v17;
    HGGPURenderer::Clear(this, v30, v17, v18);
    BOOL v10 = 1;
  }
  if (v6 > var0)
  {
    uint64_t v19 = HGRectMake4i(var0, var1, v6, HIDWORD(v5));
    uint64_t v21 = v20;
    *(void *)&v31.signed int var0 = v19;
    *(void *)&v31.int var2 = v21;
    HGGPURenderer::Clear(this, v31, v21, v22);
    BOOL v10 = 1;
  }
  if ((int)v5 < (int)v3)
  {
    uint64_t v23 = HGRectMake4i(v5, var1, v3, HIDWORD(v5));
    PCSharedCount v25 = v24;
    *(void *)&v32.signed int var0 = v23;
    *(void *)&v32.int var2 = v25;
    HGGPURenderer::Clear(this, v32, v25, v26);
    BOOL v10 = 1;
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v28);
  return v10;
}

void sub_1B776D530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGGPURenderer::BindMultiSampleBuffer(HGGPURenderer *this, signed int a2, int a3, const char *a4, char *a5)
{
  signed int v6 = a2;
  if (a2 == 1 && (a3 & 1) == 0)
  {
    unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
    if (v8) {
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"really?\n", a4, a5);
    }
  }
  uint64_t v9 = *((void *)this + 3);
  if (v9 && *(_DWORD *)(v9 + 16))
  {
    GLuint v10 = *((_DWORD *)this + 297);
    if (!v10)
    {
      glGenFramebuffers(1, (GLuint *)this + 297);
      GLuint v10 = *((_DWORD *)this + 297);
    }
    glBindFramebuffer(0x8D40u, v10);
    if (*((_DWORD *)this + 356) < v6) {
      signed int v6 = *((_DWORD *)this + 356);
    }
    GLuint Renderbuffer = HGTextureManager::createRenderbuffer(*((HGTextureManager **)this + 184), v6, 32856);
    *((_DWORD *)this + 299) = Renderbuffer;
    glBindRenderbuffer(0x8D41u, Renderbuffer);
    glRenderbufferStorageMultisampleAPPLE();
    glFramebufferRenderbuffer(0x8D40u, 0x8CE0u, 0x8D41u, *((_DWORD *)this + 299));
    if (a3)
    {
      GLuint v12 = HGTextureManager::createRenderbuffer(*((HGTextureManager **)this + 184), v6, 33190);
      *((_DWORD *)this + 300) = v12;
      glBindRenderbuffer(0x8D41u, v12);
      glRenderbufferStorageMultisampleAPPLE();
      glFramebufferRenderbuffer(0x8D40u, 0x8D00u, 0x8D41u, *((_DWORD *)this + 300));
    }
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearDepthf(1.0);
    glDepthMask(1u);
    glClear(0x4100u);
    glEnable(0xB71u);
    glDepthFunc(0x201u);
  }
}

void HGGPURenderer::ResolveMultiSampleBuffer(HGGPURenderer *this)
{
  glDepthMask(0);
  glDisable(0xB71u);
  glFlush();
  glBindFramebuffer(0x8CA9u, *((_DWORD *)this + 298));
  GLuint v2 = *((_DWORD *)this + 297);
  if (!v2)
  {
    glGenFramebuffers(1, (GLuint *)this + 297);
    GLuint v2 = *((_DWORD *)this + 297);
  }
  glBindFramebuffer(0x8CA8u, v2);
  glResolveMultisampleFramebufferAPPLE();
  glDiscardFramebufferEXT();
  glFramebufferRenderbuffer(0x8D40u, 0x8CE0u, 0x8D41u, 0);
  glFramebufferRenderbuffer(0x8D40u, 0x8D00u, 0x8D41u, 0);
  glBindRenderbuffer(0x8D41u, 0);
  glBindFramebuffer(0x8CA9u, 0);
  glBindFramebuffer(0x8CA8u, 0);
  uint64_t v3 = *((unsigned int *)this + 299);
  if (v3)
  {
    HGTextureManager::deleteRenderbuffer(*((HGTextureManager **)this + 184), v3);
    *((_DWORD *)this + 299) = 0;
  }
  uint64_t v4 = *((unsigned int *)this + 300);
  if (v4)
  {
    HGTextureManager::deleteRenderbuffer(*((HGTextureManager **)this + 184), v4);
    *((_DWORD *)this + 300) = 0;
  }
  glBindFramebuffer(0x8D40u, *((_DWORD *)this + 298));
  glFramebufferTexture2D(0x8D40u, 0x8CE0u, *(_DWORD *)(*((void *)this + 3) + 152), *(_DWORD *)(*((void *)this + 3) + 156), 0);
}

void HGGPURenderer::SetLastMetalCmdBuffer(uint64_t a1)
{
  GLuint v2 = *(id **)(a1 + 1320);
  if (v2)
  {
    HGMetalCommandBufferRef::~HGMetalCommandBufferRef(v2);
    MEMORY[0x1BA9BFBA0]();
  }
  *(void *)(a1 + 1320) = 0;
  operator new();
}

void sub_1B776D8E4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

void HGGPURenderer::GetContext(uint64_t a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = *(HGGLContext **)(a1 + 8 * s_HGFormatInfos[8 * a2 + 4] + 1144);
  if (v3) {
    HGGLContext::context(a3, v3);
  }
  else {
    HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)a3, 0);
  }
}

const char *HGGPURenderer::ValidateCurrentContext(const char *this)
{
  if (this[1281]) {
    BOOL v1 = HG_RENDERER_ENV::VALIDATE_CURRENT_GL_CONTEXT == 1;
  }
  else {
    BOOL v1 = 0;
  }
  if (v1)
  {
    uint64_t v2 = (uint64_t)this;
    HGGLGetCurrentContext();
    uint64_t CGColorSpace = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v6);
    PCSharedCount::PCSharedCount(&v6);
    this = (const char *)HGGLContext::ptr(*(HGGLContext **)(v2 + 1144));
    if ((const char *)CGColorSpace != this)
    {
      this = (const char *)HGGLContext::ptr(*(HGGLContext **)(v2 + 1152));
      if ((const char *)CGColorSpace != this) {
        return HGLogger::warning((HGLogger *)"ValidateCurrentContext() : Invalid OpenGL context.", v4, v5);
      }
    }
  }
  return this;
}

void sub_1B776D9C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

uint64_t HGGPURenderer::GetGLState(HGGPURenderer *this)
{
  return *((void *)this + 146);
}

uint64_t HGGPURenderer::GetProjectionMatrix(HGGPURenderer *this)
{
  return *((void *)this + 151);
}

uint64_t HGGPURenderer::BindTexture(uint64_t a1, const char *a2, char *a3, uint64_t a4, int a5)
{
  if (a2 > 7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = (uint64_t)a3;
  uint64_t v10 = *(void *)(a1 + 1168);
  if (v10)
  {
    uint64_t v11 = *(HGGLContext **)(a1 + 8 * *(unsigned int *)(a1 + 1160) + 1144);
    if (v11) {
      HGGLContext::context((uint64_t *)&v51, v11);
    }
    else {
      HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v51, 0);
    }
    HGGLState::setCurrentContext(v10, &v51.var0);
    PCSharedCount::PCSharedCount(&v51);
  }
  if (!*(unsigned char *)(a1 + 1281)) {
    goto LABEL_21;
  }
  GLuint v12 = *(HGGLContext **)(a1 + 8 * *(unsigned int *)(a1 + 1160) + 1144);
  if (v12) {
    HGGLContext::context((uint64_t *)&v51, v12);
  }
  else {
    HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v51, 0);
  }
  uint64_t CGColorSpace = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v51);
  PCSharedCount::PCSharedCount(&v51);
  if (!CGColorSpace)
  {
LABEL_21:
    if (!v7) {
      return 0;
    }
    HGLogger::warning((HGLogger *)"BindTexture() : non-null buffer but OpenGL is disallowed", a2, a3);
    return 0xFFFFFFFFLL;
  }
  uint64_t v16 = a1 + 24 * a2;
  uint64_t v19 = *(void *)(v16 + 32);
  uint64_t v18 = (uint64_t *)(v16 + 32);
  uint64_t v17 = v19;
  uint64_t v20 = v18[1];
  if (v7 || (a4 = 0, v17))
  {
    HGTextureManager::activeTexture(*(HGTextureManager **)(a1 + 1472), a2 + 33984, (uint64_t)a3, v14, v15);
    unsigned int v21 = a2;
    if (v17 == v7) {
      goto LABEL_27;
    }
    uint64_t *v18 = 0;
    if (!v7)
    {
      HGTextureManager::bindTexture(*(HGTextureManager **)(a1 + 1472), *(_DWORD *)(v17 + 160), 0);
      uint64_t v24 = 0;
      goto LABEL_45;
    }
    int v49 = *(_DWORD *)(v7 + 12) & 0x30;
    uint64_t v50 = a4;
    if (v49
      || (uint64_t v7 = (*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a1 + 352))(a1, *(void *)(v7 + 20), *(void *)(v7 + 28), v7)) != 0)
    {
      uint64_t v22 = *(void *)(v7 + 128);
      if (!v22 || v22 == a1)
      {
        uint64_t *v18 = v7;
        HGTextureManager::bindTexture(*(HGTextureManager **)(a1 + 1472), *(_DWORD *)(v7 + 160), *(unsigned int *)(v7 + 168));
        uint64_t v26 = *(HGTextureManager **)(a1 + 1472);
        char isES2 = HGGLContext::isES2(*(HGGLContext **)(a1 + 8 * *(unsigned int *)(a1 + 1160) + 1144));
        HGTextureManager::sizeHint(v26, (HGGLTexture *)v7, isES2, v28, v29);
        unsigned __int8 v32 = atomic_load(HGLogger::_enabled);
        if (v32)
        {
          uint64_t v33 = "RECT";
          if (*(_DWORD *)(v7 + 160) == 3553) {
            uint64_t v33 = "2D";
          }
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"Binding %s texture ID %d to unit %d\n", v30, v31, v33, *(void *)(v7 + 168), a2);
        }
        *(_DWORD *)(v7 + 184) |= 1 << *(_DWORD *)(a1 + 1160);
        (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
        int v34 = *(_DWORD *)(v7 + 188);
        *(_DWORD *)(v7 + 188) = v34 + 1;
        if (!v34)
        {
          HGGLTexture::AttachRenderer((HGGLTexture *)v7, (HGGPURenderer *)a1);
          HGGPURenderer::AddTextureUsage((HGGPURenderer *)a1, (HGBitmap *)v7);
        }
        GLenum v35 = *(_DWORD *)(v7 + 160);
        if (*(_DWORD *)HGBitmap::GetEdgePolicy((HGBitmap *)v7) == 1)
        {
          unsigned __int8 v38 = atomic_load(HGLogger::_enabled);
          if (v38) {
            HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"texture mode : GL_CLAMP_TO_EDGE\n", v36, v37);
          }
        }
        glTexParameteri(v35, 0x2802u, 33071);
        glTexParameteri(v35, 0x2803u, 33071);
        char v23 = 0;
        uint64_t v24 = 0;
LABEL_41:
        if (!v49 && (v23 & 1) == 0) {
          (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
        }
        a4 = v50;
        if (!v17) {
          goto LABEL_55;
        }
LABEL_45:
        int v41 = *(_DWORD *)(v17 + 188) - 1;
        *(_DWORD *)(v17 + 188) = v41;
        if (!v41)
        {
          unsigned __int8 v42 = *(char **)(a1 + 1216);
          unsigned __int8 v43 = *(char **)(a1 + 1224);
          unsigned int v48 = v21;
          if (v42 != v43)
          {
            while (*(void *)v42 != v17)
            {
              v42 += 8;
              if (v42 == v43)
              {
                unsigned __int8 v42 = *(char **)(a1 + 1224);
                break;
              }
            }
          }
          uint64_t v44 = a4;
          int64_t v45 = v43 - (v42 + 8);
          if (v43 != v42 + 8) {
            memmove(v42, v42 + 8, v43 - (v42 + 8));
          }
          *(void *)(a1 + 1224) = &v42[v45];
          *(_DWORD *)(a1 + 1240) = -1;
          a4 = v44;
          unsigned int v21 = v48;
          if ((*(unsigned char *)(v17 + 12) & 0x30) != 0) {
            HGGLTexture::DetachRenderer((HGGLTexture *)v17);
          }
        }
        (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
        goto LABEL_55;
      }
      char v23 = 0;
    }
    else
    {
      char v23 = 1;
    }
    HGTextureManager::bindTexture(*(HGTextureManager **)(a1 + 1472), 0xDE1u, 0);
    HGLogger::warning((HGLogger *)"BindTexture() : buffer is tied to another renderer", v39, v40);
    uint64_t v24 = 0xFFFFFFFFLL;
    goto LABEL_41;
  }
  unsigned int v21 = a2;
LABEL_27:
  uint64_t v24 = 0;
LABEL_55:
  if (*v18)
  {
    if (a5) {
      GLint v46 = 9729;
    }
    else {
      GLint v46 = 9728;
    }
    GLenum v47 = *(_DWORD *)(*v18 + 160);
    glTexParameteri(v47, 0x2801u, v46);
    glTexParameteri(v47, 0x2800u, v46);
  }
  v18[1] = a4;
  *(_DWORD *)(a1 + 24 * v21 + 48) = a5;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 24))(v20);
  }
  return v24;
}

void sub_1B776DEB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, PCSharedCount a16)
{
}

void sub_1B776DECC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, PCSharedCount a16)
{
}

PCICCTransferFunctionLUT *HGGPURenderer::MarkBufferedOutput(PCICCTransferFunctionLUT **this, HGNode *a2)
{
  int NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI((HGGPURenderer *)this, a2);
  int v5 = *((_DWORD *)a2 + 4) & 0x1000;
  BOOL v6 = NodeRenderAPI == 1;
  if (NodeRenderAPI != 1 && v5) {
    BOOL v6 = *((unsigned char *)a2 + 108) != 0;
  }
  BOOL v7 = NodeRenderAPI == 0;
  if (NodeRenderAPI && v5) {
    BOOL v7 = *((unsigned char *)a2 + 107) != 0;
  }
  unsigned int v8 = *((_DWORD *)a2 + 44) - *((_DWORD *)a2 + 42);
  unsigned int v9 = *((_DWORD *)a2 + 45) - *((_DWORD *)a2 + 43);
  unint64_t result = (PCICCTransferFunctionLUT *)HGRenderer::GetOutputFormat((HGRenderer *)this, a2);
  int v11 = (int)result;
  if (*((_DWORD *)a2 + 54) != -1 && *((_DWORD *)this + 153) != 1) {
    goto LABEL_44;
  }
  if (*((unsigned char *)this + 1281))
  {
    if (v6)
    {
      unint64_t result = (PCICCTransferFunctionLUT *)PCICCTransferFunctionLUT::getLUTEnd(this[139]);
      unsigned int v12 = *((_DWORD *)result + 12);
      BOOL v13 = v12 >= v8 && v12 >= v9;
      char v14 = !v13;
      char v15 = v14 ^ 1;
      if (!v13 || !v7)
      {
        int v16 = *((_DWORD *)a2 + 4);
        if (*((int *)a2 + 52) >= 2) {
          goto LABEL_21;
        }
LABEL_47:
        BOOL v17 = 0;
        if (*((_DWORD *)this + 153) == 2) {
          goto LABEL_48;
        }
        goto LABEL_50;
      }
    }
    else if (!v7)
    {
      char v15 = 1;
      int v16 = *((_DWORD *)a2 + 4);
      if (*((int *)a2 + 52) < 2) {
        goto LABEL_47;
      }
      goto LABEL_21;
    }
    unint64_t result = this[184];
    if (result)
    {
      unint64_t result = (PCICCTransferFunctionLUT *)HGTextureManager::maxTextureSizeGL((uint64_t)result, v11);
      char v15 = result >= v8 && result >= v9;
      int v16 = *((_DWORD *)a2 + 4);
      if (*((int *)a2 + 52) < 2) {
        goto LABEL_47;
      }
      goto LABEL_21;
    }
LABEL_44:
    char v15 = 0;
    int v16 = *((_DWORD *)a2 + 4);
    if (*((int *)a2 + 52) < 2) {
      goto LABEL_47;
    }
    goto LABEL_21;
  }
  unint64_t result = (PCICCTransferFunctionLUT *)PCICCTransferFunctionLUT::getLUTEnd(this[139]);
  unsigned int v18 = *((_DWORD *)result + 12);
  char v15 = v18 >= v8 && v18 >= v9;
  int v16 = *((_DWORD *)a2 + 4);
  if (*((int *)a2 + 52) < 2) {
    goto LABEL_47;
  }
LABEL_21:
  if ((v16 & 0x100) != 0)
  {
    BOOL v17 = 1;
    if (*((_DWORD *)this + 153) == 2) {
      goto LABEL_48;
    }
  }
  else
  {
    BOOL v17 = *((_DWORD *)this + 153) == 3;
    if (*((_DWORD *)this + 153) == 2) {
      goto LABEL_48;
    }
  }
LABEL_50:
  BOOL v21 = 0;
  if ((v16 & 6) != 0) {
    BOOL v17 = 1;
  }
  if ((v16 & 8) == 0 && v17)
  {
    if (!*((unsigned char *)this + 1281))
    {
      unint64_t result = (PCICCTransferFunctionLUT *)PCICCTransferFunctionLUT::getLUTEnd(this[139]);
      BOOL v21 = 0;
      unsigned int v25 = *((_DWORD *)result + 12);
      if (v25 < v8 || v25 < v9) {
        goto LABEL_49;
      }
      goto LABEL_74;
    }
    if (v6)
    {
      unint64_t result = (PCICCTransferFunctionLUT *)PCICCTransferFunctionLUT::getLUTEnd(this[139]);
      unsigned int v22 = *((_DWORD *)result + 12);
      BOOL v23 = v22 >= v8 && v22 >= v9;
      char v24 = !v23;
      if (!v23 || !v7)
      {
        if ((v24 & 1) == 0) {
          goto LABEL_74;
        }
LABEL_48:
        BOOL v21 = 0;
        goto LABEL_49;
      }
    }
    else if (!v7)
    {
LABEL_74:
      if (v11 <= 41) {
        uint64_t v26 = s_HGFormatInfos[8 * v11 + 3];
      }
      else {
        uint64_t v26 = 0;
      }
      BOOL v21 = v9 * (unint64_t)v8 * v26 < (unint64_t)this[157];
      goto LABEL_49;
    }
    unint64_t result = this[184];
    if (result)
    {
      unint64_t result = (PCICCTransferFunctionLUT *)HGTextureManager::maxTextureSizeGL((uint64_t)result, v11);
      BOOL v21 = 0;
      if (result < v8 || result < v9) {
        goto LABEL_49;
      }
      goto LABEL_74;
    }
    goto LABEL_48;
  }
LABEL_49:
  *((unsigned char *)a2 + 104) = v15 | v21;
  return result;
}

BOOL HGGPURenderer::RenderBufferedOutput(HGGPURenderer *this, HGNode *a2)
{
  int v2 = *((unsigned __int8 *)a2 + 104);
  if (*((unsigned char *)a2 + 104))
  {
    (*(void (**)(HGNode *, HGGPURenderer *))(*(void *)a2 + 416))(a2, this);
    (*(void (**)(HGNode *, HGGPURenderer *, uint64_t))(*(void *)a2 + 336))(a2, this, 1);
    BOOL v5 = (*((_DWORD *)a2 + 4) & 0x2000) == 0;
    uint64_t OutputFormat = HGRenderer::GetOutputFormat(this, a2);
    BOOL v7 = (HGBitmap *)(*(uint64_t (**)(HGGPURenderer *, HGNode *, void, void, uint64_t, void, void, BOOL))(*(void *)this + 168))(this, a2, *((void *)a2 + 21), *((void *)a2 + 22), OutputFormat, 0, 0, v5);
    unsigned int v8 = v7;
    if (*((unsigned char *)a2 + 107))
    {
      if (!*((unsigned char *)a2 + 108))
      {
        unsigned int v9 = (HGBitmap *)HGGPURenderer::ConvertToGLTexture(this, *(HGRect *)((char *)a2 + 168), v7);
LABEL_7:
        *((void *)a2 + 24) = v9;
        (*(void (**)(HGBitmap *))(*(void *)v8 + 24))(v8);
LABEL_9:
        (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
        return v2 != 0;
      }
    }
    else if (*((unsigned char *)a2 + 108))
    {
      unsigned int v9 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)this, *(HGRect *)((char *)a2 + 168), v7, 1);
      goto LABEL_7;
    }
    *((void *)a2 + 24) = v7;
    goto LABEL_9;
  }
  return v2 != 0;
}

uint64_t HGGPURenderer::RenderTilesBegin(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 212);
  *(_DWORD *)(a2 + 212) = v2 + 1;
  if (v2) {
    return result;
  }
  uint64_t v4 = (unsigned int *)result;
  *(_DWORD *)(a2 + 16) = (*(_DWORD *)(a2 + 16) >> 17) & 2 | *(_DWORD *)(a2 + 16) & 0xFFFFFFEF;
  int v5 = *(_DWORD *)(a2 + 88);
  if (v5 > 0)
  {
    uint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = *(void *)(*(void *)(a2 + 80) + 8 * v6);
      if (!v7) {
        goto LABEL_6;
      }
      uint64_t v8 = *(void *)(v7 + 16);
      if (!v8) {
        goto LABEL_6;
      }
      int v9 = *(_DWORD *)(v7 + 12);
      uint64_t v10 = v9 & 0x2006;
      if ((v9 & 0x2006) != 0)
      {
        BOOL IsNull = HGRectIsNull(*(void *)(v7 + 32), *(void *)(v7 + 40));
        uint64_t v8 = *(void *)(v7 + 16);
        if (!IsNull) {
          break;
        }
      }
      if ((*(unsigned char *)(a2 + 18) & 4) != 0) {
        goto LABEL_12;
      }
LABEL_5:
      (*(void (**)(unsigned int *, void, void, void, void))(*(void *)v4 + 240))(v4, *(void *)(v8 + 144), *(void *)(v7 + 32), *(void *)(v7 + 40), v4[144]);
      int v5 = *(_DWORD *)(a2 + 88);
LABEL_6:
      if (++v6 >= v5) {
        goto LABEL_15;
      }
    }
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v8 + 144) + 136))(*(void *)(v8 + 144), 0xFFFFFFFFLL, v10);
    uint64_t v8 = *(void *)(v7 + 16);
    if ((*(unsigned char *)(a2 + 18) & 4) == 0) {
      goto LABEL_5;
    }
LABEL_12:
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v8 + 144) + 136))(*(void *)(v8 + 144), 0xFFFFFFFFLL, 2);
    uint64_t v8 = *(void *)(v7 + 16);
    goto LABEL_5;
  }
LABEL_15:
  (*(void (**)(unsigned int *, uint64_t, uint64_t))(*(void *)v4 + 320))(v4, a2, 1);
  BOOL v12 = HGRectIsNull(*(void *)(a2 + 168), *(void *)(a2 + 176));
  uint64_t v13 = *(void *)v4;
  if (v12)
  {
    char v14 = *(uint64_t (**)(unsigned int *, uint64_t))(v13 + 232);
    return v14(v4, a2);
  }
  else
  {
    (*(void (**)(unsigned int *, uint64_t))(v13 + 192))(v4, a2);
    (*(void (**)(unsigned int *, uint64_t))(*(void *)v4 + 208))(v4, a2);
    unint64_t result = (*(uint64_t (**)(unsigned int *, uint64_t))(*(void *)v4 + 232))(v4, a2);
    if (*(_DWORD *)(a2 + 40) != 1)
    {
      char v15 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(*(void *)a2 + 336);
      return v15(a2, v4, 1);
    }
  }
  return result;
}

uint64_t HGGPURenderer::PostGetOutput(HGGPURenderer *this, HGNode *a2)
{
  uint64_t result = HGGPURenderer::GetNodeRenderAPI(this, a2);
  if (*((int *)a2 + 22) >= 1)
  {
    int v5 = result;
    for (uint64_t i = 0; i < *((int *)a2 + 22); ++i)
    {
      uint64_t v7 = *(void *)(*((void *)a2 + 10) + 8 * i);
      if (!v7) {
        continue;
      }
      uint64_t v8 = *(void *)(v7 + 16);
      if (!v8) {
        continue;
      }
      uint64_t v9 = *(void *)(v8 + 144);
      if (v5 == 1)
      {
        *(unsigned char *)(v9 + 108) = 1;
        uint64_t result = HGGPURenderer::GetNodeRenderAPI(this, (HGNode *)v9);
        if (result == 1) {
          goto LABEL_13;
        }
      }
      else
      {
        if (!v5) {
          *(unsigned char *)(v9 + 107) = 1;
        }
        uint64_t result = HGGPURenderer::GetNodeRenderAPI(this, (HGNode *)v9);
        if (result == v5)
        {
LABEL_13:
          if ((*(unsigned char *)(v7 + 13) & 0x10) == 0) {
            continue;
          }
        }
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 136))(v9, 0xFFFFFFFFLL, 4096);
    }
  }
  return result;
}

char *HGGPURenderer::RenderTiles(uint64_t a1, const char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7, unsigned __int8 a8)
{
  if (a5)
  {
    HGAutoReleasePoolScopeGuard::HGAutoReleasePoolScopeGuard((HGAutoReleasePoolScopeGuard *)&v27);
    int v16 = *(HGGLContext **)(a1 + 1144);
    if (v16 && HGGLContext::ptr(v16))
    {
      HGGLContext::getVirtualScreen(*(HGGLContext **)(a1 + 1144));
      HGGLContext::setVirtualScreen(*(HGGLContext **)(a1 + 1152));
    }
    if (a6)
    {
      if ((*(unsigned char *)(a6 + 12) & 0x30) != 0)
      {
        (*(void (**)(uint64_t))(*(void *)a6 + 16))(a6);
        if ((~*(_DWORD *)(a6 + 12) & 0x220) == 0)
        {
          MetalStorage = HGMetalTexture::getMetalStorage((HGBitmap *)a6, v17);
          if (MetalStorage)
          {
            uint64_t v19 = *(void *)(HGMetalDeviceInfo::getDeviceInfo(MetalStorage[17]) + 24);
            uint64_t LUTEnd = PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 1112));
            if (v19 != *(void *)(LUTEnd + 24))
            {
              HGLogger::error((HGLogger *)"Device mismatch between renderer (0x%llx) and target texture (0x%llx).", v21, v22, *(void *)(LUTEnd + 24), v19);
              unsigned int v25 = 0;
LABEL_16:
              HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(&v27);
              return v25;
            }
          }
        }
        char v23 = 0;
        uint64_t v24 = 0;
      }
      else
      {
        char v23 = 1;
        uint64_t v24 = a6;
        a6 = 0;
      }
    }
    else
    {
      uint64_t v24 = 0;
      char v23 = 1;
    }
    unsigned int v25 = HGGPURenderer::ProcessNode(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, v24, (char *)a6, 0, a7, a8);
    (*(void (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
    if ((v23 & 1) == 0) {
      (*(void (**)(uint64_t))(*(void *)a6 + 24))(a6);
    }
    goto LABEL_16;
  }
  HGLogger::error((HGLogger *)"RenderTiles() : format == kHGFormat_Null.\n", a2, a3);
  return 0;
}

void sub_1B776E904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B776E918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B776E92C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B776E940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B776E954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B776E968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B776E97C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B776E990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

char *HGGPURenderer::ProcessNode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, int a8, unsigned __int8 a9, unsigned __int8 a10)
{
  if (a6)
  {
    uint64_t LUTEnd = (HGMetalDeviceInfo *)PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 1112));
    if (*(unsigned char *)(a6 + 12))
    {
      char v23 = (HGBuffer *)HGObject::operator new(0x80uLL);
      HGBuffer::HGBuffer(v23, *(HGRect *)(a6 + 20), (HGBitmap *)a6);
      BOOL v21 = HGGPURenderer::ProcessNodeInternal((HGRenderer *)a1, a2, a3, a4, a5, (char *)v23, a8, a9, a10);
      if (v23) {
        (*(void (**)(HGBuffer *))(*(void *)v23 + 24))(v23);
      }
    }
    else if (HGMetalDeviceInfo::isApple(LUTEnd) {
           && *(_DWORD *)(a1 + 1268) == 1
    }
           && (*(unsigned char *)(a6 + 12) & 0x30) == 0
           && HGMetalBuffer::canCreateFromBytes((HGBitmap *)a6, v18))
    {
      uint64_t v19 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)a1, *(HGRect *)(a6 + 20), (HGBitmap *)a6, 1);
      uint64_t v20 = (HGBuffer *)HGObject::operator new(0x80uLL);
      *(void *)&v34.signed int var0 = *(void *)((char *)v19 + 20);
      *(void *)&v34.int var2 = *(void *)((char *)v19 + 28);
      HGBuffer::HGBuffer(v20, v34, v19);
      BOOL v21 = HGGPURenderer::ProcessNodeInternal((HGRenderer *)a1, a2, a3, a4, a5, (char *)v20, a8, a9, a10);
      HGGPURenderer::FinishMetalCommandBuffer((HGGPURenderer *)a1);
      if (v20) {
        (*(void (**)(HGBuffer *))(*(void *)v20 + 24))(v20);
      }
      (*(void (**)(HGBitmap *))(*(void *)v19 + 24))(v19);
    }
    else
    {
      uint64_t v24 = HGGPURenderer::ProcessNodeInternal((HGRenderer *)a1, a2, a3, a4, a5, 0, a8, a9, a10);
      uint64_t v26 = v24;
      int v27 = *((_DWORD *)v24 + 3);
      if ((v27 & 1) != 0 || (v27 & 0x30) == 0)
      {
        CVBitmapStorage = (HGCVBitmap *)HGCVBitmap::getCVBitmapStorage((HGBitmap *)v24, v25);
        if (CVBitmapStorage) {
          HGRect v31 = CVBitmapStorage;
        }
        else {
          HGRect v31 = (HGCVBitmap *)v26;
        }
        if (CVBitmapStorage) {
          HGCVBitmap::lock(CVBitmapStorage, 0);
        }
        if (*((_DWORD *)v31 + 4) == *(_DWORD *)(a6 + 16)) {
          HGRenderUtils::BufferCopier::BufferCopier((HGRenderUtils::BufferCopier *)v32);
        }
        HGRenderUtils::BufferReformatter::BufferReformatter((HGRenderUtils::BufferReformatter *)v32);
      }
      if ((v27 & 0x20) != 0)
      {
        HGGPURenderer::ReadbackMetalTexture((HGGPURenderer *)a1, (HGBitmap *)v24, (HGBitmap *)a6);
      }
      else if ((v27 & 0x100) != 0)
      {
        (*(void (**)(uint64_t, char *))(*(void *)a1 + 144))(a1, v24);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 344))(a1, a3, a4, a6);
      }
      else
      {
        *(void *)&v35.signed int var0 = a3;
        *(void *)&v35.int var2 = a4;
        Buffer = HGGPURenderer::CreateBuffer(a1, v35, a5, 0);
        (*(void (**)(uint64_t, char *))(*(void *)a1 + 144))(a1, Buffer);
        (*(void (**)(uint64_t, void, char *, void, void))(*(void *)a1 + 152))(a1, 0, v26, 0, 0);
        *(void *)&v36.signed int var0 = a3;
        *(void *)&v36.int var2 = a4;
        HGGPURenderer::Copy((HGGPURenderer *)a1, v36, 0, v29);
        (*(void (**)(uint64_t, void, void, void, void))(*(void *)a1 + 152))(a1, 0, 0, 0, 0);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 344))(a1, a3, a4, a6);
        (*(void (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
        (*(void (**)(char *))(*(void *)Buffer + 24))(Buffer);
      }
      (*(void (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
      (*(void (**)(char *))(*(void *)v26 + 24))(v26);
      return 0;
    }
    return v21;
  }
  else
  {
    return HGGPURenderer::ProcessNodeInternal((HGRenderer *)a1, a2, a3, a4, a5, a7, a8, a9, a10);
  }
}

void sub_1B776EF20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  HGObject::operator delete(v11);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

unsigned int *HGGPURenderer::GetNodeTexture(HGGPURenderer *this, HGNode *a2, HGRect a3, HGBuffer *a4, unsigned __int8 a5)
{
  uint64_t v6 = *(void *)&a3.var2;
  uint64_t v7 = *(void *)&a3.var0;
  NodeBitmap = HGGPURenderer::GetNodeBitmap(this, a2, a3, a4, a5);
  if (NodeBitmap)
  {
    int v11 = NodeBitmap;
    if (!a4)
    {
      uint64_t v7 = HGRectIntersection(v7, v6, *((void *)a2 + 19), *((void *)a2 + 20));
      uint64_t v6 = v12;
    }
    *(void *)&v16.signed int var0 = v7;
    *(void *)&v16.int var2 = v6;
    uint64_t v13 = HGGPURenderer::ConvertToGLTexture(this, v16, v11);
    (*(void (**)(HGBitmap *))(*(void *)v11 + 24))(v11);
    return (unsigned int *)v13;
  }
  else
  {
    return HGGPURenderer::LoadNullGLTexture(this);
  }
}

HGBitmap *HGGPURenderer::GetNodeBitmap(HGGPURenderer *this, HGNode *a2, HGRect a3, HGBuffer *a4, unsigned __int8 a5)
{
  if (!a2) {
    return 0;
  }
  uint64_t v6 = *(void *)&a3.var2;
  uint64_t v7 = *(void *)&a3.var0;
  uint64_t v10 = (HGBitmap *)*((void *)a2 + 24);
  if (v10 || (uint64_t v10 = (HGBitmap *)*((void *)a2 + 31)) != 0)
  {
    (*(void (**)(HGBitmap *))(*(void *)v10 + 16))(v10);
    if (a5) {
      return v10;
    }
    goto LABEL_5;
  }
  if (!a4)
  {
    uint64_t v7 = HGRectIntersection(*(uint64_t *)&a3.var0, *(uint64_t *)&a3.var2, *((void *)a2 + 19), *((void *)a2 + 20));
    uint64_t v6 = v20;
  }
  uint64_t OutputFormat = HGRenderer::GetOutputFormat(this, a2);
  uint64_t v10 = (HGBitmap *)HGGPURenderer::ProcessNodeInternal(this, (uint64_t)a2, v7, v6, OutputFormat, (char *)a4, 0, 0, a5);
  if ((a5 & 1) == 0)
  {
LABEL_5:
    if (HGBitmapUtils::isPadded((HGBitmapUtils *)v10, v11))
    {
      uint64_t v12 = *((unsigned int *)v10 + 4);
      int NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI(this, a2);
      *(void *)&v22.signed int var0 = v7;
      *(void *)&v22.int var2 = v6;
      Buffer = HGGPURenderer::CreateBuffer((uint64_t)this, v22, v12, NodeRenderAPI, (*((_DWORD *)a2 + 4) >> 12) & 1, 0, *((unsigned char *)this + 1336) == 0);
      *(void *)&v23.signed int var0 = v7;
      *(void *)&v23.int var2 = v6;
      HGGPURenderer::CopyBitmapIntoBuffer(this, (HGBuffer *)Buffer, v23, v10);
      unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
      if (v17) {
        HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"Helium WARNING -- buffer copy in HGGPURenderer::GetNodeBitmap(...) due to padding requirements.\n", v15, v16);
      }
      (*(void (**)(HGBitmap *))(*(void *)v10 + 24))(v10);
      return (HGBitmap *)Buffer;
    }
  }
  return v10;
}

HGBitmap *HGGPURenderer::GetNodeMetalTexture(HGGPURenderer *this, HGNode *a2, HGRect a3, HGBuffer *a4, unsigned __int8 a5)
{
  uint64_t v6 = *(void *)&a3.var2;
  uint64_t v7 = *(void *)&a3.var0;
  NodeBitmap = HGGPURenderer::GetNodeBitmap(this, a2, a3, a4, a5);
  if (NodeBitmap)
  {
    int v11 = NodeBitmap;
    if (!a4)
    {
      uint64_t v7 = HGRectIntersection(v7, v6, *((void *)a2 + 19), *((void *)a2 + 20));
      uint64_t v6 = v12;
    }
    *(void *)&v16.signed int var0 = v7;
    *(void *)&v16.int var2 = v6;
    uint64_t v13 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)this, v16, v11, 1);
    (*(void (**)(HGBitmap *))(*(void *)v11 + 24))(v11);
    return v13;
  }
  else
  {
    return (HGBitmap *)HGGPURenderer::LoadNullMetalTexture(this);
  }
}

uint64_t HGGPURenderer::CopyBitmapIntoBuffer(uint64_t this, HGBuffer *a2, HGRect a3, HGBitmap *a4)
{
  if (a2)
  {
    if (a4)
    {
      uint64_t v5 = *(void *)&a3.var2;
      uint64_t v6 = *(void *)&a3.var0;
      uint64_t v8 = (HGMetalTexture **)this;
      this = HGRectIsNull(*(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28));
      if (!this)
      {
        int v9 = (*((uint64_t (**)(HGMetalTexture **, uint64_t))*v8 + 16))(v8, 43);
        MetalStorage = HGMetalTexture::getMetalStorage((HGBitmap *)a2, v10);
        CVBitmapStorage = HGCVBitmap::getCVBitmapStorage((HGBitmap *)a2, v12);
        if (MetalStorage || CVBitmapStorage && v9 == 1)
        {
          (*((void (**)(HGMetalTexture **, void))*v8 + 18))(v8, 0);
          *(void *)&v28.signed int var0 = v6;
          *(void *)&v28.int var2 = v5;
          char v14 = (char *)HGGPURenderer::ConvertToMetalTexture(v8, v28, a4, 1);
          __asm { FMOV            V0.4S, #1.0 }
          __n128 v26 = _Q0;
          uint64_t v23 = 0;
          long long v24 = xmmword_1B7EBF8F0;
          uint64_t v25 = 0;
          *(void *)&v31.signed int var0 = v6;
          *(void *)&v31.int var2 = v5;
          HGGPURenderer::CopyMetal((HGGPURenderer *)v8, (HGBitmap *)a2, v31, v14, (const HGBlendingInfo *)&v23, &v26, 0);
          return (*(uint64_t (**)(char *))(*(void *)v14 + 24))(v14);
        }
        else
        {
          *(void *)&v29.signed int var0 = v6;
          *(void *)&v29.int var2 = v5;
          uint64_t v20 = HGGPURenderer::ConvertToGLTexture((HGGPURenderer *)v8, v29, a4);
          (*((void (**)(HGMetalTexture **, HGBuffer *))*v8 + 18))(v8, a2);
          (*((void (**)(HGMetalTexture **, void, uint64_t, void, void))*v8 + 19))(v8, 0, v20, 0, 0);
          *(void *)&v30.signed int var0 = v6;
          *(void *)&v30.int var2 = v5;
          HGGPURenderer::Copy((HGGPURenderer *)v8, v30, 0, v21);
          (*((void (**)(HGMetalTexture **, void, void, void, void))*v8 + 19))(v8, 0, 0, 0, 0);
          HGRect v22 = *(uint64_t (**)(uint64_t))(*(void *)v20 + 24);
          return v22(v20);
        }
      }
    }
  }
  return this;
}

HGBitmap *HGGPURenderer::ConvertToNonGLTexture(HGGPURenderer *this, HGBitmap *a2)
{
  int v3 = *((_DWORD *)a2 + 3);
  if ((v3 & 0x10) != 0)
  {
    if (v3)
    {
      CVBitmapStorage = (HGBuffer *)HGCVBitmap::getCVBitmapStorage(a2, a2);
      (*(void (**)(HGBuffer *))(*(void *)CVBitmapStorage + 16))(CVBitmapStorage);
    }
    else
    {
      unsigned int v6 = *((_DWORD *)a2 + 4);
      BOOL v7 = v6 > 0x21;
      uint64_t v8 = (1 << v6) & 0x38401C000;
      if (v7 || v8 == 0)
      {
        kdebug_trace();
        if (*((unsigned char *)this + 1281) && *((_DWORD *)this + 311)) {
          glFlush();
        }
        *((_DWORD *)this + 311) = 0;
        unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
        if (v17) {
          HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - HGGPURenderer::ConvertToNonGLTexture: extra copy from OpenGL texture to IOSurface\n", v15, v16);
        }
        CVBitmapStorage = (HGBuffer *)HGGPURenderer::CreateBuffer((uint64_t)this, *(HGRect *)((char *)a2 + 20), *((unsigned int *)a2 + 4), 0, 1, 0, *((unsigned char *)this + 1336) == 0);
        HGGPURenderer::BufferCopyOpenGL(this, CVBitmapStorage, *(HGRect *)((char *)a2 + 20), a2);
        kdebug_trace();
      }
      else
      {
        kdebug_trace();
        unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
        if (v12) {
          HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - HGGPURenderer::ConvertToNonGLTexture: extra copy from OpenGL texture through system memory\n", v10, v11);
        }
        CVBitmapStorage = (HGBuffer *)(*(uint64_t (**)(HGGPURenderer *, HGBitmap *, void))(*(void *)this + 96))(this, a2, *((unsigned int *)a2 + 4));
        kdebug_trace();
      }
    }
    EdgePolicy = (const HGEdgePolicy *)HGBitmap::GetEdgePolicy(a2);
    HGBitmap::SetEdgePolicy((HGBitmap *)CVBitmapStorage, EdgePolicy);
    return (HGBitmap *)CVBitmapStorage;
  }
  else
  {
    (*(void (**)(HGBitmap *))(*(void *)a2 + 16))(a2);
    return a2;
  }
}

void sub_1B776F87C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B776F89C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::BufferCopyOpenGL(HGGPURenderer *this, HGBuffer *a2, HGRect a3, HGBitmap *a4)
{
  if ((*((unsigned char *)a4 + 12) & 0x20) != 0 || (*((unsigned char *)a2 + 12) & 0x20) != 0)
  {
    HGLogger::warning((HGLogger *)"Can't OpenGL-copy between Metal objects.", (const char *)a2, *(char **)&a3.var0, *(void *)&a3.var2);
  }
  else
  {
    uint64_t v6 = *(void *)&a3.var2;
    uint64_t v7 = *(void *)&a3.var0;
    if (!HGRectIsNull(*(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28)))
    {
      *(void *)&v12.signed int var0 = v7;
      *(void *)&v12.int var2 = v6;
      uint64_t v9 = HGGPURenderer::ConvertToGLTexture(this, v12, a4);
      (*(void (**)(HGGPURenderer *, HGBuffer *))(*(void *)this + 144))(this, a2);
      (*(void (**)(HGGPURenderer *, void, uint64_t, void, void))(*(void *)this + 152))(this, 0, v9, 0, 0);
      *(void *)&v13.signed int var0 = v7;
      *(void *)&v13.int var2 = v6;
      HGGPURenderer::Copy(this, v13, 0, v10);
      (*(void (**)(HGGPURenderer *, void, void, void, void))(*(void *)this + 152))(this, 0, 0, 0, 0);
      (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
      if (*((unsigned char *)this + 1281))
      {
        if (*((_DWORD *)this + 311)) {
          glFlush();
        }
      }
      *((_DWORD *)this + 311) = 0;
    }
  }
}

HGBitmap *HGGPURenderer::ConvertToNonMetalTexture(HGGPURenderer *this, HGBitmap *a2)
{
  int v3 = *((_DWORD *)a2 + 3);
  if ((v3 & 0x20) != 0)
  {
    if (v3)
    {
      CVBitmapStorage = (HGBuffer *)HGCVBitmap::getCVBitmapStorage(a2, a2);
      (*(void (**)(HGBuffer *))(*(void *)CVBitmapStorage + 16))(CVBitmapStorage);
    }
    else
    {
      unsigned int v6 = *((_DWORD *)a2 + 4);
      BOOL v7 = v6 > 0x21;
      uint64_t v8 = (1 << v6) & 0x38401C000;
      if (v7 || v8 == 0)
      {
        kdebug_trace();
        (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
        HGRect v16 = (const void *)*((void *)this + 164);
        if (v16)
        {
          if (v17)
          {
            unsigned int v18 = v17;
            HGMetalHandler::FinalizeCommandBuffer(v17);
            HGMetalHandler::BindBuffer(v18, 0);
          }
        }
        uint64_t v19 = (id *)*((void *)this + 165);
        if (v19) {
          HGMetalCommandBufferRef::waitUntilCompleted(v19);
        }
        HGMetalTexture::getMetalStorage(a2, v15);
        unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
        if (v22) {
          HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - HGGPURenderer::ConvertToNonMetalTexture: extra copy from Metal texture to IOSurface\n", v20, v21);
        }
        CVBitmapStorage = (HGBuffer *)HGGPURenderer::CreateBuffer((uint64_t)this, *(HGRect *)((char *)a2 + 20), *((unsigned int *)a2 + 4), 1, 1, 0, *((unsigned char *)this + 1336) == 0);
        HGGPURenderer::BufferCopyMetal(this, CVBitmapStorage, *(HGRect *)((char *)a2 + 20), a2);
        kdebug_trace();
      }
      else
      {
        kdebug_trace();
        unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
        if (v12) {
          HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - HGGPURenderer::ConvertToNonMetalTexture: extra copy from Metal texture through system memory\n", v10, v11);
        }
        CVBitmapStorage = (HGBuffer *)(*(uint64_t (**)(HGGPURenderer *, HGBitmap *, void))(*(void *)this + 96))(this, a2, *((unsigned int *)a2 + 4));
        kdebug_trace();
      }
    }
    EdgePolicy = (const HGEdgePolicy *)HGBitmap::GetEdgePolicy(a2);
    HGBitmap::SetEdgePolicy((HGBitmap *)CVBitmapStorage, EdgePolicy);
    return (HGBitmap *)CVBitmapStorage;
  }
  else
  {
    (*(void (**)(HGBitmap *))(*(void *)a2 + 16))(a2);
    return a2;
  }
}

void sub_1B776FD60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B776FD80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::BufferCopyMetal(HGGPURenderer *this, HGBuffer *a2, HGRect a3, HGBitmap *a4)
{
  if ((*((unsigned char *)a4 + 12) & 0x10) != 0 || (*((unsigned char *)a2 + 12) & 0x10) != 0)
  {
    HGLogger::warning((HGLogger *)"Can't Metal-copy between OpenGL objects.", (const char *)a2, *(char **)&a3.var0, *(void *)&a3.var2);
  }
  else
  {
    uint64_t v6 = *(void *)&a3.var2;
    uint64_t v7 = *(void *)&a3.var0;
    (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v21 = _Q0;
    uint64_t v18 = 0;
    long long v19 = xmmword_1B7EBF8F0;
    uint64_t v20 = 0;
    *(void *)&v23.signed int var0 = v7;
    *(void *)&v23.int var2 = v6;
    HGGPURenderer::CopyMetal(this, (HGBitmap *)a2, v23, (char *)a4, (const HGBlendingInfo *)&v18, &v21, 0);
    (*(void (**)(HGGPURenderer *, void))(*(void *)this + 144))(this, 0);
    char v14 = (const void *)*((void *)this + 164);
    if (v14)
    {
      if (v15)
      {
        HGRect v16 = v15;
        HGMetalHandler::FinalizeCommandBuffer(v15);
        HGMetalHandler::BindBuffer(v16, 0);
      }
    }
    unsigned __int8 v17 = (id *)*((void *)this + 165);
    if (v17) {
      HGMetalCommandBufferRef::waitUntilCompleted(v17);
    }
  }
}

HGBitmap *HGGPURenderer::ConvertToMetalTexture(HGMetalTexture **this, HGBitmap *a2)
{
  *(void *)&v4.signed int var0 = *(void *)((char *)a2 + 20);
  *(void *)&v4.int var2 = *(void *)((char *)a2 + 28);
  return HGGPURenderer::ConvertToMetalTexture(this, v4, a2, 1);
}

HGBitmap *HGGPURenderer::ConvertToMetalTexture(HGMetalTexture **this, HGRect a2, HGBitmap *a3, int a4)
{
  uint64_t v6 = *(void *)&a2.var2;
  uint64_t v7 = *(HGBitmap **)&a2.var0;
  uint64_t v9 = HGGPURenderer::ConvertToNonGLTexture((HGGPURenderer *)this, a3);
  uint64_t v10 = HGRectIntersection((uint64_t)v7, v6, *(void *)((char *)v9 + 20), *(void *)((char *)v9 + 28));
  if (HGRectIsNull(v10, v11)) {
    goto LABEL_2;
  }
  int v15 = *((_DWORD *)v9 + 3);
  if ((v15 & 0x30) == 0)
  {
    if ((v15 & 1) == 0 && !*((void *)v9 + 10)) {
      goto LABEL_2;
    }
    *(void *)&v24.signed int var0 = v6;
    *(void *)&v24.int var2 = 1;
    HGMetalTexture::createFromBitmap(this[139], (HGMetalContext *)v9, v7, v24, 0, (HGMetalContext **)&v23);
    NullMetalTexture = v23;
    if (!v23 || !a4) {
      goto LABEL_3;
    }
LABEL_18:
    EdgePolicy = (const HGEdgePolicy *)HGBitmap::GetEdgePolicy(a3);
    HGBitmap::SetEdgePolicy(NullMetalTexture, EdgePolicy);
    goto LABEL_3;
  }
  if ((v15 & 0x20) == 0)
  {
LABEL_2:
    NullMetalTexture = 0;
    goto LABEL_3;
  }
  if ((v15 & 0x100) != 0)
  {
    MetalStorage = (char *)HGMetalBuffer::getMetalStorage(v9, v12);
    uint64_t v20 = (unsigned int *)this[139];
    __n128 v21 = (HGMetalBuffer *)HGRectIntersection(*(void *)(MetalStorage + 20), *(void *)(MetalStorage + 28), (uint64_t)v7, v6);
    *(void *)&v25.signed int var0 = v22;
    *(void *)&v25.int var2 = 0;
    HGMetalTexture::createFromBuffer((HGMetalTexture *)v20, (HGMetalContext *)v20[12], (HGMetalContext *)MetalStorage, v21, v25, &v23);
    NullMetalTexture = v23;
    if (!v23) {
      goto LABEL_3;
    }
    HGBitmap::SetStorage(v23, (HGObject *)MetalStorage);
    if (!a4) {
      goto LABEL_3;
    }
    goto LABEL_18;
  }
  if ((v15 & 0x200) == 0) {
    goto LABEL_2;
  }
  HGRect v16 = (HGBitmap *)HGMetalTexture::getMetalStorage(v9, v12);
  if (*((void *)v16 + 17) != *(void *)(*((void *)this[139] + 2) + 16)) {
    goto LABEL_2;
  }
  NullMetalTexture = v16;
  (*(void (**)(HGBitmap *))(*(void *)v16 + 16))(v16);
  if (a4)
  {
    unsigned __int8 v17 = (const HGEdgePolicy *)HGBitmap::GetEdgePolicy(a3);
    HGBitmap::SetEdgePolicy(NullMetalTexture, v17);
  }
LABEL_3:
  (*(void (**)(HGBitmap *))(*(void *)v9 + 24))(v9);
  if (NullMetalTexture
    || (NullMetalTexture = (HGBitmap *)HGGPURenderer::LoadNullMetalTexture((HGGPURenderer *)this)) != 0)
  {
    (*(void (**)(HGBitmap *))(*(void *)NullMetalTexture + 16))(NullMetalTexture);
    (*(void (**)(HGBitmap *))(*(void *)NullMetalTexture + 24))(NullMetalTexture);
  }
  return NullMetalTexture;
}

void sub_1B7770180(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

std::string *HGGPURenderer::CopyMetal(HGGPURenderer *this, HGBitmap *a2, HGRect a3, HGBitmap *a4)
{
  __asm { FMOV            V0.4S, #1.0 }
  __n128 v13 = _Q0;
  uint64_t v10 = 0;
  long long v11 = xmmword_1B7EBF8F0;
  uint64_t v12 = 0;
  return HGGPURenderer::CopyMetal(this, a2, a3, (char *)a4, (const HGBlendingInfo *)&v10, &v13, 0);
}

BOOL HGGPURenderer::ClearBuffer(BOOL this, HGBuffer *a2, HGRect a3, HGRect a4)
{
  if (a2)
  {
    uint64_t v4 = *(void *)&a4.var2;
    uint64_t v5 = *(void *)&a4.var0;
    uint64_t v6 = *(void *)&a3.var2;
    uint64_t v7 = *(void *)&a3.var0;
    uint64_t v9 = (HGGPURenderer *)this;
    this = HGRectIsNull(*(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28));
    if (!this)
    {
      int v10 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)v9 + 128))(v9, 43);
      MetalStorage = HGMetalTexture::getMetalStorage((HGBitmap *)a2, v11);
      CVBitmapStorage = HGCVBitmap::getCVBitmapStorage((HGBitmap *)a2, v13);
      if (MetalStorage || CVBitmapStorage && v10 == 1)
      {
        (*(void (**)(HGGPURenderer *, void))(*(void *)v9 + 144))(v9, 0);
        *(void *)&v15.signed int var0 = v7;
        *(void *)&v15.int var2 = v6;
        *(void *)&v16.signed int var0 = v5;
        *(void *)&v16.int var2 = v4;
        return HGGPURenderer::ClearMetal(v9, a2, v15, v16);
      }
      else
      {
        (*(void (**)(HGGPURenderer *, HGBuffer *))(*(void *)v9 + 144))(v9, a2);
        *(void *)&v18.signed int var0 = v7;
        *(void *)&v18.int var2 = v6;
        *(void *)&v19.signed int var0 = v5;
        *(void *)&v19.int var2 = v4;
        this = HGGPURenderer::Clear(v9, v18, v19);
        if (this) {
          *((_DWORD *)v9 + 311) = 1;
        }
      }
    }
  }
  return this;
}

BOOL HGGPURenderer::ClearMetal(HGGPURenderer *this, HGBuffer *a2, HGRect a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  signed int var0 = a4.var0;
  uint64_t v6 = *(void *)&a3.var2;
  signed int v7 = a3.var0;
  signed int var1 = a3.var1;
  signed int v11 = a4.var1;
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v18, "gpu", 2, "clear texture borders to zero");
  BOOL v12 = var1 > v11;
  if (var1 > v11)
  {
    *(void *)&v19.signed int var0 = HGRectMake4i(var0, v11, v4, var1);
    *(void *)&v19.int var2 = v13;
    HGGPURenderer::ClearMetal(this, a2, v19);
  }
  if (SHIDWORD(v6) < SHIDWORD(v4))
  {
    *(void *)&v20.signed int var0 = HGRectMake4i(var0, HIDWORD(v6), v4, HIDWORD(v4));
    *(void *)&v20.int var2 = v14;
    HGGPURenderer::ClearMetal(this, a2, v20);
    BOOL v12 = 1;
  }
  if (v7 > var0)
  {
    *(void *)&v21.signed int var0 = HGRectMake4i(var0, var1, v7, HIDWORD(v6));
    *(void *)&v21.int var2 = v15;
    HGGPURenderer::ClearMetal(this, a2, v21);
    BOOL v12 = 1;
  }
  if ((int)v6 < (int)v4)
  {
    *(void *)&v22.signed int var0 = HGRectMake4i(v6, var1, v4, HIDWORD(v6));
    *(void *)&v22.int var2 = v16;
    HGGPURenderer::ClearMetal(this, a2, v22);
    BOOL v12 = 1;
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v18);
  return v12;
}

void sub_1B7770510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGGPURenderer::ClearBuffer(uint64_t this, HGBuffer *a2, HGRect a3)
{
  if (a2)
  {
    uint64_t v3 = *(void *)&a3.var2;
    uint64_t v4 = *(void *)&a3.var0;
    uint64_t v6 = (HGGPURenderer *)this;
    this = HGRectIsNull(*(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28));
    if (!this)
    {
      int v7 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)v6 + 128))(v6, 43);
      MetalStorage = HGMetalTexture::getMetalStorage((HGBitmap *)a2, v8);
      CVBitmapStorage = HGCVBitmap::getCVBitmapStorage((HGBitmap *)a2, v10);
      if (MetalStorage || CVBitmapStorage && v7 == 1)
      {
        (*(void (**)(HGGPURenderer *, void))(*(void *)v6 + 144))(v6, 0);
        *(void *)&v12.signed int var0 = v4;
        *(void *)&v12.int var2 = v3;
        return HGGPURenderer::ClearMetal(v6, a2, v12);
      }
      else
      {
        (*(void (**)(HGGPURenderer *, HGBuffer *))(*(void *)v6 + 144))(v6, a2);
        *(void *)&v16.signed int var0 = v4;
        *(void *)&v16.int var2 = v3;
        this = HGGPURenderer::Clear(v6, v16, v13, v14);
        *((_DWORD *)v6 + 311) = 1;
      }
    }
  }
  return this;
}

std::string *HGGPURenderer::ClearMetal(HGGPURenderer *this, HGBitmap *a2, HGRect a3, char *a4)
{
  uint64_t v4 = *(void *)&a3.var2;
  uint64_t v5 = *(void *)&a3.var0;
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8) {
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"clear texture to zero [%d %d %d %d]\n", *(const char **)&a3.var2, a4, *(void *)&a3.var0, a3.var1, *(void *)&a3.var2, a3.var3);
  }
  uint64_t v9 = (HGGLShaderCache *)*((void *)this + 161);
  HGString::zero((HGString *)0x60B10, 1, __p);
  uint64_t v13 = HGString::c_str((string_t *)&__p[0].__r_.__value_.__l.__data_, v10, v11, v12);
  Entry = HGGLShaderCache::GetEntry(v9, v13);
  HGString::~HGString((HGString *)__p);
  if ((*(unsigned int (**)(HGGPURenderer *, int *))(*(void *)this + 432))(this, Entry)) {
    uint64_t v15 = 0;
  }
  else {
    uint64_t v15 = Entry;
  }
  uint64_t result = (std::string *)(*(uint64_t (**)(HGGPURenderer *, int *, HGGPURenderer *))(*(void *)this + 368))(this, v15, this);
  if (result)
  {
    if (result)
    {
      unsigned __int8 v17 = (HGMetalHandler *)result;
      *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 5;
      strcpy((char *)__p, "clear");
      HGMetalHandler::SetDebugLabel(result, __p);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
      HGMetalHandler::BindBuffer(v17, a2);
      (*(void (**)(HGMetalHandler *))(*(void *)v17 + 40))(v17);
      (*(void (**)(HGMetalHandler *, uint64_t, uint64_t, uint64_t))(*(void *)v17 + 192))(v17, v5, v4, 1);
      return (std::string *)(*(uint64_t (**)(HGGPURenderer *, HGMetalHandler *))(*(void *)this + 392))(this, v17);
    }
  }
  return result;
}

void sub_1B77708D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::Clear(HGGPURenderer *this, HGRect a2, const char *a3, char *a4)
{
  uint64_t v4 = *(void *)&a2.var2;
  uint64_t v5 = *(void *)&a2.var0;
  unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
  if (v7) {
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"clear texture to zero [%d %d %d %d]\n", a3, a4, *(void *)&a2.var0, a2.var1, *(void *)&a2.var2, a2.var3);
  }
  unsigned __int8 v8 = (HGGLShaderCache *)*((void *)this + 161);
  HGString::zero((HGString *)0x60620, 1, v17);
  uint32x4_t v12 = HGString::c_str(v17, v9, v10, v11);
  Entry = HGGLShaderCache::GetEntry(v8, v12);
  HGString::~HGString((HGString *)v17);
  uint64_t result = (*(uint64_t (**)(HGGPURenderer *, int *))(*(void *)this + 432))(this, Entry);
  if (result) {
    BOOL v15 = 1;
  }
  else {
    BOOL v15 = Entry == 0;
  }
  if (!v15)
  {
    HGRect v16 = (HGHandler *)(*(uint64_t (**)(HGGPURenderer *, int *, HGGPURenderer *))(*(void *)this + 368))(this, Entry, this);
    (*(void (**)(HGHandler *))(*(void *)v16 + 40))(v16);
    *(void *)&v18.signed int var0 = v5;
    *(void *)&v18.int var2 = v4;
    HGGPURenderer::Rect(this, v16, v18, 1);
    return (*(uint64_t (**)(HGGPURenderer *, HGHandler *))(*(void *)this + 392))(this, v16);
  }
  return result;
}

void sub_1B7770AA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

std::string *HGGPURenderer::ClearMetal(HGGPURenderer *this, HGBitmap *a2, HGRect a3, float *a4)
{
  uint64_t v5 = *(void *)&a3.var2;
  uint64_t v6 = *(void *)&a3.var0;
  unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
  if (v9) {
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"clear texture to uniform [%d %d %d %d]\n", *(const char **)&a3.var2, (char *)a4, *(void *)&a3.var0, a3.var1, *(void *)&a3.var2, a3.var3);
  }
  double v10 = (HGGLShaderCache *)*((void *)this + 161);
  HGString::uniform((HGString *)0x60B10, 1, __p);
  uint64_t v14 = HGString::c_str((string_t *)&__p[0].__r_.__value_.__l.__data_, v11, v12, v13);
  Entry = HGGLShaderCache::GetEntry(v10, v14);
  HGString::~HGString((HGString *)__p);
  if ((*(unsigned int (**)(HGGPURenderer *, int *))(*(void *)this + 432))(this, Entry)) {
    HGRect v16 = 0;
  }
  else {
    HGRect v16 = Entry;
  }
  uint64_t result = (std::string *)(*(uint64_t (**)(HGGPURenderer *, int *, HGGPURenderer *))(*(void *)this + 368))(this, v16, this);
  if (result)
  {
    if (result)
    {
      HGRect v18 = (HGMetalHandler *)result;
      *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 11;
      strcpy((char *)__p, "clear2color");
      HGMetalHandler::SetDebugLabel(result, __p);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
      HGMetalHandler::BindBuffer(v18, a2);
      (*(void (**)(HGMetalHandler *, void, float *, uint64_t))(*(void *)v18 + 144))(v18, 0, a4, 1);
      (*(void (**)(HGMetalHandler *))(*(void *)v18 + 40))(v18);
      (*(void (**)(HGMetalHandler *, uint64_t, uint64_t, uint64_t))(*(void *)v18 + 192))(v18, v6, v5, 1);
      return (std::string *)(*(uint64_t (**)(HGGPURenderer *, HGMetalHandler *))(*(void *)this + 392))(this, v18);
    }
  }
  return result;
}

void sub_1B7770D58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::Clear(HGGPURenderer *this, HGRect a2, float *a3, char *a4)
{
  uint64_t v5 = *(void *)&a2.var2;
  uint64_t v6 = *(void *)&a2.var0;
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8) {
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"clear texture to uniform [%d %d %d %d]\n", (const char *)a3, a4, *(void *)&a2.var0, a2.var1, *(void *)&a2.var2, a2.var3);
  }
  unsigned __int8 v9 = (HGGLShaderCache *)*((void *)this + 161);
  HGString::uniform((HGString *)0x60620, 1, v18);
  uint32x4_t v13 = HGString::c_str(v18, v10, v11, v12);
  Entry = HGGLShaderCache::GetEntry(v9, v13);
  HGString::~HGString((HGString *)v18);
  uint64_t result = (*(uint64_t (**)(HGGPURenderer *, int *))(*(void *)this + 432))(this, Entry);
  if (result) {
    BOOL v16 = 1;
  }
  else {
    BOOL v16 = Entry == 0;
  }
  if (!v16)
  {
    unsigned __int8 v17 = (HGHandler *)(*(uint64_t (**)(HGGPURenderer *, int *, HGGPURenderer *))(*(void *)this + 368))(this, Entry, this);
    (*(void (**)(HGHandler *, void, float *, uint64_t))(*(void *)v17 + 144))(v17, 0, a3, 1);
    (*(void (**)(HGHandler *))(*(void *)v17 + 40))(v17);
    *(void *)&v19.signed int var0 = v6;
    *(void *)&v19.int var2 = v5;
    HGGPURenderer::Rect(this, v17, v19, 1);
    return (*(uint64_t (**)(HGGPURenderer *, HGHandler *))(*(void *)this + 392))(this, v17);
  }
  return result;
}

void sub_1B7770F68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::Rect(HGGPURenderer *this, HGHandler *a2, HGRect a3, uint64_t a4)
{
  unint64_t v5 = *(void *)&a3.var2;
  unint64_t v6 = *(void *)&a3.var0;
  if (!HGRenderer::RenderCheckPoint(this))
  {
    unint64_t v9 = HIDWORD(v6);
    uint64_t v10 = *((void *)this + 3);
    if (v10)
    {
      unsigned int v11 = *(_DWORD *)(v10 + 16);
      if (v11 <= 0x1F && ((1 << v11) & 0x8001C000) != 0)
      {
        float v13 = ceilf((float)(int)v6 / 6.0) * 4.0;
        float v14 = ceilf((float)(int)v5 / 6.0) * 4.0;
        float v15 = ceilf((float)(int)v6 * 0.5);
        float v16 = ceilf((float)(int)v5 * 0.5);
        if (v11 - 14 > 2) {
          float v15 = v13;
        }
        else {
          float v14 = v16;
        }
        unint64_t v6 = HGRectMake4i((int)v15, HIDWORD(v6), (int)v14, HIDWORD(v5));
        unint64_t v5 = v17;
        unint64_t v9 = HIDWORD(v6);
      }
    }
    if (!a2 || HG_RENDERER_ENV::SCISSORED_LARGE_TRI_TILES == 1)
    {
      if (!HGRenderer::RenderCheckPoint(this))
      {
        HGLogger::warning((HGLogger *)"HGGPURenderer::Rect() needs a HGHandler!\n", v20, v21);
        *(void *)&v23.signed int var0 = v6;
        *(void *)&v23.int var2 = v5;
        HGGPURenderer::Clear(this, v23);
      }
    }
    else
    {
      (*(void (**)(HGHandler *, unint64_t, unint64_t, uint64_t))(*(void *)a2 + 192))(a2, v6, v5, a4);
    }
    unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
    if (v22) {
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"rect[0..%d]: { %d, %d, %d, %d }\n", v18, v19, a4, v6, v9, v5, HIDWORD(v5));
    }
    *((_DWORD *)this + 311) = 1;
  }
}

std::string *HGGPURenderer::CopyMetal(HGGPURenderer *this, HGBitmap *a2, HGRect a3, char *a4, const HGBlendingInfo *a5, __n128 *a6, int a7)
{
  uint64_t v7 = *(void *)&a3.var2;
  uint64_t v8 = *(void *)&a3.var0;
  if (a4)
  {
    unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
    if (v15) {
      HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"copy texture to buffer [%d %d %d %d]\n", *(const char **)&a3.var2, a4, *(void *)&a3.var0, a3.var1, *(void *)&a3.var2, a3.var3);
    }
    float v16 = (HGGLShaderCache *)*((void *)this + 161);
    HGString::sample2d((HGString *)0x60B10, 0, *((_DWORD *)this + 145) == 27, (HGString *)__p);
    HGRect v20 = HGString::c_str((string_t *)&__p[0].__r_.__value_.__l.__data_, v17, v18, v19);
    Entry = HGGLShaderCache::GetEntry(v16, v20);
    HGString::~HGString((HGString *)__p);
    if ((*(unsigned int (**)(HGGPURenderer *, int *))(*(void *)this + 432))(this, Entry)) {
      unsigned __int8 v22 = 0;
    }
    else {
      unsigned __int8 v22 = Entry;
    }
    uint64_t result = (std::string *)(*(uint64_t (**)(HGGPURenderer *, int *, HGGPURenderer *))(*(void *)this + 368))(this, v22, this);
    if (result)
    {
      if (result)
      {
        HGRect v24 = (HGMetalHandler *)result;
        *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 4;
        strcpy((char *)__p, "copy");
        HGMetalHandler::SetDebugLabel(result, __p);
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p[0].__r_.__value_.__l.__data_);
        }
        if (a7)
        {
          HGMetalHandler::EnableBlending((uint64_t)v24);
          HGMetalHandler::SetBlendingInfo(v24, a5);
          HGMetalHandler::SetBlendingColor((__n128 *)v24, a6);
        }
        HGMetalHandler::BindBuffer(v24, a2);
        HGMetalHandler::BindTexture((HGMetalTexture ***)v24, 0, (HGBitmap *)a4);
        *(void *)&v27.signed int var0 = v8;
        *(void *)&v27.int var2 = v7;
        HGMetalHandler::InitTextureUnit(v24, v27, 0);
        (*(void (**)(HGMetalHandler *, void, void))(*(void *)v24 + 72))(v24, 0, 0);
        (*(void (**)(HGMetalHandler *, void, void))(*(void *)v24 + 48))(v24, 0, 0);
        HGHandler::TexCoord(v24, 0, 0, 0, 0);
        if (!(*(unsigned int (**)(HGGPURenderer *, uint64_t))(*(void *)this + 128))(this, 46)) {
          (*(void (**)(HGMetalHandler *))(*(void *)v24 + 168))(v24);
        }
        (*(void (**)(HGMetalHandler *))(*(void *)v24 + 40))(v24);
        (*(void (**)(HGMetalHandler *, uint64_t, uint64_t, uint64_t))(*(void *)v24 + 192))(v24, v8, v7, 1);
        return (std::string *)(*(uint64_t (**)(HGGPURenderer *, HGMetalHandler *))(*(void *)this + 392))(this, v24);
      }
    }
  }
  else
  {
    return HGGPURenderer::ClearMetal(this, a2, a3, 0);
  }
  return result;
}

void sub_1B7771514(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::Rect(HGGPURenderer *this, HGRect a2)
{
  uint64_t v2 = *(void *)&a2.var2;
  uint64_t v3 = *(void *)&a2.var0;
  uint64_t result = HGRenderer::RenderCheckPoint(this);
  if (!result)
  {
    HGLogger::warning((HGLogger *)"HGGPURenderer::Rect() needs a HGHandler!\n", v6, v7);
    *(void *)&v10.signed int var0 = v3;
    *(void *)&v10.int var2 = v2;
    return HGGPURenderer::Clear(this, v10, v8, v9);
  }
  return result;
}

uint64_t HGGPURenderer::PageInit(HGGPURenderer *this, HGNode *a2, HGRect a3, HGRect *a4, int a5)
{
  if (*((void *)a2 + 10))
  {
    unint64_t v5 = a4;
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    p_int var2 = &a4[*((_DWORD *)a2 + 71) + a5].var2;
    do
    {
      uint64_t v10 = *(void *)(*((void *)a2 + 10) + 8 * v8);
      if (!v10 || !*(void *)(v10 + 16)) {
        goto LABEL_4;
      }
      BOOL IsMergedWithInput = HGNode::IsMergedWithInput(a2, v8);
      uint64_t v12 = (*(uint64_t (**)(HGNode *, HGGPURenderer *, unint64_t, void, void))(*(void *)a2 + 400))(a2, this, v8, *(void *)&a3.var0, *(void *)&a3.var2);
      unint64_t v14 = HGRectIntersection(v12, v13, *(void *)(*(void *)(*(void *)(v10 + 16) + 144) + 152), *(void *)(*(void *)(*(void *)(v10 + 16) + 144) + 160));
      int v16 = v14;
      int v17 = v15;
      if (IsMergedWithInput)
      {
        *(void *)&v51.signed int var0 = v14;
        *(void *)&v51.int var2 = v15;
        if (HGGPURenderer::PageInit(this, *(HGNode **)(*((void *)a2 + 37) + v7), v51, v5, *(_DWORD *)(*((void *)a2 + 37) + v7 + 40) + a5))return 0xFFFFFFFFLL; {
        goto LABEL_4;
        }
      }
      *((void *)p_var2 - 1) = v14;
      *(void *)p_int var2 = v15;
      unint64_t v18 = HIDWORD(v15);
      unint64_t v19 = HIDWORD(v14);
      int OutputFormat = HGRenderer::GetOutputFormat(this, *(HGNode **)(*(void *)(v10 + 16) + 144));
      int NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI(this, *(HGNode **)(*(void *)(v10 + 16) + 144));
      uint64_t v21 = *(void *)(*(void *)(v10 + 16) + 144);
      int v22 = *(_DWORD *)(v21 + 16) & 0x1000;
      BOOL v23 = NodeRenderAPI == 1;
      if (NodeRenderAPI == 1 || v22 == 0)
      {
        BOOL v33 = NodeRenderAPI == 0;
        if (NodeRenderAPI) {
          BOOL v25 = v22 == 0;
        }
        else {
          BOOL v25 = 1;
        }
        if (v25)
        {
LABEL_18:
          __n128 v26 = this;
          unsigned int v27 = v17 - v16;
          unsigned int v28 = v18 - v19;
          int v29 = *((_DWORD *)this + 165);
          if (*(void *)(v21 + 192)) {
            goto LABEL_19;
          }
          goto LABEL_26;
        }
      }
      else
      {
        BOOL v23 = *(unsigned char *)(v21 + 108) != 0;
        BOOL v33 = NodeRenderAPI == 0;
        if (NodeRenderAPI) {
          BOOL v34 = v22 == 0;
        }
        else {
          BOOL v34 = 1;
        }
        if (v34) {
          goto LABEL_18;
        }
      }
      BOOL v33 = *(unsigned char *)(v21 + 107) != 0;
      __n128 v26 = this;
      unsigned int v27 = v17 - v16;
      unsigned int v28 = v18 - v19;
      int v29 = *((_DWORD *)this + 165);
      if (*(void *)(v21 + 192))
      {
LABEL_19:
        BOOL v30 = 1;
        HGRect v31 = *(unsigned char **)(*(void *)(v10 + 16) + 144);
        if (v31[105]) {
          goto LABEL_20;
        }
        goto LABEL_57;
      }
LABEL_26:
      if (*((unsigned char *)v26 + 1281))
      {
        if (v23)
        {
          unsigned int v35 = *(_DWORD *)(PCICCTransferFunctionLUT::getLUTEnd(*((PCICCTransferFunctionLUT **)v26 + 139)) + 48);
          BOOL v36 = v35 >= v27 && v35 >= v28;
          char v37 = !v36;
          if (!v36 || !v33)
          {
            if (v37) {
              goto LABEL_51;
            }
            goto LABEL_53;
          }
        }
        else if (!v33)
        {
          goto LABEL_53;
        }
        uint64_t v40 = *((void *)this + 184);
        if (!v40) {
          goto LABEL_51;
        }
        unsigned int v41 = HGTextureManager::maxTextureSizeGL(v40, OutputFormat);
        if (v41 < v27 || v41 < v28) {
          goto LABEL_51;
        }
      }
      else
      {
        unsigned int v38 = *(_DWORD *)(PCICCTransferFunctionLUT::getLUTEnd(*((PCICCTransferFunctionLUT **)v26 + 139)) + 48);
        if (v38 < v27 || v38 < v28)
        {
LABEL_51:
          BOOL v30 = 0;
          HGRect v31 = *(unsigned char **)(*(void *)(v10 + 16) + 144);
          if (v31[105]) {
            goto LABEL_20;
          }
          goto LABEL_57;
        }
      }
LABEL_53:
      if (OutputFormat <= 41) {
        uint64_t v43 = s_HGFormatInfos[8 * OutputFormat + 3];
      }
      else {
        uint64_t v43 = 0;
      }
      BOOL v30 = v28 * (unint64_t)v27 * v43 < *((void *)this + 157);
      HGRect v31 = *(unsigned char **)(*(void *)(v10 + 16) + 144);
      if (v31[105])
      {
LABEL_20:
        int v32 = 1;
        goto LABEL_58;
      }
LABEL_57:
      int v32 = (*(uint64_t (**)(unsigned char *, HGGPURenderer *))(*(void *)v31 + 304))(v31, this);
LABEL_58:
      if (v28 * v27 < 2 * v29 * v29) {
        int v44 = 1;
      }
      else {
        int v44 = v32;
      }
      unint64_t v5 = a4;
      if ((v44 & v30) != 1) {
        return 0xFFFFFFFFLL;
      }
LABEL_4:
      ++v8;
      p_var2 += 4;
      v7 += 56;
    }
    while (v8 != 8);
  }
  return 0;
}

uint64_t HGGPURenderer::GetMaxTileArea(HGGPURenderer *this)
{
  return (2 * *((_DWORD *)this + 165) * *((_DWORD *)this + 165));
}

char *HGGPURenderer::ProcessNodeInternal(HGRenderer *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *Buffer, int a7, int a8, unsigned __int8 a9)
{
  uint64_t v17 = HGRectIntersection(a3, a4, *(void *)(a2 + 152), *(void *)(a2 + 160));
  if (!a8 || (v19 = a3, uint64_t v20 = a4, !*((unsigned char *)a1 + 808)))
  {
    uint64_t v19 = v17;
    uint64_t v20 = v18;
  }
  std::string __p = 0;
  int v32 = 0;
  uint64_t v33 = 0;
  uint64_t v29 = v18;
  uint64_t v30 = v17;
  HGGPURenderer::BuildPagesList((uint64_t)a1, (char **)&__p, (HGNode *)a2, v17, v18);
  if ((char *)v32 - (unsigned char *)__p == 144)
  {
    if (a7)
    {
      *(void *)&v37.signed int var0 = a3;
      *(void *)&v37.int var2 = a4;
      HGRenderer::SetTilesROI(a1, (HGNode *)a2, v37);
      unsigned int v35 = (unsigned int (*)(char *, long long *))&unk_1F10D4780;
      HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v34, a1, a2, (uint64_t *)&v35);
      Buffer = (char *)HGGPURenderer::ProcessOnePage((int64x2_t *)a1, a2, a3, a4, (uint64_t)__p, a5, Buffer, a8, a9);
      unsigned int v35 = (unsigned int (*)(char *, long long *))&unk_1F10D47F8;
      HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v34, a1, a2, (uint64_t *)&v35);
    }
    else
    {
      Buffer = (char *)HGGPURenderer::ProcessOnePage((int64x2_t *)a1, a2, a3, a4, (uint64_t)__p, a5, Buffer, a8, a9);
    }
    goto LABEL_26;
  }
  unsigned int v35 = (unsigned int (*)(char *, long long *))PageSortPredicate;
  unint64_t v21 = 126 - 2 * __clz(0x8E38E38E38E38E39 * (((char *)v32 - (unsigned char *)__p) >> 4));
  if (v32 == __p) {
    uint64_t v22 = 0;
  }
  else {
    uint64_t v22 = v21;
  }
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*,false>((unint64_t)__p, v32, &v35, v22, 1);
  if (!Buffer)
  {
    int NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI(a1, (HGNode *)a2);
    *(void *)&v36.signed int var0 = v19;
    *(void *)&v36.int var2 = v20;
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)a1, v36, a5, NodeRenderAPI, (*(_DWORD *)(a2 + 16) >> 12) & 1, a9 & ~a8, *((unsigned char *)a1 + 1336) == 0);
    HGRect v24 = (__n128 *)__p;
    BOOL v23 = v32;
    if (__p == v32) {
      goto LABEL_23;
    }
LABEL_15:
    if (a7)
    {
      do
      {
        HGRenderer::SetTilesROI(a1, (HGNode *)a2, *(HGRect *)v24);
        unsigned int v35 = (unsigned int (*)(char *, long long *))&unk_1F10D4780;
        HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v34, a1, a2, (uint64_t *)&v35);
        unsigned int v27 = HGGPURenderer::ProcessOnePage((int64x2_t *)a1, a2, v24->n128_u64[0], v24->n128_i64[1], (uint64_t)v24, a5, Buffer, 0, a9);
        unsigned int v35 = (unsigned int (*)(char *, long long *))&unk_1F10D47F8;
        HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v34, a1, a2, (uint64_t *)&v35);
        if (v27) {
          (*(void (**)(HGBuffer *))(*(void *)v27 + 24))(v27);
        }
        v24 += 9;
      }
      while (v24 != v23);
    }
    else
    {
      do
      {
        __n128 v26 = HGGPURenderer::ProcessOnePage((int64x2_t *)a1, a2, v24->n128_u64[0], v24->n128_i64[1], (uint64_t)v24, a5, Buffer, 0, a9);
        if (v26) {
          (*(void (**)(HGBuffer *))(*(void *)v26 + 24))(v26);
        }
        v24 += 9;
      }
      while (v24 != v23);
    }
    goto LABEL_23;
  }
  (*(void (**)(char *))(*(void *)Buffer + 16))(Buffer);
  HGRect v24 = (__n128 *)__p;
  BOOL v23 = v32;
  if (__p != v32) {
    goto LABEL_15;
  }
LABEL_23:
  if (v32 == __p)
  {
    *(void *)&v39.signed int var0 = a3;
    *(void *)&v39.int var2 = a4;
    HGGPURenderer::ClearBuffer((uint64_t)a1, (HGBuffer *)Buffer, v39);
  }
  else
  {
    *(void *)&v38.int var2 = v29;
    *(void *)&v38.signed int var0 = v30;
    *(void *)&v40.signed int var0 = a3;
    *(void *)&v40.int var2 = a4;
    HGGPURenderer::ClearBuffer((BOOL)a1, (HGBuffer *)Buffer, v38, v40);
  }
LABEL_26:
  if (__p)
  {
    int v32 = (__n128 *)__p;
    operator delete(__p);
  }
  return Buffer;
}

void sub_1B7771D24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL PageSortPredicate(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[1];
  int v3 = a2[1];
  if (v2 < v3) {
    return 1;
  }
  if (v2 == v3) {
    return *a1 < *a2;
  }
  return 0;
}

void HGGPURenderer::BuildPagesList(uint64_t a1, char **a2, HGNode *a3, uint64_t a4, uint64_t a5)
{
  while (1)
  {
    uint64_t v5 = a5;
    unint64_t v6 = a4;
    uint64_t v7 = a3;
    unint64_t v8 = a2;
    uint64_t v9 = a1;
    *(void *)&long long v56 = a4;
    *((void *)&v56 + 1) = a5;
    long long v57 = HGRectNull;
    long long v58 = HGRectNull;
    long long v59 = HGRectNull;
    long long v60 = HGRectNull;
    long long v61 = HGRectNull;
    long long v62 = HGRectNull;
    long long v63 = HGRectNull;
    long long v64 = HGRectNull;
    if (HGRectIsNull(a4, a5)
      || (*(void *)&v66.signed int var0 = v6,
          *(void *)&v66.int var2 = v5,
          !HGGPURenderer::PageInit((HGGPURenderer *)v9, v7, v66, (HGRect *)&v57, 0)))
    {
      unsigned int v11 = v8[1];
      unint64_t v10 = (unint64_t)v8[2];
      if ((unint64_t)v11 >= v10)
      {
        uint64_t v17 = *v8;
        unint64_t v18 = 0x8E38E38E38E38E39 * ((v11 - *v8) >> 4);
        unint64_t v19 = v18 + 1;
        if (v18 + 1 > 0x1C71C71C71C71C7) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v20 = 0x8E38E38E38E38E39 * ((uint64_t)(v10 - (void)v17) >> 4);
        if (2 * v20 > v19) {
          unint64_t v19 = 2 * v20;
        }
        if (v20 >= 0xE38E38E38E38E3) {
          unint64_t v21 = 0x1C71C71C71C71C7;
        }
        else {
          unint64_t v21 = v19;
        }
        if (v21)
        {
          if (v21 > 0x1C71C71C71C71C7) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v22 = (char *)operator new(144 * v21);
        }
        else
        {
          uint64_t v22 = 0;
        }
        long long v32 = v63;
        uint64_t v33 = &v22[144 * v18];
        *((_OWORD *)v33 + 6) = v62;
        *((_OWORD *)v33 + 7) = v32;
        *((_OWORD *)v33 + 8) = v64;
        long long v34 = v59;
        *((_OWORD *)v33 + 2) = v58;
        *((_OWORD *)v33 + 3) = v34;
        long long v35 = v61;
        *((_OWORD *)v33 + 4) = v60;
        *((_OWORD *)v33 + 5) = v35;
        HGRect v36 = (HGRect)v57;
        int v16 = v33 + 144;
        *(_OWORD *)uint64_t v33 = v56;
        *((HGRect *)v33 + 1) = v36;
        if (v11 != v17)
        {
          do
          {
            *((_OWORD *)v33 - 9) = *((_OWORD *)v11 - 9);
            long long v37 = *((_OWORD *)v11 - 8);
            long long v38 = *((_OWORD *)v11 - 7);
            long long v39 = *((_OWORD *)v11 - 5);
            *((_OWORD *)v33 - 6) = *((_OWORD *)v11 - 6);
            *((_OWORD *)v33 - 5) = v39;
            *((_OWORD *)v33 - 8) = v37;
            *((_OWORD *)v33 - 7) = v38;
            long long v40 = *((_OWORD *)v11 - 4);
            long long v41 = *((_OWORD *)v11 - 3);
            long long v42 = *((_OWORD *)v11 - 1);
            *((_OWORD *)v33 - 2) = *((_OWORD *)v11 - 2);
            *((_OWORD *)v33 - 1) = v42;
            *((_OWORD *)v33 - 4) = v40;
            *((_OWORD *)v33 - 3) = v41;
            v33 -= 144;
            v11 -= 144;
          }
          while (v11 != v17);
          unsigned int v11 = *v8;
        }
        *unint64_t v8 = v33;
        v8[1] = v16;
        int v8[2] = &v22[144 * v21];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        long long v12 = v63;
        *((_OWORD *)v11 + 6) = v62;
        *((_OWORD *)v11 + 7) = v12;
        *((_OWORD *)v11 + 8) = v64;
        long long v13 = v59;
        *((_OWORD *)v11 + 2) = v58;
        *((_OWORD *)v11 + 3) = v13;
        long long v14 = v61;
        *((_OWORD *)v11 + 4) = v60;
        *((_OWORD *)v11 + 5) = v14;
        HGRect v15 = (HGRect)v57;
        *(_OWORD *)unsigned int v11 = v56;
        *((HGRect *)v11 + 1) = v15;
        int v16 = v11 + 144;
      }
      v8[1] = v16;
      return;
    }
    unint64_t v23 = HIDWORD(v6);
    unsigned int v24 = HIDWORD(v5) - HIDWORD(v6);
    if ((v5 - v6) <= 1 && v24 < 2) {
      break;
    }
    if ((int)v5 - (int)v6 <= v24)
    {
      uint64_t v50 = HGRectMake4i(v6, HIDWORD(v6), v5, (HIDWORD(v5) + HIDWORD(v6)) >> 1);
      uint64_t v52 = v51;
      uint64_t v53 = HGRectMake4i(v6, (HIDWORD(v5) + HIDWORD(v6)) >> 1, v5, HIDWORD(v5));
      uint64_t v55 = v54;
      HGGPURenderer::BuildPagesList(v9, v8, v7, v50, v52);
      a1 = v9;
      a2 = v8;
      a3 = v7;
      a4 = v53;
      a5 = v55;
    }
    else
    {
      unsigned int v43 = ((int)v5 + (int)v6) >> 1;
      uint64_t v44 = HGRectMake4i(v6, HIDWORD(v6), v43, HIDWORD(v5));
      uint64_t v46 = v45;
      uint64_t v47 = HGRectMake4i(v43, v23, v5, HIDWORD(v5));
      uint64_t v49 = v48;
      HGGPURenderer::BuildPagesList(v9, v8, v7, v44, v46);
      a1 = v9;
      a2 = v8;
      a3 = v7;
      a4 = v47;
      a5 = v49;
    }
  }
  BOOL v25 = *(uint64_t **)(v9 + 1448);
  if (v25)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v27 = (uint64_t **)v25;
        unint64_t v28 = v25[4];
        if (v28 <= (unint64_t)v7) {
          break;
        }
        BOOL v25 = *v27;
        __n128 v26 = v27;
        if (!*v27) {
          goto LABEL_23;
        }
      }
      if (v28 >= (unint64_t)v7) {
        break;
      }
      BOOL v25 = v27[1];
      if (!v25)
      {
        __n128 v26 = v27 + 1;
        goto LABEL_23;
      }
    }
  }
  else
  {
    __n128 v26 = (uint64_t **)(v9 + 1448);
    unsigned int v27 = (uint64_t **)(v9 + 1448);
LABEL_23:
    uint64_t v29 = (uint64_t *)operator new(0x28uLL);
    v29[4] = (uint64_t)v7;
    *uint64_t v29 = 0;
    v29[1] = 0;
    _OWORD v29[2] = (uint64_t)v27;
    *__n128 v26 = v29;
    uint64_t v30 = **(void **)(v9 + 1440);
    if (v30)
    {
      *(void *)(v9 + 1440) = v30;
      HGRect v31 = *v26;
    }
    else
    {
      HGRect v31 = v29;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v9 + 1448), v31);
    ++*(void *)(v9 + 1456);
  }
}

HGBuffer *HGGPURenderer::ProcessOnePage(int64x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, char *a7, int a8, unsigned __int8 a9)
{
  HGGPURenderer::PurgePostDeleteEvents(a1);
  if (a7) {
    (*(void (**)(char *))(*(void *)a7 + 16))(a7);
  }
  uint64_t v16 = *(void *)a5;
  uint64_t v17 = *(void *)(a5 + 8);
  *(void *)&v44.signed int var0 = a3;
  *(void *)&v44.int var2 = a4;
  if (!a8 || !a1[50].i8[8])
  {
    a4 = *(void *)(a5 + 8);
    a3 = *(void *)a5;
  }
  BOOL IsNull = HGRectIsNull(v16, v17);
  if (IsNull | HGRenderer::RenderCheckPoint((HGRenderer *)a1))
  {
    if ((a8 & 1) == 0) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  unint64_t v19 = *(HGBitmap **)(a2 + 192);
  if (v19 || (unint64_t v19 = *(HGBitmap **)(a2 + 248)) != 0)
  {
    (*(void (**)(HGBitmap *))(*(void *)v19 + 16))(v19);
    if ((a8 & 1) == 0) {
      goto LABEL_43;
    }
  }
  else
  {
    unsigned __int8 v33 = a9;
    if (((a8 ^ 1) & 1) == 0 && !a7 && a1[50].i8[8])
    {
      int NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI((HGGPURenderer *)a1, (HGNode *)a2);
      Buffer = HGGPURenderer::CreateBuffer((uint64_t)a1, v44, a6, NodeRenderAPI, (*(_DWORD *)(a2 + 16) >> 12) & 1, (a8 ^ 1u) & a9, a1[83].i8[8] == 0);
      unsigned __int8 v33 = a9;
      a7 = Buffer;
    }
    long long v36 = *(_OWORD *)(a5 + 96);
    long long v51 = *(_OWORD *)(a5 + 80);
    long long v52 = v36;
    long long v37 = *(_OWORD *)(a5 + 128);
    long long v53 = *(_OWORD *)(a5 + 112);
    long long v54 = v37;
    long long v38 = *(_OWORD *)(a5 + 32);
    long long v47 = *(_OWORD *)(a5 + 16);
    long long v48 = v38;
    long long v39 = *(_OWORD *)(a5 + 64);
    long long v49 = *(_OWORD *)(a5 + 48);
    uint64_t v59 = a2;
    uint64_t v60 = 0;
    long long v50 = v39;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    v45[0] = a1;
    v45[1] = a7;
    unsigned int v46 = a6;
    void v45[2] = v16;
    v45[3] = v17;
    unsigned __int8 v61 = v33;
    unint64_t v19 = HGGPURenderer::RenderPage((HGBitmap **)a1, (HGNode *)a2, (HGPage *)v45);
    __int32 v40 = a1[43].i32[2];
    if (*(void *)(a2 + 64)) {
      ++v40;
    }
    a1[43].i32[2] = v40;
    a1[77].i32[3] = 1;
    if ((a8 & 1) == 0) {
      goto LABEL_43;
    }
  }
  if (!v19)
  {
LABEL_17:
    if (!a7)
    {
      if (a1[50].i8[8])
      {
        BOOL v25 = (void *)a1[84].i64[1];
        if (!v25)
        {
          BOOL v25 = HGObject::operator new(0x80uLL);
          uint64_t v26 = HGRectMake4i(0, 0, 0, 0);
          HGBitmap::HGBitmap(v25, v26, v27, 24);
          a1[84].i64[1] = (uint64_t)v25;
        }
        (*(void (**)(void *))(*(void *)v25 + 16))(v25);
        unint64_t v19 = (HGBitmap *)a1[84].i64[1];
        int v28 = a1[79].i32[1];
        int v29 = (*(_DWORD *)(a2 + 16) >> 12) & 1;
        BOOL v30 = a1[83].i8[8] == 0;
        uint64_t v31 = (uint64_t)a1;
        HGRect v32 = v44;
        goto LABEL_42;
      }
      unint64_t v21 = (char *)HGObject::operator new(0x80uLL);
      HGBitmap::HGBitmap(v21, 0, 0, a6);
      a7 = 0;
LABEL_19:
      BOOL v22 = a7 != 0;
      BOOL v23 = v21 != 0;
      unsigned int v24 = (HGBuffer *)a7;
      a7 = v21;
      if (!v21) {
        goto LABEL_51;
      }
LABEL_20:
      (*(void (**)(char *))(*(void *)a7 + 16))(a7);
      unint64_t v19 = (HGBitmap *)a7;
      if (!v23) {
        return (HGBuffer *)a7;
      }
      goto LABEL_49;
    }
LABEL_18:
    unint64_t v21 = 0;
    goto LABEL_19;
  }
  if (HGRectIsEqual(*(void *)((char *)v19 + 20), *(void *)((char *)v19 + 28), a3, a4))
  {
    int v20 = *((_DWORD *)v19 + 3);
    if ((v20 & 1) == 0)
    {
      if ((~v20 & 0x120) == 0 || (*(_DWORD *)(a2 + 16) & 0x1000) != 0) {
        goto LABEL_37;
      }
LABEL_35:
      if (*((_DWORD *)v19 + 4) == a6)
      {
        EdgePolicy = (HGEdgePolicy *)HGBitmap::GetEdgePolicy(v19);
        if (HGEdgePolicy::isDefault(EdgePolicy)) {
          goto LABEL_43;
        }
      }
      goto LABEL_37;
    }
    if ((~v20 & 0x120) != 0) {
      goto LABEL_35;
    }
  }
LABEL_37:
  if (v19 == (HGBitmap *)a7)
  {
    (*(void (**)(HGBitmap *))(*(void *)v19 + 24))(v19);
LABEL_41:
    int v28 = a1[79].i32[1];
    int v29 = (*(_DWORD *)(a2 + 16) >> 12) & 1;
    BOOL v30 = a1[83].i8[8] == 0;
    uint64_t v31 = (uint64_t)a1;
    *(void *)&v32.signed int var0 = a3;
    *(void *)&v32.int var2 = a4;
LABEL_42:
    a7 = HGGPURenderer::CreateBuffer(v31, v32, a6, v28, v29, 0, v30);
    goto LABEL_43;
  }
  if (!a7) {
    goto LABEL_41;
  }
LABEL_43:
  BOOL v22 = a7 != 0;
  BOOL v23 = v19 != 0;
  if (a7 && v19)
  {
    if (v19 != (HGBitmap *)a7) {
      HGGPURenderer::CopyBitmapIntoBuffer((HGGPURenderer *)a1, (HGBuffer *)a7, v44, v19);
    }
    if (!HGRectIsEqual(v16, v17, *(uint64_t *)&v44.var0, *(uint64_t *)&v44.var2))
    {
      *(void *)&v62.signed int var0 = v16;
      *(void *)&v62.int var2 = v17;
      HGGPURenderer::ClearBuffer((BOOL)a1, (HGBuffer *)a7, v62, v44);
    }
LABEL_49:
    (*(void (**)(HGBitmap *))(*(void *)v19 + 24))(v19);
    return (HGBuffer *)a7;
  }
  unsigned int v24 = (HGBuffer *)a7;
  a7 = (char *)v19;
  if (v19) {
    goto LABEL_20;
  }
LABEL_51:
  if (v22)
  {
    HGGPURenderer::ClearBuffer((uint64_t)a1, v24, v44);
    return v24;
  }
  else
  {
    a1[77].i32[3] = 1;
    return HGGPURenderer::LoadNullBuffer((HGGPURenderer *)a1);
  }
}

void sub_1B777264C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7772660(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGBitmap *HGGPURenderer::RenderPage(HGBitmap **this, HGNode *a2, HGPage *a3)
{
  int NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI((HGGPURenderer *)this, a2);
  int v7 = NodeRenderAPI;
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8)
  {
    if (NodeRenderAPI == 1) {
      uint64_t v9 = "Metal";
    }
    else {
      uint64_t v9 = "GLSL ";
    }
    uint64_t v10 = (*(uint64_t (**)(HGNode *))(*(void *)a2 + 48))(a2);
    HGLogger::log((HGLogger *)"metal", (const char *)3, (HGLogger *)"node render API (%p) : %s  (%s)\n", v11, v12, a2, v9, v10);
  }
  HGGPURenderer::ValidateCurrentContext((const char *)this);
  uint64_t v14 = *((unsigned int *)a3 + 7);
  uint64_t v13 = *((unsigned int *)a3 + 8);
  uint64_t v15 = *((unsigned int *)a3 + 4);
  uint64_t v16 = *((unsigned int *)a3 + 5);
  uint64_t v17 = *((unsigned int *)a3 + 6);
  if (v7 != 1)
  {
    if (v7)
    {
      int v29 = this[169];
      if (!v29)
      {
        int v29 = (HGBitmap *)HGObject::operator new(0x80uLL);
        uint64_t v30 = HGRectMake4i(0, 0, 0, 0);
        HGBitmap::HGBitmap(v29, v30, v31, 24);
LABEL_34:
        this[169] = v29;
      }
LABEL_35:
      (*(void (**)(HGBitmap *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v29 + 16))(v29, v13, v15, v16, v17, v14);
      int v28 = this[169];
      goto LABEL_36;
    }
    if (*((int *)this + 319) < 1)
    {
LABEL_27:
      if (*((unsigned char *)this + 1281))
      {
        uint64_t v33 = *((void *)a3 + 1);
        if (v33 && (*(unsigned char *)(v33 + 12) & 0x20) != 0) {
          *((void *)a3 + 1) = 0;
        }
        int v28 = (HGBitmap *)(*(uint64_t (**)(HGNode *, HGPage *))(*(void *)a2 + 456))(a2, a3);
        goto LABEL_36;
      }
      int v29 = this[169];
      if (!v29)
      {
        int v29 = (HGBitmap *)HGObject::operator new(0x80uLL);
        uint64_t v34 = HGRectMake4i(0, 0, 0, 0);
        HGBitmap::HGBitmap(v29, v34, v35, 24);
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v40);
    unint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)"OpenGL rendering : Using ", 25);
    unint64_t v19 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)a2 + 48))(a2);
    size_t v20 = strlen(v19);
    unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)v19, v20);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"::RenderPage().", 15);
    std::stringbuf::str();
    char v24 = v39;
    p_p = __p;
    if (v39 >= 0) {
      p_p = &__p;
    }
    int v26 = *((_DWORD *)this + 319);
    if (v26 == 2)
    {
      HGLogger::error((HGLogger *)"%s", v22, v23, p_p);
    }
    else
    {
      if (v26 != 1)
      {
LABEL_22:
        if (v24 < 0) {
          operator delete(__p);
        }
        v40[0] = *MEMORY[0x1E4FBA408];
        uint64_t v32 = *(void *)(MEMORY[0x1E4FBA408] + 72);
        *(void *)((char *)v40 + *(void *)(v40[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
        v41[0] = v32;
        v41[1] = MEMORY[0x1E4FBA470] + 16;
        if (v42 < 0) {
          operator delete((void *)v41[9]);
        }
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        MEMORY[0x1BA9BFAB0](&v43);
        goto LABEL_27;
      }
      HGLogger::warning((HGLogger *)"%s", v22, v23, p_p);
    }
    char v24 = v39;
    goto LABEL_22;
  }
  uint64_t v27 = *((void *)a3 + 1);
  if (v27 && (*(unsigned char *)(v27 + 12) & 0x10) != 0) {
    *((void *)a3 + 1) = 0;
  }
  int v28 = (HGBitmap *)(*(uint64_t (**)(HGNode *, HGPage *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 464))(a2, a3, v15, v16, v17, v14);
LABEL_36:
  HGGPURenderer::ValidateCurrentContext((const char *)this);
  if (v28)
  {
    HGRenderer::DotLogNodeBufferFormat((uint64_t)this, a2, v28);
    if (v7 == 1) {
      long long v36 = "purple";
    }
    else {
      long long v36 = "blue";
    }
    HGDotGraph::fontColor((uint64_t)(this + 105), (unint64_t)a2, v36);
    HGRenderer::DotLogBufferOutput((uint64_t *)this, (HGBitmap *)a2, v28);
  }
  return v28;
}

void sub_1B7772B80(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7772B94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a18 < 0)
  {
    operator delete(__p);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a19);
    _Unwind_Resume(a1);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void HGGPURenderer::EnqueueTextureDelete(HGGPURenderer *this, const unsigned int *a2, HGBitmap *a3, char *a4, int a5)
{
  uint64_t v10 = (HGGLContext *)*((void *)this + *((unsigned int *)this + 290) + 143);
  if (v10) {
    HGGLContext::context((uint64_t *)&v20, v10);
  }
  else {
    HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v20, 0);
  }
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v21, &v20.var0);
  PCSharedCount::PCSharedCount(&v20);
  glFlush();
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v21);
  if (a4)
  {
    (*(void (**)(HGBitmap *))(*(void *)a3 + 16))(a3);
    uint64_t v11 = *((void *)this + 174);
    uint64_t v12 = *((void *)this + 173);
    if (v11 == v12) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = ((v11 - v12) << 6) - 1;
    }
    uint64_t v14 = *((void *)this + 177);
    unint64_t v15 = v14 + *((void *)this + 176);
    if (v13 == v15)
    {
      std::deque<HGBitmap *>::__add_back_capacity((uint64_t)this + 1376);
      uint64_t v14 = *((void *)this + 177);
      uint64_t v12 = *((void *)this + 173);
      unint64_t v15 = *((void *)this + 176) + v14;
    }
    *(void *)(*(void *)(v12 + ((v15 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v15 & 0x1FF)) = a3;
    *((void *)this + 177) = v14 + 1;
    uint64_t v16 = (HGTextureManager *)*((void *)this + 184);
    uint64_t v17 = a2;
    unint64_t v18 = a4;
    unint64_t v19 = (const char *)a3;
    if (!a5) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v16 = (HGTextureManager *)*((void *)this + 184);
    uint64_t v17 = a2;
    unint64_t v18 = a4;
    unint64_t v19 = 0;
    if (!a5)
    {
LABEL_11:
      HGTextureManager::dismissTexture(v16, v17, v18, v19);
      return;
    }
  }
  HGTextureManager::deleteTexture(v16, v17, v18, v19);
}

void sub_1B7772D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7772D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

uint64_t HGGPURenderer::ReleaseBitmap(int64x2_t *this, HGBitmap *a2, char *a3)
{
  HGGPURenderer::PurgePostDeleteEvents(this);
  if (!a2) {
    goto LABEL_9;
  }
  int v8 = *((_DWORD *)a2 + 3);
  if ((v8 & 0x30) == 0) {
    goto LABEL_9;
  }
  if ((v8 & 0x100) != 0)
  {
    if (*((int64x2_t **)a2 + 16) == this)
    {
      uint64_t v11 = (_DWORD *)((char *)a2 + 156);
      if (*((_DWORD *)a2 + 39))
      {
        if (*((_DWORD *)a2 + 40))
        {
          HGGPURenderer::EnqueueTextureDelete((HGGPURenderer *)this, (const unsigned int *)a2 + 40, a2, a3, 1);
          *((_DWORD *)a2 + 40) = 0;
        }
        else if (*((unsigned char *)a2 + 181))
        {
          HGGPURenderer::EnqueueTextureDelete((HGGPURenderer *)this, (const unsigned int *)a2 + 39, a2, a3, 0);
          uint64_t result = 0;
          *uint64_t v11 = 0;
          return result;
        }
        uint64_t result = 0;
        *uint64_t v11 = 0;
        return result;
      }
      return 0;
    }
LABEL_9:
    HGLogger::warning((HGLogger *)"ReleaseBitmap() : buffer is tied to another renderer", v6, v7);
    return 0xFFFFFFFFLL;
  }
  if (*((int64x2_t **)a2 + 16) != this) {
    goto LABEL_9;
  }
  uint64_t v9 = (void *)((char *)a2 + 168);
  if (!*((void *)a2 + 21)) {
    return 0;
  }
  if (*((void *)a2 + 22))
  {
    HGGPURenderer::EnqueueTextureDelete((HGGPURenderer *)this, (const unsigned int *)a2 + 44, a2, a3, 1);
    *((void *)a2 + 22) = 0;
    uint64_t result = 0;
    *uint64_t v9 = 0;
  }
  else
  {
    if (!*((void *)a2 + 17))
    {
      if (*((unsigned char *)a2 + 192)) {
        HGGPURenderer::EnqueueTextureDelete((HGGPURenderer *)this, (const unsigned int *)a2 + 42, a2, a3, 0);
      }
    }
    uint64_t result = 0;
    *uint64_t v9 = 0;
  }
  return result;
}

uint64_t HGGPURenderer::ReleaseTexture(int64x2_t *this, HGGLTexture *a2, char *a3)
{
  uint64_t v6 = *((void *)a2 + 17);
  if (v6)
  {
    int v7 = (char *)this[76].i64[0];
    int v8 = (char *)this[76].i64[1];
    if (v7 != v8)
    {
      while (*(void *)v7 != v6)
      {
        v7 += 8;
        if (v7 == v8)
        {
          int v7 = (char *)this[76].i64[1];
          break;
        }
      }
    }
    int64_t v9 = v8 - (v7 + 8);
    if (v8 != v7 + 8) {
      memmove(v7, v7 + 8, v8 - (v7 + 8));
    }
    this[76].i64[1] = (uint64_t)&v7[v9];
    this[77].i32[2] = -1;
  }

  return HGGPURenderer::ReleaseBitmap(this, (HGBitmap *)a2, a3);
}

uint64_t HGGPURenderer::TestShader(uint64_t a1, uint64_t a2)
{
  return HGGLShaderCache::TestShader(*(HGGLShaderCache **)(a1 + 1288), a2, 0);
}

uint64_t HGGPURenderer::TestShader(uint64_t a1, HGString *a2, _OWORD *a3, void *a4)
{
  return HGGLShaderCache::TestShader(*(HGGLShaderCache **)(a1 + 1288), a2, a3, a4);
}

uint64_t HGGPURenderer::TestShader(uint64_t a1, int *a2, _OWORD *a3, uint64_t *a4)
{
  return HGGLShaderCache::TestShader(*(HGGLShaderCache **)(a1 + 1288), a2, a3, a4);
}

void HGGPURenderer::GetString(uint64_t a1@<X1>, HGString *a2@<X8>)
{
  if (a1) {
    HGString::HGString(a2, (const HGString *)(a1 + 64));
  }
  else {
    HGString::HGString(a2, 0, 1, 0xFFu);
  }
}

uint64_t HGGPURenderer::BindProgram(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v125 = *MEMORY[0x1E4F143B8];
  if (!v2) {
    return 0;
  }
  int v3 = v2;
  uint64_t v4 = v1;
  uint64_t v5 = (HGLimits *)(v2 + 4);
  if (HGLimits::ismetal((HGLimits *)(v2 + 4)))
  {
    uint64_t v6 = *v3 ^ (2 * (v3[2] ^ v3[1] ^ v3[3]));
    uint64_t v7 = *(void *)(*(void *)(*(void *)(v4 + 1112) + 24) + 168);
    *((unsigned char *)&source[0].__r_.__value_.__s + 23) = 12;
    strcpy((char *)source, "fragmentFunc");
    *((unsigned char *)&shaders.__r_.__value_.__s + 23) = 10;
    strcpy((char *)&shaders, "vertexFunc");
    Function = HGMetalFunctionCache::getFunction(v7, source, v6);
    FunctionWithSource = HGMetalFunctionCache::getFunction(v7, &shaders, v6);
    if (Function) {
      goto LABEL_72;
    }
    unint64_t v15 = HGString::c_str((string_t *)v3 + 8, v12, v13, v14);
    size_t v16 = strlen(v15);
    if (v16 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v20 = v16;
    if (v16 >= 0x17)
    {
      uint64_t v49 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17) {
        uint64_t v49 = v16 | 7;
      }
      uint64_t v50 = v49 + 1;
      p_dst = (void **)operator new(v49 + 1);
      size_t v120 = v20;
      int64_t v121 = v50 | 0x8000000000000000;
      std::string __dst = p_dst;
    }
    else
    {
      HIBYTE(v121) = v16;
      p_dst = (void **)&__dst;
      if (!v16)
      {
LABEL_26:
        *((unsigned char *)p_dst + v20) = 0;
        long long v51 = (void **)&__dst;
        if (v121 >= 0)
        {
          int64_t v52 = HIBYTE(v121);
        }
        else
        {
          long long v51 = __dst;
          int64_t v52 = v120;
        }
        long long v53 = (void **)((char *)v51 + v52);
        int64_t size = HIBYTE(shaders.__r_.__value_.__r.__words[2]);
        p_std::string shaders = &shaders;
        if ((shaders.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          int64_t size = shaders.__r_.__value_.__l.__size_;
          p_std::string shaders = (std::string *)shaders.__r_.__value_.__r.__words[0];
        }
        if (size)
        {
          if (v52 < size || (uint64_t v56 = (uint64_t)v53 - size + 1, (void **)v56 == v51))
          {
LABEL_43:
            std::string __p = 0;
            long long v118 = 0uLL;
            goto LABEL_44;
          }
          while (*(unsigned __int8 *)v51 != p_shaders->__r_.__value_.__s.__data_[0])
          {
LABEL_35:
            long long v51 = (void **)((char *)v51 + 1);
            if (v51 == (void **)v56) {
              goto LABEL_43;
            }
          }
          uint64_t v57 = 1;
          while (size != v57)
          {
            int v58 = *((unsigned __int8 *)v51 + v57);
            int v59 = p_shaders->__r_.__value_.__s.__data_[v57++];
            if (v58 != v59) {
              goto LABEL_35;
            }
          }
        }
        std::string __p = 0;
        long long v118 = 0uLL;
        if (v51 != v53)
        {
          string_t v60 = HGString::c_str((string_t *)v3 + 8, v17, v18, v19);
          MEMORY[0x1BA9BF660](&__p, v60);
          char v61 = 0;
          goto LABEL_64;
        }
LABEL_44:
        HGMetalUtils::stringForMetalHeader((uint64_t)&v114);
        HGMetalUtils::stringForMetalVertexOutputStruct((HGMetalUtils *)*((unsigned __int16 *)v3 + 26), (v3[12] & 0x200) != 0, (uint64_t)v112);
        if ((v113 & 0x80u) == 0) {
          HGRect v62 = v112;
        }
        else {
          HGRect v62 = (void **)v112[0];
        }
        if ((v113 & 0x80u) == 0) {
          std::string::size_type v63 = v113;
        }
        else {
          std::string::size_type v63 = (std::string::size_type)v112[1];
        }
        long long v64 = std::string::append(&v114, (const std::string::value_type *)v62, v63);
        long long v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
        v115.__r_.__value_.__r.__words[2] = v64->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v115.__r_.__value_.__l.__data_ = v65;
        v64->__r_.__value_.__l.__size_ = 0;
        v64->__r_.__value_.__r.__words[2] = 0;
        v64->__r_.__value_.__r.__words[0] = 0;
        HGMetalUtils::stringForMetalFragmentOutputStruct((HGMetalUtils *)*((unsigned __int8 *)v3 + 58), *((unsigned char *)v3 + 57) != 0, (uint64_t)v110);
        if ((v111 & 0x80u) == 0) {
          HGRect v66 = v110;
        }
        else {
          HGRect v66 = (void **)v110[0];
        }
        if ((v111 & 0x80u) == 0) {
          std::string::size_type v67 = v111;
        }
        else {
          std::string::size_type v67 = (std::string::size_type)v110[1];
        }
        unint64_t v68 = std::string::append(&v115, (const std::string::value_type *)v66, v67);
        long long v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
        v116.__r_.__value_.__r.__words[2] = v68->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v116.__r_.__value_.__l.__data_ = v69;
        v68->__r_.__value_.__l.__size_ = 0;
        v68->__r_.__value_.__r.__words[2] = 0;
        v68->__r_.__value_.__r.__words[0] = 0;
        int v72 = HGString::c_str((string_t *)v3 + 8, *(double *)&v69, v70, v71);
        uint64_t v73 = std::string::append(&v116, v72);
        uint64_t v74 = (void *)v73->__r_.__value_.__r.__words[0];
        v123[0] = v73->__r_.__value_.__l.__size_;
        *(void *)((char *)v123 + 7) = *(std::string::size_type *)((char *)&v73->__r_.__value_.__r.__words[1] + 7);
        char v75 = HIBYTE(v73->__r_.__value_.__r.__words[2]);
        v73->__r_.__value_.__l.__size_ = 0;
        v73->__r_.__value_.__r.__words[2] = 0;
        v73->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v118) < 0) {
          operator delete(__p);
        }
        std::string __p = v74;
        *(void *)&long long v118 = v123[0];
        *(void *)((char *)&v118 + 7) = *(void *)((char *)v123 + 7);
        HIBYTE(v118) = v75;
        if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v116.__r_.__value_.__l.__data_);
          if (((char)v111 & 0x80000000) == 0)
          {
LABEL_60:
            if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_61;
            }
            goto LABEL_94;
          }
        }
        else if (((char)v111 & 0x80000000) == 0)
        {
          goto LABEL_60;
        }
        operator delete(v110[0]);
        if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_61:
          if (((char)v113 & 0x80000000) == 0) {
            goto LABEL_62;
          }
          goto LABEL_95;
        }
LABEL_94:
        operator delete(v115.__r_.__value_.__l.__data_);
        if (((char)v113 & 0x80000000) == 0)
        {
LABEL_62:
          if ((SHIBYTE(v114.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_63:
            char v61 = 1;
LABEL_64:
            Function = HGMetalFunctionCache::getFunctionWithSource(v7, source, v6, (uint64_t *)&__p);
            if (FunctionWithSource) {
              char v76 = 1;
            }
            else {
              char v76 = v61;
            }
            if ((v76 & 1) == 0) {
              FunctionWithSource = HGMetalFunctionCache::getFunctionWithSource(v7, &shaders, v6, (uint64_t *)&__dst);
            }
            if (SHIBYTE(v118) < 0)
            {
              operator delete(__p);
              if ((SHIBYTE(v121) & 0x80000000) == 0)
              {
LABEL_71:
                if (Function) {
                  goto LABEL_72;
                }
                goto LABEL_83;
              }
            }
            else if ((SHIBYTE(v121) & 0x80000000) == 0)
            {
              goto LABEL_71;
            }
            operator delete(__dst);
            if (Function)
            {
LABEL_72:
              unsigned __int8 v77 = atomic_load(HGLogger::_enabled);
              if (v77) {
                HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind metal {\n", v9, v10);
              }
              HGLogger::indent(1);
              unsigned __int8 v81 = atomic_load(HGLogger::_enabled);
              if (v81)
              {
                string_t v82 = HGString::c_str((string_t *)v3 + 8, v78, v79, v80);
                HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"\n%s\n", v83, v84, v82);
              }
              long long v48 = *(void **)(v4 + 1312);
              (*(void (**)(void *, uint64_t))(*v48 + 16))(v48, v4);
              HGMetalHandler::AddMTLFunction(v48, Function);
              HGMetalHandler::SetAttributeFlags((uint64_t)v48, *((_WORD *)v3 + 24));
              HGMetalHandler::SetTextureCoords((uint64_t)v48, *((unsigned __int16 *)v3 + 26));
              if (FunctionWithSource) {
                HGMetalHandler::AddMTLFunction(v48, FunctionWithSource);
              }
              if ((SHIBYTE(shaders.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_79;
              }
              goto LABEL_90;
            }
LABEL_83:
            unsigned __int8 v86 = atomic_load(HGLogger::_enabled);
            if (v86) {
              HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind metal shader failed(%d) {\n", v9, v10, 4294967237);
            }
            HGLogger::indent(1);
            unsigned __int8 v90 = atomic_load(HGLogger::_enabled);
            if (v90)
            {
              string_t v91 = HGString::c_str((string_t *)v3 + 8, v87, v88, v89);
              HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"%s\n", v92, v93, v91);
            }
            HGLogger::indent(0xFFFFFFFFLL);
            unsigned __int8 v96 = atomic_load(HGLogger::_enabled);
            if (v96) {
              HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"}\n", v94, v95);
            }
            HGGLShaderCache::DisableEntry(*(void *)(v4 + 1288), (uint64_t)v3, -59);
            long long v48 = 0;
            if ((SHIBYTE(shaders.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_79:
              if ((SHIBYTE(source[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                return (uint64_t)v48;
              }
LABEL_91:
              operator delete(source[0].__r_.__value_.__l.__data_);
              return (uint64_t)v48;
            }
LABEL_90:
            operator delete(shaders.__r_.__value_.__l.__data_);
            if ((SHIBYTE(source[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              return (uint64_t)v48;
            }
            goto LABEL_91;
          }
LABEL_96:
          operator delete(v114.__r_.__value_.__l.__data_);
          goto LABEL_63;
        }
LABEL_95:
        operator delete(v112[0]);
        if ((SHIBYTE(v114.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_63;
        }
        goto LABEL_96;
      }
    }
    memmove(p_dst, v15, v20);
    goto LABEL_26;
  }
  uint64_t v22 = HGGLShaderCache::Enable(*(HGGLShaderCache **)(v4 + 1288), (uint64_t)v3, 0, 0);
  if (!v22)
  {
    if (HGLimits::isarb(v5))
    {
      unsigned __int8 v35 = atomic_load(HGLogger::_enabled);
      if (v35) {
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind arb {\n", v33, v34);
      }
      HGLogger::indent(1);
      unsigned __int8 v39 = atomic_load(HGLogger::_enabled);
      if (v39)
      {
        string_t v40 = HGString::c_str((string_t *)v3 + 8, v36, v37, v38);
        HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"\n%s\n", v41, v42, v40);
      }
    }
    else if (*(_DWORD *)v5 >> 9 >= 0x303u)
    {
      unsigned __int8 v97 = atomic_load(HGLogger::_enabled);
      if (v97) {
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind glsl {\n", v33, v34);
      }
      HGLogger::indent(1);
      unsigned __int8 v99 = atomic_load(HGLogger::_enabled);
      if ((v99 & 1) != 0 && (int)HGLogger::getLevel((HGLogger *)"gpu", v98) >= 1)
      {
        GLuint v100 = *(_DWORD *)(*((void *)v3 + 15) + 8);
        LODWORD(__dst) = 0;
        glGetAttachedShaders(v100, 3, (GLsizei *)&__dst, (GLuint *)&shaders);
        unsigned __int8 v103 = atomic_load(HGLogger::_enabled);
        if (v103) {
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"num attached shaders : %d\n", v101, v102, __dst);
        }
        HGLogger::indent(1);
        if ((int)__dst >= 1)
        {
          uint64_t v106 = 0;
          do
          {
            unsigned __int8 v107 = atomic_load(HGLogger::_enabled);
            if (v107) {
              HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"shader #%d : %d\n", v104, v105, v106, *((unsigned int *)&shaders.__r_.__value_.__l.__data_ + v106));
            }
            LODWORD(__p) = 0;
            glGetShaderSource(*((_DWORD *)&shaders.__r_.__value_.__l.__data_ + v106), 0x4000, (GLsizei *)&__p, (GLchar *)source);
            unsigned __int8 v108 = atomic_load(HGLogger::_enabled);
            if (v108) {
              HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"\n%s\n", v104, v105, source);
            }
            ++v106;
          }
          while (v106 < (int)__dst);
        }
        HGLogger::indent(0xFFFFFFFFLL);
      }
    }
    if (HGLimits::isarb(v5)) {
      return (*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 1296) + 16))(*(void *)(v4 + 1296), v4);
    }
    if (*(_DWORD *)v5 >> 9 < 0x303u) {
      return 0;
    }
    return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(v4 + 1304) + 208))(*(void *)(v4 + 1304), v4, *(unsigned int *)(*((void *)v3 + 15) + 8));
  }
  unsigned __int8 v25 = atomic_load(HGLogger::_enabled);
  if (v25)
  {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"failed(%d) {\n", v23, v24, v22);
    HGLogger::indent(1);
    unsigned __int8 v43 = atomic_load(HGLogger::_enabled);
    if ((v43 & 1) == 0)
    {
LABEL_11:
      HGLogger::indent(0xFFFFFFFFLL);
      unsigned __int8 v32 = atomic_load(HGLogger::_enabled);
      if ((v32 & 1) == 0) {
        return 0;
      }
      goto LABEL_20;
    }
  }
  else
  {
    HGLogger::indent(1);
    unsigned __int8 v29 = atomic_load(HGLogger::_enabled);
    if ((v29 & 1) == 0) {
      goto LABEL_11;
    }
  }
  string_t v44 = HGString::c_str((string_t *)v3 + 8, v26, v27, v28);
  HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"%s\n", v45, v46, v44);
  HGLogger::indent(0xFFFFFFFFLL);
  unsigned __int8 v47 = atomic_load(HGLogger::_enabled);
  if (v47) {
LABEL_20:
  }
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"}\n", v30, v31);
  return 0;
}

void sub_1B7773978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *__p,uint64_t a51,int a52,__int16 a53,char a54,char a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  if (a49 < 0)
  {
    operator delete(a44);
    if (a55 < 0)
    {
LABEL_3:
      operator delete(__p);
      if (*(char *)(v61 - 105) < 0)
      {
LABEL_7:
        operator delete(*(void **)(v61 - 128));
        if ((a61 & 0x80000000) == 0) {
          goto LABEL_11;
        }
LABEL_10:
        operator delete(a56);
LABEL_11:
        _Unwind_Resume(a1);
      }
LABEL_9:
      if ((a61 & 0x80000000) == 0) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
  }
  else if (a55 < 0)
  {
    goto LABEL_3;
  }
  if (*(char *)(v61 - 105) < 0) {
    goto LABEL_7;
  }
  goto LABEL_9;
}

uint64_t HGGPURenderer::BindProgramDescriptor(uint64_t a1, HGProgramDescriptor **a2)
{
  uint64_t v4 = *(void **)(a1 + 1312);
  (*(void (**)(void *, uint64_t))(*v4 + 16))(v4, a1);
  unint64_t Hash = HGProgramDescriptor::GetHash(*a2, v5, v6);
  memset(&v59, 0, sizeof(v59));
  uint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 1112) + 24) + 168);
  FragmentFunctionName = HGProgramDescriptor::GetFragmentFunctionName(*a2);
  size_t v10 = strlen(FragmentFunctionName);
  if (v10 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v11 = v10;
  if (v10 >= 0x17)
  {
    uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v13 = v10 | 7;
    }
    uint64_t v14 = v13 + 1;
    p_dst = (std::string *)operator new(v13 + 1);
    __dst.__r_.__value_.__l.__size_ = v11;
    __dst.__r_.__value_.__r.__words[2] = v14 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v10;
  p_dst = &__dst;
  if (v10) {
LABEL_8:
  }
    memmove(p_dst, FragmentFunctionName, v11);
  p_dst->__r_.__value_.__s.__data_[v11] = 0;
  Function = HGMetalFunctionCache::getFunction(v8, &__dst, Hash);
  if (Function) {
    goto LABEL_25;
  }
  MetalLibPath = (const char *)HGProgramDescriptor::GetMetalLibPath(*a2);
  size_t v17 = strlen(MetalLibPath);
  if (v17 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v18 = v17;
  if (v17 >= 0x17)
  {
    uint64_t v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17) {
      uint64_t v20 = v17 | 7;
    }
    uint64_t v21 = v20 + 1;
    p_p = (std::string *)operator new(v20 + 1);
    __p.__r_.__value_.__l.__size_ = v18;
    __p.__r_.__value_.__r.__words[2] = v21 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    goto LABEL_17;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = v17;
  p_p = &__p;
  if (v17) {
LABEL_17:
  }
    memmove(p_p, MetalLibPath, v18);
  p_p->__r_.__value_.__s.__data_[v18] = 0;
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (size && (HGProgramDescriptor::IsConcatenated(*a2) & 1) == 0)
  {
    Function = HGMetalFunctionCache::getFunctionWithLibrary(v8, &__dst, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_42;
    }
    goto LABEL_24;
  }
  memset(&__str, 0, sizeof(__str));
  HGProgramDescriptor::EncodeShaderDeclarations((std::string *)*a2, &__str);
  HGProgramDescriptor::EncodeShaderProgram((uint64_t)*a2, &__str, v23);
  HGProgramDescriptor::EncodeShaderBufferStruct((std::string *)*a2, &__str);
  HGProgramDescriptor::EncodeShaderFunction((uint64_t)*a2, &__str);
  Function = HGMetalFunctionCache::getFunctionWithSource(v8, &__dst, Hash, (uint64_t *)&__str);
  std::string::operator=(&v59, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_42;
    }
LABEL_24:
    if (Function) {
      goto LABEL_25;
    }
    goto LABEL_43;
  }
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_24;
  }
LABEL_42:
  operator delete(__p.__r_.__value_.__l.__data_);
  if (Function)
  {
LABEL_25:
    HGMetalHandler::AddMTLFunction(v4, Function);
    HGProgramDescriptor::GetSignature(*a2, (uint64_t)&__p);
    HGMetalHandler::SetAttributeFlags((uint64_t)v4, v55);
    HGMetalHandler::SetTextureCoords((uint64_t)v4, (unsigned __int16)v56);
    VertexFunctionName = (const char *)HGProgramDescriptor::GetVertexFunctionName(*a2);
    size_t v27 = strlen(VertexFunctionName);
    if (v27 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v28 = v27;
    if (v27 >= 0x17)
    {
      uint64_t v30 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v27 | 7) != 0x17) {
        uint64_t v30 = v27 | 7;
      }
      uint64_t v31 = v30 + 1;
      unsigned __int8 v29 = (std::string *)operator new(v30 + 1);
      __p.__r_.__value_.__l.__size_ = v28;
      __p.__r_.__value_.__r.__words[2] = v31 | 0x8000000000000000;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
    }
    else
    {
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = v27;
      unsigned __int8 v29 = &__p;
      if (!v27)
      {
LABEL_33:
        v29->__r_.__value_.__s.__data_[v28] = 0;
        std::string::size_type v32 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v32 = __p.__r_.__value_.__l.__size_;
        }
        if (!v32) {
LABEL_75:
        }
          HGProgramDescriptor::CopyDependencies(*a2);
        FunctionWithSource = HGMetalFunctionCache::getFunction(v8, &__p, Hash);
        if (FunctionWithSource)
        {
LABEL_74:
          HGMetalHandler::AddMTLFunction(v4, FunctionWithSource);
          goto LABEL_75;
        }
        uint64_t v34 = (const char *)HGProgramDescriptor::GetMetalLibPath(*a2);
        size_t v35 = strlen(v34);
        if (v35 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        std::string::size_type v36 = v35;
        if (v35 >= 0x17)
        {
          uint64_t v46 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v35 | 7) != 0x17) {
            uint64_t v46 = v35 | 7;
          }
          uint64_t v47 = v46 + 1;
          p_str = operator new(v46 + 1);
          __str.__r_.__value_.__l.__size_ = v36;
          __str.__r_.__value_.__r.__words[2] = v47 | 0x8000000000000000;
          __str.__r_.__value_.__r.__words[0] = (std::string::size_type)p_str;
        }
        else
        {
          *((unsigned char *)&__str.__r_.__value_.__s + 23) = v35;
          p_str = &__str;
          if (!v35)
          {
LABEL_57:
            p_str[v36] = 0;
            std::string::size_type v48 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v48 = __str.__r_.__value_.__l.__size_;
            }
            if (v48)
            {
              FunctionWithLibrary = HGMetalFunctionCache::getFunctionWithLibrary(v8, &__p, (uint64_t)&__str);
            }
            else
            {
              std::string::size_type v50 = HIBYTE(v59.__r_.__value_.__r.__words[2]);
              if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string::size_type v50 = v59.__r_.__value_.__l.__size_;
              }
              if (!v50)
              {
LABEL_68:
                memset(&v53, 0, sizeof(v53));
                HGProgramDescriptor::EncodeShaderDeclarations((std::string *)*a2, &v53);
                HGProgramDescriptor::EncodeShaderProgram((uint64_t)*a2, &v53, v51);
                HGProgramDescriptor::EncodeShaderBufferStruct((std::string *)*a2, &v53);
                HGProgramDescriptor::EncodeShaderFunction((uint64_t)*a2, &v53);
                FunctionWithSource = HGMetalFunctionCache::getFunctionWithSource(v8, &__p, Hash, (uint64_t *)&v53);
                if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v53.__r_.__value_.__l.__data_);
                }
LABEL_70:
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(__str.__r_.__value_.__l.__data_);
                  if (!FunctionWithSource) {
                    goto LABEL_75;
                  }
                }
                else if (!FunctionWithSource)
                {
                  goto LABEL_75;
                }
                goto LABEL_74;
              }
              FunctionWithLibrary = HGMetalFunctionCache::getFunctionWithSource(v8, &__p, Hash, (uint64_t *)&v59);
            }
            FunctionWithSource = FunctionWithLibrary;
            if (FunctionWithLibrary) {
              goto LABEL_70;
            }
            goto LABEL_68;
          }
        }
        memmove(p_str, v34, v36);
        goto LABEL_57;
      }
    }
    memmove(v29, VertexFunctionName, v28);
    goto LABEL_33;
  }
LABEL_43:
  unsigned __int8 v38 = atomic_load(HGLogger::_enabled);
  if (v38) {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"bind metal shader failed {\n", v24, v25);
  }
  HGLogger::indent(1);
  unsigned __int8 v41 = atomic_load(HGLogger::_enabled);
  if (v41)
  {
    char v42 = &v59;
    if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      char v42 = (std::string *)v59.__r_.__value_.__r.__words[0];
    }
    HGLogger::log((HGLogger *)"gpu", (const char *)3, (HGLogger *)"%s\n", v39, v40, v42);
  }
  HGLogger::indent(0xFFFFFFFFLL);
  unsigned __int8 v45 = atomic_load(HGLogger::_enabled);
  if (v45) {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"}\n", v43, v44);
  }
  (*(void (**)(void *, uint64_t))(*v4 + 16))(v4, a1);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_79;
    }
  }
  else if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
  {
LABEL_79:
    operator delete(v59.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_1B777438C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a30 < 0)
  {
    operator delete(__p);
    if (a21 < 0)
    {
LABEL_5:
      operator delete(a16);
      if ((a36 & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_9;
    }
  }
  else if (a21 < 0)
  {
    goto LABEL_5;
  }
  if ((a36 & 0x80000000) == 0)
  {
LABEL_6:
    if (*(char *)(v36 - 89) < 0) {
      goto LABEL_7;
    }
    goto LABEL_10;
  }
LABEL_9:
  operator delete(a31);
  if (*(char *)(v36 - 89) < 0)
  {
LABEL_7:
    operator delete(*(void **)(v36 - 112));
    _Unwind_Resume(a1);
  }
LABEL_10:
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::BindProgram(HGGPURenderer *this, const char *a2, void *a3)
{
  uint64_t v8 = 0;
  HGString::HGString((HGString *)v7, a2, 0, 0xFFu);
  int v5 = (*(uint64_t (**)(HGGPURenderer *, unsigned char *, void, uint64_t *))(*(void *)this + 408))(this, v7, 0, &v8);
  HGString::~HGString((HGString *)v7);
  if (v5) {
    return 0;
  }
  else {
    return (*(uint64_t (**)(HGGPURenderer *, uint64_t, void *))(*(void *)this + 368))(this, v8, a3);
  }
}

void sub_1B777456C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

void HGGPURenderer::UnBindProgram(HGGPURenderer *this, HGHandler *a2)
{
  if (a2)
  {
    HGLogger::indent(0xFFFFFFFFLL);
    unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
    if (v5) {
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"}\n", v3, v4);
    }
    uint64_t v6 = *(void (**)(HGHandler *))(*(void *)a2 + 200);
    v6(a2);
  }
}

uint64_t HGGPURenderer::GetConcatenationMask(HGGPURenderer *this, HGNode *a2)
{
  HGNode::GetProgramDescriptor(a2, &v11);
  HGProgramDescriptor::GetSignature(v11, (uint64_t)v9);
  int v4 = v10;
  if (v10)
  {
    unsigned int v5 = 0;
    uint64_t v6 = v10;
    do
    {
      if (v4)
      {
        if (HGRenderer::IsMergeable(this, a2, v5, 0)) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = v6 & ~(1 << v5);
        }
      }
      ++v5;
      BOOL v7 = v4 > 1;
      v4 >>= 1;
    }
    while (v7);
  }
  else
  {
    uint64_t v6 = 0;
  }
  if (v11) {
    (*(void (**)(HGProgramDescriptor *))(*(void *)v11 + 24))(v11);
  }
  return v6;
}

void sub_1B77746F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16) {
    (*(void (**)(uint64_t))(*(void *)a16 + 24))(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGGPURenderer::GenProgram(HGGLShaderCache **this, HGNode *a2, int a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)a2 + 48))(a2);
  snprintf(__str, 0x100uLL, "GenProgram(node = %p, %s)", a2, v6);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v36, "concat", 1, __str);
  if ((*((unsigned char *)a2 + 16) & 0x10) == 0)
  {
    if (HGGPURenderer::GetNodeRenderAPI((HGGPURenderer *)this, a2) == 1 || !*((unsigned char *)this + 1281))
    {
      uint64_t v9 = (*((uint64_t (**)(HGGLShaderCache **, uint64_t))*this + 16))(this, 32);
      (*((void (**)(HGGLShaderCache **, uint64_t, uint64_t))*this + 15))(this, 32, 396048);
      GLuint Program = (const char *)HGRenderer::GetProgram((HGRenderer *)this, a2);
      (*((void (**)(HGGLShaderCache **, uint64_t, uint64_t))*this + 15))(this, 32, v9);
    }
    else
    {
      GLuint Program = (const char *)HGRenderer::GetProgram((HGRenderer *)this, a2);
    }
    if (!Program || !*Program)
    {
      *((void *)a2 + 40) = 0;
      if (*((void *)a2 + 8))
      {
        HGNode::ClearNodeChain(a2);
        HGShaderBinding::reset((HGShaderBinding *)((char *)a2 + 260));
        *((void *)a2 + 8) = 0;
      }
      uint64_t v8 = 0xFFFFFFFFLL;
      goto LABEL_69;
    }
    Entry = HGGLShaderCache::GetEntry(this[161], Program);
    std::string::size_type v11 = (int *)*((void *)a2 + 8);
    int v12 = Entry != v11;
    if (!*Program || (uint64_t v13 = HGGLShaderCache::GetEntry(this[161], Program), (v14 = v13[7]) == 0))
    {
      *((void *)a2 + 40) = Entry;
      if (Entry == v11) {
        goto LABEL_62;
      }
      goto LABEL_58;
    }
    unsigned int v15 = 0;
    unint64_t v16 = v13[7];
    do
    {
      if (v14)
      {
        if (HGRenderer::IsMergeable((HGRenderer *)this, a2, v15, 0)) {
          unint64_t v16 = v16;
        }
        else {
          unint64_t v16 = v16 & ~(1 << v15);
        }
      }
      ++v15;
      BOOL v17 = v14 >= 2;
      v14 >>= 1;
    }
    while (v17);
    *((void *)a2 + 40) = Entry;
    if (!v16) {
      goto LABEL_45;
    }
    HGNode::InitNodeChain(a2, 8uLL);
    if (*((void *)a2 + 10))
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      uint64_t v20 = (const char *)v16;
      do
      {
        if (v16)
        {
          uint64_t v24 = *(void *)(*((void *)a2 + 10) + 8 * v18);
          if (v24 && (uint64_t v25 = *(void *)(v24 + 16)) != 0)
          {
            uint64_t v26 = *(void *)(v25 + 144);
            if (*(void *)(v26 + 192) || *(void *)(v26 + 248) || HGRect::IsNull((HGRect *)(v26 + 168)))
            {
              uint64_t v21 = 0;
              uint64_t v20 = (const char *)(v20 & ~(1 << v18));
              uint64_t v22 = (void *)(*((void *)a2 + 37) + v19);
            }
            else
            {
              if (((*((uint64_t (**)(HGGLShaderCache **, uint64_t, void))*this + 40))(this, v26, 0) & 0x80000000) != 0
                || (uint64_t v27 = *(void *)(v26 + 64)) == 0
                || !HGLimits::issafe((HGLimits *)(v27 + 16)))
              {
                uint64_t v20 = (const char *)(v20 & ~(1 << v18));
              }
              uint64_t v22 = (void *)(v26 + 64);
              uint64_t v21 = *(void *)(*((void *)a2 + 37) + v19);
            }
          }
          else
          {
            uint64_t v21 = 0;
            uint64_t v22 = (void *)(*((void *)a2 + 37) + 56 * v18 + 8);
          }
          int v12 = v12 & 1 | (*v22 != v21);
        }
        ++v18;
        v19 += 56;
        BOOL v23 = v16 > 1;
        LODWORD(v16) = (int)v16 >> 1;
      }
      while (v23);
      if (!v20)
      {
LABEL_45:
        if (!v12) {
          goto LABEL_62;
        }
        goto LABEL_58;
      }
    }
    else
    {
      uint64_t v20 = (const char *)v16;
    }
    if (!v12 || HGGPURenderer::Concatenate((HGRenderer *)this, a2, (unsigned __int8 *)Entry, v20))
    {
      std::string::size_type v28 = (char *)*((void *)a2 + 37);
      unsigned __int8 v29 = (char *)*((void *)a2 + 38);
      int64_t v30 = v29 - v28;
      if (v29 != v28)
      {
        uint64_t v31 = 0;
        unint64_t v32 = v30 / 56;
        if (v32 <= 1) {
          unint64_t v32 = 1;
        }
        do
        {
          if (*(void *)v28) {
            *(void *)std::string::size_type v28 = *(void *)(*(void *)(*(void *)(*((void *)a2 + 10) + 8 * v31) + 16) + 144);
          }
          ++v31;
          v28 += 56;
        }
        while (v32 != v31);
      }
      goto LABEL_66;
    }
    uint64_t v33 = (int *)*((void *)a2 + 8);
    HGNode::ClearNodeChain(a2);
    if (v33 == Entry) {
      goto LABEL_62;
    }
LABEL_58:
    if (*((void *)a2 + 8))
    {
      HGNode::ClearNodeChain(a2);
      double v34 = HGShaderBinding::reset((HGShaderBinding *)((char *)a2 + 260));
      if (a3 && (*((unsigned int (**)(HGGLShaderCache **, int *, double))*this + 54))(this, Entry, v34)) {
        Entry = 0;
      }
      goto LABEL_65;
    }
LABEL_62:
    if (!a3) {
      goto LABEL_66;
    }
    if ((*((unsigned int (**)(HGGLShaderCache **, int *))*this + 54))(this, Entry)) {
      Entry = 0;
    }
LABEL_65:
    *((void *)a2 + 8) = Entry;
LABEL_66:
    if (*((void *)a2 + 8)) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = 0xFFFFFFFFLL;
    }
LABEL_69:
    *((_DWORD *)a2 + 4) |= 0x10u;
    goto LABEL_70;
  }
  if (*((void *)a2 + 8)) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = 0xFFFFFFFFLL;
  }
LABEL_70:
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v36);
  return v8;
}

void sub_1B7774C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7774C7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7774C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7774CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7774CBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7774CD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderer::GenProgram2(HGGPURenderer *this, HGNode *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v4 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)a2 + 48))(a2);
  snprintf(__str, 0x100uLL, "GenProgram2(node = %p, %s)", a2, v4);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v18, "concat", 1, __str);
  HGNode::GetProgramDescriptor(a2, &v17);
  if (!v17)
  {
    uint64_t v6 = (_DWORD *)((char *)a2 + 16);
    if ((*((unsigned char *)a2 + 16) & 0x10) != 0)
    {
      uint64_t v14 = 0xFFFFFFFFLL;
      goto LABEL_32;
    }
    goto LABEL_18;
  }
  BOOL IsComplete = HGProgramDescriptor::IsComplete(v17);
  uint64_t v6 = (_DWORD *)((char *)a2 + 16);
  if ((*((unsigned char *)a2 + 16) & 0x10) != 0)
  {
    uint64_t v14 = (IsComplete - 1);
    unsigned int v15 = v17;
    if (!v17) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  if (!IsComplete)
  {
LABEL_18:
    *((void *)a2 + 40) = 0;
    if (*((void *)a2 + 8))
    {
      HGNode::ClearNodeChain(a2);
      HGShaderBinding::reset((HGShaderBinding *)((char *)a2 + 260));
      *((void *)a2 + 8) = 0;
    }
    uint64_t v14 = 0xFFFFFFFFLL;
    *v6 |= 0x10u;
    unsigned int v15 = v17;
    if (v17) {
      goto LABEL_31;
    }
    goto LABEL_32;
  }
  int ConcatenationMask = HGGPURenderer::GetConcatenationMask(this, a2);
  if (!ConcatenationMask)
  {
    if (!*((void *)a2 + 10)) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  HGNode::InitNodeChain(a2, 8uLL);
  if (*((void *)a2 + 10))
  {
    unint64_t v8 = 0;
    unsigned int v9 = ConcatenationMask;
    do
    {
      if (ConcatenationMask)
      {
        uint64_t v11 = *(void *)(*((void *)a2 + 10) + 8 * v8);
        if (!v11
          || (uint64_t v12 = *(void *)(v11 + 16)) == 0
          || (uint64_t v13 = *(void *)(v12 + 144), *(void *)(v13 + 192))
          || *(void *)(v13 + 248)
          || HGRect::IsNull((HGRect *)(v13 + 168))
          || ((*(uint64_t (**)(HGGPURenderer *, uint64_t, void))(*(void *)this + 320))(this, v13, 0) & 0x80000000) != 0)
        {
          HGProgramDescriptor::SetInput(v17, v8, 1);
          v9 &= ~(1 << v8);
        }
      }
      ++v8;
      BOOL v10 = ConcatenationMask >= 2;
      ConcatenationMask >>= 1;
    }
    while (v10);
    if (!v9 || !HGGPURenderer::Concatenate(this, a2, v9))
    {
LABEL_29:
      HGShaderBinding::reset((HGShaderBinding *)((char *)a2 + 260));
      HGNode::ClearNodeChain(a2);
    }
  }
LABEL_30:
  uint64_t v14 = 0;
  *v6 |= 0x10u;
  unsigned int v15 = v17;
  if (v17) {
LABEL_31:
  }
    (*(void (**)(HGProgramDescriptor *))(*(void *)v15 + 24))(v15);
LABEL_32:
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v18);
  return v14;
}

void sub_1B7774F9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  if (a4) {
    (*(void (**)(uint64_t))(*(void *)a4 + 24))(a4);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

double HGGPURenderer::GetShaderCompileTime(HGGLShaderCache **this)
{
  return HGGLShaderCache::GetShaderCompileTime(this[161]);
}

float HGGPURenderer::BindProbe(HGGPURenderer *this)
{
  return 8.0;
}

uint64_t HGGPURenderer::CreateDepthBufferManagers(uint64_t this)
{
  if (*(unsigned char *)(this + 1281))
  {
    if (*(void *)(this + 224) == *(void *)(this + 232)) {
      operator new();
    }
  }
  return this;
}

void sub_1B77751FC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C408BC0E8B2);
  _Unwind_Resume(a1);
}

void FBOStrategy::cleanupCache(FBOStrategy *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v13, "framebuffer", 2, "cleanupCache()");
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A1FC8))
  {
    qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
    qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
    qword_1EB9A1FE0 = 0;
    __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A1FC8);
  }
  uint64_t v3 = qword_1EB9A1FE0;
  if ((unint64_t)qword_1EB9A1FE0 >= 0x20)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A1FC0))
    {
      operator new();
    }
    std::mutex::lock((std::mutex *)qword_1EB9A1FB8);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A1FC8))
    {
      qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FE0 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1FC8);
    }
    int v4 = &qword_1EB9A1FD0;
    unint64_t v5 = v3;
    do
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB9A1FC8))
      {
        qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
        qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
        qword_1EB9A1FE0 = 0;
        __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
        __cxa_guard_release(&qword_1EB9A1FC8);
      }
      if (v4 == (uint64_t *)qword_1EB9A1FD8) {
        break;
      }
      unsigned int v9 = (void *)*v4;
      if (!*(unsigned char *)(*v4 + 32))
      {
        GLuint framebuffers = *((_DWORD *)v9 + 7);
        glDeleteFramebuffers(1, &framebuffers);
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EB9A1FC8))
        {
          qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
          qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
          qword_1EB9A1FE0 = 0;
          __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
          __cxa_guard_release(&qword_1EB9A1FC8);
        }
        uint64_t v6 = (void **)*v4;
        uint64_t v7 = *(void *)*v4;
        unint64_t v8 = *(void **)(*v4 + 8);
        *(void *)(v7 + 8) = v8;
        *v6[1] = v7;
        --qword_1EB9A1FE0;
        operator delete(v6);
        --v5;
        unsigned int v9 = (void *)*v8;
      }
      int v4 = v9;
    }
    while (v5 > 0x1F);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A1FC0))
    {
      operator new();
    }
    std::mutex::unlock((std::mutex *)qword_1EB9A1FB8);
    unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
    if (v10) {
      HGLogger::log((HGLogger *)"framebuffer", (const char *)1, (HGLogger *)"removed %lu entries from cache\n", v1, v2, v3 - v5);
    }
  }
  unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
  if (v11)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FC8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB9A1FC8))
    {
      qword_1EB9A1FD0 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FD8 = (uint64_t)&qword_1EB9A1FD0;
      qword_1EB9A1FE0 = 0;
      __cxa_atexit((void (*)(void *))std::list<FBOStrategy::FBOCacheEntry>::~list, &qword_1EB9A1FD0, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1FC8);
    }
    HGLogger::log((HGLogger *)"framebuffer", (const char *)2, (HGLogger *)"current size of cache = %lu\n", v1, v2, qword_1EB9A1FE0);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v13);
}

void sub_1B77755DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  __cxa_guard_abort(&qword_1EB9A1FC0);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7775600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7775614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7775628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B777563C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void PBOStrategy::PBOStageSetBuffer::~PBOStageSetBuffer(PBOStrategy::PBOStageSetBuffer *this)
{
}

void PBOStrategy::PBOStageReadPixels::~PBOStageReadPixels(PBOStrategy::PBOStageReadPixels *this)
{
}

void PBOStrategy::PBOStageMapBuffer::~PBOStageMapBuffer(PBOStrategy::PBOStageMapBuffer *this)
{
}

void PBOStrategy::PBOStageStartCopy::~PBOStageStartCopy(PBOStrategy::PBOStageStartCopy *this)
{
}

void PBOStrategy::PBOStageFinishCopy::~PBOStageFinishCopy(PBOStrategy::PBOStageFinishCopy *this)
{
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **,false>(uint64_t result, char *a2, uint64_t a3, uint64_t a4, char a5)
{
  unsigned __int8 v11 = (unint64_t *)result;
LABEL_2:
  uint64_t v12 = v11;
  while (1)
  {
    unsigned __int8 v11 = v12;
    uint64_t v13 = a2 - (char *)v12;
    unint64_t v14 = (a2 - (char *)v12) >> 3;
    if (v6 || !v5)
    {
      switch(v14)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unint64_t v71 = *((void *)a2 - 1);
          unint64_t v72 = *v12;
          if (v71 < *v12)
          {
            *uint64_t v12 = v71;
            *((void *)a2 - 1) = v72;
          }
          return result;
        case 3uLL:
          unint64_t v73 = *v12;
          unint64_t v74 = v12[1];
          unint64_t v75 = *((void *)a2 - 1);
          if (v74 >= *v12)
          {
            if (v75 < v74)
            {
              v12[1] = v75;
              *((void *)a2 - 1) = v74;
              unint64_t v93 = *v12;
              unint64_t v92 = v12[1];
              if (v92 < *v12)
              {
                *uint64_t v12 = v92;
                v12[1] = v93;
              }
            }
          }
          else
          {
            if (v75 >= v74)
            {
              *uint64_t v12 = v74;
              v12[1] = v73;
              unint64_t v100 = *((void *)a2 - 1);
              if (v100 >= v73) {
                return result;
              }
              v12[1] = v100;
            }
            else
            {
              *uint64_t v12 = v75;
            }
            *((void *)a2 - 1) = v73;
          }
          return result;
        case 4uLL:
          char v76 = v12 + 1;
          unsigned __int8 v77 = (unint64_t *)v12[1];
          double v78 = v12 + 2;
          unint64_t v79 = v12[2];
          uint32x4_t v80 = (unint64_t *)*v12;
          if ((unint64_t)v77 >= *v12)
          {
            if (v79 >= (unint64_t)v77)
            {
LABEL_149:
              unsigned __int8 v77 = (unint64_t *)v79;
              unint64_t v94 = *((void *)a2 - 1);
              if (v94 >= (unint64_t)v77) {
                return result;
              }
LABEL_150:
              unint64_t *v78 = v94;
              *((void *)a2 - 1) = v77;
              unint64_t v97 = *v78;
              unint64_t v98 = *v76;
              if (v97 < v98)
              {
                v12[1] = v97;
                void v12[2] = v98;
                unint64_t v99 = *v12;
                if (v97 < *v12)
                {
                  *uint64_t v12 = v97;
                  v12[1] = v99;
                }
              }
              return result;
            }
            *char v76 = v79;
            unint64_t *v78 = (unint64_t)v77;
            unsigned __int8 v81 = v12;
            string_t v82 = (unint64_t **)(v12 + 1);
            uint64_t result = (uint64_t)v77;
            if (v79 >= (unint64_t)v80)
            {
LABEL_141:
              unint64_t v94 = *((void *)a2 - 1);
              if (v94 >= (unint64_t)v77) {
                return result;
              }
              goto LABEL_150;
            }
          }
          else
          {
            unsigned __int8 v81 = v12;
            string_t v82 = (unint64_t **)(v12 + 2);
            uint64_t result = *v12;
            if (v79 >= (unint64_t)v77)
            {
              *uint64_t v12 = (unint64_t)v77;
              v12[1] = (unint64_t)v80;
              unsigned __int8 v81 = v12 + 1;
              string_t v82 = (unint64_t **)(v12 + 2);
              uint64_t result = (uint64_t)v80;
              if (v79 >= (unint64_t)v80) {
                goto LABEL_149;
              }
            }
          }
          *unsigned __int8 v81 = v79;
          float *v82 = v80;
          unsigned __int8 v77 = (unint64_t *)result;
          goto LABEL_141;
        case 5uLL:
          return (uint64_t)std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **>(v12, v12 + 1, v12 + 2, v12 + 3, (unint64_t *)a2 - 1);
        default:
          JUMPOUT(0);
      }
    }
    if (v13 <= 191) {
      break;
    }
    if (!a4)
    {
      if (v12 != (unint64_t *)a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **,HGBitmap **>((char *)v12, a2, a2);
      }
      return result;
    }
    unint64_t v15 = v14 >> 1;
    unint64_t v16 = &v12[v14 >> 1];
    unint64_t v17 = *((void *)a2 - 1);
    if ((unint64_t)v13 < 0x401)
    {
      unint64_t v20 = *v12;
      unint64_t v21 = *v16;
      if (*v12 < *v16)
      {
        if (v17 < v20)
        {
          unint64_t *v16 = v17;
          goto LABEL_32;
        }
        unint64_t *v16 = v20;
        *uint64_t v12 = v21;
        unint64_t v33 = *((void *)a2 - 1);
        if (v33 < v21)
        {
          *uint64_t v12 = v33;
LABEL_32:
          *((void *)a2 - 1) = v21;
        }
LABEL_33:
        --a4;
        unint64_t v24 = *v12;
        if (a5) {
          goto LABEL_57;
        }
        goto LABEL_56;
      }
      if (v17 >= v20) {
        goto LABEL_33;
      }
      *uint64_t v12 = v17;
      *((void *)a2 - 1) = v20;
      unint64_t v23 = *v16;
      if (*v12 >= *v16) {
        goto LABEL_33;
      }
      unint64_t *v16 = *v12;
      *uint64_t v12 = v23;
      --a4;
      unint64_t v24 = v23;
      if (a5) {
        goto LABEL_57;
      }
LABEL_56:
      if (*(v12 - 1) < v24) {
        goto LABEL_57;
      }
      if (v24 < *((void *)a2 - 1))
      {
        do
        {
          unint64_t v62 = v12[1];
          ++v12;
        }
        while (v24 >= v62);
      }
      else
      {
        std::string::size_type v63 = v12 + 1;
        do
        {
          uint64_t v12 = v63;
          if (v63 >= (unint64_t *)a2) {
            break;
          }
          ++v63;
        }
        while (v24 >= *v12);
      }
      long long v64 = (unint64_t *)a2;
      if (v12 < (unint64_t *)a2)
      {
        long long v64 = (unint64_t *)a2;
        do
          unint64_t v65 = *--v64;
        while (v24 < v65);
      }
      if (v12 < v64)
      {
        unint64_t v66 = *v12;
        unint64_t v67 = *v64;
        do
        {
          *uint64_t v12 = v67;
          unint64_t *v64 = v66;
          do
          {
            unint64_t v68 = v12[1];
            ++v12;
            unint64_t v66 = v68;
          }
          while (v24 >= v68);
          do
          {
            unint64_t v69 = *--v64;
            unint64_t v67 = v69;
          }
          while (v24 < v69);
        }
        while (v12 < v64);
      }
      double v70 = v12 - 1;
      BOOL v5 = v12 - 1 >= v11;
      BOOL v6 = v12 - 1 == v11;
      if (v12 - 1 != v11) {
        *unsigned __int8 v11 = *v70;
      }
      a5 = 0;
      unint64_t *v70 = v24;
    }
    else
    {
      unint64_t v18 = *v16;
      unint64_t v19 = *v12;
      if (*v16 >= *v12)
      {
        if (v17 < v18)
        {
          unint64_t *v16 = v17;
          *((void *)a2 - 1) = v18;
          unint64_t v22 = *v12;
          if (*v16 < *v12)
          {
            *uint64_t v12 = *v16;
            unint64_t *v16 = v22;
          }
        }
      }
      else
      {
        if (v17 >= v18)
        {
          *uint64_t v12 = v18;
          unint64_t *v16 = v19;
          unint64_t v25 = *((void *)a2 - 1);
          if (v25 >= v19) {
            goto LABEL_24;
          }
          unint64_t *v16 = v25;
        }
        else
        {
          *uint64_t v12 = v17;
        }
        *((void *)a2 - 1) = v19;
      }
LABEL_24:
      uint64_t v26 = &v12[v15];
      unint64_t v29 = *(v26 - 1);
      uint64_t v27 = v26 - 1;
      unint64_t v28 = v29;
      unint64_t v30 = v12[1];
      unint64_t v31 = *((void *)a2 - 2);
      if (v29 >= v30)
      {
        if (v31 < v28)
        {
          *uint64_t v27 = v31;
          *((void *)a2 - 2) = v28;
          unint64_t v32 = v12[1];
          if (*v27 < v32)
          {
            v12[1] = *v27;
            *uint64_t v27 = v32;
          }
        }
      }
      else
      {
        if (v31 >= v28)
        {
          v12[1] = v28;
          *uint64_t v27 = v30;
          unint64_t v34 = *((void *)a2 - 2);
          if (v34 >= v30) {
            goto LABEL_38;
          }
          *uint64_t v27 = v34;
        }
        else
        {
          v12[1] = v31;
        }
        *((void *)a2 - 2) = v30;
      }
LABEL_38:
      size_t v35 = &v12[v15];
      unint64_t v38 = v35[1];
      uint64_t v36 = v35 + 1;
      unint64_t v37 = v38;
      unint64_t v39 = v12[2];
      unint64_t v40 = *((void *)a2 - 3);
      if (v38 >= v39)
      {
        if (v40 < v37)
        {
          *uint64_t v36 = v40;
          *((void *)a2 - 3) = v37;
          unint64_t v41 = v12[2];
          if (*v36 < v41)
          {
            void v12[2] = *v36;
            *uint64_t v36 = v41;
          }
        }
      }
      else
      {
        if (v40 >= v37)
        {
          void v12[2] = v37;
          *uint64_t v36 = v39;
          unint64_t v42 = *((void *)a2 - 3);
          if (v42 >= v39) {
            goto LABEL_47;
          }
          *uint64_t v36 = v42;
        }
        else
        {
          void v12[2] = v40;
        }
        *((void *)a2 - 3) = v39;
      }
LABEL_47:
      unint64_t v43 = *v16;
      unint64_t v44 = *v27;
      unint64_t v45 = *v36;
      if (*v16 >= *v27)
      {
        if (v45 >= v43) {
          goto LABEL_55;
        }
        unint64_t *v16 = v45;
        *uint64_t v36 = v43;
        uint64_t v36 = &v12[v14 >> 1];
        unint64_t v43 = v44;
        if (v45 < v44)
        {
LABEL_54:
          *uint64_t v27 = v45;
          *uint64_t v36 = v44;
LABEL_55:
          unint64_t v47 = *v12;
          *uint64_t v12 = v43;
          unint64_t *v16 = v47;
          --a4;
          unint64_t v24 = *v12;
          if ((a5 & 1) == 0) {
            goto LABEL_56;
          }
          goto LABEL_57;
        }
        unint64_t v61 = *v12;
        *uint64_t v12 = v45;
        unint64_t *v16 = v61;
        --a4;
        unint64_t v24 = *v12;
        if (a5) {
          goto LABEL_57;
        }
        goto LABEL_56;
      }
      if (v45 < v43) {
        goto LABEL_54;
      }
      *uint64_t v27 = v43;
      unint64_t *v16 = v44;
      uint64_t v27 = &v12[v14 >> 1];
      unint64_t v43 = v45;
      if (v45 < v44) {
        goto LABEL_54;
      }
      unint64_t v46 = *v12;
      *uint64_t v12 = v44;
      unint64_t *v16 = v46;
      --a4;
      unint64_t v24 = *v12;
      if ((a5 & 1) == 0) {
        goto LABEL_56;
      }
LABEL_57:
      uint64_t v48 = 0;
      do
        unint64_t v49 = v12[++v48];
      while (v49 < v24);
      std::string::size_type v50 = &v12[v48];
      long long v51 = a2;
      if (v48 == 1)
      {
        long long v51 = a2;
        do
        {
          if (v50 >= (unint64_t *)v51) {
            break;
          }
          unint64_t v53 = *((void *)v51 - 1);
          v51 -= 8;
        }
        while (v53 >= v24);
      }
      else
      {
        do
        {
          unint64_t v52 = *((void *)v51 - 1);
          v51 -= 8;
        }
        while (v52 >= v24);
      }
      if (v50 >= (unint64_t *)v51)
      {
        std::string v59 = v50 - 1;
        if (v50 - 1 == v12) {
          goto LABEL_75;
        }
LABEL_74:
        *uint64_t v12 = *v59;
        goto LABEL_75;
      }
      unint64_t v54 = *(void *)v51;
      unsigned int v55 = &v12[v48];
      unsigned int v56 = (unint64_t *)v51;
      do
      {
        *unsigned int v55 = v54;
        *unsigned int v56 = v49;
        do
        {
          unint64_t v57 = v55[1];
          ++v55;
          unint64_t v49 = v57;
        }
        while (v57 < v24);
        do
        {
          unint64_t v58 = *--v56;
          unint64_t v54 = v58;
        }
        while (v58 >= v24);
      }
      while (v55 < v56);
      std::string v59 = v55 - 1;
      if (v55 - 1 != v12) {
        goto LABEL_74;
      }
LABEL_75:
      *std::string v59 = v24;
      if (v50 < (unint64_t *)v51) {
        goto LABEL_78;
      }
      BOOL v60 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **>(v12, v59);
      uint64_t v12 = v59 + 1;
      uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **>(v59 + 1, (unint64_t *)a2);
      if (result)
      {
        a2 = (char *)v59;
        if (v60) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v60)
      {
LABEL_78:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **,false>(v11, v59, a3, a4, a5 & 1);
        a5 = 0;
        uint64_t v12 = v59 + 1;
      }
    }
  }
  uint64_t v83 = (char *)(v12 + 1);
  BOOL v85 = v12 == (unint64_t *)a2 || v83 == a2;
  if (a5)
  {
    if (!v85)
    {
      uint64_t v86 = 0;
      double v87 = v12;
      do
      {
        unint64_t v90 = *v87;
        unint64_t v89 = v87[1];
        double v87 = (unint64_t *)v83;
        if (v89 < v90)
        {
          uint64_t v91 = v86;
          do
          {
            *(unint64_t *)((char *)v12 + v91 + 8) = v90;
            if (!v91)
            {
              double v88 = v12;
              goto LABEL_124;
            }
            unint64_t v90 = *(unint64_t *)((char *)v12 + v91 - 8);
            v91 -= 8;
          }
          while (v89 < v90);
          double v88 = (unint64_t *)((char *)v12 + v91 + 8);
LABEL_124:
          *double v88 = v89;
        }
        uint64_t v83 = (char *)(v87 + 1);
        v86 += 8;
      }
      while (v87 + 1 != (unint64_t *)a2);
    }
  }
  else if (!v85)
  {
    do
    {
      unint64_t v96 = *v11;
      unint64_t v95 = v11[1];
      unsigned __int8 v11 = (unint64_t *)v83;
      if (v95 < v96)
      {
        do
        {
          *(void *)uint64_t v83 = v96;
          unint64_t v96 = *((void *)v83 - 2);
          v83 -= 8;
        }
        while (v95 < v96);
        *(void *)uint64_t v83 = v95;
      }
      uint64_t v83 = (char *)(v11 + 1);
    }
    while (v11 + 1 != (unint64_t *)a2);
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **>(unint64_t *a1, unint64_t *a2)
{
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return 1;
    case 2:
      unint64_t v9 = *(a2 - 1);
      unint64_t v10 = *a1;
      if (v9 >= *a1) {
        return 1;
      }
      *a1 = v9;
      *(a2 - 1) = v10;
      return 1;
    case 3:
      unint64_t v11 = *a1;
      unint64_t v12 = a1[1];
      unint64_t v13 = *(a2 - 1);
      if (v12 >= *a1)
      {
        if (v13 >= v12) {
          return 1;
        }
        a1[1] = v13;
        *(a2 - 1) = v12;
        unint64_t v30 = *a1;
        unint64_t v29 = a1[1];
        if (v29 >= *a1) {
          return 1;
        }
        *a1 = v29;
        a1[1] = v30;
        return 1;
      }
      else if (v13 >= v12)
      {
        *a1 = v12;
        a1[1] = v11;
        unint64_t v35 = *(a2 - 1);
        if (v35 >= v11) {
          return 1;
        }
        a1[1] = v35;
        *(a2 - 1) = v11;
        return 1;
      }
      else
      {
        *a1 = v13;
        *(a2 - 1) = v11;
        return 1;
      }
    case 4:
      unint64_t v14 = a1 + 1;
      unint64_t v15 = a1[1];
      unint64_t v16 = a1 + 2;
      unint64_t v17 = a1[2];
      unint64_t v18 = *a1;
      if (v15 < *a1)
      {
        unint64_t v19 = a1;
        unint64_t v20 = a1 + 2;
        unint64_t v21 = *a1;
        if (v17 >= v15)
        {
          *a1 = v15;
          a1[1] = v18;
          unint64_t v19 = a1 + 1;
          unint64_t v20 = a1 + 2;
          unint64_t v21 = v18;
          if (v17 >= v18) {
            goto LABEL_38;
          }
        }
LABEL_35:
        unint64_t *v19 = v17;
        unint64_t *v20 = v18;
        unint64_t v15 = v21;
LABEL_36:
        unint64_t v31 = *(a2 - 1);
        if (v31 >= v15) {
          return 1;
        }
        goto LABEL_39;
      }
      if (v17 < v15)
      {
        unint64_t *v14 = v17;
        unint64_t *v16 = v15;
        unint64_t v19 = a1;
        unint64_t v20 = a1 + 1;
        unint64_t v21 = v15;
        if (v17 >= v18) {
          goto LABEL_36;
        }
        goto LABEL_35;
      }
LABEL_38:
      unint64_t v15 = v17;
      unint64_t v31 = *(a2 - 1);
      if (v31 >= v15) {
        return 1;
      }
LABEL_39:
      unint64_t *v16 = v31;
      *(a2 - 1) = v15;
      unint64_t v32 = *v16;
      unint64_t v33 = *v14;
      if (v32 >= v33) {
        return 1;
      }
      a1[1] = v32;
      a1[2] = v33;
      unint64_t v34 = *a1;
      if (v32 >= *a1) {
        return 1;
      }
      *a1 = v32;
      a1[1] = v34;
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      int v4 = a1 + 2;
      unint64_t v3 = a1[2];
      unint64_t v5 = a1[1];
      unint64_t v6 = *a1;
      if (v5 >= *a1)
      {
        if (v3 >= v5) {
          goto LABEL_20;
        }
        a1[1] = v3;
        *int v4 = v5;
        uint64_t v7 = a1;
        unint64_t v8 = a1 + 1;
      }
      else
      {
        uint64_t v7 = a1;
        unint64_t v8 = a1 + 2;
        if (v3 < v5) {
          goto LABEL_19;
        }
        *a1 = v5;
        a1[1] = v6;
        uint64_t v7 = a1 + 1;
        unint64_t v8 = a1 + 2;
      }
      if (v3 >= v6) {
        goto LABEL_20;
      }
LABEL_19:
      *uint64_t v7 = v3;
      *unint64_t v8 = v6;
LABEL_20:
      unint64_t v22 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v23 = 0;
      for (uint64_t i = 24; ; i += 8)
      {
        unint64_t v25 = *v22;
        unint64_t v26 = *v4;
        if (*v22 < v26) {
          break;
        }
LABEL_23:
        int v4 = v22++;
        if (v22 == a2) {
          return 1;
        }
      }
      uint64_t v27 = i;
      do
      {
        *(unint64_t *)((char *)a1 + v27) = v26;
        uint64_t v28 = v27 - 8;
        if (v27 == 8)
        {
          *a1 = v25;
          if (++v23 != 8) {
            goto LABEL_23;
          }
          return v22 + 1 == a2;
        }
        unint64_t v26 = *(unint64_t *)((char *)a1 + v27 - 16);
        v27 -= 8;
      }
      while (v25 < v26);
      *(unint64_t *)((char *)a1 + v28) = v25;
      if (++v23 != 8) {
        goto LABEL_23;
      }
      return v22 + 1 == a2;
  }
}

unint64_t *std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **>(unint64_t *result, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t v5 = *a2;
  unint64_t v6 = *result;
  unint64_t v7 = *a3;
  if (*a2 >= *result)
  {
    if (v7 >= v5)
    {
      unint64_t v5 = *a3;
      unint64_t v9 = *a4;
      if (*a4 >= v7) {
        goto LABEL_17;
      }
      goto LABEL_14;
    }
    *a2 = v7;
    *a3 = v5;
    unint64_t v8 = *result;
    if (*a2 < *result)
    {
      *uint64_t result = *a2;
      *a2 = v8;
      unint64_t v5 = *a3;
      unint64_t v9 = *a4;
      if (*a4 >= *a3) {
        goto LABEL_17;
      }
      goto LABEL_14;
    }
  }
  else
  {
    if (v7 >= v5)
    {
      *uint64_t result = v5;
      *a2 = v6;
      unint64_t v5 = *a3;
      if (*a3 >= v6) {
        goto LABEL_11;
      }
      *a2 = v5;
    }
    else
    {
      *uint64_t result = v7;
    }
    *a3 = v6;
    unint64_t v5 = v6;
  }
LABEL_11:
  unint64_t v9 = *a4;
  if (*a4 >= v5) {
    goto LABEL_17;
  }
LABEL_14:
  *a3 = v9;
  *a4 = v5;
  unint64_t v10 = *a2;
  if (*a3 < *a2)
  {
    *a2 = *a3;
    *a3 = v10;
    unint64_t v11 = *result;
    if (*a2 < *result)
    {
      *uint64_t result = *a2;
      *a2 = v11;
    }
  }
LABEL_17:
  unint64_t v12 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v12;
    unint64_t v13 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v13;
      unint64_t v14 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v14;
        unint64_t v15 = *result;
        if (*a2 < *result)
        {
          *uint64_t result = *a2;
          *a2 = v15;
        }
      }
    }
  }
  return result;
}

char *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,HGBitmap **,HGBitmap **>(char *a1, char *a2, char *a3)
{
  if (a1 == a2) {
    return a3;
  }
  uint64_t v3 = a2 - a1;
  uint64_t v4 = (a2 - a1) >> 3;
  if (a2 - a1 >= 9 && (unint64_t)v3 >= 0x10)
  {
    int64_t v33 = (unint64_t)(v4 - 2) >> 1;
    int64_t v34 = v33;
    do
    {
      if (v33 >= v34)
      {
        uint64_t v35 = (2 * v34) | 1;
        uint64_t v36 = &a1[8 * v35];
        if (2 * v34 + 2 >= v4)
        {
          unint64_t v37 = *(void *)v36;
          unint64_t v39 = &a1[8 * v34];
          unint64_t v40 = *(void *)v39;
          if (*(void *)v36 >= *(void *)v39) {
            goto LABEL_71;
          }
        }
        else
        {
          unint64_t v37 = *((void *)v36 + 1);
          BOOL v38 = *(void *)v36 >= v37;
          if (*(void *)v36 < v37) {
            v36 += 8;
          }
          else {
            unint64_t v37 = *(void *)v36;
          }
          if (!v38) {
            uint64_t v35 = 2 * v34 + 2;
          }
          unint64_t v39 = &a1[8 * v34];
          unint64_t v40 = *(void *)v39;
          if (v37 >= *(void *)v39)
          {
LABEL_71:
            while (1)
            {
              *(void *)unint64_t v39 = v37;
              unint64_t v39 = v36;
              if (v33 < v35) {
                break;
              }
              uint64_t v41 = (2 * v35) | 1;
              uint64_t v36 = &a1[8 * v41];
              uint64_t v35 = 2 * v35 + 2;
              if (v35 < v4)
              {
                unint64_t v37 = *(void *)v36;
                if (*(void *)v36 >= *((void *)v36 + 1))
                {
                  uint64_t v35 = v41;
                }
                else
                {
                  unint64_t v37 = *((void *)v36 + 1);
                  v36 += 8;
                }
                if (v37 < v40) {
                  break;
                }
              }
              else
              {
                unint64_t v37 = *(void *)v36;
                uint64_t v35 = v41;
                if (*(void *)v36 < v40) {
                  break;
                }
              }
            }
            *(void *)unint64_t v39 = v40;
          }
        }
      }
      BOOL v19 = v34-- <= 0;
    }
    while (!v19);
  }
  unint64_t v5 = a2;
  if (a2 != a3)
  {
    if (v3 < 16)
    {
      unint64_t v6 = *(void *)a1;
      unint64_t v7 = a2;
      do
      {
        unint64_t v8 = *(void *)v7;
        if (*(void *)v7 < v6)
        {
          *(void *)unint64_t v7 = v6;
          *(void *)a1 = v8;
          unint64_t v6 = v8;
        }
        v7 += 8;
      }
      while (v7 != a3);
LABEL_33:
      unint64_t v5 = a3;
      goto LABEL_34;
    }
    unint64_t v9 = (unint64_t *)(a1 + 16);
    unint64_t v10 = a2;
    while (1)
    {
      unint64_t v11 = *(void *)v10;
      if (*(void *)v10 < *(void *)a1)
      {
        *(void *)unint64_t v10 = *(void *)a1;
        *(void *)a1 = v11;
        unint64_t v12 = *((void *)a1 + 1);
        if (v3 == 16)
        {
          unint64_t v13 = a1 + 8;
          uint64_t v14 = 1;
          if (v12 >= v11) {
            goto LABEL_24;
          }
        }
        else
        {
          BOOL v15 = v12 >= *v9;
          if (v12 >= *v9)
          {
            unint64_t v13 = a1 + 8;
          }
          else
          {
            unint64_t v12 = *v9;
            unint64_t v13 = a1 + 16;
          }
          if (v15) {
            uint64_t v14 = 1;
          }
          else {
            uint64_t v14 = 2;
          }
          if (v12 >= v11)
          {
LABEL_24:
            unint64_t v16 = a1;
            while (1)
            {
              *(void *)unint64_t v16 = v12;
              unint64_t v16 = v13;
              if ((uint64_t)((unint64_t)(v4 - 2) >> 1) < v14) {
                break;
              }
              uint64_t v17 = (2 * v14) | 1;
              unint64_t v13 = &a1[8 * v17];
              uint64_t v14 = 2 * v14 + 2;
              if (v14 < v4)
              {
                unint64_t v12 = *(void *)v13;
                if (*(void *)v13 >= *((void *)v13 + 1))
                {
                  uint64_t v14 = v17;
                }
                else
                {
                  unint64_t v12 = *((void *)v13 + 1);
                  v13 += 8;
                }
                if (v12 < v11) {
                  break;
                }
              }
              else
              {
                unint64_t v12 = *(void *)v13;
                uint64_t v14 = v17;
                if (*(void *)v13 < v11) {
                  break;
                }
              }
            }
            *(void *)unint64_t v16 = v11;
          }
        }
      }
      v10 += 8;
      if (v10 == a3) {
        goto LABEL_33;
      }
    }
  }
LABEL_34:
  if (v3 >= 9)
  {
    uint64_t v18 = (unint64_t)v3 >> 3;
    do
    {
      uint64_t v20 = 0;
      unint64_t v21 = *(void *)a1;
      int64_t v22 = (unint64_t)(v18 - 2) >> 1;
      int v23 = a1;
      do
      {
        while (1)
        {
          unint64_t v25 = &v23[8 * v20 + 8];
          uint64_t v26 = (2 * v20) | 1;
          uint64_t v20 = 2 * v20 + 2;
          if (v20 < v18) {
            break;
          }
          uint64_t v20 = v26;
          *(void *)int v23 = *(void *)v25;
          int v23 = v25;
          if (v26 > v22) {
            goto LABEL_45;
          }
        }
        uint64_t v24 = *(void *)v25;
        if (*(void *)v25 >= *((void *)v25 + 1))
        {
          uint64_t v20 = v26;
        }
        else
        {
          uint64_t v24 = *((void *)v25 + 1);
          v25 += 8;
        }
        *(void *)int v23 = v24;
        int v23 = v25;
      }
      while (v20 <= v22);
LABEL_45:
      a2 -= 8;
      if (v25 == a2)
      {
        *(void *)unint64_t v25 = v21;
      }
      else
      {
        *(void *)unint64_t v25 = *(void *)a2;
        *(void *)a2 = v21;
        uint64_t v27 = v25 - a1 + 8;
        if (v27 >= 9)
        {
          unint64_t v28 = (((unint64_t)v27 >> 3) - 2) >> 1;
          unint64_t v29 = &a1[8 * v28];
          uint64_t v30 = *(void *)v29;
          unint64_t v31 = *(void *)v25;
          if (*(void *)v29 < *(void *)v25)
          {
            do
            {
              *(void *)unint64_t v25 = v30;
              unint64_t v25 = v29;
              if (!v28) {
                break;
              }
              unint64_t v28 = (v28 - 1) >> 1;
              unint64_t v29 = &a1[8 * v28];
              uint64_t v30 = *(void *)v29;
            }
            while (*(void *)v29 < v31);
            *(void *)unint64_t v25 = v31;
          }
        }
      }
      BOOL v19 = v18-- <= 2;
    }
    while (!v19);
  }
  return v5;
}

void HGGPURenderer::ProcessOnePageBegin(HGNode *)::RenderBufferedTilesVisitor::visitNodePre(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  a3[60] = a3[59];
  a3[4] &= ~0x10u;
}

void HGGPURenderer::ProcessOnePageBegin(HGNode *)::RenderBufferedTilesVisitor::visitNodePost(uint64_t a1, HGRenderer *a2, uint64_t *a3)
{
  if (a3[24]) {
    return;
  }
  (*(void (**)(HGRenderer *, uint64_t *, uint64_t))(*(void *)a2 + 320))(a2, a3, 1);
  if (!HGRectIsNull(*(uint64_t *)((char *)a3 + 220), *(uint64_t *)((char *)a3 + 228)))
  {
    int v5 = *((_DWORD *)a2 + 154);
    if (v5 == 1 || v5 != 2 && *((int *)a3 + 59) > 1)
    {
      unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
      if (v6)
      {
        uint64_t v7 = (*(uint64_t (**)(uint64_t *))(*a3 + 48))(a3);
        HGLogger::log((HGLogger *)"nbfo", (const char *)1, (HGLogger *)"will buffer sub-tile of node %s (%p)\n", v8, v9, v7, a3);
      }
      (*(void (**)(uint64_t *, HGRenderer *))(*a3 + 432))(a3, a2);
      uint64_t v10 = *(uint64_t *)((char *)a3 + 220);
      uint64_t v11 = *(uint64_t *)((char *)a3 + 228);
      unint64_t v12 = (HGBitmap *)a3[24];
      if (v12 || (unint64_t v12 = (HGBitmap *)a3[31]) != 0)
      {
        (*(void (**)(HGBitmap *))(*(void *)v12 + 16))(v12);
      }
      else
      {
        uint64_t v22 = HGRectIntersection(*(uint64_t *)((char *)a3 + 220), *(uint64_t *)((char *)a3 + 228), a3[19], a3[20]);
        uint64_t v24 = v23;
        uint64_t OutputFormat = HGRenderer::GetOutputFormat(a2, (HGNode *)a3);
        uint64_t v26 = HGGPURenderer::ProcessNodeInternal(a2, (uint64_t)a3, v22, v24, OutputFormat, 0, 0, 0, 1u);
        if (!v26)
        {
          NullGLTexture = HGGPURenderer::LoadNullGLTexture(a2);
          goto LABEL_13;
        }
        unint64_t v12 = (HGBitmap *)v26;
      }
      uint64_t v13 = HGRectIntersection(v10, v11, a3[19], a3[20]);
      uint64_t v15 = v14;
      *(void *)&v29.signed int var0 = v13;
      *(void *)&v29.int var2 = v15;
      NullGLTexture = (unsigned int *)HGGPURenderer::ConvertToGLTexture(a2, v29, v12);
      (*(void (**)(HGBitmap *))(*(void *)v12 + 24))(v12);
LABEL_13:
      a3[31] = (uint64_t)NullGLTexture;
      (*(void (**)(HGRenderer *, void))(*(void *)a2 + 144))(a2, 0);
    }
  }
  int v17 = *((_DWORD *)a3 + 22);
  if (v17 >= 1)
  {
    for (uint64_t i = 0; i < v17; ++i)
    {
      uint64_t v19 = *(void *)(a3[10] + 8 * i);
      if (v19)
      {
        uint64_t v20 = *(void *)(v19 + 16);
        if (v20)
        {
          if (a3[31])
          {
            uint64_t v21 = *(void *)(v20 + 144);
            unint64_t v28 = &unk_1F10D47F8;
            HGTraversal::RecursiveTraversal<(HGTraversal::NodeInput)1,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v27, a2, v21, (uint64_t *)&v28);
            int v17 = *((_DWORD *)a3 + 22);
          }
        }
      }
    }
  }
}

BOOL HGGPURenderer::ProcessOnePageBegin(HGNode *)::RenderBufferedTilesVisitor::willVisitNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_DWORD *)(a3 + 240) == 0;
}

BOOL HGGPURenderer::ProcessOnePageBegin(HGNode *)::RenderBufferedTilesVisitor::willVisitChildren(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(void *)(a3 + 192) == 0;
}

uint64_t HGGPURenderer::ProcessOnePageEnd(HGNode *)::ReleaseBufferedTilesVisitor::visitNodePost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = *(void *)(a3 + 248);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    *(void *)(a3 + 248) = 0;
  }
  return result;
}

void HGGPURenderer::ProcessOnePageEnd(HGNode *)::ReleaseBufferedTilesVisitor::discoverNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

BOOL HGGPURenderer::ProcessOnePageEnd(HGNode *)::ReleaseBufferedTilesVisitor::willVisitNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return !*(_DWORD *)(a3 + 240) && *(void *)(a3 + 192) == 0;
}

BOOL HGGPURenderer::ProcessOnePageEnd(HGNode *)::ReleaseBufferedTilesVisitor::willVisitChild(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 80) + 8 * a4);
  return v4 && *(void *)(v4 + 16) && *(void *)(a3 + 248) == 0;
}

uint64_t *std::list<FBOStrategy::FBOCacheEntry>::~list(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v3 = *a1;
    int v2 = (uint64_t *)a1[1];
    uint64_t v4 = *v2;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        int v5 = (uint64_t *)v2[1];
        operator delete(v2);
        int v2 = v5;
      }
      while (v5 != a1);
    }
  }
  return a1;
}

void *std::__call_once_proxy[abi:ne180100]<std::tuple<HGFormatUtils::adjustPrecision(unsigned int,unsigned int)::$_0 &&>>()
{
  uint64_t v144 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = _MergedGlobals_10;
  int v2 = (uint64_t **)(_MergedGlobals_10 + 8);
  uint64_t v1 = *(unsigned int **)(_MergedGlobals_10 + 8);
  if (v1)
  {
    uint64_t v3 = *(unsigned int **)(_MergedGlobals_10 + 8);
    while (1)
    {
      while (1)
      {
        uint64_t v4 = v3;
        unsigned int v5 = v3[7];
        if (v5 < 2) {
          break;
        }
        uint64_t v3 = (unsigned int *)*v4;
        int v2 = (uint64_t **)v4;
        if (!*v4) {
          goto LABEL_9;
        }
      }
      if (v5) {
        break;
      }
      uint64_t v3 = (unsigned int *)v4[1];
      if (!v3)
      {
        int v2 = (uint64_t **)(v4 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v4 = (void *)(_MergedGlobals_10 + 8);
LABEL_9:
    unsigned __int8 v6 = v4;
    uint64_t v4 = operator new(0x28uLL);
    *(void *)((char *)v4 + 28) = 1;
    *uint64_t v4 = 0;
    v4[1] = 0;
    v4[2] = v6;
    uint64_t *v2 = v4;
    uint64_t v7 = **(void **)v0;
    unint64_t v8 = v4;
    if (v7)
    {
      *(void *)uint64_t v0 = v7;
      unint64_t v8 = *v2;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v0 + 8), v8);
    ++*(void *)(v0 + 16);
    uint64_t v0 = _MergedGlobals_10;
    uint64_t v1 = *(unsigned int **)(_MergedGlobals_10 + 8);
  }
  *((_DWORD *)v4 + 8) = 0;
  if (v1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v10 = v1;
        unsigned int v11 = v1[7];
        if (v11 < 3) {
          break;
        }
        uint64_t v1 = (unsigned int *)*v10;
        unint64_t v9 = (uint64_t **)v10;
        if (!*v10) {
          goto LABEL_19;
        }
      }
      if (v11 == 2) {
        break;
      }
      uint64_t v1 = (unsigned int *)v10[1];
      if (!v1)
      {
        unint64_t v9 = (uint64_t **)(v10 + 1);
        goto LABEL_19;
      }
    }
  }
  else
  {
    unint64_t v9 = (uint64_t **)(v0 + 8);
    uint64_t v10 = (void *)(v0 + 8);
LABEL_19:
    unint64_t v12 = v10;
    uint64_t v10 = operator new(0x28uLL);
    *(void *)((char *)v10 + 28) = 2;
    void *v10 = 0;
    v10[1] = 0;
    unsigned int v10[2] = v12;
    *unint64_t v9 = v10;
    uint64_t v13 = **(void **)v0;
    uint64_t v14 = v10;
    if (v13)
    {
      *(void *)uint64_t v0 = v13;
      uint64_t v14 = *v9;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v0 + 8), v14);
    ++*(void *)(v0 + 16);
    uint64_t v0 = _MergedGlobals_10;
  }
  *((_DWORD *)v10 + 8) = 1;
  unint64_t v16 = (uint64_t **)(v0 + 8);
  uint64_t v15 = *(unsigned int **)(v0 + 8);
  if (v15)
  {
    int v17 = *(unsigned int **)(v0 + 8);
    while (1)
    {
      while (1)
      {
        uint64_t v18 = v17;
        unsigned int v19 = v17[7];
        if (v19 < 5) {
          break;
        }
        int v17 = (unsigned int *)*v18;
        unint64_t v16 = (uint64_t **)v18;
        if (!*v18) {
          goto LABEL_30;
        }
      }
      if (v19 == 4) {
        break;
      }
      int v17 = (unsigned int *)v18[1];
      if (!v17)
      {
        unint64_t v16 = (uint64_t **)(v18 + 1);
        goto LABEL_30;
      }
    }
  }
  else
  {
    uint64_t v18 = (void *)(v0 + 8);
LABEL_30:
    uint64_t v20 = v18;
    uint64_t v18 = operator new(0x28uLL);
    *(void *)((char *)v18 + 28) = 4;
    void *v18 = 0;
    v18[1] = 0;
    v18[2] = v20;
    char *v16 = v18;
    uint64_t v21 = **(void **)v0;
    uint64_t v22 = v18;
    if (v21)
    {
      *(void *)uint64_t v0 = v21;
      uint64_t v22 = *v16;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v0 + 8), v22);
    ++*(void *)(v0 + 16);
    uint64_t v0 = _MergedGlobals_10;
    uint64_t v15 = *(unsigned int **)(_MergedGlobals_10 + 8);
  }
  *((_DWORD *)v18 + 8) = 2;
  if (v15)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v24 = v15;
        unsigned int v25 = v15[7];
        if (v25 < 9) {
          break;
        }
        uint64_t v15 = (unsigned int *)*v24;
        uint64_t v23 = (uint64_t **)v24;
        if (!*v24) {
          goto LABEL_40;
        }
      }
      if (v25 == 8) {
        break;
      }
      uint64_t v15 = (unsigned int *)v24[1];
      if (!v15)
      {
        uint64_t v23 = (uint64_t **)(v24 + 1);
        goto LABEL_40;
      }
    }
  }
  else
  {
    uint64_t v23 = (uint64_t **)(v0 + 8);
    uint64_t v24 = (void *)(v0 + 8);
LABEL_40:
    uint64_t v26 = v24;
    uint64_t v24 = operator new(0x28uLL);
    *(void *)((char *)v24 + 28) = 8;
    *uint64_t v24 = 0;
    v24[1] = 0;
    v24[2] = v26;
    *uint64_t v23 = v24;
    uint64_t v27 = **(void **)v0;
    unint64_t v28 = v24;
    if (v27)
    {
      *(void *)uint64_t v0 = v27;
      unint64_t v28 = *v23;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v0 + 8), v28);
    ++*(void *)(v0 + 16);
  }
  *((_DWORD *)v24 + 8) = 3;
  long long v142 = xmmword_1B83431D0;
  uint64_t v29 = qword_1EB9A1FA0;
  unint64_t v31 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  uint64_t v30 = *(unsigned int **)(qword_1EB9A1FA0 + 8);
  if (v30)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v32 = v30;
        unsigned int v33 = v30[8];
        if (v33 < 8) {
          break;
        }
        uint64_t v30 = (unsigned int *)*v32;
        unint64_t v31 = (uint64_t **)v32;
        if (!*v32) {
          goto LABEL_50;
        }
      }
      if (v33 == 7) {
        break;
      }
      uint64_t v30 = (unsigned int *)v32[1];
      if (!v30)
      {
        unint64_t v31 = (uint64_t **)(v32 + 1);
        goto LABEL_50;
      }
    }
  }
  else
  {
    unint64_t v32 = (void *)(qword_1EB9A1FA0 + 8);
LABEL_50:
    int64_t v34 = v32;
    unint64_t v32 = operator new(0x40uLL);
    *((_DWORD *)v32 + 8) = 7;
    v32[6] = 0;
    v32[7] = 0;
    v32[5] = 0;
    *unint64_t v32 = 0;
    v32[1] = 0;
    v32[2] = v34;
    *unint64_t v31 = v32;
    uint64_t v35 = **(void **)v29;
    uint64_t v36 = v32;
    if (v35)
    {
      *(void *)uint64_t v29 = v35;
      uint64_t v36 = *v31;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v29 + 8), v36);
    ++*(void *)(v29 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>(v32 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B83431E0;
  uint64_t v37 = qword_1EB9A1FA0;
  unint64_t v39 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  BOOL v38 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v38)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v40 = (uint64_t **)v38;
        unsigned int v41 = *((_DWORD *)v38 + 8);
        if (v41 < 0xC) {
          break;
        }
        BOOL v38 = *v40;
        unint64_t v39 = v40;
        if (!*v40) {
          goto LABEL_60;
        }
      }
      if (v41 == 11) {
        break;
      }
      BOOL v38 = v40[1];
      if (!v38)
      {
        unint64_t v39 = v40 + 1;
        goto LABEL_60;
      }
    }
    unint64_t v42 = v40;
  }
  else
  {
    unint64_t v40 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_60:
    unint64_t v42 = operator new(0x40uLL);
    v42[8] = 11;
    *((void *)v42 + 6) = 0;
    *((void *)v42 + 7) = 0;
    *((void *)v42 + 5) = 0;
    *(void *)unint64_t v42 = 0;
    *((void *)v42 + 1) = 0;
    *((void *)v42 + 2) = v40;
    char *v39 = (uint64_t *)v42;
    uint64_t v43 = **(void **)v37;
    unint64_t v44 = (uint64_t *)v42;
    if (v43)
    {
      *(void *)uint64_t v37 = v43;
      unint64_t v44 = *v39;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v37 + 8), v44);
    ++*(void *)(v37 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v42 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B83431F0;
  uint64_t v45 = qword_1EB9A1FA0;
  unint64_t v47 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  unint64_t v46 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v46)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v48 = (uint64_t **)v46;
        unsigned int v49 = *((_DWORD *)v46 + 8);
        if (v49 < 4) {
          break;
        }
        unint64_t v46 = *v48;
        unint64_t v47 = v48;
        if (!*v48) {
          goto LABEL_71;
        }
      }
      if (v49 == 3) {
        break;
      }
      unint64_t v46 = v48[1];
      if (!v46)
      {
        unint64_t v47 = v48 + 1;
        goto LABEL_71;
      }
    }
    std::string::size_type v50 = v48;
  }
  else
  {
    uint64_t v48 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_71:
    std::string::size_type v50 = operator new(0x40uLL);
    v50[8] = 3;
    *((void *)v50 + 6) = 0;
    *((void *)v50 + 7) = 0;
    *((void *)v50 + 5) = 0;
    *(void *)std::string::size_type v50 = 0;
    *((void *)v50 + 1) = 0;
    *((void *)v50 + 2) = v48;
    *unint64_t v47 = (uint64_t *)v50;
    uint64_t v51 = **(void **)v45;
    unint64_t v52 = (uint64_t *)v50;
    if (v51)
    {
      *(void *)uint64_t v45 = v51;
      unint64_t v52 = *v47;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v45 + 8), v52);
    ++*(void *)(v45 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v50 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B8343200;
  uint64_t v53 = qword_1EB9A1FA0;
  unsigned int v55 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  unint64_t v54 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v54)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v56 = (uint64_t **)v54;
        unsigned int v57 = *((_DWORD *)v54 + 8);
        if (v57 < 0xE) {
          break;
        }
        unint64_t v54 = *v56;
        unsigned int v55 = v56;
        if (!*v56) {
          goto LABEL_82;
        }
      }
      if (v57 == 13) {
        break;
      }
      unint64_t v54 = v56[1];
      if (!v54)
      {
        unsigned int v55 = v56 + 1;
        goto LABEL_82;
      }
    }
    unint64_t v58 = v56;
  }
  else
  {
    unsigned int v56 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_82:
    unint64_t v58 = operator new(0x40uLL);
    v58[8] = 13;
    *((void *)v58 + 6) = 0;
    *((void *)v58 + 7) = 0;
    *((void *)v58 + 5) = 0;
    *(void *)unint64_t v58 = 0;
    *((void *)v58 + 1) = 0;
    *((void *)v58 + 2) = v56;
    *unsigned int v55 = (uint64_t *)v58;
    uint64_t v59 = **(void **)v53;
    BOOL v60 = (uint64_t *)v58;
    if (v59)
    {
      *(void *)uint64_t v53 = v59;
      BOOL v60 = *v55;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v53 + 8), v60);
    ++*(void *)(v53 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v58 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B8343210;
  uint64_t v61 = qword_1EB9A1FA0;
  std::string::size_type v63 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  unint64_t v62 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v62)
  {
    while (1)
    {
      while (1)
      {
        long long v64 = (uint64_t **)v62;
        unsigned int v65 = *((_DWORD *)v62 + 8);
        if (v65 < 6) {
          break;
        }
        unint64_t v62 = *v64;
        std::string::size_type v63 = v64;
        if (!*v64) {
          goto LABEL_93;
        }
      }
      if (v65 == 5) {
        break;
      }
      unint64_t v62 = v64[1];
      if (!v62)
      {
        std::string::size_type v63 = v64 + 1;
        goto LABEL_93;
      }
    }
    unint64_t v66 = v64;
  }
  else
  {
    long long v64 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_93:
    unint64_t v66 = operator new(0x40uLL);
    v66[8] = 5;
    *((void *)v66 + 6) = 0;
    *((void *)v66 + 7) = 0;
    *((void *)v66 + 5) = 0;
    *(void *)unint64_t v66 = 0;
    *((void *)v66 + 1) = 0;
    *((void *)v66 + 2) = v64;
    *std::string::size_type v63 = (uint64_t *)v66;
    uint64_t v67 = **(void **)v61;
    unint64_t v68 = (uint64_t *)v66;
    if (v67)
    {
      *(void *)uint64_t v61 = v67;
      unint64_t v68 = *v63;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v61 + 8), v68);
    ++*(void *)(v61 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v66 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B8343220;
  uint64_t v69 = qword_1EB9A1FA0;
  unint64_t v71 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  double v70 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v70)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v72 = (uint64_t **)v70;
        unsigned int v73 = *((_DWORD *)v70 + 8);
        if (v73 < 0xA) {
          break;
        }
        double v70 = *v72;
        unint64_t v71 = v72;
        if (!*v72) {
          goto LABEL_104;
        }
      }
      if (v73 == 9) {
        break;
      }
      double v70 = v72[1];
      if (!v70)
      {
        unint64_t v71 = v72 + 1;
        goto LABEL_104;
      }
    }
    unint64_t v74 = v72;
  }
  else
  {
    unint64_t v72 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_104:
    unint64_t v74 = operator new(0x40uLL);
    v74[8] = 9;
    *((void *)v74 + 6) = 0;
    *((void *)v74 + 7) = 0;
    *((void *)v74 + 5) = 0;
    *(void *)unint64_t v74 = 0;
    *((void *)v74 + 1) = 0;
    *((void *)v74 + 2) = v72;
    *unint64_t v71 = (uint64_t *)v74;
    uint64_t v75 = **(void **)v69;
    char v76 = (uint64_t *)v74;
    if (v75)
    {
      *(void *)uint64_t v69 = v75;
      char v76 = *v71;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v69 + 8), v76);
    ++*(void *)(v69 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v74 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B8343230;
  uint64_t v77 = qword_1EB9A1FA0;
  unint64_t v79 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  double v78 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v78)
  {
    while (1)
    {
      while (1)
      {
        uint32x4_t v80 = (uint64_t **)v78;
        unsigned int v81 = *((_DWORD *)v78 + 8);
        if (v81 < 2) {
          break;
        }
        double v78 = *v80;
        unint64_t v79 = v80;
        if (!*v80) {
          goto LABEL_115;
        }
      }
      if (v81) {
        break;
      }
      double v78 = v80[1];
      if (!v78)
      {
        unint64_t v79 = v80 + 1;
        goto LABEL_115;
      }
    }
    string_t v82 = v80;
  }
  else
  {
    uint32x4_t v80 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_115:
    string_t v82 = operator new(0x40uLL);
    v82[8] = 1;
    *((void *)v82 + 6) = 0;
    *((void *)v82 + 7) = 0;
    *((void *)v82 + 5) = 0;
    *(void *)string_t v82 = 0;
    *((void *)v82 + 1) = 0;
    *((void *)v82 + 2) = v80;
    *unint64_t v79 = (uint64_t *)v82;
    uint64_t v83 = **(void **)v77;
    float v84 = (uint64_t *)v82;
    if (v83)
    {
      *(void *)uint64_t v77 = v83;
      float v84 = *v79;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v77 + 8), v84);
    ++*(void *)(v77 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v82 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B8343240;
  uint64_t v85 = qword_1EB9A1FA0;
  double v87 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  uint64_t v86 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v86)
  {
    while (1)
    {
      while (1)
      {
        double v88 = (uint64_t **)v86;
        unsigned int v89 = *((_DWORD *)v86 + 8);
        if (v89 < 0xF) {
          break;
        }
        uint64_t v86 = *v88;
        double v87 = v88;
        if (!*v88) {
          goto LABEL_126;
        }
      }
      if (v89 == 14) {
        break;
      }
      uint64_t v86 = v88[1];
      if (!v86)
      {
        double v87 = v88 + 1;
        goto LABEL_126;
      }
    }
    unint64_t v90 = v88;
  }
  else
  {
    double v88 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_126:
    unint64_t v90 = operator new(0x40uLL);
    v90[8] = 14;
    *((void *)v90 + 6) = 0;
    *((void *)v90 + 7) = 0;
    *((void *)v90 + 5) = 0;
    *(void *)unint64_t v90 = 0;
    *((void *)v90 + 1) = 0;
    *((void *)v90 + 2) = v88;
    *double v87 = (uint64_t *)v90;
    uint64_t v91 = **(void **)v85;
    unint64_t v92 = (uint64_t *)v90;
    if (v91)
    {
      *(void *)uint64_t v85 = v91;
      unint64_t v92 = *v87;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v85 + 8), v92);
    ++*(void *)(v85 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v90 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B8343250;
  uint64_t v93 = qword_1EB9A1FA0;
  unint64_t v95 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  unint64_t v94 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v94)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v96 = (uint64_t **)v94;
        unsigned int v97 = *((_DWORD *)v94 + 8);
        if (v97 < 7) {
          break;
        }
        unint64_t v94 = *v96;
        unint64_t v95 = v96;
        if (!*v96) {
          goto LABEL_137;
        }
      }
      if (v97 == 6) {
        break;
      }
      unint64_t v94 = v96[1];
      if (!v94)
      {
        unint64_t v95 = v96 + 1;
        goto LABEL_137;
      }
    }
    unint64_t v98 = v96;
  }
  else
  {
    unint64_t v96 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_137:
    unint64_t v98 = operator new(0x40uLL);
    v98[8] = 6;
    *((void *)v98 + 6) = 0;
    *((void *)v98 + 7) = 0;
    *((void *)v98 + 5) = 0;
    *(void *)unint64_t v98 = 0;
    *((void *)v98 + 1) = 0;
    *((void *)v98 + 2) = v96;
    *unint64_t v95 = (uint64_t *)v98;
    uint64_t v99 = **(void **)v93;
    unint64_t v100 = (uint64_t *)v98;
    if (v99)
    {
      *(void *)uint64_t v93 = v99;
      unint64_t v100 = *v95;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v93 + 8), v100);
    ++*(void *)(v93 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v98 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B8343260;
  uint64_t v101 = qword_1EB9A1FA0;
  unsigned __int8 v103 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  uint64_t v102 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v102)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v104 = (uint64_t **)v102;
        unsigned int v105 = *((_DWORD *)v102 + 8);
        if (v105 < 0xB) {
          break;
        }
        uint64_t v102 = *v104;
        unsigned __int8 v103 = v104;
        if (!*v104) {
          goto LABEL_148;
        }
      }
      if (v105 == 10) {
        break;
      }
      uint64_t v102 = v104[1];
      if (!v102)
      {
        unsigned __int8 v103 = v104 + 1;
        goto LABEL_148;
      }
    }
    uint64_t v106 = v104;
  }
  else
  {
    uint64_t v104 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_148:
    uint64_t v106 = operator new(0x40uLL);
    v106[8] = 10;
    *((void *)v106 + 6) = 0;
    *((void *)v106 + 7) = 0;
    *((void *)v106 + 5) = 0;
    *(void *)uint64_t v106 = 0;
    *((void *)v106 + 1) = 0;
    *((void *)v106 + 2) = v104;
    unint64_t *v103 = (uint64_t *)v106;
    uint64_t v107 = **(void **)v101;
    unsigned __int8 v108 = (uint64_t *)v106;
    if (v107)
    {
      *(void *)uint64_t v101 = v107;
      unsigned __int8 v108 = *v103;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v101 + 8), v108);
    ++*(void *)(v101 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v106 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B8343270;
  uint64_t v109 = qword_1EB9A1FA0;
  unsigned __int8 v111 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  uint64_t v110 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v110)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v112 = (uint64_t **)v110;
        unsigned int v113 = *((_DWORD *)v110 + 8);
        if (v113 < 3) {
          break;
        }
        uint64_t v110 = *v112;
        unsigned __int8 v111 = v112;
        if (!*v112) {
          goto LABEL_159;
        }
      }
      if (v113 == 2) {
        break;
      }
      uint64_t v110 = v112[1];
      if (!v110)
      {
        unsigned __int8 v111 = v112 + 1;
        goto LABEL_159;
      }
    }
    std::string v114 = v112;
  }
  else
  {
    uint64_t v112 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_159:
    std::string v114 = operator new(0x40uLL);
    v114[8] = 2;
    *((void *)v114 + 6) = 0;
    *((void *)v114 + 7) = 0;
    *((void *)v114 + 5) = 0;
    *(void *)std::string v114 = 0;
    *((void *)v114 + 1) = 0;
    *((void *)v114 + 2) = v112;
    *unsigned __int8 v111 = (uint64_t *)v114;
    uint64_t v115 = **(void **)v109;
    std::string v116 = (uint64_t *)v114;
    if (v115)
    {
      *(void *)uint64_t v109 = v115;
      std::string v116 = *v111;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v109 + 8), v116);
    ++*(void *)(v109 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v114 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B8343280;
  uint64_t v117 = qword_1EB9A1FA0;
  unsigned int v119 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  long long v118 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v118)
  {
    while (1)
    {
      while (1)
      {
        size_t v120 = (uint64_t **)v118;
        unsigned int v121 = *((_DWORD *)v118 + 8);
        if (v121 < 0xD) {
          break;
        }
        long long v118 = *v120;
        unsigned int v119 = v120;
        if (!*v120) {
          goto LABEL_170;
        }
      }
      if (v121 == 12) {
        break;
      }
      long long v118 = v120[1];
      if (!v118)
      {
        unsigned int v119 = v120 + 1;
        goto LABEL_170;
      }
    }
    int v122 = v120;
  }
  else
  {
    size_t v120 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_170:
    int v122 = operator new(0x40uLL);
    v122[8] = 12;
    *((void *)v122 + 6) = 0;
    *((void *)v122 + 7) = 0;
    *((void *)v122 + 5) = 0;
    *(void *)int v122 = 0;
    *((void *)v122 + 1) = 0;
    *((void *)v122 + 2) = v120;
    *unsigned int v119 = (uint64_t *)v122;
    uint64_t v123 = **(void **)v117;
    unint64_t v124 = (uint64_t *)v122;
    if (v123)
    {
      *(void *)uint64_t v117 = v123;
      unint64_t v124 = *v119;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v117 + 8), v124);
    ++*(void *)(v117 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v122 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B8343290;
  uint64_t v125 = qword_1EB9A1FA0;
  uint64_t v127 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  uint64_t v126 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v126)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v128 = (uint64_t **)v126;
        unsigned int v129 = *((_DWORD *)v126 + 8);
        if (v129 < 5) {
          break;
        }
        uint64_t v126 = *v128;
        uint64_t v127 = v128;
        if (!*v128) {
          goto LABEL_181;
        }
      }
      if (v129 == 4) {
        break;
      }
      uint64_t v126 = v128[1];
      if (!v126)
      {
        uint64_t v127 = v128 + 1;
        goto LABEL_181;
      }
    }
    uint64_t v130 = v128;
  }
  else
  {
    uint64_t v128 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_181:
    uint64_t v130 = operator new(0x40uLL);
    v130[8] = 4;
    *((void *)v130 + 6) = 0;
    *((void *)v130 + 7) = 0;
    *((void *)v130 + 5) = 0;
    *(void *)uint64_t v130 = 0;
    *((void *)v130 + 1) = 0;
    *((void *)v130 + 2) = v128;
    *uint64_t v127 = (uint64_t *)v130;
    uint64_t v131 = **(void **)v125;
    HGRect v132 = (uint64_t *)v130;
    if (v131)
    {
      *(void *)uint64_t v125 = v131;
      HGRect v132 = *v127;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v125 + 8), v132);
    ++*(void *)(v125 + 16);
  }
  std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v130 + 5, (char *)&v142, v143, 4uLL);
  long long v142 = xmmword_1B83432A0;
  uint64_t v133 = qword_1EB9A1FA0;
  unint64_t v135 = (uint64_t **)(qword_1EB9A1FA0 + 8);
  uint64_t v134 = *(uint64_t **)(qword_1EB9A1FA0 + 8);
  if (v134)
  {
    while (1)
    {
      while (1)
      {
        HGRect v136 = (uint64_t **)v134;
        unsigned int v137 = *((_DWORD *)v134 + 8);
        if (v137 < 9) {
          break;
        }
        uint64_t v134 = *v136;
        unint64_t v135 = v136;
        if (!*v136) {
          goto LABEL_192;
        }
      }
      if (v137 == 8) {
        break;
      }
      uint64_t v134 = v136[1];
      if (!v134)
      {
        unint64_t v135 = v136 + 1;
        goto LABEL_192;
      }
    }
    uint64_t v138 = v136;
  }
  else
  {
    HGRect v136 = (uint64_t **)(qword_1EB9A1FA0 + 8);
LABEL_192:
    uint64_t v138 = operator new(0x40uLL);
    v138[8] = 8;
    *((void *)v138 + 6) = 0;
    *((void *)v138 + 7) = 0;
    *((void *)v138 + 5) = 0;
    *(void *)uint64_t v138 = 0;
    *((void *)v138 + 1) = 0;
    *((void *)v138 + 2) = v136;
    int8x16_t *v135 = (uint64_t *)v138;
    uint64_t v139 = **(void **)v133;
    uint64_t v140 = (uint64_t *)v138;
    if (v139)
    {
      *(void *)uint64_t v133 = v139;
      uint64_t v140 = *v135;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v133 + 8), v140);
    ++*(void *)(v133 + 16);
  }
  return std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>((void *)v138 + 5, (char *)&v142, v143, 4uLL);
}